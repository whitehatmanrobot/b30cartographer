           dwCompletionStatus,
                          TRUE );
}

//static
VOID
W3_MAIN_CONTEXT::AddressResolutionCallback(
    ADDRCHECKARG            pContext,
    BOOL                    fUnused,
    LPSTR                   pszUnused
)
/*++

Routine Description:

    Callback called when RDNS crud has done its resolution

Arguments:

    pContext - Context (in our case, pointer to W3_MAIN_CONTEXT so that
                        we can resume state machine)
    fUnused - Not used
    pszUnused - Not used

Return Value:

    None

--*/
{
    W3_MAIN_CONTEXT *           pMainContext;

    pMainContext = (W3_MAIN_CONTEXT*) pContext;
    DBG_ASSERT( pMainContext != NULL );
    DBG_ASSERT( pMainContext->CheckSignature() );

    POST_MAIN_COMPLETION( pMainContext );
}

VOID
W3_MAIN_CONTEXT::TimerCallback(LPVOID pvParam,
                             BOOLEAN fReason)
/*++

Routine Description:

    Callback called when W3_MAIN_CONTEXT has existed for too long

    OutputDebugString to tell people why we are doing this
    and DebugBreak if a debugger is attached.

    If no debugger is attached, ignore the callback.

Arguments:

    pvParam - pointer to W3_MAIN_CONTEXT that has exceeded its maximum lifetime
    fReason - not used

Return Value:

    void

--*/
{
    W3_MAIN_CONTEXT* pThis = (W3_MAIN_CONTEXT*)pvParam;
    if (IsDebuggerPresent())
    {
        OutputDebugString(L"****************\nIIS (w3core.dll) has called DebugBreak because\nHKLM\\System\\CurrentControlSet\\Services\\InetInfo\\Parameters\\RequestTimeoutBreak\nwas set.\nAnd a request has taken longer than the specified maximium time in milliseconds\n****************\n");
        DebugBreak();
    }

    return;
}


BOOL
W3_MAIN_CONTEXT::QueryDisconnect()
{
    if (QueryUrlContext() == NULL ||
        QueryUrlContext()->QueryMetaData() == NULL ||
        QueryUrlContext()->QueryMetaData()->QueryKeepAliveEnabled())
    {
        return _fDisconnect;
    }

    return TRUE;
}

//static
HRESULT
W3_MAIN_CONTEXT::SetupTraceLogging()
{
    HRESULT hr = S_OK;
    HKEY hKey = NULL;
    LONG lRet = 0;
    STACK_STRU(struFileName, MAX_PATH);
    DWORD cbSize = MAX_PATH * sizeof( WCHAR );
    DWORD dwType;
    WCHAR buffer[sizeof("0123456789")] = {0};

    lRet = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                         REGISTRY_KEY_W3SVC_PARAMETERS_W,
                         0,
                         KEY_READ,
                         &hKey); //RegOpenKeyEx
    if ( ERROR_SUCCESS != lRet )
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto exit;
    }

    lRet = RegQueryValueEx(hKey,
                           L"TraceFile",
                           NULL,
                           &dwType,
                           (LPBYTE)struFileName.QueryStr(),
                           &cbSize); //RegQueryValueEx
    if (ERROR_SUCCESS != lRet ||
        REG_SZ != dwType )
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto exit;
    }
    
    struFileName.QueryStr()[ cbSize / sizeof( WCHAR ) - 1 ] = L'\0';
    
    struFileName.SyncWithBuffer();

    wsprintf( buffer, L"%lu", GetCurrentProcessId() );
    hr = struFileName.Append(buffer);
    if (FAILED(hr))
    {
        goto exit;
    }

    sm_hTraceFile = CreateFile(struFileName.QueryStr(),
                                               GENERIC_WRITE,
                                               FILE_SHARE_READ,
                                               NULL,
                                               OPEN_ALWAYS,
                                               FILE_ATTRIBUTE_NORMAL,
                                               NULL); // CreateFile
    if (INVALID_HANDLE_VALUE == sm_hTraceFile)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto exit;
    }

    //
    // Create TraceLog factory
    //
    hr = W3_TRACE_LOG_FACTORY::CreateTraceLogFactory(&sm_pLogFactory, sm_hTraceFile);
    if (FAILED(hr))
    {
        goto exit;
    }

exit:
    if (FAILED(hr))
    {
        CleanupTraceLogging();
    }

    if (hKey)
    {
        RegCloseKey(hKey);
        hKey = NULL;
    }

    return hr;
}

//static
VOID
W3_MAIN_CONTEXT::CleanupTraceLogging()
{
    if ( sm_pLogFactory != NULL )
    {
        sm_pLogFactory->DestroyTraceLogFactory();
        sm_pLogFactory = NULL;
    }

    if ( sm_hTraceFile != INVALID_HANDLE_VALUE )
    {
        CloseHandle(sm_hTraceFile);
        sm_hTraceFile = INVALID_HANDLE_VALUE;
    }
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\iisplus\ulw3\methodhash.h ===
#ifndef _METHODHASH_HXX_
#define _METHODHASH_HXX_

class METHOD_HASH
    : public CTypedHashTable< METHOD_HASH, 
                              HEADER_RECORD, 
                              CHAR * >
{
public:
    METHOD_HASH()
      : CTypedHashTable< METHOD_HASH, 
                         HEADER_RECORD, 
                         CHAR * >
            ("METHOD_HASH")
    {
    }
    
    static 
    CHAR *
    ExtractKey(
        const HEADER_RECORD * pRecord
    )
    {
        DBG_ASSERT( pRecord != NULL );
        return pRecord->_pszName;
    }

    static
    DWORD
    CalcKeyHash(
        CHAR *                 pszKey
    )
    {
        return Hash( pszKey ); 
    }

    static
    bool
    EqualKeys(
        CHAR *                 pszKey1,
        CHAR *                 pszKey2
    )
    {
        return strcmp( pszKey1, pszKey2 ) == 0;
    }

    static
    void
    AddRefRecord(
        HEADER_RECORD *,
        int
    )
    {
    }

    static
    HRESULT
    Initialize(
        VOID
    );

    static
    VOID
    Terminate(
        VOID
    );

    static
    ULONG
    GetIndex(
        CHAR *             pszName
    )
    {
        HEADER_RECORD *       pRecord = NULL;
        LK_RETCODE                  retCode;

        retCode = sm_pMethodHash->FindKey( pszName,
                                           &pRecord );
        if ( retCode == LK_SUCCESS )
        {
            DBG_ASSERT( pRecord != NULL );
            return pRecord->_ulHeaderIndex;
        }
        else
        {
            return HttpVerbUnknown;
        }
    }
    
    static
    CHAR *
    GetString(
        ULONG               ulIndex,
        USHORT *            pcchLength
    )
    {
        for (DWORD i = 0; sm_rgMethods[i]._pszName != NULL; i++)
        {
            if (ulIndex == sm_rgMethods[i]._ulHeaderIndex)
            {
                *pcchLength = sm_rgMethods[i]._cchName;
                return sm_rgMethods[i]._pszName;
            }
        }

        return NULL;
    }
    
private:

    static METHOD_HASH    *sm_pMethodHash;
    static HEADER_RECORD   sm_rgMethods[];

    METHOD_HASH(const METHOD_HASH &);
    void operator=(const METHOD_HASH &);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\iisplus\ulw3\map_handler.cxx ===
/*++

   Copyright    (c)   2000    Microsoft Corporation

   Module Name :
     map_handler.cxx

   Abstract:
     Handle Map Files requests
 
   Author:
     Anil Ruia (AnilR)          9-Mar-2000

   Environment:
     Win32 - User Mode

   Project:
     ULW3.DLL
--*/

#include "precomp.hxx"
#include "staticfile.hxx"

#define MAXVERTS 160

const int MIN_INTEGER = 0x80000001;

void SkipLine(LPCSTR pszFileContents,
              const DWORD cbFileSize,
              DWORD &fileIndex);

void SkipWhiteExceptNewLine(LPCSTR pszFileContents,
                            const DWORD cbFileSize,
                            DWORD &fileIndex);

void SkipWhite(LPCSTR pszFileContents,
               const DWORD cbFileSize,
               DWORD &fileIndex);

void SkipNonWhite(LPCSTR pszFileContents,
                  const DWORD cbFileSize,
                  DWORD &fileIndex);

int GetNumber(LPCSTR pszFileContents,
              const DWORD cbFileSize,
              DWORD &fileIndex);

BOOL PointInRect(LPCSTR pszFileContents,
                 const DWORD cbFileSize,
                 DWORD &fileIndex,
                 const int x,
                 const int y,
                 DWORD &urlIndex);

BOOL PointInCircle(LPCSTR pszFileContents,
                   const DWORD cbFileSize,
                   DWORD &fileIndex,
                   const int x,
                   const int y,
                   DWORD &urlIndex);

BOOL PointInPoly(LPCSTR pszFileContents,
                 const DWORD cbFileSize,
                 DWORD &fileIndex,
                 const int x,
                 const int y,
                 DWORD &urlIndex);

double PointInPoint(LPCSTR pszFileContents,
                    const DWORD cbFileSize,
                    DWORD &fileIndex,
                    const int x,
                    const int y,
                    DWORD &urlIndex);

DWORD GetDefaultUrl(LPCSTR pszFileContents,
                    const DWORD cbFileSize,
                    DWORD &fileIndex);

HRESULT W3_STATIC_FILE_HANDLER::MapFileDoWork(
    W3_CONTEXT   *pW3Context,
    W3_FILE_INFO *pOpenFile,
    BOOL         *pfHandled)
{
    DBG_ASSERT(pW3Context != NULL);
    DBG_ASSERT(pOpenFile != NULL);
    DBG_ASSERT(pfHandled != NULL);

    STACK_STRA(strTargetUrl,        MAX_PATH);
    STACK_STRU(strQueryString,      MAX_PATH);
    LPSTR                           pszFileContents = NULL;
    BOOL                            fFileContentsAllocated = FALSE;
    int                             x = 0;
    int                             y = 0;
    HRESULT                         hr = S_OK;

    W3_REQUEST *pRequest = pW3Context->QueryRequest();
    DBG_ASSERT(pRequest != NULL);

    *pfHandled = FALSE;

    DWORD cbFileSize;
    ULARGE_INTEGER liFileSize;
    pOpenFile->QuerySize(&liFileSize);
    cbFileSize = liFileSize.LowPart;

    if (pOpenFile->QueryFileBuffer() != NULL)
    {
        pszFileContents = (LPSTR)pOpenFile->QueryFileBuffer();
    }
    else
    {
        pszFileContents = new CHAR[cbFileSize];
        if (pszFileContents == NULL)
        {
            hr = HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
            goto Finished;
        }
        fFileContentsAllocated = TRUE;

        DWORD cbRead;
        OVERLAPPED ovl;
        ZeroMemory(&ovl, sizeof ovl);
        if (!ReadFile(pOpenFile->QueryFileHandle(),
                       pszFileContents,
                       cbFileSize,
                       &cbRead,
                      &ovl))
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            switch (hr)
            {
            case HRESULT_FROM_WIN32(ERROR_IO_PENDING):
                if (!GetOverlappedResult(pOpenFile->QueryFileHandle(),
                                         &ovl,
                                         &cbRead,
                                         TRUE))
                {
                    hr = HRESULT_FROM_WIN32(GetLastError());
                    goto Finished;
                }
                break;

            default:
                goto Finished;
            }
        }
    }

    if (FAILED(hr = pW3Context->QueryRequest()->GetQueryString(&strQueryString)))
    {
        goto Finished;
    }

    strQueryString.Unescape();

    swscanf(strQueryString.QueryStr(), L"%d, %d", &x, &y);

    if (FAILED(hr = SearchMapFile(pszFileContents,
                                  cbFileSize,
                                  x, y, &strTargetUrl)))
    {
        goto Finished;
    }

    if (strTargetUrl.QueryCCH() == 0)
    {
        //
        // No entry found
        //
        LPCSTR pszReferer;
        if ((pszReferer = pRequest->GetHeader(HttpHeaderReferer)) != NULL)
        {
            //
            // Redirect back to referrer
            //

            strTargetUrl.Copy(pszReferer);
        }
        else
        {
            *pfHandled = FALSE;
            goto Finished;
        }
    }

    *pfHandled = TRUE;
    hr = pW3Context->SetupHttpRedirect(strTargetUrl,
                                       FALSE,
                                       HttpStatusRedirect);

Finished:

    if (fFileContentsAllocated)
    {
        delete [] pszFileContents;
    }

    return hr;
}

HRESULT W3_STATIC_FILE_HANDLER::SearchMapFile(
            IN LPCSTR pszFileContents,
            IN const DWORD cbFileSize,
            IN const int x,
            IN const int y,
            OUT STRA *pstrTarget)
{
    DWORD fileIndex = 0;
    DWORD urlIndex = 0;
    BOOL fFound = FALSE;
    double MinDistanceFromPoint = 1e64;
    DWORD PointUrlIndex = 0;
    DWORD DefaultUrlIndex = 0;

    while ((fileIndex < cbFileSize) && !fFound)
    {
        switch (pszFileContents[fileIndex])
        {
        case '#':
            //
            // Comment, skip the line
            //
            break;

        case 'r':
        case 'R':
            //
            // Rectangle
            //

            if ((fileIndex < (cbFileSize - 4)) &&
                !_strnicmp("rect", pszFileContents + fileIndex, 4))
            {
                fileIndex += 4;
                fFound = PointInRect(pszFileContents, cbFileSize,
                                     fileIndex,
                                     x, y,
                                     urlIndex);
            }
            break;

        case 'c':
        case 'C':
            //
            // Circle
            //

            if ((fileIndex < (cbFileSize - 4)) &&
                !_strnicmp("circ", pszFileContents + fileIndex, 4))
            {
                fileIndex += 4;
                fFound = PointInCircle(pszFileContents, cbFileSize,
                                       fileIndex,
                                       x, y,
                                       urlIndex);
            }
            break;

        case 'p':
        case 'P':
            //
            // Polygon or point
            //

            if ((fileIndex < (cbFileSize - 4)) &&
                !_strnicmp("poly", pszFileContents + fileIndex, 4))
            {
                fileIndex += 4;
                fFound = PointInPoly(pszFileContents, cbFileSize,
                                     fileIndex,
                                     x, y,
                                     urlIndex);
            }
            else if ((fileIndex < (cbFileSize - 5)) &&
                     !_strnicmp("point", pszFileContents + fileIndex, 5))
            {
                fileIndex += 5;

                double distance = PointInPoint(pszFileContents, cbFileSize,
                                               fileIndex,
                                               x, y,
                                               urlIndex);

                if (distance < MinDistanceFromPoint)
                {
                    MinDistanceFromPoint = distance;
                    PointUrlIndex = urlIndex;
                }
            }
            break;

        case 'd':
        case 'D':
            //
            // default URL
            //

            if ((fileIndex < (cbFileSize - 3)) &&
                !_strnicmp("def", pszFileContents + fileIndex, 3))
            {
                fileIndex += 3;
                DefaultUrlIndex = GetDefaultUrl(pszFileContents,
                                                cbFileSize,
                                                fileIndex);
            }
            break;
        }  // switch

        if (!fFound)
            SkipLine(pszFileContents, cbFileSize, fileIndex);
    }  // while

    //
    //  If we didn't find a mapping and a point or a default was specified, 
    //  use that URL
    //

    if (!fFound)
    {
        if (PointUrlIndex != 0)
        {
            urlIndex = PointUrlIndex;
            fFound = TRUE;
        }
        else if (DefaultUrlIndex != 0)
        {
            urlIndex = DefaultUrlIndex;
            fFound = TRUE;
        }
    }

    if (fFound)
    {
        //
        //  make urlIndex point to the start of the URL
        //

        SkipWhiteExceptNewLine(pszFileContents, cbFileSize, urlIndex);

        //
        //  Determine the length of the URL and copy it out
        //

        DWORD endOfUrlIndex = urlIndex;
        SkipNonWhite(pszFileContents, cbFileSize, endOfUrlIndex); 

        HRESULT hr;
        if (FAILED(hr = pstrTarget->Copy(pszFileContents + urlIndex,
                                          endOfUrlIndex - urlIndex)))
        {
            return hr;
        }

        //
        // BUGBUG - Escape the URL
        //
    }
    else
    {
        DBGPRINTF((DBG_CONTEXT, "No mapping found for %d, %d\n", x, y));
    }

    return S_OK;
}

void SkipLine(LPCSTR pszFileContents,
              const DWORD cbFileSize,
              DWORD &fileIndex)
{
    while ((fileIndex < cbFileSize) &&
           (pszFileContents[fileIndex] != '\n'))
        fileIndex++;

    fileIndex++;
}

void SkipWhiteExceptNewLine(LPCSTR pszFileContents,
                            const DWORD cbFileSize,
                            DWORD &fileIndex)
{
    while ((fileIndex < cbFileSize) &&
           ((pszFileContents[fileIndex] == ' ') ||
            (pszFileContents[fileIndex] == '\t') ||
            (pszFileContents[fileIndex] == '(') ||
            (pszFileContents[fileIndex] == ')')))
    {
        fileIndex++;
    }
}

void SkipWhite(LPCSTR pszFileContents,
               const DWORD cbFileSize,
               DWORD &fileIndex)
{
    while ((fileIndex < cbFileSize) &&
           ((pszFileContents[fileIndex] == ' ') ||
            (pszFileContents[fileIndex] == '\t') ||
            (pszFileContents[fileIndex] == '\r') ||
            (pszFileContents[fileIndex] == '\n') ||
            (pszFileContents[fileIndex] == '(') ||
            (pszFileContents[fileIndex] == ')')))
    {
        fileIndex++;
    }
}

void SkipNonWhite(LPCSTR pszFileContents,
                  const DWORD cbFileSize,
                  DWORD &fileIndex)
{
    while ((fileIndex < cbFileSize) &&
           (pszFileContents[fileIndex] != ' ') &&
           (pszFileContents[fileIndex] != '\t') &&
           (pszFileContents[fileIndex] != '\r') &&
           (pszFileContents[fileIndex] != '\n'))
    {
        fileIndex++;
    }
}

int GetNumber(LPCSTR pszFileContents,
              const DWORD cbFileSize,
              DWORD &fileIndex)
{
    int Value = MIN_INTEGER;

    char    ch;
    bool    fNegative = false;

    //
    //  Make sure we don't get into the URL
    //

    while ((fileIndex < cbFileSize) &&
           !isalnum(ch = pszFileContents[fileIndex]) &&
           (ch != '-') && (ch != '/') &&
           (ch != '\r') && (ch != '\n'))
    {
        fileIndex++;
    }

    //
    // Read the number
    //
    if ((fileIndex < cbFileSize) &&
        (pszFileContents[fileIndex] == '-'))
    {
        fNegative = true;
        fileIndex++;
    }

    while ((fileIndex < cbFileSize) &&
           isdigit(ch = pszFileContents[fileIndex]))
    {
        if (Value == MIN_INTEGER)
            Value = 0;

        Value = Value*10 + (ch - '0');
        fileIndex++;
    }

    if (fNegative)
        Value = -Value;

    return Value;
}

BOOL PointInRect(LPCSTR pszFileContents,
                 const DWORD cbFileSize,
                 DWORD &fileIndex,
                 const int x,
                 const int y,
                 DWORD &urlIndex)
{
    BOOL fNCSA = FALSE;
    BOOL fFound  = FALSE;

    SkipNonWhite(pszFileContents, cbFileSize, fileIndex);
    urlIndex = fileIndex;                        // NCSA case
    SkipWhiteExceptNewLine(pszFileContents, cbFileSize, fileIndex);

    char ch   = pszFileContents[fileIndex];

    if (((ch < '0') || (ch > '9')) &&
        (ch != '-') && (ch != '('))
    {
        //
        // NCSA format. Skip the URL
        //

        fNCSA = true;
        SkipNonWhite(pszFileContents, cbFileSize, fileIndex);
    }

    int x1 = GetNumber(pszFileContents, cbFileSize, fileIndex);
    int y1 = GetNumber(pszFileContents, cbFileSize, fileIndex);

    int x2 = GetNumber(pszFileContents, cbFileSize, fileIndex);
    int y2 = GetNumber(pszFileContents, cbFileSize, fileIndex);

    if ((x >= x1) && (x < x2) &&  (y >= y1) && (y < y2))
        fFound = true;

    if (!fNCSA)
    {
        urlIndex = fileIndex;

        //
        //  Skip the URL
        //

        SkipWhiteExceptNewLine(pszFileContents, cbFileSize, fileIndex);
        SkipNonWhite(pszFileContents, cbFileSize, fileIndex);
    }

    return fFound;
}

BOOL PointInCircle(LPCSTR pszFileContents,
                   const DWORD cbFileSize,
                   DWORD &fileIndex,
                   const int x,
                   const int y,
                   DWORD &urlIndex)
{
    BOOL fNCSA = FALSE;
    BOOL fFound = FALSE;

    double      r1, r2;

    SkipNonWhite(pszFileContents, cbFileSize, fileIndex);
    urlIndex  =  fileIndex;                           // NCSA case
    SkipWhiteExceptNewLine(pszFileContents, cbFileSize, fileIndex);

    char ch   = pszFileContents[fileIndex];

    if (!isdigit(ch) && (ch != '-') && (ch != '('))
    {
        //
        // NCSA format. Skip the URL
        //

        fNCSA = true;
        SkipNonWhite(pszFileContents, cbFileSize, fileIndex);
    }

    //
    //  Get the center and edge of the circle
    //

    double xCenter = GetNumber(pszFileContents, cbFileSize, fileIndex);
    double yCenter = GetNumber(pszFileContents, cbFileSize, fileIndex);

    double xEdge = GetNumber(pszFileContents, cbFileSize, fileIndex);
    double yEdge = GetNumber(pszFileContents, cbFileSize, fileIndex);

    //
    // If we have the NCSA format, (xEdge, yEdge) is a point on the
    // circumference.  Otherwise xEdge specifies the radius
    //
    if (yEdge != (double)MIN_INTEGER)
    {
        r1 = (yCenter - yEdge) * (yCenter - yEdge) +
            (xCenter - xEdge) * (xCenter - xEdge);

        r2 = (yCenter - y) * (yCenter - y) +
            (xCenter - x) * (xCenter - x);

        if ( r2 <= r1 )
            fFound = true;
    }
    //
    //  CERN format, third param is the radius
    //
    else if(xEdge >= 0)
    {
        double radius;
        radius = xEdge;

        if (( xCenter - x ) * ( xCenter - x)  + 
            ( yCenter - y ) * ( yCenter - y) <= ( radius * radius))
            fFound = true;
    }
    // if invalid radius, just check if it is on center
    else if ((xCenter == x) && (yCenter == y))
    {
        fFound = true;
    }

    if (!fNCSA)
    {
        urlIndex = fileIndex;

        //
        //  Skip the URL
        //
        SkipWhiteExceptNewLine(pszFileContents, cbFileSize, fileIndex);
        SkipNonWhite(pszFileContents, cbFileSize, fileIndex);
    }

    return fFound;
}

const int X = 0;
const int Y = 1;

BOOL PointInPoly(LPCSTR pszFileContents,
                 const DWORD cbFileSize,
                 DWORD &fileIndex,
                 const int x,
                 const int y,
                 DWORD &urlIndex)
{
    //
    // Algorithm used is from http://www.whisqu.se/per/docs/math27.htm
    //

    BOOL fNCSA = FALSE;
    BOOL fFound = FALSE;

    SkipNonWhite(pszFileContents, cbFileSize, fileIndex);
    urlIndex  =  fileIndex;                           // NCSA case
    SkipWhiteExceptNewLine(pszFileContents, cbFileSize, fileIndex);

    char ch   = pszFileContents[fileIndex];

    if (!isdigit(ch) && (ch != '-') && (ch != '('))
    {
        //
        // NCSA format. Skip the URL
        //

        fNCSA = TRUE;
        SkipNonWhite(pszFileContents, cbFileSize, fileIndex);
    }

    //
    //  Build the array of points
    //

    double polygon[MAXVERTS][2];
    int count = 0;

    while ((fileIndex < cbFileSize) && 
           (pszFileContents[fileIndex] != '\r') && 
           (pszFileContents[fileIndex] != '\n'))
    {
        int polyX = GetNumber(pszFileContents, cbFileSize, fileIndex);

        //
        //  Did we hit the end of the line (and go past the URL)?
        //

        if ( polyX != MIN_INTEGER)
        {
            polygon[count][X] = polyX;
            polygon[count][Y] = GetNumber(pszFileContents, cbFileSize, fileIndex);
            count++;
            if (count >= MAXVERTS)
                return FALSE;
        }
        else
            break;
    }

    if (count > 1)
    {
        double tX = x;
        double tY = y;

        double prevX = polygon[count - 1][X];
        double prevY = polygon[count - 1][Y];

        double  currX, currY;

        int crossings = 0;

        for (int i=0; i < count; i++)
        {
            double  interpY;

            currX   = polygon[i][X];
            currY   = polygon[i][Y];

            if (((prevX >= tX) && (currX < tX)) ||
                ((prevX < tX) && (currX >= tX)))
            {
                //
                // Use linear interpolation to find the y coordinate of
                // the line connecting (prevX, prevY) to (currX, currY)
                // at the same x coordinate as the target point
                //

                interpY = prevY + ((currY - prevY)/(currX - prevX))* (tX - prevX);

                if (interpY == tY)
                {
                    fFound = true;
                    break;
                }
                else if (interpY > tY)
                    crossings++;
            }
            // To catch the left end of a line
            else if (((prevX == tX) && (prevY == tY)) ||
                     ((currX == tX) && (currY == tY)))
            {
                fFound = true;
                break;
            }
            // To catch a vertical line
            else if ((prevX == currX) && (prevX == tX))
                if (((prevY >= tY) && ( currY <= tY)) ||
                    ((prevY <= tY) && ( currY >= tY)))
                {
                    fFound = true;
                    break;
                }

            prevX = currX;
            prevY = currY;
        }

        if (!fFound)
        {
            //
            // If # crossings is odd => In polygon
            //
            fFound = crossings & 0x1;
        }
    }

    if (!fNCSA)
    {
        urlIndex = fileIndex;

        //
        //  Skip the URL
        //

        SkipWhiteExceptNewLine(pszFileContents, cbFileSize, fileIndex);
        SkipNonWhite(pszFileContents, cbFileSize, fileIndex);
    }

    return fFound;
}

double PointInPoint(LPCSTR pszFileContents,
                    const DWORD cbFileSize,
                    DWORD &fileIndex,
                    const int x,
                    const int y,
                    DWORD &urlIndex)
{
    SkipNonWhite(pszFileContents, cbFileSize, fileIndex);

    urlIndex  =  fileIndex;                               // NCSA case

    SkipWhiteExceptNewLine(pszFileContents, cbFileSize, fileIndex);
    SkipNonWhite(pszFileContents, cbFileSize, fileIndex);

    double x1 = GetNumber(pszFileContents, cbFileSize, fileIndex);
    double y1 = GetNumber(pszFileContents, cbFileSize, fileIndex);

    return ((x1-x)*(x1-x)) + ((y1-y)*(y1-y));
}

DWORD GetDefaultUrl(LPCSTR pszFileContents,
                    const DWORD cbFileSize,
                    DWORD &fileIndex)
{
    //
    //  Skip "default" (don't skip white space)
    //

    SkipNonWhite(pszFileContents, cbFileSize, fileIndex);
    DWORD defUrlIndex  = fileIndex;

    //
    //  Skip URL
    //

    SkipWhiteExceptNewLine(pszFileContents, cbFileSize, fileIndex);
    SkipNonWhite(pszFileContents, cbFileSize, fileIndex);

    return defUrlIndex;                        
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\iisplus\ulw3\methodhash.cxx ===
/*++

   Copyright    (c)    2000   Microsoft Corporation

   Module Name :
     headerhash.cxx

   Abstract:
     Header hash goo
 
   Author:
     Bilal Alam (balam)             20-Feb-2000

   Environment:
     Win32 - User Mode

   Project:
     ULW3.DLL
--*/

#include "precomp.hxx"

METHOD_HASH *METHOD_HASH::sm_pMethodHash;

HEADER_RECORD METHOD_HASH::sm_rgMethods[] = 
{
    { HttpVerbOPTIONS,   HEADER("OPTIONS") },
    { HttpVerbGET,       HEADER("GET") },
    { HttpVerbHEAD,      HEADER("HEAD") },
    { HttpVerbPOST,      HEADER("POST") },
    { HttpVerbPUT,       HEADER("PUT") },
    { HttpVerbDELETE,    HEADER("DELETE") },
    { HttpVerbTRACE,     HEADER("TRACE") },
    { HttpVerbCONNECT,   HEADER("CONNECT") },
    { HttpVerbTRACK,     HEADER("TRACK") },
    { HttpVerbMOVE,      HEADER("MOVE") },
    { HttpVerbCOPY,      HEADER("COPY") },
    { HttpVerbPROPFIND,  HEADER("PROPFIND") },
    { HttpVerbPROPPATCH, HEADER("PROPPATCH") },
    { HttpVerbMKCOL,     HEADER("MKCOL") },
    { HttpVerbLOCK,      HEADER("LOCK") },
    { HttpVerbUNLOCK,    HEADER("UNLOCK") },
    { HttpVerbSEARCH,    HEADER("SEARCH") },
    { HttpVerbUnknown,   NULL }
};

//static
HRESULT
METHOD_HASH::Initialize(
    VOID
)
/*++

Routine Description:

    Initialize global header hash table

Arguments:

    None

Return Value:

    HRESULT

--*/
{
    HEADER_RECORD *     pRecord;
    LK_RETCODE          lkrc = LK_SUCCESS;
    DWORD               dwNumRecords;
    
    //
    // Add header index/name to hash table
    //
    
    sm_pMethodHash = new METHOD_HASH();
    if ( sm_pMethodHash == NULL )
    {
        return HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );
    }
    
    //
    // Add every string->routine mapping
    //

    dwNumRecords = sizeof( sm_rgMethods ) / sizeof( HEADER_RECORD ) - 1;
    
    for ( DWORD i = 0; i < dwNumRecords; i++ )
    {
        pRecord = &(sm_rgMethods[ i ]); 
        lkrc = sm_pMethodHash->InsertRecord( pRecord );
        if ( lkrc != LK_SUCCESS )
        {
            break;
        }
    }
    
    //
    // If any insert failed, then fail initialization
    //
    
    if ( lkrc != LK_SUCCESS )
    {
        delete sm_pMethodHash;
        sm_pMethodHash = NULL;
        return HRESULT_FROM_WIN32( lkrc );        // BUGBUG
    }
    else
    {
        return NO_ERROR;
    }
}

//static
VOID
METHOD_HASH::Terminate(
    VOID
)
/*++

Routine Description:

    Global cleanup of header hash table

Arguments:

    None

Return Value:

    None

--*/
{
    if ( sm_pMethodHash != NULL )
    {
        delete sm_pMethodHash;
        sm_pMethodHash = NULL;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\iisplus\ulw3\passportprovider.cxx ===
/*++

   Copyright    (c)    1999    Microsoft Corporation

   Module Name :
     passportprovider.cxx

   Abstract:
     Core passport authentication support
     
   Author:
     Bilal Alam (balam)             16-Mar-2001

   Environment:
     Win32 - User Mode

   Project:
     ULW3.DLL

--*/

#include "precomp.hxx"
#include "passportprovider.hxx"

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}

#define MAGIC_TWEENER_STRING        L"msppchlg=1&mspplogin="
#define MAGIC_TWEENER_STRING_LEN    ( sizeof( MAGIC_TWEENER_STRING ) / sizeof( WCHAR ) - 1 )

MIDL_DEFINE_GUID(IID,IID_IPassportManager3,0x1451151f,0x90a0,0x491b,0xb8,0xe1,0x81,0xa1,0x37,0x67,0xed,0x98);
MIDL_DEFINE_GUID(IID,IID_IPassportFactory,0x5602E147,0x27F6,0x11d3,0x94,0xDD,0x00,0xC0,0x4F,0x72,0xDC,0x08);
MIDL_DEFINE_GUID(CLSID,CLSID_PassportFactory,0x74EB2514,0xE239,0x11D2,0x95,0xE9,0x00,0xC0,0x4F,0x8E,0x7A,0x70);

IPassportFactory *       PASSPORT_CONTEXT::sm_pPassportManagerFactory;
BSTR                     PASSPORT_CONTEXT::sm_bstrMemberIdHigh;
BSTR                     PASSPORT_CONTEXT::sm_bstrMemberIdLow;
BSTR                     PASSPORT_CONTEXT::sm_bstrReturnUrl;
BSTR                     PASSPORT_CONTEXT::sm_bstrTimeWindow;
BSTR                     PASSPORT_CONTEXT::sm_bstrForceSignIn;
BSTR                     PASSPORT_CONTEXT::sm_bstrCoBrandTemplate;
BSTR                     PASSPORT_CONTEXT::sm_bstrLanguageId;
BSTR                     PASSPORT_CONTEXT::sm_bstrSecureLevel;

//static
HRESULT
PASSPORT_CONTEXT::Initialize(
    VOID
)
/*++

Routine Description:

    Do global initialization for passport goo

Arguments:

    None

Return Value:

    HRESULT

--*/
{
    HRESULT             hr = NO_ERROR;

    //
    // Pre-allocate some BSTRs 
    //
    
    sm_bstrMemberIdHigh = SysAllocString( L"MemberIdHigh" );
    if ( sm_bstrMemberIdHigh == NULL )
    {
        hr = HRESULT_FROM_WIN32( GetLastError() );
        goto Failure;
    }

    sm_bstrMemberIdLow = SysAllocString( L"MemberIdLow" );
    if ( sm_bstrMemberIdLow == NULL )
    {
        hr = HRESULT_FROM_WIN32( GetLastError() );
        goto Failure;
    }
    
    sm_bstrReturnUrl = SysAllocString( L"ReturnURL" );
    if ( sm_bstrReturnUrl == NULL )
    {
        hr = HRESULT_FROM_WIN32( GetLastError() );
        goto Failure;
    }
    
    sm_bstrTimeWindow = SysAllocString( L"TimeWindow" );
    if ( sm_bstrTimeWindow == NULL )
    {
        hr = HRESULT_FROM_WIN32( GetLastError() );
        goto Failure;
    }
    
    sm_bstrForceSignIn = SysAllocString( L"ForceSignIn" );
    if ( sm_bstrForceSignIn == NULL )
    {
        hr = HRESULT_FROM_WIN32( GetLastError() );
        goto Failure;
    }
    
    sm_bstrCoBrandTemplate = SysAllocString( L"CoBrandTemplate" );
    if ( sm_bstrCoBrandTemplate == NULL )
    {
        hr = HRESULT_FROM_WIN32( GetLastError() );
        goto Failure;
    }
    
    sm_bstrLanguageId = SysAllocString( L"LanguageId" );
    if ( sm_bstrLanguageId == NULL )
    {
        hr = HRESULT_FROM_WIN32( GetLastError() );
        goto Failure;
    }
    
    sm_bstrSecureLevel = SysAllocString( L"SecureLevel" );
    if ( sm_bstrSecureLevel == NULL )
    {
        hr = HRESULT_FROM_WIN32( GetLastError() );
        goto Failure;
    }
    
    //
    // Try to initialize the passport manager factory.  If we cannot, then
    // we're done
    //
    
    hr = CoInitializeEx( NULL, COINIT_MULTITHREADED );
    
    if( FAILED( hr ) )
    {
        goto Failure;
    }

    hr = CoCreateInstance( CLSID_PassportFactory, 
                           NULL, 
                           CLSCTX_INPROC_SERVER, 
                           IID_IPassportFactory, 
                           (void**)&sm_pPassportManagerFactory );
    
    CoUninitialize();
    
    if ( FAILED( hr ) )
    {
        goto Failure;
    }
    
    DBG_ASSERT( sm_pPassportManagerFactory != NULL );

    return NO_ERROR;    

Failure:

    if ( FAILED( hr ) )
    {
        if ( sm_pPassportManagerFactory != NULL )
        {
            sm_pPassportManagerFactory->Release();
            sm_pPassportManagerFactory = NULL;
        }
        
        if ( sm_bstrMemberIdLow != NULL )
        {
            SysFreeString( sm_bstrMemberIdLow );
            sm_bstrMemberIdLow = NULL;
        }
        
        if ( sm_bstrMemberIdHigh != NULL )
        {
            SysFreeString( sm_bstrMemberIdHigh );
            sm_bstrMemberIdHigh = NULL;
        }
        
        if ( sm_bstrReturnUrl != NULL )
        {
            SysFreeString( sm_bstrReturnUrl );
            sm_bstrReturnUrl = NULL;
        }

        if ( sm_bstrTimeWindow == NULL )
        {
            SysFreeString( sm_bstrTimeWindow );
            sm_bstrTimeWindow = NULL;
        }
    
        if ( sm_bstrForceSignIn == NULL )
        {
            SysFreeString( sm_bstrForceSignIn );
            sm_bstrForceSignIn = NULL;
        }
    
        if ( sm_bstrCoBrandTemplate == NULL )
        {
            SysFreeString( sm_bstrCoBrandTemplate );
            sm_bstrCoBrandTemplate = NULL;
        }
    
        if ( sm_bstrLanguageId == NULL )
        {
            SysFreeString( sm_bstrLanguageId );
            sm_bstrLanguageId = NULL;
        }
    
        if ( sm_bstrSecureLevel == NULL )
        {
            SysFreeString( sm_bstrSecureLevel );
            sm_bstrSecureLevel = NULL;
        }
    }
    
    return hr;
}

//static
VOID
PASSPORT_CONTEXT::Terminate(
    VOID
)
/*++

Routine Description:

    Cleanup global passport goo

Arguments:

    None

Return Value:

    None

--*/
{
    if ( sm_pPassportManagerFactory != NULL )
    {
        sm_pPassportManagerFactory->Release();
        sm_pPassportManagerFactory = NULL;
    }
    
    if ( sm_bstrMemberIdLow != NULL )
    {
        SysFreeString( sm_bstrMemberIdLow );
        sm_bstrMemberIdLow = NULL;
    }
    
    if ( sm_bstrMemberIdHigh != NULL )
    {
        SysFreeString( sm_bstrMemberIdHigh );
        sm_bstrMemberIdHigh = NULL;
    }
 
    if ( sm_bstrReturnUrl != NULL )
    {
        SysFreeString( sm_bstrReturnUrl );
        sm_bstrReturnUrl = NULL;
    }
    
    if ( sm_bstrTimeWindow == NULL )
    {
        SysFreeString( sm_bstrTimeWindow );
        sm_bstrTimeWindow = NULL;
    }
    
    if ( sm_bstrForceSignIn == NULL )
    {
        SysFreeString( sm_bstrForceSignIn );
        sm_bstrForceSignIn = NULL;
    }
    
    if ( sm_bstrCoBrandTemplate == NULL )
    {
        SysFreeString( sm_bstrCoBrandTemplate );
        sm_bstrCoBrandTemplate = NULL;
    }
    
    if ( sm_bstrLanguageId == NULL )
    {
        SysFreeString( sm_bstrLanguageId );
        sm_bstrLanguageId = NULL;
    }
    
    if ( sm_bstrSecureLevel == NULL )
    {
        SysFreeString( sm_bstrSecureLevel );
        sm_bstrSecureLevel = NULL;
    }
}

BOOL
PASSPORT_CONTEXT::QueryUserError(
    VOID
)
/*++

Routine Description:

    Returns whether the user cancelled.  That we have to do this work
    really sucks

Arguments:

    None

Return Value:

    BOOL

--*/
{
    LONG                lError;
    HRESULT             hr;
    
    if ( _pPassportManager == NULL )
    {
        return FALSE;
    }
    
    hr = _pPassportManager->get_Error( &lError );
    if ( FAILED( hr ) )
    {
        return FALSE;
    }
    
    return lError != 0;
}

HRESULT
PASSPORT_CONTEXT::SetupDefaultRedirect(
    W3_MAIN_CONTEXT *           pMainContext,
    BOOL *                      pfFoundRedirect
)
/*++

Routine Description:

    Setup default redirect in case of client cancelling

Arguments:

    pMainContext - main context
    pfFoundRedirect - Set to TRUE if redirect URL found

Return Value:

    HRESULT

--*/
{
    HRESULT             hr;
    VARIANT             vReturnUrl;
    STACK_STRU(         strRedirect, 512 );

    VariantInit( &vReturnUrl );
    
    if ( pMainContext == NULL ||
         pfFoundRedirect == NULL )
    {
        DBG_ASSERT( FALSE );
        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }
    
    *pfFoundRedirect = FALSE;
    
    DBG_ASSERT( _pPassportManager != NULL );
    
    //
    // First get the default URL if any
    // 
    
    hr = _pPassportManager->GetCurrentConfig( sm_bstrReturnUrl,
                                              &vReturnUrl );
    if ( FAILED( hr ) )
    {
        return NO_ERROR;
    }           
    
    if ( vReturnUrl.vt != VT_BSTR || 
         vReturnUrl.bstrVal[ 0 ] == L'\0' )
    {
        return NO_ERROR;        
    }

    //
    // Do the redirect 
    //
    
    hr = strRedirect.Copy( vReturnUrl.bstrVal );
    if ( FAILED( hr ) )
    {
        return hr;
    }
    
    hr = pMainContext->SetupHttpRedirect( strRedirect,
                                          TRUE,
                                          HttpStatusRedirect );
    if ( FAILED( hr ) )
    {
        return hr;
    }
    
    *pfFoundRedirect = TRUE;
    
    return NO_ERROR;
}

HRESULT
PASSPORT_CONTEXT::Create(
    W3_FILTER_CONTEXT *         pFilterContext
)
/*++

Routine Description:

    Initialize a passport filter context 
    -the big thing being getting a passport manager for this request

Arguments:

    pFilterContext - Filter context

Return Value:

    HRESULT

--*/
{
    IDispatch *         pDispatch = NULL;
    HRESULT             hr;
    DWORD               cbBufferLength;

    if ( sm_pPassportManagerFactory == NULL )
    {
        DBG_ASSERT( FALSE );
        return HRESULT_FROM_WIN32( ERROR_NOT_SUPPORTED );
    }    
    
    //
    // Do some COM/OLEAUT crap to get a passport manager
    //
    
    hr = sm_pPassportManagerFactory->CreatePassportManager( &pDispatch );
    if ( FAILED( hr ) )
    {
        return hr;
    }
    
    DBG_ASSERT( pDispatch != NULL );
    
    hr = pDispatch->QueryInterface( IID_IPassportManager3,
                                    (VOID**) &_pPassportManager );

    pDispatch->Release();

    if ( FAILED( hr ) )
    {
        return hr;
    }
    
    DBG_ASSERT( _pPassportManager != NULL );
   
    //
    // Try a cookie of size 4096 since the samples all seem to use that size
    //
    
    if ( !_buffCookie.Resize( 4096 ) )
    {
        return HRESULT_FROM_WIN32( GetLastError() );
    }
    cbBufferLength = _buffCookie.QuerySize();
    
    //
    // Pass filter context to passport manager so that it can inspect the
    // request
    //

    DBG_ASSERT( _pPassportManager != NULL );
    
    hr = _pPassportManager->OnStartPageFilter( (PBYTE) pFilterContext->QueryFC(),
                                               &cbBufferLength,
                                               (LPSTR)
                                               _buffCookie.QueryPtr() ); 
    if ( FAILED( hr ) )
    {   
        return hr;
    }

    return NO_ERROR;
}

HRESULT
PASSPORT_CONTEXT::DoesApply(
    HTTP_FILTER_CONTEXT *               pfc,
    BOOL *                              pfApplies,
    STRA *                              pstrReturnCookie
)
/*++

Routine Description:

    Check whether the given request has Passport stuff in it

Arguments:

    pfc - Filter context
    pfApplies - Set to TRUE if passport applies
    pstrReturnCookie - Cookie to return in response

Return Value:

    HRESULT

--*/
{
    HRESULT                 hr;
    VARIANT                 vTimeWindow;
    VARIANT                 vForceLogin;
    VARIANT                 vSecureLevel;
    VARIANT_BOOL            vb;
    BUFFER                  bufReturnCookie;

    if ( pfc == NULL ||
         pfApplies == NULL ||
         pstrReturnCookie == NULL )
    {
        DBG_ASSERT( FALSE );
        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }
    
    *pfApplies = FALSE;

    //
    // Read parameters for IsAuthenticated().  If we can't find
    // them then choose arbitrary (tm) defaults
    //
    
    VariantInit( &vTimeWindow );

    hr = _pPassportManager->GetCurrentConfig( sm_bstrTimeWindow,
                                              &vTimeWindow );
    if ( FAILED( hr ) )
    {
        vTimeWindow.vt = VT_I4;
        vTimeWindow.lVal = 10000;
    }           
    
    VariantInit( &vForceLogin );
    
    hr = _pPassportManager->GetCurrentConfig( sm_bstrForceSignIn,
                                              &vForceLogin );
    if ( FAILED( hr ) )
    {
        vForceLogin.vt = VT_BOOL;
        vForceLogin.boolVal = VARIANT_FALSE;
    }

    VariantInit( &vSecureLevel );
    
    hr = _pPassportManager->GetCurrentConfig( sm_bstrSecureLevel,
                                              &vSecureLevel );
    if ( FAILED( hr ) )
    {
        vSecureLevel.vt = VT_I4;
        vSecureLevel.lVal = 10;
    }
    
    //
    // Are we authenticated?
    //

    hr = _pPassportManager->IsAuthenticated( vTimeWindow,
                                             vForceLogin,
                                             vSecureLevel,
                                             &vb );
    if ( FAILED( hr ) )
    {
        return hr;
    }
    
    if ( vb == VARIANT_TRUE )
    {
        _fAuthenticated = TRUE;
    }
    
    *pfApplies = _fAuthenticated;
    
    return pstrReturnCookie->Copy( (CHAR*) _buffCookie.QueryPtr() );
}

HRESULT
PASSPORT_CONTEXT::DoAuthenticate(
    W3_MAIN_CONTEXT *               pMainContext,
    TOKEN_CACHE_ENTRY **            ppCachedToken,
    STRU *                          pstrAuthUser,
    STRU *                          pstrRemoteUser,
    STRU &                          strDomainName
)
/*++

Routine Description:

    Logon the passport user (i.e. get a token)

Arguments:

    pMetaData - Metadata for this request
    ppCachedToken - Filled with token cache entry represented mapped user
    pstrAuthUser - Filled with AUTH_USER
    pstrRemoteUser - Filled with PUID
    strDomainName - Domain name

Return Value:

    HRESULT

--*/
{
    VARIANT                 vMemberId;
    HRESULT                 hr;
    WCHAR                   achLarge[ 64 ];
    DWORD                   dwLogonError;
    TOKEN_CACHE_ENTRY *     pCachedToken = NULL;
    LONG                    lLowPuid;
    LONG                    lHighPuid;
    BOOL                    fRet;
    HANDLE                  hToken;
    STACK_BUFFER(           bufName, 512 );
    DWORD                   cchName;
    W3_METADATA           * pMetaData;
    
    if ( pMainContext == NULL ||
         ppCachedToken == NULL ||
         pstrAuthUser == NULL ||
         pstrRemoteUser == NULL )
    {
        DBG_ASSERT( FALSE );
        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }
    
    pMetaData = pMainContext->QueryUrlContext()->QueryMetaData();
    DBG_ASSERT( pMetaData != NULL );
    
    //
    // Get the PUID -> this is the remote user name.
    // Start with the high part
    //
    
    VariantInit( &vMemberId );
   
    DBG_ASSERT( _pPassportManager != NULL );
   
    hr = _pPassportManager->get_Profile( sm_bstrMemberIdHigh, &vMemberId );
    if ( FAILED( hr ) )
    {
        goto Failure;
    }
    
    lHighPuid = V_I4( &vMemberId );
    
    //
    // Next the low part
    //
    
    hr = _pPassportManager->get_Profile( sm_bstrMemberIdLow, &vMemberId );
    if ( FAILED( hr ) )
    {
        goto Failure;
    }
    
    lLowPuid = V_I4( &vMemberId );
    
    //
    // Now make a string out of the QuadPart
    //
    
    wsprintfW( achLarge,
               L"%08X%08X",
               lHighPuid,
               lLowPuid );

    //
    // The REMOTE_USER server variable is always PUID@domain.
    //

    hr = pstrRemoteUser->Copy( achLarge );
    if ( FAILED( hr ) )
    {
        goto Failure;
    }
    
    hr = pstrRemoteUser->Append( L"@" );
    if ( FAILED( hr ) )
    {
        goto Failure;
    }
    
    hr = pstrRemoteUser->Append( strDomainName.QueryStr() );
    if ( FAILED( hr ) )
    {
        goto Failure;
    }
    
    //
    // Should we be doing mapping at all?
    // 
    
    if ( pMetaData->QueryRequireMapping() == MD_PASSPORT_NO_MAPPING )
    {
        //
        // No mapping.  Just use anonymous. 
        //
        
        hr = pMetaData->GetAndRefAnonymousToken( &pCachedToken );
        if( FAILED( hr ) )
        {
            return hr;
        }
        
        if ( pCachedToken == NULL )
        {
            return HRESULT_FROM_WIN32( ERROR_LOGON_FAILURE );
        }
        
        pstrAuthUser->Reset();
        
        *ppCachedToken = pCachedToken;
        
        return NO_ERROR;
    }
    
    //
    // If we got here then we must be doing mapping (trying it anyways)
    //
    
    //
    // Get the cached token (in other words, call into LsaLogonUser() )
    //
    
    DBG_ASSERT( g_pW3Server->QueryTokenCache() != NULL );
    
    hr = g_pW3Server->QueryTokenCache()->GetCachedToken( 
                                         pstrRemoteUser->QueryStr(),
                                         L"",
                                         L"",
                                         ( DWORD )IIS_LOGON_METHOD_PASSPORT,
                                         FALSE,
                                         FALSE,
                                         pMainContext->QueryRequest()->
                                              QueryRemoteSockAddress(),
                                         &pCachedToken,
                                         &dwLogonError );
    if ( FAILED( hr ) )
    {
        goto Failure;
    }
    
    //
    // Now, was mapping required or not??? (extra ??? for special effect)
    //
    
    if ( pCachedToken == NULL )
    {
        if ( pMetaData->QueryRequireMapping() == MD_PASSPORT_NEED_MAPPING )
        {
            //
            // No mapping -> fail!
            //
        
            return HRESULT_FROM_WIN32( dwLogonError );
        }
        else
        {   
            //
            // We tried, we failed, we'll persevere! 
            //
            
            hr = pMetaData->GetAndRefAnonymousToken( &pCachedToken );
            if ( FAILED( hr ) )
            {
                return hr;
            }

            if ( pCachedToken == NULL )
            {
                return HRESULT_FROM_WIN32( ERROR_LOGON_FAILURE );
            }
            
            pstrAuthUser->Reset();

            *ppCachedToken = pCachedToken;
            
            return NO_ERROR;
        }
    }
    
    //
    // The AUTH_USER server variable is the account name if mapping worked, else empty string
    //
    
    //
    // Get the token information by impersonating
    // (we could just cache this info, but then again who is going
    //  to use this mapping feature anyways???)
    //
        
    hToken = pCachedToken->QueryImpersonationToken();
    if ( hToken == NULL )
    {
        hr = HRESULT_FROM_WIN32( GetLastError() );
        goto Failure;
    }
        
    fRet = ImpersonateLoggedOnUser( hToken );
    if ( !fRet )
    {
        hr = HRESULT_FROM_WIN32( GetLastError() );
        goto Failure;
    }
        
    cchName = bufName.QuerySize() / sizeof( WCHAR );
        
    fRet = GetUserNameExW( NameSamCompatible,
                           (WCHAR*) bufName.QueryPtr(), 
                           &cchName );
    if ( !fRet )
    {
        hr = HRESULT_FROM_WIN32( GetLastError() );
            
        if ( hr == HRESULT_FROM_WIN32( ERROR_MORE_DATA ) )
        {
            DBG_ASSERT( cchName > bufName.QuerySize() / sizeof( WCHAR ) );
                
            fRet = bufName.Resize( cchName * sizeof( WCHAR ) );
            if ( !fRet )
            {
                hr = HRESULT_FROM_WIN32( GetLastError() );
            }
            else
            {
                fRet = GetUserNameExW( NameSamCompatible,
                                       (WCHAR*) bufName.QueryPtr(),
                                       &cchName );
                if ( !fRet )
                {
                    hr = HRESULT_FROM_WIN32( GetLastError() );
                }
                else
                {
                    hr = NO_ERROR;
                }
            }
        }
    }
        
    //
    // Always revert
    //
        
    if ( !RevertToSelf() )
    {
        hr = HRESULT_FROM_WIN32( GetLastError() );
        goto Failure;
    }
        
    //
    // If we failed earlier, bail.
    //
        
    if ( FAILED( hr ) )
    {
        goto Failure;
    }
        
    hr = pstrAuthUser->Copy( (WCHAR*) bufName.QueryPtr() );
    if ( FAILED( hr ) )
    {
        goto Failure;
    }
    
    if ( pCachedToken != NULL )
    {
        *ppCachedToken = pCachedToken;
    }
    
    return NO_ERROR;
    
Failure:

    DBG_ASSERT( FAILED( hr ) );

    if ( pCachedToken != NULL )
    {
        pCachedToken->DereferenceCacheEntry();
        pCachedToken = NULL;
    }
    
    return hr;
}

HRESULT
PASSPORT_CONTEXT::OnChallenge(
    STRU &              strOriginalUrl
)
/*++

Routine Description:

    Do a passport challenge

Arguments:

    strOriginalUrl - Original URL

Return Value:

    HRESULT

--*/
{
    BSTR                    bstrOriginalUrl;
    VARIANT                 vReturnURL;
    VARIANT                 vTimeWindow;
    VARIANT                 vForceLogin;
    VARIANT                 vNoParam;
    VARIANT                 vCoBrandTemplate;
    VARIANT                 vSecureLevel;
    HRESULT                 hr = NO_ERROR;
    
    VariantInit( &vTimeWindow );

    hr = _pPassportManager->GetCurrentConfig( sm_bstrTimeWindow,
                                              &vTimeWindow );
    if ( FAILED( hr ) )
    {
        vTimeWindow.vt = VT_I4;
        vTimeWindow.lVal = 10000;
    }
    
    VariantInit( &vForceLogin );
    
    hr = _pPassportManager->GetCurrentConfig( sm_bstrForceSignIn,
                                              &vForceLogin );
    if ( FAILED( hr ) )
    {
        vForceLogin.vt = VT_BOOL;
        vForceLogin.boolVal = VARIANT_FALSE;
    }
    
    VariantInit( &vCoBrandTemplate );
    
    hr = _pPassportManager->GetCurrentConfig( sm_bstrCoBrandTemplate,
                                              &vCoBrandTemplate );
    if ( FAILED( hr ) )
    {
        vCoBrandTemplate.vt = VT_ERROR;
        vCoBrandTemplate.scode = DISP_E_PARAMNOTFOUND;
    }
    
    VariantInit( &vSecureLevel );
    
    hr = _pPassportManager->GetCurrentConfig( sm_bstrSecureLevel,
                                              &vSecureLevel );
    if ( FAILED( hr ) )
    {
        vSecureLevel.vt = VT_I4;
        vSecureLevel.lVal = 10;
    }
    
    //
    // Make this a secure return URL if needed (lame)
    //
    
    if ( vSecureLevel.lVal > 0 )
    {
        if ( _wcsnicmp( strOriginalUrl.QueryStr(), L"https://", 8 ) != 0 )
        {
            STACK_STRU(         strTemp, 256 );
            
            //
            // Must be a nonsecure url
            //
            
            DBG_ASSERT( _wcsnicmp( strOriginalUrl.QueryStr(), L"http://", 7 ) == 0 );
            
            hr = strTemp.Copy( L"https://" );
            if ( FAILED( hr ) )
            {
                return hr;
            }
            
            hr = strTemp.Append( strOriginalUrl.QueryStr() + 7 );
            if ( FAILED( hr ) )
            {
                return hr;
            }
            
            bstrOriginalUrl = SysAllocString( strTemp.QueryStr() );
        }
        else
        {
            //
            // Just use the original URL
            //
        
            bstrOriginalUrl = SysAllocString( strOriginalUrl.QueryStr() );
        }
    }
    else
    {
        //
        // Just use the original URL
        //
        
        bstrOriginalUrl = SysAllocString( strOriginalUrl.QueryStr() );
        
    }
    
    if ( bstrOriginalUrl == NULL )
    {
        return HRESULT_FROM_WIN32( GetLastError() );
    }        

    VariantInit( &vNoParam );

    VariantInit( &vReturnURL );
    vReturnURL.vt = VT_BSTR;
    vReturnURL.bstrVal = bstrOriginalUrl;
        
    vNoParam.vt = VT_ERROR;
    vNoParam.scode = DISP_E_PARAMNOTFOUND;
        
    hr = _pPassportManager->LoginUser( vReturnURL,
                                       vTimeWindow,
                                       vForceLogin,
                                       vCoBrandTemplate,
                                       vNoParam,
                                       vNoParam,
                                       vNoParam,
                                       vSecureLevel,
                                       vNoParam );

    if ( FAILED( hr ) )
    {
        goto Finished;
    }

Finished:

    VariantClear( &vReturnURL );
    
    return hr;
}

HRESULT
PASSPORT_AUTH_PROVIDER::Initialize(
    DWORD               dwInternalId
)
/*++

Routine Description:

    Initialize passport authentication provider

Arguments:

    None

Return Value:

    HRESULT

--*/
{    
    SetInternalId( dwInternalId );

    //
    // We defer initialization of passport manager crap until we really 
    // need it.  Why?  Because loading their DLLs causes a process-wide
    // perf hit with string compares.  This hit is killing ASP perf
    //

    if( !INITIALIZE_CRITICAL_SECTION( &_csInitLock ) )
    {
        return HRESULT_FROM_WIN32( GetLastError() );
    }

    _fInitialized = FALSE;
    
    return NO_ERROR;
}
    
VOID
PASSPORT_AUTH_PROVIDER::Terminate(
    VOID
)
/*++

Routine Description:

    Terminate passport authentication provider

Arguments:

    None

Return Value:

    None

--*/
{
    if ( _fInitialized )
    {
        PASSPORT_CONTEXT::Terminate();
        _fInitialized = FALSE;
    }
    
    DeleteCriticalSection( &_csInitLock );
}

HRESULT
PASSPORT_AUTH_PROVIDER::DoesApply(
    W3_MAIN_CONTEXT *       pMainContext,
    BOOL *                  pfApplies
)
/*++

Routine Description:

    Check whether Passport applies to this request

Arguments:

    pMainContext - Main context
    pfApplies - Set to TRUE if one of the filters indicates the request applies

Return Value:

    HRESULT

--*/
{
    URL_CONTEXT *                       pUrlContext;
    W3_METADATA *                       pMetaData;
    PASSPORT_CONTEXT *                  pPassportContext;
    W3_FILTER_CONTEXT *                 pFilterContext;
    HRESULT                             hr = S_OK;
    STACK_STRA(                         strReturnCookie, 256 );
    BOOL                                fTweenerHandled = FALSE;
    
    if ( pMainContext == NULL ||
         pfApplies == NULL )
    {
        DBG_ASSERT( FALSE );
        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }
    
    *pfApplies = FALSE;
    
    //
    // Before we call into filters, check whether custom auth is enabled.
    // This is a departure from the other protocols, but is the practical 
    // thing to do, since we don't want to call into arbitrary code (or
    // Passport Manager) on every request.
    //
    
    pUrlContext = pMainContext->QueryUrlContext();
    DBG_ASSERT( pUrlContext != NULL );
    
    pMetaData = pUrlContext->QueryMetaData();
    DBG_ASSERT( pMetaData != NULL );
    
    if ( !pMetaData->QueryAuthTypeSupported( MD_AUTH_PASSPORT ) )
    {
        return NO_ERROR;
    }
    
    //
    // Ok.  We need to do passport stuff.  Initialize the passport stuff
    // now if needed
    //
    
    if ( !_fInitialized )
    {
        EnterCriticalSection( &_csInitLock );
       
        if ( !_fInitialized )
        {
            hr = PASSPORT_CONTEXT::Initialize();
            if ( SUCCEEDED( hr ) )
            {
                _fInitialized = TRUE;        
            }
        }
        
        LeaveCriticalSection( &_csInitLock );
    }
    
    if ( !_fInitialized )
    {
        DBG_ASSERT( FAILED( hr ) );
        return hr;
    }
    
    //
    // Get a filter context since we'll need it now to ask passport manager
    // whether the current request applies
    //
    
    pFilterContext = pMainContext->QueryFilterContext();
    if ( pFilterContext == NULL )
    {
        return HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );
    }   
    
    //
    // Create a passport manager
    //

    pPassportContext = new (pMainContext) PASSPORT_CONTEXT; 
    if ( pPassportContext == NULL )
    {
        return HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );
    }  
    
    hr = pPassportContext->Create( pFilterContext );
    if ( FAILED( hr ) )
    {
        delete pPassportContext;
        return hr;
    } 
    
    pMainContext->SetContextState( pPassportContext );
    
    //
    // OK.  Do some weird Tweener crap.  Check the request for magic and if
    // we see it, we avoid Passport Manager altogether
    //
    
    hr = DoTweenerSpecialCase( pMainContext,
                               &fTweenerHandled );
    if ( FAILED( hr ) )
    {
        return hr;
    }                                
    
    if ( fTweenerHandled )
    {
        //
        // We have done our thing.  Just return success.  We'll let the
        // DoAuthenticate send the response
        //

        *pfApplies = TRUE;
        
        pPassportContext->SetTweener( TRUE );
        
        return NO_ERROR;
    }
    
    //
    // Does this request look destined for passport?
    //
    
    hr = pPassportContext->DoesApply( pFilterContext->QueryFC(),
                                      pfApplies,
                                      &strReturnCookie );
    if ( FAILED( hr ) )
    {
        return hr;
    } 
    
    //
    //
    // If a cookie was set, add it to the response
    //
    
    if ( !strReturnCookie.IsEmpty() )
    {
        hr = pFilterContext->AddResponseHeaders( strReturnCookie.QueryStr() );
        if ( FAILED( hr ) )
        {
            return hr;
        }
    }
    
    return NO_ERROR;
}
                                        
HRESULT
PASSPORT_AUTH_PROVIDER::DoAuthenticate(
    W3_MAIN_CONTEXT *       pMainContext,
    BOOL *                  pfFilterFinished
)
/*++

Routine Description:

    Allows filter which applies to actually authenticate the request

Arguments:

    pMainContext - Main context
    pfFilterFinished - Set to TRUE if filter wants out

Return Value:

    HRESULT

--*/
{
    W3_METADATA *                   pMetaData;
    URL_CONTEXT *                   pUrlContext;    
    TOKEN_CACHE_ENTRY *             pToken = NULL;
    PASSPORT_USER_CONTEXT *         pUserContext;
    HRESULT                         hr;
    PASSPORT_CONTEXT *              pPassportContext;
    W3_RESPONSE *                   pResponse;
    STACK_STRU(                     strAuthUser, 256 );
    STACK_STRU(                     strRemoteUser, 256 );
    STACK_STRU(                     strDomainName, 256 );
    
    if ( pMainContext == NULL || 
         pfFilterFinished == NULL )
    {
        DBG_ASSERT( FALSE );
        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }
    
    *pfFilterFinished = FALSE;

    //
    // We must be initialized!
    //
    
    DBG_ASSERT( _fInitialized );

    //
    // We must be supported by metadata
    //
    
    pUrlContext = pMainContext->QueryUrlContext();
    DBG_ASSERT( pUrlContext != NULL );
    
    pMetaData = pUrlContext->QueryMetaData();
    DBG_ASSERT( pMetaData != NULL );

    DBG_ASSERT( pMetaData->QueryAuthTypeSupported( MD_AUTH_PASSPORT ) );

    //
    // Get the saved passport state, we better be able to find it!
    //
    
    pPassportContext = (PASSPORT_CONTEXT*) pMainContext->QueryContextState();
    DBG_ASSERT( pPassportContext != NULL );

    //
    // Before we go any further, check whether we've already Tweenerized this
    // request.  If we have, the response is already setup.  Just bail
    //
    
    if ( pPassportContext->QueryIsTweener() )
    {
        return NO_ERROR;
    }
    
    //
    // Choose a domain for the logon.  If the metabase domain is set, use it,
    // otherwise choose the default domain name
    //
    
    if ( pMetaData->QueryDomainName() == NULL ||
         pMetaData->QueryDomainName()[ 0 ] == L'\0' )
    {
        //
        // If we're a member of a domain, use that domain name
        //
        
        if ( W3_STATE_AUTHENTICATION::QueryIsDomainMember() )
        {
            hr = strDomainName.Copy( W3_STATE_AUTHENTICATION::QueryMemberDomainName() );
        }
        else
        {
            hr = strDomainName.Copy( W3_STATE_AUTHENTICATION::QueryDefaultDomainName() );
        }
        
        if ( FAILED( hr ) )
        {
            return hr;
        }    
    }
    else
    {
        //
        // Use the metabase domain name
        //
        
        hr = strDomainName.Copy( pMetaData->QueryDomainName() );
        if ( FAILED( hr ) )
        {
            return hr;
        }
    }
    
    //
    // Lets authenticate
    //
    
    hr = pPassportContext->DoAuthenticate( pMainContext,
                                           &pToken,
                                           &strAuthUser,
                                           &strRemoteUser,
                                           strDomainName );
    if ( FAILED( hr ) )
    {
        //
        // Setup the 401 response
        //
        
        DBG_ASSERT( pToken == NULL );
        
        pMainContext->QueryResponse()->SetStatus( HttpStatusUnauthorized,
                                                  Http401BadLogon );
    
        return NO_ERROR;
    }
    
    //
    // Create a user context
    //
    
    pUserContext = new PASSPORT_USER_CONTEXT( this );
    if ( pUserContext == NULL )
    {
        pToken->DereferenceCacheEntry();
        pToken = NULL;

        return HRESULT_FROM_WIN32( GetLastError() );
    }
    
    hr = pUserContext->Create( pToken,
                               strAuthUser,
                               strRemoteUser );
    if ( FAILED( hr ) )
    {
        pToken->DereferenceCacheEntry();
        pToken = NULL;

        pUserContext->DereferenceUserContext();
        pUserContext = NULL;
    }
    
    pMainContext->SetUserContext( pUserContext );
    
    return NO_ERROR;
}

HRESULT
PASSPORT_AUTH_PROVIDER::EscapeAmpersands(
    STRA &                  strUrl
)
/*++

Routine Description:

    Sigh.  A special function to escape ampersands so passport is happy

Arguments:

    strUrl - String to escape

Return Value:

    HRESULT

--*/
{
    STACK_STRA(             strTemp, 256 );
    HRESULT                 hr;
    CHAR *                  pszCursor;
    CHAR *                  pszAmpersand;
    
    pszCursor = strUrl.QueryStr();
    
    pszAmpersand = strchr( pszCursor, '&' );
    while ( pszAmpersand != NULL )
    {
        hr = strTemp.Append( pszCursor, DIFF( pszAmpersand - pszCursor ) );
        if ( FAILED( hr ) )
        {
            return hr;
        }
        
        hr = strTemp.Append( "%26" );
        if ( FAILED( hr ) )
        {
            return hr;
        }
        
        pszCursor = pszAmpersand + 1;
        
        pszAmpersand = strchr( pszCursor, '&' );
    }
    
    hr = strTemp.Append( pszCursor );
    if ( FAILED( hr ) )
    {
        return hr;
    }
    
    return strUrl.Copy( strTemp );
}

HRESULT
PASSPORT_AUTH_PROVIDER::OnAccessDenied(
    W3_MAIN_CONTEXT *       pMainContext
)
/*++

Routine Description:

    If we are logged on, present an acecss denied page.  Otherwise, 
    present the redirect

Arguments:

    pMainContext - Main context

Return Value:

    HRESULT

--*/
{
    W3_METADATA *                   pMetaData;
    URL_CONTEXT *                   pUrlContext;    
    HRESULT                         hr = S_OK;
    PASSPORT_CONTEXT *              pPassportContext;
    STACK_STRU(                     strRedirect, 256 );
    STACK_STRA(                     strReturnUrl, 256 );
    STACK_STRU(                     strUnicodeReturnUrl, 256 );
    W3_FILTER_CONTEXT *             pFilterContext = NULL;
    STACK_STRA(                     strRawUrl, 256 );
    W3_RESPONSE *                   pResponse;
    STACK_STRA(                     strAuthenticateHeader, 256 );
    
    if ( pMainContext == NULL )
    {
        DBG_ASSERT( FALSE );
        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }

    //
    // We must be supported by metadata
    //
    
    pUrlContext = pMainContext->QueryUrlContext();
    DBG_ASSERT( pUrlContext != NULL );
    
    pMetaData = pUrlContext->QueryMetaData();
    DBG_ASSERT( pMetaData != NULL );

    DBG_ASSERT( pMetaData->QueryAuthTypeSupported( MD_AUTH_PASSPORT ) );

    //
    // Sigh.  Have to check whether a passport challenge is already
    // setup.  If so, just NOP
    //

    pResponse = pMainContext->QueryResponse();
    DBG_ASSERT( pResponse != NULL );
    
    hr = pResponse->GetHeader( "WWW-Authenticate", &strAuthenticateHeader );
    if ( SUCCEEDED( hr ) )
    {
        if ( _strnicmp( strAuthenticateHeader.QueryStr(),
                        "Passport1.4 ",
                        12 ) == 0 )
        {
            //
            // Challenge already there.  Just NOP
            //
            
            return NO_ERROR;
        }
    }
    
    //
    // In some cases (too complicated to explain), we might actually get 
    // called on AccessDenied() before anything else.  Therefore we do the 
    // same deferred init here
    //
    
    if ( !_fInitialized )
    {
        EnterCriticalSection( &_csInitLock );
       
        if ( !_fInitialized )
        {
            hr = PASSPORT_CONTEXT::Initialize();
            if ( SUCCEEDED( hr ) )
            {
                _fInitialized = TRUE;        
            }
        }
        
        LeaveCriticalSection( &_csInitLock );
    }
    
    if ( !_fInitialized )
    {
        DBG_ASSERT( FAILED( hr ) );
        return hr;
    }

    //
    // Get the saved passport state, we better be able to find it!
    //
    
    pPassportContext = (PASSPORT_CONTEXT*) pMainContext->QueryContextState( CONTEXT_STATE_AUTHENTICATION );
    if ( pPassportContext == NULL )
    {
        pFilterContext = pMainContext->QueryFilterContext();
        if ( pFilterContext == NULL )
        {
            return HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );
        }   
    
        //
        // Build a context now
        //
        
        pPassportContext = new (pMainContext) PASSPORT_CONTEXT; 
        if ( pPassportContext == NULL )
        {
            return HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );
        }  
    
        hr = pPassportContext->Create( pFilterContext );
        if ( FAILED( hr ) )
        {
            delete pPassportContext;
            return hr;
        } 
    
        pMainContext->SetContextState( pPassportContext );
    }
    
    //
    // If we have authenticated, then we'll want to send a local redirect
    // to an access denied page.  Otherwise, we'll send a 302 redirect
    //
    
    if ( !pPassportContext->QueryIsAuthenticated() )
    {
        //
        // Ok.  Before we ask PassportManager for the authentication URL
        // to redirect to, first check whether the client just cancelled.  If
        // they did we will redirect to the default page.
        //
        
        if ( pPassportContext->QueryUserError() )
        {
            BOOL                fDidRedirect = FALSE;
            
            hr = pPassportContext->SetupDefaultRedirect( pMainContext, &fDidRedirect );
            if ( FAILED( hr ) || fDidRedirect )
            {
                return hr;
            }
            
            //
            // If we're here, then there was no DefaultRedirect configured in passport
            //
            // Just set the passport forbidden error
            //
            
            pMainContext->QueryResponse()->SetStatus( HttpStatusForbidden,
                                                      Http403PassportLoginFailure ); 
                                                      
            return NO_ERROR;
        }
        
        //
        // We want a URL without the extra :80
        //
        
        hr = pMainContext->QueryRequest()->GetRawUrl( &strRawUrl );
        if ( FAILED( hr ) )
        {
            return hr;
        }
        
        hr = pMainContext->QueryRequest()->BuildFullUrl( strRawUrl,
                                                         &strReturnUrl,
                                                         FALSE );
        if ( FAILED( hr ) )
        {
            return hr;
        }
        
        hr = strReturnUrl.Escape();
        if ( FAILED( hr ) )
        {
            return hr;
        }
        
        hr = EscapeAmpersands( strReturnUrl );
        if ( FAILED( hr ) )
        {
            return hr;
        }
        
        hr = strUnicodeReturnUrl.CopyA( strReturnUrl.QueryStr() );
        if ( FAILED( hr ) )
        {
            return hr;
        }
        
        hr = pPassportContext->OnChallenge( strUnicodeReturnUrl );
        if ( FAILED( hr ) )
        {
            return hr;
        }
    }
    
    return NO_ERROR;
}

HRESULT
PASSPORT_AUTH_PROVIDER::DoTweenerSpecialCase(
    W3_MAIN_CONTEXT *           pMainContext,
    BOOL *                      pfTweenerHandled
)
/*++

Routine Description:

    Handle Tweener crap

Arguments:

    pMainContext - Main context
    pfTweenerHandled - Set to TRUE if tweener crap was done 

Return Value:

    HRESULT

--*/
{
    STACK_STRU(             strQueryString, 512 );
    STACK_STRA(             strTweenerUrl, 512 );
    HRESULT                 hr;
    W3_RESPONSE *           pResponse;
    W3_REQUEST *            pRequest;
    STACK_STRA(             strAuthenticateHeader, 512 );
    CHAR *                  pszAuthenticateHeader = NULL;
    CHAR *                  pszStupid;
    CHAR *                  pszBizarre;
    CHAR *                  pszAcceptAuth;
    WCHAR *                 pszTweenerMagic;
    STACK_STRA(             strAcceptAuth, 32 );
    BOOL                    fSendRedirect = TRUE;
    
    if ( pMainContext == NULL ||
         pfTweenerHandled == NULL )
    {
        DBG_ASSERT( FALSE );
        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }
    
    *pfTweenerHandled = FALSE;
    
    pResponse = pMainContext->QueryResponse();
    DBG_ASSERT( pResponse != NULL );

    pRequest = pMainContext->QueryRequest();
    DBG_ASSERT( pRequest != NULL );
    
    //
    // First check for a query string, if there isn't one, we're done
    // 
    
    hr = pMainContext->QueryRequest()->GetQueryString( &strQueryString );
    if ( FAILED( hr ) )
    {
        return hr;
    }
    
    if ( strQueryString.QueryStr()[ 0 ] == L'\0' )
    {
        //
        // No query string.  We're done.  
        //
        
        return NO_ERROR;
    }
    
    //
    // Check the query string for the magic "msppchlg=1&mspplogin=" string
    //

    pszTweenerMagic = wcsstr( strQueryString.QueryStr(), MAGIC_TWEENER_STRING );
    if ( pszTweenerMagic == NULL )
    {
        return NO_ERROR;
    }    
    
    //
    // The next part of the string should be the URL
    //

    hr = strTweenerUrl.CopyWToUTF8Unescaped( pszTweenerMagic + MAGIC_TWEENER_STRING_LEN );
    if ( FAILED( hr ) )
    {
        return hr;
    }   
    
    strTweenerUrl.Unescape(); 
    
    //
    // Start generating the response
    //
    
    hr = pResponse->SetHeaderByReference( HttpHeaderContentType,
                                          "text/html", 
                                          9 );
    if ( FAILED( hr ) )
    {
        return hr;
    }
    
    hr = pResponse->SetHeader( HttpHeaderLocation,
                               strTweenerUrl.QueryStr(),
                               (USHORT)strTweenerUrl.QueryCCH() );
    if ( FAILED( hr ) )
    {
        return hr;
    }
    
    //
    // Calculate the authenticate header.  This is the query string with
    // in the tweener URL
    //
    
    pszAuthenticateHeader = strchr( strTweenerUrl.QueryStr(), '?' );
    if ( pszAuthenticateHeader == NULL )
    {
        return NO_ERROR;
    }
    else
    {
        pszAuthenticateHeader++;
    }
    
    hr = strAuthenticateHeader.Copy( "Passport1.4 " );
    if ( FAILED( hr ) )
    {
        return hr;
    }
    
    hr = strAuthenticateHeader.Append( pszAuthenticateHeader );
    if ( FAILED( hr ) )
    {
        return hr;
    }
    
    pszBizarre = strchr( strAuthenticateHeader.QueryStr(), '&' );
    while ( pszBizarre != NULL )
    {
        *pszBizarre = ',';
        pszBizarre++;
        pszBizarre = strchr( pszBizarre, '&' );
    }
    
    hr = pResponse->SetHeader( "WWW-Authenticate",
                               16,
                               strAuthenticateHeader.QueryStr(),
                               (USHORT)strAuthenticateHeader.QueryCCH() );
    if ( FAILED( hr ) )
    {
        return hr;
    }
    
    //
    // Finally, if this client supports it, return a 401, else a 302
    //
    
    pszAcceptAuth = pRequest->GetHeader( "Accept-Auth" );
    if ( pszAcceptAuth != NULL )
    {
        hr = strAcceptAuth.Copy( pszAcceptAuth );
        if ( FAILED( hr ) )
        {
            return hr;
        }
        
        _strupr( strAcceptAuth.QueryStr() );
        
        if ( strstr( strAcceptAuth.QueryStr(), "PASSPORT1.4" ) != NULL )
        {
            fSendRedirect = FALSE;
        }
    }
    
    if ( fSendRedirect )
    {
        pResponse->SetStatus( HttpStatusRedirect );
    }
    else
    {
        pResponse->SetStatus( HttpStatusUnauthorized,
                              Http401BadLogon );
    }
    
    *pfTweenerHandled = TRUE;
    
    return NO_ERROR;
}
    
HRESULT
PASSPORT_USER_CONTEXT::Create(
    TOKEN_CACHE_ENTRY *         pToken,
    STRU &                      strAuthUser,
    STRU &                      strRemoteUser
)
/*++

Routine Description:

    Create a user context based off token

Arguments:

    pToken - Cached token
    strAuthUser - AUTH_USER
    strRemoteUser - REMOTE_USER

Return Value:

    HRESULT

--*/
{
    HRESULT             hr;

    if ( pToken == NULL )
    {
        DBG_ASSERT( FALSE );
        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }

    hr = _strAuthUser.Copy( strAuthUser );
    if ( FAILED( hr ) )
    {
        return hr;
    }
    
    hr = _strRemoteUser.Copy( strRemoteUser );
    if ( FAILED( hr ) )
    {
        return hr;
    }
    
    _pToken = pToken;

    return NO_ERROR;
}

HANDLE
PASSPORT_USER_CONTEXT::QueryPrimaryToken(
    VOID
)
/*++

Routine Description:

    Get primary token for this user

Arguments:

    None

Return Value:

    Token handle

--*/
{
    DBG_ASSERT( _pToken != NULL );
    
    return _pToken->QueryPrimaryToken();
}

HANDLE
PASSPORT_USER_CONTEXT::QueryImpersonationToken(
    VOID
)
/*++

Routine Description:

    Get impersonation token for this user

Arguments:

    None

Return Value:

    Token handle

--*/
{
    DBG_ASSERT( _pToken != NULL );
    
    return _pToken->QueryImpersonationToken();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\iisplus\ulw3\mimemap.cxx ===
/*++

   Copyright    (c)    2000    Microsoft Corporation

   Module Name :
     mimemap.cxx

   Abstract:
     Store and retrieve mime-mapping for file types

   Author:
     Murali R. Krishnan (MuraliK)  10-Jan-1995

   Environment:
     Win32 - User Mode

   Project:
     UlW3.dll

   History:
     Anil Ruia          (AnilR)    27-Mar-2000   Ported to IIS+
--*/

#include "precomp.hxx"

const WCHAR *g_pszDefaultFileExt  = L"*";
const CHAR  *g_pszDefaultMimeType = "application/octet-stream";

MIME_MAP *g_pMimeMap = NULL;

HRESULT MIME_MAP::InitMimeMap()
/*++
  Synopsis
    This function reads the mimemap stored either as a MULTI_SZ or as a
    sequence of REG_SZ

  Returns:
    HRESULT
--*/
{
    DBG_ASSERT(!IsValid());

    // First read metabase (common types will have priority)
    HRESULT hr = InitFromMetabase();

    if (SUCCEEDED(hr))
    {
        m_fValid = TRUE;
    }

    return hr;
}

static VOID GetFileExtension(IN  LPWSTR  pszPathName,
                             OUT LPWSTR *ppszExt)
/*++
  Synopsis
    Gets The extension portion from a filename.

  Arguments
    pszPathName:   The full path name (containing forward '/' or '\\' 's)
    ppszExt:       Points to start of extension on return

  Return Value
    None
--*/
{
    LPWSTR pszExt  = (LPWSTR)g_pszDefaultFileExt;

    DBG_ASSERT(ppszExt != NULL);

    if (pszPathName)
    {
        LPWSTR pszLastDot;

        pszLastDot = wcsrchr(pszPathName, L'.');

        if (pszLastDot != NULL)
        {
            LPWSTR pszLastSlash     = wcsrchr(pszPathName, L'/');
            LPWSTR pszLastBackSlash = wcsrchr(pszPathName, L'\\');
            LPWSTR pszLastWhack     = max(pszLastSlash, pszLastBackSlash);

            if (pszLastDot > pszLastWhack)
            {
                // if the dot comes only in the last component, then get ext
                pszExt = pszLastDot + 1;  // +1 to skip last dot.
            }
        }
    }

    *ppszExt = pszExt;
}

VOID MIME_MAP::CreateAndAddMimeMapEntry(
    IN  LPWSTR     pszMimeType,
    IN  LPWSTR     pszExtension)
{
    MIME_MAP_ENTRY   *pEntry = NULL;

    //
    // File extensions, stored by OLE/shell registration UI have leading
    // dot, we need to remove it , as other code won't like it.
    //
    if (pszExtension[0] == L'.')
    {
        pszExtension++;
    }

    //
    // First check if this extension is not yet present
    //
    FindKey(pszExtension, &pEntry);
    if (pEntry)
    {
        pEntry->DereferenceMimeMapEntry();
        return;
    }

    MIME_MAP_ENTRY *pMmeNew;

    pMmeNew = new MIME_MAP_ENTRY(pszMimeType, pszExtension);

    if (!pMmeNew || !pMmeNew->IsValid())
    {
        //
        // unable to create a new MIME_MAP_ENTRY object.
        //
        if (pMmeNew)
        {
            pMmeNew->DereferenceMimeMapEntry();
            pMmeNew = NULL;
        }
        return;
    }

    InsertRecord(pMmeNew);

    pMmeNew->DereferenceMimeMapEntry();
    pMmeNew = NULL;
}

static BOOL ReadMimeMapFromMetabase(OUT MULTISZ *pmszMimeMap)
/*++
  Synopsis
    This function reads the mimemap stored either as a MULTI_SZ or as a
    sequence of REG_SZ and returns a double null terminated sequence of mime
    types on success. If there is any failure, the failures are ignored and
    it returns a NULL.

  Arguments:
    pmszMimeMap: MULTISZ which will contain the MimeMap on success

  Returns:
    BOOL
--*/
{
    MB mb(g_pW3Server->QueryMDObject());

    if (!mb.Open(L"/LM/MimeMap", METADATA_PERMISSION_READ))
    {
        //
        // if this fails, we're hosed.
        //
        DBGPRINTF((DBG_CONTEXT,"Open MD /LM/MimeMap returns %d\n", GetLastError()));
        return FALSE;
    }

    if (!mb.GetMultisz(L"", MD_MIME_MAP, IIS_MD_UT_FILE, pmszMimeMap))
    {
        DBGPRINTF((DBG_CONTEXT,"Unable to read mime map from metabase: %d\n",GetLastError() ));
        return FALSE;
    }

    return TRUE;
}


static MIME_MAP_ENTRY *
ReadAndParseMimeMapEntry(IN OUT LPWSTR *ppszValues)
/*++
    This function parses the string containing next mime map entry and
        related fields and if successful creates a new MIME_MAP_ENTRY
        object and returns it.
    Otherwise it returns NULL.
    In either case, the incoming pointer is updated to point to next entry
     in the string ( past terminating NULL), assuming incoming pointer is a
     multi-string ( double null terminated).

    Arguments:
        ppszValues:  pointer to MULTISZ containing the MimeEntry values.

    Returns:
        On successful MIME_ENTRY being parsed, a new MIME_MAP_ENTRY object.
        On error returns NULL.
--*/
{
    MIME_MAP_ENTRY *pMmeNew = NULL;
    DBG_ASSERT( ppszValues != NULL);
    LPWSTR pszMimeEntry = *ppszValues;

    if ( pszMimeEntry != NULL && *pszMimeEntry != L'\0')
    {
        LPWSTR pszMimeType;
        LPWSTR pszFileExt;
        LPWSTR pszComma;

        pszFileExt = *ppszValues;
        if ((pszComma = wcschr(*ppszValues, L',')) != NULL)
        {
            //
            //  update *ppszValues to contain the next field.
            //
            *ppszValues = pszComma + 1; // goto next field.
            *pszComma = L'\0';

            pszMimeType = *ppszValues;
            *ppszValues += wcslen(*ppszValues) + 1;
        }
        else
        {
            *ppszValues += wcslen(*ppszValues) + 1;
            pszMimeType = L"\0";
        }

        if (*pszMimeType == L'\0')
        {
            DBGPRINTF( ( DBG_CONTEXT,
                        " ReadAndParseMimeEntry()."
                        " Invalid Mime String ( %S)."
                        "MimeType( %08x): %S, FileExt( %08x): %S\n",
                        pszMimeEntry,
                        pszMimeType, pszMimeType,
                        pszFileExt,  pszFileExt
                        ));

            DBG_ASSERT( pMmeNew == NULL);
        }
        else
        {
            // Strip leading dot.

            if (*pszFileExt == '.')
            {
                pszFileExt++;
            }

            pMmeNew = new MIME_MAP_ENTRY( pszMimeType, pszFileExt);

            if ( pMmeNew != NULL && !pMmeNew->IsValid())
            {
                //
                // unable to create a new MIME_MAP_ENTRY object. Delete it.
                //
                pMmeNew->DereferenceMimeMapEntry();
                pMmeNew = NULL;
            }
        }
    }

    return pMmeNew;
}


MIME_MAP::MIME_MAP(LPWSTR pszMimeMappings)
    : CTypedHashTable<MIME_MAP, MIME_MAP_ENTRY, LPWSTR>("MimeMapper"),
      m_fValid                                         (FALSE)
{
    BOOL fOk;

    while (*pszMimeMappings != L'\0')
    {
        MIME_MAP_ENTRY *pMmeNew;

        pMmeNew = ReadAndParseMimeMapEntry(&pszMimeMappings);

        //
        // If New MimeMap entry found, Create a new object and update list
        //

        if (pMmeNew != NULL)
        {
            fOk = (InsertRecord(pMmeNew) != LK_ALLOC_FAIL);

            pMmeNew->DereferenceMimeMapEntry();
            pMmeNew = NULL;

            if (!fOk)
            {
                return;
            }
        }
    } // while

    m_fValid = TRUE;
}


HRESULT MIME_MAP::InitFromMetabase()
/*++
  Synopsis
    This function reads the MIME_MAP entries from metabase and parses
    the entry, creates MIME_MAP_ENTRY object and adds the object to list
    of MimeMapEntries.

  Returns:
    HRESULT

  Format of Storage in registry:
    The entries are stored in NT in tbe metabase with a list of values in
    following format: file-extension, mimetype

--*/
{
    LPTSTR  pszValue;
    MULTISZ mszMimeMap;

    //
    //  There is some registry key for Mime Entries. Try open and read.
    //
    if (!ReadMimeMapFromMetabase(&mszMimeMap))
    {
        return HRESULT_FROM_WIN32(GetLastError());
    }

    pszValue = (LPWSTR)mszMimeMap.QueryPtr();

    //
    // Parse each MimeEntry in the string containing list of mime objects.
    //
    while (*pszValue != L'\0')
    {
        MIME_MAP_ENTRY *pMmeNew;
        BOOL            fOk;

        pMmeNew = ReadAndParseMimeMapEntry( &pszValue);

        //
        // If New MimeMap entry found, Create a new object and update list
        //

        if (pMmeNew != NULL)
        {
            fOk = (InsertRecord(pMmeNew) != LK_ALLOC_FAIL);

            pMmeNew->DereferenceMimeMapEntry();
            pMmeNew = NULL;

            if (!fOk)
            {
                return HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
            }
        }
    } // while

    return S_OK;
}


HRESULT InitializeMimeMap()
/*++

  Creates a new mime map object and loads the registry entries from
    under this entry from  \\MimeMap.

--*/
{
    HRESULT hr = E_FAIL;

    DBG_ASSERT(g_pMimeMap == NULL);

    g_pMimeMap = new MIME_MAP();

    if (g_pMimeMap == NULL)
    {
        return HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
    }

    if (FAILED(hr = g_pMimeMap->InitMimeMap()))
    {
        DBGPRINTF((DBG_CONTEXT,"InitMimeMap failed with hr %x\n", hr));

        delete g_pMimeMap;
        g_pMimeMap = NULL;
    }

    return hr;
} // InitializeMimeMap()


VOID CleanupMimeMap()
{
    if ( g_pMimeMap != NULL)
    {
        delete g_pMimeMap;
        g_pMimeMap = NULL;
    }
} // CleanupMimeMap()

HRESULT SelectMimeMappingForFileExt(IN  WCHAR    *pszFilePath,
                                    IN  MIME_MAP *pMimeMap,
                                    OUT STRA     *pstrMimeType,
                                    OUT BOOL     *pfUsedDefault)
/*++
  Synopsis
    Obtains the mime type for file based on the file extension.

  Arguments
    pszFilePath     pointer to path for the given file
    pMimeMap        mimemap table to use for lookup
    pstrMimeType    pointer to string to store the mime type on return
    pfUsedDefault   (optional) set to TRUE if default mimemapping was chosen

  Returns:
    HRESULT
--*/
{
    HRESULT hr = S_OK;

    DBG_ASSERT (pstrMimeType != NULL);

    if (pfUsedDefault != NULL)
    {
        *pfUsedDefault = FALSE;
    }

    if (pszFilePath != NULL && *pszFilePath)
    {
        LPWSTR pszExt;
        MIME_MAP_ENTRY *pMmeMatch = NULL;

        GetFileExtension(pszFilePath, &pszExt);
        DBG_ASSERT(pszExt);

        //
        // Successfully got extension. Search in the table
        //
        if (pMimeMap)
        {
            pMimeMap->FindKey(pszExt, &pMmeMatch);

            if (!pMmeMatch)
            {
                pMimeMap->FindKey(L"*", &pMmeMatch);
            }
        }

        //
        // If not found, lookup in the global table
        //
        if (!pMmeMatch)
        {
            g_pMimeMap->FindKey(pszExt, &pMmeMatch);
        }

        if (!pMmeMatch)
        {
            g_pMimeMap->FindKey(L"*", &pMmeMatch);
        }

        if (pMmeMatch)
        {
            hr = pstrMimeType->CopyW(pMmeMatch->QueryMimeType());

            pMmeMatch->DereferenceMimeMapEntry();
            pMmeMatch = NULL;

            return hr;
        }

        //
        // If it is not in the table, look in the registry, but only if
        // there was an actual extension (GetFileExtension returns '*' if
        // there was no real extension
        //
        if (pszExt[0] != L'*' || pszExt[1] != L'\0')
        {
            HKEY hkeyExtension;

            //
            // Go back to the dot
            //
            pszExt--;

            if (RegOpenKeyEx(HKEY_CLASSES_ROOT,
                             pszExt,
                             0,
                             KEY_READ,
                             &hkeyExtension) == ERROR_SUCCESS)
            {
                WCHAR pszMimeType[MAX_PATH];
                DWORD dwType;
                DWORD cbValue;

                //
                // Now get content type for this extension if present
                //
                cbValue = sizeof pszMimeType;

                if (RegQueryValueEx(hkeyExtension,
                                    L"Content Type",
                                    NULL,
                                    &dwType,
                                    (LPBYTE)pszMimeType,
                                    &cbValue) == ERROR_SUCCESS &&
                    dwType == REG_SZ)
                {
                    g_pMimeMap->CreateAndAddMimeMapEntry(pszMimeType, pszExt);

                    RegCloseKey(hkeyExtension);

                    return pstrMimeType->CopyW(pszMimeType);
                }

                RegCloseKey(hkeyExtension);
            }
        }
    }
    
    if (pfUsedDefault != NULL)
    {
        *pfUsedDefault = TRUE;   
    }
    
    return pstrMimeType->Copy(g_pszDefaultMimeType);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\iisplus\ulw3\rawconnection.cxx ===
/*++

   Copyright    (c)    1999    Microsoft Corporation

   Module Name :
     rawconnection.cxx

   Abstract:
     ISAPI raw data filter support
 
   Author:
     Bilal Alam (balam)             10-Jan-2000

   Environment:
     Win32 - User Mode

   Project:
     ULW3.DLL
--*/

#include "precomp.hxx"
#include "rawconnection.hxx"

RAW_CONNECTION_HASH *    RAW_CONNECTION::sm_pRawConnectionHash;
PTRACE_LOG               RAW_CONNECTION::sm_pTraceLog;
BOOL                     RAW_CONNECTION::sm_fNotifyRawReadData = FALSE;

RAW_CONNECTION::RAW_CONNECTION(
    CONNECTION_INFO *           pConnectionInfo
)
{
    _cRefs = 1;
    _pMainContext = NULL;
    _dwCurrentFilter = INVALID_DLL;
    
    DBG_ASSERT( pConnectionInfo != NULL );

    _hfc.cbSize             = sizeof( _hfc );
    _hfc.Revision           = HTTP_FILTER_REVISION;
    _hfc.ServerContext      = (void *) this;
    _hfc.ulReserved         = 0;
    _hfc.fIsSecurePort      = pConnectionInfo->fIsSecure;
    _hfc.pFilterContext     = NULL;

    _hfc.ServerSupportFunction = RawFilterServerSupportFunction;
    _hfc.GetServerVariable     = RawFilterGetServerVariable;
    _hfc.AddResponseHeaders    = RawFilterAddResponseHeaders;
    _hfc.WriteClient           = RawFilterWriteClient;
    _hfc.AllocMem              = RawFilterAllocateMemory;

    ZeroMemory( &_rgContexts, sizeof( _rgContexts ) );
    
    InitializeListHead( &_PoolHead );

    _pfnSendDataBack = pConnectionInfo->pfnSendDataBack;
    _pvStreamContext = pConnectionInfo->pvStreamContext;
    _LocalAddressType  = pConnectionInfo->LocalAddressType;
    _RemoteAddressType = pConnectionInfo->RemoteAddressType;
    
    if( pConnectionInfo->LocalAddressType == AF_INET )
    {
        memcpy( &_SockLocalAddress,
                &pConnectionInfo->SockLocalAddress,
                sizeof( SOCKADDR_IN ) );
    }
    else if( pConnectionInfo->LocalAddressType == AF_INET6 )
    {
        memcpy( &_SockLocalAddress,
                &pConnectionInfo->SockLocalAddress,
                sizeof( SOCKADDR_IN6 ) );
    }
    else
    {
        DBG_ASSERT( FALSE );
    }
    
    if( pConnectionInfo->RemoteAddressType == AF_INET )
    {
        memcpy( &_SockRemoteAddress,
                &pConnectionInfo->SockRemoteAddress,
                sizeof( SOCKADDR_IN ) );
    }
    else if( pConnectionInfo->RemoteAddressType == AF_INET6 )
    {
        memcpy( &_SockRemoteAddress,
                &pConnectionInfo->SockRemoteAddress,
                sizeof( SOCKADDR_IN6 ) );
    }
    else
    {
        DBG_ASSERT( FALSE );
    }
    
    _RawConnectionId = pConnectionInfo->RawConnectionId;

    _dwSecureNotifications = 0;
    _dwNonSecureNotifications = 0;
    _fNotificationsDisabled = FALSE;

    _liWorkerProcessData.QuadPart = 0;
    _fSkipAtAll = FALSE;
    
    _dwSignature = RAW_CONNECTION_SIGNATURE;
}

RAW_CONNECTION::~RAW_CONNECTION()
{
    FILTER_POOL_ITEM *          pfpi;
    
    _dwSignature = RAW_CONNECTION_SIGNATURE_FREE;

    //
    // Free pool items (is most cases there won't be any since they will
    // have been migrated to the W3_FILTER_CONNECTION_CONTEXT)
    //

    while ( !IsListEmpty( &_PoolHead ) ) 
    {
        pfpi = CONTAINING_RECORD( _PoolHead.Flink,
                                  FILTER_POOL_ITEM,
                                  _ListEntry );

        RemoveEntryList( &pfpi->_ListEntry );

        delete pfpi;
    }
    
    //
    // Disconnect raw connection from main context
    //
    
    if ( _pMainContext != NULL )
    {
        _pMainContext->DereferenceMainContext();
        _pMainContext = NULL;
    }
}

//static
HRESULT
RAW_CONNECTION::Initialize(
    VOID
)
/*++

Routine Description:

    Initialize ISAPI raw data filter crap

Arguments:

    None
    
Return Value:

    HRESULT

--*/
{

    DBG_ASSERT( g_pW3Server != NULL );
    
    DBG_ASSERT( sm_pRawConnectionHash == NULL );
   
#if DBG
    sm_pTraceLog = CreateRefTraceLog( 2000, 0 );
#endif
    
    //
    // Create a UL_RAW_CONNECTION_ID keyed hash table
    //
    
    sm_pRawConnectionHash = new RAW_CONNECTION_HASH;
    if ( sm_pRawConnectionHash == NULL )
    {
        return HRESULT_FROM_WIN32( GetLastError() );
    }
    
    return NO_ERROR;
}

//static
VOID
RAW_CONNECTION::Terminate(
    VOID
)
/*++

Routine Description:

    Terminate raw connection hash table

Arguments:

    None
    
Return Value:

    None

--*/
{
   
    if ( sm_pRawConnectionHash != NULL )
    {
        delete sm_pRawConnectionHash;
        sm_pRawConnectionHash = NULL;
    }

    if ( sm_pTraceLog != NULL )
    {
        DestroyRefTraceLog( sm_pTraceLog );
        sm_pTraceLog = NULL;
    }
}

//static
HRESULT
RAW_CONNECTION::StopListening(
    VOID
)
/*++

Routine Description:

    Begin shutdown by preventing further raw stream messages from UL

Arguments:

    None
    
Return Value:

    HRESULT

--*/
{
    if ( sm_fNotifyRawReadData )
    {
        IsapiFilterTerminate();
    }
    return NO_ERROR;
}

//static
HRESULT
RAW_CONNECTION::StartListening(
    VOID
)
/*++

Routine Description:

    Start listening for stream messages from UL.  Unlike UlAtqStartListen(),
    this routine does NOT block and will return once the initial number
    of outstanding UlFilterAccept() requests have been made

Arguments:

    None
    
Return Value:

    HRESULT

--*/
{
    FILTER_LIST *           pFilterList;
    HRESULT                 hr;
    ISAPI_FILTERS_CALLBACKS sfConfig;

    //
    // Is there a read raw data filter enabled?
    //
    
    pFilterList = FILTER_LIST::QueryGlobalList();
    if ( pFilterList != NULL )
    {
        if ( pFilterList->IsNotificationNeeded( SF_NOTIFY_READ_RAW_DATA,
                                                FALSE ) )
        {
            sm_fNotifyRawReadData = TRUE;
        }
    }

    if ( sm_fNotifyRawReadData )
    {
        //
        // Now configure stream filter DLL to enable ISAPI filter
        // notifications
        //
        
        sfConfig.pfnRawRead = RAW_CONNECTION::ProcessRawRead;    
        sfConfig.pfnRawWrite = RAW_CONNECTION::ProcessRawWrite;
        sfConfig.pfnConnectionClose = RAW_CONNECTION::ProcessConnectionClose;
        sfConfig.pfnNewConnection = RAW_CONNECTION::ProcessNewConnection;
        sfConfig.pfnReleaseContext = RAW_CONNECTION::ReleaseContext;
        
        hr = IsapiFilterInitialize( &sfConfig );
        if ( FAILED( hr ) )
        {
            //
            // Write event in the case if filter failed because
            // HTTPFilter is not running in the inetinfo.exe
            //
            g_pW3Server->LogEvent( W3_EVENT_RAW_FILTER_CANNOT_BE_STARTED_DUE_TO_HTTPFILTER,
                                   0,
                                   NULL );

            sm_fNotifyRawReadData = FALSE;
            return hr;
        }
    }    
    return NO_ERROR;
}

FILTER_LIST *
RAW_CONNECTION::QueryFilterList(
    VOID
)
/*++

Routine Description:

    Return the appropriate filter list to notify.  Before a W3_CONNECTION
    is established, this list will simply be the global filter list.  But 
    once the W3_CONNECTION is established, the list will be the appropriate
    instance filter list

Arguments:

    None
    
Return Value:

    FILTER_LIST *

--*/
{
    W3_FILTER_CONTEXT *         pFilterContext = NULL;
    FILTER_LIST *               pFilterList = FILTER_LIST::QueryGlobalList();
    W3_MAIN_CONTEXT *           pMainContext;
    
    pMainContext = GetAndReferenceMainContext();
    if ( pMainContext != NULL )
    {
        pFilterContext = pMainContext->QueryFilterContext();
        if ( pFilterContext != NULL )
        {
            pFilterList = pFilterContext->QueryFilterList();
            DBG_ASSERT( pFilterList != NULL );
        }
        
        pMainContext->DereferenceMainContext();
    }
    
    return pFilterList;
}

HRESULT
RAW_CONNECTION::DisableNotification(
    DWORD                   dwNotification
)
/*++

Routine Description:

    Disable notification

Arguments:

    None

Return Value:

    HRESULT

--*/
{
    W3_MAIN_CONTEXT *           pMainContext;
    W3_FILTER_CONTEXT *         pFilterContext;
    HRESULT                     hr = NO_ERROR;
    
    pMainContext = GetAndReferenceMainContext();
    if ( pMainContext != NULL )
    {
        pFilterContext = pMainContext->QueryFilterContext();
        if ( pFilterContext != NULL )
        {
            hr = pFilterContext->DisableNotification( dwNotification );
        }
        
        pMainContext->DereferenceMainContext();
    }
    else
    {
        DBG_ASSERT( QueryFilterList() != NULL );

        if ( !_fNotificationsDisabled )
        {
            //
            // All subsequent calls to IsNotificationNeeded() and NotifyFilter() must
            // use local copy of flags to determine action.
            //

            _fNotificationsDisabled = TRUE;

            //
            // Copy notification tables created in the FILTER_LIST objects
            //

            if ( !_BuffSecureArray.Resize( QueryFilterList()->QuerySecureArray()->QuerySize() ) ||
                 !_BuffNonSecureArray.Resize( QueryFilterList()->QueryNonSecureArray()->QuerySize() ) )
            {
                return HRESULT_FROM_WIN32( GetLastError() );
            }

            memcpy( _BuffSecureArray.QueryPtr(),
                    QueryFilterList()->QuerySecureArray()->QueryPtr(),
                    QueryFilterList()->QuerySecureArray()->QuerySize() );

            memcpy( _BuffNonSecureArray.QueryPtr(),
                    QueryFilterList()->QueryNonSecureArray()->QueryPtr(),
                    QueryFilterList()->QueryNonSecureArray()->QuerySize() );
        }
            
        //
        // Disable the appropriate filter in our local table
        //

        ((DWORD*)_BuffSecureArray.QueryPtr())[ _dwCurrentFilter ] &=
                                                            ~dwNotification;
        ((DWORD*)_BuffNonSecureArray.QueryPtr())[ _dwCurrentFilter ] &=
                                                            ~dwNotification;

        //
        // Calculate the aggregate notification status for our local scenario
        // NYI:  Might want to defer this operation?
        //

        _dwSecureNotifications = 0;
        _dwNonSecureNotifications = 0;

        for( DWORD i = 0; i < QueryFilterList()->QueryFilterCount(); i++ )
        {
            _dwSecureNotifications |= ((DWORD*)_BuffSecureArray.QueryPtr())[i];
            _dwNonSecureNotifications |= ((DWORD*)_BuffNonSecureArray.QueryPtr())[i];
        }
    }
    
    return hr;
}


BOOL
RAW_CONNECTION::QueryNotificationChanged(
    VOID
)
/*++

Routine Description:

    Returns whether or not any notifications have been disabled on the fly

Arguments:

    None
    
Return Value:

    BOOL

--*/
{
    W3_FILTER_CONTEXT *         pFilterContext;
    W3_MAIN_CONTEXT *           pMainContext;
    BOOL                        fRet = FALSE;
    
    pMainContext = GetAndReferenceMainContext();
    if ( pMainContext != NULL )
    {
        pFilterContext = pMainContext->QueryFilterContext();
        if ( pFilterContext == NULL )
        {
            fRet = FALSE;
        }
        else
        {
            fRet = pFilterContext->QueryNotificationChanged();
        }
        
        pMainContext->DereferenceMainContext();
    }
    else
    {
        fRet = _fNotificationsDisabled;
    }
    
    return fRet;
}

BOOL
RAW_CONNECTION::QueryRawConnectionNotificationChanged(
    VOID
)
{
    return _fNotificationsDisabled;
}

BOOL
RAW_CONNECTION::IsDisableNotificationNeeded(
    DWORD                   dwFilter,
    DWORD                   dwNotification
)
/*++

Routine Description:

    If a notification was disabled on the fly, then this routine goes thru
    the notification copy path to find whether the given notification is
    indeed enabled

Arguments:

    dwFilter - Filter number
    dwNotification - Notification to check for
    
Return Value:

    BOOL (TRUE is the notification is needed)

--*/
{
    W3_MAIN_CONTEXT *           pMainContext;
    W3_FILTER_CONTEXT *         pFilterContext;
    BOOL                        fRet = FALSE;

    pMainContext = GetAndReferenceMainContext();
    if ( pMainContext != NULL )
    {
        pFilterContext = pMainContext->QueryFilterContext();
        DBG_ASSERT( pFilterContext != NULL );
        
        fRet = pFilterContext->IsDisableNotificationNeeded( dwFilter,
                                                            dwNotification );

        pMainContext->DereferenceMainContext();
    }
    else
    {   
        fRet = _hfc.fIsSecurePort ?
                ((DWORD*)_BuffSecureArray.QueryPtr())[ dwFilter ] & dwNotification :
                ((DWORD*)_BuffNonSecureArray.QueryPtr())[ dwFilter ] & dwNotification;
        fRet = !!fRet;
    }
    
    return fRet;
}

BOOL
RAW_CONNECTION::IsRawConnectionDisableNotificationNeeded(
    DWORD                   dwFilter,
    DWORD                   dwNotification
)
{   
    BOOL    fRet;

    fRet = _hfc.fIsSecurePort ?
            ((DWORD*)_BuffSecureArray.QueryPtr())[ dwFilter ] & dwNotification :
            ((DWORD*)_BuffNonSecureArray.QueryPtr())[ dwFilter ] & dwNotification;
    fRet = !!fRet;

    return fRet;
}

PVOID
RAW_CONNECTION::QueryClientContext(
    DWORD                   dwFilter
)
/*++

Routine Description:

    Retrieve the filter client context for the given filter

Arguments:

    dwFilter - Filter number
    
Return Value:

    Context pointer

--*/
{
    W3_MAIN_CONTEXT *           pMainContext;
    PVOID                       pvRet;
    
    //
    // If we have a main context associated, then use its merged context 
    // list
    //
    
    pMainContext = GetAndReferenceMainContext();
    if ( pMainContext == NULL )
    {
        pvRet = _rgContexts[ dwFilter ];
    }
    else
    {
        pvRet = pMainContext->QueryFilterContext()->QueryClientContext( dwFilter );
        pMainContext->DereferenceMainContext();        
    }
    
    return pvRet;
}

VOID
RAW_CONNECTION::SetClientContext(
    DWORD                   dwFilter,
    PVOID                   pvContext
)
/*++

Routine Description:

    Set client context for the given filter

Arguments:

    dwFilter - Filter number
    pvContext - Client context
    
Return Value:

    None

--*/
{
    W3_MAIN_CONTEXT *           pMainContext;
    
    //
    // If we have a main context, use its merged context list
    //
   
    pMainContext = GetAndReferenceMainContext();
    if ( pMainContext == NULL )
    {
        _rgContexts[ dwFilter ] = pvContext;
    }
    else
    {
        pMainContext->QueryFilterContext()->SetClientContext( dwFilter,
                                                              pvContext );
        pMainContext->DereferenceMainContext();
    }
}

VOID
RAW_CONNECTION::SetLocalClientContext(
    DWORD                   dwFilter,
    PVOID                   pvContext
)
/*++

Routine Description:

    Set client context for the given filter into
    the local array.

Arguments:

    dwFilter - Filter number
    pvContext - Client context
    
Return Value:

    None

--*/
{
    _rgContexts[ dwFilter ] = pvContext;
}

HRESULT
RAW_CONNECTION::GetLimitedServerVariables(
    LPSTR                       pszVariableName,
    PVOID                       pvBuffer,
    PDWORD                      pdwSize
)
/*++

Routine Description:

    Get the server variables which are possible given that we haven't parsed
    the HTTP request yet

Arguments:

    pszVariableName - Variable name
    pvBuffer - Buffer to receive variable data
    pdwSize - On input size of buffer, on output the size needed
    
Return Value:

    HRESULT

--*/
{
    STACK_STRA(         strVariable, 256 );
    HRESULT             hr = NO_ERROR;
    CHAR                achNumber[ 64 ];
    USHORT              Port;

    if ( pszVariableName == NULL )
    {
        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }
   
    if ( strcmp( pszVariableName, "SERVER_PORT" ) == 0 || 
         strcmp( pszVariableName, "REMOTE_PORT" ) == 0 )
    {
        if( pszVariableName[ 0 ] == 'S' )
        {
            if( _LocalAddressType == AF_INET )
            {
                Port = ntohs( _SockLocalAddress.ipv4SockAddress.sin_port );
            }
            else if( _LocalAddressType == AF_INET6 )
            {
                Port = ntohs( _SockLocalAddress.ipv6SockAddress.sin6_port );
            }
            else
            {
                DBG_ASSERT( FALSE );
            }
        }
        else
        {
            if( _RemoteAddressType == AF_INET )
            {
                Port = ntohs( _SockRemoteAddress.ipv4SockAddress.sin_port );
            }
            else if( _LocalAddressType == AF_INET6 )
            {
                Port = ntohs( _SockRemoteAddress.ipv6SockAddress.sin6_port );
            }
            else
            {
                DBG_ASSERT( FALSE );
            }
        }
                
        _itoa( Port, achNumber, 10 );
        
        hr = strVariable.Copy( achNumber );
    } 
    else if ( strcmp( pszVariableName, "REMOTE_ADDR" ) == 0 || 
              strcmp( pszVariableName, "REMOTE_HOST" ) == 0 ||
              strcmp( pszVariableName, "LOCAL_ADDR" ) == 0 ||
              strcmp( pszVariableName, "SERVER_NAME" ) == 0 )
    {
        DWORD           dwAddr;
        SOCKADDR_IN6    IPv6Address;
        CHAR            szNumericAddress[ NI_MAXHOST ];

        if( pszVariableName[ 0 ] == 'L' ||
            pszVariableName[ 0 ] == 'S' )
        {
            if( _LocalAddressType == AF_INET )
            {
                dwAddr = ntohl( _SockLocalAddress.ipv4SockAddress.sin_addr.s_addr );
                hr = TranslateIpAddressToStr( dwAddr, &strVariable );
            }
            else if( _LocalAddressType == AF_INET6 )
            {
                IPv6Address.sin6_family   = AF_INET6;
                IPv6Address.sin6_port     = 
                          _SockLocalAddress.ipv6SockAddress.sin6_port;
                IPv6Address.sin6_flowinfo = 
                          _SockLocalAddress.ipv6SockAddress.sin6_flowinfo;
                IPv6Address.sin6_addr     = 
                          _SockLocalAddress.ipv6SockAddress.sin6_addr;
                IPv6Address.sin6_scope_id = 
                          _SockLocalAddress.ipv6SockAddress.sin6_scope_id;
        
                if( getnameinfo( ( LPSOCKADDR )&IPv6Address,
                                 sizeof( IPv6Address ),
                                 szNumericAddress,
                                 sizeof( szNumericAddress ),
                                 NULL,
                                 0,
                                 NI_NUMERICHOST ) != 0 )
                {
                    hr = HRESULT_FROM_WIN32( WSAGetLastError() );
                }
                else
                {
                    hr = strVariable.Copy( szNumericAddress );
                }
            }
            else
            {
                DBG_ASSERT( FALSE );
            }
        }
        else
        {
            if( _RemoteAddressType == AF_INET )
            {
                dwAddr = ntohl( _SockRemoteAddress.ipv4SockAddress.sin_addr.s_addr );
                hr = TranslateIpAddressToStr( dwAddr, &strVariable );
            }
            else if( _RemoteAddressType == AF_INET6 )
            {
                IPv6Address.sin6_family   = AF_INET6;
                IPv6Address.sin6_port     = 
                          _SockRemoteAddress.ipv6SockAddress.sin6_port;
                IPv6Address.sin6_flowinfo = 
                          _SockRemoteAddress.ipv6SockAddress.sin6_flowinfo;
                IPv6Address.sin6_addr     = 
                          _SockRemoteAddress.ipv6SockAddress.sin6_addr;
                IPv6Address.sin6_scope_id = 
                          _SockRemoteAddress.ipv6SockAddress.sin6_scope_id;
        
                if( getnameinfo( ( LPSOCKADDR )&IPv6Address,
                                 sizeof( IPv6Address ),
                                 szNumericAddress,
                                 sizeof( szNumericAddress ),
                                 NULL,
                                 0,
                                 NI_NUMERICHOST ) != 0 )
                {
                    hr = HRESULT_FROM_WIN32( WSAGetLastError() );
                }
                else
                {
                    hr = strVariable.Copy( szNumericAddress );
                }
            }
            else
            {
                DBG_ASSERT( FALSE );
            }
        }
    }
    else if ( strcmp( pszVariableName, "HTTPS" ) == 0 )
    {
        hr = strVariable.Copy( _hfc.fIsSecurePort ? "on" : "off" );
    }
    else if ( strcmp( pszVariableName, "SERVER_PORT_SECURE" ) == 0 )
    {
        hr = strVariable.Copy( _hfc.fIsSecurePort ? "1" : "0" );
    }
    else if ( strcmp( pszVariableName, "CONTENT_LENGTH" ) == 0 )
    {
        hr = strVariable.Copy( "0" );
    }
    else if ( strcmp( pszVariableName, "SERVER_PROTOCOL" ) == 0 )
    {
        hr = strVariable.Copy( "HTTP/0.0" );
    }
    else if ( strcmp( pszVariableName, "SERVER_SOFTWARE" ) == 0 )
    {
        hr = strVariable.Copy( SERVER_SOFTWARE_STRING );
    }
    else if ( strcmp( pszVariableName, "GATEWAY_INTERFACE" ) == 0 )
    {
        hr = strVariable.Copy( "CGI/1.1" );
    }
    else
    {
        hr = strVariable.Copy( "" );
    }
    
    return strVariable.CopyToBuffer( (LPSTR) pvBuffer, pdwSize );
}

VOID
RAW_CONNECTION::AddSkippedData(
    ULARGE_INTEGER              liData
)
/*++

Routine Description:
    
    Account for data sent by worker process (which thus should be skipped by
    streamfilt's filter code)

Arguments:

    liData - Add data to be skipped
    
Return Value:

    None
    
--*/
{
    _skipLock.WriteLock();
    
    _liWorkerProcessData.QuadPart += liData.QuadPart;
    
    _skipLock.WriteUnlock();
}

BOOL
RAW_CONNECTION::DetermineSkippedData(
    DWORD                         cbData,
    DWORD *                       pcbOffset
)
/*++

Routine Description:

    Given a streamfilt completion, determine how much has been sent by
    the worker process and therefore should be skipped.  This function 
    returns the amount of the data we actually want to send thru
    the streamfilt filter code.

Arguments:

    cbData - Streamfilt completion
    pcbOffset - Points to data to be sent
    
Return Value:

    BOOL - TRUE if we should send data, else FALSE

--*/
{
    BOOL                fRet;
    
    _skipLock.WriteLock();
    
    if ( _liWorkerProcessData.QuadPart <= cbData )
    {
        *pcbOffset = (DWORD) cbData - _liWorkerProcessData.QuadPart;
        _liWorkerProcessData.QuadPart = 0;
        
        fRet = *pcbOffset != 0;
    }
    else
    {
        *pcbOffset = cbData;
        
        _liWorkerProcessData.QuadPart -= cbData;
        
        fRet = FALSE;
    }
    
    _skipLock.WriteUnlock(); 
    
    return fRet;
}

//static    
BOOL
WINAPI
RAW_CONNECTION::RawFilterServerSupportFunction(
    HTTP_FILTER_CONTEXT *         pfc,
    enum SF_REQ_TYPE              SupportFunction,
    void *                        pData,
    ULONG_PTR                     ul,
    ULONG_PTR                     ul2
)
/*++

Routine Description:

    Stream filter SSF crap

Arguments:

    pfc - Used to get back the W3_FILTER_CONTEXT and W3_MAIN_CONTEXT pointers
    SupportFunction - SSF to invoke (see ISAPI docs)
    pData, ul, ul2 - Function specific data
    
Return Value:

    BOOL (use GetLastError() for error)

--*/
{
    RAW_CONNECTION *            pRawConnection;
    HRESULT                     hr = NO_ERROR;
    BOOL                        fRet;
    
    //
    // Primitive parameter validation
    //

    if ( pfc == NULL ||
         pfc->ServerContext == NULL )
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        return FALSE;
    }
    
    pRawConnection = (RAW_CONNECTION*) pfc->ServerContext;
    DBG_ASSERT( pRawConnection->CheckSignature() );

    switch ( SupportFunction )
    {
    case SF_REQ_SEND_RESPONSE_HEADER:

        hr = pRawConnection->SendResponseHeader( (CHAR*) pData,
                                                 (CHAR*) ul,
                                                 pfc );
        break;

    case SF_REQ_ADD_HEADERS_ON_DENIAL:
        
        hr = pRawConnection->AddDenialHeaders( (CHAR*) pData );
        break;

    case SF_REQ_SET_NEXT_READ_SIZE:

        pRawConnection->SetNextReadSize( (DWORD) ul );
        break;
        
    case SF_REQ_DISABLE_NOTIFICATIONS:
    
        hr = pRawConnection->DisableNotification( (DWORD) ul );
        break;
    
    default:
        DBG_ASSERT( FALSE );
        hr = HRESULT_FROM_WIN32( ERROR_NOT_SUPPORTED );
    }    

    if ( FAILED( hr ) )
    {
        SetLastError( WIN32_FROM_HRESULT( hr ) );
        return FALSE;
    }    
    return TRUE;
}

//static
BOOL
WINAPI
RAW_CONNECTION::RawFilterGetServerVariable(
    HTTP_FILTER_CONTEXT *         pfc,
    LPSTR                         lpszVariableName,
    LPVOID                        lpvBuffer,
    LPDWORD                       lpdwSize
)
/*++

Routine Description:

    Stream filter GetServerVariable() implementation

Arguments:

    pfc - Filter context
    lpszVariableName - Variable name
    lpvBuffer - Buffer to receive the server variable
    lpdwSize - On input, the size of the buffer, on output, the sized needed
    
    
Return Value:

    BOOL (use GetLastError() for error).  
    ERROR_INSUFFICIENT_BUFFER if larger buffer needed
    ERROR_INVALID_INDEX if the server variable name requested is invalid

--*/
{
    HRESULT                         hr = NO_ERROR;
    RAW_CONNECTION *                pRawConnection = NULL;
    W3_MAIN_CONTEXT *               pMainContext;
    
    //
    // Primitive parameter validation
    //

    if ( pfc == NULL ||
         pfc->ServerContext == NULL ||
         lpdwSize == NULL )
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        return FALSE;
    }
    
    pRawConnection = (RAW_CONNECTION*) pfc->ServerContext;
    DBG_ASSERT( pRawConnection->CheckSignature() );

    //
    // If we have a W3_CONNECTION associated, then use its context to 
    // get at server variables.  Otherwise we can only serve the ones that
    // make sense
    //

    pMainContext = pRawConnection->GetAndReferenceMainContext();
    if ( pMainContext != NULL )
    {
        hr = SERVER_VARIABLE_HASH::GetServerVariable( pMainContext,
                                                      lpszVariableName,
                                                      (CHAR*) lpvBuffer,
                                                      lpdwSize ); 
            
        pMainContext->DereferenceMainContext();
    }
    else
    {
        //
        // We can supply only a few (since we haven't parsed the request yet)
        //
        
        hr = pRawConnection->GetLimitedServerVariables( lpszVariableName,
                                                        lpvBuffer,
                                                        lpdwSize );
    }
    
    if ( FAILED( hr ) )
    {
        SetLastError( WIN32_FROM_HRESULT( hr ) );
        return FALSE;
    }

    return TRUE;
}

//static
BOOL
WINAPI
RAW_CONNECTION::RawFilterWriteClient(
    HTTP_FILTER_CONTEXT *         pfc,
    LPVOID                        Buffer,
    LPDWORD                       lpdwBytes,
    DWORD                         dwReserved
)
/*++

Routine Description:

    Synchronous WriteClient() for stream filter

Arguments:

    pfc - Filter context
    Buffer - buffer to write to client
    lpdwBytes - On input, the size of the input buffer.  On output, the number
                of bytes sent
    dwReserved - Reserved
    
    
Return Value:

    BOOL (use GetLastError() for error).  

--*/
{
    HRESULT                     hr;
    RAW_CONNECTION *            pRawConnection = NULL;
    PVOID                       pvContext;
    RAW_STREAM_INFO             rawStreamInfo;
    BOOL                        fComplete = FALSE;

    //
    // Primitive parameter validation
    //

    if ( pfc == NULL ||
         pfc->ServerContext == NULL ||
         Buffer == NULL )
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        return FALSE;
    }
    
    pRawConnection = (RAW_CONNECTION*) pfc->ServerContext;
    DBG_ASSERT( pRawConnection->CheckSignature() );

    //
    // Remember the filter context since calling filters will overwrite it
    //
    
    pvContext = pfc->pFilterContext;

    //
    // Set up the raw stream info
    //
    
    rawStreamInfo.pbBuffer = (BYTE*) Buffer;
    rawStreamInfo.cbBuffer = *lpdwBytes;
    rawStreamInfo.cbData = rawStreamInfo.cbBuffer;

    //
    // We need to notify all write raw data filters which are a higher 
    // priority than the current filter 
    //
    
    if ( pRawConnection->_dwCurrentFilter > 0 )
    {
        hr = pRawConnection->NotifyRawWriteFilters( &rawStreamInfo,
                                                    &fComplete,
                                                    pRawConnection->_dwCurrentFilter - 1 );
        if ( FAILED( hr ) )
        {
            goto Finished;
        }
    }
    
    pfc->pFilterContext = pvContext;
    
    //
    // Now call back into the stream filter to send the data.  In transmit
    // SSL might do its thing with the data as well
    //
   
    hr = pRawConnection->_pfnSendDataBack( pRawConnection->_pvStreamContext,
                                           &rawStreamInfo );
    if ( FAILED( hr ) )
    {
        goto Finished;
    }
    
    return TRUE;
    
Finished:
    if ( FAILED( hr ) )
    {
        SetLastError( WIN32_FROM_HRESULT( hr ) );
        return FALSE;
    }
    return TRUE;
}
    
//static
VOID *
WINAPI
RAW_CONNECTION::RawFilterAllocateMemory(
    HTTP_FILTER_CONTEXT *         pfc,
    DWORD                         cbSize,
    DWORD                         dwReserved
)
/*++

Routine Description:

    Used by filters to allocate memory freed on connection close

Arguments:

    pfc - Filter context
    cbSize - Amount to allocate
    dwReserved - Reserved
    
    
Return Value:

    A pointer to the allocated memory

--*/
{
    RAW_CONNECTION *        pRawConnection = NULL;

    //
    // Primitive parameter validation
    //

    if ( pfc == NULL ||
         pfc->ServerContext == NULL )
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        return NULL;
    }
    
    pRawConnection = (RAW_CONNECTION*) pfc->ServerContext;
    DBG_ASSERT( pRawConnection->CheckSignature() );

    return pRawConnection->AllocateFilterMemory( cbSize );
}

//static
BOOL
WINAPI
RAW_CONNECTION::RawFilterAddResponseHeaders(
    HTTP_FILTER_CONTEXT * pfc,
    LPSTR                 lpszHeaders,
    DWORD                 dwReserved
)
/*++

Routine Description:

    Add response headers to whatever response eventually gets sent

Arguments:

    pfc - Filter context
    lpszHeaders - Headers to send (\r\n delimited)
    dwReserved - Reserved
    
Return Value:

    BOOL (use GetLastError() for error).  

--*/
{
    HRESULT                         hr;
    RAW_CONNECTION *                pRawConnection;
    W3_MAIN_CONTEXT *               pMainContext = NULL;
    W3_FILTER_CONTEXT *             pFilterContext;

    //
    // Primitive parameter validation
    //

    if ( pfc == NULL ||
         pfc->ServerContext == NULL || 
         lpszHeaders == NULL )
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        return FALSE;
    }
    
    pRawConnection = (RAW_CONNECTION*) pfc->ServerContext;
    DBG_ASSERT( pRawConnection->CheckSignature() );
    
    pMainContext = pRawConnection->GetAndReferenceMainContext();
    if ( pMainContext != NULL )
    {
        pFilterContext = pMainContext->QueryFilterContext();
        DBG_ASSERT( pFilterContext != NULL );

        hr = pFilterContext->AddResponseHeaders( lpszHeaders );        
        
        pMainContext->DereferenceMainContext();
    }
    else
    {
        hr = pRawConnection->AddResponseHeaders( lpszHeaders );
    }
    
    if ( FAILED( hr ) )
    {
        SetLastError( WIN32_FROM_HRESULT( hr ) );
        return FALSE;
    }
    
    return TRUE;
}

//static
HRESULT
RAW_CONNECTION::ProcessNewConnection(
    CONNECTION_INFO *       pConnectionInfo,
    PVOID *                 ppConnectionState
)
/*++

Routine Description:

    Called for every new raw connection to server

Arguments:

    pConnectionInfo - Information about the local/remote addresses
    ppConnectionState - Connection state to be associated with raw connection

Return Value:

    HRESULT

--*/
{
    RAW_CONNECTION *            pConnection = NULL;
    LK_RETCODE                  lkrc;
    
    if ( pConnectionInfo == NULL ||
         ppConnectionState == NULL )
    {
        DBG_ASSERT( FALSE );
        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }
    
    *ppConnectionState = NULL;
    
    //
    // Try to create and add the connection
    // 

    pConnection = new RAW_CONNECTION( pConnectionInfo );
    if ( pConnection == NULL )
    {
        return HRESULT_FROM_WIN32( GetLastError() );
    } 
        
    lkrc = sm_pRawConnectionHash->InsertRecord( pConnection );
    if ( lkrc != LK_SUCCESS )
    {
        pConnection->DereferenceRawConnection();
        pConnection = NULL;
        
        return HRESULT_FROM_WIN32( lkrc );
    }
    
    *ppConnectionState = pConnection;
    
    return NO_ERROR;
}

//static
HRESULT
RAW_CONNECTION::ProcessRawRead(
    RAW_STREAM_INFO *       pRawStreamInfo,
    PVOID                   pContext,
    BOOL *                  pfReadMore,
    BOOL *                  pfComplete,
    DWORD *                 pcbNextReadSize
)
/*++

Routine Description:

    Notify ISAPI read raw data filters

Arguments:

    pRawStreamInfo - The raw stream to muck with
    pContext - Raw connection context
    pfReadMore - Set to TRUE if we need to read more data
    pfComplete - Set to TRUE if we want to disconnect client
    pcbNextReadSize - Set to next read size (0 means use default size)

Return Value:

    HRESULT

--*/
{
    RAW_CONNECTION *        pConnection = NULL;
    HRESULT                 hr = NO_ERROR;
    W3_MAIN_CONTEXT *       pMainContext;
    
    if ( pRawStreamInfo == NULL ||
         pfReadMore == NULL ||
         pfComplete == NULL ||
         pContext == NULL ||
         pcbNextReadSize == NULL )
    {
        DBG_ASSERT( FALSE );
        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }
    
    *pfReadMore = FALSE;
    *pfComplete = FALSE;

    pConnection = (RAW_CONNECTION*) pContext;
    DBG_ASSERT( pConnection->CheckSignature() );

    pConnection->SetNextReadSize( 0 );

    //
    // Synchronize access to the filter to prevent raw notifications from
    // occurring at the same time as regular worker process notifications
    //
    
    pMainContext = pConnection->GetAndReferenceMainContext();
    if ( pMainContext != NULL )
    {
        pMainContext->QueryFilterContext()->FilterLock();
    }

    hr = pConnection->NotifyRawReadFilters( pRawStreamInfo,
                                            pfReadMore,
                                            pfComplete );

    if ( pMainContext != NULL )
    {
        pMainContext->QueryFilterContext()->FilterUnlock();
        pMainContext->DereferenceMainContext();
    }
    
    *pcbNextReadSize = pConnection->QueryNextReadSize();
    
    return hr;
}

//static
VOID
RAW_CONNECTION::ReleaseContext(
    PVOID                   pvContext
)
/*++

Routine Description:

    Release a raw connection since stream filter is done with it

Arguments:

    pvContext - RAW_CONNECTION *

Return Value:

    None

--*/
{
    RAW_CONNECTION *            pRawConnection;
    
    pRawConnection = (RAW_CONNECTION*) pvContext;
    DBG_ASSERT( pRawConnection->CheckSignature() );
    
    pRawConnection->DereferenceRawConnection();
}

HRESULT
RAW_CONNECTION::NotifyRawReadFilters(
    RAW_STREAM_INFO *               pRawStreamInfo,
    BOOL *                          pfReadMore,
    BOOL *                          pfComplete
)
/*++

Routine Description:

    Notify raw read filters

Arguments:

    pRawStreamInfo - Raw stream info
    pfReadMore - Set to TRUE to we should read more data
    pfComplete - Set to TRUE if we should disconnect

Return Value:

    HRESULT

--*/
{
    HTTP_FILTER_DLL *           pFilterDll;
    DWORD                       err;
    SF_STATUS_TYPE              sfStatus;
    DWORD                       i;
    PVOID                       pvtmp;
    PVOID                       pvCurrentClientContext;
    FILTER_LIST *               pFilterList;
    HTTP_FILTER_RAW_DATA        hfrd;

    if ( pRawStreamInfo == NULL ||
         pfReadMore == NULL ||
         pfComplete == NULL )
    {
        DBG_ASSERT( FALSE );
        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }
    
    *pfComplete = FALSE;
    *pfReadMore = FALSE;

    //
    // Setup filter raw object
    //

    hfrd.pvInData = pRawStreamInfo->pbBuffer;
    hfrd.cbInData = pRawStreamInfo->cbData;
    hfrd.cbInBuffer = pRawStreamInfo->cbBuffer;
    
    //
    // In certain cases, we can send a notification to a filter while we're still
    // processing another filter's notification. In that case, we need to make sure
    // we restore the current filter's context when we're done with the notifications
    //
    
    pvCurrentClientContext = _hfc.pFilterContext;
    
    pFilterList = QueryFilterList();
    DBG_ASSERT( pFilterList != NULL );

    for ( i = 0; i < pFilterList->QueryFilterCount(); i++ )
    {
        pFilterDll = pFilterList->QueryDll( i ); 

        //
        // Notification flags are cached in the HTTP_FILTER object, but they're
        // only copied from the actual HTTP_FILTER_DLL object if a filter dll
        // disables a particular notification [sort of a copy-on-write scheme].
        // If a filter dll disables/changes a notification, we need to check the flags
        // in the HTTP_FILTER object, not those in the HTTP_FILTER_DLL object
        //
        
        if ( !QueryNotificationChanged() )
        {
            if ( !pFilterDll->IsNotificationNeeded( SF_NOTIFY_READ_RAW_DATA,
                                                    _hfc.fIsSecurePort ) )
            {
                continue;
            }
        }
        else
        {
            if ( !IsDisableNotificationNeeded( i,
                                               SF_NOTIFY_READ_RAW_DATA ) )
            {
                continue;
            }
        }

        _hfc.pFilterContext = QueryClientContext( i );

        pvtmp = _hfc.pFilterContext;
       
        //
        // Keep track of the current filter so that we know which filters
        // to notify when a raw filter does a write client
        //
       
        _dwCurrentFilter = i;
        
        sfStatus = (SF_STATUS_TYPE)
                   pFilterDll->QueryEntryPoint()( &_hfc,
                                                  SF_NOTIFY_READ_RAW_DATA,
                                                  &hfrd );

        if ( pvtmp != _hfc.pFilterContext )
        {
            SetClientContext( i, _hfc.pFilterContext );
            pFilterDll->SetHasSetContextBefore(); 
        }

        switch ( sfStatus )
        {
        default:
            DBGPRINTF(( DBG_CONTEXT,
                        "Unknown status code from filter %d\n",
                        sfStatus ));
            //
            //  Fall through
            //

        case SF_STATUS_REQ_NEXT_NOTIFICATION:
            continue;

        case SF_STATUS_REQ_ERROR:
            
            _hfc.pFilterContext = pvCurrentClientContext;
            return E_FAIL;

        case SF_STATUS_REQ_FINISHED:
        case SF_STATUS_REQ_FINISHED_KEEP_CONN:  // Not supported at this point

            *pfComplete = TRUE;
            goto Exit;

        case SF_STATUS_REQ_READ_NEXT:
            *pfReadMore = TRUE;
            goto Exit;

        case SF_STATUS_REQ_HANDLED_NOTIFICATION:

            //
            //  Don't notify any other filters
            //

            goto Exit;
        }
    }

Exit:

    pRawStreamInfo->pbBuffer = (BYTE*) hfrd.pvInData;
    pRawStreamInfo->cbData = hfrd.cbInData;
    pRawStreamInfo->cbBuffer = hfrd.cbInBuffer;
    
    //
    // Reset the filter context we came in with
    //
    
    _hfc.pFilterContext = pvCurrentClientContext;

    return NO_ERROR;
}

//static
HRESULT
RAW_CONNECTION::ProcessRawWrite(
    RAW_STREAM_INFO *       pRawStreamInfo,
    PVOID                   pvContext,
    BOOL *                  pfComplete
)
/*++

Routine Description:

    Entry point called by stream filter to handle data coming from the 
    application.  We will call SF_NOTIFY_SEND_RAW_DATA filter notifications
    here

Arguments:

    pRawStreamInfo - The stream to process, as well as an optional opaque
                     context set by the RAW_CONNECTION code
    pvContext - Context pass back
    pfComplete - Set to TRUE if we should disconnect
    
Return Value:

    HRESULT

--*/
{
    RAW_CONNECTION *        pConnection = NULL;
    W3_MAIN_CONTEXT *       pMainContext;
    HRESULT                 hr = NO_ERROR;
    BOOL                    fCallFilter = FALSE;
    DWORD                   cbOffset;
    
    if ( pRawStreamInfo == NULL ||
         pfComplete == NULL )
    {
        DBG_ASSERT( FALSE );
        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }
    
    *pfComplete = FALSE;

    pConnection = (RAW_CONNECTION*) pvContext;
    DBG_ASSERT( pConnection->CheckSignature() );

    if ( pConnection->_fSkipAtAll == FALSE )
    {
        return NO_ERROR;
    }

    //
    // Check whether we should just eat up these bytes
    //
    
    fCallFilter = pConnection->DetermineSkippedData( pRawStreamInfo->cbData,
                                                     &cbOffset );
                                    
    if ( fCallFilter )
    {
        //
        // Patch the buffer we send to the filter
        //
        
        pRawStreamInfo->pbBuffer = pRawStreamInfo->pbBuffer + cbOffset;
        pRawStreamInfo->cbData = pRawStreamInfo->cbData - cbOffset;
        
        hr = pConnection->NotifyRawWriteFilters( pRawStreamInfo,
                                                 pfComplete,
                                                 INVALID_DLL ); 
    }
    
    return hr;
}

HRESULT
RAW_CONNECTION::NotifyRawWriteFilters(
    RAW_STREAM_INFO *   pRawStreamInfo,
    BOOL *              pfComplete,
    DWORD               dwStartFilter
)
/*++

Routine Description:

    Notify raw write filters

Arguments:

    pRawStreamInfo - Raw stream to munge
    pfComplete - Set to TRUE if we should disconnect now
    dwStartFilter - Filter to start notifying.  If this valid is INVALID_DLL,
                    then simply start with the lowest priority filter

Return Value:

    HRESULT

--*/
{
    HTTP_FILTER_DLL *           pFilterDll;
    DWORD                       err;
    SF_STATUS_TYPE              sfStatus;
    DWORD                       i;
    PVOID                       pvtmp;
    PVOID                       pvCurrentClientContext;
    FILTER_LIST *               pFilterList;
    HTTP_FILTER_RAW_DATA        hfrd;

    if ( pRawStreamInfo == NULL ||
         pfComplete == NULL )
    {
        DBG_ASSERT( FALSE );
        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }
    
    *pfComplete = FALSE;

    hfrd.pvInData = pRawStreamInfo->pbBuffer;
    hfrd.cbInData = pRawStreamInfo->cbData;
    hfrd.cbInBuffer = pRawStreamInfo->cbBuffer;
    
    //
    // In certain cases, we can send a notification to a filter while we're still
    // processing another filter's notification. In that case, we need to make sure
    // we restore the current filter's context when we're done with the notifications
    //
    
    pvCurrentClientContext = _hfc.pFilterContext;
    
    pFilterList = QueryFilterList();
    DBG_ASSERT( pFilterList != NULL );

    if ( dwStartFilter == INVALID_DLL )
    {
        dwStartFilter = pFilterList->QueryFilterCount() - 1;
    }
    
    i = dwStartFilter;

    do
    {
        pFilterDll = pFilterList->QueryDll( i ); 

        //
        // Notification flags are cached in the HTTP_FILTER object, but they're
        // only copied from the actual HTTP_FILTER_DLL object if a filter dll
        // disables a particular notification [sort of a copy-on-write scheme].
        // If a filter dll disables/changes a notification, we need to check the flags
        // in the HTTP_FILTER object, not those in the HTTP_FILTER_DLL object
        //
        
        if ( !QueryNotificationChanged() )
        {
            if ( !pFilterDll->IsNotificationNeeded( SF_NOTIFY_SEND_RAW_DATA,
                                                    _hfc.fIsSecurePort ) )
            {
                continue;
            }
        }
        else
        {
            if ( !IsDisableNotificationNeeded( i,
                                               SF_NOTIFY_SEND_RAW_DATA ) )
            {
                continue;
            }
        }

        //
        // Another slimy optimization.  If this filter has never associated
        // context with connection, then we don't have to do the lookup
        //
        
        _hfc.pFilterContext = QueryClientContext( i );

        pvtmp = _hfc.pFilterContext;

        //
        // Keep track of the current filter so that we know which filters
        // to notify when a raw filter does a write client
        //
       
        _dwCurrentFilter = i;
        
        sfStatus = (SF_STATUS_TYPE)
                   pFilterDll->QueryEntryPoint()( &_hfc,
                                                  SF_NOTIFY_SEND_RAW_DATA,
                                                  &hfrd );

        if ( pvtmp != _hfc.pFilterContext )
        {
            SetClientContext( i, _hfc.pFilterContext );
            pFilterDll->SetHasSetContextBefore(); 
        }

        switch ( sfStatus )
        {
        default:
            DBGPRINTF(( DBG_CONTEXT,
                        "Unknown status code from filter %d\n",
                        sfStatus ));
            //
            //  Fall through
            //

        case SF_STATUS_REQ_NEXT_NOTIFICATION:
            continue;

        case SF_STATUS_REQ_ERROR:
            
            _hfc.pFilterContext = pvCurrentClientContext;
            return E_FAIL;

        case SF_STATUS_REQ_FINISHED:
        case SF_STATUS_REQ_FINISHED_KEEP_CONN:  // Not supported at this point

            *pfComplete = TRUE;
            goto Exit;

        case SF_STATUS_REQ_HANDLED_NOTIFICATION:

            //
            //  Don't notify any other filters
            //

            goto Exit;
        }
    }
    while ( i-- > 0 );

Exit:

    pRawStreamInfo->pbBuffer = (BYTE*) hfrd.pvInData;
    pRawStreamInfo->cbData = hfrd.cbInData;
    pRawStreamInfo->cbBuffer = hfrd.cbInBuffer;
    
    //
    // Reset the filter context we came in with
    //
    
    _hfc.pFilterContext = pvCurrentClientContext;
    
    return NO_ERROR;
}

HRESULT
RAW_CONNECTION::NotifyEndOfNetSessionFilters(
    VOID
)
/*++

Routine Description:

    Notify END_OF_NET_SESSION filters

Arguments:

    None

Return Value:

    HRESULT

--*/
{
    HTTP_FILTER_DLL *           pFilterDll;
    DWORD                       err;
    SF_STATUS_TYPE              sfStatus;
    DWORD                       i;
    PVOID                       pvtmp;
    PVOID                       pvCurrentClientContext;
    FILTER_LIST *               pFilterList;
    HTTP_FILTER_RAW_DATA        hfrd;

    //
    // In certain cases, we can send a notification to a filter while we're still
    // processing another filter's notification. In that case, we need to make sure
    // we restore the current filter's context when we're done with the notifications
    //
    
    pvCurrentClientContext = _hfc.pFilterContext;
    
    pFilterList = QueryFilterList();
    DBG_ASSERT( pFilterList != NULL );

    for ( i = 0; i < pFilterList->QueryFilterCount(); i++ )
    {
        pFilterDll = pFilterList->QueryDll( i ); 
        
        if ( !QueryNotificationChanged() )
        {
            if ( !pFilterDll->IsNotificationNeeded( SF_NOTIFY_END_OF_NET_SESSION,
                                                    _hfc.fIsSecurePort ) )
            {
                continue;
            }
        }
        else
        {
            if ( !IsDisableNotificationNeeded( i,
                                               SF_NOTIFY_END_OF_NET_SESSION ) )
            {
                continue;
            }
        }

        _hfc.pFilterContext = QueryClientContext( i );

        pvtmp = _hfc.pFilterContext;
       
        //
        // Keep track of the current filter so that we know which filters
        // to notify when a raw filter does a write client
        //
       
        _dwCurrentFilter = i;
        
        sfStatus = (SF_STATUS_TYPE)
                   pFilterDll->QueryEntryPoint()( &_hfc,
                                                  SF_NOTIFY_END_OF_NET_SESSION,
                                                  &hfrd );

        if ( pvtmp != _hfc.pFilterContext )
        {
            SetClientContext( i, _hfc.pFilterContext );
            pFilterDll->SetHasSetContextBefore(); 
        }

        switch ( sfStatus )
        {
        default:
            DBGPRINTF(( DBG_CONTEXT,
                        "Unknown status code from filter %d\n",
                        sfStatus ));
            //
            //  Fall through
            //

        case SF_STATUS_REQ_NEXT_NOTIFICATION:
            continue;

        case SF_STATUS_REQ_ERROR:
            
            _hfc.pFilterContext = pvCurrentClientContext;
            return E_FAIL;

        case SF_STATUS_REQ_FINISHED:
        case SF_STATUS_REQ_FINISHED_KEEP_CONN:  // Not supported at this point

            goto Exit;

        case SF_STATUS_REQ_HANDLED_NOTIFICATION:

            //
            //  Don't notify any other filters
            //

            goto Exit;
        }
    }

Exit:
    
    //
    // Reset the filter context we came in with
    //
    
    _hfc.pFilterContext = pvCurrentClientContext;

    return NO_ERROR;
}

//static
VOID
RAW_CONNECTION::ProcessConnectionClose(
    PVOID                       pvContext
)
/*++

Routine Description:

    Entry point called by stream filter when a connection has closed

Arguments:

    pvContext - Opaque context associated with the connection
    
Return Value:

    None

--*/
{
    RAW_CONNECTION *            pRawConnection;
    
    pRawConnection = (RAW_CONNECTION*) pvContext;
    if ( pRawConnection != NULL )
    {
        DBG_ASSERT( pRawConnection->CheckSignature() );

        //
        // We're done with the raw connection.  Delete it from hash table
        // In the process, this will dereference the connection
        //
        
        DBG_ASSERT( sm_pRawConnectionHash != NULL );
        
        sm_pRawConnectionHash->DeleteRecord( pRawConnection );
    }
}

VOID
RAW_CONNECTION::CopyAllocatedFilterMemory(
    W3_FILTER_CONTEXT *         pFilterContext
)
/*++

Routine Description:

    Copy over any allocated filter memory items

Arguments:

    pFilterContext - Destination of filter memory item references

Return Value:

    None

--*/
{   
    FILTER_POOL_ITEM *          pfpi;
    
    //
    // We need to grab the raw connection lock since we don't want a 
    // read-raw data notification to muck with the pool list while we
    // are copying it over to the W3_CONNECTION
    //
    
    pFilterContext->FilterLock();

    while ( !IsListEmpty( &_PoolHead ) ) 
    {
        pfpi = CONTAINING_RECORD( _PoolHead.Flink,
                                  FILTER_POOL_ITEM,
                                  _ListEntry );

        RemoveEntryList( &pfpi->_ListEntry );

        InitializeListHead( &pfpi->_ListEntry );

        //
        // Copy the pool item to the other list
        //

        pFilterContext->AddFilterPoolItem( pfpi );
    }
    
    pFilterContext->FilterUnlock();
}

VOID
RAW_CONNECTION::CopyContextPointers(
    W3_FILTER_CONTEXT *         pFilterContext
)
/*++

Routine Description:

    The global filter list is constant, in addition, when an instance filter
    list is built, the global filters are always built into the list.  After
    the instance filter list has been identified, we need to copy any non-null
    client filter context values from the global filter list to the new
    positions in the instance filter list.  For example:

     Global List &  |  Instance List &
     context values | new context value positions
                    |
        G1     0    |    I1    0
        G2   555    |    G1    0
        G3   123    |    G2  555
                    |    I2    0
                    |    G3  123

    Note: This scheme precludes having the same .dll be used for both a
          global and per-instance dll.  Since global filters are automatically
          per-instance this shouldn't be an interesting case.

--*/
{
    DWORD i, j;
    DWORD cGlobal;
    DWORD cInstance;
    HTTP_FILTER_DLL * pFilterDll;
    FILTER_LIST * pGlobalFilterList;
    FILTER_LIST * pInstanceFilterList;

    pFilterContext->FilterLock();

    DBG_ASSERT( pFilterContext != NULL );

    pGlobalFilterList = FILTER_LIST::QueryGlobalList();
    DBG_ASSERT( pGlobalFilterList != NULL );

    cGlobal = pGlobalFilterList->QueryFilterCount();

    pInstanceFilterList = pFilterContext->QueryFilterList();
    DBG_ASSERT( pInstanceFilterList != NULL );
    
    cInstance = pInstanceFilterList->QueryFilterCount();

    //
    // If no global filters or no instance filters, then there won't be
    // any filter context pointers that need adjusting
    //

    if ( !cGlobal || !cInstance )
    {
        goto Finished;
    }
    
    //
    // For each global list context pointer, find the filter in the instance
    // list and adjust
    //

    for ( i = 0; i < cGlobal; i++ )
    {
        if ( _rgContexts[ i ] != NULL )
        {
            pFilterDll = pGlobalFilterList->QueryDll( i );
            
            //
            // We found one.  Find the filter in instance list and set
            //
            
            for ( j = 0; j < cInstance; j++ )
            {
                if ( pInstanceFilterList->QueryDll( j ) == pFilterDll )
                {
                    pFilterContext->SetClientContext( j, _rgContexts[ i ] );
                }
            }
            
        }
    }

Finished:
    pFilterContext->FilterUnlock();
}

HRESULT
RAW_CONNECTION::CopyHeaders(
    W3_FILTER_CONTEXT *             pFilterContext
)
/*++

Routine Description:

    Copy denied/response headers from read raw

Arguments:

    pFilterContext - Filter context to copy to

Return Value:

    HRESULT

--*/
{
    HRESULT                 hr;
    
    if ( pFilterContext == NULL )
    {
        DBG_ASSERT( FALSE );
        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }
    
    hr = pFilterContext->AddDenialHeaders( _strAddDenialHeaders.QueryStr() );
    if ( FAILED( hr ) )
    {
        return hr;
    }
    
    hr = pFilterContext->AddResponseHeaders( _strAddResponseHeaders.QueryStr() );
    if ( FAILED( hr ) )
    {
        return hr;
    }
    
    _strAddDenialHeaders.Reset();
    _strAddResponseHeaders.Reset();
    
    return NO_ERROR;
}

HRESULT
RAW_CONNECTION::SendResponseHeader(
    CHAR *                          pszStatus,
    CHAR *                          pszAdditionalHeaders,
    HTTP_FILTER_CONTEXT *           pfc
)
/*++

Routine Description:

    Called when raw filters want to send a response header.  Depending
    on whether a W3_CONNECTION is associated or not, we will either 
    send the stream ourselves here, or call in the main context's 
    response facilities

Arguments:

    pszStatus - ANSI status line
    pszAdditionalHeaders - Any additional headers to send
    pfc - Filter context (to be passed to FilterWriteClient())

Return Value:

    HRESULT

--*/
{
    W3_MAIN_CONTEXT *       pMainContext = NULL;
    STACK_STRA(             strResponse, 256 );
    HRESULT                 hr = NO_ERROR;
    DWORD                   cbBytes = 0;
    BOOL                    fRet = FALSE;
    W3_RESPONSE *           pResponse = NULL;
    
    if ( pszStatus == NULL &&
         pszAdditionalHeaders == NULL )
    {
        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }
    
    //
    // Which response are we touching?
    //
    
    pMainContext = GetAndReferenceMainContext();
    if ( pMainContext != NULL )
    {
        pResponse = pMainContext->QueryResponse();
    }
    else
    {
        pResponse = &_response;
    }
        
    //
    // Build up a response from what ISAPI gave us
    //
    
    hr = pResponse->BuildResponseFromIsapi( pMainContext,
                                            pszStatus,
                                            pszAdditionalHeaders,
                                            pszAdditionalHeaders ? 
                                            strlen( pszAdditionalHeaders ) : 0 );
    if ( FAILED( hr ) )
    {
        return hr;
    }
    
    //
    // Now if we have a w3 context then we can send the response normally.
    // Otherwise we must use the UL filter API
    //
       
    if ( pMainContext != NULL )
    {
        hr = pMainContext->SendResponse( W3_FLAG_SYNC | 
                                         W3_FLAG_NO_ERROR_BODY |
                                         W3_FLAG_NO_CONTENT_LENGTH );

        pMainContext->DereferenceMainContext();
    } 
    else
    {
        //
        // Add denial/response headers
        //
        
        if ( pResponse->QueryStatusCode() == HttpStatusUnauthorized.statusCode )
        {
            hr = pResponse->AppendResponseHeaders( _strAddDenialHeaders );
            if ( FAILED( hr ) )
            {
                return hr;
            }
        }
        
        hr = pResponse->AppendResponseHeaders( _strAddResponseHeaders );
        if ( FAILED( hr ) )
        {
            return hr;
        }
        
        hr = pResponse->GetRawResponseStream( &strResponse );
        if ( FAILED( hr ) )
        {
            return hr;
        }
        
        //
        // Go thru WriteClient() so the right filtering happens on the
        // response
        //
        
        cbBytes = strResponse.QueryCB();
        
        fRet = RAW_CONNECTION::RawFilterWriteClient( pfc,
                                                     strResponse.QueryStr(),
                                                     &cbBytes,
                                                     0 );
        if ( !fRet )
        {
            hr = HRESULT_FROM_WIN32( GetLastError() );
        }
    }
    
    return hr;
}

//static
HRESULT
RAW_CONNECTION::FindConnection(
    HTTP_RAW_CONNECTION_ID      rawConnectionId,
    RAW_CONNECTION **           ppRawConnection
)
/*++

Routine Description:

    Find and return raw connection if found

Arguments:

    rawConnectionId - Raw connection ID from UL_HTTP_REQUEST
    ppRawConnection - Set to raw connection if found

Return Value:

    HRESULT

--*/
{
    LK_RETCODE                  lkrc;
    
    if ( ppRawConnection == NULL ||
         rawConnectionId == HTTP_NULL_ID )
    {
        DBG_ASSERT( FALSE );
        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }
    
    DBG_ASSERT( sm_pRawConnectionHash != NULL );
    
    lkrc = sm_pRawConnectionHash->FindKey( &rawConnectionId,
                                           ppRawConnection );
    
    if ( lkrc != LK_SUCCESS )
    {
        return HRESULT_FROM_WIN32( ERROR_FILE_NOT_FOUND );
    }
    else
    {
        return NO_ERROR;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\iisplus\ulw3\options_handler.cxx ===
/*++

   Copyright    (c)    2001    Microsoft Corporation

   Module Name :
     options_handler.cxx

   Abstract:
     Handle OPTIONS requests

   Author:
     Anil Ruia (AnilR)              4-Apr-2001

   Environment:
     Win32 - User Mode

   Project:
     ULW3.DLL
--*/

#include "precomp.hxx"
#include "options_handler.hxx"

CONTEXT_STATUS
W3_OPTIONS_HANDLER::DoWork()
/*++

Routine Description:

    Do the OPTIONS thing if DAV is disabled

Return Value:

    CONTEXT_STATUS_PENDING if async pending, else CONTEXT_STATUS_CONTINUE

--*/
{
    HRESULT hr;
    W3_CONTEXT *pW3Context = QueryW3Context();
    DBG_ASSERT(pW3Context != NULL);

    W3_RESPONSE *pW3Response = pW3Context->QueryResponse();

    W3_REQUEST *pW3Request = pW3Context->QueryRequest();
    STACK_STRU (strUrl, MAX_PATH);

    if (FAILED(hr = pW3Response->SetHeader(HEADER("Public"),
                                           HEADER("OPTIONS, TRACE, GET, HEAD, POST"))))
    {
        goto Failed;
    }

    if (FAILED(hr = pW3Request->GetUrl(&strUrl)))
    {
        goto Failed;
    }

    if (wcscmp(strUrl.QueryStr(), L"*") != 0 &&
        wcscmp(strUrl.QueryStr(), L"/*") != 0)
    {
        //
        // Add Allow header
        //
        if (FAILED(hr = pW3Context->SetupAllowHeader()))
        {
            goto Failed;
        }

        //
        // Also figure out whether Frontpage is enabled and send
        // MS-Author-Via header if so
        // Cannot store it with the metadata since we do not want to pick
        // up the inherited value, can store with url-info but deferred
        // for later (BUGBUG)
        //
        MB mb( g_pW3Server->QueryMDObject() );
        BOOL fIsFrontPageWeb;

        if (!mb.Open(pW3Context->QuerySite()->QueryMBRoot()->QueryStr()))
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            goto Failed;
        }

        if (mb.GetDword(strUrl.QueryStr(),
                        MD_FRONTPAGE_WEB,
                        IIS_MD_UT_SERVER,
                        (DWORD *)&fIsFrontPageWeb,
                        METADATA_NO_ATTRIBUTES) &&
            fIsFrontPageWeb)
        {
            if (FAILED(hr = pW3Response->SetHeader(HEADER("MS-Author-Via"),
                                                   HEADER("MS-FP/4.0"))))
            {
                goto Failed;
            }
        }

        DBG_REQUIRE( mb.Close() );
    }
    else
    {
        pW3Response->SetHeaderByReference(HttpHeaderAllow,
                                          HEADER("OPTIONS, TRACE, GET, HEAD, POST"));
    }

    if (FAILED(hr = pW3Context->SendResponse(W3_FLAG_ASYNC)))
    {
        goto Failed;
    }

    return CONTEXT_STATUS_PENDING;

 Failed:
    pW3Context->SetErrorStatus(hr);
    pW3Response->SetStatus(HttpStatusServerError);
    pW3Context->SendResponse(W3_FLAG_SYNC);

    return CONTEXT_STATUS_CONTINUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\iisplus\ulw3\range.cxx ===
/*++

   Copyright    (c)    2000    Microsoft Corporation

   Module Name :
     range.cxx

   Abstract:
     Handle Range Requests

   Author:
     Anil Ruia (AnilR)            29-Mar-2000

   Environment:
     Win32 - User Mode

   Project:
     UlW3.dll
--*/

#include "precomp.hxx"
#include "staticfile.hxx"

#define RANGE_BOUNDARY  "<q1w2e3r4t5y6u7i8o9p0zaxscdvfbgnhmjklkl>"
#define MAX_RANGE_ALLOWED 5

extern BOOL FindInETagList(LPCSTR pLocalETag,
                           LPCSTR pETagList,
                           BOOL   fWeakCompare);


STRA  *W3_STATIC_FILE_HANDLER::sm_pstrRangeContentType;
STRA  *W3_STATIC_FILE_HANDLER::sm_pstrRangeMidDelimiter;
STRA  *W3_STATIC_FILE_HANDLER::sm_pstrRangeEndDelimiter;
DWORD  W3_STATIC_FILE_HANDLER::sm_dwMaxRangeAllowed = MAX_RANGE_ALLOWED;


// static
HRESULT W3_STATIC_FILE_HANDLER::Initialize()
{
    ALLOC_CACHE_CONFIGURATION       acConfig;
    HRESULT                         hr = NO_ERROR;

    //
    // Setup allocation lookaside
    //
    
    acConfig.nConcurrency = 1;
    acConfig.nThreshold = 100;
    acConfig.cbSize = sizeof( W3_STATIC_FILE_HANDLER );

    DBG_ASSERT( sm_pachStaticFileHandlers == NULL );
    
    sm_pachStaticFileHandlers = new ALLOC_CACHE_HANDLER( "W3_STATIC_FILE_HANDLER",  
                                                         &acConfig );

    if ( sm_pachStaticFileHandlers == NULL )
    {
        hr = HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );
        goto Failed;
    }

    //
    // Initialize the various Range Strings
    //
    sm_pstrRangeContentType = new STRA;
    sm_pstrRangeMidDelimiter = new STRA;
    sm_pstrRangeEndDelimiter = new STRA;
    if (sm_pstrRangeContentType == NULL ||
        sm_pstrRangeMidDelimiter == NULL ||
        sm_pstrRangeEndDelimiter == NULL)
    {
        hr = HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
        goto Failed;
    }

    if (FAILED(hr = sm_pstrRangeContentType->Copy(
                        "multipart/byteranges; boundary=")) ||
        FAILED(hr = sm_pstrRangeContentType->Append(RANGE_BOUNDARY)))
    {
        goto Failed;
    }

    if (FAILED(hr = sm_pstrRangeMidDelimiter->Copy("--")) ||
        FAILED(hr = sm_pstrRangeMidDelimiter->Append(RANGE_BOUNDARY)) ||
        FAILED(hr = sm_pstrRangeMidDelimiter->Append("\r\n")))
    {
        goto Failed;
    }

    if (FAILED(hr = sm_pstrRangeEndDelimiter->Copy("\r\n--")) ||
        FAILED(hr = sm_pstrRangeEndDelimiter->Append(RANGE_BOUNDARY)) ||
        FAILED(hr = sm_pstrRangeEndDelimiter->Append("--\r\n\r\n")))
    {
        goto Failed;
    }

    HKEY w3Params;
    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                     W3_PARAMETERS_KEY,
                     0,
                     KEY_READ,
                     &w3Params) == NO_ERROR)
    {
        DWORD dwType;
        DWORD cbData = sizeof DWORD;
        if ((RegQueryValueEx(w3Params,
                             L"MaximumRangeAllowed",
                             NULL,
                             &dwType,
                             (LPBYTE)&sm_dwMaxRangeAllowed,
                             &cbData) != NO_ERROR) ||
            (dwType != REG_DWORD))
        {
            sm_dwMaxRangeAllowed = MAX_RANGE_ALLOWED;
        }

        RegCloseKey(w3Params);
    }

    return S_OK;

 Failed:
    Terminate();
    return hr;
}


BOOL ScanRange(LPCSTR         *ppszRange,
               ULARGE_INTEGER  liFileSize,
               ULARGE_INTEGER *pliOffset,
               ULARGE_INTEGER *pliSize,
               BOOL           *pfInvalidRange)
/*++
  Routine Description:
    Scan the next range in strRange

  Returns:
    TRUE if a range was found, else FALSE

  Arguments:
    ppszRange       String pointing to the current range.
    liFileSize      Size of the file being retrieved
    pliOffset       range offset on return
    pliSizeTo       range size on return
    pfInvalidRange  set to TRUE on return if Invalid syntax
--*/
{
    LPCSTR pszRange = *ppszRange;

    //
    // Skip to begining of next range
    //
    while (*pszRange == ' ')
    {
        ++pszRange;
    }

    //
    // Test for no range
    //
    if (*pszRange == '\0')
    {
        return FALSE;
    }

    //
    // determine Offset & Size to send
    //
    if (*pszRange == '-')
    {
        //
        // This is in format -nnn which means send bytes filesize-nnn
        // to eof
        //
        ++pszRange;

        if (!isdigit(*pszRange))
        {
            *pfInvalidRange = TRUE;
            return TRUE;
        }

        pliSize->QuadPart = _atoi64(pszRange);
        if (pliSize->QuadPart > liFileSize.QuadPart)
        {
            pliSize->QuadPart = liFileSize.QuadPart;
            pliOffset->QuadPart = 0;
        }
        else
        {
            pliOffset->QuadPart = liFileSize.QuadPart - pliSize->QuadPart;
        }
    }
    else if (isdigit(*pszRange))
    {
        //
        // This is in format mmm-nnn which menas send bytes mmm to nnn
        //         or format mmm- which means send bytes mmm to eof
        //
        pliOffset->QuadPart = _atoi64(pszRange);

        //
        // Skip over the beginning number - and any intervening spaces
        //
        while(isdigit(*pszRange))
        {
            pszRange++;
        }

        while(*pszRange == ' ')
        {
            pszRange++;
        }

        if (*pszRange != '-')
        {
            *pfInvalidRange = TRUE;
            return TRUE;
        }
        pszRange++;

        while(*pszRange == ' ')
        {
            pszRange++;
        }

        if (isdigit(*pszRange))
        {
            //
            // We have mmm-nnn
            //
            ULARGE_INTEGER liEnd;
            liEnd.QuadPart = _atoi64(pszRange);
            if (liEnd.QuadPart < pliOffset->QuadPart)
            {
                *pfInvalidRange = TRUE;
                return TRUE;
            }

            if (liEnd.QuadPart >= liFileSize.QuadPart)
            {
                pliSize->QuadPart = liFileSize.QuadPart - pliOffset->QuadPart;
            }
            else
            {
                pliSize->QuadPart = liEnd.QuadPart - pliOffset->QuadPart + 1;
            }
        }
        else
        {
            //
            // We have mmm-
            //
            pliSize->QuadPart = liFileSize.QuadPart - pliOffset->QuadPart;
        }
    }
    else
    {
        //
        // Invalid Syntax
        //
        *pfInvalidRange = TRUE;
        return TRUE;
    }

    //
    // Skip to the start of the next range
    //
    while (isdigit(*pszRange))
    {
        ++pszRange;
    }

    while (*pszRange == ' ')
    {
        ++pszRange;
    }

    if (*pszRange == ',')
    {
        ++pszRange;
    }
    else if (*pszRange != '\0')
    {
        *pfInvalidRange = TRUE;
        return TRUE;
    }

    *ppszRange = pszRange;
    return TRUE;
}


HRESULT W3_STATIC_FILE_HANDLER::RangeDoWork(W3_CONTEXT   *pW3Context,
                                            W3_FILE_INFO *pOpenFile,
                                            BOOL         *pfHandled)
{
    W3_REQUEST  *pRequest  = pW3Context->QueryRequest();
    W3_RESPONSE *pResponse = pW3Context->QueryResponse();

    // First, handle If-Range: if it exists.  If the If-Range matches we
    // don't do anything. If the If-Range doesn't match then we force
    // retrieval of the whole file.

    LPCSTR pszIfRange = pRequest->GetHeader(HttpHeaderIfRange);
    if (pszIfRange != NULL && *pszIfRange != L'\0')
    {
        // Need to determine if what we have is a date or an ETag.
        // An ETag may start with a W/ or a quote. A date may start
        // with a W but will never have the second character be a /.

        if (*pszIfRange == L'"' ||
            (*pszIfRange == L'W' && pszIfRange[1] == L'/'))
        {
            // This is an ETag.
            if (pOpenFile->QueryIsWeakETag() ||
                !FindInETagList(pOpenFile->QueryETag(),
                                pszIfRange,
                                FALSE))
            {
                // The If-Range failed, so we can't send a range. Force
                // sending the whole thing.
                *pfHandled = FALSE;
                return S_OK;
            }
        }
        else
        {
            // This is a date
            LARGE_INTEGER   liRangeTime;

            // This must be a date. Convert it to a time, and see if it's
            // less than or equal to our last write time. If it is, the
            // file's changed, and we can't perform the range.

            if (!StringTimeToFileTime(pszIfRange, &liRangeTime))
            {
                // Couldn't convert it, so don't send the range.
                *pfHandled = FALSE;
                return S_OK;
            }
            else
            {
                FILETIME tm;
                
                pOpenFile->QueryLastWriteTime(&tm);

                if (*(LONGLONG*)&tm > liRangeTime.QuadPart )
                {
                    // The If-Range failed, so we can't send a range. Force
                    // sending the whole thing.
                    *pfHandled = FALSE;
                    return S_OK;
                }
            }
        }
    }

    // If we fell through, then If-Range passed, we are going to try sending
    // a range response
    LPCSTR pszRange = pRequest->GetHeader(HttpHeaderRange);
    //
    // We have bytes = <range1>, <range2>, ...
    // skip past the '='
    //
    pszRange = strchr(pszRange, '=');
    if (pszRange == NULL)
    {
        // Invalid syntax, send entire file
        *pfHandled = FALSE;
        return S_OK;
    }
    pszRange++;

    ULARGE_INTEGER liFileSize;
    HRESULT hr = S_OK;
    pOpenFile->QuerySize(&liFileSize);
    if (liFileSize.QuadPart <= 0)
    {
        pResponse->ClearHeaders();
        pResponse->SetStatus(HttpStatusRangeNotSatisfiable);

        CHAR pszContentRange[32];
        strcpy(pszContentRange, "bytes */");
        _i64toa(liFileSize.QuadPart, pszContentRange + 8, 10);
        if (FAILED(hr = pResponse->SetHeader(HttpHeaderContentRange,
                                             pszContentRange,
                                             (USHORT)strlen(pszContentRange))))
        {
            return hr;
        }

        *pfHandled = TRUE;
        return S_OK;
    }

    DWORD cRanges = 0;
    STACK_BUFFER( bufByteRange, 256);
    HTTP_BYTE_RANGE *pByteRange;
    ULARGE_INTEGER liRangeOffset;
    ULARGE_INTEGER liRangeSize;
    BOOL fInvalidSyntax = FALSE;
    BOOL fAtLeastOneRange = FALSE;
    ULONGLONG dwTotalRangeBytes = 0;

    while (ScanRange(&pszRange,
                     liFileSize,
                     &liRangeOffset,
                     &liRangeSize,
                     &fInvalidSyntax))
    {
        fAtLeastOneRange = TRUE;

        if (fInvalidSyntax)
        {
            //
            // Invalid syntax in Range header.  Ignore Range headers,
            // Send complete File.
            //
            *pfHandled = FALSE;
            return S_OK;
        }

        if (liRangeOffset.QuadPart > liFileSize.QuadPart ||
            liRangeSize.QuadPart == 0)
        {
            //
            // The Range is not satisfiable
            //
            continue;
        }

        cRanges++;

        if (cRanges * sizeof(HTTP_BYTE_RANGE) > bufByteRange.QuerySize())
        {
            if (!bufByteRange.Resize(cRanges * sizeof(HTTP_BYTE_RANGE), 256))
            {
                return HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
            }
        }

        pByteRange = (HTTP_BYTE_RANGE *)bufByteRange.QueryPtr();
        pByteRange[cRanges - 1].StartingOffset.QuadPart = liRangeOffset.QuadPart;
        pByteRange[cRanges - 1].Length.QuadPart         = liRangeSize.QuadPart;

        //
        // Keep track of the total bytes in all the ranges combined
        //
        dwTotalRangeBytes += liRangeSize.QuadPart;
    }

    if (dwTotalRangeBytes > (liFileSize.QuadPart * sm_dwMaxRangeAllowed))
    {
        pResponse->ClearHeaders();
        pResponse->SetStatus(HttpStatusBadRequest);

        *pfHandled = TRUE;
        return S_OK;
    }

    if (!fAtLeastOneRange)
    {
        //
        // Syntactically invalid, ignore the range header
        //
        *pfHandled = FALSE;
        return S_OK;
    }

    if (cRanges == 0)
    {
        //
        // No byte ranges are satisfiable
        //
        pResponse->ClearHeaders();
        pResponse->SetStatus(HttpStatusRangeNotSatisfiable);

        CHAR pszContentRange[32];
        strcpy(pszContentRange, "bytes */");
        _i64toa(liFileSize.QuadPart, pszContentRange + 8, 10);
        if (FAILED(hr = pResponse->SetHeader(HttpHeaderContentRange,
                                             pszContentRange,
                                             (USHORT)strlen(pszContentRange))))
        {
            return hr;
        }

        *pfHandled = TRUE;
        return S_OK;
    }

    *pfHandled = TRUE;
    pResponse->SetStatus(HttpStatusPartialContent);
    STRA *pstrContentType = pW3Context->QueryUrlContext()->QueryUrlInfo()->
        QueryContentType();

    STACK_STRA ( strPartContentType, 128);
    if (cRanges == 1)
    {
        //
        // Only one chunk, Content-Type is same as that of complete entity
        //
        if (FAILED(hr = pResponse->SetHeaderByReference(
                            HttpHeaderContentType,
                            pstrContentType->QueryStr(),
                            (USHORT)pstrContentType->QueryCCH())))
        {
            return hr;
        }
    }
    else
    {
        //
        // Content-Type is multipart/byteranges; boundary=....
        //
        if (FAILED(hr = pResponse->SetHeaderByReference(
                            HttpHeaderContentType,
                            sm_pstrRangeContentType->QueryStr(),
                            (USHORT)sm_pstrRangeContentType->QueryCCH())))
        {
            return hr;
        }

        //
        // The actual content-type of the entity to be sent with each part
        //
        if (FAILED(hr = strPartContentType.Copy("Content-Type: ")) ||
            FAILED(hr = strPartContentType.Append(*pstrContentType)) ||
            FAILED(hr = strPartContentType.Append("\r\n")))
        {
            return hr;
        }
    }

    //
    // build the response
    //
    STRA strContentRange;
    STRA strDelimiter;
    pByteRange = (HTTP_BYTE_RANGE *)bufByteRange.QueryPtr();
    for (DWORD i = 0; i < cRanges; i++)
    {
        liRangeOffset.QuadPart = pByteRange[i].StartingOffset.QuadPart;
        liRangeSize.QuadPart   = pByteRange[i].Length.QuadPart;

        //
        // Build up the Content-Range header
        //
        CHAR pszSize[32];
        if (FAILED(hr = strContentRange.Copy("bytes ")))
        {
            return hr;
        }
        _i64toa(liRangeOffset.QuadPart, pszSize, 10);
        if (FAILED(hr = strContentRange.Append(pszSize)) ||
            FAILED(hr = strContentRange.Append("-")))
        {
            return hr;
        }
        _i64toa(liRangeOffset.QuadPart + liRangeSize.QuadPart - 1,
                pszSize, 10);
        if (FAILED(hr = strContentRange.Append(pszSize)) ||
            FAILED(hr = strContentRange.Append("/")))
        {
            return hr;
        }
        _i64toa(liFileSize.QuadPart, pszSize, 10);
        if (FAILED(hr = strContentRange.Append(pszSize)))
        {
            return hr;
        }

        if (cRanges == 1)
        {
            //
            // If only one chunk, send Content-Range as a header
            //
            if (FAILED(hr = pResponse->SetHeader(HttpHeaderContentRange,
                                                 strContentRange.QueryStr(),
                                                 (USHORT)strContentRange.QueryCCH())))
            {
                return hr;
            }
        }
        else
        {
            if (i > 0)
            {
                // Already sent a range, add a newline
                if (FAILED(hr = strDelimiter.Copy("\r\n", 2)))
                {
                    return hr;
                }
            }

            //
            // Add delimiter, Content-Type, Content-Range
            //
            if (FAILED(hr = strDelimiter.Append(*sm_pstrRangeMidDelimiter)) ||
                FAILED(hr = strDelimiter.Append(strPartContentType)) ||
                FAILED(hr = strDelimiter.Append(HEADER("Content-Range: "))) ||
                FAILED(hr = strDelimiter.Append(strContentRange)) ||
                FAILED(hr = strDelimiter.Append("\r\n\r\n", 4)))
            {
                return hr;
            }

            //
            // store the ANSI version in the BUFFER chain
            //
            DWORD bufSize = strDelimiter.QueryCCH() + 1;
            BUFFER_CHAIN_ITEM *pBCI = new BUFFER_CHAIN_ITEM(bufSize);
            if (pBCI == NULL)
            {
                return HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
            }
            memcpy(pBCI->QueryPtr(),
                   strDelimiter.QueryStr(),
                   bufSize);
            if (!m_RangeBufferChain.AppendBuffer(pBCI))
            {
                return HRESULT_FROM_WIN32(GetLastError());
            }

            //
            // Now actually add this delimiter chunk
            //
            if (FAILED(hr = pResponse->AddMemoryChunkByReference(
                                           pBCI->QueryPtr(),
                                           bufSize - 1)))
            {
                return hr;
            }
        }

        //
        // Add the actual file chunk
        //
        if (pOpenFile->QueryFileBuffer() != NULL &&
            liRangeSize.HighPart == 0 &&
            liRangeOffset.HighPart == 0)
        {
            hr = pResponse->AddMemoryChunkByReference(
                     pOpenFile->QueryFileBuffer() + liRangeOffset.LowPart,
                     liRangeSize.LowPart);
        }
        else
        {
            hr = pResponse->AddFileHandleChunk( pOpenFile->QueryFileHandle(),
                                                liRangeOffset.QuadPart,
                                                liRangeSize.QuadPart );
        }

        if (FAILED(hr))
        {
            return hr;
        }
    }

    if (cRanges > 1)
    {
        //
        // Add the terminating delimiter
        //
        if (FAILED(hr = pResponse->AddMemoryChunkByReference(
                            sm_pstrRangeEndDelimiter->QueryStr(),
                            sm_pstrRangeEndDelimiter->QueryCCH())))
        {
            return hr;
        }
    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\iisplus\ulw3\redirect.cxx ===
/*++

Copyright (c) 1999-2000 Microsoft Corporation

Module Name:

    redirect.cxx

Abstract:

    This module contains code for handling HTTP redirections in server.


Revision History:

    balam       10-Jan-1996     Created
    taylorw     04-Apr-2000     Ported to IIS+

--*/

#include <precomp.hxx>
#include "redirect.hxx"

enum REDIR_TOKEN
{
    REDIR_TOKEN_EXACT_DST,
    REDIR_TOKEN_PERMANENT,
    REDIR_TOKEN_TEMPORARY,
    REDIR_TOKEN_SUFFIX,
    REDIR_TOKEN_FULL,
    REDIR_TOKEN_PARAMETERS,
    REDIR_TOKEN_QMARK_PARAMETERS,
    REDIR_TOKEN_VROOT_REQUEST,
    REDIR_TOKEN_CHILD_ONLY,
    REDIR_TOKEN_UNKNOWN
};

struct _REDIR_TOKEN_LIST
{
    WCHAR *          pszKeyword;
    DWORD            cbLen;
    REDIR_TOKEN      rtType;
}
RedirectTokenList[] =
{
    L"EXACT_DESTINATION",   17, REDIR_TOKEN_EXACT_DST,
    L"PERMANENT",           9,  REDIR_TOKEN_PERMANENT,
    L"TEMPORARY",           9,  REDIR_TOKEN_TEMPORARY,
    L"$S",                  2,  REDIR_TOKEN_SUFFIX,
    L"$P",                  2,  REDIR_TOKEN_PARAMETERS,
    L"$Q",                  2,  REDIR_TOKEN_QMARK_PARAMETERS,
    L"$V",                  2,  REDIR_TOKEN_VROOT_REQUEST,
    L"CHILD_ONLY",          10, REDIR_TOKEN_CHILD_ONLY,
    NULL,                   0,  REDIR_TOKEN_UNKNOWN
};

DWORD
GetRedirectToken(
    IN  WCHAR *     pchToken,
    OUT DWORD *     pdwLen
)
/*++

Routine Description:

    Searches token table for match.

Arguments:

    pchToken - Pointer to string to search for.
    pdwLen - Receives the length of matched token.

Return Value:

    The type (REDIR_TOKEN enum) of the token if matched.
    Or REDIR_TOKEN_UNKNOWN if string not found.

--*/
{
    DWORD           dwCounter = 0;

    while ( RedirectTokenList[ dwCounter ].pszKeyword != NULL )
    {
        if ( !_wcsnicmp( pchToken,
                         RedirectTokenList[ dwCounter ].pszKeyword,
                         RedirectTokenList[ dwCounter ].cbLen ) )
        {
            break;
        }
        dwCounter++;
    }
    if ( pdwLen != NULL )
    {
        *pdwLen = RedirectTokenList[ dwCounter ].cbLen;
    }
    return RedirectTokenList[ dwCounter ].rtType;
}

HRESULT
REDIRECTION_BLOB::ParseDestination(
    IN STRU &           strDestination
)
/*++

Routine Description:

    Parse destination template.

Arguments:

    strDestination - Destination template

Return Value:

    HRESULT

--*/
{
    WCHAR *             pchNextComma = NULL;
    DWORD               cbTokenLen;
    STACK_STRU(         strOptions, MAX_PATH );
    WCHAR *             pchWhiteSpace;
    DWORD               cchLen;
    HRESULT             hr;

    //
    // first separate out the destination path from the options (if any)
    //

    pchNextComma = wcschr( strDestination.QueryStr(), L',' );
    if ( pchNextComma != NULL )
    {
        if ( FAILED( hr = strOptions.Copy( pchNextComma + 1 ) ) )
        {
            return hr;
        }

        cchLen = (DWORD)DIFF(pchNextComma - strDestination.QueryStr());
    }
    else
    {
        cchLen = strDestination.QueryCCH();
    }

    if ( FAILED( hr = _strDestination.Copy( strDestination.QueryStr(),
                                            cchLen ) ) )
    {
        return hr;
    }

    //
    // look for any trailing white space in destination, remove it
    //

    pchWhiteSpace = _strDestination.QueryStr() + _strDestination.QueryCCH();

    while( pchWhiteSpace > _strDestination.QueryStr() )
    {
        if ( !iswspace( *( pchWhiteSpace - 1 ) ) )
        {
            break;
        }

        _strDestination.SetLen( --cchLen );

        pchWhiteSpace--;
    }

    //
    // now check whether this is a wildcard redirection
    //

    if ( _strDestination.QueryStr()[0] == L'*' )
    {
        if ( FAILED( hr = ParseWildcardDestinations() ) )
        {
            return hr;
        }

        _fWildcards = TRUE;
    }
    else
    {
        //
        // cache whether we expect tokens in the destination template
        //

        if ( wcschr( _strDestination.QueryStr(), L'$' ) != NULL )
        {
            _fHasTokens = TRUE;
        }
    }

    if ( !strOptions.IsEmpty() )
    {
        //
        // parse and cache any options set for redirection
        //

        pchNextComma = strOptions.QueryStr();

        for (;;)
        {
            while ( iswspace( *pchNextComma ) )
            {
                pchNextComma++;
            }

            switch ( GetRedirectToken( pchNextComma, &cbTokenLen ) )
            {
                case REDIR_TOKEN_EXACT_DST:
                    _fExactDestination = TRUE;
                    break;
                case REDIR_TOKEN_PERMANENT:
                    _redirectType = PERMANENT_REDIRECT;
                    break;
                case REDIR_TOKEN_TEMPORARY:
                    _redirectType = TEMPORARY_REDIRECT;
                    break;
                case REDIR_TOKEN_CHILD_ONLY:
                    _fChildOnly = TRUE;
                    break;
                default:
                    break;
            }

            pchNextComma = wcschr( pchNextComma, L',' );

            if ( pchNextComma == NULL )
            {
                break;
            }

            pchNextComma++;
        }
    }

    return S_OK;
}

HRESULT
REDIRECTION_BLOB::ParseWildcardDestinations()
/*++

Routine Description:

    Parse wildcard destination.

    Wildcard destination takes the form:

    *;<wildcard1>;<destination1>;<wildcard2>;<destination2>...
    eg. *;*.stm;/default1.htm;*.htm;/default2.htm

Arguments:

    None

Return Value:

    HRESULT

--*/
{
    WCHAR *             pchCursor;
    WCHAR *             pchNext;
    WCHAR *             pchEndToken;
    WILDCARD_ENTRY     *pEntry;
    HRESULT             hr;

    pchCursor = wcschr( _strDestination.QueryStr(), L';' );

    if ( pchCursor == NULL )
    {
        return HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);
    }

    while ( pchCursor != NULL )
    {
        pchCursor++;

        pchNext = wcschr( pchCursor, L';' );
        if ( pchNext == NULL )
        {
            break;
        }

        while ( iswspace( *pchCursor ) )
        {
            pchCursor++;
        }

        pEntry = AddWildcardEntry();
        if ( pEntry == NULL )
        {
            return HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
        }

        pchEndToken = pchNext - 1;
        while ( iswspace( *pchEndToken ) )
        {
            pchEndToken--;
        }

        if ( FAILED( hr = pEntry->_strWildSource.Copy(
                              pchCursor,
                              (DWORD)DIFF(pchEndToken - pchCursor) + 1 ) ) )
        {
            return hr;
        }

        pchCursor = pchNext + 1;

        while ( iswspace( *pchCursor ) )
        {
            pchCursor++;
        }

        pchNext = wcschr( pchCursor, ';' );

        if ( pchNext == NULL )
        {
            if ( FAILED( hr = pEntry->_strWildDest.Copy( pchCursor ) ) )
            {
                return hr;
            }
        }
        else
        {
            pchEndToken = pchNext - 1;
            while ( iswspace( *pchEndToken ) )
            {
                pchEndToken--;
            }

            if ( FAILED( hr = pEntry->_strWildDest.Copy(
                                  pchCursor,
                                  (DWORD)DIFF(pchEndToken - pchCursor) + 1 ) ) )
            {
                return hr;
            }
        }

        _fHasTokens |= wcschr( pEntry->_strWildDest.QueryStr(), L'$' ) != NULL;

        pchCursor = pchNext;
    }

    return S_OK;
}

HRESULT
REDIRECTION_BLOB::GetDestination(
    IN  W3_CONTEXT     *pW3Context,
    OUT STRU           *pstrFinalDestination,
    OUT BOOL           *pfMatch,
    OUT HTTP_STATUS    *pStatusCode
)
/*++

Routine Description:

    Get the complete destination of a redirection

Arguments:

    pW3Context      - W3_CONTEXT associated with the request
    pstrDestination - Redirection destination placed here
    pdwServerCode   - Server code of redirect (HT_REDIRECT or HT_MOVED )

Return Value:

    HRESULT

--*/
{
    STACK_STRU(         strMatchedSuffix, MAX_PATH );
    STACK_STRU(         strRequestedURL, MAX_PATH );
    STACK_STRU(         strParameters, MAX_PATH );
    STRU *              pstrDestination;
    WILDCARD_ENTRY     *pEntry = NULL;
    HRESULT             hr;

    if (FAILED(hr = pW3Context->QueryRequest()->GetUrl(&strRequestedURL)))
    {
        return hr;
    }

    WILDCARD_MATCH_LIST wmlList( strRequestedURL.QueryCCH() );

    if (FAILED(hr = pW3Context->QueryRequest()->GetQueryString(&strParameters)))
    {
        return hr;
    }

    switch (_redirectType)
    {
    case NORMAL_REDIRECT:
        *pStatusCode = HttpStatusRedirect;
        break;
    case PERMANENT_REDIRECT:
        *pStatusCode = HttpStatusMovedPermanently;
        break;
    case TEMPORARY_REDIRECT:
        *pStatusCode = HttpStatusMovedTemporarily;
        break;
    default:
        DBG_ASSERT(FALSE);
    }

    DBG_ASSERT(strRequestedURL.QueryCCH() >= _strSource.QueryCCH());

    if ( FAILED( hr = strMatchedSuffix.Copy(
                          strRequestedURL.QueryStr() +
                          _strSource.QueryCCH() ) ) )
    {
        return hr;
    }

    if ( _fChildOnly )
    {
        //
        // Make sure the URL is a child of the current URL (i.e. it
        // does not have more than one component following the matched
        // portion)
        //
        WCHAR * pchOtherSlash;

        pchOtherSlash = wcschr( strMatchedSuffix.QueryStr(), L'/' );
        if ( pchOtherSlash == strMatchedSuffix.QueryStr() )
        {
            pchOtherSlash = wcschr( pchOtherSlash + 1, L'/' );
        }

        if ( pchOtherSlash != NULL &&
             pchOtherSlash[1] != L'\0' )
        {
            *pfMatch = FALSE;
            return S_OK;
        }
    }

    if ( _fWildcards )
    {
        if ( FAILED(hr = FindWildcardMatch( strMatchedSuffix,
                                            &pEntry,
                                            &wmlList ) ) )
        {
            return hr;
        }

        if (pEntry == NULL)
        {
            *pfMatch = FALSE;
            return S_OK;
        }

        pstrDestination = &(pEntry->_strWildDest);
    }
    else
    {
        pstrDestination = &_strDestination;
    }

    if ( !_fHasTokens )
    {
        if ( FAILED(hr = pstrFinalDestination->Copy( *pstrDestination ) ) )
        {
            return hr;
        }
    }
    else
    {
        WCHAR           achAdd[ 2 ] = { L'\0', L'\0' };
        WCHAR           ch;
        WCHAR *         pchCursor = pstrDestination->QueryStr();
        DWORD           cchLen;
        WCHAR *         pchNext;

        while ( ( ch = *pchCursor ) != L'\0' )
        {
            switch ( ch )
            {
            case L'$':
                // Substitute for special tokens in destination template

                switch ( GetRedirectToken( pchCursor, &cchLen ) )
                {
                case REDIR_TOKEN_SUFFIX:
                    pchCursor += ( cchLen - 1 );
                    if ( FAILED(hr = pstrFinalDestination->Append( strMatchedSuffix ) ) )
                    {
                        return hr;
                    }
                    break;
                case REDIR_TOKEN_VROOT_REQUEST:
                    pchCursor += ( cchLen - 1 );
                    if ( FAILED(hr = pstrFinalDestination->Append( strRequestedURL ) ) )
                    {
                        return hr;
                    }
                    break;
                case REDIR_TOKEN_PARAMETERS:
                    pchCursor += ( cchLen - 1 );
                    if ( FAILED(hr = pstrFinalDestination->Append( strParameters ) ) )
                    {
                        return hr;
                    }
                    break;
                case REDIR_TOKEN_QMARK_PARAMETERS:
                    pchCursor += ( cchLen - 1 );
                    if ( !strParameters.IsEmpty() )
                    {
                        if ( FAILED(hr = pstrFinalDestination->Append( L"?" ) ) ||
                             FAILED(hr = pstrFinalDestination->Append( strParameters ) ) )
                        {
                            return hr;
                        }
                    }
                    break;
                default:
                    pchCursor++;
                    ch = *pchCursor;
                    if ( iswdigit( ch ) )
                    {
                        if ( FAILED(hr = pstrFinalDestination->Append(
                                wmlList.GetMatchNumber( ch - L'0' ) ) ) )
                        {
                            return hr;
                        }
                    }
                    else
                    {
                        if ( FAILED(hr = pstrFinalDestination->Append( L"$" ) ) )
                        {
                            return hr;
                        }

                        if (ch == L'\0')
                        {
                            pchCursor--;
                        }
                        else
                        {
                            achAdd[ 0 ] = ch;
                            if ( FAILED(hr = pstrFinalDestination->Append( achAdd ) ) )
                            {
                                return hr;
                            }
                        }
                    }
                }
                break;
            default:
                pchNext = pchCursor;
                while ( pchCursor[ 1 ] != L'$' && pchCursor[ 1 ] != L'\0' )
                {
                    pchCursor++;
                }
                if ( FAILED(hr = pstrFinalDestination->Append(
                                     pchNext, 
                                     (DWORD)DIFF(pchCursor - pchNext) + 1 ) ) )
                {
                    return hr;
                }
            }
            pchCursor++;
        }
    }

    // was EXACT_DESTINATION option used?

    *pfMatch = TRUE;
    if ( !_fExactDestination )
    {
        return pstrFinalDestination->Append( strMatchedSuffix );
    }

    return S_OK;
}

HRESULT
REDIRECTION_BLOB::FindWildcardMatch(
    IN STRU &                   strInput,
    OUT WILDCARD_ENTRY **       ppEntry,
    OUT WILDCARD_MATCH_LIST *   pwmlList
)
/*++

Routine Description:

    Searches WILDCARD_ENTRYs for the first that matches the input string.
    Also fills in a WILDCARD_MATCH_LIST for the matched string (if any).

Arguments:

    strInput - Input string to check
    ppEntry - Set to point to the WILDCARD_ENTRY that matches (or NULL)
    pwmlList - Filled in if strInput matches a template

Return Value:

    TRUE on success, FALSE on failure

--*/
{
    for ( LIST_ENTRY *pListEntry = _ListHead.Flink;
          pListEntry != &_ListHead;
          pListEntry = pListEntry->Flink )
    {
        WILDCARD_ENTRY *pWildcardEntry = CONTAINING_RECORD( pListEntry,
                                            WILDCARD_ENTRY,
                                            _ListEntry );

        HRESULT hr;
        BOOL    fMatch = FALSE;
        if ( FAILED(hr = IsWildcardMatch( strInput,
                                          pWildcardEntry->_strWildSource,
                                          pwmlList,
                                          &fMatch ) ) )
        {
            return hr;
        }

        if (fMatch)
        {
            *ppEntry = pWildcardEntry;
            return S_OK;
        }
    }

    *ppEntry = NULL;
    return S_OK;
}

HRESULT
REDIRECTION_BLOB::IsWildcardMatch(
    IN STRU &                   strInput,
    IN STRU &                   strTemplate,
    OUT WILDCARD_MATCH_LIST *   pwmlList,
    BOOL                    *   pfMatch
)
/*++

Routine Description:

    Checks whether input string matches wildcard expression of internal
    source string.  For example:  given internal source of "a*b*c",
    "abooc", "asdfjbsdfc" match, "foobar", "scripts" do not match

Arguments:

    strInput - input string to check for wildcard match
    pwmlList - List of matched strings (one for each * in wildcard)
               Only generated if the destination string of
               contains special tokens.

Return Value:

    HRESULT

--*/
{
    WCHAR           chExpr;
    WCHAR           chTemp;
    WCHAR *         pchExpr = strTemplate.QueryStr();
    WCHAR *         pchTest = strInput.QueryStr();
    WCHAR *         pchEnd;
    HRESULT         hr;

    pwmlList->Reset();

    pchEnd = pchExpr + strTemplate.QueryCCH();
    for (;;)
    {
        chExpr = *pchExpr++;
        if ( chExpr == L'\0' )
        {
            if ( *pchTest == L'\0' )
            {
                *pfMatch = TRUE;
            }
            else
            {
                *pfMatch = FALSE;
            }

            return S_OK;
        }
        else if ( chExpr != L'*' )
        {
            chTemp = *pchTest++;
            if ( chTemp != chExpr )
            {
                *pfMatch = FALSE;
                return S_OK;
            }
        }
        else
        {
            INT             iComLen;
            WCHAR *         pchNextWild;

            while ( *pchExpr == L'*' )
            {
                pchExpr++;
            }

            pchNextWild = wcschr( pchExpr, L'*' );
            iComLen = pchNextWild == NULL ? (DWORD)DIFF(pchEnd - pchExpr) :
                                            (DWORD)DIFF(pchNextWild - pchExpr);
            while ( *pchTest != '\0' )
            {
                if ( wcsncmp( pchExpr,
                              pchTest,
                              iComLen ) || !iComLen )
                {
                    // if the destination has tokens, then generate WML
                    if ( _fHasTokens &&
                         FAILED(hr = pwmlList->AddChar( *pchTest ) ) )
                    {
                        return hr;
                    }
                    pchTest++;
                }
                else
                {
                    break;
                }
            }

            if ( *pchTest == L'\0' && iComLen )
            {
                *pfMatch = FALSE;
                return S_OK;
            }
            else if ( _fHasTokens && FAILED(hr = pwmlList->NewString() ) )
            {
                return hr;
            }
        }
    }
}

HRESULT
W3_CONTEXT::CheckUrlRedirection(BOOL *pfRedirected,
                                STRU *pstrDestination,
                                HTTP_STATUS *pStatusCode)
/*++

Routine Description:

    Do a HTTP redirect as specified by template in metadata.

Arguments:

    pfRedirected - TRUE if client-side redirection to be performed
    pstrDestination - URL to be redirected to
    pStatusCode - status-code to be used for the redirection

Return Value:

    HRESULT

--*/
{
    REDIRECTION_BLOB *pRBlob = QueryUrlContext()->QueryMetaData()->QueryRedirectionBlob();
    HRESULT hr = S_OK;

    if (pRBlob != NULL)
    {
        hr = pRBlob->GetDestination(this,
                                    pstrDestination,
                                    pfRedirected,
                                    pStatusCode);
    }

    return hr;
}

HRESULT W3_METADATA::SetRedirectionBlob(STRU &strSource,
                                        STRU &strDestination)
{
    //
    // If the redirection is nullified, don't allocate a blob
    // and just return success.
    //

    if (strDestination.QueryStr()[0] == L'!')
    {
        return S_OK;
    }

    _pRedirectBlob = new REDIRECTION_BLOB();
    if (_pRedirectBlob == NULL)
    {
        return HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
    }

    return _pRedirectBlob->Create(strSource, strDestination);
}

HRESULT
W3_METADATA::GetTrueRedirectionSource(
     LPWSTR                  pszURL,
     LPCWSTR                 pszMetabasePath,
     OUT STRU *              pstrTrueSource
)
/*++

Routine Description:

    Determine the true source of the redirection.  That is, the object from
    which the required URL inherited the redirect metadata.

Arguments:

    pszURL          - URL requested
    strMetabasePath - The metabase path to the root of the site
    pszDestination  - The destination metadata inherited by the original URL.
    pstrTrueSource  - The path of the object from which the original URL
                      inherited pszDestination.

Return Value:

    HRESULT

--*/
{
    MB       mb( g_pW3Server->QueryMDObject() );
    DWORD    dwNeed;
    DWORD    dwVRLen;
    INT      ch;
    LPWSTR   pszInVr;
    LPWSTR   pszMinInVr;
    BOOL     bAtThisLevel;

    // need to reopen the metabase and search up the tree

    if ( !mb.Open(pszMetabasePath))
    {
        return HRESULT_FROM_WIN32(GetLastError());
    }

    //
    // Check from where we got HTTP_REDIRECT
    //

    pszMinInVr = pszURL ;
    if ( *pszURL )
    {
        for ( pszInVr = pszMinInVr + wcslen(pszMinInVr) ;; )
        {
            ch = *pszInVr;
            *pszInVr = L'\0';
            dwNeed = 0;

            bAtThisLevel = !mb.GetString( pszURL,
                                          MD_HTTP_REDIRECT,
                                          IIS_MD_UT_FILE,
                                          NULL,
                                          &dwNeed,
                                          0 ) &&
                            GetLastError() == ERROR_INSUFFICIENT_BUFFER;

            *pszInVr = (CHAR)ch;

            if ( bAtThisLevel )
            {
                // HTTP_REDIRECT was defined at this level !

                break;
            }

            if (ch)
            {
                if ( pszInVr > pszMinInVr )
                {
                    --pszInVr;
                }
                else
                {
                    DBG_REQUIRE(mb.Close());
                    return HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
                }
            }

            // scan for previous delimiter

            while ( *pszInVr != L'/' && *pszInVr != L'\\' )
            {
                if ( pszInVr > pszMinInVr )
                {
                    --pszInVr;
                }
                else
                {
                    DBG_REQUIRE( mb.Close() );
                    return HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
                }
            }
        }

        dwVRLen = (DWORD)DIFF(pszInVr - pszMinInVr);
    }
    else
    {
        dwVRLen = 0;
        pszInVr = pszMinInVr;
    }

    DBG_REQUIRE( mb.Close() );

    if ( dwVRLen > 1 )
    { 
        DBG_ASSERT( pszURL[ 0 ] == L'/' );

        return pstrTrueSource->Copy( pszURL, dwVRLen );
    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\iisplus\ulw3\requestheaderhash.h ===
#ifndef _REQUEST_HEADERHASH_HXX_
#define _REQUEST_HEADERHASH_HXX_

//
// Helper class for String->Index hash
//
    
struct HEADER_RECORD
{
    ULONG               _ulHeaderIndex;
    CHAR *              _pszName;
    USHORT              _cchName;
};

#define HEADER(x)           x, sizeof(x) - sizeof(CHAR)

//
// *_HEADER_HASH maps strings to UlHeader* values
//

#define UNKNOWN_INDEX           (0xFFFFFFFF)

class REQUEST_HEADER_HASH
    : public CTypedHashTable< REQUEST_HEADER_HASH, 
                              HEADER_RECORD, 
                              CHAR * >
{
public:
    REQUEST_HEADER_HASH() 
      : CTypedHashTable< REQUEST_HEADER_HASH, 
                         HEADER_RECORD, 
                         CHAR * >
            ("REQUEST_HEADER_HASH")
    {
    }
    
    static 
    CHAR *
    ExtractKey(
        const HEADER_RECORD * pRecord
    )
    {
        DBG_ASSERT( pRecord != NULL );
        return pRecord->_pszName;
    }
    
    static
    DWORD
    CalcKeyHash(
        CHAR *                 pszKey
    )
    {
        return HashStringNoCase( pszKey ); 
    }
     
    static
    bool
    EqualKeys(
        CHAR *                 pszKey1,
        CHAR *                 pszKey2
    )
    {
        return _stricmp( pszKey1, pszKey2 ) == 0;
    }
    
    static
    void
    AddRefRecord(
        HEADER_RECORD *,
        int
    )
    {
    }
    
    static
    HRESULT
    Initialize(
        VOID
    );
    
    static
    VOID
    Terminate(
        VOID
    );
    
    static
    ULONG
    GetIndex(
        CHAR *             pszName
    )
    {
        HEADER_RECORD *       pRecord = NULL;
        LK_RETCODE                  retCode;

        retCode = sm_pRequestHash->FindKey( pszName,
                                            &pRecord );
        if ( retCode == LK_SUCCESS )
        {
            DBG_ASSERT( pRecord != NULL );
            return pRecord->_ulHeaderIndex;
        }
        else
        {
            return UNKNOWN_INDEX;
        }
    }
    
    static
    CHAR *
    GetString(
        ULONG               ulIndex,
        DWORD *             pcchLength
    )
    {
        if ( ulIndex < HttpHeaderRequestMaximum )
        {
            *pcchLength = sm_rgHeaders[ ulIndex ]._cchName;
            return sm_rgHeaders[ ulIndex ]._pszName;
        }
        
        return NULL;
    }
    
private:

    static REQUEST_HEADER_HASH  *sm_pRequestHash;
    static HEADER_RECORD         sm_rgHeaders[];

    REQUEST_HEADER_HASH(const REQUEST_HEADER_HASH &);
    void operator=(const REQUEST_HEADER_HASH &);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\iisplus\ulw3\responseheaderhash.h ===
#ifndef _RESPONSE_HEADERHASH_HXX_
#define _RESPONSE_HEADERHASH_HXX_



class RESPONSE_HEADER_HASH
{

public:
    
    static
    HRESULT
    Initialize(
        VOID
    );
    
    static
    VOID
    Terminate(
        VOID
    );

    static
    ULONG
    GetIndex(
        CHAR *             pszName
    );

    static
    CHAR *
    GetString(
        ULONG               ulIndex,
        DWORD *             pcchLength
    )
    {
        if ( ulIndex < HttpHeaderResponseMaximum )
        {
            *pcchLength = sm_rgHeaders[ ulIndex ]._cchName;
            return sm_rgHeaders[ ulIndex ]._pszName;
        }

        return NULL;
    }

private:

    static RESPONSE_HEADER_HASH *sm_pResponseHash;
    static HEADER_RECORD         sm_rgHeaders[];
    //
    // total number of headers
    //
    static DWORD                 sm_cResponseHeaders;
    //
    // sorted headers used for header index lookup (for bsearch)
    //
    static HEADER_RECORD * *     sm_ppSortedResponseHeaders;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\iisplus\ulw3\redirectionhandler.cxx ===
/*++

   Copyright    (c)    2002    Microsoft Corporation

   Module Name :
     redirectionhandler.cxx

   Abstract:
     A general purpose redirection handler, this allows to send client
     side redirection asynchronously.
     
   Author:
     Anil Ruia (AnilR)              25-Nov-2002

   Environment:
     Win32 - User Mode

   Project:
     w3core.dll
--*/

#include "precomp.hxx"
#include "redirectionhandler.hxx"

ALLOC_CACHE_HANDLER *       W3_REDIRECTION_HANDLER::sm_pachRedirectionHandlers;

CONTEXT_STATUS
W3_REDIRECTION_HANDLER::DoWork(
    VOID
)
/*++

Routine Description:

    Send the configured redirect response to the client

Return Value:

    HRESULT

--*/
{
    HRESULT             hr;

    W3_CONTEXT *pW3Context = QueryW3Context();
    DBG_ASSERT( pW3Context != NULL );

    //
    // Setup the redirect response and send it
    //
    
    if (FAILED(hr = pW3Context->SetupHttpRedirect(_strDestination,
                                                  FALSE,
                                                  _httpStatus)) ||
        FAILED(hr = pW3Context->SendResponse(W3_FLAG_ASYNC)))
    {
        pW3Context->SetErrorStatus(hr);
        pW3Context->QueryResponse()->SetStatus(HttpStatusServerError);
        return CONTEXT_STATUS_CONTINUE;
    }
    
    return CONTEXT_STATUS_PENDING;
}

// static
HRESULT
W3_REDIRECTION_HANDLER::Initialize(
    VOID
)
/*++

Routine Description:

    Global initialization routine for W3_REDIRECTION_HANDLERs

Arguments:

    None
    
Return Value:

    HRESULT

--*/
{
    ALLOC_CACHE_CONFIGURATION       acConfig;
    HRESULT                         hr = NO_ERROR;

    //
    // Setup allocation lookaside
    //
    
    acConfig.nConcurrency = 1;
    acConfig.nThreshold = 100;
    acConfig.cbSize = sizeof( W3_REDIRECTION_HANDLER );

    DBG_ASSERT( sm_pachRedirectionHandlers == NULL );
    
    sm_pachRedirectionHandlers = new ALLOC_CACHE_HANDLER( "W3_REDIRECTION_HANDLER",  
                                                      &acConfig );

    if ( sm_pachRedirectionHandlers == NULL )
    {
        return HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );
    }
    
    return NO_ERROR;
}

// static
VOID
W3_REDIRECTION_HANDLER::Terminate(
    VOID
)
/*++

Routine Description:

    Terminate MAIN_CONTEXT globals

Arguments:

    None
    
Return Value:

    None

--*/
{
    if ( sm_pachRedirectionHandlers != NULL )
    {
        delete sm_pachRedirectionHandlers;
        sm_pachRedirectionHandlers = NULL;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\iisplus\ulw3\sspiprovider.cxx ===
/*++
   Copyright    (c)    1999    Microsoft Corporation

   Module Name :
     sspiprovider.cxx

   Abstract:
     SSPI authentication provider
 
   Author:
     Bilal Alam (balam)             10-Jan-2000

   Environment:
     Win32 - User Mode

   Project:
     ULW3.DLL
--*/

#include "precomp.hxx"
#include "sspiprovider.hxx"
#include "uuencode.hxx"

ALLOC_CACHE_HANDLER * SSPI_SECURITY_CONTEXT::sm_pachSSPISecContext = NULL;

CRITICAL_SECTION     SSPI_CREDENTIAL::sm_csCredentials;
LIST_ENTRY           SSPI_CREDENTIAL::sm_CredentialListHead;

//static
HRESULT
SSPI_CREDENTIAL::Initialize(
    VOID
)
/*++

  Description:

    Credential cache initialization

  Arguments:

    None

  Returns:

    HRESULT

--*/
{
    InitializeListHead( &sm_CredentialListHead );
    
    if( !INITIALIZE_CRITICAL_SECTION( &sm_csCredentials ) )
    {
        return HRESULT_FROM_WIN32( GetLastError() );
    }

    return NO_ERROR;
}

//static
VOID
SSPI_CREDENTIAL::Terminate(
    VOID
)
/*++

  Description:

    Credential cache cleanup

  Arguments:

    None

  Returns:

    None

--*/
{
    SSPI_CREDENTIAL *           pCred = NULL;
    
    EnterCriticalSection( &sm_csCredentials );

    while ( !IsListEmpty( &sm_CredentialListHead ))
    {
        pCred = CONTAINING_RECORD( sm_CredentialListHead.Flink,
                                   SSPI_CREDENTIAL,
                                   m_ListEntry );

        RemoveEntryList( &pCred->m_ListEntry );
        
        pCred->m_ListEntry.Flink = NULL;

        delete pCred;
        pCred = NULL;
    }

    LeaveCriticalSection( &sm_csCredentials );

    DeleteCriticalSection( &sm_csCredentials );
}    

//static
HRESULT
SSPI_CREDENTIAL::GetCredential(
    CHAR *              pszPackage, 
    SSPI_CREDENTIAL **  ppCredential
)
/*++

  Description:

    Get SSPI credential handle from cache. If it does not exist 
    for the SSPI package, generates a new cache entry and adds 
    it to the credential cache

  Arguments:

    pszPackage      - SSPI package name, e.g NTLM
    ppCredential    - Set to cached credential if found

  Returns:

    HRESULT

--*/
{
    LIST_ENTRY *                pEntry;
    SSPI_CREDENTIAL *           pCred;
    SecPkgInfoA *               pSecPkg;
    TimeStamp                   LifeTime;
    SECURITY_STATUS             ss;
    HRESULT                     hr = S_OK;

    if ( pszPackage == NULL ||
         ppCredential == NULL )
    {
        DBG_ASSERT( FALSE );
        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }
    
    *ppCredential = NULL;

    EnterCriticalSection( &sm_csCredentials );

    for ( pEntry  = sm_CredentialListHead.Flink;
          pEntry != &sm_CredentialListHead;
          pEntry  = pEntry->Flink )
    {
        pCred = CONTAINING_RECORD( pEntry, 
                                   SSPI_CREDENTIAL, 
                                   m_ListEntry );

        if ( !strcmp( pszPackage, pCred->m_strPackageName.QueryStr() ) )
        {
            // 
            // Since we only need to read the credential info at this
            // point, leave the critical section first.
            // 
            
            LeaveCriticalSection( &sm_csCredentials );

            *ppCredential = pCred;
            return NO_ERROR;
        }
    }

    if ( ( pCred = new SSPI_CREDENTIAL ) == NULL )
    {
        LeaveCriticalSection( &sm_csCredentials );
        
        hr = HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY ); 

        return hr;
    }

    hr = pCred->m_strPackageName.Copy( pszPackage );
    if ( FAILED( hr ) )
    {
        LeaveCriticalSection( &sm_csCredentials );

        delete pCred;
        pCred = NULL;

        return hr;
    }

    ss = AcquireCredentialsHandleA( NULL,             
                                    pszPackage,       
                                    SECPKG_CRED_INBOUND,
                                    NULL,             
                                    NULL,    
                                    NULL,             
                                    NULL,             
                                    &pCred->m_hCredHandle,
                                    &LifeTime );
    if ( ss != STATUS_SUCCESS )
    {
        LeaveCriticalSection( &sm_csCredentials );

        hr = HRESULT_FROM_WIN32( ss );

        DBGPRINTF(( DBG_CONTEXT,
                   "Error acquiring credential handle, hr = %x\n",
                    hr ));

        delete pCred;
        pCred = NULL;

        return hr;
    }

    //
    //  Need to determine the max token size for this package
    //
    ss = QuerySecurityPackageInfoA( pszPackage,
                                    &pSecPkg );
    if ( ss != STATUS_SUCCESS )
    {
        LeaveCriticalSection( &sm_csCredentials );

        hr = HRESULT_FROM_WIN32( ss );

        DBGPRINTF(( DBG_CONTEXT,
                   "Error querying security package info, hr = %x\n",
                    hr ));

        delete pCred;
        pCred = NULL;

        return hr;
    }

    pCred->m_cbMaxTokenLen = pSecPkg->cbMaxToken;
    pCred->m_fSupportsEncoding = !(pSecPkg->fCapabilities & SECPKG_FLAG_ASCII_BUFFERS); 

    //
    // Insert the credential handle to the list for future use
    //
    
    InsertHeadList( &sm_CredentialListHead, &pCred->m_ListEntry );

    LeaveCriticalSection( &sm_csCredentials );

    *ppCredential = pCred;

    FreeContextBuffer( pSecPkg );

    return hr;
}

//static 
VOID
SSPI_CREDENTIAL::RemoveCredentialFromCache(
    SSPI_CREDENTIAL *       pCredential
)
/*++

  Description:

    Remove SSPI credential handle from cache. 

  Arguments:

    pCredential    - Point to SSPI credential handle to be deleted

  Returns:

    HRESULT

--*/
{
    EnterCriticalSection( &sm_csCredentials );

    RemoveEntryList( &pCredential->m_ListEntry );
    
    LeaveCriticalSection( &sm_csCredentials );

    pCredential->m_ListEntry.Flink = NULL;

    delete pCredential;
    pCredential = NULL;
}

HRESULT
SSPI_AUTH_PROVIDER::Initialize(
    DWORD dwInternalId
)
/*++

Routine Description:

    Initialize SSPI provider 

Arguments:

    None
    
Return Value:

    HRESULT

--*/
{
    HRESULT                 hr;

    SetInternalId( dwInternalId );
    hr = SSPI_SECURITY_CONTEXT::Initialize();
    if ( FAILED( hr ) )
    {
        return hr;
    }
    
    hr = SSPI_CREDENTIAL::Initialize();
    if ( FAILED( hr ) )
    {
        SSPI_SECURITY_CONTEXT::Terminate();
        return hr;
    }

    return NO_ERROR;
}

VOID
SSPI_AUTH_PROVIDER::Terminate(
    VOID
)
/*++

Routine Description:

    Terminate SSPI provider

Arguments:

    None
    
Return Value:

    None

--*/
{
    SSPI_CREDENTIAL::Terminate();
    SSPI_SECURITY_CONTEXT::Terminate();
}

HRESULT
SSPI_AUTH_PROVIDER::DoesApply(
    W3_MAIN_CONTEXT *           pMainContext,
    BOOL *                      pfApplies
)
/*++

Routine Description:

    Does the given request have credentials applicable to the SSPI 
    provider

Arguments:

    pMainContext - Main context representing request
    pfApplies - Set to true if SSPI is applicable
    
    
Return Value:

    HRESULT

--*/
{
    HRESULT                 hr;
    W3_METADATA *           pMetaData;
    SSPI_CONTEXT_STATE *    pContextState;
    STACK_STRA(             strPackage, 64 );
    LPCSTR                  pszAuthHeader;
    USHORT                  cchAuthHeader = 0;
    
    if ( pMainContext == NULL ||
         pfApplies == NULL )
    {
        DBG_ASSERT( FALSE );
        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }

    *pfApplies = FALSE;

    pszAuthHeader = pMainContext->QueryRequest()->GetHeader( HttpHeaderAuthorization,
                                                             &cchAuthHeader );

    if ( pszAuthHeader == NULL )
    {
        // no authorization header
        return NO_ERROR;
    }

    //
    // Get the package name
    //
    
    hr = pMainContext->QueryRequest()->GetAuthType( &strPackage );
    if ( FAILED( hr ) )
    {
        return hr;
    }
    
    //
    // No package, then this doesn't apply
    //
    
    if ( strPackage.IsEmpty() )
    {
        return NO_ERROR;
    }
    
    //
    // Check metabase for whether SSPI package is supported
    //

    pMetaData = pMainContext->QueryUrlContext()->QueryMetaData();
    DBG_ASSERT( pMetaData != NULL );

    if ( pMetaData->CheckAuthProvider( strPackage.QueryStr() ) )
    {
        DBG_ASSERT( pszAuthHeader != NULL );
        
        //
        // Save away the package so we don't have to calc again
        //
        
        DBG_ASSERT( !strPackage.IsEmpty() );
        
        pContextState = new (pMainContext) SSPI_CONTEXT_STATE(
                                ( cchAuthHeader > strPackage.QueryCCH() ) ?  
                                ( pszAuthHeader + strPackage.QueryCCH() + 1 ) : "" );
        if ( pContextState == NULL )
        {
            return HRESULT_FROM_WIN32( GetLastError() );
        }

        hr = pContextState->SetPackage( strPackage.QueryStr() );
        if ( FAILED( hr ) )
        {
            delete pContextState;
            return hr;
        }

        pMainContext->SetContextState( pContextState );

        *pfApplies = TRUE;
    }

    return NO_ERROR;
}

HRESULT
SSPI_AUTH_PROVIDER::DoAuthenticate(
    W3_MAIN_CONTEXT *       pMainContext,
    BOOL *                  // unused
)
/*++

Description:

    Do authentication work (we will be called if we apply)

Arguments:

    pMainContext - Main context
    
Return Value:

    HRESULT

--*/
{
    SSPI_CONTEXT_STATE *        pContextState = NULL;
    W3_METADATA *               pMetaData = NULL;
    W3_REQUEST *                pW3Request = NULL;
    SSPI_SECURITY_CONTEXT *     pSecurityContext = NULL;
    SECURITY_STATUS             ss = SEC_E_OK;
    TimeStamp                   Lifetime;
    SecBufferDesc               OutBuffDesc;
    SecBuffer                   OutSecBuff;
    SecBufferDesc               InBuffDesc;
    SecBuffer                   InSecBuff;
    ULONG                       ContextAttributes;
    SSPI_CREDENTIAL *           pCredentials = NULL;
    HRESULT                     hr;
    STACK_BUFFER              ( buffDecoded, 256 );
    CHAR *                      pszFinalBlob = NULL;
    DWORD                       cbFinalBlob;
    CtxtHandle                  hCtxtHandle;
    BOOL                        fNeedContinue = FALSE;
    SSPI_USER_CONTEXT *         pUserContext;
    BUFFER                      buffResponse;
    BOOL                        fNewConversation = TRUE;
    DWORD                       err;
    
    if ( pMainContext == NULL )
    {
        DBG_ASSERT( FALSE );
        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }
    
    pContextState = (SSPI_CONTEXT_STATE*) pMainContext->QueryContextState();
    DBG_ASSERT( pContextState != NULL );
    
    pMetaData = pMainContext->QueryUrlContext()->QueryMetaData();
    DBG_ASSERT( pMetaData != NULL );

    pW3Request = pMainContext->QueryRequest();
    DBG_ASSERT( pW3Request != NULL );
    
    //
    // If we got to here, then the package better be supported!
    //
    
    DBG_ASSERT( pMetaData->CheckAuthProvider( pContextState->QueryPackage() ) );
    
    //
    // Are we in the middle of a handshake?
    //
    
    pSecurityContext = 
         ( SSPI_SECURITY_CONTEXT * )  QueryConnectionAuthContext( pMainContext );

    //
    // If the security context indicates we are complete already, then
    // cleanup that context before proceeding to create a new one.  
    //
    
    if ( pSecurityContext != NULL &&
         pSecurityContext->QueryIsComplete() )
    {
        SetConnectionAuthContext( pMainContext,
                                  NULL );
        pSecurityContext = NULL;
    }

    if ( pSecurityContext != NULL )
    {
        DBG_ASSERT( pSecurityContext->CheckSignature() );

        pCredentials = pSecurityContext->QueryCredentials();

        fNewConversation = FALSE;
    }    
    else
    {
        //
        // Nope.  Need to create a new SSPI_SECURITY_CONTEXT and find 
        // credentials for this package
        //
        
        hr = SSPI_CREDENTIAL::GetCredential((CHAR*) pContextState->QueryPackage(),
                                             &pCredentials );
        
        if ( FAILED( hr ) )
        {
            DBGPRINTF((DBG_CONTEXT,
                      "Error get credential handle. hr = 0x%x \n",
                      hr ));
            
            goto Failure;
        }
        
        pSecurityContext = new SSPI_SECURITY_CONTEXT( pCredentials );
        if ( pSecurityContext == NULL )
        {
            hr = HRESULT_FROM_WIN32( GetLastError() );
            goto Failure;
        }
        
        hr = SetConnectionAuthContext( pMainContext,
                                       pSecurityContext );
        if ( FAILED( hr ) )
        {
            DBGPRINTF((DBG_CONTEXT,
                      "Failed to set Connection Auth Context. hr = 0x%x \n",
                      hr ));
            
            goto Failure;
        }

    }
    
    DBG_ASSERT( pCredentials != NULL );
    DBG_ASSERT( pSecurityContext != NULL );

    //
    // Process credential blob.
    //
    
    //
    // Should we uudecode this buffer?
    //
    
    if ( pCredentials->QuerySupportsEncoding() )
    {
        if ( !uudecode( (PCHAR) pContextState->QueryCredentials(),
                        &buffDecoded,
                        &cbFinalBlob ) )
        {
            pMainContext->QueryResponse()->SetStatus( HttpStatusUnauthorized,
                                                      Http401BadLogon );
            
            return NO_ERROR;
        }
        
        pszFinalBlob = (CHAR*) buffDecoded.QueryPtr();
    }
    else
    {
        pszFinalBlob = (PCHAR) pContextState->QueryCredentials();
        cbFinalBlob = strlen(pContextState->QueryCredentials()) + 1;
    }

    //
    // Setup the response blob buffer 
    // 
    
    if ( !buffResponse.Resize( pCredentials->QueryMaxTokenSize() ) )
    {
        hr = HRESULT_FROM_WIN32( GetLastError() );
        goto Failure;
    }                                  

    //
    // Setup the call to AcceptSecurityContext()
    //
    
    OutBuffDesc.ulVersion = 0;
    OutBuffDesc.cBuffers  = 1;
    OutBuffDesc.pBuffers  = &OutSecBuff;

    OutSecBuff.cbBuffer   = pCredentials->QueryMaxTokenSize();
    OutSecBuff.BufferType = SECBUFFER_TOKEN;
    OutSecBuff.pvBuffer   = buffResponse.QueryPtr();

    InBuffDesc.ulVersion = 0;
    InBuffDesc.cBuffers  = 1;
    InBuffDesc.pBuffers  = &InSecBuff;

    InSecBuff.cbBuffer   = cbFinalBlob;
    InSecBuff.BufferType = SECBUFFER_TOKEN;
    InSecBuff.pvBuffer   = pszFinalBlob;

    //
    // Let'r rip!
    //

    //
    // Register the remote IP address with LSA so that it can be logged
    //

    if( pW3Request->QueryRemoteAddressType() == AF_INET )
    {
        ss = SecpSetIPAddress( ( PUCHAR )pW3Request->QueryRemoteSockAddress(),
                               sizeof( SOCKADDR_IN ) );
    }
    else if( pW3Request->QueryRemoteAddressType() == AF_INET6 )
    {
        ss = SecpSetIPAddress( ( PUCHAR )pW3Request->QueryRemoteSockAddress(),
                               sizeof( SOCKADDR_IN6 ) );
    }
    else
    {
        DBG_ASSERT( FALSE );
    }

    if( !NT_SUCCESS( ss ) )
    {
        hr = ss;
        goto Failure;
    }
    
    ThreadPoolSetInfo( ThreadPoolIncMaxPoolThreads, 0 );

    //
    // Set required context attributes ASC_REQ_EXTENDED_ERROR, this 
    // allows Negotiate/Kerberos to support time-skew recovery.  
    //

    ss = AcceptSecurityContext( pCredentials->QueryCredHandle(),
                                fNewConversation ? 
                                NULL :
                                pSecurityContext->QueryContextHandle(),
                                &InBuffDesc,
                                ASC_REQ_EXTENDED_ERROR,
                                SECURITY_NATIVE_DREP,
                                &hCtxtHandle,
                                &OutBuffDesc,
                                &ContextAttributes,
                                &Lifetime );

    ThreadPoolSetInfo( ThreadPoolDecMaxPoolThreads, 0 );

    if( ss == SEC_E_INVALID_TOKEN )
    {
        //
        // The client has abandoned the previous conversation and possibly 
        // started a new conversation on the same connection. Get rid of 
        // the previous partially formed context first then retry 
        // authentication.
        //
        
        if ( SecIsValidHandle( pSecurityContext->QueryContextHandle() ) )
        {
            DeleteSecurityContext( pSecurityContext->QueryContextHandle() );
            SecInvalidateHandle( pSecurityContext->QueryContextHandle() );
        }
        
        //
        // Register the remote IP address with LSA so that it can be logged
        //

        if( pW3Request->QueryRemoteAddressType() == AF_INET )
        {
            ss = SecpSetIPAddress( ( PUCHAR )pW3Request->QueryRemoteSockAddress(),
                                   sizeof( SOCKADDR_IN ) );
        }
        else if( pW3Request->QueryRemoteAddressType() == AF_INET6 )
        {
            ss = SecpSetIPAddress( ( PUCHAR )pW3Request->QueryRemoteSockAddress(),
                                   sizeof( SOCKADDR_IN6 ) );
        }
        else
        {
            DBG_ASSERT( FALSE );
        }

        if( !NT_SUCCESS( ss ) )
        {
            hr = ss;
            goto Failure;
        }
    
        ThreadPoolSetInfo( ThreadPoolIncMaxPoolThreads, 0 );

        ss = AcceptSecurityContext( pCredentials->QueryCredHandle(),
                                    NULL,
                                    &InBuffDesc,
                                    ASC_REQ_EXTENDED_ERROR,
                                    SECURITY_NATIVE_DREP,
                                    &hCtxtHandle,
                                    &OutBuffDesc,
                                    &ContextAttributes,
                                    &Lifetime );

        ThreadPoolSetInfo( ThreadPoolDecMaxPoolThreads, 0 );

    }
    else if( ss == SEC_E_WRONG_PRINCIPAL )
    {
        //
        // The error is caused by changes of the machine password, we 
        // need to regenerate a credential handle in this case
        //
        
        SSPI_CREDENTIAL::RemoveCredentialFromCache( pCredentials );

        hr = SSPI_CREDENTIAL::GetCredential((CHAR*) pContextState->QueryPackage(),
                                             &pCredentials );
        
        if ( FAILED( hr ) )
        {
            DBGPRINTF((DBG_CONTEXT,
                      "Error get credential handle. hr = 0x%x \n",
                      hr ));
            
            goto Failure;
        }

        pSecurityContext->SetCredentials( pCredentials );

        //
        // Register the remote IP address with LSA so that it can be logged
        //

        if( pW3Request->QueryRemoteAddressType() == AF_INET )
        {
            ss = SecpSetIPAddress( ( PUCHAR )pW3Request->QueryRemoteSockAddress(),
                                   sizeof( SOCKADDR_IN ) );
        }
        else if( pW3Request->QueryRemoteAddressType() == AF_INET6 )
        {
            ss = SecpSetIPAddress( ( PUCHAR )pW3Request->QueryRemoteSockAddress(),
                                   sizeof( SOCKADDR_IN6 ) );
        }
        else
        {
            DBG_ASSERT( FALSE );
        }

        if( !NT_SUCCESS( ss ) )
        {
            hr = ss;
            goto Failure;
        }

        ThreadPoolSetInfo( ThreadPoolIncMaxPoolThreads, 0 );
    
        ss = AcceptSecurityContext( pCredentials->QueryCredHandle(),
                                    NULL,
                                    &InBuffDesc,
                                    ASC_REQ_EXTENDED_ERROR,
                                    SECURITY_NATIVE_DREP,
                                    &hCtxtHandle,
                                    &OutBuffDesc,
                                    &ContextAttributes,
                                    &Lifetime );

        ThreadPoolSetInfo( ThreadPoolDecMaxPoolThreads, 0 );

    }

    if ( !NT_SUCCESS( ss ) )
    {
        DBGPRINTF(( DBG_CONTEXT,
                   "AcceptSecurityContext failed, error %x\n",
                    ss ));

        if ( ss == SEC_E_LOGON_DENIED  || 
             ss == SEC_E_INVALID_TOKEN ||
             ss == SEC_E_INVALID_HANDLE )
        {
            err = GetLastError();
            if( err == ERROR_PASSWORD_MUST_CHANGE ||
                err == ERROR_PASSWORD_EXPIRED )
            {
                return HRESULT_FROM_WIN32( err );
            }

            //
            // Could not logon the user because of wrong credentials
            //
            
            pMainContext->QueryResponse()->SetStatus( HttpStatusUnauthorized,
                                                      Http401BadLogon );
                                                      
            pMainContext->SetErrorStatus( ss );
            hr = NO_ERROR;
        }
        else
        {
            hr = ss;
        }
        
        goto Failure;
    }

    if( ContextAttributes & ASC_RET_NULL_SESSION )
    {
        pMainContext->QueryResponse()->SetStatus( HttpStatusUnauthorized,
                                                  Http401BadLogon );

        pMainContext->SetErrorStatus( HRESULT_FROM_WIN32( 
                                      ERROR_ACCESS_DENIED ) );

        hr = NO_ERROR;
        goto Failure;
    }

    pSecurityContext->SetContextHandle( hCtxtHandle );
    pSecurityContext->SetContextAttributes( ContextAttributes );

    if ( ss == SEC_I_CONTINUE_NEEDED ||
         ss == SEC_I_COMPLETE_AND_CONTINUE )
    {
        fNeedContinue = TRUE;
    }
    else if ( ( ss == SEC_I_COMPLETE_NEEDED ) ||
              ( ss == SEC_I_COMPLETE_AND_CONTINUE ) )
    {
        //
        // Now we just need to complete the token (if requested) and 
        // prepare it for shipping to the other side if needed
        //
        
        ss = CompleteAuthToken( &hCtxtHandle,
                                &OutBuffDesc );

        if ( !NT_SUCCESS( ss ))
        {
            hr = ss;

            DBGPRINTF(( DBG_CONTEXT,
                       "Error on CompleteAuthToken, hr = 0x%x\n",
                        hr ));

            goto Failure;
        }
    }

    //
    // Format or copy to the output buffer if we need to reply
    //
    
    if ( OutSecBuff.cbBuffer != 0 )
    {
        STACK_BUFFER( buffAuthData, 256 );
        
        hr = pContextState->QueryResponseHeader()->Copy( 
                        pContextState->QueryPackage() );
        if( FAILED( hr ) )
        {
            DBGPRINTF(( DBG_CONTEXT,
                       "Error copying auth type, hr = 0x%x.\n",
                       hr ));
            
            goto Failure;
        }

        hr = pContextState->QueryResponseHeader()->Append( " ", 1 );
        if( FAILED( hr ) )
        {
            DBGPRINTF(( DBG_CONTEXT,
                       "Error copying auth header, hr = 0x%x.\n",
                       hr ));

            goto Failure;
        }

        DBG_ASSERT( pCredentials != NULL );

        if ( pCredentials->QuerySupportsEncoding() )
        {
            if ( !uuencode( (BYTE *) OutSecBuff.pvBuffer,
                            (DWORD) OutSecBuff.cbBuffer,
                            &buffAuthData ) )
            {
                DBGPRINTF(( DBG_CONTEXT,
                           "Error uuencoding the output buffer.\n"
                         ));

                hr = HRESULT_FROM_WIN32( GetLastError() );
                goto Failure;
            }

            pszFinalBlob = (CHAR *)buffAuthData.QueryPtr();
        }
        else
        {
            pszFinalBlob = (CHAR *)OutSecBuff.pvBuffer;
        }
        
        hr = pContextState->QueryResponseHeader()->Append( pszFinalBlob );
        if( FAILED( hr ) )
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "Error appending resp header, hr = 0x%x.\n",
                        hr ));

            goto Failure;
        }
        
        //
        // If we are not done authentication, then add the challenge header
        // now (we are guaranteed to want to send it, which is not the case
        // if this is just a continuation header for kerberos mutual auth)
        //
        
        if ( fNeedContinue )
        {
            //
            // Add the WWW-Authenticate header
            //
        
            hr = pMainContext->QueryResponse()->SetHeader(
                        "WWW-Authenticate",
                        16, // number of chars in above string
                        pContextState->QueryResponseHeader()->QueryStr(),
                        (USHORT)pContextState->QueryResponseHeader()->QueryCCH() );
       
            if ( FAILED( hr ) )
            {
                goto Failure;
            }

            //
            // Don't let anyone else send back authentication headers when
            // the 401 is sent
            //

            pMainContext->SetProviderHandled( TRUE );
        }
    }   
        
    if ( !fNeedContinue )
    {
        //
        // Create a user context and setup it up
        //
        
        pUserContext = new SSPI_USER_CONTEXT( this );
        if ( pUserContext == NULL )
        {
            hr = HRESULT_FROM_WIN32( GetLastError() );
            goto Failure;
        } 
        
        hr = pUserContext->Create( pSecurityContext,
                                   pMainContext );
        if ( FAILED( hr ) )
        {
            pUserContext->DereferenceUserContext();
            pUserContext = NULL;
            goto Failure;
        }
        
        //
        // If there is an auth token remaining to be sent, associate that
        // with the user context.  We will send it
        //
        
        if ( OutSecBuff.cbBuffer != 0 )
        {
            hr = pUserContext->QueryAuthToken()->Copy( *(pContextState->QueryResponseHeader()) );
            if ( FAILED( hr ) )
            {
                pUserContext->DereferenceUserContext();
                pUserContext = NULL;
                goto Failure;
            }
        }
    
        pMainContext->SetUserContext( pUserContext );
        
        pSecurityContext->SetIsComplete( TRUE );
    }
    else
    {
        //
        // We need to send a 401 response to continue the handshake.  
        // We have already setup the WWW-Authenticate header
        //
        
        pMainContext->QueryResponse()->SetStatus( HttpStatusUnauthorized,
                                                  Http401BadLogon );
        
        pMainContext->SetFinishedResponse();
    }
    
    return NO_ERROR;

Failure:
    if ( pSecurityContext != NULL )
    {
        SetConnectionAuthContext( pMainContext,
                                  NULL );
        pSecurityContext = NULL;
    }
        
    return hr;
}

HRESULT
SSPI_AUTH_PROVIDER::OnAccessDenied(
    W3_MAIN_CONTEXT *       pMainContext
)
/*++

  Description:
    
    Add WWW-Authenticate headers

Arguments:

    pMainContext - main context
    
Return Value:

    HRESULT

--*/
{
    MULTISZA *              pProviders;
    W3_METADATA *           pMetaData;
    const CHAR *            pszProvider;
    W3_USER_CONTEXT *       pUserContext = NULL;
    HRESULT                 hr;
    
    if ( pMainContext == NULL )
    {
        DBG_ASSERT( FALSE );
        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }
    
    //
    // If the user context has an associated auth token with it, clear it now
    //
    
    pUserContext = pMainContext->QueryUserContext();
    if ( pUserContext != NULL )
    {
        if ( pUserContext->QueryAuthToken() != NULL )
        {
            pUserContext->QueryAuthToken()->Reset();
        }
    }
    
    pMetaData = pMainContext->QueryUrlContext()->QueryMetaData();
    DBG_ASSERT( pMetaData != NULL );
    
    pProviders = pMetaData->QueryAuthProviders();
    if ( pProviders != NULL )
    {
        pszProvider = pProviders->First();
        while ( pszProvider != NULL )
        {
            hr = pMainContext->QueryResponse()->SetHeader(
                      "WWW-Authenticate",
                      16,
                      ( CHAR * )pszProvider,
                      strlen( pszProvider ) );
            if ( FAILED( hr ) )
            {
                return hr;
            }

            pszProvider = pProviders->Next( pszProvider );
        }
    }
    
    return NO_ERROR;
}

//static
HRESULT
SSPI_SECURITY_CONTEXT::Initialize(
    VOID
)
/*++

  Description:
    
    Global SSPI_SECURITY_CONTEXT initialization

Arguments:

    None
    
Return Value:

    HRESULT

--*/
{
    ALLOC_CACHE_CONFIGURATION       acConfig;

    //
    // Initialize allocation lookaside
    //
    
    acConfig.nConcurrency = 1;
    acConfig.nThreshold = 100;
    acConfig.cbSize = sizeof( SSPI_SECURITY_CONTEXT );

    DBG_ASSERT( sm_pachSSPISecContext == NULL );
    
    sm_pachSSPISecContext = new ALLOC_CACHE_HANDLER( 
                                     "SSPI_SECURITY_CONTEXT",  
                                     &acConfig );

    if ( sm_pachSSPISecContext == NULL ||
         !sm_pachSSPISecContext->IsValid() )
    {
        if( sm_pachSSPISecContext != NULL )
        {
            delete sm_pachSSPISecContext;
            sm_pachSSPISecContext = NULL;
        }
        
        HRESULT hr = HRESULT_FROM_WIN32( GetLastError() );

        DBGPRINTF(( DBG_CONTEXT,
               "Error initializing sm_pachSSPISecContext. hr = 0x%x\n",
               hr ));

        return hr;
    }
    
    return S_OK;

} // SSPI_SECURITY_CONTEXT::Initialize

//static
VOID
SSPI_SECURITY_CONTEXT::Terminate(
    VOID
)
/*++

Routine Description:

    Destroy SSPI_SECURITY_CONTEXT globals

Arguments:

    None
    
Return Value:

    None

--*/
{
    DBG_ASSERT( sm_pachSSPISecContext != NULL );

    delete sm_pachSSPISecContext;
    sm_pachSSPISecContext = NULL;

}

HRESULT
SSPI_USER_CONTEXT::Create(
    SSPI_SECURITY_CONTEXT *         pSecurityContext,
    W3_MAIN_CONTEXT *               pMainContext
)
/*++

Routine Description:

    Create an SSPI user context

Arguments:

    pSecurityContext - container of important SSPI handles
    
Return Value:

    HRESULT

--*/
{
    SECURITY_STATUS                ss;
    HRESULT                        hr;
    SecPkgContext_Names            CredNames;
    SecPkgContext_PackageInfo      PkgInfo;

    if ( pSecurityContext == NULL || 
         pMainContext == NULL )    
    {
        DBG_ASSERT( pSecurityContext != NULL );
        DBG_ASSERT( pMainContext != NULL );    

        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }
    
    //
    // Get the token
    // 
    
    ss = QuerySecurityContextToken( pSecurityContext->QueryContextHandle(), 
                                    &_hImpersonationToken );
    if ( ss == SEC_E_INVALID_HANDLE )
    {
        hr = ss;
            
        DBGPRINTF(( DBG_CONTEXT,
                   "Error QuerySecurityContextToken, hr = 0x%x.\n",
                   ss ));

        return hr;
    }

    //
    // Disable the backup privilege for the token 
    //

    DisableTokenBackupPrivilege( _hImpersonationToken );
    
    //
    // Next, the user name
    //
        
    ss = QueryContextAttributes( pSecurityContext->QueryContextHandle(),
                                 SECPKG_ATTR_NAMES,
                                 &CredNames );
    if ( !NT_SUCCESS( ss ) )
    {
        hr = ss;
          
        DBGPRINTF(( DBG_CONTEXT,
                    "QueryContextAttributes() failed with ss = 0x%x.\n",
                    ss ));

        return hr;
    }         
    else
    {
        //
        // Digest SSP may have a bug in it since the user name returned
        // is NULL, workaround here
        //

        if( CredNames.sUserName )
        {
            hr = _strUserName.Copy( CredNames.sUserName );
            FreeContextBuffer( CredNames.sUserName );
            if ( FAILED( hr ) )
            {
                return hr;
            }
        }
    }
    
    //
    // Get the package name
    //

    ss = QueryContextAttributes( pSecurityContext->QueryContextHandle(),
                                 SECPKG_ATTR_PACKAGE_INFO,
                                 &PkgInfo );
    if ( !NT_SUCCESS( ss ) )
    {
        hr = ss;
          
        DBGPRINTF(( DBG_CONTEXT,
                    "QueryContextAttributes() failed with ss = 0x%x.\n",
                    ss ));

        return hr;
    }
    else
    {
        hr = _strPackageName.Copy( PkgInfo.PackageInfo->Name );
        FreeContextBuffer( PkgInfo.PackageInfo );
        
        if ( FAILED( hr ) )
        {
            return hr;
        }

        if( _strPackageName.Equals( L"NTLM" ) )
        {
            _fAuthNTLM = TRUE;
        }
    }         
    
    
    //
    // If password expiration notification is enabled
    // and Url is configured properly
    // then save expiration info
    //
    
    if( pMainContext->QuerySite()->IsAuthPwdChangeNotificationEnabled() && 
        pMainContext->QuerySite()->QueryAdvNotPwdExpUrl() != NULL )
    {
        SecPkgContext_PasswordExpiry   speExpiry;
        ss = QueryContextAttributes( 
                         pSecurityContext->QueryContextHandle(),
                         SECPKG_ATTR_PASSWORD_EXPIRY,
                         &speExpiry );

        if ( ss == STATUS_SUCCESS )
        {
            memcpy( &_AccountPwdExpiry,
                    &speExpiry.tsPasswordExpires,
                    sizeof( LARGE_INTEGER ) );

            _fSetAccountPwdExpiry = TRUE;
        }
    }
    
    //
    // Save a pointer to the security context
    //
    
    _pSecurityContext = pSecurityContext;
    
    return NO_ERROR;
}

HANDLE
SSPI_USER_CONTEXT::QueryPrimaryToken(
    VOID
)
/*++

Routine Description:

    Get primary token for this user

Arguments:

    None

Return Value:

    Token handle

--*/
{
    DBG_ASSERT( _hImpersonationToken != NULL );

    if ( _hPrimaryToken == NULL )
    {
        if ( DuplicateTokenEx( _hImpersonationToken,
                               0,
                               NULL,
                               SecurityImpersonation,
                               TokenPrimary,
                               &_hPrimaryToken ) )
        {
            DBG_ASSERT( _hPrimaryToken != NULL );
        }
    }
    
    return _hPrimaryToken;
}

LARGE_INTEGER *
SSPI_USER_CONTEXT::QueryExpiry(
    VOID
) 
/*++

Routine Description:

    User account expiry information
    
Arguments:

    None

Return Value:

    LARGE_INTEGER
    
--*/
{

    if ( _fSetAccountPwdExpiry )
    {
        return &_AccountPwdExpiry;
    }
    return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\iisplus\ulw3\responseheaderhash.cxx ===
/*++

   Copyright    (c)    2000   Microsoft Corporation

   Module Name :
     headerhash.cxx

   Abstract:
     Header hash goo
 
   Author:
     Bilal Alam (balam)             20-Feb-2000

   Environment:
     Win32 - User Mode

   Project:
     ULW3.DLL
--*/

#include "precomp.hxx"

RESPONSE_HEADER_HASH *RESPONSE_HEADER_HASH::sm_pResponseHash;

HEADER_RECORD RESPONSE_HEADER_HASH::sm_rgHeaders[] = 
{
    //
    // The only consumer of this data is W3_REQUEST::GetHeader
    // GetServerVariable is handled by SERVER_VARIABLE_HASH, so we do
    // not need to store the HTTP_'ed and capitalized names here
    //

    { HttpHeaderCacheControl       , HEADER("Cache-Control") },
    { HttpHeaderConnection         , HEADER("Connection") },
    { HttpHeaderDate               , HEADER("Date") },
    { HttpHeaderKeepAlive          , HEADER("Keep-Alive") },
    { HttpHeaderPragma             , HEADER("Pragma") },
    { HttpHeaderTrailer            , HEADER("Trailer") },
    { HttpHeaderTransferEncoding   , HEADER("Transfer-Encoding") },
    { HttpHeaderUpgrade            , HEADER("Upgrade") },
    { HttpHeaderVia                , HEADER("Via") },
    { HttpHeaderWarning            , HEADER("Warning") },
    { HttpHeaderAllow              , HEADER("Allow") },
    { HttpHeaderContentLength      , HEADER("Content-Length") },
    { HttpHeaderContentType        , HEADER("Content-Type") },
    { HttpHeaderContentEncoding    , HEADER("Content-Encoding") },
    { HttpHeaderContentLanguage    , HEADER("Content-Language") },
    { HttpHeaderContentLocation    , HEADER("Content-Location") },
    { HttpHeaderContentMd5         , HEADER("Content-MD5") },
    { HttpHeaderContentRange       , HEADER("Content-Range") },
    { HttpHeaderExpires            , HEADER("Expires") },
    { HttpHeaderLastModified       , HEADER("Last-Modified") },
    { HttpHeaderAcceptRanges       , HEADER("Accept-Ranges") },
    { HttpHeaderAge                , HEADER("Age") },
    { HttpHeaderEtag               , HEADER("ETag") },
    { HttpHeaderLocation           , HEADER("Location") },
    { HttpHeaderProxyAuthenticate  , HEADER("Proxy-Authenticate") },
    { HttpHeaderRetryAfter         , HEADER("Retry-After") },
    // Set it to something which cannot be a header name, in effect
    // making Server an unknown header
    { HttpHeaderServer             , HEADER("c:d\r\n") },
    // Set it to something which cannot be a header name, in effect
    // making Set-Cookie an unknown header
    { HttpHeaderSetCookie          , HEADER("a:b\r\n") },
    { HttpHeaderVary               , HEADER("Vary") },
    // Set it to something which cannot be a header name, in effect
    // making WWW-Authenticate an unknown header
    { HttpHeaderWwwAuthenticate    , HEADER("b:c\r\n") }
};

HEADER_RECORD * *     RESPONSE_HEADER_HASH::sm_ppSortedResponseHeaders = NULL;
DWORD                 RESPONSE_HEADER_HASH::sm_cResponseHeaders = 
                                     sizeof( RESPONSE_HEADER_HASH::sm_rgHeaders ) / 
                                     sizeof( HEADER_RECORD );


int _cdecl 
CompareResponseHeaderRecords(
    const void *pRecord1,
    const void *pRecord2 )
/*++

Routine Description:

    Comparison function for qsort

Arguments:

    pRecord1
    pRecord2

Return Value:

    <0 if Record1 < pRecord2
    =0 if Record1 == pRecord2
    >0 if Record1 > pRecord2
--*/    
{
    return _stricmp(  ( * (HEADER_RECORD **) pRecord1)->_pszName,
                      ( * (HEADER_RECORD **) pRecord2)->_pszName );
}


int _cdecl 
CompareResponseHeaderRecordsForBSearch(
    const void *pKey,
    const void *pRecord )
/*++

Routine Description:

    Comparison function for qsort

Arguments:

    pKey
    pRecord

Return Value:

    <0 if Key < Record.Key
    =0 if Key == Record.Key
    >0 if Key > Record.Key
--*/    
    
{
    return _stricmp(  (CHAR *) (pKey),
                    (*(HEADER_RECORD **) pRecord)->_pszName );
}


//static
HRESULT
RESPONSE_HEADER_HASH::Initialize(
    VOID
)
/*++

Routine Description:

    Initialize global header hash table

Arguments:

    None

Return Value:

    HRESULT

--*/
{
    //
    // lkrhash used to be to translate header name to header index
    // RESPONSE_HEADER_HASH is array of constant number of elements
    // it is less expensive to sort it and then use bsearch to find the item
    //

    sm_ppSortedResponseHeaders =
          new HEADER_RECORD * [ sm_cResponseHeaders ];
    if ( sm_ppSortedResponseHeaders == NULL )
    {
        return HRESULT_FROM_WIN32( ERROR_OUTOFMEMORY );
    }
    
    for(DWORD i = 0; i < sm_cResponseHeaders; i++ )
    {
        sm_ppSortedResponseHeaders[i] = &sm_rgHeaders[i];
    }
    
    qsort((void*)sm_ppSortedResponseHeaders,
          sm_cResponseHeaders,
          sizeof( HEADER_RECORD *),
          CompareResponseHeaderRecords );

    return NO_ERROR;
}

//static
VOID
RESPONSE_HEADER_HASH::Terminate(
    VOID
)
/*++

Routine Description:

    Global cleanup of header hash table

Arguments:

    None

Return Value:

    None

--*/
{
    if ( sm_ppSortedResponseHeaders != NULL )
    {
          delete [] sm_ppSortedResponseHeaders;
    }
}


//static
ULONG
RESPONSE_HEADER_HASH::GetIndex(
    CHAR *             pszName
)
{
    HEADER_RECORD ** ppHdrRec =
        reinterpret_cast< HEADER_RECORD **>( 
        bsearch( (void *) pszName,
                (void*)sm_ppSortedResponseHeaders,
                sm_cResponseHeaders, 
                sizeof( HEADER_RECORD * ),
                CompareResponseHeaderRecordsForBSearch ) );

    if ( ppHdrRec != NULL )
    {
        return (*ppHdrRec)->_ulHeaderIndex;
    }
    else
    {
        return UNKNOWN_INDEX;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\iisplus\ulw3\servervar.cxx ===
/*++

   Copyright    (c)    2000   Microsoft Corporation

   Module Name :
     servervar.cxx

   Abstract:
     Server Variable evaluation goo
 
   Author:
     Bilal Alam (balam)             20-Feb-2000

   Environment:
     Win32 - User Mode

   Project:
     ULW3.DLL
--*/

#include "precomp.hxx"

const DWORD MAX_IP_ADDRESS_CHARS = 15;

HRESULT
TranslateIpAddressToStr  (
    DWORD dwAddress,
    STRA * pstraBuffer
    )
/*++
Routine Description:

    Convert DWORD representing IP address into a string in dotted format.
    based in inet_ntoa. TLS has been eliminated adding a little perf gain.

Arguments:

    dwAddress - DWORD address is in reverse order
    pstraBuffer - static buffer containing the text address in standard ".'' 
                  notation. 
    
Returns:

    HRESULT
    
    
--*/
{
   
    PUCHAR pAddress;
    PUCHAR pCurrentChar;
    HRESULT hr = E_FAIL;
    STACK_STRA( strBuff, 32 );
    static BYTE NToACharStrings[][4] = {
    '0', 'x', 'x', 1,
    '1', 'x', 'x', 1,
    '2', 'x', 'x', 1,
    '3', 'x', 'x', 1,
    '4', 'x', 'x', 1,
    '5', 'x', 'x', 1,
    '6', 'x', 'x', 1,
    '7', 'x', 'x', 1,
    '8', 'x', 'x', 1,
    '9', 'x', 'x', 1,
    '1', '0', 'x', 2,
    '1', '1', 'x', 2,
    '1', '2', 'x', 2,
    '1', '3', 'x', 2,
    '1', '4', 'x', 2,
    '1', '5', 'x', 2,
    '1', '6', 'x', 2,
    '1', '7', 'x', 2,
    '1', '8', 'x', 2,
    '1', '9', 'x', 2,
    '2', '0', 'x', 2,
    '2', '1', 'x', 2,
    '2', '2', 'x', 2,
    '2', '3', 'x', 2,
    '2', '4', 'x', 2,
    '2', '5', 'x', 2,
    '2', '6', 'x', 2,
    '2', '7', 'x', 2,
    '2', '8', 'x', 2,
    '2', '9', 'x', 2,
    '3', '0', 'x', 2,
    '3', '1', 'x', 2,
    '3', '2', 'x', 2,
    '3', '3', 'x', 2,
    '3', '4', 'x', 2,
    '3', '5', 'x', 2,
    '3', '6', 'x', 2,
    '3', '7', 'x', 2,
    '3', '8', 'x', 2,
    '3', '9', 'x', 2,
    '4', '0', 'x', 2,
    '4', '1', 'x', 2,
    '4', '2', 'x', 2,
    '4', '3', 'x', 2,
    '4', '4', 'x', 2,
    '4', '5', 'x', 2,
    '4', '6', 'x', 2,
    '4', '7', 'x', 2,
    '4', '8', 'x', 2,
    '4', '9', 'x', 2,
    '5', '0', 'x', 2,
    '5', '1', 'x', 2,
    '5', '2', 'x', 2,
    '5', '3', 'x', 2,
    '5', '4', 'x', 2,
    '5', '5', 'x', 2,
    '5', '6', 'x', 2,
    '5', '7', 'x', 2,
    '5', '8', 'x', 2,
    '5', '9', 'x', 2,
    '6', '0', 'x', 2,
    '6', '1', 'x', 2,
    '6', '2', 'x', 2,
    '6', '3', 'x', 2,
    '6', '4', 'x', 2,
    '6', '5', 'x', 2,
    '6', '6', 'x', 2,
    '6', '7', 'x', 2,
    '6', '8', 'x', 2,
    '6', '9', 'x', 2,
    '7', '0', 'x', 2,
    '7', '1', 'x', 2,
    '7', '2', 'x', 2,
    '7', '3', 'x', 2,
    '7', '4', 'x', 2,
    '7', '5', 'x', 2,
    '7', '6', 'x', 2,
    '7', '7', 'x', 2,
    '7', '8', 'x', 2,
    '7', '9', 'x', 2,
    '8', '0', 'x', 2,
    '8', '1', 'x', 2,
    '8', '2', 'x', 2,
    '8', '3', 'x', 2,
    '8', '4', 'x', 2,
    '8', '5', 'x', 2,
    '8', '6', 'x', 2,
    '8', '7', 'x', 2,
    '8', '8', 'x', 2,
    '8', '9', 'x', 2,
    '9', '0', 'x', 2,
    '9', '1', 'x', 2,
    '9', '2', 'x', 2,
    '9', '3', 'x', 2,
    '9', '4', 'x', 2,
    '9', '5', 'x', 2,
    '9', '6', 'x', 2,
    '9', '7', 'x', 2,
    '9', '8', 'x', 2,
    '9', '9', 'x', 2,
    '1', '0', '0', 3,
    '1', '0', '1', 3,
    '1', '0', '2', 3,
    '1', '0', '3', 3,
    '1', '0', '4', 3,
    '1', '0', '5', 3,
    '1', '0', '6', 3,
    '1', '0', '7', 3,
    '1', '0', '8', 3,
    '1', '0', '9', 3,
    '1', '1', '0', 3,
    '1', '1', '1', 3,
    '1', '1', '2', 3,
    '1', '1', '3', 3,
    '1', '1', '4', 3,
    '1', '1', '5', 3,
    '1', '1', '6', 3,
    '1', '1', '7', 3,
    '1', '1', '8', 3,
    '1', '1', '9', 3,
    '1', '2', '0', 3,
    '1', '2', '1', 3,
    '1', '2', '2', 3,
    '1', '2', '3', 3,
    '1', '2', '4', 3,
    '1', '2', '5', 3,
    '1', '2', '6', 3,
    '1', '2', '7', 3,
    '1', '2', '8', 3,
    '1', '2', '9', 3,
    '1', '3', '0', 3,
    '1', '3', '1', 3,
    '1', '3', '2', 3,
    '1', '3', '3', 3,
    '1', '3', '4', 3,
    '1', '3', '5', 3,
    '1', '3', '6', 3,
    '1', '3', '7', 3,
    '1', '3', '8', 3,
    '1', '3', '9', 3,
    '1', '4', '0', 3,
    '1', '4', '1', 3,
    '1', '4', '2', 3,
    '1', '4', '3', 3,
    '1', '4', '4', 3,
    '1', '4', '5', 3,
    '1', '4', '6', 3,
    '1', '4', '7', 3,
    '1', '4', '8', 3,
    '1', '4', '9', 3,
    '1', '5', '0', 3,
    '1', '5', '1', 3,
    '1', '5', '2', 3,
    '1', '5', '3', 3,
    '1', '5', '4', 3,
    '1', '5', '5', 3,
    '1', '5', '6', 3,
    '1', '5', '7', 3,
    '1', '5', '8', 3,
    '1', '5', '9', 3,
    '1', '6', '0', 3,
    '1', '6', '1', 3,
    '1', '6', '2', 3,
    '1', '6', '3', 3,
    '1', '6', '4', 3,
    '1', '6', '5', 3,
    '1', '6', '6', 3,
    '1', '6', '7', 3,
    '1', '6', '8', 3,
    '1', '6', '9', 3,
    '1', '7', '0', 3,
    '1', '7', '1', 3,
    '1', '7', '2', 3,
    '1', '7', '3', 3,
    '1', '7', '4', 3,
    '1', '7', '5', 3,
    '1', '7', '6', 3,
    '1', '7', '7', 3,
    '1', '7', '8', 3,
    '1', '7', '9', 3,
    '1', '8', '0', 3,
    '1', '8', '1', 3,
    '1', '8', '2', 3,
    '1', '8', '3', 3,
    '1', '8', '4', 3,
    '1', '8', '5', 3,
    '1', '8', '6', 3,
    '1', '8', '7', 3,
    '1', '8', '8', 3,
    '1', '8', '9', 3,
    '1', '9', '0', 3,
    '1', '9', '1', 3,
    '1', '9', '2', 3,
    '1', '9', '3', 3,
    '1', '9', '4', 3,
    '1', '9', '5', 3,
    '1', '9', '6', 3,
    '1', '9', '7', 3,
    '1', '9', '8', 3,
    '1', '9', '9', 3,
    '2', '0', '0', 3,
    '2', '0', '1', 3,
    '2', '0', '2', 3,
    '2', '0', '3', 3,
    '2', '0', '4', 3,
    '2', '0', '5', 3,
    '2', '0', '6', 3,
    '2', '0', '7', 3,
    '2', '0', '8', 3,
    '2', '0', '9', 3,
    '2', '1', '0', 3,
    '2', '1', '1', 3,
    '2', '1', '2', 3,
    '2', '1', '3', 3,
    '2', '1', '4', 3,
    '2', '1', '5', 3,
    '2', '1', '6', 3,
    '2', '1', '7', 3,
    '2', '1', '8', 3,
    '2', '1', '9', 3,
    '2', '2', '0', 3,
    '2', '2', '1', 3,
    '2', '2', '2', 3,
    '2', '2', '3', 3,
    '2', '2', '4', 3,
    '2', '2', '5', 3,
    '2', '2', '6', 3,
    '2', '2', '7', 3,
    '2', '2', '8', 3,
    '2', '2', '9', 3,
    '2', '3', '0', 3,
    '2', '3', '1', 3,
    '2', '3', '2', 3,
    '2', '3', '3', 3,
    '2', '3', '4', 3,
    '2', '3', '5', 3,
    '2', '3', '6', 3,
    '2', '3', '7', 3,
    '2', '3', '8', 3,
    '2', '3', '9', 3,
    '2', '4', '0', 3,
    '2', '4', '1', 3,
    '2', '4', '2', 3,
    '2', '4', '3', 3,
    '2', '4', '4', 3,
    '2', '4', '5', 3,
    '2', '4', '6', 3,
    '2', '4', '7', 3,
    '2', '4', '8', 3,
    '2', '4', '9', 3,
    '2', '5', '0', 3,
    '2', '5', '1', 3,
    '2', '5', '2', 3,
    '2', '5', '3', 3,
    '2', '5', '4', 3,
    '2', '5', '5', 3
};

    
    hr = strBuff.Resize( MAX_IP_ADDRESS_CHARS + 1 ); // to assure buffer is big enough
    if ( FAILED( hr ) )
    {
        return hr;
    }
    
    PUCHAR pszBuffer = (PUCHAR) strBuff.QueryStr();
    
    pCurrentChar = pszBuffer;
    
    //
    // In an unrolled loop, calculate the string value for each of the four
    // bytes in an IP address.  Note that for values less than 100 we will
    // do one or two extra assignments, but we save a test/jump with this
    // algorithm.
    //

    pAddress = (PUCHAR)&dwAddress;
    //
    // address is in reverse order
    //
    pAddress += 3;

    *pCurrentChar = NToACharStrings[*pAddress][0];
    *(pCurrentChar+1) = NToACharStrings[*pAddress][1];
    *(pCurrentChar+2) = NToACharStrings[*pAddress][2];
    pCurrentChar += NToACharStrings[*pAddress][3];
    *pCurrentChar++ = '.';

    pAddress--;
    *pCurrentChar = NToACharStrings[*pAddress][0];
    *(pCurrentChar+1) = NToACharStrings[*pAddress][1];
    *(pCurrentChar+2) = NToACharStrings[*pAddress][2];
    pCurrentChar += NToACharStrings[*pAddress][3];
    *pCurrentChar++ = '.';

    pAddress--;
    *pCurrentChar = NToACharStrings[*pAddress][0];
    *(pCurrentChar+1) = NToACharStrings[*pAddress][1];
    *(pCurrentChar+2) = NToACharStrings[*pAddress][2];
    pCurrentChar += NToACharStrings[*pAddress][3];
    *pCurrentChar++ = '.';

    pAddress--;
    *pCurrentChar = NToACharStrings[*pAddress][0];
    *(pCurrentChar+1) = NToACharStrings[*pAddress][1];
    *(pCurrentChar+2) = NToACharStrings[*pAddress][2];
    pCurrentChar += NToACharStrings[*pAddress][3];
    *pCurrentChar = '\0';

    return pstraBuffer->Copy( (CHAR*) pszBuffer );
}


//
// Hash table mapping variable name to a PFN_SERVER_VARIABLE_ROUTINE
//


SERVER_VARIABLE_HASH * SERVER_VARIABLE_HASH::sm_pRequestHash;

SERVER_VARIABLE_RECORD SERVER_VARIABLE_HASH::sm_rgServerRoutines[] =
{ 
    { "ALL_HTTP",             GetServerVariableAllHttp, NULL, NULL },
    { "ALL_RAW",              GetServerVariableAllRaw, NULL, NULL },
    { "APPL_MD_PATH",         GetServerVariableApplMdPath, GetServerVariableApplMdPathW, NULL },
    { "APPL_PHYSICAL_PATH",   GetServerVariableApplPhysicalPath, GetServerVariableApplPhysicalPathW , NULL },
    { "APP_POOL_ID",          GetServerVariableAppPoolId, GetServerVariableAppPoolIdW, NULL },
    { "AUTH_PASSWORD",        GetServerVariableAuthPassword, NULL, NULL },
    { "AUTH_TYPE",            GetServerVariableAuthType, NULL, NULL },
    { "AUTH_USER",            GetServerVariableRemoteUser, GetServerVariableRemoteUserW, NULL },
    { "CACHE_URL",            GetServerVariableOriginalUrl, GetServerVariableOriginalUrlW, NULL },
    { "CERT_COOKIE",          GetServerVariableClientCertCookie, NULL, NULL },
    { "CERT_FLAGS",           GetServerVariableClientCertFlags, NULL, NULL },
    { "CERT_ISSUER",          GetServerVariableClientCertIssuer, NULL, NULL },
    { "CERT_KEYSIZE",         GetServerVariableHttpsKeySize, NULL, NULL },
    { "CERT_SECRETKEYSIZE",   GetServerVariableHttpsSecretKeySize, NULL, NULL },
    { "CERT_SERIALNUMBER",    GetServerVariableClientCertSerialNumber, NULL, NULL },
    { "CERT_SERVER_ISSUER",   GetServerVariableHttpsServerIssuer, NULL, NULL },
    { "CERT_SERVER_SUBJECT",  GetServerVariableHttpsServerSubject, NULL, NULL },
    { "CERT_SUBJECT",         GetServerVariableClientCertSubject, NULL, NULL },
    { "CONTENT_LENGTH",       GetServerVariableContentLength, NULL, NULL },
    { "CONTENT_TYPE",         GetServerVariableContentType, NULL, NULL },
    { "GATEWAY_INTERFACE",    GetServerVariableGatewayInterface, NULL, NULL },
    { "HTTPS",                GetServerVariableHttps, NULL, NULL },
    { "HTTPS_KEYSIZE",        GetServerVariableHttpsKeySize, NULL, NULL },
    { "HTTPS_SECRETKEYSIZE",  GetServerVariableHttpsSecretKeySize, NULL, NULL },
    { "HTTPS_SERVER_ISSUER",  GetServerVariableHttpsServerIssuer, NULL, NULL },
    { "HTTPS_SERVER_SUBJECT", GetServerVariableHttpsServerSubject, NULL, NULL },
    { "HTTP_URL",             GetServerVariableHttpUrl, NULL, NULL },
    { "HTTP_METHOD",          GetServerVariableRequestMethod, NULL, NULL },
    { "HTTP_VERSION",         GetServerVariableHttpVersion, NULL, NULL },
    { "INSTANCE_ID",          GetServerVariableInstanceId, NULL, NULL },
    { "INSTANCE_META_PATH",   GetServerVariableInstanceMetaPath, NULL, NULL },
    { "LOCAL_ADDR",           GetServerVariableLocalAddr, NULL, NULL },
    { "LOGON_USER",           GetServerVariableLogonUser, GetServerVariableLogonUserW, NULL },
    { "PATH_INFO",            GetServerVariablePathInfo, GetServerVariablePathInfoW, NULL },
    { "PATH_TRANSLATED",      GetServerVariablePathTranslated, GetServerVariablePathTranslatedW, NULL },
    { "QUERY_STRING",         GetServerVariableQueryString, NULL, NULL },
    { "REMOTE_ADDR",          GetServerVariableRemoteAddr, NULL, NULL },
    { "REMOTE_HOST",          GetServerVariableRemoteHost, NULL, NULL },
    { "REMOTE_PORT",          GetServerVariableRemotePort, NULL, NULL },
    { "REMOTE_USER",          GetServerVariableRemoteUser, GetServerVariableRemoteUserW, NULL },
    { "REQUEST_METHOD",       GetServerVariableRequestMethod, NULL, NULL },
    { "SCRIPT_NAME",          GetServerVariableUrl, GetServerVariableUrlW, NULL },
    { "SCRIPT_TRANSLATED",    GetServerVariableScriptTranslated, GetServerVariableScriptTranslatedW, NULL },
    { "SERVER_NAME",          GetServerVariableServerName, GetServerVariableServerNameW, NULL },
    { "SERVER_PORT",          GetServerVariableServerPort, NULL, NULL },
    { "SERVER_PORT_SECURE",   GetServerVariableServerPortSecure, NULL, NULL },
    { "SERVER_PROTOCOL",      GetServerVariableHttpVersion, NULL, NULL },
    { "SERVER_SOFTWARE",      GetServerVariableServerSoftware, NULL, NULL },
    { "SSI_EXEC_DISABLED",    GetServerVariableSsiExecDisabled, NULL, NULL },
    { "UNENCODED_URL",        GetServerVariableUnencodedUrl, NULL, NULL },
    { "UNMAPPED_REMOTE_USER", GetServerVariableRemoteUser, GetServerVariableRemoteUserW, NULL },
    { "URL",                  GetServerVariableUrl, GetServerVariableUrlW, NULL },
    { NULL,                   NULL, NULL, NULL }
};

//static
HRESULT
SERVER_VARIABLE_HASH::Initialize(
    VOID
)
/*++

Routine Description:

    Initialize global server variable hash table

Arguments:

    None

Return Value:

    HRESULT

--*/
{
    SERVER_VARIABLE_RECORD *        pRecord;
    LK_RETCODE                      lkrc = LK_SUCCESS;
    
    sm_pRequestHash = new SERVER_VARIABLE_HASH;
    if ( sm_pRequestHash == NULL )
    {
        return HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );        
    }
    
    //
    // Add every string->routine mapping
    //
    
    pRecord = sm_rgServerRoutines;
    while ( pRecord->_pszName != NULL )
    {
        sm_pRequestHash->InsertRecord( pRecord );
        pRecord++;
    }
    
    //
    // If any insert failed, then fail initialization
    //
    
    if ( lkrc != LK_SUCCESS )
    {
        delete sm_pRequestHash;
        sm_pRequestHash = NULL;
        return HRESULT_FROM_WIN32( lkrc );        // ARGH
    }
    else
    {
        return NO_ERROR;
    }
}

//static
VOID
SERVER_VARIABLE_HASH::Terminate(
    VOID
)
/*++

Routine Description:

    Cleanup global server variable hash table

Arguments:

    None

Return Value:

    None

--*/
{
    if ( sm_pRequestHash != NULL )
    {
        delete sm_pRequestHash;
        sm_pRequestHash = NULL;
    }
}

//static
HRESULT
SERVER_VARIABLE_HASH::GetServerVariableRoutine(
    CHAR *                          pszName,
    PFN_SERVER_VARIABLE_ROUTINE   * ppfnRoutine,
    PFN_SERVER_VARIABLE_ROUTINE_W * ppfnRoutineW
)
/*++

Routine Description:

    Lookup the hash table for a routine to evaluate the given variable

Arguments:

    pszName - Name of server variable
    ppfnRoutine - Set to the routine if successful

Return Value:

    HRESULT

--*/
{
    SERVER_VARIABLE_RECORD* pServerVariableRecord = NULL;
   
    if ( pszName == NULL ||
         ppfnRoutine == NULL ||
         ppfnRoutineW == NULL )
    {
        DBG_ASSERT( FALSE );
        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }
   
    DBG_ASSERT( sm_pRequestHash != NULL );

    pServerVariableRecord = sm_pRequestHash->FindKey( pszName );
    if ( pServerVariableRecord == NULL )
    {
        return HRESULT_FROM_WIN32( ERROR_FILE_NOT_FOUND );
    }
    else
    {
        DBG_ASSERT( pServerVariableRecord != NULL );
        
        *ppfnRoutine = pServerVariableRecord->_pfnRoutine;
        *ppfnRoutineW = pServerVariableRecord->_pfnRoutineW;
        
        return NO_ERROR;
    }
}

//static
HRESULT
SERVER_VARIABLE_HASH::GetServerVariable(
    W3_CONTEXT *            pW3Context,
    CHAR *                  pszVariableName,
    CHAR *                  pszBuffer,
    DWORD *                 pcbBuffer
)
/*++

Routine Description:

    Get server variable

Arguments:

    pW3Context - W3_CONTEXT with request state.  Can be NULL if we are
                 just determining whether the server variable requested is
                 valid.
    pszVariable - Variable name to retrieve
    pszBuffer - Filled with variable on success
    pcbBuffer - On input, the size of input buffer.  On out, the required size

Return Value:

    HRESULT

--*/
{
    HRESULT                     hr;
    DWORD                       cbOriginalBuffer = *pcbBuffer;

    //
    // For performance sake, do some Kung Fu to minimize buffer copies
    // We'll initialize our string with the user's input buffer.  If
    // it wasn't big enough, we'll handle it
    //

    if (pszVariableName[0] == 'U' &&
        strncmp(pszVariableName, "UNICODE_", 8) == 0)
    {
        WCHAR achBuffer[ 512 ];
        STRU strValW( *pcbBuffer ? (LPWSTR)pszBuffer : achBuffer, 
                      *pcbBuffer ? *pcbBuffer : sizeof( achBuffer ) );

        hr = GetServerVariableW( pW3Context,
                                 pszVariableName + 8,
                                 &strValW );
        if ( FAILED( hr ) )
        {
            return hr;
        }

        *pcbBuffer = strValW.QueryCB() + sizeof( WCHAR );
       
        //
        // Did we have to resize the buffer?
        //
        
        if ( strValW.QueryStr() != (LPWSTR) pszBuffer )
        {
            //
            // Still might have enough space in source buffer, if
            // ServerVariable routine resizes buffer to larger than
            // really needed (lame)
            //
            
            if ( *pcbBuffer <= cbOriginalBuffer )
            {
                memcpy( pszBuffer,
                        strValW.QueryStr(),
                        *pcbBuffer );
                        
                return NO_ERROR;
            }
            else
            {
                //
                // User string wasn't big enough
                //
            
                return HRESULT_FROM_WIN32( ERROR_INSUFFICIENT_BUFFER );
            }
        }
        else
        {
            return NO_ERROR;
        }
    }
    else
    {
        CHAR achBuffer[ 512 ];
        STRA strVal( *pcbBuffer ? pszBuffer : achBuffer,
                     *pcbBuffer ? *pcbBuffer : sizeof( achBuffer ) );

        hr = GetServerVariable( pW3Context,
                                pszVariableName,
                                &strVal );
        if ( FAILED( hr ) )
        {
            return hr;
        }
        
        *pcbBuffer = strVal.QueryCB() + sizeof( CHAR );

        //
        // Did we have to resize the buffer?
        //

        if ( strVal.QueryStr() != pszBuffer )
        {
            //
            // Still might have enough space in source buffer, if
            // ServerVariable routine resizes buffer to larger than
            // really needed (lame)
            //
            
            if ( *pcbBuffer <= cbOriginalBuffer )
            {
                memcpy( pszBuffer,
                        strVal.QueryStr(),
                        *pcbBuffer );
                        
                return NO_ERROR;
            }
            else
            {
                //
                // User string wasn't big enough
                //
            
                return HRESULT_FROM_WIN32( ERROR_INSUFFICIENT_BUFFER );
            }
        }
        else
        {
            return NO_ERROR;
        }
    }
}


//static
HRESULT
SERVER_VARIABLE_HASH::GetServerVariable(
    W3_CONTEXT *            pW3Context,
    CHAR *                  pszVariableName,
    STRA *                  pstrVal
)
/*++

Routine Description:

    Get server variable

Arguments:

    pW3Context - W3_CONTEXT with request state.  Can be NULL if we are
                 just determining whether the server variable requested is
                 valid.  If NULL, we will return an empty string (and success)
                 if the variable requested is valid.
    pszVariable - Variable name to retrieve
    pstrVal - Filled with variable on success

Return Value:

    HRESULT

--*/
{
    HRESULT                         hr = S_OK;
    PFN_SERVER_VARIABLE_ROUTINE     pfnRoutine = NULL;
    PFN_SERVER_VARIABLE_ROUTINE_W   pfnRoutineW = NULL;

    //
    // First:  Is this a server variable we know about?  If so handle it
    //         by calling the appropriate server variable routine
    //

    hr = SERVER_VARIABLE_HASH::GetServerVariableRoutine( pszVariableName,
                                                         &pfnRoutine,
                                                         &pfnRoutineW );
    if ( SUCCEEDED(hr) )
    {
        DBG_ASSERT( pfnRoutine != NULL );

        if ( pW3Context != NULL )
        {
            return pfnRoutine( pW3Context, pstrVal );
        }
        else
        {
            //
            // Just return empty string to signify that the variable is 
            // valid but we just don't know the value at this time
            //
            
            return pstrVal->Copy( "", 0 );
        }
    }

    //
    // Second:  Is this a header name (prefixed with HTTP_)
    //

    if ( pW3Context != NULL &&
         pszVariableName[ 0 ] == 'H' &&
         !strncmp( pszVariableName, "HTTP_" , 5 ) )
    {   
        STACK_STRA(        strVariable, 256 );

        hr = strVariable.Copy( pszVariableName + 5 );
        if ( FAILED( hr ) )
        {
            return hr;
        }

        // Change '_' to '-'
        PCHAR pszCursor = strchr( strVariable.QueryStr(), '_' );
        while ( pszCursor != NULL )
        {
            *pszCursor++ = '-';
            pszCursor = strchr( pszCursor, '_' );
        }

        return pW3Context->QueryRequest()->GetHeader( strVariable,
                                                      pstrVal );
    }

    //
    // Third:  Is this an uncanonicalized header name (prefixed with HEADER_)
    //

    if ( pW3Context != NULL &&
         pszVariableName[ 0 ] == 'H' &&
         !strncmp( pszVariableName, "HEADER_" , 7 ) )
    {   
        STACK_STRA(        strVariable, 256 );

        hr = strVariable.Copy( pszVariableName + 7 );
        if ( FAILED( hr ) )
        {
            return hr;
        }

        return pW3Context->QueryRequest()->GetHeader( strVariable,
                                                      pstrVal );
    }


    return HRESULT_FROM_WIN32( ERROR_INVALID_INDEX );
}

//static
HRESULT
SERVER_VARIABLE_HASH::GetServerVariableW(
    W3_CONTEXT *            pW3Context,
    CHAR *                  pszVariableName,
    STRU *                  pstrVal
)
/*++

Routine Description:

    Get server variable

Arguments:

    pW3Context - W3_CONTEXT with request state.  Can be NULL if we are
                 just determining whether the server variable requested is
                 valid.  If NULL, we will return an empty string (and success)
                 if the variable requested is valid.
    pszVariable - Variable name to retrieve
    pstrVal - Filled with variable on success

Return Value:

    HRESULT

--*/
{
    HRESULT                         hr = S_OK;
    PFN_SERVER_VARIABLE_ROUTINE     pfnRoutine = NULL;
    PFN_SERVER_VARIABLE_ROUTINE_W   pfnRoutineW = NULL;

    hr = SERVER_VARIABLE_HASH::GetServerVariableRoutine( pszVariableName,
                                                         &pfnRoutine,
                                                         &pfnRoutineW );
    if ( SUCCEEDED(hr) )
    {
        if (pW3Context == NULL)
        {
            //
            // Just return empty string to signify that the variable is 
            // valid but we just don't know the value at this time
            //

            return pstrVal->Copy( L"", 0 );
        }

        if (pfnRoutineW != NULL)
        {
            //
            // This server-variable contains real unicode data and there
            // is a unicode ServerVariable routine for this
            //

            return pfnRoutineW( pW3Context, pstrVal );
        }
        else
        {
            //
            // No unicode version, use the ANSI version and just wide'ize it
            //
            STACK_STRA( straVal, 256);

            DBG_ASSERT( pfnRoutine != NULL );

            if (FAILED(hr = pfnRoutine( pW3Context, &straVal )) ||
                FAILED(hr = pstrVal->CopyA( straVal.QueryStr(),
                                            straVal.QueryCCH() )))
            {
                return hr;
            }

            return S_OK;
        }
    }
    
    return HRESULT_FROM_WIN32( ERROR_INVALID_INDEX );
}

//
// Server variable functions
//

HRESULT
GetServerVariableQueryString(
    W3_CONTEXT *pW3Context,
    STRA       *pstrVal
)
{
    DBG_ASSERT( pW3Context != NULL );

    return pW3Context->QueryRequest()->GetQueryStringA(pstrVal);
}

HRESULT
GetServerVariableAllHttp(   
    W3_CONTEXT *pW3Context,
    STRA       *pstrVal
)
{
    DBG_ASSERT( pW3Context != NULL );
    
    return pW3Context->QueryRequest()->GetAllHeaders( pstrVal, TRUE );
}

HRESULT
GetServerVariableAllRaw(   
    W3_CONTEXT *pW3Context,
    STRA       *pstrVal
)
{
    DBG_ASSERT( pW3Context != NULL );
    
    return pW3Context->QueryRequest()->GetAllHeaders( pstrVal, FALSE );
}

HRESULT
GetServerVariableContentLength(
    W3_CONTEXT *pW3Context,
    STRA       *pstrVal
)
{
    const CHAR *                pszContentLength;
    
    DBG_ASSERT( pW3Context != NULL );

    if ( pW3Context->QueryRequest()->IsChunkedRequest() )
    {
        pszContentLength = "-1";
    }
    else
    {
        pszContentLength = pW3Context->QueryRequest()->GetHeader( HttpHeaderContentLength );
        if ( pszContentLength == NULL )
        {
            pszContentLength = "0";
        }        
    }

    return pstrVal->Copy( pszContentLength );
}

HRESULT
GetServerVariableContentType(
    W3_CONTEXT *pW3Context,
    STRA       *pstrVal
)
{
    DBG_ASSERT( pW3Context != NULL );
    
    LPCSTR pszContentType = pW3Context->QueryRequest()->
        GetHeader( HttpHeaderContentType );
    if ( pszContentType == NULL )
    {
        pszContentType = "";
    }   

    return pstrVal->Copy( pszContentType );
}

HRESULT
GetServerVariableInstanceId(
    W3_CONTEXT *pW3Context,
    STRA       *pstrVal
)
{
    DBG_ASSERT( pW3Context != NULL );
    
    CHAR      pszId[16];
    _itoa( pW3Context->QueryRequest()->QuerySiteId(), pszId, 10 );

    return pstrVal->Copy( pszId );
}

HRESULT
GetServerVariableRemoteHost(
    W3_CONTEXT *pW3Context,
    STRA       *pstrVal
)
{
    HRESULT         hr;
    
    DBG_ASSERT( pW3Context != NULL );

    //
    // If we have a resolved DNS name, then use it.  Otherwise just
    // return the address
    //

    hr = pW3Context->QueryMainContext()->GetRemoteDNSName( pstrVal );
    if ( hr == HRESULT_FROM_WIN32( ERROR_NOT_SUPPORTED ) )
    {
        hr = GetServerVariableRemoteAddr( pW3Context, pstrVal );
    }
    
    return hr;
}

HRESULT
GetServerVariableRemoteAddr(
    W3_CONTEXT *pW3Context,
    STRA       *pstrVal
)
{
    DBG_ASSERT( pW3Context != NULL );

    HRESULT      hr         = S_OK;
    W3_REQUEST * pW3Request = pW3Context->QueryRequest();
    DBG_ASSERT( pW3Request != NULL );

    if( pW3Request->QueryRemoteAddressType() == AF_INET )
    {
        DWORD dwAddr = ntohl( pW3Request->QueryIPv4RemoteAddress() );
        hr = TranslateIpAddressToStr( dwAddr, pstrVal );
    }
    else if( pW3Request->QueryRemoteAddressType() == AF_INET6 )
    {
        SOCKADDR_IN6    IPv6RemoteAddress;
        CHAR            szNumericRemoteAddress[ NI_MAXHOST ];

        IPv6RemoteAddress.sin6_family   = AF_INET6;
        IPv6RemoteAddress.sin6_port     = pW3Request->QueryRemotePort();
        IPv6RemoteAddress.sin6_flowinfo = ( ( PSOCKADDR_IN6 )
                  pW3Request->QueryRemoteSockAddress() )->sin6_flowinfo;
        IPv6RemoteAddress.sin6_addr     = 
                  *pW3Request->QueryIPv6RemoteAddress();
        IPv6RemoteAddress.sin6_scope_id = ( ( PSOCKADDR_IN6 )
                  pW3Request->QueryRemoteSockAddress() )->sin6_scope_id;
        
        if( getnameinfo( ( LPSOCKADDR )&IPv6RemoteAddress,
                         sizeof( IPv6RemoteAddress ),
                         szNumericRemoteAddress,
                         sizeof( szNumericRemoteAddress ),
                         NULL,
                         0,
                         NI_NUMERICHOST ) != 0 )
        {
            hr = HRESULT_FROM_WIN32( WSAGetLastError() );
        }
        else
        {
            hr = pstrVal->Copy( szNumericRemoteAddress );
        }
    }
    else
    {
        DBG_ASSERT( FALSE );
    }
    
    return hr;
}

HRESULT
GetServerVariableRemotePort(
    W3_CONTEXT *pW3Context,
    STRA       *pstrVal
)
{
    DBG_ASSERT( pW3Context != NULL );

    W3_REQUEST * pW3Request = pW3Context->QueryRequest();
    CHAR         szPort[33]; // 33 is max buffer used by _ultoa
    USHORT       uPort;

    DBG_ASSERT( pW3Request != NULL );

    uPort = htons( pW3Request->QueryRemotePort() );

    _ultoa( uPort, szPort, 10 );

    return pstrVal->Copy( szPort );
}

HRESULT
GetServerVariableServerName(
    W3_CONTEXT *pW3Context,
    STRA       *pstrVal
)
{
    STACK_STRU( strValW, 32 );

    DBG_ASSERT( pW3Context != NULL );

    //
    // If the client sent a host name, use it.
    //

    HRESULT hr = pW3Context->QueryRequest()->GetHostAddr( &strValW );
    if ( FAILED( hr ))
    {
        return hr;
    }

    return pstrVal->CopyW( strValW.QueryStr() );
}

HRESULT
GetServerVariableServerNameW(
    W3_CONTEXT *pW3Context,
    STRU       *pstrVal
)
{
    DBG_ASSERT( pW3Context != NULL );

    //
    // If the client sent a host name, use it.
    //

    return pW3Context->QueryRequest()->GetHostAddr( pstrVal );
}

HRESULT
GetServerVariableServerPort(
    W3_CONTEXT *pW3Context,
    STRA       *pstrVal
)
{
    DBG_ASSERT( pW3Context != NULL );
    
    USHORT  port;

    W3_REQUEST * pW3Request = pW3Context->QueryRequest();
    DBG_ASSERT( pW3Request != NULL );

    port = ntohs( pW3Request->QueryLocalPort() );
    
    CHAR szPort[8];
    _itoa( port, szPort, 10 );

    return pstrVal->Copy( szPort );
}

HRESULT
GetServerVariablePathInfo(
    W3_CONTEXT *pW3Context,
    STRA       *pstrVal
)
{
    DBG_ASSERT( pW3Context != NULL );

    URL_CONTEXT *pUrlContext;
    BOOL fDeleteHandler = FALSE;
    
    pUrlContext = pW3Context->QueryUrlContext();

    //
    // We might be called in an early filter where URL context isn't available
    //

    if ( pUrlContext == NULL )
    {
        pstrVal->Reset();
        return NO_ERROR;
    }

    W3_URL_INFO *pUrlInfo = pUrlContext->QueryUrlInfo();
    DBG_ASSERT( pUrlInfo != NULL );

    W3_SITE *pSite = pW3Context->QuerySite();
    DBG_ASSERT( pSite != NULL );

    W3_HANDLER *pHandler;
    pHandler = pW3Context->QueryHandler();

    HRESULT hr;

    //
    // If we have no handler, yet we have a URL_CONTEXT, then this
    // must be GetServerVariable() call before the handler state
    // Determine the handler temporarily so we can make right call
    // on variable.  Only need to do this for ANSI variable since this 
    // problem only happens for filter calls
    //

    if ( pHandler == NULL )
    {
        hr = pW3Context->InternalDetermineHandler( &pHandler, FALSE );
        if ( FAILED( hr ) )
        {
            goto Finished;
        }
        
        DBG_ASSERT( pHandler != NULL );
        
        fDeleteHandler = TRUE;
    }

    //
    // In the case of script maps, if AllowPathInfoForScriptMappings
    // is not set for the site, we ignore path info, it is
    // just the URL
    //

    if ( pHandler != NULL &&
         pHandler->QueryScriptMapEntry() &&
         !pSite->QueryAllowPathInfoForScriptMappings() )
    {
        STACK_STRU (strUrl, MAX_PATH);
        
        if (FAILED(hr = pW3Context->QueryRequest()->GetUrl( &strUrl )) ||
            FAILED(hr = pstrVal->CopyW( strUrl.QueryStr() )))
        {
            goto Finished; 
        }
    }
    else
    {
        hr = pstrVal->CopyW( pUrlInfo->QueryPathInfo()->QueryStr() );
    }

Finished:

    if ( fDeleteHandler )
    {
        delete pHandler;
        pHandler = NULL;
    }
    
    return hr;
}

HRESULT
GetServerVariablePathInfoW(
    W3_CONTEXT *pW3Context,
    STRU       *pstrVal
)
{
    DBG_ASSERT( pW3Context != NULL );

    URL_CONTEXT *pUrlContext;
    pUrlContext = pW3Context->QueryUrlContext();

    //
    // We might be called in an early filter where URL context isn't available
    //

    if ( pUrlContext == NULL )
    {
        pstrVal->Reset();
        return NO_ERROR;
    }

    W3_URL_INFO *pUrlInfo = pUrlContext->QueryUrlInfo();
    DBG_ASSERT( pUrlInfo != NULL );

    W3_SITE *pSite = pW3Context->QuerySite();
    DBG_ASSERT( pSite != NULL );

    W3_HANDLER *pHandler;
    pHandler = pW3Context->QueryHandler();

    //
    // In the case of script maps, if AllowPathInfoForScriptMappings
    // is not set for the site, we ignore path info, it is
    // just the URL
    //

    if ( pHandler != NULL &&
         pHandler->QueryScriptMapEntry() &&
         !pSite->QueryAllowPathInfoForScriptMappings() )
    {
        return pW3Context->QueryRequest()->GetUrl( pstrVal );
    }
    else
    {
        return pstrVal->Copy( pUrlInfo->QueryPathInfo()->QueryStr() );
    }
}

HRESULT
GetServerVariablePathTranslated(
    W3_CONTEXT *pW3Context,
    STRA       *pstrVal
)
{
    DBG_ASSERT( pW3Context != NULL );

    HRESULT hr;
    BOOL fDeleteHandler = FALSE;

    URL_CONTEXT *pUrlContext;
    pUrlContext = pW3Context->QueryUrlContext();

    if ( pUrlContext == NULL )
    {
        return pstrVal->Copy( "" );
    }

    W3_URL_INFO *pUrlInfo = pUrlContext->QueryUrlInfo();
    DBG_ASSERT(pUrlInfo != NULL);

    W3_SITE *pSite = pW3Context->QuerySite();
    DBG_ASSERT(pSite != NULL);

    W3_HANDLER *pHandler;
    pHandler = pW3Context->QueryHandler();

    //
    // If we have no handler, yet we have a URL_CONTEXT, then this
    // must be GetServerVariable() call before the handler state
    // Determine the handler temporarily so we can make right call
    // on variable.  Only need to do this for ANSI variable since this 
    // problem only happens for filter calls
    //

    if ( pHandler == NULL )
    {
        hr = pW3Context->InternalDetermineHandler( &pHandler, FALSE );
        if ( FAILED( hr ) )
        {
            return hr;
        }
        
        DBG_ASSERT( pHandler != NULL );
        
        fDeleteHandler = TRUE;
    }

    BOOL fUsePathInfo;
    if ( pHandler != NULL &&
         pHandler->QueryScriptMapEntry() &&
         !pSite->QueryAllowPathInfoForScriptMappings() )
    {
        fUsePathInfo = FALSE;
    }
    else
    {
        fUsePathInfo = TRUE;
    }

    STACK_STRU (struPathTranslated, 256);
    //
    // This is a new virtual path to have filters map
    //

    hr = pUrlInfo->GetPathTranslated( pW3Context,
                                      fUsePathInfo,
                                      &struPathTranslated );

    if (SUCCEEDED(hr))
    {
        hr = pstrVal->CopyW( struPathTranslated.QueryStr() );
    }
    
    if ( fDeleteHandler )
    {
        delete pHandler;
        pHandler = NULL;
    }

    return hr;
}

HRESULT
GetServerVariablePathTranslatedW(
    W3_CONTEXT *pW3Context,
    STRU       *pstrVal
)
{
    DBG_ASSERT( pW3Context != NULL );

    URL_CONTEXT *pUrlContext;
    pUrlContext = pW3Context->QueryUrlContext();

    if ( pUrlContext == NULL )
    {
        return pstrVal->Copy( L"" );
    }

    W3_URL_INFO *pUrlInfo = pUrlContext->QueryUrlInfo();
    DBG_ASSERT(pUrlInfo != NULL);

    W3_SITE *pSite = pW3Context->QuerySite();
    DBG_ASSERT(pSite != NULL);

    W3_HANDLER *pHandler;
    pHandler = pW3Context->QueryHandler();

    BOOL fUsePathInfo;
    if ( pHandler != NULL &&
         pHandler->QueryScriptMapEntry() &&
         !pSite->QueryAllowPathInfoForScriptMappings() )
    {
        fUsePathInfo = FALSE;
    }
    else
    {
        fUsePathInfo = TRUE;
    }

    //
    // This is a new virtual path to have filters map
    //

    return pUrlInfo->GetPathTranslated( pW3Context,
                                        fUsePathInfo,
                                        pstrVal );
}

HRESULT
GetServerVariableRequestMethod(
    W3_CONTEXT *pW3Context,
    STRA       *pstrVal
)
{
    DBG_ASSERT( pW3Context != NULL );
    
    return pW3Context->QueryRequest()->GetVerbString( pstrVal );
}

HRESULT
GetServerVariableServerPortSecure(
    W3_CONTEXT *pW3Context,
    STRA       *pstrVal
)
{
    DBG_ASSERT( pW3Context != NULL );
    
    if ( pW3Context->QueryRequest()->IsSecureRequest() )
    {
        return pstrVal->Copy("1", 1);
    }

    return pstrVal->Copy("0", 1);
}

HRESULT
GetServerVariableServerSoftware(
    W3_CONTEXT *,
    STRA       *pstrVal
)
{
    return pstrVal->Copy( SERVER_SOFTWARE_STRING );
}

HRESULT
GetServerVariableUrl(
    W3_CONTEXT *pW3Context,
    STRA       *pstrVal
)
{
    URL_CONTEXT *       pUrlContext;
    W3_URL_INFO *       pUrlInfo;
    STACK_STRU(         strUrl, 256 );
    HRESULT             hr;
    
    DBG_ASSERT( pW3Context != NULL );
    
    //
    // URL context can be NULL if an early filter is called GetServerVar()
    //
    
    pUrlContext = pW3Context->QueryUrlContext();
    if ( pUrlContext != NULL )
    {
        pUrlInfo = pUrlContext->QueryUrlInfo();
        DBG_ASSERT( pUrlInfo != NULL );
        
        return pstrVal->CopyW( pUrlInfo->QueryProcessedUrl()->QueryStr() );
    }
    else
    {
        hr = pW3Context->QueryRequest()->GetUrl( &strUrl );
        if ( FAILED( hr ) )
        {
            return hr;
        }
        
        return pstrVal->CopyW( strUrl.QueryStr() );
    }
}

HRESULT
GetServerVariableUrlW(
    W3_CONTEXT *pW3Context,
    STRU       *pstrVal
)
{
    URL_CONTEXT *       pUrlContext;
    W3_URL_INFO *       pUrlInfo;
    
    DBG_ASSERT( pW3Context != NULL );
    
    //
    // URL context can be NULL if an early filter is called GetServerVar()
    //
    
    pUrlContext = pW3Context->QueryUrlContext();
    if ( pUrlContext != NULL )
    {
        pUrlInfo = pUrlContext->QueryUrlInfo();
        DBG_ASSERT( pUrlInfo != NULL );
        
        return pstrVal->Copy( pUrlInfo->QueryProcessedUrl()->QueryStr() );
    }
    else
    {
        return pW3Context->QueryRequest()->GetUrl( pstrVal );
    }
}

HRESULT
GetServerVariableInstanceMetaPath(
    W3_CONTEXT *pW3Context,
    STRA       *pstrVal
)
{
    DBG_ASSERT( pW3Context != NULL );

    STRU *pstrMetaPath = pW3Context->QuerySite()->QueryMBPath();
    DBG_ASSERT( pstrMetaPath );

    return pstrVal->CopyW( pstrMetaPath->QueryStr() );
}

HRESULT
GetServerVariableLogonUser(
    W3_CONTEXT *pW3Context,
    STRA       *pstrVal
)
{
    DBG_ASSERT( pW3Context != NULL );
    
    W3_USER_CONTEXT *pUserContext;
    pUserContext = pW3Context->QueryUserContext();
    
    if ( pUserContext == NULL )
    {
        return pW3Context->QueryRequest()->GetRequestUserName( pstrVal );
    }
    else
    {
        return pstrVal->CopyW( pUserContext->QueryUserName() );
    }
}

HRESULT
GetServerVariableLogonUserW(
    W3_CONTEXT *pW3Context,
    STRU       *pstrVal
)
{
    DBG_ASSERT( pW3Context != NULL );
    
    W3_USER_CONTEXT *pUserContext;
    pUserContext = pW3Context->QueryUserContext();
    
    if ( pUserContext == NULL )
    {
        return pstrVal->CopyA( pW3Context->QueryRequest()->QueryRequestUserName()->QueryStr() );
    }
    else
    {
        return pstrVal->Copy( pUserContext->QueryUserName() );
    }
}

HRESULT
GetServerVariableRemoteUser(
    W3_CONTEXT *pW3Context,
    STRA       *pstrVal
)
{
    HRESULT                     hr;
    
    DBG_ASSERT( pW3Context != NULL );
    
    hr = pW3Context->QueryRequest()->GetRequestUserName( pstrVal );
    if ( FAILED( hr ) )
    {
        return hr;
    }
    
    if ( pstrVal->IsEmpty() )
    {
        W3_USER_CONTEXT *pUserContext;
        pUserContext = pW3Context->QueryUserContext();
        
        if ( pUserContext != NULL )
        {
            hr = pstrVal->CopyW( pUserContext->QueryRemoteUserName() );
        }
        else
        {
            hr = NO_ERROR;
        }
    }

    return hr;
}

HRESULT
GetServerVariableRemoteUserW(
    W3_CONTEXT *pW3Context,
    STRU       *pstrVal
)
{
    DBG_ASSERT( pW3Context != NULL );
    
    STRA *pstrUserName = pW3Context->QueryRequest()->QueryRequestUserName();
    
    if ( pstrUserName->IsEmpty() )
    {
        W3_USER_CONTEXT *pUserContext;
        pUserContext = pW3Context->QueryUserContext();
        
        if ( pUserContext != NULL )
        {
            return pstrVal->Copy( pUserContext->QueryRemoteUserName() );
        }
    }
    else
    {
        return pstrVal->CopyA( pstrUserName->QueryStr() );
    }

    return S_OK;
}

HRESULT
GetServerVariableAuthType(
    W3_CONTEXT *pW3Context,
    STRA       *pstrVal
)
{
    DBG_ASSERT( pW3Context != NULL );
    DBG_ASSERT( pstrVal != NULL );

    HRESULT hr = S_OK;

    W3_USER_CONTEXT *pUserContext = pW3Context->QueryUserContext();

    if ( pUserContext != NULL )
    {
        if ( pUserContext->QueryAuthType() == MD_ACCESS_MAP_CERT )
        {
            hr = pstrVal->Copy( "SSL/PCT" );
        }
        else if ( pUserContext->QueryAuthType() == MD_AUTH_ANONYMOUS )
        {
            hr = pstrVal->Copy( "" );
        }
        else if ( pUserContext->QueryAuthType() == MD_AUTH_PASSPORT )
        {
            hr = pstrVal->Copy( "PASSPORT" );
        }
        else
        {
            hr = pW3Context->QueryRequest()->GetAuthType( pstrVal );
        }
    }
    else
    {
        //
        // If an filter checks this server variable in
        // SF_NOTIFY_AUTHENTICATION, there won't be a pUserContext
        // yet, but we need to give an answer based on the
        // authorization header anyway to be compatible with
        // legacy behavior.
        //

        hr = pW3Context->QueryRequest()->GetAuthType( pstrVal );

    }
    return hr;
}

HRESULT
GetServerVariableAuthPassword(
    W3_CONTEXT *pW3Context,
    STRA       *pstrVal
)
{
    HRESULT                 hr;
    
    DBG_ASSERT( pW3Context != NULL );

    hr = pW3Context->QueryRequest()->GetRequestPassword( pstrVal );
    if ( FAILED( hr ) )
    {
        return hr;
    }
        
    if ( pstrVal->IsEmpty() )
    {
        W3_USER_CONTEXT * pUserContext;
        pUserContext = pW3Context->QueryUserContext();
        
        if ( pUserContext != NULL )
        {
            hr = pstrVal->CopyW( pUserContext->QueryPassword() );
        }
        else
        {
            hr = NO_ERROR;
        }
    }

    return hr;
}

HRESULT
GetServerVariableApplMdPath(
    W3_CONTEXT *pW3Context,
    STRA       *pstrVal
)
{
    STRU *          pstrAppMetaPath = NULL;
    URL_CONTEXT *   pUrlContext;
    HRESULT         hr;
    
    DBG_ASSERT( pW3Context != NULL );

    pUrlContext = pW3Context->QueryUrlContext();
    if ( pUrlContext != NULL )
    {
        W3_METADATA *pMetaData = pUrlContext->QueryMetaData();
        
        DBG_ASSERT( pMetaData != NULL );
        
        pstrAppMetaPath = pMetaData->QueryAppMetaPath();
    }

    if( pstrAppMetaPath == NULL ||
        pstrAppMetaPath->IsEmpty() )
    {
        //
        // If we don't have APPL_MD_PATH, then the caller should
        // get an empty string.
        //

        hr = pstrVal->Copy( "", 0 );
    }
    else
    {
        hr = pstrVal->CopyW( pstrAppMetaPath->QueryStr() );
    }

    return hr;
}

HRESULT
GetServerVariableApplMdPathW(
    W3_CONTEXT *pW3Context,
    STRU       *pstrVal
)
{
    STRU *          pstrAppMetaPath = NULL;
    URL_CONTEXT *   pUrlContext;
    HRESULT         hr;
    
    DBG_ASSERT( pW3Context != NULL );

    pUrlContext = pW3Context->QueryUrlContext();
    if ( pUrlContext != NULL )
    {
        W3_METADATA *pMetaData = pUrlContext->QueryMetaData();
        
        DBG_ASSERT( pMetaData != NULL );
        
        pstrAppMetaPath = pMetaData->QueryAppMetaPath();
    }

    if( pstrAppMetaPath == NULL || 
        pstrAppMetaPath->IsEmpty() )
    {
        //
        // If we don't have APPL_MD_PATH, then the caller should
        // get an empty string.
        //

        hr = pstrVal->Copy( L"" );
    }
    else
    {
        hr = pstrVal->Copy( pstrAppMetaPath->QueryStr() );
    }

    return hr;
}

HRESULT
GetServerVariableApplPhysicalPath(
    W3_CONTEXT *pW3Context,
    STRA       *pstrVal
)
{
    DBG_ASSERT( pW3Context != NULL );
    DBG_ASSERT( pstrVal );

    STACK_STRA( strAppMetaPath, MAX_PATH );
    STACK_STRU( strAppUrl, MAX_PATH );
    HRESULT     hr = E_FAIL;

    hr = GetServerVariableApplMdPath( pW3Context, &strAppMetaPath );

    if( SUCCEEDED(hr) )
    {
        //
        // pstrAppMetaPath is a full metabase path:
        //      /LM/W3SVC/<site>/Root/...
        //
        // To convert it to a physical path we will use 
        // W3_STATE_URLINFO::MapPath, but this requires 
        // that we remove the metabase prefixes and build 
        // a Url string.
        //

        //
        // Get the metabase path for the site root
        //

        W3_SITE *pSite = pW3Context->QuerySite();
        DBG_ASSERT( pSite );

        STRU *pstrSiteRoot = pSite->QueryMBRoot();
        DBG_ASSERT( pstrSiteRoot );

        //
        // Make some assumptions about the site path and the AppMetaPath 
        // being well-formed. The AppMetaPath may not have a terminating 
        // /, but the site root will.
        //
    
        DBG_ASSERT( pstrSiteRoot->QueryCCH() >= 
                    sizeof("/LM/W3SVC/1/Root/") - 1 
                    );

        if( strAppMetaPath.QueryCCH() < pstrSiteRoot->QueryCCH() - 1 )
        {
            //
            // This indicates an invalid value for MD_APP_ROOT is sitting
            // around. We need to bail if this is the case.
            //

            DBGPRINTF(( DBG_CONTEXT,
                        "Invalid MD_APP_ROOT detected (%s)\n",
                        strAppMetaPath.QueryStr()
                        ));
            
            return HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
        }

        DBG_ASSERT( strAppMetaPath.QueryCCH() >= 
                    sizeof("/LM/W3SVC/1/Root/") - 2 
                    );

        //
        // The AppUrl will be the metabase path - 
        // all the /LM/W3SVC/1/ROOT goo
        //

        CHAR * pszStartAppUrl = strAppMetaPath.QueryStr() + 
            (pstrSiteRoot->QueryCCH() - 1);

        //
        // The AppMetaPath may not have a terminating /, so if it is 
        // a site root pszStartAppUrl will be empty.
        //
    
        if( *pszStartAppUrl != '\0' )
        {
            if( *pszStartAppUrl != '/' )
            {
                DBGPRINTF(( DBG_CONTEXT,
                            "Invalid MD_APP_ROOT detected (%s)\n",
                            strAppMetaPath.QueryStr()
                            ));
            
                return HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
            }

            hr = strAppUrl.CopyA(
                    pszStartAppUrl,
                    strAppMetaPath.QueryCCH() - (pstrSiteRoot->QueryCCH() - 1)
                    );
        }
        else
        {
            hr = strAppUrl.Copy( L"/", 1 );
        }

        if( SUCCEEDED(hr) )
        {
            STACK_STRU (strAppPath, MAX_PATH);
            //
            // Convert to a physical path
            //

            hr = W3_STATE_URLINFO::MapPath( pW3Context,
                                            strAppUrl,
                                            &strAppPath,
                                            FALSE,
                                            NULL,
                                            NULL,
                                            NULL,
                                            NULL,
                                            NULL
                                            );
            if (SUCCEEDED(hr))
            {
                hr = pstrVal->CopyW(strAppPath.QueryStr());

                //
                // Ensure that the last character in the path
                // is '\\'.  There are legacy scripts that will
                // concatenate filenames to this path, and many
                // of them will break if we don't do this.
                //

                if ( SUCCEEDED( hr ) &&
                     *(pstrVal->QueryStr()+pstrVal->QueryCCH()-1) != '\\' )
                {
                    hr = pstrVal->Append( "\\" );
                }
            }
        }
    }

    return hr;
}

HRESULT
GetServerVariableApplPhysicalPathW(
    W3_CONTEXT *pW3Context,
    STRU       *pstrVal
)
{
    DBG_ASSERT( pW3Context != NULL );
    DBG_ASSERT( pstrVal );

    STACK_STRU( strAppMetaPath, MAX_PATH );
    STACK_STRU( strAppUrl, MAX_PATH );
    HRESULT     hr = E_FAIL;

    hr = GetServerVariableApplMdPathW( pW3Context, &strAppMetaPath );

    if( SUCCEEDED(hr) )
    {
        //
        // pstrAppMetaPath is a full metabase path:
        //      /LM/W3SVC/<site>/Root/...
        //
        // To convert it to a physical path we will use 
        // W3_STATE_URLINFO::MapPath, but this requires 
        // that we remove the metabase prefixes and build 
        // a Url string.
        //

        //
        // Get the metabase path for the site root
        //

        W3_SITE *pSite = pW3Context->QuerySite();
        DBG_ASSERT( pSite );

        STRU *pstrSiteRoot = pSite->QueryMBRoot();
        DBG_ASSERT( pstrSiteRoot );

        //
        // Make some assumptions about the site path and the AppMetaPath 
        // being well-formed. The AppMetaPath may not have a terminating 
        // /, but the site root will.
        //
    
        DBG_ASSERT( pstrSiteRoot->QueryCCH() >= 
                    sizeof("/LM/W3SVC/1/Root/") - 1 
                    );

        if( strAppMetaPath.QueryCCH() < pstrSiteRoot->QueryCCH() - 1 )
        {
            //
            // This indicates an invalid value for MD_APP_ROOT is sitting
            // around. We need to bail if this is the case.
            //

            DBGPRINTF(( DBG_CONTEXT,
                        "Invalid MD_APP_ROOT detected (%S)\n",
                        strAppMetaPath.QueryStr()
                        ));
            
            return HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
        }

        DBG_ASSERT( strAppMetaPath.QueryCCH() >= 
                    sizeof("/LM/W3SVC/1/Root/") - 2 
                    );

        //
        // The AppUrl will be the metabase path - 
        // all the /LM/W3SVC/1/ROOT goo
        //

        WCHAR * pszStartAppUrl = strAppMetaPath.QueryStr() + 
            (pstrSiteRoot->QueryCCH() - 1);

        //
        // The AppMetaPath may not have a terminating /, so if it is 
        // a site root pszStartAppUrl will be empty.
        //
    
        if( *pszStartAppUrl != L'\0' )
        {
            if( *pszStartAppUrl != L'/' )
            {
                DBGPRINTF(( DBG_CONTEXT,
                            "Invalid MD_APP_ROOT detected (%s)\n",
                            strAppMetaPath.QueryStr()
                            ));
            
                return HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
            }

            hr = strAppUrl.Copy(
                    pszStartAppUrl,
                    strAppMetaPath.QueryCCH() - (pstrSiteRoot->QueryCCH() - 1)
                    );
        }
        else
        {
            hr = strAppUrl.Copy( L"/", 1 );
        }

        if( SUCCEEDED(hr) )
        {
            hr =  W3_STATE_URLINFO::MapPath( pW3Context,
                                              strAppUrl,
                                              pstrVal,
                                              FALSE,
                                              NULL,
                                              NULL,
                                              NULL,
                                              NULL,
                                              NULL
                                              );

            //
            // Ensure that the last character in the path
            // is '\\'.  There are legacy scripts that will
            // concatenate filenames to this path, and many
            // of them will break if we don't do this.
            //

            if ( SUCCEEDED( hr ) &&
                 *(pstrVal->QueryStr()+pstrVal->QueryCCH()-1) != L'\\' )
            {
                hr = pstrVal->Append( L"\\" );
            }
        }
    }

    return hr;
}

HRESULT
GetServerVariableGatewayInterface(
    W3_CONTEXT *,
    STRA       *pstrVal
)
{
    return pstrVal->Copy("CGI/1.1", 7);
}

HRESULT 
GetServerVariableLocalAddr(
    W3_CONTEXT *pW3Context,
    STRA *pstrVal
)
{
    DBG_ASSERT( pW3Context != NULL );

    HRESULT      hr         = S_OK;
    W3_REQUEST * pW3Request = pW3Context->QueryRequest();
    DBG_ASSERT( pW3Request != NULL );

    if( pW3Request->QueryLocalAddressType() == AF_INET )
    {
        DWORD dwAddr = ntohl( pW3Request->QueryIPv4LocalAddress() );
        hr = TranslateIpAddressToStr( dwAddr, pstrVal );
    }
    else if( pW3Request->QueryLocalAddressType() == AF_INET6 )
    {
        SOCKADDR_IN6     IPv6LocalAddress;
        CHAR             szNumericLocalAddress[ NI_MAXHOST ];

        IPv6LocalAddress.sin6_family   = AF_INET6;
        IPv6LocalAddress.sin6_port     = pW3Request->QueryLocalPort();
        IPv6LocalAddress.sin6_flowinfo = ( ( PSOCKADDR_IN6 )
                  pW3Request->QueryLocalSockAddress() )->sin6_flowinfo;
        IPv6LocalAddress.sin6_addr     = 
                  *pW3Request->QueryIPv6LocalAddress();
        IPv6LocalAddress.sin6_scope_id = ( ( PSOCKADDR_IN6 )
                  pW3Request->QueryLocalSockAddress() )->sin6_scope_id;
        
        
        if( getnameinfo( ( LPSOCKADDR )&IPv6LocalAddress,
                         sizeof( IPv6LocalAddress ),
                         szNumericLocalAddress,
                         sizeof( szNumericLocalAddress ),
                         NULL,
                         0,
                         NI_NUMERICHOST ) != 0 )
        {
            hr = HRESULT_FROM_WIN32( WSAGetLastError() );
        }
        else
        {
            hr = pstrVal->Copy( szNumericLocalAddress );
        }
    }
    else
    {
        DBG_ASSERT( FALSE );
    }
    
    return hr;
}

HRESULT GetServerVariableHttps(
    W3_CONTEXT *pW3Context,
    STRA *pstrVal)
{
    DBG_ASSERT( pW3Context != NULL );

    if (pW3Context->QueryRequest()->IsSecureRequest())
    {
        return pstrVal->Copy("on", 2);
    }

    return pstrVal->Copy("off", 3);
}

HRESULT
GetServerVariableHttpsKeySize(
    W3_CONTEXT *            pW3Context,
    STRA *                  pstrVal
)
{
    HTTP_SSL_INFO *         pSslInfo;
    CHAR                    achNum[ 64 ];
    
    pSslInfo = pW3Context->QueryRequest()->QuerySslInfo();
    if ( pSslInfo == NULL )
    {
        achNum[ 0 ] = '\0';
    }
    else
    {
        _itoa( pSslInfo->ConnectionKeySize,
               achNum,
               10 );
    }
    
    return pstrVal->Copy( achNum );
}

HRESULT
GetServerVariableClientCertIssuer(
    W3_CONTEXT *            pW3Context,
    STRA *                  pstrVal
)
{
    CERTIFICATE_CONTEXT *       pCertContext;
    
    pCertContext = pW3Context->QueryMainContext()->QueryCertificateContext();
    if ( pCertContext == NULL )
    {
        return pstrVal->Copy( "", 0 ); 
    }
    else
    {
        return pCertContext->GetIssuer( pstrVal );
    }
}

HRESULT
GetServerVariableClientCertSubject(
    W3_CONTEXT *            pW3Context,
    STRA *                  pstrVal
)
{
    CERTIFICATE_CONTEXT *       pCertContext;
    
    pCertContext = pW3Context->QueryMainContext()->QueryCertificateContext();
    if ( pCertContext == NULL )
    {
        return pstrVal->Copy( "", 0 ); 
    }
    else
    {
        return pCertContext->GetSubject( pstrVal );
    }
}

HRESULT
GetServerVariableClientCertCookie(
    W3_CONTEXT *            pW3Context,
    STRA *                  pstrVal
)
{
    CERTIFICATE_CONTEXT *       pCertContext;
    
    pCertContext = pW3Context->QueryMainContext()->QueryCertificateContext();
    if ( pCertContext == NULL )
    {
        return pstrVal->Copy( "", 0 ); 
    }
    else
    {
        return pCertContext->GetCookie( pstrVal );
    }
}

HRESULT
GetServerVariableClientCertSerialNumber(
    W3_CONTEXT *            pW3Context,
    STRA *                  pstrVal
)
{
    CERTIFICATE_CONTEXT *       pCertContext;
    
    pCertContext = pW3Context->QueryMainContext()->QueryCertificateContext();
    if ( pCertContext == NULL )
    {
        return pstrVal->Copy( "", 0 ); 
    }
    else
    {
        return pCertContext->GetSerialNumber( pstrVal );
    }
}

HRESULT
GetServerVariableClientCertFlags(
    W3_CONTEXT *            pW3Context,
    STRA *                  pstrVal
)
{
    CERTIFICATE_CONTEXT *       pCertContext;
    
    pCertContext = pW3Context->QueryMainContext()->QueryCertificateContext();
    if ( pCertContext == NULL )
    {
        return pstrVal->Copy( "" ); 
    }
    else
    {
        // CertFlags - legacy value
        // In IIS3 days client certificates were not verified by IIS
        // so applications needed certificate flags to make 
        // their own decisions regarding trust
        // Now only valid certificate allow access so value of 1 is
        // the only one that is valid for post IIS3 versions of IIS
        //
        return pstrVal->Copy( "1" );
    }
}

HRESULT
GetServerVariableHttpsSecretKeySize(
    W3_CONTEXT *            pW3Context,
    STRA *                  pstrVal
)
{
    HTTP_SSL_INFO *         pSslInfo;
    CHAR                    achNum[ 64 ];

    pSslInfo = pW3Context->QueryRequest()->QuerySslInfo();
    if ( pSslInfo == NULL )
    {
        achNum[ 0 ] = '\0';
    }
    else
    {
        _itoa( pSslInfo->ServerCertKeySize,
              achNum,
              10 );
    }
    
    return pstrVal->Copy( achNum );
}

HRESULT
GetServerVariableHttpsServerIssuer(
    W3_CONTEXT *            pW3Context,
    STRA *                  pstrVal
)
{
    HTTP_SSL_INFO *         pSslInfo;
    LPCSTR                  pszVariable;
    
    pSslInfo = pW3Context->QueryRequest()->QuerySslInfo();
    if ( pSslInfo == NULL )
    {
        pszVariable = "";
    }
    else
    {
        DBG_ASSERT( pSslInfo->pServerCertIssuer != NULL );
        pszVariable = pSslInfo->pServerCertIssuer;
    }
    
    return pstrVal->Copy( pszVariable );
}

HRESULT
GetServerVariableHttpsServerSubject(
    W3_CONTEXT *            pW3Context,
    STRA *                  pstrVal
)
{
    HTTP_SSL_INFO *         pSslInfo;
    LPCSTR                  pszVariable;
    
    pSslInfo = pW3Context->QueryRequest()->QuerySslInfo();
    if ( pSslInfo == NULL )
    {
        pszVariable = "";
    }
    else
    {
        DBG_ASSERT( pSslInfo->pServerCertSubject != NULL );
        pszVariable = pSslInfo->pServerCertSubject;
    }
    
    return pstrVal->Copy( pszVariable );
}

HRESULT
GetServerVariableHttpUrl(
    W3_CONTEXT *            pW3Context,
    STRA *                  pstrVal
)
{
    //
    // HTTP_URL gets the raw url for the request. If a filter has
    // modified the url the request object handles redirecting the
    // RawUrl variable 
    //

    DBG_ASSERT( pW3Context != NULL );
        
    return pW3Context->QueryRequest()->GetRawUrl( pstrVal );
}

HRESULT
GetServerVariableHttpVersion(
    W3_CONTEXT *            pW3Context,
    STRA *                  pstrVal
)
{
    //
    // HTTP_VERSION returns the client version string
    //

    DBG_ASSERT( pW3Context != NULL );

    return pW3Context->QueryRequest()->GetVersionString( pstrVal );
}

HRESULT
GetServerVariableAppPoolId(
    W3_CONTEXT *,
    STRA *                  pstrVal
)
{
    //
    // APP_POOL_ID returns the AppPoolId WAS started us with
    //

    return pstrVal->CopyW( (LPWSTR)UlAtqGetContextProperty(NULL,
                                                           ULATQ_PROPERTY_APP_POOL_ID) );
}

HRESULT
GetServerVariableAppPoolIdW(
    W3_CONTEXT *,
    STRU *                  pstrVal
)
{
    //
    // APP_POOL_ID returns the AppPoolId WAS started us with
    //

    return pstrVal->Copy( (LPWSTR)UlAtqGetContextProperty(NULL,
                                                          ULATQ_PROPERTY_APP_POOL_ID) );
}

HRESULT
GetServerVariableScriptTranslated(
    W3_CONTEXT *            pW3Context,
    STRA *                  pstrVal
)
{
    STACK_STRU( strCanonicalPath, MAX_PATH );
    HRESULT     hr = NOERROR;
    
    DBG_ASSERT( pW3Context != NULL );

    URL_CONTEXT *pUrlContext = pW3Context->QueryUrlContext();
    DBG_ASSERT( pUrlContext != NULL );

    hr = MakePathCanonicalizationProof( pUrlContext->QueryPhysicalPath()->QueryStr(),
                                        &strCanonicalPath );

    if ( FAILED( hr ) )
    {
        return hr;
    }

    return pstrVal->CopyW( strCanonicalPath.QueryStr() );
}

HRESULT
GetServerVariableScriptTranslatedW(
    W3_CONTEXT *            pW3Context,
    STRU *                  pstrVal
)
{
    DBG_ASSERT( pW3Context != NULL );

    URL_CONTEXT *pUrlContext = pW3Context->QueryUrlContext();
    DBG_ASSERT( pUrlContext != NULL );

    return MakePathCanonicalizationProof( pUrlContext->QueryPhysicalPath()->QueryStr(),
                                          pstrVal );
}

HRESULT
GetServerVariableUnencodedUrl(
    W3_CONTEXT *            pW3Context,
    STRA *                  pstrVal
)
{
    DBG_ASSERT( pW3Context != NULL );

    W3_REQUEST *pW3Request = pW3Context->QueryRequest();
    DBG_ASSERT( pW3Request != NULL );

    return pW3Request->GetRawUrl(pstrVal);
}

HRESULT
GetServerVariableSsiExecDisabled(
    W3_CONTEXT *            pW3Context,
    STRA *                  pstrVal
)
{
    W3_METADATA *               pMetaData              = NULL;
    CHAR *                      pszResponse            = NULL;
    
    DBG_ASSERT( pW3Context != NULL );
    DBG_ASSERT( pstrVal != NULL );
    
    pMetaData = pW3Context->QueryUrlContext()->QueryMetaData();
    DBG_ASSERT( pMetaData != NULL );

    pszResponse = ( pMetaData->QuerySSIExecDisabled() )? "1": "0";
    
    return pstrVal->Copy( pszResponse );
}


HRESULT
GetServerVariableOriginalUrlW(
    W3_CONTEXT *            pW3Context,
    STRU *                  pstrVal
)
{
    DBG_ASSERT( pW3Context != NULL );
    DBG_ASSERT( pstrVal != NULL );

    return pW3Context->QueryMainContext()->QueryRequest()->GetOriginalFullUrl(pstrVal);
}

HRESULT
GetServerVariableOriginalUrl(
    W3_CONTEXT *            pW3Context,
    STRA *                  pstrVal
)
{
    STACK_STRU( struVal, 256);
    HRESULT hr;

    if (FAILED(hr = GetServerVariableOriginalUrlW(pW3Context, &struVal)) ||
        FAILED(hr = pstrVal->CopyW(struVal.QueryStr())))
    {
        return hr;
    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\iisplus\ulw3\trace_handler.cxx ===
/*++

   Copyright    (c)    2000    Microsoft Corporation

   Module Name :
     trace_handler.cxx

   Abstract:
     Handle TRACE requests
 
   Author:
     Anil Ruia (AnilR)              15-Mar-2000

   Environment:
     Win32 - User Mode

   Project:
     ULW3.DLL
--*/

#include "precomp.hxx"
#include "trace_handler.h"

CONTEXT_STATUS 
W3_TRACE_HANDLER::DoWork(
    VOID
)
/*++

Routine Description:

    Do the TRACE thing

Return Value:

    CONTEXT_STATUS_PENDING if async pending, else CONTEXT_STATUS_CONTINUE

--*/
{
    W3_CONTEXT *pW3Context = QueryW3Context();
    DBG_ASSERT( pW3Context != NULL );

    HRESULT             hr = S_OK;
    W3_REQUEST *        pRequest;
    W3_RESPONSE *       pResponse;
    STACK_STRA(         strTemp, 256 );
    DWORD               cbAlreadyAvailable;
    PVOID               pvAlreadyAvailable;
    
    pRequest = pW3Context->QueryRequest();
    DBG_ASSERT(pRequest != NULL);

    pResponse = pW3Context->QueryResponse();
    DBG_ASSERT(pResponse != NULL);

    //
    // If entity body with request, BAD request
    //
    
    pW3Context->QueryAlreadyAvailableEntity( &pvAlreadyAvailable,
                                             &cbAlreadyAvailable );
    
    if ( cbAlreadyAvailable ||
         pW3Context->QueryRemainingEntityFromUl() != 0 )
    {
        pResponse->SetStatus( HttpStatusBadRequest );
        goto Finished;
    }
    
    //
    // Build the request line
    //
    
    if ( FAILED( hr = pRequest->GetVerbString(&_strResponse) ) ||
         FAILED( hr = _strResponse.Append(" ") ) ||
         FAILED( hr = pRequest->GetRawUrl(&strTemp) ) ||
         FAILED( hr = _strResponse.Append(strTemp) ) ||
         FAILED( hr = _strResponse.Append(" ") ) ||
         FAILED( hr = pRequest->GetVersionString(&strTemp) ) ||
         FAILED( hr = _strResponse.Append(strTemp) ) ||
         FAILED( hr = _strResponse.Append("\r\n") ) )
    {
        goto Finished;
    }

    //
    // Echo the request headers (and trailing blank line)
    //

    strTemp.Reset();

    if ( FAILED( hr = pRequest->GetAllHeaders( &strTemp, FALSE ) ) ||
         FAILED( hr = _strResponse.Append( strTemp ) ) ||
         FAILED( hr = _strResponse.Append("\r\n") ) )
    {
        goto Finished;
    }

    //
    // Set content type as message/http
    //
 
    hr = pResponse->SetHeader( HttpHeaderContentType, 
                               HEADER("message/http") );
    if ( FAILED( hr ) )
    {
        goto Finished;
    }
    
    hr = pResponse->AddMemoryChunkByReference( _strResponse.QueryStr(),
                                               _strResponse.QueryCCH() );
    if ( FAILED( hr ) )
    {
        goto Finished;
    }

Finished:
    if ( FAILED( hr ) )
    {
        pW3Context->SetErrorStatus( hr );
        pResponse->SetStatus( HttpStatusServerError );
    }
   
    hr = pW3Context->SendResponse( W3_FLAG_ASYNC );
    if ( FAILED( hr ) )
    {
        pW3Context->SetErrorStatus( hr );  
        return CONTEXT_STATUS_CONTINUE;   
    }
    else
    {
        return CONTEXT_STATUS_PENDING;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\iisplus\ulw3\trace_handler.h ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    trace_handler.h

Abstract:

    Handler class for TRACE requests

Author:

    Anil Ruia (AnilR)           15-Mar-2000

Revision History:

--*/

#ifndef _TRACE_HANDLER_H_
#define _TRACE_HANDLER_H_

class W3_TRACE_HANDLER : public W3_HANDLER
{
public:
    W3_TRACE_HANDLER( W3_CONTEXT * pW3Context )
        : W3_HANDLER( pW3Context )
    {
    }

    WCHAR *
    QueryName(
        VOID
    )
    {
        return L"TraceHandler";
    }

    CONTEXT_STATUS
    DoWork(
        VOID
    );

    static
    HRESULT
    Initialize(
        VOID
    )
    {
        return NO_ERROR;
    }

    static
    VOID
    Terminate(
        VOID
    )
    {
    }
    
private:
    STRA   _strResponse;
};

#endif // _TRACE_HANDLER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\iisplus\ulw3\staticfile.cxx ===
/*++

   Copyright    (c)    1999    Microsoft Corporation

   Module Name :
     staticfile.cxx

   Abstract:
     Handle static file request

   Author:
     Bilal Alam (balam)             7-Jan-2000

   Environment:
     Win32 - User Mode

   Project:
     ULW3.DLL
--*/

#include "precomp.hxx"
#include "staticfile.hxx"

ALLOC_CACHE_HANDLER *       W3_STATIC_FILE_HANDLER::sm_pachStaticFileHandlers;

HRESULT
W3_STATIC_FILE_HANDLER::HandleDefaultLoad(
    W3_CONTEXT *            pW3Context,
    BOOL *                  pfHandled,
    BOOL *                  pfAsyncPending
)
/*++

Routine Description:

    Attempts to find a default load file applicable for this request.  If it
    does, it will switch the URL of the request and back track.

Arguments:

    pW3Context - Context
    pfHandled - Set to TRUE if this function has set a response or switched URL
                (in other words, no more processing is required)
    pfAsyncPending - Set to TRUE if async is pending so bail

Return Value:

    HRESULT - If not NO_ERROR, then *pfHandled is irrelevent

--*/
{
    URL_CONTEXT *           pUrlContext;
    W3_METADATA *           pMetaData;
    STACK_STRU(             strDefaultFiles, MAX_PATH );
    HRESULT                 hr = NO_ERROR;
    W3_REQUEST *            pRequest = pW3Context->QueryRequest();
    STRU *                  pstrPhysical;
    STACK_STRU(             strNextFile, MAX_PATH );
    WCHAR *                 pszNextFile;
    WCHAR *                 pszEndFile;
    W3_FILE_INFO *          pOpenFile = NULL;
    BOOL                    fFound = FALSE;
    STACK_STRU(             strNewUrl, MAX_PATH );
    WCHAR *                 pszQuery;
    CACHE_USER              FileUser;

    DBG_ASSERT( pW3Context != NULL );
    DBG_ASSERT( pRequest != NULL );
    DBG_ASSERT( pfHandled != NULL );
    DBG_ASSERT( pfAsyncPending != NULL );

    *pfHandled = FALSE;
    *pfAsyncPending = FALSE;

    //
    // Get the configuration info
    //

    pUrlContext = pW3Context->QueryUrlContext();
    DBG_ASSERT( pUrlContext != NULL );

    pMetaData = pUrlContext->QueryMetaData();
    DBG_ASSERT( pMetaData != NULL );

    pstrPhysical = pUrlContext->QueryPhysicalPath();
    DBG_ASSERT( pstrPhysical != NULL );

    hr = pRequest->GetUrl( &strNewUrl );
    if ( FAILED( hr ) )
    {
        return hr;
    }
    DBG_ASSERT( strNewUrl.QueryStr() != NULL );

    //
    // First ensure the path is / suffixed.  Otherwise, redirect to such
    //
    if (strNewUrl.QueryCCH() && strNewUrl.QueryStr()[strNewUrl.QueryCCH() - 1] != L'/')
    {
        //
        // Before redirecting, first make sure it is a GET or a HEAD
        //
        HTTP_VERB VerbType = pRequest->QueryVerbType();
        if ( VerbType != HttpVerbGET &&
             VerbType != HttpVerbHEAD )
        {
            pW3Context->QueryResponse()->SetStatus( HttpStatusMethodNotAllowed );
            pW3Context->SetErrorStatus( HRESULT_FROM_WIN32(ERROR_INVALID_FUNCTION) );
            hr = pW3Context->SetupAllowHeader();
            if ( FAILED( hr ) )
            {
                return hr;
            }

            return S_OK;
        }

        //
        // Append the suffix '/'
        //
        if (FAILED(hr = strNewUrl.Escape()) ||
            FAILED(hr = strNewUrl.Append(L"/")))
        {
            return hr;
        }

        //
        // Do the HTTP redirect
        //
        if (FAILED(hr = pW3Context->SetupHttpRedirect(strNewUrl,
                                                      TRUE,
                                                      HttpStatusMovedPermanently)))
        {
            return hr;
        }

        //
        // Tell callers we are finished
        //
        *pfHandled = TRUE;
        return S_OK;
    }

    //
    // Look for default load files
    //

    hr = strDefaultFiles.Copy( *pMetaData->QueryDefaultLoadFiles() );
    if ( FAILED( hr ) )
    {
        return hr;
    }

    pszNextFile = strDefaultFiles.QueryStr();
    while ( pszNextFile != NULL &&
            *pszNextFile != L'\0' )
    {
        pszEndFile = wcschr( pszNextFile, L',' );
        if ( pszEndFile != NULL )
        {
            *pszEndFile = L'\0';
        }

        while (iswspace(*pszNextFile))
        {
            pszNextFile++;
        }

        //
        // Append portion to directory to create a filename to check for
        //

        hr = strNextFile.Copy( *pstrPhysical );
        if ( FAILED( hr ) )
        {
            return hr;
        }

        //
        // Remove any query string
        //

        pszQuery = wcschr( pszNextFile, L'?' );
        if ( pszQuery != NULL )
        {
            hr = strNextFile.Append( pszNextFile,
                                     (DWORD)DIFF( pszQuery - pszNextFile ) );
        }
        else
        {
            hr = strNextFile.Append( pszNextFile );
        }
        if ( FAILED( hr ) )
        {
            return hr;
        }

        //
        // Make a FS path
        //

        FlipSlashes( strNextFile.QueryStr() );

        //
        // Open the file
        //

        pW3Context->QueryFileCacheUser( &FileUser );

        DBG_ASSERT( g_pW3Server->QueryFileCache() != NULL );

        hr = g_pW3Server->QueryFileCache()->GetFileInfo(
                                            strNextFile,
                                            pMetaData->QueryDirmonConfig(),
                                            &FileUser,
                                            !( pMetaData->QueryNoCache() ),
                                            &pOpenFile );
        if ( FAILED( hr ) )
        {
            DWORD           dwError = WIN32_FROM_HRESULT( hr );

            DBG_ASSERT( pOpenFile == NULL );

            //
            // If not found, or name invalid, that's ok -> proceed to next file
            //

            if ( dwError != ERROR_FILE_NOT_FOUND &&
                 dwError != ERROR_PATH_NOT_FOUND &&
                 dwError != ERROR_INVALID_NAME )
            {
                return hr;
            }

            hr = NO_ERROR;
        }
        else
        {
            DWORD           dwAttributes;

            //
            // Great, we can open the file.  We only need it for attributes.
            //

            DBG_ASSERT( pOpenFile != NULL );

            dwAttributes = pOpenFile->QueryAttributes();

            pOpenFile->DereferenceCacheEntry();
            pOpenFile = NULL;

            if ( dwAttributes & FILE_ATTRIBUTE_DIRECTORY )
            {
                //
                // If we see a directory, we ignore it and continue to
                // the next one
                //
            }
            else
            {
                fFound = TRUE;
                break;
            }
        }

        //
        // Goto next file
        //

        pszNextFile = pszEndFile ? pszEndFile + 1 : NULL;
    }

    //
    // Change the url and retrack
    //

    if ( fFound )
    {
        //
        // Ok.  We can change the URL and retrack.  Do so.
        //

        hr = strNewUrl.Append( pszNextFile );
        if ( FAILED( hr ) )
        {
            return hr;
        }

        //
        // Change the URL
        //

        hr = pRequest->SetUrl( strNewUrl, FALSE );
        if ( FAILED( hr ) )
        {
            return hr;
        }

        hr = pW3Context->ExecuteChildRequest( pRequest,
                                              FALSE,
                                              W3_FLAG_ASYNC );
        if ( FAILED( hr ) )
        {
            return hr;
        }
        else
        {
            *pfHandled = TRUE;
            *pfAsyncPending = TRUE;
            return NO_ERROR;
        }
    }
    else
    {
        //
        // If not found, the caller will continue since *pfHandled == FALSE
        // if we're here
        //
    }

    return NO_ERROR;
}

HRESULT
W3_STATIC_FILE_HANDLER::DirectoryDoWork(
    W3_CONTEXT *            pW3Context,
    BOOL *                  pfAsyncPending
)
/*++

Routine Description:

    Handle directories.  This means default loads and directory listings

Arguments:

    pW3Context - Context
    pfAsyncPending - Set to TRUE if async pending

Return Value:

    HRESULT

--*/
{
    DWORD               dwDirBrowseFlags;
    URL_CONTEXT *       pUrlContext;
    HRESULT             hr;
    BOOL                fHandled = FALSE;
    CACHE_USER          fileUser;
    BOOL                fImpersonated = FALSE;

    DBG_ASSERT( pW3Context != NULL );
    DBG_ASSERT( pfAsyncPending != NULL );

    *pfAsyncPending = FALSE;

    W3_REQUEST *pRequest = pW3Context->QueryRequest();
    DBG_ASSERT(pRequest != NULL);

    pUrlContext = pW3Context->QueryUrlContext();
    DBG_ASSERT( pUrlContext != NULL );

    //
    // Get the directory browsing flags for this directory
    //
    dwDirBrowseFlags = pUrlContext->QueryMetaData()->QueryDirBrowseFlags();

    //
    // First check for a default load (by first checking whether we are
    // allowed to serve default load)
    //
    if ( dwDirBrowseFlags & MD_DIRBROW_LOADDEFAULT )
    {
        //
        // OK.  Look for a default load
        //

        hr = HandleDefaultLoad( pW3Context,
                                &fHandled,
                                pfAsyncPending );

        if ( FAILED( hr ) || fHandled || *pfAsyncPending )
        {
            return hr;
        }
    }

    //
    // If doing directory listing, first make sure it is a GET or a HEAD
    //
    HTTP_VERB VerbType = pRequest->QueryVerbType();
    if ( VerbType != HttpVerbGET &&
         VerbType != HttpVerbHEAD )
    {
        pW3Context->QueryResponse()->SetStatus( HttpStatusMethodNotAllowed );
        pW3Context->SetErrorStatus( HRESULT_FROM_WIN32(ERROR_INVALID_FUNCTION) );
        hr = pW3Context->SetupAllowHeader();
        if ( FAILED( hr ) )
        {
            return hr;
        }

        return S_OK;
    }

    //
    // OK.  Check for whether directory listings are enabled
    //
    if ( dwDirBrowseFlags & MD_DIRBROW_ENABLED )
    {
        //
        // We may need to impersonate some other user to open the file
        //

        pW3Context->QueryFileCacheUser( &fileUser );

        if ( fileUser._hToken != NULL )
        {
            if ( !SetThreadToken( NULL, fileUser._hToken ) )
            {
                return HRESULT_FROM_WIN32( GetLastError() );
            }
            fImpersonated = TRUE;
        }

        hr = HandleDirectoryListing( pW3Context,
                                     &fHandled );

        if( fImpersonated )
        {
            RevertToSelf();
            fImpersonated = FALSE;
        }

        if ( FAILED( hr ) || fHandled )
        {
            return hr;
        }
    }

    //
    // If we are here, then neither browsing nor default loads are enabled.
    // There is nothing we can do but return a 403.
    //

    pW3Context->QueryResponse()->SetStatus( HttpStatusForbidden,
                                            Http403DirBrowsingDenied );
    pW3Context->SetErrorStatus( HRESULT_FROM_WIN32(ERROR_ACCESS_DENIED) );
    return NO_ERROR;
}


HRESULT
GetTypeAndSubType(
    LPCSTR                  pszType,
    STRA *                  pstrMainType,
    STRA *                  pstrSubType,
    BOOL *                  pfTypeOk
)
/*++

Routine Description:

    Given a mimetype of "foobar/barfoo", return "foobar" as the main type
    and "barfoo" as the subtype.

Arguments:

    pszType - Whole mime type
    pstrMainType - Filled with main type
    pstrSubType - Filled with sub type
    pfTypeOk - Is this mime type ok?

Return Value:

    HRESULT

--*/
{
    HRESULT hr;

    LPCSTR pszSlash = strchr( pszType, '/' );
    if (pszSlash == NULL)
    {
        *pfTypeOk = FALSE;
        return S_OK;
    }

    hr = pstrMainType->Copy( pszType,
                             (DWORD)DIFF( pszSlash - pszType ) );
    hr = pstrSubType->Copy( pszSlash + 1 );

    *pfTypeOk = TRUE;
    return hr;
}


HRESULT
IsAcceptable(
    LPCSTR              pszContentType,
    LPCSTR              pszAcceptHeader,
    USHORT              cchAcceptHeader,
    BOOL *              pfIsAcceptAble
)
/*++

Routine Description:

    Return whether given content type is acceptable for the given
    Accept: header

Arguments:

    pszContentType - Content type
    pszAcceptHeader - Accept header to check
    pfIsAcceptAble - Filled with bool indicating whether type is acceptable

Return Value:

    HRESULT

--*/
{
    HRESULT         hr;
    BOOL            fTypeOk;

    //
    // Quickly handle the */* case
    //

    if (cchAcceptHeader >= 3 &&
        pszAcceptHeader[cchAcceptHeader - 1] == '*' &&
        pszAcceptHeader[cchAcceptHeader - 2] == '/' &&
        pszAcceptHeader[cchAcceptHeader - 3] == '*' )
    {
        *pfIsAcceptAble = TRUE;
        return S_OK;
    }

    if ( strstr(pszAcceptHeader, "*/*") != NULL )
    {
        *pfIsAcceptAble = TRUE;
        return S_OK;
    }

    //
    // Break the Content-Type into the main- and sub-content-type
    //
    STACK_STRA ( strMainContentType, 32);
    STACK_STRA ( strSubContentType, 32);
    if ( FAILED( hr = GetTypeAndSubType( pszContentType,
                                         &strMainContentType,
                                         &strSubContentType,
                                         &fTypeOk ) ) )
    {
        return hr;
    }
    if ( !fTypeOk )
    {
        *pfIsAcceptAble = FALSE;
        return S_OK;
    }

    //
    // Skip over any spaces
    //
    while ( *pszAcceptHeader == ' ' )
    {
        pszAcceptHeader++;
    }

    STACK_STRA (strAcceptType, 64);
    STACK_STRA (strMainAcceptType, 32);
    STACK_STRA (strSubAcceptType, 32);

    for (;;)
    {
        //
        // Multiple Acceptable Types are ',' separated, get the next one
        //
        CHAR * pszComma = strchr( pszAcceptHeader, L',' );
        if ( pszComma == NULL )
        {
            if ( FAILED( hr = strAcceptType.Copy( pszAcceptHeader ) ) )
            {
                return hr;
            }
        }
        else
        {
            if ( FAILED( hr = strAcceptType.Copy( pszAcceptHeader,
                                  (DWORD)DIFF( pszComma - pszAcceptHeader ) ) ) )
            {
                return hr;
            }
        }

        //
        // Trim out any quality specifier specified after a ';'
        //
        CHAR * pszQuality = strchr( strAcceptType.QueryStr(), ';' );
        if ( pszQuality != NULL )
        {
            strAcceptType.SetLen((DWORD)DIFF(pszQuality - strAcceptType.QueryStr()));
        }

        //
        // Trim any spaces at the end
        //
        INT iSpace = strAcceptType.QueryCCH() - 1;
        while ( iSpace >= 0 &&
                strAcceptType.QueryStr()[iSpace] == ' ' )
        {
            iSpace--;
        }
        strAcceptType.SetLen( iSpace + 1 );

        //
        // Get the main- and sub-Accept types for this type
        //
        if ( FAILED(hr = GetTypeAndSubType( strAcceptType.QueryStr(),
                                            &strMainAcceptType,
                                            &strSubAcceptType,
                                            &fTypeOk ) ) )
        {
            return hr;
        }

        if ( fTypeOk )
        {
            //
            // Now actually find out if this type is acceptable
            //
            if ( !_stricmp( strMainAcceptType.QueryStr(),
                            strMainContentType.QueryStr() ) )
            {
                if ( !strcmp( strSubAcceptType.QueryStr(), "*" ) ||
                     !_stricmp( strSubAcceptType.QueryStr(),
                                strSubContentType.QueryStr() ) )
                {
                    *pfIsAcceptAble = TRUE;
                    return S_OK;
                }
            }
        }

        //
        // Set AcceptHeader to the start of the next type
        //
        if (pszComma == NULL)
        {
            *pfIsAcceptAble = FALSE;
            return S_OK;
        }
        pszAcceptHeader = pszComma + 1;
        while ( *pszAcceptHeader == ' ' )
        {
            pszAcceptHeader++;
        }
    }
}


HRESULT
W3_STATIC_FILE_HANDLER::FileDoWork(
    W3_CONTEXT *                pW3Context,
    W3_FILE_INFO *              pOpenFile
)
/*++

Routine Description:

    Handle files (non-directories).

Arguments:

    pW3Context - Context
    pOpenFile - W3_FILE_INFO with the file to send

Return Value:

    HRESULT

--*/
{
    ULARGE_INTEGER      liFileSize;
    W3_RESPONSE *       pResponse;
    W3_REQUEST  *       pRequest;
    W3_URL_INFO *       pUrlInfo;
    W3_METADATA *       pMetaData;
    HRESULT             hr;
    STACK_STRU        ( strUrl, MAX_PATH );
    LPCSTR              pszRange;
    BOOL                fHandled = FALSE;
    CACHE_USER          fileUser;

    DBG_ASSERT( pW3Context != NULL );
    DBG_ASSERT( pOpenFile != NULL );
    pResponse = pW3Context->QueryResponse();
    DBG_ASSERT( pResponse != NULL );
    pRequest = pW3Context->QueryRequest();
    DBG_ASSERT( pRequest != NULL );
    pUrlInfo = pW3Context->QueryUrlContext()->QueryUrlInfo();
    DBG_ASSERT( pUrlInfo != NULL );
    pMetaData = pW3Context->QueryUrlContext()->QueryMetaData();
    DBG_ASSERT( pMetaData != NULL );


    //
    // First make sure it a GET or a HEAD
    //
    HTTP_VERB VerbType = pRequest->QueryVerbType();
    if ( VerbType != HttpVerbGET &&
         VerbType != HttpVerbHEAD )
    {
        pW3Context->QueryResponse()->SetStatus( HttpStatusMethodNotAllowed );
        pW3Context->SetErrorStatus( HRESULT_FROM_WIN32(ERROR_INVALID_FUNCTION) );
        hr = pW3Context->SetupAllowHeader();
        if ( FAILED( hr ) )
        {
            goto Failure;
        }

        return S_OK;
    }

    //
    // Any Expect headers are not acceptable for static file requests
    //
    LPCSTR pszExpect = pRequest->GetHeader( HttpHeaderExpect );
    if (pszExpect != NULL)
    {
        pW3Context->QueryResponse()->SetStatus( HttpStatusExpectationFailed );
        return S_OK;
    }

    //
    // If this an image-map file, do the image-map stuff
    //
    if (pUrlInfo->QueryGateway() == GATEWAY_MAP)
    {
        fHandled = FALSE;
        hr = MapFileDoWork(pW3Context, pOpenFile, &fHandled);
        if (FAILED(hr))
        {
            goto Failure;
        }

        if (fHandled)
        {
            return hr;
        }

        //
        // fHandled was false, so this is a .map file which wasn't really
        // an image-map file, handle it as any other static file
        //
    }

    //
    // Add Cache-Control and Expires header if so configured
    //
    STRA *pstrCacheControlHeader = pMetaData->QueryCacheControlHeader();
    if (!pstrCacheControlHeader->IsEmpty())
    {
        if (FAILED(hr = pResponse->SetHeaderByReference(
                            HttpHeaderCacheControl,
                            pstrCacheControlHeader->QueryStr(),
                            (USHORT)pstrCacheControlHeader->QueryCCH())))
        {
            goto Failure;
        }
    }

    if (pMetaData->QueryExpireMode() == EXPIRE_MODE_STATIC)
    {
        STRA *pstrExpireHeader = pMetaData->QueryExpireHeader();

        if (FAILED(hr = pResponse->SetHeaderByReference(
                            HttpHeaderExpires,
                            pstrExpireHeader->QueryStr(),
                            (USHORT)pstrExpireHeader->QueryCCH())))
        {
            goto Failure;
        }
    }

    //
    // Do compression, if so configured
    //
    if (pMetaData->QueryDoStaticCompression() &&
        !pW3Context->QueryDoneWithCompression())
    {
        BOOL fDoCache = FALSE;

        if (FAILED(hr = HTTP_COMPRESSION::DoStaticFileCompression(
                            pW3Context, &pOpenFile, &fDoCache)))
        {
            goto Failure;
        }
        m_pOpenFile = pOpenFile;

        if (!fDoCache)
        {
            //
            // If this file is compressible but we didn't compress it,
            // don't let http.sys store the uncompressed version in its
            // cache
            //

            pW3Context->DisableUlCache();
        }
    }
    
    //
    // If we had to use a default mimemapping, then don't serve out the file
    //
    
    if ( pUrlInfo->QueryDefaultMimeMap() )
    {
        pW3Context->SetErrorStatus( HRESULT_FROM_WIN32( ERROR_NOT_SUPPORTED ) );
        pResponse->SetStatus( HttpStatusNotFound, Http404DeniedByMimeMap );
        return NO_ERROR;
    }

    //
    // Check if the Content-Type is acceptable to the client
    //

    STRA *pstrContentType = pUrlInfo->QueryContentType();
    USHORT cchAccept;
    LPCSTR pszAccept      = pRequest->GetHeader( HttpHeaderAccept, &cchAccept );
    if ( pszAccept != NULL && *pszAccept != L'\0' )
    {
        BOOL fIsAcceptAble;

        if ( FAILED( hr = IsAcceptable( pstrContentType->QueryStr(),
                                        pszAccept,
                                        cchAccept,
                                        &fIsAcceptAble ) ) )
        {
            goto Failure;
        }

        if ( !fIsAcceptAble )
        {
            pResponse->ClearHeaders();
            pResponse->SetStatus( HttpStatusNotAcceptable );
            return S_OK;
        }
    }

    //
    // Setup the response headers.  First ETag
    //

    hr = pResponse->SetHeaderByReference( HttpHeaderEtag,
                                          pOpenFile->QueryETag(),
                                          pOpenFile->QueryETagSize() );
    if ( FAILED( hr ) )
    {
        goto Failure;
    }

    //
    // Next is Last-Modified
    //

    hr = pResponse->SetHeaderByReference( HttpHeaderLastModified,
                                          pOpenFile->QueryLastModifiedString(),
                                          GMT_STRING_SIZE - 1 );
    if ( FAILED( hr ) )
    {
        goto Failure;
    }

    //
    // Next is Content-Location.  We only need to send this header if
    // we have internally changed the URL of the request.  In other words,
    // if this is a child execute
    //

    if ( pW3Context->QuerySendLocation() )
    {
        STACK_STRA (strContentLocation, MAX_PATH);
        STACK_STRA (strRawUrl, MAX_PATH);

        if (FAILED(hr = pRequest->GetRawUrl(&strRawUrl)) ||
            FAILED(hr = pRequest->BuildFullUrl(strRawUrl,
                                               &strContentLocation,
                                               FALSE)) ||
            FAILED(hr = pResponse->SetHeader(HttpHeaderContentLocation,
                                             strContentLocation.QueryStr(),
                                             (USHORT)strContentLocation.QueryCCH())))
        {
            goto Failure;
        }
    }

    //
    // Next is Accept-Ranges
    //
    if ( FAILED( hr = pResponse->SetHeaderByReference( HttpHeaderAcceptRanges,
                                                       "bytes", 5 ) ) )
    {
        goto Failure;
    }

    //
    // Handle the If-* (except If-Range) headers if present
    //
    fHandled = FALSE;
    if ( FAILED( hr = CacheValidationDoWork( pW3Context,
                                             pOpenFile,
                                             &fHandled ) ) )
    {
        goto Failure;
    }

    if ( fHandled )
    {
        return hr;
    }

    //
    // Now handle If-Range and Range headers
    //
    pszRange = pRequest->GetHeader( HttpHeaderRange );
    if ( ( pszRange != NULL ) &&
         ( !_strnicmp ( pszRange, "bytes", 5 ) ) )
    {
        //
        // Handle range request
        //
        fHandled = FALSE;
        if ( FAILED( hr = RangeDoWork( pW3Context, pOpenFile, &fHandled ) ) )
        {
            goto Failure;
        }

        if ( fHandled )
        {
            return hr;
        }
    }

    //
    // If we fell thru, then we are sending out the entire file
    //

    //
    // Setup Content-Type
    //
    if ( FAILED( hr = pResponse->SetHeaderByReference(
                          HttpHeaderContentType,
                          pstrContentType->QueryStr(),
                          (USHORT)pstrContentType->QueryCCH() ) ) )
    {
        goto Failure;
    }

    //
    // Setup the response chunks
    //
    pOpenFile->QuerySize( &liFileSize );

    if (liFileSize.QuadPart > 0)
    {
        if ( pOpenFile->QueryFileBuffer() != NULL &&
             liFileSize.HighPart == 0 )
        {
            hr = pResponse->AddMemoryChunkByReference(
                                pOpenFile->QueryFileBuffer(),
                                liFileSize.LowPart );
        }
        else
        {
            hr = pResponse->AddFileHandleChunk( pOpenFile->QueryFileHandle(),
                                                0,
                                                liFileSize.QuadPart );
        }

        if ( FAILED( hr ) )
        {
            goto Failure;
        }
    }

    // perf ctr
    pW3Context->QuerySite()->IncFilesSent();

    // Setup the document footer
    if (pMetaData->QueryIsFooterEnabled())
    {
        if (!pMetaData->QueryFooterString()->IsEmpty() )
        {
            STRA *pFooterString = pMetaData->QueryFooterString();
            if (pFooterString->QueryCCH())
            {
                if (FAILED(hr = pResponse->AddMemoryChunkByReference(
                                               pFooterString->QueryStr(),
                                               pFooterString->QueryCCH())))
                {
                    goto Failure;
                }
            }
        }
        else if (!pMetaData->QueryFooterDocument()->IsEmpty() )
        {
            //
            // When a footer document changes, we don't know which URL to flush,
            // so if footer is enabled, don't allow UL to cache this response
            //
            pW3Context->DisableUlCache();

            pW3Context->QueryFileCacheUser( &fileUser );

            DBG_ASSERT( m_pFooterDocument == NULL );

            DBG_ASSERT( g_pW3Server->QueryFileCache() );

            hr = g_pW3Server->QueryFileCache()->GetFileInfo(
                                        *(pMetaData->QueryFooterDocument()),
                                        NULL,
                                        &fileUser,
                                        TRUE,
                                        &m_pFooterDocument );
            if ( SUCCEEDED( hr ) )
            {
                DBG_ASSERT( m_pFooterDocument != NULL );

                m_pFooterDocument->QuerySize( &liFileSize );

                if (liFileSize.QuadPart > 0)
                {
                    if ( m_pFooterDocument->QueryFileBuffer() != NULL &&
                         liFileSize.HighPart == 0 )
                    {
                        hr = pResponse->AddMemoryChunkByReference(
                                        m_pFooterDocument->QueryFileBuffer(),
                                        liFileSize.LowPart );
                    }
                    else
                    {
                        hr = pResponse->AddFileHandleChunk(
                                        m_pFooterDocument->QueryFileHandle(),
                                        0,
                                        liFileSize.QuadPart );
                    }

                    if ( FAILED( hr ) )
                    {
                        goto Failure;
                    }
                }
            }
            else
            {
                //
                // Could not open the footer document.  Sub in a error string
                //

                CHAR achErrorString[ 512 ];
                DWORD cbErrorString = sizeof( achErrorString );

                hr = g_pW3Server->LoadString( IDS_ERROR_FOOTER,
                                              achErrorString,
                                              &cbErrorString );
                if ( FAILED( hr ) )
                {
                    goto Failure;
                }

                hr = m_strFooterString.Copy( achErrorString, cbErrorString );
                if ( FAILED( hr ) )
                {
                    goto Failure;
                }

                hr = pResponse->AddMemoryChunkByReference(
                                        m_strFooterString.QueryStr(),
                                        m_strFooterString.QueryCCH() );
                if ( FAILED( hr ) )
                {
                    goto Failure;
                }
            }
        }
    }

    return S_OK;

Failure:
    //
    // It is our responsibility to ensure that there is no incomplete response
    //

    pResponse->Clear();
    return hr;
}

CONTEXT_STATUS
W3_STATIC_FILE_HANDLER::DoWork(
    VOID
)
/*++

Routine Description:

    Execute the static file handler

Return Value:

    CONTEXT_STATUS_PENDING or CONTEXT_STATUS_CONTINUE

--*/
{
    W3_CONTEXT *pW3Context = QueryW3Context();
    DBG_ASSERT( pW3Context != NULL );

    HRESULT             hr = NO_ERROR;
    W3_RESPONSE *       pResponse = pW3Context->QueryResponse();
    W3_REQUEST *        pRequest = pW3Context->QueryRequest();
    W3_METADATA *       pMetaData;
    URL_CONTEXT *       pUrlContext;
    W3_URL_INFO *       pUrlInfo;
    W3_FILE_INFO *      pOpenFile = NULL;
    DWORD               dwFilePerms;
    CACHE_USER          fileUser;
    BOOL                fHandledSync;
    BOOL                fAllowNoBuffering = TRUE;

    //
    // Get the metadata, in particular the cached W3_URL_INFO off which we
    // we attempt to open the file
    //

    pUrlContext = pW3Context->QueryUrlContext();
    DBG_ASSERT( pUrlContext != NULL );

    pUrlInfo = pUrlContext->QueryUrlInfo();
    DBG_ASSERT( pUrlInfo != NULL );

    pMetaData = pUrlContext->QueryMetaData();
    DBG_ASSERT( pMetaData != NULL );

    if ( ETW_IS_TRACE_ON(ETW_LEVEL_CP) )
    {
        HTTP_REQUEST_ID RequestId = pRequest->QueryRequestId();

        g_pEtwTracer->EtwTraceEvent( &IISEventGuid,
                                     ETW_TYPE_IIS_STATIC_FILE,
                                     &RequestId,
                                     sizeof(HTTP_REQUEST_ID),
                                     pUrlContext->QueryPhysicalPath()->QueryStr(),
                                     pUrlContext->QueryPhysicalPath()->QueryCB(),
                                     NULL,
                                     0 );
    }

    //
    // Check web permissions.
    // Will fail, if no VROOT_MASK_READ, or if we forbid remote access and
    // the request is remote
    //

    dwFilePerms = pMetaData->QueryAccessPerms();

    if ( !IS_ACCESS_ALLOWED(pRequest, dwFilePerms, READ) )
    {
        pResponse->SetStatus( HttpStatusForbidden,
                              Http403ReadAccessDenied );
        pW3Context->SetErrorStatus( HRESULT_FROM_WIN32(ERROR_ACCESS_DENIED) );
        goto Failure;
    }

    //
    // Figure out if it is ok to open the file with buffering off, i.e.
    // are we going to just hand over the handle to http.sys or read it
    // ourselves
    //
    if ( !pW3Context->QueryDoneWithCompression() &&
         (pMetaData->QueryDoDynamicCompression() ||
          pMetaData->QueryDoStaticCompression()) )
    {
        fAllowNoBuffering = FALSE;
    }
    if ( pW3Context->IsNotificationNeeded( SF_NOTIFY_SEND_RAW_DATA ) )
    {
        fAllowNoBuffering = FALSE;
    }
    if ( pUrlInfo->QueryGateway() == GATEWAY_MAP )
    {
        fAllowNoBuffering = FALSE;
    }

    //
    // Now try to open the file
    //

    pW3Context->QueryFileCacheUser( &fileUser );

    m_AsyncContext.pfnCallback = FileOpenCallback;

    hr = pUrlContext->OpenFile( &fileUser,
                                &pOpenFile,
                                &m_AsyncContext,
                                &fHandledSync,
                                fAllowNoBuffering );

    if (FAILED(hr) || fHandledSync)
    {
        return RealDoWork(pOpenFile, hr);
    }

    return CONTEXT_STATUS_PENDING;

Failure:

    hr = pW3Context->SendResponse( W3_FLAG_ASYNC );
    if ( FAILED( hr ) )
    {
        pW3Context->SetErrorStatus( hr );
        pResponse->SetStatus( HttpStatusServerError );
        return CONTEXT_STATUS_CONTINUE;
    }

    return CONTEXT_STATUS_PENDING;
}

// static
VOID
W3_STATIC_FILE_HANDLER::FileOpenCallback(PVOID   pContext,
                                         HRESULT hr)
{
    W3_STATIC_FILE_HANDLER *pHandler = CONTAINING_RECORD(pContext,
                                                W3_STATIC_FILE_HANDLER,
                                                m_AsyncContext);

    W3_FILE_INFO *pFileInfo = pHandler->m_AsyncContext.pFileInfo;
    pHandler->m_AsyncContext.pFileInfo = NULL;

    if (pHandler->RealDoWork(pFileInfo, hr) == CONTEXT_STATUS_CONTINUE)
    {
        POST_MAIN_COMPLETION( pHandler->QueryW3Context()->QueryMainContext() );
    }
}

CONTEXT_STATUS
W3_STATIC_FILE_HANDLER::RealDoWork(
    W3_FILE_INFO *pOpenFile,
    HRESULT hr
)
/*++

Routine Description:

    Execute the static file handler

Return Value:

    CONTEXT_STATUS_PENDING or CONTEXT_STATUS_CONTINUE

--*/
{
    W3_CONTEXT *pW3Context = QueryW3Context();
    DBG_ASSERT( pW3Context != NULL );

    W3_RESPONSE *       pResponse = pW3Context->QueryResponse();
    W3_METADATA *       pMetaData;
    URL_CONTEXT *       pUrlContext;
    BOOL                fAsyncPending = FALSE;

    //
    // Get the metadata, in particular the cached W3_URL_INFO off which we
    // we attempt to open the file
    //

    pUrlContext = pW3Context->QueryUrlContext();
    DBG_ASSERT( pUrlContext != NULL );

    pMetaData = pUrlContext->QueryMetaData();
    DBG_ASSERT( pMetaData != NULL );

    if (FAILED(hr))
    {
        DWORD           dwError;

        IF_DEBUG( STATICFILE )
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "Error opening file %ws.  hr = %x\n",
                        pUrlContext->QueryPhysicalPath()->QueryStr(),
                        hr ));
        }

        pW3Context->SetErrorStatus( hr );
        dwError = WIN32_FROM_HRESULT( hr );
        switch( dwError )
        {
        case ERROR_FILE_NOT_FOUND:
        case ERROR_PATH_NOT_FOUND:
        case ERROR_INVALID_NAME:
            hr = NO_ERROR;
            pResponse->SetStatus( HttpStatusNotFound );
            break;

        case ERROR_LOGON_FAILURE:
        case ERROR_ACCOUNT_DISABLED:
        case ERROR_ACCESS_DENIED:
            hr = NO_ERROR;
            pResponse->SetStatus( HttpStatusUnauthorized,
                                  Http401Resource );
            break;

        case ERROR_INSUFFICIENT_BUFFER:
            hr = NO_ERROR;
            pResponse->SetStatus( HttpStatusUrlTooLong );
            break;
        }

        goto Failure;
    }

    DBG_ASSERT( pOpenFile != NULL );

    //
    // Is the file hidden?  If so, don't serve it out for legacy reasons
    //

    if ( pOpenFile->QueryAttributes() & FILE_ATTRIBUTE_HIDDEN )
    {
        pOpenFile->DereferenceCacheEntry();
        pResponse->SetStatus( HttpStatusNotFound );
        goto Failure;
    }

    //
    // Is this a file or directory?
    //

    if ( pOpenFile->QueryAttributes() & FILE_ATTRIBUTE_DIRECTORY )
    {
        //
        // At this point, we will do one of the following:
        // a) Send a directory listing
        // b) Send a default load file
        // c) Send a 302 (to redirect to a slash suffixed URL)
        // d) Send a 403 (forbidden)
        //

        pOpenFile->DereferenceCacheEntry();
        pOpenFile = NULL;

        hr = DirectoryDoWork( pW3Context,
                              &fAsyncPending );
        if ( fAsyncPending )
        {
            return CONTEXT_STATUS_PENDING;
        }

        //
        // If access denied, then send the response now
        //

        if ( WIN32_FROM_HRESULT( hr ) == ERROR_ACCESS_DENIED )
        {
            pW3Context->SetErrorStatus( hr );
            pW3Context->QueryResponse()->SetStatus( HttpStatusUnauthorized,
                                                    Http401Resource );

            hr = NO_ERROR;
        }
    }
    else
    {
        //
        // This is just a regular file.  Serve it out
        //

        //
        // Save away the file now.  We will clean it up at the end of the
        // request when this current context is cleaned up
        //

        m_pOpenFile = pOpenFile;

        hr = FileDoWork( pW3Context,
                         pOpenFile );
    }

    //
    // If there was an error here, then generate a 500.  If successful, it
    // is assumed that the response status is already set
    //

Failure:

    if ( FAILED( hr ) )
    {
        pResponse->Clear();
        pW3Context->SetErrorStatus( hr );
        pResponse->SetStatus( HttpStatusServerError );
    }

    hr = pW3Context->SendResponse( W3_FLAG_ASYNC );
    if ( FAILED( hr ) )
    {
        pW3Context->SetErrorStatus( hr );
        pResponse->SetStatus( HttpStatusServerError );
        return CONTEXT_STATUS_CONTINUE;
    }

    return CONTEXT_STATUS_PENDING;
}

HRESULT
W3_STATIC_FILE_HANDLER::SetupUlCachedResponse(
    W3_CONTEXT *                pW3Context,
    HTTP_CACHE_POLICY          *pCachePolicy
)
/*++

Routine Description:

    Setup a response to be cached by UL.  In this case we will muck with
    the cached file object to
    a) Remove its TTL
    b) Associate the current request's URL with the file object so that when
       the file object goes away, we will be called with enough info to
       flush the appropriate UL cache entry

Arguments:

    pW3Context - Context
    pCachePolicy - Cache-policy to fill in if caching desired

Return Value:

    HRESULT

--*/
{
    STACK_STRU(             strFlushUrl, MAX_PATH );
    STACK_STRU(             strQueryString, MAX_PATH );
    HRESULT                 hr;

    if ( pW3Context == NULL )
    {
        DBG_ASSERT( FALSE );
        hr = HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
        goto Exit;
    }

    if ( m_pOpenFile == NULL )
    {
        hr = HRESULT_FROM_WIN32( ERROR_FILE_NOT_FOUND );
        goto Exit;
    }

    //
    // If the file wasn't cached, then don't use UL cache
    //

    if ( m_pOpenFile->QueryUlCacheAllowed() == FALSE )
    {
        hr = HRESULT_FROM_WIN32( ERROR_NOT_SUPPORTED );
        goto Exit;
    }
    
    //
    // If we are not doing dirmon for UNC, we cannot let UL cache UNC
    // responses
    //
    if ( !g_pW3Server->QueryFileCache()->QueryDoDirmonForUnc() &&
         ISUNC( m_pOpenFile->QueryPhysicalPath() ))
    {
        hr = HRESULT_FROM_WIN32( ERROR_NOT_SUPPORTED );
        goto Exit;
    }

    //
    // If this file was not accessed anonymously, then we need to do access
    // check anonymously before putting into cache
    //

    if ( pW3Context->QueryUserContext()->QueryAuthType() != MD_AUTH_ANONYMOUS )
    {
        hr = HRESULT_FROM_WIN32( ERROR_NOT_SUPPORTED );
        goto Exit;
    }

    //
    // If there is a query string in the request, don't cache the file
    // lest we have multiple identical entries in the response cache
    //
 
    hr = pW3Context->QueryRequest()->GetQueryString( &strQueryString );
    if ( FAILED( hr ) )
    {
        goto Exit;
    }
    
    if ( !strQueryString.IsEmpty() )
    {
        hr = HRESULT_FROM_WIN32( ERROR_NOT_SUPPORTED );
        goto Exit;
    }

    //
    // Get the exact URL used to flush UL cache
    //

    hr = pW3Context->QueryMainContext()->QueryRequest()->GetOriginalFullUrl(
                                                            &strFlushUrl );
    if ( FAILED( hr ) )
    {
        goto Exit;
    }

    //
    // Setup UL cache response token
    //

    DBG_ASSERT( g_pW3Server->QueryUlCache() != NULL );

    hr = g_pW3Server->QueryUlCache()->SetupUlCachedResponse(
                                        pW3Context,
                                        strFlushUrl,
                                        TRUE,
                                        pW3Context->QueryUrlContext()->QueryPhysicalPath());
    if ( SUCCEEDED( hr ) )
    {
        pCachePolicy->Policy = HttpCachePolicyUserInvalidates;
    }

Exit:

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\iisplus\ulw3\requestheaderhash.cxx ===
/*++

   Copyright    (c)    2000   Microsoft Corporation

   Module Name :
     headerhash.cxx

   Abstract:
     Header hash goo
 
   Author:
     Bilal Alam (balam)             20-Feb-2000

   Environment:
     Win32 - User Mode

   Project:
     ULW3.DLL
--*/

#include "precomp.hxx"

REQUEST_HEADER_HASH *REQUEST_HEADER_HASH::sm_pRequestHash;

HEADER_RECORD REQUEST_HEADER_HASH::sm_rgHeaders[] = 
{
    //
    // The only consumer of this data is W3_REQUEST::GetHeader
    // GetServerVariable is handled by SERVER_VARIABLE_HASH, so we do
    // not need to store the HTTP_'ed and capitalized names here
    //

    { HttpHeaderCacheControl       , HEADER("Cache-Control") },
    { HttpHeaderConnection         , HEADER("Connection") },
    { HttpHeaderDate               , HEADER("Date") },
    { HttpHeaderKeepAlive          , HEADER("Keep-Alive") },
    { HttpHeaderPragma             , HEADER("Pragma") },
    { HttpHeaderTrailer            , HEADER("Trailer") },
    { HttpHeaderTransferEncoding   , HEADER("Transfer-Encoding") },
    { HttpHeaderUpgrade            , HEADER("Upgrade") },
    { HttpHeaderVia                , HEADER("Via") },
    { HttpHeaderWarning            , HEADER("Warning") },
    { HttpHeaderAllow              , HEADER("Allow") },
    { HttpHeaderContentLength      , HEADER("Content-Length") },
    { HttpHeaderContentType        , HEADER("Content-Type") },
    { HttpHeaderContentEncoding    , HEADER("Content-Encoding") },
    { HttpHeaderContentLanguage    , HEADER("Content-Language") },
    { HttpHeaderContentLocation    , HEADER("Content-Location") },
    { HttpHeaderContentMd5         , HEADER("Content-MD5") },
    { HttpHeaderContentRange       , HEADER("Content-Range") },
    { HttpHeaderExpires            , HEADER("Expires") },
    { HttpHeaderLastModified       , HEADER("Last-Modified") },
    { HttpHeaderAccept             , HEADER("Accept") },
    { HttpHeaderAcceptCharset      , HEADER("Accept-Charset") },
    { HttpHeaderAcceptEncoding     , HEADER("Accept-Encoding") },
    { HttpHeaderAcceptLanguage     , HEADER("Accept-Language") },
    { HttpHeaderAuthorization      , HEADER("Authorization") },
    { HttpHeaderCookie             , HEADER("Cookie") },
    { HttpHeaderExpect             , HEADER("Expect") },
    { HttpHeaderFrom               , HEADER("From") },
    { HttpHeaderHost               , HEADER("Host") },
    { HttpHeaderIfMatch            , HEADER("If-Match") },
    { HttpHeaderIfModifiedSince    , HEADER("If-Modified-Since") },
    { HttpHeaderIfNoneMatch        , HEADER("If-None-Match") },
    { HttpHeaderIfRange            , HEADER("If-Range") },
    { HttpHeaderIfUnmodifiedSince  , HEADER("If-Unmodified-Since") },
    { HttpHeaderMaxForwards        , HEADER("Max-Forwards") },
    { HttpHeaderProxyAuthorization , HEADER("Proxy-Authorization") },
    { HttpHeaderReferer            , HEADER("Referer") },
    { HttpHeaderRange              , HEADER("Range") },
    { HttpHeaderTe                 , HEADER("TE") },
    { HttpHeaderTranslate          , HEADER("Translate") },
    { HttpHeaderUserAgent          , HEADER("User-Agent") }
};

//static
HRESULT
REQUEST_HEADER_HASH::Initialize(
    VOID
)
/*++

Routine Description:

    Initialize global header hash table

Arguments:

    None

Return Value:

    HRESULT

--*/
{
    HEADER_RECORD *     pRecord;
    LK_RETCODE          lkrc = LK_SUCCESS;
    DWORD               dwNumRecords;
    
    //
    // Add header index/name to hash table
    //
    
    sm_pRequestHash = new REQUEST_HEADER_HASH();
    if ( sm_pRequestHash == NULL )
    {
        return HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );
    }
    
    //
    // Add every string->routine mapping
    //

    dwNumRecords = sizeof( sm_rgHeaders ) / sizeof( HEADER_RECORD );
    
    for ( DWORD i = 0; i < dwNumRecords; i++ )
    {
        pRecord = &(sm_rgHeaders[ i ]); 
        lkrc = sm_pRequestHash->InsertRecord( pRecord );
        if ( lkrc != LK_SUCCESS )
        {
            break;
        }
    }
    
    //
    // If any insert failed, then fail initialization
    //
    
    if ( lkrc != LK_SUCCESS )
    {
        delete sm_pRequestHash;
        sm_pRequestHash = NULL;
        return HRESULT_FROM_WIN32( lkrc );        // BUGBUG
    }
    else
    {
        return NO_ERROR;
    }
}

//static
VOID
REQUEST_HEADER_HASH::Terminate(
    VOID
)
/*++

Routine Description:

    Global cleanup of header hash table

Arguments:

    None

Return Value:

    None

--*/
{
    if ( sm_pRequestHash != NULL )
    {
        delete sm_pRequestHash;
        sm_pRequestHash = NULL;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\iisplus\ulw3\ulcache.cxx ===
/*++

   Copyright    (c)    1999    Microsoft Corporation

   Module Name :
     ulcache.cxx

   Abstract:
     UL cache entries
 
   Author:
     Bilal Alam (balam)             11-Nov-2000

   Environment:
     Win32 - User Mode

   Project:
     ULW3.DLL
--*/

#include "precomp.hxx"

ALLOC_CACHE_HANDLER *    UL_RESPONSE_CACHE_ENTRY::sm_pachUlResponseCache;

HRESULT
UL_RESPONSE_CACHE_KEY::CreateCacheKey(
    WCHAR *                 pszKey,
    DWORD                   cchKey,
    BOOL                    fCopy
)
/*++

  Description:

    Setup a UL response cache key

  Arguments:

    pszKey - URL of cache key
    cchKey - size of URL
    fCopy - Set to TRUE if we should copy the URL, else we just keep a ref
    
  Return:

    HRESULT

--*/
{
    HRESULT             hr;
    
    if ( fCopy )
    {
        hr = _strKey.Copy( pszKey );
        if ( FAILED( hr ) )
        {
            return hr;
        }
        
        _pszKey = _strKey.QueryStr();
        _cchKey = _strKey.QueryCCH();
    }
    else
    {
        _pszKey = pszKey;
        _cchKey = cchKey;
    }

    return NO_ERROR;
}

//static
HRESULT
UL_RESPONSE_CACHE_ENTRY::Initialize(
    VOID
)
/*++

  Description:

    UL_RESPONSE_CACHE_ENTRY lookaside initialization

  Arguments:

    None
    
  Return:

    HRESULT

--*/
{
    ALLOC_CACHE_CONFIGURATION   acConfig;
    HRESULT                     hr;    

    //
    // Initialize allocation lookaside
    //    
    
    acConfig.nConcurrency = 1;
    acConfig.nThreshold   = 100;
    acConfig.cbSize       = sizeof( UL_RESPONSE_CACHE_ENTRY );

    DBG_ASSERT( sm_pachUlResponseCache == NULL );
    
    sm_pachUlResponseCache = new ALLOC_CACHE_HANDLER( "UL_RESPONSE_CACHE_ENTRY",  
                                                      &acConfig );

    if ( sm_pachUlResponseCache == NULL )
    {
        hr = HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );

        DBGPRINTF(( DBG_CONTEXT,
                   "Error initializing sm_pachUlResponseCache. hr = 0x%x\n",
                   hr ));

        return hr;
    }
    
    return NO_ERROR;
}

//static
VOID
UL_RESPONSE_CACHE_ENTRY::Terminate(
    VOID
)
/*++

  Description:

    UL_RESPONSE_CACHE_ENTRY lookaside cleanup

  Arguments:

    None
    
  Return:

    None

--*/
{
    if ( sm_pachUlResponseCache != NULL )
    {
        delete sm_pachUlResponseCache;
        sm_pachUlResponseCache = NULL;
    }
}

UL_RESPONSE_CACHE_ENTRY::~UL_RESPONSE_CACHE_ENTRY()
{
    _dwSignature = UL_RESPONSE_CACHE_ENTRY_SIGNATURE_FREE;
 
    DBGPRINTF(( DBG_CONTEXT,
                "Invalidating URL %ws\n",
                _strInvalidationUrl.QueryStr() ));

    UlAtqFlushUlCache( _strInvalidationUrl.QueryStr() );
}

HRESULT
UL_RESPONSE_CACHE_ENTRY::Create(
    STRU &                  strMetadataPath,
    STRU *                  pstrPhysicalPath,
    STRU &                  strInvalidationUrl
)
/*++

Routine Description:

    Initialize a ul response cache entry

Arguments:

    strMetadataPath - Metadata path associated with this response
    strPhysicalPath - Physical path to dir monitor
    strInvalidationUrl - Exact URL used to flush the UL response cache

Return Value:

    HRESULT

--*/
{
    HRESULT                 hr = NO_ERROR;
    
    hr = _cacheKey.CreateCacheKey( strMetadataPath.QueryStr(),
                                   strMetadataPath.QueryCCH(),
                                   TRUE );
    if ( FAILED( hr ) )
    {
        return hr;
    }

    if (pstrPhysicalPath != NULL)
    {
        hr = _strPhysicalPath.Copy( *pstrPhysicalPath );
        if ( FAILED( hr ) )
        {
            return hr;
        }
    }

    hr = _strInvalidationUrl.Copy( strInvalidationUrl );
    if ( FAILED( hr ) )
    {
        return hr;
    }

    return NO_ERROR;
}

BOOL
UL_RESPONSE_CACHE_ENTRY::QueryIsOkToFlushDirmon(
    WCHAR *                 pszPath,
    DWORD                   cchPath
)
/*++

  Description:

    Is it OK to flush this entry based on the given file which has changed

  Arguments:

    pszPath - Path that changed
    cchPath - Length of path 
    
  Return:

    TRUE if we should flush, else FALSE

--*/
{
    if ( _wcsnicmp( _strPhysicalPath.QueryStr(),
                    pszPath,
                    cchPath ) == 0 )
    {
        return TRUE;
    }
    else
    {
        return FALSE;
    }
}

UL_RESPONSE_CACHE::UL_RESPONSE_CACHE()
    : _fUlCacheEnabled( TRUE )
{
}

UL_RESPONSE_CACHE::~UL_RESPONSE_CACHE()
{
}

HRESULT
UL_RESPONSE_CACHE::SetupUlCachedResponse(
    W3_CONTEXT *                pW3Context,
    STRU &                      strFullUrl,
    BOOL                        fAddDirmonInvalidator,
    STRU *                      pstrPhysicalPath,
    DWORD                       cTTLOverride
)
/*++

Routine Description:

    Build (if necessary) a cache entry which controls the invalidation of
    a UL cached response

Arguments:

    pW3Context - Context
    strFullUrl - Exact URL used to flush the UL response cache
    fAddDirmonInvalidator - Should we use dirmon to flush the response
    pstrPhysicalPath - Physical path to dir monitor
    cTTLOverride - Override the default TTL for UL_CACHE_ENTRY and hence for
        the response in http.sys cache itself

Return Value:

    HRESULT (if FAILED, then we should not UL cache the response)

--*/
{
    UL_RESPONSE_CACHE_KEY           ulKey;
    UL_RESPONSE_CACHE_ENTRY *       pEntry = NULL;
    HRESULT                         hr;
    W3_METADATA *                   pMetaData;
    W3_URL_INFO *                   pUrlInfo;
    
    if ( pW3Context == NULL )
    {
        DBG_ASSERT( FALSE );
        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }
    
    DBG_ASSERT( pW3Context->QueryUrlContext() != NULL );
    
    pMetaData = pW3Context->QueryUrlContext()->QueryMetaData();
    DBG_ASSERT( pMetaData != NULL );
    
    pUrlInfo = pW3Context->QueryUrlContext()->QueryUrlInfo();
    DBG_ASSERT( pUrlInfo != NULL );
    
    //
    // Setup key to lookup whether we already have this response cached
    //
    
    hr = ulKey.CreateCacheKey( pUrlInfo->QueryMetadataPath()->QueryStr(),
                               pUrlInfo->QueryMetadataPath()->QueryCCH(),
                               FALSE );
    if ( FAILED( hr ) )
    {
        return hr;
    }
    
    //
    // Find a response entry
    //
    
    hr = FindCacheEntry( &ulKey, 
                         (CACHE_ENTRY**) &pEntry );
    if ( SUCCEEDED( hr ) )
    {
        DBG_ASSERT( pEntry != NULL );
        
        //
        // Ok.  We already have a UL cached entry.  Just release it
        // and return success
        //
        
        pEntry->DereferenceCacheEntry();
        
        return NO_ERROR;
    }
    
    //
    // Ok.  Try to add an entry
    //
    
    pEntry = new UL_RESPONSE_CACHE_ENTRY( this, cTTLOverride );
    if ( pEntry == NULL )
    {
        return HRESULT_FROM_WIN32( GetLastError() );
    }
    
    hr = pEntry->Create( *(pUrlInfo->QueryMetadataPath()),
                         pstrPhysicalPath,
                         strFullUrl );
    if ( FAILED( hr ) )
    {
        pEntry->DereferenceCacheEntry();
        return hr;
    }

    if (fAddDirmonInvalidator)
    {
        //
        // Start monitoring the appropriate directory for changes
        //

        hr = pEntry->AddDirmonInvalidator( pMetaData->QueryDirmonConfig() );
        if ( FAILED( hr ) )
        {
            pEntry->DereferenceCacheEntry();
            return hr;
        }
    }

    //
    // Add the cache entry
    //

    hr = AddCacheEntry( pEntry );
    if ( FAILED( hr ) )
    {
        pEntry->DereferenceCacheEntry();
        return hr;
    }
    
    //
    // Hash table owns a reference now.  Just release and return success
    //
    
    pEntry->DereferenceCacheEntry();
    
    return NO_ERROR;
}

BOOL
UL_RESPONSE_CACHE::CheckUlCacheability(
    W3_CONTEXT *        pW3Context
)
/*++

Routine Description:

    Determine whether the response for the given context appears cacheable
    in UL.  

Arguments:

    pW3Context - Context describing request

Return Value:

    TRUE if response seems ul cachable

--*/
{
    HRESULT             hr = NO_ERROR;
    W3_METADATA *       pMetaData = NULL;
    URL_CONTEXT *       pUrlContext = NULL;

    if ( pW3Context == NULL )
    {
        DBG_ASSERT( FALSE );
        return FALSE;
    }

    pUrlContext = pW3Context->QueryUrlContext();
    if ( pUrlContext == NULL )
    {
        //
        // We have no metadata (must be a fatal error)
        //

        return FALSE;
    }

    pMetaData = pUrlContext->QueryMetaData();
    DBG_ASSERT( pMetaData != NULL );

    //
    // If UL cache is disabled, then response is not UL cacheable (duh!)
    // 

    if ( !QueryUlCacheEnabled() )
    {
        return FALSE;
    }

    if ( !pW3Context->QueryIsUlCacheable() )
    {
        return FALSE;
    }

    //
    // Only UL cache 200 responses
    //

    if ( pW3Context->QueryResponse()->QueryStatusCode() !=
         HttpStatusOk.statusCode )
    {
        return FALSE;
    }

    //
    // Is dynamic compression enabled?  Since dynamic compression
    // is done later in W3_RESPONSE object, we need to do check now
    //

    if ( pMetaData->QueryDoDynamicCompression() )
    {
        return FALSE;
    }

    //
    // Is this a child request?
    //

    if ( pW3Context->QueryParentContext() != NULL )
    {
        return FALSE;
    }

    //
    // Is there a current handler which is UL friendly?
    //

    if ( pW3Context->QueryHandler() == NULL ||
         !pW3Context->QueryHandler()->QueryIsUlCacheable() )
    {
        return FALSE;
    }

    //
    // Are there filters installed which are not cache aware?
    //

    if ( !pW3Context->QuerySite()->QueryFilterList()->QueryIsUlFriendly() )
    {
        return FALSE;
    }

    //
    // Is this request accessible anonymously?
    //

    if ( !( pMetaData->QueryAuthentication() & MD_AUTH_ANONYMOUS ) )
    {
        return FALSE;
    }

    //
    // Are we doing custom logging?
    //

    if ( pW3Context->QueryDoCustomLogging() ) 
    {
        return FALSE;
    }

    //
    // Do we have special SSL requirements?
    //

    if ( pMetaData->QueryAccessPerms() & 
         ( VROOT_MASK_NEGO_CERT |
           VROOT_MASK_NEGO_MANDATORY |
           VROOT_MASK_MAP_CERT |
           VROOT_MASK_SSL128 ) )
    {
        return FALSE;
    }

    //
    // If we got to here, then we believe we can use the UL cache
    //

    return TRUE;
}

HRESULT
UL_RESPONSE_CACHE::Initialize(
    VOID
)
/*++

Routine Description:

    Initialize the cache managing invalidation of the UL cache

Arguments:

    None

Return Value:

    HRESULT

--*/
{
    HRESULT             hr;
    DWORD               dwData;
    DWORD               dwType;
    DWORD               cbData = sizeof( DWORD );
    HKEY                hKey;

    //
    // First determine how UL is configured by reading UL registry config
    //
    
    if ( RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                       L"System\\CurrentControlSet\\Services\\http\\Parameters",
                       0,
                       KEY_READ,
                       &hKey ) == ERROR_SUCCESS )
    {
        DBG_ASSERT( hKey != NULL );
    
        //
        // Is the UL cache enabled?
        //
        
        if ( RegQueryValueEx( hKey,
                              L"UriEnableCache",
                              NULL,
                              &dwType,
                              (LPBYTE) &dwData,
                              &cbData ) == ERROR_SUCCESS &&
             dwType == REG_DWORD )
        {
            _fUlCacheEnabled = !!dwData;
        }

        RegCloseKey( hKey );
    }                      
    
    //
    // Setup cache configuration
    // 
    
    hr = SetCacheConfiguration( 60 * 1000, 
                                INFINITE,
                                CACHE_INVALIDATION_METADATA |
                                CACHE_INVALIDATION_DIRMON_FLUSH,
                                NULL );
    if ( FAILED( hr ) )
    {
        return hr;
    }
    
    return UL_RESPONSE_CACHE_ENTRY::Initialize();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\iisplus\ulw3\ulw3.cxx ===
/*++

   Copyright    (c)    1999    Microsoft Corporation

   Module Name :
     ulw3.cxx

   Abstract:
     W3 Handler Driver
 
   Author:
     Bilal Alam (balam)             13-Dec-1999

   Environment:
     Win32 - User Mode

   Project:
     ULW3.DLL
--*/


/************************************************************
 *  Include Headers
 ************************************************************/

#include "precomp.hxx"

/************************************************************
 *  Declarations
 ************************************************************/

// BUGBUG
#undef INET_INFO_KEY
#undef INET_INFO_PARAMETERS_KEY

#define W3_TRACE_MOF_FILE     L"W3CoreMofResource"
#define W3_IMAGE_PATH         L"w3core.dll"

//
//  Configuration parameters registry key.
//
#define INET_INFO_KEY \
            "System\\CurrentControlSet\\Services\\w3svc"

#define INET_INFO_PARAMETERS_KEY \
            INET_INFO_KEY "\\Parameters"

const CHAR g_pszWpRegLocation[] =
    INET_INFO_PARAMETERS_KEY "\\w3core";



DECLARE_DEBUG_PRINTS_OBJECT();
DECLARE_DEBUG_VARIABLE();
DECLARE_PLATFORM_TYPE();

/************************************************************
 *  Type Definitions  
 ************************************************************/

W3_SERVER *             g_pW3Server = NULL;
CEtwTracer *            g_pEtwTracer = NULL;

HRESULT
UlW3Start(
    INT                     argc,
    LPWSTR                  argv[],
    BOOL                    fCompatibilityMode
)
/*++
Description:

    Perform one time initialization, including ULATQ setup.
    Wait on shutdown. Then clean up.

    Assumes that this startup thread is CoInitialized MTA.

--*/
{
    HRESULT                 hr = NO_ERROR;

    CREATE_DEBUG_PRINT_OBJECT("w3core");
    if (!VALID_DEBUG_PRINT_OBJECT())
    {
        return E_FAIL;
    }

    LOAD_DEBUG_FLAGS_FROM_REG_STR( g_pszWpRegLocation, DEBUG_ERROR );

    INITIALIZE_PLATFORM_TYPE();

    DBG_ASSERT( g_pW3Server == NULL );

    //
    // First initialize tracing stuff so initialization of W3_SERVER has 
    // access to the object
    //
    
    g_pEtwTracer = new CEtwTracer; 
    if ( g_pEtwTracer == NULL )
    {
        hr = HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );
        goto Finished;
    }

    hr = g_pEtwTracer->Register( &IISControlGuid, 
                                 W3_IMAGE_PATH, 
                                 W3_TRACE_MOF_FILE );
    if ( FAILED( hr ) )
    {
        goto Finished;
    }
    
    //
    // Create the global W3_SERVER object
    // 
    
    g_pW3Server = new W3_SERVER( fCompatibilityMode );
    if ( g_pW3Server == NULL )
    {
        hr = HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );
        goto Finished;
    }
    
    //
    // Do global initialization (but no listen)
    //

    hr = g_pW3Server->Initialize( argc, argv );
    if ( FAILED( hr ) )
    {    
        goto Finished;
    }
    
    //
    // Start listening
    //
    
    hr = g_pW3Server->StartListen();
    if ( FAILED( hr ) )
    {
        goto Finished;
    }

Finished:
    
    //
    // Cleanup
    //
    
    if ( g_pW3Server != NULL )
    {
        g_pW3Server->Terminate( hr );
        delete g_pW3Server;
        g_pW3Server = NULL;
    }
    
    if ( g_pEtwTracer != NULL ) 
    {
        g_pEtwTracer->UnRegister();
        delete g_pEtwTracer;
        g_pEtwTracer = NULL;
    }

    DELETE_DEBUG_PRINT_OBJECT();
    
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\iisplus\ulw3\w3handler.cxx ===
/*++

   Copyright    (c)    1999    Microsoft Corporation

   Module Name :
     w3handler.cxx

   Abstract:
     Common functionality of all handlers
 
   Author:
     Bilal Alam (balam)             Sept-29-2000

   Environment:
     Win32 - User Mode

   Project:
     ULW3.DLL
--*/

#include "precomp.hxx"

CONTEXT_STATUS
W3_HANDLER::MainDoWork(
    VOID
)
/*++

Routine Description:

    Checks access and then calls handler routine

Return Value:

    CONTEXT_STATUS_PENDING if async pending,
    else CONTEXT_STATUS_CONTINUE

--*/
{
    CONTEXT_STATUS          contextStatus;
    BOOL                    fAccessAllowed = FALSE;

    W3_CONTEXT *pW3Context = QueryW3Context();
    DBG_ASSERT( pW3Context != NULL );

    //
    // Check access
    //
    
    contextStatus = pW3Context->CheckAccess( FALSE,     // not a completion
                                             0,         // cbCompletion
                                             NO_ERROR,
                                             &fAccessAllowed );

    if ( contextStatus == CONTEXT_STATUS_PENDING )
    {
        return CONTEXT_STATUS_PENDING;
    }
    
    //
    // Access check must be complete if we're here
    //
    
    DBG_ASSERT( pW3Context->QueryAccessChecked() );

    if ( !fAccessAllowed )
    {
        //
        // CheckAccess already sent error
        //
        
        return CONTEXT_STATUS_CONTINUE;
    }    
    
    //
    // Now we can execute the handler
    //
    
    return DoWork();
} 

CONTEXT_STATUS
W3_HANDLER::MainOnCompletion(
    DWORD                   cbCompletion,
    DWORD                   dwCompletionStatus
)
/*++

Routine Description:

    Continue access check if needed, then then when finished, call into
    the handler start
    
    If handler is already started, funnel the completion to the handler

Arguments:

    cbCompletion - Bytes of completion
    dwCompletionStatus - Status of completion

Return Value:

    CONTEXT_STATUS_PENDING if async pending,
    else CONTEXT_STATUS_CONTINUE

--*/
{
    W3_CONTEXT *            pW3Context;
    CONTEXT_STATUS          contextStatus;
    BOOL                    fAccessAllowed = FALSE;
    
    pW3Context = QueryW3Context();
    DBG_ASSERT( pW3Context != NULL );
    
    if ( !pW3Context->QueryAccessChecked() )
    {
        //
        // If access hasn't been checked completely yet, then we should resume
        // it
        //
        
        contextStatus = pW3Context->CheckAccess( TRUE,      // completion
                                                 cbCompletion,
                                                 dwCompletionStatus,
                                                 &fAccessAllowed );
        
        if ( contextStatus == CONTEXT_STATUS_PENDING )
        {
            return CONTEXT_STATUS_PENDING;
        }
        
        DBG_ASSERT( pW3Context->QueryAccessChecked() );
        
        if ( !fAccessAllowed )
        {
            //
            // CheckAccess already sent error
            //
            
            return CONTEXT_STATUS_CONTINUE;
        }
        
        //
        // Now we can execute the original handler
        //
        
        return DoWork();
    }
    else
    {
        //
        // Access checks have already been made.  This must be a completion
        // for the handler itself
        //
        
        return OnCompletion( cbCompletion,
                             dwCompletionStatus );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\iisplus\ulw3\w3conn.cxx ===
/*++

   Copyright    (c)    1999    Microsoft Corporation

   Module Name :
     w3conn.cxx

   Abstract:
     Http Connection management
 
   Author:
     Bilal Alam (balam)             6-Jan-2000

   Environment:
     Win32 - User Mode

   Project:
     ULW3.DLL
--*/

#include "precomp.hxx"

ALLOC_CACHE_HANDLER *    W3_CONNECTION::sm_pachW3Connections;
W3_CONNECTION_HASH *     W3_CONNECTION::sm_pConnectionTable;

W3_CONNECTION::W3_CONNECTION( 
    HTTP_CONNECTION_ID           connectionId
)
    : _cRefs( 1 ),
      _pUserContext( NULL ),
      _fConnected( TRUE )
{
    LK_RETCODE              lkrc;
    
    _connId = connectionId;
    _dwSignature = W3_CONNECTION_SIGNATURE;
    
    ZeroMemory( _rgConnectionState, sizeof( _rgConnectionState ) );

    IF_DEBUG( CONN )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "New W3_CONNECTION '%p' created\n",
                    this ));
    }
                    
}

W3_CONNECTION::~W3_CONNECTION()
{
    IF_DEBUG( CONN )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "W3_CONNECTION '%p' deleted\n",
                    this ));
    }
    
    //
    // Cleanup state associated with connection
    //
    
    for ( DWORD i = 0; i < STATE_COUNT; i++ )
    {
        if ( _rgConnectionState[ i ] != NULL )
        {
            _rgConnectionState[ i ]->Cleanup();
            _rgConnectionState[ i ] = NULL;
        }
    }
    
    //
    // Release the user context associated
    //
    
    if ( _pUserContext != NULL )
    {
        _pUserContext->DereferenceUserContext();
        _pUserContext = NULL;
    }

    _dwSignature = W3_CONNECTION_SIGNATURE_FREE;
}

HRESULT
W3_CONNECTION::Initialize(
    VOID
)
/*++

Routine Description:
    
    Global W3_CONNECTION initialization

Arguments:

    None
    
Return Value:

    HRESULT

--*/
{
    HRESULT                         hr = NO_ERROR;
    ALLOC_CACHE_CONFIGURATION       acConfig;

    //
    // Initialize allocation lookaside
    //
    
    acConfig.nConcurrency = 1;
    acConfig.nThreshold = 100;
    acConfig.cbSize = sizeof( W3_CONNECTION );

    DBG_ASSERT( sm_pachW3Connections == NULL );
    
    sm_pachW3Connections = new ALLOC_CACHE_HANDLER( "W3_CONNECTION",  
                                                    &acConfig );

    if ( sm_pachW3Connections == NULL )
    {
        return HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );
    }
    
    //
    // Allocate table
    //
    
    sm_pConnectionTable = new W3_CONNECTION_HASH;
    if ( sm_pConnectionTable == NULL )
    {
        hr = HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );
    }
    
    return hr;
}

VOID
W3_CONNECTION::Terminate(
    VOID
)
/*++

Routine Description:

    Destroy W3_CONNECTION globals

Arguments:

    None
    
Return Value:

    None

--*/
{
    if ( sm_pConnectionTable != NULL )
    {
        delete sm_pConnectionTable;
        sm_pConnectionTable = NULL;
    }

    delete sm_pachW3Connections;
    sm_pachW3Connections = NULL;
}

HRESULT
W3_CONNECTION::RetrieveConnection(
    HTTP_CONNECTION_ID              ConnectionId,
    BOOL                            fCreateIfNotFound,
    W3_CONNECTION **                ppConnection
)
/*++

Routine Description:

    Given, a UL_HTTP_REQUEST (and thus a UL_HTTP_CONNECTION_ID), determine
    whether there is an associated W3_CONNECTION with that ID.  If not, 
    create a new W3_CONNECTION.  This function will also call into ULATQ to
    get an asynchronous notification when the connection goes away.

Arguments:

    ConnectionId - Connection ID
    fCreateIfNotFound - Create if not found in hash table
    ppConnection - Receives a pointer to a W3_CONNECTION for this request
    
Return Value:

    HRESULT

--*/
{
    W3_CONNECTION *         pNewConnection;
    HRESULT                 hr;
    LK_RETCODE              lkrc;
    BOOL                    fAlreadyDisconnected;
     
    DBG_ASSERT( ppConnection != NULL );

    *ppConnection = NULL;

    lkrc = sm_pConnectionTable->FindKey( &ConnectionId,
                                         ppConnection );
    if ( lkrc != LK_SUCCESS )
    {
        if ( !fCreateIfNotFound )
        {
            //
            // Just return out now since the caller doesn't want us to create
            // the connection object
            //
            
            return HRESULT_FROM_WIN32( ERROR_FILE_NOT_FOUND );
        }
        
        //
        // Create a new connection object
        //
        
        pNewConnection = new W3_CONNECTION( ConnectionId );
        if ( pNewConnection == NULL )
        {
            return HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );
        }

        //
        // Insert the object into connection table
        //
        
        lkrc = sm_pConnectionTable->InsertRecord( pNewConnection );
        if ( lkrc != LK_SUCCESS )
        {
            delete pNewConnection;
            return HRESULT_FROM_WIN32( lkrc );
        } 
      
        //
        // Monitor when the connection goes away
        //

        hr = UlAtqWaitForDisconnect( ConnectionId,
                                     TRUE,
                                     pNewConnection,
                                     &fAlreadyDisconnected );
        if ( FAILED( hr ) )
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "Error waiting for disconnect of connection '%p'.  hr = %x\n",
                        pNewConnection,
                        hr ));

            //
            // OK.  The connection must have gone away from under us.  This
            // is not fatal.  It just means that once the state machine has
            // completed, we should immediately destroy the connection
            // object.
            //
            
            pNewConnection->RemoveConnection();
        }
        else if ( fAlreadyDisconnected )
        {
            pNewConnection->_fConnected = FALSE;
        }
        
        *ppConnection = pNewConnection;
    } 
    else
    {
        IF_DEBUG( CONN )
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "Request on existing W3_CONNECTION '%p'\n",
                        *ppConnection ));
        }
    }
    
    return NO_ERROR;
}

VOID
OnUlDisconnect(
    VOID *                  pvContext
)
/*++

Routine Description:

    Completion routine called when a connection is closed

Arguments:

    pvContext - Points to the W3_CONNECTION which was closed
    
Return Value:

    None

--*/
{
    W3_CONNECTION *         pConnection;
    
    DBG_ASSERT( pvContext != NULL );
    
    pConnection = (W3_CONNECTION*) pvContext;
    
    DBG_ASSERT( pConnection->CheckSignature() );
   
    pConnection->RemoveConnection();
    
}

VOID
W3_CONNECTION::ReferenceConnection(
    VOID
)
/*++

Routine Description:

    Reference the connection (duh)

Arguments:

    None
    
Return Value:

    None

--*/
{
    InterlockedIncrement( &_cRefs );
}
    
VOID 
W3_CONNECTION::DereferenceConnection( 
    VOID 
)
/*++

Routine Description:

    Dereference and possibly cleanup the connection

Arguments:

    None
    
Return Value:

    None

--*/
{
    if ( InterlockedDecrement( &_cRefs ) == 0 )
    {
        delete this;    
    }
}

VOID
W3_CONNECTION::RemoveConnection(    
    VOID
)
/*++

Routine Description:

    Remove the connection from the hash table.  This will indirectly
    dereference the connection so that it can await final cleanup

Arguments:

    None
    
Return Value:

    None

--*/
{
    _fConnected = FALSE;
    sm_pConnectionTable->DeleteRecord( this );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\iisplus\ulw3\urlcontext.cxx ===
/*++

   Copyright    (c)    1999    Microsoft Corporation

   Module Name :
     urlinfo.cxx

   Abstract:
     Gets metadata for URL

   Author:
     Bilal Alam (balam)             8-Jan-2000

   Environment:
     Win32 - User Mode

   Project:
     ULW3.DLL
--*/

#include "precomp.hxx"
#include <stringau.hxx>

//
// Utility to guard against ~ inconsistency
//

DWORD
CheckIfShortFileName(
    IN WCHAR *          pszPath,
    IN HANDLE           hImpersonation,
    OUT BOOL *          pfShort
);

W3_STATE_URLINFO::W3_STATE_URLINFO()
{
    _hr = URL_CONTEXT::Initialize();
}

W3_STATE_URLINFO::~W3_STATE_URLINFO()
{
    URL_CONTEXT::Terminate();
}

CONTEXT_STATUS
W3_STATE_URLINFO::OnCompletion(
    W3_MAIN_CONTEXT *       pMainContext,
    DWORD                   cbCompletion,
    DWORD                   dwCompletionStatus
)
/*++

Routine Description:

    Handle URLINFO completions.  CheckAccess() is called in DoWork() and this
    call is asynchronous.

Arguments:

    pMainContext - W3_MAIN_CONTEXT representing execution of state machine
    cbCompletion - Number of bytes in an async completion
    dwCompletionStatus - Error status of a completion

Return Value:

    CONTEXT_STATUS_CONTINUE - if we should continue in state machine
    else stop executing the machine and free up the current thread

--*/
{
    CONTEXT_STATUS              contextStatus;
    BOOL                        fAccessAllowed;

    contextStatus = pMainContext->CheckAccess( TRUE,   // this is a completion
                                               cbCompletion,
                                               dwCompletionStatus,
                                               &fAccessAllowed );

    if ( contextStatus == CONTEXT_STATUS_PENDING )
    {
        return CONTEXT_STATUS_PENDING;
    }

    //
    // If access is not allowed, then just finish state machine (
    // response has already been sent)
    //

    if ( !fAccessAllowed )
    {
        pMainContext->SetFinishedResponse();
    }

    return CONTEXT_STATUS_CONTINUE;
}

CONTEXT_STATUS
W3_STATE_URLINFO::DoWork(
    W3_MAIN_CONTEXT *       pMainContext,
    DWORD                   cbCompletion,
    DWORD                   dwCompletionStatus
)
/*++

Routine Description:

    Handle retrieving the metadata for this request

Arguments:

    pMainContext - W3_MAIN_CONTEXT representing execution of state machine
    cbCompletion - Number of bytes in an async completion
    dwCompletionStatus - Error status of a completion

Return Value:

    CONTEXT_STATUS_CONTINUE - if we should continue in state machine
    else stop executing the machine and free up the current thread

--*/
{
    URL_CONTEXT *           pUrlContext = NULL;
    BOOL                    fFinished = FALSE;
    HRESULT                 hr = NO_ERROR;
    W3_METADATA *           pMetaData = NULL;
    CONTEXT_STATUS          contextStatus = CONTEXT_STATUS_CONTINUE;
    W3_REQUEST *            pHttpRequest = pMainContext->QueryRequest();
    W3_RESPONSE *           pResponse = pMainContext->QueryResponse();
    BOOL                    fAccessAllowed = FALSE;

    DBG_ASSERT( pHttpRequest != NULL );
    DBG_ASSERT( pResponse != NULL );

    //
    // Set the context state.  Note that passing TRUE as the final
    // argument pushes the URL_CONTEXT into the main context.  As
    // a result, errors in this function should not attempt to
    // clean it up.
    //

    hr = URL_CONTEXT::RetrieveUrlContext( pMainContext,
                                          pMainContext->QueryRequest(),
                                          &pUrlContext,
                                          &fFinished,
                                          TRUE );
    if ( FAILED( hr ) )
    {
        goto Failure;
    }

    DBG_ASSERT( fFinished || ( pUrlContext != NULL ) );

    //
    // From now on, errors in this function should not cleanup the URL
    // context since it is owned by the main context
    //

    pUrlContext = NULL;

    //
    // If filter wants out, leave
    //

    if ( fFinished )
    {
        pMainContext->SetDone();
        return CONTEXT_STATUS_CONTINUE;
    }

    //
    // Check access now.  That means checking for IP/SSL/Certs.  We will
    // avoid the authentication type check since the others (IP/SSL/Certs)
    // take priority.
    //

    contextStatus = pMainContext->CheckAccess( FALSE,     // not a completion
                                               0,         // cbCompletion,
                                               NO_ERROR,
                                               &fAccessAllowed );
    if ( contextStatus == CONTEXT_STATUS_PENDING )
    {
        return CONTEXT_STATUS_PENDING;
    }

    //
    // If we don't have access, then the appropriate error response was
    // already sent.  Just finish the state machine
    //

    if ( !fAccessAllowed )
    {
        pMainContext->SetFinishedResponse();
    }

    return CONTEXT_STATUS_CONTINUE;

Failure:

    if ( pUrlContext != NULL )
    {
        delete pUrlContext;
    }

    if ( !pMainContext->QueryResponseSent() )
    {
        if ( hr == HRESULT_FROM_WIN32( ERROR_FILE_NOT_FOUND ) )
        {
            // For the non-8dot3 case
            pMainContext->QueryResponse()->SetStatus( HttpStatusNotFound );
        }
        else if ( hr == HRESULT_FROM_WIN32( ERROR_INVALID_DATA ) )
        {
            pMainContext->QueryResponse()->SetStatus( HttpStatusServerError,
                                                      Http500BadMetadata );
        }
        else if ( hr == HRESULT_FROM_WIN32( ERROR_LOGON_FAILURE ) )
        {
            pMainContext->QueryResponse()->SetStatus( HttpStatusServerError,
                                                      Http500UNCAccess );
        }
        else
        {
            pMainContext->QueryResponse()->SetStatus( HttpStatusServerError );
        }
    }

    pMainContext->SetFinishedResponse();
    pMainContext->SetErrorStatus( hr );

    return CONTEXT_STATUS_CONTINUE;
}

//static
HRESULT
URL_CONTEXT::RetrieveUrlContext(
    W3_CONTEXT *            pW3Context,
    W3_REQUEST *            pRequest,
    OUT URL_CONTEXT **      ppUrlContext,
    BOOL *                  pfFinished,
    BOOL                    fSetInW3Context
)
/*++

Routine Description:

    For a given request, get a URL_CONTEXT which represents the
    metadata and URI-specific info for that request

Arguments:

    pW3Context - W3_CONTEXT for the request
    pRequest - New request to lookup
    ppUrlContext - Set to point to new URL_CONTEXT
    pfFinished - Set to true if isapi filter said we're finished
    fSetInW3Context - OPTIONAL default FALSE

Return Value:

    HRESULT

--*/
{
    STACK_STRU(         strUrl, MAX_PATH );
    W3_URL_INFO *       pUrlInfo = NULL;
    W3_METADATA *       pMetaData = NULL;
    TOKEN_CACHE_ENTRY * pTokenEntry = NULL;
    URL_CONTEXT *       pUrlContext = NULL;
    HRESULT             hr = NO_ERROR;
    HANDLE              hToken = NULL;
    W3_TRACE_LOG *      pTraceLog;

    if ( pW3Context == NULL ||
         pRequest == NULL ||
         ppUrlContext == NULL ||
         pfFinished == NULL )
    {
        DBG_ASSERT( FALSE );
        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }
    *ppUrlContext = NULL;

    hr = pRequest->GetUrl( &strUrl );
    if ( FAILED( hr ) )
    {
        goto Failure;
    }

    //
    // Lookup the URI info for this request
    //

    DBG_ASSERT( g_pW3Server->QueryUrlInfoCache() != NULL );

    hr = g_pW3Server->QueryUrlInfoCache()->GetUrlInfo(
                                        pW3Context,
                                        strUrl,
                                        &pUrlInfo );
    if ( FAILED( hr ) )
    {
        goto Failure;
    }

    //
    // Now, create a URL_CONTEXT object which contains the W3_URL_INFO and
    // W3_METADATA pointers as well as state information for use on cleanup
    //

    DBG_ASSERT( pUrlInfo != NULL );

    pMetaData = (W3_METADATA*) pUrlInfo->QueryMetaData();
    DBG_ASSERT( pMetaData != NULL );

    pUrlContext = new (pW3Context) URL_CONTEXT( pMetaData, pUrlInfo );
    if ( pUrlContext == NULL )
    {
        hr = HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );
        goto Failure;
    }
    else if( fSetInW3Context )
    {
        //
        // If specified, set the UrlContext in pW3Context.  This is necessary
        // since the below filter notification depends on having this context
        // for APPL_MD_PATH and APPL_PHYSICAL_PATH. Once set the context owns
        // cleaning it up.
        //
        ((W3_MAIN_CONTEXT*)pW3Context)->SetUrlContext( pUrlContext );
    }

    //
    // Now notify URL_MAP filters
    //

    if ( pW3Context->IsNotificationNeeded( SF_NOTIFY_URL_MAP ) )
    {
        STACK_STRA(            straPhys, MAX_PATH + 1 );
        STACK_STRA(            straSavePhys, MAX_PATH + 1 );
        STACK_STRA(            straUrl, MAX_PATH + 1 );
        STACK_STRA(            straScriptMap, MAX_PATH + 1 );
        BOOL                   fRet;
        HTTP_FILTER_URL_MAP_EX filterMap;
        STACK_STRU(            strPhysicalPath, MAX_PATH );

        hr = straPhys.CopyW( pUrlInfo->QueryPhysicalPath()->QueryStr() );
        if ( FAILED( hr ) )
        {
            goto Failure;
        }

        //
        // Save a copy for comparison after filter notification
        //
        hr = straSavePhys.Copy( straPhys );
        if ( FAILED( hr ) )
        {
            goto Failure;
        }

        hr = straUrl.CopyW( strUrl.QueryStr() );
        if ( FAILED( hr ) )
        {
            goto Failure;
        }

        filterMap.pszURL = straUrl.QueryStr();
        filterMap.pszPhysicalPath = straPhys.QueryStr();
        filterMap.cbPathBuff = straPhys.QuerySize();
        filterMap.dwFlags = pMetaData->QueryAccessPerms();
        filterMap.cchMatchingPath = pMetaData->QueryCBMatchingPathA();
        filterMap.cchMatchingURL = pMetaData->QueryCBMatchingUrlA();
        filterMap.pszScriptMapEntry = NULL;

        if ( pUrlInfo->QueryScriptMapEntry() )
        {
            hr = straScriptMap.CopyW( pUrlInfo->QueryScriptMapEntry()->QueryExecutable()->QueryStr() );

            if ( FAILED( hr ) )
            {
                goto Failure;
            }

            filterMap.pszScriptMapEntry = straScriptMap.QueryStr();
        }

        fRet = pW3Context->NotifyFilters( SF_NOTIFY_URL_MAP,
                                          &filterMap,
                                          pfFinished );

        if ( !fRet )
        {
            W3_MAIN_CONTEXT * pMainContext = pW3Context->QueryMainContext();
            DWORD             dwError = GetLastError();

            hr = HRESULT_FROM_WIN32( dwError );

            pMainContext->SetErrorStatus( hr );

            if ( dwError == ERROR_ACCESS_DENIED )
            {
                pMainContext->QueryResponse()->SetStatus( HttpStatusUnauthorized,
                                                          Http401Filter );
            }
            else if ( dwError == ERROR_FILE_NOT_FOUND ||
                      dwError == ERROR_PATH_NOT_FOUND )
            {
                pMainContext->QueryResponse()->SetStatus( HttpStatusNotFound );
            }
            else
            {
                pMainContext->QueryResponse()->SetStatus( HttpStatusServerError );
            }

            goto Failure;
        }

        //
        // If the filter is done, then we're done
        //

        if ( *pfFinished )
        {
            hr = NO_ERROR;
            goto Failure;
        }

        //
        // If the physical path was changed, remember it here
        //

        if ( strcmp( straSavePhys.QueryStr(),
                     filterMap.pszPhysicalPath ) != 0 )
        {
            hr = strPhysicalPath.CopyA( (CHAR*) filterMap.pszPhysicalPath );
            if ( FAILED( hr ) )
            {
                goto Failure;
            }

            hr = pUrlContext->SetPhysicalPath( strPhysicalPath );
            if ( FAILED( hr ) )
            {
                goto Failure;
            }
        }
    }

    //
    // We don't accept short filename since they can break metabase
    // equivalency
    //

    if ( wcschr( pUrlContext->QueryPhysicalPath()->QueryStr(),
                 L'~' ) )
    {
        BOOL fShort = FALSE;

        hr = pMetaData->GetAndRefVrAccessToken( &pTokenEntry );
        if( FAILED( hr ) )
        {
            goto Failure;
        }
        
        if ( pTokenEntry != NULL )
        {
            hToken = pTokenEntry->QueryImpersonationToken();
        }
        else
        {
            hToken = NULL;
        }


        DWORD dwError = CheckIfShortFileName(
                                pUrlContext->QueryPhysicalPath()->QueryStr(),
                                hToken,
                                &fShort );
        if ( dwError != ERROR_SUCCESS )
        {
            hr = HRESULT_FROM_WIN32( dwError );
            goto Failure;
        }

        if ( fShort )
        {
            hr = HRESULT_FROM_WIN32( ERROR_FILE_NOT_FOUND );
            goto Failure;
        }
    }
    
    //
    // Check whether the UNC user was valid.  If not, fail
    //
    
    if ( pMetaData->QueryUNCUserInvalid() )
    {
        hr = HRESULT_FROM_WIN32( ERROR_LOGON_FAILURE );
        goto Failure;
    }

    pTraceLog = pW3Context->QueryMainContext()->QueryTraceLog();
    if ( pTraceLog != NULL )
    {
        pTraceLog->Trace( L"%I64x: Successfully metadata for URL '%ws'\n",
                          pRequest->QueryRequestId(),
                          strUrl.QueryStr() );
    }

    *ppUrlContext = pUrlContext;

    if( pTokenEntry != NULL )
    {
        pTokenEntry->DereferenceCacheEntry();
        pTokenEntry = NULL;
    }

    return S_OK;

Failure:

    pTraceLog = pW3Context->QueryMainContext()->QueryTraceLog();
    if ( pTraceLog != NULL )
    {
        pTraceLog->Trace( L"%I64x: Failed to retrieve metadata for URL '%ws'.  hr = %08X\n",
                          pRequest->QueryRequestId(),
                          strUrl.QueryStr(),
                          hr );
    }

    if ( pUrlContext != NULL  )
    {
        if( !fSetInW3Context )
        {
            delete pUrlContext;
        }
    }
    else
    {
        if ( pUrlInfo != NULL )
        {
            pUrlInfo->DereferenceCacheEntry();
        }
    }

    if( pTokenEntry != NULL )
    {
        pTokenEntry->DereferenceCacheEntry();
        pTokenEntry = NULL;
    }

    return hr;
}

//static
HRESULT
W3_STATE_URLINFO::MapPath(
    W3_CONTEXT *            pW3Context,
    STRU &                  strUrl,
    STRU *                  pstrPhysicalPath,
    BOOL                    fDoFiltering,
    DWORD *                 pcchDirRoot,
    DWORD *                 pcchVRoot,
    DWORD *                 pcbAnsiDirRoot,
    DWORD *                 pcbAnsiVRoot,
    DWORD *                 pdwMask
)
/*++

Routine Description:

    Send a URL/Physical-Path pair to a filter for processing

Arguments:

    pW3Context - W3_CONTEXT for the request
    strUrl - The URL to be mapped
    pstrPhysicalPath - Filled with the mapped path upon return.  Set with
                       metadata physical path on entry
    fDoFiltering - Enable filters
    pcchDirRoot - Set to point to number of characters in found physical path
    pcchVRoot - Set to point to number of characters in found virtual path
    pcbAnsiDirRoot - Set to point to number of bytes in found ANSI physical path
    pcbAnsiVRoot - Set to point to number of bytes in found ANSI virtual path
    pdwMask - Set to point to the access perms mask of virtual path

Return Value:

    SUCCEEDED()/FAILED()

--*/
{
    HRESULT         hr = S_OK;
    W3_URL_INFO *   pUrlInfo = NULL;
    W3_METADATA *   pMetaData = NULL;

    DBG_ASSERT( pstrPhysicalPath );

    //
    // Get and keep the metadata and urlinfo for this path
    //

    DBG_ASSERT( g_pW3Server->QueryUrlInfoCache() != NULL );

    hr = g_pW3Server->QueryUrlInfoCache()->GetUrlInfo(
                                        pW3Context,
                                        strUrl,
                                        &pUrlInfo );
    if ( FAILED( hr ) )
    {
        goto Exit;
    }

    DBG_ASSERT( pUrlInfo != NULL );

    //
    // Call the filters if we should do so
    //

    if ( fDoFiltering )
    {
        hr = FilterMapPath( pW3Context,
                            pUrlInfo,
                            pstrPhysicalPath );
    }
    else
    {
        hr = pstrPhysicalPath->Copy( *( pUrlInfo->QueryUrlTranslated() ) );
    }

    if ( FAILED( hr ) )
    {
        goto Exit;
    }

    pMetaData = pUrlInfo->QueryMetaData();
    DBG_ASSERT( pMetaData != NULL );

    //
    // Return the other goodies
    //

    if ( pcchDirRoot != NULL )
    {
        *pcchDirRoot = pMetaData->QueryVrPath()->QueryCCH();
    }

    if ( pcchVRoot != NULL )
    {
        if (strUrl.QueryCCH())
        {
            *pcchVRoot = pMetaData->QueryVrLen();
        }
        else
        {
            *pcchVRoot = 0;
        }
    }

    if ( pcbAnsiDirRoot != NULL )
    {
        *pcbAnsiDirRoot = pMetaData->QueryCBMatchingPathA();
    }

    if ( pcbAnsiVRoot != NULL )
    {
        if ( strUrl.QueryCCH() )
        {
            *pcbAnsiVRoot = pMetaData->QueryCBMatchingUrlA();
        }
        else
        {
            *pcbAnsiVRoot = 0;
        }
    }

    if ( pdwMask != NULL )
    {
        *pdwMask = pMetaData->QueryAccessPerms();
    }

Exit:

    if ( pUrlInfo != NULL )
    {
        pUrlInfo->DereferenceCacheEntry();
        pUrlInfo = NULL;
    }

    return hr;
}

// static
HRESULT
W3_STATE_URLINFO::FilterMapPath(
    W3_CONTEXT *            pW3Context,
    W3_URL_INFO *           pUrlInfo,
    STRU *                  pstrPhysicalPath
    )
/*++

Routine Description:

    Have URL_MAP filters do their thing

Arguments:

    pW3Context - Context
    pUrlInfo - Contains virtual/physical path
    pstrPhysicalPath - Filled with physical path

Return Value:

    SUCCEEDED()/FAILED()

--*/
{
    HRESULT         hr = S_OK;
    BOOL            fFinished = FALSE;
    W3_METADATA *   pMetaData = NULL;
    STACK_STRU(     strFilterPath, MAX_PATH );
    STRU *          pstrFinalPhysical = NULL;

    if ( pW3Context == NULL ||
         pUrlInfo == NULL ||
         pstrPhysicalPath == NULL )
    {
        DBG_ASSERT( FALSE );
        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }

    pMetaData = pUrlInfo->QueryMetaData();
    DBG_ASSERT( pMetaData != NULL );

    //
    // We now have the metadata physical path.  Let filters change it here
    //

    if ( pW3Context->IsNotificationNeeded( SF_NOTIFY_URL_MAP ) )
    {
        STACK_STRA(            straPhys, MAX_PATH + 1 );
        STACK_STRA(            straSavePhys, MAX_PATH + 1 );
        STACK_STRA(            straUrl, MAX_PATH + 1 );
        STACK_STRA(            straScriptMap, MAX_PATH + 1 );
        BOOL                   fRet;
        HTTP_FILTER_URL_MAP_EX filterMap;

        hr = straPhys.CopyW( pUrlInfo->QueryUrlTranslated()->QueryStr() );
        if ( FAILED( hr ) )
        {
            goto Exit;
        }

        //
        // Save a copy for comparison after filter notification
        //
        hr = straSavePhys.Copy( straPhys );
        if ( FAILED( hr ) )
        {
            goto Exit;
        }

        hr = straUrl.CopyW( pUrlInfo->QueryUrl() );
        if ( FAILED( hr ) )
        {
            goto Exit;
        }

        filterMap.pszURL = straUrl.QueryStr();
        filterMap.pszPhysicalPath = straPhys.QueryStr();
        filterMap.cbPathBuff = straPhys.QuerySize();
        filterMap.dwFlags = pMetaData->QueryAccessPerms();
        filterMap.cchMatchingPath = pMetaData->QueryCBMatchingPathA();
        filterMap.cchMatchingURL = pMetaData->QueryCBMatchingUrlA();
        filterMap.pszScriptMapEntry = NULL;

        if ( pUrlInfo->QueryScriptMapEntry() )
        {
            hr = straScriptMap.CopyW( pUrlInfo->QueryScriptMapEntry()->QueryExecutable()->QueryStr() );

            if ( FAILED( hr ) )
            {
                goto Exit;
            }

            filterMap.pszScriptMapEntry = straScriptMap.QueryStr();
        }

        fRet = pW3Context->NotifyFilters( SF_NOTIFY_URL_MAP,
                                          &filterMap,
                                          &fFinished );

        //
        // Ignore finished flag in this case since we really can't do much
        // to advance to finish (since an ISAPI is calling this)
        //

        if ( !fRet )
        {
            hr = HRESULT_FROM_WIN32( GetLastError() );
            goto Exit;
        }

        //
        // Remember the mapped path
        //

        if ( strcmp( straSavePhys.QueryStr(),
                     filterMap.pszPhysicalPath ) != 0 )
        {
            hr = strFilterPath.CopyA( (CHAR*) filterMap.pszPhysicalPath );
            if ( FAILED( hr ) )
            {
                goto Exit;
            }

            pstrFinalPhysical = &strFilterPath;
        }
        else
        {
            pstrFinalPhysical = pUrlInfo->QueryUrlTranslated();
        }
    }
    else
    {
        //
        // No filter is mapping, therefore just take the URL_INFO's physical
        // path
        //

        pstrFinalPhysical = pUrlInfo->QueryUrlTranslated();

        DBG_ASSERT( pstrFinalPhysical != NULL );
    }

    //
    // We don't accept short filename since they can break metabase
    // equivalency
    //

    if ( wcschr( pstrFinalPhysical->QueryStr(),
                 L'~' ) )
    {
        BOOL fShort = FALSE;
        DWORD dwError = CheckIfShortFileName(
                                pstrFinalPhysical->QueryStr(),
                                pW3Context->QueryImpersonationToken(),
                                &fShort );
        if ( dwError != ERROR_SUCCESS )
        {
            hr = HRESULT_FROM_WIN32( dwError );
            goto Exit;
        }

        if ( fShort )
        {
            hr = HRESULT_FROM_WIN32( ERROR_FILE_NOT_FOUND );
            goto Exit;
        }
    }

    //
    // Copy the physical path is requested
    //

    hr = pstrPhysicalPath->Copy( *pstrFinalPhysical );
    if ( FAILED( hr ) )
    {
        goto Exit;
    }

Exit:

    return hr;
}

DWORD
CheckIfShortFileName(
    IN WCHAR *          pszPath,
    IN HANDLE           hImpersonation,
    OUT BOOL *          pfShort
)
/*++
    Description:

        This function takes a suspected NT/Win95 short filename and checks if there's
        an equivalent long filename.  For example, c:\foobar\ABCDEF~1.ABC is the same
        as c:\foobar\abcdefghijklmnop.abc.

        NOTE: This function should be called unimpersonated - the FindFirstFile() must
        be called in the system context since most systems have traverse checking turned
        off - except for the UNC case where we must be impersonated to get network access.

    Arguments:

        pszPath - Path to check
        hImpersonation - Impersonation handle if this is a UNC path - can be NULL if not UNC
        pfShort - Set to TRUE if an equivalent long filename is found

    Returns:

        Win32 error on failure
--*/
{
    DWORD              err = NO_ERROR;
    WIN32_FIND_DATA    FindData;
    WCHAR *            psz;
    BOOL               fUNC;

    psz = wcschr( pszPath, L'~' );
    *pfShort = FALSE;
    fUNC = (*pszPath == L'\\');

    //
    //  Loop for multiple tildas - watch for a # after the tilda
    //

    while ( psz++ )
    {
        if ( *psz >= L'0' && *psz <= L'9' )
        {
            WCHAR   achTmp[MAX_PATH];
            WCHAR * pchEndSeg;
            WCHAR * pchBeginSeg;
            HANDLE  hFind;

            //
            //  Isolate the path up to the segment with the
            //  '~' and do the FindFirst with that path
            //

            pchEndSeg = wcschr( psz, L'\\' );
            if ( !pchEndSeg )
            {
                pchEndSeg = psz + wcslen( psz );
            }

            //
            //  If the string is beyond MAX_PATH then we allow it through
            //

            if ( ((INT) (pchEndSeg - pszPath)) >= MAX_PATH )
            {
                return NO_ERROR;
            }

            memcpy( achTmp,
                    pszPath,
                    (INT) (pchEndSeg - pszPath) * sizeof( WCHAR ) );
            achTmp[pchEndSeg - pszPath] = L'\0';

            if ( fUNC && hImpersonation )
            {
                if ( !SetThreadToken( NULL, hImpersonation ))
                {
                    return GetLastError();
                }
            }

            //
            // IVANPASH: Although it looks simpler to use GetLongPathName
            // instead of manually traversing the folders, we must use
            // FindFirstFileW, because GetLongPathName requires ACLs for
            // IIS_WPG from the root of the drive to work.
            //

            hFind = FindFirstFileW( achTmp, &FindData );

            if ( fUNC && hImpersonation )
            {
                RevertToSelf();
            }

            if ( hFind == INVALID_HANDLE_VALUE )
            {
                err = GetLastError();

                DBGPRINTF(( DBG_CONTEXT,
                            "FindFirst failed!! - \"%s\", error %d\n",
                            achTmp,
                            GetLastError() ));

                //
                //  If the FindFirstFile() fails to find the file then return
                //  success - the path doesn't appear to be a valid path which
                //  is ok.
                //

                if ( err == ERROR_FILE_NOT_FOUND ||
                     err == ERROR_PATH_NOT_FOUND ||
                     err == ERROR_INVALID_NAME )
                {
                    return NO_ERROR;
                }

                return err;
            }

            DBG_REQUIRE( FindClose( hFind ));

            //
            //  Isolate the last segment of the string which should be
            //  the potential short name equivalency
            //

            pchBeginSeg = wcsrchr( achTmp, L'\\' );
            DBG_ASSERT( pchBeginSeg );
            pchBeginSeg++;

            //
            //  If the last segment doesn't match the long name then this is
            //  the short name version of the path
            //

            if ( _wcsicmp( FindData.cFileName, pchBeginSeg ))
            {
                *pfShort = TRUE;
                return NO_ERROR;
            }
        }

        psz = wcschr( psz, L'~' );
    }

    return err;
}

HRESULT
URL_CONTEXT::OpenFile(
    CACHE_USER *            pFileUser,
    W3_FILE_INFO **         ppOpenFile,
    FILE_CACHE_ASYNC_CONTEXT * pAsyncContext,
    BOOL *                  pfHandledSync,
    BOOL                    fAllowNoBuffering,
    BOOL                    fCheckForExistenceOnly
)
/*++

Routine Description:

    Open the physical path for this request.  If a map path filter did some
    redirecting, we will use that path.  Otherwise we will just use the
    path determined by metadata and cached in the W3_URL_INFO

Arguments:

    pFileUser - User to open file as
    ppOpenFile - Set to file cache entry on success
    pAsyncContext - In case an async read is desired, context with callback information
    pfHandledSync - Did the open complete synchronously
    fAllowNoBuffering - Allow the file to be opened with FILE_FLAG_NO_BUFFERING
    fCheckForExistenceOnly - Only interested in existence of the file

Return Value:

    HRESULT

--*/
{
    HRESULT             hr;
    BOOL                fDoCache;

    DBG_ASSERT( QueryMetaData() != NULL );

    fDoCache = !QueryMetaData()->QueryNoCache();

    //
    // If an ISAPI filter changed the physical path, then we need to go
    // directly to the file cache.  Otherwise, we can go thru the
    // W3_URL_INFO which may already have the cached file associated
    //

    if ( _strPhysicalPath.IsEmpty() )
    {
        //
        // No filter.  Fast path :-)
        //

        DBG_ASSERT( _pUrlInfo != NULL );

        hr = _pUrlInfo->GetFileInfo( pFileUser,
                                     fDoCache,
                                     ppOpenFile,
                                     pAsyncContext,
                                     pfHandledSync,
                                     fAllowNoBuffering,
                                     fCheckForExistenceOnly );
    }
    else
    {
        //
        // Filter case.  Must lookup in file cache :-(
        //

        DBG_ASSERT( g_pW3Server->QueryFileCache() != NULL );

        hr = g_pW3Server->QueryFileCache()->GetFileInfo(
                                        _strPhysicalPath,
                                        QueryMetaData()->QueryDirmonConfig(),
                                        pFileUser,
                                        fDoCache,
                                        ppOpenFile,
                                        pAsyncContext,
                                        pfHandledSync,
                                        fAllowNoBuffering,
                                        fCheckForExistenceOnly );
    }

    return hr;
}

//static
HRESULT
URL_CONTEXT::Initialize(
    VOID
)
/*++

Routine Description:

    Initialize URL_CONTEXT lookaside

Arguments:

    None

Return Value:

    HRESULT

--*/
{
    return NO_ERROR;
}

//static
VOID
URL_CONTEXT::Terminate(
    VOID
)
/*++

Routine Description:

    Clean up URL_CONTEXT lookaside

Arguments:

    None

Return Value:

    HRESULT

--*/
{
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\iisplus\ulw3\w3filter.cxx ===
/*++

   Copyright    (c)    1999    Microsoft Corporation

   Module Name :
     w3filter.cxx

   Abstract:
     ISAPI Filter Support
 
   Author:
     Bilal Alam (balam)             8-Feb-2000

   Environment:
     Win32 - User Mode

   Project:
     ULW3.DLL
--*/

#include "precomp.hxx"
#include "rawconnection.hxx"
#include "iisextp.h"

//
// Filter globals
//

LIST_ENTRY              HTTP_FILTER_DLL::sm_FilterHead;
CRITICAL_SECTION        HTTP_FILTER_DLL::sm_csFilterDlls;
DWORD                   HTTP_FILTER_DLL::sm_cLoadedFilters;

FILTER_LIST *           FILTER_LIST::sm_pGlobalFilterList;
ALLOC_CACHE_HANDLER *   W3_FILTER_CONTEXT::sm_pachFilterContexts;

//
// Standard HTTP_FILTER_CONTEXT entry points
//

BOOL
WINAPI
FilterServerSupportFunction(
    struct _HTTP_FILTER_CONTEXT * pfc,
    enum SF_REQ_TYPE              SupportFunction,
    void *                        pData,
    ULONG_PTR                     ul,
    ULONG_PTR
)
/*++

Routine Description:

    Filter ServerSupportFunction implementation

Arguments:

    pfc - Used to get back the W3_FILTER_CONTEXT and W3_MAIN_CONTEXT pointers
    SupportFunction - SSF to invoke (see ISAPI docs)
    pData, ul, ul2 - Function specific data
    
Return Value:

    BOOL (use GetLastError() for error)

--*/
{
    W3_FILTER_CONTEXT *         pFilterContext;
    HRESULT                     hr;
    W3_CONTEXT *                pContext;
    CERT_CONTEXT_EX *           pCertContext;
    FILTER_LIST *               pFilterList;
    HTTP_FILTER_DLL *           pCurrentFilterDll;
    DWORD                       dwCurrentDll;
    BOOL                        fOriginalRecursionState = FALSE;
    
    //
    // Primitive parameter validation
    //

    if ( pfc == NULL ||
         pfc->ServerContext == NULL )
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        return FALSE;
    }
    
    pFilterContext = (W3_FILTER_CONTEXT *) pfc->ServerContext;
    DBG_ASSERT( pFilterContext->CheckSignature() );

    dwCurrentDll = pFilterContext->QueryCurrentDll();

    pFilterList = pFilterContext->QueryFilterList();
    DBG_ASSERT( pFilterList );

    if ( dwCurrentDll == INVALID_DLL )
    {
        pCurrentFilterDll = NULL;
    }
    else
    {
        pCurrentFilterDll = pFilterList->QueryDll( dwCurrentDll );
        DBG_ASSERT( pCurrentFilterDll );
    }

    //
    // It is OK for the maincontext to be NULL (in the case of a
    // END_OF_NET_SESSION) notification
    //
   
    if ( pFilterContext->QueryMainContext() != NULL )
    {
        pContext = pFilterContext->QueryMainContext()->QueryCurrentContext();
        DBG_ASSERT( pContext != NULL );
        DBG_ASSERT( pContext->CheckSignature() );
    }
    else
    {
        pContext = NULL;
    }

//
// HSE_REQ_GET_CERT_INFO_EX is not one of the enumerated
// filter commands.  This is a hack, but it's been publicly
// documented and needs to be supported.
//
// We have to disable warning level 4
// to allow this to work.
//
#pragma warning(push,3)

    switch ( SupportFunction )
    {
    case SF_REQ_SEND_RESPONSE_HEADER:
   
        if ( pContext == NULL )
        {   
            hr = HRESULT_FROM_WIN32( ERROR_NOT_SUPPORTED );
            goto Finished;
        }
        
        pContext->SetNeedFinalDone();
    
        //
        // Parse the status line
        //
        
        if ( pData == NULL )
        {
            pData = "200 OK";
        }
        
        hr = pContext->QueryResponse()->BuildResponseFromIsapi( pContext,
                                                                (CHAR*) pData,
                                                                (CHAR*) ul,
                                                                ul ? (DWORD)strlen( (CHAR*)ul ) : 0 );
        if ( FAILED( hr ) )
        {
            goto Finished;
        }
        
        //
        // Is the status is access denied, then set the sub status to 
        // "Denied by Filter"
        // 
    
        if ( pContext->QueryResponse()->QueryStatusCode() == 
             HttpStatusUnauthorized.statusCode )
        {
            pContext->QueryResponse()->SetStatus( HttpStatusUnauthorized,
                                                  Http401Filter );
        }

        //
        // It's possible that the notification calling into SSF has
        // already changed pFilterContext.  Go ahead and store it now.
        //

        if ( pCurrentFilterDll != NULL )
        {
            pFilterContext->SetClientContext( dwCurrentDll, pfc->pFilterContext );
            pCurrentFilterDll->SetHasSetContextBefore();
        }

        //
        // We want any filter notificaitons associated with this response
        // to apply to the current filter for the purpose of compatibility
        // with earlier versions of IIS.
        //

        fOriginalRecursionState = pFilterContext->QueryRecursion();

        pFilterContext->SetRecursion( FALSE );

        hr = pContext->SendResponse( W3_FLAG_SYNC |
                                     W3_FLAG_NO_ERROR_BODY |
                                     W3_FLAG_MORE_DATA |
                                     W3_FLAG_NO_CONTENT_LENGTH );

        pFilterContext->SetRecursion( fOriginalRecursionState );

        if ( FAILED( hr ) )
        {
            goto Finished;
        }
        
        break;

    case HSE_REQ_GET_CERT_INFO_EX:

        if ( pContext == NULL )
        {   
            hr = HRESULT_FROM_WIN32( ERROR_NOT_SUPPORTED );
            goto Finished;
        }
        
        pCertContext = (CERT_CONTEXT_EX*) pData;

        hr = pContext->GetCertificateInfoEx(
                pCertContext->cbAllocated,
                &( pCertContext->CertContext.dwCertEncodingType ),
                pCertContext->CertContext.pbCertEncoded,
                &( pCertContext->CertContext.cbCertEncoded ),
                &( pCertContext->dwCertificateFlags ) );
        break;
    
    case SF_REQ_NORMALIZE_URL:
        hr = NormalizeUrl( (LPSTR)pData );
        break;
        
    case SF_REQ_ADD_HEADERS_ON_DENIAL:
  
        hr = pFilterContext->AddDenialHeaders( (LPSTR) pData );
        break; 
        
    case SF_REQ_DISABLE_NOTIFICATIONS:

        hr = pFilterContext->DisableNotification( (DWORD) ul );
        break;

    case SF_REQ_GET_PROPERTY:
    
        if ( ul == SF_PROPERTY_INSTANCE_NUM_ID )
        {
            if ( pContext != NULL )
            {
                *((DWORD*)pData) = pContext->QueryRequest()->QuerySiteId();
            }
            else
            {
                *((DWORD*)pData) = 0;
            }
            
            hr = NO_ERROR;
        }
        else
        {
            hr = HRESULT_FROM_WIN32( ERROR_NOT_SUPPORTED );
        }
        break;
    
    default:
        DBG_ASSERT( FALSE );
        hr = HRESULT_FROM_WIN32( ERROR_NOT_SUPPORTED );
    }    

#pragma warning(pop)

Finished:
    if ( FAILED( hr ) )
    {
        SetLastError( WIN32_FROM_HRESULT( hr ) );
        return FALSE;
    }    
    return TRUE;
}

BOOL
WINAPI
FilterGetServerVariable(
    struct _HTTP_FILTER_CONTEXT * pfc,
    LPSTR                         lpszVariableName,
    LPVOID                        lpvBuffer,
    LPDWORD                       lpdwSize
)
/*++

Routine Description:

    Filter GetServerVariable() implementation

Arguments:

    pfc - Filter context
    lpszVariableName - Variable name
    lpvBuffer - Buffer to receive the server variable
    lpdwSize - On input, the size of the buffer, on output, the sized needed
    
    
Return Value:

    BOOL (use GetLastError() for error).  
    ERROR_INSUFFICIENT_BUFFER if larger buffer needed
    ERROR_INVALID_INDEX if the server variable name requested is invalid

--*/
{
    W3_FILTER_CONTEXT *             pFilterContext;
    HRESULT                         hr;
    W3_CONTEXT *                    pContext;
    
    //
    // Primitive parameter validation
    //

    if ( pfc == NULL ||
         pfc->ServerContext == NULL ||
         lpdwSize == NULL )
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        return FALSE;
    }
    
    pFilterContext = (W3_FILTER_CONTEXT *) pfc->ServerContext;
    DBG_ASSERT( pFilterContext->CheckSignature() );

    //
    // It is OK for the maincontext to be NULL (in the case of a
    // END_OF_NET_SESSION) notification
    //
   
    if ( pFilterContext->QueryMainContext() != NULL )
    {
        pContext = pFilterContext->QueryMainContext()->QueryCurrentContext();
        DBG_ASSERT( pContext != NULL );
        DBG_ASSERT( pContext->CheckSignature() );
    }
    else
    {
        pContext = NULL;
    }

    //
    // Get the variable (duh)
    //

    hr = SERVER_VARIABLE_HASH::GetServerVariable( pContext,
                                                  lpszVariableName,
                                                  (CHAR*) lpvBuffer,
                                                  lpdwSize );

    if ( FAILED( hr ) )
    {
        SetLastError( WIN32_FROM_HRESULT( hr ) );
        return FALSE;
    }

    return TRUE;
}

BOOL
WINAPI
FilterWriteClient(
    struct _HTTP_FILTER_CONTEXT * pfc,
    LPVOID                        Buffer,
    LPDWORD                       lpdwBytes,
    DWORD
)
/*++

Routine Description:

    Synchronous WriteClient() for filters

Arguments:

    pfc - Filter context
    Buffer - buffer to write to client
    lpdwBytes - On input, the size of the input buffer.  On output, the number
                of bytes sent
    dwReserved - Reserved
    
    
Return Value:

    BOOL (use GetLastError() for error).  

--*/
{
    W3_FILTER_CONTEXT *         pFilterContext;
    HRESULT                     hr;
    W3_CONTEXT *                pContext;
    W3_RESPONSE *               pResponse;
    FILTER_LIST *               pFilterList;
    HTTP_FILTER_DLL *           pCurrentFilterDll;
    DWORD                       dwCurrentDll;

    //
    // Primitive parameter validation
    //

    if ( pfc == NULL ||
         pfc->ServerContext == NULL ||
         Buffer == NULL )
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        return FALSE;
    }
    
    pFilterContext = (W3_FILTER_CONTEXT *) pfc->ServerContext;
    DBG_ASSERT( pFilterContext->CheckSignature() );

    dwCurrentDll = pFilterContext->QueryCurrentDll();

    pFilterList = pFilterContext->QueryFilterList();
    DBG_ASSERT( pFilterList );

    pCurrentFilterDll = pFilterList->QueryDll( dwCurrentDll );
    DBG_ASSERT( pCurrentFilterDll );


    //
    // It is OK for the maincontext to be NULL (in the case of a
    // END_OF_NET_SESSION) notification
    //
   
    if ( pFilterContext->QueryMainContext() == NULL )
    {
        SetLastError( ERROR_NOT_SUPPORTED );
        return FALSE;
    }
    
    pContext = pFilterContext->QueryMainContext()->QueryCurrentContext();
    DBG_ASSERT( pContext != NULL );
    DBG_ASSERT( pContext->CheckSignature() );

    pResponse = pContext->QueryResponse();
    DBG_ASSERT( pResponse->CheckSignature() );

    // Just like an extension which calls WriteClient(), a filter doing so
    // requires us to do a final send
    //
    
    pContext->SetNeedFinalDone();

    // It's possible that the notification calling into SSF has
    // already changed pFilterContext.  Go ahead and store it now.
    //

    pFilterContext->SetClientContext( dwCurrentDll, pfc->pFilterContext );
    pCurrentFilterDll->SetHasSetContextBefore();


    //
    // Now send the data non-intrusively
    //
    
    hr = pResponse->FilterWriteClient( pContext,
                                       Buffer,
                                       *lpdwBytes );
    if ( FAILED( hr ) )
    {
        SetLastError( WIN32_FROM_HRESULT( hr ) );
        return FALSE;
    }
    
    return TRUE;
}

VOID *
WINAPI
FilterAllocateMemory(
    struct _HTTP_FILTER_CONTEXT * pfc,
    DWORD                         cbSize,
    DWORD
)
/*++

Routine Description:

    Used by filters to allocate memory freed on connection close

Arguments:

    pfc - Filter context
    cbSize - Amount to allocate
    dwReserved - Reserved
    
    
Return Value:

    A pointer to the allocated memory

--*/
{
    W3_FILTER_CONTEXT *         pFilterContext;

    //
    // Primitive parameter validation
    //

    if ( pfc == NULL ||
         pfc->ServerContext == NULL )
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        return NULL;
    }
    
    pFilterContext = (W3_FILTER_CONTEXT *) pfc->ServerContext;
    DBG_ASSERT( pFilterContext->CheckSignature() );

    return pFilterContext->AllocateFilterMemory( cbSize );
}

BOOL
WINAPI
FilterAddResponseHeaders(
    HTTP_FILTER_CONTEXT * pfc,
    LPSTR                 lpszHeaders,
    DWORD
)
/*++

Routine Description:

    Add response headers to whatever response eventually gets sent

Arguments:

    pfc - Filter context
    lpszHeaders - Headers to send (\r\n delimited)
    dwReserved - Reserved
    
Return Value:

    BOOL (use GetLastError() for error).  

--*/
{
    W3_FILTER_CONTEXT *         pFilterContext;
    HRESULT                     hr;
    W3_CONTEXT *                pContext;

    //
    // Primitive parameter validation
    //

    if ( pfc == NULL ||
         pfc->ServerContext == NULL || 
         lpszHeaders == NULL )
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        return FALSE;
    }
    
    pFilterContext = (W3_FILTER_CONTEXT *) pfc->ServerContext;
    DBG_ASSERT( pFilterContext->CheckSignature() );

    //
    // It is OK for the maincontext to be NULL (in the case of a
    // END_OF_NET_SESSION) notification
    //
   
    if ( pFilterContext->QueryMainContext() == NULL )
    {
        SetLastError( ERROR_NOT_SUPPORTED );
        return FALSE;
    }
    
    pContext = pFilterContext->QueryMainContext()->QueryCurrentContext();
    DBG_ASSERT( pContext != NULL );
    DBG_ASSERT( pContext->CheckSignature() );
   
    hr = pFilterContext->AddResponseHeaders( lpszHeaders );
    if ( FAILED( hr ) )
    {
        SetLastError( WIN32_FROM_HRESULT( hr ) );
        return FALSE;
    }
    
    return TRUE;
}

inline char AsciiCharToLower( const CHAR chA ) 
/*++

Routine Description:

    Ascii convert char to lowercase

Arguments:

    chA - character to be converted
    
Return Value:

    lowercase equivalent of chA 
    if it was in the range A-Z otherwise it returns input parameter chA

--*/    
{
        return (char)( ( chA <= 'Z' && chA >= 'A' ) ?( chA + ('a'-'A') ): chA );
}
    

BOOL AsciiStriEq( PCHAR pszA, PCHAR pszB )
/*++

Routine Description:

    Ascii locale independent comparison of 2 strings 
    (second of which must always be lowercase)

Arguments:

    pszA - first string 
    pszB - second string to compare
    
Return Value:

    BOOL TRUE if 2 strings equal, false if they don't

--*/
{
    while ( AsciiCharToLower(*pszA) == AsciiCharToLower( *(pszB++) ) )
    {
        if ( *(pszA++) == '\0' )
        {
            return TRUE;
        }
    }

    return FALSE;
}

//
// Preproc headers entry points
//

BOOL
WINAPI
GetFilterHeader(
    struct _HTTP_FILTER_CONTEXT * pfc,
    LPSTR                         lpszName,
    LPVOID                        lpvBuffer,
    LPDWORD                       lpdwSize
)
/*++

Routine Description:

    Used by PREPROC_HEADER filters to get request headers

Arguments:

    pfc - Filter context
    lpszName - Name of header to get (suffixed with ':' unless special
               case of 'url', 'version', method'
    lpvBuffer - Filled with header value
    lpdwSize - on input, size of input buffer, on output, size needed
    
Return Value:

    BOOL (use GetLastError() for error).  

--*/
{
    W3_FILTER_CONTEXT *         pFilterContext;
    STACK_STRA(                 strValue, 128 );
    HRESULT                     hr;
    W3_CONTEXT *                pContext;
    DWORD                       cchName;

    //
    // Primitive parameter validation
    //

    if ( pfc == NULL ||
         pfc->ServerContext == NULL ||
         lpszName == NULL ||
         lpdwSize == NULL )
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        return FALSE;
    }
    
    pFilterContext = (W3_FILTER_CONTEXT *) pfc->ServerContext;
    DBG_ASSERT( pFilterContext->CheckSignature() );
    
    pContext = pFilterContext->QueryMainContext()->QueryCurrentContext();
    DBG_ASSERT( pContext != NULL );
    DBG_ASSERT( pContext->CheckSignature() );

    //
    // Aargh.  Handle the "URL", "METHOD", "VERSION" cases here
    //
    
    if ( AsciiStriEq( lpszName, "url" )  )
    {
        hr = pContext->QueryRequest()->GetRawUrl( &strValue );
    }
    else if ( AsciiStriEq( lpszName, "method" ) )
    {
        hr = pContext->QueryRequest()->GetVerbString( &strValue );
    }
    else if ( AsciiStriEq( lpszName, "version" ) )
    {
        hr = pContext->QueryRequest()->GetVersionString( &strValue );
    }
    else 
    { 
        STACK_STRA(                 strName, 64 );
        
        //
        // A real header
        //
        // We expect that the name provided by the caller will
        // end in a ':'.  We'll validate that assumption now, and
        // then strip it for further processing.
        //

        cchName = (DWORD)strlen( lpszName );

        if ( cchName <= 1 ||
             lpszName[ cchName - 1 ] != ':' )
        {
            hr = HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
            goto Finished;
        }
    
        hr = strName.Copy( (CHAR*) lpszName, 
                           *lpszName ? cchName - 1 : 0 );
        if ( FAILED( hr ) )
        {
            goto Finished;
        }

        hr = pContext->QueryRequest()->GetHeader( strName,
                                                  &strValue );
    }
    
    if ( FAILED( hr ) )
    {
        goto Finished;
    }

    //
    // Did caller provide enough space for value
    //

    hr = strValue.CopyToBuffer( (CHAR*) lpvBuffer, lpdwSize );

Finished:    
    if ( FAILED( hr ) )
    {
        SetLastError( WIN32_FROM_HRESULT( hr ) );
        return FALSE;
    }
    
    return TRUE;
}

BOOL
WINAPI
SetFilterHeader(
    struct _HTTP_FILTER_CONTEXT * pfc,
    LPSTR                         lpszName,
    LPSTR                         lpszValue
)
/*++

Routine Description:

    Used by PREPROC_HEADER filters to set request headers

Arguments:

    pfc - Filter context
    lpszName - Name of header to set (suffixed with ':' unless special
               case of 'url', 'version', method'
    lpszValue - Value of header being set (old value will be replaced)
    
Return Value:

    BOOL (use GetLastError() for error).  

--*/
{
    W3_FILTER_CONTEXT *         pFilterContext;
    W3_CONTEXT *                pContext;
    STACK_STRA(                 strHeaderName, 128 );
    STACK_STRA(                 strHeaderValue, 128 );
    LPSTR                       pCursor = NULL;
    ULONG                       ulHeaderIndex;
    DWORD                       cchName;
    HRESULT                     hr;

    //
    // Primitive parameter validation
    //

    if ( pfc == NULL ||
         pfc->ServerContext == NULL ||
         lpszName == NULL )
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        return FALSE;
    }
    
    pFilterContext = (W3_FILTER_CONTEXT*) pfc->ServerContext;
    DBG_ASSERT( pFilterContext->CheckSignature() );
    
    pContext = pFilterContext->QueryMainContext()->QueryCurrentContext();
    DBG_ASSERT( pContext != NULL );
    DBG_ASSERT( pContext->CheckSignature() );
   
    //
    // Get the new header value
    //
    
    hr = strHeaderValue.Copy( lpszValue ? lpszValue : "" );
    if ( FAILED( hr ) ) 
    {
        goto Finished;
    }

    //
    // Strip anything after '\r' or '\n' for IIS 5 compatibility
    //

    pCursor = strchr( strHeaderValue.QueryStr(), '\r' );

    if ( pCursor )
    {
        *pCursor = '\0';
    }
   
    pCursor = strchr( strHeaderValue.QueryStr(), '\n' );

    if ( pCursor )
    {
        *pCursor = '\0';
    }

    strHeaderValue.SetLen( strlen( strHeaderValue.QueryStr() ) );

    //
    // Check for "URL", "METHOD", and "VERSION
    //

    if ( _stricmp( lpszName, "url" ) == 0 )
    {
        hr = pContext->QueryRequest()->SetUrlA( strHeaderValue );

        //
        // If the filter changed the URL, then we need to disable
        // caching for this request.  This will allow URL mapping filters
        // to declare themselves as cache friendly.
        //

        pContext->DisableUlCache();
    } 
    else if ( _stricmp( lpszName, "method" ) == 0 )
    {
        hr = pContext->QueryRequest()->SetVerb( strHeaderValue );
    }
    else if ( _stricmp( lpszName, "version" ) == 0 )
    {
        hr = pContext->QueryRequest()->SetVersion( strHeaderValue );
    }
    else
    {
        //
        // A real header
        //
        // We expect that the name provided by the caller will
        // end in a ':'.  We'll validate that assumption now, and
        // then strip it for further processing.
        //

        cchName = (DWORD)strlen( lpszName );

        if ( cchName <= 1 ||
             lpszName[ cchName - 1 ] != ':' )
        {
            hr = HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
            goto Finished;
        }

        hr = strHeaderName.Copy( lpszName, 
                                 *lpszName ? cchName - 1 : 0 );
        if ( FAILED( hr ) )
        {
            goto Finished;
        }

        //
        // Known header or not?  We may need to take special action on
        // some known headers.  For example, if the Connection header
        // changes, we need to re-evaluate whether disconnect should be
        // set or not.
        //

        ulHeaderIndex = REQUEST_HEADER_HASH::GetIndex( strHeaderName.QueryStr() );

        if ( ulHeaderIndex == UNKNOWN_INDEX )
        {
            pContext->QueryRequest()->DeleteHeader( strHeaderName.QueryStr() );
        
            if ( lpszValue != NULL && *lpszValue != '\0' )
            {
                hr = pContext->QueryRequest()->SetHeader( strHeaderName,
                                                          strHeaderValue );
            }
        }
        else
        {
            pContext->QueryRequest()->DeleteKnownHeader( ulHeaderIndex );

            if ( lpszValue != NULL && *lpszValue != '\0' )
            {
                hr = pContext->QueryRequest()->SetKnownHeader( ulHeaderIndex,
                                                               strHeaderValue );
            }

            if ( ulHeaderIndex == HttpHeaderConnection )
            {
                pContext->SetDisconnect( pContext->QueryRequest()->QueryClientWantsDisconnect() );
            }
        }

    }

Finished:    
    if ( FAILED( hr ) )
    {
        SetLastError( WIN32_FROM_HRESULT( hr ) );
        return FALSE;
    }
    
    return TRUE;
}

BOOL
WINAPI
AddFilterHeader(
    struct _HTTP_FILTER_CONTEXT * pfc,
    LPSTR                         lpszName,
    LPSTR                         lpszValue
)
/*++

Routine Description:

    Used by PREPROC_HEADER filters to append request headers

Arguments:

    pfc - Filter context
    lpszName - Name of header to set
    lpszValue - Value of header being set (old value will be replaced)
    
Return Value:

    BOOL (use GetLastError() for error).  

--*/
{
    W3_FILTER_CONTEXT *         pFilterContext;
    W3_CONTEXT *                pContext;
    STACK_STRA(                 strHeaderName, 128 );
    STACK_STRA(                 strHeaderValue, 128 );
    LPSTR                       pCursor = NULL;
    DWORD                       cchName;
    HRESULT                     hr;

    //
    // Primitive parameter validation
    //

    if ( pfc == NULL ||
         pfc->ServerContext == NULL ||
         lpszName == NULL ||
         lpszValue == NULL )
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        return FALSE;
    }
    
    pFilterContext = (W3_FILTER_CONTEXT*) pfc->ServerContext;
    DBG_ASSERT( pFilterContext->CheckSignature() );
    
    pContext = pFilterContext->QueryMainContext()->QueryCurrentContext();
    DBG_ASSERT( pContext != NULL );
    DBG_ASSERT( pContext->CheckSignature() );
   
    //
    // Get the new header value
    //
    
    hr = strHeaderValue.Copy( *lpszValue ? lpszValue : " " );
    if ( FAILED( hr ) ) 
    {
        goto Finished;
    }

    //
    // Strip anything after '\r' or '\n' for IIS 5 compatibility
    //

    pCursor = strchr( strHeaderValue.QueryStr(), '\r' );

    if ( pCursor )
    {
        *pCursor = '\0';
    }
   
    pCursor = strchr( strHeaderValue.QueryStr(), '\n' );

    if ( pCursor )
    {
        *pCursor = '\0';
    }

    strHeaderValue.SetLen( strlen( strHeaderValue.QueryStr() ) );

    //
    // We expect that the name provided by the caller will
    // end in a ':'.  We'll validate that assumption now, and
    // then strip it for further processing.
    //

    cchName = (DWORD)strlen( lpszName );

    if ( cchName <= 1 ||
         lpszName[ cchName - 1 ] != ':' )
    {
        hr = HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
        goto Finished;
    }
    
    hr = strHeaderName.Copy( lpszName, 
                             *lpszName ? cchName - 1 : 0 );
    if ( FAILED( hr ) )
    {
        goto Finished;
    }
        
    hr = pContext->QueryRequest()->SetHeader( strHeaderName,
                                              strHeaderValue,
                                              TRUE );

Finished:    
    if ( FAILED( hr ) )
    {
        SetLastError( WIN32_FROM_HRESULT( hr ) );
        return FALSE;
    }
    
    return TRUE;
}

//
// SEND_RESPONSE notification helpers
//

BOOL
WINAPI
GetSendHeader(
    struct _HTTP_FILTER_CONTEXT * pfc,
    LPSTR                         lpszName,
    LPVOID                        lpvBuffer,
    LPDWORD                       lpdwSize
)
/*++

Routine Description:

    Get a response header

Arguments:

    pfc - Filter context
    lpszName - Name of header to get
    lpvBuffer - Filled with header
    lpdwSize - On input the size of the buffer, on output, the size needed
    
Return Value:

    BOOL (use GetLastError() for error).  

--*/
{
    W3_FILTER_CONTEXT *         pFilterContext;
    W3_CONTEXT *                pContext;
    STACK_STRA(                 strHeaderName, 128 );
    STACK_STRA(                 strHeaderValue, 128 );
    DWORD                       cchName;
    HRESULT                     hr;

    //
    // Primitive parameter validation
    //

    if ( pfc == NULL ||
         pfc->ServerContext == NULL ||
         lpszName == NULL ||
         lpdwSize == NULL )
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        return FALSE;
    }
    
    pFilterContext = (W3_FILTER_CONTEXT*) pfc->ServerContext;
    DBG_ASSERT( pFilterContext->CheckSignature() );
    
    pContext = pFilterContext->QueryMainContext()->QueryCurrentContext();
    DBG_ASSERT( pContext != NULL );
    DBG_ASSERT( pContext->CheckSignature() );

    //
    // Check for special name "status"
    //

    if ( strcmp( lpszName, "status" ) == 0 )
    {
        hr = pContext->QueryResponse()->GetStatusLine( &strHeaderValue );
        if ( FAILED( hr ) )
        {
            goto Finished;
        }
    }
    else
    {
        //
        // A real header
        //
        // We expect that the name provided by the caller will
        // end in a ':'.  We'll validate that assumption now, and
        // then strip it for further processing.
        //

        cchName = (DWORD)strlen( lpszName );

        if ( cchName <= 1 ||
             lpszName[ cchName - 1 ] != ':' )
        {
            hr = HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
            goto Finished;
        }

        hr = strHeaderName.Copy( lpszName, 
                                 *lpszName ? cchName - 1 : 0 );
        if ( FAILED( hr ) )
        {
            goto Finished;
        }

        hr = pContext->QueryResponse()->GetHeader( strHeaderName.QueryStr(),
                                                   &strHeaderValue );
        if ( FAILED( hr ) )
        {
            goto Finished;
        }
    }
    
    //
    // Copy into ANSI buffer
    //
    
    hr = strHeaderValue.CopyToBuffer( (CHAR*) lpvBuffer,
                                      lpdwSize );

Finished:
    if ( FAILED( hr ) )
    {
        SetLastError( WIN32_FROM_HRESULT( hr ) );
        return FALSE;
    }
    
    return TRUE;
}

BOOL
WINAPI
SetSendHeader(
    struct _HTTP_FILTER_CONTEXT * pfc,
    LPSTR                         lpszName,
    LPSTR                         lpszValue
)
/*++

Routine Description:

    Set a response header

Arguments:

    pfc - Filter context
    lpszName - Name of header to set
    lpszValue - Value of header to set
    
Return Value:

    BOOL (use GetLastError() for error).  

--*/
{
    W3_FILTER_CONTEXT *         pFilterContext;
    W3_CONTEXT *                pContext;
    STACK_STRA(                 strHeaderName, 128 );
    STACK_STRA(                 strHeaderValue, 128 );
    DWORD                       cchName;
    HRESULT                     hr;

    //
    // Primitive parameter validation
    //

    if ( pfc == NULL ||
         pfc->ServerContext == NULL ||
         lpszName == NULL )
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        return FALSE;
    }
    
    pFilterContext = (W3_FILTER_CONTEXT*) pfc->ServerContext;
    DBG_ASSERT( pFilterContext->CheckSignature() );
    
    pContext = pFilterContext->QueryMainContext()->QueryCurrentContext();
    DBG_ASSERT( pContext != NULL );
    DBG_ASSERT( pContext->CheckSignature() );

    //
    // We expect that the name provided by the caller will
    // end in a ':'.  We'll validate that assumption now, and
    // then strip it for further processing.
    //

    cchName = (DWORD)strlen( lpszName );

    if ( cchName <= 1 ||
         lpszName[ cchName - 1 ] != ':' )
    {
        hr = HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
        goto Finished;
    }

    hr = strHeaderName.Copy( lpszName, 
                             *lpszName ? cchName - 1 : 0 );
    if ( FAILED( hr ) )
    {
        goto Finished;   
    } 
    
    //
    // First delete existing header, then add new one
    //
    
    hr = pContext->QueryResponse()->DeleteHeader( strHeaderName.QueryStr() );
    if ( FAILED( hr ) )
    {
        goto Finished;
    }
    
    if ( lpszValue != NULL && *lpszValue != '\0' )
    {
        hr = strHeaderValue.Copy( lpszValue );
        if ( FAILED( hr ) )
        {
            goto Finished;
        }

        if (strHeaderName.QueryCCH() > MAXUSHORT ||
            strHeaderValue.QueryCCH() > MAXUSHORT)
        {
            hr = HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);
            goto Finished;
        }

        hr = pContext->QueryResponse()->SetHeader( strHeaderName.QueryStr(),
                                                   (USHORT)strHeaderName.QueryCCH(),
                                                   strHeaderValue.QueryStr(),
                                                   (USHORT)strHeaderValue.QueryCCH(),
                                                   FALSE );
    }

Finished:
    if ( FAILED( hr ) )
    {
        SetLastError( WIN32_FROM_HRESULT( hr ) );
        return FALSE;
    }
    return TRUE;
}

BOOL
WINAPI
AddSendHeader(
    struct _HTTP_FILTER_CONTEXT * pfc,
    LPSTR                         lpszName,
    LPSTR                         lpszValue
)
/*++

Routine Description:

    Add a response header

Arguments:

    pfc - Filter context
    lpszName - Name of header to set
    lpszValue - Value of header to set
    
Return Value:

    BOOL (use GetLastError() for error).  

--*/
{
    W3_FILTER_CONTEXT *         pFilterContext;
    W3_CONTEXT *                pContext;
    STACK_STRA(                 strHeaderName, 128 );
    STACK_STRA(                 strHeaderValue, 128 );
    DWORD                       cchName;
    HRESULT                     hr;

    //
    // Primitive parameter validation
    //

    if ( pfc == NULL ||
         pfc->ServerContext == NULL ||
         lpszName == NULL ||
         lpszValue == NULL )
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        return FALSE;
    }
    
    pFilterContext = (W3_FILTER_CONTEXT*) pfc->ServerContext;
    DBG_ASSERT( pFilterContext->CheckSignature() );
    
    pContext = pFilterContext->QueryMainContext()->QueryCurrentContext();
    DBG_ASSERT( pContext != NULL );
    DBG_ASSERT( pContext->CheckSignature() );

    //
    // We expect that the name provided by the caller will
    // end in a ':'.  We'll validate that assumption now, and
    // then strip it for further processing.
    //

    cchName = (DWORD)strlen( lpszName );

    if ( cchName <= 1 ||
         lpszName[ cchName - 1 ] != ':' )
    {
        hr = HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
        goto Finished;
    }

    hr = strHeaderName.Copy( lpszName, 
                             *lpszName ? cchName - 1 : 0 );
    if ( FAILED( hr ) )
    {
        goto Finished;   
    } 
    
    hr = strHeaderValue.Copy( *lpszValue ? lpszValue : " " );
    if ( FAILED( hr ) )
    {
        goto Finished;
    }

    if (strHeaderName.QueryCCH() > MAXUSHORT ||
        strHeaderValue.QueryCCH() > MAXUSHORT)
    {
        hr = HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);
        goto Finished;
    }

    hr = pContext->QueryResponse()->SetHeader( strHeaderName.QueryStr(),
                                               (USHORT)strHeaderName.QueryCCH(),
                                               strHeaderValue.QueryStr(),
                                               (USHORT)strHeaderValue.QueryCCH(),
                                               TRUE,
                                               FALSE,
                                               TRUE,
                                               TRUE );

Finished:
    if ( FAILED( hr ) )
    {
        SetLastError( WIN32_FROM_HRESULT( hr ) );
        return FALSE;
    }
    return TRUE;
}

BOOL
WINAPI
GetUserToken(
    struct _HTTP_FILTER_CONTEXT * pfc,
    HANDLE *                      phToken
)
/*++

Routine Description:

    Get impersonated user token

Arguments:

    pfc - Filter context
    phToken - Filled with impersonation token
    
Return Value:

    TRUE on success, FALSE on failure

--*/
{
    W3_FILTER_CONTEXT *    pFilterContext;
    W3_CONTEXT *           pContext;
    W3_USER_CONTEXT *      pW3UserContext;

    //
    // Primitive parameter validation
    //
    if ( !pfc ||
         !pfc->ServerContext ||
         !phToken )
    {
        DBGPRINTF(( DBG_CONTEXT,
              "[GetUserToken] Extension passed invalid parameters\r\n"));

        SetLastError( ERROR_INVALID_PARAMETER );
        return FALSE;
    }

    pFilterContext = (W3_FILTER_CONTEXT*) pfc->ServerContext;
    DBG_ASSERT( pFilterContext->CheckSignature() );
    
    pContext = pFilterContext->QueryMainContext()->QueryCurrentContext();
    DBG_ASSERT( pContext != NULL );
    DBG_ASSERT( pContext->CheckSignature() );

    pW3UserContext = pContext->QueryUserContext();
    DBG_ASSERT( pW3UserContext != NULL );
    DBG_ASSERT( pW3UserContext->CheckSignature() );

    *phToken = pW3UserContext->QueryImpersonationToken();
    
    return TRUE;
}

//
// Connection filter context
//

W3_FILTER_CONNECTION_CONTEXT::W3_FILTER_CONNECTION_CONTEXT(
    VOID
) : _pFilterContext( NULL )
{
    InitializeListHead( &_PoolHead );
    
    ZeroMemory( _rgContexts, sizeof( _rgContexts ) );
}

W3_FILTER_CONNECTION_CONTEXT::~W3_FILTER_CONNECTION_CONTEXT(
    VOID
)
{
    FILTER_POOL_ITEM *          pfpi;

    //
    // OK.  The connection is going away, we need to notify 
    // SF_NOTIFY_END_OF_NET_SESSION filters, if a filter context was
    // associated with this connection
    //
    
    if ( _pFilterContext != NULL )
    {
        if ( _pFilterContext->IsNotificationNeeded( SF_NOTIFY_END_OF_NET_SESSION ) )
        {
            _pFilterContext->NotifyEndOfNetSession();
        }
    
        _pFilterContext->DereferenceFilterContext();
        _pFilterContext = NULL;
    }

    //
    // Free pool items
    //

    while ( !IsListEmpty( &_PoolHead ) ) 
    {
        pfpi = CONTAINING_RECORD( _PoolHead.Flink,
                                  FILTER_POOL_ITEM,
                                  _ListEntry );

        RemoveEntryList( &pfpi->_ListEntry );

        delete pfpi;
    }
}

VOID
W3_FILTER_CONNECTION_CONTEXT::AddFilterPoolItem(
    FILTER_POOL_ITEM *          pFilterPoolItem
)
/*++

Routine Description:

    Add given filter pool item to this list

Arguments:

    pFilterPoolItem - Filter item to add

Return Value:

    None

--*/
{
    DBG_ASSERT( pFilterPoolItem != NULL );
    DBG_ASSERT( pFilterPoolItem->CheckSignature() );
    
    InsertHeadList( &_PoolHead, &(pFilterPoolItem->_ListEntry) );
}

VOID
W3_FILTER_CONNECTION_CONTEXT::AssociateFilterContext(
    W3_FILTER_CONTEXT *         pFilterContext
)
/*++

Routine Description:

    Called once per request to associate the current W3_FILTER_CONTEXT
    with the filter connection context.  This is the context that will be
    used when the connection dies and we need to determine which filters
    have registered for the END_OF_NET_SESSION notification

Arguments:

    pFilterContext - Current W3_FILTER_CONTEXT of the connection
    
Return Value:

    None

--*/
{
    //
    // Dereference the old context -> let it go away on its own
    //
        
    if ( _pFilterContext != NULL )
    {
        _pFilterContext->DereferenceFilterContext();
        _pFilterContext = NULL;
    }

    //
    // Attach to the new filter context
    //
    
    pFilterContext->ReferenceFilterContext();
    _pFilterContext = pFilterContext;
}

//
// Filter list, dll, and context implementations
//

HRESULT
HTTP_FILTER_DLL::LoadDll(
    MB *                        pMB,
    LPWSTR                      pszKeyName,
    BOOL *                      pfOpened,
    LPWSTR                      pszRelFilterPath,
    LPWSTR                      pszFilterDll
)
/*++

Routine Description:

    Load an ISAPI filter and add it to our filter cache

Arguments:

    pMB - Used to write diagnostics to the metabase 
    pszKeyName - Metabase path "lm/w3svc/1/filters" or "lm/w3svc/filters"
    pfOpened - *pfOpened TRUE if MB has been opened yet
    pszRelFilterPath - The path segment with the filter name 
    pszFilterDll - Physical path of ISAPI filter to load
    
Return Value:

    HRESULT

--*/
{
    HTTP_FILTER_VERSION             ver;
    DWORD                           dwError;
    HRESULT                         hr = NO_ERROR;
    STACK_STRU(                     strDescription, 256 );
    STACK_STRU(                     strExistingDescription, 256 );
    DWORD                           dwExistingFlags = 0;
    BOOL                            fWrite = FALSE;

    if ( pMB == NULL ||
         pszKeyName == NULL ||
         pfOpened == NULL ||
         pszRelFilterPath == NULL ||
         pszFilterDll == NULL )
    {
        DBG_ASSERT( FALSE );
        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }

    hr = _strName.Copy( pszFilterDll );
    if ( FAILED( hr ) )
    {
        return hr;
    }

    //
    // Load the actual DLL
    //
    
    _hModule = LoadLibraryEx( _strName.QueryStr(),
                              NULL,
                              LOAD_WITH_ALTERED_SEARCH_PATH );
    if ( _hModule == NULL )
    {
        dwError = GetLastError();
        
        DBGPRINTF(( DBG_CONTEXT,
                    "Unable to LoadLibrary ISAPI filter '%ws'.  Error = %d\n",
                    _strName.QueryStr(),
                    dwError ));
                    
        return HRESULT_FROM_WIN32( dwError );
    }
    
    //
    // Retrieve the entry points
    //
    
    _pfnSFVer = (PFN_SF_VER_PROC) GetProcAddress( _hModule,
                                                  SF_VERSION_ENTRY );
    
    _pfnSFProc = (PFN_SF_DLL_PROC) GetProcAddress( _hModule,
                                                   SF_DEFAULT_ENTRY );
                                                   
    _pfnSFTerm = (PFN_SF_TERM_PROC) GetProcAddress( _hModule,
                                                    SF_TERM_ENTRY );

    //
    // We require at least the FilterInit and HttpFilterProc exports
    //

    if ( !_pfnSFProc || !_pfnSFVer )
    {
        //
        // On HTTP_FILTER_DLL cleanup, don't call TerminateFilter
        //
        
        _pfnSFTerm = NULL;
        
        return HRESULT_FROM_WIN32( ERROR_PROC_NOT_FOUND );
    }
    
    //
    // Call the initialization routine
    //

    ver.dwServerFilterVersion = HTTP_FILTER_REVISION;
    ver.lpszFilterDesc[ 0 ] = '\0';
    ver.dwFlags = 0;

    if ( !_pfnSFVer( &ver ) )
    {
        return HRESULT_FROM_WIN32( GetLastError() );
    }
    
    //
    // Write out the returned description, notifications to the metabase
    // for consumption by the UI
    //
    
    hr = strDescription.CopyA( (CHAR*) ver.lpszFilterDesc );
    if ( FAILED( hr ) )
    {
        return hr;
    }
    
    if ( *pfOpened ||
         pMB->Open( pszKeyName,
                    METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE ) )
    {
        *pfOpened = TRUE;
       
        //
        // Check if the properties we're writing already exist in the 
        // metabase.  If they do, then leave them alone
        //
        
        if ( pMB->GetStr( pszRelFilterPath,
                          MD_FILTER_DESCRIPTION,
                          IIS_MD_UT_SERVER,
                          &strExistingDescription ) &&
             pMB->GetDword( pszRelFilterPath,
                            MD_FILTER_FLAGS,
                            IIS_MD_UT_SERVER,
                            &dwExistingFlags ) )
        {
            fWrite = !strExistingDescription.Equals( strDescription ) ||
                     dwExistingFlags != ver.dwFlags;
        }
        else
        {
            fWrite = TRUE;
        }
        
        if ( fWrite )
        {
            if ( !pMB->SetString( pszRelFilterPath,
                                  MD_FILTER_DESCRIPTION,
                                  IIS_MD_UT_SERVER,
                                  strDescription.QueryStr(),
                                  0 ) ||
                 !pMB->SetDword( pszRelFilterPath,
                                 MD_FILTER_FLAGS,
                                 IIS_MD_UT_SERVER,
                                 ver.dwFlags,
                                 0 ))
            {
                hr = HRESULT_FROM_WIN32( GetLastError() );
                return hr;
            }
        }
    }

    //
    // If the client didn't specify any of the secure port notifications,
    // supply them with the default of both
    //

    if ( !(ver.dwFlags & (SF_NOTIFY_SECURE_PORT | SF_NOTIFY_NONSECURE_PORT)))
    {
        ver.dwFlags |= (SF_NOTIFY_SECURE_PORT | SF_NOTIFY_NONSECURE_PORT);
    }

    _dwVersion      = ver.dwFilterVersion;
    
    _dwFlags        = (ver.dwFlags & SF_NOTIFY_NONSECURE_PORT) ? ver.dwFlags : 0;
    _dwSecureFlags  = (ver.dwFlags & SF_NOTIFY_SECURE_PORT) ? ver.dwFlags : 0;

    //
    // Put the new dll on the filter dll list
    //

    InsertHeadList( &sm_FilterHead, &_ListEntry );

    return NO_ERROR;
}

//static
HRESULT
HTTP_FILTER_DLL::OpenFilter(
    MB *                        pMB,
    LPWSTR                      pszKeyName,
    BOOL *                      pfOpened,
    LPWSTR                      pszRelFilterPath,
    LPWSTR                      pszFilterDll,
    BOOL                        fUlFriendly,
    HTTP_FILTER_DLL **          ppFilter
)
/*++

Routine Description:

    Checkout an ISAPI filter from cache.  If necessary load it for the 
    first time

Arguments:

    pMB - Used to write diagnostics to the metabase 
    pszKeyName - Metabase path "lm/w3svc/1/filters" or "lm/w3svc/filters"
    pfOpened - *pfOpened TRUE if MB has been opened yet
    pszRelFilterPath - The path segment with the filter name 
    pszFilterDll - Physical path of ISAPI filter to load
    fUlFriendly - Is this filter friendly with the UL cache?
    ppFilter - Set to point to an HTTP_FILTER_DLL on success
    
Return Value:

    HRESULT

--*/
{
    HTTP_FILTER_DLL *           pFilterDll = NULL;
    HRESULT                     hr = NO_ERROR;
    LIST_ENTRY *                pEntry;
    
    if ( pMB == NULL ||
         pszKeyName == NULL ||
         pfOpened == NULL ||
         pszRelFilterPath == NULL ||
         pszFilterDll == NULL ||
         ppFilter == NULL )
    {
        DBG_ASSERT( FALSE );
        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }
    
    //
    // Hold the global lock while we iterate thru loaded ISAPI filters
    // 
   
    EnterCriticalSection( &sm_csFilterDlls );

    for ( pEntry = sm_FilterHead.Flink;
          pEntry != &sm_FilterHead;
          pEntry = pEntry->Flink )
    {
        pFilterDll = CONTAINING_RECORD( pEntry, HTTP_FILTER_DLL, _ListEntry );

        DBG_ASSERT( pFilterDll->CheckSignature() );

        if ( _wcsicmp( pszFilterDll, pFilterDll->QueryName()->QueryStr() ) == 0 )
        {
            pFilterDll->Reference();
            break;
        }
        
        pFilterDll = NULL;
    }
    
    //
    // If pFilterDll is still NULL, then we haven't already loaded it
    //
    
    if ( pFilterDll == NULL )
    {
        //
        // First check whether we've already loaded MAX_FILTER filters.  If so, bail
        //
        
        if ( sm_cLoadedFilters == MAX_FILTERS )
        {
            //
            // BUGBUG:  Might want to event log this case
            //
            
            hr = HRESULT_FROM_WIN32( ERROR_NOT_SUPPORTED );
            goto Finished;
        }
        
        //
        // Try to add it
        //
        
        pFilterDll = new HTTP_FILTER_DLL( fUlFriendly );
        if ( pFilterDll == NULL )
        {
            hr = HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );
            goto Finished;
        }
        
        hr = pFilterDll->LoadDll( pMB,
                                  pszKeyName,
                                  pfOpened,
                                  pszRelFilterPath, 
                                  pszFilterDll );
        if ( FAILED( hr ) )
        {
            // Log the failure
            LPCWSTR apsz[1];
            apsz[0] = pszFilterDll;
            g_pW3Server->LogEvent(W3_EVENT_FILTER_DLL_LOAD_FAILED,
                                  1,
                                  apsz,
                                  WIN32_FROM_HRESULT(hr));

            delete pFilterDll;
            pFilterDll = NULL;
            goto Finished;
        }
        
        sm_cLoadedFilters++;
    }
    
Finished:
    LeaveCriticalSection( &sm_csFilterDlls );
    
    *ppFilter = pFilterDll;
    return hr;
}

//static
HRESULT
HTTP_FILTER_DLL::Initialize(
    VOID
)
/*++

Routine Description:

    Global HTTP_FILTER_DLL cache initialization

Arguments:

    None
    
Return Value:

    HRESULT

--*/
{
    InitializeListHead( &sm_FilterHead );
    
    if ( !InitializeCriticalSectionAndSpinCount( &sm_csFilterDlls, 200 ) )
    {
        return HRESULT_FROM_WIN32( GetLastError() );
    }
    
    return NO_ERROR;
}

//static
VOID
HTTP_FILTER_DLL::Terminate(
    VOID
)
/*++

Routine Description:

    Global HTTP_FILTER_DLL cache cleanup.
    The actual HTTP_FILTER_DLL will get cleaned up as sites go away.  Sites
    hold references to HTTP_FILTER_DLLs thru filter lists

Arguments:

    None
    
Return Value:

    None

--*/
{
    DBG_ASSERT(IsListEmpty(&sm_FilterHead));

    DeleteCriticalSection( &sm_csFilterDlls );
}

HRESULT
FILTER_LIST::LoadFilter(
    MB *                    pMB,
    LPWSTR                  pszKeyName,
    BOOL *                  pfOpened,
    LPWSTR                  pszRelativeMBPath,
    LPWSTR                  pszFilterDll,
    BOOL                    fAllowRawRead,
    BOOL                    fUlFriendly
)
/*++

Routine Description:

    Add a filter to the the current filter list

Arguments:

    pMB - Used to write diagnostics to the metabase 
    pszKeyName - Metabase path "lm/w3svc/1/filters" or "lm/w3svc/filters"
    pfOpened - *pfOpened TRUE if MB has been opened yet
    pszRelFilterPath - The path segment with the filter name 
    pszFilterDll - Physical path of ISAPI filter to load
    fUlFriendly - Is this filter usable with the UL cache
    
Return Value:

    HRESULT

--*/
{
    HTTP_FILTER_DLL *       pFilterDll = NULL;
    HRESULT                 hr = NO_ERROR;
    BOOL                    fWrite = FALSE;
    DWORD                   dwExistingState = 0;
    DWORD                   dwExistingError = 0;
    
    //
    // Get a pointer to the filter (either by loading or checking out)
    //
    
    hr = HTTP_FILTER_DLL::OpenFilter( pMB,
                                      pszKeyName,
                                      pfOpened,
                                      pszRelativeMBPath,
                                      pszFilterDll,
                                      fUlFriendly,
                                      &pFilterDll );
    if ( FAILED( hr ) )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "Cannot load filter dll '%ws'.  hr = %x\n",
                    pszFilterDll,
                    hr ));
    
        if ( *pfOpened ||
             pMB->Open( pszKeyName,
                        METADATA_PERMISSION_READ |
                        METADATA_PERMISSION_WRITE ) )
        {
            *pfOpened = TRUE;
            
            pMB->SetDword( pszRelativeMBPath,
                           MD_WIN32_ERROR,
                           IIS_MD_UT_SERVER,
                           WIN32_FROM_HRESULT( hr ),
                           METADATA_VOLATILE );
            
            pMB->SetDword( pszRelativeMBPath,
                           MD_FILTER_STATE,
                           IIS_MD_UT_SERVER,
                           MD_FILTER_STATE_UNLOADED,
                           0 );
                           
            pMB->SetDword( pszRelativeMBPath,
                           MD_FILTER_FLAGS,
                           IIS_MD_UT_SERVER,
                           0,
                           0 );
        }
        
        return hr;
    }
    
    DBG_ASSERT( pFilterDll != NULL );

    //
    // Check that we do not accept any per-site read-raw filter
    //
    if (!fAllowRawRead &&
        (pFilterDll->QueryNotificationFlags() & SF_NOTIFY_READ_RAW_DATA))
    {
        LPCWSTR apsz[1];
        DWORD dwMessageId;
        apsz[0] = pszFilterDll;
        
        //
        // We could be disallowing read filters for two reasons
        // 1) The filter is not global
        // 2) We are running in Dedicated Application Mode
        //
        
        if ( g_pW3Server->QueryInBackwardCompatibilityMode() )
        {
            dwMessageId = W3_MSG_READ_RAW_MUST_BE_GLOBAL;
        }
        else
        {
            dwMessageId = W3_MSG_READ_RAW_MUST_USE_STANDARD_APPLICATION_MODE;
        }
    
        g_pW3Server->LogEvent( dwMessageId,
                               1,
                               apsz);

        DBGPRINTF((DBG_CONTEXT,
                   "Refusing READ_RAW filter on site (%S)\n",
                   pszFilterDll));

        if (*pfOpened ||
            pMB->Open(pszKeyName,
                      METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE))
        {
            *pfOpened = TRUE;

            pMB->SetDword( pszRelativeMBPath,
                           MD_WIN32_ERROR,
                           IIS_MD_UT_SERVER,
                           ERROR_INVALID_PARAMETER,
                           METADATA_VOLATILE);

            pMB->SetDword( pszRelativeMBPath,
                           MD_FILTER_STATE,
                           IIS_MD_UT_SERVER,
                           MD_FILTER_STATE_UNLOADED,
                           0);

            pMB->SetDword( pszRelativeMBPath,
                           MD_FILTER_FLAGS,
                           IIS_MD_UT_SERVER,
                           0,
                           0 );
        }

        pFilterDll->Dereference();
        return S_OK;
    }

    //
    // Write out that we successfully loaded the filter
    //
    
    if ( *pfOpened ||
         pMB->Open( pszKeyName, 
                    METADATA_PERMISSION_READ | 
                    METADATA_PERMISSION_WRITE ) )
    {
        *pfOpened = TRUE;

        if ( pMB->GetDword( pszRelativeMBPath,
                            MD_WIN32_ERROR,
                            IIS_MD_UT_SERVER,
                            &dwExistingError ) &&
             pMB->GetDword( pszRelativeMBPath,
                            MD_FILTER_STATE,
                            IIS_MD_UT_SERVER,
                            &dwExistingState ) )
        {
            fWrite = dwExistingError != NO_ERROR ||
                     dwExistingState != MD_FILTER_STATE_LOADED;
        }
        else
        {
            fWrite = TRUE;
        }
        
        if ( fWrite )
        {
            pMB->SetDword( pszRelativeMBPath,
                           MD_WIN32_ERROR,
                           IIS_MD_UT_SERVER,
                           NO_ERROR,
                           METADATA_VOLATILE );
                       
            pMB->SetDword( pszRelativeMBPath,
                           MD_FILTER_STATE,
                           IIS_MD_UT_SERVER,
                           MD_FILTER_STATE_LOADED,
                           0 );
        }
    }
    
    //
    // Now insert into array
    //

    hr = AddFilterToList( pFilterDll );
    if ( FAILED( hr ) )
    {
        pFilterDll->Dereference();
    }

    return hr;
}

HRESULT
FILTER_LIST::AddFilterToList(
    HTTP_FILTER_DLL *           pFilterDll
)
/*++

Routine Description:

    Do the filter list insertion

Arguments:

    pFilterDll - Filter to insert
    
Return Value:

    HRESULT

--*/
{
    //
    // Make sure there's a free entry in the filter list array, and
    // the secure/non-secure notification arrays (the latter two are used
    // in conjunction with filters disabling themselves per request
    //

    if ( (_cFilters+1) > (_buffFilterArray.QuerySize() / sizeof(PVOID)))
    {
        if ( !_buffFilterArray.Resize( (_cFilters + 5) * sizeof(PVOID)) )
        {
            return HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );
        }

        if ( !_buffSecureArray.Resize( (_cFilters + 5) * sizeof(DWORD)) )
        {
            return HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );
        }

        if ( !_buffNonSecureArray.Resize( (_cFilters + 5) * sizeof(DWORD)) )
        {
            return HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );
        }
    }
    
    //    
    // Find where pFilterDll goes in the list
    //

    for ( ULONG i = 0; i < _cFilters; i++ )
    {
        if ( (QueryDll(i)->QueryNotificationFlags() & SF_NOTIFY_ORDER_MASK)
           <  (pFilterDll->QueryNotificationFlags() & SF_NOTIFY_ORDER_MASK) )
        {
            break;
        }
    }

    //
    // And insert it into the array
    //

    memmove( (PVOID *) _buffFilterArray.QueryPtr() + i + 1,
             (PVOID *) _buffFilterArray.QueryPtr() + i,
             (_cFilters - i) * sizeof(PVOID) );

    (((HTTP_FILTER_DLL * *) (_buffFilterArray.QueryPtr())))[i] = pFilterDll;

    //
    // Add notification DWORDS to secure/non-secure arrays
    //

    memmove( (DWORD *) _buffSecureArray.QueryPtr() + i + 1,
             (DWORD *) _buffSecureArray.QueryPtr() + i,
             (_cFilters - i) * sizeof(DWORD) );

    ((DWORD*) _buffSecureArray.QueryPtr())[i] = pFilterDll->QuerySecureFlags();

    memmove( (DWORD *) _buffNonSecureArray.QueryPtr() + i + 1,
             (DWORD *) _buffNonSecureArray.QueryPtr() + i,
             (_cFilters - i) * sizeof(DWORD) );

    ((DWORD*) _buffNonSecureArray.QueryPtr())[i] = pFilterDll->QueryNonsecureFlags();

    _cFilters++;

    //
    // Segregate the secure and non-secure port notifications
    //
    
    _dwSecureNotifications |= pFilterDll->QuerySecureFlags();
    _dwNonSecureNotifications |= pFilterDll->QueryNonsecureFlags();
   
    //
    // Check the UL friendliness of the filter and reflect that for the
    // list's UL friendliness
    //
    
    if ( !pFilterDll->QueryIsUlFriendly() )
    {
        _fUlFriendly = FALSE;
    }
    
    return NO_ERROR;
}

HRESULT
FILTER_LIST::LoadFilters(
    LPWSTR                  pszMDPath,
    BOOL                    fAllowRawRead,
    BOOL                    fRequireAllFilters
)
/*++

Routine Description:

    The high level filter list routine to grok the metabase and load all
    appropriate filters.  This routine is called globally and once for each
    server instance (site)

Arguments:

    pszMDPath - Metabase path (either lm/w3svc or lm/w3svc/<n>)
    fAllowRawRead - Allow read raw filters
    fRequireAllFilters - Should this function fail if a filter couldn't be 
                         loaded
    
Return Value:

    HRESULT

--*/
{
    STACK_STRU(     strFilterKey, MAX_PATH );
    DWORD           cb;
    DWORD           fEnabled;
    WCHAR           achLoadOrder[ 1024 ];
    WCHAR           achDllName[ MAX_PATH + 1 ];
    LPWSTR          pszFilter;
    LPWSTR          pszComma;
    MB              mb( g_pW3Server->QueryMDObject() );
    BOOL            fOpened = FALSE;
    HRESULT         hr;
    DWORD           dwUlFriendly = 0;

    //
    // Add the obligatory "/filters"
    //

    hr = strFilterKey.Copy( pszMDPath );
    if ( FAILED( hr ) )
    {
        return hr;
    }

    hr = strFilterKey.Append( TEXT( IIS_MD_ISAPI_FILTERS ) );
    if ( FAILED( hr ) ) 
    {
        return hr;
    } 

    //
    // Loop through filter keys, if we can't access the metabase, we assume
    // success and continue
    //

    if ( mb.Open( strFilterKey.QueryStr(),
                  METADATA_PERMISSION_READ ) )
    {
        fOpened = TRUE;

        //
        // Get the filter load order.  This is a comma delimited 
        // list of filter subkey names.  Here, we parse thru the list
        //

        cb = sizeof( achLoadOrder );
        *achLoadOrder = L'\0';

        if ( mb.GetString( L"",
                           MD_FILTER_LOAD_ORDER,
                           IIS_MD_UT_SERVER,
                           achLoadOrder,
                           &cb,
                           0 ) )
        {
            pszFilter = achLoadOrder;

            while ( *pszFilter != L'\0' )
            {
                dwUlFriendly = 0;
                
                if ( !fOpened &&
                     !mb.Open( strFilterKey.QueryStr(),
                               METADATA_PERMISSION_READ ) )
                {
                    DBGPRINTF(( DBG_CONTEXT,
                                "CreateFilterList: Cannot open path %ws, error %lu\n",
                                strFilterKey.QueryStr(), 
                                GetLastError() ));
                    break;
                }

                fOpened = TRUE;

                pszComma = wcschr( pszFilter, L',' );
                if ( pszComma != NULL )
                {
                    *pszComma = L'\0';
                }

                while ( iswspace( *pszFilter ) )
                {
                    pszFilter++;
                }

                fEnabled = TRUE;

                mb.GetDword( pszFilter,
                             MD_FILTER_ENABLED,
                             IIS_MD_UT_SERVER,
                             &fEnabled );

                if ( fEnabled ) 
                {
                    //
                    // Is the filter friendly with the UL cache?
                    //
                    // If the read fails, we'll assume it is not
                    // (i.e. fUlFriendly is by default FALSE)
                    //

                    mb.GetDword( pszFilter,
                                 MD_FILTER_ENABLE_CACHE,
                                 IIS_MD_UT_SERVER,
                                 &dwUlFriendly );

                    cb = sizeof( achDllName );

                    if ( mb.GetString( pszFilter,
                                       MD_FILTER_IMAGE_PATH,
                                       IIS_MD_UT_SERVER,
                                       achDllName,
                                       &cb,
                                       0 ) )
                    {
                        mb.Close();
                        fOpened = FALSE;

                        hr = LoadFilter( &mb,
                                         strFilterKey.QueryStr(),
                                         &fOpened,
                                         pszFilter,
                                         achDllName,
                                         fAllowRawRead,
                                         !!dwUlFriendly );
                                         
                        if ( FAILED( hr ) && fRequireAllFilters )
                        {
                            LPCWSTR apsz[ 1 ];
                            
                            //
                            // Fatal to have a filter not load.  Bail
                            //
                            
                            apsz[ 0 ] = pszFilter;
                            
                            g_pW3Server->LogEvent( W3_EVENT_ALL_FILTERS_DID_NOT_LOAD,
                                                   1,
                                                   apsz,
                                                   WIN32_FROM_HRESULT( hr ) );                                                   
                            
                            return hr;
                        }
                    }
                }

                if ( pszComma != NULL )
                {
                    pszFilter = pszComma + 1;
                }
                else
                {
                    break;
                }
            }
        }
    }

    return NO_ERROR;
}

HRESULT
FILTER_LIST::InsertGlobalFilters(
    VOID
)
/*++

Routine Description:

    Transfers all of the global filters to the per-instance filter list

Parameters:

    None

Return Value:

    HRESULT

--*/
{
    DWORD               i;
    HTTP_FILTER_DLL *   pFilterDll;
    HRESULT             hr = NO_ERROR;

    for ( i = 0; i < sm_pGlobalFilterList->QueryFilterCount(); i++ )
    {
        //
        // Ignore the return code, an event gets logged in LoadFilter()
        // We allow raw read filters here as we're just duplicating the
        // global filter list
        //
        
        pFilterDll = sm_pGlobalFilterList->QueryDll( i );
        DBG_ASSERT( pFilterDll != NULL );
        
        pFilterDll->Reference();

        hr = AddFilterToList( sm_pGlobalFilterList->QueryDll( i ) );
        if ( FAILED( hr ) )
        {
            pFilterDll->Dereference();
            return hr;
        }
    }
    
    return NO_ERROR;
}

//static
HRESULT
FILTER_LIST::Initialize(
    VOID
)
/*++

Routine Description:

    Global FILTER_LIST initialization

Parameters:

    None

Return Value:

    HRESULT

--*/
{
    HRESULT             hr;
    
    DBG_ASSERT( sm_pGlobalFilterList == NULL );

    //
    // We keep one global list of filters
    //

    sm_pGlobalFilterList = new FILTER_LIST();
    if ( sm_pGlobalFilterList == NULL )
    {
        hr = HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );
        goto Failure;
    }
    
    //
    // Load global filters configured at the W3SVC level
    //

    //
    // Only load RawRead filters if we are in old mode
    //
    BOOL fLoadRawRead = g_pW3Server->QueryInBackwardCompatibilityMode();
    hr = sm_pGlobalFilterList->LoadFilters( L"/LM/W3SVC",
                                            fLoadRawRead,
                                            TRUE );
    if ( FAILED( hr ) )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "Error load global ISAPI filters.  hr = %x\n",
                    hr ));
        goto Failure;
    }
    
    return NO_ERROR;
    
Failure:
    if ( sm_pGlobalFilterList != NULL )
    {
        sm_pGlobalFilterList->Dereference();
        sm_pGlobalFilterList = NULL;
    }
    
    return hr;
}

//static
VOID
FILTER_LIST::Terminate(
    VOID
)
/*++

Routine Description:

    Cleanup global FILTER_LIST

Parameters:

    None

Return Value:
    
    None

--*/
{
    DBG_ASSERT( sm_pGlobalFilterList != NULL );
    
    //
    // We cleanup the global filter list just like any other list.  We 
    // dereference and let it cleanup "naturally"
    //
    
    sm_pGlobalFilterList->Dereference();
    sm_pGlobalFilterList = NULL;
}

//
// W3_FILTER_CONTEXT goo
//

W3_FILTER_CONTEXT::W3_FILTER_CONTEXT() 
  : _pMainContext( NULL ),
    _dwSecureNotifications( 0 ),
    _dwNonSecureNotifications( 0 ),
    _dwDeniedFlags( 0 ),
    _fNotificationsDisabled( FALSE ),
    _fInAccessDeniedNotification( FALSE ),
    _cRefs( 1 ),
    _pConnectionContext( NULL ),
    _dwCurrentFilter( INVALID_DLL ),
    _fRecurseIntoCurrentFilter( FALSE ),
    _fIsInlineContext( FALSE )
{
    _hfc.cbSize             = sizeof( _hfc );
    _hfc.Revision           = HTTP_FILTER_REVISION;
    _hfc.ServerContext      = (void *) this;
    _hfc.ulReserved         = 0;

    _hfc.ServerSupportFunction = FilterServerSupportFunction;
    _hfc.GetServerVariable     = FilterGetServerVariable;
    _hfc.AddResponseHeaders    = FilterAddResponseHeaders;
    _hfc.WriteClient           = FilterWriteClient;
    _hfc.AllocMem              = FilterAllocateMemory;

    _dwSignature = W3_FILTER_CONTEXT_SIGNATURE;
}

W3_FILTER_CONTEXT::~W3_FILTER_CONTEXT()
{
    if (_pFilterList)
    {
        _pFilterList->Dereference();
        _pFilterList = NULL;
    }

    _dwSignature = W3_FILTER_CONTEXT_SIGNATURE_FREE;
}

VOID
W3_FILTER_CONTEXT::InitializeFilterContext(
    BOOL                        fIsSecure,
    FILTER_LIST *               pFilterList,
    BOOL                        fInlineContext
)
/*++

Routine Description:

    Initialize filter context (stuff that should be done
    immediately after constructing)

Arguments:

    fIsSecure - Is this secure port request?
    pFilterList - Filter list (site filter list)
    fInlineContext - Is this an inline context

Return Value:

    VOID

--*/
{
    _pFilterList = pFilterList;
    if (_pFilterList != NULL)
    {
        _pFilterList->Reference();
    }

    _hfc.fIsSecurePort      = fIsSecure;
    
    _fIsInlineContext = fInlineContext;
}

VOID
W3_FILTER_CONTEXT::SetMainContext(
    W3_MAIN_CONTEXT *           pMainContext
)
/*++

Routine Description:

    Associate a main context with a filter context so that we can get 
    at the request state in filter notifications

Arguments:

    pMainContext - Main context to associate

Return Value:

    VOID

--*/
{
    _pMainContext = pMainContext;
}

W3_FILTER_CONNECTION_CONTEXT *
W3_FILTER_CONTEXT::QueryConnectionContext(
    BOOL                    fCreateIfNotFound
)
/*++

Routine Description:

    Find an connection context associated with this filter contxt.  
    Optionally create one if necessary

Arguments:

    fCreateIfNotFound - Create if not found (default TRUE)

Return Value:

    A W3_FILTER_CONNECTION_CONTEXT or NULL

--*/
{
    W3_CONNECTION *         pConnection = NULL;
    
    if ( _pConnectionContext == NULL )
    {
        //
        // If _pMainContext is NULL, then this being called in a
        // END_OF_NET_SESSION notification, which is kinda busted.
        //
        
        DBG_ASSERT( _pMainContext != NULL );
        
        pConnection = _pMainContext->QueryConnection( fCreateIfNotFound );
        if ( pConnection != NULL )
        {
            _pConnectionContext = pConnection->QueryFilterConnectionContext();
        
            //
            // Only associate this W3_FILTER_CONTEXT with the connection if
            // this is not an inline context
            //
            
            if ( !_fIsInlineContext )
            {
                _pConnectionContext->AssociateFilterContext( this );
            }
        }
    }
    
    return _pConnectionContext;
}

VOID 
W3_FILTER_CONTEXT::SetClientContext(
    DWORD                   dwCurrentFilter,
    VOID *                  pvContext
)
{
    W3_FILTER_CONNECTION_CONTEXT *      pConnectionContext;

    //
    // We're setting a client context.  If we don't already have a
    // connection context, we need to get it now
    //

    pConnectionContext = QueryConnectionContext( TRUE );
    if ( pConnectionContext != NULL )
    {        
        pConnectionContext->SetClientContext( dwCurrentFilter, pvContext );

        if ( _pMainContext != NULL )
        {
            _pMainContext->SetRawConnectionClientContext( dwCurrentFilter, pvContext );
        }
    }
    else
    {
        DBG_ASSERT( FALSE );
    }
}

BOOL
W3_FILTER_CONTEXT::NotifyAccessDenied(
    const CHAR *  pszURL,
    const CHAR *  pszPhysicalPath,
    BOOL *        pfFinished
    )
/*++

Routine Description:

    This method handles notification of all filters that handle the
    access denied notification

Arguments:

    pszURL - URL that was target of request
    pszPath - Physical path the URL mapped to
    pfFinished - Set to TRUE if no further processing is required

Return Value:

    TRUE if successful, FALSE on error

--*/
{
    HTTP_FILTER_ACCESS_DENIED   hfad;
    BOOL                        fRet;
    HRESULT                     hr;
    HTTP_SUB_ERROR              subError;

    //
    //  If these flags are not set, then somebody hasn't indicated the 
    //  filter flags yet.  We can do so now based on the set error response
    //

    if ( QueryDeniedFlags() == 0 )
    {
        DBG_ASSERT( QueryMainContext() != NULL );

        hr = QueryMainContext()->QueryResponse()->QuerySubError( &subError );
        if ( FAILED( hr ) )
        {
            return FALSE; 
        }
            
        if ( subError.mdSubError == MD_ERROR_SUB401_LOGON )
        {
            SetDeniedFlags( SF_DENIED_LOGON );
        }
        else if ( subError.mdSubError == MD_ERROR_SUB401_LOGON_CONFIG )
        {
            SetDeniedFlags( SF_DENIED_BY_CONFIG | SF_DENIED_LOGON );
        }
        else if ( subError.mdSubError == MD_ERROR_SUB401_LOGON_ACL )
        {
            SetDeniedFlags( SF_DENIED_RESOURCE );
        }
        else if ( subError.mdSubError == MD_ERROR_SUB401_APPLICATION )
        {
            SetDeniedFlags( SF_DENIED_APPLICATION );
        }
        else if ( subError.mdSubError == MD_ERROR_SUB401_FILTER )
        {
            SetDeniedFlags( SF_DENIED_FILTER );
        }
    }

    //
    //  Ignore the notification of a send "401 ..." if this notification
    //  generated it
    //

    if ( _fInAccessDeniedNotification )
    {
        return TRUE;
    }

    _fInAccessDeniedNotification = TRUE;

    //
    //  Fill out the url map structure
    //

    hfad.pszURL          = pszURL;
    hfad.pszPhysicalPath = pszPhysicalPath;
    hfad.dwReason        = QueryDeniedFlags();

    fRet = NotifyFilters( SF_NOTIFY_ACCESS_DENIED,
                          &hfad,
                          pfFinished );

    _fInAccessDeniedNotification = FALSE;

    return fRet;
}

BOOL
W3_FILTER_CONTEXT::NotifyFilters(
    DWORD                   dwNotificationType,
    PVOID                   pNotificationData,
    BOOL *                  pfFinished
)
/*++

Routine Description:

    Notify all filters for this context

Arguments:

    dwNotificationType - SF_NOTIFY*
    pNotificationData - Notification specific data
    pfFinished - Set to TRUE if we are done and should disconnect

Return Value:

    BOOL

--*/
{
    HTTP_FILTER_DLL *           pFilterDll;
    SF_STATUS_TYPE              sfStatus;
    DWORD                       i;
    PVOID                       pvtmp;
    PVOID                       pvCurrentClientContext;
    FILTER_LIST *               pFilterList;
    BOOL                        fRet = TRUE;
    HTTP_REQUEST_ID             RequestId;
    DWORD                       dwCurrentFilterOnEntry;

    if ( pfFinished == NULL )
    {
        DBG_ASSERT( FALSE );
        SetLastError( ERROR_INVALID_PARAMETER );
        return FALSE;
    }
    
    *pfFinished = FALSE;

    //
    // In certain cases, we can send a notification to a filter while we're still
    // processing another filter's notification. In that case, we need to make sure
    // we restore the current filter's context when we're done with the notifications
    //
    // We also need to preserve the _dwCurrentFilter state.
    //
    
    pvCurrentClientContext = _hfc.pFilterContext;
    dwCurrentFilterOnEntry = _dwCurrentFilter;
    
    pFilterList = _pFilterList;
    DBG_ASSERT( pFilterList != NULL );

    for ( i = 0; i < pFilterList->QueryFilterCount(); i++ )
    {
        pFilterDll = pFilterList->QueryDll( i ); 

        //
        // Notification flags are cached in the HTTP_FILTER object, but they're
        // only copied from the actual HTTP_FILTER_DLL object if a filter dll
        // disables a particular notification [sort of a copy-on-write scheme].
        // If a filter dll disables/changes a notification, we need to check the flags
        // in the HTTP_FILTER object, not those in the HTTP_FILTER_DLL object
        //
        
        if ( !QueryNotificationChanged() )
        {
            if ( !pFilterDll->IsNotificationNeeded( dwNotificationType,
                                                    _hfc.fIsSecurePort ) )
            {
                continue;
            }
        }
        else
        {
            if ( !IsDisableNotificationNeeded( i,
                                               dwNotificationType ) )
            {
                continue;
            }
        }

        //
        // Another slimy optimization.  If this filter has never associated
        // context with connection, then we don't have to do the lookup
        //
        
        if ( pFilterDll->QueryHasSetContextBefore() )
        {
            _hfc.pFilterContext = QueryClientContext( i );
        }
        else
        {
            _hfc.pFilterContext = NULL;
        }

        pvtmp = _hfc.pFilterContext;

        _dwCurrentFilter = i;

        if ( ETW_IS_TRACE_ON(ETW_LEVEL_CP) ) 
        {
            W3_MAIN_CONTEXT * pContext = QueryMainContext();
            if ( pContext != NULL ) 
            {
                DBG_ASSERT( pContext->QueryRequest() != NULL );
                RequestId = pContext->QueryRequest()->QueryRequestId();

                g_pEtwTracer->EtwTraceEvent( &IISFilterGuid,
                                             ETW_TYPE_START, 
                                             &RequestId, 
                                             sizeof(HTTP_REQUEST_ID),
                                             pFilterDll->QueryName()->QueryStr(),
                                             pFilterDll->QueryName()->QueryCB(),
                                             NULL, 
                                             0 );
            }
        }
        
        sfStatus = (SF_STATUS_TYPE)
                   pFilterDll->QueryEntryPoint()( &_hfc,
                                                  dwNotificationType,
                                                  pNotificationData );

        if ( ETW_IS_TRACE_ON(ETW_LEVEL_CP) ) 
        {
            g_pEtwTracer->EtwTraceEvent( &IISFilterGuid,
                                         ETW_TYPE_END, 
                                         &RequestId, 
                                         sizeof(HTTP_REQUEST_ID),
                                         NULL, 
                                         0 );
        }

        if ( pvtmp != _hfc.pFilterContext )
        {
            SetClientContext( i, _hfc.pFilterContext );
            pFilterDll->SetHasSetContextBefore(); 
        }

        switch ( sfStatus )
        {
        default:
            DBGPRINTF(( DBG_CONTEXT,
                        "Unknown status code from filter %d\n",
                        sfStatus ));
            //
            //  Fall through
            //

        case SF_STATUS_REQ_NEXT_NOTIFICATION:
            continue;

        case SF_STATUS_REQ_ERROR:
            
            fRet = FALSE;
            goto Exit;

        case SF_STATUS_REQ_FINISHED:
        case SF_STATUS_REQ_FINISHED_KEEP_CONN:  // Not supported at this point

            if ( _pMainContext != NULL )
            {
                _pMainContext->SetDisconnect( TRUE );
            }
            *pfFinished = TRUE;
            goto Exit;

        case SF_STATUS_REQ_HANDLED_NOTIFICATION:

            //
            //  Don't notify any other filters
            //

            goto Exit;
        }
    }

Exit:
    //
    // Reset the filter context we came in with
    //
    
    _hfc.pFilterContext = pvCurrentClientContext;
    
    _dwCurrentFilter = dwCurrentFilterOnEntry;
    
    return fRet;
}

BOOL
W3_FILTER_CONTEXT::NotifySendRawFilters(
    HTTP_FILTER_RAW_DATA *      pRawData,
    BOOL *                      pfFinished
)
/*++

Routine Description:

    Notify raw write filters.  Done differently than the other filter 
    notifications since we must call in opposite priority order

Arguments:

    pRawData - Raw data structure to be munged
    pfFinished - Set to TRUE if we should disconnect

Return Value:

    HRESULT

--*/
{
    HTTP_FILTER_DLL *           pFilterDll;
    SF_STATUS_TYPE              sfStatus;
    DWORD                       i;
    PVOID                       pvtmp;
    PVOID                       pvCurrentClientContext;
    FILTER_LIST *               pFilterList;
    HTTP_FILTER_RAW_DATA        hfrd;
    DWORD                       dwOriginalFilter;
    BOOL                        fRet = TRUE;
    HTTP_REQUEST_ID             RequestId;

    if ( pRawData == NULL ||
         pfFinished == NULL )
    {
        DBG_ASSERT( FALSE );
        return FALSE;
    }
    
    *pfFinished = FALSE;

    hfrd.pvInData = pRawData->pvInData;
    hfrd.cbInData = pRawData->cbInData;
    hfrd.cbInBuffer = pRawData->cbInBuffer;
    
    //
    // In certain cases, we can send a notification to a filter while we're still
    // processing another filter's notification. In that case, we need to make sure
    // we restore the current filter's context when we're done with the notifications
    //
    
    pvCurrentClientContext = _hfc.pFilterContext;
    
    pFilterList = QueryFilterList();
    DBG_ASSERT( pFilterList != NULL );

    //
    // Determine which filter to start notifying at.  If the current filter
    // is INVALID_DLL, then start at the least priority, else start at the
    // least priority filter less than the current filter
    //

    dwOriginalFilter = _dwCurrentFilter;
    if ( _dwCurrentFilter == INVALID_DLL )
    {
        i = pFilterList->QueryFilterCount() - 1;
    }
    else if ( _dwCurrentFilter > 0 )
    {
        i = _fRecurseIntoCurrentFilter ? _dwCurrentFilter : _dwCurrentFilter - 1;
    }
    else
    {
        //
        // There are no more filters of lower priority.  Bail.
        //
        
        if ( !_fRecurseIntoCurrentFilter )
        {
            return TRUE;
        }

        i = _dwCurrentFilter;
    }

    do
    {
        pFilterDll = pFilterList->QueryDll( i ); 

        //
        // Notification flags are cached in the HTTP_FILTER object, but they're
        // only copied from the actual HTTP_FILTER_DLL object if a filter dll
        // disables a particular notification [sort of a copy-on-write scheme].
        // If a filter dll disables/changes a notification, we need to check the flags
        // in the HTTP_FILTER object, not those in the HTTP_FILTER_DLL object
        //
        
        if ( !QueryNotificationChanged() )
        {
            if ( !pFilterDll->IsNotificationNeeded( SF_NOTIFY_SEND_RAW_DATA,
                                                    _hfc.fIsSecurePort ) )
            {
                continue;
            }
        }
        else
        {
            if ( !IsDisableNotificationNeeded( i,
                                               SF_NOTIFY_SEND_RAW_DATA ) )
            {
                continue;
            }
        }

        //
        // Another slimy optimization.  If this filter has never associated
        // context with connection, then we don't have to do the lookup
        //
        
        _hfc.pFilterContext = QueryClientContext( i );

        pvtmp = _hfc.pFilterContext;

        //
        // Keep track of the current filter so that we know which filters
        // to notify when a raw filter does a write client
        //
       
        _dwCurrentFilter = i;
        
        if ( ETW_IS_TRACE_ON(ETW_LEVEL_CP) ) 
        {
            W3_MAIN_CONTEXT * pContext = QueryMainContext();
            if ( pContext != NULL ) 
            {
                DBG_ASSERT( pContext->QueryRequest() != NULL );
                RequestId = pContext->QueryRequest()->QueryRequestId();

                g_pEtwTracer->EtwTraceEvent( &IISFilterGuid,
                                             ETW_TYPE_START, 
                                             &RequestId, 
                                             sizeof(HTTP_REQUEST_ID),
                                             NULL, 
                                             0 );
            }
        }
        
        sfStatus = (SF_STATUS_TYPE)
                   pFilterDll->QueryEntryPoint()( &_hfc,
                                                  SF_NOTIFY_SEND_RAW_DATA,
                                                  &hfrd );

        if ( ETW_IS_TRACE_ON(ETW_LEVEL_CP) ) 
        {
            g_pEtwTracer->EtwTraceEvent( &IISFilterGuid,
                                         ETW_TYPE_END, 
                                         &RequestId, 
                                         sizeof(HTTP_REQUEST_ID),
                                         NULL, 
                                         0 );
        }
        
        if ( pvtmp != _hfc.pFilterContext )
        {
            SetClientContext( i, _hfc.pFilterContext );
            pFilterDll->SetHasSetContextBefore(); 
        }

        switch ( sfStatus )
        {
        default:
            DBGPRINTF(( DBG_CONTEXT,
                        "Unknown status code from filter %d\n",
                        sfStatus ));
            //
            //  Fall through
            //

        case SF_STATUS_REQ_NEXT_NOTIFICATION:
            continue;

        case SF_STATUS_REQ_ERROR:
            
            _hfc.pFilterContext = pvCurrentClientContext;
            fRet = FALSE;
            goto Exit;

        case SF_STATUS_REQ_FINISHED:
        case SF_STATUS_REQ_FINISHED_KEEP_CONN:  // Not supported at this point

            *pfFinished = TRUE;
            goto Exit;

        case SF_STATUS_REQ_HANDLED_NOTIFICATION:

            //
            //  Don't notify any other filters
            //

            goto Exit;
        }
    }
    while ( i-- > 0 );

Exit:

    pRawData->pvInData = (BYTE*) hfrd.pvInData;
    pRawData->cbInData = hfrd.cbInData;
    pRawData->cbInBuffer = hfrd.cbInBuffer;
    
    //
    // Reset the filter context we came in with
    //
    
    _hfc.pFilterContext = pvCurrentClientContext;
    
    _dwCurrentFilter = dwOriginalFilter;
    
    return fRet;
}

HRESULT
W3_FILTER_CONTEXT::DisableNotification(
    DWORD                   dwNotification
)
/*++

Routine Description:

    Initialize W3_FILTER_CONTEXT lookaside

Arguments:

    None

Return Value:

    HRESULT

--*/
{
    DBG_ASSERT( QueryFilterList() != NULL );

    if ( !_fNotificationsDisabled )
    {
        //
        // All subsequent calls to IsNotificationNeeded() and NotifyFilter() must
        // use local copy of flags to determine action.
        //

        _fNotificationsDisabled = TRUE;

        //
        // Copy notification tables created in the FILTER_LIST objects
        //

        if ( !_BuffSecureArray.Resize( QueryFilterList()->QuerySecureArray()->QuerySize() ) ||
             !_BuffNonSecureArray.Resize( QueryFilterList()->QueryNonSecureArray()->QuerySize() ) )
        {
            return HRESULT_FROM_WIN32( GetLastError() );
        }

        memcpy( _BuffSecureArray.QueryPtr(),
                QueryFilterList()->QuerySecureArray()->QueryPtr(),
                QueryFilterList()->QuerySecureArray()->QuerySize() );

        memcpy( _BuffNonSecureArray.QueryPtr(),
                QueryFilterList()->QueryNonSecureArray()->QueryPtr(),
                QueryFilterList()->QueryNonSecureArray()->QuerySize() );

    }

    //
    // Disable the appropriate filter in our local table
    //

    ((DWORD*)_BuffSecureArray.QueryPtr())[ _dwCurrentFilter ] &=
                                                        ~dwNotification;
    ((DWORD*)_BuffNonSecureArray.QueryPtr())[ _dwCurrentFilter ] &=
                                                        ~dwNotification;

    //
    // Calculate the aggregate notification status for our local scenario
    // NYI:  Might want to defer this operation?
    //

    _dwSecureNotifications = 0;
    _dwNonSecureNotifications = 0;

    for( DWORD i = 0; i < QueryFilterList()->QueryFilterCount(); i++ )
    {
        _dwSecureNotifications |= ((DWORD*)_BuffSecureArray.QueryPtr())[i];
        _dwNonSecureNotifications |= ((DWORD*)_BuffNonSecureArray.QueryPtr())[i];
    }

    return NO_ERROR;
}

BOOL 
W3_FILTER_CONTEXT::IsDisableNotificationNeeded(
    DWORD          i,
    DWORD          dwNotification
)
{
    if ( _pMainContext &&
         _pMainContext->IsRawConnectionDisableNotificationNeeded( i,
                                                                  dwNotification ) )
    {
        return TRUE;
    }

    return QueryIsSecure() ?
            ((DWORD*)_BuffSecureArray.QueryPtr())[i] & dwNotification :
            ((DWORD*)_BuffNonSecureArray.QueryPtr())[i] & dwNotification;
}

BOOL 
W3_FILTER_CONTEXT::QueryNotificationChanged( 
    VOID 
)
{
    if ( _pMainContext &&
         _pMainContext->QueryRawConnectionNotificationChanged() )
    {
        return TRUE;
    }

    return _fNotificationsDisabled;
}

//static
HRESULT
W3_FILTER_CONTEXT::Initialize(
    VOID
)
/*++

Routine Description:

    Initialize W3_FILTER_CONTEXT lookaside

Arguments:

    None

Return Value:

    HRESULT

--*/
{
    ALLOC_CACHE_CONFIGURATION       acConfig;

    acConfig.nConcurrency = 1;
    acConfig.nThreshold = 100;
    acConfig.cbSize = sizeof( W3_FILTER_CONTEXT );

    DBG_ASSERT( sm_pachFilterContexts == NULL );
    
    sm_pachFilterContexts = new ALLOC_CACHE_HANDLER( "W3_FILTER_CONTEXT",  
                                                     &acConfig );

    if ( sm_pachFilterContexts == NULL )
    {
        return HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );
    }
    
    return NO_ERROR;
}

//static
VOID
W3_FILTER_CONTEXT::Terminate(
    VOID
)
/*++

Routine Description:

    Terminate W3_FILTER_CONTEXT lookaside

Arguments:

    None

Return Value:

    None

--*/
{
    if ( sm_pachFilterContexts != NULL )
    {
        delete sm_pachFilterContexts;
        sm_pachFilterContexts = NULL;
    }
}

HRESULT
GlobalFilterInitialize(
    VOID
)
/*++

Routine Description:

    Overall global filter initialization

Parameters:

    None

Return Value:
    
    HRESULT

--*/
{
    HRESULT                 hr = NO_ERROR;
   
    //
    // Initialize ISAPI filter cache
    //
    
    hr = HTTP_FILTER_DLL::Initialize();
    if ( FAILED( hr ) )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "Failed to initialize HTTP_FILTER_DLL globals.  hr = %x\n",
                    hr ));
        return hr;
    }
    
    //
    // Initialize global filter list
    //
    
    hr = FILTER_LIST::Initialize();
    if ( FAILED( hr ) )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "Failed to initialize global filter list.  hr = %x\n",
                    hr ));
        HTTP_FILTER_DLL::Terminate();
        
        return hr;
    }
    
    //
    // Initialize W3_FILTER_CONTEXT lookaside
    //
    
    hr = W3_FILTER_CONTEXT::Initialize();
    if ( FAILED( hr ) )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "Failed to initialize W3_FILTER_CONTEXT globals.  hr = %x\n",
                    hr ));
        FILTER_LIST::Terminate();
        HTTP_FILTER_DLL::Terminate();
        
        return hr;
    }
    
    return NO_ERROR;
}

VOID
GlobalFilterTerminate(
    VOID
)
/*++

Routine Description:

    Global filter termination

Parameters:

    None

Return Value:
    
    None

--*/
{
    W3_FILTER_CONTEXT::Terminate();
    
    FILTER_LIST::Terminate();
    
    HTTP_FILTER_DLL::Terminate();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\iisplus\ulw3\urlinfo.cxx ===
/*++

   Copyright    (c)    1999    Microsoft Corporation

   Module Name :
     urlinfo.cxx

   Abstract:
     Implementation of URL cache
 
   Author:
     Bilal Alam (balam)             8-Jan-2000

   Environment:
     Win32 - User Mode

   Project:
     ULW3.DLL
--*/

#include "precomp.hxx"

//
// This is the maximum size for a script map extension
//

#define MAX_EXT_LEN 128

ALLOC_CACHE_HANDLER *   W3_URL_INFO::sm_pachW3UrlInfo;
DWORD                   W3_URL_INFO::sm_cMaxDots;

HRESULT
W3_URL_INFO_KEY::CreateCacheKey(
    WCHAR *                 pszKey,
    DWORD                   cchKey,
    DWORD                   cchSitePrefix,
    BOOL                    fCopy
)
/*++

  Description:

    Setup a URI cache key

  Arguments:

    pszKey - URL of cache key
    cchKey - size of URL
    cchSitePrefix - Size of site prefix ("LM/W3SVC/<n>")
    fCopy - Set to TRUE if we should copy the URL, else we just keep a ref
    
  Return:

    HRESULT

--*/
{
    HRESULT             hr;
   
    _cchSitePrefix = cchSitePrefix;
    
    if ( fCopy )
    {
        hr = _strKey.Copy( pszKey );
        if ( FAILED( hr ) )
        {
            return hr;
        }
        
        _pszKey = _strKey.QueryStr();
        _cchKey = _strKey.QueryCCH();
    }
    else
    {
        _pszKey = pszKey;
        _cchKey = cchKey;
    }

    return NO_ERROR;
}

//static
HRESULT
W3_URL_INFO::Initialize(
    VOID
)
/*++

  Description:

    URI entry lookaside initialization

  Arguments:

    None
    
  Return:

    HRESULT

--*/
{
    ALLOC_CACHE_CONFIGURATION   acConfig;
    HRESULT                     hr;    
    DWORD                       dwError;
    HKEY                        hKey = NULL;
    DWORD                       cbData;
    DWORD                       dwType;
    DWORD                       dwValue;

    //
    // Default max dots is 100
    //

    sm_cMaxDots = 100;
        
    //
    // Look for a registry override to the max dot value
    // (one of the more useful configurable options in IIS)
    //
    
    dwError = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                            L"System\\CurrentControlSet\\Services\\inetinfo\\Parameters",
                            0,
                            KEY_READ,
                            &hKey );
    if ( dwError == ERROR_SUCCESS )
    {
        DBG_ASSERT( hKey != NULL );
    
        //
        // Should we be file caching at all?
        //
    
        cbData = sizeof( DWORD );
        dwError = RegQueryValueEx( hKey,
                                   L"MaxDepthDots",
                                   NULL,
                                   &dwType,
                                   (LPBYTE) &dwValue,
                                   &cbData );
        if ( dwError == ERROR_SUCCESS && dwType == REG_DWORD )
        {
            sm_cMaxDots = dwValue;
        }
        
        RegCloseKey( hKey );
    }

    //
    // Initialize allocation lookaside
    //    
    
    acConfig.nConcurrency = 1;
    acConfig.nThreshold   = 100;
    acConfig.cbSize       = sizeof( W3_URL_INFO );

    DBG_ASSERT( sm_pachW3UrlInfo == NULL );
    
    sm_pachW3UrlInfo = new ALLOC_CACHE_HANDLER( "W3_URL_INFO",  
                                                &acConfig );

    if ( sm_pachW3UrlInfo == NULL )
    {
        hr = HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );

        DBGPRINTF(( DBG_CONTEXT,
                   "Error initializing sm_pachW3UrlInfo. hr = 0x%x\n",
                   hr ));

        return hr;
    }
    
    return NO_ERROR;
}

//static
VOID
W3_URL_INFO::Terminate(
    VOID
)
/*++

  Description:

    URI cache cleanup

  Arguments:

    None
    
  Return:

    None

--*/
{
    if ( sm_pachW3UrlInfo != NULL )
    {
        delete sm_pachW3UrlInfo;
        sm_pachW3UrlInfo = NULL;
    }
}

HRESULT
W3_URL_INFO::Create(
    STRU &              strUrl,
    STRU &              strMetadataPath
)
/*++

  Description:

    Initialize a W3_URL_INFO

  Arguments:

    strUrl - Url key for this entry
    strMetadataPath - Full metadata path used for key

  Return:

    HRESULT

--*/
{
    HRESULT         hr;
    
    hr = _cacheKey.CreateCacheKey( strMetadataPath.QueryStr(),
                                   strMetadataPath.QueryCCH(),
                                   strMetadataPath.QueryCCH() - strUrl.QueryCCH(),
                                   TRUE );
    if ( FAILED( hr ) )
    {
        return hr;
    } 
    
    //
    // Process the URL for execution info (and splitting path_info/url)
    //
    
    hr = ProcessUrl( strUrl );
    if( FAILED( hr ) )
    {
        return hr;
    }
    
    //
    // Now create physical path
    //

    hr = _pMetaData->BuildPhysicalPath( _strProcessedUrl,
                                        &_strPhysicalPath );
    if ( FAILED( hr ) )
    {
        return hr;
    }
    
    //
    // Now create translation of the whole URL.  Note: this is not always
    // PathTranslated, so we do not name it so
    //

    hr = _pMetaData->BuildPhysicalPath( strUrl,
                                        &_strUrlTranslated );
    if ( FAILED( hr ) )
    {
        return hr;
    }
    
    return NO_ERROR;
}

HRESULT
W3_URL_INFO::GetPathTranslated(
    W3_CONTEXT *                pW3Context,
    BOOL                        fUsePathInfo,
    STRU *                      pstrPathTranslated
)
/*++

Routine Description:

    Given the PATH_INFO of this cached entry, determine PATH_TRANSLATED.
    This involves:
        1) Mapping PATH_INFO to a physical path
        2) Calling filters if necessary for this path

    We cache the output of step 1)

Arguments:

    pW3Context - W3Context
    pstrPathTranslated - Filled with physical path on success

Return Value:

    HRESULT

--*/
{
    HRESULT             hr = S_OK;
    W3_URL_INFO *       pUrlInfo = NULL;
    BOOL                fReadLocked = TRUE;
    
    if ( pW3Context == NULL ||
         pstrPathTranslated == NULL )
    {
        DBG_ASSERT( FALSE );
        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }

    //
    // Check for cached path translated entry.  If its there and flushed,
    // then release it (and try again)
    //
    
    if ( _pUrlInfoPathTranslated != NULL )
    {
        _PathTranslatedLock.ReadLock();
        
        if ( _pUrlInfoPathTranslated != NULL )
        {
            if ( _pUrlInfoPathTranslated->QueryIsFlushed() )
            {
                _PathTranslatedLock.ConvertSharedToExclusive();
               
                //
                // Remember to write unlock when we're done
                //
               
                fReadLocked = FALSE;
                
                //
                // Due to how lock works, someone may have freed it already
                //
                
                if ( _pUrlInfoPathTranslated != NULL )
                {
                    _pUrlInfoPathTranslated->DereferenceCacheEntry();
                    _pUrlInfoPathTranslated = NULL;
                }
            }
            else
            {
                _pUrlInfoPathTranslated->ReferenceCacheEntry();
                pUrlInfo = _pUrlInfoPathTranslated;
            }
        }
        
        if ( fReadLocked )
        {
            _PathTranslatedLock.ReadUnlock();
        }
        else
        {
            _PathTranslatedLock.WriteUnlock();
        }
    }

    //
    // Use the cached translated entry if there
    //

    if ( pUrlInfo == NULL )
    {
        //
        // Get and keep the metadata and urlinfo for this path
        //
    
        DBG_ASSERT( g_pW3Server->QueryUrlInfoCache() != NULL );

        if ( fUsePathInfo )
        {
            hr = g_pW3Server->QueryUrlInfoCache()->GetUrlInfo( pW3Context,
                                                               _strPathInfo,
                                                               &pUrlInfo );
        }
        else
        {
            pUrlInfo = this;
            pUrlInfo->ReferenceCacheEntry();
        }

        if ( FAILED( hr ) )
        {
            return hr;
        }
        
        DBG_ASSERT( pUrlInfo != NULL );

        //
        // Store away the URL info, provided it is an empty string.
        //
        // Basically, we're trying to optimize the case of "/foobar.dll".  
        // In this case, path info is empty, and we want to avoid doing the
        // extra URL lookup for empty string.
        //
        
        if ( pUrlInfo->QueryCached() && 
             pUrlInfo->QueryUrl()[0] == L'\0' )
        {
            _PathTranslatedLock.WriteLock();
            
            if ( _pUrlInfoPathTranslated == NULL )
            {
                _pUrlInfoPathTranslated = pUrlInfo;
            }
            else
            {
                pUrlInfo->DereferenceCacheEntry();
                pUrlInfo = _pUrlInfoPathTranslated;
            }

            pUrlInfo->ReferenceCacheEntry();

            _PathTranslatedLock.WriteUnlock();
        }
    }        
    
    DBG_ASSERT( pUrlInfo != NULL );
    
    //
    // Now call into the filter
    //
    
    hr = W3_STATE_URLINFO::FilterMapPath( pW3Context,     
                                          pUrlInfo,
                                          pstrPathTranslated );
    
    pUrlInfo->DereferenceCacheEntry();
    
    return hr;
}

HRESULT
W3_URL_INFO::GetFileInfo(
    CACHE_USER *            pOpeningUser,
    BOOL                    fDoCache,
    W3_FILE_INFO **         ppFileInfo,
    FILE_CACHE_ASYNC_CONTEXT * pAsyncContext,
    BOOL *                  pfHandledSync,
    BOOL                    fAllowNoBuffering,
    BOOL                    fCheckForExistenceOnly
)
/*++

Routine Description:

    Get file info associated with this cache entry.  If it doesn't exist,
    then go to file cache directly to open the file

Arguments:

    pOpeningUser - Opening user
    fDoCache - Should we cache the file
    ppFileInfo - Set to file cache entry on success
    pAsyncContext - In case an async read is desired, context with callback info rmation
    pfHandledSync - Did the open complete synchronously
    fAllowNoBuffering - If opening the file, can we open with no-OS-buffering
    fCheckFOrExistenceOnly - Check for existence only
    
Return Value:

    HRESULT

--*/
{
    W3_FILE_INFO *          pFileInfo = NULL;
    BOOL                    fCleanup = FALSE;
    HRESULT                 hr;
    
    if ( ppFileInfo == NULL || 
         pOpeningUser == NULL )
    {
        DBG_ASSERT( FALSE );
        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }
    *ppFileInfo = NULL;
    
    //
    // Do we already have a file entry associated?  If so use it, if it was
    // not already flushed
    //
    // BIG NOTE: We will also cache "existence-only" cache entries since
    // that makes our "Check-Path-Existence" option work fast. 
    // 
    // What that means is if we're not being asked for an existence-check,
    // then we need to not use an existence-only cache entry
    //
    
    LockCacheEntry();
   
    if ( _pFileInfo != NULL )
    {
        if ( _pFileInfo->Checkout(pOpeningUser) )
        {
            pFileInfo = _pFileInfo;
        }
        else
        {
            _pFileInfo->DereferenceCacheEntry();
            _pFileInfo = NULL;
        }
    }
    
    UnlockCacheEntry();

    //
    // Is this an existence-only entry?  Is it usable
    //
    
    if ( pFileInfo != NULL &&
         pFileInfo->QueryFileHandle() == INVALID_HANDLE_VALUE &&
         pFileInfo->QueryFileBuffer() == NULL &&
         !fCheckForExistenceOnly )
    {
        //
        // Doh.  This entry isn't very useful for us.  Clear it out
        //
        
        LockCacheEntry();
        
        if ( _pFileInfo != NULL )
        {
            _pFileInfo = NULL;
        }
        
        UnlockCacheEntry();
        
        pFileInfo->DereferenceCacheEntry();
        pFileInfo = NULL;
        
        //
        // Fall thru and act as if we never had a cached file to begin with
        //
    }

    //
    // If we got a file entry, we're done, assuming access check is ok
    //
    
    if ( pFileInfo != NULL )
    {
        hr = pFileInfo->DoAccessCheck( pOpeningUser );
        if ( SUCCEEDED( hr ) )
        {
            *ppFileInfo = pFileInfo;
            if (pfHandledSync != NULL)
            {
                *pfHandledSync = TRUE;
            }

            return NO_ERROR;
        }
        else
        {
            pFileInfo->DereferenceCacheEntry();
            return hr;
        }
    }
    
    //
    // We'll have to go to file cache directly
    //
    
    DBG_ASSERT( g_pW3Server->QueryFileCache() != NULL );
    
    hr = g_pW3Server->QueryFileCache()->GetFileInfo( 
                                    _strPhysicalPath,
                                    _pMetaData->QueryDirmonConfig(),
                                    pOpeningUser,
                                    fDoCache,
                                    &pFileInfo,
                                    pAsyncContext,
                                    pfHandledSync,
                                    fAllowNoBuffering,
                                    fCheckForExistenceOnly );
    if ( FAILED( hr ) )
    {
        return hr;
    }             
    
    //
    // Now try to stuff the file descriptor into this object (bearing in mind
    // that another thread may try to do the same thing for this W3_URL_INFO)
    //
   
    if ( ((pfHandledSync == NULL) || *pfHandledSync) &&
         pFileInfo->QueryCached() )
    {
        LockCacheEntry();
        
        if ( _pFileInfo == NULL )
        {
            pFileInfo->ReferenceCacheEntry();
            _pFileInfo = pFileInfo;
        }
    
        UnlockCacheEntry();
    }

    //
    // It is OK if this thread was not able to associate the file entry.
    //

    *ppFileInfo = pFileInfo;

    return NO_ERROR;
}

HRESULT
W3_URL_INFO::ProcessUrl( 
    STRU &                  strUrl
)
/*++

Routine Description:

    Process the URL and assocate execution information with
    the W3_URL_INFO.

    Called before adding a new URL info to the cache.

    Look through the url for script-mapped or executable extensions
    and update the W3_URL_INFO with the actual URL to execute,
    path-info, gateway type, etc.

Arguments:

    strUrl - Original requested URL

Return Value:

    SUCCEEDED()/FAILED()

CODEWORK 

1. Handle wildcard mappings

--*/
{
    HRESULT hr = NOERROR;
    DWORD   cDots = 0;

    DBG_ASSERT( _pMetaData );

    STACK_STRU( strExtension, MAX_EXT_LEN );

    //
    // Reference the URL_INFO's data
    //

    STRU *  pstrProcessedUrl = &_strProcessedUrl;
    STRU *  pstrPathInfo     = &_strPathInfo;

    //
    // Iterate over pstrProcessedUrl. These always point at the
    // pstrProcessedUrl string.
    //

    WCHAR * pszExtensionIter = NULL;
    WCHAR * pszPathInfoIter = NULL;

    //
    // Make a working copy of the URL, this will be modified if an 
    // exectuable extension is found before the terminal node in the 
    // path.
    //

    hr = pstrProcessedUrl->Copy( strUrl );
    if( FAILED(hr) )
    {
        goto failure;
    }

    //
    // Search the URL for an extension that matches something
    // we know how to execute.
    //

    pszExtensionIter = pstrProcessedUrl->QueryStr();
    while( pszExtensionIter = wcschr( pszExtensionIter, L'.' ) )
    {
        //
        // Maintain a count of the dots we encounter, any more than
        // sm_cMaxDots and we fail the request
        //
        
        cDots++;
        if ( cDots > sm_cMaxDots )
        {
            break;
        }        
        
        //
        // Save the extension string
        //

        hr = strExtension.Copy( pszExtensionIter );
        if( FAILED(hr) )
        {
            goto failure;
        }
        
        //
        // Find the end of the string or the beginning of the path info
        //

        pszPathInfoIter = wcschr( pszExtensionIter, L'/' );
        if( pszPathInfoIter != NULL )
        {
            DBG_REQUIRE( 
                strExtension.SetLen( 
                    DIFF(pszPathInfoIter - pszExtensionIter) 
                    )
                );
        }
        
        //
        // Lowercase the extension string to allow case-insensitive 
        // comparisons.
        //
        _wcslwr( strExtension.QueryStr() );

        //
        // Try to find a matching script map entry
        //

        META_SCRIPT_MAP *       pScriptMap;
        META_SCRIPT_MAP_ENTRY * pScriptMapEntry;

        pScriptMap = _pMetaData->QueryScriptMap();
        DBG_ASSERT( pScriptMap );
        
        if( pScriptMap->FindEntry( strExtension, &pScriptMapEntry ) )
        {
            DBG_ASSERT( pScriptMapEntry );

            _pScriptMapEntry = pScriptMapEntry;

            if( pszPathInfoIter )
            {
                hr = pstrPathInfo->Copy( pszPathInfoIter );
                if( FAILED(hr) )
                {
                    goto failure;
                }

                //
                // Make sure that we truncate the URL so that we don't end
                // up downloading a source file by mistake.
                //

                DBG_REQUIRE( 
                    pstrProcessedUrl->SetLen( 
                        DIFF(pszPathInfoIter - pstrProcessedUrl->QueryStr()) 
                        )
                    );
            }
            else
            {
                pstrPathInfo->Reset();
            }

            //
            // Since we found the entry, we are done
            //
            break;
        }

        //
        // No matching script map, so check if this is a wellknown
        // Gateway type.
        //

        DBG_ASSERT( pScriptMapEntry == NULL );
        DBG_ASSERT( _pScriptMapEntry == NULL );

        //
        // Avoid all the string comps if we will never match.
        //
        if( strExtension.QueryCCH() == 4 )
        {
            GATEWAY_TYPE Gateway;
            Gateway = GATEWAY_UNKNOWN;
            
            //
            // Test extension against known gateway extensions.
            // 
            // Does it make sense to allow the known extensions to be
            // configured?
            //

            if( wcscmp( L".dll", strExtension.QueryStr() ) == 0 ||
                wcscmp( L".isa", strExtension.QueryStr() ) == 0
                )
            {
                Gateway = GATEWAY_ISAPI;
            }
            else if( !wcscmp( L".exe", strExtension.QueryStr() ) ||
                     !wcscmp( L".cgi", strExtension.QueryStr() ) ||
                     !wcscmp( L".com", strExtension.QueryStr() ) )
            {
                Gateway = GATEWAY_CGI;
            }
            else if( wcscmp( L".map", strExtension.QueryStr() ) == 0 )
            {
                Gateway = GATEWAY_MAP;
            }
            
            //
            // OK.  Before we continue, if the request was a GATEWAY_ISAPI
            // or GATEWAY_CGI and we do NOT have EXECUTE permissions, then
            // this really isn't a ISA/CGI after all
            //
            
            if ( Gateway == GATEWAY_CGI ||
                 Gateway == GATEWAY_ISAPI )
            {
                if ( !( _pMetaData->QueryAccessPerms() & VROOT_MASK_EXECUTE ) )
                {
                    Gateway = GATEWAY_UNKNOWN;
                }
            } 
            
            //
            // The gateway is specified in the URL and we recognize it.
            //
            if( Gateway != GATEWAY_UNKNOWN )
            {
                _Gateway = Gateway;

                //
                // Save everthing after the matching extension as
                // path-info and truncate the URL so that it doesn't
                // include the path info
                //
                if( pszPathInfoIter )
                {

                    hr = pstrPathInfo->Copy( pszPathInfoIter );
                    if( FAILED(hr) )
                    {
                        goto failure;
                    }

                    DBG_REQUIRE( 
                        pstrProcessedUrl->SetLen( 
                            DIFF(pszPathInfoIter - pstrProcessedUrl->QueryStr()) 
                            )
                        );
                }
                else
                {
                    pstrPathInfo->Reset();
                }
                
                //
                // We have a match so exit the loop
                //
                break;
            }
        }
            
        //
        // We do not have a matching entry, so continue to look for an
        // executable extension.
        //
        pszExtensionIter++;
        
    
    } // while (pszExtensionIter)

    //
    // Now associate the ContentType for this entry
    //
    if (_pScriptMapEntry == NULL &&
        _Gateway != GATEWAY_ISAPI &&
        _Gateway != GATEWAY_CGI)
    {
        if (FAILED(hr = SelectMimeMappingForFileExt(pstrProcessedUrl->QueryStr(),
                                                    _pMetaData->QueryMimeMap(),
                                                    &_strContentType,
                                                    &_fDefaultMimeMap)))
        {
            goto failure;
        }
    }
    
    return S_OK;

failure:

    DBG_ASSERT( FAILED(hr) );
    return FAILED(hr) ? hr : E_FAIL;
}

HRESULT
W3_URL_INFO_CACHE::Initialize(
    VOID
)
/*++

  Description:

    Initialize URI cache

  Arguments:

    None

  Return:

    HRESULT

--*/
{
    HRESULT             hr;
    DWORD               dwData;
    DWORD               dwType;
    DWORD               cbData = sizeof( DWORD );
    DWORD               csecTTL = DEFAULT_W3_URL_INFO_CACHE_TTL;
    HKEY                hKey;

    //
    // What is the TTL for the URI cache
    //
    
    if ( RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                       L"System\\CurrentControlSet\\Services\\inetinfo\\Parameters",
                       0,
                       KEY_READ,
                       &hKey ) == ERROR_SUCCESS )
    {
        DBG_ASSERT( hKey != NULL );
        
        if ( RegQueryValueEx( hKey,
                              L"ObjectCacheTTL",
                              NULL,
                              &dwType,
                              (LPBYTE) &dwData,
                              &cbData ) == ERROR_SUCCESS &&
             dwType == REG_DWORD )
        {
            csecTTL = dwData;
        }
        
        RegCloseKey( hKey );
    }                      
    
    //
    // We'll use TTL for scavenge period, and expect two inactive periods to
    // flush
    //
    
    hr = SetCacheConfiguration( csecTTL * 1000, 
                                csecTTL * 1000,
                                CACHE_INVALIDATION_METADATA,
                                NULL );
    if ( FAILED( hr ) )
    {
        return hr;
    }

    return W3_URL_INFO::Initialize();
}

HRESULT
W3_URL_INFO_CACHE::GetUrlInfo(
    W3_CONTEXT *                pW3Context,
    STRU &                      strUrl,
    W3_URL_INFO **              ppUrlInfo
)
/*++

Routine Description:

    Retrieve a W3_URL_INFO, creating it if necessary

Arguments:

    pW3Context - W3 context
    strUrl - Url to lookup
    ppUrlInfo - Filled with cache entry if successful
    
Return Value:

    HRESULT

--*/
{
    W3_URL_INFO_KEY           uriKey;
    W3_URL_INFO *             pUrlInfo;
    STACK_STRU(               strKey, MAX_PATH );
    STRU *                    pstrMBRoot;
    HRESULT                   hr;
    
    if ( pW3Context == NULL ||
         ppUrlInfo == NULL )
    {
        DBG_ASSERT( FALSE );
        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }
    
    *ppUrlInfo = NULL;
    
    //
    // The key is the full metadata path.  Start with the site prefix minus
    // the trailing '/'
    //

    pstrMBRoot = pW3Context->QuerySite()->QueryMBRoot();
    DBG_ASSERT( pstrMBRoot != NULL );
    
    hr = strKey.Copy( pstrMBRoot->QueryStr(),
                      pstrMBRoot->QueryCCH() - 1 );
    if ( FAILED( hr ) )
    {
        return hr;
    }
    
    //
    // Now add the URL (note that some applications depend on
    // case-sensitivity in the URL.)
    //
    
    hr = strKey.Append( strUrl );
    if ( FAILED( hr ) )
    {
        return hr;
    }
    
    //
    // Setup a key to lookup
    // 
    
    
    hr = uriKey.CreateCacheKey( strKey.QueryStr(),
                                strKey.QueryCCH(),
                                pW3Context->QuerySite()->QueryMBRoot()->QueryCCH(),
                                FALSE );
    if ( FAILED( hr ) )
    {
        return hr;
    }
    
    //
    // Look it up
    //
    
    hr = FindCacheEntry( &uriKey,
                         (CACHE_ENTRY**) &pUrlInfo );
    if ( SUCCEEDED( hr ) )
    {
        DBG_ASSERT( pUrlInfo != NULL );
        
        *ppUrlInfo = pUrlInfo;
        
        return NO_ERROR;
    }
    
    //
    // We need to create a URI cache entry
    //
    
    hr = CreateNewUrlInfo( pW3Context,
                           strUrl,
                           strKey,
                           &pUrlInfo );
    if ( FAILED( hr ) )
    {
        return hr;
    }
    
    DBG_ASSERT( pUrlInfo != NULL );
    
    //
    // Add to the cache
    //
    
    AddCacheEntry( pUrlInfo );
    
    *ppUrlInfo = pUrlInfo;
    
    return NO_ERROR;
}

HRESULT
W3_URL_INFO_CACHE::CreateNewUrlInfo(
    W3_CONTEXT *            pW3Context,
    STRU &                  strUrl,
    STRU &                  strMetadataPath,
    W3_URL_INFO **          ppUrlInfo
)
/*++

Routine Description:

    Create a new URI cache entry

Arguments:

    pW3Context - Main context
    strUrl - Url
    strMetadataPath - Full metadata path used as key
    ppUrlInfo - Set to URI cache entry
    
Return Value:

    HRESULT

--*/
{
    W3_METADATA *           pMetaData = NULL;
    W3_URL_INFO *           pUrlInfo = NULL;
    HRESULT                 hr;
    
    if ( pW3Context == NULL ||
         ppUrlInfo == NULL )
    {
        DBG_ASSERT( FALSE );
        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }
    
    *ppUrlInfo = NULL;
    
    //
    // Find a metacache entry
    //
    
    DBG_ASSERT( g_pW3Server->QueryMetaCache() != NULL );
    
    hr = g_pW3Server->QueryMetaCache()->GetMetaData( pW3Context,
                                                     strUrl,
                                                     &pMetaData );
    if ( FAILED( hr ) )
    {
        //
        // Check for RPC disconnected error.  If that's what happened,
        // mark unhealthy.
        //
        // Oh yeah, make sure we only log one message
        //
        
        if ( hr == RPC_E_DISCONNECTED ||
             hr == HRESULT_FROM_WIN32( RPC_S_SERVER_UNAVAILABLE ) ||
             hr == HRESULT_FROM_WIN32( RPC_S_CALL_FAILED ) ||
             hr == HRESULT_FROM_WIN32( RPC_S_CALL_FAILED_DNE ) )
        {   
            if ( InterlockedExchange( (LPLONG) &_fMarkedUnhealthy, TRUE ) == FALSE )
            {
                g_pW3Server->LogEvent( W3_EVENT_NO_METABASE,
                                       0,
                                       NULL,
                                       0 );
                                       
                UlAtqSetUnhealthy();
            }
        }
            
        return hr;
    }                  
    
    DBG_ASSERT( pMetaData != NULL );

    //
    // Create a W3_URL_INFO
    //
    
    pUrlInfo = new W3_URL_INFO( this, pMetaData );
    if ( pUrlInfo == NULL )
    {
        hr = HRESULT_FROM_WIN32( GetLastError() );
        pMetaData->DereferenceCacheEntry();
        
        return hr;
    }

    hr = pUrlInfo->Create( strUrl,
                           strMetadataPath );
    if ( FAILED( hr ) )
    {
        pUrlInfo->DereferenceCacheEntry();
        return hr;
    }

    *ppUrlInfo = pUrlInfo;
    
    return NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\iisplus\ulw3\w3metadata.cxx ===
/*++

   Copyright    (c)    1999    Microsoft Corporation

   Module Name :
     w3metadata.cxx

   Abstract:
     Code to read metadata and generate W3_METADATA objects
 
   Author:
     Bilal Alam (balam)             23-Jan-2000

   Environment:
     Win32 - User Mode

   Project:
     ULW3.DLL
--*/

#include "precomp.hxx"
#include "redirect.hxx"

ALLOC_CACHE_HANDLER * W3_METADATA::sm_pachW3MetaData;

W3_METADATA::W3_METADATA( OBJECT_CACHE * pObjectCache )
    : CACHE_ENTRY            ( pObjectCache ),
      _dwAccessPerm          ( MD_ACCESS_READ ),
      _dwSslAccessPerm       ( 0 ),
      _cbIpAccessCheck       ( 0 ),
      _fUseAnonSubAuth       ( FALSE ),
      _dwLogonMethod         ( LOGON32_LOGON_NETWORK_CLEARTEXT ),
      _dwVrLevel             ( 0 ),
      _dwVrLen               ( 0 ),
      _pRedirectBlob         ( NULL ),
      _dwDirBrowseFlags      ( MD_DIRBROW_LOADDEFAULT ),
      _dwAuthentication      ( 0 ),
      _dwAuthPersistence     ( 0 ),
      _strVrUserName         ( _rgVrUserName, sizeof( _rgVrUserName ) ),
      _strVrPasswd           ( _rgVrPasswd, sizeof( _rgVrPasswd ) ),
      _strUserName           ( _rgUserName, sizeof( _rgUserName ) ),
      _strPasswd             ( _rgPasswd, sizeof( _rgPasswd ) ),
      _strDomainName         ( _rgDomainName, sizeof( _rgDomainName ) ),
      _strRealm              ( _rgRealm, sizeof( _rgRealm ) ),
      _mstrAuthProviders     (),
      _pctVrToken            ( NULL ),
      _pctAnonymousToken     ( NULL ),
      _fCreateProcessAsUser  ( TRUE ),
      _fCreateProcessNewConsole ( FALSE ),
      _fDoStaticCompression  ( HTTP_COMPRESSION::QueryDoStaticCompression() ),
      _fDoDynamicCompression ( HTTP_COMPRESSION::QueryDoDynamicCompression() ),
      _dwCGIScriptTimeout    ( DEFAULT_SCRIPT_TIMEOUT ),
      _ScriptMap             (),
      _pMimeMap              ( NULL ),
      _fSSIExecDisabled      ( FALSE ),
      _fDontLog              ( FALSE ),
      _fFooterEnabled        ( FALSE ),
      _dwExpireMode          ( EXPIRE_MODE_NONE ),
      _fHaveNoCache          ( FALSE ),
      _fHaveMaxAge           ( FALSE ),
      _fDoReverseDNS         ( FALSE ),
      _cbEntityReadAhead     ( DEFAULT_ENTITY_READ_AHEAD ),
      _dwMaxRequestEntityAllowed    ( DEFAULT_MAX_REQUEST_ENTITY_ALLOWED ),
      _fNoCache              ( FALSE ),
      _dwAppIsolated         ( 0 ),
      _dwAppOopRecoverLimit  ( 0 ),
      _fKeepAliveEnabled     ( TRUE ),
      _cGetAllRecords        ( NULL ),
      _pGetAllBuffer         ( NULL ),
      _fAppPoolMatches       ( FALSE ),
      _dwRequireMapping      ( MD_PASSPORT_TRY_MAPPING ),
      _fUNCUserInvalid       ( FALSE ),
      _cbMatchingUrlA        ( 0 ),
      _cbMatchingPathA       ( 0 )
{
    //
    // Hmmm, since most of these values aren't getting initialized, if
    // somebody went and deleted all the metadata items from the tree, 
    // then bad things could happen.  We should initialize with defaults 
    // things that might screw us
    //
    
    _dirmonConfig.hToken = NULL;
    _dirmonConfig.pszDirPath = NULL;
}

W3_METADATA::~W3_METADATA()
{
    if ( _pctVrToken != NULL )
    {
        _pctVrToken->DereferenceCacheEntry();
        _pctVrToken = NULL;
    }   
    
    if ( _pctAnonymousToken != NULL )
    {
        _pctAnonymousToken->DereferenceCacheEntry();
        _pctAnonymousToken = NULL;
    }

    if ( _pMimeMap != NULL )
    {
        delete _pMimeMap;
        _pMimeMap = NULL;
    }

    if ( _pRedirectBlob != NULL )
    {
        delete _pRedirectBlob;
        _pRedirectBlob = NULL;
    }
    
    if ( _pGetAllBuffer != NULL )
    {
        delete _pGetAllBuffer;
        _pGetAllBuffer = NULL;
    }

    DBG_ASSERT(CheckSignature());
}

//static
HRESULT
W3_METADATA::Initialize(
    VOID
)
/*++

Routine Description:

    Initialize metadata lookaside

Arguments:

    None

Return Value:

    HRESULT

--*/
{
    ALLOC_CACHE_CONFIGURATION   acConfig;
    HRESULT                     hr;    

    //
    // Initialize allocation lookaside
    //    
    
    acConfig.nConcurrency = 1;
    acConfig.nThreshold   = 100;
    acConfig.cbSize       = sizeof( W3_METADATA );

    DBG_ASSERT( sm_pachW3MetaData == NULL );
    
    sm_pachW3MetaData = new ALLOC_CACHE_HANDLER( "W3_METADATA",  
                                                  &acConfig );

    if ( sm_pachW3MetaData == NULL )
    {
        hr = HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );

        DBGPRINTF(( DBG_CONTEXT,
                   "Error initializing sm_pachW3MetaData. hr = 0x%x\n",
                   hr ));

        return hr;
    }
    
    DATA_SET_CACHE::Initialize();
    
    return NO_ERROR;
}

//static
VOID
W3_METADATA::Terminate(
    VOID
)
{
    DATA_SET_CACHE::Terminate();
    
    if ( sm_pachW3MetaData != NULL )
    {
        delete sm_pachW3MetaData;
        sm_pachW3MetaData = NULL;
    }
}

//
//  Private constants.
//

#define DEFAULT_MD_RECORDS          40
#define DEFAULT_RECORD_SIZE         50

# define DEF_MD_REC_SIZE   ((1 + DEFAULT_MD_RECORDS) * \
                            (sizeof(METADATA_GETALL_RECORD) + DEFAULT_RECORD_SIZE))

HRESULT
W3_METADATA::ReadMetaData(
    const STRU & strMetabasePath,
    const STRU & strURL
)
/*++

Routine Description:

    Reads the metabase (directly) to get the metadata for the given URL

Arguments:

    strMetabasePath - The preceding service/instance goo (like "LM/W3SVC/1/ROOT" )
    strURL - URL in question
    
Return Value:

    HRESULT

--*/
{
    PMETADATA_GETALL_RECORD    pMDRecord;
    DWORD               dwNumMDRecords;
    DWORD               dwNumWamRecords;
    BYTE                tmpBuffer[ DEF_MD_REC_SIZE];
    BYTE                tmpWamBuffer[ DEF_MD_REC_SIZE];
    BUFFER              TempBuff( tmpBuffer, DEF_MD_REC_SIZE);
    BUFFER              WamBuff( tmpWamBuffer, DEF_MD_REC_SIZE);
    DWORD               i;
    DWORD               dwDataSetNumber;
    DWORD               dwWamDataSetNumber;
    WCHAR               ch;
    LPWSTR              pszInVr;
    LPWSTR              pszMinInVr;
    LPWSTR              pszURL;
    DWORD               dwNeed;
    DWORD               dwL;
    DWORD               dwVRLen;
    BYTE                tmpPrivateBuffer[ 20 ];
    BUFFER              PrivateBuffer( tmpPrivateBuffer, 20 );
    DWORD               dwPrivateBufferUsed;
    MB                  mb( g_pW3Server->QueryMDObject() );
    MB *                pmb = &mb;
    HRESULT             hr = NO_ERROR;
    WCHAR *             pszStart = NULL;
    DWORD               cchLength = 0;
    STACK_STRU(         strAppPoolId, 256 );
    STACK_STRU(         strMatchingUrl, 64 );
    WCHAR *             pszProcessAppPoolId;
    BOOL                fRet;

    //
    // We lie about modifying the input path
    //
    pszURL = (LPWSTR)strURL.QueryStr();
    DBG_ASSERT( pszURL != NULL );

    DBG_ASSERT( TempBuff.QuerySize() >=
                (DEFAULT_MD_RECORDS *
                 (sizeof(METADATA_GETALL_RECORD) + DEFAULT_RECORD_SIZE))
                );

    DBG_ASSERT( WamBuff.QuerySize() >=
                (DEFAULT_MD_RECORDS *
                 (sizeof(METADATA_GETALL_RECORD) + DEFAULT_RECORD_SIZE))
                );

    //
    // Read the metabase
    //

    if ( !pmb->Open( strMetabasePath.QueryStr() ))
    {
        hr = HRESULT_FROM_WIN32( GetLastError() );
        goto Failure;
    }

    //
    // Get the UT_FILE info
    //

    if ( !pmb->GetAll( pszURL,
                       METADATA_INHERIT | METADATA_PARTIAL_PATH,
                       IIS_MD_UT_FILE,
                       &TempBuff,
                       &dwNumMDRecords,
                       &dwDataSetNumber ))
    {
        hr = HRESULT_FROM_WIN32( GetLastError() );
        goto Failure;
    }

    //
    // Get the UT_WAM info
    //

    if ( !pmb->GetAll( pszURL,
                       METADATA_INHERIT | METADATA_PARTIAL_PATH,
                       IIS_MD_UT_WAM,
                       &WamBuff,
                       &dwNumWamRecords,
                       &dwWamDataSetNumber ))
    {
        hr = HRESULT_FROM_WIN32( GetLastError() );
        goto Failure;
    }
    
    //
    // Aarrggh.  MD_APP_APPPOOL_ID is UT_SERVER.  We want to get this property
    // so that we can validate that we don't execute AppPool A's stuff in a
    // process running as AppPool B (A != B)
    //
    // Note that it is OK if this call fails.  WAS by default uses 
    // DefaultAppPool as apppool
    //
    
    pmb->GetStr( pszURL,
                 MD_APP_APPPOOL_ID,
                 IIS_MD_UT_SERVER,
                 &strAppPoolId,
                 METADATA_INHERIT | METADATA_PARTIAL_PATH );

    pszProcessAppPoolId = (WCHAR*) UlAtqGetContextProperty( NULL,
                                                            ULATQ_PROPERTY_APP_POOL_ID ); 
    DBG_ASSERT( pszProcessAppPoolId != NULL );
   
    //
    // For efficiency sake, we'll store whether the AppPools match.  That way, we don't have
    // to repeat the determination per request.
    //
    
    if ( strAppPoolId.IsEmpty() )
    {
        _fAppPoolMatches = _wcsicmp( pszProcessAppPoolId, L"DefaultAppPool" ) == 0;
    }
    else
    {
        _fAppPoolMatches = _wcsicmp( pszProcessAppPoolId,
                                     strAppPoolId.QueryStr() ) == 0;
    }            

    //
    // Both sets of data better have the same data set number
    //

    DBG_ASSERT( dwDataSetNumber == dwWamDataSetNumber );

    //
    // Set the data set number, so that this object is metadata cachable
    //
    
    _cacheKey.SetDataSetNumber( dwDataSetNumber );
   
    //
    // Grok the buffer containing all the records
    //

    pMDRecord = (PMETADATA_GETALL_RECORD)TempBuff.QueryPtr();

    i = 0;

    //
    // Check from where we got VR_PATH
    //

    pszMinInVr = pszURL ;
    if ( *pszURL )
    {
        for ( pszInVr = pszMinInVr + wcslen(pszMinInVr) ;; )
        {
            ch = *pszInVr;
            *pszInVr = L'\0';
            dwNeed = 0;
            if ( !pmb->GetString( pszURL, 
                                  MD_VR_PATH, 
                                  IIS_MD_UT_FILE, 
                                  NULL, 
                                  &dwNeed, 
                                  0 ) &&
                 GetLastError() == ERROR_INSUFFICIENT_BUFFER )
            {
                *pszInVr = ch;
                // VR_PATH was defined at this level !

                break;
            }
            *pszInVr = ch;

            if ( ch )
            {
                if ( pszInVr > pszMinInVr )
                {
                    pszInVr--;
                }
                else
                {
                    //
                    // VR_PATH was defined above Instance vroot
                    // or not at all. If defined above, then the reference
                    // path is empty, so we can claim we found it.
                    // if not defined, then this will be catch later.
                    //

                    break;
                }
            }

            // scan for previous delimiter

            while ( *pszInVr != L'/' && *pszInVr != L'\\' )
            {
                if ( pszInVr > pszMinInVr )
                {
                    pszInVr--;
                }
                else
                {
                    //
                    // VR_PATH was defined above Instance vroot
                    // or not at all. If defined above, then the reference
                    // path is empty, so we can claim we found it.
                    // if not defined, then this will be catch later.
                    //

                    break;
                }
            }
        }

        dwVRLen = DIFF(pszInVr - pszMinInVr);
    }
    else
    {
        dwVRLen = 0;
        pszInVr = pszMinInVr;
    }

    // Close this now to minimize lock contention.
    DBG_REQUIRE(pmb->Close());

    for ( dwL = 0 ; pszMinInVr < pszInVr - 1 ; pszMinInVr++ )
    {
        if ( *pszMinInVr == L'/' || *pszMinInVr == L'\\' )
        {
            ++dwL;
        }
    }
    
    //
    // Store away an ANSI copy of the matching URL
    //

    hr = strMatchingUrl.Copy( pszURL );

    if ( FAILED( hr ) )
    {
        goto Failure;
    }

    DBG_ASSERT( strMatchingUrl.QueryCCH() >= dwVRLen );

    strMatchingUrl.SetLen( dwVRLen );

    hr = _strMatchingUrlA.CopyW( strMatchingUrl.QueryStr() );

    if ( FAILED( hr ) )
    {
        goto Failure;
    }

    _cbMatchingUrlA = strlen( _strMatchingUrlA.QueryStr() );

    //
    // Now walk through the array of returned metadata objects and format
    // each one into our predigested form.
    //
    
    _dwVrLevel = dwL;
    _dwVrLen = dwVRLen;
    
    dwPrivateBufferUsed = 0;

    for ( ; i < dwNumMDRecords; i++, pMDRecord++ ) {

        PVOID       pDataPointer;

        pDataPointer = (PVOID) ((PCHAR)TempBuff.QueryPtr() +
                                    pMDRecord->dwMDDataOffset);

        DBG_ASSERT(pMDRecord->dwMDDataTag == 0);

        switch ( pMDRecord->dwMDIdentifier )
        {

        case MD_ALLOW_KEEPALIVES:
            if (pMDRecord->dwMDDataType != DWORD_METADATA)
            {
                hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
                goto Failure;
            }

            _fKeepAliveEnabled = *(DWORD *)pDataPointer;
            break;

        case MD_FOOTER_DOCUMENT:
            if (pMDRecord->dwMDDataType != STRING_METADATA)
            {
                hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
                goto Failure;
            }

            if (*(WCHAR *)pDataPointer != L'\0')
            {
                if (FAILED(hr = ReadCustomFooter((WCHAR *)pDataPointer)))
                {
                    goto Failure;
                }
            }

            break;

        case MD_FOOTER_ENABLED:
            if (pMDRecord->dwMDDataType != DWORD_METADATA)
            {
                hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
                goto Failure;
            }

            _fFooterEnabled = !!*((DWORD *) pDataPointer );

            if ( _fFooterEnabled )
            {
                //
                // If we have footers for a static file, we cannot do static
                // compression on it
                //
                
                _fDoStaticCompression = FALSE;
            }
            break;

        case MD_HTTP_EXPIRES:
            if (pMDRecord->dwMDDataType != STRING_METADATA)
            {
                hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
                goto Failure;
            }

            if (FAILED(hr = SetExpire((WCHAR *)pDataPointer)))
            {
                goto Failure;
            }
            break;

        case MD_CC_NO_CACHE:
            if (pMDRecord->dwMDDataType != DWORD_METADATA)
            {
                hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
                goto Failure;
            }

            if (*(BOOL *)pDataPointer)
            {
                _fHaveNoCache = TRUE;
            }
            break;

        case MD_CC_MAX_AGE:
            if (pMDRecord->dwMDDataType != DWORD_METADATA)
            {
                hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
                goto Failure;
            }

            _dwMaxAge = *(DWORD *)pDataPointer;
            _fHaveMaxAge = TRUE;
            break;

        case MD_CC_OTHER:
            if (pMDRecord->dwMDDataType != STRING_METADATA)
            {
                hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
                goto Failure;
            }

            if (FAILED(hr = _strCacheControlHeader.CopyWTruncate((WCHAR *)pDataPointer)))
            {
                goto Failure;
            }
            break;

        case MD_HTTP_REDIRECT:
        {
            if (pMDRecord->dwMDDataType != STRING_METADATA)
            {
                hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
                goto Failure;
            }

            STACK_STRU( strRealSource, MAX_PATH );
            STACK_STRU( strDestination, MAX_PATH );

            if (FAILED(hr = strDestination.Copy((WCHAR *)pDataPointer)) ||
                FAILED(hr = GetTrueRedirectionSource(
                                pszURL,
                                strMetabasePath.QueryStr(),
                                &strRealSource)) ||
                FAILED(hr = SetRedirectionBlob(strRealSource,
                                               strDestination)))
            {
                goto Failure;
            }

            break;
        }

        case MD_DONT_LOG:
            if (pMDRecord->dwMDDataType != DWORD_METADATA) 
            {
                hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
                goto Failure;
            }

            _fDontLog = *(BOOL *)pDataPointer;
            break;

        case MD_CREATE_PROCESS_AS_USER:
            if (pMDRecord->dwMDDataType != DWORD_METADATA) 
            {
                hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
                goto Failure;
            }

            _fCreateProcessAsUser = *(BOOL *)pDataPointer;
            break;

        case MD_CREATE_PROC_NEW_CONSOLE:
            if (pMDRecord->dwMDDataType != DWORD_METADATA) 
            {
                hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
                goto Failure;
            }

            _fCreateProcessNewConsole = *(BOOL *)pDataPointer;
            break;

        case MD_SCRIPT_TIMEOUT:
            if (pMDRecord->dwMDDataType != DWORD_METADATA) 
            {
                hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
                goto Failure;
            }

            _dwCGIScriptTimeout = *(DWORD *)pDataPointer;
            break;

        case MD_MIME_MAP:
            if (pMDRecord->dwMDDataType != MULTISZ_METADATA)
            {
                hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
                goto Failure;
            }

            if (*(WCHAR *)pDataPointer)
            {
                _pMimeMap = new MIME_MAP((WCHAR *)pDataPointer);
                if (_pMimeMap == NULL)
                {
                    hr = HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
                    goto Failure;
                }
            }
            break;

        case MD_HC_DO_NAMESPACE_DYNAMIC_COMPRESSION:
            if (pMDRecord->dwMDDataType != DWORD_METADATA)
            {
                hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
                goto Failure;
            }

            _fDoDynamicCompression = *(BOOL *)pDataPointer;
            break;

        case MD_HC_DO_NAMESPACE_STATIC_COMPRESSION:
            if (pMDRecord->dwMDDataType != DWORD_METADATA)
            {
                hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
                goto Failure;
            }

            _fDoStaticCompression = *(BOOL *)pDataPointer;
            break;

        case MD_ANONYMOUS_USER_NAME:
            if ( pMDRecord->dwMDDataType != STRING_METADATA ) 
            {
                hr = HRESULT_FROM_WIN32( ERROR_INVALID_DATA );
                goto Failure;
            }
            
            if ( FAILED( hr = _strUserName.Copy(
                                   (WCHAR *)pDataPointer) ) )
            {
                goto Failure;
            }

            break;

        case MD_ANONYMOUS_PWD:
            if ( pMDRecord->dwMDDataType != STRING_METADATA ) 
            {
                hr = HRESULT_FROM_WIN32( ERROR_INVALID_DATA );
                goto Failure;
            }
            
            if ( FAILED( hr = _strPasswd.Copy(
                                   (WCHAR *)pDataPointer) ) )
            {
                goto Failure;
            }
            break;

        case MD_ANONYMOUS_USE_SUBAUTH:
            if (pMDRecord->dwMDDataType != DWORD_METADATA) 
            {
                hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
                goto Failure;
            }

            _fUseAnonSubAuth = *(BOOL *)pDataPointer;
            break;
        
        case MD_DEFAULT_LOGON_DOMAIN:
            if ( pMDRecord->dwMDDataType != STRING_METADATA ) 
            {
                hr = HRESULT_FROM_WIN32( ERROR_INVALID_DATA );
                goto Failure;
            }
            
            if ( FAILED( hr = _strDomainName.Copy(
                                   (WCHAR *)pDataPointer) ) )
            {
                goto Failure;
            }
            break;

        case MD_HTTP_PICS:
        case MD_HTTP_CUSTOM:

            if ( pMDRecord->dwMDDataType != MULTISZ_METADATA ) 
            {
                hr = HRESULT_FROM_WIN32( ERROR_INVALID_DATA );
                goto Failure;
            }

            // 
            // Copy all the specified headers into our header buffer
            //
            
            pszStart = (WCHAR*) pDataPointer;
            while ( *pszStart != L'\0' )
            {
                cchLength = wcslen( pszStart );
                
                hr = _strCustomHeaders.AppendW( pszStart );
                if ( FAILED( hr ) )
                {
                    goto Failure;
                }
                
                hr = _strCustomHeaders.Append( "\r\n", 2 );
                if ( FAILED( hr ) )
                {
                    goto Failure;
                }
                
                pszStart += ( cchLength + 1 );
            }
            break;

        case MD_LOGON_METHOD:
            if ( pMDRecord->dwMDDataType != DWORD_METADATA ) 
            {
                hr = HRESULT_FROM_WIN32( ERROR_INVALID_DATA );
                goto Failure;
            }
            
            //
            // The MD_LOGON_METHOD values in the metabase don't match 
            // the NT logon values, so we'll convert them
            //
            switch ( *((DWORD *) pDataPointer ) )
            {
            case MD_LOGON_BATCH:
                _dwLogonMethod = LOGON32_LOGON_BATCH;
                break;

            case MD_LOGON_INTERACTIVE:
                _dwLogonMethod = LOGON32_LOGON_INTERACTIVE;
                break;
            
            case MD_LOGON_NETWORK:
                _dwLogonMethod = LOGON32_LOGON_NETWORK;
                break;
                
            case MD_LOGON_NETWORK_CLEARTEXT:
                _dwLogonMethod = LOGON32_LOGON_NETWORK_CLEARTEXT;
                break;

            default:
                break;
            }

            break;

        case MD_AUTHORIZATION:
            if( pMDRecord->dwMDDataType != DWORD_METADATA ) 
            {
                hr = HRESULT_FROM_WIN32( ERROR_INVALID_DATA );
                goto Failure;
            }
            
            _dwAuthentication = *((DWORD *) pDataPointer );            
            break;

        case MD_REALM:
            if( pMDRecord->dwMDDataType != STRING_METADATA )
            {
                hr = HRESULT_FROM_WIN32( ERROR_INVALID_DATA );
                goto Failure;
            }

            if( FAILED( hr = _strRealm.Copy( ( WCHAR* )pDataPointer ) ) )
            {
                goto Failure;
            }

            break;

        case MD_NTAUTHENTICATION_PROVIDERS:
            if( pMDRecord->dwMDDataType != STRING_METADATA )
            {
                hr = HRESULT_FROM_WIN32( ERROR_INVALID_DATA );
                goto Failure;
            }

            hr = BuildProviderList( ( WCHAR* )pDataPointer );
            if ( FAILED( hr ) )
            {
                goto Failure;
            }

            break;

        case MD_AUTHORIZATION_PERSISTENCE:
            if( pMDRecord->dwMDDataType != DWORD_METADATA )
            {
                hr = HRESULT_FROM_WIN32( ERROR_INVALID_DATA );
                goto Failure;
            }
            
            _dwAuthPersistence = *((DWORD *) pDataPointer );
            break;

        case MD_IP_SEC:
            if( pMDRecord->dwMDDataType != BINARY_METADATA )
            {
                hr = HRESULT_FROM_WIN32( ERROR_INVALID_DATA );
                goto Failure;
            }

            if ( pMDRecord->dwMDDataLen )
            { 
                hr = SetIpAccessCheck( pDataPointer,
                                       pMDRecord->dwMDDataLen );
                if ( FAILED( hr ) )
                {
                    goto Failure;
                }
            }

            break;

        case MD_ACCESS_PERM:
            if ( pMDRecord->dwMDDataType != DWORD_METADATA ) 
            {
                hr = HRESULT_FROM_WIN32( ERROR_INVALID_DATA );
                goto Failure;
            }
            
            _dwAccessPerm = *((DWORD*) pDataPointer);
            break;

        case MD_SSL_ACCESS_PERM:
            if ( pMDRecord->dwMDDataType != DWORD_METADATA ) 
            {
                hr = HRESULT_FROM_WIN32( ERROR_INVALID_DATA );
                goto Failure;
            }
            
            _dwSslAccessPerm = *((DWORD*)pDataPointer) & MD_SSL_ACCESS_MASK;
            break;

        case MD_VR_PATH:
            if ( pMDRecord->dwMDDataType != STRING_METADATA ) 
            {
                hr = HRESULT_FROM_WIN32( ERROR_INVALID_DATA );
                goto Failure;
            }
            
            if ( FAILED( hr = _strVrPath.Copy((WCHAR *)pDataPointer) ) )
            {
                goto Failure;
            }

            if ( FAILED( hr = _strMatchingPathA.CopyW((WCHAR *)pDataPointer) ) )
            {
                goto Failure;
            }

            _cbMatchingPathA = strlen( _strMatchingPathA.QueryStr() );
            break;

        case MD_APP_ROOT:
            
            if ( pMDRecord->dwMDDataType != STRING_METADATA ) 
            {
                hr = HRESULT_FROM_WIN32( ERROR_INVALID_DATA );
                goto Failure;
            }
            
            if ( FAILED( hr = _strAppMetaPath.Copy((WCHAR *)pDataPointer) ) )
            {
                goto Failure;
            }

            break;

        case MD_VR_USERNAME:
            if ( pMDRecord->dwMDDataType != STRING_METADATA ) 
            {
                hr = HRESULT_FROM_WIN32( ERROR_INVALID_DATA );
                goto Failure;
            }
            
            if ( FAILED( hr = _strVrUserName.Copy(
                                   (WCHAR *)pDataPointer) ) )
            {
                goto Failure;
            }

            break;

        case MD_VR_PASSWORD:
            if ( pMDRecord->dwMDDataType != STRING_METADATA ) 
            {
                hr = HRESULT_FROM_WIN32( ERROR_INVALID_DATA );
                goto Failure;
            }
            
            if ( FAILED( hr = _strVrPasswd.Copy(
                                   (WCHAR *)pDataPointer) ) )
            {
                goto Failure;
            }

            break;

        case MD_REDIRECT_HEADERS:
            if ( pMDRecord->dwMDDataType != MULTISZ_METADATA ) 
            {
                hr = HRESULT_FROM_WIN32( ERROR_INVALID_DATA );
                goto Failure;
            }
           
            // 
            // Copy all the specified headers into our header buffer
            //
            
            pszStart = (WCHAR*) pDataPointer;
            while ( *pszStart != L'\0' )
            {
                cchLength = wcslen( pszStart );
                
                hr = _strRedirectHeaders.AppendW( pszStart );
                if ( FAILED( hr ) )
                {
                    goto Failure;
                }
                
                hr = _strRedirectHeaders.Append( "\r\n", 2 );
                if ( FAILED( hr ) )
                {
                    goto Failure;
                }
                
                pszStart += ( cchLength + 1 );
            }
            break;
            
        case MD_DIRECTORY_BROWSING:
            if ( pMDRecord->dwMDDataType != DWORD_METADATA )
            {
                hr = HRESULT_FROM_WIN32( ERROR_INVALID_DATA );
                goto Failure;
            }
            _dwDirBrowseFlags = *((DWORD *) pDataPointer );
            break;
            
        case MD_DEFAULT_LOAD_FILE:
            if ( pMDRecord->dwMDDataType != STRING_METADATA )
            {
                hr = HRESULT_FROM_WIN32( ERROR_INVALID_DATA );
                goto Failure;
            }
            
            hr = _strDefaultLoad.Copy( (WCHAR*) pDataPointer );
            if ( FAILED( hr ) )
            {
                goto Failure;
            }
            break;
        
        case MD_SCRIPT_MAPS:
            if ( pMDRecord->dwMDDataType != MULTISZ_METADATA )
            {
                hr = HRESULT_FROM_WIN32( ERROR_INVALID_DATA );
                goto Failure;
            }

            hr = _ScriptMap.Initialize( (WCHAR *)pDataPointer );

            if( FAILED(hr) )
            {
                goto Failure;
            }
            break;
        
        case MD_CUSTOM_ERROR:
            if ( pMDRecord->dwMDDataType != MULTISZ_METADATA )
            {
                hr = HRESULT_FROM_WIN32( ERROR_INVALID_DATA );
                goto Failure;
            }
            
            //
            // An empty string means use hard-coded errors
            //
            
            if ( *((WCHAR*)pDataPointer) == L'\0' )
            {
                break; 
            }
            
            hr = _customErrorTable.BuildTable( (WCHAR*) pDataPointer );
            if ( FAILED( hr ) )
            {
                goto Failure;
            }
            break;

        case MD_SSI_EXEC_DISABLED:
            if ( pMDRecord->dwMDDataType != DWORD_METADATA )
            {
                hr = HRESULT_FROM_WIN32( ERROR_INVALID_DATA );
                goto Failure;
            }
            
            _fSSIExecDisabled = !!*( ( DWORD * ) pDataPointer );
            break;

        case MD_DO_REVERSE_DNS:
            if ( pMDRecord->dwMDDataType != DWORD_METADATA )
            {
                hr = HRESULT_FROM_WIN32( ERROR_INVALID_DATA );
                goto Failure;
            }
            
            _fDoReverseDNS = !!*((DWORD*)pDataPointer);
            break;
           
        case MD_UPLOAD_READAHEAD_SIZE:
            if ( pMDRecord->dwMDDataType != DWORD_METADATA )
            {
                hr = HRESULT_FROM_WIN32( ERROR_INVALID_DATA );
                goto Failure;
            }
            
            _cbEntityReadAhead = *(DWORD*)pDataPointer;
            break;

        case MD_MAX_REQUEST_ENTITY_ALLOWED:
            if ( pMDRecord->dwMDDataType != DWORD_METADATA )
            {
                hr = HRESULT_FROM_WIN32( ERROR_INVALID_DATA );
                goto Failure;
            }

            _dwMaxRequestEntityAllowed = *(DWORD*)pDataPointer;
            break;

        case MD_VR_NO_CACHE:
        
            if ( pMDRecord->dwMDDataType != DWORD_METADATA )
            {
                hr = HRESULT_FROM_WIN32( ERROR_INVALID_DATA );
                goto Failure;
            }
            
            _fNoCache = !!*((DWORD*)pDataPointer);
            break;
            
        case MD_PASSPORT_REQUIRE_AD_MAPPING:
        
            if ( pMDRecord->dwMDDataType != DWORD_METADATA )
            {
                hr = HRESULT_FROM_WIN32( ERROR_INVALID_DATA );
                goto Failure;
            }
            
            _dwRequireMapping = *((DWORD*)pDataPointer);
            break;
            
        default:
            // BUGBUGBUG
            DBG_ASSERT(CheckSignature());
            break;
        }
    }

    //
    // Walk through the WAM data
    //

    pMDRecord = (PMETADATA_GETALL_RECORD)WamBuff.QueryPtr();

    i = 0;

    for ( ; i < dwNumWamRecords; i++, pMDRecord++ ) {

        PVOID       pDataPointer;

        pDataPointer = (PVOID) ((PCHAR)WamBuff.QueryPtr() +
                                    pMDRecord->dwMDDataOffset);

        DBG_ASSERT(pMDRecord->dwMDDataTag == 0);

        switch ( pMDRecord->dwMDIdentifier )
        {
        case MD_APP_ISOLATED:

            if ( pMDRecord->dwMDDataType != DWORD_METADATA )
            {
                hr = HRESULT_FROM_WIN32( ERROR_INVALID_DATA );
                goto Failure;
            }

            _dwAppIsolated = *(DWORD*)pDataPointer;

            break;

        case MD_APP_WAM_CLSID:

            if ( pMDRecord->dwMDDataType != STRING_METADATA )
            {
                hr = HRESULT_FROM_WIN32( ERROR_INVALID_DATA );
                goto Failure;
            }

            hr = _strWamClsId.Copy( (WCHAR*)pDataPointer );

            break;

        case MD_APP_OOP_RECOVER_LIMIT:

            if ( pMDRecord->dwMDDataType != DWORD_METADATA )
            {
                hr = HRESULT_FROM_WIN32( ERROR_INVALID_DATA );
                goto Failure;
            }

            _dwAppOopRecoverLimit = *(DWORD*)pDataPointer;

            break;

        default:
            break;
        }
    }

    //
    // If no-cache, max-age or a dynamic expires directive is present, add
    // it to Cache-Control header
    //
    if (FAILED(hr = SetCacheControlHeader()))
    {
        goto Failure;
    }

    if ( _strVrPath.IsEmpty() )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "[ReadMetaData] Virtual Dir Path mapping not found\n" ));
                    
        hr = HRESULT_FROM_WIN32( ERROR_FILE_NOT_FOUND );    
        goto Failure;
    }

    //
    // If this is an UNC share, logon using associated credentials
    // keep a reference to this access token in the cache
    //
    
    if ( _strVrPath.QueryStr()[0] == L'\\' &&
         _strVrPath.QueryStr()[1] == L'\\' )
    {
        if ( _strVrUserName.QueryStr() != NULL && 
             _strVrPasswd.QueryStr()   != NULL &&
             _strVrUserName.QueryStr()[0] )
        {
            hr = CreateUNCVrToken( _strVrUserName.QueryStr(), 
                                   _strVrPasswd.QueryStr() );
            if( SUCCEEDED( hr ) )
            {
                hr = EncryptMemoryPassword( &_strVrPasswd );
                if( FAILED( hr ) )
                {
                    goto Failure;
                }
            }
            else
            {   
                //
                // Continue metadata creation, but remember the failure
                //
                
                hr = NO_ERROR;
                
                _fUNCUserInvalid = TRUE;
            }
        }
    }
    
    //
    // Setup the dirmon configuration
    //

    if ( _pctVrToken != NULL )
    {
        _dirmonConfig.hToken = _pctVrToken->QueryImpersonationToken();
    }
    else
    {
        _dirmonConfig.hToken = NULL;
    }   
    _dirmonConfig.pszDirPath = _strVrPath.QueryStr();
    
    //
    // Build a default provider list for SSPI auth if the 
    // NTAuthenticationProviders is not set in the metabase.
    //
    if( _mstrAuthProviders.IsEmpty() )
    {
        hr = BuildDefaultProviderList();
        if( FAILED( hr ) )
        {
            goto Failure;
        }
    }
    
    //
    // Get anonymous user token
    //
    
    hr = CreateAnonymousToken( _strUserName.QueryStr(),
                               _strPasswd.QueryStr() );
    if ( FAILED( hr ) )
    {
        goto Failure;
    }

    hr = EncryptMemoryPassword( &_strPasswd );
    if( FAILED( hr ) )
    {
        goto Failure;
    }
    
    DBG_ASSERT( CheckSignature() );

    return S_OK;

Failure:
    return hr;
}

HRESULT
W3_METADATA::BuildPhysicalPath(
    STRU &          strUrl,
    STRU *          pstrPhysicalPath
)
/*++

Routine Description:

    From the current metadata, convert a URL to a physical path 
    (using the MD_VR_ROOT property and inheritance level calculated on read)

Arguments:

    strUrl - Virtual path
    pstrPhysicalPath - String filled with physical path of strURL
    
Return Value:

    BOOL

--*/
{
    LPWSTR              pszInVr;
    DWORD               dwL;
    WCHAR               ch;
    HRESULT             hr = S_OK;

    DBG_ASSERT(CheckSignature());

    //
    // Build physical path from VR_PATH & portion of URI not used to define VR_PATH
    //


    //
    // skip the URI components used to locate the virtual root
    //

    pszInVr = strUrl.QueryStr();
    dwL = _dwVrLevel;
    while ( dwL-- )
    {
        if ( *pszInVr )
        {
            DBG_ASSERT( *pszInVr == L'/' || *pszInVr == L'\\' );

            ++pszInVr;

            while ( (ch = *pszInVr) && ch != L'/' && ch !=L'\\' )
            {
                pszInVr++;
            }
        }
    }

    DBG_ASSERT( dwL == (DWORD)-1 );

    if ( FAILED(hr = pstrPhysicalPath->Copy( _strVrPath ) ) )
    {
        return hr;
    }

    //
    // Add a path delimiter char between virtual root mount point & significant part of URI
    //

    if ( pstrPhysicalPath->QueryCCH() )
    {
        ch = pstrPhysicalPath->QueryStr()[ pstrPhysicalPath->QueryCCH() - 1 ];
        if ( (ch == L'/' || ch == L'\\') && *pszInVr )
        {
            ++pszInVr;
        }
    }

    if ( FAILED(hr = pstrPhysicalPath->Append( pszInVr ) ) )
    {
        return hr;
    }

    //
    // insure physical path last char uses standard directory delimiter
    //

    FlipSlashes( pstrPhysicalPath->QueryStr() );

    return NO_ERROR;
}

HRESULT
W3_METADATA::BuildProviderList(
    IN WCHAR *                  pszProviders
    )
/*++

  Description:

    Builds a name array of SSPI Authentication providers

  Arguments:

    pszProviders - Comma separated list of providers

  Returns:

    HRESULT

--*/
{
    WCHAR *             pszCursor; 
    WCHAR *             pszEnd;
    BOOL                fFinished = FALSE;
    
    DBG_ASSERT(CheckSignature());

    if ( pszProviders == NULL )
    {
        DBG_ASSERT( FALSE );
        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }
    
    //
    // Parse comma delimited list of providers, removing white space
    //
    
    pszCursor = SkipWhite( pszProviders );
    for( ; ; )
    {
        pszEnd = wcschr( pszCursor, L',' );
        if ( pszEnd == NULL )
        {
            fFinished = TRUE;
            pszEnd = pszCursor + wcslen( pszCursor );
        }
        
        while ( pszEnd > pszCursor )
        {
            if ( !ISWHITEW( *pszEnd ) )
            {
                break;
            }
            pszEnd--;
        }
        
        *pszEnd = L'\0';
        
        if ( !_mstrAuthProviders.AppendW( pszCursor ) )
        {
            return HRESULT_FROM_WIN32( GetLastError() );
        }
        
        if ( fFinished )
        {
            break;
        }
        
        //
        // Advance to next provider
        //
        
        pszCursor = SkipWhite( pszEnd + 1 );
    }

    return NO_ERROR;
}    
     
HRESULT
W3_METADATA::BuildDefaultProviderList(
    VOID
    )
/*++

  Description:

    Builds a default name array of SSPI Authentication providers
    if NTAuthenticationProviders is not set in metabase

  Arguments:

    NONE

  Returns:

    HRESULT

--*/
{
    DBG_ASSERT( CheckSignature() );
    DBG_ASSERT( _mstrAuthProviders.IsEmpty() );

    if ( !_mstrAuthProviders.Append( "Negotiate" ) )
    {
        return HRESULT_FROM_WIN32( GetLastError() );
    }
    
    if ( !_mstrAuthProviders.Append( "NTLM" ) )
    {
        return HRESULT_FROM_WIN32( GetLastError() );
    }
    
    return NO_ERROR;
}    
     
BOOL 
W3_METADATA::CheckAuthProvider(
    IN const CHAR *        pszPkgName
    ) 
/*++

  Description:

    Check if we support the SSP package of name pszPkgName

  Arguments:

    pszPkgName - Name of the package we check against 

  Returns:

    TRUE if we support the package, FALSE if we don't.

--*/
{
    const CHAR *          pszProvider;
    
    DBG_ASSERT( CheckSignature() );
    
    if ( pszPkgName == NULL )
    {
        DBG_ASSERT( FALSE );
        return FALSE;
    }

    pszProvider = _mstrAuthProviders.First();
    while ( pszProvider != NULL )
    {
        if ( _stricmp( pszPkgName, pszProvider ) == 0 )
        {
            return TRUE;
        }
        pszProvider = _mstrAuthProviders.Next( pszProvider );
    }
    
    return FALSE;
} 
    
HRESULT
W3_METADATA::CreateUNCVrToken( 
    IN LPWSTR       pszUserName,
    IN LPWSTR       pszPasswd
    )
/*++

  Description:

    Logon the user account for the UNC virtual path

  Arguments:

    pszUserName - User name of the account in format domain\username
    pszPasswd   - Passwd of the account

  Returns:

    HRESULT

--*/
{
    STACK_STRU(             strUserName, UNLEN + 1 );
    STACK_STRU(             strDomainName, IIS_DNLEN + 1 );
    // add 1 to strUserDomain for separator "\"
    STACK_STRU(             strUserDomain, UNLEN + IIS_DNLEN + 1 + 1);
    HRESULT                 hr;
    DWORD                   dwError;
    BOOL                    fPossibleUPNLogon = FALSE;
    
    hr = strUserDomain.Copy( pszUserName );
    if ( FAILED( hr ) )
    {
        return hr;
    }
    
    hr = W3_STATE_AUTHENTICATION::SplitUserDomain( strUserDomain,
                                                   &strUserName,
                                                   &strDomainName,
                                                   NULL,
                                                   &fPossibleUPNLogon );
    if ( FAILED( hr ) )
    {
        return hr;
    }
    
    DBG_ASSERT( g_pW3Server->QueryTokenCache() != NULL );
    
    hr = g_pW3Server->QueryTokenCache()->GetCachedToken( 
                                                    strUserName.QueryStr(),
                                                    strDomainName.QueryStr(),
                                                    pszPasswd,
                                                    QueryLogonMethod(),
                                                    FALSE,
                                                    fPossibleUPNLogon,
                                                    NULL,
                                                    &_pctVrToken,
                                                    &dwError );
    if ( FAILED( hr ) )
    {
        return hr;
    }
    
    //
    // If we didn't get a token, this is a fatal error.  It means bad config
    // so we will prop back an error which means Error 500
    //
    
    if ( _pctVrToken == NULL )
    {
        DBG_ASSERT( dwError != ERROR_SUCCESS );
       
        //
        // Make the error ERROR_LOGON_FAILURE so that we can generate the appropriate
        // custom error response
        //
        
        hr = HRESULT_FROM_WIN32( ERROR_LOGON_FAILURE );
        
        return hr;
    }
    
    return NO_ERROR;
}

HRESULT
W3_METADATA::CreateAnonymousToken( 
    IN LPWSTR       pszUserName,
    IN LPWSTR       pszPasswd
    )
/*++

  Description:

    Logon the user account for the UNC virtual path

  Arguments:

    pszUserName - User name of the account in format domain\username
    pszPasswd   - Passwd of the account

  Returns:

    HRESULT

--*/
{
    STACK_STRU(             strUserName, UNLEN );
    STACK_STRU(             strDomainName, IIS_DNLEN );
    // add 1 to strUserDomain for separator "\"
    STACK_STRU(             strUserDomain, UNLEN + IIS_DNLEN + 1 );
    HRESULT                 hr;
    DWORD                   dwLogonError;
    BOOL                    fPossibleUPNLogon = FALSE;
    BOOL                    fUseAnonSubAuth = FALSE;
    
    hr = strUserDomain.Copy( pszUserName );
    if ( FAILED( hr ) )
    {
        return hr;
    }
    
    hr = W3_STATE_AUTHENTICATION::SplitUserDomain( strUserDomain,
                                                   &strUserName,
                                                   &strDomainName,
                                                   NULL,
                                                   &fPossibleUPNLogon );
    if ( FAILED( hr ) )
    {
        return hr;
    }

    DBG_ASSERT( g_pW3Server->QueryTokenCache() != NULL );
    
    if( _fUseAnonSubAuth ) 
    {
        if( !W3_STATE_AUTHENTICATION::sm_fSubAuthConfigured )
        {
            if( W3_STATE_AUTHENTICATION::sm_lSubAuthAnonEvent == 0 )
            {
                if( !InterlockedExchange( &W3_STATE_AUTHENTICATION::sm_lSubAuthAnonEvent, 1 ) )
                {
                    //
                    // The registry key for iissuba is not configured correctly on local machine
                    //
                    g_pW3Server->LogEvent( W3_EVENT_SUBAUTH_REGISTRY_CONFIGURATION_LOCAL,
                                           0,
                                           NULL );
                }
            }
        }
        else if( !W3_STATE_AUTHENTICATION::sm_fLocalSystem )
        {
            if( W3_STATE_AUTHENTICATION::sm_lLocalSystemEvent == 0 )
            {
                if( !InterlockedExchange( &W3_STATE_AUTHENTICATION::sm_lLocalSystemEvent, 1 ) )
                {
                    //
                    // The process token does not have SeTcbPrivilege
                    //
                    g_pW3Server->LogEvent( W3_EVENT_SUBAUTH_LOCAL_SYSTEM,
                                           0,
                                           NULL );
                }
            }
        }
        else
        {
            fUseAnonSubAuth = TRUE;
        }
    }
    
    hr = g_pW3Server->QueryTokenCache()->GetCachedToken( 
                                                    strUserName.QueryStr(),
                                                    strDomainName.QueryStr(),
                                                    pszPasswd,
                                                    QueryLogonMethod(),
                                                    fUseAnonSubAuth,
                                                    fPossibleUPNLogon,
                                                    NULL,
                                                    &_pctAnonymousToken,
                                                    &dwLogonError );
    if ( FAILED( hr ) )
    {
        return hr;
    }

    return NO_ERROR;
}

HRESULT
W3_METADATA::GetAndRefAnonymousToken(
    TOKEN_CACHE_ENTRY ** ppCachedToken
)
/*++

  Description:

    Get the anonymous token for the current request.
    Everybody that calls this function needs to call
    deref when it's done.
          

  Arguments:

    NONE

  Returns:

    HRESULT

--*/
{
    HRESULT         hr = S_OK;
    BOOL            fReadLocked = TRUE;

    //
    // If you want to modify the stack buffer length, make sure 
    // it's a multiple of 16 bytes( CRYPTPROTECTMEMORY_BLOCK_SIZE )
    //

    STACK_BUFFER( bufDecryptedPassword, PWLEN * sizeof( WCHAR ) );

    if( ppCachedToken == NULL )
    {
        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }
    
    *ppCachedToken = NULL;
    
    //
    // Do a quick check for an existing token
    //
    
    if ( _pctAnonymousToken == NULL )
    {
        return NO_ERROR;
    }
    
    //
    // First see if we even have a token to return?
    //

    _TokenLock.ReadLock();
        
    if ( _pctAnonymousToken != NULL )
    {
        //
        // Checkout the token.  This insures we don't use a 
        // flushed token
        //
        
        if ( !_pctAnonymousToken->Checkout( NULL ) )
        {
            //
            // OK.  Get rid of associated token and build a new one
            //
            
            _TokenLock.ConvertSharedToExclusive();
        
            fReadLocked = FALSE;
            
            if ( _pctAnonymousToken != NULL )
            {
                _pctAnonymousToken->DereferenceCacheEntry();
                _pctAnonymousToken = NULL;
            }
            
            //
            // Do the logon
            //
        
            hr = DecryptMemoryPassword( &_strPasswd, 
                                        &bufDecryptedPassword );
            if ( SUCCEEDED( hr ) )
            {
                hr = CreateAnonymousToken( 
                           _strUserName.QueryStr(),
                           ( WCHAR * )bufDecryptedPassword.QueryPtr() );
                           
                if ( SUCCEEDED( hr ) )
                {
                    if ( _pctAnonymousToken != NULL )
                    {
                        _pctAnonymousToken->ReferenceCacheEntry();
                    }
                    
                    *ppCachedToken = _pctAnonymousToken;
                }

                SecureZeroMemory( bufDecryptedPassword.QueryPtr(),
                                  bufDecryptedPassword.QuerySize() );
            }
        }
        else
        {
            *ppCachedToken = _pctAnonymousToken;
        }
    }
    
    if ( fReadLocked )
    {
        _TokenLock.ReadUnlock();
    }
    else
    {
        _TokenLock.WriteUnlock();
    }

    return hr;
}

HRESULT
W3_METADATA::GetAndRefVrAccessToken(
    TOKEN_CACHE_ENTRY ** ppCachedToken
)
/*++

  Description:

    Get the UNC token for the current request.
    Everybody that calls this function needs to call
    deref when it's done.

  Arguments:

    NONE

  Returns:

    HRESULT

--*/
{
    HRESULT         hr = S_OK;
    BOOL            fReadLocked = TRUE;
    
    STACK_BUFFER( bufDecryptedPassword, PWLEN * sizeof( WCHAR )  );

    if( ppCachedToken == NULL )
    {
        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }
    
    *ppCachedToken = NULL;

    //
    // Do a quick check for an existing token
    //
    
    if ( _pctVrToken == NULL )
    {
        return NO_ERROR;
    }
    
    //
    // First see if we even have a token to return?
    //

    _TokenLock.ReadLock();
        
    if ( _pctVrToken != NULL )
    {
        //
        // Checkout the token.  This insures we don't use a 
        // flushed token
        //
        
        if ( !_pctVrToken->Checkout( NULL ) )
        {
            //
            // OK.  Get rid of associated token and build a new one
            //
            
            _TokenLock.ConvertSharedToExclusive();
        
            fReadLocked = FALSE;
            
            if ( _pctVrToken != NULL )
            {
                _pctVrToken->DereferenceCacheEntry();
                _pctVrToken = NULL;
            }
            
            //
            // Do the logon
            //

            if ( _strVrUserName.QueryStr() != NULL && 
                 _strVrPasswd.QueryStr()   != NULL &&
                 _strVrUserName.QueryStr()[0] )
            {
                hr = DecryptMemoryPassword( &_strVrPasswd,
                                            &bufDecryptedPassword );
                if( SUCCEEDED( hr ) )
                {                
                    hr = CreateUNCVrToken( _strVrUserName.QueryStr(), 
                                           (WCHAR*) bufDecryptedPassword.QueryPtr() );
                    if( SUCCEEDED( hr ) )
                    {
                        _dirmonConfig.hToken = _pctVrToken->QueryImpersonationToken();        
                        _pctVrToken->ReferenceCacheEntry();
                        
                        *ppCachedToken = _pctVrToken;
                    }
                    else
                    {
                        _fUNCUserInvalid = TRUE;
                        hr = NO_ERROR;
                    }

                    SecureZeroMemory( bufDecryptedPassword.QueryPtr(),
                                      bufDecryptedPassword.QuerySize() );
                }
            }
        }
        else
        {
            *ppCachedToken = _pctVrToken;
        }
    }

    if ( fReadLocked )
    {
        _TokenLock.ReadUnlock();
    }
    else
    {
        _TokenLock.WriteUnlock();
    }

    return hr;
}

HRESULT
W3_METADATA::SetIpAccessCheck( 
    LPVOID   pMDData, 
    DWORD    dwDataLen
)
/*++

  Description:

    Store away the IP DNS list

  Arguments:

    pMDData - Beginning of binary blob to store
    dwDataLen - Length of binary data

  Returns:

    HRESULT

--*/
{
    if ( !_buffIpAccessCheck.Resize( dwDataLen ) )
    {
        return HRESULT_FROM_WIN32( GetLastError() );
    }
    
    memcpy( _buffIpAccessCheck.QueryPtr(),
            pMDData,
            dwDataLen );
   
    _cbIpAccessCheck = dwDataLen;
    
    return NO_ERROR;
}

HRESULT
W3_METADATA::GetMetadataProperty(
    W3_CONTEXT *            pW3Context,
    DWORD                   dwPropertyId,
    PBYTE                   pbBuffer,
    DWORD                   cbBuffer,
    DWORD *                 pcbBufferRequired
)
/*++

Routine Description:

    Retrieve and serialize the requested metabase property.  

Arguments:

    pW3Context - W3 Context
    dwPropertyId - Property ID
    pbBuffer - Buffer (OPTIONAL)
    cbBuffer - Size of given buffer
    pcbBufferRequired - Set to size of buffer required

Returns:

    HRESULT

--*/
{
    HRESULT                 hr;
    DWORD                   dwDataSetNumber;
    DWORD                   dwNumMDRecords;
    METADATA_GETALL_RECORD* pRecord;
    VOID *                  pDataPointer;
    DWORD                   cbNeeded = 0;
    METADATA_RECORD *       pOutputRecord;
    
    if ( pcbBufferRequired == NULL ||
         pW3Context == NULL )
    {
        DBG_ASSERT( FALSE );
        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }
    
    //
    // First check whether we have already read the raw buffer.  If not, 
    // read it in
    //
    
    if ( _pGetAllBuffer == NULL )
    {
        BUFFER *                pBuffer;
        MB                      mb( g_pW3Server->QueryMDObject() );
        BOOL                    fRet;
        STACK_STRU(             strUrl, 256 );
        HANDLE                  hToken = NULL;
        
        pBuffer = new BUFFER;
        if ( pBuffer == NULL )
        {
            return HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );
        }
        
        hr = pW3Context->QueryRequest()->GetUrl( &strUrl );
        if ( FAILED( hr ) )
        {
            return hr;
        }

        fRet = OpenThreadToken( GetCurrentThread(),
                                TOKEN_IMPERSONATE,
                                TRUE,
                                &hToken );
        if ( fRet )
        {
            DBG_ASSERT( hToken != NULL );
            RevertToSelf();
        }
        
        //
        // Open the metabase at the site level
        //
        
        fRet = mb.Open( pW3Context->QuerySite()->QueryMBRoot()->QueryStr() );
        if ( fRet )
        {
            fRet = mb.GetAll( strUrl.QueryStr(),
                              METADATA_INHERIT | METADATA_PARTIAL_PATH,
                              IIS_MD_UT_FILE,
                              pBuffer,
                              &dwNumMDRecords,
                              &dwDataSetNumber );
            
            mb.Close();
        }
        
        if ( hToken != NULL )
        {
            SetThreadToken( NULL, hToken );
            CloseHandle( hToken );
            hToken = NULL;
        }
        
        if ( !fRet )
        {
            return HRESULT_FROM_WIN32( GetLastError() );
        }
        
        //
        // Try to stuff our buffer into this cache entry
        //
        
        LockCacheEntry();
        
        if ( _pGetAllBuffer == NULL )
        {
            _pGetAllBuffer = pBuffer;
            _cGetAllRecords = dwNumMDRecords;
        }
        else
        {
            //
            // We already have one in here.  Kill ours.
            //
            
            delete pBuffer;
            pBuffer = NULL;
        }
        
        UnlockCacheEntry();
    }
    
    DBG_ASSERT( _pGetAllBuffer != NULL );
    
    //
    // Lookup the property in question
    // 
    
    for ( DWORD i = 0; i < _cGetAllRecords; i++ )
    {
        pRecord = &(((METADATA_GETALL_RECORD*) _pGetAllBuffer->QueryPtr())[ i ]);
        pDataPointer = (PVOID) ((PCHAR) _pGetAllBuffer->QueryPtr() + pRecord->dwMDDataOffset );
        
        DBG_ASSERT( pRecord != NULL );
        DBG_ASSERT( pDataPointer != NULL );

        if ( pRecord->dwMDIdentifier == dwPropertyId )
        {
            //
            // Found it!
            // 
            
            switch( pRecord->dwMDDataType )
            {
            case DWORD_METADATA:
                cbNeeded = sizeof( DWORD );
                break;
            
            case STRING_METADATA:
                cbNeeded = ( wcslen( (WCHAR*) pDataPointer ) + 1 ) * sizeof( WCHAR );
                break;

            default:
                // CODEWORK: Handle the other data types
                return HRESULT_FROM_WIN32( ERROR_NOT_SUPPORTED );
            }
            
            //
            // Account for the METADATA_RECORD
            //
            
            cbNeeded += sizeof( METADATA_RECORD );
            
            //
            // Do the copy and other return values
            //
            
            DBG_ASSERT( cbNeeded != 0 );
            
            *pcbBufferRequired = cbNeeded;
            
            if ( pbBuffer == NULL ||
                 cbBuffer < *pcbBufferRequired )
            {
                return HRESULT_FROM_WIN32( ERROR_INSUFFICIENT_BUFFER );
            }
            
            pOutputRecord = (METADATA_RECORD*) pbBuffer;
            
            pOutputRecord->dwMDIdentifier = dwPropertyId;
            pOutputRecord->dwMDAttributes = pRecord->dwMDAttributes;
            pOutputRecord->dwMDUserType = pRecord->dwMDUserType;
            pOutputRecord->dwMDDataLen = cbNeeded - sizeof( METADATA_RECORD );
            pOutputRecord->dwMDDataType = pRecord->dwMDDataType;
            pOutputRecord->pbMDData = pbBuffer + sizeof( METADATA_RECORD );
            
            memcpy( pbBuffer + sizeof( METADATA_RECORD ),
                    pDataPointer,
                    pOutputRecord->dwMDDataLen );

            return NO_ERROR;
        }
    } 
    
    return HRESULT_FROM_WIN32( ERROR_INVALID_INDEX );
}

HRESULT 
W3_METADATA::ReadCustomFooter(
    WCHAR *                 pszFooter
)
/*++

Routine Description:

    Process a footer string, either reading the file or copying the string
    to the buffer.

Arguments:

    pszFooter - The footer string, which may be a string or a file name.
    It looks like "STRING : some-string" or "FILE : file-name"

Returns:

    HRESULT

--*/
{
    HRESULT             hr;
    STACK_STRU(         strFooter, MAX_PATH );
    BOOL                fFooterIsString = FALSE;

    // First thing to do is to determine if this is a string or a file name.
    // Skip preceding whitespace and then strcmp.

    while (iswspace(*pszFooter))
    {
        pszFooter++;
    }

    if (!_wcsnicmp(pszFooter, L"STRING", 6))
    {
        fFooterIsString = TRUE;
        pszFooter += 6;
    }
    else if (!_wcsnicmp(pszFooter, L"FILE", 4))
    {
        fFooterIsString = FALSE;
        pszFooter += 4;
    }
    else
    {
        return HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
    }

    // Now we look for 0 or more white space, followed by a colon, followed by
    // more white space.

    while (iswspace(*pszFooter))
    {
        pszFooter++;
    }

    if (*pszFooter != L':')
    {
        // No colon seperator, error.
        return HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
    }

    pszFooter++;

    //
    // OK, now if this is a string we take everything after the colon to the
    // end for the string. If this is a file name then we'll open and read the
    // file.
    //
    if (fFooterIsString)
    {
        return _strFooterString.CopyW(pszFooter);
    }
    else
    {
        //
        // For files, we'll skip any more white space before the name.
        //
        while (iswspace(*pszFooter))
        {
            pszFooter++;
        }
        
        hr = _strFooterDocument.Copy( pszFooter );
        if ( FAILED( hr ) )
        {
            return hr;
        }
    }

    return S_OK;
}

HRESULT 
W3_METADATA::EncryptMemoryPassword(
    IN OUT STRU * strPassword
)
/*++

Routine Description:

    Encrypt the password within the current process

Arguments:

    strPassword - The password to be encrypted. The encrypted password
                  is in the buffer in the STRU, and is not null 
                  terminated. So QueryCB and QueryCCH don't mean 
                  anything here.

Returns:

    HRESULT

--*/
{
    HRESULT hr;

    hr = strPassword->Resize( 
                    ( ( strPassword->QueryCCH() + 1 ) * sizeof( WCHAR )                 
                      / CRYPTPROTECTMEMORY_BLOCK_SIZE + 1 ) 
                    * CRYPTPROTECTMEMORY_BLOCK_SIZE );
    if( SUCCEEDED( hr ) )
    {
        if( !CryptProtectMemory( strPassword->QueryBuffer()->QueryPtr(),
                                 strPassword->QueryBuffer()->QuerySize(),
                                 CRYPTPROTECTMEMORY_SAME_PROCESS ) )
        {
            hr = HRESULT_FROM_WIN32( GetLastError() );
        }
    }
    
    return hr;
}

HRESULT 
W3_METADATA::DecryptMemoryPassword(
    IN  STRU   * strProtectedPassword,
    OUT BUFFER * bufDecryptedPassword
)
/*++

Routine Description:

    Decrypt the password with the current process

Arguments:

    strProtectedPassword - The protected password to be decrypted.
    bufDecryptedPassword - Holds the decrypted password.

Returns:

    HRESULT

--*/
{
    HRESULT  hr = S_OK;

    if( !bufDecryptedPassword->Resize( 
            strProtectedPassword->QueryBuffer()->QuerySize() ) )
    {
        return HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );
    }

    memcpy( bufDecryptedPassword->QueryPtr(),
            strProtectedPassword->QueryStr(),
            bufDecryptedPassword->QuerySize() );

    if( !CryptUnprotectMemory( bufDecryptedPassword->QueryPtr(),
                               bufDecryptedPassword->QuerySize(),
                               CRYPTPROTECTMEMORY_SAME_PROCESS ) )
    {
        hr = HRESULT_FROM_WIN32( GetLastError() );
    }

    return hr;
}

HRESULT W3_METADATA::SetExpire(WCHAR *pszExpire)
/*++

Routine Description:

    Set the expire header to be used on all responses

Arguments:

    pszExpire: the string containing the description.  It could have the form
    empty: no expire
    "s, some-date" : expire on this date"
    "d, some-number" : expire after this many seconds

Returns:

    HRESULT

--*/
{
    while (iswspace(*pszExpire))
    {
        pszExpire++;
    }

    LPWSTR pszParam;
    if ((pszParam = wcschr(pszExpire, L',')) == NULL)
    {
        if (*pszExpire == L'\0')
        {
            _dwExpireMode = EXPIRE_MODE_OFF;
            return S_OK;
        }

        return HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
    }

    pszParam++;
    while (iswspace(*pszParam))
    {
        pszParam++;
    }

    HRESULT hr;
    switch (*pszExpire)
    {
    case L's':
    case L'S':
        if (FAILED(hr = _strExpireHeader.CopyWTruncate(pszParam)))
        {
            return hr;
        }
        _dwExpireMode = EXPIRE_MODE_STATIC;
        break;

    case L'd':
    case L'D':
        LPWSTR endPtr;
        DWORD dwExpire;

        if (pszParam[0] == L'0' && pszParam[1] == L'x')
        {
            dwExpire = wcstoul(pszParam + 2, &endPtr, 16);
        }
        else
        {
            dwExpire = wcstoul(pszParam, &endPtr, 10);
        }

        if (!iswspace(*endPtr) &&
            *endPtr != L'\0')
        {
            return HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
        }

        if (dwExpire != ULONG_MAX)
        {
            if (dwExpire > MAX_GLOBAL_EXPIRE)
            {
                dwExpire = MAX_GLOBAL_EXPIRE;
            }

            _dwExpireMode = EXPIRE_MODE_DYNAMIC;
            _dwExpireDelta = dwExpire;
        }
        break;

    default:
        return HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
    }

    return S_OK;
}

HRESULT W3_METADATA::SetCacheControlHeader()
/*++

Routine Description:

    If no-cache, max-age or a dynamic expires directive is present, add
    it to Cache-Control header

Arguments:

    None

Returns:

    HRESULT

--*/
{
    switch (QueryExpireMode())
    {
    case EXPIRE_MODE_NONE:
        _fHaveNoCache = FALSE;
        _fHaveMaxAge = FALSE;
        break;

    case EXPIRE_MODE_DYNAMIC:
        // If we have a dynamic Expires header, create a max-age directive
        if (_dwExpireDelta != 0)
        {
            _fHaveNoCache = FALSE;
            if (!_fHaveMaxAge)
            {
                _fHaveMaxAge = TRUE;
                _dwMaxAge = _dwExpireDelta;
            }
        }
        else
        {
            _fHaveNoCache = TRUE;
            _fHaveMaxAge = FALSE;
        }
        break;

    default:
        break;
    }

    BOOL fHaveCCHeader = !_strCacheControlHeader.IsEmpty();
    HRESULT hr;
    if (_fHaveNoCache)
    {
        if (FAILED(hr = _strCacheControlHeader.Append(
                             fHaveCCHeader ? ",no-cache" : "no-cache")))
        {
            return hr;
        }
    }
    else if (_fHaveMaxAge)
    {
        CHAR pszMaxAgeBuffer[16];
        _itoa(_dwMaxAge, pszMaxAgeBuffer, 10);

        if (FAILED(hr = _strCacheControlHeader.Append(
                             fHaveCCHeader ? ",max-age=" : "max-age=")) ||
            FAILED(hr = _strCacheControlHeader.Append(pszMaxAgeBuffer)))
        {
            return hr;
        }
    }

    return S_OK;
}

HRESULT
META_SCRIPT_MAP::Initialize( 
    IN WCHAR * szScriptMapData
    )
/*++

Routine Description:

    Initialize the collection of META_SCRIPT_MAP_ENTRIES from the 
    metadata.

    This routine will modify the multisz it works with (by replacing 
    some ',' with '\0' ).
    
    Currently it modifies the in parameter, which is kindof icky. 
    We could avoid this by copying the buffer.

Arguments:
    
    szScriptMapData - A multi-sz of script map entries. 

    
Return Value:

Notes:

    Script map is a multi-sz with each string being a comma separated list
    <extension>,<executable>,<flags>,<verb list>

    <extension>:
      .xyz  - Maximum of 128 characters
      *     - Star script map - routes all requests though the executable

    <executable>
        - Extension to invoke

    <flags>:
      1     - Allow run in script access directory ( MD_SCRIPTMAPFLAG_SCRIPT )
      4 - Check for pathinfo file ( MD_SCRIPTMAPFLAG_CHECK_PATH_INFO )

    <verb list>:
      <verb>,<verb>,<verb>
        - Allowed verbs
        - If no verbs are listed, a value of "all verbs" is assumed. 

--*/
{
    DBG_ASSERT( szScriptMapData );

    HRESULT     hr = NOERROR;

    // Iterate over multisz
    WCHAR *     pszEntryIterator;
    
    // Current mapping
    WCHAR *     pszExtension;
    WCHAR *     pszExecutable;
    WCHAR *     pszFlags;
    DWORD       Flags;
    WCHAR *     pszVerbs;
    DWORD       cchVerbs;
    WCHAR *     pszDest;

    //
    // Iterate over each mapping
    //

    pszEntryIterator = szScriptMapData;
    while( *pszEntryIterator != L'\0' )
    {
        //
        // Get the extension
        //

        pszExtension = pszEntryIterator;

        //
        // Get the executable
        //
        
        pszEntryIterator = wcschr( pszEntryIterator, L',' );
        if( pszEntryIterator == NULL )
        {
            hr = HRESULT_FROM_WIN32( ERROR_INVALID_DATA );
            return hr;
        }

        *pszEntryIterator++ = L'\0';

        pszExecutable = pszEntryIterator;

        if( pszExecutable == L'\0' )
        {
            hr = HRESULT_FROM_WIN32( ERROR_INVALID_DATA );
            return hr;
        }

        //
        // Get the flags
        //
        
        pszEntryIterator = wcschr( pszEntryIterator, L',' );
        if( pszEntryIterator == NULL )
        {
            hr = HRESULT_FROM_WIN32( ERROR_INVALID_DATA );
            return hr;
        }

        *pszEntryIterator++ = L'\0';

        //
        // We don't need pszFlags here, but we will need it if
        // there is an empty verb list, to reset our iterator.
        //
        pszFlags = pszEntryIterator;

        Flags = wcstoul( pszFlags, NULL, 10 );

        //
        // Get the verbs
        //

        pszEntryIterator = wcschr( pszEntryIterator, L',' );
        if( pszEntryIterator != NULL )
        {
            //
            // There is a list of verbs
            //

            *pszEntryIterator++ = L'\0';

            pszDest = pszVerbs = pszEntryIterator;
        
            //
            // Format verb list as a multi-sz for each entry
            //

            cchVerbs = 1;

            while( *pszEntryIterator != L'\0')
            {
                if( *pszEntryIterator == L',' || *pszEntryIterator == L' ' )
                {
                    while( *pszEntryIterator == L',' || *pszEntryIterator == L' ' )
                    {
                        pszEntryIterator++;
                    }

                    *pszDest++ = L'\0';
                }
                else
                {
                    *pszDest++ = *pszEntryIterator++;
                }

                cchVerbs++;
            }
        }
        else
        {
            //
            // Empty Verb List
            //

            //
            // We've lost our iterator so we need to get it back.
            // Point to the terminator.
            //
            pszEntryIterator = pszFlags + wcslen( pszFlags );
            
            pszVerbs = pszEntryIterator;
            cchVerbs = 1;
        }


        //
        // Create and add the entry object to our list
        //
    
        META_SCRIPT_MAP_ENTRY * 
            pNewEntry = new META_SCRIPT_MAP_ENTRY();

        if( pNewEntry == NULL )
        {
            hr = E_OUTOFMEMORY;
            return hr;
        }

        hr = pNewEntry->Create( pszExtension,
                                pszExecutable,
                                Flags,
                                pszVerbs,
                                cchVerbs
                                );
        if( FAILED(hr) )
        {
            delete pNewEntry;
            return hr;
        }

        if (pNewEntry->QueryIsStarScriptMap())
        {
            InsertTailList( &m_StarScriptMapListHead, &pNewEntry->m_ListEntry );
        }
        else
        {
            InsertTailList( &m_ListHead, &pNewEntry->m_ListEntry );
        }
        
        //
        // Move to the next entry.
        //
        pszEntryIterator++;      
    }

    return hr;
}

BOOL
META_SCRIPT_MAP::FindEntry(
    IN  const STRU &              strExtension,
    OUT META_SCRIPT_MAP_ENTRY * * ppScriptMapEntry
    )
/*++

Routine Description:

Arguments:
    
Return Value:

--*/
{
    *ppScriptMapEntry = NULL;

    PLIST_ENTRY             pEntry;
    META_SCRIPT_MAP_ENTRY * pScriptMapEntry = NULL;

    for( pEntry  = m_ListHead.Flink;
         pEntry != &m_ListHead;
         pEntry  = pEntry->Flink )
    {
        pScriptMapEntry = CONTAINING_RECORD( pEntry, 
                                             META_SCRIPT_MAP_ENTRY, 
                                             m_ListEntry 
                                             );

        if( strExtension.Equals( pScriptMapEntry->m_strExtension ) )
        {
            *ppScriptMapEntry = pScriptMapEntry;
            return TRUE;
        }
    }

    return FALSE;
}


VOID
META_SCRIPT_MAP::Terminate( VOID )
/*++

Routine Description:

Arguments:
    
Return Value:

--*/
{
    META_SCRIPT_MAP_ENTRY * pScriptMapEntry;

    while( !IsListEmpty( &m_StarScriptMapListHead ) )
    {
        pScriptMapEntry = CONTAINING_RECORD(  m_StarScriptMapListHead.Flink,
                                              META_SCRIPT_MAP_ENTRY,
                                              m_ListEntry );

        RemoveEntryList( &pScriptMapEntry->m_ListEntry );

        delete pScriptMapEntry;
    }

    while( !IsListEmpty( &m_ListHead ) )
    {
        pScriptMapEntry = CONTAINING_RECORD(  m_ListHead.Flink,
                                              META_SCRIPT_MAP_ENTRY,
                                              m_ListEntry );

        RemoveEntryList( &pScriptMapEntry->m_ListEntry );

        delete pScriptMapEntry;
    }
}

HRESULT
META_SCRIPT_MAP_ENTRY::Create(
    IN const WCHAR * szExtension,
    IN const WCHAR * szExecutable,
    IN DWORD         Flags,
    IN const WCHAR * szVerbs,
    IN DWORD         cchVerbs
    )
/*++

Routine Description:

Arguments:
    
Return Value:

--*/
{
    HRESULT hr = NOERROR;
    DWORD cchExecutable;

    //
    // Capture initialization parameters
    //

    m_Flags = Flags;

    hr = m_strExtension.Copy( szExtension );
    if( FAILED(hr) )
    {
        return hr;
    }

    //
    // Lower-case to allow for case insensitive comparisons
    //
    _wcslwr( m_strExtension.QueryStr() );
    
    if (szExtension[0] == L'*' && szExtension[1] == L'\0')
    {
        m_fIsStarScriptMapEntry = TRUE;
    }

    //
    // We treat the executable name as an ExpandSz, so expand it
    //
    WCHAR szExpand[MAX_PATH + 1];
    if (!ExpandEnvironmentStrings(szExecutable,
                                  szExpand,
                                  sizeof szExpand/sizeof WCHAR))
    {
        return HRESULT_FROM_WIN32(GetLastError());
    }

    if (FAILED(hr = m_strExecutable.Copy( szExpand )))
    {
        return hr;
    }
    
    //
    // If the executable is quoted, remove the quotes now
    //
    // Note that we can't just remove the first and last
    // quote, as it's possible that the script map entry
    // could look like this:
    //
    //   "c:\program files\test\test.exe" "%s" "%s"
    //
    if ( m_strExecutable.QueryStr()[ 0 ] == L'\"' &&
         wcschr( m_strExecutable.QueryStr() + 1, L'\"' ) )
    {
        LPWSTR  pCursor;

        cchExecutable = m_strExecutable.QueryCCH();

        pCursor = m_strExecutable.QueryStr();

        while ( *(pCursor+1) != L'\"' )
        {
            *pCursor = *(pCursor+1);

            pCursor++;
        }

        while ( *(pCursor+2) != L'\0' )
        {
            *pCursor = *(pCursor+2);

            pCursor++;
        }

        *pCursor = L'\0';

        m_strExecutable.SetLen( cchExecutable - 2 );
    }

    if (m_strExecutable.QueryCCH() > 4)
    {
        if (!_wcsicmp(
                 m_strExecutable.QueryStr() + m_strExecutable.QueryCCH() - 4,
                 L".dll"))
        {
            m_Gateway = GATEWAY_ISAPI;
        }
        else
        {
            m_Gateway = GATEWAY_CGI;
        }
    }
    else
    {
        return HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
    }

    if (!m_Verbs.AppendW( szVerbs, cchVerbs ))
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        return hr;
    }

    return S_OK;
}

HRESULT
W3_METADATA_CACHE::Initialize(
    VOID
)
/*++

  Description:

    Initialize metadata cache

  Arguments:

    None

  Return:

    HRESULT

--*/
{
    HRESULT             hr;
    DWORD               dwData;
    DWORD               dwType;
    DWORD               cbData = sizeof( DWORD );
    DWORD               csecTTL = DEFAULT_W3_METADATA_CACHE_TTL;
    HKEY                hKey;

    //
    // What is the TTL for the URI cache
    //
    
    if ( RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                       L"System\\CurrentControlSet\\Services\\w3svc\\Parameters",
                       0,
                       KEY_READ,
                       &hKey ) == ERROR_SUCCESS )
    {
        DBG_ASSERT( hKey != NULL );
        
        if ( RegQueryValueEx( hKey,
                              L"MetadataCacheTTL",
                              NULL,
                              &dwType,
                              (LPBYTE) &dwData,
                              &cbData ) == ERROR_SUCCESS &&
             dwType == REG_DWORD )
        {
            csecTTL = dwData;
        }

        RegCloseKey( hKey );
    }                      
    
    //
    // We'll use TTL for scavenge period, and expect two inactive periods to
    // flush
    //
    
    hr = SetCacheConfiguration( csecTTL * 1000, 
                                csecTTL * 1000,
                                CACHE_INVALIDATION_METADATA,
                                NULL );
    if ( FAILED( hr ) )
    {
        return hr;
    }

    return W3_METADATA::Initialize();
}

HRESULT
W3_METADATA_CACHE::GetMetaData(
    W3_CONTEXT *                pW3Context,
    STRU &                      strUrl,
    W3_METADATA **              ppMetaData
)
/*++

Routine Description:

    Retrieve a W3_METADATA, creating if necessary

Arguments:

    pW3Context - W3 context
    strUrl - Url
    ppMetaData - Set to point to metadata on success
    
Return Value:

    HRESULT

--*/
{
    W3_METADATA_KEY           metaKey;
    W3_METADATA *             pMetaData;
    DWORD                     dwDataSetNumber;
    HRESULT                   hr;
    STACK_STRU(               strFullPath, 128 );
    DATA_SET_CACHE *          pDataSetCache;
    MB                        mb( g_pW3Server->QueryMDObject() );
    HANDLE                    hToken = NULL;
    
    if ( pW3Context == NULL ||
         ppMetaData == NULL )
    {
        DBG_ASSERT( FALSE );
        hr = HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
        goto Failed;
    }
    
    *ppMetaData = NULL;
    
    //
    // Setup a key to lookup by determining data set number
    // 
    
    hr = GetFullMetadataPath( pW3Context,
                              strUrl,
                              &strFullPath );
    if ( FAILED( hr ) )
    {
        goto Failed;
    }
    
    //
    // Get a data set cache
    // 
    
    hr = pW3Context->QuerySite()->GetDataSetCache( &pDataSetCache );
    if ( FAILED( hr ) )
    {
        goto Failed;
    }
    
    DBG_ASSERT( pDataSetCache != NULL );
    
    hr = pDataSetCache->GetDataSetNumber( strFullPath,
                                          &dwDataSetNumber );

    pDataSetCache->DereferenceDataSetCache();
    pDataSetCache = NULL;

    if ( FAILED( hr ) )
    {
        goto Failed;
    }
    
    metaKey.SetDataSetNumber( dwDataSetNumber );
    
    //
    // Look it up
    //
    
    hr = FindCacheEntry( &metaKey, (CACHE_ENTRY**) &pMetaData );
    if ( SUCCEEDED( hr ) )
    {
        DBG_ASSERT( pMetaData != NULL );
       
        *ppMetaData = pMetaData;
        
        goto Succeeded;
    }
    
    //
    // We need to create a metadata entry and add it
    //
    
    if ( OpenThreadToken( GetCurrentThread(),
                          TOKEN_IMPERSONATE,
                          TRUE,
                          &hToken ) )
    {
        DBG_ASSERT( hToken != NULL );
        DBG_REQUIRE( RevertToSelf() );
    }

    hr = CreateNewMetaData( pW3Context,
                            strUrl,
                            strFullPath,
                            &pMetaData );
    if ( FAILED( hr ) )
    {
        goto Failed;
    }
    
    if ( hToken != NULL )
    {
        DBG_REQUIRE( SetThreadToken( NULL, hToken ) );
        DBG_REQUIRE( CloseHandle( hToken ) );
        hToken = NULL;
    }

    DBG_ASSERT( pMetaData != NULL );
    
    //
    // Add to the cache
    //
    
    AddCacheEntry( pMetaData );
    
    *ppMetaData = pMetaData;
    
Succeeded:

    DBG_ASSERT( SUCCEEDED( hr ) );

    return NO_ERROR;

Failed:

    if ( hToken != NULL )
    {
        DBG_REQUIRE( SetThreadToken( NULL, hToken ) );
        DBG_REQUIRE( CloseHandle( hToken ) );
        hToken = NULL;
    }

    DBG_ASSERT( FAILED( hr ) );

    return hr;

}

HRESULT
W3_METADATA_CACHE::CreateNewMetaData(
    W3_CONTEXT *            pW3Context,
    STRU &                  strUrl,
    STRU &                  strFullMetadataPath,
    W3_METADATA **          ppMetaData
)
/*++

Routine Description:

    Create a new W3_METADATA and initializes it

Arguments:

    pW3Context - context
    strUrl - URL
    strFullMetadataPath - Full metabase path to open
    ppMetaData - Set to new metadata entry on success

Return Value:

    HRESULT

--*/
{
    HRESULT                     hr;
    W3_METADATA *               pMetaData = NULL;
    
    if ( pW3Context == NULL ||
         ppMetaData == NULL )
    {
        DBG_ASSERT( FALSE );
        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }
    
    *ppMetaData = NULL;
    
    //
    // Create the metadata object
    //
    
    pMetaData = new W3_METADATA( this );
    if ( pMetaData == NULL )
    {
        return HRESULT_FROM_WIN32( GetLastError() );
    }
    
    //
    // Set full URL for flushing purposes
    //
    
    hr = pMetaData->QueryMetadataPath()->Copy( strFullMetadataPath );
    if ( FAILED( hr ) )
    {
        pMetaData->DereferenceCacheEntry();
        return hr;
    }
    
    //
    // Initialize it
    //

    hr = pMetaData->ReadMetaData( *(pW3Context->QuerySite()->QueryMBRoot()),
                                  strUrl );
    if( FAILED(hr) )
    {
        pMetaData->DereferenceCacheEntry();
        return hr;
    }

    *ppMetaData = pMetaData;

    return NO_ERROR;
}

HRESULT
W3_METADATA_CACHE::GetFullMetadataPath(
    W3_CONTEXT *                pW3Context,
    STRU &                      strUrl,
    STRU *                      pstrFullPath
)
/*++

Routine Description:

    Get the full metadata given the URL and site

Arguments:

    pW3Context - Used to get the site
    strUrl - Url
    pstrFullPath - Filled with full path on success
    
Return Value:

    HRESULT

--*/
{
    HRESULT             hr;
    WCHAR *             pszSource;
    DWORD               cchSource;

    if ( pW3Context == NULL ||
         pstrFullPath == NULL )
    {
        DBG_ASSERT( FALSE );
        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }
    
    //
    // Build up full metabase path (including instance)
    //
    
    hr = pstrFullPath->Copy( *(pW3Context->QuerySite()->QueryMBRoot()) );
    if ( FAILED( hr ) )
    {
        return hr;
    }
    
    //
    // Don't copy two slashes
    //
    
    if ( strUrl.QueryStr()[ 0 ] == L'/' ) 
    {
        pszSource = strUrl.QueryStr() + 1;
        cchSource = strUrl.QueryCCH() - 1;
    }
    else
    {
        pszSource = strUrl.QueryStr();
        cchSource = strUrl.QueryCCH();
    }
    
    hr = pstrFullPath->Append( pszSource, cchSource );
    if ( FAILED( hr ) )
    {
        return hr;
    }
   
    return NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\iisplus\ulw3\w3context.cxx ===
/*++

   Copyright    (c)    1999    Microsoft Corporation

   Module Name :
     w3context.cxx

   Abstract:
     Drive the state machine

   Author:
     Bilal Alam (balam)             10-Jan-2000

   Environment:
     Win32 - User Mode

   Project:
     ULW3.DLL
--*/

#include "precomp.hxx"
#include "anonymousprovider.hxx"
#include "customprovider.hxx"
#include "staticfile.hxx"
#include "isapi_handler.h"
#include "cgi_handler.h"
#include "trace_handler.h"
#include "dav_handler.h"
#include "options_handler.hxx"
#include "generalhandler.hxx"
#include "redirectionhandler.hxx"

//
// Global context list
//

CHAR                    W3_CONTEXT::sm_achRedirectMessage[ 512 ];
DWORD                   W3_CONTEXT::sm_cbRedirectMessage;
CHAR *                  W3_CONTEXT::sm_pszAccessDeniedMessage;

CHAR                    g_szErrorMessagePreHtml[] =
                            "<html><head><title>Error</title></head><body>";
CHAR                    g_szErrorMessagePostHtml[] =
                            "</body></html>";

ALLOC_CACHE_HANDLER *   EXECUTE_CONTEXT::sm_pachExecuteContexts;

HRESULT
EXECUTE_CONTEXT::InitializeFromExecUrlInfo(
    EXEC_URL_INFO *     pExecUrlInfo
)
/*++

Routine Description:

    Initialize an execution context from an HSE_EXEC_URL_INFO structure.
    This function does the necessary copying

Arguments:

    pExecUrlInfo - Describes the child request to execute

Return Value:

    HRESULT

--*/
{
    HRESULT                 hr;

    if ( pExecUrlInfo == NULL )
    {
        DBG_ASSERT( FALSE );
        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }

    //
    // Copy entity if (any)
    //

    if ( pExecUrlInfo->pEntity != NULL )
    {
        _EntityInfo.cbAvailable = pExecUrlInfo->pEntity->cbAvailable;
        _EntityInfo.lpbData = pExecUrlInfo->pEntity->lpbData;
        _ExecUrlInfo.pEntity = &_EntityInfo;
    }

    //
    // Copy user (if any)
    //

    if ( pExecUrlInfo->pUserInfo != NULL )
    {
        _UserInfo.hImpersonationToken = pExecUrlInfo->pUserInfo->hImpersonationToken;

        hr = _HeaderBuffer.AllocateSpace(
                        pExecUrlInfo->pUserInfo->cbUserName,
                        (LPWSTR *)&_UserInfo.pszUserName );

        if ( FAILED( hr ) )
        {
            return hr;
        }
        memcpy(_UserInfo.pszUserName,
               pExecUrlInfo->pUserInfo->pszUserName,
               pExecUrlInfo->pUserInfo->cbUserName);
        _UserInfo.cbUserName = pExecUrlInfo->pUserInfo->cbUserName;
        _UserInfo.fIsUserNameUnicode = pExecUrlInfo->pUserInfo->fIsUserNameUnicode;

        hr = _HeaderBuffer.AllocateSpace(
                        pExecUrlInfo->pUserInfo->pszAuthType,
                        strlen( pExecUrlInfo->pUserInfo->pszAuthType ),
                        &( _UserInfo.pszAuthType ) );

        if ( FAILED( hr ) )
        {
            return hr;
        }

        _ExecUrlInfo.pUserInfo = &_UserInfo;
    }

    //
    // Copy URL (if any)
    //

    if ( pExecUrlInfo->pszUrl != NULL )
    {
        hr = _HeaderBuffer.AllocateSpace(
                            pExecUrlInfo->cbUrl,
                            (LPWSTR *)&_ExecUrlInfo.pszUrl );

        if ( FAILED( hr ) )
        {
            return hr;
        }
        memcpy(_ExecUrlInfo.pszUrl,
               pExecUrlInfo->pszUrl,
               pExecUrlInfo->cbUrl);
        _ExecUrlInfo.cbUrl = pExecUrlInfo->cbUrl;
        _ExecUrlInfo.fIsUrlUnicode = pExecUrlInfo->fIsUrlUnicode;
    }

    //
    // Copy method (if any)
    //

    if ( pExecUrlInfo->pszMethod != NULL )
    {
        hr = _HeaderBuffer.AllocateSpace(
                            pExecUrlInfo->pszMethod,
                            strlen( pExecUrlInfo->pszMethod ),
                            &( _ExecUrlInfo.pszMethod ) );

        if ( FAILED( hr ) )
        {
            return hr;
        }
    }

    //
    // Copy child headers
    //

    if ( pExecUrlInfo->pszChildHeaders != NULL )
    {
        hr = _HeaderBuffer.AllocateSpace(
                            pExecUrlInfo->pszChildHeaders,
                            strlen( pExecUrlInfo->pszChildHeaders ),
                            &( _ExecUrlInfo.pszChildHeaders ) );

        if ( FAILED( hr ) )
        {
            return hr;
        }
    }

    _ExecUrlInfo.dwExecUrlFlags = pExecUrlInfo->dwExecUrlFlags;

    return NO_ERROR;
}

//static
HRESULT
EXECUTE_CONTEXT::Initialize(
    VOID
)
/*++

Routine Description:

    Initialize execute_context lookaside

Arguments:

    None

Return Value:

    HRESULT

--*/
{
    ALLOC_CACHE_CONFIGURATION       acConfig;

    //
    // Setup allocation lookaside
    //

    acConfig.nConcurrency = 1;
    acConfig.nThreshold = 100;
    acConfig.cbSize = sizeof( EXECUTE_CONTEXT );

    DBG_ASSERT( sm_pachExecuteContexts == NULL );

    sm_pachExecuteContexts = new ALLOC_CACHE_HANDLER( "EXECUTE_CONTEXT",
                                                       &acConfig );
    if ( sm_pachExecuteContexts == NULL )
    {
        return HRESULT_FROM_WIN32( GetLastError() );
    }

    return NO_ERROR;
}

//static
VOID
EXECUTE_CONTEXT::Terminate(
    VOID
)
/*++

Routine Description:

    Cleanup execute_context lookaside

Arguments:

    None

Return Value:

    None

--*/
{
    if ( sm_pachExecuteContexts != NULL )
    {
        delete sm_pachExecuteContexts;
        sm_pachExecuteContexts = NULL;
    }
}

HRESULT
W3_CONTEXT::IsapiExecuteUrl(
    EXEC_URL_INFO *pExecUrlInfo
)
/*++

Routine Description:

    Do an ISAPI execute URL request.

    SO WHY IS THIS CODE NOT IN THE ISAPI_CORE?

    Because I don't want to preclude the same child execute API exposed to
    ISAPI filters (though of course just the synchronous version)

Arguments:

    pExecUrlInfo - Describes the child request to execute

Return Value:

    HRESULT

--*/
{
    DWORD               dwExecFlags = 0;
    WCHAR *             pszRequiredAppPool = NULL;
    BOOL                fIgnoreValidation = FALSE;
    W3_REQUEST *        pChildRequest = NULL;
    W3_CHILD_CONTEXT *  pChildContext = NULL;
    HRESULT             hr = NO_ERROR;
    DWORD               dwCloneRequestFlags = 0;
    BOOL                fFinished = FALSE;
    STACK_STRA(         strNewVerb, 10 );
    BOOL                fIsSSICommandExecution = FALSE;
    W3_HANDLER *        pSSICommandHandler = NULL;
    HANDLE              hImpersonationToken = NULL;
    W3_USER_CONTEXT *   pCustomUser = NULL;
    STACK_STRA(         strAuthorization, 24 );
    STACK_STRA(         strCustomAuthType, 32 );
    STACK_STRA(         strCustomUserName, 64 );
    BOOL                fSameUrl = FALSE;
    DWORD               dwRemainingData;

    if ( pExecUrlInfo == NULL )
    {
        DBG_ASSERT( FALSE );
        hr = HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
        goto Finished;
    }

    if ( _dwRecursionLevel >= W3_CONTEXT_MAX_RECURSION_LEVEL )
    {
        hr = HRESULT_FROM_WIN32( ERROR_STACK_OVERFLOW );
        goto Finished;
    }


    //
    // Is this a SSI hack
    //

    if ( pExecUrlInfo->dwExecUrlFlags & HSE_EXEC_URL_SSI_CMD )
    {
        //
        // Issue-10-11-2000-BAlam
        //
        // This is a really dangerous code path (executing a raw command)
        // so verify that SSI is calling us
        //

        fIsSSICommandExecution = TRUE;
    }

    //
    // We always execute the request asynchronously
    //

    dwExecFlags |= W3_FLAG_ASYNC;

    //
    // Should we suppress headers in the response (useful for SSI)
    //

    if ( pExecUrlInfo->dwExecUrlFlags & HSE_EXEC_URL_NO_HEADERS )
    {
        dwExecFlags |= W3_FLAG_NO_HEADERS;
    }

    //
    // Should we disable custom errors
    //

    if ( pExecUrlInfo->dwExecUrlFlags & HSE_EXEC_URL_DISABLE_CUSTOM_ERROR )
    {
        dwExecFlags |= W3_FLAG_NO_ERROR_BODY;
    }

    //
    // In every case we will clone the basics
    //

    dwCloneRequestFlags = W3_REQUEST_CLONE_BASICS;

    //
    // If the client specified headers, then we don't want to clone any
    // headers
    //

    if ( pExecUrlInfo->pszChildHeaders == NULL )
    {
        dwCloneRequestFlags |= W3_REQUEST_CLONE_HEADERS;
    }

    //
    // Now, should we also clone the precondition headers?
    //

    if ( pExecUrlInfo->dwExecUrlFlags & HSE_EXEC_URL_IGNORE_VALIDATION_AND_RANGE )
    {
        dwCloneRequestFlags |= W3_REQUEST_CLONE_NO_PRECONDITION;
    }

    //
    // Now, should we also clone the preloaded entity?
    //

    if ( pExecUrlInfo->pEntity == NULL )
    {
        dwCloneRequestFlags |= W3_REQUEST_CLONE_ENTITY;
    }

    //
    // OK.  Start the fun by cloning the current request (as much as needed)
    //

    DBG_ASSERT( QueryRequest() != NULL );

    hr = QueryRequest()->CloneRequest( dwCloneRequestFlags,
                                       &pChildRequest );
    if ( FAILED( hr ) )
    {
        goto Finished;
    }

    DBG_ASSERT( pChildRequest != NULL );

    //
    // If the parent specified headers, add them now
    //

    if ( pExecUrlInfo->pszChildHeaders != NULL )
    {
        hr = pChildRequest->SetHeadersByStream( pExecUrlInfo->pszChildHeaders );
        if ( FAILED( hr ) )
        {
            goto Finished;
        }
    }

    //
    // If we have entity to stuff in, do so now
    //

    if ( pExecUrlInfo->pEntity != NULL )
    {
        hr = pChildRequest->AppendEntityBody( pExecUrlInfo->pEntity->lpbData,
                                              pExecUrlInfo->pEntity->cbAvailable );
        if ( FAILED( hr ) )
        {
            goto Finished;
        }

        //
        // Fix up the content-length header for the child.
        //
        // Note that if the request is chunk transfer
        // encoded then the size of remaining data will
        // be 0xffffffff, and we should not mess with it.
        //

        dwRemainingData = QueryRemainingEntityFromUl();

        if ( dwRemainingData < 0xffffffff )
        {
            STACK_STRA( strName, 32 );
            STACK_STRA( strValue, 16 );
            DWORD   dwNewContentLength;

            dwNewContentLength = dwRemainingData + pExecUrlInfo->pEntity->cbAvailable;

            //
            // It would be bad to wrap around the length
            //

            if ( dwNewContentLength < dwRemainingData &&
                 dwNewContentLength < pExecUrlInfo->pEntity->cbAvailable )
            {
                dwNewContentLength = 0xfffffffe;
            }

            hr = strName.Copy( "Content-Length" );

            if ( FAILED( hr ) )
            {
                goto Finished;
            }

            //
            // Only safe because 0xfffffffe is 10 digits
            // as a string!
            //

            _ultoa( dwNewContentLength, strValue.QueryStr(), 10 );

            strValue.SetLen( strlen( strValue.QueryStr() ) );

            hr = pChildRequest->SetHeader( strName, strValue );

            if ( FAILED( hr ) )
            {
                DBG_ASSERT( FALSE );
                goto Finished;
            }
        }
    }

    //
    // Setup the URL for the request, if specified (it can contain a
    // query string)
    //
    // If this is a command execution, then ignore the URL since it really
    // isn't a URL in this case (it is a command to execute)
    //
    // Also figure out if the new URL is the same as the old one (except maybe
    // the querystring) because that affects how *-ScriptMaps get executed.
    //

    if ( pExecUrlInfo->pszUrl == NULL )
    {
        fSameUrl = TRUE;
    }

    if ( pExecUrlInfo->pszUrl != NULL &&
         !fIsSSICommandExecution )
    {
        if (pExecUrlInfo->fIsUrlUnicode)
        {
            STACK_STRU(         strNewUrl, 256 );
            hr = strNewUrl.Copy( (WCHAR *)pExecUrlInfo->pszUrl );
            if ( FAILED( hr ) )
            {
                goto Finished;
            }

            //
            // Now set the new URL/Querystring
            //

            hr = pChildRequest->SetUrl( strNewUrl );
            if ( FAILED( hr ) )
            {
                goto Finished;
            }
        }
        else
        {
            STACK_STRA(         strNewUrl, 256 );
            hr = strNewUrl.Copy( (CHAR *)pExecUrlInfo->pszUrl );
            if ( FAILED( hr ) )
            {
                goto Finished;
            }

            //
            // Now set the new URL/Querystring
            //

            hr = pChildRequest->SetUrlA( strNewUrl );
            if ( FAILED( hr ) )
            {
                goto Finished;
            }
        }

        STACK_STRU( strParentUrl, 256);
        STACK_STRU( strChildUrl, 256);
        if (FAILED( hr = QueryRequest()->GetUrl( &strParentUrl ) ) ||
            FAILED( hr = pChildRequest->GetUrl( &strChildUrl ) ) )
        {
            goto Finished;
        }

        if ( strChildUrl.QueryCCH() == strParentUrl.QueryCCH() &&
             _wcsicmp(strChildUrl.QueryStr(), strParentUrl.QueryStr()) == 0 )
        {
            fSameUrl = TRUE;
        }
    }

    //
    // Set the verb for this request if specified
    //

    if ( pExecUrlInfo->pszMethod != NULL )
    {
        hr = strNewVerb.Copy( pExecUrlInfo->pszMethod );
        if ( FAILED( hr ) )
        {
            goto Finished;
        }

        hr = pChildRequest->SetVerb( strNewVerb );
        if ( FAILED( hr ) )
        {
            goto Finished;
        }
    }

    //
    // If a user context was set for this child request, then create a
    // custom user context and do the necessary hookup
    //

    if ( pExecUrlInfo->pUserInfo != NULL )
    {
        if ( pExecUrlInfo->pUserInfo->hImpersonationToken != NULL )
        {
            hImpersonationToken = (HANDLE)pExecUrlInfo->pUserInfo->hImpersonationToken;
        }
        else
        {
            hImpersonationToken = QueryImpersonationToken();
        }

        DBG_ASSERT( hImpersonationToken != NULL );

        //
        // Create the user context
        //

        pCustomUser = new CUSTOM_USER_CONTEXT(
                            W3_STATE_AUTHENTICATION::QueryCustomProvider() );
        if ( pCustomUser == NULL )
        {
            goto Finished;
        }

        hr = ((CUSTOM_USER_CONTEXT*)pCustomUser)->Create( 
                                  hImpersonationToken,
                                  pExecUrlInfo->pUserInfo->pszUserName,
                                  pExecUrlInfo->pUserInfo->fIsUserNameUnicode,
                                  QueryUserContext()->QueryAuthType() );
        if ( FAILED( hr ) )
        {
            goto Finished;
        }

        //
        // Make sure REMOTE_USER is calculated properly
        //

        if (pExecUrlInfo->pUserInfo->fIsUserNameUnicode)
        {
            hr = strCustomUserName.CopyW( (WCHAR *)pExecUrlInfo->pUserInfo->pszUserName );
        }
        else
        {
            hr = strCustomUserName.Copy( (CHAR *)pExecUrlInfo->pUserInfo->pszUserName );
        }
        if ( FAILED( hr ) )
        {
            goto Finished;
        }

        hr = pChildRequest->SetRequestUserName( strCustomUserName );
        if ( FAILED( hr ) )
        {
            goto Finished;
        }

        //
        // Note that AUTH_TYPE server variable is a request'ism.  So stuff it
        // into the request now indirectly by setting authorization header
        //

        hr = strAuthorization.Copy( "Authorization" );
        if ( FAILED( hr ) )
        {
            goto Finished;
        }

        hr = strCustomAuthType.Copy( pExecUrlInfo->pUserInfo->pszAuthType );
        if ( FAILED( hr ) )
        {
            goto Finished;
        }

        hr = pChildRequest->SetHeader( strAuthorization,
                                       strCustomAuthType,
                                       FALSE );
        if ( FAILED( hr ) )
        {
            goto Finished;
        }
    }
    else
    {
        //
        // No custom user.  Use this current request's user context
        //

        pCustomUser = QueryUserContext();

        if ( pCustomUser != NULL )
        {
            pCustomUser->ReferenceUserContext();
        }        
    }

    //
    // If a *-ScriptMap wants to be ignored for all child-requests from here
    // on out, oblige it
    //
    if ( pExecUrlInfo->dwExecUrlFlags & HSE_EXEC_URL_IGNORE_CURRENT_INTERCEPTOR )
    {
        META_SCRIPT_MAP_ENTRY *pScriptMapEntry = QueryHandler()->QueryScriptMapEntry();
        if (pScriptMapEntry != NULL &&
            pScriptMapEntry->QueryIsStarScriptMap())
        {
            hr = QueryMainContext()->AppendIgnoreInterceptor(*pScriptMapEntry->QueryExecutable());
            if ( FAILED( hr ) )
            {
                goto Finished;
            }
        }
    }

    //
    // If we are re-executing the same URL and there is no current *-ScriptMap
    // it must be DAV, so remove the DAV headers
    //
    if (fSameUrl &&
        QueryUrlContext()->QueryMetaData()->QueryScriptMap()->QueryStarScriptMap( QueryCurrentStarScriptMapIndex() ) == NULL)
    {
        pChildRequest->RemoveDav();
    }

    //
    // Now we can create a child context
    //

    pChildContext = new W3_CHILD_CONTEXT( QueryMainContext(),
                                          this,             // parent
                                          pChildRequest,
                                          TRUE,             // child owns
                                          pCustomUser,
                                          dwExecFlags,
                                          fSameUrl,
                                          _dwRecursionLevel + 1 );
    if ( pChildContext == NULL )
    {
        hr = HRESULT_FROM_WIN32( GetLastError() );
        goto Finished;
    }

    //
    // Get the URL context for this new context
    //

    hr = pChildContext->RetrieveUrlContext( &fFinished );
    if ( FAILED( hr ) )
    {
        goto Finished;
    }

    if ( fFinished )
    {
        //
        // Filter wants to bail.
        //

        hr = HRESULT_FROM_WIN32( ERROR_NOT_SUPPORTED );
        goto Finished;
    }

    //
    // ULTRA-GROSS.  If this is an explicit command execution from SSI, then
    // we explicitly setup the CGI handler.  Otherwise, we determine the
    // handler using sane rules
    //

    if ( fIsSSICommandExecution )
    {
        DBG_ASSERT( !pExecUrlInfo->fIsUrlUnicode );

        pSSICommandHandler = new W3_CGI_HANDLER( pChildContext,
                                                 NULL,
                                                 (CHAR *)pExecUrlInfo->pszUrl );
        if ( pSSICommandHandler == NULL )
        {
            hr = HRESULT_FROM_WIN32( GetLastError() );
            goto Finished;
        }

        pChildContext->SetSSICommandHandler( pSSICommandHandler );
    }
    else
    {
        //
        // Properly find a handler for this request
        //

        hr = pChildContext->DetermineHandler();
        if ( FAILED( hr ) )
        {
            goto Finished;
        }
    }

    DBG_ASSERT( pChildContext->QueryHandler() != NULL );

    hr = pChildContext->ExecuteHandler( dwExecFlags );

    //
    // If we failed, then we should just cleanup and report the error.
    //
    // NOTE:  Failure means failure to spawn the child request.  Not that
    //        the child request encountered a failure.
    //

Finished:

    //
    // If we spawned this async, and there was no failure, then return out
    //

    if ( SUCCEEDED( hr ) && ( dwExecFlags & W3_FLAG_ASYNC ) )
    {
        return NO_ERROR;
    }

    //
    // If we're here, we either failed, or succeeded synchronously
    //

    //
    // If the urlcontext/child-request was attached to the child context,
    // the child context will clean it up
    //

    if ( pChildContext != NULL )
    {
        delete pChildContext;
    }
    else
    {
        if ( pChildRequest != NULL )
        {
            delete pChildRequest;
        }

        if ( pCustomUser != NULL )
        {
            pCustomUser->DereferenceUserContext();
            pCustomUser = NULL;
        }
    }

    return hr;
}

HRESULT
W3_CONTEXT::ExecuteChildRequest(
    W3_REQUEST *            pNewRequest,
    BOOL                    fOwnRequest,
    DWORD                   dwFlags
)
/*++

Routine Description:

    Execute a child request (for internal W3CORE use only)

Arguments:

    pNewRequest - W3_REQUEST * representing the new request
    fOwnRequest - Should the child context be responsible for cleaning up
                  request?
    dwFlags - W3_FLAG_ASYNC async
              W3_FLAG_SYNC sync
              W3_FLAG_MORE_DATA caller needs to send data too,
              W3_FLAG_NO_CUSTOM_ERROR do not execute custom errors

Return Value:

    HRESULT

--*/
{
    HRESULT                 hr;
    W3_CHILD_CONTEXT *      pChildContext = NULL;
    BOOL                    fFinished = FALSE;
    W3_USER_CONTEXT *       pUserContext = NULL;

    if ( !VALID_W3_FLAGS( dwFlags ) )
    {
        DBG_ASSERT( FALSE );
        hr = HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
        goto Finished;
    }

    if ( _dwRecursionLevel >= W3_CONTEXT_MAX_RECURSION_LEVEL )
    {
        hr = HRESULT_FROM_WIN32( ERROR_STACK_OVERFLOW );
        goto Finished;
    }
    
    //
    // Use the current user
    //
    
    pUserContext = QueryUserContext();
    if ( pUserContext != NULL )
    {
        pUserContext->ReferenceUserContext();
    }

    //
    // Ignore the fFinished value on a child
    //

    pChildContext = new W3_CHILD_CONTEXT( QueryMainContext(),
                                          this,
                                          pNewRequest,
                                          fOwnRequest,
                                          pUserContext,
                                          dwFlags,
                                          FALSE,
                                          _dwRecursionLevel + 1 );
    if ( pChildContext == NULL )
    {
        hr = HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
        goto Finished;
    }

    //
    // First read the metadata for this new request
    //

    hr = pChildContext->RetrieveUrlContext( &fFinished );
    if ( FAILED( hr ) )
    {
        goto Finished;
    }

    if ( fFinished )
    {
        //
        // Filter wants to bail.
        //

        hr = HRESULT_FROM_WIN32( ERROR_NOT_SUPPORTED );
        goto Finished;
    }

    //
    // Find handler
    //

    hr = pChildContext->DetermineHandler();
    if ( FAILED( hr ) )
    {
        goto Finished;
    }

    DBG_ASSERT( pChildContext->QueryHandler() );

    //
    // Execute the handler and take the error in any non-pending case
    // (we can't get the status on pending since the value we would be
    // getting is instable)
    //

    hr = pChildContext->ExecuteHandler( dwFlags );

Finished:

    //
    // If we spawned this async, and there was no failure, then return out
    //

    if ( !FAILED( hr ) && ( dwFlags & W3_FLAG_ASYNC ) )
    {
        return NO_ERROR;
    }

    //
    // If we got here, then either something bad happened OR a synchronous
    // child execute is complete.  Either way, we can delete the context
    // here
    //

    if ( pChildContext != NULL )
    {
        delete pChildContext;
    }
    else
    {
        if ( pNewRequest && fOwnRequest )
        {
            delete pNewRequest;
        }
        
        if ( pUserContext != NULL )
        {
            pUserContext->DereferenceUserContext();
            pUserContext = NULL;
        }
    }

    return hr;
}

HRESULT
W3_CONTEXT::SetupAllowHeader(
    VOID
)
/*++

Routine Description:

    Setup a 405 response.  This means setting the response status as well
    as setting up an appropriate Allow: header

Arguments:

    None

Return Value:

    HRESULT

--*/
{
    STACK_STRA(             strAllowHeader, 256 );
    URL_CONTEXT *           pUrlContext;
    HRESULT                 hr;
    W3_URL_INFO *           pUrlInfo;
    W3_METADATA *           pMetaData;
    MULTISZA *              pAllowedVerbs;
    const CHAR *            pszAllowedVerb;

    pUrlContext = QueryUrlContext();
    if ( pUrlContext == NULL )
    {
        //
        // If we have no metadata, then don't send an Allow: header.  The
        // only case this would happen is if a filter decided to send the
        // response and in that case it is up to it to send an appropriate
        // Allow: header
        //

        return NO_ERROR;
    }

    pUrlInfo = pUrlContext->QueryUrlInfo();
    if ( pUrlInfo == NULL )
    {
        DBG_ASSERT( FALSE );
        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }

    pMetaData = pUrlContext->QueryMetaData();
    if ( pMetaData == NULL )
    {
        DBG_ASSERT( FALSE );
        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }

    //
    // We always support OPTIONS and TRACE
    //

    hr = strAllowHeader.Append( "OPTIONS, TRACE" );
    if ( FAILED( hr ) )
    {
        return hr;
    }

    //
    // Is this URL script mapped?  If so, then the verbs allowed is equal to
    // to the verbs specified in the script map, provided that we have
    // script execute permissions
    //

    if ( pUrlInfo->QueryScriptMapEntry() != NULL )
    {
        if ( IS_ACCESS_ALLOWED( QueryRequest(),
                                pMetaData->QueryAccessPerms(),
                                SCRIPT ) )
        {
            pAllowedVerbs = pUrlInfo->QueryScriptMapEntry()->QueryAllowedVerbs();
            DBG_ASSERT( pAllowedVerbs != NULL );

            pszAllowedVerb = pAllowedVerbs->First();
            while ( pszAllowedVerb != NULL )
            {
                hr = strAllowHeader.Append( ", " );
                if ( FAILED( hr ) )
                {
                    return hr;
                }

                hr = strAllowHeader.Append( pszAllowedVerb );
                if (FAILED(hr))
                {
                    return hr;
                }

                pszAllowedVerb = pAllowedVerbs->Next( pszAllowedVerb );
            }
        }
    }
    else
    {
        //
        // Must be a static file or a explicit gateway
        //

        switch( pUrlInfo->QueryGateway() )
        {
        case GATEWAY_UNKNOWN:
        case GATEWAY_MAP:
            hr = strAllowHeader.Append( ", GET, HEAD" );
            break;
        case GATEWAY_CGI:
        case GATEWAY_ISAPI:
            hr = strAllowHeader.Append( ", GET, HEAD, POST" );
            break;
        }

        if ( FAILED( hr ) )
        {
            return hr;
        }
    }

    //
    // Now add some DAV verbs (man, this is broken)
    //

    if ( IS_ACCESS_ALLOWED( QueryRequest(),
                            pMetaData->QueryAccessPerms(),
                            WRITE ) &&
         g_pW3Server->QueryIsDavEnabled() )
    {
        hr = strAllowHeader.Append( ", DELETE, PUT" );
        if ( FAILED( hr ) )
        {
            return hr;
        }
    }

    //
    // Finally, set the header
    //

    hr = QueryResponse()->SetHeader( HttpHeaderAllow,
                                     strAllowHeader.QueryStr(),
                                     (USHORT)strAllowHeader.QueryCCH() );

    return hr;
}

HRESULT
W3_CONTEXT::SetupCustomErrorFileResponse(
    STRU &                  strErrorFile
)
/*++

Routine Description:

    Open the custom error file (nor URL) from cache if possible and setup
    the response (which means, fill in entity body with file)

Arguments:

    strErrorFile - Custom Error File

Return Value:

    HRESULT (HRESULT_FROM_WIN32( ERROR_FILE_NOT_FOUND) to indicate to caller
    that it should just generate hard coded custom error.

--*/
{
    W3_FILE_INFO *          pOpenFile = NULL;
    HRESULT                 hr = NO_ERROR;
    DWORD                   dwFlags;
    W3_RESPONSE *           pResponse = QueryResponse();
    CACHE_USER              fileUser;
    ULARGE_INTEGER          liFileSize;
    W3_METADATA *           pMetaData;
    URL_CONTEXT *           pUrlContext;
    STACK_STRA(             strContentType, 32 );

    DBG_ASSERT( pResponse != NULL );
    DBG_ASSERT( !pResponse->QueryEntityExists() );
    DBG_ASSERT( pResponse->QueryStatusCode() >= 400 );

    //
    // Get the file from the cache.  We will enable deferred directory
    // monitor changes.  This means that we will register for the appropriate
    // parent directory changes as needed and remove as the cached file
    // object goes away.
    //

    DBG_ASSERT( g_pW3Server->QueryFileCache() != NULL );

    hr = g_pW3Server->QueryFileCache()->GetFileInfo( strErrorFile,
                                                     NULL,
                                                     &fileUser,
                                                     TRUE,
                                                     &pOpenFile );
    if ( FAILED( hr ) )
    {
        //
        // If we cannot open the file for whatever reason, return
        // as if the file didn't exist, so that caller can proceed by sending
        // no custom error

        return HRESULT_FROM_WIN32( ERROR_FILE_NOT_FOUND );
    }

    DBG_ASSERT( pOpenFile != NULL );

    //
    // We might already have a custom error file IF we encountered an error
    // setting up the last custom error response
    //

    if ( _pCustomErrorFile != NULL )
    {
        _pCustomErrorFile->DereferenceCacheEntry();
        _pCustomErrorFile = NULL;
    }

    DBG_ASSERT( pOpenFile != NULL );
    _pCustomErrorFile = pOpenFile;

    //
    // Determine the content-type and set the header
    //

    pUrlContext = QueryUrlContext();
    DBG_ASSERT( pUrlContext != NULL );

    pMetaData = pUrlContext->QueryMetaData();
    DBG_ASSERT( pMetaData != NULL );

    hr = SelectMimeMappingForFileExt( strErrorFile.QueryStr(),
                                      pMetaData->QueryMimeMap(),
                                      &strContentType );
    if ( SUCCEEDED( hr ) )
    {
        hr = pResponse->SetHeader( HttpHeaderContentType,
                                   strContentType.QueryStr(),
                                   (USHORT)strContentType.QueryCCH() );
        if ( FAILED( hr ) )
        {
            return hr;
        }
    }

    //
    // Now setup the response chunk
    //

    pOpenFile->QuerySize( &liFileSize );

    if ( pOpenFile->QueryFileBuffer() != NULL )
    {
        hr = pResponse->AddMemoryChunkByReference(
                                pOpenFile->QueryFileBuffer(),
                                liFileSize.LowPart );
    }
    else
    {
        hr = pResponse->AddFileHandleChunk(pOpenFile->QueryFileHandle(),
                                           0,
                                           liFileSize.LowPart );
    }

    return hr;
}

HANDLE
W3_CONTEXT::QueryImpersonationToken(
    BOOL *                      pfIsVrToken
)
/*++

Routine Description:

    Get the impersonation token for this request.  This routine will
    choose correctly based on whether there is a VRoot token

Arguments:

    pfIsVrToken - Set to TRUE if this is the metabase user (instead of 
                  authenticated user)

Return Value:

    HANDLE

--*/
{
    W3_METADATA *           pMetaData;
    W3_USER_CONTEXT *       pUserContext;
    HANDLE                  hToken;

    if ( QueryUrlContext() == NULL )
    {
        return NULL;
    }

    pMetaData = QueryUrlContext()->QueryMetaData();
    DBG_ASSERT( pMetaData != NULL );

    if( _pctVrToken == NULL )
    {
        pMetaData->GetAndRefVrAccessToken( &_pctVrToken );
    }
    
    if ( _pctVrToken == NULL )
    {
        if ( pfIsVrToken )
        {
            *pfIsVrToken = FALSE;
        }

        pUserContext = QueryUserContext();

        hToken = pUserContext != NULL ? pUserContext->QueryImpersonationToken() : NULL;
    }
    else
    {
        DBG_ASSERT( _pctVrToken != NULL );

        if ( pfIsVrToken )
        {
            *pfIsVrToken = TRUE;
        }

        hToken = _pctVrToken->QueryImpersonationToken();
    }

    return hToken;
}

VOID
W3_CONTEXT::QueryFileCacheUser(
    CACHE_USER *           pFileCacheUser
)
/*++

Routine Description:

    Get a user descriptor suitable for use with file cache

Arguments:

    pFileCacheUser - Filled with file cache user information

Return Value:

    None

--*/
{
    W3_METADATA *           pMetaData;
    W3_USER_CONTEXT *       pUserContext;
    HANDLE                  hReturnToken = NULL;
    PSID                    pReturnSid = NULL;

    DBG_ASSERT( pFileCacheUser != NULL );

    DBG_ASSERT( QueryUrlContext() != NULL );

    pMetaData = QueryUrlContext()->QueryMetaData();
    DBG_ASSERT( pMetaData != NULL );

    pUserContext = QueryUserContext();
    DBG_ASSERT( pUserContext != NULL );

    if( _pctVrToken == NULL )
    {
        pMetaData->GetAndRefVrAccessToken( &_pctVrToken );
    }
    
    if ( _pctVrToken == NULL )
    {
        hReturnToken = pUserContext->QueryImpersonationToken();
        pReturnSid = pUserContext->QuerySid();
    }
    else
    {
        DBG_ASSERT( _pctVrToken != NULL );

        pReturnSid = _pctVrToken->QuerySid();
        hReturnToken = _pctVrToken->QueryImpersonationToken();
    }

    //
    // Setup the file cache user
    //

    pFileCacheUser->_hToken = hReturnToken;
    pFileCacheUser->_pSid = pReturnSid;
}

HANDLE
W3_CONTEXT::QueryPrimaryToken(
    VOID
)
/*++

Routine Description:

    Get the primary token for this request.  This routine will
    choose correctly based on whether there is a VRoot token

Arguments:

    None

Return Value:

    HANDLE

--*/
{
    W3_METADATA *           pMetaData;
    W3_USER_CONTEXT *       pUserContext;
    HANDLE                  hToken;

    DBG_ASSERT( QueryUrlContext() != NULL );

    pMetaData = QueryUrlContext()->QueryMetaData();
    DBG_ASSERT( pMetaData != NULL );

    pUserContext = QueryUserContext();
    DBG_ASSERT( pUserContext != NULL );

    if( _pctVrToken == NULL )
    {
        pMetaData->GetAndRefVrAccessToken( &_pctVrToken );
    }
    
    if ( _pctVrToken == NULL )
    {
        hToken = pUserContext->QueryPrimaryToken();
    }
    else
    {
        DBG_ASSERT( _pctVrToken != NULL );
        hToken = _pctVrToken->QueryPrimaryToken();
    }

    return hToken;
}

HRESULT
W3_CONTEXT::GetCertificateInfoEx(
    IN  DWORD           cbAllocated,
    OUT DWORD *         pdwCertEncodingType,
    OUT unsigned char * pbCertEncoded,
    OUT DWORD *         pcbCertEncoded,
    OUT DWORD *         pdwCertificateFlags
)
/*++

Routine Description:

    Retrieve certificate info if available

Arguments:

Return Value:

    HRESULT

--*/
{
    CERTIFICATE_CONTEXT *       pCertContext = NULL;
    DWORD                       cbCert = 0;
    PVOID                       pvCert = NULL;

    if ( pdwCertEncodingType == NULL ||
         pbCertEncoded == NULL ||
         pcbCertEncoded == NULL ||
         pdwCertificateFlags == NULL )
    {
        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }

    pCertContext = QueryCertificateContext();

    if ( pCertContext == NULL )
    {
        //
        // If we don't have a certificate, then just succeed with nothing
        // to keep in line with IIS 5 behaviour
        //

        *pbCertEncoded = NULL;
        *pcbCertEncoded = 0;
        return NO_ERROR;
    }

    pCertContext->QueryEncodedCertificate( &pvCert, &cbCert );
    DBG_ASSERT( pvCert != NULL );
    DBG_ASSERT( cbCert != 0 );

    //
    // Fill in the parameters
    //

    *pcbCertEncoded = cbCert;

    if ( cbAllocated < *pcbCertEncoded )
    {
        //
        // Not enough space
        //

        return HRESULT_FROM_WIN32( ERROR_INSUFFICIENT_BUFFER );
    }
    else
    {
        memcpy( pbCertEncoded,
                pvCert,
                *pcbCertEncoded );

        //
        // pdwCertificateFlags - legacy value
        // In IIS3 days client certificates were not verified by IIS
        // so applications needed certificate flags to make 
        // their own decisions regarding trust
        // Now only valid certificate allow access so value of 1 is
        // the only one that is valid for post IIS3 versions of IIS
        //
        *pdwCertificateFlags = 1;
        
        *pdwCertEncodingType = X509_ASN_ENCODING;

        return NO_ERROR;
    }
}

HRESULT
W3_CONTEXT::SendResponse(
    DWORD                   dwFlags
)
/*++

Routine Description:

    Sends a response to the client thru ULATQ.

Arguments:

    dwFlags - Flags
              W3_FLAG_ASYNC - Send response asynchronously
              W3_FLAG_SYNC - Send response synchronously
              W3_FLAG_MORE_DATA - Send more data
              W3_FLAG_NO_ERROR_BODY - Don't generate error body
              W3_FLAG_NO_CONTENT_LENGTH - Don't generate content-length

Return Value:

    HRESULT

--*/
{
    HRESULT                 hr = NO_ERROR;
    BOOL                    fIsFileError = FALSE;
    BOOL                    fFinished = FALSE;
    DWORD                   cbSent = 0;
    BOOL                    fAddContentLength = TRUE;
    BOOL                    fSendHeaders = FALSE;
    BOOL                    fHandlerManagesHead = FALSE;
    DWORD                   dwResponseFlags = 0;
    AUTH_PROVIDER *         pAnonymousProvider = NULL;
    W3_RESPONSE *           pResponse;
    W3_FILTER_CONTEXT *     pFilterContext;
    W3_USER_CONTEXT *       pUserContext = NULL;
    HTTP_CACHE_POLICY       cachePolicy;

    if ( !VALID_W3_FLAGS( dwFlags ) )
    {
        DBG_ASSERT( FALSE );
        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }

    pResponse = QueryResponse();
    DBG_ASSERT( pResponse != NULL );

    //
    // Should we be sending headers at all?
    //

    fSendHeaders = QuerySendHeaders();

    if ( !fSendHeaders ||
         dwFlags & W3_FLAG_NO_CONTENT_LENGTH ||
         pResponse->QueryStatusCode() == HttpStatusNotModified.statusCode )
    {
        fAddContentLength = FALSE;
    }

    //
    // Do a quick precheck to see whether we require an END_OF_REQUEST
    // notification.  If so, then this won't be our last send
    //

    //
    // Even if the caller didn't want to send any more data, if we are
    // expecting a post-response notification (END_OF_REQUEST/LOG), then
    // we need to tell UL to expect a final send
    //

    if ( IsNotificationNeeded( SF_NOTIFY_END_OF_REQUEST ) ||
         IsNotificationNeeded( SF_NOTIFY_LOG ) )
    {
        dwFlags |= W3_FLAG_MORE_DATA;
    }

    //
    // Remember whether we need to send an empty done on our own at the end
    //

    if ( dwFlags & W3_FLAG_MORE_DATA )
    {
        SetNeedFinalDone();
    }

    //
    // Was this an access denial not handled by an authentication provider?
    //

    if ( pResponse->QueryStatusCode() == HttpStatusUnauthorized.statusCode &&
         !QueryProviderHandled() &&
         QueryUrlContext() != NULL )
    {
        //
        // First call access denied filters
        //

        if ( IsNotificationNeeded( SF_NOTIFY_ACCESS_DENIED ) )
        {
            STACK_STRA( straUrl, 256 );
            STACK_STRA( straPhys, 256 );
            STACK_STRU( strUrl, 256 );
            STRU *      pstrPhysicalPath;

            hr = QueryRequest()->GetUrl( &strUrl );
            if ( FAILED( hr ) )
            {
                return hr;
            }

            pstrPhysicalPath = QueryUrlContext()->QueryPhysicalPath();
            DBG_ASSERT( pstrPhysicalPath != NULL );

            if (FAILED(hr = straUrl.CopyW(strUrl.QueryStr())) ||
                FAILED(hr = straPhys.CopyW(pstrPhysicalPath->QueryStr())))
            {
                return hr;
            }

            fFinished = FALSE;

            if ( !QueryFilterContext()->NotifyAccessDenied(
                                        straUrl.QueryStr(),
                                        straPhys.QueryStr(),
                                        &fFinished ) )
            {
                return HRESULT_FROM_WIN32( GetLastError() );
            }

            if ( fFinished )
            {
                if ( dwFlags & W3_FLAG_ASYNC )
                {
                    POST_MAIN_COMPLETION( QueryMainContext() );
                }

                return NO_ERROR;
            }
        }

        //
        // Now, notify all authentication providers so they can add headers
        // if necessary. We ignore the return value here since we want to be
        // able to send possible authentication headers back along with the
        // response
        //

        W3_STATE_AUTHENTICATION::CallAllAccessDenied( QueryMainContext() );
        
        //
        // If a response has been sent, then we can finish
        //
        
        if ( pResponse->QueryResponseSent() )
        {
            if ( dwFlags & W3_FLAG_ASYNC )
            {
                POST_MAIN_COMPLETION( QueryMainContext() );
            }
            
            return NO_ERROR;
        }
    }

    //
    // Send a custom error for this response if all of following are true:
    //
    // a) The caller wants an error body
    // b) This request (and all children) actually allow an error body
    // c) The response code is greater than 400 (error)
    //

    if ( !(dwFlags & W3_FLAG_NO_ERROR_BODY ) &&
         QuerySendErrorBody() &&
         pResponse->QueryStatusCode() >= 400 )
    {
        STACK_STRU(             strError, 64 );
        STACK_STRU(             strFullUrl, 64 );
        WCHAR                   achNum[ 32 ];
        HTTP_SUB_ERROR          subError;
        W3_REQUEST *            pChildRequest = NULL;

        DBG_ASSERT( pResponse->QueryEntityExists() == FALSE );

        DisableUlCache();

        //
        // Get the sub error for this response (if any)
        //

        hr = pResponse->QuerySubError( &subError );
        if ( FAILED( hr ) )
        {
            return hr;
        }

        //
        // Check for a configured custom error.  This check is only possible
        // if we have read metadata.  We may not have read metadata if
        // some fatal error occurred early in the pipeline (for example,
        // an out-of-mem error in the URLINFO state)
        //

        if ( QueryUrlContext() != NULL &&
             QuerySendCustomError() )
        {
            W3_METADATA *           pMetaData = NULL;

            pMetaData = QueryUrlContext()->QueryMetaData();
            DBG_ASSERT( pMetaData != NULL );

            hr = pMetaData->FindCustomError( pResponse->QueryStatusCode(),
                                             subError.mdSubError,
                                             &fIsFileError,
                                             &strError );

            //
            // If this is a file error, check for file existence now.  If it
            // does not exist, then act as if there is no custom error set
            //

            if ( SUCCEEDED( hr ) )
            {
                if ( fIsFileError )
                {
                    hr = SetupCustomErrorFileResponse( strError );
                }
                else
                {
                    //
                    // This is a custom error URL
                    //

                    //
                    // If there is no user context, then executing a child
                    // request would be tough.
                    //
                    // But we can still try to get the anonymous token, if
                    // it exists and use it
                    //

                    if ( QueryUserContext() == NULL )
                    {
                        pAnonymousProvider = W3_STATE_AUTHENTICATION::QueryAnonymousProvider();
                        DBG_ASSERT( pAnonymousProvider != NULL );

                        hr = pAnonymousProvider->DoAuthenticate( QueryMainContext(),
                                                                 &fFinished );
                        if ( FAILED( hr ) ||
                             QueryMainContext()->QueryUserContext() == NULL )
                        {
                            //
                            // Ok.  We really can't get anonymous user.
                            // No custom error URL
                            //

                            hr = HRESULT_FROM_WIN32( ERROR_FILE_NOT_FOUND );
                        }
                    }
                }
            }
        }
        else
        {
            hr = HRESULT_FROM_WIN32( ERROR_FILE_NOT_FOUND );
        }

        if ( SUCCEEDED( hr ) )
        {
            //
            // Great.  Send the configured custom error
            //

            if ( !fIsFileError )
            {
                //
                // This is a custom error URL.  Reset and launch custom URL
                //
                // The URL is of the form:
                //
                // /customerrorurl?<status>;http://<server>/<original url>
                //

                hr = strError.Append( L"?" );
                if ( FAILED( hr ) )
                {
                    return hr;
                }

                _itow( pResponse->QueryStatusCode(), achNum, 10 );

                hr = strError.Append( achNum );
                if ( FAILED( hr ) )
                {
                    return hr;
                }

                hr = strError.Append( L";" );
                if ( FAILED( hr ) )
                {
                    return hr;
                }

                hr = QueryRequest()->GetFullUrl( &strFullUrl );
                if ( FAILED( hr ) )
                {
                    return hr;
                }

                hr = strError.Append( strFullUrl );
                if ( FAILED( hr ) )
                {
                    return hr;
                }

                //
                // Now build up a new child request by first cloning the
                // existing request
                //

                hr = QueryRequest()->CloneRequest(
                                    W3_REQUEST_CLONE_BASICS |
                                    W3_REQUEST_CLONE_HEADERS |
                                    W3_REQUEST_CLONE_NO_PRECONDITION |
                                    W3_REQUEST_CLONE_NO_DAV,
                                    &pChildRequest );
                if ( FAILED( hr ) )
                {
                    return hr;
                }

                DBG_ASSERT( pChildRequest != NULL );

                //
                // Change the URL and verb of the request
                //

                hr = pChildRequest->SetUrl( strError );
                if ( FAILED( hr ) )
                {
                    delete pChildRequest;
                    return hr;
                }

                //
                // Remove DAVFS'ness
                //

                pChildRequest->RemoveDav();

                //
                // All custom error URLs are GET/HEADs
                //

                if ( pChildRequest->QueryVerbType() == HttpVerbHEAD )
                {
                    pChildRequest->SetVerbType( HttpVerbHEAD );
                }
                else
                {
                    pChildRequest->SetVerbType( HttpVerbGET );
                }

                pResponse->SetStatus( HttpStatusOk );

                //
                // From now on, ExecuteChildRequest owns the request
                //

                hr = ExecuteChildRequest( pChildRequest,
                                          TRUE,    // child context cleans up
                                          dwFlags | W3_FLAG_NO_CUSTOM_ERROR );
                if ( FAILED( hr ) )
                {
                    return hr;
                }

                return NO_ERROR;
            }
            else
            {
                // Increment the perf counter
                QuerySite()->IncFilesSent();
            }
        }
        else
        {
            //
            // Not finding a custom error is OK, but any other error is
            // fatal
            //

            DBG_ASSERT( FAILED( hr ) );

            if ( hr != HRESULT_FROM_WIN32( ERROR_FILE_NOT_FOUND ) )
            {
                return hr;
            }

            CHAR  *achImageError;
            DWORD cbImageError = 512;

            if (FAILED(hr = QueryHeaderBuffer()->AllocateSpace(
                                cbImageError,
                                &achImageError)))
            {
                return hr;
            }

            //
            // Check the image for a resource string which may apply.
            //

            if ( subError.dwStringId != 0 )
            {
                hr = g_pW3Server->LoadString( subError.dwStringId,
                                              achImageError,
                                              &cbImageError );
            }
            else if ( pResponse->QueryStatusCode() ==
                          HttpStatusUnauthorized.statusCode &&
                      sm_pszAccessDeniedMessage != NULL )
            {
                //
                // Note: 401 message is actually configured in the registry
                //

                strncpy( achImageError,
                         sm_pszAccessDeniedMessage,
                         cbImageError - 1 );

                achImageError[ cbImageError - 1 ] = '\0';
                cbImageError = strlen( achImageError );
                hr = NO_ERROR;
            }
            else
            {
                hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
            }

            if ( FAILED( hr ) )
            {
                if ( FAILED( QueryErrorStatus() ) )
                {
                    cbImageError = 512;

                    //
                    // If there is a particular error status set, find the
                    // message for that error and send it.  This is that last
                    // thing we can do to attempt to send a useful message to
                    // client
                    //

                    cbImageError = FormatMessageA(
                        FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS,
                        NULL,
                        QueryErrorStatus(),
                        MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                        achImageError,
                        cbImageError,
                        NULL);

                    if (cbImageError == 0)
                    {
                        cbImageError = sprintf(
                            achImageError,
                            "%d (0x%08x)",
                            WIN32_FROM_HRESULT( QueryErrorStatus() ),
                            WIN32_FROM_HRESULT( QueryErrorStatus() ) );
                    }
                }
                else
                {
                    //
                    // No error message to give
                    //

                    cbImageError = 0;
                }
            }

            //
            // Only add an error message if we created one
            //

            if ( cbImageError != 0 )
            {
                //
                // Add content type
                //

                hr = pResponse->SetHeader( HttpHeaderContentType,
                                           "text/html",
                                           9 );
                if ( FAILED( hr ) )
                {
                    return hr;
                }

                hr = pResponse->AddMemoryChunkByReference(
                                           g_szErrorMessagePreHtml,
                                           sizeof( g_szErrorMessagePreHtml ) - 1 );
                if ( FAILED( hr ) )
                {
                    return hr;
                }

                hr = pResponse->AddMemoryChunkByReference(
                                           achImageError,
                                           cbImageError );
                if ( FAILED( hr ) )
                {
                    return hr;
                }

                hr = pResponse->AddMemoryChunkByReference(
                                           g_szErrorMessagePostHtml,
                                           sizeof( g_szErrorMessagePostHtml ) - 1 );
                if ( FAILED( hr ) )
                {
                    return hr;
                }
            }
        }
    }

    //
    // Send custom headers if any
    //

    if ( fSendHeaders &&
         QueryUrlContext() != NULL )
    {
        W3_METADATA *pMetaData = QueryUrlContext()->QueryMetaData();
        DBG_ASSERT( pMetaData != NULL );

        //
        // Add Custom HTTP Headers if defined in the metabase.
        //

        if ( !pMetaData->QueryCustomHeaders()->IsEmpty() )
        {
            hr = pResponse->AppendResponseHeaders( *(pMetaData->QueryCustomHeaders()) );
            if ( FAILED( hr ) )
            {
                pResponse->Clear();
                return hr;
            }
        }
    }

    //
    // Does the current handler manage content length on its own?
    // We'll assume (i.e. the choice which means we do nothing to supply
    // a content-length header or suppress HEADs)
    //

    if ( QueryHandler() != NULL )
    {
        fHandlerManagesHead = QueryHandler()->QueryManagesOwnHead();
    }

    //
    // Should we be adding a content-length header? If so, do it now
    //

    if ( fAddContentLength )
    {
        CHAR                   achNum[ 32 ];

        //
        // If there is already a Content-Length header, then no need to
        // make one (this must mean the handler handled HEAD themselves)
        //

        if ( pResponse->GetHeader( HttpHeaderContentLength ) == NULL )
        {
            _ui64toa( pResponse->QueryContentLength(),
                      achNum,
                      10 );

            hr = pResponse->SetHeader( HttpHeaderContentLength,
                                       achNum,
                                       strlen( achNum ) );
            if ( FAILED( hr ) )
            {
                SetErrorStatus( hr );
                pResponse->SetStatus( HttpStatusServerError );
                return hr;
            }
        }
    }

    //
    // Should we be suppressing entity.  This should be done if this is a
    // HEAD request and the current handler doesn't take responsibility
    // to handle HEADs
    //

    if ( QueryRequest()->QueryVerbType() == HttpVerbHEAD &&
         !fHandlerManagesHead )
    {
        DisableUlCache();
        _fSuppressEntity = TRUE;
    }

    //
    // Remember what type of operation this is, so that the completion
    // can do the proper book keeping
    //

    if ( dwFlags & W3_FLAG_ASYNC )
    {
        SetLastIOPending( LOG_WRITE_IO );
    }

    //
    // If a filter added response headers (either for regular responses or
    // for denial responses), then add them now
    //

    pFilterContext = QueryFilterContext( FALSE );
    if ( pFilterContext != NULL )
    {
        //
        // Add denial headers if this is a denial
        //

        if ( pResponse->QueryStatusCode() == HttpStatusUnauthorized.statusCode )
        {
            //
            // Add filter denied headers
            //

            hr = pResponse->AppendResponseHeaders(
                                    *pFilterContext->QueryAddDenialHeaders() );
            if ( FAILED( hr ) )
            {
                return hr;
            }

            pFilterContext->QueryAddDenialHeaders()->Reset();
        }

        //
        // Add regular headers
        //

        hr = pResponse->AppendResponseHeaders(
                                *pFilterContext->QueryAddResponseHeaders() );
        if ( FAILED( hr ) )
        {
            return hr;
        }

        pFilterContext->QueryAddResponseHeaders()->Reset();
    }

    //
    // If there is any auth token magic to send back, do so now
    //

    pUserContext = QueryMainContext()->QueryUserContext();
    if ( pUserContext != NULL )
    {
        if ( pUserContext->QueryAuthToken() != NULL &&
             !pUserContext->QueryAuthToken()->IsEmpty() )
        {
            hr = pResponse->SetHeader( "WWW-Authenticate",
                                       16,
                                       pUserContext->QueryAuthToken()->QueryStr(),
                                       (USHORT)pUserContext->QueryAuthToken()->QueryCCH() );
            if ( FAILED( hr ) )
            {
                return hr;
            }
        }
    }

    //
    // Notify Response header filters
    //

    if ( fSendHeaders &&
         IsNotificationNeeded( SF_NOTIFY_SEND_RESPONSE ) )
    {
        HTTP_FILTER_SEND_RESPONSE           sendResponse;
        BOOL                                fRet;

        sendResponse.GetHeader = GetSendHeader;
        sendResponse.SetHeader = SetSendHeader;
        sendResponse.AddHeader = AddSendHeader;
        sendResponse.HttpStatus = pResponse->QueryStatusCode();

        fRet = NotifyFilters( SF_NOTIFY_SEND_RESPONSE,
                              &sendResponse,
                              &fFinished );

        if ( !fRet || fFinished )
        {
            //
            // Just cause a disconnect
            //

            SetDisconnect( TRUE );
            SetNeedFinalDone();

            hr = HRESULT_FROM_WIN32( GetLastError() );

            if ( dwFlags & W3_FLAG_ASYNC )
            {
                POST_MAIN_COMPLETION( QueryMainContext() );

                hr = NO_ERROR;
            }
        }

        if ( !fRet )
        {
            return hr;
        }

        if ( fFinished )
        {
            return NO_ERROR;
        }
    }

    // perf ctr
    if (QuerySite() != NULL)
    {
        if ( pResponse->QueryStatusCode() == HttpStatusNotFound.statusCode )
        {
            QuerySite()->IncNotFound();
        }
        else if ( pResponse->QueryStatusCode() == HttpStatusLockedError.statusCode )
        {
            QuerySite()->IncLockedError();
        }
    }

    //
    // If any one sees a reason why this response and this kernel mode cache
    // should not be together, speak now or forever hold your peace (or
    // at least until the UL cache flushes the response)
    //

    DBG_ASSERT( g_pW3Server->QueryUlCache() != NULL );

    cachePolicy.Policy = HttpCachePolicyNocache;
    if ( g_pW3Server->QueryUlCache()->CheckUlCacheability( this ) )
    {
        //
        // The response is UL cacheable, so setup a ul cache entry token
        //

        if ( _pHandler != NULL )
        {
            DBG_ASSERT( _pHandler->QueryIsUlCacheable() );

            _pHandler->SetupUlCachedResponse( this, &cachePolicy );
        }
    }

    //
    // Generate response flags now
    //

    if ( QueryNeedFinalDone() )
    {
        dwResponseFlags |= W3_RESPONSE_MORE_DATA;
    }

    if ( QueryDisconnect() )
    {
        dwResponseFlags |= W3_RESPONSE_DISCONNECT;
    }

    if ( !fSendHeaders )
    {
        dwResponseFlags |= W3_RESPONSE_SUPPRESS_HEADERS;
    }

    if ( _fSuppressEntity )
    {
        dwResponseFlags |= W3_RESPONSE_SUPPRESS_ENTITY;
    }

    if ( dwFlags & W3_FLAG_ASYNC )
    {
        dwResponseFlags |= W3_RESPONSE_ASYNC;
    }

    //
    // Send out the full response now
    //

    hr = pResponse->SendResponse( this,
                                  dwResponseFlags,
                                  &cachePolicy,
                                  &cbSent );

    if (!(dwFlags & W3_FLAG_ASYNC))
    {
        IncrementBytesSent(cbSent);
    }

    if (FAILED(hr))
    {
        if (_pHandler == NULL)
        {
            DBGPRINTF((DBG_CONTEXT,
                       "SendResponse failed: no handler, hr %x\n",
                       hr));
        }
        else
        {
            DBGPRINTF((DBG_CONTEXT,
                       "SendResponse failed: handler %S, hr %x\n",
                       _pHandler->QueryName(),
                       hr));
        }
    }

    return hr;
}

HRESULT
W3_CONTEXT::SendEntity(
    DWORD               dwFlags
)
/*++

Routine Description:

    Sends a response entity to the client thru ULATQ.

Arguments:

    dwFlags - Flags
              W3_FLAG_ASYNC - Send response asynchronously
              W3_FLAG_SYNC - Send response synchronously
              W3_FLAG_PAST_END_OF_REQ - Send after END_OF_REQUEST notification
                  to let UL know we are done
              W3_FLAG_MORE_DATA - More data to be sent

Return Value:

    HRESULT

--*/
{
    DWORD               dwResponseFlags = 0;
    HRESULT             hr;

    if ( !VALID_W3_FLAGS( dwFlags ) ||
         ( dwFlags & W3_FLAG_NO_CUSTOM_ERROR ) )

    {
        DBG_ASSERT( FALSE );
        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }

    //
    // Set the final send just in case we never did a SendResponse (which
    // would normally have set this).
    //
    
    if (dwFlags & W3_FLAG_ASYNC)
    {
        SetLastIOPending(LOG_WRITE_IO);
    }

    //
    // Setup response flags
    //

    if ( ( dwFlags & W3_FLAG_MORE_DATA ) ||
         ( QueryNeedFinalDone() &&
           !( dwFlags & W3_FLAG_PAST_END_OF_REQ ) ) )
    {
        SetNeedFinalDone();
        dwResponseFlags |= W3_RESPONSE_MORE_DATA;
    }

    if ( dwFlags & W3_FLAG_ASYNC )
    {
        dwResponseFlags |= W3_RESPONSE_ASYNC;
    }

    if ( QueryDisconnect() )
    {
        dwResponseFlags |= W3_RESPONSE_DISCONNECT;
    }

    if ( _fSuppressEntity )
    {
        dwResponseFlags |= W3_RESPONSE_SUPPRESS_ENTITY;
    }

    //
    // Do the send now
    //
    DWORD cbSent = 0;
    hr = QueryResponse()->SendEntity(
           this,
           dwResponseFlags,
           &cbSent );

    if (!(dwFlags & W3_FLAG_ASYNC))
    {
        IncrementBytesSent(cbSent);
    }

    if (FAILED(hr))
    {
        if (_pHandler == NULL)
        {
            DBGPRINTF((DBG_CONTEXT,
                       "SendEntity failed: no handler, hr %x\n",
                       hr));
        }
        else
        {
            DBGPRINTF((DBG_CONTEXT,
                       "SendEntity failed: handler %S, hr %x\n",
                       _pHandler->QueryName(),
                       hr));
        }
    }

    return hr;
}

DWORD
W3_CONTEXT::QueryRemainingEntityFromUl(
    VOID
)
/*++

Routine Description:

    Returns how much entity can be read from UL

Arguments:

    None

Return Value:

    Number of bytes available (INFINITE if chunked)

--*/
{
    return QueryMainContext()->QueryRemainingEntityFromUl();
}

VOID
W3_CONTEXT::SetRemainingEntityFromUl(
    DWORD cbRemaining
)
/*++

Routine Description:

    Sets how much entity can be read from UL

Arguments:

    DWORD

Return Value:

    None

--*/
{
    QueryMainContext()->SetRemainingEntityFromUl(cbRemaining);
}

VOID
W3_CONTEXT::QueryAlreadyAvailableEntity(
    VOID **                 ppvBuffer,
    DWORD *                 pcbBuffer
)
/*++

Routine Description:

    Returns the already preloaded entity found in the current request

Arguments:

    ppvBuffer - filled with pointer to available entity
    pcbBuffer - filled with size of buffer pointed to by *ppvBuffer

Return Value:

    None

--*/
{
    W3_REQUEST *            pRequest;

    DBG_ASSERT( ppvBuffer != NULL );
    DBG_ASSERT( pcbBuffer != NULL );

    pRequest = QueryRequest();
    DBG_ASSERT( pRequest != NULL );

    *ppvBuffer = pRequest->QueryEntityBody();
    *pcbBuffer = pRequest->QueryAvailableBytes();
}

HRESULT
W3_CONTEXT::ReceiveEntity(
    DWORD                   dwFlags,
    VOID *                  pBuffer,
    DWORD                   cbBuffer,
    DWORD *                 pBytesReceived
)
/*++

Routine Description:

    Receives request entity from the client thru ULATQ.

Arguments:

    dwFlags - W3_FLAG_ASYNC or W3_FLAG_SYNC
    pBuffer - Buffer to contain the data
    cbBuffer - The size of the buffer
    pBytesReceived - Upon return, the number of bytes
                     copied to the buffer

Return Value:

    HRESULT

--*/
{
    W3_MAIN_CONTEXT *           pMainContext;
    W3_METADATA *               pMetaData;
    DWORD                       dwMaxEntityAllowed;
    DWORD                       dwEntityReadSoFar;
    HRESULT                     hr;

    if (dwFlags & W3_FLAG_ASYNC)
    {
        SetLastIOPending(LOG_READ_IO);
    }

    pMainContext = QueryMainContext();
    DBG_ASSERT( pMainContext != NULL );

    pMetaData = QueryUrlContext()->QueryMetaData();
    DBG_ASSERT( pMetaData );

    dwMaxEntityAllowed = pMetaData->QueryMaxRequestEntityAllowed();
    dwEntityReadSoFar = pMainContext->QueryEntityReadSoFar();

    if ( dwEntityReadSoFar >= dwMaxEntityAllowed )
    {
        //
        // We've already read all the data we're allowed
        // to read.  Fail the call
        //

        return HRESULT_FROM_WIN32( ERROR_CONNECTION_INVALID );
    }

    //
    // If necessary, set cbBuffer so that we cannot overrun
    // the max entity allowed.
    //

    if ( cbBuffer + dwEntityReadSoFar > dwMaxEntityAllowed )
    {
        cbBuffer = dwMaxEntityAllowed - dwEntityReadSoFar;
    }

    hr = pMainContext->ReceiveEntityBody( !!(dwFlags & W3_FLAG_ASYNC),
                                          pBuffer,
                                          cbBuffer,
                                          pBytesReceived );

    if (!(dwFlags & W3_FLAG_ASYNC))
    {
        IncrementBytesRecvd(*pBytesReceived);
    }

    if (FAILED(hr))
    {
        if (_pHandler == NULL)
        {
            DBGPRINTF((DBG_CONTEXT,
                       "ReceiveEntity failed: no handler, hr %x\n",
                       hr));
        }
        else if (hr != HRESULT_FROM_WIN32(ERROR_HANDLE_EOF))
        {
            DBGPRINTF((DBG_CONTEXT,
                       "ReceiveEntity failed: handler %S, hr %x\n",
                       _pHandler->QueryName(),
                       hr));
        }
    }

    return hr;
}

HRESULT
W3_CONTEXT::CleanIsapiExecuteUrl(
    EXEC_URL_INFO * pExecUrlInfo
)
/*++

Routine Description:

    Wrapper for IsapiExecuteUrl() which insured it is called on a clean
    thread (non-coinited).  COM bites

Arguments:

    pExecUrlInfo - EXEC_URL_INFO

Return Value:

    HRESULT

--*/
{
    EXECUTE_CONTEXT *           pExecuteContext;
    HRESULT                     hr;
    BOOL                        fRet;

    if ( pExecUrlInfo == NULL )
    {
        DBG_ASSERT( FALSE );
        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }

    pExecuteContext = new EXECUTE_CONTEXT( this );
    if ( pExecuteContext == NULL )
    {
        return HRESULT_FROM_WIN32( GetLastError() );
    }

    hr = pExecuteContext->InitializeFromExecUrlInfo( pExecUrlInfo );
    if ( FAILED( hr ) )
    {
        delete pExecuteContext;
        return hr;
    }

    fRet = ThreadPoolPostCompletion( 0,
                                     W3_CONTEXT::OnCleanIsapiExecuteUrl,
                                     (LPOVERLAPPED) pExecuteContext );
    if ( !fRet )
    {
        hr = HRESULT_FROM_WIN32( GetLastError() );
        delete pExecuteContext;
        return hr;
    }

    return NO_ERROR;
}

HRESULT
W3_CONTEXT::CleanIsapiSendCustomError(
    HSE_CUSTOM_ERROR_INFO * pCustomErrorInfo
)
/*++

Routine Description:

    Wrapper for IsapiSendCustomError() which insured it is called on a clean
    thread (non-coinited).  COM bites

Arguments:

    pCustomErrorInfo - Custom error info

Return Value:

    HRESULT

--*/
{
    EXECUTE_CONTEXT *           pExecuteContext;
    HRESULT                     hr;
    HANDLE                      hEvent = NULL;
    BOOL                        fRet;
    W3_RESPONSE *               pResponse = QueryResponse();
    W3_METADATA *               pMetaData = NULL;
    STACK_STRU(                 strError, 256 );
    BOOL                        fIsFileError;
    HTTP_SUB_ERROR              subError;

    if ( pCustomErrorInfo == NULL )
    {
        DBG_ASSERT( FALSE );
        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }

    DBG_ASSERT( pResponse != NULL );

    //
    // If we're already sending a custom error, then stop the recursion
    //

    if ( !QuerySendCustomError() )
    {
        return HRESULT_FROM_WIN32( ERROR_NOT_SUPPORTED );
    }

    pResponse->Clear();

    //
    // We don't expect an empty status line here (we expect an error)
    //

    if ( pCustomErrorInfo->pszStatus == NULL ||
         pCustomErrorInfo->pszStatus[ 0 ] == '\0' )
    {
        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }

    //
    // Setup the response status/substatus
    //

    hr = pResponse->BuildStatusFromIsapi( pCustomErrorInfo->pszStatus );
    if ( FAILED( hr ) )
    {
        return hr;
    }

    subError.mdSubError = pCustomErrorInfo->uHttpSubError;
    subError.dwStringId = 0;
    pResponse->SetSubError( &subError );

    //
    // Attempt to match a string ID.  If not, thats ok.
    //

    pResponse->FindStringId();

    //
    // An error better have been sent
    //

    if ( pResponse->QueryStatusCode() < 400 )
    {
        return HRESULT_FROM_WIN32( ERROR_NOT_SUPPORTED );
    }

    //
    // Now try to find a custom error for the given response.  If it doesn't
    // exist then we error our
    //

    DBG_ASSERT( QueryUrlContext() != NULL );

    pMetaData = QueryUrlContext()->QueryMetaData();
    DBG_ASSERT( pMetaData != NULL );

    hr = pMetaData->FindCustomError( QueryResponse()->QueryStatusCode(),
                                     subError.mdSubError,
                                     &fIsFileError,
                                     &strError );
    if ( FAILED( hr ) )
    {
        return HRESULT_FROM_WIN32( ERROR_FILE_NOT_FOUND );
    }

    //
    // Now start executing the custom error
    //

    if ( pCustomErrorInfo->fAsync == FALSE )
    {
        hEvent = CreateEvent( NULL, FALSE, FALSE, NULL );
        if ( hEvent == NULL )
        {
            return HRESULT_FROM_WIN32( GetLastError() );
        }
    }

    pExecuteContext = new EXECUTE_CONTEXT( this );
    if ( pExecuteContext == NULL )
    {
        return HRESULT_FROM_WIN32( GetLastError() );
    }

    pExecuteContext->SetCompleteEvent( hEvent );

    //
    // Post the call
    //

    fRet = ThreadPoolPostCompletion( 0,
                                     W3_CONTEXT::OnCleanIsapiSendCustomError,
                                     (LPOVERLAPPED) pExecuteContext );
    if ( !fRet )
    {
        hr = HRESULT_FROM_WIN32( GetLastError() );
        CloseHandle( hEvent );
        pExecuteContext->SetCompleteEvent( NULL );
        delete pExecuteContext;
        return hr;
    }


    if ( pCustomErrorInfo->fAsync == FALSE )
    {
        WaitForSingleObject( hEvent, INFINITE );
        CloseHandle( hEvent );
    }

    return NO_ERROR;
}

HRESULT
W3_CONTEXT::ExecuteHandler(
    DWORD               dwFlags,
    BOOL *              pfDidImmediateFinish
)
/*++

Routine Description:

    Run the context's handler

Arguments:

    dwFlags - W3_FLAG_ASYNC async
              W3_FLAG_SYNC sync
              W3_FLAG_MORE_DATA caller needs to send data too

    pfDidImmediateFinish - If the caller sets this value (i.e. non NULL) AND
                           the callers asks for async execution, then in the
                           case where the handler executes synchronously, we
                           will set *pfDidImmediateFinish to TRUE and not
                           bother with faking a completion.  This is an
                           optimization to handle the synchronous ISAPI
                           execution (non-child) case.

Return Value:

    HRESULT

--*/
{
    CONTEXT_STATUS              status;
    W3_HANDLER *                pHandler;
    HTTP_SUB_ERROR              subError;
    HRESULT                     hr;

    if ( pfDidImmediateFinish != NULL )
    {
        *pfDidImmediateFinish = FALSE;
    }

    //
    // If this is synchronous execution, then setup an event to signal
    // upon the handler completion
    //

    if ( dwFlags & W3_FLAG_SYNC )
    {
        SetupCompletionEvent();
    }

    //
    // Clear any response lingering
    //

    hr = QueryResponse()->Clear();
    if ( FAILED( hr ) )
    {
        return hr;
    }

    //
    // Redirect all completions to the current context (this)
    //

    QueryMainContext()->PushCurrentContext( this );

    //
    // Execute the handler
    //

    status = ExecuteCurrentHandler();

    if ( status == CONTEXT_STATUS_CONTINUE )
    {
        //
        // Remember not to execute completion routine for handler
        //

        DBG_ASSERT( _pHandler != NULL );

        //
        // We don't need the handler any more
        //

        delete _pHandler;
        _pHandler = NULL;

        //
        // The handler completed synchronously.  If async call was required
        // then post a fake completion, unless the caller set
        // pfDidImmediateFinish in which case we'll finish now and set the
        // flag to TRUE
        //

        if ( dwFlags & W3_FLAG_ASYNC &&
             pfDidImmediateFinish == NULL )
        {
            POST_MAIN_COMPLETION( QueryMainContext() );
        }
        else
        {
            //
            // We indicate the "success/failure" of this child context
            // to the parent context, so that the parent can send this
            // info to ISAPIs if needed
            //

            if ( QueryParentContext() != NULL )
            {
                QueryResponse()->QuerySubError( &subError );

                QueryParentContext()->SetChildStatusAndError(
                                         QueryResponse()->QueryStatusCode(),
                                         subError.mdSubError,
                                         QueryErrorStatus() );
            }

            //
            // Don't both signalling completion event since there is nothing
            // to wait for.  (Might revisit this decision later)
            //

            //
            // Current context is no longer needed in completion stack
            //

            QueryMainContext()->PopCurrentContext();

            //
            // If caller wanted status, tell them now
            //

            if ( pfDidImmediateFinish != NULL )
            {
                *pfDidImmediateFinish = TRUE;
            }
        }
    }
    else
    {
        DBG_ASSERT( status == CONTEXT_STATUS_PENDING );

        //
        // The handler will complete asynchronsouly.  But we are asked for
        // synchronous execution.  So wait here until complete
        //

        if ( dwFlags & W3_FLAG_SYNC )
        {
            WaitForCompletion();
        }
    }

    return NO_ERROR;
}

CONTEXT_STATUS
W3_CONTEXT::ExecuteCurrentHandler(
    VOID
)
/*++

Routine Description:

    Execute the handler for this context

Arguments:

    None

Return Value:

    CONTEXT_STATUS_PENDING if async pending, else CONTEXT_STATUS_CONTINUE

--*/
{
    HRESULT                     hr;
    W3_TRACE_LOG *              pTraceLog;

    DBG_ASSERT( _pHandler != NULL );

    pTraceLog = QueryMainContext()->QueryTraceLog();
    if ( pTraceLog != NULL )
    {
        pTraceLog->Trace( L"%I64x: Starting execution of handler '%s'\n",
                          QueryRequest()->QueryRequestId(),
                          _pHandler->QueryName() );
    }

    //
    // Access is allowed and no URL redirection.  Let'r rip!
    //

    return _pHandler->MainDoWork();
}

CONTEXT_STATUS
W3_CONTEXT::ExecuteHandlerCompletion(
    DWORD               cbCompletion,
    DWORD               dwCompletionStatus
)
/*++

Routine Description:

    Execute the current handler's completion.

Arguments:

    cbCompletion - Completion bytes
    dwCompletionStatus - Completion error

Return Value:

    CONTEXT_STATUS_PENDING if async pending, else CONTEXT_STATUS_CONTINUE

--*/
{
    CONTEXT_STATUS          status;
    W3_HANDLER *            pHandler;
    W3_CONTEXT *            pParentContext;
    DWORD                   dwChildStatus;
    BOOL                    fAccessAllowed = FALSE;
    HRESULT                 hr;
    HTTP_SUB_ERROR          subError;
    W3_TRACE_LOG *          pTraceLog;

    //
    // This is a completion for the handler.
    //
    // If this is a faked completion, the handler is already cleaned up
    //

    if ( _pHandler != NULL )
    {
        status = _pHandler->MainOnCompletion( cbCompletion,
                                              dwCompletionStatus );

    }
    else
    {
        status = CONTEXT_STATUS_CONTINUE;
    }

    if ( status == CONTEXT_STATUS_PENDING )
    {
        return status;
    }
    else
    {
        //
        // Cleanup the current context if necessary
        //

        DBG_ASSERT( status == CONTEXT_STATUS_CONTINUE );

        //
        // Current handler execute is complete.  Delete it
        //

        if ( _pHandler != NULL )
        {
            delete _pHandler;
            _pHandler = NULL;
        }

        //
        // The current handler is complete.  But if this is a child
        // request we must first indicate handler completion to the caller
        //

        pParentContext = QueryParentContext();
        if ( pParentContext != NULL )
        {
            //
            // We indicate the "success/failure" of this child context
            // to the parent context, so that the parent can send this
            // info to ISAPIs if needed
            //

            QueryResponse()->QuerySubError( &subError );

            pParentContext->SetChildStatusAndError(
                                     QueryResponse()->QueryStatusCode(),
                                     subError.mdSubError,
                                     QueryErrorStatus() );

            //
            // Setup all future completions to indicate to parent
            //

            QueryMainContext()->PopCurrentContext();

            //
            // We are a child execute
            //

            if ( QueryIsSynchronous() )
            {
                IndicateCompletion();

                //
                // We assume the thread waiting on completion will be
                // responsible for advancing the state machine
                //

                //
                // The waiting thread will also cleanup the child context
                //

                return CONTEXT_STATUS_PENDING;
            }
            else
            {
                dwChildStatus = WIN32_FROM_HRESULT( QueryErrorStatus() );

                //
                // We can destroy the current context now.  In the case of
                // synchronous execution, it is the caller that cleans up
                // the new context
                //

                delete this;

                return pParentContext->ExecuteHandlerCompletion(
                                0,
                                dwChildStatus );
            }
        }

        pTraceLog = QueryMainContext()->QueryTraceLog();
        if ( pTraceLog != NULL )
        {
            pTraceLog->Trace( L"%I64x: Handler completed\n",
                              QueryRequest()->QueryRequestId() );
        }

        return CONTEXT_STATUS_CONTINUE;
    }
}

W3_CONTEXT::W3_CONTEXT(
    DWORD dwExecFlags,
    DWORD dwRecursionLevel
)
    : _pHandler                  ( NULL ),
      _hCompletion               ( NULL ),
      _errorStatus               ( S_OK ),
      _pCustomErrorFile          ( NULL ),
      _dwExecFlags               ( dwExecFlags ),
      _accessState               ( ACCESS_STATE_START ),
      _fDNSRequiredForAccess     ( FALSE ),
      _fAuthAccessCheckRequired  ( TRUE ),
      _childStatusCode           ( 200 ),
      _childSubErrorCode         ( 0 ),
      _childError                ( S_OK ),
      _fSuppressEntity           ( FALSE ),
      _pctVrToken                ( NULL ),
      _dwRecursionLevel          ( dwRecursionLevel )
{
    _dwSignature = W3_CONTEXT_SIGNATURE;
}

W3_CONTEXT::~W3_CONTEXT()
{
    _dwSignature = W3_CONTEXT_SIGNATURE_FREE;

    if ( _pHandler != NULL )
    {
        delete _pHandler;
        _pHandler = NULL;
    }

    if ( _hCompletion != NULL )
    {
        CloseHandle( _hCompletion );
        _hCompletion = NULL;
    }

    if ( _pCustomErrorFile != NULL )
    {
        _pCustomErrorFile->DereferenceCacheEntry();
        _pCustomErrorFile = NULL;
    }

    if( _pctVrToken != NULL )
    {
        _pctVrToken->DereferenceCacheEntry();
        _pctVrToken = NULL;
    }
}

// static
HRESULT
W3_CONTEXT::Initialize(
    VOID
)
/*++

Routine Description:

    Global initialization routine for W3_CONTEXTs

Arguments:

    None

Return Value:

    HRESULT

--*/
{
    HRESULT             hr = NO_ERROR;
    HKEY                hKey = NULL;
    DWORD               dwError;
    DWORD               dwType;
    DWORD               cbBuffer;
    BYTE                bUnused;

    //
    // Read in the 302 message once
    //

    DBG_ASSERT( g_pW3Server != NULL );

    sm_cbRedirectMessage = sizeof( sm_achRedirectMessage );

    hr = g_pW3Server->LoadString( IDS_URL_MOVED,
                                  sm_achRedirectMessage,
                                  &sm_cbRedirectMessage );
    if ( FAILED( hr ) )
    {
        return hr;
    }

    DBG_ASSERT( sm_cbRedirectMessage > 0 );

    //
    // Read the Access-Denied message from registry
    //

    dwError = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                            W3_PARAMETERS_KEY,
                            0,
                            KEY_READ,
                            &hKey );
    if ( dwError == ERROR_SUCCESS )
    {
        DBG_ASSERT( hKey != NULL );

        cbBuffer = 0;
        dwType = 0;

        dwError = RegQueryValueExA( hKey,
                                    "AccessDeniedMessage",
                                    NULL,
                                    &dwType,
                                    &bUnused,
                                    &cbBuffer );

        if ( dwError == ERROR_MORE_DATA && dwType == REG_SZ )
        {
            DBG_ASSERT( cbBuffer > 0 );

            sm_pszAccessDeniedMessage = (CHAR*) LocalAlloc( LPTR, cbBuffer );
            if ( sm_pszAccessDeniedMessage == NULL )
            {
                return HRESULT_FROM_WIN32( GetLastError() );
            }

            dwError = RegQueryValueExA( hKey,
                                        "AccessDeniedMessage",
                                        NULL,
                                        NULL,
                                        (LPBYTE) sm_pszAccessDeniedMessage,
                                        &cbBuffer );

            if ( dwError != ERROR_SUCCESS )
            {
                DBG_ASSERT( FALSE );

                LocalFree( sm_pszAccessDeniedMessage );
                sm_pszAccessDeniedMessage = NULL;
            }
            else
            {
                //
                // Zero terminate the string just in case the string we got
                // wasn't (tres lame)
                //
                
                DBG_ASSERT( sm_pszAccessDeniedMessage != NULL );
                sm_pszAccessDeniedMessage[ cbBuffer - 1 ] = '\0';
            }
        }
    }

    //
    // Setup child contexts
    //

    hr = W3_CHILD_CONTEXT::Initialize();
    if ( FAILED( hr ) )
    {
        return hr;
    }

    //
    // Setup main contexts
    //

    hr = W3_MAIN_CONTEXT::Initialize();
    if ( FAILED( hr ) )
    {
        W3_CHILD_CONTEXT::Terminate();
        return hr;
    }

    //
    // Setup execute contexts
    //

    hr = EXECUTE_CONTEXT::Initialize();
    if ( FAILED( hr ) )
    {
        W3_MAIN_CONTEXT::Terminate();
        W3_CHILD_CONTEXT::Terminate();
        return hr;
    }

    return NO_ERROR;
}

// static
VOID
W3_CONTEXT::Terminate(
    VOID
)
/*++

Routine Description:

    Terminate W3_CONTEXT globals

Arguments:

    None

Return Value:

    None

--*/
{
    EXECUTE_CONTEXT::Terminate();

    W3_CHILD_CONTEXT::Terminate();

    W3_MAIN_CONTEXT::Terminate();

    if ( sm_pszAccessDeniedMessage != NULL )
    {
        LocalFree( sm_pszAccessDeniedMessage );
        sm_pszAccessDeniedMessage = NULL;
    }
}

//static
VOID
W3_CONTEXT::OnCleanIsapiExecuteUrl(
    DWORD                   dwCompletionStatus,
    DWORD                   cbWritten,
    LPOVERLAPPED            lpo
)
/*++

Routine Description:

    Actually calls ExecuteHandler() on behalf of a thread which may have
    already been CoInited().  The thread this this guy runs on should not
    have been (COM sucks)

Arguments:

    dwCompletionStatus - Completion status (ignored)
    cbWritten - Bytes written (ignored)
    lpo - Pointer to EXECUTE_CONTEXT which contains info needed for
          ExecuteHandler() call

Return Value:

    None

--*/
{
    EXECUTE_CONTEXT *           pExecuteContext;
    W3_CONTEXT *                pW3Context;
    HRESULT                     hr;

    DBG_ASSERT( lpo != NULL );

    pExecuteContext = (EXECUTE_CONTEXT*) lpo;
    DBG_ASSERT( pExecuteContext->CheckSignature() );

    pW3Context = pExecuteContext->QueryW3Context();
    DBG_ASSERT( pW3Context != NULL );
    DBG_ASSERT( pW3Context->CheckSignature() );

    //
    // Make the call (this is an async call)
    //

    hr = pW3Context->IsapiExecuteUrl( pExecuteContext->QueryExecUrlInfo() );

    delete pExecuteContext;

    if ( FAILED( hr ) )
    {
        //
        // We failed before posting async operation.  It is up to us to
        // fake a completion
        //

        DBG_ASSERT( pW3Context->QueryHandler() != NULL );

        pW3Context->SetChildStatusAndError( HttpStatusServerError.statusCode,
                                            0,
                                            hr );

        pW3Context->QueryHandler()->MainOnCompletion( 0,
                                                      ERROR_SUCCESS );
    }
}

//static
VOID
W3_CONTEXT::OnCleanIsapiSendCustomError(
    DWORD                   dwCompletionStatus,
    DWORD                   cbWritten,
    LPOVERLAPPED            lpo
)
/*++

Routine Description:

    Actually calls ExecuteHandler() on behalf of a thread which may have
    already been CoInited().  The thread this this guy runs on should not
    have been (COM sucks)

Arguments:

    dwCompletionStatus - Completion status (ignored)
    cbWritten - Bytes written (ignored)
    lpo - Pointer to SEND_CUSTOM_ERROR_CONTEXT which contains info needed for
          ExecuteHandler() call

Return Value:

    None

--*/
{
    EXECUTE_CONTEXT *           pExecuteContext;
    W3_CONTEXT *                pW3Context;
    HRESULT                     hr;
    BOOL                        fAsync;

    DBG_ASSERT( lpo != NULL );

    pExecuteContext = (EXECUTE_CONTEXT*) lpo;
    DBG_ASSERT( pExecuteContext->CheckSignature() );

    pW3Context = pExecuteContext->QueryW3Context();
    DBG_ASSERT( pW3Context != NULL );
    DBG_ASSERT( pW3Context->CheckSignature() );

    fAsync = pExecuteContext->QueryCompleteEvent() == NULL;

    hr = pW3Context->SendResponse( fAsync ? W3_FLAG_ASYNC : W3_FLAG_SYNC );

    delete pExecuteContext;

    if ( FAILED( hr ) )
    {
        if ( fAsync )
        {
            //
            // We failed before posting async operation.  It is up to us to
            // fake a completion
            //

            DBG_ASSERT( pW3Context->QueryHandler() != NULL );

            pW3Context->SetErrorStatus( hr );

            pW3Context->QueryHandler()->MainOnCompletion( 0,
                                                          WIN32_FROM_HRESULT( hr ) );
        }
    }
}

CONTEXT_STATUS
W3_CONTEXT::CheckAccess(
    BOOL                    fCompletion,
    DWORD                   cbCompletion,
    DWORD                   dwCompletionStatus,
    BOOL *                  pfAccessAllowed
)
/*++

Routine Description:

    Check whether the given request is allowed for the current metadata
    settings.  In particular check:
    1) Is SSL required?
    2) Are IP address restrictions in force?
    3) Is a client certificate required?
    4) Is the authentication mechanism allowed?  Optionally

    If access is not allowed, then this routine will send the appropriate
    response asychronously

Arguments:

    fCompletion - Are we being called on a completion (i.e.
                  is this a subsequent call to CheckAccess())
    cbCompletion - number of bytes completed
    dwCompletionStatus - Completion status (if fCompletion is TRUE)
    pfAccessAllowed - Set to TRUE if access is allowed, else FALSE

Return Value:

    CONTEXT_STATUS_PENDING if we're not finished the check yet
    CONTEXT_STATUS_CONTINUE if we are finished.

--*/
{
    W3_REQUEST *                pRequest;
    W3_METADATA *               pMetaData;
    URL_CONTEXT *               pUrlContext;
    HTTP_SSL_INFO *             pSslInfo;
    HTTP_SSL_CLIENT_CERT_INFO * pClientCertInfo = NULL;
    DWORD                       dwAccessPerms;
    HRESULT                     hr = NO_ERROR;
    BOOL                        fAccessAllowed = TRUE;
    ADDRESS_CHECK *             pAddressCheck = NULL;
    AC_RESULT                   acResult;
    BOOL                        fSyncDNS = FALSE;
    LPSTR                       pszTemp;
    BOOL                        fDoCertMap;
    BOOL                        fFilterFinished = FALSE;

    if ( pfAccessAllowed == NULL )
    {
        DBG_ASSERT( FALSE );
        SetErrorStatus( HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER ) );
        return CONTEXT_STATUS_CONTINUE;
    }
    *pfAccessAllowed = FALSE;

    pRequest = QueryRequest();
    DBG_ASSERT( pRequest != NULL );

    pUrlContext = QueryUrlContext();
    DBG_ASSERT( pUrlContext != NULL );

    pMetaData = pUrlContext->QueryMetaData();
    DBG_ASSERT( pMetaData != NULL );

    dwAccessPerms = pMetaData->QueryAccessPerms();

    switch ( _accessState )
    {
    case ACCESS_STATE_SENDING_ERROR:

        //
        // We have sent an error.  Just chill
        //

        fAccessAllowed = FALSE;
        break;

    case ACCESS_STATE_START:

        //
        // Is SSL required?
        //

        if ( dwAccessPerms & VROOT_MASK_SSL &&
             !QueryRequest()->IsSecureRequest() )
        {
            QueryResponse()->SetStatus( HttpStatusForbidden,
                                        Http403SSLRequired );
            SetErrorStatus( HRESULT_FROM_WIN32(ERROR_ACCESS_DENIED) );
            goto AccessDenied;
        }

        //
        // Is 128bit required?
        //

        if ( dwAccessPerms & VROOT_MASK_SSL128 )
        {
            pSslInfo = QueryRequest()->QuerySslInfo();

            if ( pSslInfo == NULL ||
                 pSslInfo->ConnectionKeySize < 128 )
            {
                QueryResponse()->SetStatus( HttpStatusForbidden,
                                            Http403SSL128Required );
                SetErrorStatus( HRESULT_FROM_WIN32(ERROR_ACCESS_DENIED) );
                goto AccessDenied;
            }
        }


        //
        // Fall through to next phase in access check
        //

    case ACCESS_STATE_CLIENT_CERT_PRELOAD_ENTITY:

        _accessState = ACCESS_STATE_CLIENT_CERT_PRELOAD_ENTITY;

        //
        // For the client certificate renegotiation to succeed
        // it is necessary to assure that client is not blocked
        // on sending entity body. That's why if client certificate
        // is not present and client renegotiation is requested
        // it is necessary to preload request body
        // SSL preload will use EntityReadAhead() value used for ISAPI
        // The only difference is that if ReadAhead is >= Content length then
        // http error 413 is returned and connection is closed to prevent
        // deadlock (client waiting to complete request entity, while
        // server is waiting for renegotiation to complete, but renegotiation
        // requires client to be able to send data)

        if ( dwAccessPerms & VROOT_MASK_NEGO_CERT &&
             QueryRequest()->IsSecureRequest() )
        {
            //
            // If we don't already have client cert negotiated
            // then entity body preload is necessary
            //

            pSslInfo = QueryRequest()->QuerySslInfo();

            if ( pSslInfo == NULL ||
                 !pSslInfo->SslClientCertNegotiated )
            {
                if ( fCompletion )
                {
                    fCompletion = FALSE;

                    //
                    // If we got an error, that's OK.  We will fall thru
                    // and check whether we actually need a client cert
                    //

                    if ( dwCompletionStatus == NO_ERROR )
                    {
                        BOOL fComplete = FALSE;

                        //
                        // This completion is for entity body preload
                        //

                        hr = pRequest->PreloadCompletion(this,
                                                         cbCompletion,
                                                         dwCompletionStatus,
                                                         &fComplete);

                        //
                        // If we cannot read the request entity, we will assume it is the
                        // client's fault
                        //
                        if ( FAILED( hr ) )
                        {
                            SetErrorStatus( hr );
                            QueryResponse()->SetStatus( HttpStatusServerError );
                            goto AccessDenied;
                        }

                        if (!fComplete)
                        {
                            return CONTEXT_STATUS_PENDING;
                        }

                        W3_METADATA *pMetadata = QueryUrlContext()->QueryMetaData();
                        DWORD cbConfiguredReadAhead = pMetadata->QueryEntityReadAhead();

                        //
                        // If Content-Length of the request exceeds
                        // configured ReadAhead size
                        // and client certificate is not yet present
                        // then we have to return error and close connection
                        // to prevent client cert renegotiation deadlock
                        //

                        if ( pRequest->QueryAvailableBytes() >= cbConfiguredReadAhead )
                        {
                            //
                            // This code path should be hit only with chunk encoded request
                            // entity body.
                            // Make QueryRemainingEntityFromUl call to figure out if
                            // for we have read all the request data
                            // for the chunk encoded request
                            //
                            if ( QueryRemainingEntityFromUl() != 0 )
                            {
                                //
                                // There are still some outstanding chunks.
                                // This means error
                                //
                                QueryResponse()->SetStatus( HttpStatusEntityTooLarge );
                                SetDisconnect( TRUE );
                                goto AccessDenied;
                            }
                        }

                        //
                        // all the data has been preloaded. We can fall through to next state
                        //

                    }
                }
                else
                {
                    BOOL fComplete = FALSE;
                    W3_REQUEST *pRequest = QueryRequest();

                    DBG_ASSERT( pRequest != NULL );

                    //
                    // Preload entity to eliminate blocking on
                    // client cert renegotiation when long entity body
                    // is sent from client
                    //

                    LPCSTR pszContentLength =
                            pRequest->GetHeader( HttpHeaderContentLength );

                    W3_METADATA *pMetadata = QueryUrlContext()->QueryMetaData();
                    DWORD cbConfiguredReadAhead = pMetadata->QueryEntityReadAhead();

                    //
                    // If Content-Length of the request exceeds
                    // configured ReadAhead size
                    // and client certificate is not yet present
                    // then we have to return error and close connection
                    // to prevent client cert renegotiation deadlock
                    //

                    //
                    // if pszContentLength is NULL it means that
                    // request entity body is chunked encoded
                    // in that case we have to preload entity body
                    // to find out it's length.

                    if ( pszContentLength != NULL &&
                        _strtoi64( pszContentLength, NULL, 10 ) > cbConfiguredReadAhead )
                    {
                        QueryResponse()->SetStatus( HttpStatusEntityTooLarge );
                        SetDisconnect( TRUE );
                        goto AccessDenied;
                    }

                    hr = pRequest->PreloadEntityBody( this,
                                                      &fComplete );
                    //
                    // If we cannot read the request entity, we will assume it is the
                    // client's fault
                    //
                    if ( FAILED( hr ) )
                    {
                        SetErrorStatus( hr );
                        QueryResponse()->SetStatus( HttpStatusServerError );
                        goto AccessDenied;
                    }

                    if ( !fComplete )
                    {
                        //
                        // Async read pending.  Just bail
                        //

                        return CONTEXT_STATUS_PENDING;
                    }

                    if ( pRequest->QueryAvailableBytes() >= cbConfiguredReadAhead )
                    {
                        //
                        // This code path should be hit only with chunk encoded request
                        // entity body
                        //

                        QueryResponse()->SetStatus( HttpStatusEntityTooLarge );
                        SetDisconnect( TRUE );
                        goto AccessDenied;
                    }

                    //
                    // all the data has been preloaded. We can fall through to next state
                    //

                }
            }
        }

        //
        // Fall through to next phase in access check
        //

    case ACCESS_STATE_CLIENT_CERT:

        _accessState = ACCESS_STATE_CLIENT_CERT;

        //
        // Is a client certificate possible?  First check is we even allow
        // a client cert to be negotiated and that this is a secure request
        //

        if ( dwAccessPerms & VROOT_MASK_NEGO_CERT &&
             QueryRequest()->IsSecureRequest() )
        {
            //
            // Try for a client cert if we don't already have one associated
            // with the request
            //

            if ( QueryCertificateContext() == NULL )
            {
                if ( fCompletion )
                {
                    fCompletion = FALSE;

                    //
                    // If we got an error, that's OK.  We will fall thru
                    // and check whether we actually need a client cert
                    //

                    if ( dwCompletionStatus == NO_ERROR )
                    {
                        //
                        // Are we cert mapping?
                        //

                        fDoCertMap = !!(dwAccessPerms & VROOT_MASK_MAP_CERT);

                        //
                        // All is well.  Make a synchronous call to get
                        // the certificate
                        //

                        hr = UlAtqReceiveClientCertificate(
                                            QueryUlatqContext(),
                                            FALSE,              // sync
                                            fDoCertMap,
                                            &pClientCertInfo );
                        if ( FAILED( hr ) )
                        {
                            QueryResponse()->SetStatus( HttpStatusServerError );
                            goto AccessDenied;
                        }

                        DBG_ASSERT( pClientCertInfo != NULL );

                        //
                        // Setup a client cert context for this request
                        //

                        hr = QueryMainContext()->SetupCertificateContext( pClientCertInfo );
                        if ( FAILED( hr ) )
                        {
                            QueryResponse()->SetStatus( HttpStatusServerError );
                            goto AccessDenied;
                        }

                        //
                        // Just because we got a client cert, doesn't mean
                        // it is acceptable.  It might be revoked, time
                        // expired, etc.  The policy of what to do when
                        // certs are non-totally-valid is metabase driven.
                        // (in case you are wondering why the stream filter
                        // doesn't do these checks and just fail the
                        // renegotiation)
                        //

                        if ( !CheckClientCertificateAccess() )
                        {
                            goto AccessDenied;
                        }
                    }
                }
                else
                {
                    //
                    // Are we cert mapping?
                    //

                    fDoCertMap = !!(dwAccessPerms & VROOT_MASK_MAP_CERT);

                    //
                    // First time asking for a client cert.  Do it
                    // async
                    //

                    fCompletion = FALSE;

                    hr = UlAtqReceiveClientCertificate(
                                            QueryUlatqContext(),
                                            TRUE,               // async
                                            fDoCertMap,
                                            &pClientCertInfo );
                    if ( FAILED( hr ) )
                    {
                        QueryResponse()->SetStatus( HttpStatusServerError );
                        goto AccessDenied;
                    }

                    return CONTEXT_STATUS_PENDING;
                }
            }
        }

        //
        // Ok.  We're done the certificate crud.  If we needed a client
        // cert and didn't get it, then setup 403.7
        //

        if ( dwAccessPerms & VROOT_MASK_NEGO_MANDATORY &&
             QueryCertificateContext() == NULL )
        {
            QueryResponse()->SetStatus( HttpStatusForbidden,
                                        Http403CertRequired );
            SetErrorStatus( HRESULT_FROM_WIN32(ERROR_ACCESS_DENIED) );
            goto AccessDenied;
        }

        //
        // Fall through to next phase in access check
        //

    case ACCESS_STATE_RDNS:

        _accessState = ACCESS_STATE_RDNS;

        if( pRequest->QueryRemoteAddressType() == AF_INET )
        {
            SOCKADDR_IN     remoteAddress;

            pAddressCheck = QueryMainContext()->QueryAddressCheck();
            DBG_ASSERT( pAddressCheck != NULL );

            if ( !fCompletion )
            {
                if ( pMetaData->QueryIpAccessCheckSize() != 0 ||
                     pMetaData->QueryDoReverseDNS() )
                {
                    //
                    // Setup the RDNS crud (joy)
                    //

                    remoteAddress.sin_family = AF_INET;
                    remoteAddress.sin_port = QueryRequest()->QueryRemotePort();
                    remoteAddress.sin_addr.s_addr = QueryRequest()->QueryIPv4RemoteAddress();
                    ZeroMemory( remoteAddress.sin_zero, sizeof( remoteAddress.sin_zero ) );

                    pAddressCheck->BindAddr( (sockaddr*) &remoteAddress );
                }

                //
                // Ok.  If there is an access check set in metabase, then
                // do the check.
                //

                if ( pMetaData->QueryIpAccessCheckSize() != 0 )
                {
                    //
                    // Set the metadata IP blob
                    //

                    pAddressCheck->BindCheckList(
                                        pMetaData->QueryIpAccessCheckBuffer(),
                                        pMetaData->QueryIpAccessCheckSize() );

                    //
                    // Check access
                    //

                    acResult = pAddressCheck->CheckIpAccess( &_fDNSRequiredForAccess );

                    if ( !_fDNSRequiredForAccess )
                    {
                        pAddressCheck->UnbindCheckList();
                    }
                }
                else
                {
                    //
                    // Fake a valid access check since there was no checks
                    // configured in metabase
                    //

                    acResult = AC_NO_LIST;
                }

                //
                // Check if we now know our access status now
                //

                if ( acResult == AC_IN_DENY_LIST ||
                     ( acResult == AC_NOT_IN_GRANT_LIST &&
                       !_fDNSRequiredForAccess ) )
                {
                    //
                    // We know we're rejected
                    //

                    QueryResponse()->SetStatus( HttpStatusForbidden,
                                                Http403IPAddressReject );
                    goto AccessDenied;
                }

                //
                // Do we need to do a DNS check to determine access?
                // Do we need to do DNS check for logging/servervar purposes?
                //
                // In either case, we will do an async DNS check
                //

                if ( _fDNSRequiredForAccess ||
                     pMetaData->QueryDoReverseDNS() )
                {
                    fSyncDNS = TRUE;

                    if ( !pAddressCheck->QueryDnsName( &fSyncDNS,
                                                       W3_MAIN_CONTEXT::AddressResolutionCallback,
                                                       QueryMainContext(),
                                                       &pszTemp ) )
                    {
                        //
                        // Only error if DNS was required for access check
                        // purposes
                        //

                        if ( _fDNSRequiredForAccess )
                        {
                            QueryResponse()->SetStatus( HttpStatusForbidden,
                                                        Http403IPAddressReject );
                            goto AccessDenied;
                        }
                    }

                    if ( fSyncDNS )
                    {
                        //
                        // Fake a completion if needed.  This just prevents us from
                        // posting one more time to the thread pool
                        //

                        fCompletion = TRUE;
                    }
                    else
                    {
                        return CONTEXT_STATUS_PENDING;
                    }
                }
            }

            if ( fCompletion )
            {
                fCompletion = FALSE;

                //
                // This is the completion for DNS check
                //

                if ( _fDNSRequiredForAccess )
                {
                    _fDNSRequiredForAccess = FALSE;

                    acResult = pAddressCheck->CheckDnsAccess();

                    pAddressCheck->UnbindCheckList();

                    if ( acResult == AC_NOT_CHECKED ||
                         acResult == AC_IN_DENY_LIST ||
                         acResult == AC_NOT_IN_GRANT_LIST )
                    {
                        QueryResponse()->SetStatus( HttpStatusForbidden,
                                                    Http403IPAddressReject );
                        goto AccessDenied;
                    }
                }
            }
        }
        else
        {
            DBG_ASSERT( pRequest->QueryRemoteAddressType() == AF_INET6 );
        }

        //
        // Fall through to next phase in access check
        //

    case ACCESS_STATE_AUTHENTICATION:

        //
        // Is the authentication method valid?  We may not have a user
        // context available at this point if this was an early
        // custom error URL invocation
        //

        _accessState = ACCESS_STATE_AUTHENTICATION;

        if ( QueryAuthAccessCheckRequired() &&
             QueryUserContext() != NULL )
        {
            //
            // Check if authentication scheme matches or cert mapping is enabled
            //
            if ( !( pMetaData->QueryAuthentication() & QueryUserContext()->QueryAuthType() ||
                    ( ( pMetaData->QuerySslAccessPerms() & MD_ACCESS_MAP_CERT ) &&
                        QueryUserContext()->QueryAuthType() == MD_ACCESS_MAP_CERT ) ) )
            {
                QueryResponse()->SetStatus( HttpStatusUnauthorized,
                                            Http401Config );
                SetErrorStatus( HRESULT_FROM_WIN32(ERROR_ACCESS_DENIED) );
                goto AccessDenied;
            }
        }

    }

    //
    // We know the access status (allowed or denied)
    //

    _accessState = ACCESS_STATE_DONE;
    *pfAccessAllowed = fAccessAllowed;
    return CONTEXT_STATUS_CONTINUE;

AccessDenied:
    *pfAccessAllowed = FALSE;
    _accessState = ACCESS_STATE_SENDING_ERROR;

    //
    // Send back the bad access response
    //

    hr = SendResponse( W3_FLAG_ASYNC );
    if ( FAILED( hr ) )
    {
        _accessState = ACCESS_STATE_DONE;
        return CONTEXT_STATUS_CONTINUE;
    }
    else
    {
        return CONTEXT_STATUS_PENDING;
    }
}

CERTIFICATE_CONTEXT *
W3_CONTEXT::QueryCertificateContext(
    VOID
)
/*++

Routine Description:

    Get client cert info object.  We get it from the main context

Arguments:

    None

Return Value:

    Pointer to client cert object

--*/
{
    return QueryMainContext()->QueryCertificateContext();
}

BOOL
W3_CONTEXT::CheckClientCertificateAccess(
    VOID
)
/*++

Routine Description:

    Check the context's certificate for validity

Arguments:

    None

Return Value:

    TRUE if the cert is valid, else FALSE

--*/
{
    W3_MAIN_CONTEXT *           pMainContext;
    CERTIFICATE_CONTEXT *       pCertificateContext;
    DWORD                       dwCertError;

    pMainContext = QueryMainContext();
    DBG_ASSERT( pMainContext != NULL );

    pCertificateContext = pMainContext->QueryCertificateContext();
    if ( pCertificateContext == NULL )
    {
        return FALSE;
    }

    dwCertError = pCertificateContext->QueryCertError();

    if ( dwCertError == ERROR_SUCCESS )
    {
        return TRUE;
    }

    
    SetErrorStatus( (HRESULT) dwCertError );
    
    if ( dwCertError == CERT_E_EXPIRED )
    {
        QueryResponse()->SetStatus( HttpStatusForbidden,
                                    Http403CertTimeInvalid );
        return FALSE;
    }
    else if ( dwCertError == CERT_E_REVOKED  ||
              dwCertError == CRYPT_E_REVOKED  ||
              dwCertError == CRYPT_E_REVOCATION_OFFLINE ||
              dwCertError == CERT_E_REVOCATION_FAILURE )

    {
        QueryResponse()->SetStatus( HttpStatusForbidden,
                                    Http403CertRevoked );
        return FALSE;
    }
    else if ( dwCertError == CRYPT_E_NO_REVOCATION_CHECK )
    {
        // If client cert has no CDP we will not take it as error
        // CRYPT_E_NO_REVOCATION_CHECK is returned in that case
        return TRUE;
    }
    else
    {
        QueryResponse()->SetStatus( HttpStatusForbidden,
                                    Http403CertInvalid );
        return FALSE;
    }
    return TRUE;
}

HRESULT
W3_CONTEXT::CheckPathInfoExists(
    W3_HANDLER **               ppHandler
)
/*++

Routine Description:

    Utility to check whether path info exists.  If it does exist, this
    function succeeds without setting the handler.

    If the file doesn't exist, this function succeeds but sets a general
    handler to send the error

Arguments:

    ppHandler - Set to handler

Return Value:

    HRESULT

--*/
{
    HRESULT             hr = NO_ERROR;
    W3_FILE_INFO *      pOpenFile = NULL;
    W3_HANDLER *        pHandler = NULL;
    URL_CONTEXT *       pUrlContext;
    CACHE_USER          fileUser;

    if ( ppHandler != NULL )
    {
        *ppHandler = NULL;
    }

    pUrlContext = QueryUrlContext();
    DBG_ASSERT( pUrlContext != NULL );

    QueryFileCacheUser( &fileUser );

    //
    // Access the file cache, but only for existence
    //

    hr = pUrlContext->OpenFile( &fileUser, 
                                &pOpenFile,
                                NULL,
                                NULL,
                                FALSE,
                                TRUE );
    if ( FAILED( hr ) )
    {
        DBG_ASSERT( pOpenFile == NULL );

        if ( ppHandler == NULL )
        {
            goto Exit;
        }

        switch ( WIN32_FROM_HRESULT( hr ) )
        {
        case ERROR_FILE_NOT_FOUND:
        case ERROR_PATH_NOT_FOUND:
        case ERROR_INVALID_NAME:
            pHandler = new W3_GENERAL_HANDLER( this,
                                               HttpStatusNotFound );
            break;

        case ERROR_INVALID_PARAMETER:
            pHandler = new W3_GENERAL_HANDLER( this,
                                               HttpStatusUrlTooLong );
            break;

        case ERROR_ACCESS_DENIED:
        case ERROR_ACCOUNT_DISABLED:
        case ERROR_LOGON_FAILURE:
            pHandler = new W3_GENERAL_HANDLER( this,
                                               HttpStatusUnauthorized,
                                               Http401Application );
            break;

        default:
            pHandler = new W3_GENERAL_HANDLER( this,
                                               HttpStatusServerError );
            break;
        }

        if ( pHandler == NULL )
        {
            hr = HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );

            SetErrorStatus( hr );
        }
        else
        {
            SetErrorStatus( hr );

            hr = NO_ERROR;
        }
    }
    else
    {   
        //
        // We just wanted to check for existence, no need to keep the file
        //
        
        DBG_ASSERT( pOpenFile != NULL );

        pOpenFile->DereferenceCacheEntry();
    }

    if ( ppHandler != NULL )
    {
        *ppHandler = pHandler;
    }

 Exit:
    return hr;
}

HRESULT
W3_CONTEXT::ValidateAppPool(
    BOOL *                  pfAppPoolValid
)
/*++

Routine Description:

    Validate whether the apppool for the URL is allowed.  Basically this 
    is code to ensure that filters/extensions/config don't attempt to 
    execute a URL outside this processes' AppPool space.  
    
    This problem is largely complicated by the fact WAS may route to an
    apppool contrary to the URL config, if the AppPool in config is not 
    valid.  Life is full of lame complications I guess.  

Arguments:

    pfAppPoolValid - Set to TRUE if AppPool is valid

Return Value:

    HRESULT

--*/
{
    W3_MAIN_CONTEXT *               pMainContext;
    W3_REQUEST *                    pRequest;
    URL_CONTEXT *                   pUrlContext;
    HRESULT                         hr;
    W3_URL_INFO *                   pUrlInfo = NULL;
    
    if ( pfAppPoolValid == NULL )
    {
        DBG_ASSERT( FALSE );
        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }
    
    *pfAppPoolValid = FALSE;
    
    //
    // If we're in backward compat mode, OR if we're being lanuched on the
    // command line, then bail on the check
    //
    
    if ( g_pW3Server->QueryInBackwardCompatibilityMode() )
    {
        *pfAppPoolValid = TRUE;
        return NO_ERROR;
    }
    
    if ( g_pW3Server->QueryIsCommandLineLaunch() )
    {
        *pfAppPoolValid = TRUE;
        return NO_ERROR;
    }
    
    //
    // Do the fast check.  If the URL's AppPool matches the current AppPool
    // then we know we're good!
    //
    
    pUrlContext = QueryUrlContext();
    DBG_ASSERT( pUrlContext != NULL );
    
    if ( pUrlContext->QueryMetaData()->QueryAppPoolMatches() )
    {
        *pfAppPoolValid = TRUE;
        return NO_ERROR;
    }
    
    //
    // If we're the original request (i.e. this is a main context), then 
    // life may be tricky.
    //
    // We know (we assume) that WAS will route correctly.  Therefore if we
    // see that the URL's AppPoolID property doesn't match the processes'
    // AppPoolId, that is OK.  
    // 
    
    pMainContext = QueryMainContext();
    if ( pMainContext == this )
    {
        pRequest = QueryRequest();
        DBG_ASSERT( pRequest != NULL );
        
        if ( !pRequest->QueryUrlChanged() )
        {
            //
            // We URL hasn't changed.  This means that the URL's apppool
            // is invalid, and thus WAS routed somewhere else.  At this point,
            // we really can't check config AppPools since WAS has already
            // changed the "rules".  Therefore we store doing 
            // AppPool checks
            //
            
            pMainContext->SetIgnoreAppPoolCheck();
            
            *pfAppPoolValid = TRUE;
        }
        else
        {
            STACK_STRU(             strOriginalUrl, 256 );
            
            //
            // URL has changed.  We must check the original URL
            //
            
            hr = pRequest->GetOriginalFullUrl( &strOriginalUrl );
            if ( FAILED( hr ) )
            {
                return hr;
            }
            
            DBG_ASSERT( g_pW3Server->QueryUrlInfoCache() != NULL );

            hr = g_pW3Server->QueryUrlInfoCache()->GetUrlInfo( this,
                                                               strOriginalUrl,
                                                               &pUrlInfo );
            if ( FAILED( hr ) )
            {
                return hr;
            }
            
            DBG_ASSERT( pUrlInfo != NULL );
            
            if ( !pUrlInfo->QueryMetaData()->QueryAppPoolMatches() )
            {
                //
                // Even the original URL doesn't match.  We have to 
                // allow this request to proceed.
                //
                
                pMainContext->SetIgnoreAppPoolCheck();
                
                *pfAppPoolValid = TRUE;
            }
            else
            {
                *pfAppPoolValid = FALSE;
            }
            
            pUrlInfo->DereferenceCacheEntry();
        }
    }
    else
    {
        //
        // This is a child request.  The only way we can let this request
        // proceed is if the main request's apppool didn't match
        //
        
        *pfAppPoolValid = pMainContext->QueryIgnoreAppPoolCheck();
    }
    
    return NO_ERROR;
}

HRESULT
W3_CONTEXT::InternalDetermineHandler(
    W3_HANDLER **               ppHandler,
    BOOL                        fDoExistenceCheck
)
/*++

Routine Description:

    Determine the handler for a given request, and return it to caller

    How to determine handler is driven by the Magic Flow Chart (TM)

Arguments:

    ppHandler - Set to point to handler on success
    fDoExistenceCheck - Should we do the pathinfo existence check

Return Value:

    HRESULT

--*/
{
    W3_REQUEST *                pRequest;
    URL_CONTEXT *               pUrlContext;
    W3_METADATA *               pMetaData;
    HRESULT                     hr = NO_ERROR;
    W3_HANDLER *                pHandler = NULL;
    META_SCRIPT_MAP_ENTRY *     pScriptMapEntry = NULL;
    STACK_STRA(                 strHeaderValue, 10 );
    STACK_STRA(                 strVerb, 10 );
    HTTP_VERB                   VerbType;
    BOOL                        fKnownVerb = FALSE;
    DWORD                       dwFilePerms;
    GATEWAY_TYPE                GatewayType;
    BOOL                        fAccessAllowed = FALSE;
    BOOL                        fSuspectUrl = FALSE;
    LPCSTR                      szHeaderValue =  NULL;
    W3_TRACE_LOG *              pTraceLog;
    BOOL                        fAppPoolValid = FALSE;
    LPCSTR                      szContentLength;
    BOOL                        fRedirected = FALSE;
    STACK_STRU                ( strRedirection, 256);
    HTTP_STATUS                 statusCode;

    if ( ppHandler == NULL )
    {
        DBG_ASSERT( FALSE );
        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }
    
    *ppHandler = NULL;

    pRequest = QueryRequest();
    DBG_ASSERT( pRequest != NULL );

    pUrlContext = QueryUrlContext();
    DBG_ASSERT( pUrlContext != NULL );

    pMetaData = pUrlContext->QueryMetaData();
    DBG_ASSERT( pMetaData != NULL );

    VerbType = pRequest->QueryVerbType();

    //
    // Here is as good a place as any to check apppool.  Basically we 
    // need to ensure that the AppPool which applies to this request is the
    // same as the current process's AppPool. 
    //
    
    hr = ValidateAppPool( &fAppPoolValid );
    if ( FAILED( hr ) )
    {
        goto Finished;
    }
    
    if ( !fAppPoolValid )
    {
        //
        // No match.  This request is forbidden.  
        //
        
        pHandler = new W3_GENERAL_HANDLER( this,
                                           HttpStatusForbidden,
                                           Http403AppPoolDenied );
        if ( pHandler == NULL )
        {
            hr = HRESULT_FROM_WIN32( GetLastError() );
        }
        
        goto Finished;
    } 

    //
    // Check to see if the content-length of this request
    // exceeds the maximum allowed.
    //

    szContentLength = pRequest->GetHeader( HttpHeaderContentLength );

    if ( szContentLength &&
         ( strtoul( szContentLength, NULL, 10 ) >
           pMetaData->QueryMaxRequestEntityAllowed() ) )
    {
        pHandler = new W3_GENERAL_HANDLER( this,
                                           HttpStatusEntityTooLarge );

        if ( pHandler == NULL )
        {
            hr = HRESULT_FROM_WIN32( GetLastError() );
        }

        goto Finished;
    }

    //
    // Handle the incredibly important TRACE verb
    //

    if ( VerbType == HttpVerbTRACE )
    {
        if ( g_pW3Server->QueryIsTraceEnabled() )
        {
            pHandler = new W3_TRACE_HANDLER( this );
        }
        else
        {
            pHandler = new W3_GENERAL_HANDLER( this,
                                               HttpStatusNotImplemented );
        }

        if ( pHandler == NULL )
        {
            hr = HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );
        }

        goto Finished;
    }

    //
    // Check if we should do client-side redirection for this request
    //

    hr = CheckUrlRedirection( &fRedirected,
                              &strRedirection,
                              &statusCode );
    if (FAILED(hr))
    {
        goto Finished;
    }
    if (fRedirected)
    {
        pHandler = new W3_REDIRECTION_HANDLER( this );

        if (pHandler == NULL)
        {
            hr = HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );
        }
        else
        {
            hr = ((W3_REDIRECTION_HANDLER *)pHandler)->SetDestination(
                                            strRedirection,
                                            statusCode);
        }

        goto Finished;
    }

    //
    // Check for a * script map.  If one exists, use it if allowed
    //

    pScriptMapEntry = pMetaData->QueryScriptMap()->
        QueryStarScriptMap( QueryCurrentStarScriptMapIndex() );
    if ( pScriptMapEntry != NULL )
    {
        //
        // If there is a ./ in the URL, then always check for existence.  This
        // prevents a trailing . metabase equivilency problem
        //

        fSuspectUrl = pRequest->IsSuspectUrl();

        if ( fDoExistenceCheck &&
             ( pScriptMapEntry->QueryCheckPathInfoExists() ||
               fSuspectUrl ) )
        {
            hr = CheckPathInfoExists( &pHandler );
            if ( FAILED( hr ) )
            {
                goto Finished;
            }

            if ( pHandler != NULL )
            {
                //
                // We already have an error handler for this request.
                // That means path info didn't really exist
                //

                goto Finished;
            }
        }

        //
        // Create the appropriate handler for the script mapping
        //

        if ( pScriptMapEntry->QueryGateway() == GATEWAY_CGI )
        {
            pHandler = new W3_CGI_HANDLER( this, pScriptMapEntry );
        }
        else
        {
            DBG_ASSERT( pScriptMapEntry->QueryGateway() == GATEWAY_ISAPI );
            pHandler = new (this) W3_ISAPI_HANDLER( this, pScriptMapEntry );
        }

        if ( pHandler == NULL )
        {
            hr = HRESULT_FROM_WIN32( GetLastError() );
        }

        goto Finished;
    }

    //
    // Check for Translate: f
    //
    // If there, it goes to DAVFS unless DAV is disabled
    //
    
    if ( g_pW3Server->QueryIsDavEnabled() )
    {
        szHeaderValue = pRequest->GetHeader( HttpHeaderTranslate );
        if ( szHeaderValue &&
             toupper( szHeaderValue[ 0 ] ) == 'F' &&
             szHeaderValue[ 1 ] == '\0' )
        {
            //
            // This is a DAV request
            //

            pHandler = new (this) W3_DAV_HANDLER( this );

            if ( pHandler == NULL )
            {
                hr = HRESULT_FROM_WIN32( GetLastError() );
            }

            goto Finished;
        }
    }

    //
    // Does this request map to an extension
    //
    // Map can mean one of two things
    // a) A script map (as in MD_SCRIPT_MAP)
    // b) An explicit .DLL/.EXE/.COM/etc.
    //

    pScriptMapEntry = pUrlContext->QueryUrlInfo()->QueryScriptMapEntry();
    if ( pScriptMapEntry != NULL ||
         pUrlContext->QueryUrlInfo()->QueryGateway() == GATEWAY_ISAPI ||
         pUrlContext->QueryUrlInfo()->QueryGateway() == GATEWAY_CGI )
    {
        dwFilePerms = pMetaData->QueryAccessPerms();

        if ( pScriptMapEntry != NULL )
        {
            GatewayType = pScriptMapEntry->QueryGateway();

            //
            // We have a script map.  Check access rights
            //

            if ( pScriptMapEntry->QueryAllowScriptAccess() &&
                 IS_ACCESS_ALLOWED( pRequest, dwFilePerms, SCRIPT ) )
            {
                fAccessAllowed = TRUE;
            }

            if ( !fAccessAllowed &&
                 IS_ACCESS_ALLOWED( pRequest, dwFilePerms, EXECUTE ) )
            {
                fAccessAllowed = TRUE;
            }

            if ( !fAccessAllowed )
            {
                pHandler = new W3_GENERAL_HANDLER( this,
                                                   HttpStatusForbidden,
                                                   Http403ExecAccessDenied );
                if ( pHandler == NULL )
                {
                    hr = HRESULT_FROM_WIN32( GetLastError() );
                }
                goto Finished;
            }

            //
            // If there is a ./ in the URL, then always check for existence.  This
            // prevents a trailing . metabase equivilency problem
            //

            fSuspectUrl = pRequest->IsSuspectUrl();

            //
            // Should we verify that path info does exist?
            //

            if ( fDoExistenceCheck && 
                 ( pScriptMapEntry->QueryCheckPathInfoExists() ||
                   fSuspectUrl ) )
            {
                hr = CheckPathInfoExists( &pHandler );
                if ( FAILED( hr ) )
                {
                    goto Finished;
                }

                if ( pHandler != NULL )
                {
                    //
                    // We already have an error handler for this request.
                    // That means path info didn't really exist
                    //

                    goto Finished;
                }
            }

            //
            // Does the script map support the verb?
            //

            hr = pRequest->GetVerbString( &strVerb );
            if ( FAILED( hr ) )
            {
                goto Finished;
            }

            if ( !pScriptMapEntry->IsVerbAllowed( strVerb ) )
            {
                pHandler = new W3_GENERAL_HANDLER( this,
                                                   HttpStatusForbidden,
                                                   Http403ExecAccessDenied );
                if ( pHandler == NULL )
                {
                    hr = HRESULT_FROM_WIN32( GetLastError() );
                }
                goto Finished;
            }
        }
        else
        {
            GatewayType = pUrlContext->QueryUrlInfo()->QueryGateway();
        }

        //
        // OK.  If we got to here, we can setup an executable handler
        //

        if ( GatewayType == GATEWAY_CGI )
        {
            pHandler = new W3_CGI_HANDLER( this, pScriptMapEntry );
        }
        else
        {
            DBG_ASSERT( GatewayType == GATEWAY_ISAPI );
            pHandler = new (this) W3_ISAPI_HANDLER( this, pScriptMapEntry );
        }

        if ( pHandler == NULL )
        {
            hr = HRESULT_FROM_WIN32( GetLastError() );
        }

        goto Finished;
    }

    //
    // Ok.  No script map applied.  Is this an unknown verb?
    // (i.e. not GET, HEAD, POST, TRACE)
    //

    if ( VerbType == HttpVerbGET ||
         VerbType == HttpVerbPOST ||
         VerbType == HttpVerbHEAD )
    {
        fKnownVerb = TRUE;
    }
    else
    {
        fKnownVerb = FALSE;
    }

    //
    // If this verb is unknown, then it goes to DAV
    //

    if ( fKnownVerb == FALSE )
    {
        if (g_pW3Server->QueryIsDavEnabled())
        {
            pHandler = new (this) W3_DAV_HANDLER( this );
        }
        else if ( VerbType == HttpVerbOPTIONS )
        {
            //
            // We handle OPTIONS if DAV is disabled
            //
            pHandler = new W3_OPTIONS_HANDLER( this );
        }
        else
        {
            pHandler = new W3_GENERAL_HANDLER( this,
                                               HttpStatusNotImplemented );
        }

        if ( pHandler == NULL )
        {
            hr = HRESULT_FROM_WIN32( GetLastError() );
        }

        goto Finished;
    }

    //
    // If there are special DAV verbs like If: and Lock-Token:, then it also
    // go to DAV unless it is disabled
    //

    if ( g_pW3Server->QueryIsDavEnabled() )
    {
        if ( SUCCEEDED( pRequest->GetHeader( "If",
                                             2,
                                             &strHeaderValue,
                                             TRUE ) ) ||
             SUCCEEDED( pRequest->GetHeader( "Lock-Token",
                                             10,
                                             &strHeaderValue,
                                             TRUE ) ) )
        {
            pHandler = new (this) W3_DAV_HANDLER( this );

            if ( pHandler == NULL )
            {
                hr = HRESULT_FROM_WIN32( GetLastError() );
            }

            goto Finished;
        }
    }
    
    //
    // OK.  Exchange/DAV-providers have had their chance.  Now its our turn!
    //

    //
    // Call the static file handler
    //

    pHandler = new (this) W3_STATIC_FILE_HANDLER( this );

    if ( pHandler == NULL )
    {
        hr = HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );
        goto Finished;
    }

Finished:

    pTraceLog = QueryMainContext()->QueryTraceLog();

    if ( FAILED( hr ) )
    {
        if ( pTraceLog != NULL )
        {
            pTraceLog->Trace( L"%I64x: Failed to find handler for request.  hr = %08X\n",
                              QueryRequest()->QueryRequestId(),
                              hr );
        }

        DBG_ASSERT( pHandler == NULL );
    }
    else
    {
        if ( pTraceLog != NULL )
        {
            pTraceLog->Trace( L"%I64x: Found handler '%ws' for request\n",
                              QueryRequest()->QueryRequestId(),
                              pHandler->QueryName() );
        }
    }

    *ppHandler = pHandler;

    return hr;
}

HRESULT
W3_CONTEXT::SetupHttpRedirect(
    STRA &              strPath,
    BOOL                fIncludeParameters,
    HTTP_STATUS &       httpStatus
)
/*++

Routine Description:

    Do an HTTP redirect (301 or 302)

Arguments:

    strPath - New path component of destination
    fIncludeParameters - Include query string in Location: header
    httpStatus - Status for redirect (i.e. HttpStatusRedirect)

Return Value:

    HRESULT

--*/
{
    HRESULT      hr;
    STACK_STRA(  strRedirect, MAX_PATH);

    W3_RESPONSE *pResponse = QueryResponse();
    W3_REQUEST  *pRequest  = QueryRequest();

    //
    // If it an absolute path add the protocol, host name and QueryString
    // if specified, otherwise just assume it is a fully qualified URL.
    //
    if (strPath.QueryStr()[0] == '/')
    {
        // build the redirect URL (with http://) into strRedirect
        hr = pRequest->BuildFullUrl( strPath,
                                     &strRedirect,
                                     fIncludeParameters );
    }
    else
    {
        hr = strRedirect.Copy( strPath );
    }

    if ( FAILED( hr ) )
    {
        return hr;
    }

    if (strRedirect.QueryCCH() > MAXUSHORT)
    {
        return HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);
    }

    //
    // Setup the response, starting with status and location:
    //

    pResponse->SetStatus( httpStatus );

    //
    // Be careful to reset the response on subsequent failures so we don't
    // end up with an incomplete response!
    //

    hr = pResponse->SetHeader( HttpHeaderLocation,
                               strRedirect.QueryStr(),
                               (USHORT)strRedirect.QueryCCH() );
    if ( FAILED( hr ) )
    {
        goto Failed;
    }

    pResponse->SetHeaderByReference( HttpHeaderContentType,
                                     "text/html", 9 );

    //
    // Now add any metabase configured "redirect" headers (lame)
    //

    STRA *pstrRedirectHeaders = QueryUrlContext()->QueryMetaData()->QueryRedirectHeaders();
    if ( pstrRedirectHeaders != NULL )
    {
        hr = pResponse->AppendResponseHeaders( *pstrRedirectHeaders );
        if ( FAILED( hr ) )
        {
            goto Failed;
        }
    }

    //
    // Add the canned redirect body.  This means taking the format string,
    // and inserting the URL into it
    //

    //
    // First HTMLEncode the target URL
    //
    hr = strRedirect.HTMLEncode();
    if ( FAILED( hr ) )
    {
        goto Failed;
    }

    CHAR *pvRedirect;
    DWORD cbRedirect = sm_cbRedirectMessage + strRedirect.QueryCCH();

    //
    // Keep a buffer around
    //

    hr = QueryHeaderBuffer()->AllocateSpace( cbRedirect + 1,
                                             &pvRedirect );
    if ( FAILED( hr ) )
    {
        goto Failed;
    }

    cbRedirect = _snprintf( pvRedirect,
                            cbRedirect,
                            sm_achRedirectMessage,
                            strRedirect.QueryStr() );

    //
    // Setup the response
    //

    hr = pResponse->AddMemoryChunkByReference( pvRedirect,
                                               cbRedirect );
    if ( FAILED( hr ) )
    {
        goto Failed;
    }

    return S_OK;

 Failed:
    pResponse->Clear();
    pResponse->SetStatus( HttpStatusServerError );

    return hr;
}

HRESULT
W3_CONTEXT::SetupHttpRedirect(
    STRU &              strPath,
    BOOL                fIncludeParameters,
    HTTP_STATUS &       httpStatus
)
/*++

Routine Description:

    Do an HTTP redirect (301 or 302)

Arguments:

    strPath - New path component of destination
    fIncludeParameters - Include query string in Location: header
    httpStatus - Status for redirect (i.e. HttpStatusRedirect)

Return Value:

    HRESULT

--*/
{
    //
    // Convert the unicode path to ansi
    //
    HRESULT hr;
    STACK_STRA (straPath, MAX_PATH);
    if (FAILED(hr = straPath.CopyWToUTF8Unescaped(strPath)) ||
        FAILED(hr = straPath.Escape(TRUE))) // Only escape high-bit set chars
    {
        return hr;
    }

    return SetupHttpRedirect(straPath,
                             fIncludeParameters,
                             httpStatus);
}

BOOL W3_CONTEXT::QueryDoUlLogging()
{
    if (QuerySite() == NULL ||
        !QuerySite()->QueryDoUlLogging())
    {
        return FALSE;
    }

    if (QueryUrlContext() == NULL ||
        QueryUrlContext()->QueryMetaData() == NULL)
    {
        return TRUE;
    }

    return !QueryUrlContext()->QueryMetaData()->QueryDontLog();
}

BOOL W3_CONTEXT::QueryDoCustomLogging()
{
    if (QuerySite() == NULL ||
        !QuerySite()->QueryDoCustomLogging())
    {
        return FALSE;
    }

    if (QueryUrlContext() == NULL ||
        QueryUrlContext()->QueryMetaData() == NULL)
    {
        return TRUE;
    }

    return !QueryUrlContext()->QueryMetaData()->QueryDontLog();
}

VOID
W3_CONTEXT::SetSSICommandHandler(
    W3_HANDLER *            pHandler
)
/*++

Routine Description:

    Explicitly sets the CGI_HANDLER for this request.  This is the handler
    which executes explicit command lines on behalf of SSI

    The function is named SetSSICommandHandler (instead of just SetHandler())
    to discourage others from using this function.

Arguments:

    pHandler - Handler to set.  Must be the CGI handler

Return Value:

    None

--*/
{
    DBG_ASSERT( pHandler != NULL );
    DBG_ASSERT( _pHandler == NULL );
    DBG_ASSERT( wcscmp( pHandler->QueryName(), L"CGIHandler" ) == 0 );

    _pHandler = pHandler;
}

VOID *
W3_CONTEXT::ContextAlloc(
    DWORD           cbSize
)
/*++

Routine Description:

    Allocate some per-W3Context memory

Arguments:

    cbSize - Size to allocate

Return Value:

    Pointer to memory (or NULL on failure)

--*/
{
    VOID *          pvRet = NULL;
    HRESULT         hr;

    pvRet = QueryMainContext()->AllocateFromInlineMemory( cbSize );
    if ( pvRet == NULL )
    {
        hr = _ChunkBuffer.AllocateSpace( cbSize,
                                         &pvRet );
        if ( FAILED( hr ) )
        {
            SetLastError( WIN32_FROM_HRESULT( hr ) );
        }
        else
        {
            DBG_ASSERT( pvRet != NULL );
        }
    }
        
    return pvRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\iisplus\ulw3\w3request.cxx ===
/*++

   Copyright    (c)    1999    Microsoft Corporation

   Module Name :
     w3request.cxx

   Abstract:
     Friendly wrapper for UL_HTTP_REQUEST
 
   Author:
     Bilal Alam (balam)             13-Dec-1999

   Environment:
     Win32 - User Mode

   Project:
     ULW3.DLL
--*/

#include "precomp.hxx"

//
// LocalHost address used to determining whether request is local/remote
// 

#define LOCAL127            0x0100007F  // 127.0.0.1

#define DEFAULT_PORT        80
#define DEFAULT_PORT_SECURE 443

LPADDRINFO                   W3_REQUEST::sm_pHostAddrInfo = NULL;

ALLOC_CACHE_HANDLER *       W3_CLONE_REQUEST::sm_pachCloneRequests;

VOID
W3_REQUEST::RemoveDav(
    VOID
)
/*++

Routine Description:

    Remove DAV'ness of request

Arguments:

    None

Return Value:

    None

--*/
{
    //
    // Remove translate header
    //

    DeleteHeader( "Translate" );
    DeleteHeader( "If" );
    DeleteHeader( "Lock-Token" );
}

BOOL
W3_REQUEST::IsSuspectUrl(
    VOID
)
/*++

Routine Description:
    
    Is the URL for this request look suspect?  
    
    Suspect means there is a ./ pattern in it which could cause a metabase
    equivilency issue.

Arguments:

    None

Return Value:

    TRUE if the URL is suspect, else FALSE

--*/
{
    WCHAR *             pszDotSlash;
    WCHAR *             pszUrl;
    WCHAR               chTemp;
    DWORD               cchAbsPathLen;
    
    pszUrl = (PWSTR) _pUlHttpRequest->CookedUrl.pAbsPath;
    
    cchAbsPathLen = _pUlHttpRequest->CookedUrl.AbsPathLength / sizeof( WCHAR );
    
    //
    // URL UL gives us has backslashes flipped.  But it is not 0 terminated
    //
    
    chTemp = pszUrl[ cchAbsPathLen ];
    pszUrl[ cchAbsPathLen ] = L'\0';
    
    pszDotSlash = wcsstr( pszUrl, L"./" );
    
    pszUrl[ cchAbsPathLen ] = chTemp;
    
    if ( pszDotSlash != NULL )
    {
        return TRUE;
    }
    
    //
    // If the URL ends with a ., it is also suspect
    //
    
    if ( pszUrl[ cchAbsPathLen - 1 ] == L'.' )
    {
        return TRUE;
    }
    
    return FALSE;
}

BOOL
W3_REQUEST::QueryClientWantsDisconnect(
    VOID
)
/*++

Routine Description:

    Returns whether the client wants to disconnect, based on its version and
    connection: headers

Arguments:

    None

Return Value:

    TRUE if client wants to disconnect

--*/
{
    HTTP_VERSION            version;
    LPCSTR                  pszConnection;
    
    version = QueryVersion();
    
    //
    // If 0.9, then disconnect
    //
    
    if ( HTTP_EQUAL_VERSION( version, 0, 9 ) )
    {
        return TRUE;
    }
    
    //
    // If 1.0 and Connection: keep-alive isn't present
    //
    
    if ( HTTP_EQUAL_VERSION( version, 1, 0 ) )
    {
        pszConnection = GetHeader( HttpHeaderConnection );
        if ( pszConnection == NULL ||
             _stricmp( pszConnection, "Keep-Alive" ) != 0 )
        {
            return TRUE;
        }
    }
    
    //
    // If 1.1 and Connection: Close is present
    //
    
    if ( HTTP_EQUAL_VERSION( version, 1, 1 ) )
    {
        pszConnection = GetHeader( HttpHeaderConnection );
        if ( pszConnection != NULL &&
             _stricmp( pszConnection, "Close" ) == 0 )
        {
            return TRUE;
        }
    }

    return FALSE;
}

HRESULT
W3_REQUEST::SetHeadersByStream(
    CHAR *              pszStream
)
/*++

Routine Description:

    Set request headers based on given stream    

Arguments:

    pszHeaderStream - Stream to parse and set headers off

Return Value:

    HRESULT

--*/
{
    CHAR *              pszCursor;
    CHAR *              pszEnd;
    CHAR *              pszColon;
    HRESULT             hr = NO_ERROR;
    STACK_STRA(         strHeaderLine, 128 );
    STACK_STRA(         strHeaderName, 32 );
    STACK_STRA(         strHeaderValue, 64 );
    
    if ( pszStream == NULL )
    {
        DBG_ASSERT( FALSE );
        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }
    
    //
    // \r\n delimited
    //
    
    pszCursor = pszStream;
    while ( pszCursor != NULL && *pszCursor != '\0' )
    {
        if ( *pszCursor == '\r' && *(pszCursor + 1) == '\n' )
        {
            break;
        }
        
        pszEnd = strstr( pszCursor, "\r\n" );
        if ( pszEnd == NULL )
        {
            break;
        }
        //
        // Split out a line
        //
         
        hr = strHeaderLine.Copy( pszCursor, 
                                 (DWORD)DIFF(pszEnd - pszCursor) );
        if ( FAILED( hr ) )
        {
            goto Finished;
        }        

        //
        // Advance the cursor the right after the \r\n
        //

        pszCursor = pszEnd + 2;
        
        //
        // Split the line above into header:value
        //
        
        pszColon = strchr( strHeaderLine.QueryStr(), ':' );
        if ( pszColon == NULL )
        {
            //
            // Expecting name:value.  Just skip for now
            //
            
            continue;
        }
        
        hr = strHeaderName.Copy( strHeaderLine.QueryStr(),
                                 (DWORD)DIFF(pszColon - strHeaderLine.QueryStr()) );
        if ( FAILED( hr ) )
        {
            goto Finished;
        }
        
        //
        // Skip the first space after the : if there is one
        //
        
        if ( pszColon[ 1 ] == ' ' )
        {
            pszColon++;
        }
        
        hr = strHeaderValue.Copy( pszColon + 1 );
        if ( FAILED( hr ) )
        {
            goto Finished;
        }

        //
        // Add the header to the response
        //

        hr = SetHeader( strHeaderName,
                        strHeaderValue,
                        FALSE );           
        if ( FAILED( hr ) )
        {
            goto Finished;
        }
    }

Finished:
    return hr;
}

DWORD
W3_REQUEST::QueryIPv4LocalAddress(
    VOID
) const
/*++

Routine Description:

    Get the local IP address connected to, in host order (assumes IPv4)

Arguments:

    None

Return Value:

    Address

--*/
{
    PSOCKADDR_IN   pAddress;

    DBG_ASSERT( _pUlHttpRequest->Address.pLocalAddress->sa_family == AF_INET );
    pAddress = (PSOCKADDR_IN)_pUlHttpRequest->Address.pLocalAddress;
    return pAddress->sin_addr.s_addr;
}

DWORD
W3_REQUEST::QueryIPv4RemoteAddress(
    VOID
) const
/*++

Routine Description:

    Get the remote IP address connected to, in host order (assumes IPv4)

Arguments:

    None

Return Value:

    Address

--*/
{
    PSOCKADDR_IN   pAddress;

    DBG_ASSERT( _pUlHttpRequest->Address.pRemoteAddress->sa_family == AF_INET );
    pAddress = (PSOCKADDR_IN)_pUlHttpRequest->Address.pRemoteAddress;
    return pAddress->sin_addr.s_addr;
}

IN6_ADDR *
W3_REQUEST::QueryIPv6LocalAddress( 
    VOID 
) const
/*++

Routine Description:

    Get the local IP address connected to, in host order (assumes IPv6)

Arguments:

    None

Return Value:

    Address

--*/
{
    PSOCKADDR_IN6   pAddress;

    DBG_ASSERT( _pUlHttpRequest->Address.pLocalAddress->sa_family == AF_INET6 );
    pAddress = (PSOCKADDR_IN6)_pUlHttpRequest->Address.pLocalAddress;
    return &pAddress->sin6_addr;
}

IN6_ADDR *
W3_REQUEST::QueryIPv6RemoteAddress( 
    VOID 
) const
/*++

Routine Description:

    Get the remote IP address connecting to us, in host order (assumes IPv6)

Arguments:

    None

Return Value:

    Address

--*/
{
    PSOCKADDR_IN6   pAddress;

    DBG_ASSERT( _pUlHttpRequest->Address.pRemoteAddress->sa_family == AF_INET6 );
    pAddress = (PSOCKADDR_IN6)_pUlHttpRequest->Address.pRemoteAddress;
    return &pAddress->sin6_addr;
}

USHORT
W3_REQUEST::QueryLocalPort(
    VOID
) const
{
    USHORT port = 0;
    PSOCKADDR_IN6   pV6Address;
    PSOCKADDR_IN    pV4Address;
    
    if( _pUlHttpRequest->Address.pLocalAddress->sa_family == AF_INET )
    {
        pV4Address = (PSOCKADDR_IN)_pUlHttpRequest->Address.pLocalAddress;
        port = pV4Address->sin_port;
    }
    else if( _pUlHttpRequest->Address.pLocalAddress->sa_family == AF_INET6 )
    {
        pV6Address = (PSOCKADDR_IN6)  _pUlHttpRequest->Address.pLocalAddress;
        port = pV6Address->sin6_port;
    }
    else
    {
        DBG_ASSERT( FALSE );
    }

    return port;
}

USHORT
W3_REQUEST::QueryRemotePort(
    VOID
) const
{
    USHORT port = 0;
    PSOCKADDR_IN6   pV6Address;
    PSOCKADDR_IN    pV4Address;
    
    if( _pUlHttpRequest->Address.pRemoteAddress->sa_family == AF_INET )
    {
        pV4Address = (PSOCKADDR_IN)_pUlHttpRequest->Address.pRemoteAddress;
        port = pV4Address->sin_port;
    }
    else if( _pUlHttpRequest->Address.pRemoteAddress->sa_family == AF_INET6 )
    {
        pV6Address = (PSOCKADDR_IN6)  _pUlHttpRequest->Address.pRemoteAddress;
        port = pV6Address->sin6_port;
    }
    else
    {
        DBG_ASSERT( FALSE );
    }

    return port;
}

PSOCKADDR
W3_REQUEST::QueryLocalSockAddress(
    VOID
) const
{
    return _pUlHttpRequest->Address.pLocalAddress;
}

PSOCKADDR
W3_REQUEST::QueryRemoteSockAddress(
    VOID
) const
{
    return _pUlHttpRequest->Address.pRemoteAddress;
}

BOOL
W3_REQUEST::IsProxyRequest(
    VOID
)
/*++
    Description:

        Check if request was issued by a proxy, as determined by following rules :
        - "Via:" header is present (HTTP/1.1)
        - "Forwarded:" header is present (some HTTP/1.0 implementations)
        - "User-Agent:" contains "via ..." (CERN proxy)

    Arguments:
        None

    Returns:
        TRUE if client request was issued by proxy

--*/
{
    LPCSTR   pUserAgent;
    UINT     cUserAgent;
    LPCSTR   pEnd;

    if ( GetHeader( HttpHeaderVia ) || GetHeader( "Forward" ) )
    {
        return TRUE;
    }

    if ( (pUserAgent = GetHeader( HttpHeaderUserAgent )) != NULL )
    {
        cUserAgent = (DWORD)strlen( pUserAgent );
        pEnd = pUserAgent + cUserAgent - 3;

        //
        // scan for "[Vv]ia[ :]" in User-Agent: header
        //

        while ( pUserAgent < pEnd )
        {
            if ( *pUserAgent == 'V' || *pUserAgent == 'v' )
            {
                if ( pUserAgent[1] == 'i' &&
                     pUserAgent[2] == 'a' &&
                     (pUserAgent[3] == ' ' || pUserAgent[3] == ':') )
                {
                    return TRUE;
                }
            }
            ++pUserAgent;
        }
    }

    return FALSE;
}

BOOL
W3_REQUEST::IsChunkedRequest(
    VOID
)
/*++
    Description:

        Check if request is chunk transfer encoded.

    Arguments:
        None

    Returns:
        TRUE if client request has a "transfer-encoding: chunked"
        header.

--*/
{
    BOOL     fRet = FALSE;

    LPCSTR pTransferEncoding = GetHeader( HttpHeaderTransferEncoding );
    if ( pTransferEncoding != NULL )
    {
        fRet = ( _stricmp( pTransferEncoding, "chunked" ) == 0 );
    }

    return fRet;
}

HRESULT
W3_REQUEST::GetAuthType(
    STRA *              pstrAuthType
)
/*++

Routine Description:

    Determine the auth type for this request.  Auth type is the string
    after the authorization header (and before the space if there).
    
    Eg. Authorization: Basic FOOBAR     ==> AuthType is Basic
        Authorization: NTLM             ==> AuthType is NTLM

    And of course if client cert mapping happened, type is "SSL/PCT"

Arguments:

    pstrAuthType - Filled with auth type

Return Value:

    HRESULT

--*/
{
    LPCSTR              pszAuthType;
    LPCSTR              pszSpace;
    HRESULT             hr;
    
    if ( pstrAuthType == NULL )
    {
        DBG_ASSERT( FALSE );
        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }
    
    //
    // First check for client cert mapping
    //
    
    if ( QueryClientCertInfo() != NULL &&
         QueryClientCertInfo()->Token != NULL )
    {
        return pstrAuthType->Copy( "SSL/PCT" );
    }
    
    //
    // Now check for the Authorization: header
    //
    
    pszAuthType = GetHeader( HttpHeaderAuthorization );
    if ( pszAuthType == NULL )
    {
        pstrAuthType->Copy( "" );
        hr = NO_ERROR;
    }
    else
    {
        pszSpace = strchr( pszAuthType, ' ' );
        
        if ( pszSpace == NULL )
        {
            hr = pstrAuthType->Copy( pszAuthType );
        }
        else
        {
            hr = pstrAuthType->Copy( pszAuthType,
                                     (DWORD)DIFF( pszSpace - pszAuthType ) );
        }
    }
    
    return hr;
}

BOOL
W3_REQUEST::IsLocalRequest(
    VOID
) const
/*++

Routine Description:

    Determines whether current request is a local request.  This is used
    since certain vroot permissions can be specified for remote/local

Arguments:

    None

Return Value:

    TRUE if this is a local request

--*/
{
    ADDRINFO    * p = sm_pHostAddrInfo;

    if( _pUlHttpRequest->Address.pLocalAddress->sa_family == AF_INET )
    {
        SOCKADDR_IN * pSockAddr;

        DWORD  ipv4RemoteAddress = ntohl( QueryIPv4RemoteAddress() );

        if( _pUlHttpRequest->Address.pLocalAddress->sa_family == AF_INET )
        {
            DWORD  ipv4LocalAddress  = ntohl( QueryIPv4LocalAddress() );
        
            //
            // Are the remote/local addresses the same?  
            //
    
            if ( ipv4LocalAddress == ipv4RemoteAddress )
            {
                return TRUE;
            }
    
            //
            // Are either equal to 127.0.0.1
            //
    
            if ( ipv4LocalAddress == LOCAL127 ||
                 ipv4RemoteAddress == LOCAL127 )
            {
                return TRUE;
            }
        }

        //
        // Is the remote address equal to one of the host addresses
        // 

        while( p != NULL )
        {
            if( p->ai_family == AF_INET )
            {
                pSockAddr = ( SOCKADDR_IN * )p->ai_addr;
                if( pSockAddr->sin_addr.s_addr == ipv4RemoteAddress )
                {
                    return TRUE;
                }
            }

            p = p->ai_next;
        }
        
        return FALSE;
    }

    if( _pUlHttpRequest->Address.pLocalAddress->sa_family == AF_INET6 )
    {
        SOCKADDR_IN6 * pSockAddr6;
        IN6_ADDR     * pIPv6RemoteAddress = QueryIPv6RemoteAddress(); 

        if( _pUlHttpRequest->Address.pLocalAddress->sa_family  == AF_INET6 )
        {
            IN6_ADDR * pIPv6LocalAddress  = QueryIPv6LocalAddress(); 

            //
            // Are the remote/local addresses the same?  
            //
    
            if( !memcmp( pIPv6LocalAddress, 
                         pIPv6RemoteAddress, 
                         sizeof( IN6_ADDR ) ) )
            {
                return TRUE;
            }

            //
            // Are either equal to ::1
            //

            if( IN6_IS_ADDR_LOOPBACK( pIPv6LocalAddress ) ||
                IN6_IS_ADDR_LOOPBACK( pIPv6RemoteAddress ) ) 
            {
                return TRUE;
            }    
        }

        //
        // Is the remote address equal to one of the host addresses
        // 

        while( p != NULL )
        {
            if( p->ai_family == AF_INET6 )
            {
                pSockAddr6 = ( SOCKADDR_IN6 * )p->ai_addr;
                if( !memcmp( &pSockAddr6->sin6_addr, 
                             pIPv6RemoteAddress,
                             sizeof( IN6_ADDR ) ) )
                {
                    return TRUE;
                }
            }

            p = p->ai_next;
        } 
        
        return FALSE;
    }
    
    DBG_ASSERT( FALSE );
    return FALSE;
}

HRESULT
W3_REQUEST::BuildFullUrl(
    STRU&               strPath,
    STRU *              pstrRedirect,
    BOOL                fIncludeParameters
)
/*++

Routine Description:

    Create a new URL while maintaining host/port/protocol/query-string of
    original request

Arguments:

    strPath - New path portion of URL
    pstrRedirect - String filled with new full URL
    fIncludeParameters - TRUE if original query string should be copied too

Return Value:

    HRESULT

--*/
{
    HRESULT         hr              = NO_ERROR;
    LPWSTR          pszColon        = NULL;
    LPWSTR          pszRightBracket = NULL;

    if ( pstrRedirect == NULL )
    {
        DBG_ASSERT( FALSE );
        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    } 

    hr = pstrRedirect->Copy( IsSecureRequest() ? L"https://" : L"http://" );
    if ( FAILED( hr ) )
    {
        return hr;
    }

    LPCSTR pszHost = GetHeader( HttpHeaderHost );
    if ( pszHost != NULL )
    {
        hr = pstrRedirect->AppendA( pszHost );
    }
    else
    {
        if( _pUlHttpRequest->CookedUrl.pHost[0] == L'[' )
        {
            pszRightBracket = wcschr( _pUlHttpRequest->CookedUrl.pHost, L']' );
            if( pszRightBracket != NULL )
            {
                pszColon = pszRightBracket + 1;
                if( *pszColon != L':' )
                {
                    pszColon = NULL;
                }
            }
            else
            {
                hr = E_FAIL;
            }
        }
        else
        {
            pszColon = wcschr( _pUlHttpRequest->CookedUrl.pHost, L':' );
        }

        if ((pszColon != NULL) &&
            ((IsSecureRequest() && _wtoi(pszColon + 1) == DEFAULT_PORT_SECURE) ||
             (!IsSecureRequest() && _wtoi(pszColon + 1) == DEFAULT_PORT)))
        {
            hr = pstrRedirect->Append( _pUlHttpRequest->CookedUrl.pHost,
                                       (DWORD)DIFF(pszColon - _pUlHttpRequest->CookedUrl.pHost) );
        }
        else
        {
            hr = pstrRedirect->Append( _pUlHttpRequest->CookedUrl.pHost,
                                       _pUlHttpRequest->CookedUrl.HostLength / sizeof( WCHAR ) );
        }
    }

    if ( FAILED( hr ) )
    {
        return hr;
    }

    hr = pstrRedirect->Append( strPath );
    if ( FAILED( hr ) )
    {
        return hr;
    }

    if ( fIncludeParameters &&
         _pUlHttpRequest->CookedUrl.pQueryString != NULL )
    {
        //
        // UL_HTTP_REQUEST::QueryString already contains the '?'
        //

        hr = pstrRedirect->Append(
                 _pUlHttpRequest->CookedUrl.pQueryString,
                 _pUlHttpRequest->CookedUrl.QueryStringLength / sizeof(WCHAR));
        if ( FAILED( hr ) )
        {
            return hr;
        }
    }

    return S_OK;
}

HRESULT
W3_REQUEST::BuildFullUrl(
    STRA&               strPath,
    STRA *              pstrRedirect,
    BOOL                fIncludeParameters
)
/*++

Routine Description:

    Create a new URL while maintaining host/port/protocol/query-string of
    original request

Arguments:

    strPath - New path portion of URL
    pstrRedirect - String filled with new full URL
    fIncludeParameters - TRUE if original query string should be copied too

Return Value:

    HRESULT

--*/
{
    HRESULT         hr              = NO_ERROR;
    LPWSTR          pszColon        = NULL;
    LPWSTR          pszRightBracket = NULL;

    if ( pstrRedirect == NULL )
    {
        DBG_ASSERT( FALSE );
        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    } 

    hr = pstrRedirect->Copy( IsSecureRequest() ? "https://" : "http://" );
    if ( FAILED( hr ) )
    {
        return hr;
    }

    USHORT cchHost;
    LPCSTR pszHost = GetHeader( HttpHeaderHost, &cchHost );
    if ( pszHost != NULL )
    {
        hr = pstrRedirect->Append( pszHost, cchHost );
    }
    else
    {
        if( _pUlHttpRequest->CookedUrl.pHost[0] == L'[' )
        {
            pszRightBracket = wcschr( _pUlHttpRequest->CookedUrl.pHost, L']' );
            if( pszRightBracket != NULL )
            {
                pszColon = pszRightBracket + 1;
                if( *pszColon != L':' )
                {
                    pszColon = NULL;
                }
            }
            else
            {
                hr = E_FAIL;
            }
        }
        else
        {
            pszColon = wcschr( _pUlHttpRequest->CookedUrl.pHost, L':' );
        }

        if ((pszColon != NULL) &&
            ((IsSecureRequest() && _wtoi(pszColon + 1) == DEFAULT_PORT_SECURE) ||
             (!IsSecureRequest() && _wtoi(pszColon + 1) == DEFAULT_PORT)))
        {
            hr = pstrRedirect->AppendW( _pUlHttpRequest->CookedUrl.pHost,
                                        (DWORD)DIFF(pszColon - _pUlHttpRequest->CookedUrl.pHost) );
        }
        else
        {
            hr = pstrRedirect->AppendW( _pUlHttpRequest->CookedUrl.pHost,
                                        _pUlHttpRequest->CookedUrl.HostLength / sizeof( WCHAR ) );
        }
    }

    if ( FAILED( hr ) )
    {
        return hr;
    }

    hr = pstrRedirect->Append( strPath );
    if ( FAILED( hr ) )
    {
        return hr;
    }

    if ( fIncludeParameters &&
         _pUlHttpRequest->CookedUrl.pQueryString != NULL )
    {
        //
        // UL_HTTP_REQUEST::QueryString already contains the '?'
        //

        hr = pstrRedirect->AppendW(
                 _pUlHttpRequest->CookedUrl.pQueryString,
                 _pUlHttpRequest->CookedUrl.QueryStringLength / sizeof(WCHAR));
        if ( FAILED( hr ) )
        {
            return hr;
        }
    }

    return S_OK;
}

CHAR *
W3_REQUEST::GetHeader(
    CHAR *         pszHeaderName
) 
/*++

Routine Description:

    Get a request header and copy it into supplied buffer

Arguments:

    pszHeaderName - Name of header to get

Return Value:

    WCHAR pointer pointed to the header, NULL if no such header 

--*/
{
    ULONG                       ulHeaderIndex = UNKNOWN_INDEX;
    HTTP_REQUEST_HEADERS    *   pHeaders = &(_pUlHttpRequest->Headers);

    DBG_ASSERT( pszHeaderName != NULL );

    //
    // First check whether this header is a known header
    //

    ulHeaderIndex = REQUEST_HEADER_HASH::GetIndex( pszHeaderName );
    if ( ulHeaderIndex == UNKNOWN_INDEX )
    {
        //
        // Need to iterate thru unknown headers
        //

        for ( DWORD i = 0; 
              i < pHeaders->UnknownHeaderCount;
              i++ )
        {
            if ( _stricmp( pszHeaderName,
                           pHeaders->pUnknownHeaders[ i ].pName ) == 0 )
            {
                return (LPSTR) pHeaders->pUnknownHeaders[ i ].pRawValue;
            }
        }

        return NULL;
    }
    else
    {   
        //
        // Known header
        //
    
        DBG_ASSERT( ulHeaderIndex < HttpHeaderRequestMaximum );
        
        return (LPSTR) pHeaders->KnownHeaders[ ulHeaderIndex ].pRawValue; 
    }
}

HRESULT
W3_REQUEST::GetHeader(
    CHAR *              pszHeaderName,
    DWORD               cchHeaderName,
    STRA *              pstrHeaderValue,
    BOOL                fIsUnknownHeader
)
/*++

Routine Description:

    Get a request header and copy it into supplied buffer

Arguments:

    pszHeaderName - Header name
    cchHeaderName - Length of header name
    pstrHeaderValue - Filled with header value
    fIsUnknownHeader - (optional) set to TRUE if header is unknown 
                 and we can avoid doing header hash lookup

Return Value:

    HRESULT

--*/
{
    ULONG                       ulHeaderIndex = UNKNOWN_INDEX;
    HTTP_REQUEST_HEADERS *      pHeaders = &(_pUlHttpRequest->Headers);
    HRESULT                     hr = HRESULT_FROM_WIN32( ERROR_INVALID_INDEX );
    
    if ( pszHeaderName == NULL )
    {
        DBG_ASSERT( FALSE );
        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }
    
    //
    // First check whether this header is a known header
    //
    
    if ( !fIsUnknownHeader )
    {
        ulHeaderIndex = REQUEST_HEADER_HASH::GetIndex( pszHeaderName );
    }
    
    if ( ulHeaderIndex == UNKNOWN_INDEX )
    {
        //
        // Need to iterate thru unknown headers
        //
        
        for ( DWORD i = 0; 
              i < pHeaders->UnknownHeaderCount;
              i++ )
        {
            if ( cchHeaderName == pHeaders->pUnknownHeaders[ i ].NameLength &&
                 _stricmp( pszHeaderName,
                           pHeaders->pUnknownHeaders[ i ].pName ) == 0 )
            {
                hr = pstrHeaderValue->Copy( 
                       pHeaders->pUnknownHeaders[ i ].pRawValue, 
                       pHeaders->pUnknownHeaders[ i ].RawValueLength );
                break;
            }
        }
    }
    else
    {   
        //
        // Known header
        //
    
        DBG_ASSERT( ulHeaderIndex < HttpHeaderRequestMaximum );
        
        if ( pHeaders->KnownHeaders[ ulHeaderIndex ].pRawValue != NULL )
        {
            hr = pstrHeaderValue->Copy(
                   pHeaders->KnownHeaders[ ulHeaderIndex ].pRawValue,
                   pHeaders->KnownHeaders[ ulHeaderIndex ].RawValueLength);
        }
        else
        {
            hr = HRESULT_FROM_WIN32( ERROR_INVALID_INDEX );
        }
    }
    
    return hr;
}

HRESULT
W3_REQUEST::DeleteHeader(
    CHAR *             pszHeaderName
)
/*++

Routine Description:
    
    Delete a request header

Arguments:

    pszHeaderName - Header to delete
    
Return Value:

    HRESULT

--*/
{
    ULONG                   ulHeaderIndex;
    HTTP_UNKNOWN_HEADER   * pUnknownHeader;
    
    //
    // Is this a known header?  If so, we can just set by reference now
    // since we have copied the header value
    // 

    ulHeaderIndex = REQUEST_HEADER_HASH::GetIndex( pszHeaderName );
    if ( ulHeaderIndex != UNKNOWN_INDEX && 
         ulHeaderIndex < HttpHeaderMaximum )
    {
       _pUlHttpRequest->Headers.KnownHeaders[ ulHeaderIndex ].pRawValue = NULL;
       _pUlHttpRequest->Headers.KnownHeaders[ ulHeaderIndex ].RawValueLength = 0;
    }
    else
    {
        //
        // Unknown header.  First check if it exists
        //
            
        for ( DWORD i = 0;
              i < _pUlHttpRequest->Headers.UnknownHeaderCount;
              i++ )
        {
            pUnknownHeader = &(_pUlHttpRequest->Headers.pUnknownHeaders[ i ]);
            DBG_ASSERT( pUnknownHeader != NULL );
            
            if ( _stricmp( pUnknownHeader->pName, pszHeaderName ) == 0 )
            {
                break;
            }
        }
        
        if ( i < _pUlHttpRequest->Headers.UnknownHeaderCount )
        {
            //
            // Now shrink the array to remove the header
            //
        
            memmove( _pUlHttpRequest->Headers.pUnknownHeaders + i,
                     _pUlHttpRequest->Headers.pUnknownHeaders + i + 1,
                     ( _pUlHttpRequest->Headers.UnknownHeaderCount - i - 1 ) * 
                     sizeof( HTTP_UNKNOWN_HEADER ) );
        
            _pUlHttpRequest->Headers.UnknownHeaderCount--;
        }
    }
    
    return NO_ERROR;
}

HRESULT
W3_REQUEST::DeleteKnownHeader(
    ULONG           ulHeaderIndex
)
/*++

Routine Description:
    
    Delete a request header

Arguments:

    pszHeaderName - Header to delete
    
Return Value:

    HRESULT

--*/
{
    if ( ulHeaderIndex != UNKNOWN_INDEX && 
         ulHeaderIndex < HttpHeaderMaximum )
    {
       _pUlHttpRequest->Headers.KnownHeaders[ ulHeaderIndex ].pRawValue = NULL;
       _pUlHttpRequest->Headers.KnownHeaders[ ulHeaderIndex ].RawValueLength = 0;
    }

    return NO_ERROR;
}
    
HRESULT
W3_REQUEST::SetHeader(
    STRA &                  strHeaderName,
    STRA &                  strHeaderValue,
    BOOL                    fAppend
)
/*++

Routine Description:

    Set a request header

Arguments:

    strHeaderName - Name of header to set
    strHeaderValue - New header value to set
    fAppend - If TRUE, the existing header value is appended to, else it is
              replaced

Return Value:

    HRESULT

--*/
{
    CHAR *                  pszNewName = NULL;
    CHAR *                  pszNewValue = NULL;
    STACK_STRA(             strOldHeaderValue, 256 );
    STRA *                  pstrNewHeaderValue = NULL;
    HRESULT                 hr;
    ULONG                   index;

    //
    // If we're appending, then get the old header value (if any) and 
    // append the new value (with a comma delimiter)
    //

    if ( fAppend )
    {
        hr = GetHeader( strHeaderName, &strOldHeaderValue );
        if ( FAILED( hr ) )
        {
            pstrNewHeaderValue = &strHeaderValue;
            hr = NO_ERROR;
        }
        else 
        {
            hr = strOldHeaderValue.Append( ",", 1 );
            if ( FAILED( hr ) )
            {
                return hr;
            }
            
            hr = strOldHeaderValue.Append( strHeaderValue );
            if ( FAILED( hr ) )
            {
                return hr;
            }

            pstrNewHeaderValue = &strOldHeaderValue;
        }
    }
    else
    {
        pstrNewHeaderValue = &strHeaderValue;
    }
    
    DBG_ASSERT( pstrNewHeaderValue != NULL );

    //
    // pstrNewHeaderValue will point to either "old,new" or "new"
    //
    
    hr = _HeaderBuffer.AllocateSpace( pstrNewHeaderValue->QueryStr(),
                                      pstrNewHeaderValue->QueryCCH(),
                                      &pszNewValue );
    if ( FAILED( hr ) )
    {
        return hr;
    }
    
    //
    // Is this a known header?
    //
    
    index = REQUEST_HEADER_HASH::GetIndex( strHeaderName.QueryStr() );
    if ( index == UNKNOWN_INDEX )
    {
        hr = _HeaderBuffer.AllocateSpace( strHeaderName.QueryStr(),
                                          strHeaderName.QueryCCH(),
                                          &pszNewName );
        if ( FAILED( hr ) )
        {
            return hr;
        }
        
        //
        // Find the header in the unknown list
        // 
        
        for ( DWORD i = 0;
              i < _pUlHttpRequest->Headers.UnknownHeaderCount;
              i++ )
        {
            if ( _strnicmp( strHeaderName.QueryStr(),
                            _pUlHttpRequest->Headers.pUnknownHeaders[ i ].pName,
                            strHeaderName.QueryCCH() ) == 0 )
            {
                break;
            }
        }
        
        //
        // If we found the unknown header, then this is much simpler
        //
        
        if ( i < _pUlHttpRequest->Headers.UnknownHeaderCount )
        {
            _pUlHttpRequest->Headers.pUnknownHeaders[i].pRawValue = 
                                    pszNewValue;
            _pUlHttpRequest->Headers.pUnknownHeaders[i].RawValueLength = 
                                    (USHORT) pstrNewHeaderValue->QueryCB();
        }
        else
        {
            HTTP_UNKNOWN_HEADER *pUnknownHeaders;
            DWORD                cCount;

            //
            // Fun.  Need to add a new unknown header
            //

            cCount = _pUlHttpRequest->Headers.UnknownHeaderCount;

            //
            // BUGBUG: are we leaking this memory?
            //
            pUnknownHeaders = (HTTP_UNKNOWN_HEADER *) LocalAlloc( 
                                    LPTR,
                                    sizeof( HTTP_UNKNOWN_HEADER ) * 
                                    ( cCount+1 ) );
            if ( pUnknownHeaders == NULL )
            {
                return HRESULT_FROM_WIN32( GetLastError() );
            }
            
            memcpy( pUnknownHeaders,
                    _pUlHttpRequest->Headers.pUnknownHeaders,
                    sizeof( HTTP_UNKNOWN_HEADER ) * (cCount) );
           
            pUnknownHeaders[ cCount ].pName = pszNewName;
            pUnknownHeaders[ cCount ].NameLength = (USHORT)strHeaderName.QueryCB();

            pUnknownHeaders[ cCount ].pRawValue = pszNewValue;
            pUnknownHeaders[ cCount ].RawValueLength = (USHORT) pstrNewHeaderValue->QueryCB();

            //
            // Patch in the new array
            //
            
            if ( _pExtraUnknown != NULL )
            {
                LocalFree( _pExtraUnknown );
            }
            
            _pExtraUnknown = pUnknownHeaders;
            _pUlHttpRequest->Headers.pUnknownHeaders = pUnknownHeaders;
            _pUlHttpRequest->Headers.UnknownHeaderCount++;
        }
    }
    else
    {
        //
        // The easy case.  Known header
        //
        
        _pUlHttpRequest->Headers.KnownHeaders[ index ].pRawValue = pszNewValue;
        _pUlHttpRequest->Headers.KnownHeaders[ index ].RawValueLength = (USHORT) pstrNewHeaderValue->QueryCB();
    }
    
    return S_OK;
}

HRESULT
W3_REQUEST::SetKnownHeader(
    ULONG                   ulHeaderIndex,
    STRA &                  strHeaderValue,
    BOOL                    fAppend
)
/*++

Routine Description:

    Set a request header

Arguments:

    ulHeaderIndex - Name index of the header to set
    strHeaderValue - New header value to set
    fAppend - If TRUE, the existing header value is appended to, else it is
              replaced

Return Value:

    HRESULT

--*/
{
    CHAR *                  pszNewValue = NULL;
    STACK_STRA(             strOldHeaderValue, 256 );
    STRA *                  pstrNewHeaderValue = NULL;
    HRESULT                 hr;

    //
    // If we're appending, then get the old header value (if any) and 
    // append the new value (with a comma delimiter)
    //

    if ( fAppend )
    {
        hr = strOldHeaderValue.Copy( GetHeader( ulHeaderIndex ) );
        if ( FAILED( hr ) )
        {
            pstrNewHeaderValue = &strHeaderValue;
            hr = NO_ERROR;
        }
        else 
        {
            hr = strOldHeaderValue.Append( ",", 1 );
            if ( FAILED( hr ) )
            {
                return hr;
            }
            
            hr = strOldHeaderValue.Append( strHeaderValue );
            if ( FAILED( hr ) )
            {
                return hr;
            }

            pstrNewHeaderValue = &strOldHeaderValue;
        }
    }
    else
    {
        pstrNewHeaderValue = &strHeaderValue;
    }
    
    DBG_ASSERT( pstrNewHeaderValue != NULL );

    //
    // pstrNewHeaderValue will point to either "old,new" or "new"
    //
    
    hr = _HeaderBuffer.AllocateSpace( pstrNewHeaderValue->QueryStr(),
                                      pstrNewHeaderValue->QueryCCH(),
                                      &pszNewValue );
    if ( FAILED( hr ) )
    {
        return hr;
    }

    //
    // Set the new value
    //

    if ( ulHeaderIndex != UNKNOWN_INDEX &&
         ulHeaderIndex < HttpHeaderRequestMaximum )
    {
        _pUlHttpRequest->Headers.KnownHeaders[ ulHeaderIndex ].pRawValue = pszNewValue;
        _pUlHttpRequest->Headers.KnownHeaders[ ulHeaderIndex ].RawValueLength = (USHORT) pstrNewHeaderValue->QueryCB();
    }

    return S_OK;
}

HRESULT
W3_REQUEST::GetVersionString(
    STRA *              pstrVersion
)
/*++

Routine Description:

    Get version string of request (like "HTTP/1.1")

Arguments:

    pstrVersion - Filled in with version

Return Value:

    HRESULT

--*/
{
    HRESULT hr;
    CHAR   pszMajorVersion[6];
    CHAR   pszMinorVersion[6];

    _itoa(_pUlHttpRequest->Version.MajorVersion, pszMajorVersion, 10);
    _itoa(_pUlHttpRequest->Version.MinorVersion, pszMinorVersion, 10);

    if (FAILED(hr = pstrVersion->Copy("HTTP/", 5)) ||
        FAILED(hr = pstrVersion->Append(pszMajorVersion)) ||
        FAILED(hr = pstrVersion->Append(".", 1)) ||
        FAILED(hr = pstrVersion->Append(pszMinorVersion)))
    {
        return hr;
    }

    return S_OK;
}

HRESULT
W3_REQUEST::GetVerbString(
    STRA *              pstrVerb
)
/*++

Routine Description:

    Get the HTTP verb from the request

Arguments:

    pstrVerb - Filled in with verb

Return Value:

    HRESULT

--*/
{
    USHORT cchVerb;
    CHAR *pszVerb = METHOD_HASH::GetString(_pUlHttpRequest->Verb, &cchVerb);
    if (pszVerb != NULL)
    {
        return pstrVerb->Copy(pszVerb, cchVerb);
    }
    else
    {
        return pstrVerb->Copy(_pUlHttpRequest->pUnknownVerb,
                              _pUlHttpRequest->UnknownVerbLength);
    }
}

VOID
W3_REQUEST::QueryVerb(
    CHAR  **ppszVerb,
    USHORT *pcchVerb)
/*++
    Get the HTTP verb from the request
--*/
{
    *ppszVerb = METHOD_HASH::GetString(_pUlHttpRequest->Verb, pcchVerb);
    if (*ppszVerb == NULL)
    {
        *ppszVerb = (CHAR*) _pUlHttpRequest->pUnknownVerb;
        *pcchVerb = _pUlHttpRequest->UnknownVerbLength;
    }
}

HRESULT
W3_REQUEST::SetVerb(
    STRA &              strVerb
)
/*++

Routine Description:

    Change the request verb (done in PREPROC_HEADER ISAPI filters)

Arguments:

    strVerb - New verb

Return Value:

    HRESULT

--*/
{
    HRESULT hr;
    CHAR *pszNewVerb;

    HTTP_VERB Verb = (HTTP_VERB)METHOD_HASH::GetIndex(strVerb.QueryStr());
    _pUlHttpRequest->Verb = Verb;
    
    if ( Verb == HttpVerbUnknown )
    {
        //
        // Handle unknown verbs
        //

        hr = _HeaderBuffer.AllocateSpace( strVerb.QueryStr(),
                                          strVerb.QueryCCH(),
                                          &pszNewVerb );
        if ( FAILED( hr ) )
        {
            return hr;
        }
        
        _pUlHttpRequest->pUnknownVerb = pszNewVerb;
        _pUlHttpRequest->UnknownVerbLength = (USHORT) strVerb.QueryCCH();
    }
    else
    {
        _pUlHttpRequest->pUnknownVerb = NULL;
        _pUlHttpRequest->UnknownVerbLength = 0;
    }
    
    return S_OK;
}

HRESULT
W3_REQUEST::SetVersion(
    STRA&               strVersion
)
/*++

Routine Description:

    strVersion - Set the request version (done by PREPROC_HEADER filters)

Arguments:

    strVersion - Version string

Return Value:

    HRESULT

--*/
{
    HRESULT         hr = S_OK;
    
    //
    // BUGBUG: Probably not the fastest way to do this
    //
    
    if ( strcmp( strVersion.QueryStr(), "HTTP/1.1" ) == 0 )
    {
        _pUlHttpRequest->Version.MajorVersion = 1;
        _pUlHttpRequest->Version.MinorVersion = 1;
    }
    else if ( strcmp( strVersion.QueryStr(), "HTTP/1.0" ) == 0 )
    {
        _pUlHttpRequest->Version.MajorVersion = 1;
        _pUlHttpRequest->Version.MinorVersion = 0;
    }
    else if ( strcmp( strVersion.QueryStr(), "HTTP/0.9" ) == 0 )
    {
        _pUlHttpRequest->Version.MajorVersion = 0;
        _pUlHttpRequest->Version.MinorVersion = 9;
    }
    else
    {
        hr = HRESULT_FROM_WIN32( ERROR_NOT_SUPPORTED );
    }
    
    return hr;
}        

HRESULT
W3_REQUEST::SetNewPreloadedEntityBody(
    VOID *              pvBuffer,
    DWORD               cbBuffer
)
/*++

Routine Description:

    Change the preloaded entity body for this request

Arguments:

    pvBuffer - the buffer
    cbBuffer - the size of the buffer

Return Value:

    HRESULT

--*/
{
    _InsertedEntityBodyChunk.DataChunkType = HttpDataChunkFromMemory;
    _InsertedEntityBodyChunk.FromMemory.pBuffer = pvBuffer;
    _InsertedEntityBodyChunk.FromMemory.BufferLength = cbBuffer;
    _pUlHttpRequest->EntityChunkCount = 1;
    _pUlHttpRequest->pEntityChunks = &_InsertedEntityBodyChunk;
    
    return NO_ERROR;
}

HRESULT
W3_REQUEST::AppendEntityBody(
    VOID *            pvBuffer,
    DWORD             cbBuffer
)
/*
  Description
    Add the given entity to (any) entity already present

  Arguments
    pvBuffer - the buffer
    cbBuffer - the size of the buffer

  Return Value
    HRESULT
*/
{
    DWORD cbAlreadyPresent = QueryAvailableBytes();

    if ( cbAlreadyPresent == 0 )
    {
        return SetNewPreloadedEntityBody(pvBuffer, cbBuffer);
    }
    else
    {
        PVOID pbAlreadyPresent = QueryEntityBody();

        if (!_buffEntityBodyPreload.Resize(cbBuffer + cbAlreadyPresent))
        {
            return HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
        }

        memcpy(_buffEntityBodyPreload.QueryPtr(),
               pbAlreadyPresent,
               cbAlreadyPresent);

        memcpy((PBYTE)_buffEntityBodyPreload.QueryPtr() + cbAlreadyPresent,
               pvBuffer,
               cbBuffer);
    }

    return S_OK;
}

HRESULT
W3_REQUEST::SetUrl(
    STRU &              strNewUrl,
    BOOL                fResetQueryString // = TRUE
)
/*++

Routine Description:

    Change the URL of the request

Arguments:

    strNewUrl - New URL
    fResetQueryString - TRUE if we should expect query string in strNewUrl

Return Value:

    HRESULT

--*/
{
    STACK_STRA        ( straUrl, MAX_PATH );
    HRESULT             hr = S_OK;

    DWORD lenToConvert = 0;

    WCHAR * pFirstQuery = wcschr(strNewUrl.QueryStr(), L'?');
    if (NULL == pFirstQuery)
    {
        lenToConvert = strNewUrl.QueryCCH();
    }
    else
    {
        lenToConvert = (DWORD)DIFF(pFirstQuery - strNewUrl.QueryStr());
    }

    if (FAILED(hr = straUrl.CopyWToUTF8(strNewUrl.QueryStr(), lenToConvert)))
    {
        return hr;
    }

    straUrl.AppendW(strNewUrl.QueryStr() + lenToConvert);

    //
    // SetUrlA does the canonicalization, unescaping
    //
    
    return SetUrlA( straUrl, fResetQueryString );
}

HRESULT
W3_REQUEST::SetUrlA(
    STRA &              strNewUrl,
    BOOL                fResetQueryString // = TRUE
)
/*++

Routine Description:

    Change the URL of the request.  Takes in an ANSI URL

Arguments:

    strNewUrl - RAW version of URL which is also stored away
    fResetQueryString - Should we expect query string in strNewUrl

Return Value:

    HRESULT

--*/
{
    HRESULT             hr = NO_ERROR;
    ULONG               cbBytesCopied;
    LPWSTR              pszQueryString;
    CHAR *              pszNewRawUrl;
    LPWSTR              pszNewFullUrl;
    LPWSTR              pszNewAbsPath;
    STACK_STRU        ( strFullUrl, MAX_PATH);
    STACK_STRU        ( strAbsPath, MAX_PATH);

    if (strNewUrl.QueryCCH() > MAXUSHORT)
    {
        return HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);
    }

    //
    // Need to process the URL ourselves.  This means:
    // -Unescaping, canonicalizing, and query-string-ilizing
    //

    //
    // BUGBUG.  Probably need to handle HTTP:// and HTTPS:// preceded URLs
    // so that MS proxy can still work
    //

    hr = _HeaderBuffer.AllocateSpace( strNewUrl.QueryStr(),
                                      strNewUrl.QueryCCH(),
                                      &pszNewRawUrl );
    if ( FAILED( hr ) )
    {
        goto Finished;
    }

    //
    // Need to patch the UL_HTTP_REQUEST raw URL
    //

    _pUlHttpRequest->pRawUrl = pszNewRawUrl;
    _pUlHttpRequest->RawUrlLength = (USHORT) strNewUrl.QueryCCH();

    hr = _HeaderBuffer.AllocateSpace( (strNewUrl.QueryCCH() + 1)*sizeof(WCHAR),
                                      &pszNewAbsPath );
    if ( FAILED( hr ) )
    {
        goto Finished;
    }

    //
    // Call into a UL ripped helper to do the parsing
    //

    hr = UlCleanAndCopyUrl( (PUCHAR)pszNewRawUrl,
                            strNewUrl.QueryCCH(),
                            &cbBytesCopied,
                            pszNewAbsPath,
                            &pszQueryString );
    if ( FAILED( hr ) )
    {
        goto Finished;
    }

    //
    // Need to patch the UL_HTTP_REQUEST AbsPath and QueryString
    //

    _pUlHttpRequest->CookedUrl.pAbsPath = pszNewAbsPath;

    if ( pszQueryString != NULL )
    {
        _pUlHttpRequest->CookedUrl.pQueryString = pszQueryString;
        _pUlHttpRequest->CookedUrl.AbsPathLength = (USHORT)DIFF(pszQueryString - pszNewAbsPath) * sizeof(WCHAR);
        _pUlHttpRequest->CookedUrl.QueryStringLength = (USHORT)(cbBytesCopied - _pUlHttpRequest->CookedUrl.AbsPathLength);
    }
    else
    {
        if ( fResetQueryString )
        {
            _pUlHttpRequest->CookedUrl.pQueryString = NULL;
            _pUlHttpRequest->CookedUrl.QueryStringLength = 0;
        }

        _pUlHttpRequest->CookedUrl.AbsPathLength = (USHORT) cbBytesCopied;
    }

    hr = strAbsPath.Copy(pszNewAbsPath);
    if (FAILED(hr))
    {
        goto Finished;
    }

    //
    // Need to patch up the Full Url.
    //

    BuildFullUrl( strAbsPath, &strFullUrl, FALSE);
    hr = _HeaderBuffer.AllocateSpace( strFullUrl.QueryStr(),
                                      strFullUrl.QueryCCH(),
                                      &pszNewFullUrl );
    if (FAILED(hr))
    {
        goto Finished;
    }

    _pUlHttpRequest->CookedUrl.pFullUrl = pszNewFullUrl;
    _pUlHttpRequest->CookedUrl.FullUrlLength = (USHORT) strFullUrl.QueryCB();

Finished:
    return hr;
}

HRESULT
W3_REQUEST::BuildISAPIHeaderLine(
    LPCSTR          pszHeaderName,
    DWORD           cchHeaderName,
    LPCSTR          pszHeaderValue,
    DWORD           cchHeaderValue,
    STRA *          pstrHeaderLine
)
/*++

Routine Description:

    Private utility to build a header line as such:
    
    pszHeaderName = "this-is-a-header", pszHeaderValue = "foobar"
    
    PRODUCES
    
    "HTTP_THIS_IS_A_HEADER:foobar\n"

Arguments:

    pszHeaderName - Header name
    cchHeaderName - Length of header name
    pszHeaderValue - Header value
    cchHeaderValue - Length of header value
    pstrHeaderLine - Header line is appended

Return Value:

    HRESULT

--*/
{
    HRESULT             hr;
    CHAR *              pszCursor;
    DWORD               currHeaderLength = pstrHeaderLine->QueryCCH();
    
    //
    // Convert header name "a-b-c" into "HTTP_A_B_C"
    //

    hr = pstrHeaderLine->Append( "HTTP_", 5 );
    if ( FAILED( hr ) )
    {
        return hr;
    }

    hr = pstrHeaderLine->Append( pszHeaderName, cchHeaderName );
    if ( FAILED( hr ) )
    {
        return hr;
    }
            
    //
    // Convert - to _
    //
            
    pszCursor = strchr( pstrHeaderLine->QueryStr() + currHeaderLength + 5,
                        '-' );
    while ( pszCursor != NULL )
    {
        *pszCursor++ = '_';
        pszCursor = strchr( pszCursor, L'-' );
    }
            
    //
    // Uppercase it
    //

    _strupr( pstrHeaderLine->QueryStr() + currHeaderLength + 5 );
            
    //
    // Now finish the header line by adding ":<header value>\n"
    //
    // Note that raw HTTP looks like ": <header value>", but earlier
    // versions of IIS did not include the space, and there are
    // legacy ISAPI's that depend on the space after the colon
    // not being there.
    //

    hr = pstrHeaderLine->Append( ":", 1 );
    if ( FAILED( hr ) )
    {
        return hr;
    }

    hr = pstrHeaderLine->Append( pszHeaderValue, cchHeaderValue );
    if ( FAILED( hr ) )
    {
        return hr;
    }

    hr = pstrHeaderLine->Append( "\n", 1 );
    if ( FAILED( hr ) )
    {
        return hr;
    }
    
    return NO_ERROR;
}

HRESULT
W3_REQUEST::BuildRawHeaderLine(
    LPCSTR          pszHeaderName,
    DWORD           cchHeaderName,
    LPCSTR          pszHeaderValue,
    DWORD           cchHeaderValue,
    STRA *          pstrHeaderLine
)
/*++

Routine Description:

    Private utility to build a header line as such:
    
    pszHeaderName = "this-is-a-header", pszHeaderValue = "foobar"
    
    PRODUCES

    this-is-a-header: foobar\r\n

Arguments:

    pszHeaderName - Header name
    cchHeaderName - Length of header name
    pszHeaderValue - Header value
    cchHeaderValue - Length of header value
    pstrHeaderLine - Header line is appended

Return Value:

    HRESULT

--*/
{
    HRESULT             hr;

    hr = pstrHeaderLine->Append( pszHeaderName, cchHeaderName );
    if ( FAILED( hr ) )
    {
        return hr;
    }

    //
    // Now finish the header line by adding ": <header value>\n"
    //

    hr = pstrHeaderLine->Append( ": ", 2 );
    if ( FAILED( hr ) )
    {
        return hr;
    }

    hr = pstrHeaderLine->Append( pszHeaderValue, cchHeaderValue );
    if ( FAILED( hr ) )
    {
        return hr;
    }

    hr = pstrHeaderLine->Append( "\r\n" );
    if ( FAILED( hr ) )
    {
        return hr;
    }

    return NO_ERROR;
}
    
HRESULT
W3_REQUEST::GetAllHeaders(
    STRA *          pstrHeaders,
    BOOL            fISAPIStyle
)
/*++

Routine Description:

    Get all headers in one string, delimited by \r\n

Arguments:

    pstrHeaders - Filled with headers
    fISAPIStyle - 
        If TRUE, format is: HTTP_CONTENT_LENGTH: 245\nHTTP_CONTENT_TYPE: t\n
        If FALSE, format is: CONTENT-LENGTH: 245\r\nCONTENT-TYPE: t\r\n

Return Value:

    HRESULT

--*/
{
    HRESULT                     hr = NO_ERROR;
    DWORD                       cCounter;
    HTTP_KNOWN_HEADER *         pKnownHeader;
    LPCSTR                      pszName;
    DWORD                       cchName;
    HTTP_UNKNOWN_HEADER *       pUnknownHeader; 
    
    if ( pstrHeaders == NULL )
    {
        DBG_ASSERT( FALSE );
        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }
    
    //
    // Copy known headers
    //
    
    for ( cCounter = 0;
          cCounter < HttpHeaderRequestMaximum;
          cCounter++ )
    {
        pKnownHeader = &(_pUlHttpRequest->Headers.KnownHeaders[ cCounter ]);
        if ( pKnownHeader->RawValueLength != 0 )
        {
            pszName = REQUEST_HEADER_HASH::GetString( cCounter, &cchName );
            if ( pszName == NULL )
            {
                DBG_ASSERT( FALSE );
                return HRESULT_FROM_WIN32( ERROR_INVALID_DATA );
            }

            if ( fISAPIStyle )
            {
                hr = BuildISAPIHeaderLine( pszName,
                                           cchName,
                                           pKnownHeader->pRawValue,
                                           pKnownHeader->RawValueLength,
                                           pstrHeaders );
            }
            else
            {
                hr = BuildRawHeaderLine( pszName,
                                         cchName,
                                         pKnownHeader->pRawValue,
                                         pKnownHeader->RawValueLength,
                                         pstrHeaders );
            }
            
            if ( FAILED( hr ) )
            {
                return hr;
            }            
        }
    }
    
    //
    // Copy unknown headers
    //
    
    for ( cCounter = 0;
          cCounter < _pUlHttpRequest->Headers.UnknownHeaderCount;
          cCounter++ )
    {   
        pUnknownHeader = &(_pUlHttpRequest->Headers.pUnknownHeaders[ cCounter ]);
        
        pszName = pUnknownHeader->pName;
        cchName = pUnknownHeader->NameLength;        

        if ( fISAPIStyle )
        {        
            hr = BuildISAPIHeaderLine( pszName,
                                       cchName,
                                       pUnknownHeader->pRawValue,
                                       pUnknownHeader->RawValueLength,
                                       pstrHeaders );
        }
        else
        {
            hr = BuildRawHeaderLine( pszName,
                                     cchName,
                                     pUnknownHeader->pRawValue,
                                     pUnknownHeader->RawValueLength,
                                     pstrHeaders );
        }
        
        if ( FAILED( hr ) )
        {
            return hr;
        }
    }
    
    return NO_ERROR;
}

HRESULT
W3_REQUEST::CloneRequest(
    DWORD               dwCloneFlags,
    W3_REQUEST **       ppRequest
)
/*++

Routine Description:

    Clone request.  Used to setup a child request to execute

Arguments:

    dwCloneFlags - Flags controlling how much of the current request to clone.
                   Without any flag, we will copy only the bare minimum

                   W3_REQUEST_CLONE_BASICS - clone URL/querystring/Verb
                   W3_REQUEST_CLONE_HEADERS - clone request headers
                   W3_REQUEST_CLONE_ENTITY - clone the entity body
                   W3_REQUEST_CLONE_NO_PRECONDITION - remove range/if-*
                   W3_REQUEST_CLONE_NO_DAV - remove DAV requests

    ppRequest - Set to point to a new W3_REQUEST on success

Return Value:

    HRESULT

--*/
{
    W3_CLONE_REQUEST *          pCloneRequest = NULL;
    HRESULT                     hr = NO_ERROR;
    
    if ( ppRequest == NULL )
    {
        DBG_ASSERT( FALSE );
        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }
    *ppRequest = NULL;
    
    //
    // Allocate a new cloned request
    //
    
    pCloneRequest = new W3_CLONE_REQUEST();
    if ( pCloneRequest == NULL )
    {   
        hr = HRESULT_FROM_WIN32( GetLastError() );
        goto Finished;
    }
    
    //
    // Copy the bare minimum
    //
    
    hr = pCloneRequest->CopyMinimum( _pUlHttpRequest );
    if ( FAILED( hr ) )
    {
        goto Finished;
    }
    
    //
    // Should we copy the request basics (URL/querystring/Verb)?
    //
    
    if ( dwCloneFlags & W3_REQUEST_CLONE_BASICS )
    {
        hr = pCloneRequest->CopyBasics( _pUlHttpRequest );
    }
    else
    {
        hr = pCloneRequest->CopyBasics( NULL );
    }
    if ( FAILED( hr ) )
    {
        goto Finished;
    }
    
    //
    // Should we copy the headers?
    //
    
    if ( dwCloneFlags & W3_REQUEST_CLONE_HEADERS )
    {
        hr = pCloneRequest->CopyHeaders( _pUlHttpRequest );
    }
    else
    {
        hr = pCloneRequest->CopyHeaders( NULL );
    }

    if ( FAILED( hr ) )
    {
        goto Finished;
    }
    
    //
    // Should we also reference the parent's entity body
    //
    
    if ( dwCloneFlags & W3_REQUEST_CLONE_ENTITY )
    {
        hr = pCloneRequest->CopyEntity( _pUlHttpRequest );
    }
    else
    {
        hr = pCloneRequest->CopyEntity( NULL );
    }
    if ( FAILED( hr ) )
    {
        goto Finished;
    }
    
    //
    // Remove conditionals if requested
    //
    
    if ( dwCloneFlags & W3_REQUEST_CLONE_NO_PRECONDITION )
    {
        pCloneRequest->RemoveConditionals();
    }
    
    //
    // Remove DAV'ness if requested
    //
    
    if ( dwCloneFlags & W3_REQUEST_CLONE_NO_DAV  )
    {
        pCloneRequest->RemoveDav();
    }
    
    *ppRequest = pCloneRequest;
    
Finished:
    if ( FAILED( hr ) )
    {
        if ( pCloneRequest != NULL )
        {
            delete pCloneRequest;
            pCloneRequest = NULL;
        }
    }
    
    return hr;
}
  
//static
HRESULT
W3_REQUEST::Initialize(
    VOID
)
/*++

Routine Description:

    Global initalization for utilities used by W3_REQUEST object

Arguments:

    None

Return Value:

    HRESULT

--*/
{
    CHAR                achName[ MAX_PATH + 1 ];
    INT                 err;
    HRESULT             hr;
    ADDRINFO            Hints;
    
    //
    // Get the host name for use in remote/local determination
    //
    
    err = gethostname( achName, sizeof( achName ) );
    if ( err != 0 )
    {
        hr = HRESULT_FROM_WIN32( WSAGetLastError() );
        DBGPRINTF(( DBG_CONTEXT,
                    "Error getting host name.  hr = %x\n",
                    hr ));
        return hr;
    }
    
    memset( &Hints, 0, sizeof( Hints ) );
    Hints.ai_family = PF_UNSPEC;
    Hints.ai_flags = AI_CANONNAME;

    err = getaddrinfo( achName,
                       NULL,
                       &Hints,
                       &sm_pHostAddrInfo );
    if( err != 0 && err != WSAHOST_NOT_FOUND )
    {
        hr = HRESULT_FROM_WIN32( WSAGetLastError() );
        DBGPRINTF(( DBG_CONTEXT,
                    "Error getting host adress info.  hr = %x\n",
                    hr ));
        return hr;
    }

    hr = REQUEST_HEADER_HASH::Initialize();
    if ( FAILED( hr ) )
    {
        return hr;
    }
    
    hr = METHOD_HASH::Initialize();
    if ( FAILED( hr ) )
    {
        return hr;
    }
    
    hr = W3_CLONE_REQUEST::Initialize();
    if ( FAILED( hr ) )
    {
        REQUEST_HEADER_HASH::Terminate();
        return hr;
    }
    
    return NO_ERROR;
}

//static
VOID
W3_REQUEST::Terminate(
    VOID
)
{
    if( sm_pHostAddrInfo != NULL )
    {
        freeaddrinfo( sm_pHostAddrInfo );
        sm_pHostAddrInfo = NULL;
    }
    
    W3_CLONE_REQUEST::Terminate();
    
    REQUEST_HEADER_HASH::Terminate();

    METHOD_HASH::Terminate();
}

HRESULT
W3_CLONE_REQUEST::CopyEntity(
    HTTP_REQUEST *       pRequestToClone
)
/*++

Routine Description:

    Reference the parents entity body if required

Arguments:

    pRequestToClone - UL_HTTP_REQUEST to clone.  NULL if we shouldn't clone

Return Value:

    HRESULT

--*/
{
    if ( pRequestToClone == NULL )
    {
        _ulHttpRequest.Flags = 0;
        _ulHttpRequest.EntityChunkCount = 0;
        _ulHttpRequest.pEntityChunks = NULL;
    }
    else
    {
        _ulHttpRequest.Flags
           = pRequestToClone->Flags & HTTP_REQUEST_FLAG_MORE_ENTITY_BODY_EXISTS;
        _ulHttpRequest.EntityChunkCount = pRequestToClone->EntityChunkCount;
        _ulHttpRequest.pEntityChunks = pRequestToClone->pEntityChunks;
    }
    
    return S_OK;
}

HRESULT
W3_CLONE_REQUEST::CopyBasics(
    HTTP_REQUEST *           pRequestToClone
)
/*++

Routine Description:

    Copy the URL/query-string/Verb if required

Arguments:

    pRequestToClone - HTTP_REQUEST to clone.  NULL if we shouldn't clone

Return Value:

    HRESULT

--*/
{
    if ( pRequestToClone == NULL )
    {
        _ulHttpRequest.Verb = HttpVerbUnparsed;

        _ulHttpRequest.UnknownVerbLength = 0;
        _ulHttpRequest.pUnknownVerb = NULL;
        
        _ulHttpRequest.RawUrlLength = 0;
        _ulHttpRequest.pRawUrl = NULL;
        
        _ulHttpRequest.CookedUrl.FullUrlLength = 0;
        _ulHttpRequest.CookedUrl.pFullUrl = NULL;
        
        _ulHttpRequest.CookedUrl.HostLength = 0;
        _ulHttpRequest.CookedUrl.pHost = NULL;
        
        _ulHttpRequest.CookedUrl.AbsPathLength = 0;
        _ulHttpRequest.CookedUrl.pAbsPath = NULL;
        
        _ulHttpRequest.CookedUrl.QueryStringLength = 0;
        _ulHttpRequest.CookedUrl.pQueryString = NULL;
    }
    else
    {
        _ulHttpRequest.Verb = pRequestToClone->Verb;

        _ulHttpRequest.UnknownVerbLength = pRequestToClone->UnknownVerbLength;
        _ulHttpRequest.pUnknownVerb = pRequestToClone->pUnknownVerb;
        
        _ulHttpRequest.RawUrlLength = pRequestToClone->RawUrlLength;
        _ulHttpRequest.pRawUrl = pRequestToClone->pRawUrl;
        
        _ulHttpRequest.CookedUrl.FullUrlLength = pRequestToClone->CookedUrl.FullUrlLength;
        _ulHttpRequest.CookedUrl.pFullUrl = pRequestToClone->CookedUrl.pFullUrl;
        
        _ulHttpRequest.CookedUrl.HostLength = pRequestToClone->CookedUrl.HostLength;
        _ulHttpRequest.CookedUrl.pHost = pRequestToClone->CookedUrl.pHost;
        
        _ulHttpRequest.CookedUrl.AbsPathLength = pRequestToClone->CookedUrl.AbsPathLength;
        _ulHttpRequest.CookedUrl.pAbsPath = pRequestToClone->CookedUrl.pAbsPath;
        
        _ulHttpRequest.CookedUrl.QueryStringLength = pRequestToClone->CookedUrl.QueryStringLength;
        _ulHttpRequest.CookedUrl.pQueryString = pRequestToClone->CookedUrl.pQueryString;
    }
    
    return S_OK;
}

HRESULT
W3_CLONE_REQUEST::CopyMinimum(
    HTTP_REQUEST *           pRequestToClone
)
/*++

Routine Description:

    Copies the bare minimum from the clonee.  Bare minimums includes
    remote/local port/address, version, etc.

Arguments:

    pRequestToClone - UL_HTTP_REQUEST to clone

Return Value:

    HRESULT

--*/
{
    if ( pRequestToClone == NULL )
    {
        DBG_ASSERT( FALSE );
        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }
    
    //
    // Miscellaneous UL goo
    //
    
    _ulHttpRequest.ConnectionId = pRequestToClone->ConnectionId;
    _ulHttpRequest.RequestId = pRequestToClone->RequestId;
    _ulHttpRequest.UrlContext = pRequestToClone->UrlContext;
    _ulHttpRequest.Version = pRequestToClone->Version;

    //
    // Local/Remote address
    //
    
    _ulHttpRequest.Address.pRemoteAddress = pRequestToClone->Address.pRemoteAddress;
    _ulHttpRequest.Address.pLocalAddress = pRequestToClone->Address.pLocalAddress;

    //
    // Other stuff
    // 
    
    _ulHttpRequest.RawConnectionId = pRequestToClone->RawConnectionId;
    _ulHttpRequest.pSslInfo = pRequestToClone->pSslInfo;

    return NO_ERROR;
}

HRESULT
W3_CLONE_REQUEST::CopyHeaders(
    HTTP_REQUEST *       pRequestToClone
)
/*++

Routine Description:
    
    Copies request headers from pRequestToClone into the current cloned
    request

Arguments:

    pRequestToClone - HTTP_REQUEST to clone, NULL if there should be no
                      headers

Return Value:

    HRESULT

--*/
{
    USHORT                  cUnknownHeaders;

    if ( pRequestToClone == NULL )
    {
        //
        // No headers.  
        //

        ZeroMemory( &( _ulHttpRequest.Headers ),
                    sizeof( _ulHttpRequest.Headers ) );
    }
    else
    {
        //
        // Copy all the headers
        //
        
        //
        // Start with the known headers.  Note that we can just copy 
        // the Headers member directly.  The memory being referenced by
        // the pointers are guaranteed to be around for the life of this
        // request.  (the memory is either off the UL_NATIVE_REQUEST or
        // it is off a CHUNK_BUFFER from the main parent request)
        //

        memcpy( _ulHttpRequest.Headers.KnownHeaders,
                pRequestToClone->Headers.KnownHeaders,
                sizeof( _ulHttpRequest.Headers.KnownHeaders ) );

        //
        // Copy the unknown headers.  For this case, we will have to 
        // allocate our own buffer since the unknown header array can be 
        // resized.  But as before, the memory referenced by the 
        // unknown headers is OK to reference again.  
        //

        cUnknownHeaders = pRequestToClone->Headers.UnknownHeaderCount;

        if ( cUnknownHeaders > 0 )
        {   
            _pExtraUnknown = (HTTP_UNKNOWN_HEADER*) LocalAlloc( 
                                            LPTR,
                                            sizeof( HTTP_UNKNOWN_HEADER)*
                                            cUnknownHeaders );
            if ( _pExtraUnknown == NULL )
            {   
                return HRESULT_FROM_WIN32( GetLastError() );
            }
            
            memcpy( _pExtraUnknown,
                    pRequestToClone->Headers.pUnknownHeaders,
                    cUnknownHeaders * sizeof( HTTP_UNKNOWN_HEADER ) );
        }
            
        _ulHttpRequest.Headers.UnknownHeaderCount = cUnknownHeaders;
        _ulHttpRequest.Headers.pUnknownHeaders = _pExtraUnknown;
    }
    
    return NO_ERROR;
}

VOID
W3_CLONE_REQUEST::RemoveConditionals(
    VOID
)
/*++

Routine Description:

    Remove conditional/range headers from request.  Used to allow a custom
    error URL to work correctly

Arguments:

    None

Return Value:

    None

--*/
{
    HTTP_REQUEST_HEADERS *   pHeaders;

    pHeaders = &(_pUlHttpRequest->Headers);

    //
    // Remove Range:
    //

    pHeaders->KnownHeaders[ HttpHeaderRange ].pRawValue = NULL;
    pHeaders->KnownHeaders[ HttpHeaderRange ].RawValueLength = 0;

    //
    // Remove If-Modified-Since:
    //

    pHeaders->KnownHeaders[ HttpHeaderIfModifiedSince ].pRawValue = NULL;
    pHeaders->KnownHeaders[ HttpHeaderIfModifiedSince ].RawValueLength = 0;

    //
    // Remove If-Match:
    //

    pHeaders->KnownHeaders[ HttpHeaderIfMatch ].pRawValue = NULL;
    pHeaders->KnownHeaders[ HttpHeaderIfMatch ].RawValueLength = 0;

    //
    // Remove If-Unmodifed-Since:
    //

    pHeaders->KnownHeaders[ HttpHeaderIfUnmodifiedSince ].pRawValue = NULL;
    pHeaders->KnownHeaders[ HttpHeaderIfUnmodifiedSince ].RawValueLength = 0;

    //
    // Remove If-Range:
    //

    pHeaders->KnownHeaders[ HttpHeaderIfRange ].pRawValue = NULL;
    pHeaders->KnownHeaders[ HttpHeaderIfRange ].RawValueLength = 0;

    //
    // Remove If-None-Match:
    //

    pHeaders->KnownHeaders[ HttpHeaderIfNoneMatch ].pRawValue = NULL;
    pHeaders->KnownHeaders[ HttpHeaderIfNoneMatch ].RawValueLength = 0;
}

//static
HRESULT
W3_CLONE_REQUEST::Initialize(
    VOID
)
/*++

Routine Description:

    Initialize clone request lookaside

Arguments:

    None

Return Value:

    HRESULT

--*/
{
    ALLOC_CACHE_CONFIGURATION       acConfig;
    
    DBG_ASSERT( sm_pachCloneRequests == NULL );

    //
    // Setup allocation lookaside
    //
    
    acConfig.nConcurrency = 1;
    acConfig.nThreshold = 100;
    acConfig.cbSize = sizeof( W3_CLONE_REQUEST );
    
    sm_pachCloneRequests = new ALLOC_CACHE_HANDLER( "W3_CLONE_REQUEST",
                                                    &acConfig );
    
    if ( sm_pachCloneRequests == NULL )
    {
        return HRESULT_FROM_WIN32( GetLastError() );
    }
    
    return NO_ERROR;
}

//static
VOID
W3_CLONE_REQUEST::Terminate(
    VOID
)
/*++

Routine Description:

    Terminate clone request lookaside

Arguments:

    None

Return Value:

    None

--*/
{
    if ( sm_pachCloneRequests != NULL )
    {
        delete sm_pachCloneRequests;
        sm_pachCloneRequests = NULL;
    }
}    

HRESULT
W3_REQUEST::PreloadEntityBody(
    W3_CONTEXT *pW3Context,
    BOOL       *pfComplete
    )
/*++

Routine Description:

    Preload entity body for this request if appropriate

Arguments:

    cbConfiguredReadAhead - Amount to preload
    pfComplete - Set to TRUE if preload is complete

Return Value:

    HRESULT

--*/
{
    DWORD                   cbConfiguredReadAhead;
    DWORD                   cbAvailableAlready = 0;
    PVOID                   pbAvailableAlready = NULL;
    DWORD                   cbAmountToPreload = 0;
    HRESULT                 hr;

    W3_METADATA *pMetadata = pW3Context->QueryUrlContext()->QueryMetaData();
    cbConfiguredReadAhead = pMetadata->QueryEntityReadAhead();

    *pfComplete = FALSE;
    
    //
    // How much entity do we already have available to us?  If it is more
    // than the preload size then we are finished
    //
    
    pbAvailableAlready = QueryEntityBody();
    cbAvailableAlready = QueryAvailableBytes();

    if ( cbAvailableAlready >= cbConfiguredReadAhead )
    {
        *pfComplete = TRUE;
        return S_OK;
    }

    //
    // OK.  We don't have the configured preload-size number of bytes 
    // currently available. 
    // 
    // Do we know how many bytes of entity are available from UL still.
    //

    cbAmountToPreload = pW3Context->QueryRemainingEntityFromUl();
    if ( cbAmountToPreload == INFINITE )
    {
        //
        // Must be a chunked request.  Cap at configured read ahead
        //
        
        cbAmountToPreload = cbConfiguredReadAhead;
    }
    else if ( cbAmountToPreload == 0 )
    {
        //
        // There is no more data available from UL.  
        //
        
        *pfComplete = TRUE;
        return S_OK;
    }
    else
    {
        //
        // There is still data to be read from UL
        //
        
        cbAmountToPreload += cbAvailableAlready;
        cbAmountToPreload = min( cbAmountToPreload, cbConfiguredReadAhead );
    }
    
    //
    // Allocate the buffer
    //
    
    if ( !_buffEntityBodyPreload.Resize( cbAmountToPreload ) )
    {
        return HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );
    }
    
    //
    // Copy any data already available to us
    //

    if ( cbAvailableAlready > 0 &&
         pbAvailableAlready != _buffEntityBodyPreload.QueryPtr())
    {
        DBG_ASSERT( pbAvailableAlready != NULL );

        memcpy( _buffEntityBodyPreload.QueryPtr(),
                pbAvailableAlready,
                cbAvailableAlready );
    }    
    
    //
    // Now read the read from UL asychronously
    //
    
    hr = pW3Context->ReceiveEntity( W3_FLAG_ASYNC,
                                    (PBYTE) _buffEntityBodyPreload.QueryPtr() + cbAvailableAlready,
                                    cbAmountToPreload - cbAvailableAlready,
                                    NULL );                                 

    if ( FAILED( hr ) )
    {
        //
        // In the chunked case, we do not know how many bytes there were so
        // we can hit EOF.  However, if the client sent content-length, then
        // it is an error
        //
        if (hr == HRESULT_FROM_WIN32(ERROR_HANDLE_EOF) &&
            pW3Context->QueryRemainingEntityFromUl() == INFINITE)
        {
            pW3Context->SetRemainingEntityFromUl(0);
            *pfComplete = TRUE;
            return S_OK;
        }

        return hr;
    }
    
    *pfComplete = FALSE;
    return S_OK;
}

HRESULT W3_REQUEST::PreloadCompletion(W3_CONTEXT *pW3Context,
                                      DWORD cbRead,
                                      DWORD dwStatus,
                                      BOOL *pfComplete)
{
    if ( dwStatus )
    {
        //
        // In the chunked case, we do not know how many bytes there were so
        // we can hit EOF.  However, if the client sent content-length, then
        // it is an error
        //
        if (dwStatus == ERROR_HANDLE_EOF &&
            pW3Context->QueryRemainingEntityFromUl() == INFINITE)
        {
            pW3Context->SetRemainingEntityFromUl(0);
            *pfComplete = TRUE;
            return S_OK;
        }

        return HRESULT_FROM_WIN32(dwStatus);
    }
    
    SetNewPreloadedEntityBody(_buffEntityBodyPreload.QueryPtr(),
                              QueryAvailableBytes() + cbRead);

    return PreloadEntityBody(pW3Context, pfComplete);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\iisplus\ulw3\w3server.h ===
/*++

Copyright (c) 1999-2000 Microsoft Corporation

Module Name:

    w3server.h

Abstract:

    Type definition for worker process implementation of IIS.

Author:

    Taylor Weiss (TaylorW)       16-Dec-1999

Revision History:

At this point - the following features of the IIS5 code base are
considered obsolete (ie never to be part of IIS+):

1. Service control manager goo
2. RPC administration support
3. Down-level admin support
4. Socket/Endpoint goo
5. Direct handling of site - start/stop/pause/etc
6. Password change support (ie. .htr hooks).


--*/

#ifndef _W3SERVER_H_
#define _W3SERVER_H_

/************************************************************
 *  Include Headers
 ************************************************************/

#include "mb_notify.h"

/************************************************************
 *  Type Definitions  
 ************************************************************/

#define W3_SERVER_MB_PATH       L"/LM/W3SVC/"
#define W3_SERVER_MB_PATH_CCH   10

enum RESTRICTION_LIST_TYPE
{
    IsapiRestrictionList,
    CgiRestrictionList
};

class   W3_SITE;

/*++

class W3_SERVER

    Encapsulates global settings for an HTTP server run in
    a duct-tape worker process.

    Condenses the relevant functionality exposed in IIS 
    through the IIS_SERVICE and W3_IIS_SERVICE.

--*/

#define W3_SERVER_SIGNATURE             'VRSW'
#define W3_SERVER_FREE_SIGNATURE        'fRSW'

/*++

    A simple referenced record to hold an image name

--*/

class W3_IMAGE_RECORD
{
public:
    
    W3_IMAGE_RECORD()
        : _cRefs( 1 )
    {
    }

    HRESULT
    Create(
        LPCWSTR pName,
        BOOL    fIsAllowed
        )
    {
        _fIsAllowed = fIsAllowed;
        return strName.Copy( pName );
    }

    LPWSTR
    QueryName(
        VOID
        ) const
    {
        return (LPWSTR)strName.QueryStr();
    }

    BOOL
    QueryIsAllowed(
        VOID
        ) const
    {
        return _fIsAllowed;
    }

    VOID
    ReferenceImageRecord(
        VOID
        )
    {
        InterlockedIncrement( &_cRefs );
    }

    VOID
    DereferenceImageRecord(
        VOID
        )
    {
        DBG_ASSERT( _cRefs != 0 );

        if ( InterlockedDecrement( &_cRefs ) == 0 )
        {
            delete this;
        }
    }

    VOID
    SetAllowedFlag(
        BOOL    fIsAllowed
        )
    {
        _fIsAllowed = fIsAllowed;
    }

private:

    ~W3_IMAGE_RECORD()
    {
    }

    LONG    _cRefs;
    STRU    strName;
    BOOL    _fIsAllowed;
};

/*++

  class W3_SITE_LIST

    The list of sites serviced by a W3_SERVER.

--*/

class W3_SITE_LIST :
    public CTypedHashTable<W3_SITE_LIST, W3_SITE, DWORD>
{

 public: 

    W3_SITE_LIST() :
        CTypedHashTable<W3_SITE_LIST, W3_SITE, DWORD>("W3_SITE_LIST")
    {}

    static DWORD 
    ExtractKey(const W3_SITE *site);

    static DWORD 
    CalcKeyHash(const DWORD key)
    { 
        return key; 
    }

    static bool 
    EqualKeys(DWORD key1, DWORD key2)
    { 
        return key1 == key2; 
    }

    static VOID
    AddRefRecord(W3_SITE *site, int nIncr);

 private:

    W3_SITE_LIST(const W3_SITE_LIST &);
    void operator=(const W3_SITE_LIST &);
};

class W3_RESTRICTION_LIST :
    public CTypedHashTable<W3_RESTRICTION_LIST, W3_IMAGE_RECORD, LPCWSTR>
{

public:

    W3_RESTRICTION_LIST() :
        CTypedHashTable<W3_RESTRICTION_LIST, W3_IMAGE_RECORD, LPCWSTR>("W3_RESTRICTION_LIST")
    {
        _cRefs = 1;
        _fInitialized = FALSE;
    }

    static LPCWSTR
    ExtractKey(const W3_IMAGE_RECORD *pEntry)
    {
        return pEntry->QueryName();
    }
    
    static DWORD
    CalcKeyHash(LPCWSTR pszKey)
    {
        DWORD cchKey = (DWORD)wcslen(pszKey);

        return HashStringNoCase(pszKey, cchKey);
    }
     
    static bool
    EqualKeys(LPCWSTR pszKey1, LPCWSTR pszKey2)
    {
        return _wcsicmp( pszKey1, pszKey2 ) == 0;
    }
    
    static void
    AddRefRecord(W3_IMAGE_RECORD *pEntry, int nIncr)
    {
        if ( nIncr == +1 )
        {
            pEntry->ReferenceImageRecord();
        }
        else if ( nIncr == - 1)
        {
            pEntry->DereferenceImageRecord();
        }
    }

    HRESULT
    Create(MULTISZ * pmszList, RESTRICTION_LIST_TYPE ListType);

    VOID
    ReferenceRestrictionList()
    {
        DBG_ASSERT( _cRefs != 0 );
        
        InterlockedIncrement( &_cRefs );
    }

    VOID
    DereferenceRestrictionList()
    {
        DBG_ASSERT( _cRefs > 0 );

        if ( InterlockedDecrement( &_cRefs ) == 0 )
        {
            delete this;
        }
    }

    BOOL
    IsImageEnabled(LPCWSTR szImage);

private:

    BOOL    _fInitialized;
    BOOL    _fAllowUnknown;
    LONG    _cRefs;

    W3_RESTRICTION_LIST(const W3_RESTRICTION_LIST &);
    void operator=(const W3_RESTRICTION_LIST &);

    ~W3_RESTRICTION_LIST()
    {}
};

class W3_METADATA_CACHE;
class W3_URL_INFO_CACHE;
class UL_RESPONSE_CACHE;
class DIGEST_CONTEXT_CACHE;

class W3_SERVER
{
    //
    // CODEWORK
    // Using friends to keep the public interface of this
    // class as clean as possible. It's pretty sleazy so
    // we definitely should undo if it isn't valuable.
    //
    friend class MB_LISTENER;

public:
    
    W3_SERVER( BOOL fCompatibilityMode );

    ~W3_SERVER();

    HRESULT
    Initialize(
        INT             argc,
        LPWSTR          argv[]
    );

    VOID
    Terminate(
        HRESULT hrReason
    );

    HRESULT
    StartListen(
        VOID
    );
    
    IMSAdminBase *
    QueryMDObject(
        VOID
    ) const
    {
        // This is only valid if all are threads are CoInited
        // in the MTA
        return m_pMetaBase;
    }

    LPCWSTR
    QueryMDPath(
        VOID
    ) const
    {
        return W3_SERVER_MB_PATH;
    }

    TOKEN_CACHE *
    QueryTokenCache(
        VOID
    ) const
    {
        return m_pTokenCache;
    }

    DIGEST_CONTEXT_CACHE *
    QueryDigestContextCache(
        VOID
    ) const
    {
        return m_pDigestContextCache;
    }
    
    W3_FILE_INFO_CACHE *
    QueryFileCache(
        VOID
    ) const
    {
        return m_pFileCache;
    }

    W3_URL_INFO_CACHE *
    QueryUrlInfoCache(
        VOID
    ) const
    {
        return m_pUrlInfoCache;
    }

    W3_METADATA_CACHE *
    QueryMetaCache(
        VOID
    ) const
    {
        return m_pMetaCache;
    }

    UL_RESPONSE_CACHE *
    QueryUlCache(
        VOID
    ) const
    {
        return m_pUlCache;
    }

    DWORD
    QuerySystemChangeNumber(
        VOID
    ) const
    {
        return m_dwSystemChangeNumber;
    }

    W3_SITE *
    FindSite( 
        IN DWORD dwInstance 
        );

    BOOL
    AddSite(
        IN W3_SITE * pInstance,
        IN bool      fOverWrite = false
        );

    BOOL
    RemoveSite(
        IN W3_SITE * pInstance
        );

    VOID
    DestroyAllSites(
        VOID
    );

    VOID WriteLockSiteList()
    {
        m_pSiteList->WriteLock();
    }

    VOID WriteUnlockSiteList()
    {
        m_pSiteList->WriteUnlock();
    }

        
    
    HRESULT CollectCounters(
        PBYTE *         ppCounterData,
        DWORD *         pdwCounterData
    );

    HRESULT
    LoadString(
        DWORD               dwStringID,
        CHAR *              pszString,
        DWORD *             pcbString
    );

    VOID
    GetCacheStatistics(
        IISWPGlobalCounters *   pCacheCtrs
    );

    BOOL
    QueryInBackwardCompatibilityMode(
        VOID
    )
    {
        return m_fInBackwardCompatibilityMode;
    }

    HRESULT
    ReadUseDigestSSP(
        VOID
    );

    BOOL
    QueryUseDigestSSP(
        VOID
    )
    {
        return m_fUseDigestSSP;
    }

    BOOL
    QueryDoCentralBinaryLogging(
        VOID
    )
    {
        return m_fDoCentralBinaryLogging;
    }

    CHAR *
    QueryComputerName(
        VOID
    )
    {
        return m_pszComputerName;
    }

    USHORT
    QueryComputerNameLength(
        VOID
    )
    {
        return m_cchComputerName;
    }

    BOOL
    QueryIsCommandLineLaunch(
        VOID
    )
    {
        return m_fIsCommandLineLaunch;
    }

    BOOL
    QueryIsDavEnabled(
        VOID
    ) const
    {
        return m_fDavEnabled; 
    }

    BOOL
    QueryIsTraceEnabled(
        VOID
    ) const
    {
        return m_fTraceEnabled;
    }

    void LogEvent(IN DWORD idMessage,
                  IN WORD cSubStrings,
                  IN const WCHAR *apszSubStrings[],
                  IN DWORD errCode = 0)
    {
        m_EventLog.LogEvent(idMessage,
                            cSubStrings,
                            apszSubStrings,
                            errCode);
    }

    static
    VOID
    OnShutdown(
        BOOL fDoImmediate
    );

    static
    VOID
    FlushUlResponses(
        MULTISZ *           pmszUrls
    );

    BOOL
    QueryIsIsapiImageEnabled(
        LPCWSTR szImage
        );

    BOOL
    QueryIsCgiImageEnabled(
        LPCWSTR szImage
        );

private:

    //
    // Metabase change handlers
    //

    HRESULT 
    MetabaseChangeNotification( 
        DWORD               dwMDNumElements,
        MD_CHANGE_OBJECT    pcoChangeList[]
    );

    HRESULT
    HandleMetabaseChange(
        const MD_CHANGE_OBJECT & ChangeObject
    );

    HRESULT
    InitializeRestrictionList(
        RESTRICTION_LIST_TYPE   ListType
        );


    W3_RESTRICTION_LIST *
    CreateRestrictionList(
        MULTISZ *               pmszImageList,
        RESTRICTION_LIST_TYPE   ListType
        );

    HRESULT
    InitializeCaches(
        VOID
    );

    VOID
    TerminateCaches(
        VOID
    );
 
    //
    // Internal Types
    //

    enum INIT_STATUS {
        INIT_NONE,
        INIT_SHUTDOWN_EVENT,
        INIT_IISUTIL,
        INIT_WINSOCK,
        INIT_METABASE,
        INIT_MB_LISTENER,
        INIT_W3_SITE,
        INIT_ULATQ,
        INIT_SITE_LIST,
        INIT_FILTERS,
        INIT_CACHES,
        INIT_W3_CONNECTION,
        INIT_W3_CONTEXT,
        INIT_W3_REQUEST,
        INIT_W3_RESPONSE,
        INIT_SERVER_VARIABLES,
        INIT_MIME_MAP,
        INIT_LOGGING,
        INIT_RAW_CONNECTION,
        INIT_CERTIFICATE_CONTEXT,
        INIT_HTTP_COMPRESSION,
        INIT_ISAPI_RESTRICTION_LIST,
        INIT_CGI_RESTRICTION_LIST,
        INIT_SERVER
    };

    DWORD               m_Signature;

    //
    // How far have we initialized?
    //
    
    INIT_STATUS         m_InitStatus;

    //
    // All important pointer to ABO 
    //
    
    IMSAdminBase *      m_pMetaBase;

    //
    // Site list
    //
    
    W3_SITE_LIST *      m_pSiteList;

    //
    // Site info used for optimization when only one site is on the list
    // Issue 08/28/2001 jaroslad: one site optimization should eventually be
    // integrated with LKR hash that could optimize for empty tables
    // and tables with one item
    //
    
    W3_SITE *           m_pOneSite;

    //
    // Synchronize access to m_pOneSite (refcounted object)
    //

    CReaderWriterLock2  m_OneSiteLock;

    //
    // Metabase change nofication object
    //

    MB_LISTENER *       m_pMetabaseListener;

    //
    // event log
    //
    EVENT_LOG           m_EventLog;

    //
    // Are we in backward compatibility mode?
    //
    BOOL                m_fInBackwardCompatibilityMode;

    //
    // Do we use new Digest SSP?
    //
    BOOL                m_fUseDigestSSP;

    //
    // Do we log into the central binary log?
    //
    BOOL                m_fDoCentralBinaryLogging;

    //
    // Number of current sites
    //
    DWORD               m_cSites;

    //
    // Handle to the resource DLL containing response strings
    //
    HMODULE             m_hResourceDll;

    //
    // The buffer used to put in all the site and global counters in to
    // pass to WAS
    //
    PBYTE               m_pCounterDataBuffer;
    DWORD               m_dwCounterDataBuffer;

    //
    // The server's name
    //
    CHAR                m_pszComputerName[MAX_COMPUTERNAME_LENGTH + 1];
    USHORT              m_cchComputerName;

    //
    // All our caches
    //

    TOKEN_CACHE          * m_pTokenCache;
    DIGEST_CONTEXT_CACHE * m_pDigestContextCache;
    W3_FILE_INFO_CACHE   * m_pFileCache;
    W3_METADATA_CACHE    * m_pMetaCache;
    W3_URL_INFO_CACHE    * m_pUrlInfoCache;
    UL_RESPONSE_CACHE    * m_pUlCache;

    //
    // :-( System change number.  Tie it to sink for perf reasons
    //

    DWORD               m_dwSystemChangeNumber;

    //
    // Secure server - image enabled lists
    //

    W3_RESTRICTION_LIST *       m_pIsapiRestrictionList;
    W3_RESTRICTION_LIST *       m_pCgiRestrictionList;
    CReaderWriterLock3          m_IsapiRestrictionLock;
    CReaderWriterLock3          m_CgiRestrictionLock;

    //
    // Remember if DAV is enabled or not
    //

    BOOL                        m_fDavEnabled;

    //
    // Were we command line launched?
    //

    BOOL                        m_fIsCommandLineLaunch;

    //
    // Is TRACE enabled?
    //

    BOOL                        m_fTraceEnabled;
};

extern W3_SERVER *      g_pW3Server;

#endif // _W3SERVER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\iisplus\ulw3\w3server.cxx ===
/*++

Copyright (c) 1999-2000 Microsoft Corporation

Module Name:

    w3server.cxx

Abstract:

    W3_SERVER object holds global state for ULW3.DLL

Author:

    Taylor Weiss (TaylorW)       26-Jan-1999

Revision History:

--*/

#include "precomp.hxx"
#include "rawconnection.hxx"
#include "cgi_handler.h"
#include "dav_handler.h"

/*++

class MB_LISTENER

    Implements a metabase change listener for W3_SERVER.

--*/
class MB_LISTENER
    : public MB_BASE_NOTIFICATION_SINK
{
public:

    MB_LISTENER( W3_SERVER * pParent )
        : m_pParent( pParent )
    {
    }

    STDMETHOD( SynchronizedSinkNotify )( 
        DWORD               dwMDNumElements,
        MD_CHANGE_OBJECT    pcoChangeList[]
        )
    {
        return m_pParent->MetabaseChangeNotification( dwMDNumElements, pcoChangeList );
    }

private:
    
    W3_SERVER * m_pParent;

};

W3_SERVER::W3_SERVER( BOOL fCompatibilityMode ) 
  : m_Signature                   (W3_SERVER_SIGNATURE),
    m_pMetaBase                   (NULL),
    m_InitStatus                  (INIT_NONE),
    m_fInBackwardCompatibilityMode(fCompatibilityMode),
    m_fUseDigestSSP               (FALSE),
    m_EventLog                    (L"W3SVC-WP"),
    m_pCounterDataBuffer          (NULL),
    m_dwCounterDataBuffer         (0),
    m_cSites                      (0),
    m_hResourceDll                (NULL),
    m_pTokenCache                 (NULL),
    m_pDigestContextCache         (NULL),
    m_pUlCache                    (NULL),
    m_pUrlInfoCache               (NULL),
    m_pFileCache                  (NULL),
    m_pMetaCache                  (NULL),
    m_pIsapiRestrictionList       (NULL),
    m_pCgiRestrictionList         (NULL),
    m_pOneSite                    (NULL),
    m_fDavEnabled                 (FALSE),
    m_fDoCentralBinaryLogging     (FALSE),
    m_fTraceEnabled               (FALSE)
{
}

W3_SERVER::~W3_SERVER()
{
    if (m_pCounterDataBuffer != NULL)
    {
        LocalFree(m_pCounterDataBuffer);
        m_pCounterDataBuffer = NULL;
    }

    m_Signature = W3_SERVER_FREE_SIGNATURE;
}

// static
DWORD W3_SITE_LIST::ExtractKey(const W3_SITE *site)
{
    return site->QueryId();
}

// static
VOID W3_SITE_LIST::AddRefRecord(W3_SITE *site, int nIncr)
{
    if (nIncr > 0)
    {
        site->ReferenceSite();
    }
    else if (nIncr < 0)
    {
        site->DereferenceSite();
    }
    else
    {
        DBG_ASSERT( !"Invalid reference");
    }
}

HRESULT
W3_RESTRICTION_LIST::Create(MULTISZ * pmszList, RESTRICTION_LIST_TYPE ListType)
{
    LPCWSTR             szData = NULL;
    LPWSTR              pCursor;
    LPWSTR              pDelimiter;
    W3_IMAGE_RECORD *   pNewRecord = NULL;
    LK_RETCODE          lkr;
    HRESULT             hr = NOERROR;
    BOOL                fAllowItem;
    BOOL                fFoundDefault = FALSE;
    STACK_STRU(         struEntry,256 );

    DBG_ASSERT( pmszList );
    DBG_ASSERT( ListType == IsapiRestrictionList ||
                ListType == CgiRestrictionList );

    //
    // Set default to disallow unlisted items
    //

    _fAllowUnknown = FALSE;

    //
    // Initialize szData to the first element in the list
    //

    szData = pmszList->First();

    if ( szData == NULL )
    {
        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }

    //
    // Walk the list and add items
    //

    do
    {
        hr = struEntry.Copy( szData );

        if ( FAILED( hr ) )
        {
            return hr;
        }

        //
        // Figure out if this is an allow or deny entry
        //

        pCursor = struEntry.QueryStr();
        pDelimiter = wcschr( pCursor, L',' );

        if ( !pDelimiter )
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "Invalid entry in restriction list and will be ignored: '%S'\r\n",
                        szData ));

            continue;
        }

        *pDelimiter = L'\0';
        
        if ( wcscmp( pCursor, L"0" ) == 0 )
        {
            fAllowItem = FALSE;
        }
        else if ( wcscmp( pCursor, L"1" ) == 0 )
        {
            fAllowItem = TRUE;
        }
        else
        {
            //
            // Invalid value.  Assume it's a deny entry
            //

            DBGPRINTF(( DBG_CONTEXT,
                        "Invalid allow/deny flag in restriction list assumed to be '0': '%S'\r\n",
                        szData ));

            fAllowItem = FALSE;
        }

        //
        // Get the image name.  Check for special case entry
        // "*.dll" or ISAPI, or "*.exe" for CGI.
        //

        pCursor = pDelimiter + 1;
        pDelimiter = wcschr( pCursor, L',' );

        if ( pDelimiter )
        {
            *pDelimiter = L'\0';
        }

        if ( ( ListType == IsapiRestrictionList && _wcsicmp( pCursor, L"*.dll" ) == 0 ) ||
             ( ListType == CgiRestrictionList && _wcsicmp( pCursor, L"*.exe" ) == 0 ) )
        {
            if ( !fFoundDefault )
            {
                _fAllowUnknown = fAllowItem;

                fFoundDefault = TRUE;
            }
            else
            {
                //
                // There are at least two entries that represent
                // the default entry.  We should assume that deny
                // entries take priority.
                //

                if ( _fAllowUnknown )
                {
                    _fAllowUnknown = fAllowItem;
                }

                DBGPRINTF(( DBG_CONTEXT,
                            "Duplicate default entry found in restriction list.  "
                            "'Deny' entries will take priority.\r\n" ));
            }

            continue;
        }

        //
        // Check to see if this entry already exists.  If so,
        // deny entries should take priority.
        //

        lkr = FindKey( pCursor, &pNewRecord );

        if ( pNewRecord != NULL )
        {
            //
            // Found duplicate entry.
            //

            DBGPRINTF(( DBG_CONTEXT,
                        "Duplicate entry for '%S' found in restriction list. "
                        "'Deny' entries will take priority.\r\n",
                        pCursor ));

            if ( pNewRecord->QueryIsAllowed() == TRUE )
            {
                pNewRecord->SetAllowedFlag( fAllowItem );
            }

            pNewRecord->DereferenceImageRecord();
            pNewRecord = NULL;
        }
        else
        {
            //
            // Adding a new non-default entry to the list.
            //
        
            pNewRecord = new W3_IMAGE_RECORD;

            if ( pNewRecord == NULL )
            {
                return HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );
            }

            hr = pNewRecord->Create( pCursor, fAllowItem );

            if ( FAILED( hr ) )
            {
                pNewRecord->DereferenceImageRecord();
                pNewRecord = NULL;
                return hr;
            }

            lkr = InsertRecord( pNewRecord, TRUE );

            pNewRecord->DereferenceImageRecord();
            pNewRecord = NULL;

            if ( lkr != LK_SUCCESS && lkr != LK_KEY_EXISTS )
            {
                return E_FAIL;
            }
        }
    } while ( szData = pmszList->Next( szData ) );


    _fInitialized = TRUE;

    return NOERROR;
}


BOOL W3_RESTRICTION_LIST::IsImageEnabled(LPCWSTR szImage)
{
    W3_IMAGE_RECORD *   pRecord = NULL;
    LK_RETCODE          lkr;
    BOOL                fAllowImage = FALSE;

    //
    // If this object has not been initialized, then
    // all queries should return FALSE.
    //

    if ( _fInitialized == FALSE )
    {
        return FALSE;
    }

    //
    // Is the item in the list?
    //

    if ( Size() == 0 )
    {
        //
        // fast path to avoid lkrhash
        // restriction list is static
        // The only change happens on metabase change updates
        // but in that case the whole list is replaced
        //
        
        lkr = LK_NO_SUCH_KEY;
    }
    else
    {
        lkr = FindKey( szImage, &pRecord );
    }

    if ( lkr == LK_SUCCESS )
    {
        fAllowImage = pRecord->QueryIsAllowed();

        pRecord->DereferenceImageRecord();
        pRecord = NULL;
    }
    else
    {
        fAllowImage = _fAllowUnknown;
    }

    return fAllowImage;
}

HRESULT FakeCollectCounters(PBYTE *ppCounterData,
                            DWORD *pdwCounterData)
{
    return g_pW3Server->CollectCounters(ppCounterData,
                                        pdwCounterData);
}

HRESULT
W3_SERVER::Initialize(
    INT                 argc,
    LPWSTR              argv[]
)
/*++

Routine Description:

    Initialize ULW3.DLL but do not begin listening for requests

Arguments:

    argc - Command line argument count
    argv[] - Command line arguments (from WAS)
    
Return Value:

    HRESULT

--*/
{
    HRESULT                 hr = NOERROR;
    ULONG                   err;
    ULATQ_CONFIG            ulatqConfig;
    WSADATA                 wsaData;
    ULONG_PTR               commandLaunch;
    HKEY                    hKey;
    DWORD                   dwType;
    DWORD                   cbTraceEnabled;
    DWORD                   dwTraceEnabled;

    DBGPRINTF((
        DBG_CONTEXT, 
        "Initializing the W3 Server Started CTC = %d \n",
        GetTickCount()
        ));
    //
    // Initialize Computer name, trivial so doesn't need its own state
    //

    DWORD cbSize = sizeof m_pszComputerName;
    if (!GetComputerNameA(m_pszComputerName, &cbSize))
    {
        strcpy(m_pszComputerName, "<Server>");
    }
    m_cchComputerName = (USHORT)strlen(m_pszComputerName);

    //
    // Figure out whether TRACE requests are enabled
    //

    if ( RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                       W3_PARAMETERS_KEY,
                       0,
                       KEY_READ,
                       &hKey ) == NO_ERROR )
    {
        cbTraceEnabled = sizeof( DWORD );
        
        if ( RegQueryValueEx( hKey,
                              L"EnableTraceMethod",
                              NULL,
                              &dwType,
                              (LPBYTE) &dwTraceEnabled,
                              &cbTraceEnabled ) == NO_ERROR )
        {
            m_fTraceEnabled = !!dwTraceEnabled;
        }
        
        RegCloseKey( hKey );
    }
    
    //
    // Keep track of how much we have initialized so that we can cleanup
    // only that which is necessary
    //
    
    m_InitStatus = INIT_NONE;

    m_hResourceDll = LoadLibrary(IIS_RESOURCE_DLL_NAME);

    if ( m_hResourceDll == NULL )
    {
        hr = HRESULT_FROM_WIN32( GetLastError() );
        DBGPRINTF(( DBG_CONTEXT,
                    "Error Loading required resource DLL.  hr = %x\n",
                    hr ));
        goto exit;
    }

    //
    // Initialize IISUTIL
    //

    if ( !InitializeIISUtil() )
    {
        hr = HRESULT_FROM_WIN32( GetLastError() );
        DBGPRINTF(( DBG_CONTEXT,
                    "Error initializing IISUTIL.  hr = %x\n",
                    hr ));
        goto exit;
    }
    m_InitStatus = INIT_IISUTIL;

    DBGPRINTF((
        DBG_CONTEXT, 
        "W3 Server initializing WinSock.  CTC = %d \n",
        GetTickCount()
        ));

    //
    // Initialize WinSock
    //

    if ( ( err = WSAStartup( MAKEWORD( 1, 1 ), &wsaData ) ) != ERROR_SUCCESS )
    {
        hr = HRESULT_FROM_WIN32( err );
        DBGPRINTF(( DBG_CONTEXT,
                    "Error initializing WinSock.  hr = %x\n",
                    hr ));
        goto exit;
    } 
    m_InitStatus = INIT_WINSOCK;

    DBGPRINTF((
        DBG_CONTEXT, 
        "W3 Server WinSock initialized.  CTC = %d \n",
        GetTickCount()
        ));

    //
    // Initialize the metabase access (ABO)
    //

    hr = CoCreateInstance( CLSID_MSAdminBase,
                           NULL,
                           CLSCTX_SERVER,
                           IID_IMSAdminBase,
                           (LPVOID *)&(m_pMetaBase)
                           );

    if( FAILED(hr) )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "Error creating ABO object.  hr = %x\n",
                    hr ));
        goto exit;
    }
    
    hr = ReadUseDigestSSP();
    if( FAILED(hr) )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "Error reading UseDigestSSP property.  hr = %x\n",
                    hr ));
        goto exit;
    }
    
    m_pMetaBase->GetSystemChangeNumber( &m_dwSystemChangeNumber );

    m_InitStatus = INIT_METABASE;

    DBGPRINTF((
        DBG_CONTEXT, 
        "W3 Server Metabase initialized.  CTC = %d \n",
        GetTickCount()
        ));
        
    //
    // Initialize metabase change notification mechanism
    //
    
    m_pMetabaseListener = new MB_LISTENER( this );
    if ( m_pMetabaseListener == NULL )
    {
        hr = HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );
        goto exit;
    }
    m_InitStatus = INIT_MB_LISTENER;
    
    //
    // Initialize W3_SITE
    //

    hr = W3_SITE::W3SiteInitialize();
    if ( FAILED( hr ) )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "Error doing global W3_SITE initialization.  hr = %x\n",
                    hr ));
        goto exit;
    }
    m_InitStatus = INIT_W3_SITE;
    
    //
    // Initialize ULATQ
    //

    ulatqConfig.pfnNewRequest = W3_MAIN_CONTEXT::OnNewRequest;
    ulatqConfig.pfnIoCompletion = W3_MAIN_CONTEXT::OnIoCompletion;
    ulatqConfig.pfnDisconnect = OnUlDisconnect;
    ulatqConfig.pfnOnShutdown = W3_SERVER::OnShutdown;
    ulatqConfig.pfnCollectCounters = FakeCollectCounters;

    hr = UlAtqInitialize( argc, 
                          argv,
                          &ulatqConfig );
    if( FAILED(hr) )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "Error initializing ULATQ.  hr = %x\n",
                    hr ));

        // Since we most likely have not hooked up to WAS yet we need
        // to communicate that we failed to initialize either the communication
        // with HTTP or with WAS.

        g_pW3Server->LogEvent(
            W3_EVENT_FAIL_INITIALIZING_ULATQ,
            0,
            NULL,
            hr
            );

        goto exit;
    }
    
    commandLaunch = (ULONG_PTR) UlAtqGetContextProperty( NULL,
                                                         ULATQ_PROPERTY_IS_COMMAND_LINE_LAUNCH );

    m_fIsCommandLineLaunch = commandLaunch ? TRUE : FALSE;

    m_fDoCentralBinaryLogging = (ULONG_PTR) UlAtqGetContextProperty( NULL,
                                    ULATQ_PROPERTY_DO_CENTRAL_BINARY_LOGGING );

    m_InitStatus = INIT_ULATQ;

    DBGPRINTF((
        DBG_CONTEXT, 
        "W3 Server UlAtq initialized (ipm has signalled).  CTC = %d \n",
        GetTickCount()
        ));

    //
    // Initialize global filter list
    //
    
    hr = GlobalFilterInitialize();
    if ( FAILED( hr ) )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "Error doing global filter initialization.  hr = %x\n",
                    hr ));
        goto exit;
    }
    m_InitStatus = INIT_FILTERS;

    //
    // Initialize site list
    //
    
    m_pSiteList = new W3_SITE_LIST();
    if ( m_pSiteList == NULL )
    {
        hr = HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );
        goto exit;
    }
    m_InitStatus = INIT_SITE_LIST;

    //
    // Initialize caches
    //

    hr = InitializeCaches();
    if ( FAILED( hr ) )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "Error initializing caches.  hr = %x\n",
                    hr ));
        goto exit;
    }
    m_InitStatus = INIT_CACHES;

    //
    // Initialize connection table
    //
    
    hr = W3_CONNECTION::Initialize();
    if ( FAILED( hr ) )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "Error initializing connection table.  hr = %x\n",
                    hr ));
        goto exit;
    }
    m_InitStatus = INIT_W3_CONNECTION;

    //
    // Initialize W3_CONTEXTs
    //    
    
    hr = W3_CONTEXT::Initialize();
    if ( FAILED( hr ) )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "Error initializing W3_CONTEXT globals.  hr = %x\n",
                    hr ));
        goto exit;
    }
    m_InitStatus = INIT_W3_CONTEXT;

    //
    // Initialize W3_REQUEST
    //
    
    hr = W3_REQUEST::Initialize();
    if ( FAILED( hr ) )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "Error initializing W3_REQUEST globals.  hr = %x\n",
                    hr ));
        goto exit;
    }
    m_InitStatus = INIT_W3_REQUEST;
    
    //
    // Initialize W3_RESPONSE
    //
    
    hr = W3_RESPONSE::Initialize();
    if ( FAILED( hr ) )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "Error initializing W3_RESPONSE globals.  hr = %x\n",
                    hr ));
        goto exit;
    }
    m_InitStatus = INIT_W3_RESPONSE;
    
    //
    // Initialize server variables
    //
    
    hr = SERVER_VARIABLE_HASH::Initialize();
    if ( FAILED( hr ) )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "Error initializing server variable hash table.  hr = %x\n",
                    hr ));
        goto exit;
    }
    m_InitStatus = INIT_SERVER_VARIABLES;

    //
    // Initialize Mime-mappings
    //
    hr = InitializeMimeMap();
    if ( FAILED( hr ) )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "Error initializing mime map table.  hr = %x\n",
                    hr ));
        goto exit;
    }
    m_InitStatus = INIT_MIME_MAP;

    //
    // Initialize logging
    //
    if (FAILED(hr = LOGGING::Initialize()))
    {
        goto exit;
    }
    m_InitStatus = INIT_LOGGING;
    
    //
    // If we are in backward compatibility mode, then initialize stream 
    // filter here
    //

    if (m_fInBackwardCompatibilityMode)
    {
        hr = RAW_CONNECTION::Initialize();
        if ( FAILED( hr ) )
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "Error initialize ISAPI raw data filter support.  hr = %x\n",
                        hr ));
            goto exit;
        }
    }
    m_InitStatus = INIT_RAW_CONNECTION;

    //
    // Client certificate object wrapper
    // 
    
    hr = CERTIFICATE_CONTEXT::Initialize();
    if ( FAILED( hr ) )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "Error initializing certificate contexts.  hr = %x\n",
                    hr ));
        goto exit;
    }
    m_InitStatus = INIT_CERTIFICATE_CONTEXT;

    //
    // Gateway Restriction Lists
    //

    hr = InitializeRestrictionList( IsapiRestrictionList );
    if ( FAILED( hr ) )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "Error initializing ISAPI restriction list.  hr = %x\n",
                    hr ));
        goto exit;
    }
    m_InitStatus = INIT_ISAPI_RESTRICTION_LIST;

    hr = InitializeRestrictionList( CgiRestrictionList );
    if ( FAILED( hr ) )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "Error initializing CGI restriction list.  hr = %x\n",
                    hr ));
        goto exit;
    }
    m_InitStatus = INIT_CGI_RESTRICTION_LIST;
    
    //
    // Initialize Http Compression
    // Ignore failure but remember if we Initialized.
    //
    hr = HTTP_COMPRESSION::Initialize();
    if ( FAILED( hr ) )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "Error initializing Http Compression.  hr = %x\n",
                    hr ));
        hr = S_OK;
    }
    else
    {
        m_InitStatus = INIT_HTTP_COMPRESSION;
    }
    
exit:
    return hr;
}

VOID
W3_SERVER::Terminate(
    HRESULT hrReason
)
/*++

Routine Description:

    Terminate ULW3 globals.  This should be done after we have stopped 
    listening for new requests (duh)

Arguments:
    
    None
    
Return Value:

    TRUE if successful, else FALSE

--*/
{
    DBGPRINTF(( DBG_CONTEXT,
                "Terminating W3_SERVER object\n" ));

    switch( m_InitStatus )
    {
    case INIT_HTTP_COMPRESSION:
        HTTP_COMPRESSION::Terminate();

    case INIT_CGI_RESTRICTION_LIST:
        m_CgiRestrictionLock.WriteLock();
        
        if ( m_pCgiRestrictionList != NULL )
        {
            m_pCgiRestrictionList->DereferenceRestrictionList();
            m_pCgiRestrictionList = NULL;
        }

        m_CgiRestrictionLock.WriteUnlock();

    case INIT_ISAPI_RESTRICTION_LIST:
        m_IsapiRestrictionLock.WriteLock();
        
        if ( m_pIsapiRestrictionList != NULL )
        {
            m_pIsapiRestrictionList->DereferenceRestrictionList();
            m_pIsapiRestrictionList = NULL;
        }

        m_IsapiRestrictionLock.WriteUnlock();

    case INIT_CERTIFICATE_CONTEXT:
        CERTIFICATE_CONTEXT::Terminate();

    case INIT_RAW_CONNECTION:
        if (m_fInBackwardCompatibilityMode)
        {
            RAW_CONNECTION::Terminate();
        }

    case INIT_LOGGING:
        LOGGING::Terminate();

    case INIT_MIME_MAP:
        CleanupMimeMap();
        
    case INIT_SERVER_VARIABLES:
        SERVER_VARIABLE_HASH::Terminate();
        
    case INIT_W3_RESPONSE:
        W3_RESPONSE::Terminate();
        
    case INIT_W3_REQUEST:
        W3_REQUEST::Terminate();
        
    case INIT_W3_CONTEXT:
        W3_CONTEXT::Terminate();
        
    case INIT_W3_CONNECTION:
        W3_CONNECTION::Terminate();

    case INIT_CACHES:
        TerminateCaches();

    case INIT_SITE_LIST:
        //
        // Optimization for one site
        //
        m_OneSiteLock.WriteLock();
        if ( m_pOneSite != NULL )
        {
            m_pOneSite->DereferenceSite();
            m_pOneSite = NULL;
        }
        m_OneSiteLock.WriteUnlock();
        //
        // end of optimization for one site
        //
        delete m_pSiteList;
        m_pSiteList = NULL;

    case INIT_FILTERS:
        GlobalFilterTerminate();

    case INIT_ULATQ:
        UlAtqTerminate( hrReason );

    case INIT_W3_SITE:
        W3_SITE::W3SiteTerminate();

    case INIT_MB_LISTENER:
        if ( m_pMetabaseListener != NULL )
        {
            m_pMetabaseListener->Release();
            m_pMetabaseListener = NULL;
        }

    case INIT_METABASE:
        if ( m_pMetaBase )
        {
            m_pMetaBase->Release();
        }

    case INIT_WINSOCK:
        WSACleanup();

    case INIT_IISUTIL:
        TerminateIISUtil();


    }

    if (m_hResourceDll != NULL)
    {
        FreeLibrary(m_hResourceDll);
        m_hResourceDll = NULL;
    }
    
    m_InitStatus = INIT_NONE;
}

HRESULT
W3_SERVER::LoadString(
    DWORD                       dwStringID,
    CHAR *                      pszString,
    DWORD *                     pcbString
)
/*++

Routine Description:

    Load a resource string from W3CORE.DLL

Arguments:
    
    dwStringID - String ID
    pszString - Filled with string
    pcbString - On input the size of the buffer pszString, on successful 
                output, the length of the string copied to pszString
   
Return Value:

    HRESULT

--*/
{
    DWORD           cbCopied;
    
    if ( pszString == NULL || 
         pcbString == NULL )
    {
        DBG_ASSERT( FALSE );
        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    } 

    cbCopied = LoadStringA( m_hResourceDll,
                            dwStringID,
                            pszString,
                            *pcbString );
    if ( cbCopied == 0 )
    {
        return HRESULT_FROM_WIN32( GetLastError() );
    }
    
    *pcbString = cbCopied;
    return NO_ERROR;
}

HRESULT
W3_SERVER::StartListen(
    VOID
)
/*++

Routine Description:

    Begin listening for requests.  This function will return once we have 
    stopped listening for requests (due to WAS stopping us for some reason)

    Listen for metabase changes.

Arguments:
    
    None
    
Return Value:

    HRESULT

--*/
{
    HRESULT hr = NOERROR;

    DBG_ASSERT( m_pMetabaseListener );

    //
    // Starting getting metabase changes
    //

    hr = m_pMetabaseListener->StartListening( m_pMetaBase );
    if ( FAILED( hr ) )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "Error trying to listen for metabase changes.  hr = %x\n",
                    hr ));
        return hr;
    }
    
    //
    // Listen for the stream filter
    //

    if (m_fInBackwardCompatibilityMode)
    {
        hr = RAW_CONNECTION::StartListening();
        if ( FAILED( hr ) )
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "Error listening on filter channel.  hr = %x\n",
                        hr ));

            m_pMetabaseListener->StopListening( m_pMetaBase );

            return hr;
        }
    }
    
    //
    // Start listening for requests
    //
    
    hr = UlAtqStartListen();
    if( FAILED( hr ) )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "Error listening for HTTP requests.  hr = %x\n",
                    hr ));
        
        if (m_fInBackwardCompatibilityMode)
        {
            RAW_CONNECTION::StopListening();
        }

        m_pMetabaseListener->StopListening( m_pMetaBase );
        
        return hr;
    }
    
    //
    // StartListen() will return when we are to shutdown.
    //
    
    m_pMetabaseListener->StopListening( m_pMetaBase );

    return NO_ERROR;
}

W3_SITE *
W3_SERVER::FindSite(
    DWORD               dwInstance
)
{
    W3_SITE *site = NULL;
    //
    // Optimization for one site
    //
    if ( m_pOneSite != NULL )
    {
        m_OneSiteLock.ReadLock();     
        // minimize the time spent under this critical section
        //
        if ( m_pOneSite != NULL )
        {
            m_pOneSite->ReferenceSite();
            site = m_pOneSite;
        }
        m_OneSiteLock.ReadUnlock();
        
        if ( site != NULL )
        { 
            if ( site->QueryId() != dwInstance )    
            {
                site->DereferenceSite();
                site = NULL;
            }   
            return site;
        }
    }
    //
    // End of optimization for one site
    //
  
    
    LK_RETCODE lkrc = m_pSiteList->FindKey(dwInstance, &site);
    if (site != NULL)
    {
        DBG_ASSERT(lkrc == LK_SUCCESS);
    }

    return site;
}

BOOL W3_SERVER::AddSite(W3_SITE *site,
                        bool fOverWrite)
{
    
    if (m_pSiteList->InsertRecord(site, fOverWrite) == LK_SUCCESS)
    {
        if (!fOverWrite)
        {
            InterlockedIncrement((LPLONG)&m_cSites);
        }
       
        //
        // optimization for SiteList with only one active site
        //
        m_OneSiteLock.WriteLock();
        if ( m_pOneSite != NULL )
        {
            m_pOneSite->DereferenceSite();
            m_pOneSite = NULL;
        }
        if ( m_cSites == 1 )
        {
            site->ReferenceSite();
            m_pOneSite = site;
        }
        m_OneSiteLock.WriteUnlock();
    
        return TRUE;
    }

    return FALSE;
}

BOOL W3_SERVER::RemoveSite(W3_SITE *pInstance)
{

    if (m_pSiteList->DeleteRecord(pInstance) == LK_SUCCESS)
    {
        InterlockedDecrement((LPLONG)&m_cSites);

        //
        // optimization for SiteList with only one active site
        //

        if ( m_pOneSite != NULL )
        {
            m_OneSiteLock.WriteLock();
            if ( m_pOneSite != NULL )
            {
                m_pOneSite->DereferenceSite();
                m_pOneSite = NULL;
            }
            m_OneSiteLock.WriteUnlock();
        }
        
        return TRUE;
    }

    return FALSE;
}

void W3_SERVER::DestroyAllSites()
{
    m_OneSiteLock.WriteLock();
    if ( m_pOneSite != NULL )
    {
        m_pOneSite->DereferenceSite();
        m_pOneSite = NULL;
    }
    m_OneSiteLock.WriteUnlock();
    m_pSiteList->Clear();
}

HRESULT 
W3_SERVER::MetabaseChangeNotification( 
        DWORD               dwMDNumElements,
        MD_CHANGE_OBJECT    pcoChangeList[]
        )
/*++

Routine Description:

    This is the entry point for metabase changes.
    It just loops through pcoChangeList and passes
    the change to the handler method.

Arguments:
    
    dwMDNumElements - Number of change objects
    pcoChangeList - Array of change objects
    
Return Value:

--*/
{
    DBGPRINTF(( DBG_CONTEXT,
                "MetabaseChangeNotification called.\n" 
                ));

    //
    // Verify that the change is for /LM/W3SVC/ or lower
    // and dispatch the change.
    //

    HRESULT hr = NOERROR;
    
    for( DWORD i = 0; i < dwMDNumElements; ++i )
    {
        if( _wcsnicmp( pcoChangeList[i].pszMDPath,
                      W3_SERVER_MB_PATH,
                      W3_SERVER_MB_PATH_CCH ) == 0 )
        {
            hr = HandleMetabaseChange( pcoChangeList[i] );
        }
    }
    //
    // Update system change number for use by file cache (etags)
    //

    m_pMetaBase->GetSystemChangeNumber( &m_dwSystemChangeNumber );

    return hr;
}

VOID
W3_SERVER::TerminateCaches(
    VOID
)
/*++

Routine Description:

    Cleanup all the caches

Arguments:
    
    None
    
Return Value:

    None

--*/
{
    //
    // First flush all caches (only references which should remain on cached
    // objects should be thru the hash tables themselves).  Once we have
    // flushed all the caches, all the cached objects should go away.
    //
    // If they don't that's a bug and ACache assert will fire
    //
    
    W3CacheFlushAllCaches();
    
    //
    // Now just unregister and cleanup the caches
    //
    
    if ( m_pMetaCache != NULL )
    {
        W3CacheUnregisterCache( m_pMetaCache );
        m_pMetaCache->Terminate();
        delete m_pMetaCache;
        m_pMetaCache = NULL;
    }
    
    if ( m_pFileCache != NULL )
    {
        W3CacheUnregisterCache( m_pFileCache );
        m_pFileCache->Terminate();
        delete m_pFileCache;
        m_pFileCache = NULL;
    }
    
    if ( m_pTokenCache != NULL )
    {
        W3CacheUnregisterCache( m_pTokenCache );
        m_pTokenCache->Terminate();
        delete m_pTokenCache;
        m_pTokenCache = NULL;
    }
    
    if ( m_pDigestContextCache != NULL )
    {
        W3CacheUnregisterCache( m_pDigestContextCache );
        m_pDigestContextCache->Terminate();
        delete m_pDigestContextCache;
        m_pDigestContextCache = NULL;
    }
    
    if ( m_pUrlInfoCache != NULL )
    {
        W3CacheUnregisterCache( m_pUrlInfoCache );
        m_pUrlInfoCache->Terminate();
        delete m_pUrlInfoCache;
        m_pUrlInfoCache = NULL;
    }
    
    if ( m_pUlCache != NULL )
    {
        W3CacheUnregisterCache( m_pUlCache );
        m_pUlCache->Terminate();
        delete m_pUlCache;
        m_pUlCache = NULL;    
    }
    
    W3CacheTerminate();
}

HRESULT
W3_SERVER::InitializeCaches(
    VOID
)
/*++

Routine Description:

    Initialize caches

Arguments:
    
    None
    
Return Value:

    HRESULT

--*/
{
    HRESULT             hr = NO_ERROR;
    BOOL                fCacheInit = FALSE;
    
    //
    // Url cache
    //
    
    m_pUrlInfoCache = new W3_URL_INFO_CACHE;
    if ( m_pUrlInfoCache != NULL )
    {
        hr = m_pUrlInfoCache->Initialize();
        if ( FAILED( hr ) )
        {
            delete m_pUrlInfoCache;
            m_pUrlInfoCache = NULL;
        }    
    }
    
    if ( m_pUrlInfoCache == NULL )
    {
        goto Failure;
    }
    
    //
    // Token cache
    //
    
    m_pTokenCache = new TOKEN_CACHE;
    if ( m_pTokenCache != NULL )
    {
        hr = m_pTokenCache->Initialize();
        if ( FAILED( hr ) )
        {
            delete m_pTokenCache;
            m_pTokenCache = NULL;
        }
    }
    
    if ( m_pTokenCache == NULL )
    {
        goto Failure;
    }
    
    //
    // Digest server context cache
    //
    
    m_pDigestContextCache = new DIGEST_CONTEXT_CACHE;
    if ( m_pDigestContextCache != NULL )
    {
        hr = m_pDigestContextCache->Initialize();
        if ( FAILED( hr ) )
        {
            delete m_pDigestContextCache;
            m_pDigestContextCache = NULL;
        }
    }
    
    if ( m_pDigestContextCache == NULL )
    {
        goto Failure;
    }
    
    //
    // Digest server context cache
    //

    //
    // File cache
    //

    m_pFileCache = new W3_FILE_INFO_CACHE;
    if ( m_pFileCache != NULL )
    {
        hr = m_pFileCache->Initialize();
        if ( FAILED( hr ) )
        {
            delete m_pFileCache;
            m_pFileCache = NULL;
        }
    }
    
    if ( m_pFileCache == NULL )
    {
        goto Failure;
    }
    
    //
    // Metacache
    //
    
    m_pMetaCache = new W3_METADATA_CACHE;
    if ( m_pMetaCache != NULL )
    {
        hr = m_pMetaCache->Initialize();
        if ( FAILED( hr ) )
        {
            delete m_pMetaCache;
            m_pMetaCache = NULL;
        }
    }
    
    if ( m_pMetaCache == NULL )
    {
        goto Failure;
    }
    
    //
    // UL response cache
    //
    
    m_pUlCache = new UL_RESPONSE_CACHE;
    if ( m_pUlCache != NULL )
    {
        hr = m_pUlCache->Initialize();
        if ( FAILED( hr ) ) 
        {
            delete m_pUlCache;
            m_pUlCache = NULL;
        }
    }
    
    if ( m_pUlCache == NULL )
    {
        goto Failure;
    }
    
    //
    // Now initialize the manager and register the caches
    //
    
    DBG_ASSERT( m_pMetaBase != NULL );
    
    hr = W3CacheInitialize( m_pMetaBase );
    if ( FAILED( hr ) )
    {
        goto Failure;
    }
    fCacheInit = TRUE;
    
    hr = W3CacheRegisterCache( m_pMetaCache );
    if ( FAILED( hr ) )
    {
        goto Failure;
    }
    
    hr = W3CacheRegisterCache( m_pFileCache );
    if ( FAILED( hr ) )
    {
        goto Failure;
    }
    
    hr = W3CacheRegisterCache( m_pTokenCache );
    if ( FAILED( hr ) )
    {
        goto Failure;
    }

    hr = W3CacheRegisterCache( m_pDigestContextCache );
    if ( FAILED( hr ) )
    {
        goto Failure;
    }
    
    hr = W3CacheRegisterCache( m_pUrlInfoCache );
    if ( FAILED( hr ) )
    {
        goto Failure;
    }
    
    hr = W3CacheRegisterCache( m_pUlCache );
    if ( FAILED( hr ) )
    {
        goto Failure;
    }
   
    return NO_ERROR;

Failure:

    if ( fCacheInit )
    {
        W3CacheTerminate();
    }

    if ( m_pMetaCache != NULL )
    {
        delete m_pMetaCache;
        m_pMetaCache = NULL;
    }
    
    if ( m_pFileCache != NULL )
    {
        delete m_pFileCache;
        m_pFileCache = NULL;
    }
    
    if ( m_pTokenCache != NULL )
    {
        delete m_pTokenCache;
        m_pTokenCache = NULL;
    }

    if( m_pDigestContextCache != NULL )
    {
        delete m_pDigestContextCache;
        m_pDigestContextCache = NULL;
    }
    
    if ( m_pUrlInfoCache != NULL )
    {
        delete m_pUrlInfoCache;
        m_pUrlInfoCache = NULL;
    }
    
    if ( m_pUlCache != NULL )
    {
        delete m_pUlCache;
        m_pUlCache = NULL;
    }
    
    return hr;
}

HRESULT
W3_SERVER::HandleMetabaseChange(
    const MD_CHANGE_OBJECT & ChangeObject
    )
/*++

Routine Description:

    Handle change notifications from the metabase.
    The change object will contain a change to
    /LM/W3SVC/ or lower in the metabase tree.

    Changes to /LM/W3SVC/ may alter W3_SERVER and
    are passed to all sites in the site list.

    Changes to /LM/W3SVC/{site id}/ or lower will
    affect only one site so are just passed on.

Arguments:
    
    ChangeObject
    
Return Value:

CODEWORK - Partial implementation 1/26/00 - TaylorW

--*/
{
    DBGPRINTF(( DBG_CONTEXT,
                "W3_SERVER Notfied - Path(%S) Type(%d) NumIds(%08x)\n",
                ChangeObject.pszMDPath,
                ChangeObject.dwMDChangeType,
                ChangeObject.dwMDNumDataIDs 
                ));

    HRESULT hr = NOERROR;
    BOOL    IsPathW3 = FALSE;
    BOOL    IsPathSite = FALSE;

    //
    // Find the instance id if present
    //
    
    DWORD   SiteId;
    LPWSTR  SiteIdString = ChangeObject.pszMDPath + W3_SERVER_MB_PATH_CCH;
    LPWSTR  StringEnd;


    if( SiteIdString[0] == L'\0' )
    {
        IsPathW3 = TRUE;
    }
    else
    {
        SiteId = wcstoul( SiteIdString, &StringEnd, 10 );

        if( SiteId != 0 )
        {
            IsPathSite = TRUE;
        }
    }

    W3_SITE *   Site = NULL;

    if( IsPathSite )
    {
        //
        // We just need to notify a specific site
        //
        DBG_ASSERT( SiteId );
        Site = FindSite(SiteId);
        if (Site != NULL)
        {
            hr = Site->HandleMetabaseChange( ChangeObject );
            Site->DereferenceSite();
        }
    }
    else if( IsPathW3 )
    {
        //
        // We need to notify every site
        //

        m_pSiteList->WriteLock();

        W3_SITE_LIST TempSiteList;

        for (W3_SITE_LIST::iterator iter = m_pSiteList->begin();
             iter != m_pSiteList->end();
             ++iter)
        {
            Site = iter.Record();
            
            Site->HandleMetabaseChange( ChangeObject, &TempSiteList );
        }

        m_pSiteList->Clear();
        m_cSites = 0;

        for (W3_SITE_LIST::iterator iter = TempSiteList.begin();
             iter != TempSiteList.end();
             ++iter)
        {
            Site = iter.Record();
            
            AddSite(Site);
        }

        m_pSiteList->WriteUnlock();

        //
        // Handle changes to this object's data
        //
        // At this point all we care about is data changes
        //

        if( (ChangeObject.dwMDChangeType & MD_CHANGE_TYPE_DELETE_DATA) ||
            (ChangeObject.dwMDChangeType & MD_CHANGE_TYPE_SET_DATA) )
        {
            DWORD n;

            for ( n = 0; n < ChangeObject.dwMDNumDataIDs; n++ )
            {
                if ( ChangeObject.pdwMDDataIDs[n] == MD_WEB_SVC_EXT_RESTRICTION_LIST )
                {
                    hr = InitializeRestrictionList( IsapiRestrictionList );

                    if ( FAILED( hr ) )
                    {
                        DBGPRINTF(( DBG_CONTEXT,
                                    "Failed to initialize IsapiRestrictionList "
                                    "on a metabase change.  Error 0x%08x.\r\n",
                                    hr ));
                    }

                    hr = InitializeRestrictionList( CgiRestrictionList );

                    if ( FAILED( hr ) )
                    {
                        DBGPRINTF(( DBG_CONTEXT,
                                    "Failed to initialize CgiRestrictionList "
                                    "on a metabase change.  Error 0x%08x.\r\n",
                                    hr ));
                    }
                }
            }
        }
    }
    
    return S_OK;
}

//static
VOID
W3_SERVER::OnShutdown(
    BOOL fDoImmediate
)
/*++

Routine Description:

    Called right after IPM indication of shutdown (but before drain)

Arguments:

    None    
    
Return Value:

    None

--*/
{
    if (g_pW3Server->m_fInBackwardCompatibilityMode)
    {
        RAW_CONNECTION::StopListening();
    }

    if (fDoImmediate)
    {
        W3_CGI_HANDLER::KillAllCgis();
    }
}

HRESULT W3_SERVER::CollectCounters(PBYTE *ppCounterData,
                                   DWORD *pdwCounterData)
{
    //
    // Initialize to null
    //
    *ppCounterData = NULL;
    *pdwCounterData = 0;

    //
    // Make sure we have enough memory
    //
    DWORD dwCounterBufferNeeded = sizeof(IISWPSiteCounters) * m_cSites +
        sizeof(IISWPGlobalCounters) + sizeof(ULONGLONG);
    if (m_pCounterDataBuffer == NULL)
    {
        m_pCounterDataBuffer = (PBYTE)LocalAlloc(LMEM_FIXED, dwCounterBufferNeeded);
        if (m_pCounterDataBuffer == NULL)
        {
            return HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
        }
        m_dwCounterDataBuffer = dwCounterBufferNeeded;
    }
    else if (m_dwCounterDataBuffer < dwCounterBufferNeeded)
    {
        BYTE *pCounterDataBuffer = (PBYTE)LocalReAlloc(m_pCounterDataBuffer,
                                                       dwCounterBufferNeeded,
                                                       LMEM_MOVEABLE);
        if (pCounterDataBuffer == NULL)
        {
            return HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
        }
        m_pCounterDataBuffer = pCounterDataBuffer;
        m_dwCounterDataBuffer = dwCounterBufferNeeded;
    }

    m_pSiteList->ReadLock();

    //
    // Get the Site counters
    //
    DWORD i = 0;
    for (W3_SITE_LIST::iterator iter = m_pSiteList->begin();
         iter != m_pSiteList->end();
         ++iter, ++i)
    {
        //
        // In case some more new sites got added in between, skip them for now
        //
        if ((i+1)*sizeof(IISWPSiteCounters) + sizeof(IISWPGlobalCounters) >=
            m_dwCounterDataBuffer)
        {
            break;
        }

        W3_SITE *pSite = iter.Record();

        pSite->GetStatistics((IISWPSiteCounters *)
            (m_pCounterDataBuffer +
             i*sizeof(IISWPSiteCounters) + sizeof(DWORD)));
    }

    m_pSiteList->ReadUnlock();

    //
    // Set the number of sites
    //
    *(DWORD *)m_pCounterDataBuffer = i;

    //
    // Get the Global counters
    //

    IISWPGlobalCounters *pCacheCtrs = (IISWPGlobalCounters *)
        (m_pCounterDataBuffer + i*sizeof(IISWPSiteCounters) + sizeof(DWORD));

    //
    // This contains some ULONGLONG values so align it, this is how WAS
    // expects it
    //
    pCacheCtrs = (IISWPGlobalCounters *)(((DWORD_PTR)pCacheCtrs + 7) & ~7);
    GetCacheStatistics(pCacheCtrs);

    *ppCounterData = m_pCounterDataBuffer;
    *pdwCounterData = (DWORD)DIFF((LPBYTE)pCacheCtrs - m_pCounterDataBuffer) + sizeof(IISWPGlobalCounters);

    return S_OK;
}

VOID
W3_SERVER::GetCacheStatistics(
    IISWPGlobalCounters *           pCacheCtrs
)
/*++

  Routine Description:

    Get cache statistics for perfmon purposes

  Arguments:

    pCacheCtrs - Receives the statistics for cache

  Notes:
    CacheBytesTotal and CacheBytesInUse are not kept on a per-server basis
        so they are only returned when retrieving summary statistics.

  Returns:

    None
    
--*/
{
    //
    // Get file cache statistics
    //
    
    if ( m_pFileCache != NULL )
    {
        pCacheCtrs->CurrentFilesCached = m_pFileCache->PerfQueryCurrentEntryCount();
        pCacheCtrs->TotalFilesCached   = m_pFileCache->PerfQueryTotalEntriesCached();
        pCacheCtrs->FileCacheHits      = m_pFileCache->PerfQueryHits();
        pCacheCtrs->FileCacheMisses    = m_pFileCache->PerfQueryMisses();
        pCacheCtrs->FileCacheFlushes   = m_pFileCache->PerfQueryFlushCalls();
        pCacheCtrs->ActiveFlushedFiles = m_pFileCache->PerfQueryActiveFlushedEntries();
        pCacheCtrs->TotalFlushedFiles  = m_pFileCache->PerfQueryFlushes();
        pCacheCtrs->CurrentFileCacheMemoryUsage = m_pFileCache->PerfQueryCurrentMemCacheSize();
        pCacheCtrs->MaxFileCacheMemoryUsage = m_pFileCache->PerfQueryMaxMemCacheSize();
    }
    
    //
    // Get URI cache statistics
    //
    
    if ( m_pUrlInfoCache != NULL )
    {
        pCacheCtrs->CurrentUrisCached = m_pUrlInfoCache->PerfQueryCurrentEntryCount();
        pCacheCtrs->TotalUrisCached   = m_pUrlInfoCache->PerfQueryTotalEntriesCached();
        pCacheCtrs->UriCacheHits      = m_pUrlInfoCache->PerfQueryHits();
        pCacheCtrs->UriCacheMisses    = m_pUrlInfoCache->PerfQueryMisses();
        pCacheCtrs->UriCacheFlushes   = m_pUrlInfoCache->PerfQueryFlushCalls();
        pCacheCtrs->TotalFlushedUris  = m_pUrlInfoCache->PerfQueryFlushes();
    }
    
    //
    // BLOB cache counters (actually since there is no blob cache we will
    // sub in the metacache counters which are more interesting since 
    // metacache misses are really painful
    //

    if ( m_pMetaCache != NULL )
    {
        pCacheCtrs->CurrentBlobsCached = m_pMetaCache->PerfQueryCurrentEntryCount();
        pCacheCtrs->TotalBlobsCached   = m_pMetaCache->PerfQueryTotalEntriesCached();
        pCacheCtrs->BlobCacheHits      = m_pMetaCache->PerfQueryHits();
        pCacheCtrs->BlobCacheMisses    = m_pMetaCache->PerfQueryMisses();
        pCacheCtrs->BlobCacheFlushes   = m_pMetaCache->PerfQueryFlushCalls();
        pCacheCtrs->TotalFlushedBlobs  = m_pMetaCache->PerfQueryFlushes();
    }
}

HRESULT
W3_SERVER::ReadUseDigestSSP(
    VOID
)
/*++
  Routine description:
    Read the UseDigestSSP property from the metabase

  Arguments:
    none

  Return Value:
    HRESULT
--*/
{
    MB mb( QueryMDObject() );

    if ( !mb.Open( QueryMDPath() ) )
    {
        return HRESULT_FROM_WIN32(GetLastError());
    }

    if ( !mb.GetDword( L"",
                       MD_USE_DIGEST_SSP,
                       IIS_MD_UT_SERVER,
                       ( DWORD * )&m_fUseDigestSSP,
                       0 ) )
    {
        m_fUseDigestSSP = TRUE;
    }

    mb.Close();

    return S_OK;
}

HRESULT
W3_SERVER::InitializeRestrictionList(
    RESTRICTION_LIST_TYPE   ListType
    )
{
    W3_RESTRICTION_LIST *   pNewRestrictionList = NULL;
    MULTISZ                 msz;
    BOOL                    fResult;

    DBG_ASSERT( m_pMetaBase );
    DBG_ASSERT( ListType == IsapiRestrictionList ||
                ListType == CgiRestrictionList );

    //
    // Get the metadata
    //

    MB  mb( m_pMetaBase );

    if ( !mb.Open( L"/LM/W3SVC/" ) )
    {
        return HRESULT_FROM_WIN32( GetLastError() );
    }

    fResult = mb.GetMultisz( L"",
                             MD_WEB_SVC_EXT_RESTRICTION_LIST,
                             IIS_MD_UT_SERVER,
                             &msz );

    if ( !fResult )
    {
        //
        // If we fail to get the metadata, use default data
        //

        msz.Reset();

        fResult = msz.Append( L"0,*.dll" );

        if ( fResult )
        {
            fResult = msz.Append( L"0,*.exe" );
        }
    }

    mb.Close();

    if ( !fResult )
    {
        return HRESULT_FROM_WIN32( GetLastError() );
    }

    //
    // Create the new list
    //

    pNewRestrictionList = CreateRestrictionList( &msz,
                                                 ListType );

    if ( pNewRestrictionList == NULL )
    {
        return HRESULT_FROM_WIN32( GetLastError() );
    }

    //
    // Swap in the new list
    //

    if ( ListType == IsapiRestrictionList )
    {
        m_IsapiRestrictionLock.WriteLock();

        //
        // Release the old list and put in the new one
        //

        if ( m_pIsapiRestrictionList != NULL )
        {
            m_pIsapiRestrictionList->DereferenceRestrictionList();
        }

        m_pIsapiRestrictionList = pNewRestrictionList;
        
        m_fDavEnabled = pNewRestrictionList->IsImageEnabled(W3_DAV_HANDLER::QueryDavImage());

        m_IsapiRestrictionLock.WriteUnlock();
    }
    else
    {
        m_CgiRestrictionLock.WriteLock();

        //
        // Release the old list and put in the new one
        //

        if ( m_pCgiRestrictionList != NULL )
        {
            m_pCgiRestrictionList->DereferenceRestrictionList();
        }

        m_pCgiRestrictionList = pNewRestrictionList;

        m_CgiRestrictionLock.WriteUnlock();
    }

    return NOERROR;
}

W3_RESTRICTION_LIST *
W3_SERVER::CreateRestrictionList(
    MULTISZ *               pmszImageList,
    RESTRICTION_LIST_TYPE   ListType
    )
{
    W3_RESTRICTION_LIST *   pNewRestrictionList;
    DWORD                   dwNumStrings;
    HRESULT                 hr = NOERROR;

    DBG_ASSERT( pmszImageList );

    //
    // Get the string count
    //

    dwNumStrings = pmszImageList->QueryStringCount();

    if ( dwNumStrings == 0 )
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        return NULL;
    }

    //
    // Allocate a new restriction list object
    //

    pNewRestrictionList = new W3_RESTRICTION_LIST;

    if ( pNewRestrictionList == NULL )
    {
        SetLastError( ERROR_NOT_ENOUGH_MEMORY );
        return NULL;
    }

    //
    // Initialize it and return the result
    //

    hr = pNewRestrictionList->Create( pmszImageList,
                                      ListType );

    if ( FAILED( hr ) )
    {
        pNewRestrictionList->DereferenceRestrictionList();
        pNewRestrictionList = NULL;

        SetLastError( WIN32_FROM_HRESULT( hr ) );
        return NULL;
    }

    return pNewRestrictionList;
}

BOOL
W3_SERVER::QueryIsIsapiImageEnabled(
    LPCWSTR szImage
)
{
    W3_RESTRICTION_LIST *   pRestrictionList;
    BOOL                    fRet;

    //
    // Acquire a read lock on the IsapiRestrictionList so
    // that we can AddRef it without fear of a metabase
    // update invalidating it first.
    //

    m_IsapiRestrictionLock.ReadLock();

    pRestrictionList = m_pIsapiRestrictionList;

    DBG_ASSERT( pRestrictionList );

    pRestrictionList->ReferenceRestrictionList();

    m_IsapiRestrictionLock.ReadUnlock();

    fRet = pRestrictionList->IsImageEnabled( szImage );

    pRestrictionList->DereferenceRestrictionList();
    pRestrictionList = NULL;

    return fRet;
}

BOOL
W3_SERVER::QueryIsCgiImageEnabled(
    LPCWSTR szImage
)
{
    W3_RESTRICTION_LIST *   pRestrictionList;
    BOOL                    fRet;

    //
    // Acquire a read lock on the IsapiRestrictionList so
    // that we can AddRef it without fear of a metabase
    // update invalidating it first.
    //

    m_CgiRestrictionLock.ReadLock();

    pRestrictionList = m_pCgiRestrictionList;

    DBG_ASSERT( pRestrictionList );

    pRestrictionList->ReferenceRestrictionList();

    m_CgiRestrictionLock.ReadUnlock();

    fRet = pRestrictionList->IsImageEnabled( szImage );

    pRestrictionList->DereferenceRestrictionList();
    pRestrictionList = NULL;

    return fRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\iisplus\ulw3\w3site.cxx ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    w3site.cxx

Abstract:

    W3_SITE object holds state for each site

Author:

    Anil Ruia (AnilR)              18-Jan-2000

Revision History:

--*/

#include "precomp.hxx"

// 
// No advance notification
//
#define DEFAULT_W3_ADV_NOT_PWD_EXP_IN_DAYS   14

//
// OWA change flags
//
#define DEFAULT_W3_AUTH_CHANGE_FLAGS          6

//
// In seconds
//
#define DEFAULT_W3_ADV_CACHE_TTL              ( 10 * 60 ) 

//static
CRITICAL_SECTION   W3_SITE::sm_csIISCertMapLock;

W3_SITE::W3_SITE( 
    DWORD           SiteId 
) : m_SiteId                          ( SiteId ),
    m_cRefs                           ( 1 ),
    m_pInstanceFilterList             ( NULL ),
    m_pLogging                        ( NULL ),
    m_fAllowPathInfoForScriptMappings ( FALSE ),
    m_fUseDSMapper                    ( FALSE ),
    m_dwAuthChangeFlags               ( 0 ),
    m_dwAdvNotPwdExpInDays            ( DEFAULT_W3_ADV_NOT_PWD_EXP_IN_DAYS ),
    m_dwAdvCacheTTL                   ( DEFAULT_W3_ADV_CACHE_TTL ),
    m_fSSLSupported                   ( FALSE ),
    m_pIISCertMap                     ( NULL ),
    m_fAlreadyAttemptedToLoadIISCertMap    ( FALSE ),
    m_pDataSetCache                   ( NULL ),
    m_Signature                       ( W3_SITE_SIGNATURE )
{
    ZeroMemory(&m_PerfCounters, sizeof m_PerfCounters);
}

W3_SITE::~W3_SITE()
{
    if (m_pInstanceFilterList != NULL)
    {
        m_pInstanceFilterList->Dereference();
        m_pInstanceFilterList = NULL;
    }
    
    if (m_pLogging != NULL)
    {
        m_pLogging->Release();
        m_pLogging = NULL;
    }

    if ( m_pIISCertMap != NULL )
    {
        m_pIISCertMap->DereferenceCertMapping();
        m_pIISCertMap = NULL;
    }
    
    if ( m_pDataSetCache != NULL )
    {
        m_pDataSetCache->DereferenceDataSetCache();
        m_pDataSetCache = NULL;
    }
    
    m_Signature = W3_SITE_SIGNATURE_FREE;
}

HRESULT
W3_SITE::Initialize(LOGGING *pLogging,
                    FILTER_LIST *pFilterList)
/*++

Routine Description:

    Initialize W3_SITE.  Should be called after constructor

Arguments:
    
    None
    
Return Value:

    HRESULT

--*/
{
    HRESULT     hr = NO_ERROR;
    WCHAR       idToStr[MAX_SITEID_LENGTH + 6];
    CHAR        idToStrA[MAX_SITEID_LENGTH + 6];

    //
    // Setup Site Name like "W3SVC1"
    //

    sprintf(idToStrA, "W3SVC%u", m_SiteId);
    if (FAILED(hr = m_SiteName.Copy(idToStrA)))
    {
        goto Failure;
    }

    //
    // Setup site path (like "/LM/W3SVC/1")
    //

    hr = m_SiteMBPath.Copy(g_pW3Server->QueryMDPath());
    if ( FAILED( hr ) )
    {
        goto Failure;
    }

    _itow(m_SiteId, idToStr, 10);

    hr = m_SiteMBPath.Append( idToStr );
    if ( FAILED( hr ) )
    {
        goto Failure;
    }

    //
    // Setup site root (like "/LM/W3SVC/1/ROOT/")
    //

    hr = m_SiteMBRoot.Copy( m_SiteMBPath );
    if ( FAILED( hr ) )
    {
        goto Failure;
    }

    hr = m_SiteMBRoot.Append( L"/Root/" );
    if ( FAILED( hr ) )
    {
        goto Failure;
    }

    //
    // Read the per-site properties from the metabase
    //
    if (FAILED(hr = ReadPrivateProperties()))
    {
        goto Failure;
    }

    //
    // Initialize instance filters
    //
    if (pFilterList)
    {
        pFilterList->Reference();
        m_pInstanceFilterList = pFilterList;
    }
    else
    {
        m_pInstanceFilterList = new FILTER_LIST();
        if (m_pInstanceFilterList == NULL)
        {
            hr = HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
            goto Failure;
        }

        hr = m_pInstanceFilterList->InsertGlobalFilters();
        if (FAILED(hr))
        {
            goto Failure;
        }

        hr = m_pInstanceFilterList->LoadFilters( m_SiteMBPath.QueryStr(),
                                                 FALSE,
                                                 TRUE );
        if (FAILED(hr))
        {
            goto Failure;
        }
    }
    
    //
    // Initialize logging
    //
    if (pLogging)
    {
        pLogging->AddRef();
        m_pLogging = pLogging;
    }
    else
    {
        m_pLogging = new LOGGING;
        if (m_pLogging == NULL)
        {
            hr = HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
            goto Failure;
        }

        if (FAILED(hr = m_pLogging->ActivateLogging(m_SiteName.QueryStr(),
                                                    m_SiteMBPath.QueryStr(),
                                                    g_pW3Server->QueryMDObject(),
                                                    g_pW3Server->QueryDoCentralBinaryLogging())))
        {
            LPCWSTR apsz[1];
            apsz[0] = idToStr;
            g_pW3Server->LogEvent(W3_EVENT_LOGGING_MODULE_FAILED_TO_LOAD,
                                  1,
                                  apsz);

            goto Failure;
        }
    }
    
    return S_OK;
    
Failure:
    return hr;
}

HRESULT W3_SITE::ReadPrivateProperties()
/*++
  Routine description:
    Read the site specific properties from the metabase

  Arguments:
    none

  Return Value:
    HRESULT
--*/
{
    MB mb( g_pW3Server->QueryMDObject() );
    MULTISZ mszSecureBindings;

    //
    // Read per-site properties from the metabase
    //
    if ( !mb.Open(m_SiteMBPath.QueryStr()) )
    {
        return HRESULT_FROM_WIN32(GetLastError());
    }

    if ( !mb.GetDword(L"",
                     MD_ALLOW_PATH_INFO_FOR_SCRIPT_MAPPINGS,
                     IIS_MD_UT_FILE,
                     (DWORD *)&m_fAllowPathInfoForScriptMappings,
                     0) )
    {
        m_fAllowPathInfoForScriptMappings = FALSE;
    }

    mb.GetStr( L"",
               MD_AUTH_CHANGE_URL,
               IIS_MD_UT_SERVER,
               &m_strAuthChangeUrl );

    mb.GetStr( L"",
               MD_AUTH_EXPIRED_URL,
               IIS_MD_UT_SERVER,
               &m_strAuthExpiredUrl );

    mb.GetStr( L"",
               MD_AUTH_NOTIFY_PWD_EXP_URL,
               IIS_MD_UT_SERVER,
               &m_strAdvNotPwdExpUrl );

    mb.GetStr( L"",
               MD_AUTH_EXPIRED_UNSECUREURL,
               IIS_MD_UT_SERVER,
               &m_strAuthExpiredUnsecureUrl );

    mb.GetStr( L"",
               MD_AUTH_NOTIFY_PWD_EXP_UNSECUREURL,
               IIS_MD_UT_SERVER,
               &m_strAdvNotPwdExpUnsecureUrl );

    if ( !mb.GetDword( L"",
                       MD_ADV_NOTIFY_PWD_EXP_IN_DAYS,
                       IIS_MD_UT_SERVER,
                       &m_dwAdvNotPwdExpInDays ) )
    {
        m_dwAdvNotPwdExpInDays = DEFAULT_W3_ADV_NOT_PWD_EXP_IN_DAYS;
    }

    if ( !mb.GetDword( L"",
                       MD_AUTH_CHANGE_FLAGS,
                       IIS_MD_UT_SERVER,
                       &m_dwAuthChangeFlags ) )
    {
        m_dwAuthChangeFlags = DEFAULT_W3_AUTH_CHANGE_FLAGS;
    }

    if ( !mb.GetDword( L"",
                       MD_ADV_CACHE_TTL,
                       IIS_MD_UT_SERVER,
                       &m_dwAdvCacheTTL ) )
    {
        m_dwAdvCacheTTL = DEFAULT_W3_ADV_CACHE_TTL;
    }

    //
    // Read the secure bindings.
    //
    
    if ( mb.GetMultisz( L"",
                        MD_SECURE_BINDINGS,
                        IIS_MD_UT_SERVER,
                        &mszSecureBindings ) )
    {
        if( !mszSecureBindings.IsEmpty() )
        {
            m_fSSLSupported = TRUE;
        }
    }

    DBG_REQUIRE( mb.Close() );

    //
    // Read global properties from the metabase that affect site config
    //

    if ( !mb.Open(g_pW3Server->QueryMDPath()) )
    {
        return HRESULT_FROM_WIN32(GetLastError());
    }

    if ( !mb.GetDword( L"",
                       MD_SSL_USE_DS_MAPPER,
                       IIS_MD_UT_SERVER,
                       (DWORD*) &m_fUseDSMapper,
                       0 ))
    {
        m_fUseDSMapper = FALSE;
    }

    DBG_REQUIRE( mb.Close() );

    return S_OK;
}

HRESULT
W3_SITE::HandleMetabaseChange(
    const MD_CHANGE_OBJECT &ChangeObject,
    IN    W3_SITE_LIST     *pTempSiteList
    )
/*++

Routine Description:

    Handle metabase changes. The change may be to
    either the /LM/W3SVC/ node or they may be
    changes to this site or one of its children.

    This routine needs to perform cache flushes
    and reget site metadata if necessary.


Arguments:
    
    ChangeObject
    
Return Value:

See W3_SERVER_INSTANCE::MDChangeNotify and
    IIS_SERVER_INSTANCE::MDChangeNotify for
    implemenation details

--*/
{
    DBGPRINTF(( DBG_CONTEXT,
                "W3_SITE Notified - Path(%S) Type(%d) NumIds(%08x)\n",
                ChangeObject.pszMDPath,
                ChangeObject.dwMDChangeType,
                ChangeObject.dwMDNumDataIDs 
                ));

    if (ChangeObject.dwMDChangeType == MD_CHANGE_TYPE_SET_DATA)
    {
        BOOL fDontCare = TRUE;

        //
        // Find out if we care about these properties
        // We definitely don't care about ServerState or Win32Error
        //
        for (DWORD i = 0; i < ChangeObject.dwMDNumDataIDs; i++)
        {
            DWORD PropertyID = ChangeObject.pdwMDDataIDs[i];

            if (PropertyID != MD_SERVER_STATE &&
                PropertyID != MD_WIN32_ERROR &&
                PropertyID != MD_SERVER_AUTOSTART)
            {
                fDontCare = FALSE;
                break;
            }
        }

        if (fDontCare)
        {
            return S_OK;
        }
    }

    //
    // Let the cache manager invalidate the various cache entries dependent
    // on metadata
    //

    W3CacheDoMetadataInvalidation( ChangeObject.pszMDPath, 
                                   (DWORD)wcslen( ChangeObject.pszMDPath ) );

    //
    // Get rid of the data set cache if we have one
    //
    
    RemoveDataSetCache();

    //
    // Handle any site level change
    // That means any changes at /LM/w3svc/ or /LM/w3svc/n/ or
    // /LM/w3svc/n/Filters/
    //
    // IIS 1to1 Client certificate mappings are stored
    // under /Cert11/Mappings/ on the site level. Any change in mappings
    // will cause recreation of W3_SITE instance
    // This is not optimal but changes in 1to1 Cert mappings are not frequent
    // and feature itself is not used by many customers
    // so there should be no problems with this approach.
    //
    
    if ((_wcsicmp(ChangeObject.pszMDPath,
                  W3_SERVER_MB_PATH) == 0) ||
        ((_wcsnicmp(ChangeObject.pszMDPath,
                    m_SiteMBPath.QueryStr(),
                    m_SiteMBPath.QueryCCH()) == 0) &&
         ((wcscmp(ChangeObject.pszMDPath + m_SiteMBPath.QueryCCH(),
                  L"/") == 0) ||
          (_wcsicmp(ChangeObject.pszMDPath + m_SiteMBPath.QueryCCH(),
                    L"/Filters/") == 0) ||
          (_wcsnicmp(ChangeObject.pszMDPath + m_SiteMBPath.QueryCCH(),
                    L"/Cert11/Mappings/", wcslen(L"/Cert11/Mappings/") ) == 0)
                    )))
    {
        //
        // If the site (or its root application) has been deleted, remove it
        // unless we are in the iterator in which case it will anyway be
        // removed
        //
        if (ChangeObject.dwMDChangeType == MD_CHANGE_TYPE_DELETE_OBJECT)
        {
            if (pTempSiteList == NULL)
            {
                g_pW3Server->RemoveSite(this);
            }

            return S_OK;
        }

        //
        // Now handle any property changes.
        //

        BOOL fLoggingHasChanged = FALSE;
        BOOL fFiltersHaveChanged = FALSE;

        //
        // Find out if we would need to handle any logging or filter changes
        //
        for (DWORD i = 0; i < ChangeObject.dwMDNumDataIDs; i++)
        {
            DWORD PropertyID = ChangeObject.pdwMDDataIDs[i];

            if (((PropertyID >= IIS_MD_LOG_BASE) &&
                 (PropertyID <= IIS_MD_LOG_LAST)) ||
                ((PropertyID >= IIS_MD_LOGCUSTOM_BASE) &&
                 (PropertyID <= IIS_MD_LOGCUSTOM_LAST)))
            {
                fLoggingHasChanged = TRUE;
            }
            else if (PropertyID == MD_FILTER_LOAD_ORDER)
            {
                fFiltersHaveChanged = TRUE;
            }
        }

        //
        // Create a new site
        //
        W3_SITE *site = new W3_SITE(m_SiteId);
        if (site == NULL)
        {
            return HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
        }

        //
        // Copy over the cache context, and also logging and filter info
        // if applicable
        //
        HRESULT hr;
        if (FAILED(hr = site->Initialize(
                            fLoggingHasChanged ? NULL : m_pLogging,
                            fFiltersHaveChanged ? NULL : m_pInstanceFilterList)))
        {
            site->DereferenceSite();
            return hr;
        }

        //
        // Depending on whether we are in the iterator, either replace the
        // site in the site list or add it to the temp list which will replace
        // the real list later
        //
        if (pTempSiteList == NULL)
        {
            g_pW3Server->AddSite(site, true);
        }
        else
        {
            pTempSiteList->InsertRecord(site);
        }

        // Release the extra reference
        site->DereferenceSite();
    }

    return S_OK;
}

VOID
W3_SITE::RemoveDataSetCache(
    VOID
)
/*++

Routine Description:

    Remove data set cache

Arguments:

    None
    
Return Value:

    None

--*/
{
    m_DataSetCacheLock.WriteLock();
    
    if ( m_pDataSetCache != NULL )
    {
        m_pDataSetCache->DereferenceDataSetCache();
        m_pDataSetCache = NULL;
    }
    
    m_DataSetCacheLock.WriteUnlock();
}

HRESULT
W3_SITE::GetDataSetCache(
    DATA_SET_CACHE **           ppDataSetCache
)
/*++

Routine Description:

    Retrieve a data set cache for this site

Arguments:

    ppDataSetCache - Set to point to data set cache on success
    
Return Value:

    HRESULT

--*/
{
    DATA_SET_CACHE *            pDataSetCache;
    HRESULT                     hr;
    HANDLE                      hToken = NULL;
    
    if ( ppDataSetCache == NULL )
    {
        DBG_ASSERT( FALSE );
        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }
    
    *ppDataSetCache = NULL;
    
    m_DataSetCacheLock.ReadLock();
    
    if ( m_pDataSetCache != NULL )
    {
        m_pDataSetCache->ReferenceDataSetCache();
        *ppDataSetCache = m_pDataSetCache;
        
        m_DataSetCacheLock.ReadUnlock();
    }
    else
    {
        m_DataSetCacheLock.ReadUnlock();

        if ( OpenThreadToken( GetCurrentThread(),
                              TOKEN_IMPERSONATE,
                              TRUE,
                              &hToken ) )
        {
            DBG_ASSERT( hToken != NULL );
            DBG_REQUIRE( RevertToSelf() );
        }

        // Create a data set cache and then try to add it
        //
        
        pDataSetCache = new DATA_SET_CACHE;
        if ( pDataSetCache == NULL )
        {
            hr = HRESULT_FROM_WIN32( GetLastError() );
            goto Finished;
        }    
        
        hr = pDataSetCache->Create( *QueryMBRoot() );
        if ( FAILED( hr ) )
        {
            pDataSetCache->DereferenceDataSetCache();
            goto Finished;
        }
        
        if ( hToken != NULL )
        {
            DBG_REQUIRE( SetThreadToken( NULL, hToken ) );
            DBG_REQUIRE( CloseHandle( hToken ) );
            hToken = NULL;
        }

        //
        //
        // Try to add it
        //
        
        m_DataSetCacheLock.WriteLock();
        
        if ( m_pDataSetCache != NULL )
        {
            //
            // Someone else added it.  No problem -> we'll just kill the one
            // we just created
            //
            
            pDataSetCache->DereferenceDataSetCache();
        }
        else
        {
            m_pDataSetCache = pDataSetCache;
        }
        
        m_pDataSetCache->ReferenceDataSetCache();
        *ppDataSetCache = m_pDataSetCache;
        
        m_DataSetCacheLock.WriteUnlock();
    }
    
    DBG_ASSERT( *ppDataSetCache != NULL );

    return S_OK;

 Finished:
    if ( hToken != NULL )
    {
        DBG_REQUIRE( SetThreadToken( NULL, hToken ) );
        DBG_REQUIRE( CloseHandle( hToken ) );
        hToken = NULL;
    }

    return hr;
}

HRESULT
W3_SITE::GetIISCertificateMapping(
    IIS_CERTIFICATE_MAPPING ** ppIISCertificateMapping
    )
/*++

Routine Description:


Arguments:
    
    ppIISCertificateMapping - returns found iis cert mapping object

    m_pIISCertMap is created on demand. It will not be
    created when W3_SITE is created, only when first request that requires
    certificate mappings
    
Return Value:

    HRESULT

--*/


{
    HRESULT hr = E_FAIL;
    
    DBG_ASSERT( ppIISCertificateMapping != NULL );
        
    
    if ( m_fAlreadyAttemptedToLoadIISCertMap )
    {
        *ppIISCertificateMapping = m_pIISCertMap;
        hr = S_OK;
        goto Finished;
    }
    else
    {
        IIS_CERTIFICATE_MAPPING * pCertMap = NULL;

        //
        // This lock only applies when certmapping was not yet read
        // Global lock will only apply for reading certmapper for site
        // on the very first attempt to fetch file that enables 
        // IIS certmapping 
        //
        
        GlobalLockIISCertMap();

        //
        // try again to prevent loading of mapping multiple times
        //
        if ( m_fAlreadyAttemptedToLoadIISCertMap )
        {
            hr = S_OK;
        }
        else
        {
            //
            // build IIS Certificate mapping structure and
            // add update W3_SITE structure
            //
            if ( m_fUseDSMapper )
            {
                m_pIISCertMap = NULL;
                hr = S_OK;
            }
            else
            {
                hr = IIS_CERTIFICATE_MAPPING::GetCertificateMapping( m_SiteId,
                                                                     &pCertMap );
                if ( SUCCEEDED( hr ) )
                {
                    m_pIISCertMap = pCertMap;
                }
            }
            
            //
            // always set m_fAlreadyAttemptedToLoadIISCertMap to TRUE (regardless of error)
            // that would prevent reading mappings for each request in the case of failure
            // it is valid for m_pIISCertMap to be NULL (regardless of m_fAlreadyAttemptedToLoadIISCertMap)
            //
            
            InterlockedExchange( reinterpret_cast<LONG *>(&m_fAlreadyAttemptedToLoadIISCertMap),
                                 TRUE );
        }        
        GlobalUnlockIISCertMap();
        
        if ( FAILED( hr ) )
        {
            //
            // Write event that certificate mappings couldn't be read
            // This will be written only once per W3_SITE instance
            // so it should not cause any event log overflow troubles
            // (unless to many site parameters change notifications 
            // cause W3_SITE instance to be recreated over and 
            // over which is unlikely)
            //
            LPCWSTR apsz[1];
            WCHAR achSiteId[ 33 ]; // _ultow uses up to 33 characters 
            
            apsz[0] =_ultow( m_SiteId, achSiteId, 10 );

            g_pW3Server->LogEvent( W3_EVENT_CERTIFICATE_MAPPING_COULD_NOT_BE_LOADED,
                                   1,
                                   apsz,
                                   (DWORD) hr ); // we are not converting to WIN32 error
                                                 // not to lose HRESULT error
            goto Finished;
        }
    }
    *ppIISCertificateMapping = m_pIISCertMap;
    hr = S_OK;
Finished:
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\iisplus\ulw3\wam_process.cxx ===
/*++

   Copyright    (c)    1999    Microsoft Corporation

   Module Name :
     wam_process.cxx

   Abstract:
     Manages OOP ISAPI processes
 
   Author:
     Wade Hilmo (wadeh)             10-Oct-2000

   Environment:
     Win32 - User Mode

   Project:
     ULW3.DLL

--*/

#include <initguid.h>
#include "precomp.hxx"
#include "isapi_handler.h"
#include "iwam_i.c"
#include "wam_process.hxx"

WAM_PROCESS::WAM_PROCESS(
    LPCWSTR                 szWamClsid,
    WAM_PROCESS_MANAGER *   pWamProcessManager,
    LPCSTR                  szIsapiHandlerInstance
    )
    : _cCurrentRequests( 0 ),
      _cTotalRequests( 0 ),
      _cRefs( 1 ),
      _pWamProcessManager( pWamProcessManager ),
      _pIWam( NULL ),
      _bstrInstanceId( NULL ),
      _cMaxRequests( 0 ),
      _dwProcessId( 0 ),
      _hProcess( NULL ),
      _fGoingAway( FALSE ),
      _fCrashed( FALSE )
/*++

Routine Description:

    Constructor

Arguments:

    szWamClsid             - The CLSID of the WAM application to create
    pWamProcessManager     - A pointer to the WAM process manager
    szIsapiHandlerInstance - The instance ID of the ISAPI handler
                             that's creating this object.  Used for
                             debugging purposes

Return Value:

    None

--*/
{
    _pWamProcessManager->AddRef();

    InitializeListHead( &_RequestListHead );
    
    wcsncpy(
        _szWamClsid,
        szWamClsid,
        SIZE_CLSID_STRING
        );

    _szWamClsid[SIZE_CLSID_STRING - 1] = L'\0';

    strncpy(
        _szIsapiHandlerInstance,
        szIsapiHandlerInstance,
        SIZE_CLSID_STRING
        );

    _szIsapiHandlerInstance[SIZE_CLSID_STRING - 1] = '\0';

    INITIALIZE_CRITICAL_SECTION( &_csRequestList );
};

HRESULT
WAM_PROCESS::Create(
    LPCWSTR szApplMdPathW
    )
/*++

Routine Description:

    Initializes the parts of the WAM_PROCESS object not
    appropriate to the constructor.  This includes starting
    up the remote process via CoCreateInstance and collecting
    data about the process once it's running

Arguments:

    szApplMdPathW - The metabase path of the application

Return Value:

    HRESULT

--*/
{
    CLSID   clsid;
    HRESULT hr = NOERROR;
    LPWSTR  szIsapiModule;
    DWORD   cbIsapiModule;

    STACK_STRA( strClsid, SIZE_CLSID_STRING );

    IF_DEBUG( ISAPI )
    {
        DBGPRINTF((
            DBG_CONTEXT,
            "Creating WAM_PROCESS %p, CLSID=%S.\r\n",
            this,
            _szWamClsid
            ));
    }

    //
    // Get some info about the ISAPI module
    //

    DBG_REQUIRE( ( szIsapiModule = _pWamProcessManager->QueryIsapiModule() ) != NULL );
    cbIsapiModule = (DWORD)( wcslen( szIsapiModule ) + 1 ) * sizeof( WCHAR );

    //
    // Set the name for the WAM_PROCESS
    //

    if ( szApplMdPathW )
    {
        hr = _strApplMdPathW.Copy( szApplMdPathW );
    }
    else
    {
        hr = _strApplMdPathW.Copy( L"" );
    }

    if ( FAILED( hr ) )
    {
        goto ErrorExit;
    }

    //
    // Get the CLSID for this WAM_PROCESS
    //

    hr = CLSIDFromString(
        (LPOLESTR)_szWamClsid,
        &clsid
        );

    if ( FAILED( hr ) )
    {
        goto ErrorExit;
    }

    hr = strClsid.CopyW( _szWamClsid );

    if ( FAILED( hr ) )
    {
        goto ErrorExit;
    }

    //
    // CoCreate it
    //

    hr = CoCreateInstance(
        clsid,
        NULL,
        CLSCTX_LOCAL_SERVER,
        IID_IWam,
        (void**)&_pIWam
        );

    if ( FAILED( hr ) )
    {
        DBGPRINTF((
            DBG_CONTEXT,
            "WAM_PROCESS %p.  Failed to CoCreate WAM.\r\n",
            this
            ));

        _pIWam = NULL;

        goto ErrorExit;
    }

    //
    // Set the proxy blanket so that the client can't
    // impersonate us.
    //

    hr = CoSetProxyBlanket(
        _pIWam,
        RPC_C_AUTHN_DEFAULT,
        RPC_C_AUTHZ_DEFAULT,
        COLE_DEFAULT_PRINCIPAL,
        RPC_C_AUTHN_LEVEL_DEFAULT,
        RPC_C_IMP_LEVEL_IDENTIFY,
        COLE_DEFAULT_AUTHINFO,
        EOAC_DEFAULT
        );

    if ( FAILED( hr ) )
    {
        DBGPRINTF((
            DBG_CONTEXT,
            "WAM_PROCESS %p.  Failed to CoCreate WAM.\r\n",
            this
            ));

        goto ErrorExit;
    }


    //
    // Now initialize it.
    //

    _dwProcessId = 0;
    _hProcess = NULL;

    hr = _pIWam->WamInitProcess(
        (BYTE*)szIsapiModule,
        cbIsapiModule,
        &_dwProcessId,
        strClsid.QueryStr(),
        _szIsapiHandlerInstance,
        GetCurrentProcessId()
        );

    if ( FAILED( hr ) )
    {
        DBGPRINTF((
            DBG_CONTEXT,
            "WAM_PROCESS %p.  WamInitProcess failed.\r\n",
            this
            ));

        //
        // If we're failing with ERROR_ALREADY_INITIALIZED,
        // then we should try and get the process handle so
        // that the error routine below will kill off the
        // process.  This will allow subsequent attempts
        // to instantiate the WAM_PROCESS to succeed.
        //

        if ( hr == HRESULT_FROM_WIN32( ERROR_ALREADY_INITIALIZED ) &&
             _dwProcessId != 0 )
        {
            _hProcess = OpenProcess(
                PROCESS_DUP_HANDLE | PROCESS_TERMINATE,
                FALSE,
                _dwProcessId
                );
        }

        goto ErrorExit;
    }

    //
    // Get a handle to the new process
    //

    _hProcess = OpenProcess(
        PROCESS_DUP_HANDLE | PROCESS_TERMINATE,
        FALSE,
        _dwProcessId
        );

    if ( !_hProcess )
    {
        hr = HRESULT_FROM_WIN32( GetLastError() );

        DBGPRINTF((
            DBG_CONTEXT,
            "WAM_PROCESS %p.  Failed to get process handle.\r\n",
            this
            ));

        goto ErrorExit;
    }

    hr = _pWamProcessManager->QueryCatalog()->GetApplicationInstanceIDFromProcessID(
        _dwProcessId,
        &_bstrInstanceId
        );

    if ( FAILED( hr ) )
    {
        //
        // If we've made it this far, then it's not reasonable for the
        // above GetApplicationInstanceIDFromProcessID call to fail.
        //

        DBG_ASSERT( FALSE && "GetApplicationInstanceIDFromProcessID failed on running app." );

        DBGPRINTF((
            DBG_CONTEXT,
            "WAM_PROCESS %p.  Failed to get instance ID.\r\n",
            this
            ));

        goto ErrorExit;
    }

    IF_DEBUG( ISAPI )
    {
        DBGPRINTF((
            DBG_CONTEXT,
            "WAM_PROCESS %p created successfully.\r\n",
            this
            ));
    }

    return hr;

ErrorExit:

    DBG_ASSERT( FAILED( hr ) );

    DBGPRINTF((
        DBG_CONTEXT,
        "Attempt to create WAM_PROCESS %p failed.  CLSID=%S, HRESULT=%08x.\r\n",
        this,
        _szWamClsid,
        hr
        ));

    //
    // Log the failed attempt.  We want to put a rich error
    // message into the event log to aid administrators in
    // debugging, so we'll FormatMessage the error.
    //

    const WCHAR *   pszEventLog[2];
    WCHAR           szErrorDescription[MAX_MESSAGE_TEXT];
    WCHAR *         pszErrorDescription = NULL;
    HANDLE          hMetabase = GetModuleHandleW( L"METADATA.DLL" );
    DWORD           dwFacility;
    DWORD           dwError;

    //
    // Check the facility code for the failed HRESULT.  If it's really
    // a win32 error, then we should call FormatMessage on the win32
    // error directly.  This makes prettier messages in the event log.
    //

    dwFacility = ( hr >> 16 ) & 0x0fff;

    if ( dwFacility == FACILITY_WIN32 )
    {
        dwError = WIN32_FROM_HRESULT( hr );
    }
    else
    {
        dwError = hr;
    }

    if( FormatMessageW(
        FORMAT_MESSAGE_ALLOCATE_BUFFER |
        FORMAT_MESSAGE_FROM_HMODULE |
        FORMAT_MESSAGE_FROM_SYSTEM |
        FORMAT_MESSAGE_IGNORE_INSERTS,
        hMetabase,
        dwError,
        MAKELANGID( LANG_NEUTRAL, SUBLANG_DEFAULT ),
        (LPTSTR)&pszErrorDescription,
        sizeof( szErrorDescription ) - 1,
        NULL
        ) && pszErrorDescription )
    {
        wcsncpy(szErrorDescription, pszErrorDescription, MAX_MESSAGE_TEXT );
        szErrorDescription[MAX_MESSAGE_TEXT-1] = L'\0';

        LocalFree(pszErrorDescription);
    }
    else
    {
        wsprintfW( szErrorDescription, L"%08x", hr );
    }

    pszEventLog[0] = _strApplMdPathW.QueryStr();
    pszEventLog[1] = szErrorDescription;

    g_pW3Server->LogEvent(
        W3_EVENT_FAIL_LOADWAM,
        2,
        pszEventLog,
        0
        );

    //
    // Clean up instance ID and IWam goo
    //

    if ( _bstrInstanceId )
    {
        SysFreeString( _bstrInstanceId );
        _bstrInstanceId = NULL;
    }

    if ( _pIWam )
    {
        _pIWam->Release();
        _pIWam = NULL;
    }

    //
    // Since COM can sometimes return bogus failures when
    // we try and get the instance ID, we need to check to
    // see if the process was really created and terminate
    // it if so.
    //

    if ( _hProcess )
    {
        TerminateProcess( _hProcess, 0 );

        CloseHandle( _hProcess );

        _hProcess = NULL;
        _dwProcessId = 0;
    }

    return hr;
}

HRESULT
WAM_PROCESS::ProcessRequest(
    ISAPI_REQUEST *     pIsapiRequest,
    ISAPI_CORE_DATA *   pIsapiCoreData,
    DWORD *             pdwHseResult
    )
/*++

Routine Description:

    Processes a request by passing the necessary data
    to the OOP host.

Arguments:

    pIsapiRequest  - The ISAPI_REQUEST for this request
    pIsapiCoreData - The core data for the request
    pdwHseResult   - Upon return, the return code from HttpExtensionProc

Return Value:

    HRESULT

--*/
{
    HRESULT     hr = NOERROR;
    DWORD       dwHseResult;
    
    //
    // Bump the counters for this process and
    // Add a reference for the request to both
    // the process object and to the ISAPI request
    // object.
    //

    InterlockedIncrement( &_cTotalRequests );
    InterlockedIncrement( &_cCurrentRequests );

/*
    //
    // We need to keep a list of outstanding requests so that we
    // can clean everything up in the case of shutdown or an OOP
    // crash.
    //

    LockRequestList();
    InsertHeadList( &_RequestListHead, &pIsapiRequest->_leRequest );
    UnlockRequestList();
*/
    //
    // Associate the WAM process with the ISAPI_REQUEST and call
    // out to the OOP host.  This essentially causes the ISAPI_REQUEST
    // to take a reference on this object until it's destroyed.
    //

    pIsapiRequest->SetAssociatedWamProcess( this );

    if ( ETW_IS_TRACE_ON(ETW_LEVEL_CP) ) 
    {
        g_pEtwTracer->EtwTraceEvent( &IISEventGuid,
                                     ETW_TYPE_IIS_OOP_ISAPI_REQUEST,
                                     &pIsapiCoreData->RequestId,
                                     sizeof(ULONGLONG),
                                     &_dwProcessId, 
                                     sizeof(DWORD), 
                                     &_cTotalRequests, 
                                     sizeof(DWORD),
                                     &_cCurrentRequests, 
                                     sizeof(DWORD),
                                     NULL, 
                                     0 );
    }

    hr = _pIWam->WamProcessIsapiRequest(
        (BYTE*)pIsapiCoreData,
        pIsapiCoreData->cbSize,
        pIsapiRequest,
        &dwHseResult
        );

    //
    // Check for failure.
    //

    if ( FAILED( hr ) )
    {
        //
        // Need to check for special case failures that result
        // from OOP process crashes.
        //
        // RPC_S_CALL_FAILED        - indicates OOP process crashed
        //                            during the call.
        // RPC_S_CALL_FAILED_DNE    - indicates OOP process crashed
        //                            before the call.
        // RPC_S_SERVER_UNAVAILABLE - The OOP process was just not there
        //                             (ie. previously crashed, etc.)
        // RPC_E_SERVERFAULT        - The ISAPI AVed in HttpExtensionProc()
        //

        if ( WIN32_FROM_HRESULT( hr ) == RPC_S_CALL_FAILED ||
             WIN32_FROM_HRESULT( hr ) == RPC_S_CALL_FAILED_DNE ||
             WIN32_FROM_HRESULT( hr ) == RPC_S_SERVER_UNAVAILABLE ||
             WIN32_FROM_HRESULT( hr ) == RPC_E_SERVERFAULT )
        {
            //
            // WARNING - HandleCrash can potentially cause this object
            //           to be destroyed.  Don't do anything except
            //           return after calling it!
            //
            
            HandleCrash();
            return hr;
        }
    }

    *pdwHseResult = dwHseResult;

    return hr;
}

HRESULT
WAM_PROCESS::ProcessCompletion(
    ISAPI_REQUEST *     pIsapiRequest,
    DWORD64             IsapiContext,
    DWORD               cbCompletion,
    DWORD               dwCompletionStatus
    )
/*++

Routine Description:

    Processes a completion by passing the necessary data
    to the OOP host.

Arguments:

    pIsapiRequest      - The ISAPI_REQUEST for this request
    IsapiContext       - The ISAPI_CONTEXT that identifies the request (opaque)
    cbCompletion       - The number of bytes associated with the completion
    dwCompletionStatus - The result code for the completion

Return Value:

    HRESULT

--*/
{
    HRESULT         hr = NOERROR;

    DBG_ASSERT( pIsapiRequest );
    DBG_ASSERT( IsapiContext != 0 );

    hr = pIsapiRequest->PreprocessIoCompletion( cbCompletion );

    pIsapiRequest->ResetIsapiContext();

    //
    // Let the OOP process handle the completion
    //
    
    hr = _pIWam->WamProcessIsapiCompletion(
        IsapiContext,
        cbCompletion,
        dwCompletionStatus
        );

    //
    // This release balances the release taken when the ISAPI_REQUEST
    // made the async call into the server core.
    //

    pIsapiRequest->Release();

    //
    // Check for failure.
    //

    if ( FAILED( hr ) )
    {
        //
        // Need to check for special case failures that result
        // from OOP process crashes.
        //
        // RPC_S_CALL_FAILED        - indicates OOP process crashed
        //                            during the call.
        // RPC_S_CALL_FAILED_DNE    - indicates OOP process crashed
        //                            before the call.
        // RPC_S_SERVER_UNAVAILABLE - The OOP process was just not there
        //                             (ie. previously crashed, etc.)
        // RPC_E_SERVERFAULT        - The ISAPI AVed in HttpExtensionProc()
        //

        if ( WIN32_FROM_HRESULT( hr ) == RPC_S_CALL_FAILED ||
             WIN32_FROM_HRESULT( hr ) == RPC_S_CALL_FAILED_DNE ||
             WIN32_FROM_HRESULT( hr ) == RPC_S_SERVER_UNAVAILABLE ||
             WIN32_FROM_HRESULT( hr ) == RPC_E_SERVERFAULT )
        {
            //
            // WARNING - HandleCrash can potentially cause this object
            //           to be destroyed.  Don't do anything except
            //           return after calling it!
            //
            
            HandleCrash();
            return hr;
        }
    }

    return hr;
}

VOID
WAM_PROCESS::DecrementRequestCount(
    VOID
    )
/*++

Routine Description:

    Hmmm.  Let me think for a minute...

    Oh yeah, this function decrements the request count.

Arguments:

    None

Return Value:

    None

--*/
{
/*    
    //
    // Remove this request from the active request list
    //

    LockRequestList();
    RemoveEntryList( &pIsapiRequest->_leRequest );
    UnlockRequestList();

    //
    // Release the ISAPI_REQUEST object.
    //

    pIsapiRequest->Release();

    //
    // Release this requests reference on the WAM_PROCESS object.
    //

    Release();
*/

    InterlockedDecrement( &_cCurrentRequests );
}

VOID
WAM_PROCESS::HandleCrash(
    VOID
    )
/*++

Routine Description:

    Handles a crashed request

Arguments:

    None

Return Value:

    None

--*/
{
    //
    // If we get here, then we have to assume that the OOP host
    // process has crashed.  When this happens, COM is going to
    // release the references on any ISAPI_REQUEST objects held
    // by the process.  As these ISAPI_REQUEST's drop to zero,
    // they will be releasing references on this object.
    //
    // At this time, there's not much we can do, except call
    // TerminateProcess on it to make sure it's dead and pull
    // it off the hash table so no new requests are routed to
    // it.
    //
    // The Disable call that pulls it from the hash table could
    // very well release the final reference on this object.
    // We cannot touch any members after that.
    //
    // We need to make sure that we only call Disable once!
    //

    _fCrashed = TRUE;

    if ( InterlockedExchange( &_fGoingAway, 1 ) == 0 )
    {
        //
        // Log the crash
        //

        _pWamProcessManager->RegisterCrash( _szWamClsid );

        const WCHAR  *pszEventLog[1];

        pszEventLog[0] = _strApplMdPathW.QueryStr();

        g_pW3Server->LogEvent(
            W3_EVENT_OOPAPP_VANISHED,
            1,
            pszEventLog,
            0
            );

        TerminateProcess( _hProcess, 0 );

        //
        // Don't leak the handle...
        //

        CloseHandle( _hProcess );
        _hProcess = NULL;

        //
        // Force COM to release any references it's holding
        // to ISAPI_REQUEST objects.
        //

        DisconnectIsapiRequests();

        Disable( TRUE );
    }
}

HRESULT
WAM_PROCESS::Disable(
    BOOL    fRemoveFromProcessHash
    )
/*++

Routine Description:

    Disables the WAM_PROCESS.  Any new requests for the application
    associated with this process will cause a new process to start
    after this function is called.

Arguments:

    fRemoveFromProcessHash - If TRUE, then this function should remove
                             the WAM_PROCESS from the hash table.  This
                             flag will be FALSE when this function is
                             called from the WAM process manager's
                             shutdown.  In that case, the LKRHash 
                             DeleteIf function will handle removing the
                             object from the hash.

Return Value:

    HRESULT

--*/
{
    HRESULT     hr = NOERROR;

    _fGoingAway = TRUE;

    //
    // Remove the process from the hash if directed.
    //

    if ( fRemoveFromProcessHash )
    {
        _pWamProcessManager->LockWamProcessHash();
        hr = _pWamProcessManager->RemoveWamProcessFromHash( this );
    }

    //
    // Once we remove the process from the hash, we should recycle it.
    // This will force COM to start a new process in the case where
    // new requests arrive for this AppWamClsid before the shutdown
    // code has a chance to kill off this instance.
    //

    VARIANT varInstanceId = {0};
    varInstanceId.vt = VT_BSTR;
    varInstanceId.bstrVal = _bstrInstanceId;
    hr = _pWamProcessManager->QueryCatalog()->RecycleApplicationInstances( &varInstanceId, 0 );

    //
    // This code could potentially fail under a number of circumstances.
    // For example, if we are disabling this application because it
    // crashed, we don't really expect to be able to recycle it.
    //
    // This is not a big deal.  We'll just do some debug spew and get
    // on with it.
    //

    if ( FAILED( hr ) )
    {
        DBGPRINTF((
            DBG_CONTEXT,
            "Error 0x%08x occured attempting to recycle disabled "
            "application %S\r\n",
            hr, _szWamClsid
            ));
    }

    if ( fRemoveFromProcessHash )
    {
        _pWamProcessManager->UnlockWamProcessHash();
    }

    return hr;
}

HRESULT
WAM_PROCESS::CleanupRequests(
    DWORD   dwDrainTime
    )
/*++

Routine Description:

    This function is basically just a timer that allows time
    to pass until either the supplied timeout is reached, or
    all requests are completed, whichever is first.

Arguments:

    dwDrainTime - The timeout in milliseconds

Return Value:

    HRESULT

--*/
{
    DWORD   dwWaitSoFar = 0;
    
    //
    // We will loop here until either the specified time has
    // passed, or until all requests are done.
    
    while ( _cCurrentRequests )
    {
        DBGPRINTF((
            DBG_CONTEXT,
            "WAM_PROCESS %p waiting for %d requests.\r\n",
            this,
            _cCurrentRequests
            ));
        
        Sleep( 200 );

        if ( dwDrainTime < ( dwWaitSoFar += 200 ) )
        {
            break;
        }
    }

    DBGPRINTF((
        DBG_CONTEXT,
        "WAM_PROCESS %p done draining with %d requests "
        "still outstanding.\r\n",
        this,
        _cCurrentRequests
        ));

    return NOERROR;
}

HRESULT
WAM_PROCESS::Shutdown(
    VOID
    )
/*++

Routine Description:

    Shuts down the WAM_PROCESS and associated OOP host process

    Note that we make the assumption that the caller of this
    function has taken steps to ensure that new requests are
    properly routed.  In the typical case, this means that
    somebody has called Disable to pull us off the hash table.
    In the special case where LKRHash calls this function when
    the WAM process has is being deleted, we assume that the
    web service is in shutdown state and no new requests are
    arriving.

    Also note that it's up to the caller to hold a reference
    if necessary to ensure that this object doesn't get
    destroyed while this function is running.

Arguments:

    None

Return Value:

    HRESULT

--*/
{
    HRESULT         hr = NOERROR;

    //
    // If we get here, we expect that this object has been pulled off
    // the hash table (and that the _fGoingAway flag is set).
    //

    DBG_ASSERT( _fGoingAway );

    //
    // If there are no requests running, then we can gracefully unload
    // any extensions in the OOP host.  Otherwise, we're basically
    // going to crash the OOP host by terminating it with requests in
    // flight.
    //
    // This latter case should only happen if we are being demand
    // unloaded, through the UI, via ADSI, or via IMSAdminBase.
    //

    if ( _cCurrentRequests == 0 )
    {
        _pIWam->WamUninitProcess();
    }

    //
    // Time to kill the process.  We could potentially use the COM
    // ShutdownProcess API, but it doesn't really buy us anything.
    // We're just gonna terminate it.
    //

    DBG_ASSERT( _hProcess );

    if ( _hProcess )
    {
        TerminateProcess( _hProcess, 0 );

        CloseHandle( _hProcess );
        _hProcess = NULL;
    }

    //
    // Force COM to release any references it's holding
    // to ISAPI_REQUEST objects.
    //

    DisconnectIsapiRequests();

    //
    // Now that the process is gone, COM will clean up any
    // References on ISAPI_REQUEST objects that were held in
    // it.  It is also possible that there are threads
    // unwinding in the core that are doing work on behalf
    // of the OOP host, and there may even be I/O completions
    // that will occur for this process.
    //
    // As these objects reach zero references, they will
    // release their references on this object.  This object
    // will be destroyed when the last reference is released.
    //

    return hr;
}

HRESULT
WAM_PROCESS::Unload(
    DWORD   dwDrainTime
    )
/*++

Routine Description:

    Unloads the WAM_PROCESS, allowing for a timeout that allows
    outstanding requests to complete before killing them off.

Arguments:

    dwDrainTime - The timeout in milliseconds before requests are killed

Return Value:

    HRESULT

--*/
{
    HRESULT hr = NOERROR;

    //
    // We'd better not do this more than once.
    //

    if ( InterlockedExchange( &_fGoingAway , 1 ) == 0 )
    {
        //
        // WARNING - Calling Disable can potentially cause this object
        //           to be destroyed.  We need to take a reference until
        //           the Shutdown function returns.
        //

        AddRef();

        hr = Disable();

        hr = CleanupRequests( dwDrainTime );

        hr = Shutdown();

        Release();
    }

    return hr;
}

VOID
WAM_PROCESS::AddIsapiRequestToList(
    ISAPI_REQUEST * pIsapiRequest
    )
{
    pIsapiRequest->AddRef();
    LockRequestList();
    InsertHeadList(
        &_RequestListHead,
        &pIsapiRequest->_leRequest
        );
    UnlockRequestList();
}

VOID
WAM_PROCESS::RemoveIsapiRequestFromList(
    ISAPI_REQUEST * pIsapiRequest
    )
{
    LockRequestList();
    RemoveEntryList( &pIsapiRequest->_leRequest );
    InitializeListHead( &pIsapiRequest->_leRequest );
    UnlockRequestList();

    pIsapiRequest->Release();
}

VOID
WAM_PROCESS::DisconnectIsapiRequests(
    VOID
    )
{
    LIST_ENTRY *    pleTemp;
    ISAPI_REQUEST * pIsapiRequest;
    HRESULT         hr;

    LockRequestList();
    
    pleTemp = _RequestListHead.Flink;

    while ( pleTemp != &_RequestListHead )
    {
        pIsapiRequest = CONTAINING_RECORD(
            pleTemp,
            ISAPI_REQUEST,
            _leRequest
            );

        DBG_ASSERT( pIsapiRequest );

        pIsapiRequest->AddRef();

        hr = CoDisconnectObject( pIsapiRequest, 0 );

        if ( FAILED( hr ) )
        {
            DBGPRINTF((
                DBG_CONTEXT,
                "Failed to disconnect ISAPI_REQUEST %p.  HRESULT=%08x.\r\n",
                pIsapiRequest,
                hr
                ));

            DBG_ASSERT( FALSE && "Error disconnecting ISAPI_REQUEST." );
        }

        pleTemp = pleTemp->Flink;

        pIsapiRequest->Release();
    }

    UnlockRequestList();
}

WAM_PROCESS::~WAM_PROCESS()
/*++

Routine Description:

    Destructor

Arguments:

    None

Return Value:

    None

--*/
{    
    DBG_ASSERT( _cCurrentRequests == 0 );

    if (_bstrInstanceId)
    {
        SysFreeString(_bstrInstanceId);
        _bstrInstanceId = NULL;
    }

    DeleteCriticalSection( &_csRequestList );

    IF_DEBUG( ISAPI )
    {
        DBGPRINTF((
            DBG_CONTEXT,
            "WAM_PROCESS %p has been destroyed.\r\n",
            this
            ));
    }

    _pWamProcessManager->Release();
}

HRESULT
WAM_PROCESS_MANAGER::Create(
    VOID
    )
/*++

Routine Description:

    Initializes the parts of the WAM_PROCESS_MANAGER object not
    appropriate to the constructor.  This includes instantiating
    the COM+ admin catalog interface.

Arguments:

    None

Return Value:

    HRESULT

--*/
{
    HRESULT hr = NOERROR;

    IF_DEBUG( ISAPI )
    {
        DBGPRINTF((
            DBG_CONTEXT,
            "Creating WAM_PROCESS_MANAGER %p.\r\n",
            this
            ));
    }
    
    //
    // Need to get the COM admin interface
    //

    hr = CoCreateInstance(
        CLSID_COMAdminCatalog,
        NULL,
        CLSCTX_INPROC_SERVER,
        IID_ICOMAdminCatalog2,
        (void**)&_pCatalog
        );

    if ( FAILED( hr ) )
    {
        DBGPRINTF((
            DBG_CONTEXT,
            "WAM_PROCESS_MANAGER %p. Failed to CoCreate ICOMAdminCatalog2.\r\n",
            this
            ));

        goto ErrorExit;
    }

    IF_DEBUG( ISAPI )
    {
        DBGPRINTF((
            DBG_CONTEXT,
            "WAM_PROCESS_MANAGER %p created successfully.\r\n",
            this
            ));
    }

    return hr;

ErrorExit:

    DBG_ASSERT( FAILED( hr ) );

    DBGPRINTF((
        DBG_CONTEXT,
        "Attempt to create WAM_PROCESS_MANAGER %p has failed.  HRESULT=%08x.\r\n",
        this,
        hr
        ));

    return hr;
}

HRESULT
WAM_PROCESS_MANAGER::GetWamProcess(
    LPCWSTR         szWamClsid,
    LPCWSTR         szApplMdPathW,
    DWORD *         pdwWamSubError,
    WAM_PROCESS **  ppWamProcess,
    LPCSTR          szIsapiHandlerInstance
    )
/*++

Routine Description:

    Returns a WAM_PROCESS pointer associated with the specified
    CLSID.  If no corresponding WAM_PROCESS exists, one will be
    started.

Arguments:

    szWamClsid             - The CLSID of the desired WAM_PROCESS
    szApplMdPathW          - The metabase path of the application
    pdwWamSubError         - Upon failed return, contains the WAM sub error
                             (which is used to generate the text of the
                             error response sent to the client)
    ppWamProcess           - Upon return, contains the WAM_PROCESS pointer
    szIsapiHandlerInstance - The instance ID of the W3_ISAPI_HANDLER
                             that's looking for a WAM_PROCESS.  This
                             is used for debugging purposes.

Return Value:

    HRESULT

--*/
{
    HRESULT             hr = NOERROR;
    WAM_PROCESS *       pWamProcess = NULL;
    WAM_APP_INFO *      pWamAppInfo = NULL;
    DWORD               dwNumPreviousCrashes;

    DBG_ASSERT( szWamClsid );
    DBG_ASSERT( szApplMdPathW );
    DBG_ASSERT( pdwWamSubError );
    DBG_ASSERT( ppWamProcess );
    
    //
    // Look to see if the WAM_PROCESS has already been
    // loaded.  If so, then we can just return it.
    //
    // This is the common path, and we want to avoid
    // taking a lock for this case.
    //

    _WamProcessHash.FindKey( szWamClsid, &pWamProcess );

    if ( pWamProcess != NULL )
    {
        *ppWamProcess = pWamProcess;

        return hr;
    }

    //
    // Ok, so we didn't already find it.  Now, let's
    // lock the hash table and load it.
    //

    LockWamProcessHash();

    //
    // Better check once more now that we have the lock just
    // in case someone got to it since our initial check
    // above.
    //

    _WamProcessHash.FindKey( szWamClsid, &pWamProcess );

    if ( pWamProcess != NULL )
    {
        *ppWamProcess = pWamProcess;
        goto ExitDone;
    }

    //
    // Check to see if we have exceeded the AppOopRecoverLimit.
    //

    hr = GetWamProcessInfo(
        szApplMdPathW,
        &pWamAppInfo,
        NULL
        );

    if ( FAILED( hr ) )
    {
        goto ExitDone;
    }

    if ( pWamAppInfo->_dwAppOopRecoverLimit != 0 )
    {
        hr = QueryCrashHistory(
            szWamClsid,
            &dwNumPreviousCrashes
            );

        if ( FAILED( hr ) )
        {
            goto ExitDone;
        }

        if ( dwNumPreviousCrashes >= pWamAppInfo->_dwAppOopRecoverLimit )
        {
            //
            // If we've exceeded the recover limit,
            // then we should fail now.
            //

            hr = E_FAIL;

            *pdwWamSubError = IDS_WAM_NOMORERECOVERY_ERROR;

            goto ExitDone;
        }
    }

    //
    // Try and create the new WAM_PROCESS...
    //

    pWamProcess = new WAM_PROCESS(
        szWamClsid,
        this,
        szIsapiHandlerInstance
        );

    if ( !pWamProcess )
    {
        hr = HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );
        goto ExitDone;
    }

    //
    // Create the WAM_PROCESS object.  This will start the
    // host process.
    //

    hr = pWamProcess->Create( szApplMdPathW );

    if ( FAILED( hr ) )
    {
        DBGPRINTF((
            DBG_CONTEXT,
            "Failed to create WAM_PROCESS %p. Error 0x%08x\r\n",
            pWamProcess, hr
            ));

        pWamProcess->Release();

        *pdwWamSubError = IDS_WAM_FAILTOLOAD_ERROR;

        goto ExitDone;
    }

    DBGPRINTF((
        DBG_CONTEXT,
        "WAM_PROCESS_MANAGER has created WAM_PROCESS %p.\r\n",
        pWamProcess
        ));

    //
    // Add the newly created WAM_PROCESS to the hash table
    // 

    if ( _WamProcessHash.InsertRecord( pWamProcess ) != LK_SUCCESS )
    {
        pWamProcess->Release();
        hr = E_FAIL; // CODEWORK - Consider passing lkreturn to caller
        goto ExitDone;
    }

    //
    // Finally, set the return object for the caller
    //

    *ppWamProcess = pWamProcess;

ExitDone:

    UnlockWamProcessHash();

    if ( pWamAppInfo != NULL )
    {
        pWamAppInfo->Release();
        pWamAppInfo = NULL;
    }

    return hr;
}

HRESULT
WAM_PROCESS_MANAGER::GetWamProcessInfo(
    LPCWSTR         szAppPath,
    WAM_APP_INFO ** ppWamAppInfo,
    BOOL *          pfIsLoaded
    )
/*++

Routine Description:

    Retrieves the app info associated with the provided metabase path
    and indicates whether the application is currently loaded or not.

    Note that this function is expensive because it reads the metabase
    on each call.  It is currently only called when an application is
    unloaded or changed via the UI or an administrative API.

    Don't call this function if you care about performance.

Arguments:

    szAppPath    - The metabase path (ie. "/LM/W3SVC/1/ROOT") to retrieve
    ppWamAppInfo - Upon return, contains a pointer to the app info
    pfIsLoaded   - Upon return, indicates if the application is loaded

Return Value:

    HRESULT

--*/
{
    MB              mb( g_pW3Server->QueryMDObject() );
    WAM_APP_INFO *  pWamAppInfo = NULL;
    WAM_PROCESS *   pWamProcess = NULL;
    DWORD           dwRequiredLen;
    DWORD           dwAppIsolated;
    DWORD           dwAppOopRecoverLimit;
    WCHAR           szClsid[MAX_PATH];
    HRESULT         hr = NOERROR;

    DBG_ASSERT( szAppPath );
    DBG_ASSERT( ppWamAppInfo );

    //
    // Get the info from the metabase
    //

    if ( !mb.Open( szAppPath ) )
    {
        hr = HRESULT_FROM_WIN32( GetLastError() );
        goto Done;
    }

    //
    // Get the AppIsolated value
    //

    if (!mb.GetDword(L"", MD_APP_ISOLATED, IIS_MD_UT_WAM, &dwAppIsolated, METADATA_INHERIT))
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto Done;
    }

    //
    // Set the CLSID
    //

    switch ( dwAppIsolated )
    {
    case APP_ISOLATED:

        //
        // Read it from the metabase
        //

        dwRequiredLen= SIZE_CLSID_STRING * sizeof(WCHAR);

        if (!mb.GetString(L"", MD_APP_WAM_CLSID, IIS_MD_UT_WAM, szClsid, &dwRequiredLen, METADATA_INHERIT))
        {
            DBG_ASSERT(dwRequiredLen <= SIZE_CLSID_STRING * sizeof(WCHAR));
            hr = HRESULT_FROM_WIN32( GetLastError() );
            goto Done;
        }

        break;

    case APP_POOL:

        //
        // Set it from the hardcoded pool clsid
        //

        wcsncpy( szClsid, POOL_WAM_CLSID, SIZE_CLSID_STRING );

        break;

    case APP_INPROC:
    default:

        //
        // Set it to an empty string
        //

        szClsid[0] = L'\0';

        break;
    }

    //
    // Get the AppOopRecoverLimit
    //

    if (!mb.GetDword(L"", MD_APP_OOP_RECOVER_LIMIT, IIS_MD_UT_WAM, &dwAppOopRecoverLimit, METADATA_INHERIT))
    {
        //
        // Ok, so we didn't get the value.  The default is dependent
        // on whether this is the pool or isolated (and in the case
        // of inproc, we'll just default to zero.)
        //

        if ( dwAppIsolated == APP_ISOLATED )
        {
            dwAppOopRecoverLimit = DEFAULT_RECOVER_LIMIT;
        }
        else
        {
            dwAppOopRecoverLimit = 0;
        }
    }

    //
    // Allocate a new WAM_APP_INFO
    //

    pWamAppInfo = new WAM_APP_INFO( (LPWSTR)szAppPath, szClsid, dwAppIsolated );

    if ( !pWamAppInfo )
    {
        hr = HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );
        goto Done;
    }

    pWamAppInfo->_dwAppOopRecoverLimit = dwAppOopRecoverLimit;

    //
    // Return the new object
    //

    *ppWamAppInfo = pWamAppInfo;

    //
    // Finally, check to see if the application is loaded
    //

    if ( pfIsLoaded != NULL )
    {
        if ( pWamAppInfo->_dwAppIsolated != APP_INPROC )
        {
            _WamProcessHash.FindKey( pWamAppInfo->_szClsid,
                                     &pWamProcess );
        }

        if ( pWamProcess != NULL )
        {
            *pfIsLoaded = TRUE;
            pWamProcess->Release();
            pWamProcess = NULL;
        }
        else
        {
            *pfIsLoaded = FALSE;
        }
    }

Done:

    mb.Close();

    return hr;
}

HRESULT
WAM_PROCESS_MANAGER::RemoveWamProcessFromHash(
    WAM_PROCESS *   pWamProcess
    )
/*++

Routine Description:

    Removes a WAM_PROCESS from the hash

Arguments:

    pWamProcess - The WAM_PROCESS to remove

Return Value:

    HRESULT

--*/
{
    HRESULT     hr = S_OK;
    LK_RETCODE  lkret;
    
    lkret = _WamProcessHash.DeleteRecord( pWamProcess );

    if ( lkret != LK_SUCCESS )
    {
        DBGPRINTF((
            DBG_CONTEXT,
            "Failed to delete WAM_PROCESS %p from hash.  LK_RETCODE=0x%p.\r\n",
            pWamProcess,
            lkret
            ));

        hr = E_FAIL; // CODEWORK - Consider passing lkreturn to caller
    }
    else
    {
        IF_DEBUG( ISAPI )
        {
            DBGPRINTF((
                DBG_CONTEXT,
                "Removed WAM_PROCESS %p from hash.\r\n",
                pWamProcess
                ));
        }
    }

    return hr;
}

// static
LK_PREDICATE
WAM_PROCESS_MANAGER::UnloadWamProcess(
    WAM_PROCESS *   pWamProcess,
    void *
    )
/*++

Routine Description:

    Unloads a WAM_PROCESS.  This function is exclusively called by
    LKRHash's DeleteIf function during WAM_PROCESS_MANAGER shutdown
    just before the hash table is deleted.

Arguments:

    pWamProcess - The WAM_PROCESS to shut down
    pvState     - Required by LKRHash - we don't use it

Return Value:

    HRESULT

--*/
{
    HRESULT hr = NOERROR;

    DBG_ASSERT( pWamProcess );

    DBGPRINTF((
        DBG_CONTEXT,
        "Unloading application %S.\r\n",
        pWamProcess->QueryClsid()
        ));

    hr = pWamProcess->Disable( FALSE );
    hr = pWamProcess->CleanupRequests( 0 );
    hr = pWamProcess->Shutdown();

    DBG_ASSERT( SUCCEEDED( hr ) );

    return LKP_PERFORM;
}

HRESULT
WAM_PROCESS_MANAGER::Shutdown(
    VOID
    )
/*++

Routine Description:

    Shuts down the WAM_PROCESS_MANAGER

Arguments:

    None

Return Value:

    HRESULT

--*/
{
    HRESULT hr = NOERROR;
    
    DBGPRINTF((
        DBG_CONTEXT,
        "Shutting down WAM_PROCESS_MANAGER.\r\n"
        ));

    _WamProcessHash.DeleteIf( UnloadWamProcess, NULL );

    return hr;
}

VOID
WAM_PROCESS_MANAGER::RegisterCrash(
    LPCWSTR szWamClsid
    )
/*++

Routine Description:

    Updates the crash count for the specified application

Arguments:

    szWamClsid - The CLSID of the WAM whose process crashed

Return Value:

    None

--*/
{
    WAM_CRASH_RECORD *  pWamCrashRecord = NULL;
    LIST_ENTRY *        pleTemp = NULL;

    LockCrashHistoryList();

    pleTemp = _CrashHistoryList.Flink;

    while ( pleTemp != &_CrashHistoryList )
    {
        pWamCrashRecord = CONTAINING_RECORD(
            pleTemp,
            WAM_CRASH_RECORD,
            leCrashHistory
            );

        DBG_ASSERT( pWamCrashRecord );

        if ( _wcsicmp( pWamCrashRecord->szClsid, szWamClsid ) == 0 )
        {
            break;
        }

        pleTemp = pleTemp->Flink;
        pWamCrashRecord = NULL;
    }

    UnlockCrashHistoryList();

    //
    // If pWamCrashRecord is non-NULL, then we need to increment
    // its crash history.  If it is NULL, then we won't worry about
    // it.
    //

    if ( pWamCrashRecord != NULL )
    {
        pWamCrashRecord->dwNumCrashes++;
    }
}

HRESULT
WAM_PROCESS_MANAGER::QueryCrashHistory(
    LPCWSTR szWamClsid,
    DWORD * pdwNumCrashes
    )
/*++

Routine Description:

    Queries the number of times a particular WAM has crashed.

Arguments:

    szWamClsid    - The CLSID of the WAM whose process crashed
    pdwNumCrashes - On successful return, contains the data

Return Value:

    HRESULT

--*/
{
    WAM_CRASH_RECORD *  pWamCrashRecord = NULL;
    LIST_ENTRY *        pleTemp = NULL;
    HRESULT             hr = NOERROR;

    LockCrashHistoryList();

    pleTemp = _CrashHistoryList.Flink;

    while ( pleTemp != &_CrashHistoryList )
    {
        pWamCrashRecord = CONTAINING_RECORD(
            pleTemp,
            WAM_CRASH_RECORD,
            leCrashHistory
            );

        DBG_ASSERT( pWamCrashRecord );

        if ( _wcsicmp( pWamCrashRecord->szClsid, szWamClsid ) == 0 )
        {
            break;
        }

        pleTemp = pleTemp->Flink;
        pWamCrashRecord = NULL;
    }

    //
    // If pWamCrashRecord is non-NULL, then we need to return
    // it's crash history.
    //
    // If it is NULL, then we didn't find it, and we need to
    // create a new record.
    //

    if ( pWamCrashRecord != NULL )
    {
        *pdwNumCrashes = pWamCrashRecord->dwNumCrashes;
    }
    else
    {
        pWamCrashRecord = new WAM_CRASH_RECORD;

        if ( pWamCrashRecord == NULL )
        {
            hr = HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );
        }
        else
        {
            wcsncpy( pWamCrashRecord->szClsid, szWamClsid, SIZE_CLSID_STRING );
            pWamCrashRecord->szClsid[SIZE_CLSID_STRING-1] = L'\0';

            InsertHeadList(
                &_CrashHistoryList,
                &pWamCrashRecord->leCrashHistory
                );
        }

        *pdwNumCrashes = 0;
    }

    UnlockCrashHistoryList();

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\iisplus\ulw3\w3site.h ===
/*++

Copyright (c) 1999-2000 Microsoft Corporation

Module Name:

    w3site.h

Abstract:

    Type definition for worker process implementation of IIS.

Author:

    Taylor Weiss (TaylorW)       16-Dec-1999

Revision History:

--*/

#ifndef _W3SITE_H_
#define _W3SITE_H_

/************************************************************
 *  Include Headers
 ************************************************************/

/************************************************************
 *  Type Definitions  
 ************************************************************/

/*++

class W3_SITE

    Encapsulates site level settings for an HTTP server run in
    a duct-tape worker process.

    Condenses the relevant functionality exposed in IIS 
    through the IIS_SERVER_INSTANCE and W3_SERVER_INSTANCE.

--*/

#define W3_SITE_SIGNATURE            (DWORD)' ISW'
#define W3_SITE_SIGNATURE_FREE       (DWORD)'fISW'

#define MAX_SITEID_LENGTH            10

class FILTER_LIST;

class W3_SITE
{

public:

    //
    // Construction and Initialization
    //

    W3_SITE(DWORD SiteId);

    // global initialization and cleanup
    static HRESULT W3SiteInitialize()
    {
        INITIALIZE_CRITICAL_SECTION( &sm_csIISCertMapLock );
        return S_OK;
    }
    
    static VOID W3SiteTerminate()
    {
        DeleteCriticalSection( &sm_csIISCertMapLock );        
    }

    // global lock & unlock for iis certmap

    VOID GlobalLockIISCertMap()
    {
        EnterCriticalSection( &sm_csIISCertMapLock );
    }
    
    VOID GlobalUnlockIISCertMap()
    {
        LeaveCriticalSection( &sm_csIISCertMapLock );
    }

    HRESULT Initialize(LOGGING *pLogging = NULL,
                       FILTER_LIST *pFilterList = NULL);

    DWORD QueryId() const
    {
        return m_SiteId;
    }

    BOOL QueryUseDSMapper() const
    {
        return m_fUseDSMapper;
    }

    void ReferenceSite()
    {
        InterlockedIncrement( &m_cRefs );
    }

    void DereferenceSite()
    {
        DBG_ASSERT( m_cRefs > 0 );

        if ( InterlockedDecrement( &m_cRefs ) == 0 )
        {
            delete this;
        }
    }

    FILTER_LIST *QueryFilterList() const
    {
        return m_pInstanceFilterList;
    }

    STRA *QueryName()
    {
        return &m_SiteName;
    }

    STRU *QueryMBRoot()
    {
        return &m_SiteMBRoot;
    }

    STRU *QueryMBPath()
    {
        return &m_SiteMBPath;
    }
    
    HRESULT
    HandleMetabaseChange(
        const MD_CHANGE_OBJECT &ChangeObject,
        IN    W3_SITE_LIST     *pTempSiteList = NULL);

    BOOL QueryDoUlLogging() const
    {
        return m_pLogging->QueryDoUlLogging();
    }

    BOOL QueryDoCustomLogging() const
    {
        return m_pLogging->QueryDoCustomLogging();
    }

    BOOL IsRequiredExtraLoggingFields() const
    {
        return m_pLogging->IsRequiredExtraLoggingFields();
    }

    const MULTISZA *QueryExtraLoggingFields() const
    {
        return m_pLogging->QueryExtraLoggingFields();
    }

    void LogInformation(LOG_CONTEXT *pLogData)
    {
        m_pLogging->LogInformation(pLogData);
    }

    BOOL QueryAllowPathInfoForScriptMappings() const
    {
        return m_fAllowPathInfoForScriptMappings;
    }

    VOID GetStatistics(IISWPSiteCounters *pCounterData)
    {
        PBYTE pSrc = (PBYTE)&m_PerfCounters;
        PBYTE pDest = (PBYTE)pCounterData;

        //
        // Set the site id for the counters we
        // are sending.
        //
        pCounterData->SiteID = m_SiteId;

        for (DWORD i=0; i< WPSiteCtrsMaximum; i++)
        {
            // I am assuming all WP site counters are DWORDs and will
            // remain so, if not this code needs changing at that point
            DBG_ASSERT(aIISWPSiteDescription[i].Size == sizeof(DWORD));

            if (aIISWPSiteDescription[i].WPZeros)
            {
                //
                // For the total counters, we pass on the increment since
                // the last collection, so we need to zero them
                //

                *(DWORD *)(pDest + aIISWPSiteDescription[i].Offset) =
                    InterlockedExchange(
                        (LPLONG)(pSrc + aIISWPSiteDescription[i].Offset),
                        0);
            }
            else
            {
                *(DWORD *)(pDest + aIISWPSiteDescription[i].Offset) =
                    *(DWORD *)(pSrc + aIISWPSiteDescription[i].Offset);
            }
        }
    }

    VOID IncFilesSent()
    {
        InterlockedIncrement((LPLONG)&m_PerfCounters.FilesSent);
        InterlockedIncrement((LPLONG)&m_PerfCounters.FilesTransferred);
    }

    VOID IncFilesRecvd()
    {
        InterlockedIncrement((LPLONG)&m_PerfCounters.FilesReceived);
        InterlockedIncrement((LPLONG)&m_PerfCounters.FilesTransferred);
    }

    VOID IncAnonUsers()
    {
        InterlockedIncrement((LPLONG)&m_PerfCounters.AnonUsers);
        DWORD currAnons = InterlockedIncrement((LPLONG)&m_PerfCounters.CurrentAnonUsers);

        DWORD currMaxAnons;
        while ((currMaxAnons = m_PerfCounters.MaxAnonUsers) <
               currAnons)
        {
            InterlockedCompareExchange((LPLONG)&m_PerfCounters.MaxAnonUsers,
                                       currAnons,
                                       currMaxAnons);
        }
    }

    VOID DecAnonUsers()
    {
        InterlockedDecrement((LPLONG)&m_PerfCounters.CurrentAnonUsers);
    }

    VOID IncNonAnonUsers()
    {
        InterlockedIncrement((LPLONG)&m_PerfCounters.NonAnonUsers);
        DWORD currNonAnons = InterlockedIncrement((LPLONG)&m_PerfCounters.CurrentNonAnonUsers);

        DWORD currMaxNonAnons;
        while ((currMaxNonAnons = m_PerfCounters.MaxNonAnonUsers) <
               currNonAnons)
        {
            InterlockedCompareExchange((LPLONG)&m_PerfCounters.MaxNonAnonUsers,
                                       currNonAnons,
                                       currMaxNonAnons);
        }
    }

    VOID DecNonAnonUsers()
    {
        InterlockedDecrement((LPLONG)&m_PerfCounters.CurrentNonAnonUsers);
    }

    VOID IncLogonAttempts()
    {
        InterlockedIncrement((LPLONG)&m_PerfCounters.LogonAttempts);
    }

    VOID IncReqType(HTTP_VERB VerbType)
    {
        switch (VerbType)
        {
        case HttpVerbOPTIONS:
            InterlockedIncrement((LPLONG)&m_PerfCounters.OptionsReqs);
            return;

        case HttpVerbGET:
            InterlockedIncrement((LPLONG)&m_PerfCounters.GetReqs);
            return;

        case HttpVerbHEAD:
            InterlockedIncrement((LPLONG)&m_PerfCounters.HeadReqs);
            return;

        case HttpVerbPOST:
            InterlockedIncrement((LPLONG)&m_PerfCounters.PostReqs);
            return;

        case HttpVerbPUT:
            InterlockedIncrement((LPLONG)&m_PerfCounters.PutReqs);
            IncFilesRecvd();
            return;

        case HttpVerbDELETE:
            InterlockedIncrement((LPLONG)&m_PerfCounters.DeleteReqs);
            return;

        case HttpVerbTRACE:
            InterlockedIncrement((LPLONG)&m_PerfCounters.TraceReqs);
            return;

        case HttpVerbMOVE:
            InterlockedIncrement((LPLONG)&m_PerfCounters.MoveReqs);
            return;

        case HttpVerbCOPY:
            InterlockedIncrement((LPLONG)&m_PerfCounters.CopyReqs);
            return;

        case HttpVerbPROPFIND:
            InterlockedIncrement((LPLONG)&m_PerfCounters.PropfindReqs);
            return;

        case HttpVerbPROPPATCH:
            InterlockedIncrement((LPLONG)&m_PerfCounters.ProppatchReqs);
            return;

        case HttpVerbMKCOL:
            InterlockedIncrement((LPLONG)&m_PerfCounters.MkcolReqs);
            return;

        case HttpVerbLOCK:
            InterlockedIncrement((LPLONG)&m_PerfCounters.LockReqs);
            return;

        case HttpVerbUNLOCK:
            InterlockedIncrement((LPLONG)&m_PerfCounters.UnlockReqs);
            return;

        case HttpVerbSEARCH:
            InterlockedIncrement((LPLONG)&m_PerfCounters.SearchReqs);
            return;

        default:
            InterlockedIncrement((LPLONG)&m_PerfCounters.OtherReqs);
            return;
        }
    }

    VOID IncCgiReqs()
    {
        InterlockedIncrement((LPLONG)&m_PerfCounters.CgiReqs);
        DWORD currCgis = InterlockedIncrement((LPLONG)&m_PerfCounters.CurrentCgiReqs);

        DWORD currMaxCgis;
        while ((currMaxCgis = m_PerfCounters.MaxCgiReqs) <
               currCgis)
        {
            InterlockedCompareExchange((LPLONG)&m_PerfCounters.MaxCgiReqs,
                                       currCgis,
                                       currMaxCgis);
        }
    }

    VOID DecCgiReqs()
    {
        InterlockedDecrement((LPLONG)&m_PerfCounters.CurrentCgiReqs);
    }

    VOID IncIsapiExtReqs()
    {
        InterlockedIncrement((LPLONG)&m_PerfCounters.IsapiExtReqs);
        DWORD currIsapiExts = InterlockedIncrement((LPLONG)&m_PerfCounters.CurrentIsapiExtReqs);

        DWORD currMaxIsapiExts;
        while ((currMaxIsapiExts = m_PerfCounters.MaxIsapiExtReqs) <
               currIsapiExts)
        {
            InterlockedCompareExchange((LPLONG)&m_PerfCounters.MaxIsapiExtReqs,
                                       currIsapiExts,
                                       currMaxIsapiExts);
        }
    }

    VOID DecIsapiExtReqs()
    {
        InterlockedDecrement((LPLONG)&m_PerfCounters.CurrentIsapiExtReqs);
    }

    VOID IncNotFound()
    {
        InterlockedIncrement((LPLONG)&m_PerfCounters.NotFoundErrors);
    }

    VOID IncLockedError()
    {
        InterlockedIncrement((LPLONG)&m_PerfCounters.LockedErrors);
    }

    BOOL 
    IsAuthPwdChangeEnabled(
        VOID
        )
    {
        return !( m_dwAuthChangeFlags & MD_AUTH_CHANGE_DISABLE );
    }
    BOOL 
    IsAuthPwdChangeNotificationEnabled(
        VOID
        )
    {
        return !( m_dwAuthChangeFlags & MD_AUTH_ADVNOTIFY_DISABLE );
    }

    STRU *
    QueryAuthChangeUrl(
        VOID
        )
    {
        return &m_strAuthChangeUrl;
    }

    STRU * 
    QueryAuthExpiredUrl(
        VOID
        )
    {
        if ( m_dwAuthChangeFlags & MD_AUTH_CHANGE_DISABLE )
        {
            return NULL;
        }

        if ( m_dwAuthChangeFlags & MD_AUTH_CHANGE_UNSECURE )
        {
            return &m_strAuthExpiredUnsecureUrl;
        }
        else
        {
            return &m_strAuthExpiredUrl;
        }
    }

    STRU * 
    QueryAdvNotPwdExpUrl( 
        VOID
        )
    {
        if ( m_dwAuthChangeFlags & MD_AUTH_ADVNOTIFY_DISABLE )
        {
            return NULL;
        }

        if ( m_dwAuthChangeFlags & MD_AUTH_CHANGE_UNSECURE )
        {
            return &m_strAdvNotPwdExpUnsecureUrl;
        }
        else
        {
            return &m_strAdvNotPwdExpUrl;
        }
    }

    DWORD
    QueryAdvNotPwdExpInDays(
        VOID
        )
    {
        return m_dwAdvNotPwdExpInDays;
    }

    DWORD 
    QueryAdvCacheTTL(
        VOID
        )
    {
        return m_dwAdvCacheTTL;
    }

    BOOL
    QuerySSLSupported(
        VOID
        )
    {
        return m_fSSLSupported;
    }
    
    HRESULT
    GetIISCertificateMapping(
        IIS_CERTIFICATE_MAPPING ** ppIISCertificateMapping
    );

    HRESULT
    GetDataSetCache(
        DATA_SET_CACHE **       ppDataSetCache
    );

    VOID
    RemoveDataSetCache(
        VOID
    );

private:

    ~W3_SITE();

    HRESULT ReadPrivateProperties();

    DWORD               m_Signature;
    LONG                m_cRefs;
    DWORD               m_SiteId;
    STRA                m_SiteName;
    STRU                m_SiteMBPath;
    STRU                m_SiteMBRoot;

    FILTER_LIST        *m_pInstanceFilterList;

    LOGGING            *m_pLogging;

    BOOL                m_fAllowPathInfoForScriptMappings;
    BOOL                m_fUseDSMapper;
    IISWPSiteCounters   m_PerfCounters;

    //
    // OWA related variables 
    //

    STRU                m_strAuthChangeUrl;
    STRU                m_strAuthExpiredUrl;
    STRU                m_strAdvNotPwdExpUrl;
    STRU                m_strAuthExpiredUnsecureUrl;
    STRU                m_strAdvNotPwdExpUnsecureUrl;
    DWORD               m_dwAdvNotPwdExpInDays;
    DWORD               m_dwAuthChangeFlags;
    DWORD               m_dwAdvCacheTTL;

    //
    // Data set cache management
    //

    CReaderWriterLock3  m_DataSetCacheLock;
    DATA_SET_CACHE *    m_pDataSetCache;

    //
    // Does this site support SSL
    //
    BOOL                m_fSSLSupported;

    //
    // IIS certificate mapping
    // It is loaded on demand on first request to content
    // that enable IIS cert mapping
    //
    
    IIS_CERTIFICATE_MAPPING * m_pIISCertMap;
    BOOL                      m_fAlreadyAttemptedToLoadIISCertMap;
    static CRITICAL_SECTION   sm_csIISCertMapLock;

}; // W3_SITE

#endif // _W3SITE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\iisplus\ulw3\w3response.cxx ===
/*++

   Copyright    (c)    1999    Microsoft Corporation

   Module Name :

        w3response.cxx

   Abstract:

        W3_RESPONSE object (a friendly wrapper of UL_HTTP_RESPONSE)
        
   Author:

        Bilal Alam (BAlam)      10-Dec-99

   Project:

        ULW3.DLL
--*/

#include "precomp.hxx"

#define SERVER_HEADER_NAME  "Server"
#define SERVER_HEADER_VALUE "Microsoft-IIS/6.0"

//
// HTTP Status codes
//

HTTP_STATUS HttpStatusOk                = { 200, REASON("OK") };
HTTP_STATUS HttpStatusPartialContent    = { 206, REASON("Partial Content") };
HTTP_STATUS HttpStatusMultiStatus       = { 207, REASON("Multi Status") };
HTTP_STATUS HttpStatusMovedPermanently  = { 301, REASON("Moved Permanently") };
HTTP_STATUS HttpStatusRedirect          = { 302, REASON("Redirect") };
HTTP_STATUS HttpStatusMovedTemporarily  = { 307, REASON("Moved Temporarily") };
HTTP_STATUS HttpStatusNotModified       = { 304, REASON("Not Modified") };
HTTP_STATUS HttpStatusBadRequest        = { 400, REASON("Bad Request") };
HTTP_STATUS HttpStatusUnauthorized      = { 401, REASON("Unauthorized") };
HTTP_STATUS HttpStatusForbidden         = { 403, REASON("Forbidden") };
HTTP_STATUS HttpStatusNotFound          = { 404, REASON("Not Found") };
HTTP_STATUS HttpStatusMethodNotAllowed  = { 405, REASON("Method Not Allowed") };
HTTP_STATUS HttpStatusNotAcceptable     = { 406, REASON("Not Acceptable") };
HTTP_STATUS HttpStatusProxyAuthRequired = { 407, REASON("Proxy Authorization Required") };
HTTP_STATUS HttpStatusPreconditionFailed= { 412, REASON("Precondition Failed") };
HTTP_STATUS HttpStatusEntityTooLarge    = { 413, REASON("Request Entity Too Large") };
HTTP_STATUS HttpStatusUrlTooLong        = { 414, REASON("URL Too Long") };
HTTP_STATUS HttpStatusRangeNotSatisfiable={ 416, REASON("Requested Range Not Satisfiable") };
HTTP_STATUS HttpStatusExpectationFailed = { 417, REASON("Expectation Failed") };
HTTP_STATUS HttpStatusLockedError       = { 423, REASON("Locked Error") };
HTTP_STATUS HttpStatusServerError       = { 500, REASON("Internal Server Error") };
HTTP_STATUS HttpStatusNotImplemented    = { 501, REASON("Not Implemented") };
HTTP_STATUS HttpStatusBadGateway        = { 502, REASON("Bad Gateway") };
HTTP_STATUS HttpStatusServiceUnavailable= { 503, REASON("Service Unavailable") };
HTTP_STATUS HttpStatusGatewayTimeout    = { 504, REASON("Gateway Timeout") };

//
// HTTP SubErrors.  This goo is used in determining the proper default error
// message to send to the client when an applicable custom error is not 
// configured
// 
// As you can see, some sub errors have no corresponding resource string. 
// (signified by a 0 index) 
//

HTTP_SUB_ERROR HttpNoSubError           = { 0, 0 };
HTTP_SUB_ERROR Http401BadLogon          = { MD_ERROR_SUB401_LOGON, 0 };
HTTP_SUB_ERROR Http401Config            = { MD_ERROR_SUB401_LOGON_CONFIG, 0 };
HTTP_SUB_ERROR Http401Resource          = { MD_ERROR_SUB401_LOGON_ACL, 0 };
HTTP_SUB_ERROR Http401Filter            = { MD_ERROR_SUB401_FILTER, 0 };
HTTP_SUB_ERROR Http401Application       = { MD_ERROR_SUB401_APPLICATION, 0 };
HTTP_SUB_ERROR Http403ExecAccessDenied  = { MD_ERROR_SUB403_EXECUTE_ACCESS_DENIED, IDS_EXECUTE_ACCESS_DENIED };
HTTP_SUB_ERROR Http403ReadAccessDenied  = { MD_ERROR_SUB403_READ_ACCESS_DENIED, IDS_READ_ACCESS_DENIED };
HTTP_SUB_ERROR Http403WriteAccessDenied = { MD_ERROR_SUB403_WRITE_ACCESS_DENIED, IDS_WRITE_ACCESS_DENIED };
HTTP_SUB_ERROR Http403SSLRequired       = { MD_ERROR_SUB403_SSL_REQUIRED, IDS_SSL_REQUIRED };
HTTP_SUB_ERROR Http403SSL128Required    = { MD_ERROR_SUB403_SSL128_REQUIRED, IDS_SSL128_REQUIRED };
HTTP_SUB_ERROR Http403IPAddressReject   = { MD_ERROR_SUB403_ADDR_REJECT, IDS_ADDR_REJECT };
HTTP_SUB_ERROR Http403CertRequired      = { MD_ERROR_SUB403_CERT_REQUIRED, IDS_CERT_REQUIRED };
HTTP_SUB_ERROR Http403SiteAccessDenied  = { MD_ERROR_SUB403_SITE_ACCESS_DENIED, IDS_SITE_ACCESS_DENIED };      
HTTP_SUB_ERROR Http403TooManyUsers      = { MD_ERROR_SUB403_TOO_MANY_USERS, IDS_TOO_MANY_USERS };          
HTTP_SUB_ERROR Http403PasswordChange    = { MD_ERROR_SUB403_PWD_CHANGE, IDS_PWD_CHANGE };
HTTP_SUB_ERROR Http403MapperDenyAccess  = { MD_ERROR_SUB403_MAPPER_DENY_ACCESS, IDS_MAPPER_DENY_ACCESS };     
HTTP_SUB_ERROR Http403CertRevoked       = { MD_ERROR_SUB403_CERT_REVOKED, IDS_CERT_REVOKED };
HTTP_SUB_ERROR Http403DirBrowsingDenied = { MD_ERROR_SUB403_DIR_LIST_DENIED, IDS_DIR_LIST_DENIED };        
HTTP_SUB_ERROR Http403CertInvalid       = { MD_ERROR_SUB403_CERT_BAD, IDS_CERT_BAD };               
HTTP_SUB_ERROR Http403CertTimeInvalid   = { MD_ERROR_SUB403_CERT_TIME_INVALID, IDS_CERT_TIME_INVALID };
HTTP_SUB_ERROR Http403AppPoolDenied     = { MD_ERROR_SUB403_APPPOOL_DENIED, IDS_APPPOOL_DENIED };
HTTP_SUB_ERROR Http403InsufficientPrivilegeForCgi     = { MD_ERROR_SUB403_INSUFFICIENT_PRIVILEGE_FOR_CGI, IDS_INSUFFICIENT_PRIVILEGE_FOR_CGI };
HTTP_SUB_ERROR Http403PassportLoginFailure = { MD_ERROR_SUB403_PASSPORT_LOGIN_FAILURE, 0 };
HTTP_SUB_ERROR Http404DeniedByPolicy    = { MD_ERROR_SUB404_DENIED_BY_POLICY, 0 };
HTTP_SUB_ERROR Http404DeniedByMimeMap   = { MD_ERROR_SUB404_DENIED_BY_MIMEMAP, 0 };
HTTP_SUB_ERROR Http500UNCAccess         = { MD_ERROR_SUB500_UNC_ACCESS, 0 };
HTTP_SUB_ERROR Http500BadMetadata       = { MD_ERROR_SUB500_BAD_METADATA, 0 };
HTTP_SUB_ERROR Http502Timeout           = { MD_ERROR_SUB502_TIMEOUT, IDS_CGI_APP_TIMEOUT };
HTTP_SUB_ERROR Http502PrematureExit     = { MD_ERROR_SUB502_PREMATURE_EXIT, IDS_BAD_CGI_APP };


//
// static variables
//
DWORD W3_RESPONSE::sm_dwSendRawDataBufferSize = 2048;

HRESULT
SendEntityBodyAndLogDataHelper(
    W3_CONTEXT                 *pW3Context,
    ULATQ_CONTEXT               pContext,
    BOOL                        fAsync,
    DWORD                       dwFlags,
    USHORT                      cChunks,
    HTTP_DATA_CHUNK *           pChunks,
    DWORD                      *pcbSent
)
/*++

Routine Description:
    
    Simple wrapper of the UlAtqSendEntityBody function
    Make sure the log data gets passed on correctly if it is the final send
    Also update bytes seen

Arguments:

    pW3Context - W3 Context
    pContext - ULATQ context
    fAsync - Is the send async?
    dwFlags - HTTP.SYS response flags to be used
    cChunks - Count of chunks to send
    pChunks - Pointer to array of chunks
    pcbSent - If sync, filled in with bytes sent upon return
    
Return Value:

    HRESULT

--*/
{
    BOOL fDoLogging = FALSE;
    HRESULT hr;

    if ( pW3Context == NULL ||
         pContext == NULL )
    {
        DBG_ASSERT( FALSE );
        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }

    if (!(dwFlags & HTTP_SEND_RESPONSE_FLAG_MORE_DATA) &&
        pW3Context->QueryDoUlLogging())
    {
        fDoLogging = TRUE;
        if ( FAILED( hr = pW3Context->QueryMainContext()->CollectLoggingData( TRUE ) ) )
        {
            return hr;
        }
    }

    pW3Context->QueryMainContext()->UpdateSkipped( pChunks,
                                                   cChunks );

    return UlAtqSendEntityBody(pContext,
                               fAsync,
                               dwFlags,
                               cChunks,
                               pChunks,
                               pcbSent,
                               fDoLogging ? pW3Context->QueryUlLogData() : NULL);
}

HRESULT
SendHttpResponseAndLogDataHelper(
    W3_CONTEXT                 *pW3Context,
    ULATQ_CONTEXT               pContext,
    BOOL                        fAsync,
    DWORD                       dwFlags,
    HTTP_RESPONSE *             pResponse,
    HTTP_CACHE_POLICY *         pCachePolicy,
    DWORD *                     pcbSent
)
/*++

Routine Description:
    
    Simple wrapper of the UlAtqSendHttpResponse function
    Make sure the log data gets passed on correctly if it is the final send

Arguments:

    pW3Context - W3 Context
    pContext - ULATQ context
    fAsync - Is the send async?
    dwFlags - HTTP.SYS response flags to be used
    pResponse - HTTP_RESPONSE to send
    pCachePolicy - Cache policy (optional) for response
    pcbSent - If sync, filled in with bytes sent upon return
    
Return Value:

    HRESULT

--*/
{
    BOOL fDoLogging = FALSE;
    HRESULT hr;

    if ( pW3Context == NULL ||
         pContext == NULL )
    {
        DBG_ASSERT( FALSE );
        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }

    if (!(dwFlags & HTTP_SEND_RESPONSE_FLAG_MORE_DATA) &&
        pW3Context->QueryDoUlLogging())
    {
        fDoLogging = TRUE;
        if ( FAILED( hr = pW3Context->QueryMainContext()->CollectLoggingData( TRUE ) ) )
        {
            return hr;
        }
    }

    return UlAtqSendHttpResponse(pContext,
                                 fAsync,
                                 dwFlags,
                                 pResponse,
                                 pCachePolicy,
                                 pcbSent,
                                 fDoLogging ? pW3Context->QueryUlLogData() : NULL);
}


HRESULT
W3_RESPONSE::SetHeader(
    DWORD           ulResponseHeaderIndex,
    CHAR *          pszHeaderValue,
    USHORT          cchHeaderValue,
    BOOL            fAppend
)
/*++

Routine Description:
    
    Set a response based on known header index

Arguments:

    ulResponseHeaderIndex - index
    pszHeaderValue - Header value
    cchHeaderValue - Number of characters (without \0) in pszHeaderValue
    fAppend - Should we append the header (otherwise we replace)
    
Return Value:

    HRESULT

--*/
{
    STACK_STRA    ( strNewHeaderValue, 32);
    CHAR *        pszNewHeaderValue = NULL;
    HRESULT       hr;

    DBG_ASSERT( ulResponseHeaderIndex < HttpHeaderResponseMaximum );

    if ( _responseMode == RESPONSE_MODE_RAW )
    {
        hr = SwitchToParsedMode();
        if ( FAILED( hr ) )
        {
            return NULL;
        }
            
        DBG_ASSERT( _responseMode == RESPONSE_MODE_PARSED );
    }
    
    if ( fAppend )
    {
        LPCSTR headerValue = GetHeader( ulResponseHeaderIndex );
        if ( headerValue == NULL )
        {
            fAppend = FALSE;
        }
        else 
        {
            hr = strNewHeaderValue.Append( headerValue );
            if ( FAILED( hr ) )
            {
                return hr;
            }

            hr = strNewHeaderValue.Append( ",", 1 );
            if ( FAILED( hr ) )
            {
                return hr;
            }

            hr = strNewHeaderValue.Append( pszHeaderValue,
                                           cchHeaderValue );
            if ( FAILED( hr ) )
            {
                return hr;
            }
            
            if ( strNewHeaderValue.QueryCCH() > MAXUSHORT )
            {
                return HRESULT_FROM_WIN32( ERROR_INVALID_DATA );
            }
            
            cchHeaderValue = (USHORT)strNewHeaderValue.QueryCCH();
        }
    }

    //
    // Regardless of the "known"osity of the header, we will have to 
    // copy the value.  Do so now.
    //

    hr = _HeaderBuffer.AllocateSpace( fAppend ? strNewHeaderValue.QueryStr() :
                                                pszHeaderValue,
                                      cchHeaderValue,
                                      &pszNewHeaderValue );
    if ( FAILED( hr ) )
    {
        return hr;
    }

    //
    // Set the header
    //
    
    return SetHeaderByReference( ulResponseHeaderIndex,
                                 pszNewHeaderValue,
                                 cchHeaderValue );
}

HRESULT
W3_RESPONSE::SetHeader(
    CHAR *              pszHeaderName,
    USHORT              cchHeaderName,
    CHAR *              pszHeaderValue,
    USHORT              cchHeaderValue,
    BOOL                fAppend,
    BOOL                fForceParsed,
    BOOL                fAlwaysAddUnknown,
    BOOL                fAppendAsDupHeader
)
/*++

Routine Description:
    
    Set a response based on header name

Arguments:

    pszHeaderName - Points to header name
    cchHeaderName - Number of characters (without \0) in pszHeaderName
    pszHeaderValue - Points to the header value
    cchHeaderValue - Number of characters (without \0) in pszHeaderValue
    fAppend - Should we remove any existing value
    fForceParsed - Regardless of mode, set the header structurally
    fAlwaysAddUnknown - Add as a unknown header always
    fAppendAsDupHeader - Adds duplicate header instead of comma delimiting
    
Return Value:

    HRESULT

--*/
{
    DWORD                   cHeaders;
    HTTP_UNKNOWN_HEADER*    pHeader;
    CHAR *                  pszNewName = NULL;
    CHAR *                  pszNewValue = NULL;
    HRESULT                 hr;
    ULONG                   ulHeaderIndex;
    STACK_STRA(             strOldHeaderValue, 128 );

    //
    // Try to stay in raw mode if we're already in that mode
    // 
    // If we are not appending, that means we are just adding a new header
    // so we can just append 
    //
    
    if ( !fForceParsed )
    {
        if ( _responseMode == RESPONSE_MODE_RAW &&
             !fAppend )
        {
            DBG_ASSERT( QueryChunks()->DataChunkType == HttpDataChunkFromMemory );
            DBG_ASSERT( QueryChunks()->FromMemory.pBuffer == _strRawCoreHeaders.QueryStr() );
        
            hr = _strRawCoreHeaders.Append( pszHeaderName, cchHeaderName );
            if ( FAILED( hr ) )
            {
                return hr;
            }
        
            hr = _strRawCoreHeaders.Append( ": ", 2 );
            if ( FAILED( hr ) )
            {
                return hr;
            }
        
            hr = _strRawCoreHeaders.Append( pszHeaderValue, cchHeaderValue );
            if ( FAILED( hr ) )
            {
                return hr;
            }
        
            hr = _strRawCoreHeaders.Append( "\r\n", 2 );
            if ( FAILED( hr ) )
            {
                return hr;
            }
            
            //
            // Patch the headers back in
            //
            
            QueryChunks()->FromMemory.pBuffer = _strRawCoreHeaders.QueryStr();
            QueryChunks()->FromMemory.BufferLength = _strRawCoreHeaders.QueryCB();
        
            return NO_ERROR;
        }
        else 
        {
            //
            // No luck.  We'll have to parse the headers and switch into parsed
            // mode.
            //
        
            if ( _responseMode == RESPONSE_MODE_RAW )
            {
                hr = SwitchToParsedMode();
                if ( FAILED( hr ) )
                {
                    return hr;
                }
            }
            
            DBG_ASSERT( _responseMode == RESPONSE_MODE_PARSED );
        }
    }

    //
    // If we're appending, then get the old header value (if any) and 
    // append the new value (with a comma delimiter)
    //

    if ( fAppend && !fAppendAsDupHeader )
    {
        hr = GetHeader( pszHeaderName,
                        &strOldHeaderValue );
        if ( FAILED( hr ) )
        {
            fAppend = FALSE;
            hr = NO_ERROR;
        }
        else 
        {
            hr = strOldHeaderValue.Append( ",", 1 );
            if ( FAILED( hr ) )
            {
                return hr;
            }

            hr = strOldHeaderValue.Append( pszHeaderValue,
                                           cchHeaderValue );
            if ( FAILED( hr ) )
            {
                return hr;
            }
            
            if ( strOldHeaderValue.QueryCCH() > MAXUSHORT )
            {
                return HRESULT_FROM_WIN32( ERROR_INVALID_DATA );
            }

            cchHeaderValue = (USHORT)strOldHeaderValue.QueryCCH();

            DeleteHeader( pszHeaderName );
        }
    }

    //
    // Regardless of the "known"osity of the header, we will have to 
    // copy the value.  Do so now.
    //

    hr = _HeaderBuffer.AllocateSpace( ( fAppend && !fAppendAsDupHeader ) ? strOldHeaderValue.QueryStr() : pszHeaderValue,
                                      cchHeaderValue,
                                      &pszNewValue );
    if ( FAILED( hr ) )
    {
        return hr;
    }

    //
    // Is this a known header?  If so, we can just set by reference now
    // since we have copied the header value
    //

    if ( !fAlwaysAddUnknown )
    {
        ulHeaderIndex = RESPONSE_HEADER_HASH::GetIndex( pszHeaderName );
        if ( ulHeaderIndex != UNKNOWN_INDEX )
        {
            DBG_ASSERT( ulHeaderIndex < HttpHeaderResponseMaximum );

            return SetHeaderByReference( ulHeaderIndex,
                                         pszNewValue,
                                         cchHeaderValue,
                                         fForceParsed );
        }
    }

    if ( ( strchr( pszNewValue, '\r' ) != NULL ) ||
         ( strchr( pszNewValue, '\n' ) != NULL ) )
    {
        return HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);
    }

    //
    // OK.  This is an unknown header.  Make a copy of the header name as
    // well and proceed the long way.
    //

    hr = _HeaderBuffer.AllocateSpace( pszHeaderName,
                                      cchHeaderName,
                                      &pszNewName );
    if ( FAILED( hr ) )
    {
        return hr;
    }

    cHeaders = _ulHttpResponse.Headers.UnknownHeaderCount + 1;

    if ( cHeaders * sizeof( HTTP_UNKNOWN_HEADER ) 
          > _bufUnknownHeaders.QuerySize() )
    {
        if ( !_bufUnknownHeaders.Resize( cHeaders * 
                                         sizeof( HTTP_UNKNOWN_HEADER ),
                                         512 ) )
        {
            return HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );
        }
    }
    _ulHttpResponse.Headers.UnknownHeaderCount++;
    _ulHttpResponse.Headers.pUnknownHeaders = (HTTP_UNKNOWN_HEADER*)
                                              _bufUnknownHeaders.QueryPtr();

    //
    // We should have a place to put the header now!
    //

    pHeader = &(_ulHttpResponse.Headers.pUnknownHeaders[ cHeaders - 1 ]);
    pHeader->pName = pszNewName;
    pHeader->NameLength = cchHeaderName;
    pHeader->pRawValue = pszNewValue;
    pHeader->RawValueLength = cchHeaderValue;

    _fResponseTouched = TRUE;

    return S_OK;
}

HRESULT
W3_RESPONSE::SetHeaderByReference(
    DWORD           ulResponseHeaderIndex,
    CHAR *          pszHeaderValue,
    USHORT          cchHeaderValue,
    BOOL            fForceParsed
)
/*++

Routine Description:
    
    Set a header value by reference.  In other words, the caller takes the
    reponsibility of managing the memory referenced.  The other setheader
    methods copy the header values to a private buffer.

Arguments:

    ulResponseHeaderIndex - index
    pszHeaderValue - Header value
    cbHeaderValue - Size of header value in characters (without 0 terminator)
    fForceParsed - Set to TRUE if we should always used parsed
    
Return Value:

    HRESULT

--*/
{
    HTTP_KNOWN_HEADER *         pHeader;
    HRESULT                     hr;

    DBG_ASSERT( ulResponseHeaderIndex < HttpHeaderResponseMaximum );
    DBG_ASSERT( pszHeaderValue != NULL || cchHeaderValue == 0 );

    if ( !fForceParsed )
    {
        if ( _responseMode == RESPONSE_MODE_RAW )
        {
            hr = SwitchToParsedMode();
            if ( FAILED( hr ) )
            {
                return hr;
            }
            
            DBG_ASSERT( _responseMode == RESPONSE_MODE_PARSED );
        }
    }

    //
    // Set the header
    //
    
    pHeader = &(_ulHttpResponse.Headers.KnownHeaders[ ulResponseHeaderIndex ]);

    if ( cchHeaderValue == 0 )
    {
        pHeader->pRawValue = NULL;
    }
    else
    {
        if ( ( strchr( pszHeaderValue, '\r' ) != NULL ) ||
             ( strchr( pszHeaderValue, '\n' ) != NULL ) )
        {
            return HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);
        }

        pHeader->pRawValue = pszHeaderValue;
        _fResponseTouched = TRUE;
    }
    pHeader->RawValueLength = cchHeaderValue;

    return NO_ERROR;
}

HRESULT
W3_RESPONSE::DeleteHeader(
    CHAR *             pszHeaderName
)
/*++

Routine Description:
    
    Delete a response header

Arguments:

    pszHeaderName - Header to delete
    
Return Value:

    HRESULT

--*/
{
    ULONG                   ulHeaderIndex;
    HRESULT                 hr;
    HTTP_UNKNOWN_HEADER *   pUnknownHeader;
    DWORD                   i;

    if ( _responseMode == RESPONSE_MODE_RAW )
    {
        hr = SwitchToParsedMode();
        if ( FAILED( hr ) )
        {
            return hr;
        }
    }
    DBG_ASSERT( _responseMode == RESPONSE_MODE_PARSED );
    
    //
    // Is this a known header?  If so, we can just set by reference now
    // since we have copied the header value
    // 
    
    ulHeaderIndex = RESPONSE_HEADER_HASH::GetIndex( pszHeaderName );
    if ( ulHeaderIndex != UNKNOWN_INDEX && 
         ulHeaderIndex < HttpHeaderResponseMaximum )
    {
        _ulHttpResponse.Headers.KnownHeaders[ ulHeaderIndex ].pRawValue = "";
        _ulHttpResponse.Headers.KnownHeaders[ ulHeaderIndex ].RawValueLength = 0;
    }
    else
    {
        //
        // Unknown header.  First check if it exists
        //
            
        for ( i = 0;
              i < _ulHttpResponse.Headers.UnknownHeaderCount;
              i++ )
        {
            pUnknownHeader = &(_ulHttpResponse.Headers.pUnknownHeaders[ i ]);
            DBG_ASSERT( pUnknownHeader != NULL );
            
            if ( _stricmp( pUnknownHeader->pName, pszHeaderName ) == 0 )
            {
                break;
            }
        }
        
        if ( i < _ulHttpResponse.Headers.UnknownHeaderCount )
        {
            //
            // Now shrink the array to remove the header
            //
            
            memmove( _ulHttpResponse.Headers.pUnknownHeaders + i,
                     _ulHttpResponse.Headers.pUnknownHeaders + i + 1,
                     ( _ulHttpResponse.Headers.UnknownHeaderCount - i - 1 ) * 
                     sizeof( HTTP_UNKNOWN_HEADER ) );
        
            _ulHttpResponse.Headers.UnknownHeaderCount--;
        }
    }
    
    return NO_ERROR;
}

VOID
W3_RESPONSE::FindStringId(
    VOID
)
/*++

Routine Description:
    
    Make the SendCustomError() ISAPI call a little more friendly.  If the
    user specifies a status/substatus, then try to find the matching 
    string ID so that we can send a built in error 

Arguments:

    None
    
Return Value:

    None

--*/
{
    if ( QueryStatusCode() == 403 )
    {
        switch( _subError.mdSubError )
        {
        case MD_ERROR_SUB403_EXECUTE_ACCESS_DENIED:
            _subError.dwStringId = IDS_EXECUTE_ACCESS_DENIED;
            break;

        case MD_ERROR_SUB403_READ_ACCESS_DENIED:
            _subError.dwStringId = IDS_READ_ACCESS_DENIED;
            break;

        case MD_ERROR_SUB403_WRITE_ACCESS_DENIED:
            _subError.dwStringId = IDS_WRITE_ACCESS_DENIED;
            break;

        case MD_ERROR_SUB403_SSL_REQUIRED:
            _subError.dwStringId = IDS_SSL_REQUIRED;
            break;

        case MD_ERROR_SUB403_SSL128_REQUIRED:
            _subError.dwStringId = IDS_SSL128_REQUIRED;
            break;

        case MD_ERROR_SUB403_ADDR_REJECT:
            _subError.dwStringId = IDS_ADDR_REJECT;
            break;

        case MD_ERROR_SUB403_CERT_REQUIRED:
            _subError.dwStringId = IDS_CERT_REQUIRED;
            break;

        case MD_ERROR_SUB403_TOO_MANY_USERS:
            _subError.dwStringId = IDS_TOO_MANY_USERS;
            break;

        case MD_ERROR_SUB403_PWD_CHANGE:
            _subError.dwStringId = IDS_PWD_CHANGE;
            break;

        case MD_ERROR_SUB403_MAPPER_DENY_ACCESS:
            _subError.dwStringId = IDS_MAPPER_DENY_ACCESS;
            break;

        case MD_ERROR_SUB403_CERT_REVOKED:
            _subError.dwStringId = IDS_CERT_REVOKED;
            break;

        case MD_ERROR_SUB403_DIR_LIST_DENIED:
            _subError.dwStringId = IDS_DIR_LIST_DENIED;
            break;

        case MD_ERROR_SUB403_CERT_BAD:
            _subError.dwStringId = IDS_CERT_BAD;
            break;

        case MD_ERROR_SUB403_CERT_TIME_INVALID:
            _subError.dwStringId = IDS_CERT_TIME_INVALID;
            break;

        case MD_ERROR_SUB403_APPPOOL_DENIED:
            _subError.dwStringId = IDS_APPPOOL_DENIED;
            break;

        case MD_ERROR_SUB403_INSUFFICIENT_PRIVILEGE_FOR_CGI:
            _subError.dwStringId = IDS_INSUFFICIENT_PRIVILEGE_FOR_CGI;
            break;
        }
    }
    else if ( QueryStatusCode() == 502 && 
              _subError.mdSubError == MD_ERROR_SUB502_TIMEOUT )
    {
        _subError.dwStringId = IDS_CGI_APP_TIMEOUT;
    }
    else if ( QueryStatusCode() == 502 &&
              _subError.mdSubError == MD_ERROR_SUB502_PREMATURE_EXIT )
    {
        _subError.dwStringId = IDS_BAD_CGI_APP;
    }
}

HRESULT
W3_RESPONSE::SetStatus(
    USHORT              statusCode,
    STRA &              strReason,
    HTTP_SUB_ERROR &    subError
)
/*++

Routine Description:
    
    Set the status/reason of the response

Arguments:

    status - Status code
    strReason - Reason string
    subError - Optional (default 0)
    
Return Value:

    HRESULT

--*/
{
    HRESULT             hr;
    CHAR *              pszNewStatus;
   
    if ( strReason.QueryCCH() > MAXUSHORT )
    {
        return HRESULT_FROM_WIN32( ERROR_INVALID_DATA );
    }
    
    hr = _HeaderBuffer.AllocateSpace( strReason.QueryStr(),
                                      strReason.QueryCCH(),
                                      &pszNewStatus );
    if ( FAILED( hr ) )
    {
        return hr;
    }
    
    _ulHttpResponse.StatusCode = statusCode;
    _ulHttpResponse.pReason = pszNewStatus;
    _ulHttpResponse.ReasonLength = (USHORT) strReason.QueryCCH();
    _subError = subError;
    
    return NO_ERROR;
}

HRESULT
W3_RESPONSE::GetStatusLine(
    STRA *              pstrStatusLine
)
/*++

Routine Description:
    
    What a stupid little function.  Here we generate what the response's
    status line will be

Arguments:

    pstrStatusLine - Filled with status like

Return Value:

    HRESULT

--*/
{
    HRESULT             hr = NO_ERROR;
    CHAR                achNum[ 32 ];
    
    if ( pstrStatusLine == NULL )
    {
        DBG_ASSERT( FALSE );
        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }
    
    hr = pstrStatusLine->Copy( "HTTP/1.1 " );
    if ( FAILED( hr ) )
    {
        return hr;
    }
    
    _itoa( _ulHttpResponse.StatusCode, achNum, 10 );
    
    hr = pstrStatusLine->Append( achNum );
    if ( FAILED( hr ) )
    {
        return hr;
    }
    
    hr = pstrStatusLine->Append( " ", 1 );
    if ( FAILED( hr ) )
    {
        return hr;
    }

    hr = pstrStatusLine->Append( _ulHttpResponse.pReason,
                                 _ulHttpResponse.ReasonLength );

    return hr;
} 

HRESULT
W3_RESPONSE::GetHeader(
    CHAR *                  pszHeaderName,
    STRA *                  pstrHeaderValue
)
/*++

Routine Description:
    
    Get a response header

Arguments:

    pszHeaderName - Header to retrieve
    pstrHeaderValue - Filled with header value
    
Return Value:

    HRESULT

--*/
{
    ULONG                       ulHeaderIndex;
    HTTP_UNKNOWN_HEADER *       pUnknownHeader;
    HTTP_KNOWN_HEADER *         pKnownHeader;
    HRESULT                     hr;
    BOOL                        fFound = FALSE;
    DWORD                       i;

    if ( pstrHeaderValue == NULL ||
         pszHeaderName == NULL )
    {
        DBG_ASSERT( FALSE );
        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }

    if ( _responseMode == RESPONSE_MODE_RAW )
    {
        hr = SwitchToParsedMode();
        if ( FAILED( hr ) )
        {
            return hr;
        }
    }
    DBG_ASSERT( _responseMode == RESPONSE_MODE_PARSED );

    ulHeaderIndex = RESPONSE_HEADER_HASH::GetIndex( pszHeaderName );
    if ( ulHeaderIndex == UNKNOWN_INDEX )
    {
        //
        // Unknown header
        //
        
        for ( i = 0; i < _ulHttpResponse.Headers.UnknownHeaderCount; i++ )
        {
            pUnknownHeader = &(_ulHttpResponse.Headers.pUnknownHeaders[ i ]);
            DBG_ASSERT( pUnknownHeader != NULL );
            
            if ( _stricmp( pszHeaderName,
                           pUnknownHeader->pName ) == 0 )
            {
                if ( !fFound )
                {
                    hr = pstrHeaderValue->Copy( pUnknownHeader->pRawValue,
                                               pUnknownHeader->RawValueLength );

                    if ( FAILED( hr ) )
                    {
                        return HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );
                    }
                }
                else
                {
                    hr = pstrHeaderValue->Append( "," );
                    
                    if ( FAILED( hr ) )
                    {
                        return HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );
                    }

                    hr = pstrHeaderValue->Append( pUnknownHeader->pRawValue,
                                                  pUnknownHeader->RawValueLength );

                    if ( FAILED( hr ) )
                    {
                        return HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );
                    }
                }

                fFound = TRUE;
            } 
        }

        if ( fFound )
        {
            return NO_ERROR;
        }
        else
        {
            return HRESULT_FROM_WIN32( ERROR_INVALID_INDEX );
        }
    }
    else
    {
        pKnownHeader = &(_ulHttpResponse.Headers.KnownHeaders[ ulHeaderIndex ]);
        if ( pKnownHeader->pRawValue != NULL &&
             pKnownHeader->RawValueLength != 0 )
        {
            hr = pstrHeaderValue->Copy( pKnownHeader->pRawValue,
                                        pKnownHeader->RawValueLength );

            //
            // Still need to loop through the unknown headers, in case
            // this header has been added there.
            //

            for ( i = 0; i < _ulHttpResponse.Headers.UnknownHeaderCount; i++ )
            {
                pUnknownHeader = &(_ulHttpResponse.Headers.pUnknownHeaders[ i ]);
                DBG_ASSERT( pUnknownHeader != NULL );
            
                if ( _stricmp( pszHeaderName,
                               pUnknownHeader->pName ) == 0 )
                {
                    hr = pstrHeaderValue->Append( "," );

                    if ( FAILED( hr ) )
                    {
                        return HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );
                    }

                    hr = pstrHeaderValue->Append( pUnknownHeader->pRawValue,
                                                  pUnknownHeader->RawValueLength );

                    if ( FAILED( hr ) )
                    {
                        return HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );
                    }
                }
            }

            return hr;
        }
        else
        {
            return HRESULT_FROM_WIN32( ERROR_INVALID_INDEX );
        }
    }
}

VOID
W3_RESPONSE::ClearHeaders(
    VOID
)
/*++

Routine Description:
    
    Clear headers

Arguments:
    
    None
    
Return Value:

    None

--*/
{
    HTTP_UNKNOWN_HEADER *   pHeader;

    memset( &(_ulHttpResponse.Headers),
            0,
            sizeof( _ulHttpResponse.Headers ) );

    //
    // Set the known "server" header to blank and add
    // an unknown header called "server".  This is to
    // prevent munging of the server header by http.sys.
    //

    _ulHttpResponse.Headers.KnownHeaders[ HttpHeaderServer ].pRawValue = "";
    _ulHttpResponse.Headers.KnownHeaders[ HttpHeaderServer ].RawValueLength = 0;

    _ulHttpResponse.Headers.UnknownHeaderCount = 1;
    _ulHttpResponse.Headers.pUnknownHeaders = (HTTP_UNKNOWN_HEADER*)_bufUnknownHeaders.QueryPtr();

    pHeader = &(_ulHttpResponse.Headers.pUnknownHeaders[ 0 ]);
    pHeader->pName = SERVER_HEADER_NAME;
    pHeader->NameLength = sizeof( SERVER_HEADER_NAME ) - 1;
    pHeader->pRawValue = SERVER_HEADER_VALUE;
    pHeader->RawValueLength = sizeof( SERVER_HEADER_VALUE ) - 1;
}

HRESULT
W3_RESPONSE::AddFileHandleChunk(
    HANDLE                  hFile,
    ULONGLONG               cbOffset,
    ULONGLONG               cbLength
)
/*++

Routine Description:
    
    Add file handle chunk to response

Arguments:
    
    hFile - File handle
    cbOffset - Offset in file
    cbLength - Length of chunk
    
Return Value:

    HRESULT

--*/
{
    HTTP_DATA_CHUNK         DataChunk;
    HRESULT                 hr;

    _fResponseTouched = TRUE;
    
    DataChunk.DataChunkType = HttpDataChunkFromFileHandle;
    DataChunk.FromFileHandle.ByteRange.StartingOffset.QuadPart = cbOffset;
    DataChunk.FromFileHandle.ByteRange.Length.QuadPart = cbLength;
    DataChunk.FromFileHandle.FileHandle = hFile;
    
    hr = InsertDataChunk( &DataChunk, -1 );
    if ( FAILED( hr ) )
    {
        return hr;
    }

    //
    // Update content length count
    //
    
    _cbContentLength += cbLength;
    
    return NO_ERROR;
}

HRESULT
W3_RESPONSE::AddFragmentChunk(
    WCHAR *                 pszFragmentName,
    USHORT                  dwNameLength
)
/*++

Routine Description:
    
    Add fragment chunk to response

Arguments:

    pszFragmentName - name of the fragment
    dwNameLength - length of the name
    
Return Value:

    HRESULT

--*/
{
    HTTP_DATA_CHUNK         DataChunk;

    _fResponseTouched = TRUE;

    DataChunk.DataChunkType = HttpDataChunkFromFragmentCache;
    DataChunk.FromFragmentCache.pFragmentName = pszFragmentName;
    DataChunk.FromFragmentCache.FragmentNameLength = dwNameLength;
    
    return InsertDataChunk( &DataChunk, -1 );
}

HRESULT
W3_RESPONSE::AddMemoryChunkByReference(
    PVOID                   pvBuffer,
    DWORD                   cbBuffer
)
/*++

Routine Description:
    
    Add memory chunk to W3_RESPONSE.  Don't copy the memory -> we assume
    the caller will manage the memory lifetime

Arguments:
   
    pvBuffer - Memory buffer
    cbBuffer - Size of memory buffer 
    
Return Value:

    HRESULT

--*/
{
    HTTP_DATA_CHUNK         DataChunk;
    HRESULT                 hr;

    _fResponseTouched = TRUE;
    
    DataChunk.DataChunkType = HttpDataChunkFromMemory;
    DataChunk.FromMemory.pBuffer = pvBuffer;
    DataChunk.FromMemory.BufferLength = cbBuffer;
    
    hr = InsertDataChunk( &DataChunk, -1 );
    if ( FAILED( hr ) )
    {
        return hr;
    }

    //
    // Update content length count
    //
    
    _cbContentLength += cbBuffer;

    return NO_ERROR;
}

HRESULT
W3_RESPONSE::Clear(
    BOOL                    fClearEntityOnly
)
/*++

Routine Description:
    
    Clear response

Arguments:

    fEntityOnly - Set to TRUE to clear only entity
    
Return Value:

    HRESULT

--*/
{
    HRESULT             hr = NO_ERROR;
    
    if ( !fClearEntityOnly )
    {
        //
        // Must we send the response in raw mode?
        //
    
        _fIncompleteHeaders = FALSE;

        //
        // Raw mode management
        //    
    
        _strRawCoreHeaders.Reset();
        _cFirstEntityChunk  = 0;
    
        //
        // Always start in parsed mode
        //
    
        _responseMode = RESPONSE_MODE_PARSED;

        //
        // Clear headers/status
        //
        
        ClearHeaders();
    }

    _cChunks = _cFirstEntityChunk;
    _cbContentLength = 0;    
    
    return hr;
}

HRESULT
W3_RESPONSE::SwitchToParsedMode(
    VOID
)
/*++

Routine Description:

    Switch to parsed mode

Arguments:

    None
    
Return Value:

    HRESULT

--*/
{
    HRESULT                 hr;
    CHAR *                  pszHeaders;
    HTTP_DATA_CHUNK *       pCurrentChunk;
    DWORD                   i;
    
    DBG_ASSERT( _responseMode == RESPONSE_MODE_RAW );
   
    //
    // Loop thru all header chunks and parse them out
    //
    
    for ( i = 0;
          i < _cFirstEntityChunk;
          i++ )
    {
        pCurrentChunk = &(QueryChunks()[ i ]);
        
        DBG_ASSERT( pCurrentChunk->DataChunkType == HttpDataChunkFromMemory );
        
        pszHeaders = (CHAR*) pCurrentChunk->FromMemory.pBuffer;        
        
        if ( i == 0 )
        {
            //
            // The first header chunk contains core headers plus status line
            //
            // (remember to skip the status line)
            //
            
            pszHeaders = strstr( pszHeaders, "\r\n" );
            DBG_ASSERT( pszHeaders != NULL );
            
            pszHeaders += 2;
            DBG_ASSERT( *pszHeaders != '\0' );
        }
        
        hr = ParseHeadersFromStream( pszHeaders );
        if ( FAILED( hr ) )
        {
            return hr;
        }
    }
    
    _strRawCoreHeaders.Reset();
    
    //
    // Any chunks in the response which are actually headers should be 
    // removed
    //
    
    if ( _cFirstEntityChunk != 0 )
    {
        memmove( QueryChunks(),
                 QueryChunks() + _cFirstEntityChunk,
                 ( _cChunks - _cFirstEntityChunk ) * sizeof( HTTP_DATA_CHUNK ) );
        
        _cChunks = _cChunks - _cFirstEntityChunk;
        _cFirstEntityChunk = 0;
    }
    
    //
    // Cool.  Now we are in parsed mode
    //
    
    _responseMode = RESPONSE_MODE_PARSED;
    
    return NO_ERROR;
}

HRESULT
W3_RESPONSE::SwitchToRawMode(
    CHAR *                  pszAdditionalHeaders,
    DWORD                   cchAdditionalHeaders
)
/*++

Routine Description:

    Switch into raw mode.
    Builds a raw response for use by raw data filters and/or ISAPI.  This
    raw response will be a set of chunks which contact the entire response
    including serialized headers.
    
Arguments:

    pszAdditionalHeaders - Additional raw headers to add
    cchAdditionalHeaders - Size of additional headers
    
Return Value:

    HRESULT

--*/
{
    HRESULT                 hr = NO_ERROR;
    HTTP_DATA_CHUNK         dataChunk;
    
    DBG_ASSERT( _responseMode == RESPONSE_MODE_PARSED );

    //
    // Generate raw core headers
    // 
    
    hr = BuildRawCoreHeaders();
    if ( FAILED( hr ) )
    {
        return hr;
    }
    
    //
    // Now fix up the chunks so the raw stream headers are in the right place
    //
    
    //
    // First chunk is the raw core headers (includes the status line)
    //
    
    dataChunk.DataChunkType = HttpDataChunkFromMemory;
    dataChunk.FromMemory.pBuffer = _strRawCoreHeaders.QueryStr();
    dataChunk.FromMemory.BufferLength = _strRawCoreHeaders.QueryCB();
    
    hr = InsertDataChunk( &dataChunk, 0 );
    if ( FAILED( hr ) )
    {
        return hr;
    }
    
    //
    // Remember the beginning of real entity
    //
    
    _cFirstEntityChunk = 1;

    //
    // Now add any additional header stream
    // 
    
    if ( cchAdditionalHeaders != 0 )
    {
        dataChunk.DataChunkType = HttpDataChunkFromMemory;
        dataChunk.FromMemory.pBuffer = pszAdditionalHeaders;
        dataChunk.FromMemory.BufferLength = cchAdditionalHeaders;
        
        hr = InsertDataChunk( &dataChunk, 1 );
        if ( FAILED( hr ) )
        {
            return hr;
        }
        
        _cFirstEntityChunk++;
    }
    
    //
    // We're now in raw mode
    //
    
    _responseMode = RESPONSE_MODE_RAW;
    
    return NO_ERROR;
}

HRESULT
W3_RESPONSE::SendResponse(
    W3_CONTEXT *            pW3Context,
    DWORD                   dwResponseFlags,
    HTTP_CACHE_POLICY *     pCachePolicy,
    DWORD *                 pcbSent
)
/*++

Routine Description:
    
    Send a W3_RESPONSE to the client.

Arguments:

    pW3Context - W3 context (contains amongst other things ULATQ context)
    dwResponseFlags - W3_RESPONSE* flags
    pCachePolicy - Cache-policy controlling cachability of the response
    pcbSent - Filled with number of bytes sent (if sync)
    
Return Value:

    HRESULT

--*/
{
    HRESULT                 hr;
    DWORD                   dwFlags = 0;
    HTTP_DATA_CHUNK *       pStartChunk;
    BOOL                    fAsync;
    BOOL                    fDoCompression = FALSE;

    if ( pW3Context == NULL )
    {
        DBG_ASSERT( FALSE );
        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }

    DBG_ASSERT( CheckSignature() );

    if ( dwResponseFlags & W3_RESPONSE_SUPPRESS_HEADERS )
    {
        if (_responseMode == RESPONSE_MODE_RAW)
        {
            _cChunks = _cChunks - _cFirstEntityChunk;

            memmove( QueryChunks(),
                     QueryChunks() + _cFirstEntityChunk,
                     _cChunks * sizeof( HTTP_DATA_CHUNK ) );

            _cFirstEntityChunk = 0;
        }

        return SendEntity( pW3Context,
                           dwResponseFlags,
                           pcbSent );
    }
    
    if ( dwResponseFlags & W3_RESPONSE_MORE_DATA )
    {
        //
        // More data follows this response?
        //

        dwFlags |= HTTP_SEND_RESPONSE_FLAG_MORE_DATA;
    }
    
    //
    // UL needs to see the disconnect flag on the initial response
    // so that it knows to send the proper connection header to the
    // client.  This needs to happen even if the more data flag is
    // set.
    //

    if ( dwResponseFlags & W3_RESPONSE_DISCONNECT )
    {
        //
        // Disconnect or not?
        // 
    
        dwFlags |= HTTP_SEND_RESPONSE_FLAG_DISCONNECT;
    }
    
    //
    // Setup any headers which are needed for dynamic compression, if 
    // supported for this request
    //

    if ( !_fIncompleteHeaders &&
         pW3Context->QueryUrlContext() != NULL )
    {
        W3_METADATA *           pMetaData;

        pMetaData = pW3Context->QueryUrlContext()->QueryMetaData();
        DBG_ASSERT( pMetaData != NULL );

        if ( !pW3Context->QueryDoneWithCompression() &&
             pMetaData->QueryDoDynamicCompression() )
        {
            if (FAILED(hr = HTTP_COMPRESSION::OnSendResponse(
                    pW3Context )))
            {
                return hr;
            }

            if (pW3Context->QueryCompressionContext() != NULL)
            {
                fDoCompression = TRUE;
            }
        }
    }

    //
    // Convert to raw if filtering is needed 
    //
    // OR if an ISAPI once gave us incomplete headers and thus we need to
    // go back to raw mode (without terminating headers) 
    //
    // OR an ISAPI has called WriteClient() before sending a response
    //
    
    if ( pW3Context->IsNotificationNeeded( SF_NOTIFY_SEND_RAW_DATA ) || 
         _fIncompleteHeaders ||
         _fResponseSent || 
         fDoCompression )
    {
        if ( _responseMode == RESPONSE_MODE_PARSED )
        {
            hr = GenerateAutomaticHeaders( pW3Context,
                                           &dwFlags );
            if ( FAILED( hr ) )
            {
                return hr;
            }

            hr = SwitchToRawMode( _fIncompleteHeaders ? "" : "\r\n",
                                  _fIncompleteHeaders ? 0 : 2 );
            if ( FAILED( hr ) )
            {
                return hr;
            }
        }

        DBG_ASSERT( _responseMode == RESPONSE_MODE_RAW );

        //
        // OK.  This is a little lame.  But the _strRawCoreHeaders may have
        // changed a bit since we last setup the chunks for the header
        // stream.  Just adjust it here
        //

        pStartChunk = QueryChunks();
        pStartChunk[0].FromMemory.pBuffer = _strRawCoreHeaders.QueryStr();
        pStartChunk[0].FromMemory.BufferLength = _strRawCoreHeaders.QueryCB();

        //
        // If we're going to be kill entity and/or headers, do so now before
        // calling into the filter
        //

        if ( dwResponseFlags & W3_RESPONSE_SUPPRESS_ENTITY )
        {
            _cChunks = _cFirstEntityChunk;
        }
    }

    //
    // From now on, we must send any future responses raw
    //

    _fResponseSent = TRUE;

    //
    // Async?
    //

    fAsync = dwResponseFlags & W3_RESPONSE_ASYNC ? TRUE : FALSE;

    //
    // If we have a send raw filter, start processing the chunks now.
    //

    if ( pW3Context->IsNotificationNeeded( SF_NOTIFY_SEND_RAW_DATA ) ||
         fDoCompression )
    {
        _cCurrentChunk = 0;
        _cbCurrentOffset = 0;
        _cbTotalCompletion = 0;
        _dwSendFlags = dwFlags;
        
        return ResumeResponseTransfer( pW3Context,
                                       FALSE,
                                       0,
                                       ERROR_SUCCESS,
                                       fAsync,
                                       pcbSent );
    }

    //
    // The simple non-filter case, just send out the darn response
    //

    if ( _responseMode == RESPONSE_MODE_RAW )
    {
        if ( dwResponseFlags & W3_RESPONSE_SUPPRESS_ENTITY )
        {
            _cChunks = _cFirstEntityChunk;
        }
        
        hr = SendEntityBodyAndLogDataHelper(
                    pW3Context,
                    pW3Context->QueryUlatqContext(),
                    fAsync,
                    dwFlags | HTTP_SEND_RESPONSE_FLAG_RAW_HEADER,
                    _cChunks,                                  
                    _cChunks ? QueryChunks() : NULL,
                    pcbSent );
    }
    else
    {
        if ( dwResponseFlags & W3_RESPONSE_SUPPRESS_ENTITY )
        {
            _cChunks = 0;
        } 

        _ulHttpResponse.EntityChunkCount = _cChunks;
        _ulHttpResponse.pEntityChunks = _cChunks ? QueryChunks() : NULL;

        hr = SendHttpResponseAndLogDataHelper(
                    pW3Context,
                    pW3Context->QueryUlatqContext(),
                    fAsync,
                    dwFlags,
                    &(_ulHttpResponse),
                    pCachePolicy,
                    pcbSent );
    }

    if ( FAILED( hr ) )
    {
        //
        // If we couldn't send the response thru UL, then this is really bad.
        // Do not reset _fSendRawData since no response will get thru
        // unless the failure was due to a fragment missing from the send
        //
        if (hr == HRESULT_FROM_WIN32(ERROR_PATH_NOT_FOUND))
        {
            _fResponseSent = FALSE;
        }
    }
        
    return hr;
}

HRESULT
W3_RESPONSE::SendEntity(
    W3_CONTEXT *            pW3Context,
    DWORD                   dwResponseFlags,
    DWORD *                 pcbSent
)
/*++

Routine Description:
    
    Send entity to the client

Arguments:

    pMainContext - Main context (contains amongst other things ULATQ context)
    dwResponseFlags - W3_REPSONSE flags
    pcbSent - Number of bytes sent (when sync)

Return Value:

    Win32 Error indicating status

--*/
{
    HRESULT                 hr = NO_ERROR;
    DWORD                   dwFlags = 0;
    BOOL                    fAsync;
    BOOL                    fDoCompression = FALSE;
    BOOL                    fOldResponseSent;

    if ( pW3Context == NULL )
    {
        DBG_ASSERT( FALSE );
        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }

    DBG_ASSERT( CheckSignature() );
    
    //
    // If we get to here and a response hasn't yet been sent, then we must
    // call HttpSendEntity first (not that HTTP.SYS lets us do that)
    //
    
    fOldResponseSent = _fResponseSent;
    if ( !_fResponseSent )
    {
        _fResponseSent = TRUE;
        dwFlags |= HTTP_SEND_RESPONSE_FLAG_RAW_HEADER;
    }
    
    //
    // Note that both HTTP_SEND_RESPONSE_FLAG_MORE_DATA and 
    // HTTP_SEND_RESPONSE_FLAG_DISCONNECT cannot be set at the same time
    //

    if ( dwResponseFlags & W3_RESPONSE_MORE_DATA )
    {
        dwFlags |= HTTP_SEND_RESPONSE_FLAG_MORE_DATA;
    }
    else if ( dwResponseFlags & W3_RESPONSE_DISCONNECT )
    {
        dwFlags |= HTTP_SEND_RESPONSE_FLAG_DISCONNECT;
    }
    
    //
    // Do we need to do compression?
    //

    if ( pW3Context->QueryUrlContext() != NULL )
    {
        W3_METADATA *pMetaData;
        pMetaData = pW3Context->QueryUrlContext()->QueryMetaData();
        DBG_ASSERT( pMetaData != NULL);

        if (!pW3Context->QueryDoneWithCompression() &&
            pMetaData->QueryDoDynamicCompression())
        {
            fDoCompression = TRUE;
        }
    }

    //
    // If we are suppressing entity (in case of HEAD for example) do it
    // now by clearing the chunk count
    //

    if ( dwResponseFlags & W3_RESPONSE_SUPPRESS_ENTITY )
    {
        _cChunks = 0;
    }
    
    fAsync = ( dwResponseFlags & W3_RESPONSE_ASYNC ) ? TRUE : FALSE;

    //
    // Send chunks to be processed if filtering if needed (and there are
    // chunks available)
    //
        
    if ( pW3Context->IsNotificationNeeded( SF_NOTIFY_SEND_RAW_DATA ) ||
         fDoCompression )
    {
        _cCurrentChunk = _cFirstEntityChunk;
        _cbCurrentOffset = 0;
        _cbTotalCompletion = 0;
        _dwSendFlags = dwFlags;
        
        return ResumeResponseTransfer( pW3Context,
                                       FALSE,
                                       0,
                                       ERROR_SUCCESS,
                                       fAsync,
                                       pcbSent );
    }
    
    //
    // Finally, send stuff out
    //

    hr = SendEntityBodyAndLogDataHelper(
                pW3Context,
                pW3Context->QueryUlatqContext(),
                fAsync,
                dwFlags,
                _cChunks,
                _cChunks ? QueryChunks() : NULL,
                pcbSent );

    if (FAILED(hr))
    {
        //
        // If we couldn't send the response thru UL, then this is really bad.
        // Do not reset _fSendRawData since no response will get thru
        // unless the failure was due to a fragment missing from the send
        //
        if (hr == HRESULT_FROM_WIN32(ERROR_PATH_NOT_FOUND))
        {
            _fResponseSent = fOldResponseSent;
        }
    }

    return hr;
}

HRESULT
W3_RESPONSE::GenerateAutomaticHeaders(
    W3_CONTEXT *                pW3Context,
    DWORD *                     pdwFlags
)
/*++

Routine Description:

    Parse-Mode only function
    
    Generate headers which UL normally generates on our behalf.  This means
    
    Server:
    Connection:
    Content-Length:
    Date:

Arguments:

    pW3Context - Helps us build the core headers (since we need to look at 
                 the request).  Can be NULL to indicate to use defaults
    pdwFlags - On input, the flags passed to UL,
               On output, the new flags to be passed to UL
    
Return Value:

    HRESULT

--*/
{
    HTTP_KNOWN_HEADER *         pHeader;
    CHAR *                      pszHeaderValue;
    CHAR                        achDate[ 128 ];
    CHAR                        achNum[ 64 ];
    USHORT                      cchDate;
    USHORT                      cchNum;
    SYSTEMTIME                  systemTime;
    HTTP_VERSION                httpVersion;
    HRESULT                     hr;
    BOOL                        fCreateContentLength;
    BOOL                        fDisconnecting = FALSE;
   
    if ( pdwFlags == NULL )
    {
        DBG_ASSERT( FALSE );
        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }
    
    DBG_ASSERT( _responseMode == RESPONSE_MODE_PARSED );
    
    //
    // Server:
    //
    
    pHeader = &(_ulHttpResponse.Headers.KnownHeaders[ HttpHeaderServer ]);
    if ( pHeader->pRawValue == NULL )
    {
        pHeader->pRawValue = SERVER_SOFTWARE_STRING;
        pHeader->RawValueLength = sizeof( SERVER_SOFTWARE_STRING ) - 1;
    }
    
    //
    // Date:
    //
    
    pHeader = &(_ulHttpResponse.Headers.KnownHeaders[ HttpHeaderDate ]);
    if ( pHeader->pRawValue == NULL )
    {
        
        if(!IISGetCurrentTimeAsSystemTime(&systemTime))
        {
            GetSystemTime( &systemTime );
        }
        if ( !SystemTimeToGMT( systemTime, 
                               achDate, 
                               sizeof(achDate) ) ) 
        {
            return HRESULT_FROM_WIN32( GetLastError() );
        }
 
        
        cchDate = (USHORT)strlen( achDate );
        
        hr = _HeaderBuffer.AllocateSpace( achDate,
                                          cchDate,
                                          &pszHeaderValue );
        
        if ( FAILED( hr ) )
        {
            return hr;
        }
        
        DBG_ASSERT( pszHeaderValue != NULL );
        
        pHeader->pRawValue = pszHeaderValue;
        pHeader->RawValueLength = cchDate;
    }

    //
    // Are we going to be disconnecting?
    //
    
    if ( *pdwFlags & HTTP_SEND_RESPONSE_FLAG_DISCONNECT ||
         ( pW3Context != NULL &&
           ( pW3Context->QueryDisconnect() ||
             pW3Context->QueryRequest()->QueryClientWantsDisconnect() ) ) )
    {
        fDisconnecting = TRUE;
    }    
    
    //
    // If disconnecting, indicate that in flags
    //
    
    if ( fDisconnecting )
    {
        *pdwFlags |= HTTP_SEND_RESPONSE_FLAG_DISCONNECT;
    }

    //
    // Connection:
    //
    
    pHeader = &(_ulHttpResponse.Headers.KnownHeaders[ HttpHeaderConnection ] );
    if ( pHeader->pRawValue == NULL )
    {
        if ( pW3Context == NULL )
        {
            HTTP_SET_VERSION( httpVersion, 1, 0 );
        }
        else
        {
            httpVersion = pW3Context->QueryRequest()->QueryVersion();
        }
    
        if ( fDisconnecting )
        {
            if ( HTTP_GREATER_EQUAL_VERSION( httpVersion, 1, 0 ) )
            {
                pHeader->pRawValue = "close";
                pHeader->RawValueLength = sizeof( "close" ) - 1;
            }   
        }
        else
        {
            if ( HTTP_EQUAL_VERSION( httpVersion, 1, 0 ) )
            {
                pHeader->pRawValue = "keep-alive";
                pHeader->RawValueLength = sizeof( "keep-alive" ) - 1;
            }
        }
    }
    
    //
    // Should we generate content length?
    //
    
    fCreateContentLength = TRUE;
    
    if ( *pdwFlags & HTTP_SEND_RESPONSE_FLAG_MORE_DATA )
    {
        fCreateContentLength = FALSE;
    }
    
    if ( fCreateContentLength &&
         ( QueryStatusCode() / 100 == 1 ||
           QueryStatusCode() == 204 ||
           QueryStatusCode() == 304 ) )
    {
        fCreateContentLength = FALSE;
    }

    if ( fCreateContentLength )
    {
        LPCSTR pszXferEncoding = GetHeader(HttpHeaderTransferEncoding);
        if ( pszXferEncoding != NULL &&
             _stricmp( pszXferEncoding, "chunked" ) == 0 )
        {
            fCreateContentLength = FALSE;
        }
    }

    if ( fCreateContentLength &&
         pW3Context != NULL &&
         pW3Context->QueryMainContext()->QueryShouldGenerateContentLength() )
    {
        fCreateContentLength = FALSE;
    }
    
    //
    // Now generate if needed
    //
    
    if ( fCreateContentLength )
    {
        //
        // Generate a content length header if needed
        //

        pHeader = &(_ulHttpResponse.Headers.KnownHeaders[ HttpHeaderContentLength ]);
        if ( pHeader->pRawValue == NULL )
        {
            _ui64toa( QueryContentLength(),
                      achNum,
                      10 );

            cchNum = (USHORT)strlen( achNum );

            pszHeaderValue = NULL;

            hr = _HeaderBuffer.AllocateSpace( achNum,
                                              cchNum,
                                              &pszHeaderValue );
            if ( FAILED( hr ) )
            {
                return hr;
            }

            DBG_ASSERT( pszHeaderValue != NULL );

            pHeader->pRawValue = pszHeaderValue;
            pHeader->RawValueLength = cchNum;
        }
    }
    
    return NO_ERROR;
}

HRESULT
W3_RESPONSE::BuildRawCoreHeaders(
    VOID
)
/*++

Routine Description:

    Build raw header stream for the core headers that UL normally generates
    on our behalf.  This means structured headers and some special 
    "automatic" ones like Connection:, Date:, Server:, etc.

Arguments:

    None
    
Return Value:

    HRESULT

--*/
{
    HRESULT                 hr = NO_ERROR;
    CHAR                    achNumber[ 32 ];
    HTTP_KNOWN_HEADER *     pKnownHeader;
    HTTP_UNKNOWN_HEADER *   pUnknownHeader;
    CHAR *                  pszHeaderName;
    DWORD                   cchHeaderName;
    DWORD                   i;

    _strRawCoreHeaders.Reset();
    
    //
    // Build a status line
    //
    
    hr = _strRawCoreHeaders.Copy( "HTTP/1.1 " );
    if ( FAILED( hr ) )
    {
        return hr;
    }
    
    _itoa( _ulHttpResponse.StatusCode,
           achNumber,
           10 );
    
    hr = _strRawCoreHeaders.Append( achNumber );
    if ( FAILED( hr ) )
    {
        return hr;
    }
    
    hr = _strRawCoreHeaders.Append( " " );
    if ( FAILED( hr ) )
    {
        return hr;
    }
    
    hr = _strRawCoreHeaders.Append( _ulHttpResponse.pReason );
    if ( FAILED( hr ) )
    {
        return hr;
    }
    
    hr = _strRawCoreHeaders.Append( "\r\n" );
    if ( FAILED( hr ) )
    {
        return hr;
    }
    
    //
    // Iterate thru all the headers in our structured response and set
    // append them to the stream.  
    //
    // Start with the known headers
    //

    for ( i = 0;
          i < HttpHeaderResponseMaximum;
          i++ )
    {
        pKnownHeader = &(_ulHttpResponse.Headers.KnownHeaders[ i ]);
        
        if ( pKnownHeader->pRawValue != NULL &&
             pKnownHeader->pRawValue[ 0 ] != '\0' )
        {
            pszHeaderName = RESPONSE_HEADER_HASH::GetString( i, &cchHeaderName );
            DBG_ASSERT( pszHeaderName != NULL );
            
            hr = _strRawCoreHeaders.Append( pszHeaderName, cchHeaderName );
            if ( FAILED( hr ) )
            {
                return hr;
            }
            
            hr = _strRawCoreHeaders.Append( ": ", 2 );
            if ( FAILED( hr ) )
            {
                return hr;
            }
            
            hr = _strRawCoreHeaders.Append( pKnownHeader->pRawValue,
                                            pKnownHeader->RawValueLength );
            if ( FAILED( hr ) )
            {
                return hr;
            }
            
            hr = _strRawCoreHeaders.Append( "\r\n", 2 );
            if ( FAILED( hr ) )
            {
                return hr;
            }
            
            //
            // Now clear the header
            //
            
            pKnownHeader->pRawValue = NULL;
            pKnownHeader->RawValueLength = 0;
        }
    }   
    
    //
    // Next, the unknown headers
    //
    
    for ( i = 0;
          i < _ulHttpResponse.Headers.UnknownHeaderCount;
          i++ )
    {
        pUnknownHeader = &(_ulHttpResponse.Headers.pUnknownHeaders[ i ]);

        hr = _strRawCoreHeaders.Append( pUnknownHeader->pName,
                                        pUnknownHeader->NameLength );
        if ( FAILED( hr ) )
        {
            return hr;
        } 
        
        hr = _strRawCoreHeaders.Append( ": ", 2 );
        if ( FAILED( hr ) )
        {
            return hr;
        }
        
        hr = _strRawCoreHeaders.Append( pUnknownHeader->pRawValue,
                                        pUnknownHeader->RawValueLength );
        if ( FAILED( hr ) )
        {
            return hr;
        }
        
        hr = _strRawCoreHeaders.Append( "\r\n", 2 );
        if ( FAILED( hr ) )
        {
            return hr;
        }
    }
    
    //
    // Clear the unknown headers
    //
    
    _ulHttpResponse.Headers.UnknownHeaderCount = 0;
        
    return NO_ERROR;
}

HRESULT
W3_RESPONSE::AppendResponseHeaders(
    STRA &                  strHeaders
)
/*++

Routine Description:

    Add response headers (an ISAPI filter special)

Arguments:

    strHeaders - Additional headers to add
                 (may contain entity -> LAAAAAAMMMMME)
    
Return Value:

    HRESULT

--*/
{
    HRESULT             hr;
    LPSTR               pszEntity;
    HTTP_DATA_CHUNK     DataChunk;

    if ( strHeaders.IsEmpty() )
    {
        return NO_ERROR;
    }

    if ( _responseMode == RESPONSE_MODE_RAW && 
         QueryChunks()->FromMemory.pBuffer == _strRawCoreHeaders.QueryStr() )
    {
        DBG_ASSERT( QueryChunks()->DataChunkType == HttpDataChunkFromMemory );
        DBG_ASSERT( QueryChunks()->FromMemory.pBuffer == _strRawCoreHeaders.QueryStr() );
        
        hr = _strRawCoreHeaders.Append( strHeaders );
        if ( FAILED( hr ) )
        {
            return hr;
        }
        
        //
        // Patch first chunk since point may have changed
        //
        
        QueryChunks()->FromMemory.pBuffer = _strRawCoreHeaders.QueryStr();
        QueryChunks()->FromMemory.BufferLength = _strRawCoreHeaders.QueryCB();
    }
    else
    {
        hr = ParseHeadersFromStream( strHeaders.QueryStr() );
        if ( FAILED( hr ) )
        {
            return hr;
        }

        //
        // Look for entity body in headers
        //

        pszEntity = strstr( strHeaders.QueryStr(), "\r\n\r\n" );
        if ( pszEntity != NULL )
        {
            DataChunk.DataChunkType = HttpDataChunkFromMemory;
            DataChunk.FromMemory.pBuffer = pszEntity + ( sizeof( "\r\n\r\n" ) - 1 );
            DataChunk.FromMemory.BufferLength = (DWORD)strlen( (LPSTR) DataChunk.FromMemory.pBuffer );

            hr = InsertDataChunk( &DataChunk, 0 );
            if ( FAILED( hr ) )
            {
                return hr;
            }
        }
    }

    return NO_ERROR;
}

HRESULT
W3_RESPONSE::BuildStatusFromIsapi(
    CHAR *              pszStatus
)
/*++

Routine Description:

    Build up status for response given raw status line from ISAPI

Arguments:

    pszStatus - Status line for response
    
Return Value:

    HRESULT

--*/
{
    USHORT                  status;
    STACK_STRA(             strReason, 32 );
    CHAR *                  pszCursor = NULL;
    HRESULT                 hr = NO_ERROR;
    
    DBG_ASSERT( pszStatus != NULL );
    
    status = (USHORT) atoi( pszStatus );
    if ( status >= 100 &&
         status <= 999 )
    {
        //
        // Need to find the reason string
        //
        
        pszCursor = pszStatus;
        while ( isdigit( *pszCursor ) ) 
        {
            pszCursor++;
        }
            
        if ( *pszCursor == ' ' )
        {
            hr = strReason.Copy( pszCursor + 1 );
            if ( FAILED( hr ) )
            {
                return hr;
            }
        }
        
        hr = SetStatus( (USHORT)status, strReason );
        if ( FAILED( hr ) )
        {
            return hr;
        }
    }
    
    return NO_ERROR;
}

HRESULT
W3_RESPONSE::FilterWriteClient(
    W3_CONTEXT *                pW3Context,
    PVOID                       pvData,
    DWORD                       cbData
)
/*++

Routine Description:

    A non-intrusive WriteClient() for use with filters.  Non-intrusive means
    the current response structure (chunks/headers) is not reset/effected
    by sending this data (think of a WriteClient() done in a SEND_RESPONSE
    filter notification)
    
Arguments:
    
    pW3Context - W3 Context used to help build core response header
    pvData - Pointer to data sent
    cbData - Size of data to send
    
Return Value:

    HRESULT

--*/
{
    HTTP_DATA_CHUNK         dataChunk;
    DWORD                   cbSent;
    HTTP_FILTER_RAW_DATA    rawStream;
    BOOL                    fRet;
    HRESULT                 hr;
    BOOL                    fFinished = FALSE;
    DWORD                   dwFlags = HTTP_SEND_RESPONSE_FLAG_MORE_DATA |
                                      HTTP_SEND_RESPONSE_FLAG_RAW_HEADER;

    _fResponseTouched = TRUE;
    _fResponseSent = TRUE;

    rawStream.pvInData = pvData;
    rawStream.cbInData = cbData;
    rawStream.cbInBuffer = cbData;

    //
    // If there are send raw filters to be notified, do so now
    //

    if ( pW3Context->IsNotificationNeeded( SF_NOTIFY_SEND_RAW_DATA ) )
    {
        fRet = pW3Context->NotifyFilters( SF_NOTIFY_SEND_RAW_DATA,
                                          &rawStream,
                                          &fFinished );
        if ( !fRet )
        {
            return HRESULT_FROM_WIN32( GetLastError() );
        }

        if ( fFinished )
        {
            rawStream.cbInData = 0;
            rawStream.cbInBuffer = 0;
            dwFlags = HTTP_SEND_RESPONSE_FLAG_DISCONNECT |
                      HTTP_SEND_RESPONSE_FLAG_RAW_HEADER;
        }

    }

    hr = HTTP_COMPRESSION::DoDynamicCompression( pW3Context,
                                                 TRUE,
                                                 &rawStream );
    if (FAILED(hr))
    {
        return hr;
    }

    dataChunk.DataChunkType = HttpDataChunkFromMemory;
    dataChunk.FromMemory.pBuffer = rawStream.pvInData;
    dataChunk.FromMemory.BufferLength = rawStream.cbInData;

    //
    // Manage up the thread count since we might be doing a really long
    // send
    //

    ThreadPoolSetInfo( ThreadPoolIncMaxPoolThreads, 0 );

    hr = SendEntityBodyAndLogDataHelper(
                pW3Context,
                pW3Context->QueryUlatqContext(),
                FALSE,          // sync
                dwFlags,
                dataChunk.FromMemory.BufferLength == 0 ? 0 : 1,
                dataChunk.FromMemory.BufferLength == 0 ? NULL : &dataChunk,
                &cbSent );

    ThreadPoolSetInfo( ThreadPoolDecMaxPoolThreads, 0 );
    
    return hr;
}

HRESULT
W3_RESPONSE::BuildResponseFromIsapi(
    W3_CONTEXT *            pW3Context,
    LPSTR                   pszStatusStream,
    LPSTR                   pszHeaderStream,
    DWORD                   cchHeaderStream
)
/*++

Routine Description:
    
    Shift this response into raw mode since we want to hold onto the
    streams from ISAPI and use them for the response if possible

Arguments:
    
    pW3Context - W3 Context used to help build core response header
                 (can be NULL)
    pszStatusStream - Status stream
    pszHeaderStream - Header stream
    cchHeaderStream - Size of above
    
Return Value:

    HRESULT

--*/
{
    HRESULT             hr = NO_ERROR;
    CHAR *              pszEndOfHeaders = NULL;
    CHAR *              pszRawAdditionalIsapiHeaders = NULL;
    DWORD               cchRawAdditionalIsapiHeaders = 0;
    CHAR *              pszRawAdditionalIsapiEntity = NULL;
    DWORD               cchRawAdditionalIsapiEntity = 0;
    DWORD               dwFlags;
    HTTP_DATA_CHUNK     DataChunk;

    Clear();

    _fResponseTouched = TRUE;

    //
    // First parse the status line.  We do this before switching into raw
    // mode because we want the _strRawCoreHeader string to contain the 
    // correct status line and reason
    //
    
    if ( pszStatusStream != NULL &&
         *pszStatusStream != '\0' )
    {
        hr = BuildStatusFromIsapi( pszStatusStream );
        if ( FAILED( hr ) )
        {
            return hr;
        }
    }

    //
    // If there is no ISAPI header stream set, then we're done
    //
    
    if ( pszHeaderStream == NULL )
    {
        return NO_ERROR;
    }

    //
    // Create automatic headers if necessary (but no content-length)
    //
    
    dwFlags = HTTP_SEND_RESPONSE_FLAG_MORE_DATA;

    hr = GenerateAutomaticHeaders( pW3Context,
                                   &dwFlags );
    if ( FAILED( hr ) )
    {
        return hr;
    }

    //
    // The ISAPI set some headers.  Store them now
    //
    
    pszRawAdditionalIsapiHeaders = pszHeaderStream;
    cchRawAdditionalIsapiHeaders = cchHeaderStream;
    
    //
    // If there is additional entity body (after ISAPI headers), then add it
    // Look for a complete set of additional headers.  Complete means that
    // we can find a "\r\n\r\n".  
    //
    
    pszEndOfHeaders = strstr( pszHeaderStream, "\r\n\r\n" );
    if ( pszEndOfHeaders != NULL )
    {
        pszEndOfHeaders += 4;       // go past the \r\n\r\n

        //
        // Update the header length since there is entity tacked on
        //
        
        cchRawAdditionalIsapiHeaders = (DWORD)DIFF( pszEndOfHeaders - pszHeaderStream );
        
        if ( *pszEndOfHeaders != '\0' )
        {
            pszRawAdditionalIsapiEntity = pszEndOfHeaders;
            cchRawAdditionalIsapiEntity = cchHeaderStream - cchRawAdditionalIsapiHeaders;
        }
    }  
    else
    {
        //
        // ISAPI didn't complete the headers.  That means the ISAPI will
        // be completing the headers later.  What this means for us is we 
        // must send the headers in the raw form with out adding our own
        // \r\n\r\n
        //
        
        _fIncompleteHeaders = TRUE;
    }
    
    //
    // Switch into raw mode if we're not already in it
    //
    
    if ( _responseMode == RESPONSE_MODE_PARSED )
    {
        hr = SwitchToRawMode( pszRawAdditionalIsapiHeaders,
                              cchRawAdditionalIsapiHeaders );
        if ( FAILED( hr ) )
        {
            return hr;
        }
    }
 
    DBG_ASSERT( _responseMode == RESPONSE_MODE_RAW );

    //
    // Now add the additional ISAPI entity
    //
    
    if ( cchRawAdditionalIsapiEntity != 0 )
    {
        DataChunk.DataChunkType = HttpDataChunkFromMemory;
        DataChunk.FromMemory.pBuffer = pszRawAdditionalIsapiEntity;
        DataChunk.FromMemory.BufferLength = cchRawAdditionalIsapiEntity;
     
        hr = InsertDataChunk( &DataChunk, -1 );
        if ( FAILED( hr ) )
        {
            return hr;
        }
    }
    
    return NO_ERROR;
}

HRESULT
W3_RESPONSE::GetRawResponseStream(
    STRA *                  pstrResponseStream
)
/*++

Routine Description:

    Fill in the raw response stream for use by raw data filter code
    
Arguments:

    pstrResponseStream - Filled with response stream
    
Return Value:

    HRESULT

--*/
{
    HRESULT             hr;
    DWORD               i;
    CHAR *              pszChunk;
    HTTP_DATA_CHUNK *   pChunks;
    
    if ( pstrResponseStream == NULL )
    {
        DBG_ASSERT( FALSE );
        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }
    
    DBG_ASSERT( _responseMode == RESPONSE_MODE_RAW );

    pChunks = QueryChunks();

    for ( i = 0;
          i < _cFirstEntityChunk;
          i++ )
    {
        DBG_ASSERT( pChunks[ i ].DataChunkType == HttpDataChunkFromMemory );
        
        pszChunk = (CHAR*) pChunks[ i ].FromMemory.pBuffer;
        
        DBG_ASSERT( pszChunk != NULL );
        
        hr = pstrResponseStream->Append( pszChunk );
        if ( FAILED( hr ) ) 
        {
            return hr;
        }
    }
    
    return NO_ERROR;
}

VOID
W3_RESPONSE::Reset(
    VOID
)
/*++

Routine Description:
    
    Initialization of a W3_RESPONSE

Arguments:

    None
    
Return Value:

    None

--*/
{
    _ulHttpResponse.Flags       = 0;

    Clear();

    //
    // Set status to 200 (default)
    //
    SetStatus( HttpStatusOk );

    //
    // Keep track of whether the response has been touched (augmented).  This
    // is useful when determining whether an response was intended
    //
    
    _fResponseTouched   = FALSE;
    
    //
    // This response hasn't been sent yet
    //
    
    _fResponseSent      = FALSE;

    //
    // Should we be intercepting completions?
    //
    
    _fHandleCompletion  = FALSE;
}

HRESULT
W3_RESPONSE::InsertDataChunk(
    HTTP_DATA_CHUNK *   pNewChunk,
    LONG                cPosition
)
/*++

Routine Description:

    Insert given data chunk into list of chunks.  The position is determined
    by cPosition.  If a chunk occupies the given spot, it (along with all
    remaining) are shifted forward.

Arguments:
    
    pNewChunk - Chunk to insert
    cPosition - Position of new chunk (0 prepends, -1 appends)
    
Return Value:

    HRESULT

--*/
{
    HTTP_DATA_CHUNK *           pChunks = NULL;
    DWORD                       cOriginalChunkCount;
    
    if ( pNewChunk == NULL )
    {
        DBG_ASSERT( FALSE );
        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }

    //
    // Must be real position or -1
    //
    
    DBG_ASSERT( cPosition >= -1 );
    
    //
    // Allocate the new chunk if needed
    //
    
    if ( !_bufChunks.Resize( (_cChunks + 1) * sizeof( HTTP_DATA_CHUNK ),
                             512 ) )
    {
        return HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );
    }

    cOriginalChunkCount = _cChunks++;
    
    pChunks = QueryChunks();
        
    //
    // If we're appending then this is simple.  Otherwise we must shift
    // 
    
    if ( cPosition == -1 )
    {
        memcpy( pChunks + cOriginalChunkCount,
                pNewChunk,
                sizeof( HTTP_DATA_CHUNK ) );
    }
    else
    {
        if ( cOriginalChunkCount > (DWORD)cPosition )
        {
            memmove( pChunks + cPosition + 1,
                     pChunks + cPosition,
                     sizeof( HTTP_DATA_CHUNK ) * ( cOriginalChunkCount - cPosition ) );
        }                    

        memcpy( pChunks + cPosition,
                pNewChunk,
                sizeof( HTTP_DATA_CHUNK ) );
    }
    
    return NO_ERROR;
}

HRESULT
W3_RESPONSE::ParseHeadersFromStream(
    CHAR *                  pszStream
)
/*++

Routine Description:

    Parse raw headers from ISAPI into the HTTP_RESPONSE

Arguments:

    pszStream - Stream of headers in form (Header: Value\r\nHeader2: value2\r\n)
    
Return Value:

    HRESULT

--*/
{
    CHAR *              pszCursor;
    CHAR *              pszEnd;
    CHAR *              pszColon;
    HRESULT             hr = NO_ERROR;
    STACK_STRA(         strHeaderLine, 128 );
    STACK_STRA(         strHeaderName, 32 );
    STACK_STRA(         strHeaderValue, 64 );
    
    if ( pszStream == NULL )
    {
        DBG_ASSERT( FALSE );
        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }
    
    //
    // \r\n delimited
    //
    
    pszCursor = pszStream;
    while ( pszCursor != NULL && *pszCursor != '\0' )
    {
        //
        // Check to see if pszCursor points to the "\r\n"
        // that separates the headers from the entity body
        // of the response and add a memory chunk for any
        // data that exists after it.
        //
        // This is to support ISAPI's that do something like
        // SEND_RESPONSE_HEADER with "head1: value1\r\n\r\nEntity"
        //

        if ( *pszCursor == '\r' && *(pszCursor + 1) == '\n' )
        {
            break;
        }
        
        pszEnd = strstr( pszCursor, "\r\n" );
        if ( pszEnd == NULL )
        {
            break;
        }
        
        //
        // Split out a line and convert to unicode
        //
         
        hr = strHeaderLine.Copy( pszCursor, 
                                 (DWORD)DIFF(pszEnd - pszCursor) );
        if ( FAILED( hr ) )
        {
            goto Finished;
        }        

        //
        // Advance the cursor the right after the \r\n
        //

        pszCursor = pszEnd + 2;
        
        //
        // Split the line above into header:value
        //
        
        pszColon = strchr( strHeaderLine.QueryStr(), ':' );
        if ( pszColon == NULL )
        {
            continue;
        }
        else
        {
            if ( pszColon == strHeaderLine.QueryStr() )
            {
                strHeaderName.Reset();
            }
            else
            {
                hr = strHeaderName.Copy( strHeaderLine.QueryStr(),
                                         (DWORD)DIFF(pszColon - strHeaderLine.QueryStr()) );
            }
        }
        
        if ( FAILED( hr ) )
        {
            goto Finished;
        }
        
        //
        // Skip the first space after the : if there is one
        //
        
        if ( pszColon[ 1 ] == ' ' )
        {
            pszColon++;
        }
        
        hr = strHeaderValue.Copy( pszColon + 1 );
        if ( FAILED( hr ) )
        {
            goto Finished;
        }
        
        if ( strHeaderName.QueryCCH() > MAXUSHORT ||
             strHeaderValue.QueryCCH() > MAXUSHORT )
        {
            hr = HRESULT_FROM_WIN32( ERROR_INVALID_DATA );
            goto Finished;
        }

        if (strHeaderName.QueryCCH() > MAXUSHORT ||
            strHeaderValue.QueryCCH() > MAXUSHORT)
        {
            hr = HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);
            goto Finished;
        }

        //
        // Add the header to the response
        //

        hr = SetHeader( strHeaderName.QueryStr(),
                        (USHORT)strHeaderName.QueryCCH(),
                        strHeaderValue.QueryStr(),
                        (USHORT)strHeaderValue.QueryCCH(),
                        FALSE,
                        TRUE );
        if ( FAILED( hr ) )
        {
            goto Finished;
        }
    }

Finished:

    if ( FAILED( hr ) )
    {
        //
        // Don't allow the response to get into a quasi-bogus-state
        //

        Clear();
    }
    return hr;
}

HRESULT
W3_RESPONSE::ResumeResponseTransfer(
    W3_CONTEXT *                pW3Context,
    BOOL                        fCompletion,
    DWORD                       cbCompletion,
    DWORD                       dwCompletionStatus,
    BOOL                        fAsync,
    DWORD *                     pcbSent
)
/*++

Routine Description:

    Resume the send of a response/entity chunk by chunk 

Arguments:

    pW3Context - Context used to filter with
    fCompletion - Is this called as a completion
    cbCompletion - if fCompletion==TRUE, # of bytes of last completion
    dwCompletionStatus - if fCompletion==TRUE, last completion status
    fAsync - Is the send async?
    pcbSent - Filled with # of bytes sent
    
Return Value:

    HRESULT

--*/
{
    HTTP_DATA_CHUNK *       pChunk;
    HTTP_FILTER_RAW_DATA    origStream;
    DWORD                   cbFilled = 0;
    DWORD                   cbToCopy = 0;
    BOOL                    fRet;
    BOOL                    fFinished = FALSE;
    HRESULT                 hr;
    DWORD                   cbSent;
    DWORD                   cbRead;
    DWORD                   dwError;
    HTTP_DATA_CHUNK         dataChunk;
    OVERLAPPED              overlapped;
    
    if ( pW3Context == NULL )
    {
        DBG_ASSERT( FALSE );
        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }
    
    //
    // If this is a completion, then first reset our requirement to pick up
    // the next completion
    //
    
    if ( fCompletion )
    {
        _fHandleCompletion = FALSE;
        _cbTotalCompletion += cbCompletion;
    }

    //
    // Prepare our 2K buffer (if it isn't already prepared)
    //
    
    if ( !_bufRawChunk.Resize( sm_dwSendRawDataBufferSize ) )
    {
        DBG_ASSERT( !fCompletion );
        return HRESULT_FROM_WIN32( GetLastError() );
    }

Restart:

    //
    // Keep track of how much of the 2K buffer we have filled
    //

    cbFilled = 0;

    //
    // Start with the current chunk, continue until we hit the end.  In the
    // interim, we may do async sends which cause us to keep state and 
    // resume appropriately
    //
    
    while ( _cCurrentChunk < _cChunks )
    {
        pChunk = &( QueryChunks()[ _cCurrentChunk ] );
       
        if ( pChunk->DataChunkType == HttpDataChunkFromMemory )
        {   
            //
            // Copy as much of the chunk as we can
            //
            
            cbToCopy = min( _bufRawChunk.QuerySize() - cbFilled,
                            pChunk->FromMemory.BufferLength - (DWORD) _cbCurrentOffset );
                            
            memcpy( ( (PBYTE) _bufRawChunk.QueryPtr() ) + cbFilled,
                    (PBYTE) pChunk->FromMemory.pBuffer + (DWORD) _cbCurrentOffset,
                    cbToCopy );
                    
            cbFilled += cbToCopy;

/*            DBGPRINTF(( DBG_CONTEXT,
                        "Processing chunk %d, bytes (%d,%d)\n",
                        _cCurrentChunk,
                        (DWORD) _cbCurrentOffset,
                        (DWORD) _cbCurrentOffset + cbToCopy ));
*/
            //
            // If we have completely handled the chunk, then update our
            // state
            //
            
            if ( _cbCurrentOffset + cbToCopy >= pChunk->FromMemory.BufferLength )
            {
                _cCurrentChunk++;
                _cbCurrentOffset = 0;
            }
            else
            {
                //
                // Keep the current chunk the same, but update the offset
                //
                
                _cbCurrentOffset += cbToCopy;
            }
        } 
        else if ( pChunk->DataChunkType == HttpDataChunkFromFileHandle )
        {
            LARGE_INTEGER           liOffset;
           
            if ( pChunk->FromFileHandle.ByteRange.Length.QuadPart == HTTP_BYTE_RANGE_TO_EOF )
            {
                //
                // We need to read the length ourselves
                //

                if ( !GetFileSizeEx( pChunk->FromFileHandle.FileHandle,
                                     (PLARGE_INTEGER) &(pChunk->FromFileHandle.ByteRange.Length) ) )
                {
                    hr = HRESULT_FROM_WIN32( GetLastError() );
                    goto Failure;
                }
                
                pChunk->FromFileHandle.ByteRange.Length.QuadPart -= pChunk->FromFileHandle.ByteRange.StartingOffset.QuadPart;
            }
            
            cbToCopy = (DWORD) min( (ULONGLONG) ( _bufRawChunk.QuerySize() - cbFilled ),
                                    pChunk->FromFileHandle.ByteRange.Length.QuadPart -
                                    _cbCurrentOffset );
                            
            //
            // Read the appropriate amount from the file
            //
            
            liOffset.QuadPart = _cbCurrentOffset;
            liOffset.QuadPart += pChunk->FromFileHandle.ByteRange.StartingOffset.QuadPart;
           
            ZeroMemory( &overlapped, sizeof( OVERLAPPED ) );
            
            overlapped.Offset = liOffset.LowPart;
            overlapped.OffsetHigh = liOffset.HighPart;
            
            fRet = ReadFile( pChunk->FromFileHandle.FileHandle,
                             (PBYTE) _bufRawChunk.QueryPtr() + cbFilled,
                             cbToCopy,
                             &cbRead,
                             &overlapped );
            if ( !fRet )
            {
                dwError = GetLastError();
                
                if ( dwError == ERROR_IO_PENDING )
                {
                    fRet = GetOverlappedResult( pChunk->FromFileHandle.FileHandle,
                                                &overlapped,
                                                &cbRead,
                                                TRUE );
                    if ( !fRet )
                    {
                        dwError = GetLastError();
                        
                        if ( dwError == ERROR_HANDLE_EOF )
                        {
                            fRet = TRUE;
                        }
                    }
                }
                else if ( dwError == ERROR_HANDLE_EOF )
                {
                    fRet = TRUE;
                }
            }

            if ( !fRet )
            {
                //
                // Couldn't read from the file.  
                //

                hr = HRESULT_FROM_WIN32( dwError );
                goto Failure;
            }

            if ( cbRead != cbToCopy )
            {
                hr = HRESULT_FROM_WIN32( ERROR_INVALID_DATA );
                goto Failure;
            }

            cbFilled += cbToCopy;

            //
            // What is the current chunk?
            //

            if ( _cbCurrentOffset + cbToCopy >= pChunk->FromFileHandle.ByteRange.Length.QuadPart )
            {
                //
                // We've read the entire chunk.  Move on.
                //

                _cCurrentChunk++;
                _cbCurrentOffset = 0;
            }
            else
            {
                _cbCurrentOffset += cbToCopy;
            }
        }

        //
        // Have we filled a buffer, if so then bail.
        //

        if ( cbFilled >= _bufRawChunk.QuerySize() )
        {
            break;
        }
    }

    origStream.pvInData = _bufRawChunk.QueryPtr();
    origStream.cbInData = cbFilled;
    origStream.cbInBuffer = _bufRawChunk.QuerySize();

    //
    // Start filtering the buffer
    //

    if ( cbFilled > 0 &&
         pW3Context->IsNotificationNeeded( SF_NOTIFY_SEND_RAW_DATA ) )
    {

        fFinished = FALSE;

        fRet = pW3Context->NotifyFilters( SF_NOTIFY_SEND_RAW_DATA,
                                          &origStream,
                                          &fFinished );
        if ( !fRet || fFinished )
        {
            hr = fRet ? NO_ERROR : HRESULT_FROM_WIN32( GetLastError() );
            goto Failure;
        }
    }

    //
    // Compress the chunk (if any), unless this is the final chance to compress
    //

    if ( origStream.cbInData > 0 ||
         ( _cCurrentChunk >= _cChunks &&
           !( _dwSendFlags & HTTP_SEND_RESPONSE_FLAG_MORE_DATA ) ) )
    {
        hr = HTTP_COMPRESSION::DoDynamicCompression( pW3Context,
                                                     (_cCurrentChunk < _cChunks) ? TRUE : (_dwSendFlags & HTTP_SEND_RESPONSE_FLAG_MORE_DATA),
                                                     &origStream );
        if ( FAILED( hr ) )
        {
            goto Failure;
        }
    }

    //
    // If the filter or compression ate up all the data, just continue
    //
    if ( origStream.cbInData == 0 &&
         ( _cCurrentChunk < _cChunks ||
           ( _dwSendFlags & HTTP_SEND_RESPONSE_FLAG_MORE_DATA ) ) )
    {
        if ( _cCurrentChunk < _cChunks )
        {
            goto Restart;
        }

        if ( fAsync )
        {
            ThreadPoolPostCompletion( _cbTotalCompletion,
                                      W3_MAIN_CONTEXT::OnPostedCompletion,
                                      (OVERLAPPED*) pW3Context->QueryMainContext() );
        }

        return NO_ERROR;
    }

    //
    // Send the chunk we have
    // 

    dataChunk.DataChunkType = HttpDataChunkFromMemory;
    dataChunk.FromMemory.pBuffer = origStream.pvInData;
    dataChunk.FromMemory.BufferLength = origStream.cbInData;

    //
    // If we're sending async, then funnel the completion back to the
    // response so we can continue
    //
    // BUT if this is going to be the final send, then we don't need
    // to handle the completion
    //

    if ( fAsync &&
         _cCurrentChunk < _cChunks )
    {
        _fHandleCompletion = TRUE;
    }
    
    hr = SendEntityBodyAndLogDataHelper(
                pW3Context,
                pW3Context->QueryUlatqContext(),
                fAsync,
                _dwSendFlags | HTTP_SEND_RESPONSE_FLAG_RAW_HEADER |
                ((_cCurrentChunk < _cChunks) ? HTTP_SEND_RESPONSE_FLAG_MORE_DATA : 0), // If it is not the last chunk, add more data flag
                dataChunk.FromMemory.BufferLength == 0 ? 0 : 1,
                dataChunk.FromMemory.BufferLength == 0 ? NULL : &dataChunk,
                &cbSent );

    if ( FAILED( hr ) )
    {
        _fHandleCompletion = FALSE;
        goto Failure;
    }

    //
    // If we sent this synchronously, then we can continue filtering
    //

    if ( !fAsync )
    {
        *pcbSent += cbSent;

        if ( _cCurrentChunk < _cChunks )
        {
            goto Restart;
        }
    }

    return NO_ERROR;

Failure:

    if ( !fAsync )
    {
        SendEntityBodyAndLogDataHelper(
                pW3Context,
                pW3Context->QueryUlatqContext(),
                FALSE,
                _dwSendFlags | 
                HTTP_SEND_RESPONSE_FLAG_RAW_HEADER |
                HTTP_SEND_RESPONSE_FLAG_DISCONNECT,
                0,
                NULL,
                &cbSent );

        return hr;
    }
    else
    {
        HRESULT         hrDisconnect;

        //
        // If async, try the disconnect async
        //

        hrDisconnect = SendEntityBodyAndLogDataHelper(
                                pW3Context,
                                pW3Context->QueryUlatqContext(),
                                TRUE,
                                _dwSendFlags | 
                                HTTP_SEND_RESPONSE_FLAG_RAW_HEADER |
                                HTTP_SEND_RESPONSE_FLAG_DISCONNECT,
                                0,
                                NULL,
                                &cbSent );
        if ( FAILED( hrDisconnect ) )
        {
            //
            // If this is the first call to ResumeResponseTransfer() then we
            // can just return the original error here
            //

            if ( !fCompletion )
            {
                return hr;
            }
            else
            {
                //
                // We're going to have to fake a completion
                //

                POST_MAIN_COMPLETION( pW3Context->QueryMainContext() );

                return NO_ERROR;
            }
        }
        else
        {
            return NO_ERROR;
        } 
    }

    DBG_ASSERT( FALSE );
    return HRESULT_FROM_WIN32( ERROR_NOT_SUPPORTED );
}

//static
HRESULT
W3_RESPONSE::Initialize(
    VOID
)
/*++

Routine Description:

    Enable W3_RESPONSE globals

Arguments:

    None
    
Return Value:

    HRESULT

--*/
{
    HKEY w3Params;
    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                     W3_PARAMETERS_KEY,
                     0,
                     KEY_READ,
                     &w3Params) == NO_ERROR)
    {
        DWORD dwType;
        DWORD cbData = sizeof DWORD;
        if ((RegQueryValueEx(w3Params,
                             L"SendRawDataBufferSize",
                             NULL,
                             &dwType,
                             (LPBYTE)&sm_dwSendRawDataBufferSize,
                             &cbData) != NO_ERROR) ||
            (dwType != REG_DWORD))
        {
            sm_dwSendRawDataBufferSize = 2048;
        }

        RegCloseKey(w3Params);
    }

    return RESPONSE_HEADER_HASH::Initialize();
}

//static
VOID
W3_RESPONSE::Terminate(
    VOID
)
{
    RESPONSE_HEADER_HASH::Terminate();
}

CONTEXT_STATUS
W3_STATE_RESPONSE::DoWork(
    W3_MAIN_CONTEXT *       pMainContext,
    DWORD,
    DWORD
)
/*++

Routine Description:

    This state is responsible for ensuring that a response does get sent
    back to the client.  We hope/expect that the handlers will do their
    thing -> but if they don't we will catch that here and send a response

Arguments:

    pMainContext - Context
    cbCompletion - Number of bytes in an async completion
    dwCompletionStatus - Error status of a completion
    
Return Value:

    CONTEXT_STATUS_PENDING or CONTEXT_STATUS_CONTINUE

--*/
{
    W3_RESPONSE*            pResponse;
    HRESULT                 hr;
    
    pResponse = pMainContext->QueryResponse();
    DBG_ASSERT( pResponse != NULL );
    
    //
    // Has a response been sent?  If not, bail
    //
    
    if ( pMainContext->QueryResponseSent() )
    {
        return CONTEXT_STATUS_CONTINUE;
    }
    
    //
    // If the response has been touched, then just send that response.
    // Else if the response has not been touched, then we should sent
    // back an empty response that just closes the connection.  This
    // latter case is most likely the result of an ISAPI that doesn't
    // send anything.  Such an ISAPI expects that no response will
    // reach the client.
    //
    
    if ( !pResponse->QueryResponseTouched() )
    {
        DWORD cbSent;
        HTTP_CACHE_POLICY cachePolicy;
        cachePolicy.Policy = HttpCachePolicyNocache;

        hr = pResponse->SendResponse(
            pMainContext,
            W3_RESPONSE_ASYNC | W3_RESPONSE_SUPPRESS_HEADERS | W3_RESPONSE_DISCONNECT,
            &cachePolicy,
            &cbSent
            );

        if ( FAILED( hr ) )
        {
            pResponse->SetStatus( HttpStatusServerError );
        }
        else
        {
            return CONTEXT_STATUS_PENDING;
        }
    }

    //
    // Send it out
    //

    hr = pMainContext->SendResponse( W3_FLAG_ASYNC );
    if ( FAILED( hr ) )
    {
        pMainContext->SetErrorStatus( hr );
        return CONTEXT_STATUS_CONTINUE;
    }
    else
    {
        return CONTEXT_STATUS_PENDING;
    }
}

CONTEXT_STATUS
W3_STATE_RESPONSE::OnCompletion(
    W3_MAIN_CONTEXT *,
    DWORD,
    DWORD
)
/*++

Routine Description:

    Subsequent completions in this state

Arguments:

    pW3Context - Context
    cbCompletion - Number of bytes in an async completion
    dwCompletionStatus - Error status of a completion
    
Return Value:

    CONTEXT_STATUS_PENDING or CONTEXT_STATUS_CONTINUE

--*/
{
    //
    // We received an IO completion.  Just advance since we have nothing to
    // cleanup
    //
    
    return CONTEXT_STATUS_CONTINUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\iisplus\urlauth\azapplication.cxx ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    application.cxx

Abstract:

    Encapsulates the IAzApplication object.  Does all the grunt work to 
    get an AzContext, determine operations, and build up server variable
    table

Author:

    Bilal Alam (balam)                  Nov 26, 2001

--*/

#include "precomp.hxx"

BSTR    AZ_APPLICATION::sm_bstrOperationName;
DWORD   AZ_APPLICATION::sm_cParameterCount;
VARIANT AZ_APPLICATION::sm_vNameArray;

CHAR * AZ_APPLICATION::sm_rgParameterNames[] = {
    "ALL_HTTP",
    "APPL_MD_PATH",
    "APPL_PHYSICAL_PATH",
    "AUTH_PASSWORD",
    "AUTH_TYPE",
    "AUTH_USER",
    "CERT_COOKIE",
    "CERT_FLAGS",
    "CERT_ISSUER",
    "CERT_KEYSIZE",
    "CERT_SECRETKEYSIZE",
    "CERT_SERIALNUMBER",
    "CERT_SERVER_ISSUER",
    "CERT_SERVER_SUBJECT",
    "CERT_SUBJECT",
    "CONTENT_LENGTH",
    "CONTENT_TYPE",
    "GATEWAY_INTERFACE",
    "LOGON_USER",
    "HTTPS",
    "HTTPS_KEYSIZE",
    "HTTPS_SECRETKEYSIZE",
    "HTTPS_SERVER_ISSUER",
    "HTTPS_SERVER_SUBJECT",
    "INSTANCE_ID",
    "INSTANCE_META_PATH",
    "PATH_INFO",
    "PATH_TRANSLATED",
    "QUERY_STRING",
    "REMOTE_ADDR",
    "REMOTE_HOST",
    "REMOTE_USER",
    "REQUEST_METHOD",
    "SERVER_NAME",
    "LOCAL_ADDR",
    "SERVER_PORT",
    "SERVER_PORT_SECURE",
    "SERVER_PROTOCOL",
    "SERVER_SOFTWARE",
    "UNMAPPED_REMOTE_USER",
    "URL",
    "HTTP_METHOD",
    "HTTP_VERSION",
    "APP_POOL_ID",
    "SCRIPT_TRANSLATED",
    "UNENCODED_URL",
    NULL
};

//static
HRESULT
AZ_APPLICATION::Initialize(
    VOID
)
/*++

Routine Description:

    Global initialization of AZ_APPLICATION

Arguments:

    None

Return Value:

    HRESULT

--*/
{
    VARIANT                 vName;
    SAFEARRAY *             psaNames = NULL;
    SAFEARRAYBOUND          rgsaBound[ 1 ];
    LONG                    lArrayIndex[ 1 ];
    HRESULT                 hr = NO_ERROR;
    BSTR                    bstrName = NULL;
    STACK_STRU(             strTemp, 512 );
    
    VariantInit( &sm_vNameArray );
    
    //
    // Allocate the single operation BSTR only once
    //
    
    sm_bstrOperationName = SysAllocString( URL_AUTH_OPERATION_NAME );
    if ( sm_bstrOperationName == NULL )
    {
        hr = HRESULT_FROM_WIN32( GetLastError() );
        goto Finished;
    }
    
    //
    // Allocate the parameter name array for use with AccessCheck() and
    // business logic
    //
    
    //
    // How many parameters in array?
    //
    
    DBG_ASSERT( sm_cParameterCount == 0 );
    
    while ( sm_rgParameterNames[ sm_cParameterCount ] != NULL )
    {
        sm_cParameterCount++;
    }
    
    DBG_ASSERT( sm_cParameterCount > 0 );
    
    //
    // Allocate the array
    //
      
    rgsaBound[ 0 ].lLbound = 0;
    rgsaBound[ 0 ].cElements = sm_cParameterCount;
    
    psaNames = SafeArrayCreate( VT_VARIANT, 1, rgsaBound );
    if ( psaNames == NULL )
    {
        hr = HRESULT_FROM_WIN32( GetLastError() );
        goto Finished;
    }
    
    //
    // Create a new BSTR for each parameter name and add to safe array
    //
    
    lArrayIndex[ 0 ] = 0;
    
    for ( DWORD j = 0; j < sm_cParameterCount; j++ )
    {
        DBG_ASSERT( sm_rgParameterNames[ j ] != NULL );

        hr = strTemp.CopyA( sm_rgParameterNames[ j ] );
        if ( FAILED( hr ) )
        {
            goto Finished;
        }

        bstrName = SysAllocString( strTemp.QueryStr() );
        if ( bstrName == NULL )
        {
            hr = HRESULT_FROM_WIN32( GetLastError() );
            goto Finished;
        }        
        
        VariantInit( &vName );
        
        vName.vt = VT_BSTR;
        vName.bstrVal = bstrName;
        
        hr = SafeArrayPutElement( psaNames,
                                  lArrayIndex,
                                  &vName );
                                  
        if ( FAILED( hr ) )
        {
            goto Finished;
        }
        
        bstrName = NULL;
        
        (lArrayIndex[ 0 ])++;
    }
    
    //
    // Finally, setup the variant for the array
    //
    
    sm_vNameArray.vt = VT_ARRAY;
    sm_vNameArray.parray = psaNames;
    
    psaNames = NULL;
    
Finished:

    if ( bstrName != NULL )
    {
        SysFreeString( bstrName );
        bstrName = NULL;
    }
    
    if ( psaNames != NULL )
    {
        SafeArrayDestroy( psaNames );
        psaNames = NULL;
    }
    
    return hr;
}

//static
VOID
AZ_APPLICATION::Terminate(
    VOID
)
/*++

Routine Description:

    Cleanup globals for AZ_APPLICATION

Arguments:

    None

Return Value:

    None

--*/
{
    VariantClear( &sm_vNameArray );
    
    if ( sm_bstrOperationName != NULL )
    {
        SysFreeString( sm_bstrOperationName );
        sm_bstrOperationName = NULL;
    }
}

HRESULT
AZ_APPLICATION::Create(
    VOID
)
/*++

Routine Description:

    Initialize an AZ_APPLICATION object

Arguments:

    None

Return Value:

    HRESULT

--*/
{
    IAzOperation *          pIOperation;
    HRESULT                 hr;
    VARIANT                 vNoParam;
    LONG                    operationId;
    SAFEARRAY *             psaOperations = NULL;
    SAFEARRAYBOUND          rgsaBound[ 1 ];
    LONG                    lArrayIndex[ 1 ];
    VARIANT                 vOperation;

    DBG_ASSERT( _pIApplication != NULL );
    
    //
    // We need to get the one operation we care about.
    //

    VariantInit( &vNoParam );
    vNoParam.vt = VT_ERROR;
    vNoParam.scode = DISP_E_PARAMNOTFOUND;
    
    hr = _pIApplication->OpenOperation( sm_bstrOperationName,
                                        vNoParam,
                                        &pIOperation );   
    if ( FAILED( hr ) )
    {
        return hr;
    }
    
    DBG_ASSERT( pIOperation != NULL );
    
    //
    // Get the operation ID
    //
   
    hr = pIOperation->get_OperationID( &operationId );
    
    pIOperation->Release();
    
    //
    // Now do some grunt work and create a variant array for use in our call
    // to AccessCheck().  How do developers live with this crap?
    //
    
    rgsaBound[ 0 ].lLbound = 0;
    rgsaBound[ 0 ].cElements = 1;
    
    psaOperations = SafeArrayCreate( VT_VARIANT, 1, rgsaBound );
    if ( psaOperations == NULL )
    {
        return HRESULT_FROM_WIN32( GetLastError() );
    }
    
    lArrayIndex[ 0 ] = 0;
    
    VariantInit( &vOperation );
    vOperation.vt = VT_I4;
    vOperation.lVal = operationId;
    
    hr = SafeArrayPutElement( psaOperations, 
                              lArrayIndex,
                              &vOperation );
    if ( FAILED( hr ) )
    {
        SafeArrayDestroy( psaOperations );
        return hr;
    }    
    
    VariantInit( &_vOperations );
    _vOperations.vt = VT_ARRAY;
    _vOperations.parray = psaOperations;
    psaOperations = NULL;
    
    return NO_ERROR;
}

HRESULT
AZ_APPLICATION::BuildValueArray(
    EXTENSION_CONTROL_BLOCK *       pecb,
    VARIANT *                       pValueArray
)
/*++

Routine Description:

    Build value array for the given ECB.  This just means retrieving all the 
    server variables and building up an array with these values

Arguments:

    pecb - ECB from which operations and sever variable table are built
    pValueArray - Filled with a variant for the array of values :-(

Return Value:

    HRESULT

--*/
{
    SAFEARRAY *             psaValues = NULL;
    SAFEARRAYBOUND          rgsaBound[ 1 ];
    LONG                    lArrayIndex[ 1 ];
    VARIANT                 vValue;
    HRESULT                 hr = NO_ERROR;
    STACK_BUFFER(           buffVariable, 512 );
    STACK_STRU(             strVariable, 512 );
    DWORD                   cbVariable;
    BSTR                    bstrValue = NULL;
    BOOL                    fRet;
    
    if ( pecb == NULL ||
         pValueArray == NULL )
    {
        DBG_ASSERT( FALSE );
        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }
    
    //
    // First create a safe array of required size
    //
    
    rgsaBound[ 0 ].lLbound = 0;
    rgsaBound[ 0 ].cElements = sm_cParameterCount;
    
    psaValues = SafeArrayCreate( VT_VARIANT, 1, rgsaBound );
    if ( psaValues == NULL )
    {
        hr = HRESULT_FROM_WIN32( GetLastError() );
        goto Finished;
    }
    
    lArrayIndex[ 0 ] = 0;
   
    //
    // Now iterate thru variables, retrieve each one and add to array
    //
    
    for ( DWORD i = 0; i < sm_cParameterCount; i++ )
    {
        DBG_ASSERT( sm_rgParameterNames[ i ] != NULL );
        
        //
        // First get the variable
        // 

        cbVariable = buffVariable.QuerySize();

        fRet = pecb->GetServerVariable( pecb->ConnID,
                                        sm_rgParameterNames[ i ],        
                                        buffVariable.QueryPtr(),
                                        &cbVariable );
        if ( !fRet )
        {
            if ( GetLastError() != ERROR_INSUFFICIENT_BUFFER )
            {
                hr = HRESULT_FROM_WIN32( GetLastError() );
                goto Finished;
            }
            
            DBG_ASSERT( cbVariable > buffVariable.QuerySize() );
            
            fRet = buffVariable.Resize( cbVariable );
            if ( !fRet )
            {
                hr = HRESULT_FROM_WIN32( GetLastError() );
                goto Finished;
            }
            
            cbVariable = buffVariable.QuerySize();
            
            fRet = pecb->GetServerVariable( pecb->ConnID,
                                            sm_rgParameterNames[ i ],
                                            buffVariable.QueryPtr(),
                                            &cbVariable );
            if ( !fRet )
            {
                hr = HRESULT_FROM_WIN32( GetLastError() );
                goto Finished;
            }
        }   
        
        //
        // Convert to UNICODE
        //

        hr = strVariable.CopyA( (CHAR*) buffVariable.QueryPtr() );
        if ( FAILED( hr ) )
        {
            goto Finished;
        }
        
        //
        // Make a BSTR
        //
        
        bstrValue = SysAllocString( strVariable.QueryStr() );
        if ( bstrValue == NULL )
        {
            hr = HRESULT_FROM_WIN32( GetLastError() );
            goto Finished;
        }
        
        VariantInit( &vValue );
        
        vValue.vt = VT_BSTR;
        vValue.bstrVal = bstrValue;
        
        hr = SafeArrayPutElement( psaValues,
                                  lArrayIndex,
                                  &vValue );
                                  
        if ( FAILED( hr ) )
        {
            goto Finished;
        }
        
        bstrValue = NULL;
        
        (lArrayIndex[ 0 ])++;
    }
    
    //
    // Finally, setup the variant for the array
    //
    
    pValueArray->vt = VT_ARRAY;
    pValueArray->parray = psaValues;
    
    psaValues = NULL;
    
Finished:

    if ( bstrValue != NULL )
    {
        SysFreeString( bstrValue );
        bstrValue = NULL;
    }
    
    if ( psaValues != NULL )
    {
        SafeArrayDestroy( psaValues );
        psaValues = NULL;
    }

    return hr;
}

HRESULT
AZ_APPLICATION::DoAccessCheck(
    EXTENSION_CONTROL_BLOCK *       pecb,
    WCHAR *                         pszScopeName,
    BOOL *                          pfAccessGranted
)
/*++

Routine Description:

    Check access

Arguments:

    pecb - ECB from which operations and sever variable table are built
    pszScopeName - Scope name
    pfAccessGranted - Set to TRUE if access is granted

Return Value:

    HRESULT

--*/
{
    BOOL                    fRet;
    HANDLE                  hToken;
    HRESULT                 hr = NO_ERROR;
    VARIANT                 vNoParam;
    IAzClientContext *      pIClientContext = NULL;
    SAFEARRAY *             psaScopes = NULL;
    SAFEARRAYBOUND          rgsaBound[ 1 ];
    LONG                    lArrayIndex[ 1 ];
    VARIANT                 vScope;
    VARIANT                 vScopes;
    BSTR                    bstrScope = NULL;
    BSTR                    bstrObjectName = NULL;
    STACK_BUFFER(           buffUrl, 256 );
    DWORD                   cbBuffUrl;
    VARIANT                 vAccessCheckOutput;
    VARIANT *               pResults = NULL;
    LONG                    lTokenHandle;
    VARIANT                 vValueArray;
    
    if ( pecb == NULL ||
         pfAccessGranted == NULL )
    {
        DBG_ASSERT( FALSE );
        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }
    
    VariantInit( &vNoParam );
    VariantInit( &vScope );
    VariantInit( &vScopes );
    VariantInit( &vAccessCheckOutput );
    VariantInit( &vValueArray );
    
    *pfAccessGranted = FALSE;
    
    //
    // First, get the token for this request.
    // 
    
    fRet = pecb->ServerSupportFunction( pecb->ConnID,
                                        HSE_REQ_GET_IMPERSONATION_TOKEN,
                                        (VOID*)&hToken,
                                        NULL,
                                        NULL );

    if ( !fRet )
    {
        hr = HRESULT_FROM_WIN32( GetLastError() );
        goto Finished;
    }     
    
    //
    // Now, get the AzClientContext from the token
    //
    
    DBG_ASSERT( _pIApplication != NULL );

    vNoParam.vt = VT_ERROR;
    vNoParam.scode = DISP_E_PARAMNOTFOUND;

    //
    // BUGBUG: This AZRoles API needs to be Win64 friendly 
    //

#if defined( _WIN64 )
    LARGE_INTEGER liLarge;
    liLarge.QuadPart = (LONGLONG) hToken;
    lTokenHandle = liLarge.LowPart;
#else
    lTokenHandle = (LONG) hToken;
#endif
    
    hr = _pIApplication->InitializeClientContextFromToken( lTokenHandle,
                                                           vNoParam,
                                                           &pIClientContext );                            
    if ( FAILED( hr ) )
    {
        goto Finished;
    }
    
    DBG_ASSERT( pIClientContext != NULL );
    
    //
    // Determine the object name.  We'll just use the URL (probably want to
    // expose a "FULL_URL" variable which is just the Unicode-untranslated
    // (i.e. pathinfo/URL not split) string.
    //

    cbBuffUrl = buffUrl.QuerySize();
    
    fRet = pecb->GetServerVariable( pecb->ConnID,
                                    "UNICODE_URL",
                                    (CHAR*) buffUrl.QueryPtr(),
                                    &cbBuffUrl );
    if ( !fRet )
    {
        if ( GetLastError() != ERROR_INSUFFICIENT_BUFFER )
        {
            hr = HRESULT_FROM_WIN32( GetLastError() );
            goto Finished;
        }
        
        DBG_ASSERT( cbBuffUrl > buffUrl.QuerySize() );
        
        fRet = buffUrl.Resize( cbBuffUrl );
        if ( !fRet )
        {
            hr = HRESULT_FROM_WIN32( GetLastError() );
            goto Finished;
        }
        
        cbBuffUrl = buffUrl.QuerySize();
        
        fRet = pecb->GetServerVariable( pecb->ConnID,
                                        "UNICODE_URL",
                                        (CHAR*) buffUrl.QueryPtr(),
                                        &cbBuffUrl );
        if ( !fRet )
        {
            hr = HRESULT_FROM_WIN32( GetLastError() );
            goto Finished;
        }
    }
    
    //
    // How many more heap allocations can we do???
    //
    
    bstrObjectName = SysAllocString( (WCHAR*) buffUrl.QueryPtr() );
    if ( bstrObjectName == NULL )
    {
        hr = HRESULT_FROM_WIN32( GetLastError() );
        goto Finished;
    }
    
    //
    // Setup the scope variant array for this request.  This is excruciating!
    // 

    rgsaBound[ 0 ].lLbound = 0;
    rgsaBound[ 0 ].cElements = 1;
    
    psaScopes = SafeArrayCreate( VT_VARIANT, 1, rgsaBound );
    if ( psaScopes == NULL )
    {
        hr = HRESULT_FROM_WIN32( GetLastError() );
        goto Finished;
    }
        
    bstrScope = SysAllocString( pszScopeName ? pszScopeName : L"" );
    if ( bstrScope == NULL )
    {
        hr = HRESULT_FROM_WIN32( GetLastError() );
        goto Finished;
    }
    
    vScope.vt = VT_BSTR;
    vScope.bstrVal = bstrScope;
    
    lArrayIndex[ 0 ] = 0;
    
    hr = SafeArrayPutElement( psaScopes,
                              lArrayIndex,
                              &vScope );
    if ( FAILED( hr ) )
    {
        goto Finished;
    }
    bstrScope = NULL;
    
    vScopes.vt = VT_ARRAY;
    vScopes.parray = psaScopes;
    psaScopes = NULL;

    //
    // Build up the value array for use with business logic
    //
    
    hr = BuildValueArray( pecb,
                          &vValueArray );

    //
    // After that ordeal, we're ready to call AccessCheck()!
    //
    
    hr = pIClientContext->AccessCheck( bstrObjectName,
                                       vScopes,
                                       _vOperations,
                                       sm_vNameArray,
                                       vValueArray,
                                       vNoParam,
                                       vNoParam,
                                       vNoParam,
                                       &vAccessCheckOutput );
    if ( FAILED( hr ) )
    {
        goto Finished;
    } 
    
    //
    // Joy continues.  Need to parse out what AccessCheck() returned
    //
    
    //
    // Return variant should be 1 dimension, 0 based array
    //
    
    DBG_ASSERT( vAccessCheckOutput.parray->rgsabound[ 0 ].lLbound == 0 );
    DBG_ASSERT( vAccessCheckOutput.parray->rgsabound[ 0 ].cElements == 1 );
    
    SafeArrayAccessData( vAccessCheckOutput.parray, (VOID**) &pResults );
    
    DBG_ASSERT( pResults[ 0 ].vt == VT_I4 );

    //
    // Finally, we can tell whether access was allowed or not
    //
    
    *pfAccessGranted = pResults[ 0 ].lVal == 0 ? TRUE : FALSE;
    
    SafeArrayUnaccessData( vAccessCheckOutput.parray );
    
Finished:

    if ( pIClientContext != NULL )
    {
        pIClientContext->Release();
        pIClientContext = NULL;
    }

    if ( bstrScope != NULL )
    {
        SysFreeString( bstrScope );
        bstrScope = NULL;
    }
    
    if ( bstrObjectName != NULL )
    {
        SysFreeString( bstrObjectName );
        bstrObjectName = NULL;
    }

    if ( psaScopes != NULL )
    {
        SafeArrayDestroy( psaScopes );
        psaScopes = NULL;
    }
    
    VariantClear( &vScopes );
    VariantClear( &vAccessCheckOutput );
    VariantClear( &vValueArray );

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\iisplus\w3cache\cachedir.cxx ===
/*++

   Copyright    (c)    1999    Microsoft Corporation

   Module Name :
     cachedir.cxx

   Abstract:
     Dir monitor for cache manager
 
   Author:
     Bilal Alam (balam)             11-Nov-2000

   Environment:
     Win32 - User Mode

   Project:
     ULW3.DLL
--*/

#include "precomp.hxx"

#define DIR_CHANGE_FILTER (FILE_NOTIFY_VALID_MASK & ~FILE_NOTIFY_CHANGE_LAST_ACCESS)

BOOL
CacheDirMonitorEntry::ActOnNotification(
    DWORD               dwStatus,
    DWORD               dwBytesWritten
)
/*++

Routine Description:

    Do any work associated with a change notification, i.e.

Arguments:

    dwStatus - Win32 status for dirmon completion
    dwBytesWritten - Bytes written in dir change buffer

Return Value:

    TRUE if directory should continue to be monitored, otherwise FALSE

--*/
{
    FILE_NOTIFY_INFORMATION *   pNotify = NULL;
    FILE_NOTIFY_INFORMATION *   pNextNotify = NULL;
    STACK_STRU(                 strFileChanged, MAX_PATH );
    BOOL                        fContinueMonitoring = TRUE;
    HRESULT                     hr = NO_ERROR;

    //
    // If there was an error monitoring directory, then flush the entire
    // directory
    //
    
    if ( dwStatus != ERROR_SUCCESS )
    {
        //
        // Access denied means directory either was deleted or secured
        // Stop monitoring in that case
        //
        
        if ( dwStatus == ERROR_ACCESS_DENIED )
        {
            fContinueMonitoring = FALSE;
        }  
        else
        {
            _cNotificationFailures++;
            
            if ( _cNotificationFailures > MAX_NOTIFICATION_FAILURES )
            {
                fContinueMonitoring = FALSE;
            }
        }
    }
    else
    {   
        _cNotificationFailures = 0;
    }
    
    //
    // If no bytes were written, then take the conservative approach and flush
    // everything for this physical prefix
    //
    
    if ( dwBytesWritten == 0 )
    {
        FileChanged( L"", TRUE );
    }
    else 
    {
        pNextNotify = (FILE_NOTIFY_INFORMATION *) m_pbBuffer;

        while ( pNextNotify != NULL )
        {
            BOOL bDoFlush = TRUE;

            pNotify = pNextNotify;
            pNextNotify = (FILE_NOTIFY_INFORMATION*) ((PCHAR) pNotify + pNotify->NextEntryOffset);

            //
            // Get the unicode file name from the notification struct
            // pNotify->FileNameLength returns the wstr's length in **bytes** not wchars
            //

            hr = strFileChanged.Copy( pNotify->FileName,
                                      pNotify->FileNameLength / 2 );
            if ( FAILED( hr ) )
            {
                SetLastError( WIN32_FROM_HRESULT( hr ) );
                return FALSE;
            }

            // Take the appropriate action for the directory change
            switch (pNotify->Action)
            {
                case FILE_ACTION_MODIFIED:
                    //
                    // Since this change won't change the pathname of
                    // any files, we don't have to do a flush.
                    //
                    bDoFlush = FALSE;
                case FILE_ACTION_REMOVED:
                case FILE_ACTION_RENAMED_OLD_NAME:
                    FileChanged(strFileChanged.QueryStr(), bDoFlush);
                    break;
                case FILE_ACTION_ADDED:
                case FILE_ACTION_RENAMED_NEW_NAME:
                default:
                    break;
            }

            if( pNotify == pNextNotify )
            {
                break;
            }
        }
    }
    
    return fContinueMonitoring;
}

VOID
CacheDirMonitorEntry::FileChanged(
    const WCHAR *               pszScriptName, 
    BOOL                        bDoFlush
)
/*++

Routine Description:

    An existing file has been modified or deleted
    Flush scripts from cache or mark application as expired

Arguments:

    pszScriptName - Name of file that changed
    bDoFlush - Should we flush all entries prefixed wih pszScriptName

Return Value:

    None

--*/
{
    STACK_STRU(         strLongName, MAX_PATH );
    STACK_STRU(         strFullPath, MAX_PATH );
    const WCHAR *       pszLongName;
    DWORD               cchLongName;
    HRESULT             hr;

    //
    // Convert any short file names
    //
    
    if ( wcschr( pszScriptName, L'~' ) != NULL )
    {
        cchLongName = GetLongPathName( pszScriptName,
                                       strLongName.QueryStr(),
                                       MAX_PATH );
        if ( cchLongName == 0 || cchLongName > MAX_PATH )
        {
            pszLongName = L"";
        }
        else
        {
            pszLongName = strLongName.QueryStr();
        }
    }
    else
    {
        pszLongName = pszScriptName;
    }
    
    //
    // Create full path of file changed
    //

    hr = strFullPath.Copy( m_pszPath );
    if ( FAILED( hr ) )
    {
        return;
    }
    
    hr = strFullPath.Append( L"\\", 1 );
    if ( FAILED( hr ) )
    {
        return;
    }
    
    hr = strFullPath.Append( pszLongName );
    if ( FAILED( hr ) )
    {
        return;
    }
    
    _wcsupr( strFullPath.QueryStr() );

    //
    // Now call the caches
    //
    
    g_pCacheManager->HandleDirMonitorInvalidation( strFullPath.QueryStr(),
                                                   bDoFlush );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\iisplus\w3dirmon\dbgutil.h ===
/*++

Copyright (c) 1994-1998 Microsoft Corporation

Module Name:

    dbgutil.h

Abstract:

    This module declares the macros to wrap around DEBUG_PRINTS class
    defined in pudebug.h    
  
    This is the exported header file, that the users are allowed to modify.
    If there are no custom definitions, please use the templated version
    in the root iisrearc\inc\dbgutil.h
 
Author:

    Murali R. Krishnan (MuraliK)    22-Sept-1994

--*/


# ifndef _DBGUTIL_H_
# define _DBGUTIL_H_



// begin_user_modifiable

//
//  Modify the following flags if necessary
//

# define DEFAULT_OUTPUT_FLAGS   ( DbgOutputStderr | DbgOutputKdb )

// end_user_modifiable


//
// include standard debug support
//
// note: define DEFAULT_OUTPUT_FLAGS before including pudebug.h
//

# include <pudebug.h>


// begin_user_modifiable

// Use the default constants from pudebug.h: 0x00000001 to 0x00000100

//
//  Define the debugging constants as bit-flag values
//  Example: # define DEBUG_FOOBAR 0x00010000
//  Note: All debugging bit-values below 0x00001000 are reserved!
// 
//  If you add or change a flag, please update FlagTableWp
//  in core\common\dtflags\dtflags.c
//

# define    DEBUG_DIRMON               0x00010000

#if DBG

//
// handy trace macro
//
#define WpTrace(a, _b_)     \
do {                        \
    IF_DEBUG(##a)           \
    {                       \
        PuDbgPrint _b_ ;      \
    }                       \
}while (0)

#else // !DBG

#define WpTrace(a, _b_)        ((void) 0)  /* do nothing */

#endif



// end_user_modifiable


# endif  /* _DBGUTIL_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\iisplus\urlauth\adminmanager.cxx ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    adminmanagercache.cxx

Abstract:

    A cache of IAzAuthorizationStore objects

Author:

    Bilal Alam (balam)                  Nov 26, 2001

--*/

#include "precomp.hxx"

BSTR ADMIN_MANAGER::sm_bstrUrlAuthApplication;

//static
HRESULT
ADMIN_MANAGER::Initialize(
    VOID
)
/*++

Routine Description:
    
    Global initialization for ADMIN_MANAGER

Arguments:

    None

Return Value:

    HRESULT

--*/
{   
    //
    // Initialize some BSTRs once
    //
    
    DBG_ASSERT( sm_bstrUrlAuthApplication == NULL );
    
    sm_bstrUrlAuthApplication = SysAllocString( URL_AUTH_APPLICATION_NAME );
    if ( sm_bstrUrlAuthApplication == NULL )
    {
        return HRESULT_FROM_WIN32( GetLastError() );
    }
    
    return NO_ERROR;
}

//static
VOID
ADMIN_MANAGER::Terminate(
    VOID
)
/*++

Routine Description:
    
    Global cleanup for ADMIN_MANAGER

Arguments:

    None

Return Value:

    None

--*/
{
    if ( sm_bstrUrlAuthApplication != NULL )
    {
        SysFreeString( sm_bstrUrlAuthApplication );
        sm_bstrUrlAuthApplication = NULL;
    }
}

HRESULT
ADMIN_MANAGER::Create(
    WCHAR *                 pszStoreName
)
/*++

Routine Description:

    Create a cache entry object.  In this case, the object contains a 
    pointer to a created IAzAuthorizationStore object

Arguments:

    pszStoreName - Name of store to pass down to IAzAdminManager

Return Value:

    HRESULT

--*/
{
    HRESULT             hr;
    BSTR                bstrStoreName;
    VARIANT             vNoParam;
    HANDLE              hToken = NULL;
    BOOL                fRet;
    
    if ( pszStoreName == NULL )
    {
        DBG_ASSERT( FALSE );
        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }
    
    //
    // First create the object
    //
    
    hr = CoCreateInstance( CLSID_AzAuthorizationStore,
                           NULL, 
                           CLSCTX_SERVER, 
                           IID_IAzAuthorizationStore,
                           (VOID**) &_pAdminManager );
    if ( FAILED( hr ) )
    {
        return hr;
    }
    
    DBG_ASSERT( _pAdminManager != NULL );

    //
    // Is this an XML or AD URL?  (incredibly lame!)
    //
    
    //
    // Do some BSTR nonsence
    //
    
    bstrStoreName = SysAllocString( pszStoreName );
    if ( bstrStoreName == NULL )
    {
        return HRESULT_FROM_WIN32( GetLastError() );
    }
    
    _wcsupr( (WCHAR*) bstrStoreName );
    
    //
    // Now initialize the AdminManager
    //

    VariantInit( &vNoParam );
    vNoParam.vt = VT_ERROR;
    vNoParam.scode = DISP_E_PARAMNOTFOUND;

    //
    // Initialize() routine must be called unimpersonated.  Very lame!
    //

    fRet = OpenThreadToken( GetCurrentThread(),
                            TOKEN_IMPERSONATE,
                            TRUE,
                            &hToken );
    if ( fRet )
    {
        DBG_ASSERT( hToken != NULL );
        RevertToSelf();
    }
    
    hr = _pAdminManager->Initialize( 0,
                                     bstrStoreName,
                                     vNoParam );
    
    if ( hToken != NULL )
    {
        if ( !SetThreadToken( NULL, hToken ) )
        {
            DBG_ASSERT( FALSE );
        }
        
        CloseHandle( hToken );
        hToken = NULL;
    }

    SysFreeString( bstrStoreName );

    if ( FAILED( hr ) )
    {
        return hr;
    }
    
    _fInitialized = TRUE;
    
    return NO_ERROR;
}

HRESULT
ADMIN_MANAGER::GetApplication(
    AZ_APPLICATION **           ppAzApplication
)
/*++

Routine Description:

    Retrieve the AZ_APPLICATION from the given admin maanger.  In the future
    there may be more than one application associated with admin manager.  
    For now there isn't.  

Arguments:

    ppApplication - Receives pointer to AZ_APPLICATION on success

Return Value:

    HRESULT

--*/
{
    HRESULT                 hr;
    AZ_APPLICATION *        pAzApplication;
    IAzApplication *        pIApplication;
    VARIANT                 vNoParam;
    
    if ( ppAzApplication == NULL )
    {
        DBG_ASSERT( FALSE );
        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }
    
    *ppAzApplication = NULL;
    
    //
    // If we already have one associated, then we're done
    //
   
    if ( _pAzApplication != NULL )
    {
        *ppAzApplication = _pAzApplication;
        return NO_ERROR;
    }
    
    //
    // OK.  We'll have to create one now
    //
    
    //
    // Get the application we're interested in (URLAuth)
    //
    
    DBG_ASSERT( _pAdminManager != NULL );

    VariantInit( &vNoParam );
    vNoParam.vt = VT_ERROR;
    vNoParam.scode = DISP_E_PARAMNOTFOUND;
    
    hr = _pAdminManager->OpenApplication( sm_bstrUrlAuthApplication,
                                          vNoParam,
                                          &pIApplication );
    if ( FAILED( hr ) )
    {
        return hr;
    }
    
    DBG_ASSERT( pIApplication != NULL );
    
    //
    // Create an AZ_APPLICATION object which wraps the IAzApplication.  In
    // the future, an ADMIN_MANAGER may hold more than one application.  For
    // now it won't
    //
    
    pAzApplication = new AZ_APPLICATION( pIApplication );
    if ( pAzApplication == NULL )
    {
        pIApplication->Release();
        
        return HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );
    }
    
    hr = pAzApplication->Create();
    if ( FAILED( hr ) )
    {
        delete pAzApplication;
        return hr;
    }
    
    //
    // Finally, set the AZ_APPLICATION 
    //
    
    LockCacheEntry();
    
    if ( _pAzApplication == NULL )
    {
        _pAzApplication = pAzApplication;
    }
    else
    {
        delete pAzApplication;
    }
    
    UnlockCacheEntry();
    
    *ppAzApplication = _pAzApplication;
    
    DBG_ASSERT( *ppAzApplication != NULL );
    
    return NO_ERROR;
}

HRESULT
ADMIN_MANAGER_CACHE::GetAdminManager(
    WCHAR *                 pszStoreName,
    ADMIN_MANAGER **        ppAdminManager
)
/*++

Routine Description:
    
    Returns (and creates if necessary) an ADMIN_MANAGER object for the 
    given store name

Arguments:

    pszStoreName - Store name
    ppAdminManager - Filled with pointer to ADMIN_MANAGER if successful

Return Value:

    HRESULT

--*/
{
    ADMIN_MANAGER_CACHE_KEY         cacheKey;
    ADMIN_MANAGER *                 pAdminManager = NULL;
    HRESULT                         hr;
    
    if ( pszStoreName == NULL ||
         ppAdminManager == NULL )
    {
        DBG_ASSERT( FALSE );
        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }
    
    *ppAdminManager = NULL;
    
    //
    // First lookup in the cache
    //
    
    hr = cacheKey.SetStore( pszStoreName );
    if ( FAILED( hr ) )
    {
        return hr;
    }

TryAgain:
    
    hr = FindCacheEntry( &cacheKey,
                         (CACHE_ENTRY**) &pAdminManager );
    if ( FAILED( hr ) )
    {
        //
        // Anything but ERROR_FILE_NOT_FOUND is a bad thing
        //
        
        if ( hr != HRESULT_FROM_WIN32( ERROR_FILE_NOT_FOUND ) )
        {
            return hr;
        }
        
        //
        // Create an ADMIN_MANAGER
        //
        
        pAdminManager = new ADMIN_MANAGER( this );
        if ( pAdminManager == NULL )
        {
            return HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );
        }
        
        //
        // We'll initialize it later.  We do this to avoid more than one 
        // simulatenous call to pAdminManager->Create() because AZRoles crap
        // doesn't like it
        //
        
        //
        // Add it to the cache.  If we couldn't because it was already
        // there, then try again to retrieve it
        //
        
        AddCacheEntry( (CACHE_ENTRY*) pAdminManager );

        if ( pAdminManager->QueryCached() == FALSE )
        {
            pAdminManager->DereferenceCacheEntry();
            pAdminManager = NULL;
            goto TryAgain;
        }
    }
    
    //
    // Initialize the entry once before use.  This mechanism ensures only
    // one call is made to initialize for the same store name
    //
    
    if ( !pAdminManager->QueryIsInitialized() )
    {
        pAdminManager->LockCacheEntry();

        if ( !pAdminManager->QueryIsInitialized() )
        {
            hr = pAdminManager->Create( pszStoreName );
        }
        else
        {
            hr = NO_ERROR;
        }
       
        pAdminManager->UnlockCacheEntry(); 
        
        if ( FAILED( hr ) )
        {
            pAdminManager->DereferenceCacheEntry();
            pAdminManager = NULL;
            return hr;
        }
    }
    
    DBG_ASSERT( pAdminManager != NULL );
    
    *ppAdminManager = pAdminManager;
    
    return NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\iisplus\w3cache\cachehint.cxx ===
/*++

   Copyright    (c)    1999    Microsoft Corporation

   Module Name :
     cachehint.cxx

   Abstract:
     Provides hint to caches about whether or not to cache an entry, based
     on usage patterns
 
   Author:
     Bilal Alam (balam)             11-Nov-2000

   Environment:
     Win32 - User Mode

   Project:
     ULW3.DLL
--*/

#include "precomp.hxx"
#include "cachehint.hxx"

BOOL
CACHE_HINT_ENTRY::QueryIsOkToCache(
    DWORD               tickCountNow,
    DWORD               cmsecActivityWindow
)
/*++

Routine Description:

    Is it OK to cache entry, given recent activity

Arguments:

    tickCountNow - Current tick count
    cmsecActivityWindow - Maximum window between access to cause caching

Return Value:

    TRUE to cache, FALSE to not cache

--*/
{
    DWORD               lastUsageTime;
    DWORD               timeBetweenUsage;
    
    lastUsageTime = InterlockedExchange( (LPLONG) &_cLastUsageTime,
                                         tickCountNow );
    
    if ( lastUsageTime > tickCountNow )
    {   
        timeBetweenUsage = tickCountNow + ( UINT_MAX - lastUsageTime );
    } 
    else
    {
        timeBetweenUsage = tickCountNow - lastUsageTime;
    }
    
    if ( timeBetweenUsage < cmsecActivityWindow )
    {
        return TRUE;
    }
    else
    {
        return FALSE;
    }
}

CACHE_HINT_MANAGER::CACHE_HINT_MANAGER()
    : _cConfiguredTTL( 0 ),
      _cmsecActivityWindow( 0 ),
      _hTimer( NULL )
{
}

CACHE_HINT_MANAGER::~CACHE_HINT_MANAGER()
{
    if ( _hTimer )
    {
        DeleteTimerQueueTimer( NULL, 
                               _hTimer,
                               INVALID_HANDLE_VALUE );
        _hTimer = NULL;
    }
}

//static
VOID
WINAPI
CACHE_HINT_MANAGER::ScavengerCallback(
    PVOID                   pParam,
    BOOLEAN                
)
{
    CACHE_HINT_MANAGER *    pHintManager;
    
    pHintManager = (CACHE_HINT_MANAGER*) pParam;

    pHintManager->FlushByTTL();
}

//static
LK_PREDICATE
CACHE_HINT_MANAGER::HintFlushByTTL(
    CACHE_HINT_ENTRY *      pHintEntry,
    VOID *              
)
/*++

Routine Description:

    Determine whether given entry should be deleted due to TTL

Arguments:

    pCacheEntry - Cache hint entry to check
    pvState - Unused

Return Value:

    LKP_PERFORM - do the delete,
    LKP_NO_ACTION - do nothing

--*/
{
    DBG_ASSERT( pHintEntry != NULL );
    
    if ( pHintEntry->QueryIsOkToFlushTTL() )
    {
        return LKP_PERFORM;
    }
    else
    {
        return LKP_NO_ACTION;
    }
}

VOID
CACHE_HINT_MANAGER::FlushByTTL(
    VOID
)
/*++

Routine Description:

    Flush hint entries which have expired

Arguments:

    None
    
Return Value:
    
    None

--*/
{
    _hintTable.DeleteIf( HintFlushByTTL, NULL );
}

HRESULT
CACHE_HINT_MANAGER::Initialize(
    CACHE_HINT_CONFIG *     pConfig
)
/*++

Routine Description:

    Initialize cache hint table

Arguments:

    pConfig - Cache hint config table
    
Return Value:
    
    HRESULT

--*/
{
    BOOL            fRet;
    
    if ( pConfig == NULL )
    {
        DBG_ASSERT( FALSE );
        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }
    
    _cConfiguredTTL = pConfig->cmsecTTL / pConfig->cmsecScavengeTime + 1;
    _cmsecActivityWindow = pConfig->cmsecActivityWindow;
    
    fRet = CreateTimerQueueTimer( &_hTimer,
                                  NULL,
                                  CACHE_HINT_MANAGER::ScavengerCallback,
                                  this,
                                  pConfig->cmsecScavengeTime,
                                  pConfig->cmsecScavengeTime,
                                  WT_EXECUTELONGFUNCTION );
    if ( !fRet )
    {
        return HRESULT_FROM_WIN32( GetLastError() );
    }
    
    return NO_ERROR;
}

HRESULT
CACHE_HINT_MANAGER::ShouldCacheEntry(
    CACHE_KEY *             pCacheEntryKey,
    BOOL *                  pfShouldCache
)
/*++

Routine Description:

    Determine whether we the given entry should be cached

Arguments:

    pCacheEntryKey - Entry key in question (must implement QueryHintKey())
    pfShouldCache - Set to TRUE if we should cache
    
Return Value:
    
    HRESULT

--*/
{
    LK_RETCODE              lkrc;
    CACHE_HINT_ENTRY *      pHintEntry = NULL;
    DWORD                   tickCount;
    HRESULT                 hr;
    
    if ( pCacheEntryKey == NULL ||
         pfShouldCache == NULL )
    {
        DBG_ASSERT( FALSE );
        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }
   
    *pfShouldCache = FALSE;

    DBG_ASSERT( pCacheEntryKey->QueryHintKey() != NULL );
    
    lkrc = _hintTable.FindKey( pCacheEntryKey->QueryHintKey(),
                               &pHintEntry );
    if ( lkrc == LK_SUCCESS )
    {
        DBG_ASSERT( pHintEntry != NULL );
        
        tickCount = GetTickCount();
        
        if ( pHintEntry->QueryIsOkToCache( tickCount,
                                           _cmsecActivityWindow ) )
        {
            *pfShouldCache = TRUE;
        }

        //
        // Release corresponding to the FindKey
        //
        pHintEntry->Release();
    }
    else
    {
        pHintEntry = new CACHE_HINT_ENTRY( _cConfiguredTTL,
                                           GetTickCount() );
        if ( pHintEntry == NULL )
        {
            return HRESULT_FROM_WIN32( GetLastError() );
        }
        
        hr = pHintEntry->SetKey( pCacheEntryKey->QueryHintKey() );
        if ( FAILED( hr ) )
        {
            pHintEntry->Release();
            return hr;
        }
        
        lkrc = _hintTable.InsertRecord( pHintEntry );

        //
        // Release the extra reference
        //
        pHintEntry->Release();
    }
    
    return NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\iisplus\w3cache\cachemanager.cxx ===
/*++

   Copyright    (c)    1999    Microsoft Corporation

   Module Name :
     cachemanager.cxx

   Abstract:
     Manages a list of all the caches and handles invalidation of them
 
   Author:
     Bilal Alam (balam)             11-Nov-2000

   Environment:
     Win32 - User Mode

   Project:
     ULW3.DLL
--*/

#include "precomp.hxx"

#define DIR_CHANGE_FILTER (FILE_NOTIFY_VALID_MASK & ~FILE_NOTIFY_CHANGE_LAST_ACCESS)

CACHE_MANAGER *         g_pCacheManager;

CACHE_MANAGER::CACHE_MANAGER()
{
    _pDirMonitor = NULL;
    ZeroMemory( &_Caches, sizeof( _Caches ) );
}

CACHE_MANAGER::~CACHE_MANAGER()
{
}

HRESULT
CACHE_MANAGER::Initialize(
    IMSAdminBase *          pAdminBase
)
/*++

Routine Description:

    Initialize cache manager

Arguments:

    pAdminBase - Admin base object pointer

Return Value:

    HRESULT

--*/
{
    //
    // Initialize dir monitor
    //
    
    DBG_ASSERT( _pDirMonitor == NULL );
    
    _pDirMonitor = new CDirMonitor;
    if ( _pDirMonitor == NULL )
    {
        return HRESULT_FROM_WIN32( GetLastError() );
    }
    
    //
    // Keep a pointer to the admin base object
    //
    
    _pAdminBase = pAdminBase;
    _pAdminBase->AddRef();
    
    return NO_ERROR;
}

VOID
CACHE_MANAGER::Terminate(
    VOID
)
/*++

Routine Description:

    Cleanup the cache manager

Arguments:

    None

Return Value:

    HRESULT

--*/
{
    if ( _pAdminBase != NULL )
    {
        _pAdminBase->Release();
        _pAdminBase = NULL;
    }
    
    if ( _pDirMonitor != NULL )
    {
        _pDirMonitor->Cleanup();
        delete _pDirMonitor;
        _pDirMonitor = NULL;
    }
}

HRESULT
CACHE_MANAGER::AddNewCache(
    OBJECT_CACHE *          pObjectCache
)
/*++

Routine Description:

    Add new cache to be managed

Arguments:

    pObjectCache - Object cache to add

Return Value:

    HRESULT

--*/
{
    DWORD               dwInsertPos;
    
    if ( pObjectCache == NULL )
    {
        DBG_ASSERT( FALSE );
        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }
    
    //
    // First the first non-NULL entry
    //
   
    for ( dwInsertPos = 0; _Caches[ dwInsertPos ] != NULL; dwInsertPos++ )
    {
    } 
    
    //
    // Add the new cache
    //
    
    _Caches[ dwInsertPos ] = pObjectCache;
    
    return NO_ERROR;
}

HRESULT
CACHE_MANAGER::RemoveCache(
    OBJECT_CACHE *          pObjectCache
)
/*++

Routine Description:

    Cache to remove from list of managed caches

Arguments:

    pObjectCache - Object cache to remove

Return Value:

    HRESULT

--*/
{
    DWORD               dwPos;
    BOOL                fFound = FALSE;

    if ( pObjectCache == NULL )
    {
        DBG_ASSERT( FALSE );
        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }    
    
    //
    // First find the cache to remove
    //
    
    for ( dwPos = 0; _Caches[ dwPos ] != NULL; dwPos++ )
    {
        if ( _Caches[ dwPos ] == pObjectCache )
        {
            memmove( _Caches + dwPos,
                     _Caches + dwPos + 1,
                     ( MAX_CACHE_COUNT - dwPos - 1 ) * sizeof( OBJECT_CACHE*) );

            fFound = TRUE;
            
            break;
        }
    }

    if ( !fFound )
    {
        return HRESULT_FROM_WIN32( ERROR_FILE_NOT_FOUND );
    }    
    
    return NO_ERROR;
}

VOID
CACHE_MANAGER::FlushAllCaches(
    VOID
)
/*++

Routine Description:

    Flush all caches

Arguments:

    None

Return Value:

    None

--*/
{
    DWORD               dwPos;
    
    for ( dwPos = 0; _Caches[ dwPos ] != NULL; dwPos++ )
    {
        //
        // Clear the cache
        //
        
        _Caches[ dwPos ]->Clear();
        
        //
        // Wait for scavengers to go away
        //
        
        _Caches[ dwPos ]->UnregisterScavenger();
    }
}

HRESULT
CACHE_MANAGER::HandleDirMonitorInvalidation(
    WCHAR *                 pszFilePath,
    BOOL                    fFlushAll
)
/*++

Routine Description:

    Invalidate any caches which are interested in dir monitor invalidation

Arguments:

    pszFilePath - File name changed
    fFlushAll - Should we flush all items prefixed with pszFilePath?

Return Value:

    HRESULT

--*/
{
    DWORD               dwPos;
    OBJECT_CACHE *      pCache;

    if ( pszFilePath == NULL )
    {
        DBG_ASSERT( FALSE );
        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }
    
    //
    // Iterate thru all the caches which support dirmon invalidation
    //
    
    for ( dwPos = 0; _Caches[ dwPos ] != NULL; dwPos++ )
    {
        pCache = _Caches[ dwPos ];

        //
        // If this cache doesn't support dirmon at all, continue
        //
        
        if ( !pCache->QuerySupportsDirmonSpecific() &&
             !pCache->QuerySupportsDirmonFlush() )
        {
            continue;
        }

        //
        // If this is a specific invalidation, check whether the cache 
        // supports it.  If it doesn't, but does support flush, the do a 
        // flush instead
        //
        
        if ( !fFlushAll )
        {
            if ( pCache->QuerySupportsDirmonSpecific() )
            {
                pCache->DoDirmonInvalidationSpecific( pszFilePath );
            }
            else
            {
                pCache->DoDirmonInvalidationFlush( pszFilePath );
            }
        }
        else
        {
            pCache->DoDirmonInvalidationFlush( pszFilePath );
        }
    } 
    
    return NO_ERROR;
}

HRESULT
CACHE_MANAGER::HandleMetadataInvalidation(
    WCHAR *                 pszMetaPath
)
/*++

Routine Description:

    Invalidate any caches which are interested in metadata invalidation

Arguments:

    pszMetaPath - Metabase path which changed

Return Value:

    HRESULT

--*/
{
    DWORD               dwPos;
    OBJECT_CACHE *      pCache;

    if ( pszMetaPath == NULL )
    {
        DBG_ASSERT( FALSE );
        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }
    
    //
    // Iterate thru all the caches which support metadata invalidation
    //
    
    for ( dwPos = 0; _Caches[ dwPos ] != NULL; dwPos++ )
    {
        pCache = _Caches[ dwPos ];
        
        if ( pCache->QuerySupportsMetadataFlush() )
        {   
            pCache->DoMetadataInvalidationFlush( pszMetaPath );
        }
    } 
    
    return NO_ERROR;
}

HRESULT
CACHE_MANAGER::MonitorDirectory(
    DIRMON_CONFIG *             pDirmonConfig,
    CDirMonitorEntry **         ppDME
)
/*++

Routine Description:

    Monitor given directory

Arguments:

    pDirmonConfig - Name of directory and token to impersonate with
    ppDME - Set to monitor entry on success

Return Value:

    HRESULT

--*/
{
    CacheDirMonitorEntry *      pDME = NULL;
    HRESULT                     hr = NO_ERROR;
    BOOL                        fRet;
    BOOL                        fImpersonated = FALSE;
    
    if ( ppDME == NULL ||
         pDirmonConfig == NULL )
    {
        DBG_ASSERT( FALSE );
        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }
    
    //
    // First check if we are already monitoring this directory
    //
    
    pDME = (CacheDirMonitorEntry*) _pDirMonitor->FindEntry( pDirmonConfig->pszDirPath );
    if ( pDME == NULL )
    {
        //
        // It is not.  We'll have to start monitoring
        //
    
        pDME = new CacheDirMonitorEntry;
        if ( pDME == NULL )
        {
            return HRESULT_FROM_WIN32( GetLastError() );
        }
    
        pDME->AddRef();

        if ( pDirmonConfig->hToken != NULL )
        {
            fRet = SetThreadToken( NULL, pDirmonConfig->hToken );
            if ( !fRet )
            {
                hr = HRESULT_FROM_WIN32( GetLastError() );
                pDME->Release();
                return hr;   
            }
            
            fImpersonated = TRUE;
        }

        
        fRet = _pDirMonitor->Monitor( pDME,
                                      pDirmonConfig->pszDirPath,
                                      TRUE,
                                      DIR_CHANGE_FILTER );

        if ( fImpersonated )
        {
            RevertToSelf();
            fImpersonated = FALSE;
        }

        if ( !fRet )
        {
            //
            // Note:  It is OK if we can't monitor the directory.  The error
            // will trickle up and the caller will not cache the entry
            //
            
            hr = HRESULT_FROM_WIN32( GetLastError() );
        
            pDME->Release();
            pDME = NULL;

            return hr;
        }
    }
    
    DBG_ASSERT( pDME != NULL );
    
    *ppDME = (CDirMonitorEntry*) pDME;
    return NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\iisplus\w3cache\usercache.cxx ===
/*++

   Copyright    (c)    1999    Microsoft Corporation

   Module Name :
     usercache.cxx

   Abstract:
     Implements the common code shared by all the caches
     (file, meta, uri, token, ul-cached-response, etc)
 
   Author:
     Bilal Alam (balam)             11-Nov-2000

   Environment:
     Win32 - User Mode

   Project:
     ULW3.DLL
--*/

#include "precomp.hxx"
#include "usercache.hxx"
#include "cachehint.hxx"

//static 
void
CACHE_ENTRY_HASH::AddRefRecord(
    CACHE_ENTRY *           pCacheEntry,
    int                     nIncr 
)
/*++

Routine Description:

    Dereference and possibly delete the cache entry.  Note the destructor
    for the cache entry is private.  Only this code should ever delete
    the cache entry

Arguments:

    None

Return Value:

    None

--*/
{
    DBG_ASSERT( pCacheEntry->CheckSignature() );
        
    if ( nIncr == +1 )
    {
        pCacheEntry->ReferenceCacheEntry();
    }
    else if ( nIncr == -1 )
    {
        pCacheEntry->SetFlushed();
        pCacheEntry->QueryCache()->IncFlushes();
        pCacheEntry->QueryCache()->DecEntriesCached();
        pCacheEntry->DereferenceCacheEntry();        
    }
    else 
    {
        DBG_ASSERT( FALSE );
    }
}

//
// CACHE_ENTRY definitions
//

CACHE_ENTRY::CACHE_ENTRY(
    OBJECT_CACHE *      pObjectCache,
    DWORD               cTTLOverride
)
{
    _cRefs = 1;
    _fFlushed = FALSE;
    _fCached = FALSE;
    if ( cTTLOverride != 0 )
    {
        _cConfiguredTTL = cTTLOverride;
    }
    else
    {
        _cConfiguredTTL = pObjectCache->QueryConfiguredTTL();
    }
    _cTTL = _cConfiguredTTL;
    _pObjectCache = pObjectCache;
    _pDirmonInvalidator = NULL;
    
    _dwSignature = CACHE_ENTRY_SIGNATURE;
}

CACHE_ENTRY::~CACHE_ENTRY(
    VOID
)
{
    DBG_ASSERT( _cRefs == 0 );

    if ( _pDirmonInvalidator != NULL )
    {
        _pDirmonInvalidator->Release();
        _pDirmonInvalidator = NULL;
    }
    
    if ( _fFlushed )
    {
        DBG_ASSERT( QueryCache() != NULL );

        QueryCache()->DecActiveFlushedEntries();
    }
    
    _dwSignature = CACHE_ENTRY_SIGNATURE_FREE;
}

VOID
CACHE_ENTRY::ReferenceCacheEntry(
    VOID
)
/*++

Routine Description:

    Reference the given entry (duh)

Arguments:

    None

Return Value:

    None

--*/
{
    LONG                cRefs;
    
    cRefs = InterlockedIncrement( &_cRefs );
    
    DBG_ASSERT( QueryCache() != NULL );
    QueryCache()->DoReferenceTrace( this, cRefs );
}

VOID
CACHE_ENTRY::DereferenceCacheEntry(
    VOID
)
/*++

Routine Description:

    Dereference and possibly delete the cache entry.  Note the destructor
    for the cache entry is private.  Only this code should ever delete
    the cache entry

Arguments:

    None

Return Value:

    None

--*/
{
    LONG                cRefs;
    OBJECT_CACHE *      pObjectCache = QueryCache();
    
    DBG_ASSERT( pObjectCache != NULL );
    
    cRefs = InterlockedDecrement( &_cRefs );

    pObjectCache->DoReferenceTrace( this, cRefs );
    
    if ( cRefs == 0 )
    {
        delete this;
    }
}

HRESULT
CACHE_ENTRY::AddDirmonInvalidator(
    DIRMON_CONFIG *     pDirmonConfig
)
/*++

Routine Description:

    Setup dirmon invalidation for this cache entry        

Arguments:

    pDirmonConfig - path/token for use in monitoring directory

Return Value:

    HRESULT 

--*/
{
    CDirMonitorEntry *          pDME = NULL;
    HRESULT                     hr;
    
    hr = QueryCache()->AddDirmonInvalidator( pDirmonConfig, &pDME );
    if ( FAILED( hr ) )
    {
        return hr;
    }
    
    DBG_ASSERT( pDME != NULL );

    //
    // Cleanup any old dir monitor entry
    //
   
    if ( _pDirmonInvalidator != NULL )
    {
        _pDirmonInvalidator->Release();
    }
    
    _pDirmonInvalidator = pDME;
    
    return NO_ERROR;
}

BOOL
CACHE_ENTRY::Checkout(
    CACHE_USER *
)
/*++

Routine Description:

    Checkout a cache entry
        
Arguments:

    None

Return Value:

    TRUE if the checkout was successful, else FALSE 

--*/
{
    ReferenceCacheEntry();
    
    if ( QueryIsFlushed() )
    {
        DereferenceCacheEntry();
        QueryCache()->IncMisses(); 
        return FALSE;
    }
    else
    {
        InterlockedExchange( &_cTTL, _cConfiguredTTL );
        QueryCache()->IncHits();
        return TRUE;
    }
}

BOOL
CACHE_ENTRY::QueryIsOkToFlushTTL(
    VOID
)
/*++

Routine Description:
        
    Called when the cache scavenger is invoked.  This routine returns whether
    it is OK to flush this entry due to TTL

Arguments:

    None

Return Value:

    TRUE if it is OK to flush by TTL, else FALSE

--*/
{
    //
    // Only do the TTL thing if the hash table holds the only reference to
    // the cache entry.  We can be loose with this check as this is just an
    // optimization to prevent overzealous flushing
    //
    
    if ( _cRefs > 1 )
    {
        return FALSE;
    }
    
    if ( InterlockedDecrement( &_cTTL ) == 0 ) 
    {
        //
        // TTL has expired.  However, we let the cache entry override this
        // expiry it wants to.  Check that now
        //
            
        //
        // Entry be gone!
        //
         
        return TRUE;
    }
    else
    {
        return FALSE;
    }
}

BOOL
CACHE_ENTRY::QueryIsOkToFlushMetadata(
    WCHAR *                     pszMetaPath,
    DWORD                       cchMetaPath
)
/*++

Routine Description:

    Called whem metadata has changed.  This routine returns whether the
    current cache entry should be flushed        

Arguments:

    pszMetaPath - Metabase path which changed
    cchMetaPath - Size of metabase path

Return Value:

    TRUE if we should flush

--*/
{
    BOOL                fRet;

    DBG_ASSERT( pszMetaPath != NULL );
    DBG_ASSERT( cchMetaPath != 0 );
    
    if ( pszMetaPath[ cchMetaPath - 1 ] == L'/' )
    {
        cchMetaPath--;
    }
    
    DBG_ASSERT( QueryCache()->QuerySupportsMetadataFlush() );

    if ( QueryMetadataPath() == NULL )
    {
        fRet = TRUE;
    }
    else if ( QueryMetadataPath()->QueryCCH() < cchMetaPath )
    {
        fRet = FALSE;
    }
    else if ( _wcsnicmp( QueryMetadataPath()->QueryStr(),
              pszMetaPath,
              cchMetaPath ) == 0 )
    {
        fRet = TRUE;
    }
    else
    {
        fRet = FALSE;
    }
    
    return fRet;
}

//
// OBJECT_CACHE definitions
//

OBJECT_CACHE::OBJECT_CACHE(
    VOID
)
/*++

Routine Description:

    Create an object cache.  Obviously all the app-specific goo will be 
    initialized in the derived class

Arguments:

    None

Return Value:

    None

--*/
{
    _hTimer = NULL;
    _pHintManager = NULL;
    _cmsecScavengeTime = 0;
    _cmsecTTL = 0;
    _dwSupportedInvalidation = 0;

    _cCacheHits = 0;
    _cCacheMisses = 0;
    _cCacheFlushes = 0;
    _cActiveFlushedEntries = 0;
    _cFlushCalls = 0;
    _cEntriesCached = 0;
    _cTotalEntriesCached = 0;

    _cPerfCacheHits = 0;
    _cPerfCacheMisses = 0;
    _cPerfCacheFlushes = 0;
    _cPerfFlushCalls = 0;
    _cPerfTotalEntriesCached = 0;
    
#if DBG
    _pTraceLog = CreateRefTraceLog( 2000, 0 );
#else
    _pTraceLog = NULL;
#endif
    
    InitializeListHead( &_listEntry );

    _dwSignature = OBJECT_CACHE_SIGNATURE;
}

VOID
OBJECT_CACHE::UnregisterScavenger(
    VOID
)
{
    if ( _hTimer != NULL )
    {
        DeleteTimerQueueTimer( NULL,
                               _hTimer,
                               INVALID_HANDLE_VALUE );
        
        _hTimer = NULL;
    }
}
    
OBJECT_CACHE::~OBJECT_CACHE(
    VOID
)
{
    _dwSignature = OBJECT_CACHE_SIGNATURE_FREE;

    UnregisterScavenger();
   
    if ( _pHintManager != NULL )
    {
        delete _pHintManager;
        _pHintManager = NULL;
    }
    
    if ( _pTraceLog != NULL )
    {
        DestroyRefTraceLog( _pTraceLog );
        _pTraceLog = NULL;
    }
}

VOID
OBJECT_CACHE::CleanupCacheEntryListItems(
    LIST_ENTRY        * pListHead
    )
{
    CACHE_ENTRY * pCacheEntry;

    //
    // Free cache entry list items
    //

    while ( !IsListEmpty( pListHead ) ) 
    {
        pCacheEntry = CONTAINING_RECORD( pListHead->Flink,
                                         CACHE_ENTRY,
                                         _listEntry );

        RemoveEntryList( &pCacheEntry->_listEntry );
        pCacheEntry->_listEntry.Flink = NULL;

        pCacheEntry->DereferenceCacheEntry();
    }
}

//static
VOID
WINAPI
OBJECT_CACHE::ScavengerCallback(
    PVOID                   pParam,
    BOOLEAN             
)
{
    OBJECT_CACHE *          pObjectCache;
    LIST_ENTRY              listHead;
    
    pObjectCache = (OBJECT_CACHE*) pParam;
    DBG_ASSERT( pObjectCache != NULL );
    DBG_ASSERT( pObjectCache->CheckSignature() );
    
    InitializeListHead( &listHead);

    pObjectCache->FlushByTTL( &listHead );
    
    //
    // Remove all cache entries in the cache entry list
    //
    pObjectCache->CleanupCacheEntryListItems( &listHead ); 
}

//static
LK_PREDICATE
OBJECT_CACHE::CacheFlushByRegChange(
    CACHE_ENTRY *           pCacheEntry,
    VOID *                  pvState
)
/*++

Routine Description:

    Determine whether given entry should be deleted due to TTL change.

Arguments:

    pCacheEntry - Cache entry to check
    pvState - Pointer to cache

Return Value:

    LKP_PERFORM - do the delete,
    LKP_NO_ACTION - do nothing

--*/
{
    LIST_ENTRY *  pListHead = static_cast<LIST_ENTRY *>( pvState );
    
    DBG_ASSERT( pCacheEntry != NULL );
    DBG_ASSERT( pCacheEntry->CheckSignature() );
    
    pCacheEntry->ReferenceCacheEntry();
    
    InsertHeadList( 
          pListHead, 
          &pCacheEntry->_listEntry );

    return LKP_PERFORM;
}

//static
LK_PREDICATE
OBJECT_CACHE::CacheFlushByTTL(
    CACHE_ENTRY *           pCacheEntry,
    VOID *                  pvState
)
/*++

Routine Description:

    Determine whether given entry should be deleted due to TTL

Arguments:

    pCacheEntry - Cache entry to check
    pvState - Pointer to cache

Return Value:

    LKP_PERFORM - do the delete,
    LKP_NO_ACTION - do nothing

--*/
{
    LIST_ENTRY *  pListHead = static_cast<LIST_ENTRY *>( pvState );
    
    DBG_ASSERT( pCacheEntry != NULL );
    DBG_ASSERT( pCacheEntry->CheckSignature() );
    
    if ( pCacheEntry->QueryIsOkToFlushTTL() )
    {   
        pCacheEntry->ReferenceCacheEntry();
        
        InsertHeadList( 
              pListHead, 
              &pCacheEntry->_listEntry );

        return LKP_PERFORM;
    }
    else
    {
        return LKP_NO_ACTION;
    }
}

//static
LK_PREDICATE
OBJECT_CACHE::CacheFlushByDirmon(
    CACHE_ENTRY *           pCacheEntry,
    VOID *                  pvState
)
/*++

Routine Description:

    Determine whether given entry should be deleted due to dir mon

Arguments:

    pCacheEntry - Cache entry to check
    pvState - STRU of path which changed

Return Value:

    LKP_PERFORM - do the delete,
    LKP_NO_ACTION - do nothing

--*/
{
    STRU *          pstrPath = (STRU*) pvState;
    OBJECT_CACHE *  pCache;
    
    DBG_ASSERT( pCacheEntry != NULL );
    DBG_ASSERT( pCacheEntry->CheckSignature() );
    
    pCache = pCacheEntry->QueryCache();
    DBG_ASSERT( pCache->CheckSignature() );
    
    if ( pCacheEntry->QueryIsOkToFlushDirmon( pstrPath->QueryStr(),
                                              pstrPath->QueryCCH() ) )
    {
        return LKP_PERFORM;
    }
    else
    {
        return LKP_NO_ACTION;
    }
}

//static
LK_PREDICATE
OBJECT_CACHE::CacheFlushByMetadata(
    CACHE_ENTRY *           pCacheEntry,
    VOID *                  pvState
)
/*++

Routine Description:

    Determine whether given entry should be deleted due to metadata change

Arguments:

    pCacheEntry - Cache entry to check
    pvState - STRU with metapath which changed

Return Value:

    LKP_PERFORM - do the delete,
    LKP_NO_ACTION - do nothing

--*/
{
    STRU *          pstrPath = (STRU*) pvState;
    OBJECT_CACHE *  pCache;
    
    DBG_ASSERT( pCacheEntry != NULL );
    DBG_ASSERT( pCacheEntry->CheckSignature() );
    
    pCache = pCacheEntry->QueryCache();
    DBG_ASSERT( pCache->CheckSignature() );
    
    if ( pCacheEntry->QueryIsOkToFlushMetadata( pstrPath->QueryStr(),
                                                pstrPath->QueryCCH() ) )
    {
        return LKP_PERFORM;
    }
    else
    {
        return LKP_NO_ACTION;
    }
}

VOID
OBJECT_CACHE::FlushByRegChange(
    LIST_ENTRY        * pListHead
)
/*++

Routine Description:

    Flush any inactive cache entries who have outlived their TTL

Arguments:

    pListHead - Head of the cache entry list to be deleted

Return Value:

    None

--*/
{
    IncFlushCalls();
    
    //
    // Iterate the hash table, deleting expired itmes
    //
    
    _hashTable.DeleteIf( CacheFlushByRegChange, pListHead );
}

VOID
OBJECT_CACHE::FlushByTTL(
    LIST_ENTRY        * pListHead
)
/*++

Routine Description:

    Flush any inactive cache entries who have outlived their TTL

Arguments:

    pListHead - Head of the cache entry list to be deleted

Return Value:

    None

--*/
{
    IncFlushCalls();
    
    //
    // Iterate the hash table, deleting expired itmes
    //
    
    _hashTable.DeleteIf( CacheFlushByTTL, pListHead );
}

VOID
OBJECT_CACHE::DoDirmonInvalidationFlush(
    WCHAR *             pszPath
)
/*++

Routine Description:

    Flush all appropriate entries due to dirmon change notification

Arguments:

    pszPath - Path that changed

Return Value:

    None

--*/
{
    STACK_STRU(             strPath, 256 );
    
    IncFlushCalls();
    
    if ( SUCCEEDED( strPath.Copy( pszPath ) ) )
    {
        _hashTable.DeleteIf( CacheFlushByDirmon, (VOID*) &strPath );
    }
}

VOID
OBJECT_CACHE::DoMetadataInvalidationFlush(
    WCHAR *             pszMetaPath
)
/*++

Routine Description:

    Flush all appropriate entries due to metadata change notification

Arguments:

    pszMetaPath - Metabase path which changed

Return Value:

    None

--*/
{
    STACK_STRU(             strPath, 256 );
    
    IncFlushCalls();
    
    if ( SUCCEEDED( strPath.Copy( pszMetaPath ) ) )
    {
        _hashTable.DeleteIf( CacheFlushByMetadata, (VOID*) &strPath );
    }
}

HRESULT
OBJECT_CACHE::SetCacheConfiguration(
    DWORD                   cmsecScavengeTime,
    DWORD                   cmsecTTL,
    DWORD                   dwSupportedInvalidation,
    CACHE_HINT_CONFIG *     pCacheHintConfig
)
/*++

Routine Description:

    Do the general cache initialization here

Arguments:

    cmsecScavengeTime - How often should a scavenger be run for this cache
                        (should be no larger than the TTL expected for 
                        entries in this cache)
    cmsecTTL - TTL for entries in this cache
    dwSupportedInvalidation - How can the cache be invalidated?
    pCacheHintConfig - Cache hint configuration (NULL for no cache hints)
    
Return Value:
    
    HRESULT

--*/
{
    BOOL                    fRet;
    HRESULT                 hr;

    DBG_ASSERT( cmsecTTL >= cmsecScavengeTime );
    
    //
    // Create a timer which fires every cmsecScavengeTime
    // 
   
    _cmsecScavengeTime = cmsecScavengeTime;
    
    fRet = CreateTimerQueueTimer( &_hTimer,
                                  NULL,
                                  OBJECT_CACHE::ScavengerCallback,
                                  this,
                                  _cmsecScavengeTime,
                                  _cmsecScavengeTime,
                                  WT_EXECUTELONGFUNCTION );
    if ( !fRet )
    {
        return HRESULT_FROM_WIN32( GetLastError() );
    }
    
    _cmsecTTL = cmsecTTL;
    
    _dwSupportedInvalidation = dwSupportedInvalidation;

    //
    // Should we setup a cache hint table
    //
    
    if ( pCacheHintConfig != NULL )
    {
        _pHintManager = new CACHE_HINT_MANAGER;
        if ( _pHintManager == NULL )
        {
            hr = HRESULT_FROM_WIN32( GetLastError() );
        
            DeleteTimerQueueTimer( NULL,
                                   _hTimer,
                                   INVALID_HANDLE_VALUE );
            _hTimer = NULL;
            
            return hr;
        }

        hr = _pHintManager->Initialize( pCacheHintConfig );
        if ( FAILED( hr ) )
        {   
             delete _pHintManager;
             _pHintManager = NULL;

            DeleteTimerQueueTimer( NULL,
                                   _hTimer,
                                   INVALID_HANDLE_VALUE );
            _hTimer = NULL;
        
            return hr;
        }
    }    

    return NO_ERROR;
}

HRESULT
OBJECT_CACHE::FindCacheEntry(
    CACHE_KEY *                 pCacheKey,
    CACHE_ENTRY **              ppCacheEntry,
    BOOL *                      pfShouldCache
)
/*++

Routine Description:

    Lookup key in cache

Arguments:

    pCacheKey - Cache key to lookup
    ppCacheEntry - Points to cache entry on success
    pfShouldCache - Provides a hint if possible on whether we should cache
                    (can be NULL indicating no hint is needed)

Return Value:

    HRESULT

--*/
{
    LK_RETCODE                  lkrc;
    HRESULT                     hr;
    CACHE_ENTRY *               pCacheEntry = NULL;
    
    if ( ppCacheEntry == NULL ||
         pCacheKey == NULL )
    {
        DBG_ASSERT( FALSE );
        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }
    
    *ppCacheEntry = NULL;

    //
    // First do a lookup
    //    
    
    lkrc = _hashTable.FindKey( pCacheKey, &pCacheEntry );
    if ( lkrc == LK_SUCCESS )
    {
        //
        // If this entry has been flushed, then it really isn't a hit
        //
        
        if ( pCacheEntry->QueryIsFlushed() )
        {
            pCacheEntry->DereferenceCacheEntry();
        }
        else
        {
            IncHits();
            
            DBG_ASSERT( pCacheEntry != NULL );
        
            *ppCacheEntry = pCacheEntry;
            
            return NO_ERROR;
        }
    }
   
    IncMisses(); 
    
    //
    // Is a hint requested?
    //
    
    if ( pfShouldCache != NULL )
    {
        *pfShouldCache = TRUE;
        
        if ( _pHintManager != NULL )
        {
            hr = _pHintManager->ShouldCacheEntry( pCacheKey,
                                                  pfShouldCache );
            
            //
            // Ignore error
            //
        }        
    }

    return HRESULT_FROM_WIN32( ERROR_FILE_NOT_FOUND );
}

HRESULT
OBJECT_CACHE::FlushCacheEntry(
    CACHE_KEY *             pCacheKey
)
/*++

Routine Description:

    Flush given cache key 

Arguments:

    pCacheKey - Key to flush

Return Value:

    HRESULT

--*/
{
    LK_RETCODE                  lkrc;
    CACHE_ENTRY *               pCacheEntry;
        
    if ( pCacheKey == NULL )
    {
        DBG_ASSERT( FALSE );
        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }
    
    //
    // First do a lookup
    //    
    
    lkrc = _hashTable.FindKey( pCacheKey, &pCacheEntry );
    if ( lkrc == LK_SUCCESS )
    {
        DBG_ASSERT( pCacheEntry != NULL );
        
        if ( !pCacheEntry->QueryIsFlushed() )
        {
            _hashTable.DeleteRecord( pCacheEntry );
        }
        
        pCacheEntry->DereferenceCacheEntry();
    }
    
    return NO_ERROR;
}

HRESULT
OBJECT_CACHE::AddCacheEntry(
    CACHE_ENTRY *              pCacheEntry
)
/*++

Routine Description:

    Lookup key in cache

Arguments:

    pCacheEntry - Points to cache entry on success

Return Value:

    HRESULT

--*/
{
    LK_RETCODE          lkrc;
    
    if ( pCacheEntry == NULL )
    {
        DBG_ASSERT( FALSE );
        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }
    
    DBG_ASSERT( pCacheEntry->QueryCached() == FALSE );
    
    //
    // Now try to insert into hash table
    //

    pCacheEntry->SetCached( TRUE );

    //
    // Replace a stale entry, if present
    //
    lkrc = _hashTable.InsertRecord( pCacheEntry, TRUE );
    if ( lkrc == LK_SUCCESS )
    {
        IncEntriesCached();
    }
    else
    {
        pCacheEntry->SetCached( FALSE );
    }

    return NO_ERROR;
}

HRESULT
OBJECT_CACHE::AddDirmonInvalidator(
    DIRMON_CONFIG *         pDirmonConfig,
    CDirMonitorEntry **     ppDME
)
/*++

Routine Description:

    Add dirmon invalidator for this cache

Arguments:

    pDirmonConfig - Configuration of dir monitor
    ppDME - filled with dir monitor entry to be attached to cache entry

Return Value:

    HRESULT

--*/
{
    HRESULT                     hr = NO_ERROR;
    
    if ( !QuerySupportsDirmonSpecific() &&
         !QuerySupportsDirmonFlush() )
    {
        return HRESULT_FROM_WIN32( ERROR_NOT_SUPPORTED );
    }
    
    //
    // Start monitoring
    //
    
    DBG_ASSERT( g_pCacheManager != NULL );
    
    hr = g_pCacheManager->MonitorDirectory( pDirmonConfig,
                                            ppDME );
    if ( FAILED( hr ) )
    {
        return hr;
    }
    
    DBG_ASSERT( *ppDME != NULL );
    
    return NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\iisplus\w3cache\w3cache.cxx ===
/*++

   Copyright    (c)    1999    Microsoft Corporation

   Module Name :
     w3cache.cxx

   Abstract:
     Exposes the cache manager (and thus cache) to everyone
 
   Author:
     Bilal Alam (balam)             11-Nov-2000

   Environment:
     Win32 - User Mode

   Project:
     ULW3.DLL
--*/

#include "precomp.hxx"

DECLARE_DEBUG_PRINTS_OBJECT();
DECLARE_DEBUG_VARIABLE();
DECLARE_PLATFORM_TYPE();

HRESULT
W3CacheInitialize(
    IMSAdminBase *          pAdminBase
)
/*++

Routine Description:

    Initialize cache manager

Arguments:

    pAdminBase - Admin base object used for stuff

Return Value:

    HRESULT

--*/
{
    HRESULT             hr = NO_ERROR;
    
    DBG_ASSERT( g_pCacheManager == NULL );
    
    //
    // Allocate an initialize the cache manager (there is only one manager)
    //
    
    g_pCacheManager = new CACHE_MANAGER;
    if ( g_pCacheManager == NULL )
    {
        return HRESULT_FROM_WIN32( GetLastError() );
    }
    
    hr = g_pCacheManager->Initialize( pAdminBase );
    if ( FAILED( hr ) )
    {
        delete g_pCacheManager;
        g_pCacheManager = NULL;
        return hr;
    }
    
    return NO_ERROR;
}

VOID
W3CacheTerminate(
    VOID
)
/*++

Routine Description:

    Cleanup the cache manager

Arguments:

    None

Return Value:

    None

--*/
{
    if ( g_pCacheManager != NULL )
    {
        g_pCacheManager->Terminate();
        delete g_pCacheManager;
        g_pCacheManager = NULL;
    }
}

HRESULT
W3CacheRegisterCache(
    OBJECT_CACHE *          pObjectCache
)
/*++

Routine Description:

    Register a cache with the manager

Arguments:

    pObjectCache - Object cache to register

Return Value:

    HRESULT

--*/
{
    if ( g_pCacheManager == NULL )
    {
        DBG_ASSERT( FALSE );
        return HRESULT_FROM_WIN32( ERROR_NOT_SUPPORTED );
    }
    
    return g_pCacheManager->AddNewCache( pObjectCache );
}

HRESULT
W3CacheUnregisterCache(
    OBJECT_CACHE *          pObjectCache
)
/*++

Routine Description:

    Unregister a cache with the manager

Arguments:

    pObjectCache - Object cache to unregister

Return Value:

    HRESULT

--*/
{
    if ( g_pCacheManager == NULL )
    {
        DBG_ASSERT( FALSE );
        return HRESULT_FROM_WIN32( ERROR_NOT_SUPPORTED );
    }

    return g_pCacheManager->RemoveCache( pObjectCache );
}

HRESULT
W3CacheDoMetadataInvalidation(
    WCHAR *                 pszMetabasePath,
    DWORD            
)
/*++

Routine Description:

    Drive invalidation of caches based on metadata changing

Arguments:

    pszMetabasePath - Metabase path which changed (includes the "LM/W3SVC/<>" stuff)
    cchMetabasePath - Unused

Return Value:

    HRESULT

--*/
{
    if ( pszMetabasePath == NULL )
    {
        DBG_ASSERT( FALSE );
        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }
    
    if ( g_pCacheManager != NULL )
    {
        g_pCacheManager->HandleMetadataInvalidation( pszMetabasePath );
    }
    
    return NO_ERROR; 
}

VOID
W3CacheFlushAllCaches(
    VOID
)
/*++

Routine Description:

    Flush all caches

Arguments:

    None

Return Value:

    None

--*/
{
    DBG_ASSERT( g_pCacheManager != NULL );
    
    g_pCacheManager->FlushAllCaches();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\iisplus\urlauth\urlauth.cxx ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    urlauth.cxx

Abstract:

    Implements an ISAPI * scriptmap which handles authorization by calling 
    into the NT AuthZ framework.  

Author:

    Bilal Alam (balam)                  Nov 26, 2001

--*/

#include "precomp.hxx"

DECLARE_DEBUG_PRINTS_OBJECT();
DECLARE_DEBUG_VARIABLE();

// local function declarations
HRESULT
GetTokenForExecution(
                     EXTENSION_CONTROL_BLOCK *pecb, 
                     HANDLE * phToken
                    );

// global data
ADMIN_MANAGER_CACHE *   g_pAdminManagerCache;

VOID 
WINAPI
UrlAuthCompletion(
    EXTENSION_CONTROL_BLOCK *       pecb,
    PVOID pvContext,                    
    DWORD,                           
    DWORD
)
/*++

Routine Description:

    Routine to be called whenever ISAPI async stuff completes

Arguments:

    pecb - EXTENSION_CONTROL_BLOCK *
    pContext - Unused
    cbIo - Unused
    dwError - Unused

Return Value:

    None

--*/
{
    if ( pvContext )
    {
        DBG_REQUIRE( CloseHandle( pvContext ) );
        pvContext = NULL;
    }

    pecb->ServerSupportFunction( pecb->ConnID,
                                 HSE_REQ_DONE_WITH_SESSION,
                                 NULL, 
                                 NULL, 
                                 NULL );
}

DWORD
WINAPI
HttpExtensionProc(
    EXTENSION_CONTROL_BLOCK *       pecb
)
/*++

Routine Description:

    Main entry point for ISAPI

Arguments:

    pecb - EXTENSION_CONTROL_BLOCK *

Return Value:

    HSE_STATUS_*

--*/
{
    BOOL                    fRet;
    STACK_BUFFER(           buff, 512 );
    DWORD                   cbBuffer;
    BOOL                    fAccessGranted = FALSE;
    BOOL                    fFatalError = FALSE;
    WCHAR *                 pszAdminStore;
    ADMIN_MANAGER *         pAdminManager = NULL;
    AZ_APPLICATION *        pApplication = NULL;
    WCHAR *                 pszScopeName;
    HRESULT                 hr = NO_ERROR;
    METADATA_RECORD *       pRecord;
    HANDLE                  hImpersonationToken = NULL;
    HSE_CUSTOM_ERROR_INFO   CustomErrorInfo = { "500 Server Error", 0, TRUE };
    
    //
    // First determine whether URL authorization is even enabled for this
    // URL
    //
    
    cbBuffer = buff.QuerySize();
    
    fRet = pecb->ServerSupportFunction( pecb,
                                        HSE_REQ_GET_METADATA_PROPERTY,
                                        buff.QueryPtr(),
                                        &cbBuffer,
                                        (LPDWORD) MD_ENABLE_URL_AUTHORIZATION );
    if ( !fRet )
    {
        if ( GetLastError() == ERROR_INVALID_INDEX )
        {
            // the common case is to fail with ERROR_INVALID_INDEX == access granted by no present metadata
            // if the above call failed with someting like OUTOFMEMORY or INVALIDPARAMETER do not allow access.
            fAccessGranted = TRUE;
        }
        else
        {
            fFatalError = TRUE;
            hr = HRESULT_FROM_WIN32( GetLastError() );
        }

        goto AccessCheckComplete;
    }
    
    //
    // Check the property now.  If invalid type or if 0, then we're done
    //

    pRecord = (METADATA_RECORD*) buff.QueryPtr();
    if ( pRecord->dwMDDataType != DWORD_METADATA ||
         *((DWORD*)pRecord->pbMDData) == 0 )
    {
        fAccessGranted = TRUE;
        goto AccessCheckComplete;
    }
    
    //
    // If we're still a go, then retrieve the store name from the metabase.
    // This is our key into the AdminManager cache we maintain
    //
    
    cbBuffer = buff.QuerySize();

    fRet = pecb->ServerSupportFunction( pecb,
                                        HSE_REQ_GET_METADATA_PROPERTY,
                                        buff.QueryPtr(),
                                        &cbBuffer,
                                        (LPDWORD) MD_URL_AUTHORIZATION_STORE_NAME );
    if ( !fRet )
    {
        //
        // The only acceptable error is insufficient buffer.  Otherwise, we
        // don't have a store name and we're sunk
        //
        
        if ( GetLastError() != ERROR_INSUFFICIENT_BUFFER )
        {
            CustomErrorInfo.pszStatus = "500 Server Error";
            CustomErrorInfo.uHttpSubError = 17;     
            CustomErrorInfo.fAsync = TRUE;
    
            goto AccessCheckComplete;
        }
        
        DBG_ASSERT( cbBuffer > buff.QuerySize() );
        
        if ( !buff.Resize( cbBuffer ) )
        {
            fFatalError = TRUE;
            hr = HRESULT_FROM_WIN32( GetLastError() );
            goto AccessCheckComplete;
        }
        
        cbBuffer = buff.QuerySize();

        fRet = pecb->ServerSupportFunction( pecb,
                                            HSE_REQ_GET_METADATA_PROPERTY,
                                            buff.QueryPtr(),
                                            &cbBuffer,
                                            (LPDWORD) MD_URL_AUTHORIZATION_STORE_NAME );
        if ( !fRet )
        {
            DBG_ASSERT( GetLastError() != ERROR_INSUFFICIENT_BUFFER );
            
            fFatalError = TRUE;
            hr = HRESULT_FROM_WIN32( GetLastError() );
            goto AccessCheckComplete;
        }
    }
    
    //
    // Store name better be a string
    //
    
    pRecord = (METADATA_RECORD*) buff.QueryPtr();
    if ( pRecord->dwMDDataType != STRING_METADATA )
    {
        fFatalError = TRUE;
        hr = HRESULT_FROM_WIN32( ERROR_INVALID_DATA );
        goto AccessCheckComplete;
    }
        
    //
    // We should have an AdminManager store name now.  Get an ADMIN_MANAGER 
    // from the cache (cache will create it if not already in cache)
    //
    
    pszAdminStore = (WCHAR*) pRecord->pbMDData;
       
    DBG_ASSERT( g_pAdminManagerCache != NULL );
    
    hr = g_pAdminManagerCache->GetAdminManager( pszAdminStore,
                                                &pAdminManager );
    if ( FAILED( hr ) )
    {
        //
        // That sucks.  We couldn't find an admin manager
        //

        CustomErrorInfo.pszStatus = "500 Server Error";
        CustomErrorInfo.uHttpSubError = 18;     
        CustomErrorInfo.fAsync = TRUE;
        
        goto AccessCheckComplete;
    }
    
    DBG_ASSERT( pAdminManager != NULL );

    //
    // Get the application from the AdminManager.  That should be trivial
    // since we always have the same application name.
    //  
    
    hr = pAdminManager->GetApplication( &pApplication );
    if ( FAILED( hr ) )
    {
        fFatalError = TRUE;
        goto AccessCheckComplete;
    }
    
    DBG_ASSERT( pApplication != NULL );

    //
    // Get the scope name for this request
    //
    
    cbBuffer = buff.QuerySize();

    fRet = pecb->ServerSupportFunction( pecb,
                                        HSE_REQ_GET_METADATA_PROPERTY,
                                        buff.QueryPtr(),
                                        &cbBuffer,
                                        (LPDWORD) MD_URL_AUTHORIZATION_SCOPE_NAME );
    if ( !fRet )
    {
        //
        // It is acceptable to have no scope name.  Then we use the NULL scope
        //
        
        if ( GetLastError() == ERROR_INSUFFICIENT_BUFFER )
        {   
            DBG_ASSERT( cbBuffer > buff.QuerySize() );
            
            if ( !buff.Resize( cbBuffer ) )
            {
                fFatalError = TRUE;
                hr = HRESULT_FROM_WIN32( GetLastError() );
                goto AccessCheckComplete;
            }
        
            cbBuffer = buff.QuerySize();
    
            fRet = pecb->ServerSupportFunction( pecb,
                                                HSE_REQ_GET_METADATA_PROPERTY,
                                                buff.QueryPtr(),
                                                &cbBuffer,
                                                (LPDWORD) MD_URL_AUTHORIZATION_SCOPE_NAME );
            if ( !fRet )
            {
                DBG_ASSERT( GetLastError() != ERROR_INSUFFICIENT_BUFFER );
            
                fFatalError = TRUE;
                hr = HRESULT_FROM_WIN32( GetLastError() );
                goto AccessCheckComplete;
            }
        }
    }
    
    if ( fRet )
    {
        pRecord = (METADATA_RECORD*) buff.QueryPtr();
        
        if ( pRecord->dwMDDataType != STRING_METADATA )
        {
            fFatalError = TRUE;
            hr = HRESULT_FROM_WIN32( ERROR_INVALID_DATA );
            goto AccessCheckComplete;
        }
        
        //
        // We have a scope name.  It better be a string
        //
        
        pszScopeName = (WCHAR*) pRecord->pbMDData;
    }
    else
    {
        pszScopeName = NULL;
    }
    
    //
    // Do the access check
    //    
    
    hr = pApplication->DoAccessCheck( pecb,
                                      pszScopeName,
                                      &fAccessGranted );
    if ( FAILED( hr ) )
    {
        fFatalError = TRUE;
        goto AccessCheckComplete;
    }
    
    //
    // Determine what impersonation token should be used for execution of real URL
    //

    if ( fAccessGranted )
    {
        hr = GetTokenForExecution( pecb, &hImpersonationToken );
        if ( FAILED ( hr ) )
        {
            DBG_ASSERT( !hImpersonationToken );
            fAccessGranted = FALSE;
            fFatalError = TRUE;
            goto AccessCheckComplete;
        }
    }
    else
    {
        //
        // Didn't have access.  Thats a 401.7
        //

        CustomErrorInfo.pszStatus = "401 Unauthorized";
        CustomErrorInfo.uHttpSubError = 7;     
        CustomErrorInfo.fAsync = TRUE;
    }

AccessCheckComplete:

    // not OK to have both access granted and a fatal error.
    DBG_ASSERT ( !( fAccessGranted && fFatalError ) );

    //
    // Do some cleanup
    //
    
    if ( pAdminManager != NULL )
    {
        pAdminManager->DereferenceCacheEntry();
        pAdminManager = NULL;
    }

    //
    // Time to do something (TM).  
    //

    if ( fAccessGranted )
    {
        HSE_EXEC_UNICODE_URL_INFO   ExecUrlInfo;
        HSE_EXEC_UNICODE_URL_USER_INFO ExecUrlUserInfo;

        //
        // Everything is ok.  Just execute the original URL
        //

        fRet = pecb->ServerSupportFunction( pecb->ConnID,
                                            HSE_REQ_IO_COMPLETION,
                                            UrlAuthCompletion,
                                            NULL,
                                            (LPDWORD) hImpersonationToken );
        if ( !fRet )
        {
            DBG_ASSERT( FALSE );
            if ( hImpersonationToken )
            {
                DBG_REQUIRE( CloseHandle( hImpersonationToken ) );
                hImpersonationToken = NULL;
            }
            return HSE_STATUS_ERROR;
        }
        
        ZeroMemory( &ExecUrlInfo, sizeof( ExecUrlInfo ) );
        
        ExecUrlInfo.dwExecUrlFlags = HSE_EXEC_URL_IGNORE_CURRENT_INTERCEPTOR;
        
        if ( hImpersonationToken )
        {
            ExecUrlInfo.pUserInfo = &ExecUrlUserInfo;

            ZeroMemory( &ExecUrlUserInfo, sizeof( ExecUrlUserInfo ) );

            cbBuffer = buff.QuerySize();
            
            fRet = pecb->GetServerVariable( pecb->ConnID,
                                            "UNICODE_REMOTE_USER",
                                            buff.QueryPtr(),
                                            &cbBuffer );
            if ( !fRet )
            {
                if ( GetLastError() != ERROR_INSUFFICIENT_BUFFER )
                {
                    if ( hImpersonationToken )
                    {
                        DBG_REQUIRE( CloseHandle( hImpersonationToken ) );
                        hImpersonationToken = NULL;
                    }
                    return HSE_STATUS_ERROR;
                }
                
                DBG_ASSERT( cbBuffer > buff.QuerySize() );
                
                fRet = buff.Resize( cbBuffer );
                if ( !fRet )
                {
                    if ( hImpersonationToken )
                    {
                        DBG_REQUIRE( CloseHandle( hImpersonationToken ) );
                        hImpersonationToken = NULL;
                    }
                    return HSE_STATUS_ERROR;
                }
                
                cbBuffer = buff.QuerySize();
                
                fRet = pecb->GetServerVariable( pecb->ConnID,
                                                "UNICODE_REMOTE_USER",
                                                buff.QueryPtr(),
                                                &cbBuffer );
                if ( !fRet )
                {
                    if ( hImpersonationToken )
                    {
                        DBG_REQUIRE( CloseHandle( hImpersonationToken ) );
                        hImpersonationToken = NULL;
                    }
                    return HSE_STATUS_ERROR;
                }
            }

            ExecUrlUserInfo.pszCustomUserName = (WCHAR*) buff.QueryPtr();
            
            ExecUrlUserInfo.pszCustomAuthType = "URLAUTH";
            
            ExecUrlUserInfo.hImpersonationToken = hImpersonationToken;
        }
        
        fRet = pecb->ServerSupportFunction( pecb->ConnID,
                                            HSE_REQ_EXEC_UNICODE_URL,
                                            &ExecUrlInfo,
                                            NULL,
                                            NULL );

        if ( !fRet && hImpersonationToken )
        {
            DBG_REQUIRE( CloseHandle( hImpersonationToken ) );
        }
        hImpersonationToken = NULL;

        return fRet ? HSE_STATUS_PENDING : HSE_STATUS_ERROR;
    }
    else if ( !fFatalError )
    {
        //
        // This just means access wasn't granted.  Send back an error
        //

        fRet = pecb->ServerSupportFunction( pecb->ConnID,
                                            HSE_REQ_IO_COMPLETION,
                                            UrlAuthCompletion,
                                            NULL,
                                            NULL );
        if ( !fRet )
        {
            DBG_ASSERT( FALSE );
            return HSE_STATUS_ERROR;
        }
        
        fRet = pecb->ServerSupportFunction( pecb->ConnID,
                                            HSE_REQ_SEND_CUSTOM_ERROR,
                                            &CustomErrorInfo,
                                            NULL,
                                            NULL );

        if ( !fRet )
        {
            pecb->ServerSupportFunction( pecb->ConnID,
                                         HSE_REQ_SEND_RESPONSE_HEADER,
                                         "500 Server Error",
                                         NULL,
                                         NULL );

            return HSE_STATUS_ERROR;
        }
        else
        {
            return HSE_STATUS_PENDING;
        }
    }
    else
    {
        //
        // Fatal error.  Just set the last error and bail.
        //
        
        SetLastError( WIN32_FROM_HRESULT( hr ) );
        
        return HSE_STATUS_ERROR;
    }
}

BOOL
WINAPI
GetExtensionVersion(
    HSE_VERSION_INFO *             pver
)
/*++

Routine Description:

    Initialization routine for ISAPI

Arguments:

    pver - Version information

Return Value:

    TRUE if successful, else FALSE

--*/
{
    HRESULT             hr;
    
    //
    // Do ISAPI interface init crap
    //
    
    pver->dwExtensionVersion = MAKELONG( 0, 1 );

    strcpy( pver->lpszExtensionDesc,
            "URL Authorization ISAPI" );
    
    //
    // Create an admin manager cache
    //
    
    g_pAdminManagerCache = new ADMIN_MANAGER_CACHE;
    if ( g_pAdminManagerCache == NULL )
    {
        return FALSE;
    }

    //
    // Initialize ADMIN_MANAGER globals
    //   
    
    hr = ADMIN_MANAGER::Initialize();
    if ( FAILED( hr ) )
    {
        delete g_pAdminManagerCache;
        g_pAdminManagerCache = NULL;
        return FALSE;
    }
    
    //
    // Initialize AZ_APPLICATION globals
    //
    
    hr = AZ_APPLICATION::Initialize();
    if ( FAILED( hr ) )
    {
        ADMIN_MANAGER::Terminate();
        delete g_pAdminManagerCache;
        g_pAdminManagerCache = NULL;
        return FALSE;
    }
        
    return TRUE;
}

BOOL
WINAPI
TerminateExtension(
    DWORD             
)
/*++

Routine Description:

    Cleanup ISAPI extension

Arguments:

    None

Return Value:

    TRUE if successful, else FALSE

--*/
{
    AZ_APPLICATION::Terminate();
    
    ADMIN_MANAGER::Terminate();
    
    delete g_pAdminManagerCache;
    g_pAdminManagerCache = NULL;
    
    return TRUE;
}

BOOL
WINAPI
DllMain(
    HINSTANCE                  hDll,
    DWORD                      dwReason,
    LPVOID               
)
/*++

Routine Description:

    DLL Entry Routine

Arguments:

Return Value:

    TRUE if successful, else FALSE

--*/
{
    switch ( dwReason )
    {
    case DLL_PROCESS_ATTACH:

        CREATE_DEBUG_PRINT_OBJECT( "urlauth" );
        DisableThreadLibraryCalls( hDll );
        break;

    case DLL_PROCESS_DETACH:
        DELETE_DEBUG_PRINT_OBJECT();
        break;

    default:
        break;
    }
    
    return TRUE;
}

HRESULT
GetTokenForExecution(
    EXTENSION_CONTROL_BLOCK *pecb, 
    HANDLE * phToken
)
/*++

Routine Description:

    From metadata, determine the impersonation token to return

Arguments:

    pecb - current ecb for request
    phToken - where to store the token on success
    
Return Value:

    HRESULT

--*/
{
    HRESULT                 hr = S_OK;
    BOOL                    fRet = FALSE;
    METADATA_RECORD        *pRecord = NULL;
    STACK_BUFFER(           buff, 512 );
    DWORD                   cbBuffer;
    DWORD                   dwValue= 0;
    HANDLE                  hToken = NULL;
    HANDLE                  hToken2 = NULL;
    
    DBG_ASSERT(pecb);
    DBG_ASSERT(phToken);
    *phToken = NULL;
    
    cbBuffer = buff.QuerySize();

    fRet = pecb->ServerSupportFunction( pecb,
                                        HSE_REQ_GET_METADATA_PROPERTY,
                                        buff.QueryPtr(),
                                        &cbBuffer,
                                        (LPDWORD) MD_URL_AUTHORIZATION_IMPERSONATION_LEVEL );
    if ( !fRet && 
         GetLastError() != ERROR_INVALID_INDEX )
    {
        hr = HRESULT_FROM_WIN32( GetLastError() );
        goto exit;
    }
    else if ( fRet )
    {
        //
        // Check the property now.  If invalid type then we're done
        //

        pRecord = (METADATA_RECORD*) buff.QueryPtr();
        if ( pRecord->dwMDDataType != DWORD_METADATA )
        {
            hr = HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
            goto exit;
        }

        // valid type of data - validity of data value done in switch below
        dwValue = *(DWORD*)pRecord->pbMDData;
    }
    else
    {
        DBG_ASSERT( !fRet && GetLastError() == ERROR_INVALID_INDEX );
        
        // no metadata present, therefore use the default of zero
        dwValue = 0;
    }

    switch(dwValue)
    {
    case 0:
        // use the current authenticated user
        fRet = OpenThreadToken( GetCurrentThread(),
                                TOKEN_ALL_ACCESS,
                                TRUE,
                                &hToken );
        if ( !fRet )
        {
            hr = HRESULT_FROM_WIN32( GetLastError() );
            goto exit;
        }
        
        break;

    case 1:
        // use the process token to impersonate

        // first get the current impersonation token
        fRet = OpenThreadToken( GetCurrentThread(),
                                TOKEN_IMPERSONATE,
                                TRUE,
                                &hToken2 );
        if ( fRet )
        {
            DBG_ASSERT( hToken2 != NULL );
            RevertToSelf();
        }

        // get the current process token - it's a primary token
        fRet = OpenProcessToken( GetCurrentProcess(),
                                 TOKEN_ALL_ACCESS,
                                 &hToken );
    
    
        if ( hToken2 != NULL )
        {
            if ( !SetThreadToken( NULL, hToken2 ) )
            {
                DBG_ASSERT( FALSE );
            }
        
            DBG_REQUIRE( CloseHandle( hToken2 ) );
            hToken2 = NULL;
        }

        // checking the return value from open the process token here
        if ( !fRet )
        {
            hr = HRESULT_FROM_WIN32( GetLastError() );
            goto exit;
        }

        // create an impersonation token from the primary process token
        fRet = DuplicateHandle ( GetCurrentProcess(), 
                                 hToken, 
                                 GetCurrentProcess(), 
                                 &hToken2, 
                                 0, 
                                 FALSE, 
                                 DUPLICATE_SAME_ACCESS );
        if ( !fRet )
        {
            hr = HRESULT_FROM_WIN32( GetLastError() );
            goto exit;
        }

        DBG_REQUIRE( CloseHandle( hToken ) );

        hToken = hToken2;
        hToken2 = NULL;
        
        break;
        
    case 2:
        // get the anonymous token for impersonation
        cbBuffer = buff.QuerySize();
        
        fRet = pecb->GetServerVariable( pecb->ConnID,
                                        "UNICODE_SCRIPT_NAME",
                                        (CHAR*) buff.QueryPtr(),
                                        &cbBuffer );
        if ( !fRet )
        {
            if ( GetLastError() != ERROR_INSUFFICIENT_BUFFER )
            {
                hr = HRESULT_FROM_WIN32( GetLastError() );
                goto exit;
            }
            
            DBG_ASSERT( cbBuffer > buff.QuerySize() );
            
            fRet = buff.Resize( cbBuffer );
            if ( !fRet )
            {
                hr = HRESULT_FROM_WIN32( GetLastError() );
                goto exit;
            }
            
            cbBuffer = buff.QuerySize();
            
            fRet = pecb->GetServerVariable( pecb->ConnID,
                                            "UNICODE_SCRIPT_NAME",
                                            (CHAR*) buff.QueryPtr(),
                                            &cbBuffer );
            if ( !fRet )
            {
                hr = HRESULT_FROM_WIN32( GetLastError() );
                goto exit;
            }
        }
        

        fRet = pecb->ServerSupportFunction( pecb->ConnID,
                                            HSE_REQ_GET_UNICODE_ANONYMOUS_TOKEN,
                                            buff.QueryPtr(),
                                            (LPDWORD)&hToken,
                                            NULL );
        if ( !fRet )
        {
            hr = HRESULT_FROM_WIN32( GetLastError() );
            goto exit;
        }

        break;
        
    default: 
        // If not 0, 1, or 2 then not valid metadata
        hr = HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
        goto exit;

        break;
    }

    *phToken = hToken;
    hToken = NULL;

    hr = S_OK;

exit:

    if ( hToken )
    {
        DBG_REQUIRE( CloseHandle( hToken ) );
        hToken = NULL;
    }
    
    return hr;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\iisplus\w3isapi\dll_manager.cxx ===
/*++

   Copyright    (c)    2000-2001    Microsoft Corporation

   Module Name :
     dll_manager.cxx

   Abstract:
     IIS Plus ISAPI Handler. Dll management classes.
 
   Author:
     Taylor Weiss (TaylorW)             03-Feb-2000
     Wade A. Hilmo (WadeH)              08-Mar-2001

   Project:
     w3isapi.dll

--*/

#include "precomp.hxx"
#include "dll_manager.h"

ISAPI_DLL_MANAGER * g_pDllManager = NULL;

PTRACE_LOG              ISAPI_DLL::sm_pTraceLog;
ALLOC_CACHE_HANDLER *   ISAPI_DLL::sm_pachIsapiDlls;

//
//  Generic mapping for Application access check
//

GENERIC_MAPPING g_FileGenericMapping =
{
    FILE_GENERIC_READ,
    FILE_GENERIC_WRITE,
    FILE_GENERIC_EXECUTE,
    FILE_ALL_ACCESS
};

//static
HRESULT
ISAPI_DLL::Initialize(
    VOID
)
{
    ALLOC_CACHE_CONFIGURATION       acConfig;
    
#if DBG
    sm_pTraceLog = CreateRefTraceLog( 2000, 0 );
#endif

    //
    // Initialize a lookaside for this structure
    //
    
    acConfig.nConcurrency = 1;
    acConfig.nThreshold = 100;
    acConfig.cbSize = sizeof( ISAPI_DLL );

    DBG_ASSERT( sm_pachIsapiDlls == NULL );
    
    sm_pachIsapiDlls = new ALLOC_CACHE_HANDLER( "ISAPI_DLL",  
                                                &acConfig );

    if ( sm_pachIsapiDlls == NULL )
    {
        return HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );
    }

    return NO_ERROR;
}

//static
VOID
ISAPI_DLL::Terminate(
    VOID
)
{
    if ( sm_pTraceLog != NULL )
    {
        DestroyRefTraceLog( sm_pTraceLog );
        sm_pTraceLog = NULL;
    }
    
    if ( sm_pachIsapiDlls != NULL )
    {
        delete sm_pachIsapiDlls;
        sm_pachIsapiDlls = NULL;
    }
}    

HRESULT
ISAPI_DLL::SetName(
    const WCHAR *   szModuleName,
    HANDLE          hImpersonation
    )
{
    HRESULT hr;
    BOOL    fImpersonateForUnc = FALSE;

    DBG_ASSERT( CheckSignature() );

    hr = m_strModuleName.Copy( szModuleName );

    if ( FAILED( hr ) )
    {
        return hr;
    }

    //
    // Store a copy of the anti-canon module name
    //

    hr = MakePathCanonicalizationProof(
        const_cast<LPWSTR>( szModuleName ),
        &m_strAntiCanonModuleName
        );

    if ( SUCCEEDED( hr ) )
    {
        //
        // Verify that the file exists by getting its attributes.
        //
        // Note that in the UNC case, we have to do an impersonation
        // before we can make this call.
        //

        if ( wcsncmp( szModuleName, L"\\\\", 2 ) == 0 )
        {
            fImpersonateForUnc = SetThreadToken( NULL, hImpersonation );

            if ( !fImpersonateForUnc )
            {
                hr = HRESULT_FROM_WIN32( GetLastError() );

                DBGPRINTF((
                    DBG_CONTEXT,
                    "Attempt impersonate to get file attributes on %S failed "
                    "with error 0x%08x.\r\n",
                    szModuleName,
                    hr
                    ));

                return hr;
            }
        }

        if ( GetFileAttributes( m_strAntiCanonModuleName.QueryStr() ) ==
             0xffffffff )
        {
            IF_DEBUG( DLL_MANAGER )
            {
                DBGPRINTF((
                    DBG_CONTEXT,
                    "Attempt to get file attributes on %S failed "
                    "with error %d.\r\n",
                    szModuleName,
                    GetLastError()
                    ));
            }

            //
            // CODEWORK - This smoke and mirrors game with the last
            // error is to preserve the old behavior that extensions
            // that are not found return 500 errors to the client
            // instead of 404.
            //

            if ( GetLastError() == ERROR_FILE_NOT_FOUND )
            {
                SetLastError( ERROR_MOD_NOT_FOUND );
            }

            hr = HRESULT_FROM_WIN32( GetLastError() );
        }
    }

    if ( fImpersonateForUnc )
    {
        RevertToSelf();
    }
    
    return hr;
}

HRESULT
ISAPI_DLL::SetFastSid(
    IN PSID             pSid
)
{
    DBG_ASSERT( pSid != NULL );
    
    if ( GetLengthSid( pSid ) <= sizeof( m_abFastSid ) )
    {
        memcpy( m_abFastSid,
                pSid,
                GetLengthSid( pSid ) );
        
        m_pFastSid = m_abFastSid;
    }
    
    return NO_ERROR;
}

HRESULT
ISAPI_DLL::Load(
    IN HANDLE hImpersonation,
    IN PSID pSid
    )
{
    HRESULT             hr;
    HSE_VERSION_INFO    VersionInfo;
    BOOL                fImpersonatingForUnc = FALSE;

    DBG_ASSERT( CheckSignature() );

    //
    // Check to see if the dll is already loaded.
    // If so, just return NO_ERROR.
    //

    if ( m_fIsLoaded )
    {
        return NO_ERROR;
    }

    //
    // So the dll is not loaded.  Grab the lock and
    // check again (another thread may have snuck in between
    // the first test and now and already loaded it...
    //

    Lock();

    if ( !m_fIsLoaded )
    {
        //
        // Load the ACL for the dll file and do an access check
        // before loading the dll itself.  This is a slightly different
        // approach than what earlier versions of IIS did.  We are
        // not going to be actually doing impersonation at the time
        // we load the dll as earlier versions did.  As a result,
        // DllMain's DLL_PROCESS_ATTACH will run in the context of
        // the worker process primary token instead of as the
        // authenticated user.
        //
        // This new approach is the right way to do it, but it might
        // introduce an incompatibility with any extensions that implement
        // code in DllMain that depends on running as the authenticated
        // user.  It is very, very unlikely that we'll see this problem.
        // If we do, the solution is to impersonate the token before
        // calling LoadLibraryEx.
        //

        //
        // Before calling LoadAcl, we should check to see if this
        // dll lives on a UNC path.  If it does, then we need to
        // do the impersonation before attempting to load the ACL,
        // since we can't assume that the inetinfo or w3wp process
        // token can jump off the box.
        //

        if ( wcsncmp( m_strModuleName.QueryStr(), L"\\\\", 2 ) == 0 )
        {
            fImpersonatingForUnc = SetThreadToken( NULL, hImpersonation );

            if ( !fImpersonatingForUnc )
            {
                hr = HRESULT_FROM_WIN32( GetLastError() );

                DBGPRINTF(( DBG_CONTEXT,
                           "[ISAPI_DLL::Load] SetThreadToken failed for %S. Error %0x08x\n",
                            m_strModuleName.QueryStr(),
                            hr
                            ));

                goto Failed;
            }
        }

        hr = LoadAcl( m_strAntiCanonModuleName );

        if ( FAILED( hr ) )
        {
            goto Failed;
        }

        if ( !AccessCheck( hImpersonation, 
                           pSid ) )
        {
            hr =  HRESULT_FROM_WIN32( ERROR_ACCESS_DENIED );
            goto Failed;
        }

        //
        // Since we've just passed an AccessCheck, we can cache
        // the fast SID now.
        //
        
        if ( pSid != NULL )
        {
            hr = SetFastSid( pSid );

            if ( FAILED( hr ) )
            {
                goto Failed;
            }
        }

        m_hModule = LoadLibraryEx( m_strAntiCanonModuleName.QueryStr(),
                                   NULL,
                                   LOAD_WITH_ALTERED_SEARCH_PATH
                                   );

        if ( m_hModule == NULL ) 
        {
            hr = HRESULT_FROM_WIN32( GetLastError() );
        
            DBGPRINTF(( DBG_CONTEXT,
                       "[ISAPI_DLL::Load] LoadLibrary %S failed. Error %d\n",
                        m_strModuleName.QueryStr(),
                        GetLastError()
                        ));

            goto Failed;
        }

        //
        // Lose the impersonation token before we call any more entry points...
        //

        if ( fImpersonatingForUnc )
        {
            RevertToSelf();
            fImpersonatingForUnc = FALSE;
        }
    
        //
        // Get the entry points
        //

        m_pfnGetExtensionVersion = 
            (PFN_GETEXTENSIONVERSION)GetProcAddress( m_hModule, 
                                                     "GetExtensionVersion" 
                                                     );

        m_pfnTerminateExtension = 
            (PFN_TERMINATEEXTENSION)GetProcAddress( m_hModule,
                                                    "TerminateExtension"
                                                    );

        m_pfnHttpExtensionProc = 
            (PFN_HTTPEXTENSIONPROC)GetProcAddress( m_hModule,
                                                   "HttpExtensionProc"
                                                   );
    
        //
        // HttpExtensionProc and GetExtensionVersion are required
        //

        if( !m_pfnGetExtensionVersion ||
            !m_pfnHttpExtensionProc )
        {
            hr = HRESULT_FROM_WIN32( ERROR_PROC_NOT_FOUND );

            //
            // Make sure we dont call TerminateExtension on
            // cleanup.
            //

            m_pfnTerminateExtension = NULL;

            goto Failed;
        }

        if( !m_pfnGetExtensionVersion( &VersionInfo ) )
        {
            hr = GetLastError() == ERROR_SUCCESS ?
                E_FAIL :
                HRESULT_FROM_WIN32( GetLastError() );

            goto Failed;
        }

        DBGPRINTF(( DBG_CONTEXT,
                    "ISAPI_DLL::Load() Loaded extension %S, "
                    " description \"%s\"\n",
                    m_strModuleName.QueryStr(),
                    VersionInfo.lpszExtensionDesc ));

        m_fIsLoaded = TRUE;
    }

    Unlock();
    
    return NO_ERROR;

Failed:

    DBG_ASSERT( FAILED( hr ) );

    //
    // Clean up after the failed load attempt
    //

    if ( fImpersonatingForUnc )
    {
        RevertToSelf();
        fImpersonatingForUnc = FALSE;
    }

    if ( m_pfnHttpExtensionProc )
    {
        m_pfnHttpExtensionProc = NULL;
    }

    if ( m_pfnGetExtensionVersion )
    {
        m_pfnGetExtensionVersion = NULL;
    }

    if ( m_pfnTerminateExtension )
    {
        m_pfnTerminateExtension = NULL;
    }

    if ( m_hModule )
    {
        FreeLibrary( m_hModule );
        m_hModule = NULL;
    }

    Unlock();

    return hr;
}

VOID
ISAPI_DLL::Unload( VOID )
{
    if( m_pfnTerminateExtension )
    {
        m_pfnTerminateExtension( HSE_TERM_MUST_UNLOAD );
        m_pfnTerminateExtension = NULL;
    }

    m_pfnGetExtensionVersion = NULL;
    m_pfnHttpExtensionProc = NULL;

    if( m_hModule )
    {
        FreeLibrary( m_hModule );
    }
}

HRESULT
ISAPI_DLL::LoadAcl( STRU &strModuleName )
{
    DWORD cbSecDesc = m_buffSD.QuerySize();
    DWORD dwError;

    DBG_ASSERT( CheckSignature() );
    
    //
    //  Force an access check on the next request
    //

    while ( !GetFileSecurity( strModuleName.QueryStr(),
                              (OWNER_SECURITY_INFORMATION |
                               GROUP_SECURITY_INFORMATION |
                               DACL_SECURITY_INFORMATION),
                              m_buffSD.QueryPtr(),
                              m_buffSD.QuerySize(),
                              &cbSecDesc ))
    {
        if ( ( dwError = GetLastError() ) != ERROR_INSUFFICIENT_BUFFER )
        {
            return HRESULT_FROM_WIN32( dwError );
        }

        if ( !m_buffSD.Resize( cbSecDesc ) )
        {
            return HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );
        }

        //
        // Hopefully, we have sufficient buffer now, retry
        //
    }

    return NOERROR;
}

BOOL
ISAPI_DLL::AccessCheck(
    IN HANDLE hImpersonation,
    IN PSID   pSid
    )
{
    BOOL          fRet = TRUE;
    DWORD         dwGrantedAccess = 0;
    BYTE          PrivSet[400];
    DWORD         cbPrivilegeSet = sizeof(PrivSet);
    BOOL          fAccessGranted;

    DBG_ASSERT( CheckSignature() );

    //
    // First compare to the fast check SID if possible
    //
    
    if ( pSid != NULL && QueryFastSid() != NULL )
    {
        if ( EqualSid( pSid, QueryFastSid() ) )
        {
            return TRUE;
        }
    }

    //
    // Ok, just do the real access check
    //

    fRet = ( ::AccessCheck( QuerySecDesc(),
                            hImpersonation,
                            FILE_GENERIC_EXECUTE,
                            &g_FileGenericMapping,
                            (PRIVILEGE_SET *) &PrivSet,
                            &cbPrivilegeSet,
                            &dwGrantedAccess,
                            &fAccessGranted )
            && fAccessGranted);

    return fRet;
}

HRESULT
ISAPI_DLL_MANAGER::GetIsapi( 
    IN const WCHAR *    szModuleName,
    OUT ISAPI_DLL **    ppIsapiDll,
    IN HANDLE           hImpersonation,
    IN PSID             pSid
    )
{
    HRESULT     hr          = NOERROR;
    ISAPI_DLL * pIsapiDll   = NULL;
    LK_RETCODE  lkrc;

    IF_DEBUG( DLL_MANAGER )
    {
        DBGPRINTF((
            DBG_CONTEXT,
            "DllManager looking for %S.\r\n",
            szModuleName
            ));
    }

    //
    // Check for the ISAPI in the hash table.  If we don't
    // find it, then we'll need to create an entry in the
    // hash for it.
    //

    lkrc = m_IsapiHash.FindKey( szModuleName, &pIsapiDll );

    if ( lkrc == LK_SUCCESS )
    {
        IF_DEBUG( DLL_MANAGER )
        {
            DBGPRINTF((
                DBG_CONTEXT,
                "Found ISAPI_DLL %p (%S).\r\n",
                pIsapiDll,
                pIsapiDll->QueryModuleName()
                ));
        }
    }
    else
    {
        //
        // Create a new entry
        //

        IF_DEBUG( DLL_MANAGER )
        {
            DBGPRINTF((
                DBG_CONTEXT,
                "Creating new ISAPI_DLL object for %S.\r\n",
                szModuleName
                ));
        }

        pIsapiDll = new ISAPI_DLL;

        if ( !pIsapiDll )
        {
            hr = HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );
            goto Failed;
        }

        if ( FAILED( hr = pIsapiDll->SetName( szModuleName, hImpersonation ) ) )
        {
            pIsapiDll->DereferenceIsapiDll();
            pIsapiDll = NULL;
            goto Failed;
        }

        //
        // Insert the new object into the hash table.  If someone
        // else beat us to it, then we'll just release our new one.
        //

        lkrc = m_IsapiHash.InsertRecord( pIsapiDll );

        if ( lkrc == LK_SUCCESS )
        {
            IF_DEBUG( DLL_MANAGER )
            {
                DBGPRINTF((
                    DBG_CONTEXT,
                    "Added ISAPI_DLL %p to table for %S.\r\n",
                    pIsapiDll,
                    szModuleName
                    ));
            }
        }
        else
        {
            pIsapiDll->DereferenceIsapiDll();
            pIsapiDll = NULL;

            if ( lkrc == LK_KEY_EXISTS )
            {
                IF_DEBUG( DLL_MANAGER )
                {
                    DBGPRINTF((
                        DBG_CONTEXT,
                        "InsertRecord for %S returned LK_KEY_EXISTS.\r\n",
                        szModuleName
                        ));
                }

                //
                // Ok, so let's get the existing one
                //

                lkrc = m_IsapiHash.FindKey( szModuleName, &pIsapiDll );
            }

            if ( lkrc != LK_SUCCESS )
            {
                hr = HRESULT_FROM_WIN32( lkrc );
                goto Failed;
            }
        }
    }

    DBG_ASSERT( pIsapiDll );

    //
    // Call the Load function for the ISAPI_DLL.  Note that the ISAPI_DLL
    // function is smart enough to deal with locking on GetExtensionVersion
    // and in only allowing it to happen one time.
    //

    hr = pIsapiDll->Load( hImpersonation,
                          pSid );

    if ( FAILED( hr ) )
    {
        goto Failed;
    }

    //
    // We've got the extension, but we still need to do
    // an access check to make sure that the client
    // is allowed to run it.
    //

    DBG_ASSERT( pIsapiDll );

    if ( !pIsapiDll->AccessCheck( hImpersonation, 
                                  pSid ) )
    {
        hr = HRESULT_FROM_WIN32( ERROR_ACCESS_DENIED );
        goto Failed;
    }

    //
    // We're about to return successfully.  Set the out parameter now.
    //

    *ppIsapiDll = pIsapiDll;

    DBG_ASSERT( SUCCEEDED( hr ) );

    return hr;

Failed:

    DBG_ASSERT( FAILED( hr ) );

    IF_DEBUG( DLL_MANAGER )
    {
        DBGPRINTF((
            DBG_CONTEXT,
            "Error %d(0x%08x) occurred getting ISAPI_DLL object for %S.\r\n",
            hr,
            hr,
            szModuleName
            ));
    }

    if ( pIsapiDll )
    {
        pIsapiDll->DereferenceIsapiDll();
        pIsapiDll = NULL;
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\iisplus\w3isapi\dbgutil.h ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    dbgutil.h

Abstract:

    This module declares the macros to wrap around DEBUG_PRINTS class
    defined in pudebug.h    
  
    This is the exported header file, that the users are allowed to modify.
    If there are no custom definitions, please use the templated version
    in the root iisrearc\inc\dbgutil.h
 
Author:

    Murali R. Krishnan (MuraliK)    22-Sept-1994

--*/


# ifndef _DBGUTIL_H_
# define _DBGUTIL_H_



// begin_user_modifiable

//
//  Modify the following flags if necessary
//

# define DEFAULT_OUTPUT_FLAGS   ( DbgOutputKdb )

// end_user_modifiable


//
// include standard debug support
//
// note: define DEFAULT_OUTPUT_FLAGS before including pudebug.h
//

# include <pudebug.h>


// begin_user_modifiable

// Use the default constants from pudebug.h: 0x00000001 to 0x00000100

//
//  Define the debugging constants as bit-flag values
//  Example: # define DEBUG_FOOBAR 0x00010000
//  Note: All debugging bit-values below 0x00001000 are reserved!
// 
//  If you add or change a flag, please update FlagTableWp
//  in core\common\dtflags\dtflags.c
//

#define DEBUG_DLL_MANAGER                   0x80000000
#define DEBUG_ISAPI_EXTENSION_ENTRY         0x10000000
#define DEBUG_ISAPI_GET_SERVER_VARIABLE     0x01000000
#define DEBUG_ISAPI_SERVER_SUPPORT_FUNCTION 0x02000000
#define DEBUG_ISAPI_SSF_DETAILS             0x04000000
#define DEBUG_ISAPI_DUMP_BUFFERS            0x08000000
#define DEBUG_ISAPI_ERROR_RETURNS           0x00100000
#define DEBUG_ISAPI_SUCCESS_RETURNS         0x00200000
#define DEBUG_ISAPI_READ_CLIENT             0x00400000
#define DEBUG_ISAPI_WRITE_CLIENT            0x00800000
#define DEBUG_ISAPI_REF_TRACE               0x00080000

//
// Set the maximum number of bytes that'll get printed in a debug
// dump of binary data (16 bytes are printed per dump line).
//

#define MAX_DEBUG_DUMP 10*16

// end_user_modifiable


# endif  /* _DBGUTIL_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\iisplus\w3isapi\w3isapi.cxx ===
/*++

   Copyright    (c)    1999-2001    Microsoft Corporation

   Module Name :
     w3isapi.cxx

   Abstract:
     IIS Plus ISAPI Handler
 
   Author:
     Wade Hilmo (WadeH)                 03-Feb-2000

   Project:
     w3isapi.dll

--*/


/************************************************************
 *  Include Headers
 ************************************************************/

#include "precomp.hxx"
#include "isapi_context.hxx"
#include "server_support.hxx"

#define W3_ISAPI_MOF_FILE     L"W3IsapiMofResource"
#define W3_ISAPI_PATH         L"w3isapi.dll"

/************************************************************
 * Globals
 ************************************************************/

CHAR    g_szClsid[SIZE_CLSID_STRING];
CHAR    g_szIsapiHandlerInstance[SIZE_CLSID_STRING];
DWORD   g_dwPidW3Core;
CEtwTracer * g_pEtwTracer;

/************************************************************
 *  Declarations
 ************************************************************/

BOOL
WINAPI
GetServerVariable(
    HCONN       hConn,
    LPSTR       lpszVariableName,
    LPVOID      lpvBuffer,
    LPDWORD     lpdwSize
    );

BOOL
WINAPI
WriteClient(
    HCONN      ConnID,
    LPVOID     Buffer,
    LPDWORD    lpdwBytes,
    DWORD      dwReserved
    );

BOOL
WINAPI
ReadClient(
    HCONN      ConnID,
    LPVOID     lpvBuffer,
    LPDWORD    lpdwSize
    );

BOOL
WINAPI
ServerSupportFunction(
    HCONN      hConn,
    DWORD      dwHSERequest,
    LPVOID     lpvBuffer,
    LPDWORD    lpdwSize,
    LPDWORD    lpdwDataType
    );

HRESULT
ProcessIsapiRequest(
    IIsapiCore *        pIsapiCore,
    ISAPI_CORE_DATA *   pCoreData,
    DWORD *             pHseResult
    );

HRESULT
ProcessIsapiCompletion(
    VOID *  pContext,
    DWORD   cbCompletion,
    DWORD   dwCompletionStatus
    );

HRESULT
InitModule(
    LPCSTR  szClsid,
    LPCSTR  szIsapiHandlerInstance,
    DWORD   dwPidW3Core
    );

VOID
TerminateModule( VOID );

VOID
FixupIsapiCoreData(
    ISAPI_CORE_DATA *   pCoreData
    );

// BUGBUG
#undef INET_INFO_KEY
#undef INET_INFO_PARAMETERS_KEY

//
//  Configuration parameters registry key.
//
#define INET_INFO_KEY \
            "System\\CurrentControlSet\\Services\\w3svc"

#define INET_INFO_PARAMETERS_KEY \
            INET_INFO_KEY "\\Parameters"

const CHAR g_pszWpRegLocation[] =
    INET_INFO_PARAMETERS_KEY "\\w3isapi";


DECLARE_DEBUG_PRINTS_OBJECT();
DECLARE_DEBUG_VARIABLE();
DECLARE_PLATFORM_TYPE();

/************************************************************
 *  Type Definitions  
 ************************************************************/


HRESULT
InitModule(
    LPCSTR  szClsid,
    LPCSTR  szIsapiHandlerInstance,
    DWORD   dwPidW3Core
    )
/*++

Routine Description:

    Initializes the w3isapi module

Arguments:

    szClsid                - In the OOP case, this is the CLSID of
                             the application being hosted.  This
                             value may be NULL (ie. in the case of
                             inproc ISAPI).
    szIsapiHandlerInstance - The instance ID of the ISAPI handler
                             that's initializing this module.
    dwPidW3Core            - The PID of the process containing the
                             core server that's responsible for this
                             module
  
Return Value:

    HRESULT

--*/
{
    HRESULT hr = NOERROR;
    BOOL    fIisUtilInitialized = FALSE;
    BOOL    fIsapiContextInitialized = FALSE;
    BOOL    fIsapiDllInitialized = FALSE;

    CREATE_DEBUG_PRINT_OBJECT("w3isapi");
    if (!VALID_DEBUG_PRINT_OBJECT())
    {
        return E_FAIL;
    }

    LOAD_DEBUG_FLAGS_FROM_REG_STR( g_pszWpRegLocation, DEBUG_ERROR );

    INITIALIZE_PLATFORM_TYPE();

    DBGPRINTF((
        DBG_CONTEXT,
        "Initializing w3isapi.dll - CLSID: %s, "
        "ISAPI Handler: %s, W3Core PID %d.\r\n",
        szClsid ? szClsid : "NULL",
        szIsapiHandlerInstance,
        dwPidW3Core
        ));

    //
    // Initialize IISUTIL
    //

    if ( !InitializeIISUtil() )
    {
        hr = HRESULT_FROM_WIN32( GetLastError() );

        DBGPRINTF(( DBG_CONTEXT,
                    "Error initializing IISUTIL.  hr = %x\n",
                    hr ));

        goto Failed;
    }

    fIisUtilInitialized = TRUE;

    //
    // Intialize trace stuff so that initialization can use it
    //
    
    g_pEtwTracer = new CEtwTracer;
    if ( g_pEtwTracer == NULL )
    {
        hr = E_OUTOFMEMORY;
        goto Failed;
    }
    
    hr = g_pEtwTracer->Register( &IsapiControlGuid,
                                 W3_ISAPI_PATH,
                                 W3_ISAPI_MOF_FILE );
    if ( FAILED( hr ) )
    {
        goto Failed;
    }
    
    //
    // If g_pDllManager is not NULL at this point, then
    // this module is being intialized multiple times.  This
    // is an unexpected state.
    //

    if ( g_pDllManager != NULL )
    {
        DBGPRINTF((
            DBG_CONTEXT,
            "Warning - w3isapi.dll previously initalized.\r\n"
            "Previous CLSID: %s, Previous ISAPI Handler: %s, "
            "Previous W3Core PID: %d.\r\n",
            g_szClsid,
            g_szIsapiHandlerInstance,
            g_dwPidW3Core
            ));

        DBG_ASSERT( g_pDllManager );

        //
        // Normally, we'd exit this function via "goto Failed" on
        // failure.  This case is an exception.  When this function
        // returns here, the WAM_PROCESS_MANAGER will just kill off
        // this process, so we're not worried about returning in a
        // non-perfect state at this point.
        //

        return HRESULT_FROM_WIN32( ERROR_ALREADY_INITIALIZED );
    }

    g_pDllManager = new ISAPI_DLL_MANAGER( szClsid == NULL ? TRUE : FALSE );

    if( g_pDllManager == NULL )
    {
        hr = E_OUTOFMEMORY;
        goto Failed;
    }
    
    hr = ISAPI_CONTEXT::Initialize();

    if ( FAILED( hr ) ) 
    {
        goto Failed;
    }

    fIsapiContextInitialized = TRUE;

    hr = ISAPI_DLL::Initialize();

    if ( FAILED( hr ) )
    {
        goto Failed;
    }

    fIsapiDllInitialized = TRUE;

    //
    // If we've successfully initialized, then store
    // the information from the caller so that we can
    // debug double initializations.
    //

    if ( SUCCEEDED( hr ) )
    {
        if ( szClsid )
        {
            strncpy(
                g_szClsid,
                szClsid,
                SIZE_CLSID_STRING
                );

            g_szClsid[SIZE_CLSID_STRING - 1] = '\0';
        }
        else
        {
            strcpy( g_szClsid, "NULL" );
        }

        strncpy(
            g_szIsapiHandlerInstance,
            szIsapiHandlerInstance,
            SIZE_CLSID_STRING
            );

        g_szIsapiHandlerInstance[SIZE_CLSID_STRING - 1] = '\0';

        g_dwPidW3Core = dwPidW3Core;
    }

    return hr;

Failed:

    DBG_ASSERT( FAILED( hr ) );

    if ( g_pEtwTracer )
    {
        delete g_pEtwTracer;
        g_pEtwTracer = NULL;
    }

    if ( g_pDllManager )
    {
        delete g_pDllManager;
        g_pDllManager = NULL;
    }

    if ( fIisUtilInitialized )
    {
        TerminateIISUtil();
        fIisUtilInitialized = FALSE;
    }

    if ( fIsapiContextInitialized )
    {
        ISAPI_CONTEXT::Terminate();
        fIsapiContextInitialized = FALSE;
    }

    if ( fIsapiDllInitialized )
    {
        ISAPI_DLL::Terminate();
        fIsapiDllInitialized = FALSE;
    }

    return hr;
}

VOID
TerminateModule( VOID )
/*++

Routine Description:

    Terminates the w3isapi module

Arguments:

    None
  
Return Value:

    None

--*/
{
    ISAPI_CONTEXT::Terminate();

    DBG_ASSERT( g_pDllManager );

    if( g_pDllManager )
    {
        delete g_pDllManager;
        g_pDllManager = NULL;
    }

    ISAPI_DLL::Terminate();

    if ( g_pEtwTracer != NULL ) 
    {
        g_pEtwTracer->UnRegister();
        delete g_pEtwTracer;
        g_pEtwTracer = NULL;
    }

    TerminateIISUtil();
    
    DELETE_DEBUG_PRINT_OBJECT();
}

HRESULT
ProcessIsapiRequest(
    IIsapiCore *        pIsapiCore,
    ISAPI_CORE_DATA *   pCoreData,
    DWORD *             pHseResult
    )
/*++

Routine Description:

    Processes an ISAPI request

Arguments:

    pIsapiCore - The interface that provides connectivity to the core server
    pCoreData  - The core data that describes the request
    pHseResult - Upon return, contains the return code from
                 the extension's HttpExtensionProc
  
Return Value:

    HRESULT

--*/
{
    ISAPI_DLL *                 pIsapiDll = NULL;
    DWORD                       dwIsapiReturn = HSE_STATUS_ERROR;
    ISAPI_CONTEXT *             pIsapiContext = NULL;
    PFN_HTTPEXTENSIONPROC       pfnHttpExtensionProc;
    EXTENSION_CONTROL_BLOCK *   pEcb = NULL;
    HRESULT                     hr = NO_ERROR;
    ISAPI_CORE_DATA *           pTempCoreData = NULL;
    
    DBG_ASSERT( g_pDllManager );

    //
    // This function is only called by w3core.dll
    //

    DBG_ASSERT( pIsapiCore );
    DBG_ASSERT( pCoreData );
    DBG_ASSERT( pHseResult );

    //
    // If this request is running OOP, then make a local copy
    // and fix up the core data internal pointers.
    //

    if ( pCoreData->fIsOop )
    {
        pTempCoreData = (ISAPI_CORE_DATA*) LocalAlloc( LPTR, pCoreData->cbSize );

        if ( !pTempCoreData )
        {
            hr = HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );
            goto Failed;
        }

        memcpy( pTempCoreData, pCoreData, pCoreData->cbSize );

        //
        // We'll set pCoreData to point to our temp one.  This
        // doesn't leak because the ISAPI_CONTEXT destructor is smart
        // enough to know it needs to be deleted in the OOP case.
        //

        pCoreData = pTempCoreData;

        FixupIsapiCoreData( pCoreData );
    }

    //
    // Get the entry point for the ISAPI
    //

    hr = g_pDllManager->GetIsapi(
        pCoreData->szGatewayImage,
        &pIsapiDll,
        pCoreData->hToken,
        pCoreData->pSid
        );

    if ( FAILED( hr ) )
    {
        goto Failed;
    }

    //
    // Construct the ISAPI_CONTEXT for this request.  Once it's
    // allocated, it owns the lifetime of the ISAPI_REQUEST.  When
    // the ISAPI_CONTEXT is deallocated, it may release the final
    // reference.
    //

    pIsapiContext = new (pIsapiCore) ISAPI_CONTEXT( pIsapiCore, pCoreData, pIsapiDll );

    if ( pIsapiContext == NULL )
    {
        hr = HRESULT_FROM_WIN32( GetLastError () );
        goto Failed;
    }

    //
    // Set the ECB
    //

    pEcb = pIsapiContext->QueryECB();

    //
    // Set the ECB function pointers
    //

    pEcb->GetServerVariable = GetServerVariable;
    pEcb->WriteClient = WriteClient;
    pEcb->ReadClient = ReadClient;
    pEcb->ServerSupportFunction = ServerSupportFunction;

    //
    // Get the extension's entry point
    //
    
    pfnHttpExtensionProc = pIsapiDll->QueryHttpExtensionProc();

    //
    // Trace Hook point that links the HTTP_REQUEST_ID to
    // ConnId passed to ISAPI dlls via the ECB.
    //

    if ( ETW_IS_TRACE_ON(ETW_LEVEL_CP) ) 
    {
        g_pEtwTracer->EtwTraceEvent( &IsapiEventGuid,
                                     ETW_TYPE_START,
                                     &pCoreData->RequestId,
                                     sizeof(HTTP_REQUEST_ID),
                                     &pEcb->ConnID, 
                                     sizeof(ULONG_PTR),
                                     &pCoreData->fIsOop, 
                                     sizeof(ULONG), 
                                     NULL, 
                                     0);
    }

    //
    // If we are running OOP, set the COM state so that the
    // extension can CoInitialize/CoUninitialize.
    //

    if ( pIsapiContext->QueryIsOop() )
    {
        hr = pIsapiContext->SetComStateForOop();

        DBG_ASSERT( SUCCEEDED( hr ) );
    }

    //
    // Impersonate the authenticated user and call it
    //

    if ( !SetThreadToken( NULL, pIsapiContext->QueryToken() ) )
    {
        hr = HRESULT_FROM_WIN32( GetLastError() );
        goto Failed;
    }

    pIsapiContext->ReferenceIsapiContext();

    IF_DEBUG( ISAPI_EXTENSION_ENTRY )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "\r\n"
                    "  Calling into HttpExtensionProc\r\n"
                    "    Extension: '%S'\r\n"
                    "    pECB: %p\r\n"
                    "  <END>\r\n\r\n",
                    pIsapiContext->QueryGatewayImage(),
                    pEcb ));
    }

    dwIsapiReturn = pfnHttpExtensionProc( pEcb );

    DBG_REQUIRE( RevertToSelf() );

    if ( pIsapiContext->QueryIsOop() )
    {
        pIsapiContext->RestoreComStateForOop();
    }

    pIsapiContext->DereferenceIsapiContext();

    switch ( dwIsapiReturn )
    {
        case HSE_STATUS_PENDING:

            IF_DEBUG( ISAPI_EXTENSION_ENTRY )
            {
                DBGPRINTF(( DBG_CONTEXT,
                            "\r\n"
                            "  HttpExtensionProc returned HSE_STATUS_PENDING\r\n"
                            "    Extension: '%S'\r\n"
                            "    pECB: %p\r\n"
                            "  <END>\r\n\r\n",
                            pIsapiContext->QueryGatewayImage(),
                            pEcb ));
            }

            //
            // Don't dereference the ISAPI_CONTEXT.  This
            // will guarantee that it lives on beyond the
            // return from this function.
            //

            break;


        case HSE_STATUS_SUCCESS_AND_KEEP_CONN:

            IF_DEBUG( ISAPI_EXTENSION_ENTRY )
            {
                DBGPRINTF(( DBG_CONTEXT,
                            "\r\n"
                            "  HttpExtensionProc returned HSE_STATUS_SUCCESS_AND_KEEP_CONN\r\n"
                            "    Extension: '%S'\r\n"
                            "    pECB: %p\r\n"
                            "  <END>\r\n\r\n",
                            pIsapiContext->QueryGatewayImage(),
                            pEcb ));
            }

            //
            // Special case of success.  The extension wants
            // to keep the connection open, even though we may
            // not have detected proper response headers.
            //
            // After setting the disconnect mode, fall through.
            //

            if ( pIsapiContext->QueryClientKeepConn() &&
                 pIsapiContext->QueryHonorAndKeepConn() )
            {
                pIsapiContext->SetKeepConn( TRUE );
                pIsapiCore->SetConnectionClose( FALSE );
            }

        case HSE_STATUS_ERROR:
        case HSE_STATUS_SUCCESS:
        default:

            IF_DEBUG( ISAPI_EXTENSION_ENTRY )
            {
                if ( dwIsapiReturn == HSE_STATUS_ERROR ||
                     dwIsapiReturn == HSE_STATUS_SUCCESS )
                {
                    DBGPRINTF(( DBG_CONTEXT,
                                "\r\n"
                                "  HttpExtensionProc returned %s\r\n"
                                "    Extension: '%S'\r\n"
                                "    pECB: %p\r\n"
                                "  <END>\r\n\r\n",
                                dwIsapiReturn == HSE_STATUS_SUCCESS ? "HSE_STATUS_SUCCESS" : "HSE_STATUS_ERROR",
                                pIsapiContext->QueryGatewayImage(),
                                pEcb ));
                }
                else
                {
                    DBGPRINTF(( DBG_CONTEXT,
                                "\r\n"
                                "  HttpExtensionProc returned unknown status 0x%08x (%d)\r\n"
                                "    Extension: '%S'\r\n"
                                "    pECB: %p\r\n"
                                "  <END>\r\n\r\n",
                                dwIsapiReturn,
                                dwIsapiReturn,
                                pIsapiContext->QueryGatewayImage(),
                                pEcb ));
                }
            }


            DBG_ASSERT( pIsapiContext->QueryIoState() == NoAsyncIoPending );

            pIsapiContext->DereferenceIsapiContext();

            break;
    }

    *pHseResult = dwIsapiReturn;

    pIsapiDll->DereferenceIsapiDll();
    pIsapiDll = NULL;

    return NO_ERROR;

Failed:

    DBG_ASSERT( FAILED( hr ) );

    if ( pIsapiContext )
    {
        pIsapiContext->DereferenceIsapiContext();
        pIsapiContext = NULL;
    }
    else
    {
        //
        // In OOP case, we're depending on the ISAPI_CONTEXT destructor
        // to free the copy of the core data and close the impersonation
        // token.  If we weren't able to allocate one, we'll have to
        // do it here.
        //

        if ( pCoreData->fIsOop )
        {
            CloseHandle( pCoreData->hToken );

            if ( pTempCoreData )
            {
                LocalFree( pTempCoreData );
                pTempCoreData = NULL;
            }
        }
    }

    if ( pIsapiDll )
    {
        pIsapiDll->DereferenceIsapiDll();
        pIsapiDll = NULL;
    }

    return hr;
}

HRESULT
ProcessIsapiCompletion(
    DWORD64 IsaContext,
    DWORD   cbCompletion,
    DWORD   dwCompletionStatus
    )
/*++

Routine Description:

    Processes an I/O completion for an ISAPI extension

Arguments:

    IsaContext         - The ISAPI_CONTEXT for this completion
    cbCompletion       - The byte count associated with the completion
    dwCompletionStatus - The result code associated with the completion
  
Return Value:

    HRESULT

--*/
{
    ISAPI_CONTEXT *         pIsapiContext;
    ASYNC_PENDING           IoType;
    PFN_HSE_IO_COMPLETION   pfnCompletion;
    DWORD                   cbLastIo;
    HRESULT                 hr = NO_ERROR;

    DBG_REQUIRE( ( pIsapiContext = reinterpret_cast<ISAPI_CONTEXT*>( IsaContext ) ) != NULL );

    pIsapiContext->ReferenceIsapiContext();

    //
    // Magical hand waving:
    //
    // If this is a completion for a write, then we need to
    // restore the original buffer size.  This is necessary
    // to keep from confusing ISAPI extensions that examine
    // the cbCompletion value in the case where a filter
    // changed the size of the buffer before the actual
    // IO occured.
    //
    // If this is a completion for an EXEC_URL, then we need
    // to set the dwCompletionStatus to ERROR_SUCCESS.  The
    // caller of the EXEC_URL should use GET_EXECUTE_URL_STATUS
    // to see the result of the child URL.
    //

    cbLastIo = pIsapiContext->QueryLastAsyncIo();
    pIsapiContext->SetLastAsyncIo( 0 );

    IoType = pIsapiContext->UninitAsyncIo();

    if ( IoType == AsyncWritePending )
    {
        cbCompletion = cbLastIo;
    }
    else if ( IoType == AsyncExecPending )
    {
        dwCompletionStatus = ERROR_SUCCESS;
    }
    else if ( IoType == AsyncReadPending &&
              dwCompletionStatus == ERROR_HANDLE_EOF )
    {
        //
        // If http.sys returns ERROR_HANDLE_EOF on an
        // asynchronous read, then this completion is
        // for the end of a chunk transfer encoded
        // request.  We should mask the error from
        // the client and make it look like a successful
        // zero byte read.
        //

        cbCompletion = 0;
        dwCompletionStatus = ERROR_SUCCESS;
    }
    
    //
    // If the completion context indicates a completion routine,
    // then call it.
    //

    pfnCompletion = pIsapiContext->QueryPfnIoCompletion();

    if ( pfnCompletion )
    {
        //
        // First, impersonate the client
        //

        if ( SetThreadToken( NULL, pIsapiContext->QueryToken() ) )
        {
            IF_DEBUG( ISAPI_EXTENSION_ENTRY )
            {
                DBGPRINTF(( DBG_CONTEXT,
                            "\r\n"
                            "  Calling into ISAPI extension for completion\r\n"
                            "    Extension: '%S'\r\n"
                            "    pECB: %p\r\n"
                            "    Completion Routine: %p\r\n"
                            "    Bytes: %d\r\n"
                            "    Status: 0x%08x (%d)\r\n"
                            "    Extension Context: %p\r\n"
                            "  <END>\r\n\r\n",
                            pIsapiContext->QueryGatewayImage(),
                            pIsapiContext->QueryECB(),
                            pfnCompletion,
                            cbCompletion,
                            dwCompletionStatus,
                            dwCompletionStatus,
                            pIsapiContext->QueryExtensionContext() ));
            }

            pfnCompletion(
                pIsapiContext->QueryECB(),
                pIsapiContext->QueryExtensionContext(),
                cbCompletion,
                dwCompletionStatus
                );

            IF_DEBUG( ISAPI_EXTENSION_ENTRY )
            {
                DBGPRINTF(( DBG_CONTEXT,
                            "\r\n"
                            "  ISAPI extension completion returned\r\n"
                            "    Extension: '%S'\r\n"
                            "    pECB: %p\r\n"
                            "  <END>\r\n\r\n",
                            pIsapiContext->QueryGatewayImage(),
                            pIsapiContext->QueryECB() ));
            }

            DBG_REQUIRE( RevertToSelf() );
        }
        else
        {
            hr =  HRESULT_FROM_WIN32( GetLastError() );
        }
    }

    pIsapiContext->DereferenceIsapiContext();

    return hr;
}

BOOL
WINAPI
GetServerVariable(
    HCONN       hConn,
    LPSTR       lpszVariableName,
    LPVOID      lpvBuffer,
    LPDWORD     lpdwSize
    )
/*++

Routine Description:

    Retrieves a server variable

Arguments:

    hConn            - The ConnID associated with the request.  This
                       value is opaque to the ISAPI that calls into
                       this function, but it can be cast to the
                       ISAPI_CONTEXT associated with the request.
    lpszVariableName - The name of the variable to retrieve
    lpvBuffer        - Upon return, contains the value of the variable
    lpdwSize         - On entry, contains the size of lpvBuffer, upon
                       return, contains the number of bytes actually
                       needed to contain the value.
  
Return Value:

    HRESULT

--*/
{
    ISAPI_CONTEXT * pIsapiContext;
    IIsapiCore *    pIsapiCore;
    HANDLE          hCurrentUser;
    HRESULT         hr;

    pIsapiContext = reinterpret_cast<ISAPI_CONTEXT*>( hConn );

    IF_DEBUG( ISAPI_GET_SERVER_VARIABLE )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "\r\n"
                    "  GetServerVariable[%p]: Function Entry\r\n"
                    "    Variable Name: %s\r\n"
                    "  <END>\r\n\r\n",
                    pIsapiContext,
                    lpszVariableName ));
    }

    //
    // Parameter validation
    //

    if ( pIsapiContext ==  NULL ||
         lpszVariableName == NULL ||
         lpdwSize == NULL )
    {
        IF_DEBUG( ISAPI_ERROR_RETURNS )
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "\r\n"
                        "  GetServerVariable[%p]: Parameter validation failure\r\n"
                        "    Variable Name: %s\r\n"
                        "    Buffer Size Ptr: %p\r\n"
                        "    Returing FALSE, LastError=ERROR_INVALID_PARAMETER\r\n"
                        "  <END>\r\n\r\n",
                        pIsapiContext,
                        lpszVariableName,
                        lpdwSize ));
        }

        SetLastError( ERROR_INVALID_PARAMETER );
        return FALSE;
    }

    pIsapiCore = pIsapiContext->QueryIsapiCoreInterface();

    if ( pIsapiCore == NULL )
    {
        IF_DEBUG( ISAPI_ERROR_RETURNS )
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "\r\n"
                        "  GetServerVariable[%p]: Failed to get interface to server core\r\n"
                        "    Returning FALSE, LastError=ERROR_INVALID_PARAMETER\r\n"
                        "  <END>\r\n\r\n",
                        pIsapiContext ));
        }

        SetLastError( ERROR_INVALID_PARAMETER );
        return FALSE;
    }

    //
    // If the caller passed us a NULL buffer, then we should
    // treat it as zero size - even if *lpdwBuffer is non-zero
    //

    if ( lpvBuffer == NULL )
    {
        *lpdwSize = 0;
    }

    //
    // If we are running OOP, then try and get the data
    // locally from the process.
    //

    if ( pIsapiContext->QueryIsOop() )
    {
        SERVER_VARIABLE_INDEX   Index;
        BOOL                    fResult;

        Index = LookupServerVariableIndex( lpszVariableName );

        if ( Index != ServerVariableExternal )
        {
            fResult = pIsapiContext->GetOopServerVariableByIndex(
                Index,
                lpvBuffer,
                lpdwSize
                );

            if ( !fResult )
            {
                IF_DEBUG( ISAPI_ERROR_RETURNS )
                {
                    DBGPRINTF(( DBG_CONTEXT,
                                "\r\n"
                                "  GetServerVariable[%p]: Failed\r\n"
                                "    Returning FALSE, LastError=%d\r\n"
                                "  <END>\r\n\r\n",
                                pIsapiContext,
                                GetLastError() ));
                }
            }
            else
            {
                IF_DEBUG( ISAPI_GET_SERVER_VARIABLE )
                {
                    IF_DEBUG( ISAPI_SUCCESS_RETURNS )
                    {
                        if ( _strnicmp( lpszVariableName, "UNICODE_", 8 ) == 0 )
                        {
                            DBGPRINTF(( DBG_CONTEXT,
                                        "\r\n"
                                        "  GetServerVariable[%p]: Succeeded\r\n"
                                        "    %s value: '%S'\r\n"
                                        "    Returning TRUE\r\n"
                                        "  <END>\r\n\r\n",
                                        pIsapiContext,
                                        lpszVariableName,
                                        (LPWSTR)lpvBuffer ));
                        }
                        else
                        {
                            DBGPRINTF(( DBG_CONTEXT,
                                        "\r\n"
                                        "  GetServerVariable[%p]: Succeeded\r\n"
                                        "    %s value: '%s'\r\n"
                                        "    Returning TRUE\r\n"
                                        "  <END>\r\n\r\n",
                                        pIsapiContext,
                                        lpszVariableName,
                                        (LPSTR)lpvBuffer ));
                        }
                    }
                }
            }

            return fResult;
        }
    }

    //
    // Call it
    //

    pIsapiContext->IsapiDoRevertHack( &hCurrentUser );

    hr = pIsapiCore->GetServerVariable(
        lpszVariableName,
        *lpdwSize ? (BYTE*)lpvBuffer : NULL,
        *lpdwSize,
        lpdwSize
        );

    pIsapiContext->IsapiUndoRevertHack( &hCurrentUser);

    if ( FAILED( hr ) )
    {
        IF_DEBUG( ISAPI_ERROR_RETURNS )
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "\r\n"
                        "  GetServerVariable[%p]: Failed\r\n"
                        "    Returning FALSE, LastError=0x%08x (%d)\r\n"
                        "  <END>\r\n\r\n",
                        pIsapiContext,
                        hr,
                        WIN32_FROM_HRESULT( hr ) ));
        }
            
        SetLastError( WIN32_FROM_HRESULT( hr ) );
        return FALSE;
    }

    IF_DEBUG( ISAPI_GET_SERVER_VARIABLE )
    {
        IF_DEBUG( ISAPI_SUCCESS_RETURNS )
        {
            if ( _strnicmp( lpszVariableName, "UNICODE_", 8 ) == 0 )
            {
                DBGPRINTF(( DBG_CONTEXT,
                            "\r\n"
                            "  GetServerVariable[%p]: Succeeded\r\n"
                            "    %s value: '%S'\r\n"
                            "    Returning TRUE\r\n"
                            "  <END>\r\n\r\n",
                            pIsapiContext,
                            lpszVariableName,
                            (LPWSTR)lpvBuffer ));
            }
            else
            {
                DBGPRINTF(( DBG_CONTEXT,
                            "\r\n"
                            "  GetServerVariable[%p]: Succeeded\r\n"
                            "    %s value: '%s'\r\n"
                            "    Returning TRUE\r\n"
                            "  <END>\r\n\r\n",
                            pIsapiContext,
                            lpszVariableName,
                            (LPSTR)lpvBuffer ));
            }
        }
    }

    return TRUE;
}

BOOL
WINAPI
WriteClient(
    HCONN      ConnID,
    LPVOID     Buffer,
    LPDWORD    lpdwBytes,
    DWORD      dwReserved
    )
/*++

Routine Description:

    Writes data to the client

Arguments:

    hConn      - The ConnID associated with the request.  This
                 value is opaque to the ISAPI that calls into
                 this function, but it can be cast to the
                 ISAPI_CONTEXT associated with the request.
    Buffer     - The data to write
    lpdwBytes  - On entry, the number of bytes to write.  Upon
                 return, the number of bytes written (or so the
                 docs say)
    dwReserved - Flags (ie. HSE_IO_SYNC, etc.)
  
Return Value:

    HRESULT

--*/
{
    ISAPI_CONTEXT * pIsapiContext;
    IIsapiCore *    pIsapiCore;
    HANDLE          hCurrentUser;
    HRESULT         hr;

    pIsapiContext = reinterpret_cast<ISAPI_CONTEXT*>( ConnID );

    IF_DEBUG( ISAPI_WRITE_CLIENT )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "\r\n"
                    "  WriteClient[%p]: Function Entry\r\n"
                    "    Extension: %S\r\n"
                    "    Bytes to Send: %d\r\n"
                    "    Sync Flag: %s\r\n"
                    "  <END>\r\n\r\n",
                    pIsapiContext,
                    pIsapiContext ? pIsapiContext->QueryGatewayImage() : L"*",
                    *lpdwBytes,
                    dwReserved ? dwReserved & HSE_IO_SYNC ? "HSE_IO_SYNC" : "HSE_IO_ASYNC" : "0" ));

        IF_DEBUG( ISAPI_DUMP_BUFFERS )
        {
            STACK_STRA( strBufferDump,512 );
            DWORD       dwBytesToDump = *lpdwBytes;

            if ( dwBytesToDump > MAX_DEBUG_DUMP )
            {
                dwBytesToDump = MAX_DEBUG_DUMP;
            }

            if ( FAILED( strBufferDump.CopyBinary( Buffer, dwBytesToDump ) ) )
            {
                strBufferDump.Copy( "" );
            }

            DBGPRINTF(( DBG_CONTEXT,
                        "\r\n"
                        "  WriteClient[%p]: Dump of up to %d bytes of send buffer\r\n"
                        "%s"
                        "  <END>\r\n\r\n",
                        pIsapiContext,
                        MAX_DEBUG_DUMP,
                        strBufferDump.QueryStr() ));
        }
    }

    //
    // Parameter validation
    //

    if ( pIsapiContext == NULL ||
         lpdwBytes == NULL ||
         ( *lpdwBytes != 0 && Buffer == NULL ) )
    {
        IF_DEBUG( ISAPI_ERROR_RETURNS )
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "\r\n"
                        "  WriteClient[%p]: Parameter validation failed\r\n"
                        "    Bytes to send: %d\r\n"
                        "    Buffer Pointer: %p.\r\n"
                        "    Returning FALSE, LastError=ERROR_INVALID_PARAMETER\r\n"
                        "  <END>\r\n\r\n",
                        pIsapiContext,
                        lpdwBytes,
                        Buffer ));
        }

        SetLastError( ERROR_INVALID_PARAMETER );
        return FALSE;
    }

    pIsapiCore = pIsapiContext->QueryIsapiCoreInterface();

    DBG_ASSERT( pIsapiCore );

    if ( pIsapiCore == NULL )
    {
        IF_DEBUG( ISAPI_ERROR_RETURNS )
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "\r\n"
                        "  WriteClient[%p]: Failed to get interface to server core\r\n"
                        "    Returning FALSE, LastError=ERROR_INVALID_PARAMETER\r\n"
                        "  <END>\r\n\r\n",
                        pIsapiContext ));
        }

        SetLastError( ERROR_INVALID_PARAMETER );
        return FALSE;
    }

    //
    // If the user is sending zero bytes, return TRUE here.  Yeah, this
    // will be kind of a bogus thing to do because if the call is async,
    // we will return successful with no completion ever occuring.
    //
    // IIS has done this for as long as sync WriteClient has existed, and
    // we'd risk breaking legacy code if we change it now.
    //

    if ( *lpdwBytes == 0 )
    {
        IF_DEBUG( ISAPI_WRITE_CLIENT )
        {
            IF_DEBUG( ISAPI_SUCCESS_RETURNS )
            {
                DBGPRINTF(( DBG_CONTEXT,
                            "\r\n"
                            "  WriteClient[%p]: Bytes to send is zero\r\n"
                            "    Returning TRUE\r\n"
                            "  <END>\r\n\r\n",
                            pIsapiContext ));
            }
        }

        return TRUE;
    }

    //
    // BUGBUG - Need to map the documented HSE_IO flags to reasonable
    // UL equivalents and provide a mechanism to pass them.
    //

    if ( dwReserved & HSE_IO_ASYNC )
    {
        //
        // Do an asynchronous write
        //
        // Check to make sure that we have a completion
        // function.
        //

        if ( pIsapiContext->QueryPfnIoCompletion() == NULL ||
             pIsapiContext->TryInitAsyncIo( AsyncWritePending ) == FALSE )
        {
            IF_DEBUG( ISAPI_ERROR_RETURNS )
            {
                DBGPRINTF(( DBG_CONTEXT,
                            "\r\n"
                            "  WriteClient[%p]: Failed to perform asynchronous send\r\n"
                            "    Another async operation was already pending.\r\n"
                            "    Returning FALSE, LastError=ERROR_INVALID_PARAMETER\r\n"
                            "  <END>\r\n\r\n",
                            pIsapiContext ));
            }

            SetLastError( ERROR_INVALID_PARAMETER );
            return FALSE;
        }

        //
        // Some extensions depend on the number of bytes reported in the
        // completion to confirm success.  In the case where a send raw
        // data filter is installed (or if we are using SSL), it's possible
        // that the number of bytes in the completion is not what the
        // caller expects.
        //
        // We need to save away the number of bytes that they are sending
        // to protect them from themselves.
        //

        pIsapiContext->SetLastAsyncIo( *lpdwBytes );

        pIsapiContext->IsapiDoRevertHack( &hCurrentUser );

        hr = pIsapiCore->WriteClient(
            reinterpret_cast<DWORD64>( pIsapiContext ),
            reinterpret_cast<LPBYTE>( Buffer ),
            *lpdwBytes,
            HSE_IO_ASYNC
            );

        pIsapiContext->IsapiUndoRevertHack( &hCurrentUser );

        if ( FAILED( hr ) )
        {
            pIsapiContext->SetLastAsyncIo( 0 );
            pIsapiContext->UninitAsyncIo();
        }
    }
    else
    {
        //
        // Do a synchronous write
        //

        pIsapiContext->IsapiDoRevertHack( &hCurrentUser );

        hr = pIsapiCore->WriteClient(
            NULL,
            reinterpret_cast<LPBYTE>( Buffer ),
            *lpdwBytes,
            HSE_IO_SYNC
            );

        pIsapiContext->IsapiUndoRevertHack( &hCurrentUser );
    }

    if ( FAILED( hr ) )
    {
        IF_DEBUG( ISAPI_ERROR_RETURNS )
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "\r\n"
                        "  WriteClient[%p]: Attempt to write failed\r\n",
                        "    Returning FALSE, LastError=0x%08x ( %d )\r\n"
                        "  <END>\r\n\r\n",
                        pIsapiContext,
                        hr,
                        WIN32_FROM_HRESULT( hr ) ));
        }

        SetLastError( WIN32_FROM_HRESULT( hr ) );
        return FALSE;
    }

    IF_DEBUG( ISAPI_WRITE_CLIENT )
    {
        IF_DEBUG( ISAPI_SUCCESS_RETURNS )
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "\r\n"
                        "  WriteClient[%p]: Succeeded\r\n"
                        "    Returning TRUE\r\n"
                        "  <END>\r\n\r\n",
                        pIsapiContext ));
        }
    }
    
    return TRUE;
}

BOOL
WINAPI
ReadClient(
    HCONN      ConnID,
    LPVOID     lpvBuffer,
    LPDWORD    lpdwSize
    )
/*++

Routine Description:

    Reads data from the client

Arguments:

    hConn     - The ConnID associated with the request.  This
                value is opaque to the ISAPI that calls into
                this function, but it can be cast to the
                ISAPI_CONTEXT associated with the request.
    lpvBuffer - Upon return, contains the data read
    lpdwsize  - On entry, the size of lpvBuffer.  Upon
                return, the number of bytes read.
  
Return Value:

    HRESULT

--*/
{
    ISAPI_CONTEXT * pIsapiContext;
    IIsapiCore *    pIsapiCore;
    HANDLE          hCurrentUser;
    HRESULT         hr;

    pIsapiContext = reinterpret_cast<ISAPI_CONTEXT*>( ConnID );

    IF_DEBUG( ISAPI_READ_CLIENT )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "\r\n"
                    "  ReadClient[%p]: Function Entry\r\n"
                    "    Bytes to Read: %d\r\n"
                    "  <END>\r\n\r\n",
                    pIsapiContext,
                    *lpdwSize ));
    }

    //
    // Parameter validation
    //

    if ( pIsapiContext == NULL ||
         lpdwSize == NULL ||
         ( *lpdwSize != 0 && lpvBuffer == NULL ) )
    {
        IF_DEBUG( ISAPI_ERROR_RETURNS )
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "\r\n"
                        "  ReadClient[%p]: Parameter validation failure\r\n"
                        "    Bytes to Read Ptr: %p\r\n"
                        "    Bytes to Read: %d\r\n"
                        "    Buffer Ptr: %p\r\n"
                        "    Returning FALSE, LastError=ERROR_INVALID_PARAMETER\r\n"
                        "  <END>\r\n\r\n",
                        pIsapiContext,
                        lpdwSize,
                        lpdwSize ? *lpdwSize : 0,
                        lpvBuffer ));
        }

        SetLastError( ERROR_INVALID_PARAMETER );
        return FALSE;
    }

    pIsapiCore = pIsapiContext->QueryIsapiCoreInterface();

    if ( pIsapiCore == NULL )
    {
        IF_DEBUG( ISAPI_ERROR_RETURNS )
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "\r\n"
                        "  ReadClient[%p]: Failed to get interface to server core\r\n"
                        "    Returning FALSE, LastError=ERROR_INVALID_PARAMETER\r\n"
                        "  <END>\r\n\r\n",
                        pIsapiContext ));
        }

        SetLastError( ERROR_INVALID_PARAMETER );
        return FALSE;
    }

    pIsapiContext->IsapiDoRevertHack( &hCurrentUser );

    hr = pIsapiCore->ReadClient(
        NULL,
        reinterpret_cast<unsigned char *>( lpvBuffer ),
        *lpdwSize,
        *lpdwSize,
        lpdwSize,
        HSE_IO_SYNC
        );

    pIsapiContext->IsapiUndoRevertHack( &hCurrentUser );

    if ( FAILED( hr ) )
    {
        IF_DEBUG( ISAPI_ERROR_RETURNS )
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "\r\n"
                        "  ReadClient[%p]: Failed\r\n"
                        "    Returning FALSE, LastError=0x%08x (%d)\r\n"
                        "  <END>\r\n\r\n",
                        pIsapiContext,
                        hr,
                        WIN32_FROM_HRESULT( hr ) ));
        }

        SetLastError( WIN32_FROM_HRESULT( hr ) );
        return FALSE;
    }

    IF_DEBUG( ISAPI_READ_CLIENT )
    {
        IF_DEBUG( ISAPI_SUCCESS_RETURNS )
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "\r\n"
                        "  ReadClient[%p]: Succeeded\r\n"
                        "    Bytes Read: %d\r\n"
                        "    Returning TRUE\r\n"
                        "  <END>\r\n\r\n",
                        pIsapiContext,
                        *lpdwSize ));

            IF_DEBUG( ISAPI_DUMP_BUFFERS )
            {
                STACK_STRA( strBufferDump,512 );
                DWORD       dwBytesToDump = *lpdwSize;

                if ( dwBytesToDump > MAX_DEBUG_DUMP )
                {
                    dwBytesToDump = MAX_DEBUG_DUMP;
                }

                if ( FAILED( strBufferDump.CopyBinary( lpvBuffer, dwBytesToDump ) ) )
                {
                    strBufferDump.Copy( "" );
                }

                DBGPRINTF(( DBG_CONTEXT,
                            "\r\n"
                            "  ReadClient[%p]: Dump of up to %d bytes of receive buffer\r\n"
                            "%s"
                            "  <END>\r\n\r\n",
                            pIsapiContext,
                            MAX_DEBUG_DUMP,
                            strBufferDump.QueryStr() ));
            }
        }
    }

    return TRUE;
}

BOOL
WINAPI
ServerSupportFunction(
    HCONN      hConn,
    DWORD      dwHSERequest,
    LPVOID     lpvBuffer,
    LPDWORD    lpdwSize,
    LPDWORD    lpdwDataType
    )
/*++

Routine Description:

    Dispatches a ServerSupportFunction command to the appropriate
    server support function.

Arguments:

    hConn        - The ConnID associated with the request.  This
                   value is opaque to the ISAPI that calls into
                   this function, but it can be cast to the
                   ISAPI_CONTEXT associated with the request.
    dwHSERequest - The server support command
    lpvBuffer    - Command-specific data
    lpdwSize     - Command-specific data
    lpdwDataType - Command-specific data
  
Return Value:

    HRESULT

--*/
{
    ISAPI_CONTEXT * pIsapiContext;
    HANDLE          hCurrentUser;
    HRESULT         hr = NO_ERROR;

    pIsapiContext = reinterpret_cast<ISAPI_CONTEXT*>( hConn );

    IF_DEBUG( ISAPI_SERVER_SUPPORT_FUNCTION )
    {
        CHAR    szCommand[64];

        switch ( dwHSERequest )
        {
        case HSE_REQ_SEND_RESPONSE_HEADER:
            wsprintfA( szCommand, "HSE_REQ_SEND_RESPONSE_HEADER" );
            break;
        case HSE_REQ_SEND_RESPONSE_HEADER_EX:
            wsprintfA( szCommand, "HSE_REQ_SEND_RESPONSE_HEADER_EX" );
            break;
        case HSE_REQ_MAP_URL_TO_PATH:
            wsprintfA( szCommand, "HSE_REQ_MAP_URL_TO_PATH" );
            break;
        case HSE_REQ_MAP_URL_TO_PATH_EX:
            wsprintfA( szCommand, "HSE_REQ_MAP_URL_TO_PATH_EX" );
            break;
        case HSE_REQ_MAP_UNICODE_URL_TO_PATH:
            wsprintfA( szCommand, "HSE_REQ_MAP_UNICODE_URL_TO_PATH" );
            break;
        case HSE_REQ_MAP_UNICODE_URL_TO_PATH_EX:
            wsprintfA( szCommand, "HSE_REQ_MAP_UNICODE_URL_TO_PATH_EX" );
            break;
        case HSE_REQ_GET_IMPERSONATION_TOKEN:
            wsprintfA( szCommand, "HSE_REQ_GET_IMPERSONATION_TOKEN" );
            break;
        case HSE_REQ_IS_KEEP_CONN:
            wsprintfA( szCommand, "HSE_REQ_IS_KEEP_CONN" );
            break;
        case HSE_REQ_DONE_WITH_SESSION:
            wsprintfA( szCommand, "HSE_REQ_DONE_WITH_SESSION" );
            break;
        case HSE_REQ_GET_CERT_INFO_EX:
            wsprintfA( szCommand, "HSE_REQ_GET_CERT_INFO_EX" );
            break;
        case HSE_REQ_IO_COMPLETION:
            wsprintfA( szCommand, "HSE_REQ_IO_COMPLETION" );
            break;
        case HSE_REQ_ASYNC_READ_CLIENT:
            wsprintfA( szCommand, "HSE_REQ_ASYNC_READ_CLIENT" );
            break;
        case HSE_REQ_TRANSMIT_FILE:
            wsprintfA( szCommand, "HSE_REQ_TRANSMIT_FILE" );
            break;
        case HSE_REQ_SEND_URL:
            wsprintfA( szCommand, "HSE_REQ_SEND_URL" );
            break;
        case HSE_REQ_SEND_URL_REDIRECT_RESP:
            wsprintfA( szCommand, "HSE_REQ_SEND_URL_REDIRECT_RESP" );
            break;
        case HSE_REQ_IS_CONNECTED:
            wsprintfA( szCommand, "HSE_REQ_IS_CONNECTED" );
            break;
        case HSE_APPEND_LOG_PARAMETER:
            wsprintfA( szCommand, "HSE_REQ_APPEND_LOG_PARAMETER" );
            break;
        case HSE_REQ_EXEC_URL:
            wsprintfA( szCommand, "HSE_REQ_EXEC_URL" );
            break;
        case HSE_REQ_EXEC_UNICODE_URL:
            wsprintfA( szCommand, "HSE_REQ_EXEC_UNICODE" );
            break;
        case HSE_REQ_GET_EXEC_URL_STATUS:
            wsprintfA( szCommand, "HSE_REQ_GET_EXEC_URL_STATUS" );
            break;
        case HSE_REQ_SEND_CUSTOM_ERROR:
            wsprintfA( szCommand, "HSE_REQ_SEND_CUSTOM_ERROR" );
            break;
        case HSE_REQ_VECTOR_SEND_DEPRECATED:
            wsprintfA( szCommand, "HSE_REQ_VECTOR_SEND_DEPRECATED" );
            break;
        case HSE_REQ_VECTOR_SEND:
            wsprintfA( szCommand, "HSE_REQ_VECTOR_SEND" );
            break;
        case HSE_REQ_GET_CUSTOM_ERROR_PAGE:
            wsprintfA( szCommand, "HSE_REQ_GET_CUSTOM_ERROR_PAGE" );
            break;
        case HSE_REQ_IS_IN_PROCESS:
            wsprintfA( szCommand, "HSE_REQ_IS_IN_PROCESS" );
            break;
        case HSE_REQ_GET_SSPI_INFO:
            wsprintfA( szCommand, "HSE_REQ_GET_SSPI_INFO" );
            break;
        case HSE_REQ_GET_VIRTUAL_PATH_TOKEN:
            wsprintfA( szCommand, "HSE_REQ_GET_VIRTUAL_PATH_TOKEN" );
            break;
        case HSE_REQ_GET_UNICODE_VIRTUAL_PATH_TOKEN:
            wsprintfA( szCommand, "HSE_REQ_UNICODE_VIRTUAL_PATH_TOKEN" );
            break;
        case HSE_REQ_REPORT_UNHEALTHY:
            wsprintfA( szCommand, "HSE_REQ_REPORT_UNHEALTHY" );
            break;
        case HSE_REQ_NORMALIZE_URL:
            wsprintfA( szCommand, "HSE_REQ_NORMALIZE_URL" );
            break;
        case HSE_REQ_ADD_FRAGMENT_TO_CACHE:
            wsprintfA( szCommand, "HSE_REQ_ADD_FRAGMENT_TO_CACHE" );
            break;
        case HSE_REQ_READ_FRAGMENT_FROM_CACHE:
            wsprintfA( szCommand, "HSE_REQ_READ_FRAGMENT_FROM_CACHE" );
            break;
        case HSE_REQ_REMOVE_FRAGMENT_FROM_CACHE:
            wsprintfA( szCommand, "HSE_REQ_REMOVE_FRAGMENT_FROM_CACHE" );
            break;
        case HSE_REQ_GET_METADATA_PROPERTY:
            wsprintfA( szCommand, "HSE_REQ_GET_METADATA_PROPERTY" );
            break;
        case HSE_REQ_CLOSE_CONNECTION:
            wsprintfA( szCommand, "HSE_REQ_CLOSE_CONNECTION" );
            break;
        case HSE_REQ_REFRESH_ISAPI_ACL:
            wsprintfA( szCommand, "HSE_REQ_REFRESH_ISAPI_ACL" );
            break;
        case HSE_REQ_ABORTIVE_CLOSE:
            wsprintfA( szCommand, "HSE_REQ_ABORTIVE_CLOSE" );
            break;
        case HSE_REQ_GET_ANONYMOUS_TOKEN:
            wsprintfA( szCommand, "HSE_REQ_GET_ANONYMOUS_TOKEN" );
            break;
        case HSE_REQ_GET_UNICODE_ANONYMOUS_TOKEN:
            wsprintfA( szCommand, "HSE_REQ_GET_UNICODE_ANONYMOUS_TOKEN" );
            break;
        case HSE_REQ_GET_CACHE_INVALIDATION_CALLBACK:
            wsprintfA( szCommand, "HSE_REQ_GET_CACHE_INVALIDATION_CALLBACK" );
            break;
        default:
            wsprintfA( szCommand,
                      "Unknown command: 0x%08x (%d)",
                      dwHSERequest,
                      dwHSERequest );
            break;
        }

        DBGPRINTF(( DBG_CONTEXT,
                    "\r\n"
                    "  ServerSupportFunction[%p]: Function Entry\r\n"
                    "    Command: %s\r\n"
                    "  <END>\r\n\r\n",
                    pIsapiContext,
                    szCommand ));
    }

    //
    // Parameter validation
    //

    if ( pIsapiContext == NULL )
    {
        IF_DEBUG( ISAPI_ERROR_RETURNS )
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "\r\n"
                        "  ServerSupportFunction[%p]: Invalid ConnID\r\n"
                        "    Returning FALSE, LastError=ERROR_INVALID_PARAMETER\r\n"
                        "  <END>\r\n\r\n",
                        pIsapiContext ));
        }

        SetLastError( ERROR_INVALID_PARAMETER );
        return FALSE;
    }

    pIsapiContext->ReferenceIsapiContext();
    pIsapiContext->IsapiDoRevertHack( &hCurrentUser );

    //
    // Handle the specified command
    //

    switch ( dwHSERequest )
    {

    case HSE_REQ_SEND_RESPONSE_HEADER:

        hr = SSFSendResponseHeader(
            pIsapiContext,
            reinterpret_cast<LPSTR>( lpvBuffer ),
            reinterpret_cast<LPSTR>( lpdwDataType )
            );

        break;

    case HSE_REQ_SEND_RESPONSE_HEADER_EX:

        hr = SSFSendResponseHeaderEx(
            pIsapiContext,
            reinterpret_cast<HSE_SEND_HEADER_EX_INFO*>( lpvBuffer )
            );

        break;

    case HSE_REQ_MAP_URL_TO_PATH:

        hr = SSFMapUrlToPath(
            pIsapiContext,
            reinterpret_cast<LPSTR>( lpvBuffer ),
            lpdwSize
            );

        break;

    case HSE_REQ_MAP_URL_TO_PATH_EX:

        hr = SSFMapUrlToPathEx(
            pIsapiContext,
            reinterpret_cast<LPSTR>( lpvBuffer ),
            reinterpret_cast<HSE_URL_MAPEX_INFO*>( lpdwDataType ),
            lpdwSize
            );

        break;

    case HSE_REQ_MAP_UNICODE_URL_TO_PATH:

        hr = SSFMapUnicodeUrlToPath(
            pIsapiContext,
            reinterpret_cast<LPWSTR>( lpvBuffer ),
            lpdwSize
            );

        break;

    case HSE_REQ_MAP_UNICODE_URL_TO_PATH_EX:

        hr = SSFMapUnicodeUrlToPathEx(
            pIsapiContext,
            reinterpret_cast<LPWSTR>( lpvBuffer ),
            reinterpret_cast<HSE_UNICODE_URL_MAPEX_INFO*>( lpdwDataType ),
            lpdwSize
            );

        break;

    case HSE_REQ_GET_IMPERSONATION_TOKEN:

        hr = SSFGetImpersonationToken(
            pIsapiContext,
            reinterpret_cast<HANDLE*>( lpvBuffer )
            );

        break;

    case HSE_REQ_IS_KEEP_CONN:

        hr = SSFIsKeepConn(
            pIsapiContext,
            reinterpret_cast<BOOL*>( lpvBuffer )
            );

        break;

    case HSE_REQ_DONE_WITH_SESSION:

        hr = SSFDoneWithSession(
            pIsapiContext,
            reinterpret_cast<DWORD*>( lpvBuffer )
            );

        break;

    case HSE_REQ_GET_CERT_INFO_EX:

        hr = SSFGetCertInfoEx(
            pIsapiContext,
            reinterpret_cast<CERT_CONTEXT_EX*>( lpvBuffer )
            );

        break;

    case HSE_REQ_IO_COMPLETION:

        hr = SSFIoCompletion(
            pIsapiContext,
            reinterpret_cast<PFN_HSE_IO_COMPLETION>( lpvBuffer ),
            reinterpret_cast<VOID*>( lpdwDataType )
            );

        break;

    case HSE_REQ_ASYNC_READ_CLIENT:

        hr = SSFAsyncReadClient(
            pIsapiContext,
            lpvBuffer,
            lpdwSize
            );

        break;

    case HSE_REQ_TRANSMIT_FILE:

        hr = SSFTransmitFile(
            pIsapiContext,
            reinterpret_cast<HSE_TF_INFO*>( lpvBuffer )
            );

        break;

    case HSE_REQ_SEND_URL:
    case HSE_REQ_SEND_URL_REDIRECT_RESP:

        hr = SSFSendRedirect(
            pIsapiContext,
            reinterpret_cast<LPSTR>( lpvBuffer )
            );

        break;

    case HSE_REQ_IS_CONNECTED:
        
        hr = SSFIsConnected(
            pIsapiContext,
            reinterpret_cast<BOOL*>( lpvBuffer )
            );

        break;

    case HSE_APPEND_LOG_PARAMETER:

        hr = SSFAppendLog(
            pIsapiContext,
            reinterpret_cast<LPSTR>( lpvBuffer )
            );

        break;
        
    case HSE_REQ_EXEC_URL:
    
        hr = SSFExecuteUrl(
            pIsapiContext,
            lpvBuffer,
            FALSE
            );
        
        break;

    case HSE_REQ_EXEC_UNICODE_URL:

        hr = SSFExecuteUrl(
            pIsapiContext,
            lpvBuffer,
            TRUE
            );

        break;

    case HSE_REQ_GET_EXEC_URL_STATUS:
    
        hr = SSFGetExecuteUrlStatus(
            pIsapiContext,
            reinterpret_cast<HSE_EXEC_URL_STATUS*>( lpvBuffer )
            );
        
        break;

    case HSE_REQ_SEND_CUSTOM_ERROR:
    
        hr = SSFSendCustomError(    
            pIsapiContext,
            reinterpret_cast<HSE_CUSTOM_ERROR_INFO*>( lpvBuffer )
            );
        
        break;

    case HSE_REQ_VECTOR_SEND_DEPRECATED:

        hr = SSFVectorSendDeprecated(
            pIsapiContext,
            reinterpret_cast<HSE_RESPONSE_VECTOR_DEPRECATED*>( lpvBuffer )
            );

        break;

    case HSE_REQ_VECTOR_SEND:

        hr = SSFVectorSend(
            pIsapiContext,
            reinterpret_cast<HSE_RESPONSE_VECTOR*>( lpvBuffer )
            );

        break;

    case HSE_REQ_GET_CUSTOM_ERROR_PAGE:

        hr = SSFGetCustomErrorPage(
            pIsapiContext,
            reinterpret_cast<HSE_CUSTOM_ERROR_PAGE_INFO*>( lpvBuffer )
            );

        break;

    case HSE_REQ_IS_IN_PROCESS:

        hr = SSFIsInProcess(
            pIsapiContext,
            reinterpret_cast<DWORD*>( lpvBuffer )
            );

        break;

    case HSE_REQ_GET_SSPI_INFO:

        hr = SSFGetSspiInfo(
            pIsapiContext,
            reinterpret_cast<CtxtHandle*>( lpvBuffer ),
            reinterpret_cast<CredHandle*>( lpdwDataType )
            );

        break;

    case HSE_REQ_GET_VIRTUAL_PATH_TOKEN:

        hr = SSFGetVirtualPathToken(
            pIsapiContext,
            reinterpret_cast<LPSTR>( lpvBuffer ),
            reinterpret_cast<HANDLE*>( lpdwSize ),
            FALSE
            );

        break;

    case HSE_REQ_GET_UNICODE_VIRTUAL_PATH_TOKEN:

        hr = SSFGetVirtualPathToken(
            pIsapiContext,
            reinterpret_cast<LPSTR>( lpvBuffer ),
            reinterpret_cast<HANDLE*>( lpdwSize ),
            TRUE
            );

        break;

    case HSE_REQ_REPORT_UNHEALTHY:

        hr = SSFReportUnhealthy(
            pIsapiContext,
            reinterpret_cast<LPSTR>( lpvBuffer )
            );

        break;

   case HSE_REQ_NORMALIZE_URL:

        hr = SSFNormalizeUrl(
            reinterpret_cast<LPSTR>( lpvBuffer )
            );

        break;

    case HSE_REQ_ADD_FRAGMENT_TO_CACHE:

        hr = SSFAddFragmentToCache(
            pIsapiContext,
            (HSE_VECTOR_ELEMENT *)lpvBuffer,
            (WCHAR *)lpdwSize
            );
        break;

    case HSE_REQ_READ_FRAGMENT_FROM_CACHE:

        hr = SSFReadFragmentFromCache(
            pIsapiContext,
            (WCHAR *)lpdwDataType,
            (BYTE *)lpvBuffer,
            lpdwSize
            );
        break;

    case HSE_REQ_REMOVE_FRAGMENT_FROM_CACHE:

        hr = SSFRemoveFragmentFromCache(
            pIsapiContext,
            (WCHAR *)lpvBuffer
            );
        break;
        
    case HSE_REQ_GET_METADATA_PROPERTY:
        
        hr = SSFGetMetadataProperty(
            pIsapiContext,
            (DWORD_PTR) lpdwDataType,
            (BYTE*) lpvBuffer,
            lpdwSize
            );
        break;

    case HSE_REQ_CLOSE_CONNECTION:

        hr = SSFCloseConnection(
            pIsapiContext
            );

        break;

            
    //
    // The following are deprecated SSF commands that are not
    // applicable to the new http.sys architecture.
    //
    // While we are not doing anything if an ISAPI uses these,
    // we should not fail the call.
    //

    case HSE_REQ_REFRESH_ISAPI_ACL: // Codework. Probably need this one
    case HSE_REQ_ABORTIVE_CLOSE:

        IF_DEBUG( ISAPI_SSF_DETAILS )
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "\r\n"
                        "  ServerSupportFunction[%p]: Command not implemented in this IIS version\r\n"
                        "  <END>\r\n\r\n",
                        pIsapiContext ));
        }

        hr = NO_ERROR;

        break;

    case HSE_REQ_GET_ANONYMOUS_TOKEN:

        hr = SSFGetAnonymousToken(
            pIsapiContext,
            reinterpret_cast<LPSTR>( lpvBuffer ),
            reinterpret_cast<HANDLE*>( lpdwSize ),
            FALSE
            );

        break;

    case HSE_REQ_GET_UNICODE_ANONYMOUS_TOKEN:

        hr = SSFGetAnonymousToken(
            pIsapiContext,
            reinterpret_cast<LPSTR>( lpvBuffer ),
            reinterpret_cast<HANDLE*>( lpdwSize ),
            TRUE
            );

        break;


    case HSE_REQ_GET_CACHE_INVALIDATION_CALLBACK:

        hr = SSFGetCacheInvalidationCallback(
            pIsapiContext,
            (PFN_HSE_CACHE_INVALIDATION_CALLBACK *)lpvBuffer
            );
        break;

    default:

        hr = HRESULT_FROM_WIN32( ERROR_CALL_NOT_IMPLEMENTED );
    }

    pIsapiContext->IsapiUndoRevertHack( &hCurrentUser );
    pIsapiContext->DereferenceIsapiContext();

    if ( FAILED( hr ) )
    {
        IF_DEBUG( ISAPI_ERROR_RETURNS )
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "\r\n"
                        "  ServerSupportFunction[%p]:  Command failed\r\n"
                        "    Returning FALSE, LastError=0x%08x (%d)\r\n"
                        "  <END>\r\n\r\n",
                        pIsapiContext,
                        hr,
                        WIN32_FROM_HRESULT( hr ) ));
        }

        SetLastError( WIN32_FROM_HRESULT( hr ) );
        return FALSE;
    }

    IF_DEBUG( ISAPI_SERVER_SUPPORT_FUNCTION )
    {
        IF_DEBUG( ISAPI_SUCCESS_RETURNS )
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "\r\n"
                        "  ServerSupportFunction[%p]: Succeeded\r\n"
                        "    Returning TRUE\r\n"
                        "  <END>\r\n\r\n",
                        pIsapiContext ));
        }
    }

    pIsapiContext = NULL;

    return TRUE;
}

VOID
FixupIsapiCoreData(
    ISAPI_CORE_DATA *   pCoreData
    )
{
    //
    // Caution.  This code must be kept in sync
    // with the W3_HANDLER::SerializeCoreDataForOop
    // function in the core server.
    //

    BYTE *  pCursor = (BYTE*)pCoreData;

    pCursor += sizeof(ISAPI_CORE_DATA);

    pCoreData->szGatewayImage = (LPWSTR)pCursor;
    pCursor += pCoreData->cbGatewayImage;

    pCoreData->szApplMdPathW = (LPWSTR)pCursor;
    pCursor += pCoreData->cbApplMdPathW;

    pCoreData->szPathTranslatedW = (LPWSTR)pCursor;
    pCursor += pCoreData->cbPathTranslatedW;

    pCoreData->szPhysicalPath = (LPSTR)pCursor;
    pCursor += pCoreData->cbPhysicalPath;

    pCoreData->szPathInfo = (LPSTR)pCursor;
    pCursor += pCoreData->cbPathInfo;

    pCoreData->szMethod = (LPSTR)pCursor;
    pCursor += pCoreData->cbMethod;

    pCoreData->szQueryString = (LPSTR)pCursor;
    pCursor += pCoreData->cbQueryString;

    pCoreData->szPathTranslated = (LPSTR)pCursor;
    pCursor += pCoreData->cbPathTranslated;

    pCoreData->szContentType = (LPSTR)pCursor;
    pCursor += pCoreData->cbContentType;

    pCoreData->szConnection = (LPSTR)pCursor;
    pCursor += pCoreData->cbConnection;

    pCoreData->szUserAgent = (LPSTR)pCursor;
    pCursor += pCoreData->cbUserAgent;

    pCoreData->szCookie = (LPSTR)pCursor;
    pCursor += pCoreData->cbCookie;

    pCoreData->szApplMdPath = (LPSTR)pCursor;
    pCursor += pCoreData->cbApplMdPath;

    if ( pCoreData->cbAvailableEntity )
    {
        pCoreData->pAvailableEntity = pCursor;
    }
    else
    {
        pCoreData->pAvailableEntity = NULL;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\iisplus\w3isapi\dll_manager.h ===
/*++

   Copyright    (c)    2000-2001    Microsoft Corporation

   Module Name :
     dll_manager.h

   Abstract:
     IIS Plus ISAPI Handler. Dll management classes.
 
   Author:
     Taylor Weiss (TaylorW)             03-Feb-2000
     Wade A. Hilmo (WadeH)              08-Mar-2001

   Project:
     w3isapi.dll

--*/

#ifndef _DLL_MANAGER_H_
#define _DLL_MANAGER_H_

#define ISAPI_DLL_SIGNATURE         (DWORD)'LDSI'
#define ISAPI_DLL_SIGNATURE_FREE    (DWORD)'fDSI'

/************************************************************
 *  Include Headers
 ************************************************************/

#include <lkrhash.h>
#include <reftrace.h>
#include <acache.hxx>

/************************************************************
 *  Declarations
 ************************************************************/

/*++

class ISAPI_DLL

    Encapsulate an ISAPI dll.

--*/

class ISAPI_DLL
{
    friend class ISAPI_DLL_MANAGER;

public:

    //
    // ACACHE and ref tracing goo
    //

    VOID * 
    operator new( 
        size_t            size
    )
    {
        //
        // Make warning level 4 happy and touch
        // the size argument in both free and checked
        // builds...
        //

        if ( size != sizeof( ISAPI_DLL ) )
        {
            DBG_ASSERT( size == sizeof( ISAPI_DLL ) );
        }

        DBG_ASSERT( sm_pachIsapiDlls != NULL );
        return sm_pachIsapiDlls->Alloc();
    }
    
    VOID
    operator delete(
        VOID *              pIsapiDll
    )
    {
        DBG_ASSERT( pIsapiDll != NULL );
        DBG_ASSERT( sm_pachIsapiDlls != NULL );
        
        DBG_REQUIRE( sm_pachIsapiDlls->Free( pIsapiDll ) );
    }

    BOOL
    CheckSignature()
    {
        return ( m_Signature == ISAPI_DLL_SIGNATURE );
    }
    
    static
    HRESULT
    Initialize(
        VOID
    );
    
    static
    VOID
    Terminate(
        VOID
    );

    //
    // Construction and destruction
    //

    ISAPI_DLL()
        : m_nRefs(1),
          m_pfnGetExtensionVersion( NULL ),
          m_pfnTerminateExtension( NULL ),
          m_pfnHttpExtensionProc( NULL ),
          m_hModule( NULL ),
          m_pFastSid( NULL ),
          m_fIsLoaded( FALSE ),
          m_Signature( ISAPI_DLL_SIGNATURE )
    {
        IF_DEBUG( DLL_MANAGER )
        {
            DBGPRINTF((
                DBG_CONTEXT,
                "Created new ISAPI_DLL %p.\r\n",
                this
                ));
        }

        INITIALIZE_CRITICAL_SECTION( &m_csLock );
    }

    VOID
    ReferenceIsapiDll(
        VOID
        )
    {
        LONG nRefs;

        //
        // Don't go from 0 to 1 refs
        //

        DBG_ASSERT( m_nRefs != 0 );

        nRefs = InterlockedIncrement( &m_nRefs );

        if ( sm_pTraceLog != NULL )
        {
            WriteRefTraceLog( sm_pTraceLog, 
                              nRefs,
                              this );
        }
    }

    VOID
    DereferenceIsapiDll(
        VOID
        )
    {
        LONG    nRefs;

        nRefs = InterlockedDecrement( &m_nRefs );

        if ( sm_pTraceLog != NULL )
        {
            WriteRefTraceLog( sm_pTraceLog, 
                              nRefs,
                              this );
        }

        if ( nRefs == 0 )
        {
            delete this;
        }
    }

    HRESULT
    SetName(
        const WCHAR *szModuleName,
        HANDLE      hImpersonation
        );

    HRESULT
    Load(
        IN HANDLE hImpersonation,
        IN PSID pSid
        );

    HRESULT
    SetFastSid(
        IN PSID pSid
    );

    PSID
    QueryFastSid(
        VOID
    ) const
    {
        return m_pFastSid;
    }

    //
    // Accessors
    //

    const WCHAR * 
    QueryModuleName( VOID ) const
    { 
        return m_strModuleName.QueryStr();
    }

    PFN_GETEXTENSIONVERSION
    QueryGetExtensionVersion( VOID ) const
    {
        return m_pfnGetExtensionVersion;
    }

    PFN_TERMINATEEXTENSION
    QueryTerminateExtension( VOID ) const
    {
        return m_pfnTerminateExtension;
    }

    PFN_HTTPEXTENSIONPROC
    QueryHttpExtensionProc( VOID ) const
    {
        return m_pfnHttpExtensionProc;
    }

    BOOL
    IsMatch(
        IN const WCHAR *    szModuleName
    )
    {
        return (_wcsicmp( szModuleName, m_strModuleName.QueryStr() ) == 0);
    }

    PSECURITY_DESCRIPTOR
    QuerySecDesc( VOID ) const
    {
        return (PSECURITY_DESCRIPTOR) m_buffSD.QueryPtr(); 
    }

    BOOL
    AccessCheck(
        IN HANDLE hImpersonation,
        IN PSID   pSid
        );

private:
    
    //
    // Avoid c++ errors
    //

    ISAPI_DLL( const ISAPI_DLL & ) {}
    ISAPI_DLL & operator = ( const ISAPI_DLL & ) { return *this; }

    ~ISAPI_DLL()
    {
        DBG_ASSERT( CheckSignature() );
        m_Signature = ISAPI_DLL_SIGNATURE_FREE;

        //
        // If this gets moved then we need to alter
        // cleanup paths during load.
        //

        Unload();

        DeleteCriticalSection( &m_csLock );

        IF_DEBUG( DLL_MANAGER )
        {
            DBGPRINTF((
                DBG_CONTEXT,
                "Deleted ISAPI_DLL %p.\r\n",
                this
                ));
        }
    }

    VOID
    Unload( VOID );

    DWORD    m_Signature;
    LONG     m_nRefs;
    STRU     m_strModuleName;
    STRU     m_strAntiCanonModuleName;

    CRITICAL_SECTION m_csLock;

    volatile BOOL    m_fIsLoaded;

    static PTRACE_LOG               sm_pTraceLog;
    static ALLOC_CACHE_HANDLER *    sm_pachIsapiDlls;

    //
    // ISAPI Entry Points
    //
    PFN_GETEXTENSIONVERSION     m_pfnGetExtensionVersion;
    PFN_TERMINATEEXTENSION      m_pfnTerminateExtension;
    PFN_HTTPEXTENSIONPROC       m_pfnHttpExtensionProc;    

    //
    // Security members
    //
    HMODULE         m_hModule;
    BUFFER          m_buffSD;

    //
    // Fast check sid (the SID of the user which originally accessed DLL)
    //

    PSID            m_pFastSid;
    BYTE            m_abFastSid[ 64 ];

    HRESULT LoadAcl( STRU &strModuleName );

    VOID
    Lock( VOID )
    {
        EnterCriticalSection( &m_csLock );
    }

    VOID
    Unlock( VOID )
    {
        LeaveCriticalSection( &m_csLock );
    }
};

//
// Hash Table for ISAPI extension lookup
//

class ISAPI_DLL_HASH
    : public CTypedHashTable<
            ISAPI_DLL_HASH,
            ISAPI_DLL,
            LPCWSTR
            >
{
public:
    ISAPI_DLL_HASH()
        : CTypedHashTable< ISAPI_DLL_HASH, 
                           ISAPI_DLL, 
                           LPCWSTR > ( "ISAPI_DLL_HASH" )
    {
    }
    
    static 
    LPCWSTR
    ExtractKey(
        const ISAPI_DLL *      pEntry
    )
    {
        return pEntry->QueryModuleName();
    }
    
    static
    DWORD
    CalcKeyHash(
        LPCWSTR              pszKey
    )
    {
        int cchKey = (int)wcslen(pszKey);

        return HashStringNoCase(pszKey, cchKey);
    }
     
    static
    bool
    EqualKeys(
        LPCWSTR               pszKey1,
        LPCWSTR               pszKey2
    )
    {
        return _wcsicmp( pszKey1, pszKey2 ) == 0;
    }
    
    static
    void
    AddRefRecord(
        ISAPI_DLL * pEntry,
        int         nIncr
        )
    {
        if ( nIncr == +1 )
        {
            pEntry->ReferenceIsapiDll();
        }
        else if ( nIncr == - 1)
        {
            pEntry->DereferenceIsapiDll();
        }
    }

private:
    
    //
    // Avoid c++ errors
    //

    ISAPI_DLL_HASH( const ISAPI_DLL_HASH & )
        : CTypedHashTable< ISAPI_DLL_HASH, 
                           ISAPI_DLL, 
                           LPCWSTR > ( "ISAPI_DLL_HASH" )
    {
    }

    ISAPI_DLL_HASH & operator = ( const ISAPI_DLL_HASH & ) { return *this; }
};

class ISAPI_DLL_MANAGER
{
public:

    ISAPI_DLL_MANAGER( BOOL fInproc )
    {
        m_fInproc = fInproc;
    }

    ~ISAPI_DLL_MANAGER()
    {
    }

    HRESULT
    GetIsapi( 
        IN const WCHAR *   szModuleName,
        OUT ISAPI_DLL **   ppIsapiDll,
        IN HANDLE          hImpersonation,
        IN PSID            pSid
        );

    BOOL
    IsInproc()
    {
        return m_fInproc;
    }

private:
    
    //
    // Avoid c++ errors
    //
    ISAPI_DLL_MANAGER( const ISAPI_DLL_MANAGER & ) {}
    ISAPI_DLL_MANAGER & operator = ( const ISAPI_DLL_MANAGER & ) { return *this; }

    ISAPI_DLL_HASH      m_IsapiHash;
    BOOL                m_fInproc;
};

extern ISAPI_DLL_MANAGER * g_pDllManager;

#endif // _DLL_MANAGER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\iisplus\w3dirmon\dirmon.cxx ===
/*++

   Copyright    (c)    1995-1996    Microsoft Corporation

   Module  Name :

       dirmon.cxx

   Abstract:
       This module includes definitions of functions and variables
        for CDirMonitor and CDirMonitorEntry object

   Author:

       Charles Grant       ( cgrant   )     April-1997

   Revision History:

--*/


/************************************************************
 *     Include Headers
 ************************************************************/

#include <iis.h>
#include "dbgutil.h"
#include "dirmon.h"

//
// CDirMonitorEntry
//

#define DEFAULT_BUFFER_SIZE 512

VOID
WINAPI
DirMonOverlappedCompletionRoutine(
    DWORD dwErrorCode,
    DWORD dwNumberOfBytesTransfered,
    LPOVERLAPPED lpOverlapped
)
{
    CDirMonitor::OverlappedCompletionRoutine( dwErrorCode,
                                              dwNumberOfBytesTransfered,
                                              lpOverlapped );
}

VOID
CDirMonitor::OverlappedCompletionRoutine(
    DWORD dwErrorCode,
    DWORD dwNumberOfBytesTransfered,
    LPOVERLAPPED lpOverlapped
)
{
    PVOID               pvContext;

    pvContext = CONTAINING_RECORD( lpOverlapped,
                                   CDirMonitorEntry,
                                   m_ovr );

    DBG_ASSERT( pvContext != NULL );

    CDirMonitor::DirMonitorCompletionFunction( pvContext,
                                               dwNumberOfBytesTransfered,
                                               dwErrorCode,
                                               lpOverlapped );
}

CDirMonitorEntry::CDirMonitorEntry() :
                    m_cDirRefCount(0),
                    m_cIORefCount(0),
                    m_hDir(INVALID_HANDLE_VALUE),
                    m_dwNotificationFlags(0),
                    m_pszPath(NULL),
                    m_cPathLength(0),
                    m_pDirMonitor(NULL),
                    m_cBufferSize(0),
                    m_pbBuffer(NULL),
                    m_fInCleanup(FALSE),
                    m_fWatchSubdirectories(FALSE)
/*++

Routine Description:

    CDirMonitorEntry constructor

Arguments:

    None

Return Value:

    Nothing

--*/
{
}


CDirMonitorEntry::~CDirMonitorEntry(
    VOID
    )
/*++

Routine Description:

    CDirMonitorEntry destructor

Arguments:

    None

Return Value:

    Nothing

--*/
{
    HANDLE              hDir;

    IF_DEBUG( DIRMON )
    {
        DBGPRINTF((DBG_CONTEXT, "[CDirMonitorEntry] Destructor\n"));
    }

    // We should only be destroyed when
    // our ref counts have gone to 0

    DBG_ASSERT(m_cDirRefCount == 0);
    DBG_ASSERT(m_cIORefCount == 0);

    //
    // We really ought to have closed the handle by now
    //
    if (m_hDir != INVALID_HANDLE_VALUE) {

        DBGPRINTF(( DBG_CONTEXT, "~CDirMonitorEntry: open handle %p\n",
                    m_hDir ));

        hDir = m_hDir;

        m_hDir = INVALID_HANDLE_VALUE;

        CloseHandle( hDir );
    }

    if (m_pDirMonitor != NULL)
    {
        m_pDirMonitor->RemoveEntry(this);
        m_pDirMonitor = NULL;
    }

    m_cPathLength = 0;

    if ( m_pszPath != NULL )
    {
        LocalFree( m_pszPath );
        m_pszPath = NULL;
    }

    if (m_pbBuffer != NULL)
    {
        LocalFree(m_pbBuffer);
        m_cBufferSize = 0;
    }
}

BOOL
CDirMonitorEntry::Init(
    DWORD cBufferSize = DEFAULT_BUFFER_SIZE
)
/*++

Routine Description:

    Initialize the dir montior entry.

Arguments:

    cBufferSize  - Initial size of buffer used to store change notifications

Return Value:

    TRUE if success, otherwise FALSE

--*/
{
    // Don't allow a 0 length buffer
    if (cBufferSize == 0)
    {
         return FALSE;
    }

    DBG_ASSERT( m_pbBuffer == NULL );

    m_pbBuffer = (BYTE *) LocalAlloc( LPTR, cBufferSize );

    if (m_pbBuffer != NULL)
    {
        m_cBufferSize = cBufferSize;
        return TRUE;
    }
    else
    {
        // Unable to allocate buffer
        return FALSE;
    }
}

BOOL
CDirMonitorEntry::RequestNotification(
    VOID
)
/*++

Routine Description:

    Request ATQ to monitor directory changes for the directory handle
    associated with this entry

Arguments:

    None

Return Value:

    TRUE if success, otherwise FALSE

--*/
{
    BOOL        fResult = FALSE;
    DWORD       cbRead = 0;

    IF_DEBUG( DIRMON )
    {
        DBGPRINTF((DBG_CONTEXT, "[CDirMonitorEntry] Request change notification\n"));
    }


    DBG_ASSERT(m_pDirMonitor);

    // Reset the overlapped io structure

    memset(&m_ovr, 0, sizeof(m_ovr));

    // Increase the ref count in advance

    IOAddRef();

    // Request notification of directory changes

    fResult = ReadDirectoryChangesW( m_hDir,
                                     m_pbBuffer,
                                     m_cBufferSize,
                                     m_fWatchSubdirectories,
                                     m_dwNotificationFlags,
                                     &cbRead,
                                     &m_ovr,
                                     NULL );

    if (!fResult)
    {
        // ReadDirChanges failed so
        // release the ref count we did in advance
        // Might cause IO ref count to go to 0

        IORelease();
    }

    return fResult;

}

BOOL
CDirMonitorEntry::Cleanup(
    VOID
    )
/*++

Routine Description:

    Cleans up resource and determines if the caller need to delete
    the Directory Monitor Entry instance.

Arguments:

    None

Return Value:

    TRUE if the caller is responsible for deleting the object
    This will be the case if there are no pending Asynch IO requests

--*/
{
    BOOL            fDeleteNeeded = FALSE;
    BOOL            fHandleClosed = FALSE;
    HANDLE          hDir = INVALID_HANDLE_VALUE;

    DBG_ASSERT(m_cDirRefCount == 0);

    BOOL fInCleanup = (BOOL) InterlockedExchange((long *) &m_fInCleanup, TRUE);
    if ( fInCleanup )
    {
        DBG_ASSERT(FALSE);
        return FALSE;
    }

    // Get the IO ref count BEFORE we close the handle

    DWORD cIORefCount = m_cIORefCount;

    if (m_hDir != INVALID_HANDLE_VALUE)
    {
        // If we have a pending AtqReadDirectoryChanges,
        // closing the directory handle will cause a call back from ATQ.
        // The call back should relase the final refcount on the object
        // which should result in its deletion

        hDir = m_hDir;

        m_hDir = INVALID_HANDLE_VALUE;

        fHandleClosed = CloseHandle( hDir );
    }

    // If there were no pending Asynch IO operations or if we failed
    // to close the handle, then the caller will be responsible for
    // deleting this object.

    if (cIORefCount == 0 || fHandleClosed == FALSE)
    {
        fDeleteNeeded = TRUE;
    }

    return fDeleteNeeded;
}

BOOL
CDirMonitorEntry::ResetDirectoryHandle(
    VOID
    )
/*++

Routine Description:

    Opens a new directory handle for the path,
    and closes the old ones. We want to be able to do this so we
    can change the size of the buffer passed in ReadDirectoryChangesW.

Arguments:

    None

Return Value:

    TRUE if the handles were succesfully reopened
    FALSE otherwise

--*/
{
    // BUGBUG - Beta2 HACK

    return FALSE;
/*
    // We'd better have a directory path available to try this

    if (m_pszPath == NULL)
    {
        return FALSE;
    }

    // Get a new handle to the directory

    HANDLE hDir = CreateFileW( m_pszPath,
                               FILE_LIST_DIRECTORY,
                                    FILE_SHARE_READ |
                                    FILE_SHARE_WRITE |
                                    FILE_SHARE_DELETE,
                               NULL,
                               OPEN_EXISTING,
                               FILE_FLAG_BACKUP_SEMANTICS |
                                    FILE_FLAG_OVERLAPPED,
                               NULL );

    if ( hDir == INVALID_HANDLE_VALUE )
    {
        // We couldn't open another handle on the directory,
        // leave the current handle and ATQ context alone

        return FALSE;
    }

    //
    // Associate handle with thread pool's completion port
    //

    if ( !ThreadPoolBindIoCompletionCallback( hDir,
                                              DirMonOverlappedCompletionRoutine,
                                              0 ) )
    {
        // We couldn't get a new ATQ context. Close our new handle.
        // We leave the objects current handle and ATQ context alone
        CloseHandle(hDir);
        return FALSE;
    }

    // We have the new handle and ATQ context so we close
    // and replace the old ones.


    if ( m_hDir != INVALID_HANDLE_VALUE )
    {
        CloseHandle( m_hDir );
    }

    m_hDir = hDir;

    return TRUE;
*/
}

BOOL
CDirMonitorEntry::SetBufferSize(
    DWORD cBufferSize
    )
/*++

Routine Description:

    Sets the size of the buffer used for storing change notification records

Arguments:

    cBufferSize         new size for the buffer.

Return Value:

    TRUE        if the size of the buffer was succesfully set
    FALSE       otherwise

Note

    When a call to ReadDirectoryChangesW is made, the size of the buffer is set in
    the data associated with the directory handle and is not changed on subsequent
    calls to ReadDirectoryChangesW. To make use of the new buffer size the directory
    handle must be closed and a new handle opened (see ResetDirectoryHandle())

--*/
{
    // We should never be called if the buffer doesn't already exist

    DBG_ASSERT(m_pbBuffer);

    // Don't allow the buffer to be set to 0

    if (cBufferSize == 0)
    {
        return FALSE;
    }

    VOID *pbBuffer = LocalReAlloc( m_pbBuffer,
                                   cBufferSize,
                                   LMEM_MOVEABLE );

    if (pbBuffer == NULL)
    {
        // Re-allocation failed, stuck with the same size buffer

        return FALSE;
    }
    else
    {
        // Re-allocation succeded, update the member variables

        m_pbBuffer = (BYTE *) pbBuffer;
        m_cBufferSize = cBufferSize;
        return TRUE;
    }
}

//
// CDirMonitor
//

CDirMonitor::CDirMonitor()
    : CTypedHashTable<CDirMonitor, CDirMonitorEntry, const WCHAR*>("DirMon")
/*++

Routine Description:

    CDirMonitor constructor

Arguments:

    None

Return Value:

    Nothing

--*/
{
    ThreadPoolInitialize( 0 ); // Use the process default stack size
    INITIALIZE_CRITICAL_SECTION( &m_csSerialComplLock );
    m_cRefs = 1;
    m_fShutdown = FALSE;
}


CDirMonitor::~CDirMonitor()
/*++

Routine Description:

    CDirMonitor destructor

Arguments:

    None

Return Value:

    Nothing

--*/
{
    DeleteCriticalSection(&m_csSerialComplLock);
    ThreadPoolTerminate();
}

BOOL
CDirMonitor::Monitor(
    CDirMonitorEntry *                  pDME,
    LPWSTR                              pszDirectory,
    BOOL                                fWatchSubDirectories,
    DWORD                               dwNotificationFlags
    )
/*++

Routine Description:

    Create a monitor entry for the specified path

Arguments:

    pszDirectory - directory to monitor
    pCtxt - Context of path is being monitored
    pszDirectory - name of directory to monitor
    fWatchSubDirectories - whether to get notifications for subdirectories
    dwNotificationFlags - which activities to be notified of

Return Value:

    TRUE if success, otherwise FALSE

Remarks:

    Caller should have a lock on the CDirMonitor
    Not compatible with WIN95

--*/
{
    HANDLE      hDirectoryFile = INVALID_HANDLE_VALUE;
    LK_RETCODE  lkrc;

    IF_DEBUG( DIRMON )
    {
        DBGPRINTF((DBG_CONTEXT, "[CDirMonitor] Monitoring new CDirMonitorEntry\n"));
    }

    // Must have a directory monitor entry and a string
    // containing the directory path

    if (!pDME || !pszDirectory)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    // Make copy of pszDirectory for the entry to hang on to


    pDME->m_cPathLength = (DWORD) wcslen(pszDirectory);
    pDME->m_pszPath = (LPWSTR)LocalAlloc( LPTR,
                                          ( pDME->m_cPathLength + 1 ) * sizeof( WCHAR ) ); 
    if (pDME->m_pszPath==NULL)
    {
        pDME->m_cPathLength = 0;
        return FALSE;
    }
    memcpy( pDME->m_pszPath,
            pszDirectory,
            ( pDME->m_cPathLength + 1 ) * sizeof( WCHAR ) );

    pDME->Init();

    // Open the directory handle

    hDirectoryFile = CreateFileW(
                           pszDirectory,
                           FILE_LIST_DIRECTORY,
                                FILE_SHARE_READ |
                                FILE_SHARE_WRITE |
                                FILE_SHARE_DELETE,
                           NULL,
                           OPEN_EXISTING,
                           FILE_FLAG_BACKUP_SEMANTICS |
                                FILE_FLAG_OVERLAPPED,
                           NULL );

    if ( hDirectoryFile == INVALID_HANDLE_VALUE )
    {
        // Cleanup
        LocalFree(pDME->m_pszPath);
        pDME->m_pszPath = NULL;
        pDME->m_cPathLength = 0;
        return FALSE;
    }
    else
    {
        // Store the handle so we can close it on cleanup

        pDME->m_hDir = hDirectoryFile;

        // Set the flags for the type of notifications we want
        // and if we should watch subdirectories or just the root

        pDME->m_dwNotificationFlags = dwNotificationFlags;
        pDME->m_fWatchSubdirectories = fWatchSubDirectories;

        // Get an ATQ context for this handle
        // and register our completion call back function

        if ( ThreadPoolBindIoCompletionCallback(
                                        hDirectoryFile,
                                        DirMonOverlappedCompletionRoutine,
                                        0 ) )
        {
            // Insert this entry into the list of active entries

            lkrc = InsertEntry(pDME);
            if (lkrc == LK_SUCCESS)
            {

                // Ask for notification if this directory has changes

                if (!pDME->RequestNotification())
                {
                    // Couldn't register for change notification
                    // Clean up resources
                    RemoveEntry(pDME);

                    pDME->m_hDir = INVALID_HANDLE_VALUE;

                    CloseHandle( hDirectoryFile );

                    LocalFree(pDME->m_pszPath);
                    pDME->m_pszPath = NULL;
                    pDME->m_cPathLength = 0;
                    return FALSE;
                }
            }
            else
            {
                //
                // Could not add to hash table.  Cleanup
                //

                CloseHandle(hDirectoryFile);
                pDME->m_hDir = INVALID_HANDLE_VALUE;
                LocalFree(pDME->m_pszPath);
                pDME->m_pszPath = NULL;
                pDME->m_cPathLength = 0;

                //
                // If it has been added from underneath us, indicate so
                //

                if ( lkrc == LK_KEY_EXISTS )
                {
                    SetLastError( ERROR_ALREADY_EXISTS );
                }

                return FALSE;
            }
        }
        else
        {

            // Failed to add handle to ATQ, clean up

            CloseHandle(hDirectoryFile);
            pDME->m_hDir = INVALID_HANDLE_VALUE;
            LocalFree(pDME->m_pszPath);
            pDME->m_pszPath = NULL;
            pDME->m_cPathLength = 0;
            return FALSE;
        }

    }

    return TRUE;
}

VOID
CDirMonitor::DirMonitorCompletionFunction(
    PVOID                       pCtxt,
    DWORD                       dwBytesWritten,
    DWORD                       dwCompletionStatus,
    OVERLAPPED *               
    )
/*++

Routine Description:

Static member function called by ATQ to signal directory changes

Arguments:

    pCtxt - CDirMonitorEntry*
    dwBytesWritten - # bytes returned by ReadDirectoryChanges
    dwCompletionStatus - status of request to ReadDirectoryChanges
    pOvr - OVERLAPPED as specified in call to ReadDirectoryChanges

Return Value:

    Nothing

--*/
{
    IF_DEBUG( DIRMON )
    {
        DBGPRINTF((DBG_CONTEXT, "[CDirMonitor] Notification call-back begining. Status %d\n", dwCompletionStatus));
    }

    CDirMonitorEntry*  pDirMonitorEntry = reinterpret_cast<CDirMonitorEntry*>(pCtxt);

    DBG_ASSERT(pDirMonitorEntry);

    // Safety add ref, this should guarentee that the DME is not deleted
    // while we are still processing the callback

    pDirMonitorEntry->IOAddRef();

    // Release for the current Asynch operation
    // Should not send IO ref count to 0

    DBG_REQUIRE(pDirMonitorEntry->IORelease());

    BOOL fRequestNotification = FALSE;

    // There has been a change in the directory we were monitoring
    // carry out whatever work we need to do.

    if (!pDirMonitorEntry->m_fInCleanup)
    {
        pDirMonitorEntry->m_pDirMonitor->SerialComplLock();
        // BUGBUG Under stress ActOnNotification has been initiating a chain
        // of events leading to an AV. For Beta 3 we think we can ignore
        // these AV. For the final product we need to rework the critical
        // sections for the template manager and
        // the include file table.

        __try
        {
            fRequestNotification = pDirMonitorEntry->ActOnNotification(dwCompletionStatus, dwBytesWritten);
        }
        __except( EXCEPTION_EXECUTE_HANDLER )
        {
            // We should never get here
            DBG_ASSERT(FALSE);
        }

        // If ActOnNotification returned TRUE, then make another Asynch
        // notification request.

        if (fRequestNotification)
        {
            fRequestNotification = pDirMonitorEntry->RequestNotification();
        }

        pDirMonitorEntry->m_pDirMonitor->SerialComplUnlock();
    }

    // Remove safety ref count, may cause IO ref count to go to 0

    pDirMonitorEntry->IORelease();

    IF_DEBUG( DIRMON )
    {
        DBGPRINTF((DBG_CONTEXT, "[CDirMonitor] Notification call-back ending\n"));
    }
}


CDirMonitorEntry *
CDirMonitor::FindEntry(
    LPWSTR                  pszPath
    )
/*++

Routine Description:

    Searches the list of entries for the specified path

Arguments:

    pszPath - file path, including file name

Return Value:

    pointer to the entry, allready addref'd

--*/
{
    DBG_ASSERT(pszPath);

    CDirMonitorEntry *pDME = NULL;

    //
    // Lock to prevent aga finding an entry that could be deleted by someone
    //
    ReadLock();

    FindKey(pszPath, &pDME);

    if (pDME != NULL)
    {
        if (pDME->m_fInCleanup)
        {
            // Don't hand back a DME that is being shutdown
            pDME = NULL;
        }
        else
        {
            // We found a valid DME which we are going to hand to the caller
            pDME->AddRef();
        }
    }

    ReadUnlock();

    return pDME;
}

LK_RETCODE
CDirMonitor::InsertEntry(
    CDirMonitorEntry *pDME
    )
/*++

Routine Description:

    Insert an entry into the list of entries for the monitor

Arguments:

    pDME - entry to insert

Return Value:

    LK returncode

--*/
{
    DBG_ASSERT(pDME);
    LK_RETCODE  lkResult;

    //
    // If we're cleaning up the table, don't let anyone else add stuff to
    // it
    //

    if ( m_fShutdown )
    {
        return LK_NOT_INITIALIZED;
    }

    pDME->m_pDirMonitor = this;

    lkResult = InsertRecord(pDME, false);

    if (lkResult == LK_SUCCESS)
    {
        DBGPRINTF((DBG_CONTEXT, "[CDirMonitor] Inserting directory (DME %08x) %ws\n", pDME, pDME->m_pszPath));

        AddRef();
    }
    else
    {
        pDME->m_pDirMonitor = NULL;
    }

    return lkResult;
}

LK_RETCODE
CDirMonitor::RemoveEntry(
    CDirMonitorEntry *pDME
    )
/*++

Routine Description:

    Deletes an entry from the list of entries for the monitor

Arguments:

    pDME - entry to delete

Return Value:

    None

--*/
{
    DBG_ASSERT(pDME);

    //
    // Delete the entry from the hash table
    //

    LK_RETCODE lkResult = DeleteRecord(pDME);
    pDME->m_pDirMonitor = NULL;

    DBGPRINTF((DBG_CONTEXT, "[CDirMonitor] Removed DME(%08x), directory %ws\n", pDME, pDME->m_pszPath));

    //
    // Release the DME's reference on the DirMonitor object.
    //
    // It seems obvious, but we must have the Release() occur AFTER the
    // removal of the hash-table entry.  This is because the loop check
    // in CDirMonitor::Cleanup() can complete while DeleteKey() is still
    // doing stuff to the table.  I mention this since DirMon cleanup is an
    // often-butchered code path.
    //

    Release();

    return lkResult;
}

VOID
CDirMonitor::Cleanup(
    VOID
    )
/*++

Routine Description:

    Pauses while all entries are cleaned up

Arguments:

    None

Return Value:

    None

--*/
{
    //
    // Don't let anyone else try to insert into the hashtable
    //

    m_fShutdown = TRUE;

    //
    // Sleep until the hash table is empty and all contained
    // CDirMonitorEntry's are destroyed
    //

    while (Size() > 0 || m_cRefs != 1)
    {
        //
        // At least one DME is still active, sleep and try again
        //

        Sleep(200);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\iisplus\w3isapi\server_support.cxx ===
/*++

   Copyright    (c)    1999-2001    Microsoft Corporation

   Module Name :
     server_support.cxx

   Abstract:
     IIS Plus ServerSupportFunction command implementations
 
   Author:
     Wade Hilmo (wadeh)             05-Apr-2000

   Project:
     w3isapi.dll

--*/

#include "precomp.hxx"
#include "isapi_context.hxx"
#include "server_support.hxx"

//
// BUGBUG - stristr is declared in iisrearc\core\inc\irtlmisc.h,
// but doesn't appear to be implemented anywhere.  Because of the
// way it's declared in that file, we have to use a different
// function name here...
//

const char*
stristr2(
    const char* pszString,
    const char* pszSubString
    );

HRESULT
SSFSendResponseHeader(
    ISAPI_CONTEXT * pIsapiContext,
    LPSTR           szStatus,
    LPSTR           szHeaders
    )
/*++

Routine Description:

    Sends HTTP status and headers to the client.

Arguments:

    pIsapiContext - The ISAPI_CONTEXT associated with this command.
    szStatus - The status to send to the client (ie. "200 OK")
    szHeaders - Headers to send to the client (ie. foo1: value1\r\n\r\n")
    
Return Value:

    HRESULT

--*/
{
    IIsapiCore *    pIsapiCore;
    HRESULT         hr;

    DBG_ASSERT( pIsapiContext );
    DBG_ASSERT( pIsapiContext->CheckSignature() );

    IF_DEBUG( ISAPI_SSF_DETAILS )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "\r\n"
                    "  HSE_REQ_SEND_RESPONSE_HEADER[%p]: Function Entry\r\n"
                    "    Status: '%s'\r\n"
                    "    Headers: '%s'\r\n"
                    "  <END>\r\n\r\n",
                    pIsapiContext,
                    szStatus,
                    szHeaders ));
    }

    pIsapiCore = pIsapiContext->QueryIsapiCoreInterface();

    if ( pIsapiCore == NULL )
    {
        IF_DEBUG( ISAPI_ERROR_RETURNS )
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "\r\n"
                        "  HSE_REQ_SEND_RESPONSE_HEADER[%p]: Failed to get interface to server core\r\n"
                        "  <END>\r\n\r\n",
                        pIsapiContext ));
        }

        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }

    //
    // We need validate the fKeepConn status for the request now,
    // since http.sys will generate the connection response
    // header based on it.
    //
    // If we're going to support keep-alive, then the
    // ISAPI must return either a content-length header,
    // or use chunked transfer encoding.  We'll check for
    // that here.
    //

    if ( pIsapiContext->QueryClientKeepConn() )
    {
        if ( szHeaders != NULL &&
             ( stristr2( szHeaders, "content-length: " ) != NULL ||
               stristr2( szHeaders, "transfer-encoding: chunked" ) != NULL ) )
        {
            pIsapiContext->SetKeepConn( TRUE );
        }
    }

    //
    // Since we automatically decided to keep the connection alive
    // or not, we should not honor HSE_STATUS_SUCCESS_AND_KEEP_CONN.
    // This maintains compatibility with previous IIS versions.
    //

    pIsapiContext->SetHonorAndKeepConn( FALSE );

    //
    // Note that NULL is valid for both szStatus and szHeaders,
    // so there's no need to validate them.
    //

    hr = pIsapiCore->SendResponseHeaders(
        !pIsapiContext->QueryKeepConn(),
        szStatus,
        szHeaders,
        HSE_IO_SYNC
        );

    if ( FAILED( hr ) )
    {
        IF_DEBUG( ISAPI_ERROR_RETURNS )
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "\r\n"
                        "  HSE_REQ_SEND_RESPONSE_HEADER[%p]: Failed\r\n"
                        "    Error: 0x%08x\r\n"
                        "  <END>\r\n\r\n",
                        pIsapiContext,
                        hr ));
        }

        return hr;
    }
    else
    {
        pIsapiContext->SetHeadersSent( TRUE );
    }


    IF_DEBUG( ISAPI_SSF_DETAILS )
    {
        IF_DEBUG( ISAPI_SUCCESS_RETURNS )
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "\r\n"
                        "  HSE_REQ_SEND_RESPONSE_HEADER[%p]: Succeeded\r\n"
                        "  <END>\r\n\r\n",
                        pIsapiContext ));
        }
    }

    return hr;
}

HRESULT
SSFSendResponseHeaderEx(
    ISAPI_CONTEXT *             pIsapiContext,
    HSE_SEND_HEADER_EX_INFO *   pHeaderInfo
    )
/*++

Routine Description:

    Sends HTTP status and headers to the client, and offers
    explicit control over keep-alive for this request.

Arguments:

    pIsapiContext - The ISAPI_CONTEXT associated with this command.
    pHeaderInfo   - The response info to be passed to the client
    
Return Value:

    HRESULT

--*/
{
    IIsapiCore *    pIsapiCore;
    HRESULT         hr;

    DBG_ASSERT( pIsapiContext );
    DBG_ASSERT( pIsapiContext->CheckSignature() );

    IF_DEBUG( ISAPI_SSF_DETAILS )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "\r\n"
                    "  HSE_REQ_SEND_RESPONSE_HEADER_EX[%p]: Function Entry\r\n"
                    "    Status: '%s'\r\n"
                    "    Headers: '%s'\r\n"
                    "    KeepConn: %d\r\n",
                    pIsapiContext,
                    pHeaderInfo->pszStatus,
                    pHeaderInfo->pszHeader,
                    pHeaderInfo->fKeepConn ));
    }

    pIsapiCore = pIsapiContext->QueryIsapiCoreInterface();

    if ( pIsapiCore == NULL )
    {
        IF_DEBUG( ISAPI_ERROR_RETURNS )
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "\r\n"
                        "  HSE_REQ_SEND_RESPONSE_HEADER_EX[%p]: Failed to get interface to server core\r\n"
                        "  <END>\r\n\r\n",
                        pIsapiContext ));
        }

        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }

    //
    // Validate parameters
    //

    if ( pHeaderInfo == NULL )
    {
        IF_DEBUG( ISAPI_ERROR_RETURNS )
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "\r\n"
                        "  HSE_REQ_SEND_RESPONSE_HEADER_EX[%p]: Parameter validation failure\r\n"
                        "    pHeaderInfo: NULL\r\n"
                        "  <END>\r\n\r\n",
                        pIsapiContext ));
        }

        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }

    //
    // Set the keep connection flag.  It can only be TRUE if the
    // ISAPI and the client both want keep alive.
    //
    // Note that we are trusting the ISAPI to provide some kind
    // of content length in the case where it's setting fKeepConn
    // to TRUE.  This is the same behavior as IIS 5 which, for
    // performance reasons, doesn't try to parse the headers from
    // the ISAPI.
    //

    if ( pHeaderInfo->fKeepConn &&
         pIsapiContext->QueryClientKeepConn() )
    {
        pIsapiContext->SetKeepConn( TRUE );
    }

    hr = pIsapiCore->SendResponseHeaders(
        !pIsapiContext->QueryKeepConn(),
        const_cast<LPSTR>( pHeaderInfo->pszStatus ),
        const_cast<LPSTR>( pHeaderInfo->pszHeader ),
        HSE_IO_SYNC
        );

    if ( FAILED( hr ) )
    {
        IF_DEBUG( ISAPI_ERROR_RETURNS )
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "\r\n"
                        "  HSE_REQ_SEND_RESPONSE_HEADER_EX[%p]: Failed.\r\n"
                        "    Error: 0x%08x\r\n"
                        "  <END>\r\n\r\n",
                        pIsapiContext,
                        hr ));
        }

        return hr;
    }
    else
    {
        pIsapiContext->SetHeadersSent( TRUE );
    }

    IF_DEBUG( ISAPI_SSF_DETAILS )
    {
        IF_DEBUG( ISAPI_SUCCESS_RETURNS )
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "\r\n"
                        "  HSE_REQ_SEND_RESPONSE_HEADER_EX[%p]: Succeeded\r\n"
                        "  <END>\r\n",
                        pIsapiContext ));
        }
    }

    return hr;
}

HRESULT
SSFMapUrlToPath(
    ISAPI_CONTEXT * pIsapiContext,
    LPSTR           szBuffer,
    LPDWORD         pcbBuffer
    )
/*++

Routine Description:

    Maps a URL into a physical path

Arguments:

    pIsapiContext - The ISAPI_CONTEXT associated with this command.
    szBuffer      - On entry, contains the URL to map.  On return,
                    contains the mapped physical path.
    pcbBuffer     - On entry, the size of szBuffer.  On successful
                    return, the number of bytes copied to szUrl.  On
                    failed return, the number of bytes needed for the
                    physical path.
    
Return Value:

    HRESULT

--*/
{
    IIsapiCore *    pIsapiCore;
    HRESULT         hr;

    DBG_ASSERT( pIsapiContext );
    DBG_ASSERT( pIsapiContext->CheckSignature() );

    IF_DEBUG( ISAPI_SSF_DETAILS )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "\r\n"
                    "  HSE_REQ_MAP_URL_TO_PATH[%p]: Function Entry\r\n"
                    "    URL: %s\r\n"
                    "  <END>\r\n\r\n",
                    pIsapiContext,
                    szBuffer ));
    }

    pIsapiCore = pIsapiContext->QueryIsapiCoreInterface();

    if ( pIsapiCore == NULL )
    {
        IF_DEBUG( ISAPI_ERROR_RETURNS )
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "\r\n"
                        "  HSE_REQ_MAP_URL_TO_PATH[%p]: Failed to get interface to server core\r\n"
                        "  <END>\r\n\r\n",
                        pIsapiContext ));
        }

        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }


    //
    // Validate parameters
    //

    if ( szBuffer == NULL ||
         pcbBuffer == NULL ||
         *pcbBuffer == 0 )
    {
        IF_DEBUG( ISAPI_ERROR_RETURNS )
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "\r\n"
                        "  HSE_REQ_MAP_URL_TO_PATH[%p]: Parameter validation failure\r\n"
                        "    Buffer: '%s'\r\n"
                        "    Buffer Size Ptr: %p\r\n"
                        "    Buffer Size: %d\r\n",
                        pIsapiContext,
                        pcbBuffer,
                        pcbBuffer ? *pcbBuffer : 0 ));
        }

        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }

    hr = pIsapiCore->MapPath(
        reinterpret_cast<BYTE*>( szBuffer ),
        *pcbBuffer,
        pcbBuffer,
        FALSE
        );

    if ( FAILED( hr ) )
    {
        IF_DEBUG( ISAPI_ERROR_RETURNS )
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "\r\n"
                        "  HSE_REQ_MAP_URL_TO_PATH[%p]: Failed\r\n"
                        "    Error: 0x%08x\r\n"
                        "  <END>\r\n\r\n",
                        pIsapiContext,
                        hr ));
        }

        return hr;
    }

    IF_DEBUG( ISAPI_SSF_DETAILS )
    {
        IF_DEBUG( ISAPI_SUCCESS_RETURNS )
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "\r\n"
                        "  HSE_REQ_MAP_URL_TO_PATH[%p]: Succeeded\r\n"
                        "    Mapped URL: %s\r\n"
                        "  <END>\r\n\r\n",
                        pIsapiContext,
                        szBuffer ));
        }
    }

    return hr;
}

HRESULT
SSFMapUrlToPathEx(
    ISAPI_CONTEXT *         pIsapiContext,
    LPSTR                   szUrl,
    HSE_URL_MAPEX_INFO *    pHseMapInfo,
    LPDWORD                 pcbMappedPath
    )
/*++

Routine Description:

    Maps a URL to a physical path and returns some metadata
    metrics for the URL to the caller.

Arguments:

    pIsapiContext - The ISAPI_CONTEXT associated with this command.
    szUrl         - The URL to map
    pHseMapInfo   - Upon return, contains the mapped URL info
    pcbMappedPath - If non-NULL, contains the buffer size needed
                    to store the mapped physical path.
    
Return Value:

    HRESULT

--*/
{
    IIsapiCore *    pIsapiCore;
    DWORD           cbMapped;
    HRESULT         hr;

    DBG_ASSERT( pIsapiContext );
    DBG_ASSERT( pIsapiContext->CheckSignature() );

    IF_DEBUG( ISAPI_SSF_DETAILS )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "\r\n"
                    "  HSE_REQ_MAP_URL_TO_PATH_EX[%p]: Function Entry\r\n"
                    "    URL='%s'\r\n"
                    "  <END>\r\n\r\n",
                    pIsapiContext,
                    szUrl ));
    }


    pIsapiCore = pIsapiContext->QueryIsapiCoreInterface();

    if ( pIsapiCore == NULL )
    {
        IF_DEBUG( ISAPI_ERROR_RETURNS )
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "\r\n"
                        "  HSE_REQ_MA_URL_TO_PATH_EX[%p]: Failed to get interface to server core\r\n"
                        "  <END>\r\n\r\n",
                        pIsapiContext ));
        }

        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }

    //
    // Additional parameter validation
    //

    if ( szUrl == NULL ||
         pHseMapInfo == NULL )
    {
        IF_DEBUG( ISAPI_ERROR_RETURNS )
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "\r\n"
                        "  HSE_REQ_MAP_URL_TO_PATH_EX[%p]: Parameter validation failure\r\n"
                        "    URL: '%s'\r\n"
                        "    HSE_URL_MAPEX_INFO: %p\r\n"
                        "  <END>\r\n\r\n",
                        pIsapiContext,
                        szUrl,
                        pHseMapInfo ));
        }

        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }

    //
    // The inline buffer within the HSE_URL_MAPEX_INFO structure
    // is defined as being MAX_PATH size.
    //

    cbMapped = MAX_PATH;

    pHseMapInfo->dwReserved1 = 0;
    pHseMapInfo->dwReserved2 = 0;

    hr = pIsapiCore->MapPathEx(
        reinterpret_cast<BYTE*>( szUrl ),
        (DWORD)strlen(szUrl) + 1,
        reinterpret_cast<BYTE*>( pHseMapInfo->lpszPath ),
        cbMapped,
        pcbMappedPath ? pcbMappedPath : &cbMapped,
        &pHseMapInfo->cchMatchingPath,
        &pHseMapInfo->cchMatchingURL,
        &pHseMapInfo->dwFlags,
        FALSE
        );

    if ( FAILED( hr ) )
    {
        IF_DEBUG( ISAPI_ERROR_RETURNS )
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "\r\n"
                        "  HSE_REQ_MAP_URL_TO_PATH_EX[%p]: Failed\r\n"
                        "    Error: 0x%08x\r\n"
                        "  <END>\r\n\r\n",
                        pIsapiContext,
                        hr ));
        }

        return hr;
    }

    return hr;
}

HRESULT
SSFMapUnicodeUrlToPath(
    ISAPI_CONTEXT * pIsapiContext,
    LPWSTR          szBuffer,
    LPDWORD         pcbBuffer
    )
/*++

Routine Description:

    Maps a URL into a physical path

Arguments:

    pIsapiContext - The ISAPI_CONTEXT associated with this command.
    szBuffer      - On entry, contains the URL to map.  On return,
                    contains the mapped physical path.
    pcbBuffer     - On entry, the size of szBuffer.  On successful
                    return, the number of bytes copied to szUrl.  On
                    failed return, the number of bytes needed for the
                    physical path.
    
Return Value:

    HRESULT

--*/
{
    IIsapiCore *    pIsapiCore;
    HRESULT         hr;

    DBG_ASSERT( pIsapiContext );
    DBG_ASSERT( pIsapiContext->CheckSignature() );

    IF_DEBUG( ISAPI_SSF_DETAILS )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "\r\n"
                    "  HSE_REQ_MAP_UNICODE_URL_TO_PATH[%p]: Function Entry\r\n"
                    "    URL='%S'\r\n"
                    "  <END>\r\n\r\n",
                    pIsapiContext,
                    szBuffer ));
    }

    pIsapiCore = pIsapiContext->QueryIsapiCoreInterface();

    if ( pIsapiCore == NULL )
    {
        IF_DEBUG( ISAPI_ERROR_RETURNS )
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "\r\n"
                        "  HSE_REQ_MA_UNICODE_URL_TO_PATH[%p]: Failed to get interface to server core\r\n"
                        "  <END>\r\n\r\n",
                        pIsapiContext ));
        }

        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }

    //
    // Validate parameters
    //

    if ( szBuffer == NULL ||
         pcbBuffer == NULL ||
         *pcbBuffer == 0 )
    {
        IF_DEBUG( ISAPI_ERROR_RETURNS )
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "\r\n"
                        "  HSE_REQ_MAP_UNICODE_URL_TO_PATH[%p]: Parameter validation failure\r\n"
                        "    Buffer: '%S'\r\n"
                        "    Buffer Size Ptr: %p\r\n"
                        "    Buffer Size: %d\r\n"
                        "  <END>\r\n\r\n",
                        pIsapiContext,
                        szBuffer,
                        pcbBuffer,
                        pcbBuffer ? *pcbBuffer : 0 ));
        }

        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }

    hr = pIsapiCore->MapPath(
        reinterpret_cast<BYTE*>( szBuffer ),
        *pcbBuffer,
        pcbBuffer,
        TRUE
        );

    if ( FAILED( hr ) )
    {
        IF_DEBUG( ISAPI_ERROR_RETURNS )
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "\r\n"
                        "  HSE_REQ_MAP_UNICODE_URL_TO_PATH[%p]: Failed\r\n"
                        "    Error: 0x%08x\r\n"
                        "  <END>\r\n\r\n",
                        pIsapiContext,
                        hr ));
        }

        return hr;
    }

    return hr;
}

HRESULT
SSFMapUnicodeUrlToPathEx(
    ISAPI_CONTEXT *             pIsapiContext,
    LPWSTR                      szUrl,
    HSE_UNICODE_URL_MAPEX_INFO *pHseMapInfo,
    LPDWORD                     pcbMappedPath
    )
/*++

Routine Description:

    Maps a URL to a physical path and returns some metadata
    metrics for the URL to the caller.

Arguments:

    pIsapiContext - The ISAPI_CONTEXT associated with this command.
    szUrl         - The URL to map
    pHseMapInfo   - Upon return, contains the mapped URL info
    pcbMappedPath - If non-NULL, contains the buffer size needed
                    to store the mapped physical path.
    
Return Value:

    HRESULT

--*/
{
    IIsapiCore *    pIsapiCore;
    DWORD           cbMapped;
    HRESULT         hr;

    DBG_ASSERT( pIsapiContext );
    DBG_ASSERT( pIsapiContext->CheckSignature() );

    IF_DEBUG( ISAPI_SSF_DETAILS )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "\r\n"
                    "  HSE_REQ_MAP_UNICODE_URL_TO_PATH_EX[%p]: Function Entry\r\n"
                    "    URL='%S'\r\n"
                    "  <END>\r\n\r\n",
                    pIsapiContext,
                    szUrl ));
    }

    pIsapiCore = pIsapiContext->QueryIsapiCoreInterface();

    if ( pIsapiCore == NULL )
    {
        IF_DEBUG( ISAPI_ERROR_RETURNS )
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "\r\n"
                        "  HSE_REQ_MA_UNICODE_URL_TO_PATH_EX[%p]: Failed to get interface to server core\r\n"
                        "  <END>\r\n\r\n",
                        pIsapiContext ));
        }

        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }

    //
    // Additional parameter validation
    //

    if ( szUrl == NULL ||
         pHseMapInfo == NULL )
    {
        IF_DEBUG( ISAPI_ERROR_RETURNS )
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "\r\n"
                        "  HSE_REQ_MAP_UNICODE_URL_TO_PATH_EX[%p]: Parameter validation failure\r\n"
                        "    URL: '%s'\r\n"
                        "    pHseMapInfo: %p\r\n"
                        "  <END>\r\n\r\n",
                        pIsapiContext,
                        szUrl,
                        pHseMapInfo ));
        }

        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }

    //
    // The inline buffer within the HSE_URL_MAPEX_INFO structure
    // is defined as being MAX_PATH size.
    //

    cbMapped = MAX_PATH * sizeof(WCHAR);

    hr = pIsapiCore->MapPathEx(
        reinterpret_cast<BYTE*>( szUrl ),
        (DWORD)(wcslen(szUrl) + 1)*sizeof(WCHAR),
        reinterpret_cast<BYTE*>( pHseMapInfo->lpszPath ),
        cbMapped,
        pcbMappedPath ? pcbMappedPath : &cbMapped,
        &pHseMapInfo->cchMatchingPath,
        &pHseMapInfo->cchMatchingURL,
        &pHseMapInfo->dwFlags,
        TRUE
        );

    if ( FAILED( hr ) )
    {
        IF_DEBUG( ISAPI_ERROR_RETURNS )
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "\r\n"
                        "  HSE_REQ_MAP_UNICODE_URL_TO_PATH_EX[%p]: Failed\r\n"
                        "    Error: 0x%08x\r\n"
                        "  <END>\r\n\r\n",
                        pIsapiContext,
                        hr ));
        }

        return hr;
    }

    return hr;
}

HRESULT
SSFGetImpersonationToken(
    ISAPI_CONTEXT * pIsapiContext,
    HANDLE *        phToken
    )
/*++

Routine Description:

    Returns a (non-duplicated) copy of the token that the server
    is using to impersonate the client for this request.

Arguments:

    pIsapiContext - The ISAPI_CONTEXT associated with this command.
    phToken       - Upon return, contains a copy of the token.
    
Return Value:

    HRESULT

--*/
{
    DBG_ASSERT( pIsapiContext );
    DBG_ASSERT( pIsapiContext->CheckSignature() );

    IF_DEBUG( ISAPI_SSF_DETAILS )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "\r\n"
                    "  HSE_REQ_GET_IMPERSONATION_TOKEN[%p]: Function Entry\r\n"
                    "  <END>\r\n\r\n",
                    pIsapiContext ));
    }

    //
    // Validate parameters
    //

    if ( phToken == NULL )
    {
        IF_DEBUG( ISAPI_ERROR_RETURNS )
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "\r\n"
                        "  HSE_REQ_GET_IMPERSONATION_TOKEN[%p]: Parameter validation failure\r\n"
                        "    Token Ptr: NULL\r\n"
                        "  <END>\r\n\r\n",
                        pIsapiContext ));
        }

        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }

    *phToken = pIsapiContext->QueryToken();

    return NO_ERROR;
}

HRESULT
SSFIsKeepConn(
    ISAPI_CONTEXT * pIsapiContext,
    BOOL *          pfIsKeepAlive
    )
/*++

Routine Description:

    Returns information about whether the client wants us to keep
    the connection open or not at completion of this request.

Arguments:

    pIsapiContext - The ISAPI_CONTEXT associated with this command.
    pfIsKeepAlive - Upon return, TRUE if IIS will be keeping the
                    connection alive, else FALSE.
    
Return Value:

    HRESULT

--*/
{
    DBG_ASSERT( pIsapiContext );
    DBG_ASSERT( pIsapiContext->CheckSignature() );

    IF_DEBUG( ISAPI_SSF_DETAILS )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "\r\n"
                    "  HSE_REQ_IS_KEEP_CONN[%p]: Function Entry\r\n"
                    "  <END>\r\n\r\n",
                    pIsapiContext ));
    }

    //
    // Validate parameters
    //

    if ( pfIsKeepAlive == NULL )
    {
        IF_DEBUG( ISAPI_ERROR_RETURNS )
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "\r\n"
                        "  HSE_REQ_IS_KEEP_CONN[%p]: Parameter validation failure\r\n"
                        "    KeepAlive Ptr: NULL\r\n"
                        "  <END>\r\n\r\n",
                        pIsapiContext ));
        }

        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }

    *pfIsKeepAlive = pIsapiContext->QueryClientKeepConn();

    return NO_ERROR;
}

HRESULT
SSFDoneWithSession(
    ISAPI_CONTEXT * pIsapiContext,
    DWORD *         pHseResult
    )
/*++

Routine Description:

    Notifies the server that the calling ISAPI is done with the
    ECB (and ISAPI_CONTEXT) for this request and that the server
    can clean up.

Arguments:

    pIsapiContext - The ISAPI_CONTEXT associated with this command.
    pHseResult    - A pointer to the HSE_STATUS code that the extension
                    wants to use.
    
Return Value:

    HRESULT

--*/
{
    IIsapiCore *    pIsapiCore;

    DBG_ASSERT( pIsapiContext );
    DBG_ASSERT( pIsapiContext->CheckSignature() );

    DBG_ASSERT( pIsapiContext->QueryIoState() == NoAsyncIoPending );

    DBG_REQUIRE( ( pIsapiCore = pIsapiContext->QueryIsapiCoreInterface() ) != NULL );

    IF_DEBUG( ISAPI_SSF_DETAILS )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "\r\n"
                    "  HSE_REQ_DONE_WITH_SESSION[%p]: Function Entry\r\n"
                    "  <END>\r\n\r\n",
                    pIsapiContext ));
    }

    //
    // If the caller wants to do STATUS_SUCCESS_AND_KEEP_CONN,
    // then we need to do that now.
    //
    // Note that this overrides our own determination of whether
    // the client can support keep-alive or not.  We are trusting
    // the caller to have returned the right headers to make this
    // work with the client.
    //

    if ( pHseResult &&
         *pHseResult == HSE_STATUS_SUCCESS_AND_KEEP_CONN )
    {
        if ( pIsapiContext->QueryClientKeepConn() )
        {
            pIsapiContext->SetKeepConn( TRUE );
            pIsapiCore->SetConnectionClose( !pIsapiContext->QueryKeepConn() );

        }
    }

    //
    // We'll just release the reference on IsapiContext.
    // Its destructor will do the rest.
    //

    pIsapiContext->DereferenceIsapiContext();
    pIsapiContext = NULL;

    return NO_ERROR;
}

HRESULT
SSFGetCertInfoEx(
    ISAPI_CONTEXT *     pIsapiContext,
    CERT_CONTEXT_EX *   pCertContext
    )
/*++

Routine Description:

    Returns certificate information about the client associated
    with this request.

Arguments:

    pIsapiContext - The ISAPI_CONTEXT associated with this command.
    pCertContext  - Upon return, contains info about the client cert.
    
Return Value:

    HRESULT

--*/
{
    IIsapiCore *    pIsapiCore;
    HRESULT         hr;
    
    DBG_ASSERT( pIsapiContext );
    DBG_ASSERT( pIsapiContext->CheckSignature() );

    IF_DEBUG( ISAPI_SSF_DETAILS )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "\r\n"
                    "  HSE_REQ_GET_CERT_INFO_EX[%p]: Function Entry\r\n"
                    "  <END>\r\n\r\n",
                    pIsapiContext ));
    }

    pIsapiCore = pIsapiContext->QueryIsapiCoreInterface();

    if ( pIsapiCore == NULL )
    {
        IF_DEBUG( ISAPI_ERROR_RETURNS )
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "\r\n"
                        "  HSE_REQ_GET_CERT_INFO_EX[%p]: Failed to get interface to server core\r\n"
                        "  <END>\r\n\r\n",
                        pIsapiContext ));
        }

        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }

    //
    // Validate parameters
    //
    
    if ( pCertContext == NULL )
    {
        IF_DEBUG( ISAPI_ERROR_RETURNS )
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "\r\n"
                        "  HSE_REQ_GET_CERT_INFO_EX[%p]: Parameter validation failure\r\n"
                        "    CertContext Ptr: NULL\r\n"
                        "  <END>\r\n\r\n",
                        pIsapiContext ));
        }

        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }

    hr = pIsapiCore->GetCertificateInfoEx(
            pCertContext->cbAllocated,
            &( pCertContext->CertContext.dwCertEncodingType ),
            pCertContext->CertContext.pbCertEncoded,
            &( pCertContext->CertContext.cbCertEncoded ),
            &( pCertContext->dwCertificateFlags ) );

   if ( FAILED( hr ) )
    {
        IF_DEBUG( ISAPI_ERROR_RETURNS )
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "\r\n"
                        "  HSE_REQ_GET_CERT_INFO_EX[%p]: Failed\r\n"
                        "    Error: 0x%08x\r\n"
                        "  <END>\r\n\r\n",
                        pIsapiContext,
                        hr ));
        }

        return hr;
    }

   return hr;
}

HRESULT
SSFIoCompletion(
    ISAPI_CONTEXT *         pIsapiContext,
    PFN_HSE_IO_COMPLETION   pCompletionRoutine,
    LPVOID                  pHseIoContext
    )
/*++

Routine Description:

    Establishes the I/O completion routine and user-defined context
    to be used for asynchronous operations associated with this
    request.

Arguments:

    pIsapiContext      - The ISAPI_CONTEXT associated with this command.
    pCompletionRoutine - The function to call upon I/O completion
    pHseIoContext      - The user-defined context to be passed to the
                         completion routine.
    
Return Value:

    HRESULT

--*/
{
    DBG_ASSERT( pIsapiContext );
    DBG_ASSERT( pIsapiContext->CheckSignature() );

    IF_DEBUG( ISAPI_SSF_DETAILS )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "\r\n"
                    "  HSE_REQ_IO_COMPLETION[%p]: Function Entry\r\n"
                    "    Completion Routine: %p\r\n"
                    "    Context: %p\r\n"
                    "  <END>\r\n\r\n",
                    pIsapiContext,
                    pCompletionRoutine,
                    pHseIoContext ));
    }

    //
    // Validate parameters
    //

    if ( pCompletionRoutine == NULL )
    {
        IF_DEBUG( ISAPI_ERROR_RETURNS )
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "\r\n"
                        "  HSE_REQ_IO_COMPLETION[%p]: Parameter validation failure\r\n"
                        "    Completion Routine: NULL\r\n"
                        "  <END>\r\n\r\n",
                        pIsapiContext ));
        }

        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }

    pIsapiContext->SetPfnIoCompletion( pCompletionRoutine );
    pIsapiContext->SetExtensionContext( pHseIoContext );

    return NO_ERROR;
}

HRESULT
SSFAsyncReadClient(
    ISAPI_CONTEXT * pIsapiContext,
    LPVOID          pBuffer,
    LPDWORD         pcbBuffer
    )
/*++

Routine Description:

    Queues an asynchronous read of data from the client.

Arguments:

    pIsapiContext - The ISAPI_CONTEXT associated with this command.
    pBuffer       - Buffer to be filled with read data.
    pcbBuffer     - The size of pBuffer
    
Return Value:

    HRESULT

--*/
{
    IIsapiCore *    pIsapiCore;
    DWORD           cbBuffer;
    HRESULT         hr = NOERROR;

    DBG_ASSERT( pIsapiContext );
    DBG_ASSERT( pIsapiContext->CheckSignature() );

    IF_DEBUG( ISAPI_SSF_DETAILS )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "\r\n"
                    "  HSE_REQ_ASYNC_READ_CLIENT[%p]: Function Entry\r\n"
                    "    Bytes to Read: %d\r\n"
                    "  <END>\r\n\r\n",
                    pIsapiContext,
                    pcbBuffer ? *pcbBuffer : 0 ));
    }

    pIsapiCore = pIsapiContext->QueryIsapiCoreInterface();

    if ( pIsapiCore == NULL )
    {
        IF_DEBUG( ISAPI_ERROR_RETURNS )
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "\r\n"
                        "  HSE_REQ_ASYNC_READ_CLIENT[%p]: Failed to get interface to server core\r\n"
                        "  <END>\r\n\r\n",
                        pIsapiContext ));
        }

        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }

    //
    // Validate parameters
    //

    if ( pIsapiContext->QueryPfnIoCompletion() == NULL ||
         pBuffer == NULL ||
         pcbBuffer == NULL ||
         *pcbBuffer == 0 )
    {
        IF_DEBUG( ISAPI_ERROR_RETURNS )
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "\r\n"
                        "  HSE_REQ_ASYNC_READ_CLIENT[%p]: Parameter validation failure\r\n"
                        "    Completion Routine: %p\r\n"
                        "    Buffer Ptr: %p\r\n"
                        "    Buffer Size Ptr: %p\r\n"
                        "    Buffer Size: %d\r\n"
                        "  <END>\r\n\r\n",
                        pIsapiContext,
                        pIsapiContext->QueryPfnIoCompletion(),
                        pBuffer,
                        pcbBuffer,
                        pcbBuffer ? *pcbBuffer : 0 ));
        }

        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }

    //
    // Do the async ReadClient call
    //

    if ( pIsapiContext->TryInitAsyncIo( AsyncReadPending ) == FALSE )
    {
        IF_DEBUG( ISAPI_ERROR_RETURNS )
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "\r\n"
                        "  HSE_REQ_ASYNC_READ_CLIENT[%p]: Failed\r\n"
                        "    Another async operation is already pending\r\n"
                        "  <END>\r\n\r\n",
                        pIsapiContext ));
        }

        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }

    //
    // Since we're never actually reading any data in the async
    // case, we want to prevent pIsapiCore->ReadClient() from
    // modifying the buffer size we report back to the caller,
    // so we'll use a local for cbBuffer.
    //

    cbBuffer = *pcbBuffer;

    //
    // If this call will be going OOP, save a pointer to the
    // read buffer so that the core can fill it when the
    // operation completes.
    //

    if ( pIsapiContext->QueryIsOop() )
    {
        DBG_ASSERT( pIsapiContext->QueryAsyncIoBuffer() == NULL );
        DBG_ASSERT( pIsapiContext->QueryLastAsyncIo() == 0 );
        pIsapiContext->SetAsyncIoBuffer( pBuffer );
        pIsapiContext->SetLastAsyncIo( cbBuffer );
    }

    hr = pIsapiCore->ReadClient(
        reinterpret_cast<DWORD64>( pIsapiContext ),
        pIsapiContext->QueryIsOop() ? NULL : reinterpret_cast<unsigned char*>( pBuffer ),
        pIsapiContext->QueryIsOop() ? 0 : cbBuffer,
        cbBuffer,
        &cbBuffer,
        HSE_IO_ASYNC
        );

    if ( FAILED( hr ) )
    {
        IF_DEBUG( ISAPI_ERROR_RETURNS )
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "\r\n"
                        "  HSE_REQ_ASYNC_READ_CLIENT[%p]: Failed\r\n"
                        "    Error: 0x%08x\r\n"
                        "  <END>\r\n\r\n",
                        pIsapiContext,
                        hr ));
        }

        pIsapiContext->SetAsyncIoBuffer( NULL );
        pIsapiContext->SetLastAsyncIo( 0 );
        pIsapiContext->UninitAsyncIo();
    }

    return hr;
}

HRESULT
SSFTransmitFile(
    ISAPI_CONTEXT * pIsapiContext,
    HSE_TF_INFO *   pTfInfo
    )
/*++

Routine Description:

    Transmits a file, a portion of a file, or some other data
    (in the event on a NULL file handle) to the client.

Arguments:

    pIsapiContext - The ISAPI_CONTEXT associated with this command.
    pTfInfo       - Describes the desired transmit file action.
    
Return Value:

    HRESULT

--*/
{
    IIsapiCore *    pIsapiCore;
    LARGE_INTEGER   cbFileSize;
    HRESULT         hr;

    DBG_ASSERT( pIsapiContext );
    DBG_ASSERT( pIsapiContext->CheckSignature() );

    IF_DEBUG( ISAPI_SSF_DETAILS )
    {
        STACK_STRA( strFilename,MAX_PATH );


        DBGPRINTF(( DBG_CONTEXT,
                    "\r\n"
                    "  HSE_REQ_TRANSMIT_FILE[%p]: Function Entry\r\n"
                    "    Completion Routine: %p\r\n"
                    "    Context: %p\r\n"
                    "    File Handle: %p\r\n"
                    "    Status Code: '%s'\r\n"
                    "    Bytes To Write: %d\r\n"
                    "    Offset: %d\r\n"
                    "  <END>\r\n\r\n",
                    pIsapiContext,
                    pTfInfo ? pTfInfo->pfnHseIO : 0,
                    pTfInfo ? pTfInfo->pContext : 0,
                    pTfInfo ? pTfInfo->hFile : 0,
                    pTfInfo ? pTfInfo->pszStatusCode : 0,
                    pTfInfo ? pTfInfo->BytesToWrite : 0,
                    pTfInfo ? pTfInfo->Offset : 0 ));

        IF_DEBUG( ISAPI_DUMP_BUFFERS )
        {
            if ( pTfInfo )
            {
                STACK_STRA( strHead,MAX_PATH );
                STACK_STRA( strTail,MAX_PATH );
                DWORD       dwBytesToDump;

                dwBytesToDump = pTfInfo->HeadLength;

                if ( dwBytesToDump > MAX_DEBUG_DUMP )
                {
                    dwBytesToDump = MAX_DEBUG_DUMP;
                }

                if ( FAILED( strHead.CopyBinary( pTfInfo->pHead, dwBytesToDump ) ) )
                {
                    strHead.Copy( "" );
                }

                dwBytesToDump = pTfInfo->TailLength;

                if ( dwBytesToDump > MAX_DEBUG_DUMP )
                {
                    dwBytesToDump = MAX_DEBUG_DUMP;
                }

                if ( FAILED( strTail.CopyBinary( pTfInfo->pTail, dwBytesToDump ) ) )
                {
                    strTail.Copy( "" );
                }

                DBGPRINTF(( DBG_CONTEXT,
                            "\r\n"
                            "  HSE_REQ_TRANSMIT_FILE[%p]: Dump of up to %d bytes of head and tail data\r\n"
                            "    Head Data:\r\n"
                            "%s"
                            "    Tail Data:\r\n"
                            "%s"
                            "  <END>\r\n",
                            pIsapiContext,
                            MAX_DEBUG_DUMP,
                            strHead.QueryStr(),
                            strTail.QueryStr() ));
            }
        }
    }

    pIsapiCore = pIsapiContext->QueryIsapiCoreInterface();

    if ( pIsapiCore == NULL )
    {
        IF_DEBUG( ISAPI_ERROR_RETURNS )
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "\r\n"
                        "  HSE_REQ_TRANSMIT_FILE[%p]: Failed to get interface to server core\r\n"
                        "  <END>\r\n\r\n",
                        pIsapiContext ));
        }

        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }

    //
    // Validate parameters - For TRANSMIT_FILE, this means:
    //
    // - We must have an ISAPI core interface to call through
    // - We must have an HSE_TF_INFO structure
    // - The HSE_IO_ASYNC flag must be set
    // - If HeadLength is set, pHead cannot be NULL
    // - If TailLength is set, pTail cannot be NULL
    // - We must have either a completion routine already set
    //   in the ISAPI_CONTEXT, or the HSE_TF_INFO must provide
    //   one
    // - There can be no other async operations in progress
    //

    if ( pTfInfo == NULL )
    {
        IF_DEBUG( ISAPI_ERROR_RETURNS )
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "\r\n"
                        "  HSE_REQ_TRANSMIT_FILE[%p]: Parameter validation failure\r\n"
                        "    Transmit File Info Ptr: NULL\r\n"
                        "  <END>\r\n\r\n",
                        pIsapiContext ));
        }

        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }

    if ( ( pTfInfo->dwFlags & HSE_IO_ASYNC ) == 0 ||
         pTfInfo->hFile == INVALID_HANDLE_VALUE ||
         ( pTfInfo->HeadLength != 0 && pTfInfo->pHead == NULL ) ||
         ( pTfInfo->TailLength != 0 && pTfInfo->pTail == NULL ) ||
         ( pIsapiContext->QueryPfnIoCompletion() == NULL &&
           pTfInfo->pfnHseIO == NULL ) )
    {
        IF_DEBUG( ISAPI_ERROR_RETURNS )
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "\r\n"
                        "  HSE_REQ_TRANSMIT_FILE[%p]: Parameter validation failure\r\n"
                        "    %s\r\n",
                        "    File Handle: %p\r\n"
                        "    Head: %p\r\n"
                        "    Head Length: %d\r\n"
                        "    Tail: %p\r\n"
                        "    Tail Length: %d\r\n"
                        "    Completion Routine: %p\r\n"
                        "  <END>\r\n\r\n",
                        pIsapiContext,
                        pTfInfo->dwFlags & HSE_IO_ASYNC ? "Async flag set" : "Async flag not set",
                        pTfInfo->hFile,
                        pTfInfo->pHead,
                        pTfInfo->HeadLength,
                        pTfInfo->pTail,
                        pTfInfo->TailLength,
                        pTfInfo->pfnHseIO ? pTfInfo->pfnHseIO : pIsapiContext->QueryPfnIoCompletion() ));
        }

        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }

    if ( pIsapiContext->TryInitAsyncIo( AsyncWritePending ) == FALSE )
    {
        IF_DEBUG( ISAPI_ERROR_RETURNS )
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "\r\n"
                        "  HSE_REQ_TRANSMIT_FILE[%p]: Failed\r\n"
                        "    Another async operation is already pending.\r\n"
                        "  <END>\r\n\r\n",
                        pIsapiContext ));
        }

        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }

    //
    // We'll do some extra validation in the case where we've been
    // provided a file handle.
    //
    // Specifically, we'll check to make sure that the offset and
    // bytes-to-write are valid for the file.
    //
    // CODEWORK - Do we really need to do this, or can http.sys handle
    //            it?  Also, does http.sys treat zero bytes to write
    //            the same as TransmitFile (ie. send the whole file?)
    //

    if ( pTfInfo->hFile != NULL )
    {
        if (!GetFileSizeEx(pTfInfo->hFile,
                           &cbFileSize))
        {
            hr = HRESULT_FROM_WIN32( GetLastError() );
            goto Done;
        }

        if ( pTfInfo->Offset > cbFileSize.QuadPart ||
             (pTfInfo->Offset > 0 && pTfInfo->Offset == cbFileSize.QuadPart ) ||
             pTfInfo->Offset + pTfInfo->BytesToWrite > cbFileSize.QuadPart )
        {
            IF_DEBUG( ISAPI_ERROR_RETURNS )
            {
                DBGPRINTF(( DBG_CONTEXT,
                            "\r\n"
                            "  HSE_REQ_TRANSMIT_FILE[%p]: Parameter validation failure\r\n"
                            "    File Size: %d\r\n"
                            "    Offset: %d\r\n"
                            "    Bytes to Write: %d\r\n"
                            "  <END>\r\n\r\n",
                            pIsapiContext,
                            cbFileSize.QuadPart,
                            pTfInfo->Offset,
                            pTfInfo->BytesToWrite ));
            }

            hr = HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
            goto Done;
        }
    }
    else
    {
        //
        // No file handle, so initialize the size to zero
        //

        cbFileSize.QuadPart = 0;
    }

    //
    // If the HSE_TF_INFO includes I/O completion or context
    // information, override the existing settings.
    //

    if ( pTfInfo->pfnHseIO )
    {
        pIsapiContext->SetPfnIoCompletion( pTfInfo->pfnHseIO );
    }

    if ( pTfInfo->pContext )
    {
        pIsapiContext->SetExtensionContext( pTfInfo->pContext );
    }

    //
    // If the extension is setting HSE_IO_SEND_HEADERS, then we need
    // to determine if it's sending some kind of content length.  If
    // it's not, then we need to set _fKeepConn to FALSE.
    //
    // CODEWORK
    // Note that we're making a bold assumption here that if
    // HSE_IO_SEND_HEADERS is set, then pHead points to a NULL
    // terminated string.
    //

    if ( pIsapiContext->QueryClientKeepConn() &&
         pTfInfo->pHead &&
         ( pTfInfo->dwFlags & HSE_IO_SEND_HEADERS ) &&
         !( pTfInfo->dwFlags & HSE_IO_DISCONNECT_AFTER_SEND ) )
    {
        if ( stristr2( (LPSTR)pTfInfo->pHead, "content-length: " ) != NULL ||
             stristr2( (LPSTR)pTfInfo->pHead, "transfer-encoding: chunked" ) != NULL )
        {
            pIsapiContext->SetKeepConn( TRUE );
        }
    }

    if ( pIsapiContext->QueryKeepConn() == FALSE )
    {
        pTfInfo->dwFlags |= HSE_IO_DISCONNECT_AFTER_SEND;
    }
    else
    {
        //
        // We need to clear the HSE_IO_DISCONNECT_AFTER_SEND flag
        // in the case where QueryKeepConn is TRUE.
        //

        pTfInfo->dwFlags &= ~HSE_IO_DISCONNECT_AFTER_SEND;
    }

    //
    // Save the BytesToWrite part as _cbLastAsyncIo, since the size of
    // pHead and pTail confuses ISAPI's that examine the cbWritten
    // value on completion.
    //

    ULARGE_INTEGER cbToWrite;

    if ( pTfInfo->BytesToWrite )
    {
        cbToWrite.QuadPart = pTfInfo->BytesToWrite;
    }
    else
    {
        cbToWrite.QuadPart = cbFileSize.QuadPart - pTfInfo->Offset;
    }

    //
    // Note that ISAPI doesn't support large integer values, so the
    // best we can do here is to store the low bits.
    //

    pIsapiContext->SetLastAsyncIo( cbToWrite.LowPart );

    hr = pIsapiCore->TransmitFile(
        reinterpret_cast<DWORD64>( pIsapiContext ),
        reinterpret_cast<DWORD_PTR>( pTfInfo->hFile ),
        pTfInfo->Offset,
        cbToWrite.QuadPart,
        (pTfInfo->dwFlags & HSE_IO_SEND_HEADERS) ? const_cast<LPSTR>( pTfInfo->pszStatusCode ) : NULL,
        reinterpret_cast<LPBYTE>( pTfInfo->pHead ),
        pTfInfo->HeadLength,
        reinterpret_cast<LPBYTE>( pTfInfo->pTail ),
        pTfInfo->TailLength,
        pTfInfo->dwFlags
        );

Done:

    if ( FAILED( hr ) )
    {
        IF_DEBUG( ISAPI_ERROR_RETURNS )
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "\r\n"
                        "  HSE_REQ_TRANSMIT_FILE[%p]: Failed\r\n"
                        "    Error: 0x%08x\r\n"
                        "  <END>\r\n\r\n",
                        pIsapiContext,
                        hr ));
        }

        pIsapiContext->SetLastAsyncIo( 0 );
        pIsapiContext->UninitAsyncIo();
    }

    return hr;
}

HRESULT
SSFSendRedirect(
    ISAPI_CONTEXT * pIsapiContext,
    LPSTR           szUrl
    )
/*++

Routine Description:

    Sends a 302 redirect to the client associated with this request.

Arguments:

    pIsapiContext - The ISAPI_CONTEXT associated with this command.
    szUrl         - The target URL for the redirection.
    
Return Value:

    HRESULT

--*/
{
    IIsapiCore *    pIsapiCore;
    HRESULT         hr;

    DBG_ASSERT( pIsapiContext );
    DBG_ASSERT( pIsapiContext->CheckSignature() );

    IF_DEBUG( ISAPI_SSF_DETAILS )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "\r\n"
                    "  HSE_REQ_SEND_REDIRECT[%p]: Function Entry\r\n"
                    "    URL: '%s'\r\n"
                    "  <END>\r\n\r\n",
                    pIsapiContext,
                    szUrl ));
    }
    
    pIsapiCore = pIsapiContext->QueryIsapiCoreInterface();

    if ( pIsapiCore == NULL )
    {
        IF_DEBUG( ISAPI_ERROR_RETURNS )
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "\r\n"
                        "  HSE_REQ_SEND_REDIRECT[%p]: Failed to get interface to server core\r\n"
                        "  <END>\r\n\r\n",
                        pIsapiContext ));
        }

        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }

    //
    // Validate parameters
    //

    if ( pIsapiContext == NULL ||
         szUrl == NULL )
    {
        IF_DEBUG( ISAPI_ERROR_RETURNS )
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "\r\n"
                        "  HSE_REQ_SEND_REDIRECT[%p]: Parameter validation failure\r\n"
                        "    szUrl: '%s'\r\n"
                        "  <END>\r\n\r\n",
                        pIsapiContext,
                        szUrl ));
        }

        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }

    if ( pIsapiContext->QueryClientKeepConn() )
    {
        pIsapiContext->SetKeepConn( TRUE );
    }

    hr = pIsapiCore->SendRedirect(
        szUrl,
        !pIsapiContext->QueryKeepConn()
        );

    if ( FAILED( hr ) )
    {
        IF_DEBUG( ISAPI_ERROR_RETURNS )
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "\r\n"
                        "  HSE_REQ_SEND_REDIRECT[%p]: Failed\r\n"
                        "    Error: 0x%08x\r\n"
                        "  <END>\r\n\r\n",
                        pIsapiContext,
                        hr ));
        }

        return hr;
    }

   return hr;

}

HRESULT
SSFIsConnected(
    ISAPI_CONTEXT * pIsapiContext,
    BOOL *          pfIsConnected
    )
/*++

Routine Description:

    Returns the connection state (connected or not connected)
    of the client associated with this request.

Arguments:

    pIsapiContext - The ISAPI_CONTEXT associated with this command.
    pfIsConnected - TRUE upon return if the client is connected,
                    else FALSE.
    
Return Value:

    HRESULT

--*/
{
    IIsapiCore *    pIsapiCore;
    HRESULT         hr;

    DBG_ASSERT( pIsapiContext );
    DBG_ASSERT( pIsapiContext->CheckSignature() );

    IF_DEBUG( ISAPI_SSF_DETAILS )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "\r\n"
                    "  HSE_REQ_IS_CONNECTED[%p]: Function Entry\r\n"
                    "  <END>\r\n\r\n",
                    pIsapiContext ));
    }

    pIsapiCore = pIsapiContext->QueryIsapiCoreInterface();

    if ( pIsapiCore == NULL )
    {
        IF_DEBUG( ISAPI_ERROR_RETURNS )
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "\r\n"
                        "  HSE_REQ_IS_CONNECTED[%p]: Failed to get interface to server core\r\n"
                        "  <END>\r\n\r\n",
                        pIsapiContext ));
        }

        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }

    //
    // Validate parameters
    //

    if ( pfIsConnected == NULL )
    {
        IF_DEBUG( ISAPI_ERROR_RETURNS )
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "\r\n"
                        "  HSE_REQ_IS_CONNECTED[%p]: Parameter validation failure\r\n"
                        "    IsConnected Ptr: NULL\r\n"
                        "  <END>\r\n\r\n",
                        pIsapiContext ));
        }

        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }

    hr = pIsapiCore->TestConnection( pfIsConnected );

    if ( FAILED( hr ) )
    {
        IF_DEBUG( ISAPI_ERROR_RETURNS )
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "\r\n"
                        "  HSE_REQ_IS_CONNECTED[%p]: Failed\r\n"
                        "    Error: 0x%08x\r\n"
                        "  <END>\r\n\r\n",
                        pIsapiContext,
                        hr ));
        }

        return hr;
    }

   return hr;
}

HRESULT
SSFAppendLog(
    ISAPI_CONTEXT * pIsapiContext,
    LPSTR           szExtraParam
    )
/*++

Routine Description:

    Appends the string passed to the QueryString that will be logged

Arguments:

    pIsapiContext - The ISAPI_CONTEXT associated with this command.
    szExtraParam  - The extra parameter to be logged
    
Return Value:

    HRESULT

--*/
{
    IIsapiCore *    pIsapiCore;
    HRESULT         hr;

    DBG_ASSERT( pIsapiContext );
    DBG_ASSERT( pIsapiContext->CheckSignature() );

    IF_DEBUG( ISAPI_SSF_DETAILS )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "\r\n"
                    "  HSE_REQ_APPEND_LOG_PARAMETER[%p]: Function Entry\r\n"
                    "    Extra Param: '%s'\r\n"
                    "  <END>\r\n\r\n",
                    pIsapiContext,
                    szExtraParam ));
    }

    pIsapiCore = pIsapiContext->QueryIsapiCoreInterface();

    if ( pIsapiCore == NULL )
    {
        IF_DEBUG( ISAPI_ERROR_RETURNS )
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "\r\n"
                        "  HSE_REQ_APPEND_LOG_PARAMETER[%p]: Failed to get interface to server core\r\n"
                        "  <END>\r\n\r\n",
                        pIsapiContext ));
        }

        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }

    //
    // Validate parameters
    //

    if ( szExtraParam == NULL )
    {
        IF_DEBUG( ISAPI_ERROR_RETURNS )
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "\r\n"
                        "  HSE_REQ_APPEND_LOG_PARAMETER[%p]: Parameter validation failure\r\n"
                        "    Extra Param: NULL\r\n"
                        "  <END>\r\n\r\n",
                        pIsapiContext ));
        }
        
        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }

    hr = pIsapiCore->AppendLog( szExtraParam, 0 );

    if ( FAILED( hr ) )
    {
        IF_DEBUG( ISAPI_ERROR_RETURNS )
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "\r\n"
                        "  HSE_REQ_APPEND_LOG_PARAMETER[%p]: Failed\r\n"
                        "    Error: 0x%08x\r\n"
                        "  <END>\r\n\r\n",
                        pIsapiContext,
                        hr ));
        }

        return hr;
    }

    return hr;
}

HRESULT
SSFExecuteUrl(
    ISAPI_CONTEXT *     pIsapiContext,
    VOID *              pOrigExecUrlInfo,
    BOOL                fIsUnicode
    )
/*++

Routine Description:

    Execute a child request

Arguments:

    pIsapiContext - The ISAPI_CONTEXT associated with this command.
    pOrigExecUrlInfo  - Description of child request to execute
    fIsUnicode - Are we passing unicode data?
    
Return Value:

    HRESULT

--*/
{
    EXEC_URL_USER_INFO          UserName;
    EXEC_URL_ENTITY_INFO        Entity;
    EXEC_URL_INFO               UrlInfo;
    IIsapiCore *                pIsapiCore;
    HRESULT                     hr;
    
    DBG_ASSERT( pIsapiContext );
    DBG_ASSERT( pIsapiContext->CheckSignature() );

    IF_DEBUG( ISAPI_SSF_DETAILS )
    {
        HSE_EXEC_URL_ENTITY_INFO *pEntityInfo = NULL;

        if ( fIsUnicode )
        {
            HSE_EXEC_UNICODE_URL_INFO *pInfo = (HSE_EXEC_UNICODE_URL_INFO *)pOrigExecUrlInfo;
            HSE_EXEC_UNICODE_URL_USER_INFO *pUserInfo = NULL;

            if ( pInfo )
            {
                pUserInfo = pInfo->pUserInfo;
                pEntityInfo = pInfo->pEntity;
            }

            DBGPRINTF(( DBG_CONTEXT,
                        "\r\n"
                        "  HSE_REQ_EXEC_UNICODE_URL[%p]: Function Entry\r\n"
                        "    URL: '%S'\r\n"
                        "    Method: '%s'\r\n"
                        "    Child Headers: '%s'\r\n"
                        "    Flags: 0x%08x (%d)\r\n"
                        "    Impersonation Token: %p\r\n"
                        "    Custom User Name: '%S'\r\n"
                        "    Custom Auth Type: '%s'\r\n"
                        "  <END>\r\n\r\n",
                        pIsapiContext,
                        pInfo ? pInfo->pszUrl : NULL,
                        pInfo ? pInfo->pszMethod : NULL,
                        pInfo ? pInfo->pszChildHeaders : NULL,
                        pInfo ? pInfo->dwExecUrlFlags : 0,
                        pInfo ? pInfo->dwExecUrlFlags : 0,
                        pUserInfo ? pUserInfo->hImpersonationToken : NULL,
                        pUserInfo ? pUserInfo->pszCustomUserName : NULL,
                        pUserInfo ? pUserInfo->pszCustomAuthType : NULL ));
        }
        else
        {
            HSE_EXEC_URL_INFO *pInfo = (HSE_EXEC_URL_INFO *)pOrigExecUrlInfo;
            HSE_EXEC_URL_USER_INFO *pUserInfo = NULL;

            if ( pInfo )
            {
                pUserInfo = pInfo->pUserInfo;
                pEntityInfo = pInfo->pEntity;
            }

            DBGPRINTF(( DBG_CONTEXT,
                        "\r\n"
                        "  HSE_REQ_EXEC_UNICODE_URL[%p]: Function Entry\r\n"
                        "    URL: '%s'\r\n"
                        "    Method: '%s'\r\n"
                        "    Child Headers: '%s'\r\n"
                        "    Flags: 0x%08x (%d)\r\n"
                        "    Impersonation Token: %p\r\n"
                        "    Custom User Name: '%s'\r\n"
                        "    Custom Auth Type: '%s'\r\n"
                        "  <END>\r\n\r\n",
                        pIsapiContext,
                        pInfo ? pInfo->pszUrl : NULL,
                        pInfo ? pInfo->pszMethod : NULL,
                        pInfo ? pInfo->pszChildHeaders : NULL,
                        pInfo ? pInfo->dwExecUrlFlags : 0,
                        pInfo ? pInfo->dwExecUrlFlags : 0,
                        pUserInfo ? pUserInfo->hImpersonationToken : NULL,
                        pUserInfo ? pUserInfo->pszCustomUserName : NULL,
                        pUserInfo ? pUserInfo->pszCustomAuthType : NULL ));
        }

        IF_DEBUG( ISAPI_DUMP_BUFFERS )
        {
            if ( pEntityInfo )
            {
                STACK_STRA( strBufferDump,512 );
                DWORD       dwBytesToDump = pEntityInfo->cbAvailable;

                if ( dwBytesToDump > MAX_DEBUG_DUMP )
                {
                    dwBytesToDump = MAX_DEBUG_DUMP;
                }

                if ( FAILED( strBufferDump.CopyBinary( pEntityInfo->lpbData, dwBytesToDump ) ) )
                {
                    strBufferDump.Copy( "" );
                }

                DBGPRINTF(( DBG_CONTEXT,
                            "\r\n"
                            "  HSE_REQ_EXEC_URL[%p]: Dump of up to %d bytes of entity\r\n"
                            "%s"
                            "  <END>\r\n\r\n",
                            pIsapiContext,
                            MAX_DEBUG_DUMP,
                            strBufferDump.QueryStr() ));
            }
        }
    }

    pIsapiCore = pIsapiContext->QueryIsapiCoreInterface();

    if ( pIsapiCore == NULL )
    {
        IF_DEBUG( ISAPI_ERROR_RETURNS )
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "\r\n"
                        "  HSE_REQ_EXEC_URL[%p]: Failed to get interface to server core\r\n"
                        "  <END>\r\n\r\n",
                        pIsapiContext ));
        }

        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }

    if ( pOrigExecUrlInfo == NULL )
    {
        IF_DEBUG( ISAPI_ERROR_RETURNS )
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "\r\n"
                        "  HSE_REQ_EXEC_URL[%p]: Parameter validation failure\r\n"
                        "    ExecUrl Info: NULL\r\n"
                        "  <END>\r\n\r\n",
                        pIsapiContext ));
        }

        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }

    //
    // This is an async call, make sure a completion routine is set
    //

    if ( pIsapiContext->QueryPfnIoCompletion() == NULL )
    {
        IF_DEBUG( ISAPI_ERROR_RETURNS )
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "\r\n"
                        "  HSE_REQ_EXEC_URL[%p]: Failed\r\n"
                        "    No I/O completion has been set: NULL\r\n"
                        "  <END>\r\n\r\n",
                        pIsapiContext ));
        }

        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }

    if ( pIsapiContext->TryInitAsyncIo( AsyncExecPending ) == FALSE )
    {
        IF_DEBUG( ISAPI_ERROR_RETURNS )
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "\r\n"
                        "  HSE_REQ_EXEC_URL[%p]: Failed\r\n"
                        "    An async operation is already pending: NULL\r\n"
                        "  <END>\r\n\r\n",
                        pIsapiContext ));
        }

        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }

    //
    // If any of the optional parameters are not NULL, then ensure they are
    // not empty.  Also, copy parameters to the marshallable structure
    //
    // Note that any failures from here on down need to goto Done so
    // that we properly uninitialize async IO.
    //

    if (fIsUnicode)
    {
        HSE_EXEC_UNICODE_URL_INFO *pExecUnicodeUrlInfo =
                    (HSE_EXEC_UNICODE_URL_INFO *)pOrigExecUrlInfo;

        if ( pExecUnicodeUrlInfo->pszUrl != NULL )
        {
            if ( pExecUnicodeUrlInfo->pszUrl[ 0 ] == L'\0' ) 
            {
                IF_DEBUG( ISAPI_ERROR_RETURNS )
                {
                    DBGPRINTF(( DBG_CONTEXT,
                                "\r\n"
                                "  HSE_REQ_EXEC_UNICODE_URL[%p]: Parameter validation failure\r\n"
                                "    URL is an empty string.\r\n"
                                "  <END>\r\n\r\n",
                                pIsapiContext ));
                }

                hr = HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
                goto Done;
            }

            UrlInfo.fIsUrlUnicode = TRUE;
            UrlInfo.pszUrl = (BYTE *)pExecUnicodeUrlInfo->pszUrl;
            UrlInfo.cbUrl = (DWORD)(wcslen(pExecUnicodeUrlInfo->pszUrl) + 1)*sizeof(WCHAR);
        }
        else
        {
            UrlInfo.pszUrl = NULL;
            UrlInfo.cbUrl = 0;
        }

        if ( pExecUnicodeUrlInfo->pszMethod != NULL )
        {
            if ( pExecUnicodeUrlInfo->pszMethod[ 0 ] == '\0' )
            {
                IF_DEBUG( ISAPI_ERROR_RETURNS )
                {
                    DBGPRINTF(( DBG_CONTEXT,
                                "\r\n"
                                "  HSE_REQ_EXEC_UNICODE_URL[%p]: Parameter validation failure\r\n"
                                "    Method is an empty string\r\n"
                                "  <END>\r\n\r\n",
                                pIsapiContext ));
                }

                hr = HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
                goto Done;
            }
        }
        UrlInfo.pszMethod = pExecUnicodeUrlInfo->pszMethod;

        if ( pExecUnicodeUrlInfo->pszChildHeaders != NULL )
        {
            if ( pExecUnicodeUrlInfo->pszChildHeaders[ 0 ] == '\0' )
            {
                IF_DEBUG( ISAPI_ERROR_RETURNS )
                {
                    DBGPRINTF(( DBG_CONTEXT,
                                "\r\n"
                                "  HSE_REQ_EXEC_UNICODE_URL[%p]: Parameter validation failure\r\n"
                                "    ChildHeaders is an empty string\r\n"
                                "  <END>\r\n\r\n",
                                pIsapiContext ));
                }

                hr = HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
                goto Done;
            }
        }
        UrlInfo.pszChildHeaders = pExecUnicodeUrlInfo->pszChildHeaders;

        if ( pExecUnicodeUrlInfo->pUserInfo != NULL )
        {
            if ( pExecUnicodeUrlInfo->pUserInfo->pszCustomUserName == NULL )
            {
                IF_DEBUG( ISAPI_ERROR_RETURNS )
                {
                    DBGPRINTF(( DBG_CONTEXT,
                                "\r\n"
                                "  HSE_REQ_EXEC_UNICODE_URL[%p]: Parameter validation failure\r\n"
                                "    Custom User Name: NULL\r\n"
                                "  <END>\r\n\r\n",
                                pIsapiContext ));
                }

                hr = HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
                goto Done;
            }
        
            if ( pExecUnicodeUrlInfo->pUserInfo->pszCustomAuthType == NULL )
            {
                IF_DEBUG( ISAPI_ERROR_RETURNS )
                {
                    DBGPRINTF(( DBG_CONTEXT,
                                "\r\n"
                                "  HSE_REQ_EXEC_UNICODE_URL[%p]: Parameter validation failure\r\n"
                                "    Custom Auth Type: NULL\r\n"
                                "  <END>\r\n\r\n",
                                pIsapiContext ));
                }

                hr = HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
                goto Done;
            }

            UserName.fIsUserNameUnicode = TRUE;
            UserName.pszUserName = (BYTE *)pExecUnicodeUrlInfo->pUserInfo->pszCustomUserName;
            UserName.cbUserName = (DWORD)(wcslen(pExecUnicodeUrlInfo->pUserInfo->pszCustomUserName) + 1)*sizeof(WCHAR);
            UserName.pszAuthType = pExecUnicodeUrlInfo->pUserInfo->pszCustomAuthType;
            UserName.hImpersonationToken = (DWORD_PTR)pExecUnicodeUrlInfo->pUserInfo->hImpersonationToken;
            UrlInfo.pUserInfo = &UserName;
        }
        else
        {
            UrlInfo.pUserInfo = NULL;
        }

        //
        // If we are being told that there is available entity, ensure
        // that the buffer is not NULL
        //

        if ( pExecUnicodeUrlInfo->pEntity != NULL )
        {
            if ( pExecUnicodeUrlInfo->pEntity->cbAvailable != 0 &&
                 pExecUnicodeUrlInfo->pEntity->lpbData == NULL )
            {
                IF_DEBUG( ISAPI_ERROR_RETURNS )
                {
                    DBGPRINTF(( DBG_CONTEXT,
                                "\r\n"
                                "  HSE_REQ_EXEC_UNICODE_URL[%p]: Parameter validation failure\r\n"
                                "    Available Entity bytes: %d\r\n"
                                "    Available Entity Ptr: %p\r\n"
                                "  <END>\r\n\r\n",
                                pIsapiContext,
                                pExecUnicodeUrlInfo->pEntity->cbAvailable,
                                pExecUnicodeUrlInfo->pEntity->lpbData ));
                }

                hr = HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
                goto Done;
            }

            Entity.cbAvailable = pExecUnicodeUrlInfo->pEntity->cbAvailable;
            Entity.lpbData = (BYTE *)pExecUnicodeUrlInfo->pEntity->lpbData;
        }
        else
        {
            //
            // If no entity body was set for this child execute, then
            // we should duplicate the original entity body.  This means
            // we will need to bring over the preloaded entity for the
            // ISAPI which calls this routine.
            //

            Entity.cbAvailable = pIsapiContext->QueryECB()->cbAvailable;
            Entity.lpbData = pIsapiContext->QueryECB()->lpbData;
        }
        UrlInfo.pEntity = &Entity;

        UrlInfo.dwExecUrlFlags = pExecUnicodeUrlInfo->dwExecUrlFlags;
    }
    else
    {
        HSE_EXEC_URL_INFO *pExecAnsiUrlInfo = 
                        (HSE_EXEC_URL_INFO *)pOrigExecUrlInfo;

        if ( pExecAnsiUrlInfo->pszUrl != NULL )
        {
            if ( pExecAnsiUrlInfo->pszUrl[ 0 ] == '\0' ) 
            {
                IF_DEBUG( ISAPI_ERROR_RETURNS )
                {
                    DBGPRINTF(( DBG_CONTEXT,
                                "\r\n"
                                "  HSE_REQ_EXEC_URL[%p]: Parameter validation failure\r\n"
                                "    URL is an empty string\r\n"
                                "  <END>\r\n\r\n",
                                pIsapiContext ));
                }

                hr = HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
                goto Done;
            }

            UrlInfo.fIsUrlUnicode = FALSE;
            UrlInfo.pszUrl = (BYTE *)pExecAnsiUrlInfo->pszUrl;
            UrlInfo.cbUrl = (DWORD)strlen(pExecAnsiUrlInfo->pszUrl) + 1;
        }
        else
        {
            UrlInfo.pszUrl = NULL;
            UrlInfo.cbUrl = 0;
        }

        if ( pExecAnsiUrlInfo->pszMethod != NULL )
        {
            if ( pExecAnsiUrlInfo->pszMethod[ 0 ] == '\0' )
            {
                IF_DEBUG( ISAPI_ERROR_RETURNS )
                {
                    DBGPRINTF(( DBG_CONTEXT,
                                "\r\n"
                                "  HSE_REQ_EXEC_URL[%p]: Parameter validation failure\r\n"
                                "    Method is an empty string\r\n"
                                "  <END>\r\n\r\n",
                                pIsapiContext ));
                }

                hr = HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
                goto Done;
            }
        }
        UrlInfo.pszMethod = pExecAnsiUrlInfo->pszMethod;

        if ( pExecAnsiUrlInfo->pszChildHeaders != NULL )
        {
            if ( pExecAnsiUrlInfo->pszChildHeaders[ 0 ] == '\0' )
            {
                IF_DEBUG( ISAPI_ERROR_RETURNS )
                {
                    DBGPRINTF(( DBG_CONTEXT,
                                "\r\n"
                                "  HSE_REQ_EXEC_URL[%p]: Parameter validation failure\r\n"
                                "    ChildHeaders is an empty string\r\n"
                                "  <END>\r\n\r\n",
                                pIsapiContext ));
                }

                hr = HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
                goto Done;
            }
        }
        UrlInfo.pszChildHeaders = pExecAnsiUrlInfo->pszChildHeaders;

        if ( pExecAnsiUrlInfo->pUserInfo != NULL )
        {
            if ( pExecAnsiUrlInfo->pUserInfo->pszCustomUserName == NULL )
            {
                IF_DEBUG( ISAPI_ERROR_RETURNS )
                {
                    DBGPRINTF(( DBG_CONTEXT,
                                "\r\n"
                                "  HSE_REQ_EXEC_URL[%p]: Parameter validation failure\r\n"
                                "    Custom User Name: NULL\r\n"
                                "  <END>\r\n\r\n",
                                pIsapiContext ));
                }

                hr = HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
                goto Done;
            }
        
            if ( pExecAnsiUrlInfo->pUserInfo->pszCustomAuthType == NULL )
            {
                IF_DEBUG( ISAPI_ERROR_RETURNS )
                {
                    DBGPRINTF(( DBG_CONTEXT,
                                "\r\n"
                                "  HSE_REQ_EXEC_URL[%p]: Parameter validation failure\r\n"
                                "    Custom Auth Type: NULL\r\n"
                                "  <END>\r\n\r\n",
                                pIsapiContext ));
                }

                hr = HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
                goto Done;
            }

            UserName.fIsUserNameUnicode = FALSE;
            UserName.pszUserName = (BYTE *)pExecAnsiUrlInfo->pUserInfo->pszCustomUserName;
            UserName.cbUserName = (DWORD)strlen(pExecAnsiUrlInfo->pUserInfo->pszCustomUserName) + 1;
            UserName.pszAuthType = pExecAnsiUrlInfo->pUserInfo->pszCustomAuthType;
            UserName.hImpersonationToken = (DWORD_PTR)pExecAnsiUrlInfo->pUserInfo->hImpersonationToken;
            UrlInfo.pUserInfo = &UserName;
        }
        else
        {
            UrlInfo.pUserInfo = NULL;
        }

        //
        // If we are being told that there is available entity, ensure
        // that the buffer is not NULL
        //

        if ( pExecAnsiUrlInfo->pEntity != NULL )
        {
            if ( pExecAnsiUrlInfo->pEntity->cbAvailable != 0 &&
                 pExecAnsiUrlInfo->pEntity->lpbData == NULL )
            {
                IF_DEBUG( ISAPI_ERROR_RETURNS )
                {
                    DBGPRINTF(( DBG_CONTEXT,
                                "\r\n"
                                "  HSE_REQ_EXEC_URL[%p]: Parameter validation failure\r\n"
                                "    Available Entity Bytes: %d\r\n"
                                "    Available Entity Ptr: %p\r\n"
                                "  <END>\r\n\r\n",
                                pIsapiContext,
                                pExecAnsiUrlInfo->pEntity->cbAvailable,
                                pExecAnsiUrlInfo->pEntity->lpbData ));
                }

                hr = HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
                goto Done;
            }

            Entity.cbAvailable = pExecAnsiUrlInfo->pEntity->cbAvailable;
            Entity.lpbData = (BYTE *)pExecAnsiUrlInfo->pEntity->lpbData;
        }
        else
        {
            //
            // If no entity body was set for this child execute, then
            // we should duplicate the original entity body.  This means
            // we will need to bring over the preloaded entity for the
            // ISAPI which calls this routine.
            //

            Entity.cbAvailable = pIsapiContext->QueryECB()->cbAvailable;
            Entity.lpbData = pIsapiContext->QueryECB()->lpbData;
        }
        UrlInfo.pEntity = &Entity;

        UrlInfo.dwExecUrlFlags = pExecAnsiUrlInfo->dwExecUrlFlags;
    }

    //
    // All the heavy lifting is in W3CORE.DLL
    //

    hr = pIsapiCore->ExecuteUrl(
        reinterpret_cast<DWORD64>( pIsapiContext ),
        &UrlInfo
        );

Done:

    if ( FAILED( hr ) )
    {
        IF_DEBUG( ISAPI_ERROR_RETURNS )
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "\r\n"
                        "  HSE_REQ_EXEC_URL[%p]: Failed\r\n"
                        "    Error: 0x%08x\r\n"
                        "  <END>\r\n\r\n",
                        pIsapiContext,
                        hr ));
        }

        pIsapiContext->UninitAsyncIo();
    }

    return hr;
}

HRESULT
SSFGetExecuteUrlStatus(
    ISAPI_CONTEXT *         pIsapiContext,
    HSE_EXEC_URL_STATUS*    pExecUrlStatus
    )
/*++

Routine Description:

    Get status of last child execute

Arguments:

    pIsapiContext  - The ISAPI_CONTEXT associated with this command.
    pExecUrlStatus - Filled with status
    
Return Value:

    HRESULT

--*/
{
    IIsapiCore *    pIsapiCore;
    HRESULT         hr;

    DBG_ASSERT( pIsapiContext );
    DBG_ASSERT( pIsapiContext->CheckSignature() );

    IF_DEBUG( ISAPI_SSF_DETAILS )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "\r\n"
                    "  HSE_REQ_GET_EXEC_URL_STATUS[%p]: Function Entry\r\n"
                    "  <END>\r\n\r\n",
                    pIsapiContext ));
    }

    pIsapiCore = pIsapiContext->QueryIsapiCoreInterface();

    if ( pIsapiCore == NULL )
    {
        IF_DEBUG( ISAPI_ERROR_RETURNS )
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "\r\n"
                        "  HSE_REQ_GET_EXEC_URL_STATUS[%p]: Failed to get interface to server core\r\n"
                        "  <END>\r\n\r\n",
                        pIsapiContext ));
        }

        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }

    if ( pExecUrlStatus == NULL )
    {
        IF_DEBUG( ISAPI_ERROR_RETURNS )
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "\r\n"
                        "  HSE_REQ_GET_EXEC_URL_STATUS[%p]: Parameter validation failure\r\n"
                        "    EXEC_URL Status Ptr: NULL\r\n"
                        "  <END>\r\n\r\n",
                        pIsapiContext ));
        }

        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }

    hr = pIsapiCore->GetExecuteUrlStatus( 
        &(pExecUrlStatus->uHttpStatusCode),
        &(pExecUrlStatus->uHttpSubStatus),
        &(pExecUrlStatus->dwWin32Error)
        );

    if ( FAILED( hr ) )
    {
        IF_DEBUG( ISAPI_ERROR_RETURNS )
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "\r\n"
                        "  HSE_REQ_GET_EXEC_URL_STATUS[%p]: Failed\r\n"
                        "    Error: 0x%08x\r\n"
                        "  <END>\r\n\r\n",
                        pIsapiContext,
                        hr ));
        }

        return hr;
    }

    return hr;
}

HRESULT
SSFSendCustomError(
    ISAPI_CONTEXT *         pIsapiContext,
    HSE_CUSTOM_ERROR_INFO * pCustomErrorInfo
    )
/*++

Routine Description:

    Send custom error to client

Arguments:

    pIsapiContext - The ISAPI_CONTEXT associated with this command.
    pCustomErrorInfo - Describes the custom error to send
    
Return Value:

    HRESULT

--*/
{
    IIsapiCore *    pIsapiCore;
    HRESULT         hr = NOERROR;

    DBG_ASSERT( pIsapiContext );
    DBG_ASSERT( pIsapiContext->CheckSignature() );

    IF_DEBUG( ISAPI_SSF_DETAILS )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "\r\n"
                    "  HSE_REQ_SEND_CUSTOM_ERROR[%p]: Function Entry\r\n"
                    "    Status: '%s'\r\n"
                    "    SubError Code: %d\r\n"
                    "  <END>\r\n\r\n",
                    pIsapiContext,
                    pCustomErrorInfo ? pCustomErrorInfo->pszStatus : NULL,
                    pCustomErrorInfo ? pCustomErrorInfo->uHttpSubError : 0 ));
    }

    pIsapiCore = pIsapiContext->QueryIsapiCoreInterface();

    if ( pIsapiCore == NULL )
    {
        IF_DEBUG( ISAPI_ERROR_RETURNS )
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "\r\n"
                        "  HSE_REQ_SEND_CUSTOM_ERROR[%p]: Failed to get interface to server core\r\n"
                        "  <END>\r\n\r\n",
                        pIsapiContext ));
        }

        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }

    if ( pCustomErrorInfo == NULL )
    {
        IF_DEBUG( ISAPI_ERROR_RETURNS )
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "\r\n"
                        "  HSE_REQ_SEND_CUSTOM_ERROR[%p]: Parameter validation failure\r\n"
                        "    Custom Error Info Ptr: NULL\r\n"
                        "  <END>\r\n\r\n",
                        pIsapiContext ));
        }

        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }
    
    //
    // Ensure status is not empty
    //
    
    if ( pCustomErrorInfo->pszStatus != NULL )
    {
        if ( pCustomErrorInfo->pszStatus[ 0 ] == '\0' )
        {
            IF_DEBUG( ISAPI_ERROR_RETURNS )
            {
                DBGPRINTF(( DBG_CONTEXT,
                            "\r\n"
                            "  HSE_REQ_SEND_CUSTOM_ERROR[%p]: Parameter validation failure\r\n"
                            "    Status is an empty string\r\n"
                            "  <END>\r\n\r\n",
                            pIsapiContext ));
            }

            return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
        }
    }

    //
    // If this is an async call, then make sure a completion routine is set
    //
    
    if ( pCustomErrorInfo->fAsync )
    {
        if ( pIsapiContext->TryInitAsyncIo( AsyncExecPending ) == FALSE )
        {
            IF_DEBUG( ISAPI_ERROR_RETURNS )
            {
                DBGPRINTF(( DBG_CONTEXT,
                            "\r\n"
                            "  HSE_REQ_SEND_CUSTOM_ERROR[%p]: Failed\r\n"
                            "    Another async operation is already pending\r\n"
                            "  <END>\r\n\r\n",
                            pIsapiContext ));
            }

            return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
        }
    }

    hr = pIsapiCore->SendCustomError(
        pCustomErrorInfo->fAsync ? reinterpret_cast<DWORD64>( pIsapiContext ) : NULL,
        pCustomErrorInfo->pszStatus,
        pCustomErrorInfo->uHttpSubError );

    if ( FAILED( hr ) )
    {
        IF_DEBUG( ISAPI_ERROR_RETURNS )
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "\r\n"
                        "  HSE_REQ_SEND_CUSTOM_ERROR[%p]: Failed\r\n"
                        "    Error: 0x%08x\r\n"
                        "  <END>\r\n\r\n",
                        pIsapiContext,
                        hr ));
        }

        if ( pCustomErrorInfo->fAsync )
        {
            pIsapiContext->UninitAsyncIo();
        }

        return hr;
    }

    return hr;
}

HRESULT
SSFVectorSendDeprecated(
    ISAPI_CONTEXT *         pIsapiContext,
    HSE_RESPONSE_VECTOR_DEPRECATED *   pResponseVector
    )
/*++

Routine Description:

    The old deprecated vector-send

Arguments:

    pIsapiContext   - The ISAPI_CONTEXT associated with this command.
    pResponseVector - The vector to be sent
    
Return Value:

    HRESULT

--*/
{
    HSE_RESPONSE_VECTOR RealResponseVector;
    STACK_BUFFER(       buffResp, 512);
    HRESULT             hr;

    IF_DEBUG( ISAPI_SSF_DETAILS )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "\r\n"
                    "  HSE_REQ_VECTOR_SEND_DEPRECATED[%p]: Function Entry\r\n"
                    "  <END>\r\n\r\n",
                    pIsapiContext ));
    }

    if ( pResponseVector == NULL )
    {
        IF_DEBUG( ISAPI_ERROR_RETURNS )
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "\r\n"
                        "  HSE_REQ_VECTOR_SEND_DEPRECATED[%p]: Parameter validation failure\r\n"
                        "    Response Vector Ptr: NULL\r\n"
                        "  <END>\r\n\r\n",
                        pIsapiContext ));
        }

        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }

    RealResponseVector.dwFlags = pResponseVector->dwFlags;
    RealResponseVector.pszStatus = pResponseVector->pszStatus;
    RealResponseVector.pszHeaders = pResponseVector->pszHeaders;
    RealResponseVector.nElementCount = pResponseVector->nElementCount;

    if (!buffResp.Resize(pResponseVector->nElementCount * sizeof(HSE_VECTOR_ELEMENT)))
    {
        return HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );
    }
    RealResponseVector.lpElementArray = (HSE_VECTOR_ELEMENT *)buffResp.QueryPtr();

    for (DWORD i=0; i<pResponseVector->nElementCount; i++)
    {
        if (pResponseVector->lpElementArray[i].pBuffer != NULL)
        {
            RealResponseVector.lpElementArray[i].ElementType = HSE_VECTOR_ELEMENT_TYPE_MEMORY_BUFFER;
            RealResponseVector.lpElementArray[i].pvContext = pResponseVector->lpElementArray[i].pBuffer;
            RealResponseVector.lpElementArray[i].cbSize = pResponseVector->lpElementArray[i].cbSize;
        }
        else
        {
            RealResponseVector.lpElementArray[i].ElementType = HSE_VECTOR_ELEMENT_TYPE_FILE_HANDLE;
            RealResponseVector.lpElementArray[i].pvContext = pResponseVector->lpElementArray[i].hFile;
            RealResponseVector.lpElementArray[i].cbOffset = pResponseVector->lpElementArray[i].cbOffset;
            RealResponseVector.lpElementArray[i].cbSize = pResponseVector->lpElementArray[i].cbSize;
        }
    }

    hr = SSFVectorSend(pIsapiContext, &RealResponseVector);

    if ( FAILED( hr ) )
    {
        IF_DEBUG( ISAPI_ERROR_RETURNS )
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "\r\n"
                        "  HSE_REQ_VECTOR_SEND_DEPRECATED[%p]: Failed\r\n"
                        "    Error: 0x%08x\r\n"
                        "  <END>\r\n\r\n",
                        pIsapiContext,
                        hr ));
        }

        return hr;
    }

    return hr;
}

HRESULT
SSFVectorSend(
    ISAPI_CONTEXT *         pIsapiContext,
    HSE_RESPONSE_VECTOR *   pResponseVector
    )
/*++

Routine Description:

    Send an array of memory/file-handle/fragment-cache chunks

Arguments:

    pIsapiContext   - The ISAPI_CONTEXT associated with this command.
    pResponseVector - The vector to be sent
    
Return Value:

    HRESULT

--*/
{
    IIsapiCore *    pIsapiCore;
    ULONGLONG       cbTotalSend = 0;
    STACK_BUFFER(   buffResp, 512);
    HRESULT         hr = NOERROR;

    DBG_ASSERT( pIsapiContext );
    DBG_ASSERT( pIsapiContext->CheckSignature() );

    IF_DEBUG( ISAPI_SSF_DETAILS )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "\r\n"
                    "  HSE_REQ_VECTOR_SEND[%p]: Function Entry (%s)\r\n"
                    "    Status: '%s'\r\n"
                    "    Headers: '%s'\r\n"
                    "    Element Count: %d\r\n"
                    "    Flags: 0x%08x (%d)\r\n"
                    "  <END>\r\n\r\n",
                    pIsapiContext,
                    pResponseVector ? pResponseVector->dwFlags & HSE_IO_ASYNC ? "Asynchronous" : "Synchronous" : "",
                    pResponseVector ? pResponseVector->pszStatus : NULL,
                    pResponseVector ? pResponseVector->pszHeaders : NULL,
                    pResponseVector ? pResponseVector->nElementCount : 0,
                    pResponseVector ? pResponseVector->dwFlags : 0,
                    pResponseVector ? pResponseVector->dwFlags : 0 ));

        IF_DEBUG( ISAPI_DUMP_BUFFERS )
        {
            if ( pResponseVector &&
                 pResponseVector->nElementCount )
            {
                STACK_STRA( strBufferDump,512 );
                DWORD       dwBytesToDump;
                DWORD       i;

                for ( i = 0; i < pResponseVector->nElementCount; i++ )
                {
                    if ( pResponseVector->lpElementArray[i].ElementType == HSE_VECTOR_ELEMENT_TYPE_MEMORY_BUFFER )
                    {
                        dwBytesToDump = pResponseVector->lpElementArray[i].cbSize;
                        
                        if ( dwBytesToDump > MAX_DEBUG_DUMP )
                        {
                            dwBytesToDump = MAX_DEBUG_DUMP;
                        }

                        if ( FAILED( strBufferDump.CopyBinary( pResponseVector->lpElementArray[i].pvContext, dwBytesToDump ) ) )
                        {
                            strBufferDump.Copy( "" );
                        }

                        DBGPRINTF(( DBG_CONTEXT,
                                    "\r\n"
                                    "  HSE_REQ_VECTOR_SEND[%p]: Dump of up to %d bytes of element %d\r\n"
                                    "%s"
                                    "  <END>\r\n\r\n",
                                    pIsapiContext,
                                    MAX_DEBUG_DUMP,
                                    i,
                                    strBufferDump.QueryStr() ));
                    }
                    else if ( pResponseVector->lpElementArray[i].ElementType == HSE_VECTOR_ELEMENT_TYPE_FILE_HANDLE )
                    {
                        DBGPRINTF(( DBG_CONTEXT,
                                    "\r\n",
                                    "  HSE_REQ_VECTOR_SEND[%p]: Element %d\r\n"
                                    "    File Handle: %p\r\n"
                                    "    Offset: %d\r\n"
                                    "    Bytes To Send: %d\r\n"
                                    "  <END>\r\n\r\n",
                                    pIsapiContext,
                                    pResponseVector->lpElementArray[i].pvContext,
                                    pResponseVector->lpElementArray[i].cbOffset,
                                    pResponseVector->lpElementArray[i].cbSize ));
                    }
                }
            }
        }
    }

    pIsapiCore = pIsapiContext->QueryIsapiCoreInterface();

    if ( pIsapiCore == NULL )
    {
        IF_DEBUG( ISAPI_ERROR_RETURNS )
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "\r\n"
                        "  HSE_REQ_VECTOR_SEND[%p]: Failed to get interface to server core\r\n"
                        "  <END>\r\n\r\n",
                        pIsapiContext ));
        }

        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }

    //
    // verify the data passed in
    //

    if ( pResponseVector == NULL ||
         ( ( pResponseVector->dwFlags & HSE_IO_ASYNC ) != 0 &&
           pIsapiContext->TryInitAsyncIo( AsyncVectorPending ) == FALSE ) )
    {
        IF_DEBUG( ISAPI_ERROR_RETURNS )
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "\r\n"
                        "  HSE_REQ_VECTOR_SEND[%p]: Failed\r\n"
                        "    Another async operation is already pending\r\n"
                        "  <END>\r\n\r\n",
                        pIsapiContext ));
        }

        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }

    if ((pResponseVector->dwFlags & HSE_IO_SYNC) &&
        (pResponseVector->dwFlags & HSE_IO_ASYNC))
    {
        IF_DEBUG( ISAPI_ERROR_RETURNS )
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "\r\n"
                        "  HSE_REQ_VECTOR_SEND[%p]: Parameter validation failure\r\n"
                        "    Both HSE_IO_SYNC and HSE_IO_ASYNC were specified\r\n"
                        "  <END>\r\n\r\n",
                        pIsapiContext ));
        }

        hr =  HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
        goto Failed;
    }

    if (pResponseVector->dwFlags & HSE_IO_SEND_HEADERS)
    {
        if ((pResponseVector->pszStatus == NULL) ||
            (pResponseVector->pszHeaders == NULL))
        {
            IF_DEBUG( ISAPI_ERROR_RETURNS )
            {
                DBGPRINTF(( DBG_CONTEXT,
                            "\r\n"
                            "  HSE_REQ_VECTOR_SEND[%p]: Parameter validation failure\r\n"
                            "    HSE_IO_SEND_HEADERS was specified, but some required info is missing\r\n"
                            "    Status: '%s'\r\n"
                            "    Headers: '%s'\r\n"
                            "  <END>\r\n\r\n",
                            pIsapiContext,
                            pResponseVector->pszStatus,
                            pResponseVector->pszHeaders ));
            }

            hr = HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
            goto Failed;
        }
    }
    else
    {
        if ((pResponseVector->pszStatus != NULL) ||
            (pResponseVector->pszHeaders != NULL))
        {
            IF_DEBUG( ISAPI_ERROR_RETURNS )
            {
                DBGPRINTF(( DBG_CONTEXT,
                            "\r\n"
                            "  HSE_REQ_VECTOR_SEND[%p]: Parameter validation failure\r\n"
                            "    HSE_IO_SEND_HEADERS was not specified, yet status or header info was provided\r\n"
                            "    Status: '%s'\r\n"
                            "    Headers: '%s'\r\n"
                            "  <END>\r\n\r\n",
                            pIsapiContext,
                            pResponseVector->pszStatus,
                            pResponseVector->pszHeaders ));
            }

            hr = HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
            goto Failed;
        }
    }

    if (!buffResp.Resize(pResponseVector->nElementCount * sizeof(VECTOR_ELEMENT)))
    {
        hr = HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );
        goto Failed;
    }
    ZeroMemory(buffResp.QueryPtr(),
               pResponseVector->nElementCount * sizeof(VECTOR_ELEMENT));

    VECTOR_ELEMENT *pVectorElement = (VECTOR_ELEMENT *)buffResp.QueryPtr();
    HSE_VECTOR_ELEMENT *pHseVectorElement;

    for (DWORD i=0; i<pResponseVector->nElementCount; i++)
    {
        pHseVectorElement = &pResponseVector->lpElementArray[i];

        if (pHseVectorElement->pvContext == NULL)
        {
            IF_DEBUG( ISAPI_ERROR_RETURNS )
            {
                DBGPRINTF(( DBG_CONTEXT,
                            "\r\n"
                            "  HSE_REQ_VECTOR_SEND[%p]: Parameter validation failure\r\n"
                            "    Context: NULL on element %d in the array\r\n"
                            "  <END>\r\n\r\n",
                            pIsapiContext,
                            i ));
            }

            hr = HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
            goto Failed;
        }

        switch (pHseVectorElement->ElementType)
        {
        case HSE_VECTOR_ELEMENT_TYPE_MEMORY_BUFFER:
            if (pHseVectorElement->cbSize > MAXULONG)
            {
                IF_DEBUG( ISAPI_ERROR_RETURNS )
                {
                    DBGPRINTF(( DBG_CONTEXT,
                                "\r\n"
                                "  HSE_REQ_VECTOR_SEND[%p]: Parameter validation failure\r\n"
                                "    Invalid memory buffer size on element %d in the array\r\n"
                                "    Size: %d\r\n"
                                "  <END>\r\n\r\n",
                                pIsapiContext,
                                i,
                                pHseVectorElement->cbSize ));
                }

                hr = HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
                goto Failed;
            }

            pVectorElement[i].pBuffer = (BYTE *)pHseVectorElement->pvContext;
            cbTotalSend += ( pVectorElement[i].cbBufSize = (DWORD)pHseVectorElement->cbSize );
            break;

        case HSE_VECTOR_ELEMENT_TYPE_FILE_HANDLE:
            if (pHseVectorElement->pvContext == INVALID_HANDLE_VALUE)
            {
                IF_DEBUG( ISAPI_ERROR_RETURNS )
                {
                    DBGPRINTF(( DBG_CONTEXT,
                                "\r\n"
                                "  HSE_REQ_VECTOR_SEND[%p]: Parameter validation failure\r\n"
                                "    Handle on file handle element %d in the array is invalid\r\n"
                                "    File Handle: %p\r\n"
                                "  <END>\r\n\r\n",
                                pIsapiContext,
                                i,
                                pHseVectorElement->pvContext ));
                }

                hr = HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
                goto Failed;
            }

            //
            // Treat 0 as "send the rest of the file" - same as TransmitFile
            //
            if (pHseVectorElement->cbSize == 0)
            {
                pHseVectorElement->cbSize = HTTP_BYTE_RANGE_TO_EOF;
            }

            pVectorElement[i].hFile = (DWORD_PTR)pHseVectorElement->pvContext;
            pVectorElement[i].cbOffset = pHseVectorElement->cbOffset;
            cbTotalSend += ( pVectorElement[i].cbFileSize = pHseVectorElement->cbSize );
            break;

        case HSE_VECTOR_ELEMENT_TYPE_FRAGMENT:
            pVectorElement[i].pszFragmentName = (WCHAR *)pHseVectorElement->pvContext;
            break;

        default:
            IF_DEBUG( ISAPI_ERROR_RETURNS )
            {
                DBGPRINTF(( DBG_CONTEXT,
                            "\r\n"
                            "  HSE_REQ_VECTOR_SEND[%p]: Parameter validation failure\r\n"
                            "    Unknown type on element %d in the array\r\n"
                            "    Element Type: %d\r\n"
                            "  <END>\r\n\r\n",
                            pIsapiContext,
                            i,
                            pHseVectorElement->ElementType ));
            }

            hr = HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);
            goto Failed;
        }
    }

    //
    // Set up the total number of bytes we are trying to send so that ISAPIs
    // are not confused
    //
    pIsapiContext->SetLastAsyncIo( (cbTotalSend > MAXULONG) ? MAXULONG : (DWORD)cbTotalSend );
 
    //
    // In general, VECTOR_SEND shouldn't touch the connection flags
    // in the ISAPI_CONTEXT, since ISAPI tries to do the right thing
    // automatically.
    //
    // There are couple of scenarios, though, where we might have a
    // bit of connection management housekeeping to do.
    //
    // If the caller specified the HSE_IO_DISCONNECT_AFTER_SEND flag,
    // then we need to force the connection closed.
    //
    // Otherwise, there are two scenarios where we may need to force
    // the connection to stay open.
    //
    // First, if all of the below are true, we should set the
    // connection to be open:
    //
    //  - The client requested keep-alive
    //  - This call is sending headers (HSE_IO_SEND_HEADERS is set)
    //  - The disconnect flag has not been set
    //
    // Second, if all of the below are true, we should set the
    // connection to be open.
    //
    //  - The client requested keep-alive
    //  - The ISAPI has not already sent headers
    //  - The disconnect flag has not been set
    //  - This is the final send
    //
    // One final note:  This logic does not account for the case where
    // this call is sending headers, and the call fails for some reason.
    // In the asynchronous case, this would be somewhat complicated to
    // handle, since the completion routine would need to know both if
    // the caller was sending headers, and also that the I/O failed.
    // Presumably, if such a failure occurs, the most likely reason is
    // that the client already disconnected, or it would otherwise be
    // unlikely for the caller to do something to try and recover and
    // redo this send in a way that would succeed, which makes all of this
    // moot.
    //

    if ( pResponseVector->dwFlags & HSE_IO_DISCONNECT_AFTER_SEND )
    {
        pIsapiContext->SetKeepConn( FALSE );
    }
    else
    {
        if ( pIsapiContext->QueryClientKeepConn() )
        {
            if ( (pResponseVector->dwFlags & HSE_IO_SEND_HEADERS) ||
                 ( pIsapiContext->QueryHeadersSent() == FALSE &&
                   (pResponseVector->dwFlags & HSE_IO_FINAL_SEND) ) )
            {
                pIsapiContext->SetKeepConn( TRUE );
            }
        }
    }

    hr = pIsapiCore->VectorSend(
        pResponseVector->dwFlags & HSE_IO_ASYNC ? reinterpret_cast<DWORD64>( pIsapiContext ) : NULL,
        !pIsapiContext->QueryKeepConn(),
        pResponseVector->pszStatus,
        pResponseVector->pszHeaders,
        pVectorElement,
        pResponseVector->nElementCount,
        !!(pResponseVector->dwFlags & HSE_IO_FINAL_SEND),
        !!(pResponseVector->dwFlags & HSE_IO_CACHE_RESPONSE)
        );

    if ( FAILED( hr ) )
    {
        goto Failed;
    }

    return hr;

Failed:

    DBG_ASSERT( FAILED( hr ) );

    IF_DEBUG( ISAPI_ERROR_RETURNS )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "\r\n"
                    "  HSE_REQ_VECTOR_SEND[%p]: Failed\r\n"
                    "    Error: 0x%08x\r\n"
                    "  <END>\r\n\r\n",
                    pIsapiContext,
                    hr ));
    }

    if ( pResponseVector->dwFlags & HSE_IO_ASYNC )
    {
        pIsapiContext->SetLastAsyncIo( 0 );
        pIsapiContext->UninitAsyncIo();
    }

    return hr;
}

HRESULT
SSFGetCustomErrorPage(
    ISAPI_CONTEXT *                 pIsapiContext,
    HSE_CUSTOM_ERROR_PAGE_INFO *    pInfo
    )
{
    IIsapiCore *    pIsapiCore;
    HRESULT         hr;

    DBG_ASSERT( pIsapiContext );
    DBG_ASSERT( pIsapiContext->CheckSignature() );

    IF_DEBUG( ISAPI_SSF_DETAILS )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "\r\n"
                    "  HSE_REQ_GET_CUSTOM_ERROR_PAGE[%p]: Function Entry\r\n"
                    "    Error: %d\r\n"
                    "    SubError: %d\r\n"
                    "  <END>\r\n\r\n",
                    pIsapiContext,
                    pInfo ? pInfo->dwError : 0,
                    pInfo ? pInfo->dwSubError : 0 ));
    }

    pIsapiCore = pIsapiContext->QueryIsapiCoreInterface();

    if ( pIsapiCore == NULL )
    {
        IF_DEBUG( ISAPI_ERROR_RETURNS )
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "\r\n"
                        "  HSE_REQ_GET_CUSTOM_ERROR_PAGE[%p]: Failed to get interface to server core\r\n"
                        "  <END>\r\n\r\n",
                        pIsapiContext ));
        }

        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }

    //
    // Validate arguments
    //

    if ( pInfo == NULL || 
         ( pInfo->dwBufferSize != 0 && pInfo->pBuffer == NULL ) ||
         pInfo->pdwBufferRequired == NULL ||
         pInfo->pfIsFileError == NULL )
    {
        IF_DEBUG( ISAPI_ERROR_RETURNS )
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "\r\n"
                        "  HSE_REQ_GET_CUSTOM_ERROR_PAGE[%p]: Parameter validation failure\r\n"
                        "    Info Ptr: %p\r\n"
                        "    Buffer Size: %d\r\n"
                        "    Buffer Ptr: %p\r\n"
                        "    Buffer Required Ptr: %p\r\n"
                        "    IsFileError Ptr: %p\r\n"
                        "  <END>\r\n\r\n",
                        pIsapiContext,
                        pInfo,
                        pInfo ? pInfo->dwBufferSize : 0,
                        pInfo ? pInfo->pBuffer : NULL,
                        pInfo ? pInfo->pdwBufferRequired : NULL,
                        pInfo ? pInfo->pfIsFileError : NULL ));
        }

        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }

    hr = pIsapiCore->GetCustomError(
        pInfo->dwError,
        pInfo->dwSubError,
        pInfo->dwBufferSize,
        reinterpret_cast<BYTE*>( pInfo->pBuffer ),
        pInfo->pdwBufferRequired,
        pInfo->pfIsFileError,
        pInfo->pfSendErrorBody
        );

    if ( FAILED( hr ) )
    {
        IF_DEBUG( ISAPI_ERROR_RETURNS )
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "\r\n"
                        "  HSE_REQ_GET_CUSTOM_ERROR_PAGE[%p]: Failed\r\n"
                        "    Error: 0x%08x\r\n"
                        "  <END>\r\n\r\n",
                        pIsapiContext,
                        hr ));
        }

        return hr;
    }

    return hr;
}

HRESULT
SSFIsInProcess(
    ISAPI_CONTEXT * pIsapiContext,
    DWORD *         pdwAppFlag
    )
{
    LPWSTR  szClsid;

    DBG_ASSERT( pIsapiContext );
    DBG_ASSERT( pIsapiContext->CheckSignature() );

    IF_DEBUG( ISAPI_SSF_DETAILS )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "\r\n"
                    "  HSE_REQ_IS_IN_PROCESS[%p]: Function Entry\r\n"
                    "  <END>\r\n\r\n",
                    pIsapiContext ));
    }

    if ( pdwAppFlag == NULL )
    {
        IF_DEBUG( ISAPI_ERROR_RETURNS )
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "\r\n"
                        "  HSE_REQ_IS_IN_PROCESS[%p]: Parameter validation failure\r\n"
                        "    AppFlag Ptr: NULL\r\n"
                        "  <END>\r\n\r\n",
                        pIsapiContext ));
        }

        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }

    szClsid = pIsapiContext->QueryClsid();

    DBG_ASSERT( szClsid != NULL );

    if ( wcslen( szClsid ) == 0 )
    {
        *pdwAppFlag = HSE_APP_FLAG_IN_PROCESS;
    }
    else if ( _wcsicmp( szClsid, W3_OOP_POOL_WAM_CLSID ) == NULL )
    {
        *pdwAppFlag = HSE_APP_FLAG_POOLED_OOP;
    }
    else
    {
        *pdwAppFlag = HSE_APP_FLAG_ISOLATED_OOP;
    }

    return NO_ERROR;
}

HRESULT
SSFGetSspiInfo(
    ISAPI_CONTEXT * pIsapiContext,
    CtxtHandle *    pCtxtHandle,
    CredHandle *    pCredHandle
    )
{
    IIsapiCore *    pIsapiCore;
    HRESULT         hr;

    DBG_ASSERT( pIsapiContext );
    DBG_ASSERT( pIsapiContext->CheckSignature() );
    DBG_REQUIRE( ( pIsapiCore = pIsapiContext->QueryIsapiCoreInterface() ) != NULL );

    IF_DEBUG( ISAPI_SSF_DETAILS )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "\r\n"
                    "  HSE_REQ_GET_SSPI_INFO[%p]: Function Entry\r\n"
                    "  <END>\r\n\r\n",
                    pIsapiContext ));
    }

    //
    // The CtxtHandle and CredHandle are only valid in their
    // local process.  There is no way to duplicate them into
    // a dllhost.  As a result, this function is inproc only.
    //

    if ( pIsapiContext->QueryIsOop() )
    {
        return HRESULT_FROM_WIN32( ERROR_INVALID_FUNCTION );
    }

    //
    // Validate parameters
    //

    if ( pCtxtHandle == NULL || pCredHandle == NULL )
    {
        IF_DEBUG( ISAPI_ERROR_RETURNS )
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "\r\n"
                        "  HSE_REQ_GET_SSPI_INFO[%p]: Parameter validation Failure\r\n"
                        "    Context Handle Ptr: %p\r\n"
                        "    Credential Handle Ptr: %p\r\n"
                        "  <END>\r\n\r\n",
                        pIsapiContext,
                        pCtxtHandle,
                        pCredHandle ));
        }

        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }

    hr = pIsapiCore->GetSspiInfo(
        reinterpret_cast<BYTE*>( pCredHandle ),
        sizeof( CredHandle ),
        reinterpret_cast<BYTE*>( pCtxtHandle ),
        sizeof( CtxtHandle )
        );

    if ( FAILED( hr ) )
    {
        IF_DEBUG( ISAPI_ERROR_RETURNS )
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "\r\n"
                        "  HSE_REQ_GET_SSPI_INFO[%p]: Failed\r\n"
                        "    Error: 0x%08x\r\n"
                        "  <END>\r\n\r\n",
                        pIsapiContext,
                        hr ));
        }

        return hr;
    }

    return hr;
}

HRESULT
SSFGetVirtualPathToken(
    ISAPI_CONTEXT * pIsapiContext,
    LPSTR           szUrl,
    HANDLE *        pToken,
    BOOL            fUnicode
    )
{
    IIsapiCore *    pIsapiCore;
        HRESULT                 hr = S_OK;
        DWORD64                 dwToken;

    DBG_ASSERT( pIsapiContext );
    DBG_ASSERT( pIsapiContext->CheckSignature() );
    DBG_REQUIRE( ( pIsapiCore = pIsapiContext->QueryIsapiCoreInterface() ) != NULL );

    IF_DEBUG( ISAPI_SSF_DETAILS )
    {
        if ( fUnicode )
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "\r\n"
                        "  HSE_REQ_GET_UNICODE_VIRTUAL_PATH_TOKEN[%p]: Function Entry\r\n"
                        "    URL: '%S'\r\n"
                        "  <END>\r\n\r\n",
                        pIsapiContext,
                        szUrl ));
        }
        else
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "\r\n"
                        "  HSE_REQ_GET_VIRTUAL_PATH_TOKEN[%p]: Function Entry\r\n"
                        "    URL: '%s'\r\n"
                        "  <END>\r\n\r\n",
                        pIsapiContext,
                        szUrl ));
        }
    }

    //
    // Validate parameters
    //

    if ( szUrl == NULL || pToken == NULL )
    {
        IF_DEBUG( ISAPI_ERROR_RETURNS )
        {
            if ( fUnicode )
            {
                DBGPRINTF(( DBG_CONTEXT,
                            "\r\n"
                            "  HSE_REQ_GET_UNICODE_VIRTUAL_PATH_TOKEN[%p]: Parameter validation failure\r\n"
                            "    URL: '%S'\r\n"
                            "    Token Ptr: %p\r\n"
                            "  <END>\r\n\r\n",
                            pIsapiContext,
                            szUrl,
                            pToken ));
            }
            else
            {
                IF_DEBUG( ISAPI_ERROR_RETURNS )
                {
                    DBGPRINTF(( DBG_CONTEXT,
                                "\r\n"
                                "  HSE_REQ_GET_VIRTUAL_PATH_TOKEN[%p]: Parameter validation failure\r\n"
                                "    URL: '%s'\r\n"
                                "    Token Ptr: %p\r\n"
                                "  <END>\r\n\r\n",
                                pIsapiContext,
                                szUrl,
                                pToken ));
                }
            }
        }

        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }

    hr = pIsapiCore->QueryToken(
        reinterpret_cast<BYTE*>( szUrl ),
        (DWORD)( fUnicode ? (wcslen( (LPWSTR)szUrl ) + 1 ) * sizeof(WCHAR) : strlen( szUrl ) + 1 ),
        TOKEN_VR_TOKEN,
        &dwToken,
        fUnicode
        );

        if (FAILED(hr))
        {
        IF_DEBUG( ISAPI_ERROR_RETURNS )
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "\r\n"
                        "  HSE_REQ_GET_%sVIRTUAL_PATH_TOKEN[%p]: Failed\r\n"
                        "    Error: 0x%08x\r\n"
                        "  <END>\r\n\r\n",
                        fUnicode ? "UNICODE_" : "",
                        pIsapiContext,
                        hr ));
        }

                return hr;
        }

        *pToken = (HANDLE)dwToken;

        return hr;
}

HRESULT
SSFGetAnonymousToken(
    ISAPI_CONTEXT * pIsapiContext,
    LPSTR           szUrl,
    HANDLE *        pToken,
    BOOL            fUnicode
    )
{
    IIsapiCore *    pIsapiCore;
    DWORD64         dwToken;
    HRESULT         hr;

    DBG_ASSERT( pIsapiContext );
    DBG_ASSERT( pIsapiContext->CheckSignature() );
    DBG_REQUIRE( ( pIsapiCore = pIsapiContext->QueryIsapiCoreInterface() ) != NULL );

    IF_DEBUG( ISAPI_SSF_DETAILS )
    {
        if ( fUnicode )
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "\r\n"
                        "  HSE_REQ_GET_UNICODE_ANONYMOUS_TOKEN[%p]: Function Entry\r\n"
                        "    URL: '%S'\r\n"
                        "  <END>\r\n\r\n",
                        pIsapiContext,
                        szUrl ));
        }
        else
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "\r\n"
                        "  HSE_REQ_GET_ANONYMOUS_TOKEN[%p]: Function Entry\r\n"
                        "    URL: '%s\r\n"
                        "  <END>\r\n\r\n",
                        pIsapiContext,
                        szUrl ));
        }
    }
    //
    // Validate parameters
    //

    if ( szUrl == NULL || pToken == NULL )
    {
        if ( fUnicode )
        {
            IF_DEBUG( ISAPI_ERROR_RETURNS )
            {
                DBGPRINTF(( DBG_CONTEXT,
                            "\r\n"
                            "  HSE_REQ_GET_UNICODE_ANONYMOUS_TOKEN[%p]: Parameter validation failure\r\n"
                            "    URL: '%S'\r\n"
                            "    Token Ptr: %p\r\n"
                            "  <END>\r\n\r\n",
                            pIsapiContext,
                            szUrl,
                            pToken ));
            }
        }
        else
        {
            IF_DEBUG( ISAPI_ERROR_RETURNS )
            {
                DBGPRINTF(( DBG_CONTEXT,
                            "\r\n"
                            "  HSE_REQ_GET_ANONYMOUS_TOKEN[%p]: Parameter validation failure\r\n"
                            "    URL: '%s'\r\n"
                            "    Token Ptr: %p\r\n"
                            "  <END>\r\n\r\n",
                            pIsapiContext,
                            szUrl,
                            pToken ));
            }
        }

        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }

    hr = pIsapiCore->QueryToken(
        reinterpret_cast<BYTE*>( szUrl ),
        (DWORD)( fUnicode ? (wcslen( (LPWSTR)szUrl ) + 1 ) * sizeof(WCHAR) : strlen( szUrl ) + 1 ),
        TOKEN_ANONYMOUS_TOKEN,
        &dwToken,
        fUnicode
        );

    if ( FAILED( hr ) )
    {
        IF_DEBUG( ISAPI_ERROR_RETURNS )
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "\r\n"
                        "  HSE_REQ_GET_%sANONYMOUS_TOKEN[%p]: Failed\r\n"
                        "    Error: 0x%08x\r\n"
                        "  <END>\r\n\r\n",
                        fUnicode ? "UNICODE_" : "",
                        pIsapiContext,
                        hr ));
        }

        return hr;
    }

    *pToken = (HANDLE)dwToken;

    return hr;
}

HRESULT
SSFReportUnhealthy(
    ISAPI_CONTEXT * pIsapiContext,
    LPSTR           szReason
    )
{
    IIsapiCore *    pIsapiCore;
    LPWSTR          szImage;
    STACK_STRU(     strReason, 512 );
    DWORD           cbImage;
    DWORD           cbReason;
    HRESULT         hr;

    DBG_ASSERT( pIsapiContext );
    DBG_ASSERT( pIsapiContext->CheckSignature() );
    DBG_REQUIRE( ( pIsapiCore = pIsapiContext->QueryIsapiCoreInterface() ) != NULL );
    DBG_REQUIRE( ( szImage = pIsapiContext->QueryGatewayImage() ) != NULL );

    IF_DEBUG( ISAPI_SSF_DETAILS )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "\r\n"
                    "  HSE_REQ_REPORT_UNHEALTHY[%p]: Function Entry\r\n"
                    "    Reason: '%s'\r\n"
                    "  <END>\r\n\r\n",
                    pIsapiContext,
                    szReason ));
    }

    cbImage = (DWORD)( wcslen( szImage ) + 1 ) * sizeof( WCHAR );

    //
    // If the ISAPI has given a reason, we need to send it
    // as UNICODE.
    //

    if ( szReason == NULL )
    {
        cbReason = 0;
    }
    else
    {
        hr = strReason.CopyA( szReason );

        if ( FAILED( hr ) )
        {
            return hr;
        }

        cbReason = ( strReason.QueryCCH() + 1 ) * sizeof( WCHAR );
    }

    hr = pIsapiCore->ReportAsUnhealthy(
        reinterpret_cast<BYTE*>( szImage ),
        cbImage,
        cbReason ? reinterpret_cast<BYTE*>( strReason.QueryStr() ) : NULL,
        cbReason
        );

    if ( FAILED( hr ) )
    {
        IF_DEBUG( ISAPI_ERROR_RETURNS )
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "\r\n"
                        "  HSE_REQ_REPORT_UNHEALTHY[%p]: Failed\r\n"
                        "    Error: 0x%08x\r\n"
                        "  <END>\r\n\r\n",
                        pIsapiContext,
                        hr ));
        }

        return hr;
    }

    return hr;
}

HRESULT
SSFNormalizeUrl(
    LPSTR           pszURL
    )
/*++

Routine Description:

    Normalize URL

Arguments:

    pszURL        - On entry, contains not normalized URL.  On return,
                    contains normalized URL.
    
Return Value:

    HRESULT

--*/
{
    HRESULT hr;

    IF_DEBUG( ISAPI_SSF_DETAILS )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "\r\n"
                    "  HSE_REQ_NORMALIZE_URL[]: Function Entry\r\n"
                    "    URL: '%s'\r\n"
                    "  <END>\r\n\r\n",
                    pszURL ));
    }

    //
    // Validate parameters
    //

    if ( pszURL == NULL )
    {
        IF_DEBUG( ISAPI_ERROR_RETURNS )
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "\r\n"
                        "  HSE_REQ_NORMALIZE_URL[]: Parameter validation failure\r\n"
                        "    URL: NULL\r\n"
                        "  <END>\r\n\r\n" ));
        }

        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }

    hr = NormalizeUrl( pszURL );

    if ( FAILED( hr ) )
    {
        IF_DEBUG( ISAPI_ERROR_RETURNS )
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "\r\n"
                        "  HSE_REQ_NORMALIZE_URL[]: Failed\r\n"
                        "    Error: 0x%08x\r\n"
                        "  <END>\r\n\r\n",
                        hr ));
        }

        return hr;
    }

    return hr;
}

HRESULT
SSFAddFragmentToCache(
    ISAPI_CONTEXT * pIsapiContext,
    HSE_VECTOR_ELEMENT * pHseVectorElement,
    WCHAR * pszFragmentName
)
/*++

Routine Description:

    Add the given fragment to the fragment-cache

Arguments:

    pIsapiContext - The ISAPI_CONTEXT associated with this command.
    pVectorElement - The fragment to be added
    pszFragmentName - The name of the fragment
    
Return Value:

    HRESULT

--*/
{
    IIsapiCore *pIsapiCore = pIsapiContext->QueryIsapiCoreInterface();
    HRESULT     hr;

    IF_DEBUG( ISAPI_SSF_DETAILS )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "\r\n"
                    "  HSE_REQ_ADD_FRAGMENT_TO_CACHE[%p]: Function Entry\r\n"
                    "    Fragment Name: '%S'\r\n"
                    "  <END>\r\n\r\n",
                    pIsapiContext,
                    pszFragmentName ));
    }

    if ( pIsapiCore == NULL )
    {
        IF_DEBUG( ISAPI_ERROR_RETURNS )
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "\r\n"
                        "  HSE_REQ_ADD_FRAGMENT_TO_CACHE[%p]: Failed to get interface to server core\r\n"
                        "  <END>\r\n\r\n",
                        pIsapiContext ));
        }

        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }

    //
    // verify the data passed in
    //

    if ( pHseVectorElement == NULL ||
         pszFragmentName == NULL )
    {
        IF_DEBUG( ISAPI_ERROR_RETURNS )
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "\r\n"
                        "  HSE_REQ_ADD_FRAGMENT_TO_CACHE[%p]: Parameter validation failure\r\n"
                        "    Vector Element Ptr: %p\r\n"
                        "    Fragment Name: '%s'\r\n"
                        "  <END>\r\n\r\n",
                        pIsapiContext,
                        pHseVectorElement,
                        pszFragmentName ));
        }

        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }

    VECTOR_ELEMENT VectorElement;
    ZeroMemory(&VectorElement, sizeof VectorElement);

    if (pHseVectorElement->pvContext == NULL)
    {
        IF_DEBUG( ISAPI_ERROR_RETURNS )
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "\r\n"
                        "  HSE_REQ_ADD_FRAGMENT_TO_CACHE[%p]: Parameter validation failure\r\n"
                        "    Vector Element Context: NULL\r\n"
                        "  <END>\r\n\r\n",
                        pIsapiContext ));
        }

        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }

    switch (pHseVectorElement->ElementType)
    {
    case HSE_VECTOR_ELEMENT_TYPE_MEMORY_BUFFER:
        if (pHseVectorElement->cbSize > MAXULONG)
        {
            IF_DEBUG( ISAPI_ERROR_RETURNS )
            {
                DBGPRINTF(( DBG_CONTEXT,
                            "\r\n"
                            "  HSE_REQ_ADD_FRAGMENT_TO_CACHE[%p]: Parameter validation failure\r\n"
                            "    Memory buffer size element invalid\r\n"
                            "    Size: %d\r\n"
                            "  <END>\r\n\r\n",
                            pIsapiContext,
                            pHseVectorElement->cbSize ));
            }

            return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
        }

        VectorElement.pBuffer = (BYTE *)pHseVectorElement->pvContext;
        VectorElement.cbBufSize = (DWORD)pHseVectorElement->cbSize;
        break;

    case HSE_VECTOR_ELEMENT_TYPE_FILE_HANDLE:
        if (pHseVectorElement->pvContext == INVALID_HANDLE_VALUE)
        {
            IF_DEBUG( ISAPI_ERROR_RETURNS )
            {
                DBGPRINTF(( DBG_CONTEXT,
                            "\r\n"
                            "  HSE_REQ_ADD_FRAGMENT_TO_CACHE[%p]: Parameter validation failure\r\n"
                            "    Element file handle invalid\r\n"
                            "    File Handle: %p\r\n"
                            "  <END>\r\n\r\n",
                            pIsapiContext,
                            pHseVectorElement->pvContext ));
            }

            return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
        }

        //
        // Treat 0 as "send the rest of the file" - same as TransmitFile/VectorSend
        //
        if (pHseVectorElement->cbSize == 0)
        {
            pHseVectorElement->cbSize = HTTP_BYTE_RANGE_TO_EOF;
        }

        VectorElement.hFile = (DWORD_PTR)pHseVectorElement->pvContext;
        VectorElement.cbOffset = pHseVectorElement->cbOffset;
        VectorElement.cbFileSize = pHseVectorElement->cbSize;
        break;

    case HSE_VECTOR_ELEMENT_TYPE_FRAGMENT:
    default:
        IF_DEBUG( ISAPI_ERROR_RETURNS )
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "\r\n"
                        "  HSE_REQ_ADD_FRAGMENT_TO_CACHE[%p]: Parameter validation failure\r\n"
                        "    Unknown element type: %d\r\n"
                        "    Fragment Name: '%s'\r\n"
                        "  <END>\r\n\r\n",
                        pIsapiContext,
                        pHseVectorElement->ElementType ));
        }

        return HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);
    }

    hr = pIsapiCore->AddFragmentToCache(&VectorElement,
                                        pszFragmentName);

    if ( FAILED( hr ) )
    {
        IF_DEBUG( ISAPI_ERROR_RETURNS )
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "\r\n"
                        "  HSE_REQ_ADD_FRAGMENT_TO_CACHE[%p]: Failed\r\n"
                        "    Error: 0x%08x\r\n"
                        "  <END>\r\n\r\n",
                        pIsapiContext,
                        hr ));
        }

        return hr;
    }

    return hr;
}


HRESULT
SSFReadFragmentFromCache(
    ISAPI_CONTEXT * pIsapiContext,
    WCHAR * pszFragmentName,
    BYTE * pvBuffer,
    DWORD * pcbSize
)
/*++

Routine Description:

    Read the given fragment from the fragment-cache

Arguments:

    pIsapiContext - The ISAPI_CONTEXT associated with this command.
    pszFragmentName - The name of the fragment
    pvBuffer - The buffer to read the fragment in
    pcbSize - On entry, the size of the buffer and on exit, the number of bytes copied
    
Return Value:

    HRESULT

--*/
{
    IIsapiCore *pIsapiCore = pIsapiContext->QueryIsapiCoreInterface();
    HRESULT     hr;

    IF_DEBUG( ISAPI_SSF_DETAILS )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "\r\n"
                    "  HSE_REQ_READ_FRAGMENT_FROM_CACHE[%p]: Function Entry\r\n"
                    "    Fragment Name: '%S'\r\n"
                    "  <END>\r\n\r\n",
                    pIsapiContext,
                    pszFragmentName ));
    }

    if ( pIsapiCore == NULL )
    {
        IF_DEBUG( ISAPI_ERROR_RETURNS )
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "\r\n"
                        "  HSE_REQ_READ_FRAGMENT_FROM_CACHE[%p]: Failed to get interface to server core\r\n"
                        "  <END>\r\n\r\n",
                        pIsapiContext ));
        }

        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }

    //
    // verify the data passed in
    //

    if ( pszFragmentName == NULL ||
         pcbSize == NULL ||
         (pvBuffer == NULL && *pcbSize != 0 ) )
    {
        IF_DEBUG( ISAPI_ERROR_RETURNS )
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "\r\n"
                        "  HSE_REQ_READ_FRAGMENT_FROM_CACHE[%p]: Parameter validation failure\r\n"
                        "    Fragment Name: '%s'\r\n"
                        "    Size Ptr: %p\r\n"
                        "    Size: %d\r\n"
                        "    Buffer Ptr: %p\r\n"
                        "  <END>\r\n\r\n",
                        pIsapiContext,
                        pszFragmentName,
                        pcbSize,
                        pcbSize ? *pcbSize : 0,
                        pvBuffer ));
        }

        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }

    hr = pIsapiCore->ReadFragmentFromCache(pszFragmentName,
                                           pvBuffer,
                                           *pcbSize,
                                           pcbSize);

    if ( FAILED( hr ) )
    {
        IF_DEBUG( ISAPI_ERROR_RETURNS )
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "\r\n"
                        "  HSE_REQ_READ_FRAGMENT_FROM_CACHE[%p]: Failed\r\n"
                        "    Error: 0x%08x\r\n"
                        "  <END>\r\n\r\n",
                        pIsapiContext,
                        hr ));
        }

        return hr;
    }

    return hr;
}


HRESULT
SSFRemoveFragmentFromCache(
    ISAPI_CONTEXT * pIsapiContext,
    WCHAR * pszFragmentName
)
/*++

Routine Description:

    Remove the given fragment from the fragment-cache

Arguments:

    pIsapiContext - The ISAPI_CONTEXT associated with this command.
    pszFragmentName - The name of the fragment
    
Return Value:

    HRESULT

--*/
{
    IIsapiCore *pIsapiCore = pIsapiContext->QueryIsapiCoreInterface();
    HRESULT     hr;

    IF_DEBUG( ISAPI_SSF_DETAILS )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "\r\n"
                    "  HSE_REQ_REMOVE_FRAGMENT_FROM_CACHE[%p]: Function Entry\r\n"
                    "    Fragment Name: '%S'\r\n"
                    "  <END>\r\n\r\n",
                    pIsapiContext,
                    pszFragmentName ));
    }

    if ( pIsapiCore == NULL )
    {
        IF_DEBUG( ISAPI_ERROR_RETURNS )
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "\r\n"
                        "  HSE_REQ_REMOVE_FRAGMENT_FROM_CACHE[%p]: Failed to get interface to server core\r\n"
                        "  <END>\r\n\r\n",
                        pIsapiContext ));
        }

        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }

    //
    // verify the data passed in
    //

    if ( pszFragmentName == NULL )
    {
        IF_DEBUG( ISAPI_ERROR_RETURNS )
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "\r\n"
                        "  HSE_REQ_REMOVE_FRAGMENT_FROM_CACHE[%p]: Parameter validation failure\r\n"
                        "    Fragment Name: '%s'\r\n"
                        "  <END>\r\n\r\n",
                        pIsapiContext,
                        pszFragmentName ));
        }

        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }

    hr = pIsapiCore->RemoveFragmentFromCache(pszFragmentName);

    if ( FAILED( hr ) )
    {
        IF_DEBUG( ISAPI_ERROR_RETURNS )
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "\r\n"
                        "  HSE_REQ_REMOVE_FRAGMENT_FROM_CACHE[%p]: Failed\r\n"
                        "    Error: 0x%08x\r\n"
                        "  <END>\r\n\r\n",
                        pIsapiContext,
                        hr ));
        }

        return hr;
    }

    return hr;
}

HRESULT
SSFGetMetadataProperty(
    ISAPI_CONTEXT *         pIsapiContext,
    DWORD_PTR               dwPropertyId,
    BYTE *                  pbBuffer,
    DWORD *                 pcbBuffer
    )
/*++

Routine Description:

    Retrieve a property from the UT_FILE metadata associated with the URL
    of this request

Arguments:

    pIsapiContext - ISAPI_CONTEXT
    dwPropertyId - MD_* metabase property ID
    pbBuffer - Points to buffer
    pcbBuffer - On input size of buffer, on output size needed/used
    
Return Value:

    HRESULT

--*/
{
    IIsapiCore *            pIsapiCore;
    HRESULT                 hr;
    METADATA_RECORD *       pRecord;
    
    DBG_ASSERT( pIsapiContext != NULL );

    IF_DEBUG( ISAPI_SSF_DETAILS )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "\r\n"
                    "  HSE_REQ_GET_METADATA_PROPERTY[%p]: Function Entry\r\n"
                    "    PropertyID: 0x%08x (%d)\r\n"
                    "  <END>\r\n\r\n",
                    pIsapiContext,
                    dwPropertyId,
                    dwPropertyId ));
    }

    pIsapiCore = pIsapiContext->QueryIsapiCoreInterface();
    DBG_ASSERT( pIsapiCore != NULL );
    
    if ( pcbBuffer == NULL )
    {
        IF_DEBUG( ISAPI_ERROR_RETURNS )
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "\r\n"
                        "  HSE_REQ_GET_METADATA_PROPERTY[%p]: Parameter validation failure\r\n"
                        "    Buffer Ptr: NULL\r\n"
                        "  <END>\r\n\r\n",
                        pIsapiContext ));
        }

        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }
    
    hr = pIsapiCore->GetMetadataProperty( (DWORD) dwPropertyId,
                                           pbBuffer,
                                           *pcbBuffer,
                                           pcbBuffer );

    if ( FAILED( hr ) )
    {
        IF_DEBUG( ISAPI_ERROR_RETURNS )
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "\r\n"
                        "  HSE_REQ_GET_METADATA_PROPERTY[%p]: Failed\r\n"
                        "    Error: 0x%08x\r\n"
                        "  <END>\r\n\r\n",
                        pIsapiContext,
                        hr ));
        }

        return hr;
    }
    else
    {
        //
        // OK.  Before we return the METADATA_RECORD back to caller, set the 
        // pbMDData buffer pointer (since for OOP the pointer can only be
        // calculated on this side
        //
        
        DBG_ASSERT( *pcbBuffer >= sizeof( METADATA_RECORD ) );
        
        pRecord = (METADATA_RECORD*) pbBuffer;
        
        pRecord->pbMDData = (BYTE*) (pRecord + 1);        
    }

    return hr;
}

HRESULT
SSFGetCacheInvalidationCallback(
    ISAPI_CONTEXT * pIsapiContext,
    PFN_HSE_CACHE_INVALIDATION_CALLBACK * pfnCallback
)
/*++

Routine description:
    Get the callback function to use to flush a response from the http.sys cache

Arguments:
    pIsapiContext - The ISAPI_CONTEXT corresponding to the request
    pfnCallback - On successful return, the address of the callback function

Return:
    HRESULT

--*/
{
    IIsapiCore *            pIsapiCore;
    HRESULT                 hr;
    
    DBG_ASSERT( pIsapiContext != NULL );

    IF_DEBUG( ISAPI_SSF_DETAILS )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "\r\n"
                    "  HSE_REQ_GET_CACHE_INVALIDATION_CALLBACK[%p]: Function Entry\r\n"
                    "  <END>\r\n\r\n",
                    pIsapiContext ));
    }

    pIsapiCore = pIsapiContext->QueryIsapiCoreInterface();
    DBG_ASSERT( pIsapiCore != NULL );
    
    if ( pfnCallback == NULL )
    {
        IF_DEBUG( ISAPI_ERROR_RETURNS )
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "\r\n"
                        "  HSE_REQ_GET_CACHE_INVALIDATION_CALLBACK[%p]: Parameter validation failure\r\n"
                        "    Callback Ptr: NULL\r\n"
                        "  <END>\r\n\r\n",
                        pIsapiContext ));
        }

        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }
    
    hr = pIsapiCore->GetCacheInvalidationCallback((DWORD64 *)pfnCallback);

    if ( FAILED( hr ) )
    {
        IF_DEBUG( ISAPI_ERROR_RETURNS )
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "\r\n"
                        "  HSE_REQ_GET_CACHE_INVALIDATION_CALLBACK[%p]: Failed\r\n"
                        "    Error: 0x%08x\r\n"
                        "  <END>\r\n\r\n",
                        pIsapiContext,
                        hr ));
        }

        return hr;
    }

    return hr;
}

HRESULT
SSFCloseConnection(
    ISAPI_CONTEXT * pIsapiContext
    )
{
    IIsapiCore *                pIsapiCore;
    HRESULT                     hr;

    DBG_ASSERT( pIsapiContext );
    DBG_ASSERT( pIsapiContext->CheckSignature() );
    DBG_REQUIRE( ( pIsapiCore = pIsapiContext->QueryIsapiCoreInterface() ) != NULL );

    IF_DEBUG( ISAPI_SSF_DETAILS )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "\r\n"
                    "  HSE_REQ_CLOSE_CONNECTION[%p]: Function Entry\r\n"
                    "  <END>\r\n\r\n",
                    pIsapiContext ));
    }

    hr = pIsapiCore->CloseConnection();

    if ( FAILED( hr ) )
    {
        IF_DEBUG( ISAPI_ERROR_RETURNS )
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "\r\n"
                        "  HSE_REQ_CLOSE_CONNECTION[%p]: Failed\r\n"
                        "    Error: 0x%08x\r\n"
                        "  <END>\r\n\r\n",
                        pIsapiContext,
                        hr ));
        }

        return hr;
    }

    return hr;
}

// stristr (stolen from fts.c, wickn)
//
// case-insensitive version of strstr.
// stristr returns a pointer to the first occurrence of
// pszSubString in pszString.  The search does not include
// terminating nul characters.
//
// BUGBUG: is this DBCS-safe?

const char*
stristr2(
    const char* pszString,
    const char* pszSubString
    )
{
    const char *cp1 = (const char*) pszString, *cp2, *cp1a;
    char first;

    // get the first char in string to find
    first = pszSubString[0];

    // first char often won't be alpha
    if (isalpha(first))
    {
        first = (char) tolower(first);
        for ( ; *cp1  != '\0'; cp1++)
        {
            if (tolower(*cp1) == first)
            {
                for (cp1a = &cp1[1], cp2 = (const char*) &pszSubString[1];
                     ;
                     cp1a++, cp2++)
                {
                    if (*cp2 == '\0')
                        return cp1;
                    if (tolower(*cp1a) != tolower(*cp2))
                        break;
                }
            }
        }
    }
    else
    {
        for ( ; *cp1 != '\0' ; cp1++)
        {
            if (*cp1 == first)
            {
                for (cp1a = &cp1[1], cp2 = (const char*) &pszSubString[1];
                     ;
                     cp1a++, cp2++)
                {
                    if (*cp2 == '\0')
                        return cp1;
                    if (tolower(*cp1a) != tolower(*cp2))
                        break;
                }
            }
        }
    }

    return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\iisplus\w3isapi\isapi_context.cxx ===
/*++

   Copyright    (c)    2001    Microsoft Corporation

   Module Name : isapi_context.cxx

   Abstract: IIS ISAPI request context
 
   Author: Wade A. Hilmo (wadeh)        14-Mar-2001

   Project: w3isapi.dll

--*/


/************************************************************
 *  Include Headers
 ************************************************************/

#include "precomp.hxx"
#include "isapi_context.hxx"

PTRACE_LOG              ISAPI_CONTEXT::sm_pTraceLog;
ALLOC_CACHE_HANDLER *   ISAPI_CONTEXT::sm_pachIsapiContexts;

/************************************************************
 *  Implementation
 ************************************************************/

//static
HRESULT
ISAPI_CONTEXT::Initialize(
    VOID
    )
/*++

Routine Description:

    Static initialization for the ISAPI_CONTEXT object.  This
    function sets up the static members needed for acache.

Arguments:

    None
  
Return Value:

    HRESULT

--*/
{
    ALLOC_CACHE_CONFIGURATION       acConfig;
    
#if DBG
    sm_pTraceLog = CreateRefTraceLog( 2000, 0 );
#else
    IF_DEBUG( ISAPI_REF_TRACE )
    {
        sm_pTraceLog = CreateRefTraceLog( 2000, 0 );
    }
#endif

    //
    // Initialize a lookaside for this structure
    //
    
    acConfig.nConcurrency = 1;
    acConfig.nThreshold = 100;
    acConfig.cbSize = sizeof( ISAPI_CONTEXT );

    DBG_ASSERT( sm_pachIsapiContexts == NULL );
    
    sm_pachIsapiContexts = new ALLOC_CACHE_HANDLER( "ISAPI_CONTEXT",  
                                                    &acConfig );

    if ( sm_pachIsapiContexts == NULL )
    {
        return HRESULT_FROM_WIN32( GetLastError() );
    }

    return NO_ERROR;
}

//static
VOID
ISAPI_CONTEXT::Terminate(
    VOID
    )
/*++

Routine Description:

    Static uninitialization for the ISAPI_CONTEXT object.  This
    function cleans up the static members needed for acache.

Arguments:

    None
  
Return Value:

    None

--*/
{
    if ( sm_pTraceLog != NULL )
    {
        DestroyRefTraceLog( sm_pTraceLog );
        sm_pTraceLog = NULL;
    }
    
    if ( sm_pachIsapiContexts != NULL )
    {
        delete sm_pachIsapiContexts;
        sm_pachIsapiContexts = NULL;
    }
}

ISAPI_CONTEXT::ISAPI_CONTEXT(
    IIsapiCore *        pIsapiCore,
    ISAPI_CORE_DATA *   pCoreData,
    ISAPI_DLL *         pIsapiDll
    )
    : _pIsapiCore( pIsapiCore ),
      _pCoreData( pCoreData ),
      _pIsapiDll( pIsapiDll ),
      _cRefs(1),
      _fClientWantsKeepConn( FALSE ),
      _fDoKeepConn( FALSE ),
      _fHonorAndKeepConn( TRUE ),
      _fHeadersSent( FALSE ),
      _AsyncPending( NoAsyncIoPending ),
      _cbLastAsyncIo( 0 ),
      _pfnHseIoCompletion( NULL ),
      _pvHseIoContext( NULL ),
      _pvAsyncIoBuffer( NULL ),
      _pComContext( NULL ),
      _pComInitsCookie( NULL )
/*++

Routine Description:

    Constructor

Arguments:

    pIsapiCore - Interface to call into the IIS core for this request
    pCoreData  - The core data for this request
    pIsapiDll  - The ISAPI_DLL object associated with this request
  
Return Value:

    None

--*/
{
    DBG_ASSERT( pIsapiCore );
    DBG_ASSERT( pCoreData );
    DBG_ASSERT( pIsapiDll );

    //
    // Take a reference on the ISAPI core interface and
    // the ISAPI dll for the lifetime of this object.
    //

    _pIsapiCore->AddRef();
    _pIsapiDll->ReferenceIsapiDll();

    //
    // Initialize the ECB.  Note that the caller needs to
    // populate the WriteClient, ReadClient, GetServerVariable
    // and ServerSupportFunction members.
    //
    // Note that the ECB cbSize member doubles as the signature
    // for the ISAPI_CONTEXT.  So, it should be the first thing set
    // at construction.
    //

    _ECB.cbSize = sizeof( EXTENSION_CONTROL_BLOCK );
    _ECB.ConnID = this;
    _ECB.dwVersion = HSE_VERSION;
    _ECB.dwHttpStatusCode = 200;
    _ECB.lpszLogData[0] = '\0';
    _ECB.cbTotalBytes = _pCoreData->dwContentLength;
    _ECB.cbAvailable = _pCoreData->cbAvailableEntity;
    _ECB.lpbData = (PBYTE) _pCoreData->pAvailableEntity;
    _ECB.lpszMethod = _pCoreData->szMethod;
    _ECB.lpszQueryString = _pCoreData->szQueryString;
    _ECB.lpszPathInfo = _pCoreData->szPathInfo;
    _ECB.lpszPathTranslated = _pCoreData->szPathTranslated;
    _ECB.lpszContentType = _pCoreData->szContentType;

    //
    // Store the request ID for tracing purposes
    //

    _RequestId = _pCoreData->RequestId;

    //
    // Inspect the HTTP version and connection header to
    // determine if the client is asking us to keep the
    // connection open at the conclusion of this request
    //
    // By default, we assume that the client wants us to
    // close the connection.  If the client sends us an
    // HTTP/1.x version, we will look for keep-alive
    // possibilities.
    //
    // Note that regardless of what the client wants, we will
    // close the connection by default.  The extension will
    // need to do something to cause us to change this stance.
    //

    if ( _pCoreData->fAllowKeepAlive && 
         _pCoreData->dwVersionMajor == 1 )
    {
        if ( _pCoreData->dwVersionMinor == 0 )
        {
            //
            // The client is HTTP/1.0 - the presence of a
            // "connection: keep-alive" header indicates the
            // client wants to keep the connection open, else
            // the connection should close.
            //

            _fClientWantsKeepConn = 
                !( _stricmp( _pCoreData->szConnection, "keep-alive" ) );
        }
        else
        {
            //
            // The client is HTTP/1.x, where x is not 0. We
            // will assume that any 1.1+ version of HTTP uses
            // HTTP/1.1 semantics.  This means that the client
            // wants to keep the connection open unless a
            // "connection: close" header is present.
            //

            _fClientWantsKeepConn = 
                !!(_stricmp( _pCoreData->szConnection, "close" ) );
        }
    }
}

ISAPI_CONTEXT::~ISAPI_CONTEXT()
/*++

Routine Description:

    Destructor

Arguments:

    None

Return Value:

    None

--*/
{
    HANDLE  hToken = NULL;
    BOOL    fIsOop = FALSE;
    HCONN   hConn;

    DBG_ASSERT( CheckSignature() );
    DBG_ASSERT( _pIsapiCore );

    //
    // The ECB cbSize member doubles as the signature.  Strange
    // but true.
    //

    _ECB.cbSize = ISAPI_CONTEXT_SIGNATURE_FREE;

    //
    // If this request is OOP, then delete the local copy of the core data
    //

    if ( _pCoreData->fIsOop )
    {
        fIsOop = TRUE;

        DBG_ASSERT( _pCoreData->hToken );
        CloseHandle( _pCoreData->hToken );

        DBG_ASSERT( _pCoreData );
        LocalFree( _pCoreData );
        _pCoreData = NULL;
    }

    //
    // Release the ISAPI_DLL and ISAPI core interface.  Note that
    // the _pIsapiCore->Release call will be going through RPC in
    // the OOP case.  We'll need to temporarily remove any impersonation
    // token for the duration of the Release call.
    //

    _pIsapiDll->DereferenceIsapiDll();

    if ( fIsOop )
    {
        if ( OpenThreadToken( GetCurrentThread(),
                              TOKEN_IMPERSONATE,
                              TRUE,
                              &hToken ) )
        {
            DBG_ASSERT( hToken );
            DBG_REQUIRE( RevertToSelf() );
        }
    }

    //
    // Pick up any logging data the ISAPI may want to log
    //
    _pIsapiCore->AppendLog( _ECB.lpszLogData, (USHORT)_ECB.dwHttpStatusCode );

    //
    // And, now we are really, finally done
    //
    _pIsapiCore->Release();

    if ( hToken != NULL )
    {
        DBG_REQUIRE( SetThreadToken( NULL, hToken ) );
        DBG_REQUIRE( CloseHandle( hToken ) );
    }

    if ( ETW_IS_TRACE_ON(ETW_LEVEL_CP) ) 
    {
        hConn = (HCONN) this;
        
        g_pEtwTracer->EtwTraceEvent( &IsapiEventGuid,
                                     ETW_TYPE_END,
                                     &_RequestId,
                                     sizeof(ULONGLONG),
                                     &hConn,
                                     sizeof( HCONN ),
                                     NULL,
                                     0 );
    }

    hToken = NULL;
}

VOID
ISAPI_CONTEXT::ReferenceIsapiContext(
    VOID
    )
/*++

Routine Description:

    Adds a reference to an ISAPI_CONTEXT object

Arguments:

    None
  
Return Value:

    None

--*/
{
    LONG    cRefs;

    cRefs = InterlockedIncrement( &_cRefs );

    //
    // Do ref tracing if configured
    //

    if ( sm_pTraceLog != NULL )
    {
        WriteRefTraceLog( sm_pTraceLog, 
                          cRefs,
                          this );
    }

    //
    // Going from zero to 1 is a bad thing
    //

    DBG_ASSERT( cRefs > 1 );

    return;
}

VOID
ISAPI_CONTEXT::DereferenceIsapiContext(
    VOID
    )
/*++

Routine Description:

    Removes a reference from an ISAPI_CONTEXT object.
    The object is deleted when the last reference is
    removed.

Arguments:

    None
  
Return Value:

    None

--*/
{
    LONG cRefs;

    cRefs = InterlockedDecrement( &_cRefs );

    //
    // Do ref tracing if configured
    //

    if ( sm_pTraceLog != NULL )
    {
        WriteRefTraceLog( sm_pTraceLog, 
                          cRefs,
                          this );
    }

    if ( cRefs == 0 )
    {
        delete this;
    }

    return;
}

BOOL
ISAPI_CONTEXT::TryInitAsyncIo(
    ASYNC_PENDING   IoType
    )
/*++

Routine Description:

    Sets up the ISAPI_CONTEXT for an asynchronous operation.
    The function also does error checking to ensure that only
    one asynchronous operation can exist for a given request.

Arguments:

    IoType - The type of asynchronous operation setting up
  
Return Value:

    TRUE if successful, FALSE if asynchronous operation should
    not be allowed

--*/
{
    ASYNC_PENDING   OldAsyncFlag;

    DBG_ASSERT( CheckSignature() );
    DBG_ASSERT( IoType != NoAsyncIoPending );

    //
    // Take a reference to prevent this object from getting cleaned
    // up while an async action is pending.  This referenced will be
    // released by the completion unless we fail below.
    //

    ReferenceIsapiContext();

    OldAsyncFlag = static_cast<ASYNC_PENDING>( InterlockedCompareExchange(
        (LPLONG)&_AsyncPending,
        IoType,
        NoAsyncIoPending
        ) );

    DBG_ASSERT( OldAsyncFlag == NoAsyncIoPending );

    if ( OldAsyncFlag != NoAsyncIoPending )
    {
        DereferenceIsapiContext();
        SetLastError( ERROR_INVALID_PARAMETER );
        return FALSE;
    }

    return TRUE;
}

ASYNC_PENDING
ISAPI_CONTEXT::UninitAsyncIo(
    VOID
    )
/*++

Routine Description:

    Cleans up after an asynchronous operation

Arguments:

    None
  
Return Value:

    The type of IO that was uninitialized

--*/
{
    ASYNC_PENDING   IoType;

    DBG_ASSERT( CheckSignature() );
    DBG_ASSERT( _AsyncPending != NoAsyncIoPending );

    IoType = _AsyncPending;
    _AsyncPending = NoAsyncIoPending;

    DereferenceIsapiContext();

    return IoType;
}

VOID
ISAPI_CONTEXT::IsapiDoRevertHack(
    HANDLE *    phToken,
    BOOL        fForce
    )
/*++

Routine Description:

    Ensures that the calling thread is running with no impersonation
    token.  If an impersonation token existed, its value is returned
    to the caller.

    Note that we generally want to do this only for OOP requests (to
    prevent RPC from caching the impersonation token).

Arguments:

    phToken - Upon return, contains the value of any impersonation
              token removed from the thread.  If no impersonation
              token is removed, this contains NULL on return
    fForce  - If TRUE, don't do the revert hack even in the
              inproc case.
  
Return Value:

    None

--*/
{
    DBG_ASSERT( CheckSignature() );
    DBG_ASSERT( phToken );

    //
    // Init token to NULL, in case we fail
    //

    *phToken = NULL;

    if ( QueryIsOop() == FALSE  &&
         fForce == FALSE )
    {
        return;
    }

    if ( OpenThreadToken( GetCurrentThread(),
                          TOKEN_IMPERSONATE,
                          TRUE,
                          phToken ) )
    {
        DBG_ASSERT( *phToken );
        DBG_REQUIRE( RevertToSelf() );
    }

    return;
}

VOID
ISAPI_CONTEXT::IsapiUndoRevertHack(
    HANDLE *    phToken
    )
/*++

Routine Description:

    Restores an impersonation token after IsapiDoRevertHack

Arguments:

    phToken         - Pointer to token to restore
  
Return Value:

    None

--*/
{
    DBG_ASSERT( CheckSignature() );
    DBG_ASSERT( phToken );

    if ( *phToken != NULL )
    {
        DBG_REQUIRE( SetThreadToken( NULL, *phToken ) );
        DBG_REQUIRE( CloseHandle( *phToken ) );
    }

    *phToken = NULL;

    return;
}

BOOL
ISAPI_CONTEXT::GetOopServerVariableByIndex
(
    SERVER_VARIABLE_INDEX   Index,
    LPVOID                  lpvBuffer,
    LPDWORD                 lpdwSize
)
{
    CHAR    szTemp[64];
    LPVOID  pData;
    DWORD   cbBuffer;

    DBG_ASSERT( CheckSignature() );
    DBG_ASSERT( _pCoreData );
    DBG_ASSERT( QueryIsOop() );
    DBG_ASSERT( lpdwSize );
    DBG_ASSERT( lpvBuffer != NULL || *lpdwSize == 0 );

    cbBuffer = *lpdwSize;

    //
    // Get the value for the specified server variable
    //

    switch ( Index )
    {
    case ServerVariableApplMdPath:

        *lpdwSize = _pCoreData->cbApplMdPath;
        pData = _pCoreData->szApplMdPath;

        break;

    case ServerVariableUnicodeApplMdPath:

        *lpdwSize = _pCoreData->cbApplMdPathW;
        pData = _pCoreData->szApplMdPathW;

        break;

    case ServerVariableContentLength:

        sprintf( szTemp, "%d", _pCoreData->dwContentLength );

        *lpdwSize = (DWORD)strlen( szTemp ) + 1;
        pData = szTemp;

        break;

    case ServerVariableContentType:

        *lpdwSize = _pCoreData->cbContentType;
        pData = _pCoreData->szContentType;

        break;

    case ServerVariableInstanceId:

        sprintf( szTemp, "%d", _pCoreData->dwInstanceId );

        *lpdwSize = (DWORD)strlen( szTemp ) + 1;
        pData = szTemp;

        break;

    case ServerVariablePathInfo:

        *lpdwSize = _pCoreData->cbPathInfo;
        pData = _pCoreData->szPathInfo;

        break;

    case ServerVariablePathTranslated:

        *lpdwSize = _pCoreData->cbPathTranslated;
        pData = _pCoreData->szPathTranslated;

        break;

    case ServerVariableUnicodePathTranslated:

        *lpdwSize = _pCoreData->cbPathTranslatedW;
        pData = _pCoreData->szPathTranslatedW;

        break;

    case ServerVariableQueryString:

        *lpdwSize = _pCoreData->cbQueryString;
        pData = _pCoreData->szQueryString;

        break;

    case ServerVariableRequestMethod:
    case ServerVariableHttpMethod:

        *lpdwSize = _pCoreData->cbMethod;
        pData = _pCoreData->szMethod;

        break;

    case ServerVariableServerPortSecure:

        sprintf( szTemp, "%d", _pCoreData->fSecure ? 1 : 0 );

        *lpdwSize = (DWORD)strlen( szTemp ) + 1;
        pData = szTemp;

        break;

    case ServerVariableServerProtocol:
    case ServerVariableHttpVersion:

        sprintf( szTemp, "HTTP/%d.%d", _pCoreData->dwVersionMajor, _pCoreData->dwVersionMinor );

        *lpdwSize = (DWORD)strlen( szTemp ) + 1;
        pData = szTemp;

        break;

    case ServerVariableHttpCookie:

        *lpdwSize = _pCoreData->cbCookie;
        pData = _pCoreData->szCookie;

        break;

    case ServerVariableHttpConnection:

        *lpdwSize = _pCoreData->cbConnection;
        pData = _pCoreData->szConnection;

        break;

    default:

        SetLastError( ERROR_INVALID_INDEX );
        return FALSE;
    }

    if ( cbBuffer < *lpdwSize )
    {
        SetLastError( ERROR_INSUFFICIENT_BUFFER );
        return FALSE;
    }

    memcpy( lpvBuffer, pData, *lpdwSize );

    return TRUE;
}

SERVER_VARIABLE_INDEX
LookupServerVariableIndex(
    LPSTR   szServerVariable
    )
{
    //
    // Simple parameter checking...
    //

    if ( szServerVariable == NULL )
    {
        return ServerVariableExternal;
    }

    //
    // Look up the string passed in and see if it matches
    // one of the server variables that's known to be available
    // from ISAPI_CORE_DATA.
    //
    // Note that we only do this in the OOP case, so the cost of
    // failing to match up is trivial compared to the RPC call
    // that'll result.
    //

    switch ( szServerVariable[0] )
    {
    case 'A':

        if ( strcmp( szServerVariable, "APPL_MD_PATH" ) == 0 )
        {
            return ServerVariableApplMdPath;
        }

        break;

    case 'U':

        if ( strcmp( szServerVariable, "UNICODE_APPL_MD_PATH" ) == 0 )
        {
            return ServerVariableUnicodeApplMdPath;
        }

        if ( strcmp( szServerVariable, "UNICODE_PATH_TRANSLATED" ) == 0 )
        {
            return ServerVariableUnicodePathTranslated;
        }

        break;

    case 'C':

        if ( strcmp( szServerVariable, "CONTENT_LENGTH" ) == 0 )
        {
            return ServerVariableContentLength;
        }

        if ( strcmp( szServerVariable, "CONTENT_TYPE" ) == 0 )
        {
            return ServerVariableContentType;
        }

        break;

    case 'I':

        if ( strcmp( szServerVariable, "INSTANCE_ID" ) == 0 )
        {
            return ServerVariableInstanceId;
        }

        break;

    case 'P':

        if ( strcmp( szServerVariable, "PATH_INFO" ) == 0 )
        {
            return ServerVariablePathInfo;
        }

        if ( strcmp( szServerVariable, "PATH_TRANSLATED" ) == 0 )
        {
            return ServerVariablePathTranslated;
        }

    case 'Q':

        if ( strcmp( szServerVariable, "QUERY_STRING" ) == 0 )
        {
            return ServerVariableQueryString;
        }

        break;

    case 'R':

        if ( strcmp( szServerVariable, "REQUEST_METHOD" ) == 0 )
        {
            return ServerVariableRequestMethod;
        }

        break;

    case 'S':

        if ( strcmp( szServerVariable, "SERVER_PORT_SECURE" ) == 0 )
        {
            return ServerVariableServerPortSecure;
        }

        if ( strcmp( szServerVariable, "SERVER_PROTOCOL" ) == 0 )
        {
            return ServerVariableServerProtocol;
        }

        break;

    case 'H':

        if ( strcmp( szServerVariable, "HTTP_COOKIE" ) == 0 )
        {
            return ServerVariableHttpCookie;
        }

        if ( strcmp( szServerVariable, "HTTP_CONNECTION" ) == 0 )
        {
            return ServerVariableHttpConnection;
        }

        if ( strcmp( szServerVariable, "HTTP_METHOD" ) == 0 )
        {
            return ServerVariableHttpMethod;
        }

        if ( strcmp( szServerVariable, "HTTP_VERSION" ) == 0 )
        {
            return ServerVariableHttpVersion;
        }

        break;

    default:

        break;
    }

    return ServerVariableExternal;
}

HRESULT
ISAPI_CONTEXT::SetComStateForOop(
    VOID
    )
{
    HRESULT hr = NOERROR;

    DBG_ASSERT( QueryIsOop() );
    DBG_ASSERT( _pComInitsCookie == NULL );
    DBG_ASSERT( _pComContext == NULL );

    if( QueryIsOop() )
    {    
        hr = CoGetCallContext(
            IID_IComDispatchInfo,
            (void **)&_pComContext
            );


        if( SUCCEEDED(hr) ) 
        {
            hr = _pComContext->EnableComInits( &_pComInitsCookie );
        }
    }

    return hr;
}

VOID
ISAPI_CONTEXT::RestoreComStateForOop(
    VOID
    )
{
    DBG_ASSERT( QueryIsOop() );

    if( _pComContext ) 
    {
        DBG_ASSERT( _pComInitsCookie );

        _pComContext->DisableComInits( _pComInitsCookie );
        _pComContext->Release();

        _pComContext = NULL;
        _pComInitsCookie = NULL;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\iisplus\w3tp\thread_functions.cxx ===
/*++

Copyright (c) 1999-2001 Microsoft Corporation

Module Name:

    thread_functions.cxx

Abstract:

    Public routines for the worker process thread pool

    Creates global instance of THREAD_POOL and forwards calls

Author:

    Taylor Weiss (TaylorW)       12-Jan-2000
    Jeffrey Wall (jeffwall)      April 2001

--*/

#include <iis.h>
#include <dbgutil.h>
#include <thread_pool.h>
#include <regconst.h>

//
// Only initialize ourselves once
//
LONG    g_cInitializeCount = -1;

//
// global pointer for process thread pool
//
THREAD_POOL * g_pThreadPool = NULL;

/**********************************************************************
    Public function definitions
**********************************************************************/

HRESULT
ThreadPoolInitialize( DWORD cbInitialStackSize )
/*++

Routine Description:

    Initializes the thread pool.

    NO SYNCHRONIZATION HERE

    Make sure the initialization of the thread pool is complete (this function returns S_OK)
    before calling other public API functions, including this one.

Arguments:

    None.

Return Value:

    NOERROR if thread pool is initialized
    FAILED() otherwise

--*/
{

    HRESULT hr = S_OK;
    BOOL fRet = FALSE;
    if ( InterlockedIncrement( &g_cInitializeCount ) != 0 )
    {
        //
        // Already inited
        //

        DBGPRINTF(( DBG_CONTEXT,
                    "W3TP: ThreadPoolInitialize() already called\n" ));

        hr = S_OK;
        goto done;
    }

    DBG_ASSERT(NULL == g_pThreadPool);

    THREAD_POOL_CONFIG poolConfig;
    hr = InitializeThreadPoolConfigWithDefaults(&poolConfig);
    if (FAILED(hr))
    {
        goto done;
    }

    hr = OverrideThreadPoolConfigWithRegistry(&poolConfig,
                                              REGISTRY_KEY_INETINFO_PARAMETERS_W);
    if (FAILED(hr))
    {
        goto done;
    }
    
    fRet = THREAD_POOL::CreateThreadPool(&g_pThreadPool, &poolConfig);
    if (FALSE == fRet)
    {
        hr = E_FAIL;
        goto done;
    }

    DBG_ASSERT(NULL != g_pThreadPool);

    hr = S_OK;
done:
    return hr;
}

HRESULT
ThreadPoolTerminate( VOID )
/*++

Routine Description:

    Cleans up the thread pool. At this point all clients should
    have terminated (cleanly we hope) and our threads should
    be idle.

Arguments:

    None.

Return Value:

    NOERROR if clean shutdown
    FAILED() otherwise

--*/
{
    HRESULT hr = S_OK;
    BOOL fRet = FALSE;

    if ( InterlockedDecrement( &g_cInitializeCount ) >= 0 )
    {
        //
        // Someone else is using the pool
        //

        DBGPRINTF(( DBG_CONTEXT,
                    "W3TP: ThreadPoolTerminate() called but pool still in use\n" ));

        hr = S_OK;
        goto done;
    }

    //
    // Now we can cleanup!
    //

    DBG_ASSERT(NULL != g_pThreadPool);

    g_pThreadPool->TerminateThreadPool();

    g_pThreadPool = NULL;

    hr = S_OK;
done:
    return hr;
}

BOOL ThreadPoolPostCompletion(
    IN DWORD dwBytesTransferred,
    IN LPOVERLAPPED_COMPLETION_ROUTINE Function,
    IN LPOVERLAPPED lpo
    )
/*++

Routine Description:

    Posts a completion to the port.  Results in an asynchronous callback.

Arguments:

    dwBytesTransferred - bytes transferred for this completions
    Function - function to call on completion
    lpo - overlapped pointer


Return Value:

    TRUE if completion posted, otherwise FALSE

--*/
{
    DBG_ASSERT(g_pThreadPool);
    return g_pThreadPool->PostCompletion(dwBytesTransferred,
                                         Function,
                                         lpo);
}

BOOL
ThreadPoolBindIoCompletionCallback(
    HANDLE FileHandle,                         // handle to file
    LPOVERLAPPED_COMPLETION_ROUTINE Function,  // callback
    ULONG Flags                                // reserved
    )
/*++

Routine Description:

    Binds given handle to completion port

Arguments:

    FileHandle - handle to bind
    Function - function to call on completion
    Flags - not used

Return Value:

    TRUE if handle bound to port, otherwise FALSE

--*/
{
    DBG_ASSERT(g_pThreadPool);
    return g_pThreadPool->BindIoCompletionCallback(FileHandle,
                                                   Function,
                                                   Flags);
}

ULONG_PTR
ThreadPoolSetInfo(
    IN THREAD_POOL_INFO InfoId,
    IN ULONG_PTR        Data
    )
/*++

Routine Description:

    Sets thread pool configuration data

Arguments:

    InfoId      - Data item to set
    Data        - New value for item

Return Value:

    The old data value

--*/
{
    DBG_ASSERT(g_pThreadPool);
    return g_pThreadPool->SetInfo(InfoId, Data);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\iisplus\w3tp\lib\makefile.inc ===
$(O)\iiswp.res: iiswp.rc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\iisplus\w3tp\dll\makefile.inc ===
$(O)\iiswp.res: iiswp.rc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\iisplus\w3wp\makefile.inc ===
$(O)\iiswp.res: iiswp.rc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\iisplus\w3tp\dll\globals.cxx ===
/*++

Copyright (c) 1999-2001 Microsoft Corporation

Module Name:

    thread_pool.cxx

Abstract:

	Globals

Author:

    Taylor Weiss (TaylorW)       12-Jan-2000
    Jeffrey Wall (jeffwall)      April 2001

--*/

#include <dbgutil.h>
#include <thread_pool.h>


/**********************************************************************
    Globals
**********************************************************************/

DECLARE_DEBUG_PRINTS_OBJECT();
DECLARE_DEBUG_VARIABLE();
DECLARE_PLATFORM_TYPE();

BOOL WINAPI DllMain(
  HINSTANCE hinstDLL,  // handle to the DLL module
  DWORD dwReason,      // reason for calling function
  LPVOID lpvReserved   // reserved
)

{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        g_hmodW3TPDLL = hinstDLL;
        DisableThreadLibraryCalls( hinstDLL );

        CREATE_DEBUG_PRINT_OBJECT("w3tp");
    }
    else if (dwReason == DLL_PROCESS_DETACH)
    {
        DELETE_DEBUG_PRINT_OBJECT();
    }

    return TRUE;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\iisplus\w3tp\thread_pool.cxx ===
/*++

Copyright (c) 1999-2001 Microsoft Corporation

Module Name:

    thread_pool.cxx

Abstract:

    THREAD_POOL implementation

    THREAD_POOL_DATA definition and implementation

Author:

    Taylor Weiss (TaylorW)       12-Jan-2000
    Jeffrey Wall (jeffwall)      April 2001

--*/

#include <iis.h>
#include <dbgutil.h>
#include <thread_pool.h>
#include "thread_pool_private.h"
#include "thread_manager.h"
#include <reftrace.h>



/**********************************************************************
    Globals
**********************************************************************/


static
CONST TCHAR s_szConfigRegKey[] =
    TEXT("System\\CurrentControlSet\\Services\\InetInfo\\Parameters");


//static
BOOL
THREAD_POOL::CreateThreadPool(THREAD_POOL ** ppThreadPool,
                              THREAD_POOL_CONFIG * pThreadPoolConfig)
/*++

Routine Description:
    Creates and initializes a THREAD_POOL object

Arguments:
    ppThreadPool - storage for pointer of allocated THREAD_POOL

Return Value:
    BOOL - TRUE if pool successfully created and initialized, else FALSE

--*/
{
    BOOL fRet = FALSE;
    THREAD_POOL * pThreadPool = NULL;
    THREAD_POOL_DATA * pData = NULL;

    DBG_ASSERT(NULL != ppThreadPool);
    *ppThreadPool = NULL;

    pThreadPool = new THREAD_POOL;
    if (NULL == pThreadPool)
    {
        fRet = FALSE;
        goto done;
    }

    pData = new THREAD_POOL_DATA(pThreadPool);
    if (NULL == pData)
    {
        fRet = FALSE;
        goto done;
    }

    // give threadpool object ownership of THREAD_POOL_DATA memory
    pThreadPool->m_pData = pData;
    pData = NULL;

    fRet = pThreadPool->m_pData->InitializeThreadPool(pThreadPoolConfig);
    if (FALSE == fRet)
    {
        goto done;
    }

    // created and initialized thread pool returned
    *ppThreadPool = pThreadPool;
    pThreadPool = NULL;
    
    fRet = TRUE;
done:
    if (pThreadPool)
    {
        pThreadPool->TerminateThreadPool();
        pThreadPool = NULL;
    }
    
    return fRet;
}

THREAD_POOL::THREAD_POOL()
/*++

Routine Description:
    THREAD_POOL constructor
    Interesting work occurs in InitializeThreadPool

Arguments:
    none

Return Value:
    none

--*/
{
    m_pData = NULL;
}

THREAD_POOL::~THREAD_POOL()
/*++

Routine Description:
    THREAD_POOL destructor
    Interesting work occurs in TerminateThreadPool

Arguments:
    none

Return Value:
    none

--*/
{
    delete m_pData;
    m_pData = NULL;
}

HRESULT
InitializeThreadPoolConfigWithDefaults(THREAD_POOL_CONFIG * pThreadPoolConfig)
{

/*++

Routine Description:
    Calculate/Set default values for the THREAD_POOL_CONFIG
    
Arguments:
    pThreadPoolConfig - structure of config parametes
    
Return Value:
    HRESULT

--*/
    DBG_ASSERT(NULL != pThreadPoolConfig);
    ZeroMemory(pThreadPoolConfig, sizeof(THREAD_POOL_CONFIG));

    BOOL    IsNtServer;

    INITIALIZE_PLATFORM_TYPE();

    //
    // Only scale for NT Server
    //

    IsNtServer = TsIsNtServer();

    SYSTEM_INFO     si;
    GetSystemInfo( &si );
    g_dwcCPU = si.dwNumberOfProcessors;

    if( IsNtServer )
    {
        MEMORYSTATUS    ms;


        //
        // get the memory size
        //

        ms.dwLength = sizeof(MEMORYSTATUS);
        GlobalMemoryStatus( &ms );

        //
        // Alloc two threads per MB of memory.
        //

        pThreadPoolConfig->dwAbsoluteMaximumThreadCount = (LONG)((ms.dwTotalPhys >> 19) + 2);

        if ( pThreadPoolConfig->dwAbsoluteMaximumThreadCount < THREAD_POOL_REG_MIN_POOL_THREAD_LIMIT )
        {
            pThreadPoolConfig->dwAbsoluteMaximumThreadCount = THREAD_POOL_REG_MIN_POOL_THREAD_LIMIT;
        }
        else if ( pThreadPoolConfig->dwAbsoluteMaximumThreadCount > THREAD_POOL_REG_MAX_POOL_THREAD_LIMIT )
        {
            pThreadPoolConfig->dwAbsoluteMaximumThreadCount = THREAD_POOL_REG_MAX_POOL_THREAD_LIMIT;
        }
    }
    else
    {
        // Not server

        pThreadPoolConfig->dwAbsoluteMaximumThreadCount = THREAD_POOL_REG_MIN_POOL_THREAD_LIMIT;
    }

   
    // the Concurrency factor for the completion port
    //

    pThreadPoolConfig->dwConcurrency
        = THREAD_POOL_REG_DEF_PER_PROCESSOR_CONCURRENCY;

    //
    // the count of threads to be allowed per processor
    //

    pThreadPoolConfig->dwSoftLimitThreadCount 
        = THREAD_POOL_REG_DEF_PER_PROCESSOR_THREADS * g_dwcCPU;


    //
    // the time (in seconds) of how long the threads
    // can stay alive when there is no IO operation happening on
    // that thread.
    //

    pThreadPoolConfig->dwThreadTimeout
        = THREAD_POOL_REG_DEF_THREAD_TIMEOUT * 1000;

    //
    // Read the number of threads to start
    // with a default of one per CPU and a floor of 4
    //
    if (g_dwcCPU < 4)
    {
        pThreadPoolConfig->dwInitialThreadCount = 4;
    }
    else
    {
        pThreadPoolConfig->dwInitialThreadCount = g_dwcCPU;
    }
    
    pThreadPoolConfig->dwMaxCPUUsage
        = THREAD_POOL_MAX_CPU_USAGE_DEFAULT;
    
    pThreadPoolConfig->dwPerSecondContextSwitchMax 
        = THREAD_POOL_CONTEXT_SWITCH_RATE;
    
    pThreadPoolConfig->dwTimerPeriod
        = THREAD_POOL_TIMER_CALLBACK;

    pThreadPoolConfig->dwExactThreadCount
        = THREAD_POOL_EXACT_NUMBER_OF_THREADS_DEFAULT;
    
    return S_OK;
    
}

HRESULT
OverrideThreadPoolConfigWithRegistry(
    IN OUT THREAD_POOL_CONFIG * pThreadPoolConfig,
    IN     WCHAR * pszRegistryPath )
{
/*++

Routine Description:

    Override the default threadpool values 
    (as set by InitializeThreadPoolConfigWithDefaults) with values stored in registry

Arguments:
    pThreadPoolConfig - structure of config parametes
    pszRegistryPath -  location in the registry where the overriding parameters are stored

Return Value:
    HRESULT

--*/

    DBG_ASSERT(NULL != pThreadPoolConfig);
   
    //
    // Get configuration parameters from the registry
    //

    HKEY    hKey = NULL;
    DWORD   dwVal;
    DWORD   dwError;

    //
    // BUGBUG - ACL may deny this if process level is insufficient
    //

    dwError = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                            pszRegistryPath,
                            0,
                            KEY_READ,
                            &hKey
                            );

    if( dwError == NO_ERROR )
    {
        //
        // Read the Concurrency factor for the completion port
        //

        pThreadPoolConfig->dwConcurrency
            = I_ThreadPoolReadRegDword(
                    hKey,
                    THREAD_POOL_REG_PER_PROCESSOR_CONCURRENCY,
                    pThreadPoolConfig->dwConcurrency
                    );

        //
        // Read the count of threads to be allowed per processor
        //

        pThreadPoolConfig->dwSoftLimitThreadCount 
            = I_ThreadPoolReadRegDword(
                    hKey,
                    THREAD_POOL_REG_PER_PROCESSOR_THREADS,
                    pThreadPoolConfig->dwSoftLimitThreadCount
                    );

        //
        // Read the time (in seconds) of how long the threads
        //   can stay alive when there is no IO operation happening on
        //   that thread.
        //

        pThreadPoolConfig->dwThreadTimeout
            = I_ThreadPoolReadRegDword(
                    hKey,
                    THREAD_POOL_REG_THREAD_TIMEOUT,
                    pThreadPoolConfig->dwThreadTimeout
                    );


        //
        // Read the max thread limit. We've already computed a limit
        // based on memory, but allow registry override.
        //

        pThreadPoolConfig->dwAbsoluteMaximumThreadCount
                = I_ThreadPoolReadRegDword(
                                hKey,
                                THREAD_POOL_REG_POOL_THREAD_LIMIT,
                                pThreadPoolConfig->dwAbsoluteMaximumThreadCount
                                );

        //
        // Read the number of threads to start
        // with a default of one per CPU and a floor of 4
        //
       
        pThreadPoolConfig->dwInitialThreadCount
            = I_ThreadPoolReadRegDword(
                                hKey,
                                THREAD_POOL_REG_POOL_THREAD_START,
                                pThreadPoolConfig->dwInitialThreadCount
                                );

        
        pThreadPoolConfig->dwMaxCPUUsage
            = I_ThreadPoolReadRegDword(
                                hKey,
                                THREAD_POOL_REG_MAX_CPU,
                                pThreadPoolConfig->dwMaxCPUUsage
                                );
        
        pThreadPoolConfig->dwPerSecondContextSwitchMax =
            I_ThreadPoolReadRegDword(hKey,
                                     THREAD_POOL_REG_MAX_CONTEXT_SWITCH,
                                     pThreadPoolConfig->dwPerSecondContextSwitchMax
                                     );
        
        pThreadPoolConfig->dwTimerPeriod =
            I_ThreadPoolReadRegDword(hKey,
                                     THREAD_POOL_REG_START_DELAY,
                                     pThreadPoolConfig->dwTimerPeriod 
                                     );

        pThreadPoolConfig->dwExactThreadCount =
            I_ThreadPoolReadRegDword(hKey,
                                     THREAD_POOL_REG_EXACT_THREAD_COUNT,
                                     pThreadPoolConfig->dwExactThreadCount
                                     );
        
        RegCloseKey( hKey );
        hKey = NULL;
    }

    return S_OK;
    
}



BOOL
THREAD_POOL_DATA::InitializeThreadPool(THREAD_POOL_CONFIG * pThreadPoolConfig)
/*++

Routine Description:

    Initializes a THREAD_POOL object.
    Determines thread limits, reads settings from registry
    creates completion port, creates THREAD_MANAGER
    and creates initial threads

Arguments:
    none

Return Value:
    BOOL - TRUE if pool successfully initialized, else FALSE

--*/
{
    BOOL fRet = FALSE;
    HRESULT hr = S_OK;

    DBG_ASSERT(NULL != pThreadPoolConfig);
    

#if DBG
    HKEY    hKey = NULL;
    DWORD   dwVal;
    DWORD   dwError;
    
    dwError = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                            s_szConfigRegKey,
                            0,
                            KEY_READ,
                            &hKey
                            );
    if( dwError == NO_ERROR )
    {

        //
        // Read the Reg setting for Ref Tracing
        //

        m_dwTraceRegSetting = TRACE_WHEN_NULL;
        m_dwTraceRegSetting = I_ThreadPoolReadRegDword(
                                  hKey,
                                  THREAD_POOL_REG_REF_TRACE_COUNTER,
                                  m_dwTraceRegSetting
                                  );
        RegCloseKey( hKey );
        hKey = NULL;

    }
    
#endif

#ifdef DBG
    // initialize refernce logging variable, else it's already set to null in the constructor
    if (m_dwTraceRegSetting != TRACE_NONE)
    {
        m_pTraceLog = CreateRefTraceLog(2000, 0);

        if( !m_pTraceLog )
        {
            fRet = FALSE;
            goto cleanup;
        }
    }
#endif

    CopyMemory(&m_poolConfig, pThreadPoolConfig, sizeof(m_poolConfig));

    hr = THREAD_MANAGER::CreateThreadManager(&m_pThreadManager, m_pPool, this);
    if (FAILED(hr))
    {
        fRet = FALSE;
        goto cleanup;
    }

    //
    // Create the completion port
    //

    m_hCompPort = CreateIoCompletionPort( INVALID_HANDLE_VALUE,
                                          NULL,
                                          0,
                                          m_poolConfig.dwConcurrency
                                          );
    if( !m_hCompPort )
    {
        fRet = FALSE;
        goto cleanup;
    }

    // When the exact thread count is set, the initial count does not matter
    if ( m_poolConfig.dwExactThreadCount )
    {
        m_poolConfig.dwInitialThreadCount = m_poolConfig.dwExactThreadCount;
    }
    
    //
    // Create our initial threads
    //
    if (m_poolConfig.dwInitialThreadCount < 1)
    {
        m_poolConfig.dwInitialThreadCount = 1;
    }

    for(DWORD i = 0; i < m_poolConfig.dwInitialThreadCount; i++)
    {
        DBG_REQUIRE( m_pThreadManager->CreateThread(ThreadPoolThread,
                                                    (LPVOID) this) );
    }

    fRet = TRUE;
    return fRet;

    //
    // Only on failure
    //
cleanup:

    if( m_hCompPort != NULL )
    {
        CloseHandle( m_hCompPort );
        m_hCompPort = NULL;
    }

    return fRet;
}

VOID
THREAD_POOL::TerminateThreadPool()
/*++

Routine Description:
    cleans up and destroys a THREAD_POOL object

    CAVEAT: blocks until all threads in pool have terminated

Arguments:
    none

Return Value:
    none

--*/
{
    DBGPRINTF(( DBG_CONTEXT,
                "W3TP: Cleaning up thread pool.\n" ));


    if ( m_pData->m_fShutdown )
    {
        //
        // We have not been intialized or have already terminated.
        //

        DBG_ASSERT( FALSE );
        return;
    }

    m_pData->m_fShutdown = TRUE;

    if ( m_pData->m_pThreadManager )
    {
        m_pData->m_pThreadManager->TerminateThreadManager(THREAD_POOL_DATA::ThreadPoolStop, 
                                                          m_pData);
        m_pData->m_pThreadManager = NULL;
    }

    if ( m_pData->m_hCompPort )
    {
        CloseHandle( m_pData->m_hCompPort );
        m_pData->m_hCompPort = NULL;
    }

#if DBG
    // delete the logging object
    if ( m_pData->m_pTraceLog )
    {
        DestroyRefTraceLog(m_pData->m_pTraceLog);
        m_pData->m_pTraceLog = NULL;
    }

    m_pData->m_dwTraceRegSetting = 0;
#endif

    // finally, release this objects memory
    delete this;

    return;
}

//static
void
WINAPI
THREAD_POOL_DATA::ThreadPoolStop(VOID * pvThis)
/*++

Routine Description:
    posts completion to signal one thread to terminate

Arguments:
    pvThis - THREAD_POOL this pointer

Return Value:
    none

--*/
{
    BOOL        fRes;
    OVERLAPPED  Overlapped;
    ZeroMemory( &Overlapped, sizeof(OVERLAPPED) );

    THREAD_POOL_DATA * pThis= reinterpret_cast<THREAD_POOL_DATA*>(pvThis);

    fRes = PostQueuedCompletionStatus( pThis->m_hCompPort,
                                       0,
                                       THREAD_POOL_THREAD_EXIT_KEY,
                                       &Overlapped
                                       );
    DBG_ASSERT( fRes ||
                (!fRes && GetLastError() == ERROR_IO_PENDING)
                );
    return;
}

ULONG_PTR
THREAD_POOL::SetInfo(IN THREAD_POOL_INFO InfoId,
                               IN ULONG_PTR        Data)
/*++

Routine Description:

    Sets thread pool configuration data

Arguments:

    InfoId      - Data item to set
    Data        - New value for item

Return Value:

    The old data value

--*/
{
    ULONG_PTR oldVal = 0;

    switch ( InfoId )
    {


    //
    //  Increment or decrement the max thread count.  In this instance, we
    //  do not scale by the number of CPUs
    //

    case ThreadPoolIncMaxPoolThreads:
        InterlockedIncrement( (LONG *) &m_pData->m_poolConfig.dwSoftLimitThreadCount );
        oldVal = TRUE;
        break;

    case ThreadPoolDecMaxPoolThreads:
        InterlockedDecrement( (LONG *) &m_pData->m_poolConfig.dwSoftLimitThreadCount );
        oldVal = TRUE;
        break;

    default:
        DBG_ASSERT( FALSE );
        break;

    } // switch

    return oldVal;

} // ThreadPoolSetInfo()


BOOL
THREAD_POOL::BindIoCompletionCallback(HANDLE FileHandle,                         // handle to file
                                      LPOVERLAPPED_COMPLETION_ROUTINE Function,  // callback
                                      ULONG Flags                                // reserved
                                      )
/*++

Routine Description:

    Binds given handle to completion port

Arguments:

    FileHandle - handle to bind
    Function - function to call on completion
    Flags - not used

Return Value:

    TRUE if handle bound to port, otherwise FALSE

--*/
{
    DBG_ASSERT( FileHandle && FileHandle != INVALID_HANDLE_VALUE );
    DBG_ASSERT( Function );
    DBG_ASSERT( m_pData->m_hCompPort );

    return ( CreateIoCompletionPort( FileHandle,
                                     m_pData->m_hCompPort,
                                     (ULONG_PTR)Function,
                                     m_pData->m_poolConfig.dwConcurrency ) != NULL );
}

BOOL
THREAD_POOL::PostCompletion(IN DWORD dwBytesTransferred,
                            IN LPOVERLAPPED_COMPLETION_ROUTINE function,
                            IN LPOVERLAPPED lpo)
/*++

Routine Description:

    Posts a completion to the port.  Results in an asynchronous callback.

Arguments:

    dwBytesTransferred - bytes transferred for this completions
    Function - function to call on completion
    lpo - overlapped pointer


Return Value:

    TRUE if completion posted, otherwise FALSE

--*/
{
    DBG_ASSERT( m_pData->m_hCompPort && m_pData->m_hCompPort != INVALID_HANDLE_VALUE );
#if DBG
    //
    // If m_pTraceData is not null then
    // Trace the function pointer when lpo is zero and reg setting is TRACE_WHEN NULL (1)
    // or when reg setting is TRACE_ALWAYS (2)
    //
    if ( m_pData->m_pTraceLog )
    {
        if ( ( !lpo  && (m_pData->m_dwTraceRegSetting == TRACE_WHEN_NULL) ) ||
             ( m_pData->m_dwTraceRegSetting == TRACE_ALWAYS )
             )
        {
            WriteRefTraceLog(m_pData->m_pTraceLog, 0, function );
        }
    }
#endif
    return ( PostQueuedCompletionStatus( m_pData->m_hCompPort,
                                         dwBytesTransferred,
                                         (ULONG_PTR)function,
                                         lpo ) != NULL );
}

BOOL
ThreadHasIOPending()
/*++

Routine Description:

    Determine if the current threads has any outstanding I/O associated with it

Arguments:

    VOID

Return Value:

    BOOL - TRUE indicates I/O is pending on this thread

--*/
{
    //
    // BUGBUG - Dependency on ntdll
    //
    NTSTATUS NtStatus;
    ULONG    ThreadHasPendingIo = TRUE;

    NtStatus = NtQueryInformationThread( NtCurrentThread(),
                                         ThreadIsIoPending,
                                         &ThreadHasPendingIo,
                                         sizeof(ThreadHasPendingIo),
                                         NULL);
    DBG_ASSERT( NT_SUCCESS( NtStatus ) );

    return !!ThreadHasPendingIo;
}

//
// Thread pool thread function
//

//static
DWORD
THREAD_POOL_DATA::ThreadPoolThread(
    LPVOID pvThis
    )
/*++

Routine Description:

    Thread pool thread function

Arguments:

    pvThis - pointer to THREAD_POOL

Return Value:

    Thread return value (ignored)

--*/
{
    THREAD_POOL_DATA *pThis = reinterpret_cast<THREAD_POOL_DATA*>(pvThis);
    DBG_ASSERT(pThis);

    BOOL             fFirst = FALSE;
    DWORD            dwRet  = ERROR_SUCCESS;

    //
    // Increment the total thread count and mark the
    // threads that we spin up at startup to not timeout
    //
    if ( pThis->m_poolConfig.dwInitialThreadCount >= 
         (DWORD) InterlockedIncrement( &pThis->m_cThreads ) )
    {
        fFirst = TRUE;
    }


    for (;;)
    {
        //
        // Begin looping on I/O completion port 
        //
        dwRet = pThis->ThreadPoolThread();

        //
        // always exit threads at shutdown
        //
        if ( pThis->m_fShutdown )
        {
            break;
        }

        //
        // Keep the initial threads alive.
        //
        if( TRUE == fFirst )
        {
            continue;
        }

        //
        // Threads cannot exit if I/O is pending on it
        //
        if ( ThreadHasIOPending() )
        {
            continue;
        }

        //
        // thread returned from completion processing function 
        // and has no reason to stick around
        //
        break;

    } // for(;;)

    //
    // Let ThreadPoolTerminate know that all the threads are dead
    //
    InterlockedDecrement( &pThis->m_cThreads );


    // Unless shutting down, threads must not exit with pending I/O
    DBG_ASSERT( pThis->m_fShutdown || !ThreadHasIOPending());

    // Unless shutting down, the threads created first must not exit
    DBG_ASSERT( pThis->m_fShutdown || !fFirst );

    return dwRet;
}

DWORD
THREAD_POOL_DATA::ThreadPoolThread()
/*++

Routine Description:

    Thread pool thread function

Arguments:

    none

Return Value:

    Thread return value (ignored)

--*/
{
    BOOL            fRet;
    DWORD           BytesTransfered;
    LPOVERLAPPED    lpo = NULL;
    DWORD           ReturnCode = ERROR_SUCCESS;
    DWORD           LastError;

    LPOVERLAPPED_COMPLETION_ROUTINE CompletionCallback;

    for(;;)
    {
        lpo = NULL;

        //
        // wait for the configured timeout
        //
        
        InterlockedIncrement( &m_cAvailableThreads );

        fRet = GetQueuedCompletionStatus( m_hCompPort,  // completion port to wait on
                                          &BytesTransfered, // number of bytes transferred
                                          (ULONG_PTR *)&CompletionCallback, // function pointer
                                          &lpo,             // buffer to fill
                                          m_poolConfig.dwThreadTimeout  // timeout in milliseconds
                                          );
                                          
        InterlockedDecrement( &m_cAvailableThreads );

        LastError = fRet ? ERROR_SUCCESS : GetLastError();

        if( fRet || lpo )
        {
            //
            // There was a completion.
            //

            if( CompletionCallback == 
                (LPOVERLAPPED_COMPLETION_ROUTINE) THREAD_POOL_THREAD_EXIT_KEY )
            {
                //
                // signal to exit this thread
                //
                ReturnCode = ERROR_SUCCESS;
                break;
            }

            DBG_ASSERT ( CompletionCallback );

            //
            // This thread is about to go do work so check the state of the pool
            //
            ThreadPoolCheckThreadStatus();

            //
            // Call the completion function.
            //
            CompletionCallback( LastError, BytesTransfered, lpo );
        }
        else
        {
            //
            // No completion, timeout or error.
            // Something bad happened or thread timed out.
            //

            ReturnCode = LastError;
            break;
        }
    } // for(;;)

    return ReturnCode;
}

BOOL WINAPI
THREAD_POOL_DATA::OkToCreateAnotherThread()
/*++

Routine Description:

    determines whether or not thread pool should have another thread created
    based on shutting down, exact thread count, available threads, current limit, and max limit

Arguments:

    void

Return Value:

    TRUE if another thread is ok to create, otherwise FALSE

--*/
{
    if (!m_fShutdown &&
        (m_poolConfig.dwExactThreadCount == 0) &&
        (m_cAvailableThreads == 0) &&
        ((DWORD)m_cThreads < m_poolConfig.dwSoftLimitThreadCount) &&
        ((DWORD)m_cThreads < m_poolConfig.dwAbsoluteMaximumThreadCount) )
    {
        return TRUE;
    }
    return FALSE;
}

BOOL
THREAD_POOL_DATA::ThreadPoolCheckThreadStatus()
/*++

Routine Description:

    Make sure there is at least one thread in the thread pool.
    We're fast and loose so a couple of extra threads may be
    created.



Arguments:

    ThreadParam - usually NULL, may be used to signify
                  special thread status.

Return Value:

    TRUE if successful
    FALSE thread

--*/
{
    BOOL fRet = TRUE;

    // CODEWORK: Should investigate making this stickier. It should
    // not be quite so easy to create threads.


    if ( OkToCreateAnotherThread() )
    {
        DBG_ASSERT( NULL != m_pThreadManager );

        m_pThreadManager->RequestThread(ThreadPoolThread,       // thread function
                                        this            // thread argument
                                        );
    }

    return fRet;
}

/**********************************************************************
    Private function definitions
**********************************************************************/

DWORD
I_ThreadPoolReadRegDword(
   IN HKEY     hKey,
   IN LPCTSTR  pszValueName,
   IN DWORD    dwDefaultValue
   )
/*++

Routine Description:

    Reads a DWORD value from the registry

Arguments:

    hKey - Opened registry key to read

    pszValueName - The name of the value.

    dwDefaultValue - The default value to use if the
        value cannot be read.


Return Value:

    DWORD - The value from the registry, or dwDefaultValue.

--*/
{
    DWORD  err;
    DWORD  dwBuffer;
    DWORD  cbBuffer = sizeof(dwBuffer);
    DWORD  dwType;

    if( hKey != NULL )
    {
        err = RegQueryValueEx( hKey,
                               pszValueName,
                               NULL,
                               &dwType,
                               (LPBYTE)&dwBuffer,
                               &cbBuffer
                               );

        if( ( err == NO_ERROR ) && ( dwType == REG_DWORD ) )
        {
            dwDefaultValue = dwBuffer;
        }
    }

    return dwDefaultValue;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\iisplus\w3wp\dbgutil.h ===
/*++

Copyright (c) 1994-1998 Microsoft Corporation

Module Name:

    dbgutil.h

Abstract:

    This module declares the macros to wrap around DEBUG_PRINTS class
    defined in pudebug.h    
  
    This is the exported header file, that the users are allowed to modify.
    If there are no custom definitions, please use the templated version
    in the root iisrearc\inc\dbgutil.h
 
Author:

    Murali R. Krishnan (MuraliK)    22-Sept-1994

--*/


# ifndef _DBGUTIL_H_
# define _DBGUTIL_H_



// begin_user_modifiable

//
//  Modify the following flags if necessary
//

# define DEFAULT_OUTPUT_FLAGS   ( DbgOutputStderr | DbgOutputKdb )

// end_user_modifiable


//
// include standard debug support
//
// note: define DEFAULT_OUTPUT_FLAGS before including pudebug.h
//

# include <pudebug.h>


// begin_user_modifiable

// Use the default constants from pudebug.h: 0x00000001 to 0x00000100

//
//  Define the debugging constants as bit-flag values
//  Example: # define DEBUG_FOOBAR 0x00010000
//  Note: All debugging bit-values below 0x00001000 are reserved!
// 
//  If you add or change a flag, please update FlagTableWp
//  in core\common\dtflags\dtflags.c
//

#define DEBUG_TRACE             0x10000000

// end_user_modifiable


# endif  /* _DBGUTIL_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\iisplus\w3tp\thread_manager.cxx ===
/*++

Copyright (c) 2000-2001 Microsoft Corporation

Module Name:

    thread_manager.cxx

Abstract:

    implementation for THREAD_MANAGER

Author:

    Jeffrey Wall (jeffwall)     11-28-2000

Revision History:



--*/

#include <iis.h>
#include <dbgutil.h>
#include "thread_manager.h"
#include "thread_pool_private.h"

TCHAR g_szModuleName[MAX_PATH];
DWORD g_dwcCPU = 1;

HMODULE g_hmodW3TPDLL = NULL;

BOOL
TooMuchContextSwitchingLoad(ULONG ulFirstSample,
                  DWORD dwFirstSampleTime,
                  ULONG ulPerSecondSwitchRateMax,
                  DWORD dwNumProcs);

BOOL
TooMuchProcessorUsage(LARGE_INTEGER liOriginalBusy,
                        LARGE_INTEGER liOriginalTotal,
                        LONG lPercentageUseMax,
                        DWORD dwNumProcs);

BOOL GetContextSwitchCount(ULONG * pulSwitchCount);

HRESULT
GetCPUData(LARGE_INTEGER * pBusyTime,
           LARGE_INTEGER * pTotalTime,
           DWORD dwNumProcs);

//static
HRESULT
THREAD_MANAGER::CreateThreadManager(THREAD_MANAGER ** ppManager,
                                    THREAD_POOL * pPool,
                                    THREAD_POOL_DATA * pPoolData)
/*++

Routine Description:
    Allocate and initialize a THREAD_MANAGER

Arguments:

    ppManager - where to store allocated manager pointer
    pPool - pointer to THREAD_POOL associated with this manager
    pPoolData - pointer to THREAD_POOL_DATA associated with this manager

Return Value:

    HRESULT
--*/
{
    DBG_ASSERT(NULL != ppManager);
    DBG_ASSERT(NULL != pPool);
    DBG_ASSERT(NULL != pPoolData);

    *ppManager = NULL;

    HRESULT hr = S_OK;

    THREAD_MANAGER * pManager = new THREAD_MANAGER(pPool, pPoolData);
    if (NULL == pManager)
    {
        hr = E_OUTOFMEMORY;
        goto done;
    }

    hr = pManager->Initialize();
    if (FAILED(hr))
    {
        // don't call TerminateThreadManager - just delete it
        delete pManager;

        goto done;
    }

    *ppManager = pManager;

    hr = S_OK;
done:
    return hr;
}

VOID
THREAD_MANAGER::TerminateThreadManager(LPTHREAD_STOP_ROUTINE lpStopAddress,
                                       LPVOID lpParameter)
/*++

Routine Description:
    Shutdown ALL THREAD_MANAGER theads and destroy a THREAD_MANAGER

Arguments:

    lpStopAddress - address of function that will stop threads
    lpParameter - argument to pass to stop function

Return Value:

    VOID
--*/
{
    // block until threads are gone
    DrainThreads(lpStopAddress, lpParameter);

    // do some initializion succeeded only cleanup
    if (m_hShutdownEvent)
    {
        CloseHandle(m_hShutdownEvent);
        m_hShutdownEvent = NULL;
    }
    if (m_hParkEvent)
    {
        CloseHandle(m_hParkEvent);
        m_hParkEvent = NULL;
    }

    DeleteCriticalSection(&m_CriticalSection);

    // don't do anything else after deletion
    delete this;

    return;
}




THREAD_MANAGER::THREAD_MANAGER(THREAD_POOL * pPool,
                               THREAD_POOL_DATA * pPoolData) :
    m_dwSignature(SIGNATURE_THREAD_MANAGER),
    m_fShuttingDown(FALSE),
    m_fWaitingForCreationCallback(FALSE),
    m_hTimer(NULL),
    m_pParam(NULL),
    m_hParkEvent(NULL),
    m_hShutdownEvent(NULL),
    m_lParkedThreads(0),
    m_pPool(pPool),
    m_pPoolData(pPoolData),
    m_lTotalThreads(0)
/*++

Routine Description:

    Constructs the ThreadManager

Arguments:

    None

Return Value:

    None

--*/
{
    DBG_ASSERT(m_pPool);
    DBG_ASSERT(m_pPoolData);
    ZeroMemory(&m_liOriginalBusy, sizeof(LARGE_INTEGER));
    ZeroMemory(&m_liOriginalTotal, sizeof(LARGE_INTEGER));

    return;
}

HRESULT
THREAD_MANAGER::Initialize()
/*++

Routine Description:
    Do initialization for THREAD_MANAGER

Arguments:

    VOID
Return Value:

    HRESULT
--*/
{
    HRESULT hr = S_OK;

    DWORD dwRet;
    HKEY hKey;
    BOOL fRet;

    // Must be set by the DLL main of the DLL loading w3tp 
    DBG_ASSERT( NULL != g_hmodW3TPDLL );
    
    if ( GetModuleFileNameW(
            g_hmodW3TPDLL,
            g_szModuleName,
            MAX_PATH
            ) == 0 )
    {
        DBG_ASSERT(FALSE && "Failed getting module name for w3tp.dll");
        hr = E_FAIL;
        goto done;
    }

    m_hParkEvent = CreateEvent(NULL,    // security descriptor
                               FALSE,   // auto reset
                               FALSE,   // not signaled at creation
                               NULL     // event name
                               );
    if (NULL == m_hParkEvent)
    {
        DBG_ASSERT(FALSE && "Could not create parking event");
        hr = E_FAIL;
        goto done;
    }
    m_hShutdownEvent = CreateEvent(NULL,    // security descriptor
                                   TRUE,    // manual reset
                                   FALSE,   // not signaled at creation
                                   NULL     // event name
                                   );
    if (NULL == m_hShutdownEvent)
    {
        DBG_ASSERT(FALSE && "Could not create shutdown event");
        hr = E_FAIL;
        goto done;
    }


    // keep this at the end of Initialize - if it fails, no need to clean it up ever
    // If it succeededs, no need to clean it up in this function.

    // By setting the high order bit for dwSpinCount, we preallocate the CriticalSection
    fRet = InitializeCriticalSectionAndSpinCount(&m_CriticalSection,
                                                 0x80000000 );
    if (FALSE == fRet)
    {
        DBG_ASSERT(FALSE && "Could not initialize critical section!");
        hr = E_FAIL;
        goto done;
    }

    hr = S_OK;
done:
    if (FAILED(hr))
    {
        if (m_hParkEvent)
        {
            CloseHandle(m_hParkEvent);
            m_hParkEvent = NULL;
        }
        if (m_hShutdownEvent)
        {
            CloseHandle(m_hShutdownEvent);
            m_hShutdownEvent = NULL;
        }
    }

    return hr;
}

THREAD_MANAGER::~THREAD_MANAGER()
/*++

Routine Description:

    Destructs the ThreadManager

Arguments:

    None

Return Value:

    None

--*/
{
    DBG_ASSERT(SIGNATURE_THREAD_MANAGER == m_dwSignature);
    m_dwSignature = SIGNATURE_THREAD_MANAGER_FREE;

    DBG_ASSERT(TRUE == m_fShuttingDown && "DrainThreads was not called!");

    DBG_ASSERT(NULL == m_hTimer);
    DBG_ASSERT(NULL == m_pParam);
    DBG_ASSERT(0 == m_lParkedThreads);
    DBG_ASSERT(0 == m_lTotalThreads);

    m_pPool = NULL;
    m_pPoolData = NULL;
}

//static
DWORD
THREAD_MANAGER::ThreadManagerThread(LPVOID ThreadParam)
/*++

Routine Description:
    Starter thread for THREAD_MANAGER created threads
    Takes a reference against the current DLL
    Notifies THREAD_MANAGER that it has started execution
    Calls out to "real" thread procedure
    Notifies THREAD_MANAGER that it is about to terminate
    Releases reference to current DLL and terminates

Arguments:

    ThreadParam - parameters for control of thread

Return Value:

    win32 error or return value from "real" thread proc
--*/
{
    HMODULE         hModuleDll;
    DWORD           dwReturnCode;
    THREAD_PARAM   *pParam = NULL;
    pParam = (THREAD_PARAM*)ThreadParam;

    // grab a reference to this DLL
    hModuleDll = LoadLibrary(g_szModuleName);
    if (NULL == hModuleDll)
    {
        dwReturnCode = GetLastError();
        goto done;
    }

    // verify the thread parameter passed was reasonable
    DBG_ASSERT(NULL != pParam);
    DBG_ASSERT(NULL != pParam->pThreadManager);
    DBG_ASSERT(NULL != pParam->pThreadFunc);

    if (pParam->fCallbackOnCreation)
    {
        // Inform thread manager that this thread has successfully gotten through the loader lock
        pParam->pThreadManager->CreatedSuccessfully(pParam);
    }

    // actually do work thread is supposed to do
    dwReturnCode = pParam->pThreadFunc(pParam->pvThreadArg);

done:
    // Inform thread manager that this thread is going away
    pParam->pThreadManager->RemoveThread(pParam);

    // Thread owns[ed] memory passed
    delete pParam;

    // release reference to this DLL
    FreeLibraryAndExitThread(hModuleDll, dwReturnCode);

    // never executed
    return dwReturnCode;
}

VOID
THREAD_MANAGER::RequestThread(LPTHREAD_START_ROUTINE lpStartAddress,
                              LPVOID lpStartParameter)
/*++

Routine Description:

    Creates a timer to determine the correct thread action to take.

    May create a thread in a little while
    May take away a thread in a little while
    May not create the timer if there is another thread creation going on

Arguments:

    lpStartAddress  - address of function to begin thread execution
    lpParameter     - argument to pass to start function

Return Value:

    VOID

--*/
{
    BOOL        fRet = FALSE;
    HRESULT     hr;
    
    DBG_ASSERT(NULL != lpStartAddress);

    if (TRUE == m_fShuttingDown ||
        TRUE == m_fWaitingForCreationCallback)
    {
        return;
    }

    //
    // only want to create one timer at a time
    //
    EnterCriticalSection(&m_CriticalSection);

    if (TRUE == m_fShuttingDown ||
        TRUE == m_fWaitingForCreationCallback)
    {
        LeaveCriticalSection(&m_CriticalSection);
        return;
    }

    // only want one thread at a time to be created
    m_fWaitingForCreationCallback = TRUE;

    DBGPRINTF(( DBG_CONTEXT, "W3TP: Thread Request received\n"));

    DWORD dwCurrentTime = GetTickCount();

    fRet = GetContextSwitchCount(&m_ulContextSwitchCount);
    if (FALSE == fRet)
    {
        goto done;
    }

    if ( THREAD_POOL_MAX_CPU_USAGE_DEFAULT != m_pPoolData->m_poolConfig.dwMaxCPUUsage)
    {
        hr = GetCPUData(&m_liOriginalBusy,
                       &m_liOriginalTotal,
                       g_dwcCPU);
        if (FAILED(hr))
        {
            fRet = FALSE;
            goto done;
        }
    }
    
    DBG_ASSERT(NULL == m_pParam);
    m_pParam = new THREAD_PARAM;
    if (NULL == m_pParam)
    {
        fRet = FALSE;
        goto done;
    }

    m_pParam->pThreadFunc = lpStartAddress;
    m_pParam->pvThreadArg = lpStartParameter;
    m_pParam->pThreadManager = this;
    m_pParam->dwRequestTime = dwCurrentTime;
    m_pParam->fCallbackOnCreation = TRUE;

    if (NULL != m_hTimer)
    {
        // if this isn't the first time we've requested a thread,
        // we have a previous TimerQueueTimer.  This timer was not
        // removed during the callback, so we have to clean it up now.
        // this is the blocking form of the delete operation, however
        // since the timer has already fired it will not block.
        fRet = DeleteTimerQueueTimer(NULL,                  // default timer queue
                                     m_hTimer,              // previous timer handle
                                     INVALID_HANDLE_VALUE   // wait until it is removed
                                     );
        m_hTimer = NULL;
    }

    DBG_ASSERT(NULL == m_hTimer);
    fRet = CreateTimerQueueTimer(&m_hTimer,             // storage for timer handle
                                 NULL,                  // default timer queue
                                 ControlTimerCallback, // callback function
                                 this,                  // callback argument
                                 m_pPoolData->m_poolConfig.dwTimerPeriod,       // time til callback
                                 0,                     // repeat time
                                 WT_EXECUTEONLYONCE     // no repition
                                 );
    if (FALSE == fRet)
    {
        goto done;
    }

    fRet = TRUE;
done:
    if (FALSE == fRet)
    {
        delete m_pParam;
        m_pParam = NULL;

        m_fWaitingForCreationCallback = FALSE;
    }

    LeaveCriticalSection(&m_CriticalSection);
    return;
}


//static
VOID
THREAD_MANAGER::ControlTimerCallback(PVOID lpParameter, BOOLEAN TimerOrWaitFired)
/*++

Routine Description:

    Callback for timer created in RequestThread

    restores this pointer and forwards to DetermineThreadAction

Arguments:
    lpParameter - THREAD_MANAGER this pointer

Return Value:
    VOID
--*/
{
    THREAD_MANAGER* pThreadManager = (THREAD_MANAGER*)lpParameter;

    DBG_ASSERT(NULL != pThreadManager);
    DBG_ASSERT(NULL != pThreadManager->m_pParam);
    DBG_ASSERT(TRUE == pThreadManager->m_fWaitingForCreationCallback);

    pThreadManager->DetermineThreadAction();

    return;
}

VOID
THREAD_MANAGER::DetermineThreadAction()
/*++

Routine Description:

    Try to determine correct action, create or take away a thread

    Will take away a thread if context switch rate is too high

    m_pParam must be populated
Arguments:

  VOID

Return Value:

  VOID

--*/
{
    BOOL        fRet = FALSE;
    DWORD       dwElapsedTime = 0;
    DWORD       dwCurrentTime = 0;

    EnterCriticalSection(&m_CriticalSection);

    DBG_ASSERT(NULL != m_pParam);

    if (TRUE == m_fShuttingDown)
    {
        fRet = FALSE;
        goto done;
    }

    DBG_ASSERT(TRUE == m_fWaitingForCreationCallback);

    if (THREAD_POOL_MAX_CPU_USAGE_DEFAULT != m_pPoolData->m_poolConfig.dwMaxCPUUsage)
    {
        if (TooMuchProcessorUsage(m_liOriginalBusy,
                                m_liOriginalTotal,
                                m_pPoolData->m_poolConfig.dwMaxCPUUsage,
                                g_dwcCPU))
        {
            // Too much processor usage to create a new thread
             fRet = FALSE;
            goto done;
        }
    }
    
    if (TooMuchContextSwitchingLoad(m_ulContextSwitchCount,
                          m_pParam->dwRequestTime,
                          m_pPoolData->m_poolConfig.dwPerSecondContextSwitchMax,
                          g_dwcCPU))
    {
        // Switching too much

        DoThreadParking();
        fRet = FALSE;
        goto done;
    }

    fRet = DoThreadCreation(m_pParam);
    if (!fRet)
    {
        goto done;
    }

    fRet = TRUE;
done:
    if (FALSE == fRet)
    {
        delete m_pParam;
        m_pParam = NULL;

        m_fWaitingForCreationCallback = FALSE;
    }
    else
    {
        // thread now has responsibility for the memory
        m_pParam = NULL;
    }

    LeaveCriticalSection(&m_CriticalSection);

    return;
}

BOOL
THREAD_MANAGER::DoThreadCreation(THREAD_PARAM *pParam)
/*++

Routine Description:

    If there are no threads in parked state

    Creates a thread,
    add the HANDLE to the internal list of handles
    add the creation time to the internal list of times

    Otherwise, bring a thread out of parked state

Arguments:
    pParam - parameter to pass to created thread

Return Value:

    TRUE if thread is created successfully
    FALSE if thread is not created - either a thread was returned from
    parked state, OR there was a problem with creation.

--*/
{
    BOOL        fRet = FALSE;
    HANDLE      hThread = NULL;

    if (DoThreadUnParking())
    {
        // we have not created a new thread
        DBGPRINTF(( DBG_CONTEXT, "W3TP: Signaled a thread to be unparked\n"));

        // return false - signal that pParam needs to be freed by the caller
        fRet = FALSE;
        goto done;
    }

    // bugbug: use _beginthreadex?
    hThread = ::CreateThread( NULL,     // default security descriptor
                              m_pPoolData->m_poolConfig.dwInitialStackSize, // Initial size as configured
                              ThreadManagerThread, // thread function
                              pParam,   // thread argument
                              0,        // create running
                              NULL      // don't care for thread identifier
                              );
    if( NULL == hThread )
    {
        fRet = FALSE;
        goto done;
    }

    // don't keep the handle around
    CloseHandle(hThread);

    DBGPRINTF(( DBG_CONTEXT, "W3TP: Created a new thread\n"));

    InterlockedIncrement(&m_lTotalThreads);

    // we've successfully created the thread!
    fRet = TRUE;
done:
    return fRet;
}

VOID
THREAD_MANAGER::DoThreadParking()
/*++

Routine Description:

    Called when context switch rate has been determined to be too high
    Removes a thread from participation in the thread pool, and parks it

Arguments:
    none

Return Value:

    VOID
--*/
{
    BOOL fRet;

    // make sure that we leave the starting number of threads in the pool
    if (m_pPoolData &&
        m_lTotalThreads - m_lParkedThreads <= (LONG) m_pPoolData->m_poolConfig.dwInitialThreadCount)
    {
        return;
    }

    DBGPRINTF(( DBG_CONTEXT, "W3TP: Posting to park a thread\n"));

    fRet = m_pPool->PostCompletion(0,
                                   ParkThread,
                                   (LPOVERLAPPED)this);
    DBG_ASSERT(TRUE == fRet);
    return;
}

BOOL
THREAD_MANAGER::DoThreadUnParking()
/*++

Routine Description:
    Release one thread from the parked state

Arguments:

    VOID
Return Value:

    BOOL - TRUE if thread was released
    FALSE if no threads were available to release
--*/
{
    if (0 == m_lParkedThreads)
    {
        return FALSE;
    }
    SetEvent(m_hParkEvent);
    return TRUE;
}

//static
VOID
THREAD_MANAGER::ParkThread(DWORD dwErrorCode,
                                  DWORD dwNumberOfBytesTransferred,
                                  LPOVERLAPPED lpo)
/*++

Routine Description:
    Put a THREAD_MANAGER thread in a parked state

Arguments:

    dwErrorCode - not used
    dwNumberOfBytesTransferred - not used
    lpo - pointer to overlapped that is really a pointer to a THREAD_MANAGER
Return Value:

    VOID
--*/
{
    DWORD dwRet = 0;
    THREAD_MANAGER * pThis= (THREAD_MANAGER*)lpo;
    DBG_ASSERT(NULL != pThis);

    HANDLE arrHandles[2];
    arrHandles[0] = pThis->m_hParkEvent;
    arrHandles[1] = pThis->m_hShutdownEvent;

    DBGPRINTF(( DBG_CONTEXT, "W3TP: Thread parking\n"));

    LONG lNewParkedThreads = InterlockedIncrement(&pThis->m_lParkedThreads);

    if (pThis->m_pPoolData &&
        pThis->m_lTotalThreads - lNewParkedThreads <= (LONG) pThis->m_pPoolData->m_poolConfig.dwInitialThreadCount)
    {
        InterlockedDecrement(&pThis->m_lParkedThreads);
        return;
    }
    
    THREAD_POOL_DATA * pPoolData = pThis->m_pPoolData;
    DWORD dwTimeout = pPoolData->m_poolConfig.dwThreadTimeout;
    dwRet = WaitForMultipleObjects(2,
                                   arrHandles,
                                   FALSE,
                                   dwTimeout);

    InterlockedDecrement(&pThis->m_lParkedThreads);

    DBGPRINTF(( DBG_CONTEXT, "W3TP: Thread unparked\n"));

    if (WAIT_TIMEOUT == dwRet)
    {
        THREAD_POOL_DATA::ThreadPoolStop(pPoolData);
        return;
    }
    
    DBG_ASSERT(WAIT_OBJECT_0 == dwRet ||
               WAIT_OBJECT_0 + 1 == dwRet);

    return;
}

BOOL
THREAD_MANAGER::CreateThread(LPTHREAD_START_ROUTINE lpStartAddress,
                             LPVOID lpParameter)
/*++

Routine Description:

    Creates a thread if no other thread is being created currently

Arguments:

    lpStartAddress  - address of function to begin thread execution
    lpParameter     - argument to pass to start function

Return Value:

    TRUE if thread is created successfully
    FALSE if thread is not created

--*/
{
    BOOL fRet = FALSE;
    THREAD_PARAM * pParam = NULL;

    EnterCriticalSection(&m_CriticalSection);

    if (TRUE == m_fShuttingDown)
    {
        fRet = FALSE;
        goto done;
    }

    pParam = new THREAD_PARAM;
    if (NULL == pParam)
    {
        fRet = FALSE;
        goto done;
    }

    DBGPRINTF(( DBG_CONTEXT, "W3TP: CreateThread thread creation\n"));

    pParam->pThreadFunc = lpStartAddress;
    pParam->pvThreadArg = lpParameter;
    pParam->pThreadManager = this;
    pParam->dwRequestTime = GetTickCount();
    pParam->fCallbackOnCreation = FALSE;

    fRet = DoThreadCreation(pParam);
    if (FALSE == fRet)
    {
        goto done;
    }

    // created thread has responsibility for this memory
    pParam = NULL;

    fRet = TRUE;
done:
    if (FALSE == fRet)
    {
        delete pParam;
        pParam = NULL;

        m_fWaitingForCreationCallback = FALSE;
    }

    LeaveCriticalSection(&m_CriticalSection);
    return fRet;
}

VOID
THREAD_MANAGER::RemoveThread(THREAD_PARAM * pParam)
/*++

Routine Description:

    Removes given thread from list of active threads and closes handle

Arguments:

    hThreadSelf - handle to current thread

Return Value:

    void
--*/
{
    InterlockedDecrement(&m_lTotalThreads);
    return;
}

VOID
THREAD_MANAGER::CreatedSuccessfully(THREAD_PARAM * pParam)
/*++

Routine Description:

    Notification that given thread has successfully started

Arguments:

    hThread - current thread handle

Return Value:

    VOID

--*/
{
    DBG_ASSERT(pParam);

    EnterCriticalSection(&m_CriticalSection);

    DBG_ASSERT(m_fWaitingForCreationCallback);

    m_fWaitingForCreationCallback = FALSE;

    LeaveCriticalSection(&m_CriticalSection);

    return;
}

VOID
THREAD_MANAGER::DrainThreads(LPTHREAD_STOP_ROUTINE lpStopAddress,
                             LPVOID lpParameter)
/*++

Routine Description:

    stop all threads currently being managed.
    Doesn't return until all threads are stopped.

Arguments:

    lpStopAddress   - address of function to call to signal one thread to stop

Return Value:

    TRUE if all threads are stopped
    FALSE if one or more threads could not be stopped

--*/
{
    if (TRUE == m_fShuttingDown)
    {
        DBG_ASSERT(FALSE && "DrainThreads has been called previously!");
        return;
    }


    EnterCriticalSection(&m_CriticalSection);
    // stop any additional thread creation
    m_fShuttingDown = TRUE;
    LeaveCriticalSection(&m_CriticalSection);

    // release all parked threads
    SetEvent(m_hShutdownEvent);

    // push as many stops are there are threads running
    for (INT i = m_lTotalThreads; i >= 0; i--)
//TODO: think about sync with interlocked and m_lTotalThreads - is there a race here?
    {
        lpStopAddress(lpParameter);
    }

    // stop the callback timer
    if (NULL != m_hTimer)
    {
        // block until timer is deleted
        DeleteTimerQueueTimer(NULL,
                              m_hTimer,
                              INVALID_HANDLE_VALUE);
        m_hTimer = NULL;
        if (m_pParam)
        {
            // the ownership for m_pParam moves from the creator
            // to the timer to the thread.
            // However, we just destroyed the timer - need to cleanup
            // the memory
            delete m_pParam;
            m_pParam = NULL;
        }
    }

    while(m_lTotalThreads > 0)
    {
        DBGPRINTF(( DBG_CONTEXT, "W3TP: Waiting for threads to drain, sleep 1000 \n"));
        Sleep(1000);
    }

    DBGPRINTF(( DBG_CONTEXT, "W3TP: All threads drained\n"));

    return;
}


BOOL
GetContextSwitchCount(ULONG * pulSwitchCount)
/*++

Routine Description:

    Get the current machine context switch count

Arguments:

    pulSwitchCount - where to store switch count

Return Value:

    TRUE if context switch count is read correctly
    FALSE if context switch count could not be read

--*/
{
    DBG_ASSERT(NULL != pulSwitchCount);

    SYSTEM_PERFORMANCE_INFORMATION spi;
    ULONG ulReturnLength;
    NTSTATUS status;
    status = NtQuerySystemInformation(SystemPerformanceInformation,
                                      &spi,
                                      sizeof(spi),
                                      &ulReturnLength);
    if (!NT_SUCCESS(status))
    {
        return FALSE;
    }

    *pulSwitchCount = spi.ContextSwitches;

    return TRUE;
}


BOOL
TooMuchContextSwitchingLoad(ULONG ulFirstSample,
                  DWORD dwFirstSampleTime,
                  ULONG ulPerSecondSwitchRateMax,
                  DWORD dwNumProcs)
/*++

Routine Description:

    Determine if the system is under too much load in terms
    of context switches / second

    If dwNumProcs > 1 - the per second switch rate per processor is multiplied by two

Arguments:

    ulFirstSample - first context switch count number
    dwSampleTimeInMilliseconds - how much time between first sample and calling this function
    ulPerSecondSwitchRateMax - Maximum switch rate per processor
    dwNumProcs - number of processors on machine

Return Value:

    TRUE if context switch rate per second per processor is > ulPerSecondSwitchRateMax
    FALSE if context switch rate is below ulPerSecondSwitchRateMax

--*/
{
    ULONG ulSecondSample = 0;
    ULONG ulContextSwitchDifference = 0;
    double dblPerSecondSwitchRate = 0;
    double dblPerSecondSwitchRatePerProcessor = 0;
    DWORD dwCurrentTime = 0;
    DWORD dwElapsedTime = 0;

    BOOL fRet = FALSE;

    fRet = GetContextSwitchCount(&ulSecondSample);
    if (FALSE == fRet)
    {
        goto done;
    }

    dwCurrentTime = GetTickCount();
    if (dwCurrentTime <= dwFirstSampleTime)
    {
        // wrap around on time occurred - assume only one wrap around
        const DWORD MAXDWORD = MAXULONG;
        dwElapsedTime = MAXDWORD - dwFirstSampleTime + dwCurrentTime;
    }
    else
    {
        // no wrap around
        dwElapsedTime = dwCurrentTime - dwFirstSampleTime;
    }
    DBG_ASSERT(dwElapsedTime > 0);


    if (ulSecondSample <= ulFirstSample)
    {
        // wrap around on counter occurred - assume only one wrap around
        ulContextSwitchDifference = (MAXULONG - ulFirstSample) + ulSecondSample;
    }
    else
    {
        // no wrap around
        ulContextSwitchDifference = ulSecondSample - ulFirstSample;
    }
    DBG_ASSERT(ulContextSwitchDifference > 0);

    dblPerSecondSwitchRate = ulContextSwitchDifference / ( dwElapsedTime / 1000.0);

    dblPerSecondSwitchRatePerProcessor = dblPerSecondSwitchRate / dwNumProcs;

    if (dwNumProcs > 1)
    {
        // on multiproc boxes, double the allowed context switch rate per processor
        ulPerSecondSwitchRateMax *= 2;
    }

    if (dblPerSecondSwitchRatePerProcessor > ulPerSecondSwitchRateMax)
    {
        DBGPRINTF(( DBG_CONTEXT, "W3TP: Not creating thread, ContextSwitch rate is: %g\n", dblPerSecondSwitchRate ));
        fRet = TRUE;
        goto done;
    }

    DBGPRINTF(( DBG_CONTEXT, "W3TP: OK to create thread, ContextSwitch rate is: %g\n", dblPerSecondSwitchRate ));

    fRet = FALSE;
done:
    return fRet;
}

HRESULT
GetCPUData(LARGE_INTEGER * pBusyTime,
           LARGE_INTEGER * pTotalTime,
           DWORD dwNumProcs)
/*++

Routine Description:

    Collects the percent CPU load for all machine processors.

Arguments:

    None

Return Value:

    Std HRESULT.

--*/

{
    DBG_ASSERT(pBusyTime && pTotalTime);
    DBG_ASSERT(dwNumProcs > 0);
    
    HRESULT  hr     = S_OK;
    NTSTATUS status = STATUS_SUCCESS;

    LARGE_INTEGER 
        cpuIdleTime   = {0},
        cpuUserTime   = {0},
        cpuKernelTime = {0},
        cpuBusyTime   = {0},
        cpuTotalTime  = {0},
        sumBusyTime   = {0},
        sumTotalTime  = {0};

    SYSTEM_PROCESSOR_PERFORMANCE_INFORMATION * psppi = new SYSTEM_PROCESSOR_PERFORMANCE_INFORMATION[dwNumProcs];
    if (NULL == psppi)
    {
        hr = HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
        goto CLEANUP;
    }
    
    
    // get the new snapshot
    status = NtQuerySystemInformation(
        SystemProcessorPerformanceInformation,
        psppi,
        sizeof(SYSTEM_PROCESSOR_PERFORMANCE_INFORMATION) * dwNumProcs,
        NULL
        );

    if(status != STATUS_SUCCESS){

        hr = HRESULT_FROM_NT(status);
        goto CLEANUP;
    }

    // calculate
    for (DWORD i = 0; i < dwNumProcs; i++) {
    
        cpuTotalTime  = RtlLargeIntegerAdd(psppi[i].UserTime, psppi[i].KernelTime);
        cpuBusyTime   = RtlLargeIntegerSubtract(cpuTotalTime, psppi[i].IdleTime);

        sumBusyTime = RtlLargeIntegerAdd(sumBusyTime, cpuBusyTime);
        sumTotalTime = RtlLargeIntegerAdd(sumTotalTime, cpuTotalTime);
    }

    *pBusyTime = sumBusyTime;
    *pTotalTime = sumTotalTime;

CLEANUP:

    delete [] psppi;
    psppi = NULL;

    return hr;
}

LONG 
GetPercentage(LARGE_INTEGER part, LARGE_INTEGER total) 
{
    if (0 == total.QuadPart)
    {
        return 100;
    }

    LARGE_INTEGER li;
    
    part.QuadPart *= 100;
    
    li.QuadPart = part.QuadPart / total.QuadPart;

    return li.LowPart;    
}

BOOL
TooMuchProcessorUsage(LARGE_INTEGER liOriginalBusy,
                        LARGE_INTEGER liOriginalTotal,
                        LONG lPercentageUseMax,
                        DWORD dwNumProcs)
{
    HRESULT hr = S_OK;
    LARGE_INTEGER
        liNewBusy = {0},
        liNewTotal = {0},
        liDiffBusy = {0},
        liDiffTotal = {0};
    
    hr = GetCPUData(&liNewBusy,
                &liNewTotal,
                dwNumProcs);
    if (FAILED(hr))
    {
        return TRUE;
    }

    liDiffBusy = RtlLargeIntegerSubtract(liNewBusy, liOriginalBusy);
    liDiffTotal = RtlLargeIntegerSubtract(liNewTotal, liOriginalTotal);

    LONG lPercentageUse = GetPercentage(liDiffBusy, liDiffTotal);
    if (lPercentageUse >= lPercentageUseMax)
    {
        return TRUE;
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\iisplus\w3tp\thread_manager.h ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    thread_manager.hxx

Abstract:

    Provides thread creation and cleanup management

Author:

    Jeffrey Wall (jeffwall)     11-28-2000

Revision History:



--*/

#ifndef _THREADMANAGER_H_
#define _THREADMANAGER_H_

#include <thread_pool.h>

typedef void (WINAPI *PTHREAD_STOP_ROUTINE)(PVOID);
typedef PTHREAD_STOP_ROUTINE LPTHREAD_STOP_ROUTINE;
typedef BOOL (WINAPI *PTHREAD_DECISION_ROUTINE )(PVOID);
typedef PTHREAD_DECISION_ROUTINE LPTHREAD_DECISION_ROUTINE;

#define SIGNATURE_THREAD_MANAGER          ((DWORD) 'NAMT')
#define SIGNATURE_THREAD_MANAGER_FREE     ((DWORD) 'xAMT')
#define SIGNATURE_THREAD_PARAM            ((DWORD) 'RAPT')
#define SIGNATURE_THREAD_PARAM_FREE       ((DWORD) 'xAPT')

class THREAD_MANAGER
{
private:
    DWORD m_dwSignature;

public:
    static HRESULT CreateThreadManager(THREAD_MANAGER ** ppThreadManager,
                                       THREAD_POOL * pPool,
                                       THREAD_POOL_DATA * pPoolData);

    VOID TerminateThreadManager(LPTHREAD_STOP_ROUTINE lpStopAddress,
                                LPVOID lpParameter);

    BOOL CreateThread(LPTHREAD_START_ROUTINE lpStartAddress,
                      LPVOID lpParameter);

    VOID RequestThread(LPTHREAD_START_ROUTINE lpStartAddress,
                       LPVOID lpStartParameter);

private:
    // use create and terminate
    THREAD_MANAGER(THREAD_POOL * pPool,
                   THREAD_POOL_DATA * pPoolData);

    ~THREAD_MANAGER();

    // not implemented
    THREAD_MANAGER(const THREAD_MANAGER&);
    THREAD_MANAGER& operator=(const THREAD_MANAGER&);

    HRESULT Initialize();

    VOID DrainThreads(LPTHREAD_STOP_ROUTINE lpStopAddress,
                      LPVOID lpParameter);

    /*++
    Struct Description:
        Storage for parameters passed to ThreadManagerThread

    Members:
        pThreadFunc - thread function to call
        pvThreadArg - arguments to pass to thread function
        pThreadManager - pointer to ThreadManager associated with current thread
        hThreadSelf - handle returned from call to CreateThread
        dwRequestTime - time that thread request was made
    --*/
    struct THREAD_PARAM
    {
        THREAD_PARAM() :
            dwSignature(SIGNATURE_THREAD_PARAM),
            pThreadFunc(NULL),
            pvThreadArg(NULL),
            pThreadManager(NULL),
            dwRequestTime(NULL),
            fCallbackOnCreation(FALSE)
        {
        }
        ~THREAD_PARAM()
        {
            DBG_ASSERT(SIGNATURE_THREAD_PARAM == dwSignature);
            dwSignature = SIGNATURE_THREAD_PARAM_FREE;
        }

        DWORD                   dwSignature;
        LPTHREAD_START_ROUTINE  pThreadFunc;
        LPVOID                  pvThreadArg;
        THREAD_MANAGER         *pThreadManager;
        DWORD                   dwRequestTime;
        BOOL                    fCallbackOnCreation;
    };

    static DWORD ThreadManagerThread(LPVOID);
    static VOID ControlTimerCallback(PVOID lpParameter,
                                      BOOLEAN TimerOrWaitFired);

    VOID DetermineThreadAction();
    BOOL DoThreadCreation(THREAD_PARAM * pParam);

    VOID CreatedSuccessfully(THREAD_PARAM * pParam);
    VOID RemoveThread(THREAD_PARAM * pParam);

    VOID DoThreadParking();
    BOOL DoThreadUnParking();
    static VOID ParkThread(DWORD dwErrorCode,
                                  DWORD dwNumberOfBytesTransferred,
                                  LPOVERLAPPED lpo);

    CRITICAL_SECTION        m_CriticalSection;

    BOOL                    m_fShuttingDown;
    BOOL                    m_fWaitingForCreationCallback;

    HANDLE                  m_hTimer;

    THREAD_PARAM           *m_pParam;

    ULONG                   m_ulContextSwitchCount;

    LONG                    m_lTotalThreads;

    LONG                    m_lParkedThreads;
    HANDLE                  m_hParkEvent;
    HANDLE                  m_hShutdownEvent;

    THREAD_POOL            *m_pPool;
    THREAD_POOL_DATA       *m_pPoolData;

    LARGE_INTEGER           m_liOriginalTotal;
    LARGE_INTEGER           m_liOriginalBusy;
};

#endif // _THREADMANAGER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\iisplus\w3wp\w3wp.cxx ===
/*++

   Copyright    (c)    1998    Microsoft Corporation

   Module  Name :
       w3wp.cxx

   Abstract:
       Main module for IIS compatible worker process
 
   Author:

       Murali R. Krishnan    ( MuraliK )     23-Sept-1998

   Environment:
       Win32 - User Mode

   Project:
       IIS compatible worker process
--*/


/************************************************************
 *     Include Headers
 ************************************************************/

#include "precomp.hxx"
#include "wpif.h"
#include "ulw3.h"
#include "../../../svcs/mdadmin/ntsec.h"

DECLARE_DEBUG_PRINTS_OBJECT();
DECLARE_DEBUG_VARIABLE();

//
// Configuration parameters registry key.
//

// BUGBUG
#undef INET_INFO_KEY
#undef INET_INFO_PARAMETERS_KEY

#define INET_INFO_KEY \
            "System\\CurrentControlSet\\Services\\iisw3adm"

#define INET_INFO_PARAMETERS_KEY \
            INET_INFO_KEY "\\Parameters"

const CHAR g_pszWpRegLocation[] =
    INET_INFO_PARAMETERS_KEY "\\WP";


class DEBUG_WRAPPER {

public:
    DEBUG_WRAPPER( IN LPCSTR pszModule)
    {
#if DBG
        CREATE_DEBUG_PRINT_OBJECT( pszModule);
#else
        UNREFERENCED_PARAMETER(pszModule);
#endif
        LOAD_DEBUG_FLAGS_FROM_REG_STR( g_pszWpRegLocation, DEBUG_ERROR );
    }

    ~DEBUG_WRAPPER(void)
    { DELETE_DEBUG_PRINT_OBJECT(); }
};

HRESULT
InitializeComSecurity( VOID );

//
// W3 DLL which does all the work
//

extern "C" INT
__cdecl
wmain(
    INT                     argc,
    PWSTR                   argv[]
    )
{
    DEBUG_WRAPPER   dbgWrapper( "w3wp" );
    HRESULT         hr;
    HMODULE         hModule = NULL;
    PFN_ULW3_ENTRY  pEntry = NULL;
    ULONG           rcRet = CLEAN_WORKER_PROCESS_EXIT_CODE;
    BOOL            fCoInit = FALSE;
    HDESK           hIISDesktop = NULL;

    //
    // We don't want the worker process to get stuck in a dialog box
    // if it goes awry.
    //

    SetErrorMode( SEM_FAILCRITICALERRORS | SEM_NOGPFAULTERRORBOX | SEM_NOOPENFILEERRORBOX );

    IF_DEBUG( TRACE) 
    {

        //
        // Print out our process affinity mask on debug builds.
        //


        BOOL fRet = TRUE;
        DWORD_PTR ProcessAffinityMask = 0;
        DWORD_PTR SystemAffinityMask = 0;

        fRet = GetProcessAffinityMask(
                    GetCurrentProcess(),
                    &ProcessAffinityMask,
                    &SystemAffinityMask
                    );

        DBGPRINTF(( DBG_CONTEXT, "Process affinity mask: %p\n", ProcessAffinityMask ));
        
    }
    
    //
    // Move this process to the WindowStation (with full access to all) in
    // which we would have been if running in inetinfo.exe (look at
    // iis\svcs\mdadmin\ntsec.cxx)
    //
    HWINSTA hWinSta = OpenWindowStationA(SZ_IIS_WINSTA, FALSE, WINSTA_DESIRED);
    if (hWinSta == NULL)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());

        rcRet = ERROR_WORKER_PROCESS_EXIT_CODE;
        goto Finished;
    }

    //
    // Set this as this process's window station
    //
    if (!SetProcessWindowStation(hWinSta))
    {
        hr = HRESULT_FROM_WIN32(GetLastError());

        rcRet = ERROR_WORKER_PROCESS_EXIT_CODE;
        goto Finished;
    }

    //
    // Save the previous desktop and then load the IIS one and set it to
    // active for this thread.  This causes COM to cache the desktop
    // and makes launching local COM servers work.
    //
    HDESK hPrevDesk = GetThreadDesktop(GetCurrentThreadId());
    if (hPrevDesk == NULL)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto Finished;
    }

    hIISDesktop = OpenDesktopA(SZ_IIS_DESKTOP, 0, FALSE, DESKTOP_DESIRED);
    if (hIISDesktop == NULL)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto Finished;
    }

    if (!SetThreadDesktop(hIISDesktop))
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto Finished;
    }

    //
    // Do some COM junk
    //
    // BUGBUG: CoInitialize twice to protect against applications which
    // over CoUnInitialize()
    //

    hr = CoInitializeEx(NULL, COINIT_MULTITHREADED);
    if (FAILED(hr))
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "Error in CoInitializeEx().  hr = %x\n",
                    hr ));
                    
        rcRet = ERROR_WORKER_PROCESS_EXIT_CODE;
        goto Finished;
    }
    else
    {
        hr = CoInitializeEx(NULL, COINIT_MULTITHREADED);
        if (FAILED(hr))
        {
            CoUninitialize();
            
            DBGPRINTF(( DBG_CONTEXT,
                        "Error in second CoInitializeEx().  hr = %x\n",
                        hr ));
                    
            rcRet = ERROR_WORKER_PROCESS_EXIT_CODE;
            goto Finished;
        }
    }
    
    fCoInit = TRUE;

    hr = InitializeComSecurity();
    if (FAILED(hr))
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "Error in InitializeComSecurity().  hr = %x\n",
                    hr ));
                    
        rcRet = ERROR_WORKER_PROCESS_EXIT_CODE;
        goto Finished;
    }
 
    //
    // Reset back to the default desktop
    //
    if (!SetThreadDesktop(hPrevDesk))
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto Finished;
    }

    //
    // Load the ULW3 DLL which does all the work
    //

    hModule = LoadLibrary( ULW3_DLL_NAME );
    if ( hModule == NULL )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "Error loading W3 service dll '%ws'.  Error = %d\n",
                    ULW3_DLL_NAME,
                    GetLastError() ));
                    
        rcRet = ERROR_WORKER_PROCESS_EXIT_CODE;
        goto Finished;
    }
    
    pEntry = (PFN_ULW3_ENTRY) GetProcAddress( hModule, 
                                              ULW3_DLL_ENTRY );
    if ( pEntry == NULL )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "Could not find entry point '%s'.  Error = %d\n",
                    ULW3_DLL_ENTRY,
                    GetLastError() ));
                    
        rcRet = ERROR_WORKER_PROCESS_EXIT_CODE;
        goto Finished;
    }
    
    hr = pEntry( argc, 
                 argv, 
                 FALSE );               // Compatibility Mode = FALSE
    if ( FAILED( hr ) )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "Error executing W3WP.  hr = %x\n",
                    hr ));
                    
        rcRet = ERROR_WORKER_PROCESS_EXIT_CODE;
        goto Finished;
    }

Finished:

    if ( IsDebuggerPresent() )
    {
        DBG_ASSERT( SUCCEEDED( hr ) );
    }

    //
    // Cleanup any lingering COM objects before unloading
    //
    
    if ( fCoInit )
    {
        CoUninitialize();
        CoUninitialize();
    }

    if ( hModule != NULL )
    {
        FreeLibrary( hModule );
    }

    if (hIISDesktop)
    {
        CloseDesktop(hIISDesktop);
    }

    return rcRet;
}

HRESULT
InitializeComSecurity( VOID )
/*++

Routine Description:

    Call CoInitializeSecurity. Seems simple, but it has significant 
    security and compatibility implications. Defaults can be overriden 
    with registry setting that are based on those used by svchost.exe.

    There are three controllable parameters:

    AuthenticationLevel
        IIS5 inetinfo   RPC_C_AUTHN_LEVEL_DEFAULT       = 0
        iisadmin        RPC_C_AUTHN_LEVEL_PKT_PRIVACY   = 6
        svchost         RPC_C_AUTHN_LEVEL_PKT           = 4
        default         IIS5

    ImpersonationLevel
        IIS5 inetinfo   RPC_C_IMP_LEVEL_IMPERSONATE     = 3
        iisadmin        RPC_C_IMP_LEVEL_IDENTIFY        = 2
        svchost         RPC_C_IMP_LEVEL_IDENTIFY        = 2
        default         IIS5

    AuthenticationCapabilities
        IIS5 inetinfo   EOAC_DYNAMIC_CLOAKING           = 0x40
        iisadmin        EOAC_DYNAMIC_CLOAKING | 
                            EOAC_DISABLE_AAA | 
                            EOAC_NO_CUSTOM_MARSHAL      = 0x3040
        svchost         EOAC_NO_CUSTOM_MARSHAL |
                            EOAC_DISABLE_AAA            = 0x1040
        default         IIS5

    A fourth parameter CoInitializeSecurityParam controls whether
    we read the other three parameters at all.
    
Arguments:

    None

Return Value:

    HRESULT

--*/
{
    HRESULT hr;
    HKEY    hKey;

    DWORD   CoInitializeSecurityParam   = 0;

    DWORD   AuthenticationLevel         = RPC_C_AUTHN_LEVEL_DEFAULT;

    DWORD   ImpersonationLevel          = RPC_C_IMP_LEVEL_IMPERSONATE;

    DWORD   AuthenticationCapabilities  = EOAC_DYNAMIC_CLOAKING;

    if( RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                      L"System\\CurrentControlSet\\Services\\w3svc\\Parameters",
                      0,
                      KEY_READ,
                      &hKey ) == ERROR_SUCCESS )
    {
        DWORD dwValue;
        DWORD dwType;
        DWORD cbValue = sizeof(DWORD);

        if( RegQueryValueEx( hKey,
                             L"CoInitializeSecurityParam",
                             NULL,
                             &dwType,
                             (LPBYTE)&dwValue,
                             &cbValue ) == ERROR_SUCCESS &&
            dwType == REG_DWORD )
        {
            CoInitializeSecurityParam = dwValue;
        }

        if( CoInitializeSecurityParam )
        {
            if( RegQueryValueEx( hKey,
                                 L"AuthenticationLevel",
                                 NULL,
                                 &dwType,
                                 (LPBYTE)&dwValue,
                                 &cbValue ) == ERROR_SUCCESS &&
                dwType == REG_DWORD )
            {
                AuthenticationLevel = dwValue;
            }

            if( RegQueryValueEx( hKey,
                                 L"ImpersonationLevel",
                                 NULL,
                                 &dwType,
                                 (LPBYTE)&dwValue,
                                 &cbValue ) == ERROR_SUCCESS &&
                dwType == REG_DWORD )
            {
                ImpersonationLevel = dwValue;
            }

            if( RegQueryValueEx( hKey,
                                 L"AuthenticationCapabilities",
                                 NULL,
                                 &dwType,
                                 (LPBYTE)&dwValue,
                                 &cbValue ) == ERROR_SUCCESS &&
                dwType == REG_DWORD )
            {
                AuthenticationCapabilities = dwValue;
            }

        }

        RegCloseKey( hKey );
        
    }

    hr = CoInitializeSecurity(  NULL,
                                -1,
                                NULL,
                                NULL,
                                AuthenticationLevel,
                                ImpersonationLevel,
                                NULL,
                                AuthenticationCapabilities,
                                NULL );
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\iisplus\w3wplist\processdetails.cxx ===
/*++
    
Copyright (c) 2001 Microsoft Corporation

Module Name:    

    processdetails.cxx

Abstract:

    implementation of processdetails.h

Author:    
    
    Hamid Mahmood (t-hamidm)     08-13-2001

Revision History:
    
    
    
--*/
#include <precomp.hxx>

BOOL    ProcessDetails::sm_fIsOldMode;


ProcessDetails::ProcessDetails()
/*++

Routine Description:

    Constructor.

Arguments:

    none

Return Value:

    none

--*/
{
    sm_fIsOldMode = FALSE;
    m_fIsInetinfo = FALSE;
    m_dwPID = 0;
    m_pszAppPoolId = NULL;
    m_fListMode = FALSE;
    m_pProcessParameters = NULL;
    m_dwRequestsServed = 0;
    m_chVerbosity = 0;
    m_dwErrorCode = ERROR_SUCCESS;

    InitializeListHead(&m_localRequestListHead);

    m_w3wpListInfoStruct.m_pListHead = NULL;
    m_w3wpListInfoStruct.m_pRequestsServed = NULL;

    m_dwSignature = PROCESS_DETAILS_SIGNATURE;
}


ProcessDetails::~ProcessDetails()
/*++

Routine Description:

    Destructor.

Arguments:

    none

Return Value:

    none

--*/
{
    DBG_ASSERT (m_dwSignature == PROCESS_DETAILS_SIGNATURE);
    m_dwSignature = PROCESS_DETAILS_SIGNATURE_FREE;

    DBG_ASSERT (m_pszAppPoolId == NULL);
    DBG_ASSERT (m_pProcessParameters == NULL);
    DBG_ASSERT (IsListEmpty(&m_localRequestListHead) == TRUE);

    DBG_ASSERT (m_dwPID == 0);
    DBG_ASSERT (m_fListMode == FALSE);
    DBG_ASSERT (m_fIsInetinfo == FALSE);
    DBG_ASSERT (m_chVerbosity == 0);
    DBG_ASSERT (m_dwErrorCode == ERROR_SUCCESS);
    DBG_ASSERT (m_dwRequestsServed == 0);
}

VOID
ProcessDetails::Init( DWORD dwPID,
                      CHAR chVerbosity,
                      BOOL fIsListMode
                      )
/*++

Routine Description:

    Initializes all the class members. 

Arguments:

    dwPID           --  input PID
    chVerbosity     --  verbosity level
    fIsListMode     --  TRUE if just enumerating all the
                        worker processes

Return Value:

    none

--*/
{
    m_dwPID = dwPID;
    m_chVerbosity = chVerbosity;
    m_fListMode = fIsListMode;
}


VOID ProcessDetails::Terminate()
/*++

Routine Description:

    deallocates memory.

Arguments:

    none

Return Value:

    none

--*/
{
    PLIST_ENTRY pListEntry;
    REQUESTLIST_NODE* pRequestListNode;

    m_fListMode = FALSE;
    m_fIsInetinfo = FALSE;
    m_dwPID = 0;
    m_dwErrorCode = ERROR_SUCCESS;
    m_dwRequestsServed = 0;
    m_chVerbosity = 0;
  
    delete[] m_pszAppPoolId;
    m_pszAppPoolId = NULL;

    m_pProcessParameters = NULL;

    //
    // w3wplist info struct
    //

    m_w3wpListInfoStruct.m_pListHead = NULL;
    m_w3wpListInfoStruct.m_pRequestsServed = NULL;    

    //
    // deleting the link list
    // 
    
    while ( ! IsListEmpty (&m_localRequestListHead) )
    {
        pListEntry = RemoveHeadList(&m_localRequestListHead);

        pRequestListNode = CONTAINING_RECORD ( pListEntry,
                                               REQUESTLIST_NODE,
                                               m_listEntry
                                               );

        DBG_ASSERT (pRequestListNode->CheckSignature());

        pRequestListNode->m_w3wpListHttpReq.Terminate();
        pRequestListNode->m_fIsHeaderPresent = FALSE;
        
        //
        // delete the current node
        //
        delete pRequestListNode;
        pRequestListNode = NULL;
        pListEntry = NULL;
    }    
}

HRESULT
ProcessDetails::GetProcessDetails( WCHAR* pszInputAppPoolId )
/*++

Routine Description:

    Walks through all the processes and calls 
    GetModuleInfo on all of them. 

    If pszInputAppPoolId is null, this method
    looks at all app pools, otherwise it will
    only look at the inputted one.

    If the process name is EXE_NAME
    then calls ReadEnvVarInfo and DebugProcess
    to populate the list with current headers.
    DumpRequests is then called to print out 
    info.

Arguments:
    pszInputAppPoolId   --      App pool id user input 

Return Value:

    HRESULT hr          --      S_FALSE, if exe name did not match
                                S_OK if name matched even if. S_OK
                                is returned even if any function
                                fails, but the error code is logged.

--*/
{
    DWORD dwBytesReceived;
    HANDLE hProcess;
    HRESULT hr = S_FALSE;

    hProcess = OpenProcess ( PROCESS_ALL_ACCESS,
                             FALSE,
                             m_dwPID
                             );

    //
    // No error generated if OpenProcess
    // fails because processes may have
    // exited between EnumProcess and 
    // OpenProcess function calls.
    //

    if ( hProcess == NULL )
    {
        goto end;
    }

    //
    // GetModuleInfo() compares the 
    // exe name to EXE_NAME. If yes,
    // then gets the app pool id
    // and updates m_pProcessParameters 
    // (does not allocate memory) and
    // m_pszAppPoolId (allocates 
    // mem for) class members
    //

    if ( FAILED (GetModuleInfo(hProcess)) )
    {
        //
        // exit if we are in old mode,
        // The thread that set fIsOldMode 
        // found the inetinfo.exe process 
        // and did all the stuff
        //
        if ( sm_fIsOldMode == TRUE )
        {
            ExitThread( CONSOLE_HANDLER_VAR::g_THREAD_EXIT_CODE );
        }
        goto end;
    }

    //
    // if it is a worker process &&
    // if we are enumerating by app pool id
    // then make sure they match
    //
    if ((m_fIsInetinfo == FALSE) &&
        (pszInputAppPoolId != NULL) &&
        (_wcsicmp ( m_pszAppPoolId, 
                   pszInputAppPoolId) != 0)
       )
    {
       goto end;
    }

    //
    // if successful ReadEnvironmentVar
    // reads in W3WPLIST_INFO struct
    // into m_w3wpListInfoStruct from 
    // the worker process, or inetinfo
    // in old mode
    //

    hr = ReadEnvironmentVar ( hProcess );

    if ( FAILED (hr) )
    {
		m_dwErrorCode = HRESULT_FROM_WIN32(GetLastError());
        hr = S_FALSE;
        goto end;
    }

    //
    // if we're in old mode, set the static
    // flag so that other threads should exit.
    // We are not entering any critical section
    // because there is only one inetinfo
    // process and thus only one thread 
    // will set this variable
    //

    if ( m_fIsInetinfo == TRUE )
    {
        sm_fIsOldMode = TRUE;
    }


    if ( (m_chVerbosity <= 0) ||
         ( m_fListMode == TRUE )
         )
    {
        hr = S_OK;
        goto end;
    }

    //
    // check for Ctrl+C, Ctrl+Break, etc
    //

    if ( CONSOLE_HANDLER_VAR::g_HAS_CONSOLE_EVENT_OCCURED == TRUE )
    {
        ExitThread(CONSOLE_HANDLER_VAR::g_THREAD_EXIT_CODE);
    }
      
    //
    // attaches itself to the worker process,
    // traverses the list,
    // detaches it self.
    //
    hr = DebugProcess( hProcess );

    if ( FAILED (hr) )
    {
        m_dwErrorCode = HRESULT_FROM_WIN32(GetLastError());
        hr = S_FALSE;
        goto end;    
    }   

    CloseHandle(hProcess);
    hProcess = NULL;
    hr = S_OK;

end:
    return hr;
}


HRESULT
ProcessDetails::GetModuleInfo(IN HANDLE hProcess)
/*++

Routine Description:

    Gets the base module info. If the 
    exe name == EXE_NAME, then calls 
    GetAppPoolID to get the application 
    pool id.

Arguments:

    IN hProcess --  Handle to Process to manipulate

Return Value:

    HRESULT hr  --  E_FAIL, if exe name does not match
                    or if error occurs
                    S_OK if name matched and other funcitons
                    called from within also passed
                    Error code: if anything else failed

--*/
{
    HMODULE hModule;    
    DWORD dwBytesReceived;
    WCHAR szProcessName[MAX_PATH];
    HRESULT hr = S_OK;

    //
    // EnumProcessModules gets all the module 
    // handles if the buffer is big enough. 
    // We are only interested in the first 
    // module here. First module is the exe name.
    //
    
    if ( EnumProcessModules ( hProcess,
                              &hModule,
                              sizeof(HMODULE),
                              &dwBytesReceived
                              ) == FALSE)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto end;
    }
    
    dwBytesReceived = 0;

    //
    // Get the exe name from the first 
    // module handle.
    //
    dwBytesReceived = GetModuleBaseName ( hProcess, 
                                          hModule,
                                          szProcessName,
                                          sizeof(szProcessName) / sizeof(WCHAR) - 1
                                          );
    
    if ( dwBytesReceived == 0)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto end;
    }

    //
    // pad a null at the end of the string
    //
    szProcessName[dwBytesReceived] = L'\0';
    
    //
    // check whether this process is inetinfo,
    //
    if (_wcsicmp (szProcessName, 
                  INETINFO_NAME
                  ) == 0
                  )
    {
        m_fIsInetinfo = TRUE;
    }
    //
    // check whether it is the 
    // worker process, if yes
    // get the app pool id.
    //
    else if (_wcsicmp (szProcessName, 
                       EXE_NAME
                       ) != 0
                       )
    {
        hr = E_FAIL;
        goto end;
    }
    
    //
    // we want to call ReadPEB if it is either
    // inetinfo or worker process. 
    //

    hr = ReadPEB( hProcess );

    if ( FAILED (hr) )
    {
        goto end;
    }


    //
    // read app pool id only if it is a 
    // worker process
    //

    if ( m_fIsInetinfo == FALSE )
    {       
        //
        // gets app pool id and initializes
        // m_currappPoolId class var
        //

        hr = GetAppPoolID(hProcess);
    }
    else
    {
        //
        // we will output inetinfo
        // in place of app Pool id
        
        m_pszAppPoolId = new WCHAR[wcslen(INETINFO_NAME) + 1];
        if ( m_pszAppPoolId == NULL )
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
        }
        else
        {
            wcscpy ( m_pszAppPoolId,
                     INETINFO_NAME
                     );
        }

    }
    
end:
    return hr;
}


HRESULT 
ProcessDetails::ReadPEB(IN HANDLE hProcess )
/*++

Routine Description:

    Read in the PEB an initializes some class
    vars/

Arguments:

    IN  hProcess    --  Handle to open process to 
                        get app pool id.

Return Value:

    HRESULT hr  --  hr error code , if error occurs
                    S_OK if success
--*/
{
    NTSTATUS ntStatus;
    PROCESS_BASIC_INFORMATION basicProcessInfo;
    DWORD dwBytesReceived;
    SIZE_T stNumBytesRead;
    PEB processPEB;
  
    BOOL fReadMemStatus = FALSE;
    HRESULT hr = S_OK;
    
    //
    // Gets the basic process info for the 
    // process handle hProcess
    //
    
    ntStatus = NtQueryInformationProcess( hProcess,
                                          ProcessBasicInformation,
                                          &basicProcessInfo,
                                          sizeof(PROCESS_BASIC_INFORMATION),
                                          &dwBytesReceived
                                          );

    if ( ntStatus != STATUS_SUCCESS )
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto end;
    }
    
    
    //
    // Read the Process PEB from 
    // the PEB base address retrieved 
    // earlier as part of the 
    // ProcessBasicInfo
    //

    fReadMemStatus = ReadProcessMemory( hProcess,
                                        basicProcessInfo.PebBaseAddress,
                                        &processPEB,
                                        sizeof(PEB),
                                        &stNumBytesRead
                                        );
    if (fReadMemStatus == FALSE)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto end;
    }

    
    //
    // PEB.ProcessParameters contains 
    // info or the proces params. 
    // We are interested only in the 
    // command line param.Therefore, 
    // pCommandLineStartAddress points 
    // to beginning of the command line 
    // param which is of type UNICODE_STRING
    //

    m_pProcessParameters = processPEB.ProcessParameters;
end:
    return hr;
}


HRESULT
ProcessDetails::GetAppPoolID(IN HANDLE hProcess )
                            
/*++

Routine Description:

    Gets the App Pool ID of the current open Process.
    Also initializes the m_pProcessParameters class var

Arguments:

    IN  hProcess    --  Handle to open process to 
                        get app pool id.

Return Value:

    HRESULT hr  --  S_FALSE, if exe name does not match
                    S_OK if name matched and other funcitons
                    called from within also passed
                    Error code: if anything else failed
--*/
{
    SIZE_T stNumBytesRead;
    BOOL fReadMemStatus = FALSE;
    UNICODE_STRING unistrCommandLine;
    WCHAR *pszCmdLine = NULL;
    WCHAR *pszTempAppPoolId;
    BYTE* pCommandLineStartAddress;
    HRESULT hr = S_OK;
    
    DBG_ASSERT ( m_pProcessParameters != NULL );

    pCommandLineStartAddress = (BYTE*)m_pProcessParameters + CMD_LINE_OFFSET;

    fReadMemStatus = ReadProcessMemory( hProcess,
                                        pCommandLineStartAddress,
                                        &unistrCommandLine,
                                        sizeof(UNICODE_STRING),
                                        &stNumBytesRead
                                        );
    if (fReadMemStatus == FALSE)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto cleanup;
    }
    
    //
    // initialize the WCHAR * to the 
    // size of the command line string. 
    // This length (in bytes) is stored in the 
    // UNICODE_STRING struct. Then call 
    // ReadProcessMemory to read in the 
    // string to the local var pszCmdLine.
    //

    int sizeCmdLine = unistrCommandLine.Length / 2;
    pszCmdLine = new WCHAR[sizeCmdLine + 1];

    if (pszCmdLine == NULL)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto cleanup;
    }

    fReadMemStatus = ReadProcessMemory( hProcess,
                                        unistrCommandLine.Buffer,
                                        pszCmdLine,
                                        unistrCommandLine.Length,
                                        &stNumBytesRead
                                        );

    if (fReadMemStatus == FALSE)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto cleanup;
    }

    //
    // Assure that the string is zero terminated
    //
    pszCmdLine[sizeCmdLine] = L'\0';

    //
    // parses the cmd line to get app pool id. if found
    // initializes the m_pszAppPoolId class var
    //

    hr = ParseAppPoolID(pszCmdLine);

cleanup:
    delete [] pszCmdLine;
    pszCmdLine = NULL;
    return hr;
}


HRESULT
ProcessDetails::ParseAppPoolID( IN WCHAR* pszCmdLine)
/*++

Routine Description:

    Parses the input command line. Looks for
    "-ap" in the command line. The next token
    is the app pool id

Arguments:

    IN pszCmdLine   --  pointer to command line to parse

Return Value:

    HRESULT hr  --  S_FALSE, if exe name does not match
                    S_OK if name matched and other funcitons
                    called from within also passed
                    Error code: if anything else failed
--*/
{
    WCHAR* pszAppPoolTag = NULL;
    WCHAR* pszStart = NULL;
    DWORD dwSize;
    HRESULT hr = S_OK;

    DBG_ASSERT( pszCmdLine != NULL );

    //
    // find "-ap" in the cmd line
    //
    pszAppPoolTag = wcsstr( pszCmdLine,
                            L"-ap"
                            );

    if (pszAppPoolTag == NULL)
    {
        return HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);
    }

    //
    // move to the start of app pool id
    // which is in quotes
    //
    while ( *(++pszAppPoolTag) != L'"');
    pszStart = ++pszAppPoolTag;

    //
    // locate the end of app pool id
    //
    while ( *(++pszAppPoolTag) != L'"');
    

    //
    // calculate size and initialize class var
    //
    dwSize = DIFF(pszAppPoolTag - pszStart);
    m_pszAppPoolId = new WCHAR[dwSize + 1];

    if (m_pszAppPoolId == NULL)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto end;
    }

    wcsncpy( m_pszAppPoolId,
             pszStart,
             dwSize
             );

    m_pszAppPoolId[dwSize] = L'\0';

end:
    return hr;
}


HRESULT
ProcessDetails::ReadEnvironmentVar( IN HANDLE hProcess)
/*++

Routine Description:

    Reads the environment block of the process
    associated with hProcess. Looks for the specific
    env var associated with the worker process
    and reads in the memory location of the 
    struct. Then reads in the struct into the class
    var m_w3wpListInfoStruct; and the LIST_ENTRY* and 
    num request served*.

Arguments:

    hProcess    --  handle to the process

Return Value:

    HRESULT hr  --  S_FALSE, if exe name does not match
                    S_OK if name matched and other funcitons
                    called from within also passed
                    Error code: if anything else failed
--*/
{
    BOOL fReadMemStatus;
    SIZE_T stNumBytesRead;
    WCHAR szBuf[200];
    WCHAR szVarName[ENV_VAR_NAME_MAX_SIZE];
    DWORD dwPos;
    DWORD_PTR pdwStructAddr = NULL;
    HRESULT hr = S_OK;
    LONG lRet = ERROR_SUCCESS;
    HKEY hkey = 0;
    
    lRet = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                REGISTRY_KEY_W3SVC_PARAMETERS_W,
                0,
                KEY_READ,
                &hkey);
    if (ERROR_SUCCESS != lRet)
    {
        hr = HRESULT_FROM_WIN32(lRet);
        goto end;
    }

    DWORD dwType;
    DWORD dwSize = sizeof(pdwStructAddr);
    lRet = RegQueryValueEx(hkey,
                    REGISTRY_VALUE_W3WPLIST_INFO_ADDR,
                    NULL,
                    &dwType,
                    (LPBYTE)&pdwStructAddr,
                    &dwSize);
    if (ERROR_SUCCESS != lRet)
    {
        hr = HRESULT_FROM_WIN32(lRet);
        goto end;
    }

    if ( pdwStructAddr == NULL ) // may need check for overflow or underflow error
    {
        hr = E_FAIL;
        goto end;
    }
    
    //
    // read in the struct in to the class var m_w3wpListInfoStruct
    //
    fReadMemStatus = ReadProcessMemory( hProcess,
                                        (LPCVOID)pdwStructAddr,
                                        &m_w3wpListInfoStruct,
                                        sizeof(W3WPLIST_INFO),
                                        &stNumBytesRead
                                        );

    if ( fReadMemStatus == FALSE )
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto end;
    }


    //
    // Read the remote list head in the class var.
    //

    fReadMemStatus = ReadProcessMemory( hProcess,
                                        m_w3wpListInfoStruct.m_pListHead,
                                        &m_remoteListHead,
                                        sizeof(LIST_ENTRY),
                                        &stNumBytesRead
                                        );
    
    if ( fReadMemStatus == FALSE )
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto end;
    }


    //
    // read in the num of requests served
    //

    fReadMemStatus = ReadProcessMemory( hProcess,
                                        m_w3wpListInfoStruct.m_pRequestsServed,
                                        &m_dwRequestsServed,
                                        sizeof(ULONG),
                                        &stNumBytesRead
                                        );
    
    if ( fReadMemStatus == FALSE )
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto end;
    }
end:
    if (hkey)
    {
        RegCloseKey(hkey);
        hkey = 0;
    }
    
    return hr;
}


HRESULT
ProcessDetails::DebugProcess( IN HANDLE hProcess)
/*++

Routine Description:

    This funciton is called if verbosity level >= 1. For
    lower verbosity level, we do not need to call this.

    Attaches it self to the worker process as a debugger. 
    Creates a debugging thread in it and waits 
    for the debug break event. The remote thread created 
    enters the critical section before breaking.

    Calls Traverse list which traverses the list 
    and copies the relevant info in this process' 
    memory.

    Detaches itseft from the worker process

Arguments:

    hProcess    --  handle to the process

Return Value:

    HRESULT hr  --  S_FALSE, if exe name does not match
                    S_OK if name matched and other funcitons
                    called from within also passed
                    Error code: if anything else failed
--*/
{
    BOOL bIsListTraversed = FALSE;
    DEBUG_EVENT DebugEv;                   // debugging event information 
    DWORD dwContinueStatus = DBG_CONTINUE; // exception continuation 
    HRESULT hr = S_OK;

    __try
    {
        //
        // attach to the worker process
        //
        if ( ! DebugActiveProcess( m_dwPID ) )
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            __leave;
        }
        for(;;) 
        { 
 
        // Wait for a debugging event to occur. The second parameter indicates 
        // that the function does not return until a debugging event occurs. 
 
            WaitForDebugEvent(&DebugEv, INFINITE); 
 
        // Process the debugging event code. 
 
            switch (DebugEv.dwDebugEventCode) 
            { 
                case EXCEPTION_DEBUG_EVENT: 
                {
                // Process the exception code. When handling 
                // exceptions, remember to set the continuation 
                // status parameter (dwContinueStatus). This value 
                // is used by the ContinueDebugEvent function. 
 
                    switch (DebugEv.u.Exception.ExceptionRecord.ExceptionCode) 
                    { 
                        case EXCEPTION_BREAKPOINT: 
                        {                            
                            // only occurs from the thread
                            // we created remotely. This 
                            // means that the worker process
                            // is in stable state, and its in 
                            // a critical section. We can 
                            // start traversing the list now.
                    
                            hr = TraverseList( hProcess);            
                            bIsListTraversed = TRUE;
                        
                            dwContinueStatus = DBG_CONTINUE;
                            break;
                        } // case EXCEPTION_BREAKPOINT
                    
                        default:
                        {
                            dwContinueStatus = DBG_EXCEPTION_NOT_HANDLED; 
                            break;
                        }
                    } // switch (DebugEv.u.Exception.ExceptionRecord.ExceptionCode)
                
                    break;
                } // case EXCEPTION_DEBUG_EVENT
                default:
                    break;
            } // switch (DebugEv.dwDebugEventCode) 
 
            // Resume executing the thread that reported the debugging event. 
        
            if ( ContinueDebugEvent( DebugEv.dwProcessId, 
                                     DebugEv.dwThreadId, 
                                     dwContinueStatus
                                     ) == 0 
                                     )
            {
                hr = HRESULT_FROM_WIN32(GetLastError());
                __leave; 
            }
        
            if ( bIsListTraversed == TRUE ) // traversed the list
            {
                break;
            }
        } 
    } // try
    __finally
    {
        if ( DebugActiveProcessStop( m_dwPID ) == FALSE )
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
        }
    } // __finally

    //
    // check for Ctrl+C, Ctrl+Break, etc
    //

    if ( CONSOLE_HANDLER_VAR::g_HAS_CONSOLE_EVENT_OCCURED == TRUE )
    {
        ExitThread(CONSOLE_HANDLER_VAR::g_THREAD_EXIT_CODE);
    }

    return hr;
}

HRESULT
ProcessDetails::TraverseList( IN HANDLE hProcess)
/*++

Routine Description:

    Traverses the list in the worker process
    and copies the relevant info (dependent on the 
    verbosity level) to the list in this process.
    This function is only called if the verbosity 
    level is >= 1. For lower verbostiy level,
    we don't need to call this

Arguments:

    hProcess    --  handle to the process
    
Return Value:

    HRESULT hr  --  E_FAIL, if any error occurs
                    else S_OK
--*/
{
    BOOL fReadMemStatus = FALSE;
    SIZE_T stNumBytesRead;
    PVOID pvMemReadAddr = NULL;
    REQUESTLIST_NODE* pRequestListNode = NULL;
    HTTP_REQUEST remoteHttpRequest;
    BYTE pNativeRequestBuffer[sizeof(UL_NATIVE_REQUEST)];
    UL_NATIVE_REQUEST* pUlNativeRequest = NULL;
    LIST_ENTRY* pNextRemoteListEntry = NULL;
    HRESULT hr = S_OK;
    DWORD dwError;
    DWORD dwCount = 1;
    BOOL fIsListCorrupt = FALSE;
    LIST_ENTRY* pPossibleBadRemoteListEntry = NULL;

    pUlNativeRequest = (UL_NATIVE_REQUEST*) pNativeRequestBuffer;

    // move to the first native request from the head and get the
    // address of native request

    pNextRemoteListEntry = m_remoteListHead.Flink;
    pPossibleBadRemoteListEntry = m_remoteListHead.Flink;

    while ((pNextRemoteListEntry != m_w3wpListInfoStruct.m_pListHead) &&
           (pNextRemoteListEntry != NULL )
           )
    {
        // traversal complete
        if ( ( fIsListCorrupt == TRUE ) &&
             ( pNextRemoteListEntry == pPossibleBadRemoteListEntry )
             )
        {
            goto end;
        }
        //
        // check for Ctrl+C, Ctrl+Break, etc
        //

        if ( CONSOLE_HANDLER_VAR::g_HAS_CONSOLE_EVENT_OCCURED == TRUE )
        {
            hr = E_FAIL;
            goto end;
        }

        pvMemReadAddr = CONTAINING_RECORD ( pNextRemoteListEntry,
                                            UL_NATIVE_REQUEST,
                                            _ListEntry
                                            );
        //
        // read in the UL_NATIVE_REQUEST obj
        //  
        fReadMemStatus = ReadProcessMemory( hProcess,
                                            pvMemReadAddr,
                                            pUlNativeRequest,
                                            sizeof(UL_NATIVE_REQUEST),
                                            &stNumBytesRead
                                            );
    
        if ( ( fReadMemStatus == FALSE ) ||
             ( pUlNativeRequest->_dwSignature != UL_NATIVE_REQUEST_SIGNATURE)
             )
        {
            dwError = GetLastError();
            
            if ( (dwError != ERROR_PARTIAL_COPY) &&
                 (dwError != ERROR_INVALID_ADDRESS) &&
                 (dwError != ERROR_NOACCESS)
                 )
            {       
                hr = E_FAIL;
                goto end;
            }

            //
            // this should never happen,
            // the only scenario is when the list
            // is corrupt at two diff locations
            //
            if ( fIsListCorrupt == TRUE )
            {
                goto end;
            }

            fIsListCorrupt = TRUE;
            goto NextRemoteNode;
        }

        //
        // read _ExecState var of UL_NATIVE_REQUEST and 
        // make sure that it is in NREQ_STATE_PROCESS
        //
        
        if ( pUlNativeRequest->_ExecState != NREQ_STATE_PROCESS )
        {
            goto NextRemoteNode;
        }

        //
        // read in the HTTP_REQUEST struct
        //
        pvMemReadAddr = pUlNativeRequest->_pbBuffer;
        
        fReadMemStatus = ReadProcessMemory( hProcess,
                                            pvMemReadAddr,
                                            &remoteHttpRequest,
                                            sizeof(HTTP_REQUEST),
                                            &stNumBytesRead
                                            );

        if ( fReadMemStatus == FALSE )
        {
            hr = E_FAIL;
            goto cleanup;
        }

        pRequestListNode = new REQUESTLIST_NODE();
        
        if ( pRequestListNode == NULL ) // new failed
        {
            hr = E_FAIL;
            goto end;
        }

        hr = pRequestListNode->m_w3wpListHttpReq.ReadFromWorkerProcess( hProcess,
                                                                        &remoteHttpRequest,
                                                                        m_chVerbosity
                                                                        );

        if ( hr == E_FAIL )
        {
            goto cleanup;
        }

        //
        // Insert node in the local list
        //
        InsertTailList( &m_localRequestListHead,
                        &(pRequestListNode->m_listEntry)
                        );
        pRequestListNode = NULL;

NextRemoteNode:
        //
        // Get address of next element in the remote list
        //
        if ( fIsListCorrupt == FALSE )
        {
            //
            // save address of the current node
            // just in case so that we can check for this
            // address coming from the back-
            // side of the list
            //

            pPossibleBadRemoteListEntry = pNextRemoteListEntry; 
            pNextRemoteListEntry = pUlNativeRequest->_ListEntry.Flink;
        }
        //
        // first time, we have to go back from the head
        //
        else if ( dwCount == 1 ) 
        {
            pNextRemoteListEntry = m_remoteListHead.Blink;
            dwCount = 2;
        }
        //
        // all other times just follow the back link
        //
        else 
        {
            pNextRemoteListEntry = pUlNativeRequest->_ListEntry.Blink;
        }

    } // while (pNextRemoteListEntry != m_pRemoteListHead);

    goto end;

cleanup:
    delete pRequestListNode;
    pRequestListNode = NULL;
        
end:
    return hr;
}



VOID
ProcessDetails::DumpRequests()
/*++

Routine Description:

    Traverses the local list and prints out the stuff
    depending on the current verbosity level chosen
    
Arguments:

    None

Return Value:

    None
--*/
{
    REQUESTLIST_NODE*  pListNode;
    PLIST_ENTRY pListEntry;


    if ( m_dwErrorCode != ERROR_SUCCESS )
    {
        wprintf( L"%-10ufailed. Error Code %u",
                 m_dwPID,
                 m_dwErrorCode
                 );
        goto end;
    }

    //
    // output stuff for verbosity level 0
    //
    wprintf ( L"%-10u %-28s %-28s",
              m_dwPID,
              m_pszAppPoolId,
              L"" // this should be app pool friendly name
              );

    if ( m_fListMode == TRUE )
    {
        wprintf( L"\n" );
        goto end;
    }

    wprintf( L"%-10u\n",
             m_dwRequestsServed
             );

    if ( m_chVerbosity == 0 )
    {
        goto end;
    }
    
    //
    // traversing the list
    //
    for ( pListEntry = m_localRequestListHead.Flink;
          pListEntry != &m_localRequestListHead;
          pListEntry = pListEntry->Flink
          )
    {

        pListNode = CONTAINING_RECORD( pListEntry,
                                       REQUESTLIST_NODE,
                                       m_listEntry
                                       );
        DBG_ASSERT(pListNode->CheckSignature());

        pListNode->m_w3wpListHttpReq.Print(m_chVerbosity);

    }
end:
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\iisplus\w3tp\thread_pool_private.h ===
/*++

Copyright (c) 1999-2001 Microsoft Corporation

Module Name:

    thread_pool_private.h

Abstract:

    Internal declarations and types for the IIS+ worker process
    thread pool.

    This thread pool is based on the IIS5 atq implementation.

Author:

    Taylor Weiss (TaylorW)       12-Jan-2000

Revision History:

--*/

#ifndef _THREAD_POOL_PRIVATE_H_
#define _THREAD_POOL_PRIVATE_H_


#include <tracelog.h>

/**********************************************************************
    Configuration
**********************************************************************/

//
// Registry parameters
// HKLM\System\CurrentControlSet\Services\InetInfo\Parameters
//

#define THREAD_POOL_REG_PER_PROCESSOR_THREADS     TEXT("MaxPoolThreads")
#define THREAD_POOL_REG_POOL_THREAD_LIMIT         TEXT("PoolThreadLimit")
#define THREAD_POOL_REG_PER_PROCESSOR_CONCURRENCY TEXT("MaxConcurrency")
#define THREAD_POOL_REG_THREAD_TIMEOUT            TEXT("ThreadTimeout")
#define THREAD_POOL_REG_POOL_THREAD_START         TEXT("ThreadPoolStartupThreadCount")
#define THREAD_POOL_REG_START_DELAY               TEXT("ThreadPoolStartDelay")
#define THREAD_POOL_REG_MAX_CONTEXT_SWITCH        TEXT("ThreadPoolMaxContextSwitch")
#define THREAD_POOL_REG_REF_TRACE_COUNTER         TEXT("ThreadPoolRefTraceCounter")
#define THREAD_POOL_REG_MAX_CPU                   TEXT("ThreadPoolMaxCPU")
#define THREAD_POOL_REG_EXACT_THREAD_COUNT        TEXT("ThreadPoolExactThreadCount")

//
// Default values
//

// special value of 0 means that system will determine this dynamically.
const DWORD THREAD_POOL_REG_DEF_PER_PROCESSOR_CONCURRENCY = 0;

// how many threads do we start with
const LONG THREAD_POOL_REG_DEF_PER_PROCESSOR_THREADS = 4;

// thirty minutes
const DWORD THREAD_POOL_REG_DEF_THREAD_TIMEOUT = (30 * 60);

// thread limits
const LONG THREAD_POOL_REG_MIN_POOL_THREAD_LIMIT = 64;
const LONG THREAD_POOL_REG_DEF_POOL_THREAD_LIMIT = 128;
const LONG THREAD_POOL_REG_MAX_POOL_THREAD_LIMIT = 256;

// thread_manager constants
const DWORD THREAD_POOL_TIMER_CALLBACK = 1000;
const DWORD THREAD_POOL_CONTEXT_SWITCH_RATE = 10000;

const DWORD THREAD_POOL_MAX_CPU_USAGE_DEFAULT = -1;

const DWORD THREAD_POOL_EXACT_NUMBER_OF_THREADS_DEFAULT = 0;

//
// Enumeration used for Ref Trace logging registry key
//

enum REF_TRACE_COUNTER_ENUM
{
   TRACE_NONE = 0,
   TRACE_WHEN_NULL,
   TRACE_ALWAYS
};

extern DWORD g_dwcCPU;

/**********************************************************************
**********************************************************************/

// Arbitrary signal for the thread to shutdown
const ULONG_PTR THREAD_POOL_THREAD_EXIT_KEY = -1;

/**********************************************************************
    Function declarations
**********************************************************************/


DWORD
I_ThreadPoolReadRegDword(
   IN HKEY     hkey,
   IN LPCTSTR  pszValueName,
   IN DWORD    dwDefaultValue
   );


class THREAD_POOL;
class THREAD_MANAGER;

#define SIGNATURE_THREAD_POOL_DATA            ((DWORD) 'ADPT')
#define SIGNATURE_THREAD_POOL_DATA_FREE       ((DWORD) 'xDPT')

/*++
Storage for data members of THREAD_POOL
--*/
class THREAD_POOL_DATA
{
private:
    DWORD m_dwSignature;

public:
    THREAD_POOL_DATA(THREAD_POOL * pPool)
    {
        m_dwSignature = SIGNATURE_THREAD_POOL_DATA;
        m_hCompPort = NULL;
        m_cThreads = 0;
        m_cAvailableThreads = 0;
        m_fShutdown = FALSE;
        m_pThreadManager = NULL;

        DBG_ASSERT(NULL != pPool);
        m_pPool = pPool;
#if DBG
        m_pTraceLog = NULL;
        m_dwTraceRegSetting = 0;
#endif

    }
    ~THREAD_POOL_DATA()
    {
        DBG_ASSERT(SIGNATURE_THREAD_POOL_DATA == m_dwSignature);
        m_dwSignature = SIGNATURE_THREAD_POOL_DATA_FREE;

        m_pPool = NULL;
        DBG_ASSERT(NULL == m_pThreadManager);
        DBG_ASSERT(NULL == m_hCompPort);
        DBG_ASSERT(0 == m_cAvailableThreads);
        DBG_ASSERT(0 == m_cThreads);
#if DBG
        DBG_ASSERT(NULL == m_pTraceLog);
        DBG_ASSERT(0 == m_dwTraceRegSetting);
#endif
    }

    BOOL InitializeThreadPool(THREAD_POOL_CONFIG * pThreadPoolConfig);

    DWORD ThreadPoolThread();
    static DWORD ThreadPoolThread(LPVOID pvThis);

    static void WINAPI ThreadPoolStop(LPVOID pvThis);

    BOOL ThreadPoolCheckThreadStatus();

    BOOL WINAPI OkToCreateAnotherThread();


    // -------------------------
    // Current state information
    // -------------------------

    //
    // Handle for completion port
    //
    HANDLE  m_hCompPort;

    //
    // number of thread in the pool
    //
    LONG    m_cThreads;

    //
    // # of threads waiting on the port.
    //
    LONG    m_cAvailableThreads;


    //
    // Are we shutting down
    //
    BOOL    m_fShutdown;

    //
    // Pointer to THREAD_MANAGER
    //
    THREAD_MANAGER *m_pThreadManager;

    //
    // Back pointer to owner THREAD_POOL
    //
    THREAD_POOL * m_pPool;

    //
    // the configuration information
    //
    THREAD_POOL_CONFIG m_poolConfig;

#if DBG
    //
    // Poniter to reference logging var
    //
    PTRACE_LOG m_pTraceLog;

    //
    // Reg setting for Ref tracing
    //
    DWORD m_dwTraceRegSetting;
#endif
};

#endif // !_THREAD_POOL_PRIVATE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\iisplus\wamps\dlldata_stub.c ===
#include "dlldata.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\iisplus\wam\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by Wam.rc
//
#define IDS_PROJNAME                    100
#define IDR_WAM                         101

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           102
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\iisplus\w3wplist\processdetails.h ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:    

    processdetails.h

Abstract:
    
    This class deals with all the things associated with
    a process in the w3wplist utility

Author:

    Hamid Mahmood (t-hamidm)     08-13-2001

Revision History:
    
    
    
--*/

#ifndef _process_details_h
#define _process_details_h

//
// exe name to match
//
#define EXE_NAME L"w3wp.exe"
//
// inetinfo name
//
#define INETINFO_NAME L"inetinfo.exe"

#define PROCESS_DETAILS_SIGNATURE       CREATE_SIGNATURE( 'PRDT')
#define PROCESS_DETAILS_SIGNATURE_FREE  CREATE_SIGNATURE( 'PRDx')

//
// offset of command line parameter from the 
// beginning of RTL_USER_PROCESS_PARAMETERS struct.
//
#define CMD_LINE_OFFSET FIELD_OFFSET(RTL_USER_PROCESS_PARAMETERS, CommandLine)
#define ENVIRONMENT_LINE_OFFSET FIELD_OFFSET(RTL_USER_PROCESS_PARAMETERS, Environment) 

class ProcessDetails
{
    public:
    
        VOID Init( IN DWORD dwPID,
                   IN CHAR chVerbosity,
                   IN BOOL bIsListMode
                   );

        VOID Terminate();

        HRESULT GetProcessDetails( IN  WCHAR* pszInputAppPoolId );
        VOID DumpRequests ();

        ProcessDetails();
        ~ProcessDetails();
    
    private:
        HRESULT ReadPEB(IN HANDLE hProcess );

        HRESULT GetModuleInfo( IN HANDLE hProcess );

        HRESULT GetAppPoolID( IN  HANDLE hProcess);

        HRESULT ParseAppPoolID( IN WCHAR* pszCmdLine);

        HRESULT ReadEnvironmentVar( IN HANDLE hProcess );

        HRESULT DebugProcess ( IN HANDLE hProcess );

        HRESULT TraverseList( IN HANDLE hProcess );

        //
        // Signature
        //
        DWORD                           m_dwSignature;
        
        //
        // process id
        //
        DWORD                           m_dwPID;

        //
        // string that holds the app pool id 
        //

        WCHAR*                          m_pszAppPoolId;

        //
        // Whether it is list mode or not
        //

        BOOL                            m_fListMode;

        //
        // pointer to the process parameters for the current worker process
        //

	    RTL_USER_PROCESS_PARAMETERS*    m_pProcessParameters;

        //
        // struct that stores the info of the worker process
        //

        W3WPLIST_INFO                   m_w3wpListInfoStruct;

        //
        // head node of the link list that contains the http requests
        // read in from the worker process
        //

        LIST_ENTRY                      m_localRequestListHead;

        //
        // head of the link list in the worker process.
        //

        LIST_ENTRY                      m_remoteListHead;

        //
        // requests served by the worker process
        //
        DWORD                           m_dwRequestsServed;
        
        //
        // verbosity level
        //

        CHAR                            m_chVerbosity;

        //
        // error code
        //
        DWORD                           m_dwErrorCode;

        //
        // flag that tells whether the current process 
        // is the inetinfo.exe
        //
        BOOL                            m_fIsInetinfo;

        //
        // set if we're in old mode. This is used by threads
        // to exit themselves when fIsOldMode is set.
        // The setting thread will get all the info
        // from the inetinfo process.
        //

        static BOOL                     sm_fIsOldMode;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\iisplus\w3wplist\w3wplist.cxx ===
/*++
    
Copyright (c) 2001 Microsoft Corporation

Module Name:    

    w3wplist.cxx

Abstract:

    implementation for w3wplist utility

Author:    
    
    Hamid Mahmood (t-hamidm)     06-08-2001

Revision History:
    
    
    
--*/
#include <precomp.hxx>
#include "w3wplist.hxx"
#include <ntrtl.h>


DECLARE_DEBUG_PRINTS_OBJECT();
DECLARE_DEBUG_VARIABLE();

w3wpList::w3wpList()
/*++

Routine Description:

    Constructor.

Arguments:

    none

Return Value:

    none

--*/
{
    m_pdwProcessId = NULL;
    m_pszTargetAppPoolId = NULL;
    m_dwCurrSizeOfProcessIdArray = 0;
    m_chVerbosity = 0;
    m_dwNumProcessId = 0;
    m_startingIndex = 0; 
    m_dwTargetPID = 0;
    InitializeListHead(&m_listHead);

    //
    // initialize global data
    //

    CONSOLE_HANDLER_VAR::g_HAS_CONSOLE_EVENT_OCCURED = FALSE;
    CONSOLE_HANDLER_VAR::g_THREAD_EXIT_CODE = 1;
    CONSOLE_HANDLER_VAR::g_PROCESS_EXIT_CODE = 1;

}


w3wpList::~w3wpList()
/*++

Routine Description:

    Destructor.

Arguments:

    none

Return Value:

    none

--*/
{
    DBG_ASSERT (m_dwCurrSizeOfProcessIdArray == 0);
    DBG_ASSERT (m_chVerbosity == 0);
    DBG_ASSERT (m_dwNumProcessId == 0);
    DBG_ASSERT (m_startingIndex == 0); 
    DBG_ASSERT (m_dwTargetPID == 0);
    DBG_ASSERT (m_pdwProcessId == NULL);
    DBG_ASSERT (m_pszTargetAppPoolId == NULL);
    DBG_ASSERT (IsListEmpty (&m_listHead) == TRUE );
}


HRESULT
w3wpList::Init( IN UCHAR chVerbosity,
                IN BOOL fIsListMode,
                IN WCHAR* pszInputAppPoolId,
                IN DWORD dwPID
                )
/*++

Routine Description:

    Initializes all the class members. 

Arguments:

    chVerbosity     --  verbosity level

Return Value:

    none

--*/
{
    HRESULT hr = S_OK;
    SYSTEM_INFO systemInfo;

    m_dwCurrSizeOfProcessIdArray = MIN_SIZE;
    m_chVerbosity = chVerbosity;
    m_fIsListMode = fIsListMode;
    m_dwTargetPID = dwPID;
    m_startingIndex = 0;
    
    InitializeListHead(&m_listHead);
    InitializeCriticalSection(&m_CriticalSection);        

    m_pdwProcessId = new DWORD[m_dwCurrSizeOfProcessIdArray];

    if ( m_pdwProcessId == NULL)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto end;
    }    

    if ( pszInputAppPoolId != NULL )
    {
        m_pszTargetAppPoolId = new WCHAR[wcslen(pszInputAppPoolId) + 1];

        if ( m_pszTargetAppPoolId == NULL )
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            goto cleanup;
        }

        wcscpy ( m_pszTargetAppPoolId,
                 pszInputAppPoolId );
    }

    // figure out how to read the num of processors

    GetSystemInfo( &systemInfo );
    m_dwNumThreads = systemInfo.dwNumberOfProcessors;

    goto end;
cleanup:
    delete [] m_pdwProcessId;
end:
    return hr;
}


VOID w3wpList::DestroyObject()
/*++

Routine Description:

    deallocates memory.

Arguments:

    none

Return Value:

    none

--*/
{
    W3WPLIST_NODE* pW3wpListNode = NULL;
    PLIST_ENTRY pListEntry = NULL;
  
    m_fIsListMode = FALSE;
    m_dwCurrSizeOfProcessIdArray = 0;
    m_chVerbosity = 0;
    m_dwNumThreads = 0;
    m_dwNumProcessId = 0;
    m_startingIndex = 0;
    m_dwTargetPID = 0;
    
    delete [] m_pdwProcessId;
    m_pdwProcessId = NULL;

    delete [] m_pszTargetAppPoolId;
    m_pszTargetAppPoolId = NULL;


    DeleteCriticalSection(&m_CriticalSection);

    //
    // deleting the link list
    //

    while ( ! IsListEmpty (&m_listHead) )
    {
        pListEntry = RemoveHeadList(&m_listHead);

        pW3wpListNode = CONTAINING_RECORD ( pListEntry,
                                            W3WPLIST_NODE,
                                            m_listEntry
                                            );
        //
        // terminate the ProcessDetails obj
        // before deleting
        //
        DBG_ASSERT(pW3wpListNode->CheckSignature());

        pW3wpListNode->m_wpDetails.Terminate();
        delete pW3wpListNode;
    }

    pW3wpListNode = NULL;
}

HRESULT
w3wpList::GetProcesses()
/*++

Routine Description:
    Gets all the PIDs and starts up threads
    to go through them.
    
Arguments:

    None

Return Value:

    HRESULT hr          --      S_OK if successful, else failed with 
                                error code

--*/
{
    BOOL fIsFull = FALSE;
    BOOL fCreateThreadFailed = FALSE;
    DWORD dwBytesReceived;
    DWORD dwBufferSize;
    HRESULT hr;
    DWORD dwIndex;
    DWORD dwCount;
    HANDLE* pHandles = NULL;

    // 
    // Enumerate all the processes. Memory is
    // re-allocated if the original size 
    // was not enough. 
    //

    do 
    {
        dwBufferSize = sizeof (DWORD) * m_dwCurrSizeOfProcessIdArray;
        if ( EnumProcesses ( m_pdwProcessId,
                             dwBufferSize,
                             &dwBytesReceived
                             ) == FALSE )
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            goto end;
        }

        m_dwNumProcessId = dwBytesReceived/sizeof(DWORD);

        //
        // Check for overflow, if yes increase size of 
        // m_pdwProcessId array
        //

        if ( m_dwNumProcessId == m_dwCurrSizeOfProcessIdArray )
        {
            DWORD * pdwTemp = m_pdwProcessId;
        
            m_dwCurrSizeOfProcessIdArray *= 2;
            m_pdwProcessId = new DWORD[m_dwCurrSizeOfProcessIdArray];
        
            delete [] pdwTemp;    
            pdwTemp = NULL;

            if ( m_pdwProcessId == NULL)
            {    
                hr = HRESULT_FROM_WIN32(GetLastError());
                goto end;
            }

            fIsFull = TRUE;
        }
        else
        {
            fIsFull = FALSE;
        }
        
    } while (fIsFull == TRUE);


    //
    // enable debug privilege for the current process
    //

    hr = EnableDebugPrivilege();
    if ( hr != S_OK )
    {
       goto end;
    }

    //
    // Create array for thread handles
    //
    pHandles = new HANDLE[m_dwNumThreads];

    if ( pHandles == NULL )
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto end;
    }

    //
    // spin off threads in suspended mode
    //
    for ( dwIndex = 0; dwIndex < m_dwNumThreads; dwIndex++ )
    {

        pHandles[dwIndex] = CreateThread( NULL,                   /* no security descriptor */
                                          0,                      /* default stack size */
                                          SpinNewThread,
                                          this,                   /* thread parameters */
                                          CREATE_SUSPENDED ,      /* suspended mode*/
                                          NULL                    /* not getting thread id */
                                          );

        if ( pHandles[dwIndex] == NULL )  // thread creation failed
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            fCreateThreadFailed = TRUE;
            break;
        }
    }

    //
    // we need dwCount b/c CreateThread may fail,
    // then we just need to loop through dwCount
    // threads
    //
    dwCount = dwIndex;
    if ( fCreateThreadFailed == TRUE )
    {
        for ( dwIndex = 0; dwIndex < dwCount; dwIndex++)
        {
            TerminateThread( pHandles[dwIndex],
                             GetLastError()
                             );
            CloseHandle( pHandles[dwIndex]);
        }
        goto end;
    }

    //
    // Set our own event handler for CTRL_C_EVENT, 
    // CTRL_BREAK_EVENT, CTRL_LOGOFF_EVENT, 
    // CTRL_SHUTDOWN_EVENT if verbosity > 0
    // else we don't debug
    // 

    if ( m_chVerbosity  > 0 )
    {
        SetConsoleCtrlHandler( ConsoleCtrlHandler,
                               TRUE
                               );
    }
    //
    // resume thread
    //
    for ( dwIndex = 0; dwIndex < dwCount; dwIndex++)
    {
        ResumeThread( pHandles[dwIndex]);
    }

    //
    // wait for all threads to exit
    //

    WaitForMultipleObjects( dwCount,             // number of handles in array
                            pHandles,            // object-handle array
                            TRUE,                // wait option
                            INFINITE             // time-out interval
                            );
 
    //
    // check for Ctrl+C, Ctrl+Break, etc
    //

    if ( CONSOLE_HANDLER_VAR::g_HAS_CONSOLE_EVENT_OCCURED == TRUE )
    {
        ExitProcess(CONSOLE_HANDLER_VAR::g_PROCESS_EXIT_CODE);
    }

    //
    // Turn back the default handler for CTRL_C_EVENT, 
    // CTRL_BREAK_EVENT, CTRL_LOGOFF_EVENT, 
    // CTRL_SHUTDOWN_EVENT
    //
    
    if ( m_chVerbosity > 0 )
    {
        SetConsoleCtrlHandler( ConsoleCtrlHandler,
                               FALSE
                               );
    }

    for ( dwIndex = 0; dwIndex < dwCount; dwIndex++)
    {
        CloseHandle(pHandles[dwIndex]);
    }


end:
    delete [] pHandles;
    return hr;
}


DWORD WINAPI 
w3wpList::SpinNewThread( LPVOID lpParam )
/*++

Routine Description:
    static Thread function
    
Arguments:

    None

Return Value:

    DWORD

--*/
{
    w3wpList* pw3wpList = (w3wpList*) lpParam;
    pw3wpList->EnumAllWPThread();
    return TRUE;
}


VOID
w3wpList::EnumAllWPThread()
/*++

Routine Description:
    Each thread goes through the PID array 
    and processess specific process.

    So, thread n will process the first 
    available PID and then PIDs at an 
    increment of NumOfThreads positions
    in the array
    
Arguments:

    None

Return Value:

    None
--*/
{
    //
    // get the first available index to start with
    //
    DWORD dwStartIndex = InterlockedIncrement(&m_startingIndex);
    
    //
    // since m_startingIndex is initialized to zero and we want to start
    // from index 0 
    //
    dwStartIndex--;

    //
    // walk throught the array of PIDs and 
    // call DoWork on each of them. DoWork
    // creates ProcessDetails obj for
    // each PID and gets the requests
    // if it were a worker process
    //

    for ( DWORD i = dwStartIndex; 
          i < m_dwNumProcessId; 
          i += m_dwNumThreads)
    {
        //
        // continue until we find the PID
        // of our interest. Only interesting
        // if lInputPID != -1, i.e were looking
        // at the app pool id
        //
        if ( (m_dwTargetPID != -1 ) && 
             (m_dwTargetPID != m_pdwProcessId[i])
             )
        {
            continue;
        }

        DoWork( m_pdwProcessId[i] );

        if (m_dwTargetPID == m_pdwProcessId[i])
        {
            break;
        }
    }// end for
}


VOID
w3wpList::DoWork( IN DWORD dwPID )
/*++

Routine Description:
    Ccreates ProcessDetails obj for
    each PID and gets the requests
    if it were a worker process.
    It then adds that obj to the list
    
Arguments:

    dwPID       --  PID of the process 

Return Value:

    None
--*/
{
    HRESULT hr;

    W3WPLIST_NODE* pW3wpListNode = NULL;

    //
    // create new Node for the list
    //
    pW3wpListNode = new W3WPLIST_NODE();

    if ( pW3wpListNode == NULL )
    {
        goto end;
    }

    //
    // Initialize the ProcessDetails obj 
    // in the node
    //
    pW3wpListNode->m_wpDetails.Init( dwPID,
                                     m_chVerbosity,
                                     m_fIsListMode
                                     );

    //
    // return value is S_OK if this was a worker process,
    // else it is S_FALSE
    //

    hr = pW3wpListNode->m_wpDetails.GetProcessDetails(m_pszTargetAppPoolId);

    if ( hr == S_FALSE )
    {
        goto cleanup;
    }
    
    //
    // It was a worker process, add the node to
    // the list
    //
    EnterCriticalSection( &m_CriticalSection );
    InsertTailList( &m_listHead,
                    &(pW3wpListNode->m_listEntry)
                    );
    LeaveCriticalSection( &m_CriticalSection );

    goto end;

cleanup:
    pW3wpListNode->m_wpDetails.Terminate();
    delete pW3wpListNode;
end:
    return;
}


HRESULT
w3wpList::EnableDebugPrivilege()
/*++

Routine Description:

    Changes the privilege of the current process
    so that it can debug other processes.

Arguments:

    None

Return Value:

    HRESULT hr  --  S_FALSE, if exe name does not match
                    S_OK if name matched and other funcitons
                    called from within also passed
                    Error code: if anything else failed
--*/
{
    HRESULT           Status = S_OK;
    HANDLE            Token;
    PTOKEN_PRIVILEGES NewPrivileges;
    BYTE              OldPriv[1024];
    ULONG             cbNeeded;
    LUID              LuidPrivilege;
 
    //
    // Make sure we have access to adjust and to get the
    // old token privileges
    //
    if (!OpenProcessToken(GetCurrentProcess(),
                          TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY,
                          &Token)
                          )
    {
        Status = GetLastError();
        goto EH_Exit;
    }

    cbNeeded = 0;

    //
    // Initialize the privilege adjustment structure
    //

    LookupPrivilegeValue(NULL, SE_DEBUG_NAME, &LuidPrivilege);

    NewPrivileges = (PTOKEN_PRIVILEGES)
        calloc(1, sizeof(TOKEN_PRIVILEGES) +
               (1 - ANYSIZE_ARRAY) * sizeof(LUID_AND_ATTRIBUTES));

    if (NewPrivileges == NULL)
    {
        Status = E_OUTOFMEMORY;
        goto EH_Token;
    }

    //
    // set new privilege
    //
    NewPrivileges->PrivilegeCount = 1;
    NewPrivileges->Privileges[0].Luid = LuidPrivilege;
    NewPrivileges->Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;

    //
    // Enable the privilege
    //

    if (!AdjustTokenPrivileges( Token,
                                FALSE,
                                NewPrivileges,
                                sizeof(OldPriv),
                                (PTOKEN_PRIVILEGES)OldPriv,
                                &cbNeeded )
                                )
    {
        //
        // If the stack was too small to hold the privileges
        // then allocate off the heap
        //
        if ( GetLastError() == ERROR_INSUFFICIENT_BUFFER )
        {
            PBYTE pbOldPriv;
            BOOL Adjusted;

            pbOldPriv = (PUCHAR)calloc(1, cbNeeded);
            if ( pbOldPriv == NULL )
            {
                Status = E_OUTOFMEMORY;
                goto EH_NewPriv;
            }

            Adjusted = AdjustTokenPrivileges( Token,
                                              FALSE,
                                              NewPrivileges,
                                              cbNeeded,
                                              (PTOKEN_PRIVILEGES)pbOldPriv,
                                              &cbNeeded );

            free(pbOldPriv);

            if ( !Adjusted )
            {
                Status = GetLastError();
            }
        }
    }

 EH_NewPriv:
    free(NewPrivileges);
 EH_Token:
    CloseHandle(Token);
 EH_Exit:
    return Status;
}

VOID
w3wpList::OutputRequests()
/*++

Routine Description:

    Outputs the information for each 
    of the ProcessDetails obj

Arguments:

    None

Return Value:

    None
--*/
{
    PLIST_ENTRY pListEntry;
    W3WPLIST_NODE* pListNode;

    for ( pListEntry = m_listHead.Flink;
          pListEntry != &m_listHead;
          pListEntry = pListEntry->Flink
          )
    {
        pListNode = CONTAINING_RECORD( pListEntry,
                                       W3WPLIST_NODE,
                                       m_listEntry
                                       );

        DBG_ASSERT (pListNode->CheckSignature());
        pListNode->m_wpDetails.DumpRequests();
    }
}

BOOL
w3wpList::ListEmpty()
/*++

Routine Description:

    Returns TRUE if the list of 
    ProcessDetails obj is empty

Arguments:

    None

Return Value:

    BOOL
--*/
{
    return IsListEmpty(&m_listHead);
}

BOOL WINAPI
w3wpList::ConsoleCtrlHandler( DWORD dwCtrlType )
{
    BOOL fReturnValue = TRUE;

    switch (dwCtrlType)
    {
       
        // Handle the CTRL+C signal. 
 
        case CTRL_C_EVENT: 
        case CTRL_BREAK_EVENT:
        case CTRL_LOGOFF_EVENT:
        case CTRL_SHUTDOWN_EVENT:
        {
            CONSOLE_HANDLER_VAR::g_HAS_CONSOLE_EVENT_OCCURED = TRUE;
            break;
        }
 
        default: 
        {
            CONSOLE_HANDLER_VAR::g_HAS_CONSOLE_EVENT_OCCURED = FALSE;
            fReturnValue = FALSE; 
        }
    } 
    return fReturnValue;
}

int __cdecl wmain(DWORD argc, WCHAR ** argv)
{
#define COL_WIDTH 30

    WCHAR pszIndent[] = { L"                              " };
    w3wpList w3wplstMyList;
    BOOL fIsListMode = FALSE;
    WCHAR* pszInputAppPoolId = NULL;
    UCHAR chInputVerbosity = 0;
    LONG lInputPID = -1;
    HRESULT hr;


    if ( argc <= 1 ) // no input args;  list mode
    {
        fIsListMode = TRUE;
    }

    else if ( argc == 2 ) // better be /?, else it's error
    {
        if ( _wcsicmp (argv[1], L"/?") == 0 ) // help
        {
            wprintf (L"Copyright (c) Microsoft Corporation. All rights reserved.\n\n\n");
            wprintf (L"%s\n%s\n%s\n\n",
                     L"Description: Use this tool to obtain worker process information, determine which",
                     L"worker process is assigned to a given application pool and show the requests",
                     L"that are queued in the worker process.");
            wprintf (L"Syntax: w3wplist [{/p | /a} <identifier> [<level of details>]]\n\n");
            wprintf (L"Parameters:\n");

            wprintf ( L"%-*s%s\n\n",
                      COL_WIDTH,
                      L"Value",
                      L"Description");

            wprintf ( L"%-*s%s\n%-*s%s\n",
                      COL_WIDTH,
                      L"/p",
                      L"Indicates that the <identifier> is a worker",
                      COL_WIDTH,
                      pszIndent,
                      L"process PID number."
                      );

            wprintf ( L"%-*s%s\n%-*s%s\n\n",
                      COL_WIDTH,
                      L"/a",
                      L"Indicates that the <identifier> is an application",
                      COL_WIDTH,
                      pszIndent,
                      L"pool identifier."
                      );

            wprintf ( L"%-*s\n",
                      COL_WIDTH,
                      L"<identifier>"
                      );

            wprintf ( L"%-*s%s\n%-*s%s\n%-*s%s\n",
                      COL_WIDTH,
                      L"application pool identifier",
                      L"Displays information associated with all active ",
                      COL_WIDTH,
                      pszIndent,
                      L"worker processes for the application pool",
                      COL_WIDTH,
                      pszIndent,
                      L"specified."
                      );

            wprintf ( L"%-*s%s\n%-*s%s\n\n",
                      COL_WIDTH,
                      L"worker process PID",
                      L"Displays information associated with the worker",
                      COL_WIDTH,
                      pszIndent,
                      L"process specified."
                      );

            wprintf ( L"%-*s%s\n",
                      COL_WIDTH,
                      L"<level of details>",
                      L"Verbosity levels are cumulative"
                      );

            wprintf ( L"%-*s%s\n%-*s%s\n%-*s%s\n%-*s%s\n",
                      COL_WIDTH,
                      L"/v or /v0",
                      L"Displays the worker process PID, the application",
                      COL_WIDTH,
                      pszIndent,
                      L"pool identifier, the application pool friendly-",
                      COL_WIDTH,
                      pszIndent,
                      L"name, and the total number of requests that have",
                      COL_WIDTH,
                      pszIndent,
                      L"been processed."
                      );

            wprintf ( L"%-*s%s\n%-*s%s\n",
                      COL_WIDTH,
                      L"/v1",
                      L"Adds the Universal Resource Identifier, host name,",
                      COL_WIDTH,
                      pszIndent,
                      L"and the HTTP verb."
                      );

            wprintf ( L"%-*s%s\n",
                      COL_WIDTH,
                      L"/v2",
                      L"Adds the URI query and the protocol version."
                      );

            wprintf ( L"%-*s%s\n%-*s%s\n",
                      COL_WIDTH,
                      L"/v3",
                      L"Adds the time, date, client-ip, and the referer,",
                      COL_WIDTH,
                      pszIndent,
                      L"user-agent, and cookie headers if available."
                      );

            wprintf ( L"%-*s%s\n%-*s%s\n\n",
                      COL_WIDTH,
                      L"/v4",
                      L"Adds the remaining available headers for the ",
                      COL_WIDTH,
                      pszIndent,
                      L"current request."
                      );

            wprintf ( L"%s\n%s\n%s\n%s\n%s\n%s\n",
                      L"Examples:",
                      L"     C:\\>w3wplist",
                      L"     C:\\>w3wplist /a app_pool_014",
                      L"     C:\\>w3wplist /p 4852",
                      L"     C:\\>w3wplist /a app_pool_014 /v",
                      L"     C:\\>w3wplist /p 4852 /v1"
                      );

            
            // MORE STUFF GOES HERE

            goto end;

        }
        else if ( _wcsicmp (argv[1], L"/p") == 0 ) 
        {
            wprintf (L"%s\n%s\n",
                     L"No worker process PID (W3wp.exe) was specified. Use Windows Task Manager to",
                     L"obtain a valid W3wp.exe PID number.");
            goto end;
        }
        else if ( _wcsicmp (argv[1], L"/a") == 0 ) 
        {
            wprintf (L"%s\n%s\n",
                     L"No application pool identifier was specified. Search in Metabase.xml to obtain",
                     L"a valid application pool identifier.");
            goto end;
        }
        else // invalid syntax 
        {
            wprintf (L"Invalid syntax. Type w3wplist /? for help.\n");
            goto end;        
        }
    }
    else if (argc == 4)
    {
        if ( (_wcsicmp(argv[3], L"/v") == 0) || 
            (_wcsicmp(argv[3], L"/v0") == 0 ) 
            ) 
        {
            chInputVerbosity = 0;
        }
        else if (_wcsicmp(argv[3], L"/v1") == 0) 
        {
            chInputVerbosity = 1;
        }
        else if (_wcsicmp(argv[3], L"/v2") == 0) 
        {
            chInputVerbosity = 2;
        }   
        else if (_wcsicmp(argv[3], L"/v3") == 0) 
        {
            chInputVerbosity = 3;
        }   
        else if (_wcsicmp(argv[3], L"/v4") == 0) 
        {
            chInputVerbosity = 4;
        }
        else if ( argc != 3 )
        {
            wprintf (L"Invalid syntax. Type w3wplist /? for help.\n");
            goto end;
        }
    }
    
    
    if ( (argc == 3 ) || 
        (argc == 4) 
        )
    {
        // default verbosity of 0
        if ( _wcsicmp (argv[1], L"/p") == 0 ) 
        {
            lInputPID = wcstol(argv[2], L'\0', 10);
        }

        else if ( _wcsicmp (argv[1], L"/a") == 0 ) 
        {
            pszInputAppPoolId = argv[2];
        }
    }

    //
    // initialize the object
    //
    hr = w3wplstMyList.Init( chInputVerbosity,
                             fIsListMode,
                             pszInputAppPoolId,
                             lInputPID );

    if ( FAILED (hr) )
    {
        goto error;
    }

    hr = w3wplstMyList.GetProcesses();

    if ( FAILED (hr) )
    {
        goto error;
    }

    //
    // if list is empty, it means that either the input
    // PID number was not a worker process or was invalid,
    // or the input app pool id was invalid
    //
    if ( w3wplstMyList.ListEmpty() )
    {
        // some message of not found
        if ( lInputPID != -1 ) // /p switch was input
        {
            wprintf( L"%s\n%s\n%s\n",
                     L"The worker process PID number (W3wp.exe) is not valid or is not associated with",
                     L"a W3wp.exe process. Use Windows Task Manager to obtain a valid W3wp.exe PID",
                     L"number." );
        }
        else if ( pszInputAppPoolId != NULL ) // /a switch was input
        {
            wprintf( L"%s\n%s\n",
                     L"The application pool identifier is not valid or does not exist. Search in",
                     L"Metabase.xml to obtain a valid application pool identifier." );
        }
    }

    // print out requests
    w3wplstMyList.OutputRequests();

    // deallocate memory
    w3wplstMyList.DestroyObject();
    goto end;    
    
error:

    // message of error
    wprintf ( L"Error occured. Error code : %d\n",
              HRESULT_CODE(hr)
              );
end:
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\iisplus\wamps\iwam_i_stub.c ===
#include "IWam_i.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\iisplus\wam\wam.cpp ===
/*++

   Copyright    (c)    1995-1997    Microsoft Corporation

   Module  Name :
       wam.cpp

   Abstract:
       This module implements the exported routines for WAM object

   Author:
       David Kaplan    ( DaveK )     26-Feb-1997
       Wade Hilmo      ( WadeH )     08-Sep-2000

   Environment:
       User Mode - Win32

   Project:
       Wam DLL

--*/

//
// Following are the notes from the original MSDEV generated file
// Note: Proxy/Stub Information
//        To merge the proxy/stub code into the object DLL, add the file
//        dlldatax.c to the project.  Make sure precompiled headers
//        are turned off for this file, and add _MERGE_PROXYSTUB to the
//        defines for the project.
//
//        If you are not running WinNT4.0 or Win95 with DCOM, then you
//        need to remove the following define from dlldatax.c
//        #define _WIN32_WINNT 0x0400
//
//        Further, if you are running MIDL without /Oicf switch, you also
//        need to remove the following define from dlldatax.c.
//        #define USE_STUBLESS_PROXY
//
//        Modify the custom build rule for Wam.idl by adding the following
//        files to the Outputs.
//            Wam_p.c
//            dlldata.c
//        To build a separate proxy/stub DLL,
//        run nmake -f Wamps.mk in the project directory.

// BEGIN mods
// Post-wizard mods appear within BEGIN mods ... END mods
// END mods

#include "precomp.hxx"

#include <w3isapi.h>
#include <isapi_context.hxx>
#include "wamobj.hxx"
#include "IWam_i.c"
#include "wamccf.hxx"

#include <atlbase.h>

// BEGIN mods
#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
// END mods

/************************************************************
 *  Global Variables
 ************************************************************/

const CHAR g_pszModuleName[] = "WAM";
const CHAR g_pszWamRegLocation[] =
  "System\\CurrentControlSet\\Services\\W3Svc\\WAM";

HMODULE                         WAM::sm_hIsapiModule;
PFN_ISAPI_TERM_MODULE           WAM::sm_pfnTermIsapiModule;
PFN_ISAPI_PROCESS_REQUEST       WAM::sm_pfnProcessIsapiRequest;
PFN_ISAPI_PROCESS_COMPLETION    WAM::sm_pfnProcessIsapiCompletion;


#ifdef _MERGE_PROXYSTUB
extern "C" HINSTANCE hProxyDll;
#endif

BEGIN_OBJECT_MAP(ObjectMap)
    OBJECT_ENTRY(CLSID_Wam, WAM)
END_OBJECT_MAP()

// BEGIN mods

WAM_CCF_MODULE _WAMCCFModule;

DECLARE_PLATFORM_TYPE();
DECLARE_DEBUG_VARIABLE();
DECLARE_DEBUG_PRINTS_OBJECT();
// END mods

/************************************************************
 *  Type Definitions  
 ************************************************************/
// BUGBUG
#undef INET_INFO_KEY
#undef INET_INFO_PARAMETERS_KEY

//
//  Configuration parameters registry key.
//
#define INET_INFO_KEY \
            "System\\CurrentControlSet\\Services\\iisw3adm"

#define INET_INFO_PARAMETERS_KEY \
            INET_INFO_KEY "\\Parameters"

const CHAR g_pszWpRegLocation[] =
    INET_INFO_PARAMETERS_KEY "\\WP";

class DEBUG_WRAPPER {

public:
    DEBUG_WRAPPER( IN LPCSTR pszModule )
    {
#if DBG
        CREATE_DEBUG_PRINT_OBJECT( pszModule );
#else
        UNREFERENCED_PARAMETER( pszModule );
#endif
        LOAD_DEBUG_FLAGS_FROM_REG_STR( g_pszWpRegLocation, DEBUG_ERROR );
    }

    ~DEBUG_WRAPPER(void)
    { DELETE_DEBUG_PRINT_OBJECT(); }
};

class CWamModule _Module;

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{
    DWORD dwErr = NO_ERROR;

#ifdef _MERGE_PROXYSTUB
    if (!PrxDllMain(hInstance, dwReason, lpReserved))
        return FALSE;
#endif

    if (dwReason == DLL_PROCESS_ATTACH)
    {

        //
        // BEGIN mods
        //
    
        // From ATL generated
        _Module.Init(ObjectMap, hInstance);
        DisableThreadLibraryCalls(hInstance);
        // End of ATL generated

        _WAMCCFModule.Init();

        // END mods

    }
    else if (dwReason == DLL_PROCESS_DETACH)
    {
        if ( NULL != lpReserved )
        {
            
            //
            // Only cleanup if there is a FreeLibrary() call
            //
         
            return ( TRUE);
        }
        _WAMCCFModule.Term();
        _Module.Term();

        // BEGIN mods

        DELETE_DEBUG_PRINT_OBJECT();
        // END mods
    }

    return (dwErr == NO_ERROR);
} // DllMain()

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
#ifdef _MERGE_PROXYSTUB
    if (PrxDllCanUnloadNow() != S_OK)
        return S_FALSE;
#endif
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    HRESULT hr;

    if (ppv == NULL) {
       return ( NULL);
    }
    *ppv = NULL;    // reset the value before getting inside.

    if (ppv == NULL) {
        return ( E_POINTER);
    }
    *ppv = NULL;   // set the incoming value to be invalid entry

#ifdef _MERGE_PROXYSTUB
    if (PrxDllGetClassObject(rclsid, riid, ppv) == S_OK)
        return S_OK;
#endif

    hr = _WAMCCFModule.GetClassObject(rclsid, riid, ppv);

    // BEGIN mods
    if (hr == CLASS_E_CLASSNOTAVAILABLE)
    {
        // If request for standard CF failed -> try custom
        hr = _Module.GetClassObject(CLSID_Wam, riid, ppv);
    }
    // END mods

    return ( hr);

} // DllGetClassObject()



/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
#ifdef _MERGE_PROXYSTUB
    HRESULT hRes = PrxDllRegisterServer();
    if (FAILED(hRes))
        return hRes;
#endif
    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
#ifdef _MERGE_PROXYSTUB
    PrxDllUnregisterServer();
#endif
    _Module.UnregisterServer();
    return S_OK;
}

HRESULT
WAM::WamProcessIsapiRequest(
    BYTE *pCoreData,
    DWORD cbCoreData,
    IIsapiCore *pIsapiCore,
    DWORD *pdwHseResult
    )
/*++

Routine Description:

    Processes an ISAPI request

Arguments:

    pCoreData    - The core data from the server for the request
    cbCoreData   - The size of pCoreData
    pIsapiCore   - The IIsapiCore interface pointer for this request
    pdwHseResult - Upon return, contains the return from HttpExtensionProc

Return Value:

    HRESULT

--*/
{
    HRESULT hr = NOERROR;

    pIsapiCore->AddRef();

    hr = sm_pfnProcessIsapiRequest(
        pIsapiCore,
        (ISAPI_CORE_DATA*)pCoreData,
        pdwHseResult
        );

    pIsapiCore->Release();

    return hr;
}

HRESULT
WAM::WamProcessIsapiCompletion(
    DWORD64 IsapiContext,
    DWORD cbCompletion,
    DWORD cbCompletionStatus
    )
/*++

Routine Description:

    Processes an ISAPI I/O completion

Arguments:

    IsapiContext        - The ISAPI_CONTEXT that identifies the request
    cbCompletion        - The number of bytes associated with the completion
    cbCompletionStatus  - The status code associated with the completion

Return Value:

    HRESULT

--*/
{
    HRESULT hr = NOERROR;

    hr = sm_pfnProcessIsapiCompletion(
        IsapiContext,
        cbCompletion,
        cbCompletionStatus
        );

    return hr;
}

HRESULT
WAM::WamInitProcess(
    BYTE *szIsapiModule,
    DWORD cbIsapiModule,
    DWORD *pdwProcessId,
    LPSTR szClsid,
    LPSTR szIsapiHandlerInstance,
    DWORD dwCallingProcess
    )
/*++

Routine Description:

    Initializes WAM for the host process.  This includes loading
    w3isapi.dll and getting function pointers for the relevant stuff

Arguments:

    szIsapiModule          - The full path (UNICODE) of w3isapi.dll
    cbIsapiModule          - The number of bytes in the above path
    pdwProcessId           - Upon return, contains the process ID of the
                             host process
    szClsid                - The CLSID of the WAM object being initialized
    szIsapiHandlerInstance - The instance ID of the W3_ISAPI_HANDLER that's
                             initializing this WAM.
    dwCallingProcess       - The process ID of this function's caller


Return Value:

    HRESULT

--*/
{
    HRESULT                 hr = NOERROR;
    PFN_ISAPI_INIT_MODULE   pfnInit = NULL;

    //
    // First, set the process ID for the process hosting this object
    //
    
    *pdwProcessId = GetCurrentProcessId();

    //
    // Initialize IISUTIL
    //

    if ( !InitializeIISUtil() )
    {
        hr = HRESULT_FROM_WIN32( GetLastError() );

        DBGPRINTF(( DBG_CONTEXT,
                    "Error initializing IISUTIL.  hr = %x\n",
                    hr ));

        goto ErrorExit;
    }
    
    //
    // Load and initialize the ISAPI module
    //

    sm_hIsapiModule = LoadLibraryW( (LPWSTR)szIsapiModule );
    if( sm_hIsapiModule == NULL )
    {
        hr = HRESULT_FROM_WIN32( GetLastError() );
        goto ErrorExit;
    }

    sm_pfnTermIsapiModule = 
        (PFN_ISAPI_TERM_MODULE)GetProcAddress( sm_hIsapiModule, 
                                               ISAPI_TERM_MODULE 
                                               );

    sm_pfnProcessIsapiRequest = 
        (PFN_ISAPI_PROCESS_REQUEST)GetProcAddress( sm_hIsapiModule,
                                                   ISAPI_PROCESS_REQUEST
                                                   );

    sm_pfnProcessIsapiCompletion =
        (PFN_ISAPI_PROCESS_COMPLETION)GetProcAddress( sm_hIsapiModule,
                                                      ISAPI_PROCESS_COMPLETION
                                                      );

    if( !sm_pfnTermIsapiModule ||
        !sm_pfnProcessIsapiRequest ||
        !sm_pfnProcessIsapiCompletion )
    {
        hr = E_FAIL;
        goto ErrorExit;
    }

    pfnInit = 
        (PFN_ISAPI_INIT_MODULE)GetProcAddress( sm_hIsapiModule, 
                                               ISAPI_INIT_MODULE 
                                               );
    if( !pfnInit )
    {
        hr = E_FAIL;
        goto ErrorExit;
    }

    hr = pfnInit(
        szClsid,
        szIsapiHandlerInstance,
        dwCallingProcess
        );

    if( FAILED(hr) )
    {
        goto ErrorExit;
    }

    return hr;

ErrorExit:

    DBG_ASSERT( FAILED( hr ) );

    return hr;
}

HRESULT
WAM::WamUninitProcess(
    VOID
    )
/*++

Routine Description:

    Uninitializes WAM for the host process.  This function ultimately
    causes TerminateExtension to get called for each loaded extension.

Arguments:

    None

Return Value:

    HRESULT

--*/
{
    HRESULT hr = NOERROR;
    
    DBG_ASSERT( sm_pfnTermIsapiModule );
    DBG_ASSERT( sm_hIsapiModule );

    if( sm_pfnTermIsapiModule )
    {
        sm_pfnTermIsapiModule();
        sm_pfnTermIsapiModule = NULL;
    }

    if( sm_hIsapiModule )
    {
        FreeLibrary( sm_hIsapiModule );
        sm_hIsapiModule = NULL;
    }

    TerminateIISUtil();

    return hr;
}

HRESULT
WAM::WamMarshalAsyncReadBuffer( 
    DWORD64 IsapiContext,
    BYTE *pBuffer,
    DWORD cbBuffer
    )
/*++

Routine Description:

    Receives a buffer to be passed to a request.  This function will be
    called just prior to an I/O completion in the case where and OOP
    extension does an asynchronous ReadClient.

Arguments:

    IsapiContext - The ISAPI_CONTEXT that identifies the request
    pBuffer      - The data buffer
    cbBuffer     - The size of pBuffer

Return Value:

    HRESULT

--*/
{
    ISAPI_CONTEXT * pIsapiContext;
    VOID *          pReadBuffer;
    DWORD           cbReadBuffer;

    pIsapiContext = reinterpret_cast<ISAPI_CONTEXT*>( IsapiContext );

    DBG_ASSERT( pIsapiContext );
    DBG_ASSERT( pIsapiContext->QueryIoState() == AsyncReadPending );

    pReadBuffer = pIsapiContext->QueryAsyncIoBuffer();
    cbReadBuffer = pIsapiContext->QueryLastAsyncIo();

    DBG_ASSERT( pReadBuffer != NULL );
    DBG_ASSERT( cbBuffer <= cbReadBuffer );

    //
    // Ensure that we don't overrun the ISAPI_CONTEXT buffer
    //

    if ( cbBuffer > cbReadBuffer )
    {
        cbBuffer = cbReadBuffer;
    }

    memcpy( pReadBuffer, pBuffer, cbBuffer );

    pIsapiContext->SetAsyncIoBuffer( NULL );
    pIsapiContext->SetLastAsyncIo( 0 );

    return NO_ERROR;
}

HRESULT
WAM::CallerHasAccess()
/*++

Routine Description:

    Get the COM call context and examine the calling thread to determine
    if the caller has sufficient access to make this call.

    Currently the check is just made that the caller is local system.

Arguments:

Return Value:

    HRESULT_FROM_WIN32( ERROR_ACCESS_DENIED ) - If caller is denied.
    FAILED() if failed for some other reason.

--*/
{
    HRESULT             hr;
    IServerSecurity *   pServerSecurity = NULL;
    BOOL                fImpersonated = FALSE;
    HANDLE              hToken = NULL;
    STACK_BUFFER(       TokenUserBuffer, 80 );
    DWORD               dwRequiredSize;
    TOKEN_USER *        pTokenUser;
    
    hr = CoGetCallContext( IID_IServerSecurity, (VOID **)&pServerSecurity );
    if( FAILED(hr) )
    {
        DBGERROR(( DBG_CONTEXT,
                   "Failed to get IServerSecurity. %0x\n",
                   hr ));
        goto exit;
    }

    hr = pServerSecurity->ImpersonateClient();
    if( FAILED(hr) )
    {
        DBGERROR(( DBG_CONTEXT,
                   "Failed to ImpersonateClient. %0x\n",
                   hr ));
        goto exit;
    }
    fImpersonated = TRUE;

    if( !OpenThreadToken( GetCurrentThread(),
                          TOKEN_QUERY,
                          TRUE,
                          &hToken ) )
    {
        hr = HRESULT_FROM_WIN32( GetLastError() );

        DBGERROR(( DBG_CONTEXT,
                   "Failed to OpenThreadToken gle=%d\n",
                   GetLastError() ));
        goto exit;
    }

    if( !GetTokenInformation( hToken,
                              TokenUser,
                              TokenUserBuffer.QueryPtr(),
                              TokenUserBuffer.QuerySize(),
                              &dwRequiredSize ) )
    {
        if( GetLastError() != ERROR_INSUFFICIENT_BUFFER )
        {
            hr = HRESULT_FROM_WIN32( GetLastError() );

            DBGERROR(( DBG_CONTEXT,
                       "Failed to GetTokenInformation gle=%d\n",
                       GetLastError() ));
            goto exit;
        }

        if( !TokenUserBuffer.Resize( dwRequiredSize ) )
        {
            hr = HRESULT_FROM_WIN32( ERROR_OUTOFMEMORY );
            goto exit;
        }

        if( !GetTokenInformation( hToken,
                                  TokenUser,
                                  TokenUserBuffer.QueryPtr(),
                                  TokenUserBuffer.QuerySize(),
                                  &dwRequiredSize ) )
        {
            hr = HRESULT_FROM_WIN32( GetLastError() );

            DBGERROR(( DBG_CONTEXT,
                       "Failed to GetTokenInformation gle=%d\n",
                       GetLastError() ));
            goto exit;
        }
    }
                              
    pTokenUser = (TOKEN_USER *)TokenUserBuffer.QueryPtr();

    if( !IsWellKnownSid( pTokenUser->User.Sid,
                         WinLocalSystemSid ) )
    {
        hr = HRESULT_FROM_WIN32( ERROR_ACCESS_DENIED );
        DBGERROR(( DBG_CONTEXT,
                  "Unknown user attempting to access\n" ));
        goto exit;
    }
    
exit:

    if( hToken )
    {
        CloseHandle( hToken );
    }
    
    if( fImpersonated )
    {
        DBG_ASSERT( pServerSecurity );
        pServerSecurity->RevertToSelf();
    }

    if( pServerSecurity )
    {
        pServerSecurity->Release();
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\iisplus\wam\wamccf.cxx ===
/*++

   Copyright    (c)    1997    Microsoft Corporation

   Module  Name :
       wamccf.cxx

   Abstract:
       This module implements the WAM Custom Class Factory
       which creates WAM objects regardless of passed class id

   Author:
       Dmitry Robsman   ( dmitryr )     07-Apr-1997

   Environment:
       User Mode - Win32

   Project:
       Wam DLL

--*/

/************************************************************
 *     Include Headers
 ************************************************************/
//#include <isapip.hxx>
//#include "setable.hxx"
#include <precomp.hxx>
#include "wamobj.hxx"
#include "wamccf.hxx"

/************************************************************
 *     W A M  C C F   
 ************************************************************/

WAM_CCF::WAM_CCF()
/*++

Routine Description:
    WAM_CCF Constructor

Arguments:

Return Value:

--*/
    : 
    m_cRef(0),
    m_pcfAtl(NULL)
    {

    // Query ATL's class factory for WAM

    _Module.GetClassObject
        (
        CLSID_Wam,
        IID_IClassFactory,
        (void **)(&m_pcfAtl)
        );
    }

/*----------------------------------------------------------*/
    
WAM_CCF::~WAM_CCF()
/*++

Routine Description:
    WAM_CCF Destructor

Arguments:

Return Value:

--*/
    {
    if (m_pcfAtl)
        m_pcfAtl->Release();
    }

/*----------------------------------------------------------*/

STDMETHODIMP 
WAM_CCF::QueryInterface
(
REFIID riid,
LPVOID *ppv
)
/*++

Routine Description:
    WAM_CCF implementation of IUnknown::QueryInterface

Arguments:
    REFIID riid     interface id
    LPVOID *ppv     [out]

Return Value:
    HRESULT

--*/
    {
    if (!ppv)
        return E_POINTER;

    if (!m_pcfAtl)  // must have original CF to create WAMs
        return E_NOINTERFACE;
        
    *ppv = NULL;

    if (IID_IUnknown == riid || IID_IClassFactory == riid)
        *ppv = this;

    if (*ppv)
        {
        ((LPUNKNOWN)*ppv)->AddRef();
        return NOERROR;
        }

    return E_NOINTERFACE;
    }

/*----------------------------------------------------------*/
    
STDMETHODIMP_(ULONG) 
WAM_CCF::AddRef()
/*++

Routine Description:
    WAM_CCF implementation of IUnknown::AddRef

Arguments:

Return Value:
    ref count

--*/
    {
    return (ULONG)InterlockedIncrement((LPLONG)(&m_cRef));
    }
    
/*----------------------------------------------------------*/

STDMETHODIMP_(ULONG) 
WAM_CCF::Release()
/*++

Routine Description:
    WAM_CCF implementation of IUnknown::Release

Arguments:

Return Value:
    ref count

--*/
    {
    ULONG cRef = (ULONG)InterlockedDecrement((LPLONG)(&m_cRef));
    if (cRef > 0)
        return cRef;

    delete this;
    return 0;
    }
    
/*----------------------------------------------------------*/

STDMETHODIMP
WAM_CCF::CreateInstance
(
LPUNKNOWN pUnkOuter,
REFIID    riid, 
LPVOID    *ppvObj
)
/*++

Routine Description:
    WAM_CCF implementation of IClassFactory::CreateInstance
    Delegate to default ATL CF

Arguments:
    LPUNKNOWN pUnkOuter     outer object
    REFIID    riid          interface id to query
    LPVOID   *ppvObj        [out]

Return Value:
    HRESULT

--*/
    {
    if (!m_pcfAtl)
        return E_UNEXPECTED;

    return m_pcfAtl->CreateInstance(pUnkOuter, riid, ppvObj);
    }
    
/*----------------------------------------------------------*/

STDMETHODIMP
WAM_CCF::LockServer
(
BOOL fLock
)
/*++

Routine Description:
    WAM_CCF implementation of IClassFactory::LockServer
    Delegate to default ATL CF

Arguments:
    BOOL fLock      flag (lock/unlock)

Return Value:
    HRESULT

--*/
    {
    if (!m_pcfAtl)
        return E_UNEXPECTED;
        
    m_pcfAtl->LockServer(fLock);
	return NOERROR;
    }


/************************************************************
 *     W A M  C C F  M O D U L E
 ************************************************************/

WAM_CCF_MODULE::WAM_CCF_MODULE()
/*++

Routine Description:
    WAM_CCF_MODULE Constructor

Arguments:

Return Value:

--*/
    : 
    m_pCF(NULL)
    {
    }

/*----------------------------------------------------------*/

WAM_CCF_MODULE::~WAM_CCF_MODULE()
/*++

Routine Description:
    WAM_CCF_MODULE Destructor

Arguments:

Return Value:

--*/
    {
    }
    
/*----------------------------------------------------------*/

HRESULT 
WAM_CCF_MODULE::Init()
/*++

Routine Description:
    Initialize WAM_CCF_MODULE. Create Custom Class Factory.

Arguments:

Return Value:
    HRESULT

--*/
    {
    m_pCF = new WAM_CCF;
    if (!m_pCF)
        return E_OUTOFMEMORY;
        
    m_pCF->AddRef(); // keep AddRef()'d
    return NOERROR;
    }

/*----------------------------------------------------------*/
        
HRESULT 
WAM_CCF_MODULE::Term()
/*++

Routine Description:
    UnInitialize WAM_CCF_MODULE. Remove Custom Class Factory.

Arguments:

Return Value:
    HRESULT

--*/
    {
    if (m_pCF)
        {
        m_pCF->Release();
        m_pCF = NULL;
        }

    return NOERROR;
    }

/*----------------------------------------------------------*/

HRESULT 
WAM_CCF_MODULE::GetClassObject
(
REFCLSID rclsid,
REFIID riid,
LPVOID *ppv
)
/*++

Routine Description:
    Gives out to the called an addref'd Custom Class Library

Arguments:
    REFCLSID rclsid     Class Id (ignored)
    REFIID   riid       QI CCF for this
    LPVOID  *ppv        [out] returned CCF pointer

Return Value:
    HRESULT

--*/
    {
    if (!m_pCF)
        return CLASS_E_CLASSNOTAVAILABLE;

    // CONSIDER: verify rclsid somehow
    
    return m_pCF->QueryInterface(riid, ppv);
    }

/************************ End of File ***********************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\iisplus\wamps\iwam_p_stub.c ===
#include "IWam_p.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\iisplus\webbench\string.cxx ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1999                **/
/**********************************************************************/

/*
    string.cxx

    This module contains a light weight string class.


    FILE HISTORY:
        Johnl       15-Aug-1994 Created
        MuraliK     27-Feb-1995 Modified to be a standalone module with buffer.
        MuraliK     2-June-1995 Made into separate library
*/

// Normal includes only for this module to be active
//

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <string.hxx>

//
//  Private Definations
//

//
//  Converts a value between zero and fifteen to the appropriate hex digit
//
#define HEXDIGIT( nDigit )                              \
     (CHAR)((nDigit) > 9 ?                              \
          (nDigit) - 10 + 'A'                           \
        : (nDigit) + '0')

// Change a hexadecimal digit to its numerical equivalent
#define TOHEX( ch )                                     \
    ((ch) > '9' ?                                       \
        (ch) >= 'a' ?                                   \
            (ch) - 'a' + 10 :                           \
            (ch) - 'A' + 10                             \
        : (ch) - '0')

//
//  When appending data, this is the extra amount we request to avoid
//  reallocations
//
#define STR_SLOP        128



/***************************************************************************++

Routine Description:

    Appends to the string starting at the (byte) offset cbOffset.

Arguments:

    pStr     - An ANSI string to be appended
    cbStr    - Length, in bytes, of pStr
    cbOffset - Offset, in bytes, at which to begin the append
    fAddSlop - If we resize, should we add an extra STR_SLOP bytes.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT STRA::AuxAppend(const BYTE * pStr,
                        ULONG        cbStr,
                        ULONG        cbOffset,
                        BOOL         fAddSlop)
{
    //
    //  Only resize when we have to.  When we do resize, we tack on
    //  some extra space to avoid extra reallocations.
    //
    //  Note: QuerySize returns the requested size of the string buffer,
    //        *not* the strlen of the buffer
    //
    if ( m_Buff.QuerySize() < cbOffset + cbStr + sizeof(CHAR) )
    {
        UINT uNewSize = cbOffset + cbStr;

        if (fAddSlop) {
            uNewSize += STR_SLOP;
        } else {
            uNewSize += sizeof(CHAR);
        }

        if ( !m_Buff.Resize(uNewSize) ) {
            return HRESULT_FROM_WIN32(GetLastError());
        }
    }

    //
    // copy the exact string and append a null character
    //
    memcpy((BYTE *)m_Buff.QueryPtr() + cbOffset,
           pStr,
           cbStr);

    //
    // set the new length
    //
    m_cchLen = cbStr + cbOffset;

    //
    // append NULL character
    //
    *(QueryStr() + m_cchLen) = '\0';

    return S_OK;
}

HRESULT
STRA::CopyToBuffer(
    CHAR *         pszBuffer,
    DWORD *        pcb
    ) const
{
    HRESULT         hr = S_OK;

    if ( pcb == NULL )
    {
        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }

    DWORD cbNeeded = QueryCCH() + 1;
    if ( *pcb >= cbNeeded &&
         pszBuffer != NULL )
    {
        //
        // Do the copy
        //
        memcpy(pszBuffer, QueryStr(), cbNeeded);
    }
    else
    {
        hr = HRESULT_FROM_WIN32( ERROR_INSUFFICIENT_BUFFER );
    }

    *pcb = cbNeeded;

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\inc\iis.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    iis.h

Abstract:

    Includes common user-mode header files.

Author:

    Murali Krishnan (MuraliK)       09-Nov-1998

Revision History:

--*/

#ifndef _IIS_H_
#define _IIS_H_



//
// Include all required system files
//

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>


//
// Include standard IIS definitions
//

#include <iisdef.h>



#endif // _IIS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\inc\makefile.inc ===
copyfiles:
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\iisplus\w3wplist\w3wplisthttpreq.cxx ===
/*++
    
Copyright (c) 2001 Microsoft Corporation

Module Name:    

    w3wplisthttpreq.cxx

Abstract:

    implementation of class W3wpListHttpReq.
    This class reads in all the relevant info
    from the http_request.

Author:    
    
    Hamid Mahmood (t-hamidm)     08-13-2001

Revision History:
    
    
    
--*/
#include "precomp.hxx"

CHAR   W3wpListHttpReq::sm_chHttpHeaderVerbosityLevel[HttpHeaderMaximum] = 
                            {   4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,
                                4,4,4,3,4,4,4,4,4,4,4,4,4,4,3,4,4,4,3
                            };


W3wpListHttpReq::W3wpListHttpReq()
/*++

Routine Description:

    Constructor

Arguments:

    None

Return Value:

    none

--*/
{
    m_httpRequestId = 0;
    m_dwNumUnknownHeaders = 0;
    m_httpVerb = HttpVerbMaximum;
    m_majorVersion = 0;
    m_minorVersion = 0;
    m_fIsHeaderPresent = FALSE;
    m_pszURI = NULL;
    m_pszHostName = NULL;
    m_pszUnknownVerb = NULL;
    m_pszQueryString = NULL;
    m_pszDateTime = NULL;
    m_pszClientIP = NULL;

    for (DWORD i = 0; i < HttpHeaderMaximum; i++)
    {
        m_ppszKnownHeaders[i] = NULL;
    }

    m_ppszUnknownHeaderNames = NULL;
    m_ppszUnknownHeaderValues = NULL;

    m_dwSignature = W3WPLIST_HTTP_REQ_SIGNATURE;
}
    
W3wpListHttpReq::~W3wpListHttpReq()
/*++

Routine Description:

    Destructor

Arguments:

    None

Return Value:

    none

--*/
{
    DBG_ASSERT (m_dwSignature == W3WPLIST_HTTP_REQ_SIGNATURE);

    m_dwSignature = W3WPLIST_HTTP_REQ_SIGNATURE_FREE;

    DBG_ASSERT(m_httpRequestId == 0);
    DBG_ASSERT(m_dwNumUnknownHeaders == 0);
    DBG_ASSERT(m_httpVerb == HttpVerbMaximum);
    DBG_ASSERT(m_majorVersion == 0);
    DBG_ASSERT(m_minorVersion == 0);
    DBG_ASSERT(m_fIsHeaderPresent == FALSE);
    DBG_ASSERT(m_pszURI == NULL);
    DBG_ASSERT(m_pszHostName == NULL);
    DBG_ASSERT(m_pszUnknownVerb == NULL);
    DBG_ASSERT(m_pszQueryString == NULL);
    DBG_ASSERT(m_pszDateTime == NULL);
    DBG_ASSERT(m_pszClientIP == NULL);

    for (DWORD i = 0; i < HttpHeaderMaximum; i++)
    {
        DBG_ASSERT(m_ppszKnownHeaders[i] == NULL);
    }

    DBG_ASSERT(m_ppszUnknownHeaderNames == NULL);
    DBG_ASSERT(m_ppszUnknownHeaderValues == NULL);
};

VOID
W3wpListHttpReq::Terminate()
/*++

Routine Description:

    Deallocates memory

Arguments:

    None

Return Value:

    none

--*/
{
    m_httpRequestId = 0;
    m_httpVerb = HttpVerbMaximum;
    m_fIsHeaderPresent = FALSE;
    m_minorVersion = 0;
    m_majorVersion = 0;

    delete[] m_pszURI;
    m_pszURI = NULL;

    delete[] m_pszHostName;
    m_pszHostName = NULL;

    delete[] m_pszUnknownVerb;
    m_pszUnknownVerb = NULL;
    
    delete[] m_pszQueryString;
    m_pszQueryString = NULL;
    
    delete[] m_pszDateTime;
    m_pszDateTime = NULL;
    
    delete[] m_pszClientIP;
    m_pszClientIP = NULL;

    for (DWORD i = 0; i < HttpHeaderMaximum; i++)
    {
        delete[] m_ppszKnownHeaders[i];
        m_ppszKnownHeaders[i] = NULL;
    }

    for (DWORD i = 0; i < m_dwNumUnknownHeaders; i++)
    {
        delete[] m_ppszUnknownHeaderNames[i];
        m_ppszUnknownHeaderNames[i] = NULL;

        delete[] m_ppszUnknownHeaderValues[i];
        m_ppszUnknownHeaderValues[i] = NULL;
    }
    m_ppszUnknownHeaderNames = NULL;
    m_ppszUnknownHeaderValues = NULL;

    m_dwNumUnknownHeaders = 0;
}



HRESULT 
W3wpListHttpReq::ReadFromWorkerProcess( HANDLE hProcess,
                                        HTTP_REQUEST* pHttpRequest,
                                        CHAR chVerbosity
                                        )
/*++

Routine Description:

    Reads in the relevant info from the input 
    http_request *.

Arguments:

    hProcess        --  input PID
    pHttpRequest    --  * to HTTP_REQEUST obj in worker process
    chVerbosity     --  verbosity level
 
Return Value:

    HRESULT         --  S_OK if success, otherwise E_FAIL

--*/
{
    BOOL fReadMemStatus = FALSE;
    SIZE_T stNumBytesRead;
    DWORD dwStrSize = 0;
    PHTTP_UNKNOWN_HEADER pUnknownHeadersInRemoteProcess = NULL;
    HTTP_UNKNOWN_HEADER unknownHeader;
    HRESULT hr = S_OK;

    //
    // check for Ctrl+C, Ctrl+Break, etc
    //

    if ( CONSOLE_HANDLER_VAR::g_HAS_CONSOLE_EVENT_OCCURED == TRUE )
    {
        hr = E_FAIL;
        goto end;
    }


    m_httpRequestId = pHttpRequest->RequestId;
    m_httpVerb = pHttpRequest->Verb;

    //
    // read in the unknown verb
    //
    dwStrSize = pHttpRequest->UnknownVerbLength;
    if ( dwStrSize != 0 )
    {
        m_pszUnknownVerb = new CHAR[dwStrSize + 1];
    
        if ( m_pszUnknownVerb == NULL ) // new failed
        {
            hr = E_FAIL;
            goto end;
        }
    
        fReadMemStatus = ReadProcessMemory( hProcess,
                                            pHttpRequest->pUnknownVerb,
                                            m_pszUnknownVerb,
                                            pHttpRequest->UnknownVerbLength,
                                            &stNumBytesRead
                                            );
    
        if ( fReadMemStatus == FALSE )
        {
            hr = E_FAIL;
            goto end;
        }

        m_pszUnknownVerb[dwStrSize] = '\0';
    }

    //
    // read in the Hostname
    //
    dwStrSize = pHttpRequest->CookedUrl.HostLength / sizeof(WCHAR);

    if ( dwStrSize != 0 )
    {
        m_pszHostName = new WCHAR[dwStrSize + 1];
    
        if ( m_pszHostName == NULL ) // new failed
        {
            hr = E_FAIL;
            goto end;
        }
    
        fReadMemStatus = ReadProcessMemory( hProcess,
                                            pHttpRequest->CookedUrl.pHost,
                                            m_pszHostName,
                                            pHttpRequest->CookedUrl.HostLength,
                                            &stNumBytesRead
                                            );
    
        if ( fReadMemStatus == FALSE )
        {
            hr = E_FAIL;
            goto end;
        }

        m_pszHostName[dwStrSize] = L'\0';
    }

    //
    // read in the AbsPath
    //
    dwStrSize = pHttpRequest->CookedUrl.AbsPathLength / sizeof(WCHAR);

    if ( dwStrSize != 0 )
    {
        m_pszURI = new WCHAR[dwStrSize + 1];
    
        if ( m_pszURI == NULL ) // new failed
        {
            hr = E_FAIL;
            goto end;
        }
        
        fReadMemStatus = ReadProcessMemory( hProcess,
                                            pHttpRequest->CookedUrl.pAbsPath,
                                            m_pszURI,
                                            pHttpRequest->CookedUrl.AbsPathLength,
                                            &stNumBytesRead
                                            );
    
        if ( fReadMemStatus == FALSE )
        {
            hr = E_FAIL;
            goto end;
        }

        m_pszURI[dwStrSize] = L'\0';
    }

    //
    // The rest is read in only if verbosity level is high enough
    //

    if ( chVerbosity < 2 )
    {
        goto end;
    }

    //
    // save protocol info
    //

    m_majorVersion = pHttpRequest->Version.MajorVersion;
    m_minorVersion = pHttpRequest->Version.MinorVersion;
    
    //
    // read in the QueryString
    //

    dwStrSize = pHttpRequest->CookedUrl.QueryStringLength / sizeof(WCHAR);

    if ( dwStrSize != 0 )
    {
        m_pszQueryString = new WCHAR[dwStrSize + 1];

        if ( m_pszQueryString == NULL ) // new failed
        {
            hr = E_FAIL;
            goto end;
        }
    
        fReadMemStatus = ReadProcessMemory( hProcess,
                                            pHttpRequest->CookedUrl.pQueryString,
                                            m_pszQueryString,
                                            pHttpRequest->CookedUrl.QueryStringLength,
                                            &stNumBytesRead
                                            );

        if ( fReadMemStatus == FALSE )
        {
            hr = E_FAIL;
            goto end;
        }

        m_pszQueryString[dwStrSize] = L'\0';
    }

    // Read verbosity 3 stuff;
    if ( chVerbosity < 3 )
    {
        goto end;
    }
    
    //
    // Client - IP
    //

    if ( pHttpRequest->Address.pRemoteAddress != NULL )
    {        
        SOCKADDR_STORAGE     SockAddr;
        CHAR                 szNumericAddress[NI_MAXHOST];
        
        if( pHttpRequest->Address.pLocalAddress->sa_family == AF_INET )
        {
            SOCKADDR_IN    * pSockaddr_In = ( SOCKADDR_IN * )&SockAddr;
            
            fReadMemStatus = ReadProcessMemory( hProcess,
                                                pHttpRequest->Address.pRemoteAddress,
                                                pSockaddr_In,
                                                sizeof(SOCKADDR_IN),
                                                &stNumBytesRead );
            if ( fReadMemStatus == FALSE )
            {
                hr = E_FAIL;
                goto end;
            }

            if( getnameinfo( ( LPSOCKADDR )&SockAddr,
                             sizeof( SOCKADDR_IN ),
                             szNumericAddress,
                             sizeof( szNumericAddress ),
                             NULL,
                             0,
                             NI_NUMERICHOST ) != 0 )
            {
                hr = HRESULT_FROM_WIN32( WSAGetLastError() );
                goto end;
            }        
        }
        else if( pHttpRequest->Address.pLocalAddress->sa_family == AF_INET6 )
        {
            SOCKADDR_IN6   * pSockaddr_In6 = ( SOCKADDR_IN6 * )&SockAddr;
            
            fReadMemStatus = ReadProcessMemory( hProcess,
                                                pHttpRequest->Address.pRemoteAddress,
                                                pSockaddr_In6,
                                                sizeof(SOCKADDR_IN6),
                                                &stNumBytesRead );

            if ( fReadMemStatus == FALSE )
            {
                hr = E_FAIL;
                goto end;
            }

            if( getnameinfo( ( LPSOCKADDR )&SockAddr,
                             sizeof( SOCKADDR_IN6 ),
                             szNumericAddress,
                             sizeof( szNumericAddress ),
                             NULL,
                             0,
                             NI_NUMERICHOST ) != 0 )
            {
                hr = HRESULT_FROM_WIN32( WSAGetLastError() );
                goto end;
            }        
        }
        else
        {
            DBG_ASSERT( FALSE );
        }

        m_pszClientIP = new CHAR[strlen( szNumericAddress ) + 1];

        if ( m_pszClientIP == NULL )
        {
            hr = E_FAIL;
            goto end;
        }

        strcpy( m_pszClientIP,
                szNumericAddress
                );
    }

    //
    // read headers, verbosity level for each header is 
    // defined in sm_chHttpHeaderVerbosityLevel array
    //

    for( DWORD i = 0; i < HttpHeaderMaximum; i++)
    {
        //
        // match verbosity level from the static array
        //
        if ( sm_chHttpHeaderVerbosityLevel[i] <= chVerbosity  )
        {   
            dwStrSize = pHttpRequest->Headers.KnownHeaders[i].RawValueLength;
        
            if ( dwStrSize != 0 )
            {
                m_fIsHeaderPresent = TRUE;
                m_ppszKnownHeaders[i] = new CHAR[dwStrSize + 1];

                if (m_ppszKnownHeaders[i] == NULL)
                {
                    hr = E_FAIL;
                    goto end;;
                }

                fReadMemStatus = ReadProcessMemory( hProcess,
                                                    pHttpRequest->Headers.KnownHeaders[i].pRawValue,
                                                    m_ppszKnownHeaders[i],
                                                    pHttpRequest->Headers.KnownHeaders[i].RawValueLength,
                                                    &stNumBytesRead
                                                    );

                if ( fReadMemStatus == FALSE )
                {
                    hr = E_FAIL;
                    goto end;
                }

                m_ppszKnownHeaders[i][dwStrSize] = '\0';
            }
        } // verbosity level check
    } // end for loop

    if ( chVerbosity < 4 )
    {
        goto end;
    }

    //
    // read in unknown headers
    //
    m_dwNumUnknownHeaders = pHttpRequest->Headers.UnknownHeaderCount;

    if ( m_dwNumUnknownHeaders > 0 ) // some unknown headers exist
    {
        m_fIsHeaderPresent = TRUE;
        pUnknownHeadersInRemoteProcess = pHttpRequest->Headers.pUnknownHeaders;

        //
        // allocate memory for unknown headers
        //
        m_ppszUnknownHeaderNames = new CHAR*[m_dwNumUnknownHeaders];

        if ( m_ppszUnknownHeaderNames == NULL )
        {
            hr = E_FAIL;
            goto end;
        }

        m_ppszUnknownHeaderValues = new CHAR*[m_dwNumUnknownHeaders];

        if ( m_ppszUnknownHeaderValues == NULL )
        {
            hr = E_FAIL;
            goto end;
        }

        //
        // read in all the unknown headers
        //
        for (DWORD i = 0 ; i < m_dwNumUnknownHeaders; i++ , pUnknownHeadersInRemoteProcess++)
        {
            //
            // read in the unknown header struct
            //
            fReadMemStatus = ReadProcessMemory( hProcess,
                                                pUnknownHeadersInRemoteProcess,
                                                &unknownHeader,
                                                sizeof(HTTP_UNKNOWN_HEADER),
                                                &stNumBytesRead
                                                );

            if (fReadMemStatus == FALSE)
            {
                hr = E_FAIL;
                goto end;
            }

            //
            // read in the name of the header
            //                    
            dwStrSize =  unknownHeader.NameLength;
            m_ppszUnknownHeaderNames[i] = new CHAR[dwStrSize + 1];

            if ( m_ppszUnknownHeaderNames[i] == NULL)
            {
                hr = E_FAIL;
                goto end;
            }

            fReadMemStatus = ReadProcessMemory( hProcess,
                                                unknownHeader.pName,
                                                m_ppszUnknownHeaderNames[i],
                                                unknownHeader.NameLength,
                                                &stNumBytesRead
                                                );

            if (fReadMemStatus == FALSE)
            {
                hr = E_FAIL;
                goto end;
            }

            m_ppszUnknownHeaderNames[i][dwStrSize] = '\0';

            //
            // read in the value of the header
            //
            dwStrSize =  unknownHeader.RawValueLength;
            m_ppszUnknownHeaderValues[i] = new CHAR[dwStrSize + 1];

            if ( m_ppszUnknownHeaderValues[i] == NULL)
            {
                hr = E_FAIL;
                goto end;
            }

            fReadMemStatus = ReadProcessMemory( hProcess,
                                                unknownHeader.pRawValue,
                                                m_ppszUnknownHeaderValues[i],
                                                unknownHeader.RawValueLength,
                                                &stNumBytesRead
                                                );

            if (fReadMemStatus == FALSE)
            {
                hr = E_FAIL;
                goto end;
            }

            m_ppszUnknownHeaderValues[i][dwStrSize] = '\0';

        } // for loop

        pUnknownHeadersInRemoteProcess = NULL;

    } // if unknown headers exists
end:
    return hr;
}



VOID 
W3wpListHttpReq::Print(CHAR chVerbosity)
/*++

Routine Description:

    Outputs request info dependent on the 
    verbosity level.

Arguments:

    chVerbosity     --  verbosity level
 
Return Value:

    None

--*/
{

#define MAX_TAG_WIDTH_1     12
#define MAX_TAG_WIDTH_2     20

enum{
URI = 0,
HOSTNAME,
PROTOCOL,
METHOD,
QUERY,
CLIENT_IP,
REQUEST_ID,
DATE_TIME,
HEADERS
};


    WCHAR* pOutputTags[] = { L"URI",
                             L"Hostname",
                             L"Protocol",
                             L"Method",
                             L"Query",
                             L"Client-IP",
                             L"Request Id",
                             L"Date/Time",
                             L"Headers"
    };
    
    WCHAR * pVerbs[] = {
        L"Unparsed",
        L"Unknown",
        L"Invalid",
        L"OPTIONS",
        L"GET",
        L"HEAD",
        L"POST",
        L"PUT",
        L"DELETE",
        L"TRACE",
        L"CONNECT",
        L"TRACK",
        L"MOVE",
        L"COPY",
        L"PROPFIND",
        L"PROPPATCH",
        L"MKCOL",
        L"LOCK",
        L"UNLOCK",
        L"SEARCH",
    };                                            

    WCHAR* pOutputHeaderNames[] = 
    {
    L"Cache-Control",
    L"Connection",
    L"Date",
    L"Keep-Alive",
    L"Pragma",
    L"Trailer",
    L"Transfer-Encoding",
    L"Upgrade",
    L"Via",
    L"Warning",
    L"Allow",
    L"Content-Length",
    L"Content-Type",
    L"Content-Encoding",
    L"Content-Language",
    L"Content-Location",
    L"Content-Md5",
    L"Content-Range",
    L"Expires",
    L"LastModified",
    L"Accept",
    L"Accept-Charset",
    L"Accept-Encoding",
    L"Accept-Language",
    L"Authorization",
    L"Cookie",
    L"Expect",
    L"From",
    L"Host",
    L"If-Match",
    L"If-Modified-Since",
    L"If-NoneMatch",
    L"If-Range",
    L"If-Unmodified-Since",
    L"Max-Forwards",
    L"Proxy-Authorization",
    L"Referer",
    L"Range",
    L"Te",
    L"Translate",
    L"UserAgent"
    };

    DBG_ASSERT (chVerbosity > 0);


    wprintf ( L"%-*s: %u\n", 
              MAX_TAG_WIDTH_1,
              pOutputTags[REQUEST_ID], 
              m_httpRequestId
              );

    wprintf ( L"   %-*s: %s\n", 
              MAX_TAG_WIDTH_1,
              pOutputTags[URI], 
              m_pszURI
              );

    wprintf ( L"   %-*s: %s\n", 
              MAX_TAG_WIDTH_1,
              pOutputTags[HOSTNAME], 
              m_pszHostName
              );

    if ( m_httpVerb != HttpVerbUnknown)
    {
        wprintf ( L"   %-*s: %s\n", 
                  MAX_TAG_WIDTH_1,
                  pOutputTags[METHOD], 
                  pVerbs[m_httpVerb]
                  );
    }
    else
    {
        printf ( "   %-*S: %s\n", 
                 MAX_TAG_WIDTH_1,
                 pOutputTags[METHOD], 
                 m_pszUnknownVerb
              );
    }
    
    if ( chVerbosity < 2 )
    {
        goto end;
    }
    wprintf ( L"   %-*s: HTTP/%d.%d\n", 
              MAX_TAG_WIDTH_1,
              pOutputTags[PROTOCOL], 
              m_majorVersion,
              m_minorVersion
              );

    if ( m_pszQueryString != NULL )
    {
        wprintf ( L"   %-*s: %s\n", 
                  MAX_TAG_WIDTH_1,
                  pOutputTags[QUERY], 
                  m_pszQueryString
                  );
    }


    if ( chVerbosity < 3 )
    {
        goto end;
    }

    if ( m_pszClientIP != NULL )
    {
        printf ( "   %-*S: %s\n", 
                 MAX_TAG_WIDTH_1,
                 pOutputTags[CLIENT_IP], 
                 m_pszClientIP
                 );
    }

    if ( m_fIsHeaderPresent != TRUE )
    {
        goto end;
    }
                
    wprintf ( L"   %-*s:\n", 
              MAX_TAG_WIDTH_1,
              pOutputTags[HEADERS]
              );

    if ( m_ppszKnownHeaders[HttpHeaderReferer] != NULL )
    {
        printf ( "      %-*S: %s\n", 
                  MAX_TAG_WIDTH_2,
                  pOutputHeaderNames[HttpHeaderReferer], 
                  m_ppszKnownHeaders[HttpHeaderReferer]
                  );
    }

    if ( m_ppszKnownHeaders[HttpHeaderUserAgent] != NULL )
    {
        printf ( "      %-*S: %s\n", 
                  MAX_TAG_WIDTH_2,
                  pOutputHeaderNames[HttpHeaderUserAgent], 
                  m_ppszKnownHeaders[HttpHeaderUserAgent]
                  );
    }
    
    if ( m_ppszKnownHeaders[HttpHeaderCookie] != NULL )
    {
        printf ( "      %-*S: %s\n", 
                  MAX_TAG_WIDTH_2,
                  pOutputHeaderNames[HttpHeaderCookie], 
                  m_ppszKnownHeaders[HttpHeaderCookie]
                  );
    }

    if ( chVerbosity < 4 )
    {
        goto end;
    }

    for( DWORD i = 0; i < HttpHeaderMaximum; i++)
    {
        if ( ( i != HttpHeaderCookie ) &&
             ( i != HttpHeaderUserAgent ) &&
             ( i != HttpHeaderReferer )
             )
        {   
            if ( m_ppszKnownHeaders[i] != NULL )
            {
                printf ( "      %-*S: %s\n", 
                          MAX_TAG_WIDTH_2,
                          pOutputHeaderNames[i], 
                          m_ppszKnownHeaders[i]
                          );
            }
        } 
    } // end for loop

    // for loop

    for ( DWORD i = 0; i < m_dwNumUnknownHeaders; i++)
    {
        printf ( "      %-*s: %s\n", 
                  MAX_TAG_WIDTH_2,
                  m_ppszUnknownHeaderNames[i],
                  m_ppszUnknownHeaderValues[i]
                  );               
    }
end:
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\iisplus\webbench\buffer.cxx ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp., 1991-1996           **/
/**********************************************************************/

/*
    buffer.cxx
    Implementation of the BUFFER class.

    FILE HISTORY:
        MuraliK     3-July-1996 Rewrote the buffer class
*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <buffer.hxx>



/*******************************************************************

    NAME:       BUFFER::GetNewStorage

    SYNOPSIS:   Given an object with no allocated storage,
                allocate the initial memory.

    ENTRY:      cbRequested - amount of storage requested in bytes

    EXIT:       Either storage alloc'd, or error reported
                Sets m_cb, m_pb and m_fIsDynAlloced

    RETURNS:    TRUE if successful, FALSE for GetLastError()

    NOTES:
        Private member function.

********************************************************************/

BOOL
BUFFER::GetNewStorage( UINT cbRequested )
{
    if ( cbRequested <= m_cb) {

        return TRUE;
    }

    m_pb = (BYTE *) ::LocalAlloc( NONZEROLPTR, cbRequested );

    if ( !m_pb ) {
        SetLastError( ERROR_NOT_ENOUGH_MEMORY );
    } else {
        m_pb[0] = '\0'; // just store null
        m_cb = cbRequested;
        m_fIsDynAlloced = 1;
    }

    return (m_pb != NULL);
} // BUFFER::GetNewStorage()



/*******************************************************************

    NAME:       BUFFER::ReallocStorage

    SYNOPSIS:   Do a "hard" reallocation to the new size

    ENTRY:      cbNewRequested - new size, in bytes

    EXIT:       Storage realloc'd. m_pb, m_cb, m_fIsDynAlloced changed

    RETURNS:    TRUE if successful, FALSE for GetLastError()

********************************************************************/

BOOL
BUFFER::ReallocStorage( UINT cbNewRequested )
{
    if ( cbNewRequested <= m_cb) {

        return (TRUE);
    }

    HANDLE hNewMem = ((IsDynAlloced()) ?
                      (::LocalReAlloc( m_pb, cbNewRequested, LMEM_MOVEABLE )):
                      (::LocalAlloc( NONZEROLPTR, cbNewRequested))
                      );

    if (hNewMem == 0)
    {
        SetLastError( ERROR_NOT_ENOUGH_MEMORY );
        return FALSE;
    }

    if ( !IsDynAlloced()) {
        // First time this block is allocated. Copy over old contents.
        CopyMemory( (BYTE* ) hNewMem, m_pb, m_cb);
        m_fIsDynAlloced = 1;
    }

    m_pb = (BYTE *) hNewMem;
    m_cb = cbNewRequested;

    return TRUE;
} // BUFFER::ReallocStorage()



/*******************************************************************

    NAME:       BUFFER::VerifyState

    SYNOPSIS:   Verifies the state of the object.
                Asserts out if the state is invalid, i.e. if an
                internal error took place.

    NOTES:      This function does nothing in the retail version.

********************************************************************/

VOID BUFFER::VerifyState() const
{
    //
    //  1. If Dynamically Allocated ==>
    //       m_pb points to something other than m_rgb &
    //       m_cb > INLINED_BUFFER_LEN
    //  2. If not Dynamicall Allocated ==>
    //       (a)  it can be using user-supplied buffer & any sized
    //       (b)  it can be using inlined buffer & m_cb == INLINED_BUFFER_LEN
    //

} // BUFFER::VerifyState()



/*******************************************************************

    NAME:       BUFFER::FreeMemory

    SYNOPSIS:   Frees the heap memory associated with this buffer object

********************************************************************/

VOID
BUFFER::FreeMemory(
    VOID
    )
{
    if ( IsDynAlloced()) {
        ::LocalFree( (HANDLE)m_pb );
        m_pb = m_rgb;
        m_cb = INLINED_BUFFER_LEN;
        m_fIsDynAlloced = 0;
    }

    m_rgb[0] = '\0';  // reset the contents
}



BOOL
BUFFER_CHAIN::AppendBuffer(
    BUFFER_CHAIN_ITEM * pBCI
    )
/*++

Routine Description:

    Adds a new buffer chain item to the end of the buffer chain

Arguments:

    pBCI - Chain item to append

Return Value:

    TRUE if successful, FALSE on error

--*/
{
    InsertTailList( &_ListHead,
                    &pBCI->_ListEntry );

    return TRUE;
}



DWORD
BUFFER_CHAIN::DeleteChain(
    VOID
    )
/*++

Routine Description:

    Deletes all of the buffers in this chain

Return Value:

    Total number of allocated bytes freed by this call

--*/
{
    BUFFER_CHAIN_ITEM * pBCI;
    DWORD               cbFreed = 0;

    while ( !IsListEmpty( &_ListHead ))
    {
        pBCI = CONTAINING_RECORD( _ListHead.Flink,
                                  BUFFER_CHAIN_ITEM,
                                  _ListEntry );

        RemoveEntryList( &pBCI->_ListEntry );

        cbFreed += pBCI->QuerySize();

        delete pBCI;
    }

    return cbFreed;
}



BUFFER_CHAIN_ITEM *
BUFFER_CHAIN::NextBuffer(
    BUFFER_CHAIN_ITEM * pBCI
    )
/*++

Routine Description:

    Returns the next buffer in the chain.  Start the enumeration by
    passing pBCI as NULL.  Continue it by passing the return value

Arguments:

    pBCI - Previous item in enumeration

Return Value:

    Pointer to next item in chain, NULL when done

--*/
{
    if ( pBCI != NULL )
    {
        if ( pBCI->_ListEntry.Flink != &_ListHead )
        {
            return CONTAINING_RECORD( pBCI->_ListEntry.Flink,
                                      BUFFER_CHAIN_ITEM,
                                      _ListEntry );
        }
        else
        {
            return NULL;
        }
    }

    if ( !IsListEmpty( &_ListHead ))
    {
        return CONTAINING_RECORD( _ListHead.Flink,
                                  BUFFER_CHAIN_ITEM,
                                  _ListEntry );
    }

    return NULL;
}



DWORD
BUFFER_CHAIN::CalcTotalSize(
    BOOL fUsed
    ) const
/*++

Routine Description:

    Returns the total amount of memory allocated by this buffer chain
    excluding the size of the structures themselves


Arguments:

    fUsed - If FALSE, returns total allocated by chain, if TRUE returns
        total used by chain

Return Value:

    Total bytes allocated or total bytes used

--*/
{
    LIST_ENTRY *        pEntry;
    BUFFER_CHAIN_ITEM * pBCI;
    DWORD               cbRet = 0;

    for ( pEntry  = _ListHead.Flink;
          pEntry != &_ListHead;
          pEntry  = pEntry->Flink )
    {
        pBCI = CONTAINING_RECORD( pEntry, BUFFER_CHAIN_ITEM, _ListEntry );

        if ( fUsed == FALSE )
            cbRet += pBCI->QuerySize();
        else
            cbRet += pBCI->QueryUsed();
    }

    return cbRet;
}

/***************************** End Of File ******************************/

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\inc\iisdef.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    iisdef.h

Abstract:

    The IIS shared definitions header.

Author:

    Seth Pollack (sethp)        01-Dec-1998

Revision History:

--*/


#ifndef _IISDEF_H_
#define _IISDEF_H_


//
// Define some standard 64-bit stuff here
//

//
// The DIFF macro should be used around an expression involving pointer
// subtraction. The expression passed to DIFF is cast to a size_t type,
// allowing the result to be easily assigned to any 32-bit variable or
// passed to a function expecting a 32-bit argument.
//

#define DIFF(x)     ((size_t)(x))



//
// Signature helpers
//


//
// Create a signature that reads the same way in the debugger as how you
// define it in code. Done by byte-swapping the DWORD passed into it.
//
// Typical usage:
//
// #define FOOBAR_SIGNATURE         CREATE_SIGNATURE( 'FBAR' )
// #define FOOBAR_SIGNATURE_FREED   CREATE_SIGNATURE( 'fbaX' )
//

#define CREATE_SIGNATURE( Value )                                   \
            (                                                       \
                ( ( ( ( DWORD ) Value ) & 0xFF000000 ) >> 24 ) |    \
                ( ( ( ( DWORD ) Value ) & 0x00FF0000 ) >> 8 )  |    \
                ( ( ( ( DWORD ) Value ) & 0x0000FF00 ) << 8 )  |    \
                ( ( ( ( DWORD ) Value ) & 0x000000FF ) << 24 )      \
            )                                                       \



#ifndef __HTTP_SYS__

//
// Error handling helpers
//

#ifdef __cplusplus

//
// Recover the Win32 error from an HRESULT.
//
// The HRESULT must be a failure, i.e. FAILED(hr) must be true.
// If these conditions are not met, then it returns the error code
// ERROR_INVALID_PARAMETER.
//

inline DWORD WIN32_FROM_HRESULT(
    IN HRESULT hr
    )
{
    if ( ( FAILED( hr ) ) &&
         ( HRESULT_FACILITY( hr ) == FACILITY_WIN32 ) )
    {
        return ( HRESULT_CODE( hr ) );
    }
    else
    {
        // invalid parameter!

        // BUGBUG would be nice to assert here

        return hr;
    }
}

# else

# define WIN32_FROM_HRESULT(hr)   \
      (( (FAILED(hr)) &&          \
         (HRESULT_FACILITY(hr) == FACILITY_WIN32) \
        )                         \
       ?                          \
       HRESULT_CODE(hr)           \
       : hr  \
       )
#endif  // _cplusplus

#endif // !__HTTP_SYS__

//
// Generate an HRESULT from a LK_RETCODE.
//
// BUGBUG temporary; really we need a fix in the lkhash code.
//

#define HRESULT_FROM_LK_RETCODE( LkRetcode )                        \
            ( ( LkRetcode == LK_SUCCESS ) ? S_OK : E_FAIL )


//
// DNLEN is set to short value (15) that is good enough only for NetBIOS names
// Until there is more suitable constant let's use our own
//
#define IIS_DNLEN					(256)

//
// IIS_DEFAULT_INITIAL_STACK_SIZE is the default size of commited stack for threads
// However DBGPRINTF uses a stack variables of approximately 0xf100 and hence
// in debug builds we need significantly bigger stack.
//
#if DBG
    // Initial size of 96k to prevent stack overflows
    #define IIS_DEFAULT_INITIAL_STACK_SIZE  0x18000
#else
    // Initial size of 32k to prevent stack overflows
    #define IIS_DEFAULT_INITIAL_STACK_SIZE  0x8000
#endif



#endif  // _IISDEF_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\inc\aspresource.h ===
/*===================================================================
Microsoft Denali

Microsoft Confidential.
Copyright 1996 Microsoft Corporation. All Rights Reserved.

Component: Resources

File: Resource.h

Owner: AndrewS

This file contains constants for all resources used by Denali

===================================================================*/


#define IDE_BEGIN					100

//
// General errors
//
#define IDE_GENERAL_BEGIN			100
#define IDE_OOM						IDE_GENERAL_BEGIN
#define IDE_UNEXPECTED				IDE_GENERAL_BEGIN + 1
#define IDE_EXPECTING_STR			IDE_GENERAL_BEGIN + 2
#define IDE_EXPECTING_INT			IDE_GENERAL_BEGIN + 3
#define IDE_NOT_ALLOWED				IDE_GENERAL_BEGIN + 4
#define IDE_BAD_ARRAY_INDEX			IDE_GENERAL_BEGIN + 5	
#define IDE_TYPE_MISMATCH			IDE_GENERAL_BEGIN + 6
#define IDE_STACK_OVERFLOW			IDE_GENERAL_BEGIN + 7
#define IDS_COUNINITIALIZE			IDE_GENERAL_BEGIN + 8
#define IDS_TRUE					IDE_GENERAL_BEGIN + 9
#define IDS_FALSE					IDE_GENERAL_BEGIN + 10
#define IDE_INTRINSIC_OUT_OF_SCOPE  IDE_GENERAL_BEGIN + 11
#define IDE_CANT_MOD_STATICOBJECTS  IDE_GENERAL_BEGIN + 12
#define IDE_TOOBIG					IDE_GENERAL_BEGIN + 13
#define IDS_CACHE_INIT_FAILED       IDE_GENERAL_BEGIN + 14
#define IDS_UNHEALTHY_STATE_STR     IDE_GENERAL_BEGIN + 15
#define IDS_FIRSTHIT_INIT_FAILED_STR 	IDE_GENERAL_BEGIN+16
#define IDS_UNHEALTHY_OOM_STATE_STR IDE_GENERAL_BEGIN + 17
#define IDE_RESPONSE_BUFFER_LIMIT_EXCEEDED  IDE_GENERAL_BEGIN + 18
#define IDS_CACHE_DIR_NAME_TOO_LONG       IDE_GENERAL_BEGIN + 19
#define IDS_CACHE_SUBDIR_CREATION_FAILED  IDE_GENERAL_BEGIN + 20
#define IDS_CACHE_SUBDIR_MISSING          IDE_GENERAL_BEGIN + 21
#define IDS_CACHE_EVENT_NAME_TOO_LONG     IDE_GENERAL_BEGIN + 22
#define IDS_CACHE_CLEANUP_EVENT_FAILED    IDE_GENERAL_BEGIN + 23
#define IDS_DEFAULT_SCRIPTLANGUAGE        IDE_GENERAL_BEGIN + 24
#define IDE_GENERAL_END				IDE_GENERAL_BEGIN + 24

#define IDS_REG_GENERAL_BEGIN		200
#define IDS_DEFAULTMSG_DENIED		IDS_REG_GENERAL_BEGIN + 1
#define IDS_DEFAULTMSG_ERROR		IDS_REG_GENERAL_BEGIN + 2
#define IDS_DEFAULTMSG_BUSY			IDS_REG_GENERAL_BEGIN + 3
#define IDS_SCRIPTLANGUAGE			IDS_REG_GENERAL_BEGIN + 4
#define IDS_IIS_NOTINSTALLED		IDS_REG_GENERAL_BEGIN + 5
#define IDS_DEFAULTPERSISTDIR       IDS_REG_GENERAL_BEGIN + 6
#define IDS_REG_GENERAL_END			IDS_REG_GENERAL_BEGIN + 6

#define IDS_BROWSER_TEMPLATE_BEGIN			300
#define IDS_BROWSER_TEMPLATE_ENGINE_BEGIN	IDS_BROWSER_TEMPLATE_BEGIN + 1
#define IDS_BROWSER_TEMPLATE_ENGINE_END		IDS_BROWSER_TEMPLATE_BEGIN + 2
#define IDS_BROWSER_TEMPLATE_ERROR_BEGIN	IDS_BROWSER_TEMPLATE_BEGIN + 3
#define IDS_BROWSER_TEMPLATE_ERROR_END		IDS_BROWSER_TEMPLATE_BEGIN + 4
#define IDS_BROWSER_TEMPLATE_SHORT_BEGIN	IDS_BROWSER_TEMPLATE_BEGIN + 5
#define IDS_BROWSER_TEMPLATE_SHORT_END		IDS_BROWSER_TEMPLATE_BEGIN + 6
#define IDS_BROWSER_TEMPLATE_FILE_BEGIN		IDS_BROWSER_TEMPLATE_BEGIN + 7
#define IDS_BROWSER_TEMPLATE_FILE_END		IDS_BROWSER_TEMPLATE_BEGIN + 8
#define IDS_BROWSER_TEMPLATE_LINE_BEGIN		IDS_BROWSER_TEMPLATE_BEGIN + 9
#define IDS_BROWSER_TEMPLATE_LINE_END		IDS_BROWSER_TEMPLATE_BEGIN + 10
#define IDS_BROWSER_TEMPLATE_CODE_BEGIN		IDS_BROWSER_TEMPLATE_BEGIN + 11
#define IDS_BROWSER_TEMPLATE_CODE_END		IDS_BROWSER_TEMPLATE_BEGIN + 12
#define IDS_BROWSER_TEMPLATE_LONG_BEGIN		IDS_BROWSER_TEMPLATE_BEGIN + 13
#define IDS_BROWSER_TEMPLATE_LONG_END		IDS_BROWSER_TEMPLATE_BEGIN + 14
#define IDS_BROWSER_TEMPLATE_END			IDS_BROWSER_TEMPLATE_BEGIN + 15

#define IDS_ERROR_HANDLINGSTRING	400
#define IDS_DEBUG_APP				IDS_ERROR_HANDLINGSTRING + 1
#define IDS_LOG_IISLOGFAILED		IDS_ERROR_HANDLINGSTRING + 2
#define	IDS_COMPILER				IDS_ERROR_HANDLINGSTRING + 3
#define IDS_ENGINE					IDS_ERROR_HANDLINGSTRING + 4
#define IDS_LOGTOEVENTLOG_FILE		IDS_ERROR_HANDLINGSTRING + 5
#define	IDS_LOGTOEVENTLOG_LINE		IDS_ERROR_HANDLINGSTRING + 6
#define IDS_MDOORANGE_FORMAT		IDS_ERROR_HANDLINGSTRING + 7
#define IDS_IISLOG_PREFIX			IDS_ERROR_HANDLINGSTRING + 8
#define IDS_RE_REGSVR_ASP			IDS_ERROR_HANDLINGSTRING + 9
#define IDS_SCRIPT_ERROR			IDS_ERROR_HANDLINGSTRING + 10
#define IDS_DEBUGGER_TEMPLATE_BEGIN	IDS_ERROR_HANDLINGSTRING + 11
#define IDS_DEBUGGER_TEMPLATE_END	IDS_ERROR_HANDLINGSTRING + 12
#define IDS_DEBUGGING_DISABLED		IDS_ERROR_HANDLINGSTRING + 13

//Header strings
#define IDH_HEADER_BEGIN			500
#define IDH_204_NO_CONTENT			IDH_HEADER_BEGIN + 1
#define IDH_403_FORBIDDEN           IDH_HEADER_BEGIN + 2
#define IDH_404_OBJECT_NOT_FOUND	IDH_HEADER_BEGIN + 3
#define IDH_500_SERVER_ERROR		IDH_HEADER_BEGIN + 4
#define IDH_401_3_ACCESS_DENIED     IDH_HEADER_BEGIN + 5
#define IDH_HEADER_END				IDH_HEADER_BEGIN + 6

//Encrypted ASP printable file header
#define IDS_EASP_PRINTABLE_HEADER   601

// Errors previously hardcoded in hitobj.h

//
// Script Engine/Manager errors
//
#define IDE_SCRIPT_BEGIN			1000
#define	IDE_SCRIPT_CANT_LOAD_OBJ	IDE_SCRIPT_BEGIN+0
#define	IDE_SCRIPT_GENERIC_PREFIX	IDE_SCRIPT_BEGIN+1
#define	IDE_SCRIPT_LINE_NUMBER		IDE_SCRIPT_BEGIN+2
#define	IDE_SCRIPT_FILE_PATH_INFO	IDE_SCRIPT_BEGIN+3
#define	IDE_SCRIPT_METHOD_NOT_FOUND	IDE_SCRIPT_BEGIN+4
#define	IDE_SCRIPT_UNKNOWN_NAME		IDE_SCRIPT_BEGIN+5
#define	IDE_SCRIPT_UNKNOWN_INTERFACE IDE_SCRIPT_BEGIN+6
#define	IDE_SCRIPT_MISSING_PARAMETER IDE_SCRIPT_BEGIN+7
#define	IDE_SCRIPT_TIMEOUT			IDE_SCRIPT_BEGIN+8
#define IDE_SCRIPT_BAD_SCOPE_MODEL	IDE_SCRIPT_BEGIN+9
#define IDE_SCRIPT_GPF				IDE_SCRIPT_BEGIN+10
#define IDE_SCRIPT_UNKNOWN			IDE_SCRIPT_BEGIN+11
#define IDE_SCRIPT_ENGINE_GPF       IDE_SCRIPT_BEGIN+12
#define IDE_SCRIPT_OBJ_INSTANTIATE_FAILED	IDE_SCRIPT_BEGIN+13
#define IDE_SCRIPT_OBJ_ONPAGE_QI_FAILED		IDE_SCRIPT_BEGIN+14
#define IDE_SCRIPT_END				IDE_SCRIPT_BEGIN+15

//
// CTemplate errors
//
#define IDE_TEMPLATE_BEGIN						2000
#define IDE_TEMPLATE_ERRMSG_TITLE				IDE_TEMPLATE_BEGIN
#define IDE_TEMPLATE_ERRMSG_PREFIX				IDE_TEMPLATE_BEGIN + 1
#define IDE_TEMPLATE_NO_CLOSE_PSCRIPT			IDE_TEMPLATE_BEGIN + 2
#define IDE_TEMPLATE_NO_CLOSE_TSCRIPT			IDE_TEMPLATE_BEGIN + 3
#define IDE_TEMPLATE_NO_CLOSE_OBJECT			IDE_TEMPLATE_BEGIN + 4
#define IDE_TEMPLATE_NO_CLASSID_PROGID			IDE_TEMPLATE_BEGIN + 5
#define IDE_TEMPLATE_RUNAT_NOT_SERVER			IDE_TEMPLATE_BEGIN + 6
#define IDE_TEMPLATE_BAD_PAGE_OBJECT_SCOPE		IDE_TEMPLATE_BEGIN + 7
#define IDE_TEMPLATE_BAD_GLOBAL_OBJECT_SCOPE	IDE_TEMPLATE_BEGIN + 8
#define IDE_TEMPLATE_NO_OBJECT_NAME				IDE_TEMPLATE_BEGIN + 9
#define IDE_TEMPLATE_NO_ENGINE_NAME				IDE_TEMPLATE_BEGIN + 10
#define IDE_TEMPLATE_NO_ATTRIBUTE_DELIMITER		IDE_TEMPLATE_BEGIN + 11
#define IDE_TEMPLATE_BAD_INCLUDE				IDE_TEMPLATE_BEGIN + 12
#define IDE_TEMPLATE_NO_CLOSE_HTML_COMMENT		IDE_TEMPLATE_BEGIN + 13
#define IDE_TEMPLATE_NO_INCLUDE_NAME			IDE_TEMPLATE_BEGIN + 14
#define IDE_TEMPLATE_BAD_PROGLANG				IDE_TEMPLATE_BEGIN + 15
#define IDE_TEMPLATE_BAD_FILE_TAG				IDE_TEMPLATE_BEGIN + 16
#define IDE_TEMPLATE_DISALLOWED_PARENT_PATH		IDE_TEMPLATE_BEGIN + 17
#define IDE_TEMPLATE_ERRMSG_GENERIC				IDE_TEMPLATE_BEGIN + 18
#define IDE_TEMPLATE_BAD_CLASSID				IDE_TEMPLATE_BEGIN + 19
#define IDE_TEMPLATE_BAD_PROGID					IDE_TEMPLATE_BEGIN + 20
#define IDE_TEMPLATE_CYCLIC_INCLUDE				IDE_TEMPLATE_BEGIN + 21
#define IDE_TEMPLATE_INVALID_OBJECT_NAME		IDE_TEMPLATE_BEGIN + 22
#define IDE_TEMPLATE_BAD_GLOBAL_PSCRIPT			IDE_TEMPLATE_BEGIN + 23
#define IDE_TEMPLATE_NESTED_TSCRIPT				IDE_TEMPLATE_BEGIN + 24
#define IDE_TEMPLATE_NESTED_OBJECT				IDE_TEMPLATE_BEGIN + 25
#define IDE_TEMPLATE_PAGE_COMMAND_NOT_FIRST		IDE_TEMPLATE_BEGIN + 26
#define IDE_TEMPLATE_PAGE_COMMAND_REPEATED		IDE_TEMPLATE_BEGIN + 27
#define IDE_TEMPLATE_BAD_PROGLANG_IN_REGISTRY	IDE_TEMPLATE_BEGIN + 28
#define IDE_TEMPLATE_NO_CODEPAGE				IDE_TEMPLATE_BEGIN + 29
#define IDE_TEMPLATE_BAD_CODEPAGE				IDE_TEMPLATE_BEGIN + 30
#define IDE_TEMPLATE_BAD_TRANSACTED_VALUE		IDE_TEMPLATE_BEGIN + 31
#define IDE_TEMPLATE_BAD_SESSION_VALUE		    IDE_TEMPLATE_BEGIN + 32
#define IDE_TEMPLATE_BAD_OBJECT_SCOPE           IDE_TEMPLATE_BEGIN + 33
#define IDE_TEMPLATE_NO_LCID					IDE_TEMPLATE_BEGIN + 34
#define IDE_TEMPLATE_BAD_LCID					IDE_TEMPLATE_BEGIN + 35
#define IDE_TEMPLATE_BAD_AT_COMMAND				IDE_TEMPLATE_BEGIN + 36
#define IDE_TEMPLATE_BAD_TYPELIB_SPEC           IDE_TEMPLATE_BEGIN + 37
#define IDE_TEMPLATE_BAD_TYPELIB_REG_SPEC       IDE_TEMPLATE_BEGIN + 38
#define IDE_TEMPLATE_LOAD_TYPELIB_FAILED        IDE_TEMPLATE_BEGIN + 39
#define IDE_TEMPLATE_WRAP_TYPELIB_FAILED        IDE_TEMPLATE_BEGIN + 40
#define IDE_TEMPLATE_BAD_COOKIE_SPEC			IDE_TEMPLATE_BEGIN + 41
#define IDE_TEMPLATE_LOAD_COOKIESCRIPT_FAILED   IDE_TEMPLATE_BEGIN + 42
#define IDE_TEMPLATE_BAD_SSI_COMMAND			IDE_TEMPLATE_BEGIN + 43
#define IDE_TEMPLATE_BAD_COOKIE_SPEC_SRC        IDE_TEMPLATE_BEGIN + 44
#define IDE_TEMPLATE_BAD_COOKIE_SPEC_NAME       IDE_TEMPLATE_BEGIN + 45
#define IDE_TEMPLATE_VALUE_REQUIRED				IDE_TEMPLATE_BEGIN + 46
#define IDE_TEMPLATE_UNICODE_NOTSUP             IDE_TEMPLATE_BEGIN + 47
#define IDE_TEMPLATE_METADATA_IN_GLOBAL_ASA		IDE_TEMPLATE_BEGIN + 48
#define IDE_TEMPLATE_CANT_ENABLE_SESSIONS	    IDE_TEMPLATE_BEGIN + 49
#define IDE_TEMPLATE_MIXED_CODEPAGE_USAGE       IDE_TEMPLATE_BEGIN + 50
#define IDE_TEMPLATE_END						IDE_TEMPLATE_BEGIN + 50

//
// Executor errors
//
#define IDE_EXECUTOR_BEGIN				3000
#define IDE_204_NO_CONTENT				IDE_EXECUTOR_BEGIN + 1
#define IDE_404_OBJECT_NOT_FOUND		IDE_EXECUTOR_BEGIN + 2
#define IDE_EXECUTOR_DTC_NOT_RUNNING	IDE_EXECUTOR_BEGIN + 3
#define IDE_401_3_ACCESS_DENIED         IDE_EXECUTOR_BEGIN + 4
#define IDE_EXECUTOR_END				IDE_EXECUTOR_BEGIN + 4

//
// Sessmgr errors
//
#define IDE_SESSMGR_BEGIN			4000
#define IDE_ERROR_STRING_403		IDE_SESSMGR_BEGIN
#define IDE_ERROR_SCRIPT_NF			IDE_SESSMGR_BEGIN+1
#define IDE_ERROR_SCRIPT_EMPTY		IDE_SESSMGR_BEGIN+2
#define IDE_OPEN_THREAD_TOKEN		IDE_SESSMGR_BEGIN+3
#define IDE_INVALID_APPLICATION		IDE_SESSMGR_BEGIN+4
#define IDE_INIT_PAGE_LEVEL_OBJ		IDE_SESSMGR_BEGIN+5
#define IDE_ADD_APPLICATION			IDE_SESSMGR_BEGIN+6
#define IDE_ADD_SESSION				IDE_SESSMGR_BEGIN+7
#define IDE_OPEN_APPLN_DIR			IDE_SESSMGR_BEGIN+8
#define IDE_CHANGE_NOTIFICATION		IDE_SESSMGR_BEGIN+9
#define IDE_IMPERSONATE_USER		IDE_SESSMGR_BEGIN+10
#define IDE_500_SERVER_ERROR		IDE_SESSMGR_BEGIN+11
#define IDE_SERVER_TOO_BUSY			IDE_SESSMGR_BEGIN+12
#define	IDE_SERVER_SHUTTING_DOWN	IDE_SESSMGR_BEGIN+13
#define IDE_GLOBAL_ASA_CHANGED		IDE_SESSMGR_BEGIN+14
#define IDE_GLOBAL_ASA_FORBIDDEN    IDE_SESSMGR_BEGIN+15
#define IDE_TOO_MANY_USERS			IDE_SESSMGR_BEGIN+16
#define IDE_BAD_CODEPAGE_IN_MB		IDE_SESSMGR_BEGIN+17
#define IDE_SESSMGR_END				IDE_SESSMGR_BEGIN+17

//
// Threadmgr errors
//
#define IDE_THREADMGR_BEGIN			5000
#define IDE_CANT_CREATE_THREAD		IDE_THREADMGR_BEGIN
#define IDE_THREADMGR_END			IDE_CANT_CREATE_THREAD

//
// Intrinsic errors
//
#define IDE_INTRINSIC_BEGIN						6000
#define IDE_RESPONSE_BEGIN						IDE_INTRINSIC_BEGIN
#define IDE_RESPONSE							IDE_RESPONSE_BEGIN
#define IDE_RESPONSE_HEADERS_CANT_REACH_CLIENT	IDE_RESPONSE_BEGIN + 1
#define IDE_RESPONSE_BODY_CANT_REACH_CLIENT		IDE_RESPONSE_BEGIN + 2
#define IDE_RESPONSE_HEADERS_WRITTEN			IDE_RESPONSE_BEGIN + 3
#define IDE_RESPONSE_CANT_STOP_BUFFER			IDE_RESPONSE_BEGIN + 4
#define IDE_RESPONSE_NO_URL						IDE_RESPONSE_BEGIN + 5
#define IDE_RESPONSE_BUFFER_NOT_ON				IDE_RESPONSE_BEGIN + 6
#define IDE_RESPONSE_LOG_FAILURE				IDE_RESPONSE_BEGIN + 7
#define IDE_RESPONSE_REDIRECT1					IDE_RESPONSE_BEGIN + 8
#define IDE_RESPONSE_REDIRECT2					IDE_RESPONSE_BEGIN + 9
#define IDE_RESPONSE_UNABLE_TO_CONVERT			IDE_RESPONSE_BEGIN + 10
#define IDE_RESPONSE_MODIFY_SESS_COOKIE			IDE_RESPONSE_BEGIN + 11
#define IDE_RESPONSE_COMMAS_NOT_ALLOWED			IDE_RESPONSE_BEGIN + 12
#define IDE_RESPONSE_CLEAR_AFTER_FLUSH_IN_DEBUG	IDE_RESPONSE_BEGIN + 13
#define IDE_RESPONSE_NOT_IMPLEMENTED			IDE_RESPONSE_BEGIN + 14
#define IDE_RESPONSE_END						IDE_RESPONSE_BEGIN + 14

#define IDE_SESSION								6100
#define IDE_SESSION_ID							IDE_SESSION + 1
#define IDE_SESSION_INVALID_TIMEOUT				IDE_SESSION + 2
#define IDE_SESSION_MAP_FAILED					IDE_SESSION + 3
#define IDE_SESSION_UNINITIALIZED_OBJ   		IDE_SESSION + 4
#define IDE_SESSION_INIT_FAIL					IDE_SESSION + 5
#define IDE_SESSION_END							IDE_SESSION + 6
#define IDE_SESSION_CANT_STORE_INTRINSIC		IDE_SESSION + 7
#define IDE_SESSION_CANT_STORE_NO_MODEL			IDE_SESSION + 8
#define IDE_SESSION_COULD_NOT_DELETE			IDE_SESSION + 9
#define	IDE_SESSION_CANT_STORE_TAG_OBJECT		IDE_SESSION + 10
#define	IDE_CANT_STORE_JAVASCRIPT_OBJECT		IDE_SESSION + 11
#define IDE_SESSION_INVALID_CODEPAGE			IDE_SESSION + 12

#define IDE_SERVER								6200
#define IDE_SERVER_MAPPATH						IDE_SERVER + 1
#define IDE_SERVER_MAPPATH_INVALID_STR			IDE_SERVER + 2
#define IDE_SERVER_MAPPATH_PHY_STR				IDE_SERVER + 3
#define IDE_SERVER_MAPPATH_INVALID_CHR			IDE_SERVER + 4
#define IDE_SERVER_MAPPATH_INVALID_CHR2			IDE_SERVER + 5
#define IDE_SERVER_MAPPATH_INVALID_CHR3			IDE_SERVER + 6
#define IDE_SERVER_MAPPATH_FAILED				IDE_SERVER + 7
#define IDE_SERVER_INVALID_CALL					IDE_SERVER + 8
#define IDE_SERVER_CREATEOBJ_FAILED				IDE_SERVER + 9
#define IDE_SERVER_CREATEOBJ_DENIED				IDE_SERVER + 10
#define IDE_SERVER_CREATEOBJ_NOTINPROC			IDE_SERVER + 11
#define IDE_SERVER_INVALID_TIMEOUT				IDE_SERVER + 12
#define IDE_SERVER_EXCEDED_MAX_PATH				IDE_SERVER + 13
#define IDE_SERVER_EXECUTE_FAILED				IDE_SERVER + 14
#define IDE_SERVER_EXECUTE_CANTLOAD				IDE_SERVER + 15
#define IDE_SERVER_EXECUTE_INVALID_PATH			IDE_SERVER + 16
#define IDE_SERVER_TRANSFER_FAILED				IDE_SERVER + 17
#define IDE_SERVER_TRANSFER_CANTLOAD			IDE_SERVER + 18
#define IDE_SERVER_TRANSFER_INVALID_PATH		IDE_SERVER + 19


#define IDE_APPLICATION							6300
#define IDE_APPLICATION_FAILED_INIT				IDE_APPLICATION + 1
#define IDE_APPLICATION_CANT_STORE_INTRINSIC 	IDE_APPLICATION + 2
#define IDE_APPLICATION_CANT_STORE_APT_MODEL	IDE_APPLICATION + 3
#define IDE_APPLICATION_CANT_STORE_NO_MODEL		IDE_APPLICATION + 4
#define	IDE_APPLICATION_CANT_STORE_TAG_OBJECT	IDE_APPLICATION + 5
#define IDE_APPLICATION_LOCKED_CANT_STORE_OBJ		IDE_APPLICATION + 7
#define IDE_APPLICATION_CANT_STORE_OBJECT		IDE_APPLICATION + 8
#define IDE_APPLICATION_CREATE_EVENT_FAILED		IDE_APPLICATION + 9

#define IDE_COOKIE								6400
#define IDE_COOKIE_EMPTY_DICT					IDE_COOKIE + 1
#define IDE_COOKIE_NO_NAME						IDE_COOKIE + 2
#define IDE_COOKIE_BAD_EXPIRATION				IDE_COOKIE + 3

#define IDE_REQUEST								6500
#define IDE_REQUEST_BINARYREAD_NA				IDE_REQUEST + 1
#define IDE_REQUEST_FORMCOLLECTION_NA			IDE_REQUEST + 2
#define IDE_REQUEST_GENERICCOLLECTION_NA		IDE_REQUEST + 3
#define IDE_REQUEST_STREAMONLY   				IDE_REQUEST + 4
#define IDE_REQUEST_BINREAD_BAD_ARG				IDE_REQUEST + 5

#define	IDE_COVER								6700
#define IDE_COVER_DISP_RELEASE_GPF			IDE_COVER + 1
#define IDE_COVER_ON_START_PAGE_GPF			IDE_COVER + 2
#define IDE_COVER_ON_END_PAGE_GPF			IDE_COVER + 3
#define IDE_COVER_ON_START_PAGE_FAILED		IDE_COVER + 4
#define IDE_COVER_ON_END_PAGE_FAILED		IDE_COVER + 5
	
#define IDE_CERTIFICATE					6800
#define IDE_CERTIFICATE_BAD_CERT        6801

#define IDE_OBJECTCONTEXT					6850
#define IDE_OBJECTCONTEXT_NOT_TRANSACTED	6851

#define IDE_INTRINSIC_END				IDE_CERTIFICATE_BAD_CERT

//
// Cachemgr errors
//
#define IDE_CACHEMGR_BEGIN			7000
#define IDE_CACHEMGR_END			IDE_CACHEMGR_BEGIN

//
// NT event log errors and warnings
//
#define IDE_EVENT_BEGIN				8000
#define IDE_EVENT_END				IDE_EVENT_BEGIN + 1

//
// Errors that utility functions detect
//
#define IDE_UTIL_BEGIN				9000
#define IDE_UTIL_NO_VALUE			IDE_UTIL_BEGIN

#define IDE_END						IDE_UTIL_NO_VALUE
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\iisplus\webbench\wbisapi.cxx ===
/*++

Copyright (c) 2002  Microsoft Corporation

Module Name:

    wbisapi.cxx

Abstract:

    Implements a fast WebBench ISAPI

Author:

    Bilal Alam (balam)                  Sept 3, 2002

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <httpext.h>
#include <string.hxx>

CHAR *                  g_pszStaticHeader;
DWORD                   g_cbStaticHeader;

DWORD
WINAPI
HttpExtensionProc(
    EXTENSION_CONTROL_BLOCK *           pecb
)
/*++

Routine Description:

    Main entry point for ISAPI

Arguments:

    pecb - EXTENSION_CONTROL_BLOCK *

Return Value:

    HSE_STATUS_*

--*/
{
    CHAR                    achDynamic[ 4096 ];
    STRA                    strDynamic( achDynamic, sizeof( achDynamic ) );
    HRESULT                 hr;
    BOOL                    fRet;
    CHAR                    achBuffer[ 512 ];
    DWORD                   cbBuffer;
    HSE_RESPONSE_VECTOR     responseVector;
    HSE_VECTOR_ELEMENT      vectorElement[ 2 ];
    
    //
    // Generate dynamic portion
    //
    
    hr = strDynamic.Append( "SERVER_NAME = <B>" );
    if ( FAILED( hr ) )
    {
        goto Failure;
    }
    
    cbBuffer = sizeof( achBuffer );
    fRet = pecb->GetServerVariable( pecb->ConnID,
                                    "SERVER_NAME",
                                    achBuffer,
                                    &cbBuffer );
    if ( !fRet )
    {
        hr = HRESULT_FROM_WIN32( GetLastError() );
        goto Failure;
    }
    
    hr = strDynamic.Append( achBuffer );
    if ( FAILED( hr ) )
    {
        goto Failure;
    }
    
    hr = strDynamic.Append( "</B>\nGATEWAY_INTERFACE = <B>CGI/1.1</B>\nSERVER_PROTOCOL = <B>" );
    if ( FAILED( hr ) )
    {
        goto Failure;
    }
    
    cbBuffer = sizeof( achBuffer );
    fRet = pecb->GetServerVariable( pecb->ConnID,
                                    "SERVER_PROTOCOL",
                                    achBuffer,
                                    &cbBuffer );
    if ( !fRet )
    {
        hr = HRESULT_FROM_WIN32( GetLastError() );
        goto Failure;
    }
    
    hr = strDynamic.Append( achBuffer );
    if ( FAILED( hr ) )
    {
        goto Failure;
    }
    
    hr = strDynamic.Append( "</B>\nSERVER_PORT = <B>80</B>\nREQUEST_METHOD = <B>" );
    if ( FAILED( hr ) )
    {
        goto Failure;
    }
    
    hr = strDynamic.Append( pecb->lpszMethod );
    if ( FAILED( hr ) )
    {
        goto Failure;
    }
    
    hr = strDynamic.Append( "</B>\nHTTP_ACCEPT = <B>" );
    if ( FAILED( hr ) )
    {
        goto Failure;
    }
    
    cbBuffer = sizeof( achBuffer );
    fRet = pecb->GetServerVariable( pecb->ConnID,
                                    "HTTP_ACCEPT",
                                    achBuffer,
                                    &cbBuffer );
    if ( !fRet )
    {
        achBuffer[ 0 ] = '\0';
    }
    
    hr = strDynamic.Append( achBuffer );
    if ( FAILED( hr ) )
    {
        goto Failure;
    }
    
    hr = strDynamic.Append( "</B>\nHTTP_USER_AGENT = <B>" );
    if ( FAILED( hr ) )
    {
        goto Failure;
    }
    
    cbBuffer = sizeof( achBuffer );
    fRet = pecb->GetServerVariable( pecb->ConnID,
                                    "HTTP_USER_AGENT",
                                    achBuffer,
                                    &cbBuffer );
    if ( !fRet )
    {
        achBuffer[ 0 ] = '\0';
    } 
    
    hr = strDynamic.Append( achBuffer );
    if ( FAILED( hr ) )
    {
        goto Failure;
    }
    
    hr = strDynamic.Append( "</B>\nHTTP_REFERER = <B>" );
    if ( FAILED( hr ) )
    {
        goto Failure;
    }
    
    cbBuffer = sizeof( achBuffer );
    fRet = pecb->GetServerVariable( pecb->ConnID,
                                    "HTTP_REFERER",
                                    achBuffer,
                                    &cbBuffer );
    if ( !fRet )
    {
        achBuffer[ 0 ] = '\0';
    } 
    
    hr = strDynamic.Append( achBuffer );
    if ( FAILED( hr ) )
    {
        goto Failure;
    }
    
    hr = strDynamic.Append( "</B>\nPATH_INFO = <B>" );
    if ( FAILED( hr ) )
    {
        goto Failure;
    }
    
    hr = strDynamic.Append( pecb->lpszPathInfo );
    if ( FAILED( hr ) )
    {
        goto Failure;
    }
    
    hr = strDynamic.Append( "</B>\nPATH_TRANSLATED = <B>" );
    if ( FAILED( hr ) )
    {
        goto Failure;
    }
    
    hr = strDynamic.Append( pecb->lpszPathTranslated );
    if ( FAILED( hr ) )
    {
        goto Failure;
    }
    
    hr = strDynamic.Append( "</B>\nSCRIPT_NAME = <B>" );
    if ( FAILED( hr ) )
    {
        goto Failure;
    }
    
    cbBuffer = sizeof( achBuffer );
    fRet = pecb->GetServerVariable( pecb->ConnID,
                                    "SCRIPT_NAME",
                                    achBuffer,
                                    &cbBuffer );
    if ( !fRet )
    {
        hr = HRESULT_FROM_WIN32( GetLastError() );
        goto Failure;
    } 
    
    hr = strDynamic.Append( achBuffer );
    if ( FAILED( hr ) )
    {
        goto Failure;
    }
    
    hr = strDynamic.Append( "</B>\nQUERY_STRING = <B>" );
    if ( FAILED( hr ) ) 
    {
        goto Failure;
    }
    
    hr = strDynamic.Append( pecb->lpszQueryString );
    if ( FAILED( hr ) )
    {
        goto Failure;
    }
    
    hr = strDynamic.Append( "</B>\nREMOTE_HOST = <B>" );
    if ( FAILED( hr ) )
    {
        goto Failure;
    }
    
    cbBuffer = sizeof( achBuffer );
    fRet = pecb->GetServerVariable( pecb->ConnID,
                                    "REMOTE_HOST",
                                    achBuffer,
                                    &cbBuffer );
    if ( !fRet )
    {
        hr = HRESULT_FROM_WIN32( GetLastError() );
        goto Failure;
    } 
    
    hr = strDynamic.Append( achBuffer );
    if ( FAILED( hr ) )
    {
        goto Failure;
    }
    
    hr = strDynamic.Append( "</B>\nREMOTE_ADDR = <B>" );
    if ( FAILED( hr ) )
    {
        goto Failure;
    }
    
    hr = strDynamic.Append( achBuffer );
    if ( FAILED( hr ) )
    {
        goto Failure;
    }
    
    hr = strDynamic.Append( "</B>\nREMOTE_USER = <B></B>\nAUTH_TYPE = <B></B>\nCONTENT_TYPE = <B>" );
    if ( FAILED( hr ) )
    {
        goto Failure;
    }
    
    hr = strDynamic.Append( pecb->lpszContentType );
    if ( FAILED( hr ) )
    {
        goto Failure;
    }
    
    hr = strDynamic.Append( "</B>\nCONTENT_LENGTH = <B>" );
    if ( FAILED( hr ) )
    {
        goto Failure;
    }
    
    cbBuffer = sizeof( achBuffer );
    fRet = pecb->GetServerVariable( pecb->ConnID,
                                    "CONTENT_LENGTH",
                                    achBuffer,
                                    &cbBuffer );
    if ( !fRet )
    {
        hr = HRESULT_FROM_WIN32( GetLastError() );
        goto Failure;
    } 
    
    hr = strDynamic.Append( achBuffer );
    if ( FAILED( hr ) )
    {
        goto Failure;
    }
    
    hr = strDynamic.Append( "</B>\nANNOTATION_SERVER = <B></B>\n\n</pre></BODY></HTML>" );
    if ( FAILED( hr ) )
    {
        goto Failure;
    }
    
    //
    // Phew.  Now that dynamic portion is done, send out response
    //
    
    vectorElement[ 0 ].ElementType = HSE_VECTOR_ELEMENT_TYPE_MEMORY_BUFFER;
    vectorElement[ 0 ].pvContext = g_pszStaticHeader;
    vectorElement[ 0 ].cbSize = g_cbStaticHeader;

    vectorElement[ 1 ].ElementType = HSE_VECTOR_ELEMENT_TYPE_MEMORY_BUFFER;
    vectorElement[ 1 ].pvContext = strDynamic.QueryStr();
    vectorElement[ 1 ].cbSize = strDynamic.QueryCB();

    responseVector.lpElementArray = vectorElement;
    responseVector.nElementCount = 2;
    
    responseVector.dwFlags = HSE_IO_FINAL_SEND | HSE_IO_SYNC | HSE_IO_DISCONNECT_AFTER_SEND;
    responseVector.pszStatus = NULL;
    responseVector.pszHeaders = NULL;

    //
    // Let'r rip
    // 
    
    fRet = pecb->ServerSupportFunction( pecb->ConnID,
                                        HSE_REQ_VECTOR_SEND,
                                        &responseVector,
                                        NULL,
                                        NULL );
    if ( !fRet )
    {
        return HSE_STATUS_ERROR;
    }
    else
    {
        return HSE_STATUS_SUCCESS;
    }
    
Failure:
    SetLastError( hr );
    return HSE_STATUS_ERROR;
}

BOOL
WINAPI
GetExtensionVersion(
    HSE_VERSION_INFO *             pver
)
/*++

Routine Description:

    Initialization routine for ISAPI

Arguments:

    pver - Version information

Return Value:

    TRUE if successful, else FALSE

--*/
{
    //
    // Do ISAPI interface init crap
    //
    
    pver->dwExtensionVersion = MAKELONG( 0, 1 );

    strcpy( pver->lpszExtensionDesc,
            "WebBench ISAPI" );
        
    //
    // Setup static header
    //
    
    g_pszStaticHeader = "HTTP/1.1 200 OK\r\n" \
                        "Content-type: text/html\r\n\r\n" \
                        "<HTML><HEAD><TITLE>WebBench 2.0 HTTP API Application</TITLE></HEAD><BODY>\n" \
                        "<pre>SERVER_SOFTWARE = <B>Microsoft-IIS/6.0</B>\n";
    g_cbStaticHeader = (DWORD) strlen( g_pszStaticHeader );

    return TRUE;
}

BOOL
WINAPI
TerminateExtension(
    DWORD             
)
/*++

Routine Description:

    Cleanup ISAPI extension

Arguments:

    None

Return Value:

    TRUE if successful, else FALSE

--*/
{
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\img\common\makefile.inc ===
CDROOT=$(_NTTREE)\inetsrv
SymbolsROOT=$(_NTTREE)\symbols\inetsrv\dll

copyfile:
!ifdef _NTTREE
        # using binplace causes this to happen automatically
	#if not exist "$(CDROOT)" mkdir $(CDROOT)
	#if not exist "$(SymbolsROOT)" mkdir $(SymbolsROOT)

#       copy wwwroot
        binplace -e -R %_NTTREE%\inetsrv -:DEST wwwroot\nts_ntw ..\wwwroot\nts_ntw\*

#       copy Admin UI replacement page
        binplace -e -R %_NTTREE%\inetsrv -:DEST wwwroot\adminui ..\wwwroot\adminui\*

#       copy admin samples stuff
	perl -S xcopy2binplace.pl /verifdy ..\admsamp          $(CDROOT)\admsamp

#       copy cluster stuff over
	perl -S xcopy2binplace.pl /verifdy ..\cluster          $(CDROOT)\cluster

#       copy custom error stuff over
	perl -S xcopy2binplace.pl /verifd ..\custerr $(CDROOT)\custerr

	perl -S xcopy2binplace.pl /verifdy ..\help\iisnts\winhelp $(CDROOT)\help\ismhelp
	perl -S xcopy2binplace.pl /verifdy ..\help\iisntw\winhelp $(CDROOT)\help\ismhelp_wks

#	copy sdk stuff
#	perl -S xcopy2binplace.pl /verifdy ..\sdksamp     $(CDROOT)\iissamp\sdk

!endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\inc\wpcounters.h ===
/*++

Copyright (c) 1998-2000 Microsoft Corporation

Module Name:

    wpcounters.h

Abstract:

    Module: Definition of counters

Author:

    Emily B. Kruglick (emilyk)    Aug-17-2000

Revision History:

--*/

#ifndef _WPCOUNTERS_H_
#define _WPCOUNTERS_H_


//
// This structure is used by WAS and the WP to communicate
// the global counters.
//
// If you change this structure you must change the associated enum (below) and
// the array found in ctrstshr.cxx.
//
struct IISWPGlobalCounters
{
    ULONGLONG CurrentFileCacheMemoryUsage;
    ULONGLONG MaxFileCacheMemoryUsage;
    DWORD CurrentFilesCached;
    DWORD TotalFilesCached;
    DWORD FileCacheHits;
    DWORD FileCacheMisses;
    DWORD FileCacheFlushes;
    DWORD ActiveFlushedFiles;
    DWORD TotalFlushedFiles;
    DWORD CurrentUrisCached;
    DWORD TotalUrisCached;
    DWORD UriCacheHits;
    DWORD UriCacheMisses;
    DWORD UriCacheFlushes;
    DWORD TotalFlushedUris;
    DWORD CurrentBlobsCached;
    DWORD TotalBlobsCached;
    DWORD BlobCacheHits;
    DWORD BlobCacheMisses;
    DWORD BlobCacheFlushes;
    DWORD TotalFlushedBlobs;
};

//
// Used by the WP to lookup counter definitions in the array below.
//
// If you change this enum you must change the associated struct (above) and
// the array found in ctrstshr.cxx.
//
typedef enum _IIS_WP_GLOBAL_COUNTERS_ENUM
{
    WPGlobalCtrsCurrentFileCacheMemoryUsage = 0,
    WPGlobalCtrsMaxFileCacheMemoryUsage,
    WPGlobalCtrsCurrentFilesCached,
    WPGlobalCtrsTotalFilesCached,
    WPGlobalCtrsFileCacheHits,
    WPGlobalCtrsFileCacheMisses,
    WPGlobalCtrsFileCacheFlushes,
    WPGlobalCtrsActiveFlushedFiles,
    WPGlobalCtrsTotalFlushedFiles,
    WPGlobalCtrsCurrentUrisCached,
    WPGlobalCtrsTotalUrisCached,
    WPGlobalCtrsUriCacheHits,
    WPGlobalCtrsUriCacheMisses,
    WPGlobalCtrsUriCacheFlushes,
    WPGlobalCtrsTotalFlushedUris,
    WPGlobalCtrsCurrentBlobsCached,
    WPGlobalCtrsTotalBlobsCached,
    WPGlobalCtrsBlobCacheHits,
    WPGlobalCtrsBlobCacheMisses,
    WPGlobalCtrsBlobCacheFlushes,
    WPGlobalCtrsTotalFlushedBlobs,

    WPGlobalCtrsMaximum
} IIS_WP_GLOBAL_COUNTERS_ENUM;

//
// Used to transfer site counter information from WP to WAS
//
// If you change this structure you must change the associated enum (below) and
// the array found in ctrstshr.cxx.
//
struct IISWPSiteCounters
{
    DWORD SiteID;
    DWORD FilesSent;
    DWORD FilesReceived;
    DWORD FilesTransferred;
    DWORD CurrentAnonUsers;
    DWORD CurrentNonAnonUsers;
    DWORD AnonUsers;
    DWORD NonAnonUsers;
    DWORD MaxAnonUsers;
    DWORD MaxNonAnonUsers;
    DWORD LogonAttempts;
    DWORD GetReqs;
    DWORD OptionsReqs;
    DWORD PostReqs;
    DWORD HeadReqs;
    DWORD PutReqs;
    DWORD DeleteReqs;
    DWORD TraceReqs;
    DWORD MoveReqs;
    DWORD CopyReqs;
    DWORD MkcolReqs;
    DWORD PropfindReqs;
    DWORD ProppatchReqs;
    DWORD SearchReqs;
    DWORD LockReqs;
    DWORD UnlockReqs;
    DWORD OtherReqs;
    DWORD CurrentCgiReqs;
    DWORD CgiReqs;
    DWORD MaxCgiReqs;
    DWORD CurrentIsapiExtReqs;
    DWORD IsapiExtReqs;
    DWORD MaxIsapiExtReqs;
    DWORD NotFoundErrors;
    DWORD LockedErrors;

};

//
// Used by WP to lookup counter definitions in the array below.
//
// If you change this enum you must change the associated struct (above) and
// the array found in ctrstshr.cxx.
//
typedef enum _IIS_WP_SITE_COUNTERS_ENUM
{
    WPSiteCtrsFilesSent = 0,
    WPSiteCtrsFilesReceived,
    WPSiteCtrsFilesTransferred,
    WPSiteCtrsCurrentAnonUsers,
    WPSiteCtrsCurrentNonAnonUsers,
    WPSiteCtrsAnonUsers,
    WPSiteCtrsNonAnonUsers,
    WPSiteCtrsMaxAnonUsers,
    WPSiteCtrsMaxNonAnonUsers,
    WPSiteCtrsLogonAttempts,
    WPSiteCtrsGetReqs,
    WPSiteCtrsOptionsReqs,
    WPSiteCtrsPostReqs,
    WPSiteCtrsHeadReqs,
    WPSiteCtrsPutReqs,
    WPSiteCtrsDeleteReqs,
    WPSiteCtrsTraceReqs,
    WPSiteCtrsMoveReqs,
    WPSiteCtrsCopyReqs,
    WPSiteCtrsMkcolReqs,
    WPSiteCtrsPropfindReqs,
    WPSiteCtrsProppatchReqs,
    WPSiteCtrsSearchReqs,
    WPSiteCtrsLockReqs,
    WPSiteCtrsUnlockReqs,
    WPSiteCtrsOtherReqs,
    WPSiteCtrsCurrentCgiReqs,
    WPSiteCtrsCgiReqs,
    WPSiteCtrsMaxCgiReqs,
    WPSiteCtrsCurrentIsapiExtReqs,
    WPSiteCtrsIsapiExtReqs,
    WPSiteCtrsMaxIsapiExtReqs,
    WPSiteCtrsNotFoundErrors,
    WPSiteCtrsLockedErrors,

    WPSiteCtrsMaximum
} IIS_WP_SITE_COUNTERS_ENUM;


//
// Arrays are found in ctrshstr.cxx.
// Used by WAS and WP.
//
#ifdef __cplusplus
extern "C" {
#endif  // __cplusplus

extern HTTP_PROP_DESC aIISWPSiteDescription[];
extern HTTP_PROP_DESC aIISWPGlobalDescription[];
extern HTTP_PROP_DESC aIISULSiteDescription[];
extern HTTP_PROP_DESC aIISULGlobalDescription[];

#ifdef __cplusplus
}   // extern "C"
#endif  // __cplusplus

#endif // _WPCOUNTERS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\inc\comrepl.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


/* File created by MIDL compiler version 5.01.0158 */
/* at Wed Jan 27 09:33:39 1999
 */
/* Compiler settings for comrepl.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32, ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 440
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __comrepl_h__
#define __comrepl_h__

#ifdef __cplusplus
extern "C"{
#endif 

/* Forward Declarations */ 

#ifndef __ICOMReplicateCatalog_FWD_DEFINED__
#define __ICOMReplicateCatalog_FWD_DEFINED__
typedef interface ICOMReplicateCatalog ICOMReplicateCatalog;
#endif  /* __ICOMReplicateCatalog_FWD_DEFINED__ */


#ifndef __ICOMReplicate_FWD_DEFINED__
#define __ICOMReplicate_FWD_DEFINED__
typedef interface ICOMReplicate ICOMReplicate;
#endif  /* __ICOMReplicate_FWD_DEFINED__ */


#ifndef __ReplicateCatalog_FWD_DEFINED__
#define __ReplicateCatalog_FWD_DEFINED__

#ifdef __cplusplus
typedef class ReplicateCatalog ReplicateCatalog;
#else
typedef struct ReplicateCatalog ReplicateCatalog;
#endif /* __cplusplus */

#endif  /* __ReplicateCatalog_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "ocidl.h"
#include "mtxrepl.h"

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

#ifndef __ICOMReplicateCatalog_INTERFACE_DEFINED__
#define __ICOMReplicateCatalog_INTERFACE_DEFINED__

/* interface ICOMReplicateCatalog */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_ICOMReplicateCatalog;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("98315904-7BE5-11d2-ADC1-00A02463D6E7")
    ICOMReplicateCatalog : public IDispatch
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Initialize( 
            /* [in] */ LONG lOptions) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ExportSourceCatalogFiles( 
            /* [in] */ BSTR bstrSourceComputer) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE CopyCatalogFilesToTarget( 
            /* [in] */ BSTR bstrTargetComputer) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE InstallCatalogOnTarget( 
            /* [in] */ BSTR bstrTargetComputer) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE CleanupSource( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetLogFilePath( 
            /* [out] */ BSTR __RPC_FAR *pbstrLogFile) = 0;
        
    };
    
#else   /* C style interface */

    typedef struct ICOMReplicateCatalogVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ICOMReplicateCatalog __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ICOMReplicateCatalog __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ICOMReplicateCatalog __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            ICOMReplicateCatalog __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            ICOMReplicateCatalog __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            ICOMReplicateCatalog __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            ICOMReplicateCatalog __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Initialize )( 
            ICOMReplicateCatalog __RPC_FAR * This,
            /* [in] */ LONG lOptions);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ExportSourceCatalogFiles )( 
            ICOMReplicateCatalog __RPC_FAR * This,
            /* [in] */ BSTR bstrSourceComputer);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CopyCatalogFilesToTarget )( 
            ICOMReplicateCatalog __RPC_FAR * This,
            /* [in] */ BSTR bstrTargetComputer);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *InstallCatalogOnTarget )( 
            ICOMReplicateCatalog __RPC_FAR * This,
            /* [in] */ BSTR bstrTargetComputer);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CleanupSource )( 
            ICOMReplicateCatalog __RPC_FAR * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetLogFilePath )( 
            ICOMReplicateCatalog __RPC_FAR * This,
            /* [out] */ BSTR __RPC_FAR *pbstrLogFile);
        
        END_INTERFACE
    } ICOMReplicateCatalogVtbl;

    interface ICOMReplicateCatalog
    {
        CONST_VTBL struct ICOMReplicateCatalogVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICOMReplicateCatalog_QueryInterface(This,riid,ppvObject)        \
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICOMReplicateCatalog_AddRef(This)       \
    (This)->lpVtbl -> AddRef(This)

#define ICOMReplicateCatalog_Release(This)      \
    (This)->lpVtbl -> Release(This)


#define ICOMReplicateCatalog_GetTypeInfoCount(This,pctinfo)     \
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ICOMReplicateCatalog_GetTypeInfo(This,iTInfo,lcid,ppTInfo)      \
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define ICOMReplicateCatalog_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)    \
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define ICOMReplicateCatalog_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)      \
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define ICOMReplicateCatalog_Initialize(This,lOptions)  \
    (This)->lpVtbl -> Initialize(This,lOptions)

#define ICOMReplicateCatalog_ExportSourceCatalogFiles(This,bstrSourceComputer)  \
    (This)->lpVtbl -> ExportSourceCatalogFiles(This,bstrSourceComputer)

#define ICOMReplicateCatalog_CopyCatalogFilesToTarget(This,bstrTargetComputer)  \
    (This)->lpVtbl -> CopyCatalogFilesToTarget(This,bstrTargetComputer)

#define ICOMReplicateCatalog_InstallCatalogOnTarget(This,bstrTargetComputer)    \
    (This)->lpVtbl -> InstallCatalogOnTarget(This,bstrTargetComputer)

#define ICOMReplicateCatalog_CleanupSource(This)        \
    (This)->lpVtbl -> CleanupSource(This)

#define ICOMReplicateCatalog_GetLogFilePath(This,pbstrLogFile)  \
    (This)->lpVtbl -> GetLogFilePath(This,pbstrLogFile)

#endif /* COBJMACROS */


#endif  /* C style interface */



/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ICOMReplicateCatalog_Initialize_Proxy( 
    ICOMReplicateCatalog __RPC_FAR * This,
    /* [in] */ LONG lOptions);


void __RPC_STUB ICOMReplicateCatalog_Initialize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ICOMReplicateCatalog_ExportSourceCatalogFiles_Proxy( 
    ICOMReplicateCatalog __RPC_FAR * This,
    /* [in] */ BSTR bstrSourceComputer);


void __RPC_STUB ICOMReplicateCatalog_ExportSourceCatalogFiles_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ICOMReplicateCatalog_CopyCatalogFilesToTarget_Proxy( 
    ICOMReplicateCatalog __RPC_FAR * This,
    /* [in] */ BSTR bstrTargetComputer);


void __RPC_STUB ICOMReplicateCatalog_CopyCatalogFilesToTarget_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ICOMReplicateCatalog_InstallCatalogOnTarget_Proxy( 
    ICOMReplicateCatalog __RPC_FAR * This,
    /* [in] */ BSTR bstrTargetComputer);


void __RPC_STUB ICOMReplicateCatalog_InstallCatalogOnTarget_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ICOMReplicateCatalog_CleanupSource_Proxy( 
    ICOMReplicateCatalog __RPC_FAR * This);


void __RPC_STUB ICOMReplicateCatalog_CleanupSource_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ICOMReplicateCatalog_GetLogFilePath_Proxy( 
    ICOMReplicateCatalog __RPC_FAR * This,
    /* [out] */ BSTR __RPC_FAR *pbstrLogFile);


void __RPC_STUB ICOMReplicateCatalog_GetLogFilePath_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif  /* __ICOMReplicateCatalog_INTERFACE_DEFINED__ */


#ifndef __ICOMReplicate_INTERFACE_DEFINED__
#define __ICOMReplicate_INTERFACE_DEFINED__

/* interface ICOMReplicate */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_ICOMReplicate;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("52F25063-A5F1-11d2-AE04-00A02463D6E7")
    ICOMReplicate : public IDispatch
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Initialize( 
            /* [in] */ BSTR bstrSourceComputer,
            /* [in] */ LONG lOptions) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ExportSourceCatalogFiles( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetTargetStatus( 
            /* [in] */ BSTR bstrTargetComputer,
            /* [out] */ LONG __RPC_FAR *plStatus,
            /* [out] */ BSTR __RPC_FAR *pbstrMaster) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE CopyFilesToTarget( 
            /* [in] */ BSTR bstrTargetComputer) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE InstallTarget( 
            /* [in] */ BSTR bstrTargetComputer) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE CleanupSourceShares( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetLogFile( 
            /* [out] */ BSTR __RPC_FAR *pbstrLogFile) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE RollbackTarget( 
            /* [in] */ BSTR bstrTargetComputer) = 0;
        
    };
    
#else   /* C style interface */

    typedef struct ICOMReplicateVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ICOMReplicate __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ICOMReplicate __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ICOMReplicate __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            ICOMReplicate __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            ICOMReplicate __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            ICOMReplicate __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            ICOMReplicate __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Initialize )( 
            ICOMReplicate __RPC_FAR * This,
            /* [in] */ BSTR bstrSourceComputer,
            /* [in] */ LONG lOptions);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ExportSourceCatalogFiles )( 
            ICOMReplicate __RPC_FAR * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTargetStatus )( 
            ICOMReplicate __RPC_FAR * This,
            /* [in] */ BSTR bstrTargetComputer,
            /* [out] */ LONG __RPC_FAR *plStatus,
            /* [out] */ BSTR __RPC_FAR *pbstrMaster);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CopyFilesToTarget )( 
            ICOMReplicate __RPC_FAR * This,
            /* [in] */ BSTR bstrTargetComputer);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *InstallTarget )( 
            ICOMReplicate __RPC_FAR * This,
            /* [in] */ BSTR bstrTargetComputer);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CleanupSourceShares )( 
            ICOMReplicate __RPC_FAR * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetLogFile )( 
            ICOMReplicate __RPC_FAR * This,
            /* [out] */ BSTR __RPC_FAR *pbstrLogFile);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RollbackTarget )( 
            ICOMReplicate __RPC_FAR * This,
            /* [in] */ BSTR bstrTargetComputer);
        
        END_INTERFACE
    } ICOMReplicateVtbl;

    interface ICOMReplicate
    {
        CONST_VTBL struct ICOMReplicateVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICOMReplicate_QueryInterface(This,riid,ppvObject)       \
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICOMReplicate_AddRef(This)      \
    (This)->lpVtbl -> AddRef(This)

#define ICOMReplicate_Release(This)     \
    (This)->lpVtbl -> Release(This)


#define ICOMReplicate_GetTypeInfoCount(This,pctinfo)    \
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ICOMReplicate_GetTypeInfo(This,iTInfo,lcid,ppTInfo)     \
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define ICOMReplicate_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)   \
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define ICOMReplicate_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)     \
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define ICOMReplicate_Initialize(This,bstrSourceComputer,lOptions)      \
    (This)->lpVtbl -> Initialize(This,bstrSourceComputer,lOptions)

#define ICOMReplicate_ExportSourceCatalogFiles(This)    \
    (This)->lpVtbl -> ExportSourceCatalogFiles(This)

#define ICOMReplicate_GetTargetStatus(This,bstrTargetComputer,plStatus,pbstrMaster)     \
    (This)->lpVtbl -> GetTargetStatus(This,bstrTargetComputer,plStatus,pbstrMaster)

#define ICOMReplicate_CopyFilesToTarget(This,bstrTargetComputer)        \
    (This)->lpVtbl -> CopyFilesToTarget(This,bstrTargetComputer)

#define ICOMReplicate_InstallTarget(This,bstrTargetComputer)    \
    (This)->lpVtbl -> InstallTarget(This,bstrTargetComputer)

#define ICOMReplicate_CleanupSourceShares(This) \
    (This)->lpVtbl -> CleanupSourceShares(This)

#define ICOMReplicate_GetLogFile(This,pbstrLogFile)     \
    (This)->lpVtbl -> GetLogFile(This,pbstrLogFile)

#define ICOMReplicate_RollbackTarget(This,bstrTargetComputer)   \
    (This)->lpVtbl -> RollbackTarget(This,bstrTargetComputer)

#endif /* COBJMACROS */


#endif  /* C style interface */



/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ICOMReplicate_Initialize_Proxy( 
    ICOMReplicate __RPC_FAR * This,
    /* [in] */ BSTR bstrSourceComputer,
    /* [in] */ LONG lOptions);


void __RPC_STUB ICOMReplicate_Initialize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ICOMReplicate_ExportSourceCatalogFiles_Proxy( 
    ICOMReplicate __RPC_FAR * This);


void __RPC_STUB ICOMReplicate_ExportSourceCatalogFiles_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ICOMReplicate_GetTargetStatus_Proxy( 
    ICOMReplicate __RPC_FAR * This,
    /* [in] */ BSTR bstrTargetComputer,
    /* [out] */ LONG __RPC_FAR *plStatus,
    /* [out] */ BSTR __RPC_FAR *pbstrMaster);


void __RPC_STUB ICOMReplicate_GetTargetStatus_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ICOMReplicate_CopyFilesToTarget_Proxy( 
    ICOMReplicate __RPC_FAR * This,
    /* [in] */ BSTR bstrTargetComputer);


void __RPC_STUB ICOMReplicate_CopyFilesToTarget_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ICOMReplicate_InstallTarget_Proxy( 
    ICOMReplicate __RPC_FAR * This,
    /* [in] */ BSTR bstrTargetComputer);


void __RPC_STUB ICOMReplicate_InstallTarget_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ICOMReplicate_CleanupSourceShares_Proxy( 
    ICOMReplicate __RPC_FAR * This);


void __RPC_STUB ICOMReplicate_CleanupSourceShares_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ICOMReplicate_GetLogFile_Proxy( 
    ICOMReplicate __RPC_FAR * This,
    /* [out] */ BSTR __RPC_FAR *pbstrLogFile);


void __RPC_STUB ICOMReplicate_GetLogFile_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ICOMReplicate_RollbackTarget_Proxy( 
    ICOMReplicate __RPC_FAR * This,
    /* [in] */ BSTR bstrTargetComputer);


void __RPC_STUB ICOMReplicate_RollbackTarget_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif  /* __ICOMReplicate_INTERFACE_DEFINED__ */



#ifndef __COMReplLib_LIBRARY_DEFINED__
#define __COMReplLib_LIBRARY_DEFINED__

/* library COMReplLib */
/* [helpstring][version][uuid] */ 

#define COMREPL_OPTION_REPLICATE_IIS_APPS               1
#define COMREPL_OPTION_MERGE_WITH_TARGET_APPS   2
#define COMREPL_OPTION_CHECK_APP_VERSION                4
#define COMREPL_OPTION_BACKUP_TARGET                    8
#define COMREPL_OPTION_LOG_TO_CONSOLE                   16

EXTERN_C const IID LIBID_COMReplLib;

EXTERN_C const CLSID CLSID_ReplicateCatalog;

#ifdef __cplusplus

class DECLSPEC_UUID("8C836AF9-FFAC-11D0-8ED4-00C04FC2C17B")
ReplicateCatalog;
#endif
#endif /* __COMReplLib_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  BSTR_UserSize(     unsigned long __RPC_FAR *, unsigned long            , BSTR __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  BSTR_UserMarshal(  unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, BSTR __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  BSTR_UserUnmarshal(unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, BSTR __RPC_FAR * ); 
void                      __RPC_USER  BSTR_UserFree(     unsigned long __RPC_FAR *, BSTR __RPC_FAR * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\inc\asppdef.h ===
/*===================================================================
Microsoft Denali

Microsoft Confidential.
Copyright 1996 Microsoft Corporation. All Rights Reserved.

Component: Main

File: perfdef.h

Owner: DmitryR

Data definitions shared between asp.dll and aspperf.dll
===================================================================*/

#ifndef _ASP_PERFDEF_H
#define _ASP_PERFDEF_H

#include <winbase.h>

#include <pudebug.h>

#ifndef ErrInitCriticalSection
#define ErrInitCriticalSection( cs, hr ) \
        do { \
        hr = S_OK; \
        __try \
            { \
            InitializeCriticalSection (cs); \
            } \
        __except(1) \
            { \
            hr = E_UNEXPECTED; \
            } \
        } while (0)

#endif
/*===================================================================
PerfData indices
===================================================================*/
// Counter offsets in the array

#define ID_DEBUGDOCREQ      0
#define ID_REQERRRUNTIME    1
#define ID_REQERRPREPROC    2
#define ID_REQERRCOMPILE    3
#define ID_REQERRORPERSEC   4
#define ID_REQTOTALBYTEIN   5
#define ID_REQTOTALBYTEOUT  6
#define ID_REQEXECTIME      7
#define ID_REQWAITTIME      8
#define ID_REQCOMFAILED     9
#define ID_REQBROWSEREXEC   10
#define ID_REQFAILED        11
#define ID_REQNOTAUTH       12
#define ID_REQNOTFOUND      13
#define ID_REQCURRENT       14
#define ID_REQREJECTED      15
#define ID_REQSUCCEEDED     16
#define ID_REQTIMEOUT       17
#define ID_REQTOTAL         18
#define ID_REQPERSEC        19
#define ID_SCRIPTFREEENG    20
#define ID_SESSIONLIFETIME  21
#define ID_SESSIONCURRENT   22
#define ID_SESSIONTIMEOUT   23
#define ID_SESSIONSTOTAL    24
#define ID_TEMPLCACHE       25
#define ID_TEMPLCACHEHITS   26
#define ID_TEMPLCACHETRYS   27
#define ID_TEMPLFLUSHES     28
#define ID_TRANSABORTED     29
#define ID_TRANSCOMMIT      30
#define ID_TRANSPENDING     31
#define ID_TRANSTOTAL       32
#define ID_TRANSPERSEC      33
#define ID_MEMORYTEMPLCACHE   34
#define ID_MEMORYTEMPLCACHEHITS 35
#define ID_MEMORYTEMPLCACHETRYS 36
#define ID_ENGINECACHEHITS   37 
#define ID_ENGINECACHETRYS   38
#define ID_ENGINEFLUSHES     39

// Number of counters in per-process file map
#define C_PERF_PROC_COUNTERS    40

/*===================================================================
Definitions of names, sizes and mapped data block structures
===================================================================*/

// Mutex name to access the main file map
#define SZ_PERF_MUTEX           "Global\\ASP_PERFMON_MUTEX"

// WaitForSingleObject arg (how long to wait for mutext before failing)
#define PERM_MUTEX_WAIT         1000

// event signaled by ASP processes when a procId is added
#define SZ_PERF_ADD_EVENT       "Global\\ASP_PERFMON_ADD_EVENT"

// Main shared file map name
#define SZ_PERF_MAIN_FILEMAP    "Global\\ASP_PERFMON_MAIN_BLOCK"

// Max number of registered (ASP) processes in main file map
#define C_PERF_PROC_MAX         2048

// Structure that defines main file map
struct CPerfMainBlockData
    {
    DWORD m_dwTimestamp;  // time (GetTickCount()) of the last change
    DWORD m_cItems;       // number of registred processes
    
    // array of process IDs
    DWORD m_dwProcIds[C_PERF_PROC_MAX];

    // array of accumulated counters for dead processes
    DWORD m_rgdwCounters[C_PERF_PROC_COUNTERS];

    DWORD m_dwWASPid;
    };

#define CB_PERF_MAIN_BLOCK      (sizeof(struct CPerfMainBlockData))

// Name for per-process file map
#define SZ_PERF_PROC_FILEMAP_PREFIX    "Global\\ASP_PERFMON_BLOCK_"
#define CCH_PERF_PROC_FILEMAP_PREFIX   25

struct CPerfProcBlockData
    {
    DWORD m_dwProcId;                            // process CLS ID
    DWORD m_rgdwCounters[C_PERF_PROC_COUNTERS];  // array counters
    };

#define CB_PERF_PROC_BLOCK      (sizeof(struct CPerfProcBlockData))
#define CB_COUNTERS             (sizeof(DWORD) * C_PERF_PROC_COUNTERS)

class   CASPPerfManager;

/*===================================================================
CSharedMemBlock  --  generic shared memory block
===================================================================*/

class CSharedMemBlock
    {
public:
    HANDLE m_hMemory;
    void  *m_pMemory;

    SECURITY_ATTRIBUTES m_sa;

    inline CSharedMemBlock() : m_hMemory(NULL), m_pMemory(NULL) {
        m_sa.nLength = sizeof(SECURITY_ATTRIBUTES);
        m_sa.lpSecurityDescriptor = NULL;
        m_sa.bInheritHandle = FALSE;
    }
    inline ~CSharedMemBlock() { 
        UnInitMap(); 
        if (m_sa.lpSecurityDescriptor)
            free(m_sa.lpSecurityDescriptor);
    }

    inline void *PMemory() { return m_pMemory; }

    HRESULT InitSD();
    HRESULT InitMap(LPCSTR szName, DWORD dwSize, BOOL bCreate = TRUE);
    HRESULT UnInitMap();

    SECURITY_ATTRIBUTES     *PGetSA() { return &m_sa; }
private:
    HRESULT CreateSids( PSID                    *ppBuiltInAdministrators,
                        PSID                    *ppPowerUsers,
                        PSID                    *ppAuthenticatedUsers,
                        PSID                    *ppPerfMonUsers,
                        PSID                    *ppPerfLogUsers);
    };

//
// CreateSids
//
// Create 3 Security IDs
//
// Caller must free memory allocated to SIDs on success.
//
// Returns: HRESULT indicating SUCCESS or FAILURE
//
inline HRESULT CSharedMemBlock::CreateSids(
    PSID                    *ppBuiltInAdministrators,
    PSID                    *ppPowerUsers,
    PSID                    *ppAuthenticatedUsers,
    PSID                    *ppPerfMonUsers,
    PSID                    *ppPerfLogUsers
)
{
    HRESULT     hr = S_OK;

    *ppBuiltInAdministrators = NULL;
    *ppPowerUsers = NULL;
    *ppAuthenticatedUsers = NULL;
    *ppPerfMonUsers = NULL;
    *ppPerfLogUsers = NULL;

    //
    // An SID is built from an Identifier Authority and a set of Relative IDs
    // (RIDs).  The Authority of interest to us SECURITY_NT_AUTHORITY.
    //

    SID_IDENTIFIER_AUTHORITY NtAuthority = SECURITY_NT_AUTHORITY;

    //
    // Each RID represents a sub-unit of the authority.  Two of the SIDs we
    // want to build, Local Administrators, and Power Users, are in the "built
    // in" domain.  The other SID, for Authenticated users, is based directly
    // off of the authority.
    //     
    // For examples of other useful SIDs consult the list in
    // \nt\public\sdk\inc\ntseapi.h.
    //

    if (!AllocateAndInitializeSid(&NtAuthority,
                                  2,            // 2 sub-authorities
                                  SECURITY_BUILTIN_DOMAIN_RID,
                                  DOMAIN_ALIAS_RID_ADMINS,
                                  0,0,0,0,0,0,
                                  ppBuiltInAdministrators)) {

        hr = HRESULT_FROM_WIN32(GetLastError());
        
    } else if (!AllocateAndInitializeSid(&NtAuthority,
                                         2,            // 2 sub-authorities
                                         SECURITY_BUILTIN_DOMAIN_RID,
                                         DOMAIN_ALIAS_RID_POWER_USERS,
                                         0,0,0,0,0,0,
                                         ppPowerUsers)) {

        hr = HRESULT_FROM_WIN32(GetLastError());
        
    } else if (!AllocateAndInitializeSid(&NtAuthority,
                                         1,            // 1 sub-authority
                                         SECURITY_AUTHENTICATED_USER_RID,
                                         0,0,0,0,0,0,0,
                                         ppAuthenticatedUsers)) {

        hr = HRESULT_FROM_WIN32(GetLastError());
        
    } else if (!AllocateAndInitializeSid(&NtAuthority,
                                         2,            // 1 sub-authority
                                         SECURITY_BUILTIN_DOMAIN_RID,
                                         DOMAIN_ALIAS_RID_MONITORING_USERS,
                                         0,0,0,0,0,0,
                                         ppPerfMonUsers)) {

        hr = HRESULT_FROM_WIN32(GetLastError());
        
    } else if (!AllocateAndInitializeSid(&NtAuthority,
                                         2,            // 1 sub-authority
                                         SECURITY_BUILTIN_DOMAIN_RID,
                                         DOMAIN_ALIAS_RID_LOGGING_USERS,
                                         0,0,0,0,0,0,
                                         ppPerfLogUsers)) {

        hr = HRESULT_FROM_WIN32(GetLastError());
        
    }

    if (FAILED(hr)) {

        if (*ppBuiltInAdministrators) {
            FreeSid(*ppBuiltInAdministrators);
            *ppBuiltInAdministrators = NULL;
        }

        if (*ppPowerUsers) {
            FreeSid(*ppPowerUsers);
            *ppPowerUsers = NULL;
        }

        if (*ppAuthenticatedUsers) {
            FreeSid(*ppAuthenticatedUsers);
            *ppAuthenticatedUsers = NULL;
        }

        if (*ppPerfMonUsers) {
            FreeSid(*ppPerfMonUsers);
            *ppPerfMonUsers = NULL;
        }

        if (*ppPerfLogUsers) {
            FreeSid(*ppPerfLogUsers);
            *ppPerfLogUsers = NULL;
        }
    }

    return hr;
}


//
// InitSD
//
// Creates a SECURITY_DESCRIPTOR with specific DACLs.
//

inline HRESULT CSharedMemBlock::InitSD()
{
    HRESULT                 hr = S_OK;
    PSID                    pAuthenticatedUsers = NULL;
    PSID                    pBuiltInAdministrators = NULL;
    PSID                    pPowerUsers = NULL;
    PSID                    pMonUsers = NULL;
    PSID                    pLogUsers = NULL;
    PSECURITY_DESCRIPTOR    pSD = NULL;

    if (m_sa.lpSecurityDescriptor != NULL) {
        return S_OK;
    }

    if (FAILED(hr = CreateSids(&pBuiltInAdministrators,
                               &pPowerUsers,
                               &pAuthenticatedUsers,
                               &pMonUsers,
                               &pLogUsers)));


    else {

        // 
        // Calculate the size of and allocate a buffer for the DACL, we need
        // this value independently of the total alloc size for ACL init.
        //

        ULONG                   AclSize;

        //
        // "- sizeof (ULONG)" represents the SidStart field of the
        // ACCESS_ALLOWED_ACE.  Since we're adding the entire length of the
        // SID, this field is counted twice.
        //

        AclSize = sizeof (ACL) +
            (5 * (sizeof (ACCESS_ALLOWED_ACE) - sizeof (ULONG))) +
            GetLengthSid(pAuthenticatedUsers) +
            GetLengthSid(pBuiltInAdministrators) +
            GetLengthSid(pPowerUsers) + 
            GetLengthSid(pMonUsers) +
            GetLengthSid(pLogUsers);

        pSD = malloc(SECURITY_DESCRIPTOR_MIN_LENGTH + AclSize);

        if (!pSD) {

            hr = E_OUTOFMEMORY;

        } else {

            ACL                     *Acl;

            Acl = (ACL *)((BYTE *)pSD + SECURITY_DESCRIPTOR_MIN_LENGTH);

            if (!InitializeAcl(Acl,
                               AclSize,
                               ACL_REVISION)) {

                hr = HRESULT_FROM_WIN32(GetLastError());

            } else if (!AddAccessAllowedAce(Acl,
                                            ACL_REVISION,
                                            SYNCHRONIZE | GENERIC_READ | GENERIC_WRITE,
                                            pAuthenticatedUsers)) {

                hr = HRESULT_FROM_WIN32(GetLastError());

            } else if (!AddAccessAllowedAce(Acl,
                                            ACL_REVISION,
                                            SYNCHRONIZE | GENERIC_READ | GENERIC_WRITE,
                                            pPowerUsers)) {

                hr = HRESULT_FROM_WIN32(GetLastError());

            } else if (!AddAccessAllowedAce(Acl,
                                            ACL_REVISION,
                                            SYNCHRONIZE | GENERIC_READ | GENERIC_WRITE,
                                            pBuiltInAdministrators)) {

                hr = HRESULT_FROM_WIN32(GetLastError());

            } else if (!AddAccessAllowedAce(Acl,
                                            ACL_REVISION,
                                            SYNCHRONIZE | GENERIC_READ | GENERIC_WRITE,
                                            pMonUsers)) {

                hr = HRESULT_FROM_WIN32(GetLastError());

            } else if (!AddAccessAllowedAce(Acl,
                                            ACL_REVISION,
                                            SYNCHRONIZE | GENERIC_READ | GENERIC_WRITE,
                                            pLogUsers)) {

                hr = HRESULT_FROM_WIN32(GetLastError());

            } else if (!InitializeSecurityDescriptor(pSD,
                                                     SECURITY_DESCRIPTOR_REVISION)) {

                hr = HRESULT_FROM_WIN32(GetLastError());

            } else if (!SetSecurityDescriptorDacl(pSD,
                                                  TRUE,
                                                  Acl,
                                                  FALSE)) {

                hr = HRESULT_FROM_WIN32(GetLastError());

            } 
        }
    }

    if (pAuthenticatedUsers)
        FreeSid(pAuthenticatedUsers);

    if (pBuiltInAdministrators)
        FreeSid(pBuiltInAdministrators);

    if (pPowerUsers)
        FreeSid(pPowerUsers);

    if (pMonUsers)
        FreeSid(pMonUsers);

    if (pLogUsers)
        FreeSid(pLogUsers);

    if (FAILED(hr) && pSD) {
        free(pSD);
        pSD = NULL;
    }

    m_sa.lpSecurityDescriptor = pSD;

    return hr;
}

inline HRESULT CSharedMemBlock::InitMap
(
LPCSTR szName,
DWORD  dwSize,
BOOL   bCreate /* = TRUE */
)
    {
    HRESULT hr = S_OK;

    if (FAILED(hr = InitSD())) {
        return hr;
    }
    
    // If we are suppose to be the one's creating the memory,
    // then make sure that we are.
    if ( bCreate )
    {
        m_hMemory = CreateFileMappingA
            (
            INVALID_HANDLE_VALUE,
            &m_sa,
            PAGE_READWRITE,
            0,
            dwSize,
            szName
            );

        if ( m_hMemory == NULL )
        {
            return HRESULT_FROM_WIN32( GetLastError () );
        }
        else
        {
            if ( GetLastError() == ERROR_ALREADY_EXISTS )
            {
                CloseHandle ( m_hMemory );
                m_hMemory = NULL;

                return HRESULT_FROM_WIN32( ERROR_ALREADY_EXISTS );
            }
        }

    }
    else
    {
        // Try to open existing
        m_hMemory = OpenFileMappingA
            (
            FILE_MAP_WRITE | FILE_MAP_READ,
            FALSE, 
            szName
            );

        if (!m_hMemory)
            return E_FAIL;
    }

    m_pMemory = MapViewOfFile
        (
        m_hMemory,
        FILE_MAP_ALL_ACCESS,
        0,
        0,
        0
        );
    if (!m_pMemory)
        {
        UnInitMap();
        return E_FAIL;
        }

    if (bCreate)
        memset(m_pMemory, 0, dwSize);
        
    return S_OK;
    }

inline HRESULT CSharedMemBlock::UnInitMap()
    {
    if (m_pMemory) 
        {
        UnmapViewOfFile(m_pMemory);
        m_pMemory = NULL;
        }
    if (m_hMemory) 
        {
        CloseHandle(m_hMemory);
        m_hMemory = NULL;
        }
    return S_OK;
    }

/*===================================================================
CPerfProcBlock - class representing pref data for a single process
===================================================================*/

class CPerfProcBlock : public CSharedMemBlock
    {

friend class CPerfMainBlock;
friend class CASPPerfManager;

#ifndef _PERF_CMD
protected:
#else
public:
#endif
    DWORD m_fInited : 1;
    DWORD m_fMemCSInited : 1;
    DWORD m_fReqCSInited : 1;
    DWORD m_fProcessDead : 1;

    HANDLE  m_hWaitHandle;

    // critical sections (only used in ASP.DLL)
    CRITICAL_SECTION m_csMemLock; // CS for memory counters
    CRITICAL_SECTION m_csReqLock; // CS for per-request counters

    // block of counters
    CPerfProcBlockData *m_pData;
    
    // next process data (used in ASPPERF.DLL/WAS)
    CPerfProcBlock *m_pNext;

    // access shared memory
    HRESULT MapMemory(DWORD  procId,  BOOL  bCreate = TRUE);

    static VOID CALLBACK WaitCallback(PVOID  pArg,  BOOLEAN fReason);

public:
    inline CPerfProcBlock() 
        : m_fInited(FALSE),
          m_fMemCSInited(FALSE), m_fReqCSInited(FALSE),
          m_fProcessDead(FALSE),
          m_hWaitHandle(NULL),
          m_pData(NULL), m_pNext(NULL)
        {}
        
    inline ~CPerfProcBlock() { UnInit(); }

    HRESULT InitCriticalSections();
    HRESULT UnInitCriticalSections();
    
    HRESULT InitExternal(DWORD  procId);  // from ASPPERF.DLL
    
    HRESULT InitForThisProcess                 // from ASP.DLL
        (
        DWORD  procId,
        DWORD *pdwInitCounters = NULL
        );

    HRESULT UnInit();
    };

inline HRESULT CPerfProcBlock::MapMemory
(
DWORD  procId,
BOOL   bCreate /* = TRUE */
)
    {
    // Construct unique map name with CLSID
    char szMapName[CCH_PERF_PROC_FILEMAP_PREFIX+32+1];
    strcpy(szMapName, SZ_PERF_PROC_FILEMAP_PREFIX);
    
    char  *pszHex = szMapName + CCH_PERF_PROC_FILEMAP_PREFIX;
    sprintf(pszHex, "%08x", procId);

    // create or open the map
    HRESULT hr = InitMap(szMapName, CB_PERF_PROC_BLOCK, bCreate);
    
    if (SUCCEEDED(hr))
        {
        m_pData = (CPerfProcBlockData *)PMemory();

        if (m_pData->m_dwProcId == 0)
            m_pData->m_dwProcId = procId;
        else if (m_pData->m_dwProcId != procId)
            hr = E_FAIL; // cls id mismatch
        }
        
    return hr;
    }

inline HRESULT CPerfProcBlock::InitCriticalSections()
    {
    HRESULT hr = S_OK;
    
    if (!m_fMemCSInited)
        {
        __try { INITIALIZE_CRITICAL_SECTION(&m_csMemLock); }
        __except(1) { hr = E_UNEXPECTED; }
        if (SUCCEEDED(hr))
            m_fMemCSInited = TRUE;
        else
            return hr;
        }
        
    if (!m_fReqCSInited)
        {
        __try { INITIALIZE_CRITICAL_SECTION(&m_csReqLock); }
        __except(1) { hr = E_UNEXPECTED; }
        if (SUCCEEDED(hr))
            m_fReqCSInited = TRUE;
        else
            return hr;
        }

    return S_OK;
    }

inline HRESULT CPerfProcBlock::UnInitCriticalSections()
    {
    if (m_fMemCSInited)
        {
        DeleteCriticalSection(&m_csMemLock);
        m_fMemCSInited = FALSE;
        }
    if (m_fReqCSInited)
        {
        DeleteCriticalSection(&m_csReqLock);
        m_fReqCSInited = FALSE;
        }

    return S_OK;
    }

inline HRESULT CPerfProcBlock::InitExternal
(
DWORD   procId
)
    {
    HRESULT hr = MapMemory(procId, FALSE);

    if (SUCCEEDED(hr))
        m_fInited = TRUE;
    else
        UnInit();
    return hr;
    }

inline HRESULT CPerfProcBlock::InitForThisProcess
(
DWORD  procId,
DWORD *pdwInitCounters
)
    {
    HRESULT hr = S_OK;

    // Map the shared memory
    if (SUCCEEDED(hr))
        hr = MapMemory(procId, TRUE);

    if (SUCCEEDED(hr))
        {
        // init the counters
        if (pdwInitCounters)
            memcpy(m_pData->m_rgdwCounters, pdwInitCounters, CB_COUNTERS);
        else
            memset(m_pData->m_rgdwCounters, 0, CB_COUNTERS);
            
        m_fInited = TRUE;
        }
    else
        {
        UnInit();
        }
        
    return hr;
    }

inline HRESULT CPerfProcBlock::UnInit()
    {
    UnInitMap();
    
    m_pData = NULL;
    m_pNext = NULL;         
    m_fInited = FALSE;
    return S_OK;
    }

inline VOID CALLBACK CPerfProcBlock::WaitCallback(PVOID  pArg,  BOOLEAN fReason)
{
    CPerfProcBlock  *pPerfBlock = (CPerfProcBlock *)pArg;

    pPerfBlock->m_fProcessDead = TRUE;
}

/*===================================================================
CPerfMainBlock - class representing the main perf data
===================================================================*/

class CPerfMainBlock : public CSharedMemBlock
    {

    friend CASPPerfManager;

#ifndef _PERF_CMD
private:
#else
public:
#endif
    DWORD m_fInited : 1;

    // the process block directory
    CPerfMainBlockData *m_pData;

    // mutex to access the process block directory
    HANDLE m_hMutex;

    HANDLE          m_hChangeEvent;

    HANDLE          m_WASProcessHandle;

    // first process data (used in ASPPERF.DLL)
    CPerfProcBlock *m_pProcBlock;

    // timestamp of main block when the list of process blocks
    // last loaded -- to make decide to reload (ASPPREF.DLL only)
    DWORD m_dwTimestamp;

public:
    inline CPerfMainBlock() 
        : m_fInited(FALSE),
          m_hChangeEvent(NULL),
          m_pData(NULL), 
          m_hMutex(NULL), 
          m_pProcBlock(NULL), 
          m_dwTimestamp(NULL),
          m_WASProcessHandle(NULL)
        {}
        
    inline ~CPerfMainBlock() { UnInit(); }

    HRESULT Init(BOOL  bWASInit = FALSE);
    HRESULT UnInit();

    // lock / unlock using mutex
    HRESULT Lock();
    HRESULT UnLock();

    // add/remove process record to the main block (used from ASP.DLL)
    HRESULT AddProcess(DWORD    procId);

    // load CPerfProcBlock blocks from the main block into
    // objects (used from APPPREF.DLL)
    HRESULT Load();

    // gather (sum-up) the statistics from each proc block
    HRESULT GetStats(DWORD *pdwCounters);

    // copies the counters from a process that is going away into
    // the shared array of the accumulated counters from dead processes.
    // Used from WAS.
    VOID AggregateDeadProcCounters(CPerfProcBlock  *pBlock);

    HRESULT         CreateChangeEvent(BOOL bMustCreate);

    VOID            SetChangeEvent() { SetEvent(m_hChangeEvent); }

    HANDLE GetWASProcessHandle();


    };

inline 
HRESULT CPerfMainBlock::Init(BOOL bWASInit)
{
    HRESULT hr = S_OK;

    if (FAILED(hr = InitSD())) 
    {
        return hr;
    }

    // only WAS can create the Mutex, others have to just open it

    if (bWASInit) 
    {
        m_hMutex = CreateMutexA(&m_sa, FALSE, SZ_PERF_MUTEX);

        if (m_hMutex == NULL )
        {
            hr = HRESULT_FROM_WIN32( GetLastError () );
        }
        // If we got it, but we didn't create it then throw it
        // back.  Only WAS can create this.
        else if ( GetLastError() == ERROR_ALREADY_EXISTS )
        {
            hr = HRESULT_FROM_WIN32( GetLastError () );

            CloseHandle( m_hMutex );
            m_hMutex = NULL;
        }
    }
    else 
    {
        m_hMutex = OpenMutexA(SYNCHRONIZE, FALSE, SZ_PERF_MUTEX);
    }

    if (!m_hMutex)
    {
        hr = E_FAIL;
    }

    if (SUCCEEDED(hr))
    {
        hr = InitMap(SZ_PERF_MAIN_FILEMAP, CB_PERF_MAIN_BLOCK, bWASInit);
        if (SUCCEEDED(hr))
        {
            m_pData = (CPerfMainBlockData *)PMemory();

            // We got the memory mapped, so set the WAS PID into it
            // if we are setting up the WAS side, otherwise read
            // the value in for others to use.
            if ( bWASInit )
            {

                m_pData->m_dwWASPid = GetCurrentProcessId();

            }
        }
    }

    if (SUCCEEDED(hr))
    {
        hr = CreateChangeEvent(bWASInit);
    }

    if (SUCCEEDED(hr))
    {
        m_fInited = TRUE;
    }
    else
    {
        UnInit();
    }

    return hr;
 }

inline HRESULT CPerfMainBlock::UnInit()
    {

 //   DBGPRINTF((DBG_CONTEXT, "Cleaning up ProcBlocks\n"));
    
    while (m_pProcBlock)
        {
        CPerfProcBlock *pNext = m_pProcBlock->m_pNext;
        m_pProcBlock->UnInit();
        delete m_pProcBlock;
        m_pProcBlock = pNext;
        }
        
 //   DBGPRINTF((DBG_CONTEXT, "Cleaning up mutex\n"));

    if (m_hMutex)
        {
        CloseHandle(m_hMutex);
        m_hMutex = NULL;
        }

//    DBGPRINTF((DBG_CONTEXT, "Uninit'ing map\n"));

    
    UnInitMap();

    m_dwTimestamp = 0;
    m_pData = NULL;
    m_pProcBlock = NULL;
    m_fInited = FALSE;

    // close its handle

 //   DBGPRINTF((DBG_CONTEXT, "Closing ChangeEvent Handle\n"));

    if (m_hChangeEvent != NULL)
        CloseHandle(m_hChangeEvent);

    m_hChangeEvent = NULL;

    if ( m_WASProcessHandle != NULL )
    {
        CloseHandle ( m_WASProcessHandle );
        m_WASProcessHandle = NULL;
    }

    return S_OK;
    }

inline HRESULT  CPerfMainBlock::CreateChangeEvent(BOOL  bMustCreate)
{
    // Create the changed event using the standard SD.  Make the
    // reset Automatic and initial state to unsignalled.

    if (bMustCreate) {
        m_hChangeEvent = CreateEventA(&m_sa, 
                                      FALSE, 
                                      FALSE,
                                      SZ_PERF_ADD_EVENT);

        // if GetLastError indicates that the handle already exists, this
        // is bad.  Return an error.  This process should always be the creator
        // of the event.
        if ((GetLastError() == ERROR_ALREADY_EXISTS)) {
            CloseHandle(m_hChangeEvent);
            m_hChangeEvent = NULL;
            return HRESULT_FROM_WIN32(ERROR_ALREADY_EXISTS);
        }

    }
    else {
        m_hChangeEvent = OpenEventA(EVENT_MODIFY_STATE,
                                    FALSE,
                                    SZ_PERF_ADD_EVENT);
    }

    if (m_hChangeEvent == NULL)
        return HRESULT_FROM_WIN32(GetLastError());

    return S_OK;
}

inline 
HANDLE CPerfMainBlock::GetWASProcessHandle()
{
    HRESULT hr = S_OK;
    
    if ( m_WASProcessHandle == NULL )
    {
        m_WASProcessHandle = OpenProcess ( SYNCHRONIZE,   // security
                                           FALSE,         // not inheritable
                                           m_pData->m_dwWASPid);

        // If we failed to open the process the handle will be null.
        // This will be checked for by the caller.
    }

    return m_WASProcessHandle;
 }


inline HRESULT CPerfMainBlock::Lock()
    {
    if (!m_hMutex)
        return E_FAIL;
    if (WaitForSingleObject(m_hMutex, PERM_MUTEX_WAIT) == WAIT_TIMEOUT)
        return E_FAIL;
    return S_OK;
    }
    
inline HRESULT CPerfMainBlock::UnLock()
    {
    if (m_hMutex)
        ReleaseMutex(m_hMutex);
    return S_OK;
    }

inline HRESULT CPerfMainBlock::AddProcess
(
DWORD   procId
)
    {
    if (!m_fInited)
        return E_FAIL;

    if (FAILED(Lock()))  // lock mutex
        return E_FAIL;
    HRESULT hr = S_OK;

    BOOL fFound = FALSE;

    DWORD  idx = 0;
    // find
    for (DWORD cnt = min(m_pData->m_cItems,C_PERF_PROC_MAX); idx < cnt; idx++)
        {
        if (m_pData->m_dwProcIds[idx] == procId)
            {
            fFound = TRUE;
            break;
            }
        }

    // add only if not already there
    if (!fFound)
        {
        if (idx < C_PERF_PROC_MAX)
            {
            m_pData->m_dwProcIds[idx] = procId;
            m_pData->m_cItems = idx + 1;
            m_pData->m_dwTimestamp = GetTickCount();

            SetChangeEvent();
            }
        else
            {
            hr = E_OUTOFMEMORY;
            }
        }

    UnLock();   // unlock mutex
    return hr;
    }

inline HRESULT CPerfMainBlock::Load()
    {
    if (!m_fInited)
        return E_FAIL;

    if (m_dwTimestamp == m_pData->m_dwTimestamp)
        return S_OK; // already up-to-date

    // clear out what we have
    while (m_pProcBlock)
        {
        CPerfProcBlock *pNext = m_pProcBlock->m_pNext;
        m_pProcBlock->UnInit();
        delete m_pProcBlock;
        m_pProcBlock = pNext;
        }
        
    if (FAILED(Lock())) // lock mutex
        return E_FAIL;
    HRESULT hr = S_OK;

    // populate new objects for blocks
    for (DWORD i = 0, cnt = min(m_pData->m_cItems,C_PERF_PROC_MAX); i < cnt;)
        {
        CPerfProcBlock *pBlock = new CPerfProcBlock;
        if (!pBlock)
            {
            hr = E_OUTOFMEMORY;
            break;
            }
        
        hr = pBlock->InitExternal(m_pData->m_dwProcIds[i]);
        if (FAILED(hr))
            {
            delete pBlock;
            hr = S_OK;
            cnt--;
            m_pData->m_cItems--;
            for (DWORD j = i; j < min(m_pData->m_cItems,C_PERF_PROC_MAX); j++) {
                m_pData->m_dwProcIds[j] = m_pData->m_dwProcIds[j+1];
            }
            continue;
            }

        pBlock->m_pNext = m_pProcBlock;
        m_pProcBlock = pBlock;
        i++;
        }

    // remember timestamp
    m_dwTimestamp = SUCCEEDED(hr) ? m_pData->m_dwTimestamp : 0;

    UnLock();   // unlock mutex
    return hr;
    }

inline HRESULT CPerfMainBlock::GetStats
(
DWORD *pdwCounters
)
{
    if (!m_fInited)
        return E_FAIL;

    // reload if needed
    if (FAILED(Load()))
        return E_FAIL;

    // first add in the accumulated stats from the dead procs...

    for (int i = 0; i < C_PERF_PROC_COUNTERS; i++)
        pdwCounters[i] = m_pData->m_rgdwCounters[i];

    // gather
    CPerfProcBlock *pBlock = m_pProcBlock;
    while (pBlock) {
        if (pBlock->m_fProcessDead) {
            m_dwTimestamp = 0;
            pBlock = pBlock->m_pNext;
            continue;
        }
        for (int i = 0; i < C_PERF_PROC_COUNTERS; i++)
            pdwCounters[i] += pBlock->m_pData->m_rgdwCounters[i];
        pBlock = pBlock->m_pNext;
    }
        
    return S_OK;
}

inline VOID CPerfMainBlock::AggregateDeadProcCounters(CPerfProcBlock  *pBlock)
{

    DWORD   *pOut = m_pData->m_rgdwCounters;
    DWORD   *pIn  = pBlock->m_pData->m_rgdwCounters;

 //   DBGPRINTF((DBG_CONTEXT, "Aggregating Dead Proc Counters\n"));

    pOut[ID_DEBUGDOCREQ]        += pIn[ID_DEBUGDOCREQ];
    pOut[ID_REQERRRUNTIME]      += pIn[ID_REQERRRUNTIME];
    pOut[ID_REQERRPREPROC]      += pIn[ID_REQERRPREPROC];
    pOut[ID_REQERRCOMPILE]      += pIn[ID_REQERRCOMPILE];
    pOut[ID_REQERRORPERSEC]     += pIn[ID_REQERRORPERSEC];
    pOut[ID_REQTOTALBYTEIN]     += pIn[ID_REQTOTALBYTEIN];
    pOut[ID_REQTOTALBYTEOUT]    += pIn[ID_REQTOTALBYTEOUT];
    pOut[ID_REQCOMFAILED]       += pIn[ID_REQCOMFAILED];
    pOut[ID_REQFAILED]          += pIn[ID_REQFAILED];
    pOut[ID_REQNOTAUTH]         += pIn[ID_REQNOTAUTH];
    pOut[ID_REQREJECTED]        += pIn[ID_REQREJECTED];
    pOut[ID_REQSUCCEEDED]       += pIn[ID_REQSUCCEEDED];
    pOut[ID_REQTIMEOUT]         += pIn[ID_REQTIMEOUT];
    pOut[ID_REQTOTAL]           += pIn[ID_REQTOTAL];
    pOut[ID_REQPERSEC]          += pIn[ID_REQPERSEC];
    pOut[ID_SESSIONTIMEOUT]     += pIn[ID_SESSIONTIMEOUT];
    pOut[ID_TEMPLFLUSHES]       += pIn[ID_TEMPLFLUSHES];
    pOut[ID_TRANSABORTED]       += pIn[ID_TRANSABORTED];
    pOut[ID_TRANSCOMMIT]        += pIn[ID_TRANSCOMMIT];
    pOut[ID_TRANSTOTAL]         += pIn[ID_TRANSTOTAL];
    pOut[ID_ENGINEFLUSHES]      += pIn[ID_ENGINEFLUSHES];

}

/******************************************************************************

  Class Definition and support structures for the centralized Global Perf
  Counter structures.  A single CASPPerfManager object will be declared and
  initialized in WAS.  If in new mode, WAS will call the public ProcessDied()
  method to inform when a worker process should no longer be considered alive.
  If not in new mode, WAS does not know about the various ASP host processes
  and so RegisterWaitForSingleObject will be used to monitor the lifetime of
  the ASP host process.

  When a process is declared dead through one of these mechanism, the ASP
  counters associated with that process are moved into a global table to
  accummulate counter counter perf counter types - e.g. Total ASP Requests.

  A named event is used by the ASP host process to single that a new
  host process is up.

  ****************************************************************************/

typedef struct {
    HANDLE          hWaitHandle;
    HANDLE          hProcHandle;
    CPerfProcBlock  *pBlock;
    CASPPerfManager  *pPerfGlobal;
} sWaitInfo;

class CASPPerfManager
{
public:
    CASPPerfManager() :
        m_hChangeWaitHandle(NULL),
        m_dwCntProcsDied(0),
        m_fcsProcsDiedInited(0),
        m_fCompatMode(0),
        m_fInited(0)
        {
            ZeroMemory(m_dwProcIdInWaitState, sizeof(m_dwProcIdInWaitState));
            ZeroMemory(m_aWaitInfos, sizeof(m_aWaitInfos));
        }

    HRESULT     Init(BOOL   bCompatMode);
    HRESULT     UnInit();

    VOID        ProcessDied(DWORD   procId);

private:

    CPerfMainBlock  m_MainBlock;
    HANDLE          m_hChangeWaitHandle;
    DWORD           m_fcsProcsDiedInited : 1;
    DWORD           m_fCompatMode : 1;
    DWORD           m_fInited : 1;

    // Booleans to track status of Process IDs in above array
    BOOL            m_dwProcIdInWaitState[C_PERF_PROC_MAX];

    // array of structures tracking the WaitInfo data
    sWaitInfo       *m_aWaitInfos[C_PERF_PROC_MAX];

    // array of proc IDs, protected by CritSec, of dead procs
    CRITICAL_SECTION    m_csProcsDied; 
    DWORD           m_dwProcsDied[C_PERF_PROC_MAX];
    DWORD           m_dwCntProcsDied;

    static VOID CALLBACK ChangeEventWaitCallback(PVOID  pArg,  BOOLEAN fReason);

    static VOID CALLBACK ProcDiedCallback(PVOID  pArg,  BOOLEAN  fReason);

    VOID            ScanForNewProcIDs();

    VOID            HandleDeadProcIDs();

    HRESULT         RegisterWaitOnProcess(sWaitInfo  *pWaitInfo);

    VOID            AddProcDiedToList(DWORD  procID);

};

inline HRESULT CASPPerfManager::Init(BOOL   bCompatMode)
{
    HRESULT     hr = S_OK;

 //   DBGPRINTF((DBG_CONTEXT, "Initializing CASPPerfManager\n"));

    m_fCompatMode = bCompatMode;

    // initialize the MainBlock.  TRUE here indicates that this is
    // a WAS init and the expectation is that the global shared
    // memory is created by this process.

    hr = m_MainBlock.Init(TRUE);

    if (FAILED(hr)) {
        DBGPRINTF((DBG_CONTEXT, "Initializing CASPPerfManager FAILED (%x)\n",hr));
        return hr;
    }

    // Use the RegisterWaitForSingleObject() API to handle the event
    // firing.  Relieves us of the burden of managing a thread.

    if (SUCCEEDED(hr)
        && RegisterWaitForSingleObject(&m_hChangeWaitHandle,
                                       m_MainBlock.m_hChangeEvent,
                                       ChangeEventWaitCallback,
                                       this,
                                       INFINITE,
                                       WT_EXECUTEINIOTHREAD) == FALSE) {

        hr = HRESULT_FROM_WIN32(GetLastError());
    }                          
    
    // Initialize the CriticalSection used to added dead proc ids to
    // the deadprocids array

    if (SUCCEEDED(hr)) {
        ErrInitCriticalSection(&m_csProcsDied, hr);
        if (SUCCEEDED(hr))
            m_fcsProcsDiedInited = TRUE;
    }

    if (FAILED(hr)) {
        DBGPRINTF((DBG_CONTEXT, "Initializing CASPPerfManager FAILED (%x)\n", hr));
        m_MainBlock.UnInit();
    }
    
    if (SUCCEEDED(hr))
        m_fInited = TRUE;

    return hr;
}

inline HRESULT CASPPerfManager::UnInit()
{

    m_fInited = FALSE;

 //   DBGPRINTF((DBG_CONTEXT, "Uninitializing CASPPerfManager\n"));

    // unregister the ChangeEvent wait, if we pass INVALID_HANDLE_VALUE
    // the routine will block until all callbacks have completed before
    // returning
    // Note:  We intentionally don't check the return value for the
    // UnregisterWaitEx, because there is nothing we can do if it fails   
    if (m_hChangeWaitHandle != NULL) {
        UnregisterWaitEx(m_hChangeWaitHandle, INVALID_HANDLE_VALUE);
    }

 //   DBGPRINTF((DBG_CONTEXT, "Unregistered ChangeWait\n"));

 //    DBGPRINTF((DBG_CONTEXT, "WaitForSingleObject on unregister completed\n"));


    // clean up the WaitInfo array
    for (DWORD i=0; m_aWaitInfos[i]; i++) {

        //
        // UnregisterWaitEx will wait for all callback routines to complete
        // before returning if the INVALID_HANDLE_VALUE is passed in.
        // Note:  We intentionally don't check the return value for the
        // UnregisterWaitEx, because there is nothing we can do if it fails
        UnregisterWaitEx(m_aWaitInfos[i]->hWaitHandle, INVALID_HANDLE_VALUE);

        CloseHandle(m_aWaitInfos[i]->hProcHandle);

        delete m_aWaitInfos[i];
    }

//    DBGPRINTF((DBG_CONTEXT, "Cleaned up WaitInfos\n"));

    // if successfully created the ProcsDiedCS, clean it up
    if (m_fcsProcsDiedInited == TRUE)
        DeleteCriticalSection(&m_csProcsDied);

//    DBGPRINTF((DBG_CONTEXT, "Calling m_MainBlock.UnInit\n"));

    return m_MainBlock.UnInit();
}


inline VOID CALLBACK CASPPerfManager::ChangeEventWaitCallback(PVOID  pArg,  BOOLEAN fReason)
{

//    DBGPRINTF((DBG_CONTEXT, "ChangeEventWaitCallback called\n"));

    CASPPerfManager   *pPerfGlob = (CASPPerfManager *)pArg;

    // when the ChangeEvent fires, check for new ProcIDs in the global
    // array and then check for DeadProcIDs.

    pPerfGlob->ScanForNewProcIDs();

    pPerfGlob->HandleDeadProcIDs();
}

inline VOID CASPPerfManager::ScanForNewProcIDs()
{

    HRESULT  hr;

//    DBGPRINTF((DBG_CONTEXT, "Scanning for New Proc IDS\n"));

    // We'll need to hold the lock the entire time we're
    // looking thru the list

    m_MainBlock.Lock();

    // start from the back looking for entries that haven't had
    // their WaitState set.  Again note that there is always the
    // key assumption that the three arrays, m_dwProcIdInWaitState
    // m_aWaitInfo and the m_dwProcIDs array in the global array
    // track each other with respect to position in array.

    for (LONG i = m_MainBlock.m_pData->m_cItems - 1; i >= 0; i--) {

        // as soon as we hit one that is in the Wait state,
        // we're done.

        if (m_dwProcIdInWaitState[i] == TRUE) {
    //        DBGPRINTF((DBG_CONTEXT, "Done Scanning for New Proc IDS\n"));
            break;
        }

   //     DBGPRINTF((DBG_CONTEXT, "Found a new Proc ID at idx - %d\n", i));

        // found one that is not waiting.  Build up the necessary
        // structures and objects

        // we'll need another CPerfProcBlock for the list

        CPerfProcBlock  *pBlock = new CPerfProcBlock;

        if (!pBlock) {
            break;
        }

        // we'll also need a new WaitInfo, if in backwards
        // compat mode.  Remember, in backwards compat mode,
        // this object will do all the register for waits, but
        // in new mode, WAS will tell us when a process has died.

        sWaitInfo   *pWaitInfo = NULL;

        if (m_fCompatMode) {

            pWaitInfo = new sWaitInfo;

            if (!pWaitInfo) {
                delete pBlock;
                break;
            }

            pWaitInfo->pPerfGlobal = this;
            pWaitInfo->pBlock      = pBlock;
        }

        // call InitExternal to hook up to the ASP host processes
        // shared memory.  This is where we will get that needed handle
        // to the shared memory and will allow us to access the shared
        // memory even after the process itself has terminated.

        if (FAILED(hr = pBlock->InitExternal(m_MainBlock.m_pData->m_dwProcIds[i]))) {
   //         DBGPRINTF((DBG_CONTEXT, "InitExternal failed in ScanForNewProcIDS (%x)\n", hr));
            delete pWaitInfo;
            delete pBlock;
            continue;
        }

        // Register the Wait if in compatmode
        if (m_fCompatMode && FAILED(hr = RegisterWaitOnProcess(pWaitInfo))) {

   //         DBGPRINTF((DBG_CONTEXT, "RegisterWait failed in ScanForNewProcIDs (%x)\n", hr));
            pBlock->UnInit();
            delete pWaitInfo;
            delete pBlock;
            continue;
        }

        // Since it's a single linked list, just put the new block
        // at the head of the list.

        pBlock->m_pNext = m_MainBlock.m_pProcBlock;
        m_MainBlock.m_pProcBlock = pBlock;

        // note that this procID is now in a wait state

        m_dwProcIdInWaitState[i] = TRUE;

        // Add the WaitInfo to the array.

        m_aWaitInfos[i] = pWaitInfo;
    }

    m_MainBlock.UnLock();

    return;
}

inline HRESULT CASPPerfManager::RegisterWaitOnProcess(sWaitInfo *pWaitInfo)
{

    HRESULT     hr = S_OK;

    // get a handle to the process to wait on

    pWaitInfo->hProcHandle = OpenProcess(SYNCHRONIZE,
                                         FALSE,
                                         pWaitInfo->pBlock->m_pData->m_dwProcId);

    if (!pWaitInfo->hProcHandle) {

        hr = HRESULT_FROM_WIN32(GetLastError());

    }
    else {

        // register the wait.

        if (!RegisterWaitForSingleObject(&pWaitInfo->hWaitHandle,       // wait handle
                                         pWaitInfo->hProcHandle,        // handle to object
                                         CASPPerfManager::ProcDiedCallback,  // timer callback function
                                         pWaitInfo,                     // callback function parameter
                                         INFINITE,                      // time-out interval
                                         WT_EXECUTEONLYONCE)) {         // options

            CloseHandle(pWaitInfo->hProcHandle);
            pWaitInfo->hProcHandle = NULL;

            hr = HRESULT_FROM_WIN32(GetLastError());
        }
    }

    return hr;
}
 
inline VOID CALLBACK CASPPerfManager::ProcDiedCallback(PVOID  pArg,  BOOLEAN  fReason)
{
    sWaitInfo  *pWaitInfo = (sWaitInfo  *)pArg;

 //   DBGPRINTF((DBG_CONTEXT, "ProcDiedCallback enterred\n"));


    // The callback will simply call the public ProcessDied method on the
    // PerfGlobal object.  This is for simplicity.  There is no reason why the
    // process couldn't be cleaned up on this thread.  

    pWaitInfo->pPerfGlobal->ProcessDied(pWaitInfo->pBlock->m_pData->m_dwProcId);
}

inline VOID CASPPerfManager::ProcessDied(DWORD  procID)
{

 //   DBGPRINTF((DBG_CONTEXT, "CASPPerfManager::ProcessDied enterred for %d\n", procID));

    if (m_fInited == FALSE)
        return;

    // Add the ProcID to the list of dead proc IDS and wakeup the
    // change callback

    AddProcDiedToList(procID);

    m_MainBlock.SetChangeEvent();

    return;
}

inline VOID CASPPerfManager::AddProcDiedToList(DWORD  procID)
{

  //  DBGPRINTF((DBG_CONTEXT, "Adding Process (%d) to proc died list\n", procID));

    // take the critical section, add the process to the list
    // and leave the critical section.

    EnterCriticalSection(&m_csProcsDied);

    m_dwProcsDied[m_dwCntProcsDied++] = procID;

//    DBGPRINTF((DBG_CONTEXT, "New count of ProcsDied list is %d\n",m_dwCntProcsDied));

    LeaveCriticalSection(&m_csProcsDied);
}

inline VOID CASPPerfManager::HandleDeadProcIDs()
{
    DWORD   procID;

  //  DBGPRINTF((DBG_CONTEXT, "HandleDeadProcIDs Enterred\n"));

    sWaitInfo       *pWaitInfo = NULL;
    CPerfProcBlock  *pLast = NULL;
    CPerfProcBlock  *pBlock = NULL;

    // Ok, this is the critical routine.  It's here where
    // we will handle the dead processes.  Cleanup will occur on
    // the various structures around this process as well as the
    // aggregation of it's counters into the global shared memory.

    // enter the critsec to check for dead procs to process

    EnterCriticalSection(&m_csProcsDied);

    // Enter a while loop to process all of the dead procs.  Will also
    // bail if we were uninited.

    while(m_dwCntProcsDied && m_fInited) {

   //     DBGPRINTF((DBG_CONTEXT, "current m_dwCntProcsDies is %d\n", m_dwCntProcsDied));

        // get a proc id from the list.  Note that we start at
        // the back so that we can release the critical section.
        // The alternative would be to take it off the front, and
        // then move all the remaining items forward.  This seems
        // unnecessary.  There should be no issue with LIFO
        // processing that I can see.

        procID = m_dwProcsDied[--m_dwCntProcsDied];

        // we can safely leave the critsec now that we've popped
        // an entry of the end of the list

        LeaveCriticalSection(&m_csProcsDied);

        // now that we have the entry, we need to find it's position
        // in the MainBlock.  Need to hold the lock to do so.

        m_MainBlock.Lock();

        int iFound = -1;
        DWORD  idx, cnt;

        // the search begins in the main shared array of procIDs

        for (idx = 0, cnt = min(m_MainBlock.m_pData->m_cItems,C_PERF_PROC_MAX); idx < cnt; idx++) {

            // break if we found it

            if (m_MainBlock.m_pData->m_dwProcIds[idx] == procID) {
                iFound = idx;
                break;
            }
        }

        // if we didn't find it, oh well, move to the next item.  

        if (iFound == -1)  {
 //           DBGPRINTF((DBG_CONTEXT, "Didn't find DeadProcID (%d) in global array\n", procID));
            goto NextItem;
        }

        pWaitInfo = m_aWaitInfos[iFound];

 //       DBGPRINTF((DBG_CONTEXT, "Found DeadProcID (%d) in global array at idx\n", procID,iFound));

        m_aWaitInfos[iFound] = NULL;
        m_dwProcIdInWaitState[iFound] = FALSE;

        // This for loop will compact the various arrays to effective remove
        // this entry from the arrays.  I could care about not moving the aWaitInfo
        // when not in compat mode, but it doesn't seem like a big deal.

        for (idx = iFound, cnt = min(m_MainBlock.m_pData->m_cItems,C_PERF_PROC_MAX)-1; idx < cnt; idx++) {
            m_MainBlock.m_pData->m_dwProcIds[idx] = m_MainBlock.m_pData->m_dwProcIds[idx+1];
            m_aWaitInfos[idx] = m_aWaitInfos[idx+1];
            m_dwProcIdInWaitState[idx] = m_dwProcIdInWaitState[idx+1];
        }
        
        // Reset the last value of the list to NULL / FALSE to make sure they 
        // all are initialzied correctly when we add the next.
        m_aWaitInfos[m_MainBlock.m_pData->m_cItems-1] = NULL;
        m_dwProcIdInWaitState[m_MainBlock.m_pData->m_cItems-1] = FALSE;

        // note that there is one less item and that the global array has changed.
        // changing the timestamp will notify ASPPERF.DLL to reload its perfprocblocks

        m_MainBlock.m_pData->m_cItems--;
        m_MainBlock.m_pData->m_dwTimestamp = GetTickCount();

        // Now we have to find the PerfProcBlock in the single linked list of
        // PerfBlocks.  There is an obvious optimization to make the PerfProcBlocks
        // double linked lists to avoid the scan.  Skipping this for now in favor
        // of simplicity.

        pLast = NULL;
        pBlock = m_MainBlock.m_pProcBlock;

        // search for the block, maintaining pBlock and pLast variables to allow
        // for the removal of the block.

        while (pBlock && (pBlock->m_pData->m_dwProcId != procID)) {
            pLast = pBlock;
            pBlock = pBlock->m_pNext;
        }

        // if we didn't find it, we'll move on, but Assert.

        if (!pBlock) {
//            DBGPRINTF((DBG_CONTEXT, "Didn't find pBlock (%d) in list\n", procID));
            goto NextItem;
        }

        // now do the removal.  Two cases to handle.  1) the block was the first
        // in the list or 2) it was in the middle.  If not the first, set the previous
        // next to the removed block's next, else set the head list in the mainblock
        // to point to the removed block's next.

        if (pLast)
            pLast->m_pNext = pBlock->m_pNext;
        else
            m_MainBlock.m_pProcBlock = pBlock->m_pNext;

        // we'll only have wait info in compat mode, which means that this
        // pointer could be NULL.

        if (pWaitInfo) {

            UnregisterWait(pWaitInfo->hWaitHandle);
            CloseHandle(pWaitInfo->hProcHandle);

            delete pWaitInfo;
        }

        // ahh.... the moment we've all been waiting for - actually saving
        // the accumulated counters!!!

        m_MainBlock.AggregateDeadProcCounters(pBlock);

        // UnInit() the block, which will release our handle on the shared
        // memory, and delete it

        pBlock->UnInit();

        delete pBlock;

NextItem:

        // get ready for the next item

        m_MainBlock.UnLock();

        EnterCriticalSection(&m_csProcsDied);
    }

    LeaveCriticalSection(&m_csProcsDied);

    // if we're no longer inited, then set m_dwCntProcsDied to 0
    // to signal to the UnInit routine that we're done processing.

    if (m_fInited == FALSE)
        m_dwCntProcsDied = 0;

    return;
}


#endif // _ASP_PERFDEF_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\inc\atq.h ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1994-1997           **/
/**********************************************************************/

/*
    atq.h

    This module contains async thread queue (atq) for async IO and thread
    pool sharing among various services.

    Brief Description of ATQ:
      For description, please see iis\spec\isatq.doc

*/

#ifndef _ATQ_H_
#define _ATQ_H_


#ifdef __cplusplus
extern "C" {
#endif


// Include Standard headers

# include <nt.h>
# include <ntrtl.h>
# include <nturtl.h>
# include <windows.h>
# include <winsock2.h>
# include <mswsock.h>
# include <iscaptrc.h>

#ifndef dllexp
#define dllexp __declspec( dllexport )
#endif


/*++
  ATQ API Overview:

  Global per module:
     AtqInitialize()
     AtqTerminate()

     AtqGetCompletionPort()
     AtqGetInfo()
     AtqSetInfo()

  ATQ Endpoint functions:
     AtqCreateEndpoint()
        AtqStartEndpoint()
        AtqEndpointGetInfo()
        AtqEndpointSetInfo()
        AtqStopCloseEndpoint()
     AtqCloseCloseEndpoint()

     AtqStopAndCloseEndpoint()  <-- soon to be killed
  Per ATQ Context Functions:
     AtqAddAsyncHandle()  <-- for non AcceptEx() sockets

     AtqGetAcceptExAddrs()       <-- for AcceptEx() sockets

     AtqContextSetInfo()

     AtqCloseFileHandle()
     AtqCloseSocket()
     AtqFreeContext()

  Bandwidth Throttler Functions:
     AtqCreateBandwidthInfo()
     AtqFreeBandwidthInfo()
     AtqBandwidthSetInfo()
     AtqBandwidthGetInfo()

  IO Functions:

     AtqReadFile()
     AtqWriteFile()
     AtqReadSocket()
     AtqWriteSocket()
     AtqTransmitFile()
     AtqTransmitFileAndRecv()   <-- gone
     AtqSendAndRecv()           <-- gone

  Utility Functions:

     AtqCreateFileW()           <-- gone
     AtqReadDirChanges()
     AtqPostCompletionStatus()


--*/


/*----------------------------------------------------------
  Registry Parameters used by ATQ during AtqInitialize()
  ATQ loads some of the parameters from
  HKLM\System\CurrentControlSet\Services\InetInfo\Parameters

  Most of these parameters are for INTERNAL ANALYSIS and
   development/testing. Setup should not install values
   for the same. Setup can include values for items marked SETUP.
------------------------------------------------------------*/

// Names

#define ATQ_REG_PER_PROCESSOR_ATQ_THREADS TEXT("MaxPoolThreads")
#define ATQ_REG_POOL_THREAD_LIMIT         TEXT("PoolThreadLimit") // SETUP
#define ATQ_REG_PER_PROCESSOR_CONCURRENCY TEXT("MaxConcurrency")
#define ATQ_REG_THREAD_TIMEOUT            TEXT("ThreadTimeout")
#define ATQ_REG_USE_ACCEPTEX              TEXT("UseAcceptEx")
#define ATQ_REG_USE_KERNEL_APC            TEXT("UseKernelApc")
#define ATQ_REG_MIN_KB_SEC                TEXT("MinFileKbSec")    // SETUP
#define ATQ_REG_LISTEN_BACKLOG            TEXT("ListenBacklog")   // SETUP
#define ATQ_REG_ENABLE_DEBUG_THREADS      TEXT("EnableDebugThreads")
#define ATQ_REG_DISABLE_BACKLOG_MONITOR   TEXT("DisableBacklogMonitor")
#define ATQ_REG_FORCE_TIMEOUT             TEXT("ForceTimeout")

// Default Values

#define ATQ_REG_DEF_PER_PROCESSOR_ATQ_THREADS         (4)
// special value of 0 means that system will determine this dynamically.
#define ATQ_REG_DEF_PER_PROCESSOR_CONCURRENCY         (0)
#define ATQ_REG_DEF_USE_KERNEL_APC                    (1)
#define ATQ_REG_DEF_MAX_UNCONNECTED_ACCEPTEX          (1024)

//
// thread limit settings
//

#define ATQ_REG_MIN_POOL_THREAD_LIMIT                 (64)
#define ATQ_REG_DEF_POOL_THREAD_LIMIT                 (128)
#define ATQ_REG_MAX_POOL_THREAD_LIMIT                 (256)

//
// THREAD_TIMEOUTs are high to prevent async ios from being cancelled
//  when the thread goes away.
//

#define ATQ_REG_DEF_THREAD_TIMEOUT                    (30 * 60)    // thirty minutes
#define ATQ_REG_DEF_USE_ACCEPTEX                      (TRUE)
#define ATQ_REG_DEF_MIN_KB_SEC                        (1000)  // 1000 bytes
#define ATQ_REG_DEF_LISTEN_BACKLOG                    (25)

//
// fake xmit file buffer size
//

#define ATQ_REG_DEF_NONTF_BUFFER_SIZE                 (4096)


/*----------------------------------------------------------
  Global Functions of ATQ module
-----------------------------------------------------------*/

BOOL
AtqInitialize(
    IN DWORD dwFlags
    );

BOOL
AtqTerminate(
    VOID
    );

dllexp
HANDLE
AtqGetCompletionPort();

/*
 *  Sets various context information in Atq Module for global modifications
 *
 *
 *  Bandwidth Throttle:   Sets the throttle level in Bytes/Second.
 *        If INFINITE, then it is assumed that
 *                      there is no throttle value (default)
 *
 *  Max Pool Threads: Sets the maximum number of pool threads Atq will allow
 *        to be created per processor
 *
 *  MaxConcurrency: tells how many threads to permit per processor
 *
 *  Thread Timeout: Indicates how long a thread should be kep alive
 *        waiting on GetQueuedCompletionStatus() before commiting suicide
 *        (in seconds)
 *
 *  Inc/Dec max pool threads: If a server will be doing extended processing
 *        in an ATQ pool thread, they should increase the max pool threads
 *        while the extended processing is occurring.  This prevents starvation
 *        of other requests
 *
 *  AtqMinKbSec: set the assumed minimum KB per second for AtqTransmitFile()
 *        This value is used in calculating the timeout for file transfer
 *        operation
 *
 */

typedef enum _ATQ_INFO {

    AtqBandwidthThrottle = 0,
    AtqExitThreadCallback,
    AtqMaxPoolThreads,    // per processor values
    AtqMaxConcurrency,    // per processor concurrency value
    AtqThreadTimeout,
    AtqUseAcceptEx,       // Use AcceptEx if available
    AtqIncMaxPoolThreads, // Up the max thread count
    AtqDecMaxPoolThreads, // Decrease the max thread count
    AtqMinKbSec,          // Minimum assumed transfer rate for AtqTransmitFile
    AtqBandwidthThrottleMaxBlocked,  // Max number of blocked requests
    AtqMaxThreadLimit,    // absolute maximum number of threads
    AtqAvailableThreads   // Number of available threads
} ATQ_INFO;

//
// ATQ_THREAD_EXIT_CALLBACK
// Type of callback function to be called when an ATQ thread exits so
// that the user of ATQ may clen up thread specific data.
//

typedef
VOID
(*ATQ_THREAD_EXIT_CALLBACK) ( VOID );


dllexp
ULONG_PTR
AtqSetInfo(
    IN ATQ_INFO atqInfo,
    IN ULONG_PTR Data
    );

dllexp
ULONG_PTR
AtqGetInfo(
    IN ATQ_INFO atqInfo
    );



typedef struct _ATQ_STATISTICS {

    DWORD  cAllowedRequests;
    DWORD  cBlockedRequests;
    DWORD  cRejectedRequests;
    DWORD  cCurrentBlockedRequests;
    DWORD  MeasuredBandwidth;

} ATQ_STATISTICS;


dllexp
BOOL AtqGetStatistics( IN OUT ATQ_STATISTICS * pAtqStats);

dllexp
BOOL AtqClearStatistics(VOID);




/*----------------------------------------------------------
  ATQ Endpoint functions
-----------------------------------------------------------*/

//
//  endpoint data
//

typedef enum _ATQ_ENDPOINT_INFO {

    EndpointInfoListenPort,
    EndpointInfoListenSocket,
    EndpointInfoAcceptExOutstanding

}  ATQ_ENDPOINT_INFO;



//
//  ATQ_COMPLETION
//  This is the routine that is called upon IO completion (on
//  error or success).
//
//  Context is the context passed to AtqAddAsyncHandle
//  BytesWritten is the number of bytes written to the file or
//      bytes written to the client's buffer
//  CompletionStatus is the WinError completion code
//  lpOverLapped is the filled in overlap structure
//
//  If the timeout thread times out an IO request, the completion routine
//  will be called by the timeout thread with IOCompletion FALSE and
//  CompletionStatus == ERROR_SEM_TIMEOUT.  The IO request is *still*
//  outstanding in this instance.  Generally it will be completed when
//  the file handle is closed.
//

typedef
VOID
(*ATQ_COMPLETION)(
            IN PVOID        Context,
            IN DWORD        BytesWritten,
            IN DWORD        CompletionStatus,  // Win32 Error code
            IN OVERLAPPED * lpo
            );

//
// Type of callback function to be called when a new connection is established.
//  This function should be defined before including conninfo.hxx
//

typedef
VOID
(*ATQ_CONNECT_CALLBACK) (
                IN SOCKET sNew,
                IN LPSOCKADDR_IN pSockAddr,
                IN PVOID EndpointContext,
                IN PVOID EndpointObject
                );



typedef struct _ATQ_ENDPOINT_CONFIGURATION {

    //
    // Port to listen on.  If 0, system will assign
    //

    USHORT ListenPort;

    //
    // IP address to bind to. 0 (INADDR_ANY) == wildcard.
    //

    DWORD IpAddress;

    DWORD cbAcceptExRecvBuffer;
    DWORD nAcceptExOutstanding;
    DWORD AcceptExTimeout;

    //
    // Callbacks
    //

    ATQ_CONNECT_CALLBACK pfnConnect;
    ATQ_COMPLETION pfnConnectEx;
    ATQ_COMPLETION pfnIoCompletion;

} ATQ_ENDPOINT_CONFIGURATION, *PATQ_ENDPOINT_CONFIGURATION;

dllexp
PVOID
AtqCreateEndpoint(
    IN PATQ_ENDPOINT_CONFIGURATION Configuration,
    IN PVOID EndpointContext
    );

dllexp
BOOL
AtqStartEndpoint(
    IN PVOID Endpoint
    );

dllexp
ULONG_PTR
AtqEndpointGetInfo(
    IN PVOID Endpoint,
    IN ATQ_ENDPOINT_INFO EndpointInfo
    );

dllexp
ULONG_PTR
AtqEndpointSetInfo(
    IN PVOID Endpoint,
    IN ATQ_ENDPOINT_INFO EndpointInfo,
    IN ULONG_PTR Info
    );

dllexp
BOOL
AtqStopEndpoint(
    IN PVOID Endpoint
    );

dllexp
BOOL
AtqCloseEndpoint(
    IN PVOID Endpoint
    );

dllexp
BOOL
AtqStopAndCloseEndpoint(
    IN PVOID Endpoint,
    IN LPTHREAD_START_ROUTINE lpCompletion,
    IN PVOID lpCompletionContext
    );



/*----------------------------------------------------------
  ATQ CONTEXT functions
-----------------------------------------------------------*/

//
//  This is the public portion of an ATQ Context.  It should be treated
//  as read only
//
//  !!! Changes made to this structure should also be made to
//  ATQ_CONTEXT in atqtypes.hxx !!!
//

typedef struct _ATQ_CONTEXT_PUBLIC {

    HANDLE         hAsyncIO;       // handle for async i/o object: socket/file
    OVERLAPPED     Overlapped;     // Overlapped structure used for IO

} ATQ_CONTEXT_PUBLIC, *PATQ_CONTEXT;


dllexp
BOOL
AtqAddAsyncHandle(
    OUT PATQ_CONTEXT * ppatqContext,
    IN  PVOID          EndpointObject,
    IN  PVOID          ClientContext,
    IN  ATQ_COMPLETION pfnCompletion,
    IN  DWORD          TimeOut,
    IN  HANDLE         hAsyncIO
    );


dllexp
VOID
AtqGetAcceptExAddrs(
    IN  PATQ_CONTEXT patqContext,
    OUT SOCKET *     pSock,
    OUT PVOID *      ppvBuff,
    OUT PVOID *      pEndpointContext,
    OUT SOCKADDR * * ppsockaddrLocal,
    OUT SOCKADDR * * ppsockaddrRemote
    );


/*++
  AtqCloseSocket()

  Routine Description:

    Closes the socket in this atq structure if it wasn't
    closed by transmitfile. This function should be called only
    if the embedded handle in AtqContext is a Socket.

  Arguments:

    patqContext - Context whose socket should be closed.
    fShutdown - If TRUE, means we call shutdown and always close the socket.
        Note that if TransmitFile closed the socket, it will have done the
        shutdown for us

  Returns:
    TRUE on success and FALSE if there is a failure.
--*/
dllexp
BOOL
AtqCloseSocket(
    PATQ_CONTEXT patqContext,
    BOOL         fShutdown
    );

/*++
  AtqCloseFileHandle()

  Routine Description:

    Closes the file handle in this atq structure.
    This function should be called only if the embedded handle
    in AtqContext is a file handle.

  Arguments:

  patqContext - Context whose file handle should be closed.

  Returns:
    TRUE on success and FALSE if there is a failure.
--*/
dllexp
BOOL
AtqCloseFileHandle(
    PATQ_CONTEXT patqContext
    );


/*++

   AtqFreeContext()

   Routine Description:

     Frees the context created in AtqAddAsyncHandle.
     Call this after the async handle has been closed and all outstanding
     IO operations have been completed. The context is invalid after this call.
     Call AtqFreeContext() for same context only ONCE.

   Arguments:

    patqContext - Context to free
    fReuseContext - TRUE if this can context can be reused in the context of
        the calling thread.  Should be FALSE if the calling thread will exit
        soon (i.e., isn't an AtqPoolThread).

   Returns:
    None
--*/
dllexp
VOID
AtqFreeContext(
    IN PATQ_CONTEXT   patqContext,
    BOOL              fReuseContext
    );




enum ATQ_CONTEXT_INFO
{
    ATQ_INFO_TIMEOUT = 0,       // Timeout rounded up to ATQ timeout interval
    ATQ_INFO_RESUME_IO,         // resumes IO as is after Timeout
    ATQ_INFO_COMPLETION,        // Completion routine
    ATQ_INFO_COMPLETION_CONTEXT,// Completion context
    ATQ_INFO_BANDWIDTH_INFO,    // Bandwidth Throttling Descriptor
    ATQ_INFO_ABORTIVE_CLOSE,    // do abortive close on closesocket
    ATQ_INFO_FORCE_CLOSE,       // Always close the socket in AtqCloseSocket()
    ATQ_INFO_SET_OVL_OFFSET     // Set the offset in the overlapped structure
};

/*++

  AtqContextSetInfo()

  Routine Description:

    Sets various bits of information for this context

  Arguments:

    patqContext - pointer to ATQ context
    atqInfo     - Data item to set
    data        - New value for item

  Return Value:

    The old value of the parameter

--*/

dllexp
ULONG_PTR
AtqContextSetInfo(
    IN PATQ_CONTEXT   patqContext,
    IN enum ATQ_CONTEXT_INFO  atqInfo,
    IN ULONG_PTR       data
    );




/*----------------------------------------------------------
  ATQ Context IO functions
-----------------------------------------------------------*/

/*++

Routine Description:

    Atq<Operation><Target>()

    <Operation> :=  Read | Write | Transmit
    <Target>    :=  File | Socket

    These functions just setup ATQ context and then call the corresponding
    Win32/WinSock function for submitting an asynchronous IO operation. By
    default the Socket functions support scatter/gather using WSABUF

    These functions are wrappers and should be called instead of the
     correpsonding Win32 API.  The one difference from the Win32 API is TRUE
     is returned if the error ERROR_IO_PENDING occurred, thus clients do not
     need to check for this case.

   The timeout time for the request is calculated by taking the maximum of
     the context's timeout time and bytes transferred based on 1k/second.

Arguments:

    patqContext - pointer to ATQ context
    Everything else as in the Win32 API/WinSock APIs

    NOTES: AtqTransmitFile takes an additional DWORD flags which may contain
        the winsock constants TF_DISCONNECT and TF_REUSE_SOCKET

    AtqReadFile and AtqWriteFile take an optional overlapped structure if
    clients want to have multiple outstanding reads or writes.  If the value
    is NULL, then the overlapped structure from the Atq context is used.

Return Value:

    TRUE if successful, FALSE on error (call GetLastError)
    sets ERROR_NETWORK_BUSY as error when the request needs to be rejected.

--*/

dllexp
BOOL
AtqReadFile(
    IN  PATQ_CONTEXT patqContext,
    IN  LPVOID       lpBuffer,
    IN  DWORD        BytesToRead,
    IN  OVERLAPPED * lpo OPTIONAL
    );

dllexp
BOOL
AtqReadSocket(
    IN  PATQ_CONTEXT patqContext,
    IN  LPWSABUF     pwsaBuffers,
    IN  DWORD        dwBufferCount,
    IN  OVERLAPPED * lpo  OPTIONAL
    );

/*
 *  Code for reading into single buffer will look like the following.
 * {
 *   WSABUF wsaBuf = { (BytesToRead), (lpBuffer)};
 *   fRet = AtqReadSocket( patqContext, &wsaBuf, 1, lpo);
 * }
 */

dllexp
BOOL
AtqWriteFile(
    IN  PATQ_CONTEXT patqContext,
    IN  LPCVOID      lpBuffer,
    IN  DWORD        BytesToWrite,
    IN  OVERLAPPED * lpo OPTIONAL
    );

dllexp
BOOL
AtqWriteSocket(
    IN  PATQ_CONTEXT patqContext,
    IN  LPWSABUF     pwsaBuffers,
    IN  DWORD        dwBufferCount,
    IN  OVERLAPPED * lpo OPTIONAL
    );


dllexp
BOOL
AtqSyncWsaSend(
    IN PATQ_CONTEXT  patqContext,
    IN  LPWSABUF     pwsaBuffers,
    IN  DWORD        dwBufferCount,
    OUT LPDWORD      pcbWritten
    );

// Note: This API always causes the complete file to be sent.
// If you want to change the behaviour store the appropriate offsets
//   in the ATQ_CONTEXT::Overlapped object. Or use AtqTransmitFileEx
dllexp
BOOL
AtqTransmitFile(
    IN  PATQ_CONTEXT            patqContext,
    IN  HANDLE                  hFile,         // File data comes from
    IN  DWORD                   dwBytesInFile, // what is the size of file?
    IN  LPTRANSMIT_FILE_BUFFERS lpTransmitBuffers,
    IN  DWORD                   dwFlags      // TF_DISCONNECT, TF_REUSE_SOCKET
    );

dllexp
BOOL
AtqTransmitFileEx(
    IN  PATQ_CONTEXT            patqContext,
    IN  HANDLE                  hFile,         // File data comes from
    IN  DWORD                   dwBytesInFile, // what is the size of file?
    IN  LPTRANSMIT_FILE_BUFFERS lpTransmitBuffers,
    IN  DWORD                   dwFlags,      // TF_DISCONNECT, TF_REUSE_SOCKET
    IN  OVERLAPPED *            lpo
    );


/*----------------------------------------------------------
  ATQ Utility Functions
-----------------------------------------------------------*/

typedef
VOID
(*ATQ_OPLOCK_COMPLETION)(
            IN PVOID        Context,
            IN DWORD        Status
            );


dllexp
BOOL
AtqReadDirChanges(PATQ_CONTEXT patqContext,
                  LPVOID       lpBuffer,
                  DWORD        BytesToRead,
                  BOOL         fWatchSubDir,
                  DWORD        dwNotifyFilter,
                  OVERLAPPED * lpo );



/*++

  AtqPostCompletionStatus()

  Routine Description:

    Posts a completion status on the completion port queue

    An IO pending error code is treated as a success error code

  Arguments:

    patqContext - pointer to ATQ context
    Everything else as in the Win32 API

    NOTES:

  Return Value:

    TRUE if successful, FALSE on error (call GetLastError)

--*/

dllexp
BOOL
AtqPostCompletionStatus(
    IN     PATQ_CONTEXT patqContext,
    IN     DWORD        BytesTransferred
    );




/*----------------------------------------------------------
  ATQ Utility Functions
-----------------------------------------------------------*/

/*++

   Bandwidth Throttling Support

   The following items are used in the support for bandwidth throttling
--*/

enum ATQ_BANDWIDTH_INFO
{
    ATQ_BW_BANDWIDTH_LEVEL = 0,
    ATQ_BW_MAX_BLOCKED,
    ATQ_BW_STATISTICS,
    ATQ_BW_DESCRIPTION,
};

/*++

  AtqCreateBandwidthInfo()

  Routine Description:

    Allocate and opaque bandwidth descriptor

  Arguments:

    None

  Return Value:

    Pointer to descriptor.  NULL if failed.

--*/
dllexp
PVOID
AtqCreateBandwidthInfo(
    VOID
    );

/*++

  AtqFreeBandwidthInfo()

  Routine Description:

    Triggers the destruction of a bandwidth descriptor

  Arguments:

    pvBandwidthInfo - pointer to valid descriptor

  Return Value:

    TRUE if successful, else FALSE

--*/
dllexp
BOOL
AtqFreeBandwidthInfo(
    IN     PVOID               pvBandwidthInfo
    );

/*++

  AtqBandwidthSetInfo()

  Routine Description:

    Set properties of bandwidth descriptor

  Arguments:

    pvBandwidthInfo - pointer to descriptor
    BWInfo - property to change
    Data - value of property

  Return Value:

    Old value of property

--*/
dllexp
ULONG_PTR
AtqBandwidthSetInfo(
    IN     PVOID               pvBandwidthInfo,
    IN     ATQ_BANDWIDTH_INFO  BwInfo,
    IN     ULONG_PTR            Data
    );

/*++

  AtqBandwidthGetInfo()

  Routine Description:

    Get properties of bandwidth descriptor

  Arguments:

    pvBandwidthInfo - pointer to descriptor
    BWInfo - property to change
    pData - filled in with value of property

  Return Value:

    TRUE if successful, else FALSE

--*/
dllexp
BOOL
AtqBandwidthGetInfo(
    IN     PVOID               pvBandwidthInfo,
    IN     ATQ_BANDWIDTH_INFO  BwInfo,
    OUT    ULONG_PTR *          pData
    );

/*++

  AtqSetSocketOption()

  Routine Description:

    Set socket options. Presently only handles TCP_NODELAY

  Arguments:

    patqContext - pointer to ATQ context
    optName     - name of property to change
    optValue    - value of property to set

  Return Value:

    TRUE if successful, else FALSE

--*/
dllexp
BOOL
AtqSetSocketOption(
    IN     PATQ_CONTEXT     patqContext,
    IN     INT              optName,
    IN     INT              optValue
    );

dllexp
PIIS_CAP_TRACE_INFO
AtqGetCapTraceInfo(
    IN     PATQ_CONTEXT     patqContext
);

#ifdef __cplusplus
}
#endif

#endif // !_ATQ_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\inc\apiutil.h ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    apiutil.h

Abstract:

    Common internet server functions.

Author:

    Murali R. Krishnan  (MuraliK)    15-Sept-1995

Environment:

    Win32 User Mode

Project:

    Common Code for Internet Services

Revision History:

--*/


#ifndef _APIUTIL_HXX_
#define _APIUTIL_HXX_

# ifdef __cplusplus
extern "C"   {
# endif // __cplusplus


#ifdef MIDL_PASS
# define RPC_STATUS   long
#else 
# include <rpc.h>
#endif // MIDL_PASS


//
//  RPC utilities
//

# define PROT_SEQ_NP_OPTIONS_W    L"Security=Impersonation Dynamic False"


extern PVOID
MIDL_user_allocate( IN size_t Size);

extern VOID
MIDL_user_free( IN PVOID pvBlob);


extern RPC_STATUS 
RpcBindHandleForServer( OUT handle_t * pBindingHandle,
                       IN LPWSTR      pwszServerName,
                       IN LPWSTR      pwszInterfaceName,
                       IN LPWSTR      pwszOptions
                       );

extern RPC_STATUS
RpcBindHandleFree( IN OUT handle_t * pBindingHandle);


# ifdef __cplusplus
};
# endif // __cplusplus


#endif // _APIUTIL_HXX_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\inc\dbgutil.h ===
/*++

Copyright (c) 1994-1998 Microsoft Corporation

Module Name:

    dbgutil.h

Abstract:

    This module declares the macros to wrap around DEBUG_PRINTS class
    defined in pudebug.h	
  
    This is the exported header file, that the users are allowed to modify.
    If there are no custom definitions, please use the templated version
    in the root iisrearc\inc\dbgutil.h
 
Author:

    Murali R. Krishnan (MuraliK)    22-Sept-1994

--*/


# ifndef _DBGUTIL_H_
# define _DBGUTIL_H_



// begin_user_modifiable

//
//  Modify the following flags if necessary
//

# define DEFAULT_OUTPUT_FLAGS   ( DbgOutputStderr | DbgOutputKdb )

// end_user_modifiable


//
// include standard debug support
//
// note: define DEFAULT_OUTPUT_FLAGS before including pudebug.h
//

# include <pudebug.h>


// begin_user_modifiable

// Use the default constants from pudebug.h: 0x00000001 to 0x00000100

//
//  Define the debugging constants as bit-flag values
//  Example: # define DEBUG_FOOBAR 0x00010000
//  Note: All debugging bit-values below 0x00001000 are reserved!
// 



// end_user_modifiable


# endif  /* _DBGUTIL_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\inc\comrepl_i.c ===
/* this file contains the actual definitions of */
/* the IIDs and CLSIDs */

/* link this file in with the server and any clients */


/* File created by MIDL compiler version 5.01.0158 */
/* at Wed Jan 27 09:33:39 1999
 */
/* Compiler settings for comrepl.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32, ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
*/
//@@MIDL_FILE_HEADING(  )
#ifdef __cplusplus
extern "C"{
#endif 


#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

const IID IID_ICOMReplicateCatalog = {0x98315904,0x7BE5,0x11d2,{0xAD,0xC1,0x00,0xA0,0x24,0x63,0xD6,0xE7}};


const IID IID_ICOMReplicate = {0x52F25063,0xA5F1,0x11d2,{0xAE,0x04,0x00,0xA0,0x24,0x63,0xD6,0xE7}};


const IID LIBID_COMReplLib = {0x98315905,0x7BE5,0x11d2,{0xAD,0xC1,0x00,0xA0,0x24,0x63,0xD6,0xE7}};


const CLSID CLSID_ReplicateCatalog = {0x8C836AF9,0xFFAC,0x11D0,{0x8E,0xD4,0x00,0xC0,0x4F,0xC2,0xC1,0x7B}};


#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\inc\crypt32l.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1996
//
//  File:       crypt32l.h
//
//  Contents:   Crypt32 static library
//              API Prototypes and Definitions
//
//  APIs:       Crypt32DllMain
//
//  NB: This header is for temporary use only, with the static library
//      form of crypt32 (crypt32l).  It should not be used after IE4 ships,
//      since then the correct action will be to use the dll form of crypt32.
//
//--------------------------------------------------------------------------

#ifndef _CRYPT32L_H_
#define _CRYPT32L_H_


//+-------------------------------------------------------------------------
//
//  Function:  Crypt32DllMain
//
//  Synopsis:  Initialize the Crypt32 static library code
//
//  Returns:   FALSE iff failed
//
//  Notes:
//      If crypt32l.lib is linked with an exe, call
//          Crypt32DllMain( NULL, DLL_PROCESS_ATTACH, NULL)
//      at the start of main() and
//          Crypt32DllMain( NULL, DLL_PROCESS_DETACH, NULL)
//      at the end of main().
//
//      If linking with a dll, call Crypt32DllMain from the dll's init
//      routine, passing it the same args as were passed to the init routine.
//
//--------------------------------------------------------------------------
BOOL
WINAPI
Crypt32DllMain(
    HMODULE hInstDLL,
    DWORD   fdwReason,
    LPVOID  lpvReserved
    );


#endif //_CRYPT32L_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\inc\festrcnv.h ===
// Copyright (c) 1995  Microsoft Corpration
//
// File Name : fechrcnv.h
// Owner     : Tetsuhide Akaishi
// Revision  : 1.00 07/20/'95 Tetsuhide Akaishi
//
# ifndef _FESTRCNV_H_
# define _FESTRCNV_H_

#ifdef __cplusplus
extern "C" {
#endif

// Define for Japanese Code Type
#define CODE_UNKNOWN            0
#define CODE_ONLY_SBCS          0
#define CODE_JPN_JIS            1
#define CODE_JPN_EUC            2
#define CODE_JPN_SJIS           3

// ----------------------------------
// Public Functions for All FarEast
//-----------------------------------

// Convert from PC Code Set to UNIX Code Set
int PC_to_UNIX (
    int CodePage,
    int CodeSet,
    UCHAR *pPC,
    int PC_len,
    UCHAR *pUNIX,
    int UNIX_len
    );

// Convert from UNIX Code Set to PC Code Set
int UNIX_to_PC (
    int CodePage,
    int CodeSet,
    UCHAR *pUNIX,
    int UNIX_len,
    UCHAR *pPC,
    int PC_len
    );

#ifdef __cplusplus
}
#endif

# endif // _FESTRCNV_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\inc\except.h ===
/*-----------------------------------------------------------------------------
Microsoft Denali

Microsoft Confidential
Copyright 1996 Microsoft Corporation. All Rights Reserved.

Component: Exception Handling

File: Except.h

Owner: DGottner

Exception handling macros implemented via Win32 structured exceptions.

Usage:

	TRY
		<try block>

	CATCH (<exception variable>)
		<exception handler>

	END_TRY

To throw an exception use "THROW (<integer expression>)"

To set up a termination handler use:

	TRY
		<try block>

	FINALLY
		<termination handler>

	END_TRY

Rationale:
	This macro package offers a strict subset of Win32 structured exception
	handling. There is no support for exception filters (you have to rethrow
	exceptions), and no support for the resumption model of exception handling
	(though Win32 supports the resumption model)

	The purpose for these restrictions is to make it very easy to rewrite the
	exception handling macros for use with other exception throwing mechanisms.
	It would be easy to use this same interface with C++ exceptions or
	setjmp/longjmp.

	The braces with TRY, CATCH, and FINALLY are optional. Since this code is
	structured using self-bracketing constructs, the braces seem redundant.

	There is no need to declare the datatype of the <exception variable>
	because it is always an integer.
-----------------------------------------------------------------------------*/

#ifndef _EXCEPT_H
#define _EXCEPT_H

// Pragmas --------------------------------------------------------------------
//
// Turn off the "signed/unsigned conversion" warning off because it we get this
// all the time that we throw an HRESULT. (which is a harmless thing)  The
// warning is usually benign anyway.


#pragma warning(disable: 4245)


// Macros ---------------------------------------------------------------------

#define TRY	               __try {
#define CATCH(nException)  } __except(1) { DWORD nException = GetExceptionCode();
#define FINALLY            } __finally {
#define END_TRY            }

#define THROW(nException)  RaiseException(nException, 0, 0, NULL)

#endif // _EXCEPT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\inc\dirmon.h ===
/*===================================================================
Microsoft Denali

Microsoft Confidential.
Copyright 1997 Microsoft Corporation. All Rights Reserved.

Component: Change notification

File: dirmon.h

Owner: cgrant

This is the header file for the CDirMonitor and CDirMonitorEntry classes.
===================================================================*/

#ifndef _DIRMON_H
#define _DIRMON_H

// TODO: We seem to need this pragma to base CDirMonitor on the
//		 CTypedHashTable template from IISRTL. We should find out
//		 why the compiler gives us this warning even if CTypedHashTable
//       is explcitly declared as __declspec(dlliimport)
#pragma warning(disable:4275)

// These declarations are needed to export the template classes from
// IATQ.DLL and import them into other modules.

// These definitions are used to manage the export/import declarations
// for the classes exported from the DIRMON module of ATQ.
#ifndef IATQ_DLLEXP
# ifdef IATQ_DLL_IMPLEMENTATION
#  define IATQ_DLLEXP __declspec(dllexport)
#  ifdef IIATQ_MPLEMENTATION_EXPORT
#   define IATQ_EXPIMP
#  else
#   undef  IATQ_EXPIMP
#  endif
# else // !IATQ_DLL_IMPLEMENTATION
#  define IATQ_DLLEXP __declspec(dllimport)
#  define IATQ_EXPIMP extern
# endif // !IATQ_DLL_IMPLEMENTATION
#endif // !IATQ_DLLEXP

#include "dbgutil.h"
#include "atq.h"
#include "lkrhash.h"

class CDirMonitor;

class IATQ_DLLEXP CDirMonitorEntry
{
friend class CDirMonitor;

public:
    CDirMonitorEntry();
    virtual ~CDirMonitorEntry();
    virtual VOID AddRef(VOID);
    virtual BOOL Release(VOID);    // return FALSE if last release
    virtual BOOL Init(DWORD);

protected:
    DWORD               m_dwNotificationFlags;
    DWORD               m_cPathLength;
    LPSTR               m_pszPath;
    LONG                m_cDirRefCount;	// Ref count for external usage
    LONG                m_cIORefCount;  // Ref count of Asynch IO
    HANDLE              m_hDir;
    PATQ_CONTEXT        m_pAtqCtxt;
    OVERLAPPED          m_ovr;
    DWORD				m_cBufferSize;
    BYTE*               m_pbBuffer;
    CDirMonitor*        m_pDirMonitor;
    BOOL                m_fInCleanup;
    BOOL    			m_fWatchSubdirectories;

    VOID IOAddRef(VOID);
    BOOL IORelease(VOID);	// return FALSE if last release
    BOOL RequestNotification(VOID);
    BOOL Cleanup();
    DWORD GetBufferSize(VOID);
    BOOL SetBufferSize(DWORD);
    BOOL ResetDirectoryHandle(VOID);

    virtual BOOL ActOnNotification(DWORD dwStatus, DWORD dwBytesWritten) = 0;
} ;

inline VOID CDirMonitorEntry::AddRef(VOID)
{
    // This ref count tracks how many templates
    // and applications are depending on this monitor entry.

    InterlockedIncrement( &m_cDirRefCount );

    #ifdef DBG_NOTIFICATION
    DBGPRINTF((DBG_CONTEXT, "[CDirMonitorEntry] After AddRef Ref count %d\n", m_cDirRefCount));
    #endif // DBG_NOTIFICATION
}

inline BOOL CDirMonitorEntry::Release(VOID)
{
    #ifdef DBG_NOTIFICATION
    DBGPRINTF((DBG_CONTEXT, "[CDirMonitorEntry] Before Release Ref count %d.\n", m_cDirRefCount));
    #endif // DBG_NOTIFICATION

    if ( !InterlockedDecrement( &m_cDirRefCount ) )
    {
        // When ref count reaches 0, clean up resources

        BOOL fDeleteNeeded = Cleanup();

        // Cleanup said that we need to handle the deletion,
        // probably because there were no Asynch operations outstanding

        if (fDeleteNeeded)
        {
            delete this;
        }

        return FALSE;
    }

    return TRUE;
}

inline VOID CDirMonitorEntry::IOAddRef(VOID)
{
    // This refcount track how many
    // asynch IO requests are oustanding

    InterlockedIncrement( &m_cIORefCount );
}


inline BOOL CDirMonitorEntry::IORelease(VOID)
{
    if ( !InterlockedDecrement( &m_cIORefCount ) )
    {

        // When both IO and external ref counts reaches 0,
        // free this object

        if (m_cDirRefCount == 0)
        {
            delete this;
        }
        return FALSE;
    }

    return TRUE;
}

inline DWORD CDirMonitorEntry::GetBufferSize(VOID)
{
	return m_cBufferSize;
}

class IATQ_DLLEXP CDirMonitor : public CTypedHashTable<CDirMonitor, CDirMonitorEntry, const char*>
{
public:
    CDirMonitor();
    ~CDirMonitor();
    VOID Lock(VOID);
    VOID Unlock(VOID);
    CDirMonitorEntry *FindEntry(LPCSTR pszPath);
    BOOL Monitor( CDirMonitorEntry *pDME, LPCSTR pszDirectory, BOOL fWatchSubDirectories, DWORD dwFlags);
    BOOL Cleanup(VOID);
    LK_RETCODE InsertEntry( CDirMonitorEntry *pDME );
    LK_RETCODE RemoveEntry( CDirMonitorEntry *pDME );
    LONG   AddRef(VOID);
    LONG   Release(VOID);

	static const char* CDirMonitor::ExtractKey(const CDirMonitorEntry* pDME)
	{
		return pDME->m_pszPath;
	};

	static DWORD CDirMonitor::CalcKeyHash(const char* pszKey)
	{
		return HashStringNoCase(pszKey);
	};

	static bool CDirMonitor::EqualKeys(const char* pszKey1, const char* pszKey2)
	{
		return _stricmp(pszKey1, pszKey2) == 0;
	};

	static void CDirMonitor::AddRefRecord(CDirMonitorEntry* pDME, int nIncr)
	{
	// Don't do automatic ref counting. Handle reference counts explicitly
	}

private:
    CRITICAL_SECTION    m_csLock;
    CRITICAL_SECTION    m_csSerialComplLock;
    LONG                m_cRefs;

    VOID                SerialComplLock();
    VOID                SerialComplUnlock();

public:
    static VOID DirMonitorCompletionFunction( PVOID pCtxt, DWORD dwBytesWritten, DWORD dwCompletionStatus, OVERLAPPED *pOvr );

};
inline LONG CDirMonitor::AddRef()
{
    return InterlockedIncrement( &m_cRefs );
}

inline LONG CDirMonitor::Release()
{
    return InterlockedDecrement( &m_cRefs);
}
inline VOID CDirMonitor::Lock(VOID)
{
    EnterCriticalSection( &m_csLock);
}


inline VOID CDirMonitor::Unlock(VOID)
{
    LeaveCriticalSection( &m_csLock);
}

inline VOID CDirMonitor::SerialComplLock(VOID)
{
    EnterCriticalSection( &m_csSerialComplLock);
}


inline VOID CDirMonitor::SerialComplUnlock(VOID)
{
    LeaveCriticalSection( &m_csSerialComplLock);
}


#endif /* _DIRMON_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\inc\fsconst.h ===
/*++

   Copyright    (c)    1995    Microsoft Corporation

   Module  Name :
        fsconsts.h

   Abstract:
        File System constants  defined here

   Author:

       Murali R. Krishnan    ( MuraliK )   21-Feb-1995

   Environment:

       User Mode -- Win32

   Project:

       Internet Services Common Headers

   Revision History:

--*/

# ifndef _FSCONST_H_
# define _FSCONST_H_

/************************************************************
 *     Include Headers
 ************************************************************/


/************************************************************
 *   Symbolic Constants
 ************************************************************/

//
// Constants that define values for each file system we
//  are going to support for servers
//  FS_ is a prefix for FileSystem  type
//

# define  FS_ERROR          ( 0x00000000)   // initializing value
# define  FS_FAT            ( 0x00000001)
# define  FS_NTFS           ( 0x00000002)
# define  FS_HPFS           ( 0x00000003)
# define  FS_OFS            ( 0x00000004)
# define  FS_CDFS           ( 0x00000005)




# endif // _FSCONST_H_

/************************ End of File ***********************/

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\inc\gntlsapi.h ===
//	gntlsapi.h
//
//	Global NT License Service, for cooperative machine-wide CAL counting

#ifndef _GNTLSAPI_H
#define _GNTLSAPI_H

#ifdef __cplusplus
extern "C"{
#endif 

#include <ntlsapi.h>					// using this for definitions of basic types and structs



//	GNtLicenseRequest
//
//	Same as NtLicenseRequest, except guaranteed not to double count, so will only call NtLicenseRequest
//	once no matter how many times GNtLicenseRequest is called for client/product/version on this machine.
//	Same return values as NtLicenseRequest.

LS_STATUS_CODE LS_API_ENTRY GNtLicenseRequestW(
	LPWSTR			ProductName,
    LPWSTR			Version,
    LS_HANDLE FAR*	LicenseHandle,
    NT_LS_DATA*		NtData);			// supports NT_LS_USER_NAME only

LS_STATUS_CODE LS_API_ENTRY GNtLicenseRequestA(
	LPSTR			ProductName,
    LPSTR			Version,
    LS_HANDLE FAR*	LicenseHandle,
    NT_LS_DATA*		NtData);			// supports NT_LS_USER_NAME only

#ifdef UNICODE
#define GNtLicenseRequest	GNtLicenseRequestW
#else
#define GNtLicenseRequest	GNtLicenseRequestA
#endif // !UNICODE


//	GNtLicenseExemption
//
//	By calling GNtLicenseExemption, the caller is saying that this client/product/version is exempt
//	from requiring (further) licenses on this machine. The caller may or may not have already consumed
//	license(s) for this client/product/version by calling directly to NtLicenseRequest.  The exemption is
//	released by calling GNtLSFreeHandle.  This is ref counted, so must call GNtLSFreeHandle for each call
//	to GNtLicenseExemption.
//	Returns LS_SUCCESS or LS_BAD_ARG.

LS_STATUS_CODE LS_API_ENTRY GNtLicenseExemptionW(
	LPWSTR			ProductName,
    LPWSTR			Version,
    LS_HANDLE FAR*	LicenseHandle,
    NT_LS_DATA*		NtData);			// supports NT_LS_USER_NAME only

LS_STATUS_CODE LS_API_ENTRY GNtLicenseExemptionA(
	LPSTR			ProductName,
    LPSTR			Version,
    LS_HANDLE FAR*	LicenseHandle,
    NT_LS_DATA*		NtData);			// supports NT_LS_USER_NAME only

#ifdef UNICODE
#define GNtLicenseExemption	GNtLicenseExemptionW
#else
#define GNtLicenseExemption	GNtLicenseExemptionA
#endif // !UNICODE


//	GNtLSFreeHandle
//
//	Same as NtLSFreeHandle, except works for LicenseHandles returned from both GNtLicenseRequest and
//	GNtLicenseExemption.  Do not call this with a LicenseHandle returned by NtLicenseRequest.
//	Same return values as NtLSFreeHandle.

LS_STATUS_CODE LS_API_ENTRY GNtLSFreeHandle(
    LS_HANDLE		LicenseHandle);



//
//	function pointer typedefs
//

typedef LS_STATUS_CODE
    (LS_API_ENTRY * PGNT_LICENSE_REQUEST_W)(
    LPWSTR      ProductName,
    LPWSTR      Version,
    LS_HANDLE   *LicenseHandle,
    NT_LS_DATA  *NtData);

typedef LS_STATUS_CODE
    (LS_API_ENTRY * PGNT_LICENSE_REQUEST_A)(
    LPSTR       ProductName,
    LPSTR       Version,
    LS_HANDLE   *LicenseHandle,
    NT_LS_DATA  *NtData);

#ifdef UNICODE
#define PGNT_LICENSE_REQUEST	PGNT_LICENSE_REQUEST_W
#else
#define PGNT_LICENSE_REQUEST	PGNT_LICENSE_REQUEST_A
#endif // !UNICODE


typedef LS_STATUS_CODE
    (LS_API_ENTRY * PGNT_LICENSE_EXEMPTION_W)(
    LPWSTR      ProductName,
    LPWSTR      Version,
    LS_HANDLE   *LicenseHandle,
    NT_LS_DATA  *NtData);

typedef LS_STATUS_CODE
    (LS_API_ENTRY * PGNT_LICENSE_EXEMPTION_A)(
    LPSTR       ProductName,
    LPSTR       Version,
    LS_HANDLE   *LicenseHandle,
    NT_LS_DATA  *NtData);

#ifdef UNICODE
#define PGNT_LICENSE_EXEMPTION	PGNT_LICENSE_EXEMPTION_W
#else
#define PGNT_LICENSE_EXEMPTION	PGNT_LICENSE_EXEMPTION_A
#endif // !UNICODE


typedef LS_STATUS_CODE
    (LS_API_ENTRY * PGNT_LS_FREE_HANDLE)(
    LS_HANDLE   LicenseHandle );



#ifdef __cplusplus
}
#endif 

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\inc\iadm.h ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1997                **/
/**********************************************************************/

/*
    iadm.h

    Defunct file.
    All clients should use iadmw.h.
*/
#include <iadmw.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\inc\ftpd.h ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1993                **/
/**********************************************************************/

/*
    ftpd.h

    This file contains constants & type definitions shared between the
    FTPD Service, Installer, and Administration UI.


    FILE HISTORY:
        KeithMo     10-Mar-1993 Created.
        MuraliK     23-Oct-1995 Imported for new ftp server
        MuraliK     14-Dec-1995 service name imported from inetinfo.h

*/


#ifndef _FTPD_H_
#define _FTPD_H_

#ifdef __cplusplus
extern "C"
{
#endif  // _cplusplus

# include <inetinfo.h>

//
//  Name of directory annotation file.  If this file exists
//  in the target directory of a CWD command, its contents
//  will be sent to the user as part of the CWD reply.
//

#define FTPD_ANNOTATION_FILE_A           "~FTPSVC~.CKM"
#define FTPD_ANNOTATION_FILE_W          L"~FTPSVC~.CKM"


//
//  Configuration parameters registry key.
//
# define FTPD_SERVICE_KEY_A  \
  "System\\CurrentControlSet\\Services\\" ## FTPD_SERVICE_NAME_A

# define FTPD_SERVICE_KEY_W \
  L"System\\CurrentControlSet\\Services\\" ## FTPD_SERVICE_NAME_W

#define FTPD_PARAMETERS_KEY_A   FTPD_SERVICE_KEY_A ## "\\Parameters"

#define FTPD_PARAMETERS_KEY_W   FTPD_SERVICE_KEY_W ## L"\\Parameters"


//
//  Performance key.
//

#define FTPD_PERFORMANCE_KEY_A  FTPD_SERVICE_KEY_A ## "\\Performance"

#define FTPD_PERFORMANCE_KEY_W  FTPD_SERVICE_KEY_W ## L"\\Performance"


//
//  If this registry key exists under the Parameters key,
//  it is used to validate FTPSVC access.  Basically, all new users
//  must have sufficient privilege to open this key before they
//  may access the FTP Server.
//

#define FTPD_ACCESS_KEY_A                "AccessCheck"
#define FTPD_ACCESS_KEY_W               L"AccessCheck"


//
//  Configuration value names.
//

#define FTPD_ALLOW_ANONYMOUS_A           "AllowAnonymous"
#define FTPD_ALLOW_ANONYMOUS_W          L"AllowAnonymous"

#define FTPD_ALLOW_GUEST_ACCESS_A        "AllowGuestAccess"
#define FTPD_ALLOW_GUEST_ACCESS_W       L"AllowGuestAccess"

#define FTPD_ANONYMOUS_ONLY_A            "AnonymousOnly"
#define FTPD_ANONYMOUS_ONLY_W           L"AnonymousOnly"

#define FTPD_MSDOS_DIR_OUTPUT_A          "MsdosDirOutput"
#define FTPD_MSDOS_DIR_OUTPUT_W         L"MsdosDirOutput"

#define FTPD_SHOW_4_DIGIT_YEAR_A          "Show4DigitYear"
#define FTPD_SHOW_4_DIGIT_YEAR_W         L"Show4DigitYear"

#define FTPD_GREETING_MESSAGE_A          "GreetingMessage"
#define FTPD_GREETING_MESSAGE_W         L"GreetingMessage"

#define FTPD_EXIT_MESSAGE_A              "ExitMessage"
#define FTPD_EXIT_MESSAGE_W             L"ExitMessage"

#define FTPD_MAX_CLIENTS_MSG_A           "MaxClientsMessage"
#define FTPD_MAX_CLIENTS_MSG_W          L"MaxClientsMessage"

#define FTPD_DEBUG_FLAGS_A               "DebugFlags"
#define FTPD_DEBUG_FLAGS_W              L"DebugFlags"

#define FTPD_ANNOTATE_DIRS_A             "AnnotateDirectories"
#define FTPD_ANNOTATE_DIRS_W            L"AnnotateDirectories"

#define FTPD_LOWERCASE_FILES_A           "LowercaseFiles"
#define FTPD_LOWERCASE_FILES_W          L"LowercaseFiles"

#define FTPD_LISTEN_BACKLOG_A            "ListenBacklog"
#define FTPD_LISTEN_BACKLOG_W           L"ListenBacklog"

#define FTPD_ENABLE_LICENSING_A          "EnableLicensing"
#define FTPD_ENABLE_LICENSING_W         L"EnableLicensing"

#define FTPD_DEFAULT_LOGON_DOMAIN_A      "DefaultLogonDomain"
#define FTPD_DEFAULT_LOGON_DOMAIN_W     L"DefaultLogonDomain"

#define FTPD_NO_EXTENDED_FILENAME_A      "DisableExtendedCharFileNames"
#define FTPD_NO_EXTENDED_FILENAME_W     L"DisableExtendedCharFileNames"

#define FTPD_ENABLE_CONN_TO_3RDIP_A      "EnableDataConnTo3rdIP"
#define FTPD_ENABLE_CONN_TO_3RDIP_W     L"EnableDataConnTo3rdIP"

#define FTPD_ENABLE_PASV_FROM_3RDIP_A    "EnablePasvConnFrom3rdIP"
#define FTPD_ENABLE_PASV_FROM_3RDIP_W   L"EnablePasvConnFrom3rdIP"

#define FTPD_BANNER_MESSAGE_A            "BannerMessage"
#define FTPD_BANNER_MESSAGE_W           L"BannerMessage"

#define FTPD_USER_ISOLATION_A            "UserIsolationMode"
#define FTPD_USER_ISOLATION_W           L"UserIsolationMode"

#define FTPD_LOG_IN_UTF_8_A              "FtpLogInUtf8"
#define FTPD_LOG_IN_UTF_8_W             L"FtpLogInUtf8"

#define FTPD_DS_CACHE_REFRESH_A          "DsCacheRefreshSecs"
#define FTPD_DS_CACHE_REFRESH_W         L"DsCacheRefreshSecs"

#define FTPD_MAX_ACCEPT_EVENTS_A         "MaxPassiveAcceptEvents"
#define FTPD_MAX_ACCEPT_EVENTS_W        L"MaxPassiveAcceptEvents"

//
//  Name of the LSA Secret Object containing the password for
//  anonymous logon and virtual UNC roots
//

#define FTPD_ANONYMOUS_SECRET_A          "FTPD_ANONYMOUS_DATA"
#define FTPD_ANONYMOUS_SECRET_W         L"FTPD_ANONYMOUS_DATA"

#define FTPD_ROOT_SECRET_A               "FTPD_ROOT_DATA"
#define FTPD_ROOT_SECRET_W              L"FTPD_ROOT_DATA"

//
//  Handle ANSI/UNICODE sensitivity.
//

#ifdef UNICODE

#define FTPD_ANNOTATION_FILE            FTPD_ANNOTATION_FILE_W
#define FTPD_PARAMETERS_KEY             FTPD_PARAMETERS_KEY_W
#define FTPD_PERFORMANCE_KEY            FTPD_PERFORMANCE_KEY_W
#define FTPD_ACCESS_KEY                 FTPD_ACCESS_KEY_W
#define FTPD_ALLOW_ANONYMOUS            FTPD_ALLOW_ANONYMOUS_W
#define FTPD_ALLOW_GUEST_ACCESS         FTPD_ALLOW_GUEST_ACCESS_W
#define FTPD_ANONYMOUS_ONLY             FTPD_ANONYMOUS_ONLY_W
#define FTPD_MSDOS_DIR_OUTPUT           FTPD_MSDOS_DIR_OUTPUT_W
#define FTPD_SHOW_4_DIGIT_YEAR          FTPD_SHOW_4_DIGIT_YEAR_W
#define FTPD_GREETING_MESSAGE           FTPD_GREETING_MESSAGE_W
#define FTPD_EXIT_MESSAGE               FTPD_EXIT_MESSAGE_W
#define FTPD_MAX_CLIENTS_MSG            FTPD_MAX_CLIENTS_MSG_W
#define FTPD_DEBUG_FLAGS                FTPD_DEBUG_FLAGS_W
#define FTPD_ANNOTATE_DIRS              FTPD_ANNOTATE_DIRS_W
#define FTPD_ANONYMOUS_SECRET           FTPD_ANONYMOUS_SECRET_W
#define FTPD_LOWERCASE_FILES            FTPD_LOWERCASE_FILES_W
#define FTPD_LISTEN_BACKLOG             FTPD_LISTEN_BACKLOG_W
#define FTPD_ENABLE_LICENSING           FTPD_ENABLE_LICENSING_W
#define FTPD_DEFAULT_LOGON_DOMAIN       FTPD_DEFAULT_LOGON_DOMAIN_W
#define FTPD_NO_EXTENDED_FILENAME       FTPD_NO_EXTENDED_FILENAME_W
#define FTPD_ENABLE_CONN_TO_3RDIP       FTPD_ENABLE_CONN_TO_3RDIP_W
#define FTPD_ENABLE_PASV_FROM_3RDIP     FTPD_ENABLE_PASV_FROM_3RDIP_W
#define FTPD_BANNER_MESSAGE             FTPD_BANNER_MESSAGE_W
#define FTPD_USER_ISOLATION             FTPD_USER_ISOLATION_W
#define FTPD_LOG_IN_UTF_8               FTPD_LOG_IN_UTF_8_W
#define FTPD_DS_CACHE_REFRESH           FTPD_DS_CACHE_REFRESH_W
#define FTPD_MAX_ACCEPT_EVENTS          FTPD_MAX_ACCEPT_EVENTS_W

#else   // !UNICODE

#define FTPD_ANNOTATION_FILE            FTPD_ANNOTATION_FILE_A
#define FTPD_PARAMETERS_KEY             FTPD_PARAMETERS_KEY_A
#define FTPD_PERFORMANCE_KEY            FTPD_PERFORMANCE_KEY_A
#define FTPD_ACCESS_KEY                 FTPD_ACCESS_KEY_A
#define FTPD_ANONYMOUS_ONLY             FTPD_ANONYMOUS_ONLY_A
#define FTPD_ALLOW_ANONYMOUS            FTPD_ALLOW_ANONYMOUS_A
#define FTPD_ALLOW_GUEST_ACCESS         FTPD_ALLOW_GUEST_ACCESS_A
#define FTPD_MSDOS_DIR_OUTPUT           FTPD_MSDOS_DIR_OUTPUT_A
#define FTPD_SHOW_4_DIGIT_YEAR          FTPD_SHOW_4_DIGIT_YEAR_A
#define FTPD_GREETING_MESSAGE           FTPD_GREETING_MESSAGE_A
#define FTPD_EXIT_MESSAGE               FTPD_EXIT_MESSAGE_A
#define FTPD_MAX_CLIENTS_MSG            FTPD_MAX_CLIENTS_MSG_A
#define FTPD_DEBUG_FLAGS                FTPD_DEBUG_FLAGS_A
#define FTPD_ANNOTATE_DIRS              FTPD_ANNOTATE_DIRS_A
#define FTPD_ANONYMOUS_SECRET           FTPD_ANONYMOUS_SECRET_A
#define FTPD_LOWERCASE_FILES            FTPD_LOWERCASE_FILES_A
#define FTPD_LISTEN_BACKLOG             FTPD_LISTEN_BACKLOG_A
#define FTPD_ENABLE_LICENSING           FTPD_ENABLE_LICENSING_A
#define FTPD_DEFAULT_LOGON_DOMAIN       FTPD_DEFAULT_LOGON_DOMAIN_A
#define FTPD_NO_EXTENDED_FILENAME       FTPD_NO_EXTENDED_FILENAME_A
#define FTPD_ENABLE_CONN_TO_3RDIP       FTPD_ENABLE_CONN_TO_3RDIP_A
#define FTPD_ENABLE_PASV_FROM_3RDIP     FTPD_ENABLE_PASV_FROM_3RDIP_A
#define FTPD_BANNER_MESSAGE             FTPD_BANNER_MESSAGE_A
#define FTPD_USER_ISOLATION             FTPD_USER_ISOLATION_A
#define FTPD_LOG_IN_UTF_8               FTPD_LOG_IN_UTF_8_A
#define FTPD_DS_CACHE_REFRESH           FTPD_DS_CACHE_REFRESH_A
#define FTPD_MAX_ACCEPT_EVENTS          FTPD_MAX_ACCEPT_EVENTS_A


#endif  // UNICODE



//
// Structures for APIs
//

typedef struct _FTP_USER_INFO
{
    DWORD    idUser;          //  User id
    LPWSTR   pszUser;         //  User name
    BOOL     fAnonymous;      //  TRUE if the user is logged on as
                              //  Anonymous, FALSE otherwise
    DWORD    inetHost;        //  Host Address
    DWORD    tConnect;        //  User Connection Time (elapsed seconds)

} FTP_USER_INFO, * LPFTP_USER_INFO;

typedef struct _FTP_STATISTICS_0
{
    LARGE_INTEGER TotalBytesSent;
    LARGE_INTEGER TotalBytesReceived;
    DWORD         TotalFilesSent;
    DWORD         TotalFilesReceived;
    DWORD         CurrentAnonymousUsers;
    DWORD         CurrentNonAnonymousUsers;
    DWORD         TotalAnonymousUsers;
    DWORD         TotalNonAnonymousUsers;
    DWORD         MaxAnonymousUsers;
    DWORD         MaxNonAnonymousUsers;
    DWORD         CurrentConnections;
    DWORD         MaxConnections;
    DWORD         ConnectionAttempts;
    DWORD         LogonAttempts;
    DWORD         ServiceUptime;
    DWORD         TotalAllowedRequests;
    DWORD         TotalRejectedRequests;
    DWORD         TotalBlockedRequests;
    DWORD         CurrentBlockedRequests;
    DWORD         MeasuredBandwidth;
    DWORD         TimeOfLastClear;

} FTP_STATISTICS_0, * LPFTP_STATISTICS_0;


//
// API Prototypes
//

NET_API_STATUS
I_FtpEnumerateUsers(
    IN LPWSTR   pszServer OPTIONAL,
    OUT LPDWORD  lpdwEntriesRead,
    OUT LPFTP_USER_INFO * Buffer
    );

NET_API_STATUS
I_FtpDisconnectUser(
    IN LPWSTR  pszServer OPTIONAL,
    IN DWORD   idUser
    );

NET_API_STATUS
I_FtpQueryVolumeSecurity(
    IN LPWSTR  pszServer OPTIONAL,
    OUT LPDWORD lpdwReadAccess,
    OUT LPDWORD lpdwWriteAccess
    );

NET_API_STATUS
I_FtpSetVolumeSecurity(
    IN LPWSTR pszServer OPTIONAL,
    IN DWORD  dwReadAccess,
    IN DWORD  dwWriteAccess
    );

NET_API_STATUS
I_FtpQueryStatistics(
    IN LPWSTR pszServer OPTIONAL,
    IN DWORD Level,
    OUT LPBYTE * Buffer
    );

NET_API_STATUS
I_FtpClearStatistics(
    IN LPWSTR pszServer OPTIONAL
    );

#ifdef __cplusplus
}
#endif  // _cplusplus


#endif  // _FTPD_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\inc\gip.h ===
/*===================================================================
Microsoft Denali

Microsoft Confidential.
Copyright 1997 Microsoft Corporation. All Rights Reserved.

Component: Global Interface Pointer API support

File: Gip.h

Owner: DmitryR

This is the GIP header file.
===================================================================*/

#ifndef __GIP_H__
#define __GIP_H__

/*===================================================================
  Includes
===================================================================*/

#include <irtldbg.h>
#include <objidl.h>

/*===================================================================
  Defines
===================================================================*/

#define NULL_GIP_COOKIE  0xFFFFFFFF

/*===================================================================
  C  G l o b a l  I n t e r f a c e  A P I
===================================================================*/

class dllexp CGlobalInterfaceAPI
{
private:
    // Is inited?
    DWORD m_fInited : 1;
    
    // Pointer to the COM object
    IGlobalInterfaceTable *m_pGIT;

public:
    CGlobalInterfaceAPI();
    ~CGlobalInterfaceAPI();

    HRESULT Init();
    HRESULT UnInit();

    // inlines for the real API calls:
    HRESULT Register(IUnknown *pUnk, REFIID riid, DWORD *pdwCookie);
    HRESULT Get(DWORD dwCookie, REFIID riid, void **ppv);
    HRESULT Revoke(DWORD dwCookie);
    
public:
#ifdef _DEBUG
	inline void AssertValid() const
    {
        IRTLASSERT(m_fInited);
        IRTLASSERT(m_pGIT);
    }
#else
	inline void AssertValid() const {}
#endif
};

/*===================================================================
  CGlobalInterfaceAPI inlines
===================================================================*/

inline HRESULT CGlobalInterfaceAPI::Register(
    IUnknown *pUnk,
    REFIID riid,
    DWORD *pdwCookie)
{
    IRTLASSERT(m_fInited);
    IRTLASSERT(m_pGIT);
    return m_pGIT->RegisterInterfaceInGlobal(pUnk, riid, pdwCookie);
}

inline HRESULT CGlobalInterfaceAPI::Get(
    DWORD dwCookie,
    REFIID riid, 
    void **ppv)
{
    IRTLASSERT(m_fInited);
    IRTLASSERT(m_pGIT);
    return m_pGIT->GetInterfaceFromGlobal(dwCookie, riid, ppv);
}
        
inline HRESULT CGlobalInterfaceAPI::Revoke(
    DWORD dwCookie)
{
    IRTLASSERT(m_fInited);
    IRTLASSERT(m_pGIT);
    return m_pGIT->RevokeInterfaceFromGlobal(dwCookie);
}

/*===================================================================
  Globals
===================================================================*/

extern CGlobalInterfaceAPI g_GIPAPI;

#endif // __GIP_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\inc\hashfn.h ===
/*++

   Copyright    (c)    1998-2000    Microsoft Corporation

   Module  Name :
       hashfn.h

   Abstract:
       Declares and defines a collection of overloaded hash functions.
       It is strongly suggested that you use these functions with LKRhash.

   Author:
       George V. Reilly      (GeorgeRe)     06-Jan-1998

   Environment:
       Win32 - User Mode

   Project:
       Internet Information Server RunTime Library

   Revision History:

--*/

#ifndef __HASHFN_H__
#define __HASHFN_H__


#ifndef __HASHFN_NO_NAMESPACE__
namespace HashFn {
#endif // !__HASHFN_NO_NAMESPACE__

// Produce a scrambled, randomish number in the range 0 to RANDOM_PRIME-1.
// Applying this to the results of the other hash functions is likely to
// produce a much better distribution, especially for the identity hash
// functions such as Hash(char c), where records will tend to cluster at
// the low end of the hashtable otherwise.  LKRhash applies this internally
// to all hash signatures for exactly this reason.

inline DWORD
HashScramble(DWORD dwHash)
{
    // Here are 10 primes slightly greater than 10^9
    //  1000000007, 1000000009, 1000000021, 1000000033, 1000000087,
    //  1000000093, 1000000097, 1000000103, 1000000123, 1000000181.

    // default value for "scrambling constant"
    const DWORD RANDOM_CONSTANT = 314159269UL;
    // large prime number, also used for scrambling
    const DWORD RANDOM_PRIME =   1000000007UL;

    return (RANDOM_CONSTANT * dwHash) % RANDOM_PRIME ;
}


// Faster scrambling function suggested by Eric Jacobsen

inline DWORD
HashRandomizeBits(DWORD dw)
{
	return (((dw * 1103515245 + 12345) >> 16)
            | ((dw * 69069 + 1) & 0xffff0000));
}


// Small prime number used as a multiplier in the supplied hash functions
const DWORD HASH_MULTIPLIER = 101;

#undef HASH_SHIFT_MULTIPLY

#ifdef HASH_SHIFT_MULTIPLY
# define HASH_MULTIPLY(dw)   (((dw) << 7) - (dw))
#else
# define HASH_MULTIPLY(dw)   ((dw) * HASH_MULTIPLIER)
#endif

// Fast, simple hash function that tends to give a good distribution.
// Apply HashScramble to the result if you're using this for something
// other than LKRhash.

inline DWORD
HashString(
    const char* psz,
    DWORD       dwHash = 0)
{
    // force compiler to use unsigned arithmetic
    const unsigned char* upsz = (const unsigned char*) psz;

    for (  ;  *upsz;  ++upsz)
        dwHash = HASH_MULTIPLY(dwHash)  +  *upsz;

    return dwHash;
}


// Unicode version of above

inline DWORD
HashString(
    const wchar_t* pwsz,
    DWORD          dwHash = 0)
{
    for (  ;  *pwsz;  ++pwsz)
        dwHash = HASH_MULTIPLY(dwHash)  +  *pwsz;

    return dwHash;
}


// Quick-'n'-dirty case-insensitive string hash function.
// Make sure that you follow up with _stricmp or _mbsicmp.  You should
// also cache the length of strings and check those first.  Caching
// an uppercase version of a string can help too.
// Again, apply HashScramble to the result if using with something other
// than LKRhash.
// Note: this is not really adequate for MBCS strings.

inline DWORD
HashStringNoCase(
    const char* psz,
    DWORD       dwHash = 0)
{
    const unsigned char* upsz = (const unsigned char*) psz;

    for (  ;  *upsz;  ++upsz)
        dwHash = HASH_MULTIPLY(dwHash)
                     +  (*upsz & 0xDF);  // strip off lowercase bit

    return dwHash;
}


// Unicode version of above

inline DWORD
HashStringNoCase(
    const wchar_t* pwsz,
    DWORD          dwHash = 0)
{
    for (  ;  *pwsz;  ++pwsz)
        dwHash = HASH_MULTIPLY(dwHash)  +  (*pwsz & 0xFFDF);

    return dwHash;
}


// HashBlob returns the hash of a blob of arbitrary binary data.
// 
// Warning: HashBlob is generally not the right way to hash a class object.
// Consider:
//     class CFoo {
//     public:
//         char   m_ch;
//         double m_d;
//         char*  m_psz;
//     };
// 
//     inline DWORD Hash(const CFoo& rFoo)
//     { return HashBlob(&rFoo, sizeof(CFoo)); }
//
// This is the wrong way to hash a CFoo for two reasons: (a) there will be
// a 7-byte gap between m_ch and m_d imposed by the alignment restrictions
// of doubles, which will be filled with random data (usually non-zero for
// stack variables), and (b) it hashes the address (rather than the
// contents) of the string m_psz.  Similarly,
// 
//     bool operator==(const CFoo& rFoo1, const CFoo& rFoo2)
//     { return memcmp(&rFoo1, &rFoo2, sizeof(CFoo)) == 0; }
//
// does the wrong thing.  Much better to do this:
//
//     DWORD Hash(const CFoo& rFoo)
//     {
//         return HashString(rFoo.m_psz,
//                           HASH_MULTIPLIER * Hash(rFoo.m_ch)
//                               +  Hash(rFoo.m_d));
//     }
//
// Again, apply HashScramble if using with something other than LKRhash.

inline DWORD
HashBlob(
    const void* pv,
    size_t      cb,
    DWORD       dwHash = 0)
{
    LPBYTE pb = static_cast<LPBYTE>(const_cast<void*>(pv));

    while (cb-- > 0)
        dwHash = HASH_MULTIPLY(dwHash)  +  *pb++;

    return dwHash;
}



//
// Overloaded hash functions for all the major builtin types.
// Again, apply HashScramble to result if using with something other than
// LKRhash.
//

inline DWORD Hash(const char* psz)
{ return HashString(psz); }

inline DWORD Hash(const unsigned char* pusz)
{ return HashString(reinterpret_cast<const char*>(pusz)); }

inline DWORD Hash(const signed char* pssz)
{ return HashString(reinterpret_cast<const char*>(pssz)); }

inline DWORD Hash(const wchar_t* pwsz)
{ return HashString(pwsz); }

inline DWORD
Hash(
    const GUID* pguid,
    DWORD       dwHash = 0)
{
    
    return * reinterpret_cast<DWORD*>(const_cast<GUID*>(pguid)) + dwHash;
}

// Identity hash functions: scalar values map to themselves
inline DWORD Hash(char c)
{ return c; }

inline DWORD Hash(unsigned char uc)
{ return uc; }

inline DWORD Hash(signed char sc)
{ return sc; }

inline DWORD Hash(short sh)
{ return sh; }

inline DWORD Hash(unsigned short ush)
{ return ush; }

inline DWORD Hash(int i)
{ return i; }

inline DWORD Hash(unsigned int u)
{ return u; }

inline DWORD Hash(long l)
{ return l; }

inline DWORD Hash(unsigned long ul)
{ return ul; }

inline DWORD Hash(float f)
{
    // be careful of rounding errors when computing keys
    union {
        float f;
        DWORD dw;
    } u;
    u.f = f;
    return u.dw;
}

inline DWORD Hash(double dbl)
{
    // be careful of rounding errors when computing keys
    union {
        double dbl;
        DWORD  dw[2];
    } u;
    u.dbl = dbl;
    return u.dw[0] * HASH_MULTIPLIER  +  u.dw[1];
}

#ifndef __HASHFN_NO_NAMESPACE__
}
#endif // !__HASHFN_NO_NAMESPACE__

#endif // __HASHFN_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\inc\iadmext.h ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1997-1999           **/
/**********************************************************************/

/*
    iadmext.h

    This module contains the interface for extensions to the IISADMIN service.


    FILE HISTORY:
    7/8/97      michth      created
*/

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __iadmext_h__
#define __iadmext_h__

#ifdef __cplusplus
extern "C"{
#endif



/* header files for imported files */
#include "unknwn.h"
#include "objidl.h"
#include "ocidl.h"

/*
The Main Interface. All extensions must support this interface.
*/
// {51DFE970-F6F2-11d0-B9BD-00A0C922E750}
DEFINE_GUID(IID_IADMEXT, 0x51dfe970, 0xf6f2, 0x11d0, 0xb9, 0xbd, 0x0, 0xa0, 0xc9, 0x22, 0xe7, 0x50);

/*
InProcess COM Registration. All extensions must write a subkey name by the
CLSID for the above interface under this key in the Registry.
*/
#define IISADMIN_EXTENSIONS_REG_KEYA          "SOFTWARE\\Microsoft\\InetStp\\Extensions"
#define IISADMIN_EXTENSIONS_REG_KEYW          L"SOFTWARE\\Microsoft\\InetStp\\Extensions"
#define IISADMIN_EXTENSIONS_REG_KEY           TEXT("SOFTWARE\\Microsoft\\InetStp\\Extensions")

/*
DCOM Registration. CLSIDS for the DCOM interface provided by these extensions will
be written to this key and ID by IISADMIN as a multisz property.

This is intended for use by other applications which need to find out what classid's are
registered.
*/

#define IISADMIN_EXTENSIONS_CLSID_MD_KEYA      "LM/IISADMIN/EXTENSIONS/DCOMCLSIDS"
#define IISADMIN_EXTENSIONS_CLSID_MD_KEYW      L"LM/IISADMIN/EXTENSIONS/DCOMCLSIDS"
#define IISADMIN_EXTENSIONS_CLSID_MD_KEY      TEXT("LM/IISADMIN/EXTENSIONS/DCOMCLSIDS")
#define IISADMIN_EXTENSIONS_CLSID_MD_ID       MD_IISADMIN_EXTENSIONS

#ifndef __IADMEXT_INTERFACE_DEFINED__
#define __IADMEXT_INTERFACE_DEFINED__


EXTERN_C const IID IID_IADMEXT;

#if defined(__cplusplus) && !defined(CINTERFACE)

    interface IADMEXT : public IUnknown
    {
    public:
        //
        // All methods below will be called under a thread which has called
        // CoInitializeEx(NULL, COINIT_MULTITHREADED).
        //
        // The IMSAdminBase Object will be available during all of these calls.
        //

        //
        // Initialize will be called by IISADMIN when it initializes.
        //
        virtual HRESULT STDMETHODCALLTYPE Initialize(void) = 0;

        //
        // EnumDcomCLSIDs will be called by IISADMIN when it initializes,
        // and the returned CLSIDs will be written to the metabase at
        // the path IISADMIN_EXTENSIONS_CLSID_MD_KEY.
        //
        virtual HRESULT STDMETHODCALLTYPE EnumDcomCLSIDs(
            /* [size_is][out] */ CLSID *pclsidDcom,
            /* [in] */ DWORD dwEnumIndex) = 0;

        //
        // Terminate will be called by IISADMIN when it terminates.
        //
        virtual HRESULT STDMETHODCALLTYPE Terminate(void) = 0;

    };

#else   /* C style interface */
#endif
#endif  /* __IADMEXT_INTERFACE_DEFINED__ */

#ifdef __cplusplus
}
#endif

#endif // __iadmext_h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\inc\iis64.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    iis64.h

Abstract:

    This include file contains public macros and type definitions to ease
    the port from 32- to 64-bits.

Author:

    Keith Moore (keithmo)        20-Jan-1998

Revision History:

--*/


#ifndef _IIS64_H_
#define _IIS64_H_


#ifdef __cplusplus
extern "C" {
#endif  // _cplusplus


//
// Ensure the size_t type is properly defined.
//

#ifndef _SIZE_T_DEFINED
#ifdef  _WIN64
typedef unsigned __int64 size_t;
#else
typedef unsigned int     size_t;
#endif
#define _SIZE_T_DEFINED
#endif


//
// The DIFF macro should be used around an expression involving pointer
// subtraction. The expression passed to DIFF is cast to a size_t type,
// allowing the result to be easily assigned to any 32-bit variable or
// passed to a function expecting a 32-bit argument.
//

#define DIFF(x)     ((size_t)(x))


//
// Macros for mapping "native" Win32 HANDLEs <-> Winsock SOCKETs.
//
// N.B. These are temporary and will (hopefully) go away after the
//      public WINSOCK2.H header file is made Win64 compliant.
//

#define HANDLE_TO_SOCKET(h) ((SOCKET)(h))
#define SOCKET_TO_HANDLE(s) ((HANDLE)(s))


#ifdef __cplusplus
}   // extern "C"
#endif  // _cplusplus


#endif  // _IIS64_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\inc\iiscblob.h ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    iiscblob.h

Abstract:

    This include file contains the definition of the IIS_CRYPTO_BLOB
    structure and associated constants.

Author:

    Keith Moore (keithmo)        25-Feb-1997

Revision History:

--*/


#ifndef _IISCBLOB_H_
#define _IISCBLOB_H_

#ifndef _IIS_CRYPTO_BLOB_DEFINED
#define _IIS_CRYPTO_BLOB_DEFINED
#ifdef __cplusplus
extern "C" {
#endif  // __cplusplus

//
// Structure signatures for the various blob types.
//

#define SALT_BLOB_SIGNATURE         ((DWORD)'bScI')
#define KEY_BLOB_SIGNATURE          ((DWORD)'bKcI')
#define PUBLIC_KEY_BLOB_SIGNATURE   ((DWORD)'bPcI')
#define DATA_BLOB_SIGNATURE         ((DWORD)'bDcI')
#define HASH_BLOB_SIGNATURE         ((DWORD)'bHcI')
#define CLEARTEXT_BLOB_SIGNATURE    ((DWORD)'bCcI')

//
// A crypto blob. Note that this is just the header for the blob.
// The details of the blob internals are private to the IIS Crypto
// package.
//

typedef struct _IIS_CRYPTO_BLOB {

    //
    // The structure signature for this blob.
    //

    DWORD BlobSignature;

    //
    // The total length of this blob, NOT including this header.
    //

    DWORD BlobDataLength;


#if defined(MIDL_PASS)

    //
    // Define the raw data so that MIDL can marshal correctly.
    //

    [size_is(BlobDataLength)] unsigned char BlobData[*];

#endif  // MIDL_PASS

} IIS_CRYPTO_BLOB;


#if defined(MIDL_PASS)

// BUGBUG: Hackety Hack: midl doesn't know about __unaligned, so we don't
// tell it.  At some point, midl should be fixed to know about it.  Also,
// we should ultimately stop using __unaligned

typedef IIS_CRYPTO_BLOB *PIIS_CRYPTO_BLOB;

#else

typedef IIS_CRYPTO_BLOB UNALIGNED64 *PIIS_CRYPTO_BLOB;

#endif  // MIDL_PASS




#ifdef __cplusplus
}   // extern "C"
#endif  // __cplusplus
#endif  // _IIS_CRYPTO_BLOB_DEFINED


#endif  // _IISCBLOB_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\inc\iisinfo.h ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    iisinfo.h

Abstract:

    This file contains the IIS v3 admin APIs.


Author:

    Johnson Apacible (johnsona) June-11-1996

--*/

#ifndef _IISINFO_H_
#define _IISINFO_H_

#include "inetinfo.h"

#ifdef __cplusplus
extern "C"
{
#endif  // _cplusplus

NET_API_STATUS
NET_API_FUNCTION
InitW3CounterStructure(
    IN LPWSTR        pszServer OPTIONAL,
	IN OUT LPDWORD   lpcbTotalRequired
	);

NET_API_STATUS
NET_API_FUNCTION
CollectW3PerfData(
    IN LPWSTR        pszServer OPTIONAL,
	IN LPWSTR        lpValueName,
    OUT LPBYTE       lppData,
    IN OUT LPDWORD   lpcbTotalBytes,
    OUT LPDWORD      lpNumObjectTypes 
	);

NET_API_STATUS
NET_API_FUNCTION
W3QueryStatistics2(
    IN LPWSTR   pszServer OPTIONAL,
    IN DWORD    Level,
    IN DWORD    dwInstance,
    IN DWORD    dwReserved,
    OUT LPBYTE * Buffer
    );

NET_API_STATUS
NET_API_FUNCTION
W3ClearStatistics2(
    IN LPWSTR pszServer OPTIONAL,
    IN DWORD  dwInstance
    );


NET_API_STATUS
NET_API_FUNCTION
FtpQueryStatistics2(
    IN LPWSTR   pszServer OPTIONAL,
    IN DWORD    dwLevel,
    IN DWORD    dwInstance,
    IN DWORD    dwReserved,
    OUT LPBYTE * Buffer
    );

NET_API_STATUS
NET_API_FUNCTION
FtpClearStatistics2(
    IN LPWSTR pszServer OPTIONAL,
    IN DWORD  dwInstance
    );

NET_API_STATUS
NET_API_FUNCTION
IISEnumerateUsers(
    IN LPWSTR                   pszServer OPTIONAL,
    IN DWORD                    dwLevel,
    IN DWORD                    dwServiceId,
    IN DWORD                    dwInstance,
    OUT LPDWORD                 nRead,
    OUT LPBYTE *                Buffer
    );

NET_API_STATUS
NET_API_FUNCTION
IISDisconnectUser(
    IN LPWSTR                   pszServer OPTIONAL,
    IN DWORD                    dwServiceId,
    IN DWORD                    dwInstance,
    IN DWORD                    dwIdUser
    );

typedef W3_USER_INFO    IIS_USER_INFO_1, *LPIIS_USER_INFO_1;

#ifdef __cplusplus
}
#endif  // _cplusplus

#endif  // _IISINFO_H_


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\inc\iisver.h ===
//
// Apps' rc files should look like this:
//
/**
#include "windows.h"
#include "ntverp.h"

#define VER_FILEDESCRIPTION_STR         "File Description"
#define VER_INTERNALNAME_STR            "Internal Name"
#define VER_ORIGINALFILENAME_STR        "Original Name"
#define VER_FILETYPE                    VFT_DLL

#include "iisver.h"
#include "common.ver"

**/
//
// Apps may also define, in the same place as the other defines, above:
// VER_FILESUBTYPE
// VER_IISPRODUCTNAME_STR
// VER_IISMAJORVERSION
// VER_IISMINORVERSION
// VER_IISPRODUCTVERSION_STR
// VER_IISPRODUCTVERSION
// VER_IISPRODUCTBUILD
//

#ifndef VER_FILEDESCRIPTION_STR
#define VER_FILEDESCRIPTION_STR     "IIS Executable"
#endif

#ifndef VER_INTERNALNAME_STR
#define VER_INTERNALNAME_STR        "IISFile.exe"
#endif

#ifndef VER_ORIGINALFILENAME_STR
#define VER_ORIGINALFILENAME_STR    VER_INTERNALNAME_STR
#endif

#ifdef VER_PRODUCTNAME_STR
#undef VER_PRODUCTNAME_STR
#endif

#ifndef VER_IISPRODUCTNAME_STR
#define VER_IISPRODUCTNAME_STR      "Internet Information Services"
#endif

#define VER_PRODUCTNAME_STR         VER_IISPRODUCTNAME_STR

#ifndef VER_IISMAJORVERSION
#if _IIS_5_1
#define VER_IISMAJORVERSION         5
#else
#define VER_IISMAJORVERSION         6
#endif
#endif

#ifndef VER_IISMINORVERSION
#if _IIS_5_1
#define VER_IISMINORVERSION         1
#else
#define VER_IISMINORVERSION         0
#endif
#endif

#ifdef VER_PRODUCTVERSION_STR
#undef VER_PRODUCTVERSION_STR
#endif

#define VER_IISPRODUCTVERSION_STRING   VER_PRODUCTVERSION_MAJORMINOR1(VER_IISMAJORVERSION, VER_IISMINORVERSION)

#define VER_IISPRODUCTVERSION_STR2(x,y) VER_IISPRODUCTVERSION_STRING "." VER_BPAD #x "." #y
#define VER_IISPRODUCTVERSION_STR1(x,y) VER_IISPRODUCTVERSION_STR2(x, y)
#define VER_PRODUCTVERSION_STR          VER_IISPRODUCTVERSION_STR1(VER_PRODUCTBUILD, VER_PRODUCTBUILD_QFE)

//
// VER_PRODUCTBUILD is defined by ntverp.h as the nt build number
//

#ifndef VER_PRODUCTBUILD
#define VER_PRODUCTBUILD            0984
#endif

#ifndef VER_IISPRODUCTBUILD
#define VER_IISPRODUCTBUILD         VER_PRODUCTBUILD
#endif

#ifdef VER_PRODUCTVERSION
#undef VER_PRODUCTVERSION
#endif

#ifndef VER_IISPRODUCTVERSION
#define VER_IISPRODUCTVERSION          VER_IISMAJORVERSION,VER_IISMINORVERSION,VER_IISPRODUCTBUILD,VER_PRODUCTBUILD_QFE
#endif

#define VER_PRODUCTVERSION          VER_IISPRODUCTVERSION

#ifndef VER_FILEVERSION
#define VER_FILEVERSION             VER_PRODUCTVERSION
#endif

#ifndef VER_FILETYPE
#define VER_FILETYPE                VFT_DLL
#endif

#ifndef VER_FILESUBTYPE
#define VER_FILESUBTYPE             VFT2_UNKNOWN
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\inc\iiscrypt.h ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    iiscrypt.h

Abstract:

    This include file contains public constants, type definitions, and
    function prototypes for the IIS cryptographic routines.

Author:

    Keith Moore (keithmo)        02-Dec-1996

Revision History:

--*/


#ifndef _IISCRYPT_H_
#define _IISCRYPT_H_


//
// Get the dependent include files.
//

#include <windows.h>
#include <wincrypt.h>
#include <iiscblob.h>


//
// Define API decoration, should we ever move these routines into a DLL.
//

#define IIS_CRYPTO_API


#ifdef __cplusplus
extern "C" {
#endif  // __cplusplus


//
// A NULL crypto handle, mysteriously absent from wincrypt.h.
//

#define CRYPT_NULL 0


//
// Initialization/termination functions.
//

IIS_CRYPTO_API
HRESULT
WINAPI
IISCryptoInitialize(
    VOID
    );

IIS_CRYPTO_API
HRESULT
WINAPI
IISCryptoTerminate(
    VOID
    );



// special function for programatically disabling encryption for French case
VOID
WINAPI
IISCryptoInitializeOverride(
    BOOL flag
    );



//
// Memory allocation functions. Clients may provide their own
// definitions of these routines if necessary.
//

PVOID
WINAPI
IISCryptoAllocMemory(
    IN DWORD Size
    );

VOID
WINAPI
IISCryptoFreeMemory(
    IN PVOID Buffer
    );


//
// Container functions.
//

IIS_CRYPTO_API
HRESULT
WINAPI
IISCryptoGetStandardContainer(
    OUT HCRYPTPROV * phProv,
    IN DWORD dwAdditionalFlags
    );

IIS_CRYPTO_API
HRESULT
WINAPI
IISCryptoGetStandardContainer2(
    OUT HCRYPTPROV * phProv
    );

IIS_CRYPTO_API
HRESULT
WINAPI
IISCryptoGetContainerByName(
    OUT HCRYPTPROV * phProv,
    IN LPTSTR pszContainerName,
    IN DWORD dwAdditionalFlags,
    IN BOOL fApplyAcl
    );

IIS_CRYPTO_API
HRESULT
WINAPI
IISCryptoDeleteStandardContainer(
    IN DWORD dwAdditionalFlags
    );

IIS_CRYPTO_API
HRESULT
WINAPI
IISCryptoDeleteContainerByName(
    IN LPTSTR pszContainerName,
    IN DWORD dwAdditionalFlags
    );

IIS_CRYPTO_API
HRESULT
WINAPI
IISCryptoCloseContainer(
    IN HCRYPTPROV hProv
    );


//
// Key manipulation functions.
//
IIS_CRYPTO_API
HRESULT
WINAPI
IISCryptoGetKeyDeriveKey2(
    OUT HCRYPTKEY * phKey,
    IN HCRYPTPROV hProv,
    IN HCRYPTHASH hHash
    );

IIS_CRYPTO_API
HRESULT
WINAPI
IISCryptoGetKeyExchangeKey(
    OUT HCRYPTKEY * phKey,
    IN HCRYPTPROV hProv
    );

IIS_CRYPTO_API
HRESULT
WINAPI
IISCryptoGetSignatureKey(
    OUT HCRYPTKEY * phKey,
    IN HCRYPTPROV hProv
    );

IIS_CRYPTO_API
HRESULT
WINAPI
IISCryptoGenerateSessionKey(
    OUT HCRYPTKEY * phKey,
    IN HCRYPTPROV hProv
    );

IIS_CRYPTO_API
HRESULT
WINAPI
IISCryptoCloseKey(
    IN HCRYPTKEY hKey
    );


//
// Hash manipulation functions.
//

IIS_CRYPTO_API
HRESULT
WINAPI
IISCryptoCreateHash(
    OUT HCRYPTHASH * phHash,
    IN HCRYPTPROV hProv
    );

IIS_CRYPTO_API
HRESULT
WINAPI
IISCryptoDestroyHash(
    IN HCRYPTHASH hHash
    );

IIS_CRYPTO_API
HRESULT
WINAPI
IISCryptoHashData(
    IN HCRYPTHASH hHash,
    IN PVOID pBuffer,
    IN DWORD dwBufferLength
    );

IIS_CRYPTO_API
HRESULT
WINAPI
IISCryptoHashSessionKey(
    IN HCRYPTHASH hHash,
    IN HCRYPTKEY hSessionKey
    );


//
// Generic blob manipulators.
//

#define IISCryptoGetBlobLength(p) (((p)->BlobDataLength) + sizeof(*(p)))

IIS_CRYPTO_API
HRESULT
WINAPI
IISCryptoReadBlobFromRegistry(
    OUT PIIS_CRYPTO_BLOB * ppBlob,
    IN HKEY hRegistryKey,
    IN LPCTSTR pszRegistryValueName
    );

IIS_CRYPTO_API
HRESULT
WINAPI
IISCryptoWriteBlobToRegistry(
    IN PIIS_CRYPTO_BLOB pBlob,
    IN HKEY hRegistryKey,
    IN LPCTSTR pszRegistryValueName
    );

IIS_CRYPTO_API
BOOL
WINAPI
IISCryptoIsValidBlob(
    IN PIIS_CRYPTO_BLOB pBlob
    );

IIS_CRYPTO_API
BOOL
WINAPI
IISCryptoIsValidBlob2(
    IN PIIS_CRYPTO_BLOB pBlob
    );

IIS_CRYPTO_API
HRESULT
WINAPI
IISCryptoFreeBlob(
    IN PIIS_CRYPTO_BLOB pBlob
    );

IIS_CRYPTO_API
HRESULT
WINAPI
IISCryptoFreeBlob2(
    IN PIIS_CRYPTO_BLOB pBlob
    );

IIS_CRYPTO_API
BOOL
WINAPI
IISCryptoCompareBlobs(
    IN PIIS_CRYPTO_BLOB pBlob1,
    IN PIIS_CRYPTO_BLOB pBlob2
    );

IIS_CRYPTO_API
HRESULT
WINAPI
IISCryptoCloneBlobFromRawData(
    OUT PIIS_CRYPTO_BLOB * ppBlob,
    IN PBYTE pRawBlob,
    IN DWORD dwRawBlobLength
    );

IIS_CRYPTO_API
HRESULT
WINAPI
IISCryptoCloneBlobFromRawData2(
    OUT PIIS_CRYPTO_BLOB * ppBlob,
    IN PBYTE pRawBlob,
    IN DWORD dwRawBlobLength
    );

IIS_CRYPTO_API
HRESULT
WINAPI
IISCryptoCreateCleartextBlob(
    OUT PIIS_CRYPTO_BLOB * ppBlob,
    IN PVOID pBlobData,
    IN DWORD dwBlobDataLength
    );


//
// Key blob functions.
//

IIS_CRYPTO_API
HRESULT
WINAPI
IISCryptoExportSessionKeyBlob(
    OUT PIIS_CRYPTO_BLOB * ppSessionKeyBlob,
    IN HCRYPTPROV hProv,
    IN HCRYPTKEY hSessionKey,
    IN HCRYPTKEY hKeyExchangeKey
    );

IIS_CRYPTO_API
HRESULT
WINAPI
IISCryptoExportSessionKeyBlob2(
    OUT PIIS_CRYPTO_BLOB * ppSessionKeyBlob,
    IN HCRYPTPROV hProv,
    IN HCRYPTKEY hSessionKey,
    IN LPSTR pszPasswd
    );

IIS_CRYPTO_API
HRESULT
WINAPI
IISCryptoImportSessionKeyBlob(
    OUT HCRYPTKEY * phSessionKey,
    IN PIIS_CRYPTO_BLOB pSessionKeyBlob,
    IN HCRYPTPROV hProv,
    IN HCRYPTKEY hSignatureKey
    );

IIS_CRYPTO_API
HRESULT
WINAPI
IISCryptoImportSessionKeyBlob2(
    OUT HCRYPTKEY * phSessionKey,
    IN PIIS_CRYPTO_BLOB pSessionKeyBlob,
    IN HCRYPTPROV hProv,
    IN LPSTR pszPasswd
    );

IIS_CRYPTO_API
HRESULT
WINAPI
IISCryptoExportPublicKeyBlob(
    OUT PIIS_CRYPTO_BLOB * ppPublicKeyBlob,
    IN HCRYPTPROV hProv,
    IN HCRYPTKEY hPublicKey
    );

IIS_CRYPTO_API
HRESULT
WINAPI
IISCryptoImportPublicKeyBlob(
    OUT HCRYPTKEY * phPublicKey,
    IN PIIS_CRYPTO_BLOB pPublicKeyBlob,
    IN HCRYPTPROV hProv
    );


//
// Data blob functions.
//

IIS_CRYPTO_API
HRESULT
WINAPI
IISCryptoEncryptDataBlob(
    OUT PIIS_CRYPTO_BLOB * ppDataBlob,
    IN PVOID pBuffer,
    IN DWORD dwBufferLength,
    IN DWORD dwRegType,
    IN HCRYPTPROV hProv,
    IN HCRYPTKEY hSessionKey
    );

IIS_CRYPTO_API
HRESULT
WINAPI
IISCryptoEncryptDataBlob2(
    OUT PIIS_CRYPTO_BLOB * ppDataBlob,
    IN PVOID pBuffer,
    IN DWORD dwBufferLength,
    IN DWORD dwRegType,
    IN HCRYPTPROV hProv,
    IN HCRYPTKEY hSessionKey
    );

IIS_CRYPTO_API
HRESULT
WINAPI
IISCryptoDecryptDataBlob(
    OUT PVOID * ppBuffer,
    OUT LPDWORD pdwBufferLength,
    OUT LPDWORD pdwRegType,
    IN PIIS_CRYPTO_BLOB pDataBlob,
    IN HCRYPTPROV hProv,
    IN HCRYPTKEY hSessionKey,
    IN HCRYPTKEY hSignatureKey
    );

IIS_CRYPTO_API
HRESULT
WINAPI
IISCryptoDecryptDataBlob2(
    OUT PVOID * ppBuffer,
    OUT LPDWORD pdwBufferLength,
    OUT LPDWORD pdwRegType,
    IN PIIS_CRYPTO_BLOB pDataBlob,
    IN HCRYPTPROV hProv,
    IN HCRYPTKEY hSessionKey
    );


//
// Hash blob functions.
//

IIS_CRYPTO_API
HRESULT
WINAPI
IISCryptoExportHashBlob(
    OUT PIIS_CRYPTO_BLOB * ppHashBlob,
    IN HCRYPTHASH hHash
    );

IIS_CRYPTO_API
HRESULT
WINAPI
IISCryptoCacheHashLength(
    IN HCRYPTPROV hProv
    );



//
// Simple check function for some special French case
//

BOOL
WINAPI
IISCryptoIsClearTextSignature (
    IIS_CRYPTO_BLOB UNALIGNED *pBlob
    );


#ifdef __cplusplus
}   // extern "C"
#endif  // __cplusplus


#endif  // _IISCRYPT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\inc\iiscryptp.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    iiscryptp.h

Abstract:

    This include file contains private constants, type definitions, and
    function prototypes shared between the various IIS cryptographic
    routines but *not* available to "normal" code.

Author:

    Keith Moore (keithmo)        23-Apr-1998

Revision History:

--*/


#ifndef _IISCRYPTP_H_
#define _IISCRYPTP_H_


//
// Get the dependent include files.
//

#include <iiscrypt.h>


#ifdef __cplusplus
extern "C" {
#endif  // __cplusplus


//
// Global lock manipulators.
//

IIS_CRYPTO_API
VOID
WINAPI
IcpAcquireGlobalLock(
    VOID
    );

IIS_CRYPTO_API
VOID
WINAPI
IcpReleaseGlobalLock(
    VOID
    );


#ifdef __cplusplus
}   // extern "C"
#endif  // __cplusplus


#endif  // _IISCRYPTP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\inc\imdp.h ===
#ifndef _MDP_IMD_
#define _MDP_IMD_

#include "unknwn.h"
#include "objidl.h"
#include "ocidl.h"

// {F1E08563-1598-11d1-9D77-00C04FD7BF3E}
DEFINE_GUID(CLSID_MDPCOM, 0xf1e08563, 0x1598, 0x11d1, 0x9d, 0x77, 0x0, 0xc0, 0x4f, 0xd7, 0xbf, 0x3e);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\inc\imd.h ===
#include "rpc.h"
#include "rpcndr.h"
#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __imd_h__
#define __imd_h__

#ifdef __cplusplus
extern "C"{
#endif

/* Forward Declarations */

#ifndef __IMDCOM_FWD_DEFINED__
#define __IMDCOM_FWD_DEFINED__
typedef interface IMDCOM IMDCOM;
#endif  /* __IMDCOM_FWD_DEFINED__ */


#ifndef __IMDCOMSINKA_FWD_DEFINED__
#define __IMDCOMSINKA_FWD_DEFINED__
typedef interface IMDCOMSINKA IMDCOMSINKA;
#endif  /* __IMDCOMSINKA_FWD_DEFINED__ */


#ifndef __IMDCOMSINKW_FWD_DEFINED__
#define __IMDCOMSINKW_FWD_DEFINED__
typedef interface IMDCOMSINKW IMDCOMSINKW;
#endif  /* __IMDCOMSINKW_FWD_DEFINED__ */


/* header files for imported files */
#include "unknwn.h"
#include "objidl.h"
#include "ocidl.h"
#include "mddef.h"

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * );

/****************************************
 * Generated header for interface: __MIDL__intf_0000
 * at Tue Jun 24 13:13:57 1997
 * using MIDL 3.00.44
 ****************************************/
/* [local] */


#ifndef _MD_IMD_
#define _MD_IMD_
/*
The Main Interface
*/
DEFINE_GUID(CLSID_MDCOM, 0xba4e57f0, 0xfab6, 0x11cf, 0x9d, 0x1a, 0x0, 0xaa, 0x0, 0xa7, 0xd, 0x51);
DEFINE_GUID(IID_IMDCOM, 0xc1aa48c0, 0xfacc, 0x11cf, 0x9d, 0x1a, 0x0, 0xaa, 0x0, 0xa7, 0xd, 0x51);
DEFINE_GUID(IID_IMDCOM2, 0x08dbe811, 0x20e5, 0x4e09, 0xb0, 0xc8, 0xcf, 0x87, 0x19, 0x0c, 0xe6, 0x0e);
DEFINE_GUID(IID_IMDCOM3, 0xa53fd4aa, 0x6f0d, 0x4fe3, 0x9f, 0x81, 0x2b, 0x56, 0x19, 0x7b, 0x47, 0xdb);
DEFINE_GUID(IID_NSECOM, 0x4810a750, 0x4318, 0x11d0, 0xa5, 0xc8, 0x0, 0xa0, 0xc9, 0x22, 0xe7, 0x52);
DEFINE_GUID(CLSID_NSEPMCOM, 0x05dc3bb0, 0x4337, 0x11d0, 0xa5, 0xc8, 0x0, 0xa0, 0xc9, 0x22, 0xe7, 0x52);
DEFINE_GUID(CLSID_MDCOMEXE, 0xba4e57f1, 0xfab6, 0x11cf, 0x9d, 0x1a, 0x0, 0xaa, 0x0, 0xa7, 0xd, 0x51);
#define GETMDCLSID(IsService) CLSID_MDCOM
DEFINE_GUID(CLSID_MDPCOM, 0xf1e08563, 0x1598, 0x11d1, 0x9d, 0x77, 0x0, 0xc0, 0x4f, 0xd7, 0xbf, 0x3e);
#define GETMDPCLSID(IsService) CLSID_MDPCOM
#define IID_IMDCOMSINK       IID_IMDCOMSINK_A
DEFINE_GUID(IID_IMDCOMSINK_A, 0x5229ea36, 0x1bdf, 0x11d0, 0x9d, 0x1c, 0x0, 0xaa, 0x0, 0xa7, 0xd, 0x51);
DEFINE_GUID(IID_IMDCOMSINK_W, 0x6906ee20, 0xb69f, 0x11d0, 0xb9, 0xb9, 0x0, 0xa0, 0xc9, 0x22, 0xe7, 0x50);


extern RPC_IF_HANDLE __MIDL__intf_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL__intf_0000_v0_0_s_ifspec;

#ifndef __IMDCOM_INTERFACE_DEFINED__
#define __IMDCOM_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IMDCOM
 * at Tue Jun 24 13:13:57 1997
 * using MIDL 3.00.44
 ****************************************/
/* [unique][uuid][object] */



EXTERN_C const IID IID_IMDCOM;

#if defined(__cplusplus) && !defined(CINTERFACE)

    interface IMDCOM : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE ComMDInitialize( void) = 0;

        virtual HRESULT STDMETHODCALLTYPE ComMDTerminate(
            /* [in] */ BOOL bSaveData) = 0;

        virtual HRESULT STDMETHODCALLTYPE ComMDShutdown( void) = 0;

        virtual HRESULT STDMETHODCALLTYPE ComMDAddMetaObjectA(
            /* [in] */ METADATA_HANDLE hMDHandle,
            /* [string][in][unique] */ unsigned char __RPC_FAR *pszMDPath) = 0;

        virtual HRESULT STDMETHODCALLTYPE ComMDAddMetaObjectW(
            /* [in] */ METADATA_HANDLE hMDHandle,
            /* [string][in][unique] */ LPCWSTR pszMDPath) = 0;

        virtual HRESULT STDMETHODCALLTYPE ComMDDeleteMetaObjectA(
            /* [in] */ METADATA_HANDLE hMDHandle,
            /* [string][in][unique] */ unsigned char __RPC_FAR *pszMDPath) = 0;

        virtual HRESULT STDMETHODCALLTYPE ComMDDeleteMetaObjectW(
            /* [in] */ METADATA_HANDLE hMDHandle,
            /* [string][in][unique] */ LPCWSTR pszMDPath) = 0;

        virtual HRESULT STDMETHODCALLTYPE ComMDDeleteChildMetaObjectsA(
            /* [in] */ METADATA_HANDLE hMDHandle,
            /* [string][in][unique] */ unsigned char __RPC_FAR *pszMDPath) = 0;

        virtual HRESULT STDMETHODCALLTYPE ComMDDeleteChildMetaObjectsW(
            /* [in] */ METADATA_HANDLE hMDHandle,
            /* [string][in][unique] */ LPCWSTR pszMDPath) = 0;

        virtual HRESULT STDMETHODCALLTYPE ComMDEnumMetaObjectsA(
            /* [in] */ METADATA_HANDLE hMDHandle,
            /* [string][in][unique] */ unsigned char __RPC_FAR *pszMDPath,
            /* [size_is][out] */ unsigned char __RPC_FAR *pszMDName,
            /* [in] */ DWORD dwMDEnumObjectIndex) = 0;

        virtual HRESULT STDMETHODCALLTYPE ComMDEnumMetaObjectsW(
            /* [in] */ METADATA_HANDLE hMDHandle,
            /* [string][in][unique] */ LPCWSTR pszMDPath,
            /* [size_is][out] */ LPWSTR pszMDName,
            /* [in] */ DWORD dwMDEnumObjectIndex) = 0;

        virtual HRESULT STDMETHODCALLTYPE ComMDCopyMetaObjectA(
            /* [in] */ METADATA_HANDLE hMDSourceHandle,
            /* [string][in][unique] */ unsigned char __RPC_FAR *pszMDSourcePath,
            /* [in] */ METADATA_HANDLE hMDDestHandle,
            /* [string][in][unique] */ unsigned char __RPC_FAR *pszMDDestPath,
            /* [in] */ BOOL bMDOverwriteFlag,
            /* [in] */ BOOL bMDCopyFlag) = 0;

        virtual HRESULT STDMETHODCALLTYPE ComMDCopyMetaObjectW(
            /* [in] */ METADATA_HANDLE hMDSourceHandle,
            /* [string][in][unique] */ LPCWSTR pszMDSourcePath,
            /* [in] */ METADATA_HANDLE hMDDestHandle,
            /* [string][in][unique] */ LPCWSTR pszMDDestPath,
            /* [in] */ BOOL bMDOverwriteFlag,
            /* [in] */ BOOL bMDCopyFlag) = 0;

        virtual HRESULT STDMETHODCALLTYPE ComMDRenameMetaObjectA(
            /* [in] */ METADATA_HANDLE hMDHandle,
            /* [string][in][unique] */ unsigned char __RPC_FAR *pszMDPath,
            /* [string][in][unique] */ unsigned char __RPC_FAR *pszMDNewName) = 0;

        virtual HRESULT STDMETHODCALLTYPE ComMDRenameMetaObjectW(
            /* [in] */ METADATA_HANDLE hMDHandle,
            /* [string][in][unique] */ LPCWSTR pszMDPath,
            /* [string][in][unique] */ LPCWSTR pszMDNewName) = 0;

        virtual HRESULT STDMETHODCALLTYPE ComMDSetMetaDataA(
            /* [in] */ METADATA_HANDLE hMDHandle,
            /* [string][in][unique] */ unsigned char __RPC_FAR *pszMDPath,
            /* [in] */ PMETADATA_RECORD pmdrMDData) = 0;

        virtual HRESULT STDMETHODCALLTYPE ComMDSetMetaDataW(
            /* [in] */ METADATA_HANDLE hMDHandle,
            /* [string][in][unique] */ LPCWSTR pszMDPath,
            /* [in] */ PMETADATA_RECORD pmdrMDData) = 0;

        virtual HRESULT STDMETHODCALLTYPE ComMDGetMetaDataA(
            /* [in] */ METADATA_HANDLE hMDHandle,
            /* [string][in][unique] */ unsigned char __RPC_FAR *pszMDPath,
            /* [out][in] */ PMETADATA_RECORD pmdrMDData,
            /* [out] */ DWORD __RPC_FAR *pdwMDRequiredDataLen) = 0;

        virtual HRESULT STDMETHODCALLTYPE ComMDGetMetaDataW(
            /* [in] */ METADATA_HANDLE hMDHandle,
            /* [string][in][unique] */ LPCWSTR pszMDPath,
            /* [out][in] */ PMETADATA_RECORD pmdrMDData,
            /* [out] */ DWORD __RPC_FAR *pdwMDRequiredDataLen) = 0;

        virtual HRESULT STDMETHODCALLTYPE ComMDDeleteMetaDataA(
            /* [in] */ METADATA_HANDLE hMDHandle,
            /* [string][in][unique] */ unsigned char __RPC_FAR *pszMDPath,
            /* [in] */ DWORD dwMDIdentifier,
            /* [in] */ DWORD dwMDDataType) = 0;

        virtual HRESULT STDMETHODCALLTYPE ComMDDeleteMetaDataW(
            /* [in] */ METADATA_HANDLE hMDHandle,
            /* [string][in][unique] */ LPCWSTR pszMDPath,
            /* [in] */ DWORD dwMDIdentifier,
            /* [in] */ DWORD dwMDDataType) = 0;

        virtual HRESULT STDMETHODCALLTYPE ComMDEnumMetaDataA(
            /* [in] */ METADATA_HANDLE hMDHandle,
            /* [string][in][unique] */ unsigned char __RPC_FAR *pszMDPath,
            /* [out][in] */ PMETADATA_RECORD pmdrMDData,
            /* [in] */ DWORD dwMDEnumDataIndex,
            /* [out] */ DWORD __RPC_FAR *pdwMDRequiredDataLen) = 0;

        virtual HRESULT STDMETHODCALLTYPE ComMDEnumMetaDataW(
            /* [in] */ METADATA_HANDLE hMDHandle,
            /* [string][in][unique] */ LPCWSTR pszMDPath,
            /* [out][in] */ PMETADATA_RECORD pmdrMDData,
            /* [in] */ DWORD dwMDEnumDataIndex,
            /* [out] */ DWORD __RPC_FAR *pdwMDRequiredDataLen) = 0;

        virtual HRESULT STDMETHODCALLTYPE ComMDGetAllMetaDataA(
            /* [in] */ METADATA_HANDLE hMDHandle,
            /* [string][in][unique] */ unsigned char __RPC_FAR *pszMDPath,
            /* [in] */ DWORD dwMDAttributes,
            /* [in] */ DWORD dwMDUserType,
            /* [in] */ DWORD dwMDDataType,
            /* [out] */ DWORD __RPC_FAR *pdwMDNumDataEntries,
            /* [out] */ DWORD __RPC_FAR *pdwMDDataSetNumber,
            /* [in] */ DWORD dwMDBufferSize,
            /* [size_is][out] */ unsigned char __RPC_FAR *pbBuffer,
            /* [out] */ DWORD __RPC_FAR *pdwMDRequiredBufferSize) = 0;

        virtual HRESULT STDMETHODCALLTYPE ComMDGetAllMetaDataW(
            /* [in] */ METADATA_HANDLE hMDHandle,
            /* [string][in][unique] */ LPCWSTR pszMDPath,
            /* [in] */ DWORD dwMDAttributes,
            /* [in] */ DWORD dwMDUserType,
            /* [in] */ DWORD dwMDDataType,
            /* [out] */ DWORD __RPC_FAR *pdwMDNumDataEntries,
            /* [out] */ DWORD __RPC_FAR *pdwMDDataSetNumber,
            /* [in] */ DWORD dwMDBufferSize,
            /* [size_is][out] */ unsigned char __RPC_FAR *pbBuffer,
            /* [out] */ DWORD __RPC_FAR *pdwMDRequiredBufferSize) = 0;

        virtual HRESULT STDMETHODCALLTYPE ComMDDeleteAllMetaDataA(
            /* [in] */ METADATA_HANDLE hMDHandle,
            /* [string][in][unique] */ unsigned char __RPC_FAR *pszMDPath,
            /* [in] */ DWORD dwMDUserType,
            /* [in] */ DWORD dwMDDataType) = 0;

        virtual HRESULT STDMETHODCALLTYPE ComMDDeleteAllMetaDataW(
            /* [in] */ METADATA_HANDLE hMDHandle,
            /* [string][in][unique] */ LPCWSTR pszMDPath,
            /* [in] */ DWORD dwMDUserType,
            /* [in] */ DWORD dwMDDataType) = 0;

        virtual HRESULT STDMETHODCALLTYPE ComMDCopyMetaDataA(
            /* [in] */ METADATA_HANDLE hMDSourceHandle,
            /* [string][in][unique] */ unsigned char __RPC_FAR *pszMDSourcePath,
            /* [in] */ METADATA_HANDLE hMDDestHandle,
            /* [string][in][unique] */ unsigned char __RPC_FAR *pszMDDestPath,
            /* [in] */ DWORD dwMDAttributes,
            /* [in] */ DWORD dwMDUserType,
            /* [in] */ DWORD dwMDDataType,
            /* [in] */ BOOL bMDCopyFlag) = 0;

        virtual HRESULT STDMETHODCALLTYPE ComMDCopyMetaDataW(
            /* [in] */ METADATA_HANDLE hMDSourceHandle,
            /* [string][in][unique] */ LPCWSTR pszMDSourcePath,
            /* [in] */ METADATA_HANDLE hMDDestHandle,
            /* [string][in][unique] */ LPCWSTR pszMDDestPath,
            /* [in] */ DWORD dwMDAttributes,
            /* [in] */ DWORD dwMDUserType,
            /* [in] */ DWORD dwMDDataType,
            /* [in] */ BOOL bMDCopyFlag) = 0;

        virtual HRESULT STDMETHODCALLTYPE ComMDGetMetaDataPathsA(
            /* [in] */ METADATA_HANDLE hMDHandle,
            /* [string][in][unique] */ unsigned char __RPC_FAR *pszMDPath,
            /* [in] */ DWORD dwMDIdentifier,
            /* [in] */ DWORD dwMDDataType,
            /* [in] */ DWORD dwMDBufferSize,
            /* [size_is][out] */ unsigned char __RPC_FAR *pszMDBuffer,
            /* [out] */ DWORD __RPC_FAR *pdwMDRequiredBufferSize) = 0;

        virtual HRESULT STDMETHODCALLTYPE ComMDGetMetaDataPathsW(
            /* [in] */ METADATA_HANDLE hMDHandle,
            /* [string][in][unique] */ LPCWSTR pszMDPath,
            /* [in] */ DWORD dwMDIdentifier,
            /* [in] */ DWORD dwMDDataType,
            /* [in] */ DWORD dwMDBufferSize,
            /* [size_is][out] */ LPWSTR pszMDBuffer,
            /* [out] */ DWORD __RPC_FAR *pdwMDRequiredBufferSize) = 0;

        virtual HRESULT STDMETHODCALLTYPE ComMDOpenMetaObjectA(
            /* [in] */ METADATA_HANDLE hMDHandle,
            /* [string][in][unique] */ unsigned char __RPC_FAR *pszMDPath,
            /* [in] */ DWORD dwMDAccessRequested,
            /* [in] */ DWORD dwMDTimeOut,
            /* [out] */ PMETADATA_HANDLE phMDNewHandle) = 0;

        virtual HRESULT STDMETHODCALLTYPE ComMDOpenMetaObjectW(
            /* [in] */ METADATA_HANDLE hMDHandle,
            /* [string][in][unique] */ LPCWSTR pszMDPath,
            /* [in] */ DWORD dwMDAccessRequested,
            /* [in] */ DWORD dwMDTimeOut,
            /* [out] */ PMETADATA_HANDLE phMDNewHandle) = 0;

        virtual HRESULT STDMETHODCALLTYPE ComMDCloseMetaObject(
            /* [in] */ METADATA_HANDLE hMDHandle) = 0;

        virtual HRESULT STDMETHODCALLTYPE ComMDChangePermissions(
            /* [in] */ METADATA_HANDLE hMDHandle,
            /* [in] */ DWORD dwMDTimeOut,
            /* [in] */ DWORD dwMDAccessRequested) = 0;

        virtual HRESULT STDMETHODCALLTYPE ComMDSaveData(METADATA_HANDLE hMDHandle = 0) = 0;

        virtual HRESULT STDMETHODCALLTYPE ComMDGetHandleInfo(
            /* [in] */ METADATA_HANDLE hMDHandle,
            /* [out] */ PMETADATA_HANDLE_INFO pmdhiInfo) = 0;

        virtual HRESULT STDMETHODCALLTYPE ComMDGetSystemChangeNumber(
            /* [out] */ DWORD __RPC_FAR *pdwSystemChangeNumber) = 0;

        virtual HRESULT STDMETHODCALLTYPE ComMDGetDataSetNumberA(
            /* [in] */ METADATA_HANDLE hMDHandle,
            /* [string][in][unique] */ unsigned char __RPC_FAR *pszMDPath,
            /* [out] */ DWORD __RPC_FAR *pdwMDDataSetNumber) = 0;

        virtual HRESULT STDMETHODCALLTYPE ComMDGetDataSetNumberW(
            /* [in] */ METADATA_HANDLE hMDHandle,
            /* [string][in][unique] */ LPCWSTR pszMDPath,
            /* [out] */ DWORD __RPC_FAR *pdwMDDataSetNumber) = 0;

        virtual HRESULT STDMETHODCALLTYPE ComMDAddRefReferenceData(
            /* [in] */ DWORD dwMDDataTag) = 0;

        virtual HRESULT STDMETHODCALLTYPE ComMDReleaseReferenceData(
            /* [in] */ DWORD dwMDDataTag) = 0;

        virtual HRESULT STDMETHODCALLTYPE ComMDSetLastChangeTimeA(
            /* [in] */ METADATA_HANDLE hMDHandle,
            /* [string][in][unique] */ unsigned char __RPC_FAR *pszMDPath,
            /* [in] */ PFILETIME pftMDLastChangeTime) = 0;

        virtual HRESULT STDMETHODCALLTYPE ComMDSetLastChangeTimeW(
            /* [in] */ METADATA_HANDLE hMDHandle,
            /* [string][in][unique] */ LPCWSTR pszMDPath,
            /* [in] */ PFILETIME pftMDLastChangeTime) = 0;

        virtual HRESULT STDMETHODCALLTYPE ComMDGetLastChangeTimeA(
            /* [in] */ METADATA_HANDLE hMDHandle,
            /* [string][in][unique] */ unsigned char __RPC_FAR *pszMDPath,
            /* [out] */ PFILETIME pftMDLastChangeTime) = 0;

        virtual HRESULT STDMETHODCALLTYPE ComMDGetLastChangeTimeW(
            /* [in] */ METADATA_HANDLE hMDHandle,
            /* [string][in][unique] */ LPCWSTR pszMDPath,
            /* [out] */ PFILETIME pftMDLastChangeTime) = 0;

        virtual HRESULT STDMETHODCALLTYPE ComMDBackupA(
            /* [in] */ METADATA_HANDLE hMDHandle,
            /* [string][in][unique] */ unsigned char __RPC_FAR *pszMDBackupLocation,
            /* [in] */ DWORD dwMDVersion,
            /* [in] */ DWORD dwMDFlags) = 0;

        virtual HRESULT STDMETHODCALLTYPE ComMDBackupW(
            /* [in] */ METADATA_HANDLE hMDHandle,
            /* [string][in][unique] */ LPCWSTR pszMDBackupLocation,
            /* [in] */ DWORD dwMDVersion,
            /* [in] */ DWORD dwMDFlags) = 0;

        virtual HRESULT STDMETHODCALLTYPE ComMDRestoreA(
            /* [string][in][unique] */ unsigned char __RPC_FAR *pszMDBackupLocation,
            /* [in] */ DWORD dwVersion,
            /* [in] */ DWORD dwMDFlags) = 0;

        virtual HRESULT STDMETHODCALLTYPE ComMDRestoreW(
            /* [string][in][unique] */ LPCWSTR pszMDBackupLocation,
            /* [in] */ DWORD dwVersion,
            /* [in] */ DWORD dwMDFlags) = 0;

        virtual HRESULT STDMETHODCALLTYPE ComMDEnumBackupsA(
            /* [size_is (MD_BACKUP_MAX_LEN)][in, out] */ unsigned char __RPC_FAR *pszMDBackupLocation,
            /* [out] */ DWORD *pdwVersion,
            /* [out] */ PFILETIME pftMDBackupTime,
            /* [in] */ DWORD dwMDEnumIndex) = 0;

        virtual HRESULT STDMETHODCALLTYPE ComMDEnumBackupsW(
            /* [size_is (MD_BACKUP_MAX_LEN)][in, out] */ LPWSTR pszMDBackupLocation,
            /* [out] */ DWORD *pdwVersion,
            /* [out] */ PFILETIME pftMDBackupTime,
            /* [in] */ DWORD dwMDEnumIndex) = 0;

        virtual HRESULT STDMETHODCALLTYPE ComMDDeleteBackupA(
            /* [string][in][unique] */ unsigned char __RPC_FAR *pszMDBackupLocation,
            /* [in] */ DWORD dwVersion) = 0;

        virtual HRESULT STDMETHODCALLTYPE ComMDDeleteBackupW(
            /* [string][in][unique] */ LPCWSTR pszMDBackupLocation,
            /* [in] */ DWORD dwVersion) = 0;

    };

#else   /* C style interface */
#endif



#endif  /* __IMDCOM_INTERFACE_DEFINED__ */


#ifndef __IMDCOM2_INTERFACE_DEFINED__
#define __IMDCOM2_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IMDCOM
 * at Tue Jun 24 13:13:57 1997
 * using MIDL 3.00.44
 ****************************************/
/* [unique][uuid][object] */



EXTERN_C const IID IID_IMDCOM2;

#if defined(__cplusplus) && !defined(CINTERFACE)

    interface IMDCOM2 : public IMDCOM
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE ComMDBackupWithPasswdW(
            /* [in] */ METADATA_HANDLE hMDHandle,
            /* [string][in][unique] */ LPCWSTR pszMDBackupLocation,
            /* [in] */ DWORD dwMDVersion,
            /* [in] */ DWORD dwMDFlags,
            /* [string][in][unique] */ LPCWSTR pszPasswd) = 0;

        virtual HRESULT STDMETHODCALLTYPE ComMDRestoreWithPasswdW(
            /* [string][in][unique] */ LPCWSTR pszMDBackupLocation,
            /* [in] */ DWORD dwVersion,
            /* [in] */ DWORD dwMDFlags,
            /* [string][in][unique] */ LPCWSTR pszPasswd) = 0;

        virtual HRESULT STDMETHODCALLTYPE ComMDExportW(
            /* [in] */ METADATA_HANDLE hMDHandle,
            /* [string][in][unique] */ LPCWSTR pszPasswd,
            /* [string][in][unique] */ LPCWSTR pszFileName,
            /* [string][in][unique] */ LPCWSTR pszAbsSourcePath,
            /* [in] */ DWORD dwMDFlags) = 0;

        virtual HRESULT STDMETHODCALLTYPE ComMDImportW(
            /* [in] */ METADATA_HANDLE hMDHandle,
            /* [string][in][unique] */ LPCWSTR pszDestPath,
            /* [string][in][unique] */ LPCWSTR pszKeyType,
            /* [string][in][unique] */ LPCWSTR pszPasswd,
            /* [string][in][unique] */ LPCWSTR pszFileName,
            /* [string][in][unique] */ LPCWSTR pszAbsSourcePath,
            /* [in] */ DWORD dwMDFlags) = 0;

        virtual HRESULT STDMETHODCALLTYPE ComMDRestoreHistoryW(
            /* [unique][in][string] */ LPCWSTR pszMDHistoryLocation,
            /* [in] */ DWORD dwMDMajorVersion,
            /* [in] */ DWORD dwMDMinorVersion,
            /* [in] */ DWORD dwMDFlags) = 0;

        virtual HRESULT STDMETHODCALLTYPE ComMDEnumHistoryW(
            /* [size_is (MD_BACKUP_MAX_LEN)][in, out] */ LPWSTR pszMDHistoryLocation,
            /* [out] */ DWORD *pdwMDMajorVersion,
            /* [out] */ DWORD *pdwMDMinorVersion,
            /* [out] */ PFILETIME pftMDHistoryTime,
            /* [in] */ DWORD dwMDEnumIndex) = 0;
    };

#else   /* C style interface */
#endif

#endif  /* __IMDCOM2_INTERFACE_DEFINED__ */

#ifndef __IMDCOM3_INTERFACE_DEFINED__
#define __IMDCOM3_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IMDCOM
 * at Tue Jun 24 13:13:57 1997
 * using MIDL 3.00.44
 ****************************************/
/* [unique][uuid][object] */


EXTERN_C const IID IID_IMDCOM3;

#if defined(__cplusplus) && !defined(CINTERFACE)

    interface IMDCOM3 : public IMDCOM2
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE ComMDGetChildPathsW(
            /* [in] */ METADATA_HANDLE hMDHandle,
            /* [unique, in, string] */ LPCWSTR pszMDPath,
            /* [in] */ DWORD dwMDBufferSize,
            /* [out, size_is(dwMDBufferSize)] */ WCHAR *pszBuffer,
            /* [out] */ DWORD *pdwMDRequiredBufferSize) = 0;

        virtual HRESULT STDMETHODCALLTYPE ComMDStopEWR(VOID) = 0;

        virtual HRESULT STDMETHODCALLTYPE ComMDSendShutdownNotifications(VOID) = 0;
    };

#else   /* C style interface */
#endif

#endif  /* __IMDCOM3_INTERFACE_DEFINED__ */


/****************************************
 * Generated header for interface: __MIDL__intf_0145
 * at Tue Jun 24 13:13:57 1997
 * using MIDL 3.00.44
 ****************************************/
/* [local] */


/*
The Callback Interface - Clients that need to receive callbacks need to provide
    an implementation of this interface and Advise the metadata server.
*/
#define IMDCOMSINK   IMDCOMSINKA


extern RPC_IF_HANDLE __MIDL__intf_0145_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL__intf_0145_v0_0_s_ifspec;

#ifndef __IMDCOMSINKA_INTERFACE_DEFINED__
#define __IMDCOMSINKA_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IMDCOMSINKA
 * at Tue Jun 24 13:13:57 1997
 * using MIDL 3.00.44
 ****************************************/
/* [unique][uuid][object] */



EXTERN_C const IID IID_IMDCOMSINKA;

#if defined(__cplusplus) && !defined(CINTERFACE)

    interface IMDCOMSINKA : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE ComMDSinkNotify(
            /* [in] */ METADATA_HANDLE hMDHandle,
            /* [in] */ DWORD dwMDNumElements,
            /* [size_is][in] */ MD_CHANGE_OBJECT_A __RPC_FAR pcoChangeList[  ]) = 0;

        virtual HRESULT STDMETHODCALLTYPE ComMDShutdownNotify() = 0;

    };

#else   /* C style interface */

#endif  /* C style interface */



#endif  /* __IMDCOMSINKA_INTERFACE_DEFINED__ */


#ifndef __IMDCOMSINKW_INTERFACE_DEFINED__
#define __IMDCOMSINKW_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IMDCOMSINKW
 * at Tue Jun 24 13:13:57 1997
 * using MIDL 3.00.44
 ****************************************/
/* [unique][uuid][object] */



EXTERN_C const IID IID_IMDCOMSINKW;

#if defined(__cplusplus) && !defined(CINTERFACE)

    interface IMDCOMSINKW : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE ComMDSinkNotify(
            /* [in] */ METADATA_HANDLE hMDHandle,
            /* [in] */ DWORD dwMDNumElements,
            /* [size_is][in] */ MD_CHANGE_OBJECT_W __RPC_FAR pcoChangeList[  ]) = 0;

        virtual HRESULT STDMETHODCALLTYPE ComMDShutdownNotify() = 0;

        virtual HRESULT STDMETHODCALLTYPE ComMDEventNotify(
            /* [in] */ DWORD dwMDEvent) = 0;
    };

#else   /* C style interface */

#endif  /* C style interface */
#endif  /* __IMDCOMSINKW_INTERFACE_DEFINED__ */


/****************************************
 * Generated header for interface: __MIDL__intf_0147
 * at Tue Jun 24 13:13:57 1997
 * using MIDL 3.00.44
 ****************************************/
/* [local] */



#ifdef UNICODE

#define ComMDAddMetaObject ComMDAddMetaObjectW
#define ComMDDeleteMetaObject ComMDDeleteMetaObjectW
#define ComMDDeleteChildMetaObjects ComMDDeleteChildMetaObjectsW
#define ComMDEnumMetaObjects ComMDEnumMetaObjectsW
#define ComMDCopyMetaObject ComMDCopyMetaObjectW
#define ComMDRenameMetaObject ComMDRenameMetaObjectW
#define ComMDSetMetaData ComMDSetMetaDataW
#define ComMDGetMetaData ComMDGetMetaDataW
#define ComMDDeleteMetaData ComMDDeleteMetaDataW
#define ComMDEnumMetaData ComMDEnumMetaDataW
#define ComMDGetAllMetaData ComMDGetAllMetaDataW
#define ComMDDeleteAllMetaData ComMDDeleteAllMetaDataW
#define ComMDCopyMetaData ComMDCopyMetaDataW
#define ComMDGetMetaDataPaths ComMDGetMetaDataPathsW
#define ComMDOpenMetaObject ComMDOpenMetaObjectW
#define ComMDGetDataSetNumber ComMDGetDataSetNumberW
#define ComMDSetLastChangeTime ComMDSetLastChangeTimeW
#define ComMDGetLastChangeTime ComMDGetLastChangeTimeW
#define ComMDBackup ComMDBackupW
#define ComMDRestore ComMDRestoreW
#define ComMDEnumBackups ComMDEnumBackupsW
#define ComMDDeleteBackup ComMDDeleteBackupW
#define ComMDBackupWithPasswd ComMDBackupWithPasswdW
#define ComMDRestoreWithPasswd ComMDRestoreWithPasswdW
#define ComMDExport ComMDExportW
#define ComMDImport ComMDImportW
#define ComMDRestoreHistory ComMDRestoreHistoryW
#define ComMDEnumHistory ComMDEnumHistoryW

#else // Not UNICODE

#define ComMDAddMetaObject ComMDAddMetaObjectA
#define ComMDDeleteMetaObject ComMDDeleteMetaObjectA
#define ComMDDeleteChildMetaObjects ComMDDeleteChildMetaObjectsA
#define ComMDEnumMetaObjects ComMDEnumMetaObjectsA
#define ComMDCopyMetaObject ComMDCopyMetaObjectA
#define ComMDRenameMetaObject ComMDRenameMetaObjectA
#define ComMDSetMetaData ComMDSetMetaDataA
#define ComMDGetMetaData ComMDGetMetaDataA
#define ComMDDeleteMetaData ComMDDeleteMetaDataA
#define ComMDEnumMetaData ComMDEnumMetaDataA
#define ComMDGetAllMetaData ComMDGetAllMetaDataA
#define ComMDDeleteAllMetaData ComMDDeleteAllMetaDataA
#define ComMDCopyMetaData ComMDCopyMetaDataA
#define ComMDGetMetaDataPaths ComMDGetMetaDataPathsA
#define ComMDOpenMetaObject ComMDOpenMetaObjectA
#define ComMDGetDataSetNumber ComMDGetDataSetNumberA
#define ComMDSetLastChangeTime ComMDSetLastChangeTimeA
#define ComMDGetLastChangeTime ComMDGetLastChangeTimeA
#define ComMDBackup ComMDBackupA
#define ComMDRestore ComMDRestoreA
#define ComMDEnumBackups ComMDEnumBackupsA
#define ComMDDeleteBackup ComMDDeleteBackupA
#define ComMDBackupWithPasswd ComMDBackupWithPasswdA
#define ComMDRestoreWithPasswd ComMDRestoreWithPasswdA
#define ComMDExport ComMDExportA
#define ComMDImport ComMDImportA
#define ComMDRestoreHistory ComMDRestoreHistoryA
#define ComMDEnumHistory ComMDEnumHistoryA

#endif //UNICODE

#endif

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\inc\inetaccs.h ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    inetaccs.h

Abstract:

    This file contains the internet access server admin APIs.


Author:

    Madan Appiah (madana) 10-Oct-1995

Revision History:

    Madana      10-Oct-1995     Made a new copy for product split from inetasrv.h
    Sophiac     16-Oct-1995     Added common statistics apis for perfmon
    MuraliK     14-Dec-1995     Changed Interface names to use Service names

--*/

#ifndef _INETACCS_H_
#define _INETACCS_H_

#include <inetcom.h>

#ifdef __cplusplus
extern "C"
{
#endif  // _cplusplus


/************************************************************
 *  Symbolic Constants
 ************************************************************/

#ifndef NO_AUX_PERF

#ifndef MAX_AUX_PERF_COUNTERS
#define MAX_AUX_PERF_COUNTERS          (20)
#endif // MAX_AUX_PERF_COUNTERS

#endif // NO_AUX_PERF

//
//  Service name.
//

#define INET_ACCS_SERVICE_NAME             TEXT("INETACCS")
#define INET_ACCS_SERVICE_NAME_A           "INETACCS"
#define INET_ACCS_SERVICE_NAME_W           L"INETACCS"

//
//  Configuration parameters registry key.
//

#define INET_ACCS_KEY \
            TEXT("System\\CurrentControlSet\\Services\\inetaccs")

#define INET_ACCS_PARAMETERS_KEY \
            INET_ACCS_KEY TEXT("\\Parameters")

#define INET_ACCS_CACHE_KEY                TEXT("Cache")
#define INET_ACCS_FILTER_KEY               TEXT("Filter")

/////////////////////////////////////////////////////////////////////////
//                                                                     //
//                  Internet Server Common Definitions                 //
//                                                                     //
/////////////////////////////////////////////////////////////////////////

//
//   Client Interface Name for RPC connections over named pipes
//

# define INET_ACCS_INTERFACE_NAME  INET_ACCS_SERVICE_NAME
# define INET_ACCS_NAMED_PIPE      TEXT("\\PIPE\\") ## INET_ACCS_INTERFACE_NAME
# define INET_ACCS_NAMED_PIPE_W    L"\\PIPE\\" ## INET_ACCS_SERVICE_NAME_W

//
// Field Control common for Gateway services
//

#define FC_INET_ACCS_ALL                FC_INET_COM_ALL

//
//  Admin configuration information
//

typedef struct _INET_ACCS_CONFIG_INFO
{
    FIELD_CONTROL FieldControl;

    //
    // don't add any service specific config parameter here.
    //

    INET_COM_CONFIG_INFO CommonConfigInfo;

    //
    // add service specific parameters here.
    //

} INET_ACCS_CONFIG_INFO, * LPINET_ACCS_CONFIG_INFO;

/////////////////////////////////////////////////////////////////////////
//                                                                     //
//                  Global Internet Server Definitions                 //
//                                                                     //
/////////////////////////////////////////////////////////////////////////


#define FC_GINET_ACCS_MEMORY_CACHE_SIZE    ((FIELD_CONTROL)BitFlag(1))
#define FC_GINET_ACCS_DISK_CACHE_TIMEOUT   ((FIELD_CONTROL)BitFlag(2))
#define FC_GINET_ACCS_DISK_CACHE_UPDATE    ((FIELD_CONTROL)BitFlag(3))
#define FC_GINET_ACCS_FRESHNESS_INTERVAL   ((FIELD_CONTROL)BitFlag(4))
#define FC_GINET_ACCS_CLEANUP_INTERVAL     ((FIELD_CONTROL)BitFlag(5))
#define FC_GINET_ACCS_CLEANUP_FACTOR       ((FIELD_CONTROL)BitFlag(6))
#define FC_GINET_ACCS_CLEANUP_TIME         ((FIELD_CONTROL)BitFlag(7))
#define FC_GINET_ACCS_PERSISTENT_CACHE     ((FIELD_CONTROL)BitFlag(8))
#define FC_GINET_ACCS_DISK_CACHE_LOCATION  ((FIELD_CONTROL)BitFlag(9))
#define FC_GINET_ACCS_BANDWIDTH_LEVEL      ((FIELD_CONTROL)BitFlag(10))
#define FC_GINET_ACCS_DOMAIN_FILTER_CONFIG ((FIELD_CONTROL)BitFlag(11))


#define FC_GINET_ACCS_ALL              (FC_GINET_ACCS_MEMORY_CACHE_SIZE    | \
                                        FC_GINET_ACCS_DISK_CACHE_TIMEOUT   | \
                                        FC_GINET_ACCS_DISK_CACHE_UPDATE    | \
                                        FC_GINET_ACCS_FRESHNESS_INTERVAL   | \
                                        FC_GINET_ACCS_CLEANUP_INTERVAL     | \
                                        FC_GINET_ACCS_CLEANUP_FACTOR       | \
                                        FC_GINET_ACCS_CLEANUP_TIME         | \
                                        FC_GINET_ACCS_PERSISTENT_CACHE     | \
                                        FC_GINET_ACCS_DISK_CACHE_LOCATION  | \
                                        FC_GINET_ACCS_BANDWIDTH_LEVEL      | \
                                        FC_GINET_ACCS_DOMAIN_FILTER_CONFIG | \
                                        0                                \
                                        )

//
//  Disk cache settings
//

typedef struct _INET_ACCS_DISK_CACHE_LOC_ENTRY
{
    LPWSTR pszDirectory;                 // Directory for temporary files
    DWORD  cbMaxCacheSize;               // Maximum number of bytes (in 1024
                                         // byte increments)
} INET_ACCS_DISK_CACHE_LOC_ENTRY, *LPINET_ACCS_DISK_CACHE_LOC_ENTRY;


#pragma warning( disable:4200 )          // nonstandard ext. - zero sized array
                                         // (MIDL requires zero entries)

typedef struct _INET_ACCS_DISK_CACHE_LOC_LIST
{
    DWORD               cEntries;
#ifdef MIDL_PASS
    [size_is( cEntries)]
#endif
    INET_ACCS_DISK_CACHE_LOC_ENTRY  aLocEntry[];

} INET_ACCS_DISK_CACHE_LOC_LIST, *LPINET_ACCS_DISK_CACHE_LOC_LIST;

//
//  Domain Filter settings
//

typedef struct _INET_ACCS_DOMAIN_FILTER_ENTRY
{
    DWORD     dwMask;                    // Mask and network number in
    DWORD     dwNetwork;                 // network order
    LPSTR     pszFilterSite;             // domain filter site name

} INET_ACCS_DOMAIN_FILTER_ENTRY, *LPINET_ACCS_DOMAIN_FILTER_ENTRY;

typedef struct _INET_ACCS_DOMAIN_FILTER_LIST
{
    DWORD               cEntries;
#ifdef MIDL_PASS
    [size_is( cEntries)]
#endif
    INET_ACCS_DOMAIN_FILTER_ENTRY  aFilterEntry[];

} INET_ACCS_DOMAIN_FILTER_LIST, *LPINET_ACCS_DOMAIN_FILTER_LIST;

//
// Domain Filter Types
//

#define INET_ACCS_DOMAIN_FILTER_DISABLED     0
#define INET_ACCS_DOMAIN_FILTER_DENIED       1
#define INET_ACCS_DOMAIN_FILTER_GRANT        2

typedef struct _INET_ACCS_GLOBAL_CONFIG_INFO
{
    FIELD_CONTROL FieldControl;

    DWORD         cbMemoryCacheSize;       // Size of memory cache

    DWORD         DiskCacheTimeOut;        // Remove if not accessed in this
                                           // time (in seconds)
    DWORD         DiskCacheUpdate;         // When to refresh the data (sec)

    DWORD         FreshnessInterval;       // Time to refresh the data

    DWORD         CleanupInterval;         // Time interval between unused
                                           // file cleanups (sec)
    DWORD         CleanupFactor;           // % of the cache storage freed up
                                           // during cleanup
    DWORD         CleanupTime;             // scheduled time to clean up

    DWORD         PersistentCache;         // Allow cache not to be cleaned

    LPINET_ACCS_DISK_CACHE_LOC_LIST  DiskCacheList;

    DWORD         BandwidthLevel;          // Bandwidth Level used.
    DWORD         DomainFilterType;        // set to either DENIED
                                           // or GRANT or DISABLED
    LPINET_ACCS_DOMAIN_FILTER_LIST  GrantFilterList;
                                           // domain filter granted sites
    LPINET_ACCS_DOMAIN_FILTER_LIST  DenyFilterList;
                                           // domain filter denied sites

} INET_ACCS_GLOBAL_CONFIG_INFO, * LPINET_ACCS_GLOBAL_CONFIG_INFO;


//
// Global statistics
//

typedef struct _INET_ACCS_STATISTICS_0
{

    INET_COM_CACHE_STATISTICS  CacheCtrs;
    INET_COM_ATQ_STATISTICS    AtqCtrs;

# ifndef NO_AUX_PERF
    DWORD   nAuxCounters; // number of active counters in rgCounters
    DWORD   rgCounters[MAX_AUX_PERF_COUNTERS];
# endif  // NO_AUX_PERF

} INET_ACCS_STATISTICS_0, * LPINET_ACCS_STATISTICS_0;


//
//  Inet Access admin API Prototypes
//

NET_API_STATUS
NET_API_FUNCTION
InetAccessGetVersion(
    IN  LPWSTR   pszServer OPTIONAL,
    IN  DWORD    dwReserved,
    OUT DWORD *  pdwVersion
    );

NET_API_STATUS
NET_API_FUNCTION
InetAccessGetGlobalAdminInformation(
    IN  LPWSTR                       pszServer OPTIONAL,
    IN  DWORD                        dwReserved,
    OUT LPINET_ACCS_GLOBAL_CONFIG_INFO * ppConfig
    );

NET_API_STATUS
NET_API_FUNCTION
InetAccessSetGlobalAdminInformation(
    IN  LPWSTR                     pszServer OPTIONAL,
    IN  DWORD                      dwReserved,
    IN  INET_ACCS_GLOBAL_CONFIG_INFO * pConfig
    );

NET_API_STATUS
NET_API_FUNCTION
InetAccessGetAdminInformation(
    IN  LPWSTR                pszServer OPTIONAL,
    IN  DWORD                 dwServerMask,
    OUT LPINET_ACCS_CONFIG_INFO * ppConfig
    );

NET_API_STATUS
NET_API_FUNCTION
InetAccessSetAdminInformation(
    IN  LPWSTR              pszServer OPTIONAL,
    IN  DWORD               dwServerMask,
    IN  INET_ACCS_CONFIG_INFO * pConfig
    );

NET_API_STATUS
NET_API_FUNCTION
InetAccessQueryStatistics(
    IN  LPWSTR   pszServer OPTIONAL,
    IN  DWORD    Level,
    IN  DWORD    dwServerMask,
    OUT LPBYTE * Buffer
    );

NET_API_STATUS
NET_API_FUNCTION
InetAccessClearStatistics(
    IN  LPWSTR pszServer OPTIONAL,
    IN  DWORD  dwServerMask
    );

NET_API_STATUS
NET_API_FUNCTION
InetAccessFlushMemoryCache(
    IN  LPWSTR pszServer OPTIONAL,
    IN  DWORD  dwServerMask
    );

#ifdef __cplusplus
}
#endif  // _cplusplus


#endif  // _INETACCS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\inc\inetinfo.h ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    inetinfo.h

Abstract:

    This file contains the internet info server admin APIs.


Author:

    Madan Appiah (madana) 10-Oct-1995

Revision History:

    Madana      10-Oct-1995  Made a new copy for product split from inetasrv.h
    MuraliK     12-Oct-1995  Fixes to support product split
    MuraliK     15-Nov-1995  Support Wide Char interface names

--*/

#ifndef _INETINFO_H_
#define _INETINFO_H_

# include "inetcom.h"
# include "iiscnfg.h"

#ifdef __cplusplus
extern "C"
{
#endif  // _cplusplus

/************************************************************
 *  Symbolic Constants
 ************************************************************/

//
//  The total number of instances of common services using the commong
//  service counters
//

#define MAX_PERF_CTR_SVCS              3
#define LAST_PERF_CTR_SVC              INET_HTTP_SVC_ID

#ifndef NO_AUX_PERF

#ifndef MAX_AUX_PERF_COUNTERS
#define MAX_AUX_PERF_COUNTERS          (20)
#endif // MAX_AUX_PERF_COUNTERS

#endif // NO_AUX_PERF

//
//  Service name.
//

#ifndef _EXEXPRESS
#define INET_INFO_SERVICE_NAME             TEXT("INETINFO")
#define INET_INFO_SERVICE_NAME_A           "INETINFO"
#define INET_INFO_SERVICE_NAME_W           L"INETINFO"
#else
#define INET_INFO_SERVICE_NAME             TEXT("KNETINFO")
#define INET_INFO_SERVICE_NAME_A           "KNETINFO"
#define INET_INFO_SERVICE_NAME_W           L"KNETINFO"
#define inetinfo_ServerIfHandle			   knetinfo_ServerIfHandle
#endif

//
// IIS Version number
//

#define IIS_VERSION_MAJOR           5
#define IIS_VERSION_MINOR           1


#define IIS_SERVER_VERSION_MAJOR           6
#define IIS_SERVER_VERSION_MINOR           0

//
//  Configuration parameters registry key.
//

#define INET_INFO_KEY \
            TEXT("System\\CurrentControlSet\\Services\\InetInfo")

#define INET_INFO_PARAMETERS_KEY \
            INET_INFO_KEY TEXT("\\Parameters")

//
//  If this registry key exists under the W3Svc\Parameters key,
//  it is used to validate server access.  Basically, all new users
//  must have sufficient privilege to open this key before they
//  may access the Server.
//

#define INET_INFO_ACCESS_KEY                TEXT("AccessCheck")

//
// Special instances value
//

//
// First instance of the service.
//

#define INET_INSTANCE_FIRST                 0xf0000001

//
// None is used to support users of the old APIs where there was
// no concept of an instance.
//

#define INET_INSTANCE_DOWNLEVEL             0xf0000002

//
// indicates the the request is for global data
//

#define INET_INSTANCE_GLOBAL                0xf0000003

//
// root instance is a special instance which is not active
//

#define INET_INSTANCE_ROOT                  0

#define INET_INSTANCE_ALL                   0xffffffff

#define INET_INSTANCE_MIN                   (1)
#define INET_INSTANCE_MAX                   (0x7ffffffff)

//
//  Authentication requirements values
//

#define INET_INFO_AUTH_ANONYMOUS           MD_AUTH_ANONYMOUS
#define INET_INFO_AUTH_CLEARTEXT           MD_AUTH_BASIC
#define INET_INFO_AUTH_NT_AUTH             MD_AUTH_NT
#define INET_INFO_AUTH_MD5_AUTH            MD_AUTH_MD5
#define INET_INFO_AUTH_MAPBASIC            MD_AUTH_MAPBASIC

#define INET_INFO_AUTH_W95_MASK            INET_INFO_AUTH_ANONYMOUS

//
//  Name of the LSA Secret Object containing the password for
//  anonymous logon.
//

#define INET_INFO_ANONYMOUS_SECRET         TEXT("INET_INFO_ANONYMOUS_DATA")
#define INET_INFO_ANONYMOUS_SECRET_A       "INET_INFO_ANONYMOUS_DATA"
#define INET_INFO_ANONYMOUS_SECRET_W       L"INET_INFO_ANONYMOUS_DATA"


/////////////////////////////////////////////////////////////////////////
//                                                                     //
//                  Internet Server Common Definitions                 //
//                                                                     //
/////////////////////////////////////////////////////////////////////////

//
//   Client Interface Name for RPC connections over named pipes
//

# define  INET_INFO_INTERFACE_NAME     INET_INFO_SERVICE_NAME
# define  INET_INFO_NAMED_PIPE         TEXT("\\PIPE\\") ## INET_INFO_INTERFACE_NAME
# define  INET_INFO_NAMED_PIPE_W  L"\\PIPE\\" ## INET_INFO_SERVICE_NAME_W


//
//  Field control values for the INET_INFO_CONFIG_INFO structure
//

#define FC_INET_INFO_CONNECTION_TIMEOUT    ((FIELD_CONTROL)BitFlag(0))
#define FC_INET_INFO_MAX_CONNECTIONS       ((FIELD_CONTROL)BitFlag(1))
#define FC_INET_INFO_LOG_CONFIG            ((FIELD_CONTROL)BitFlag(2))
#define FC_INET_INFO_ADMIN_NAME            ((FIELD_CONTROL)BitFlag(3))
#define FC_INET_INFO_SERVER_COMMENT        ((FIELD_CONTROL)BitFlag(4))
#define FC_INET_INFO_ADMIN_EMAIL           ((FIELD_CONTROL)BitFlag(5))
#define FC_INET_INFO_HOST_NAME             ((FIELD_CONTROL)BitFlag(6))
#define FC_INET_INFO_SERVER_SIZE           ((FIELD_CONTROL)BitFlag(7))

#define FC_INET_INFO_DEF_LOGON_DOMAIN      ((FIELD_CONTROL)BitFlag(15))
#define FC_INET_INFO_AUTHENTICATION        ((FIELD_CONTROL)BitFlag(16))
#define FC_INET_INFO_ALLOW_ANONYMOUS       ((FIELD_CONTROL)BitFlag(17))
#define FC_INET_INFO_LOG_ANONYMOUS         ((FIELD_CONTROL)BitFlag(18))
#define FC_INET_INFO_LOG_NONANONYMOUS      ((FIELD_CONTROL)BitFlag(19))
#define FC_INET_INFO_ANON_USER_NAME        ((FIELD_CONTROL)BitFlag(20))
#define FC_INET_INFO_ANON_PASSWORD         ((FIELD_CONTROL)BitFlag(21))
#define FC_INET_INFO_PORT_NUMBER           ((FIELD_CONTROL)BitFlag(22))
#define FC_INET_INFO_SITE_SECURITY         ((FIELD_CONTROL)BitFlag(23))
#define FC_INET_INFO_VIRTUAL_ROOTS         ((FIELD_CONTROL)BitFlag(24))
#define FC_INET_INFO_SECURE_PORT_NUMBER    ((FIELD_CONTROL)BitFlag(25))
#define FC_INET_INFO_SERVER_NAME           ((FIELD_CONTROL)BitFlag(26))
#define FC_INET_INFO_AUTO_START            ((FIELD_CONTROL)BitFlag(27))
#define FC_INET_INFO_ADDRESS_TYPE          ((FIELD_CONTROL)BitFlag(28))
#define FC_INET_INFO_IP_ADDRESS            ((FIELD_CONTROL)BitFlag(29))

// common parameters for publishing servers only
# define FC_INET_INFO_ALL              (FC_INET_INFO_CONNECTION_TIMEOUT |\
                                        FC_INET_INFO_MAX_CONNECTIONS    |\
                                        FC_INET_INFO_LOG_CONFIG         |\
                                        FC_INET_INFO_ADMIN_NAME         |\
                                        FC_INET_INFO_SERVER_COMMENT     |\
                                        FC_INET_INFO_ADMIN_EMAIL        |\
                                        FC_INET_INFO_HOST_NAME          |\
                                        FC_INET_INFO_SERVER_SIZE        |\
                                        FC_INET_INFO_AUTHENTICATION     |\
                                        FC_INET_INFO_ALLOW_ANONYMOUS    |\
                                        FC_INET_INFO_LOG_ANONYMOUS      |\
                                        FC_INET_INFO_LOG_NONANONYMOUS   |\
                                        FC_INET_INFO_ANON_USER_NAME     |\
                                        FC_INET_INFO_ANON_PASSWORD      |\
                                        FC_INET_INFO_PORT_NUMBER        |\
                                        FC_INET_INFO_SITE_SECURITY      |\
                                        FC_INET_INFO_VIRTUAL_ROOTS      |\
                                        FC_INET_INFO_SECURE_PORT_NUMBER |\
                                        FC_INET_INFO_SERVER_NAME        |\
                                        FC_INET_INFO_AUTO_START         |\
                                        FC_INET_INFO_ADDRESS_TYPE       |\
                                        FC_INET_INFO_IP_ADDRESS         |\
                                        FC_INET_INFO_DEF_LOGON_DOMAIN    \
                                        )

//
//  Virtual root access mask values
//

#define VROOT_MASK_READ                MD_ACCESS_READ
#define VROOT_MASK_WRITE               MD_ACCESS_WRITE
#define VROOT_MASK_EXECUTE             MD_ACCESS_EXECUTE
#define VROOT_MASK_READ_SOURCE         MD_ACCESS_SOURCE
#define VROOT_MASK_SSL                 MD_ACCESS_SSL
#define VROOT_MASK_DONT_CACHE          MD_ACCESS_DONT_CACHE
#define VROOT_MASK_NEGO_CERT           MD_ACCESS_NEGO_CERT
#define VROOT_MASK_NEGO_MANDATORY      MD_ACCESS_REQUIRE_CERT
#define VROOT_MASK_MAP_CERT            MD_ACCESS_MAP_CERT
#define VROOT_MASK_SSL128              MD_ACCESS_SSL128
#define VROOT_MASK_SCRIPT              MD_ACCESS_SCRIPT
#define VROOT_MASK_NO_REMOTE_READ      MD_ACCESS_NO_REMOTE_READ
#define VROOT_MASK_NO_REMOTE_WRITE     MD_ACCESS_NO_REMOTE_WRITE
#define VROOT_MASK_NO_REMOTE_EXECUTE   MD_ACCESS_NO_REMOTE_EXECUTE
#define VROOT_MASK_NO_REMOTE_SCRIPT    MD_ACCESS_NO_REMOTE_SCRIPT
#define VROOT_MASK_NO_PHYSICAL_DIR     MD_ACCESS_NO_PHYSICAL_DIR

#define VROOT_MASK_MASK                MD_ACCESS_MASK

//
//  INet admin API structures
//

typedef struct _INET_INFO_IP_SEC_ENTRY
{
    DWORD       dwMask;                  // Mask and network number in
    DWORD       dwNetwork;               // network order

} INET_INFO_IP_SEC_ENTRY, *LPINET_INFO_IP_SEC_ENTRY;

#pragma warning( disable:4200 )          // nonstandard ext. - zero sized array
                                         // (MIDL requires zero entries)

typedef struct _INET_INFO_IP_SEC_LIST
{
    DWORD               cEntries;
#ifdef MIDL_PASS
    [size_is( cEntries)]
#endif
    INET_INFO_IP_SEC_ENTRY  aIPSecEntry[];

} INET_INFO_IP_SEC_LIST, *LPINET_INFO_IP_SEC_LIST;


typedef struct _INET_INFO_SITE_ENTRY
{
    LPWSTR  pszComment;               // Site Comment
    DWORD   dwInstance;               // Site Instance Number

} INET_INFO_SITE_ENTRY, *LPINET_INFO_SITE_ENTRY;

typedef struct _INET_INFO_SITE_LIST
{
    DWORD               cEntries;
#ifdef MIDL_PASS
    [size_is( cEntries)]
#endif
    INET_INFO_SITE_ENTRY  aSiteEntry[];

} INET_INFO_SITE_LIST, *LPINET_INFO_SITE_LIST;


typedef struct _INET_INFO_VIRTUAL_ROOT_ENTRY
{
    LPWSTR  pszRoot;                  // Virtual root name
    LPWSTR  pszAddress;               // Optional IP address
    LPWSTR  pszDirectory;             // Physical direcotry
    DWORD   dwMask;                   // Mask for this virtual root
    LPWSTR  pszAccountName;           // Account to connect as
    WCHAR   AccountPassword[PWLEN+1]; // Password for pszAccountName
    DWORD   dwError;                  // Error code if entry wasn't added
                                      // only used for gets

} INET_INFO_VIRTUAL_ROOT_ENTRY, *LPINET_INFO_VIRTUAL_ROOT_ENTRY;

typedef struct _INET_INFO_VIRTUAL_ROOT_LIST
{
    DWORD               cEntries;
#ifdef MIDL_PASS
    [size_is( cEntries)]
#endif
    INET_INFO_VIRTUAL_ROOT_ENTRY  aVirtRootEntry[];

} INET_INFO_VIRTUAL_ROOT_LIST, *LPINET_INFO_VIRTUAL_ROOT_LIST;

//
//  Admin configuration information
//

typedef struct _INET_INFO_CONFIG_INFO
{
    FIELD_CONTROL FieldControl;

    DWORD       dwConnectionTimeout;     // how long to hold connections
    DWORD       dwMaxConnections;        // max connections allowed

    LPWSTR      lpszAdminName;
    LPWSTR      lpszAdminEmail;
    LPWSTR      lpszServerComment;

    LPINET_LOG_CONFIGURATION  lpLogConfig;

    LANGID      LangId;                  // These are read only
    LCID        LocalId;
    BYTE        ProductId[64];

    BOOL        fLogAnonymous;           // Log Anonymous users?
    BOOL        fLogNonAnonymous;        // Log Non anonymous users?

    LPWSTR      lpszAnonUserName;        // Anonymous user name?
    WCHAR       szAnonPassword[PWLEN+1]; // Password for the anonymous user

    DWORD       dwAuthentication;        // What authentication is enabled?

    short       sPort;                   // Port Number for service

    LPINET_INFO_IP_SEC_LIST DenyIPList;      // Site security deny list
    LPINET_INFO_IP_SEC_LIST GrantIPList;     // Site security grant list

    LPINET_INFO_VIRTUAL_ROOT_LIST VirtualRoots; // Symlinks to other data dirs

} INET_INFO_CONFIG_INFO, * LPINET_INFO_CONFIG_INFO;


/////////////////////////////////////////////////////////////////////////
//                                                                     //
//                  Global Internet Server Definitions                 //
//                                                                     //
/////////////////////////////////////////////////////////////////////////


#define FC_GINET_INFO_BANDWIDTH_LEVEL      ((FIELD_CONTROL)BitFlag(0))
#define FC_GINET_INFO_MEMORY_CACHE_SIZE    ((FIELD_CONTROL)BitFlag(1))


#define FC_GINET_INFO_ALL \
                (   FC_GINET_INFO_BANDWIDTH_LEVEL      | \
                    FC_GINET_INFO_MEMORY_CACHE_SIZE    | \
                    0                                \
                    )

typedef struct _INET_INFO_GLOBAL_CONFIG_INFO
{
    FIELD_CONTROL FieldControl;

    DWORD         BandwidthLevel;          // Bandwidth Level used.
    DWORD         cbMemoryCacheSize;

} INET_INFO_GLOBAL_CONFIG_INFO, * LPINET_INFO_GLOBAL_CONFIG_INFO;

//
// Global statistics
//

typedef struct _INET_INFO_STATISTICS_0
{

    INETA_CACHE_STATISTICS  CacheCtrs;
    INETA_ATQ_STATISTICS    AtqCtrs;

# ifndef NO_AUX_PERF
    DWORD   nAuxCounters; // number of active counters in rgCounters
    DWORD   rgCounters[MAX_AUX_PERF_COUNTERS];
# endif  // NO_AUX_PERF

} INET_INFO_STATISTICS_0, * LPINET_INFO_STATISTICS_0;

//
// Capabilities Flags
//

typedef struct _INET_INFO_CAP_FLAGS {

    DWORD   Flag;   // Which capabilities are enabled
    DWORD   Mask;   // Which capabilities are supported

} INET_INFO_CAP_FLAGS, * LPINET_INFO_CAP_FLAGS;

//
// Inet info server capabilities
//

typedef struct _INET_INFO_CAPABILITIES {

    DWORD   CapVersion;     // Version number of this structure
    DWORD   ProductType;    // Product type
    DWORD   MajorVersion;   // Major version number
    DWORD   MinorVersion;   // Minor Version number
    DWORD   BuildNumber;    // Build number
    DWORD   NumCapFlags;    // Number of capabilities structures

    LPINET_INFO_CAP_FLAGS    CapFlags;

} INET_INFO_CAPABILITIES, * LPINET_INFO_CAPABILITIES;

//
//  Location of FrontPage web registry settings if installed
//

#define REG_FP_PATH        "Software\\Microsoft\\FrontPage\\3.0"

//
// Product type
//

#define INET_INFO_PRODUCT_NTSERVER          0x00000001
#define INET_INFO_PRODUCT_NTWKSTA           0x00000002
#define INET_INFO_PRODUCT_WINDOWS95         0x00000003
#define INET_INFO_PRODUCT_UNKNOWN           0xffffffff

//
// Settable server capabilities
//

#define IIS_CAP1_ODBC_LOGGING               0x00000001
#define IIS_CAP1_FILE_LOGGING               0x00000002
#define IIS_CAP1_VIRTUAL_SERVER             0x00000004
#define IIS_CAP1_BW_THROTTLING              0x00000008
#define IIS_CAP1_IP_ACCESS_CHECK            0x00000010
#define IIS_CAP1_MAX_CONNECTIONS            0x00000020
#define IIS_CAP1_10_CONNECTION_LIMIT        0x00000040
#define IIS_CAP1_MULTIPLE_INSTANCE          0x00000080
#define IIS_CAP1_SSL_SUPPORT                0x00000100
#define IIS_CAP1_OPERATORS_LIST             0x00000200
#define IIS_CAP1_CPU_AUDITING               0x00000800
#define IIS_CAP1_SERVER_COMPRESSION         0x00001000
#define IIS_CAP1_DAV                        0x00002000
#define IIS_CAP1_POOLED_OOP                 0x00010000

//
// Get or'd in at runtime after checking the network configuration
//

#define IIS_CAP1_DIGEST_SUPPORT             0x00004000
#define IIS_CAP1_NT_CERTMAP_SUPPORT         0x00008000

//
//  Gets 'or'ed in at runtime after checking the registry
//

#define IIS_CAP1_FP_INSTALLED               0x00000400

#define IIS_CAP1_ALL  ( IIS_CAP1_ODBC_LOGGING       |   \
                        IIS_CAP1_FILE_LOGGING       |   \
                        IIS_CAP1_VIRTUAL_SERVER     |   \
                        IIS_CAP1_BW_THROTTLING      |   \
                        IIS_CAP1_IP_ACCESS_CHECK    |   \
                        IIS_CAP1_MAX_CONNECTIONS    |   \
                        IIS_CAP1_10_CONNECTION_LIMIT|   \
                        IIS_CAP1_MULTIPLE_INSTANCE  |   \
                        IIS_CAP1_SSL_SUPPORT        |   \
                        IIS_CAP1_OPERATORS_LIST     |   \
                        IIS_CAP1_SERVER_COMPRESSION |   \
                        IIS_CAP1_CPU_AUDITING       |   \
                        IIS_CAP1_DAV                |   \
                        IIS_CAP1_POOLED_OOP             \
                        )

#define IIS_CAP1_NTS  ( IIS_CAP1_ODBC_LOGGING       |   \
                        IIS_CAP1_FILE_LOGGING       |   \
                        IIS_CAP1_VIRTUAL_SERVER     |   \
                        IIS_CAP1_BW_THROTTLING      |   \
                        IIS_CAP1_IP_ACCESS_CHECK    |   \
                        IIS_CAP1_MAX_CONNECTIONS    |   \
                        IIS_CAP1_MULTIPLE_INSTANCE  |   \
                        IIS_CAP1_SSL_SUPPORT        |   \
                        IIS_CAP1_OPERATORS_LIST     |   \
                        IIS_CAP1_SERVER_COMPRESSION |   \
                        IIS_CAP1_CPU_AUDITING       |   \
                        IIS_CAP1_DAV                |   \
                        IIS_CAP1_POOLED_OOP             \
                        )

#define IIS_CAP1_NTW  ( IIS_CAP1_FILE_LOGGING       |   \
                        IIS_CAP1_MAX_CONNECTIONS    |   \
                        IIS_CAP1_10_CONNECTION_LIMIT|   \
                        IIS_CAP1_SSL_SUPPORT        |   \
                        IIS_CAP1_SERVER_COMPRESSION |   \
                        IIS_CAP1_DAV                |   \
                        IIS_CAP1_POOLED_OOP             \
                        )

#define IIS_CAP1_W95  ( IIS_CAP1_FILE_LOGGING       |   \
                        IIS_CAP1_MAX_CONNECTIONS    |   \
                        IIS_CAP1_10_CONNECTION_LIMIT    \
                        )

//
//  INet admin API Prototypes
//

NET_API_STATUS
NET_API_FUNCTION
InetInfoGetVersion(
    IN  LPWSTR   pszServer OPTIONAL,
    IN  DWORD    dwReserved,
    OUT DWORD *  pdwVersion
    );

NET_API_STATUS
NET_API_FUNCTION
InetInfoGetServerCapabilities(
    IN  LPWSTR   pszServer OPTIONAL,
    IN  DWORD    dwReserved,
    OUT LPINET_INFO_CAPABILITIES * ppCap
    );

NET_API_STATUS
NET_API_FUNCTION
InetInfoGetGlobalAdminInformation(
    IN  LPWSTR                       pszServer OPTIONAL,
    IN  DWORD                        dwReserved,
    OUT LPINET_INFO_GLOBAL_CONFIG_INFO * ppConfig
    );

NET_API_STATUS
NET_API_FUNCTION
InetInfoSetGlobalAdminInformation(
    IN  LPWSTR                     pszServer OPTIONAL,
    IN  DWORD                      dwReserved,
    IN  INET_INFO_GLOBAL_CONFIG_INFO * pConfig
    );

NET_API_STATUS
NET_API_FUNCTION
InetInfoGetAdminInformation(
    IN  LPWSTR                pszServer OPTIONAL,
    IN  DWORD                 dwServerMask,
    OUT LPINET_INFO_CONFIG_INFO * ppConfig
    );

NET_API_STATUS
NET_API_FUNCTION
InetInfoSetAdminInformation(
    IN  LPWSTR              pszServer OPTIONAL,
    IN  DWORD               dwServerMask,
    IN  INET_INFO_CONFIG_INFO * pConfig
    );

NET_API_STATUS
NET_API_FUNCTION
InetInfoQueryStatistics(
    IN  LPWSTR   pszServer OPTIONAL,
    IN  DWORD    Level,
    IN  DWORD    dwServerMask,
    OUT LPBYTE * Buffer
    );

NET_API_STATUS
NET_API_FUNCTION
InetInfoClearStatistics(
    IN  LPWSTR pszServer OPTIONAL,
    IN  DWORD  dwServerMask
    );

NET_API_STATUS
NET_API_FUNCTION
InetInfoFlushMemoryCache(
    IN  LPWSTR pszServer OPTIONAL,
    IN  DWORD  dwServerMask
    );

NET_API_STATUS
NET_API_FUNCTION
InetInfoGetSites(
    IN  LPWSTR                pszServer OPTIONAL,
    IN  DWORD                 dwServerMask,
    OUT LPINET_INFO_SITE_LIST * ppSites
    );


/////////////////////////////////////////////////////////////////////////
//                                                                     //
//                  HTTP (w3) specific items                           //
//                                                                     //
/////////////////////////////////////////////////////////////////////////

//
//   Client Interface Name for RPC connections over named pipes
//

#define W3_SERVICE_NAME                TEXT("W3SVC")
#define W3_SERVICE_NAME_A              "W3SVC"
#define W3_SERVICE_NAME_W              L"W3SVC"

# define  W3_INTERFACE_NAME     W3_SERVICE_NAME
# define  W3_NAMED_PIPE         TEXT("\\PIPE\\") ## W3_INTERFACE_NAME
# define  W3_NAMED_PIPE_W       L"\\PIPE\\" ## W3_SERVICE_NAME_W

//
// Built-in application package ID's and class ID's
//

#define W3_INPROC_PACKAGE_ID    L"{3D14228C-FBE1-11d0-995D-00C04FD919C1}"
#define W3_OOP_POOL_PACKAGE_ID  L"{3D14228D-FBE1-11d0-995D-00C04FD919C1}"
#define W3_INPROC_WAM_CLSID     L"{99169CB0-A707-11d0-989D-00C04FD919C1}"
#define W3_OOP_POOL_WAM_CLSID   L"{99169CB1-A707-11d0-989D-00C04FD919C1}"

//
// Constants for ISAPI token query functions
//

#define TOKEN_ANONYMOUS_TOKEN   1
#define TOKEN_VR_TOKEN          2


//
//  Manifests for APIs
//

#define FC_W3_DIR_BROWSE_CONTROL       ((FIELD_CONTROL)BitFlag(0))
#define FC_W3_DEFAULT_LOAD_FILE        ((FIELD_CONTROL)BitFlag(1))
#define FC_W3_CHECK_FOR_WAISDB         ((FIELD_CONTROL)BitFlag(2))
#define FC_W3_DIRECTORY_IMAGE          ((FIELD_CONTROL)BitFlag(3))
#define FC_W3_SERVER_AS_PROXY          ((FIELD_CONTROL)BitFlag(4))
#define FC_W3_CATAPULT_USER_AND_PWD    ((FIELD_CONTROL)BitFlag(5))
#define FC_W3_SSI_ENABLED              ((FIELD_CONTROL)BitFlag(6))
#define FC_W3_SSI_EXTENSION            ((FIELD_CONTROL)BitFlag(7))
#define FC_W3_GLOBAL_EXPIRE            ((FIELD_CONTROL)BitFlag(8))
#define FC_W3_SCRIPT_MAPPING           ((FIELD_CONTROL)BitFlag(9))
#define FC_W3_CGI_SCRIPT_TIMEOUT       ((FIELD_CONTROL)BitFlag(10))
#define FC_W3_POOL_ODBC_CONN_TIME      ((FIELD_CONTROL)BitFlag(11))
#define FC_W3_CACHE_ISAPI_APPS         ((FIELD_CONTROL)BitFlag(12))
#define FC_W3_USE_KEEP_ALIVES          ((FIELD_CONTROL)BitFlag(13))
#define FC_W3_ENABLE_HEADER_DOC        ((FIELD_CONTROL)BitFlag(14))
#define FC_W3_HEADER_DOC_NAME          ((FIELD_CONTROL)BitFlag(15))
#define FC_W3_ENABLE_FOOT_DOC          ((FIELD_CONTROL)BitFlag(16))
#define FC_W3_FOOTER_DOC_NAME          ((FIELD_CONTROL)BitFlag(17))
#define FC_W3_CUSTOMER_HEADERS         ((FIELD_CONTROL)BitFlag(18))




#define FC_W3_ALL                      (FC_W3_DIR_BROWSE_CONTROL | \
                                        FC_W3_DEFAULT_LOAD_FILE  | \
                                        FC_W3_CHECK_FOR_WAISDB   | \
                                        FC_W3_DIRECTORY_IMAGE    | \
                                        FC_W3_SERVER_AS_PROXY    | \
                                        FC_W3_CATAPULT_USER_AND_PWD |\
                                        FC_W3_SSI_ENABLED        | \
                                        FC_W3_SSI_EXTENSION      | \
                                        FC_W3_GLOBAL_EXPIRE      | \
                                        FC_W3_SCRIPT_MAPPING     | \
                                        FC_W3_CGI_SCRIPT_TIMEOUT | \
                                        FC_W3_POOL_ODBC_CONN_TIME| \
                                        FC_W3_CACHE_ISAPI_APPS   | \
                                        FC_W3_USE_KEEP_ALIVES    | \
                                        FC_W3_ENABLE_HEADER_DOC  | \
                                        FC_W3_HEADER_DOC_NAME    | \
                                        FC_W3_ENABLE_FOOT_DOC    | \
                                        FC_W3_FOOTER_DOC_NAME    | \
                                        FC_W3_CUSTOMER_HEADERS     \
                                        )

//
//  HTTP Directory browsing flags
//

//#define DIRBROW_SHOW_ICON           0x00000001
#define DIRBROW_SHOW_DATE           MD_DIRBROW_SHOW_DATE
#define DIRBROW_SHOW_TIME           MD_DIRBROW_SHOW_TIME
#define DIRBROW_SHOW_SIZE           MD_DIRBROW_SHOW_SIZE
#define DIRBROW_SHOW_EXTENSION      MD_DIRBROW_SHOW_EXTENSION
#define DIRBROW_LONG_DATE           MD_DIRBROW_LONG_DATE

#define DIRBROW_ENABLED             MD_DIRBROW_ENABLED
#define DIRBROW_LOADDEFAULT         MD_DIRBROW_LOADDEFAULT

#define DIRBROW_MASK                MD_DIRBROW_MASK

//
//  Setting the csecGlobalExpire field to this value will prevent the server
//  from generating an "Expires:" header.
//

#define NO_GLOBAL_EXPIRE           0xffffffff

//
//  Encryption Capabilities
//

#define ENC_CAPS_NOT_INSTALLED     0x80000000       // No keys installed
#define ENC_CAPS_DISABLED          0x40000000       // Disabled due to locale
#define ENC_CAPS_SSL               0x00000001       // SSL active
#define ENC_CAPS_PCT               0x00000002       // PCT active

//
//  Encryption type (SSL/PCT etc) portion of encryption flag dword
//

#define ENC_CAPS_TYPE_MASK         (ENC_CAPS_SSL | \
                                    ENC_CAPS_PCT)

#define ENC_CAPS_DEFAULT           ENC_CAPS_TYPE_MASK

//
//  Structures for APIs
//

typedef struct _W3_USER_INFO
{
    DWORD    idUser;          //  User id
    LPWSTR   pszUser;         //  User name
    BOOL     fAnonymous;      //  TRUE if the user is logged on as
                              //  Anonymous, FALSE otherwise
    DWORD    inetHost;        //  Host Address
    DWORD    tConnect;        //  User Connection Time (elapsed seconds)

} W3_USER_INFO, * LPW3_USER_INFO;

typedef struct _W3_STATISTICS_0
{
    LARGE_INTEGER TotalBytesSent;
    LARGE_INTEGER TotalBytesReceived;
    DWORD         TotalFilesSent;
    DWORD         TotalFilesReceived;
    DWORD         CurrentAnonymousUsers;
    DWORD         CurrentNonAnonymousUsers;
    DWORD         TotalAnonymousUsers;
    DWORD         TotalNonAnonymousUsers;
    DWORD         MaxAnonymousUsers;
    DWORD         MaxNonAnonymousUsers;
    DWORD         CurrentConnections;
    DWORD         MaxConnections;
    DWORD         ConnectionAttempts;
    DWORD         LogonAttempts;

    DWORD         TotalGets;
    DWORD         TotalPosts;
    DWORD         TotalHeads;
    DWORD         TotalOthers;      // Other HTTP verbs
    DWORD         TotalCGIRequests;
    DWORD         TotalBGIRequests;
    DWORD         TotalNotFoundErrors;

    DWORD         CurrentCGIRequests;
    DWORD         CurrentBGIRequests;
    DWORD         MaxCGIRequests;
    DWORD         MaxBGIRequests;

    DWORD         TimeOfLastClear;
# ifndef NO_AUX_PERF
    DWORD   nAuxCounters; // number of active counters in rgCounters
    DWORD   rgCounters[MAX_AUX_PERF_COUNTERS];
# endif  // NO_AUX_PERF

} W3_STATISTICS_0, * LPW3_STATISTICS_0;

typedef struct _W3_STATISTICS_1
{
    LARGE_INTEGER TotalBytesSent;
    LARGE_INTEGER TotalBytesReceived;
    DWORD         TotalFilesSent;
    DWORD         TotalFilesReceived;
    DWORD         CurrentAnonymousUsers;
    DWORD         CurrentNonAnonymousUsers;
    DWORD         TotalAnonymousUsers;
    DWORD         TotalNonAnonymousUsers;
    DWORD         MaxAnonymousUsers;
    DWORD         MaxNonAnonymousUsers;
    DWORD         CurrentConnections;
    DWORD         MaxConnections;
    DWORD         ConnectionAttempts;
    DWORD         LogonAttempts;

    DWORD         TotalOptions;
    DWORD         TotalGets;
    DWORD         TotalPosts;
    DWORD         TotalHeads;
    DWORD         TotalPuts;
    DWORD         TotalDeletes;
    DWORD         TotalTraces;
    DWORD         TotalMove;
    DWORD         TotalCopy;
    DWORD         TotalMkcol;
    DWORD         TotalPropfind;
    DWORD         TotalProppatch;
    DWORD         TotalSearch;
    DWORD         TotalLock;
    DWORD         TotalUnlock;
    DWORD         TotalOthers;      // Other HTTP verbs
    DWORD         TotalCGIRequests;
    DWORD         TotalBGIRequests;
    DWORD         TotalNotFoundErrors;
    DWORD         TotalLockedErrors;

    DWORD         CurrentCalAuth;
    DWORD         MaxCalAuth;
    DWORD         TotalFailedCalAuth;
    DWORD         CurrentCalSsl;
    DWORD         MaxCalSsl;
    DWORD         TotalFailedCalSsl;

    DWORD         CurrentCGIRequests;
    DWORD         CurrentBGIRequests;
    DWORD         MaxCGIRequests;
    DWORD         MaxBGIRequests;

    // bandwidth throttling info

    DWORD         CurrentBlockedRequests;
    DWORD         TotalBlockedRequests;
    DWORD         TotalAllowedRequests;
    DWORD         TotalRejectedRequests;
    DWORD         MeasuredBw;
    DWORD         ServiceUptime;

    DWORD         TimeOfLastClear;

# ifndef NO_AUX_PERF
    DWORD   nAuxCounters; // number of active counters in rgCounters
    DWORD   rgCounters[MAX_AUX_PERF_COUNTERS];
# endif  // NO_AUX_PERF

} W3_STATISTICS_1, * LPW3_STATISTICS_1;

typedef struct _W3_SCRIPT_MAP_ENTRY
{
    LPWSTR lpszExtension;
    LPWSTR lpszImage;
} W3_SCRIPT_MAP_ENTRY, *LPW3_SCRIPT_MAP_ENTRY;

typedef struct _W3_SCRIPT_MAP_LIST
{
    DWORD               cEntries;
#ifdef MIDL_PASS
    [size_is( cEntries)]
#endif
    W3_SCRIPT_MAP_ENTRY  aScriptMap[];

} W3_SCRIPT_MAP_LIST, *LPW3_SCRIPT_MAP_LIST;

typedef struct _W3_CONFIG_INFO
{
    FIELD_CONTROL FieldControl;

    DWORD         dwDirBrowseControl;       // Directory listing and def. load
    LPWSTR        lpszDefaultLoadFile;      // File to load if feature is on
    BOOL          fCheckForWAISDB;          // Call waislookup if .dct found?
    LPWSTR        lpszDirectoryImage;       // Image for directory in file list
    BOOL          fServerAsProxy;           // Run server as a proxy if TRUE
    LPWSTR        lpszCatapultUser;         // The user/password to impersonate
    WCHAR         szCatapultUserPwd[PWLEN+1]; // if the proxy server is using
                                            // the catapult server

    BOOL          fSSIEnabled;              // Are server side includes enabled?
    LPWSTR        lpszSSIExtension;         // Extension for server side inc.

    DWORD         csecGlobalExpire;         // Value to set Expires: header to

    LPW3_SCRIPT_MAP_LIST ScriptMap;         // List of extension mappings

    DWORD         dwEncCaps;                // Encryption capabilities

} W3_CONFIG_INFO, *LPW3_CONFIG_INFO;

//
// API Prototypes
//

NET_API_STATUS
NET_API_FUNCTION
W3GetAdminInformation(
    IN  LPWSTR                pszServer OPTIONAL,
    OUT LPW3_CONFIG_INFO *    ppConfig
    );

NET_API_STATUS
NET_API_FUNCTION
W3SetAdminInformation(
    IN  LPWSTR              pszServer OPTIONAL,
    IN  LPW3_CONFIG_INFO    pConfig
    );

NET_API_STATUS
NET_API_FUNCTION
W3EnumerateUsers(
    IN LPWSTR   pszServer OPTIONAL,
    OUT LPDWORD  lpdwEntriesRead,
    OUT LPW3_USER_INFO * Buffer
    );

NET_API_STATUS
NET_API_FUNCTION
W3DisconnectUser(
    IN LPWSTR  pszServer OPTIONAL,
    IN DWORD   idUser
    );

NET_API_STATUS
NET_API_FUNCTION
W3QueryStatistics(
    IN LPWSTR pszServer OPTIONAL,
    IN DWORD Level,
    OUT LPBYTE * Buffer
    );

NET_API_STATUS
NET_API_FUNCTION
W3ClearStatistics(
    IN LPWSTR pszServer OPTIONAL
    );

/////////////////////////////////////////////////////////////////////////
//                                                                     //
//                  FTP specific items                                 //
//                                                                     //
/////////////////////////////////////////////////////////////////////////
//
//  Service name.
//

#define FTPD_SERVICE_NAME               TEXT("MSFTPSVC")
#define FTPD_SERVICE_NAME_A              "MSFTPSVC"
#define FTPD_SERVICE_NAME_W             L"MSFTPSVC"


//
//   Client Interface Name for RPC connections over named pipes
//

# define  FTP_INTERFACE_NAME     FTPD_SERVICE_NAME
# define  FTP_NAMED_PIPE         TEXT("\\PIPE\\") ## FTP_INTERFACE_NAME
# define  FTP_NAMED_PIPE_W       L"\\PIPE\\" ## FTPD_SERVICE_NAME_W


//
//  Manifests for APIs.
//

#define FC_FTP_ALLOW_ANONYMOUS          ((FIELD_CONTROL)BitFlag( 0))
#define FC_FTP_ALLOW_GUEST_ACCESS       ((FIELD_CONTROL)BitFlag( 1))
#define FC_FTP_ANNOTATE_DIRECTORIES     ((FIELD_CONTROL)BitFlag( 2))
#define FC_FTP_ANONYMOUS_ONLY           ((FIELD_CONTROL)BitFlag( 3))
#define FC_FTP_EXIT_MESSAGE             ((FIELD_CONTROL)BitFlag( 4))
#define FC_FTP_GREETING_MESSAGE         ((FIELD_CONTROL)BitFlag( 5))
#define FC_FTP_HOME_DIRECTORY           ((FIELD_CONTROL)BitFlag( 6))
#define FC_FTP_LISTEN_BACKLOG           ((FIELD_CONTROL)BitFlag( 7))
#define FC_FTP_LOWERCASE_FILES          ((FIELD_CONTROL)BitFlag( 8))
#define FC_FTP_MAX_CLIENTS_MESSAGE      ((FIELD_CONTROL)BitFlag( 9))
#define FC_FTP_MSDOS_DIR_OUTPUT         ((FIELD_CONTROL)BitFlag(10))

#define FC_FTP_READ_ACCESS_MASK         ((FIELD_CONTROL)BitFlag(11))
#define FC_FTP_WRITE_ACCESS_MASK        ((FIELD_CONTROL)BitFlag(12))
#define FC_FTP_ALLOW_REPLACE_ON_RENAME  ((FIELD_CONTROL)BitFlag(13))
#define FC_FTP_SHOW_4_DIGIT_YEAR        ((FIELD_CONTROL)BitFlag(14))
#define FC_FTP_BANNER_MESSAGE           ((FIELD_CONTROL)BitFlag(15))
#define FC_FTP_USER_ISOLATION           ((FIELD_CONTROL)BitFlag(16))
#define FC_FTP_LOG_IN_UTF_8             ((FIELD_CONTROL)BitFlag(17))

#define FC_FTP_ALL                      (                                  \
                                          FC_FTP_ALLOW_ANONYMOUS         | \
                                          FC_FTP_ALLOW_GUEST_ACCESS      | \
                                          FC_FTP_ANNOTATE_DIRECTORIES    | \
                                          FC_FTP_ANONYMOUS_ONLY          | \
                                          FC_FTP_EXIT_MESSAGE            | \
                                          FC_FTP_GREETING_MESSAGE        | \
                                          FC_FTP_HOME_DIRECTORY          | \
                                          FC_FTP_LISTEN_BACKLOG          | \
                                          FC_FTP_LOWERCASE_FILES         | \
                                          FC_FTP_MAX_CLIENTS_MESSAGE     | \
                                          FC_FTP_MSDOS_DIR_OUTPUT        | \
                                          FC_FTP_READ_ACCESS_MASK        | \
                                          FC_FTP_WRITE_ACCESS_MASK       | \
                                          FC_FTP_ALLOW_REPLACE_ON_RENAME | \
                                          FC_FTP_SHOW_4_DIGIT_YEAR       | \
                                          FC_FTP_BANNER_MESSAGE          | \
                                          FC_FTP_USER_ISOLATION          | \
                                          FC_FTP_LOG_IN_UTF_8            | \
                                          0 )


//
//  Structures for APIs.
//

typedef struct _FTP_CONFIG_INFO
{
    FIELD_CONTROL   FieldControl;

    BOOL            fAllowAnonymous;
    BOOL            fAllowGuestAccess;
    BOOL            fAnnotateDirectories;
    BOOL            fAnonymousOnly;
    LPWSTR          lpszExitMessage;
    LPWSTR          lpszGreetingMessage;
    LPWSTR          lpszHomeDirectory;
    DWORD           dwListenBacklog;
    BOOL            fLowercaseFiles;
    LPWSTR          lpszMaxClientsMessage;
    BOOL            fMsdosDirOutput;
    BOOL            fFourDigitYear;
    LPWSTR          lpszBannerMessage;
    DWORD           dwUserIsolationMode;
    BOOL            fLogInUtf8;

} FTP_CONFIG_INFO, * LPFTP_CONFIG_INFO;


//
//  API Prototypes.
//

NET_API_STATUS
NET_API_FUNCTION
FtpGetAdminInformation(
    IN  LPWSTR                pszServer OPTIONAL,
    OUT LPFTP_CONFIG_INFO *   ppConfig
    );

NET_API_STATUS
NET_API_FUNCTION
FtpSetAdminInformation(
    IN  LPWSTR              pszServer OPTIONAL,
    IN  LPFTP_CONFIG_INFO   pConfig
    );


# include <ftpd.h>

/////////////////////////////////////////////////////////////////////////
//                                                                     //
//                  Gopher specific items                              //
//                                                                     //
/////////////////////////////////////////////////////////////////////////


//
//  Service name.
//

# define GOPHERD_SERVICE_NAME           TEXT("GopherSvc")
# define GOPHERD_SERVICE_NAME_A         "GopherSvc"
# define GOPHERD_SERVICE_NAME_W         L"GopherSvc"

//
//   Client Interface Name for RPC connections over named pipes
//
# define  GOPHERD_INTERFACE_NAME     GOPHERD_SERVICE_NAME
# define  GOPHERD_NAMED_PIPE         TEXT("\\PIPE\\") ## GOPHERD_INTERFACE_NAME
# define  GOPHERD_NAMED_PIPE_W       L"\\PIPE\\" ## GOPHERD_SERVICE_NAME_W

//
// Gopher port
//

#define IPPORT_GOPHER               0x46

/************************************************************
 *   Symbolic Constants
 *   Prefix GDA_  stands for Gopher Daemon Admin
 ************************************************************/

# define   GDA_SITE                   ((FIELD_CONTROL ) BitFlag( 1)) // SZ
# define   GDA_ORGANIZATION           ((FIELD_CONTROL ) BitFlag( 2)) // SZ
# define   GDA_LOCATION               ((FIELD_CONTROL ) BitFlag( 3)) // SZ
# define   GDA_GEOGRAPHY              ((FIELD_CONTROL ) BitFlag( 4)) // SZ
# define   GDA_LANGUAGE               ((FIELD_CONTROL ) BitFlag( 5)) // SZ
# define   GDA_CHECK_FOR_WAISDB       ((FIELD_CONTROL ) BitFlag( 8)) // BOOL

# define   GDA_DEBUG_FLAGS            ((FIELD_CONTROL ) BitFlag( 30)) // DWORD

# define   GDA_ALL_CONFIG_INFO        ( GDA_SITE         | \
                                        GDA_ORGANIZATION | \
                                        GDA_LOCATION     | \
                                        GDA_GEOGRAPHY    | \
                                        GDA_LANGUAGE     | \
                                        GDA_CHECK_FOR_WAISDB | \
                                        GDA_DEBUG_FLAGS    \
                                       )

# define   GOPHERD_ANONYMOUS_SECRET_W       L"GOPHERD_ANONYMOUS_DATA"
# define   GOPHERD_ROOT_SECRET_W            L"GOPHERD_ROOT_DATA"


//
// Configuration information is the config data that is communicated
//  b/w the server and admin UI
//
typedef struct  _GOPHERD_CONFIG_INFO {

    FIELD_CONTROL  FieldControl;        // bit mask indicating fields set.

    LPWSTR      lpszSite;               // Name of Gopher site
    LPWSTR      lpszOrganization;       // Organization Name
    LPWSTR      lpszLocation;           // Location of server
    LPWSTR      lpszGeography;          // Geographical data
    LPWSTR      lpszLanguage;           // Language for server

    BOOL        fCheckForWaisDb;        // Check & allow Wais Db

    //  Debugging data
    DWORD       dwDebugFlags;           // Bitmap of debugging data

} GOPHERD_CONFIG_INFO, * LPGOPHERD_CONFIG_INFO;


typedef struct _GOPHERD_STATISTICS_INFO {

    LARGE_INTEGER   TotalBytesSent;
    LARGE_INTEGER   TotalBytesRecvd;

    DWORD           TotalFilesSent;
    DWORD           TotalDirectoryListings;
    DWORD           TotalSearches;

    DWORD           CurrentAnonymousUsers;
    DWORD           CurrentNonAnonymousUsers;
    DWORD           MaxAnonymousUsers;
    DWORD           MaxNonAnonymousUsers;
    DWORD           TotalAnonymousUsers;
    DWORD           TotalNonAnonymousUsers;

    DWORD           TotalConnections;
    DWORD           MaxConnections;
    DWORD           CurrentConnections;

    DWORD           ConnectionAttempts;     // raw connections made
    DWORD           LogonAttempts;          // total logons attempted
    DWORD           AbortedAttempts;        // Aborted connections
    DWORD           ErroredConnections;     // # in Error when processed

    DWORD           GopherPlusRequests;

    DWORD           TimeOfLastClear;
} GOPHERD_STATISTICS_INFO,  * LPGOPHERD_STATISTICS_INFO;


//
//   GOPHERD_USER_INFO  contains details about connected users.
//   This structure may undergo modification. Currently UserInformation
//    is not supported.
//

typedef struct _GOPHERD_USER_INFO  {

    DWORD   dwIdUser;               // Id for user
    LPWSTR  lpszUserName;           // User name
    BOOL    fAnonymous;             // TRUE if user logged on as anonymous
                                    //  FALSE otherwise
    DWORD   dwInetHost;             // host address for client

    //
    //  Other details if required
    //
} GOPHERD_USER_INFO, * LPGOPHERD_USER_INFO;



/************************************************************
 * Gopher Server RPC APIs
 ************************************************************/


//
//  Server Administrative Information
//

DWORD
NET_API_FUNCTION
GdGetAdminInformation(
    IN      LPWSTR                  pszServer  OPTIONAL,
    OUT     LPGOPHERD_CONFIG_INFO * ppConfigInfo
    );

DWORD
NET_API_FUNCTION
GdSetAdminInformation(
    IN      LPWSTR                  pszServer OPTIONAL,
    IN      LPGOPHERD_CONFIG_INFO   pConfigInfo
    );



//
//  API for Users enumeration  ( Not Yet Supported).
//

DWORD
NET_API_FUNCTION
GdEnumerateUsers(
    IN      LPWSTR      pszServer OPTIONAL,
    OUT     LPDWORD     lpnEntriesRead,
    OUT     LPGOPHERD_USER_INFO * lpUserBuffer
    );

DWORD
NET_API_FUNCTION
GdDisconnectUser(
    IN      LPWSTR      pszServer  OPTIONAL,
    IN      DWORD       dwIdUser
    );


//
// Statistics API
//

DWORD
NET_API_FUNCTION
GdGetStatistics(
    IN      LPWSTR      pszServer  OPTIONAL,
    OUT     LPBYTE      lpStatBuffer        // pass LPGOPHERD_STATISTICS_INFO
    );


DWORD
NET_API_FUNCTION
GdClearStatistics(
    IN      LPWSTR      pszServer  OPTIONAL
    );


/////////////////////////////////////////////////////////////////////////
//                                                                     //
//                  Catapult specific items                            //
//                                                                     //
/////////////////////////////////////////////////////////////////////////

# define INET_GATEWAY_INTERFACE_NAME    TEXT("gateway")


// preserve back ward compatibility
typedef INET_INFO_CONFIG_INFO    INETA_CONFIG_INFO,
                               * LPINETA_CONFIG_INFO;
typedef INET_INFO_IP_SEC_ENTRY   INETA_IP_SEC_ENTRY,
                               * LPINETA_IP_SEC_ENTRY;
typedef INET_INFO_IP_SEC_LIST    INETA_IP_SEC_LIST,
                               * LPINETA_IP_SEC_LIST;
typedef INET_INFO_VIRTUAL_ROOT_ENTRY  INETA_VIRTUAL_ROOT_ENTRY,
                               * LPINETA_VIRTUAL_ROOT_ENTRY;
typedef INET_INFO_VIRTUAL_ROOT_LIST  INETA_VIRTUAL_ROOT_LIST,
                               * LPINETA_VIRTUAL_ROOT_LIST;

typedef INET_INFO_GLOBAL_CONFIG_INFO   INETA_GLOBAL_CONFIG_INFO,
                               * LPINETA_GLOBAL_CONFIG_INFO;

typedef   INET_INFO_STATISTICS_0    INETA_STATISTICS_0,
                               * LPINETA_STATISTICS_0;

#define INETA_PARAMETERS_KEY    (INET_INFO_PARAMETERS_KEY)


#ifdef __cplusplus
}
#endif  // _cplusplus

#endif  // _INETINFO_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\inc\inetcom.h ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    inetcom.h

Abstract:

    This file contains contains global definitions for internet products.


Author:

    Madan Appiah (madana) 10-Oct-1995

Revision History:

--*/

#ifndef _INETCOM_H_
#define _INETCOM_H_

#ifdef __cplusplus
extern "C"
{
#endif  // _cplusplus

# include <lmcons.h>              // for definitions of NET_API*

#ifndef dllexp
# define dllexp     __declspec( dllexport)
#endif // dllexp

//
//  Server bitfield mask definitions
//
//  The services using the tsunami cache must be the lowest bits in the
//  bitfield.
//

#define INET_FTP                INET_FTP_SVC_ID
#define INET_GOPHER             INET_GOPHER_SVC_ID
#define INET_HTTP               INET_HTTP_SVC_ID

//
// service ids
//

#define INET_FTP_SVC_ID             0x00000001
#define INET_GOPHER_SVC_ID          0x00000002
#define INET_HTTP_SVC_ID            0x00000004
#define INET_DNS_SVC_ID             0x00000008

#define INET_HTTP_PROXY             0x00000010
#define INET_NNTP_SVC_ID            0x00000040
#define INET_SMTP_SVC_ID            0x00000080
#define INET_GATEWAY_SVC_ID         0x00000100
#define INET_POP3_SVC_ID            0x00000200
#define INET_CHAT_SVC_ID            0x00000400
#define INET_LDAP_SVC_ID            0x00000800
#define INET_IMAP_SVC_ID            0x00001000

//
//  structure Field Control defines
//

typedef DWORD FIELD_CONTROL;
typedef DWORD FIELD_FLAG;

//
//  Returns TRUE if the field specified by bitFlag is set
//

#define IsFieldSet(fc, bitFlag) \
    (((FIELD_CONTROL)(fc) & (FIELD_FLAG)(bitFlag)) != 0)

//
//  Indicates the field specified by bitFlag contains a valid value
//

#define SetField(fc, bitFlag) \
    ((FIELD_CONTROL)(fc) |= (FIELD_FLAG)(bitFlag))

//
//  Simple macro that sets the ith bit
//

#define BitFlag(i)                    ((0x1) << (i))


//
//  Values for Logging related parameters should match with values in
//       internet\svcs\inc\inetlog.h
//

//
// Log Type
//

#define INET_LOG_INVALID              ((DWORD ) -1)
#define INET_LOG_DISABLED             0
#define INET_LOG_TO_FILE              1
#define INET_LOG_TO_SQL               2

//
// Log File Periods -- options identifying logging periods for InetaLogToFile
//

#define INET_LOG_PERIOD_INVALID       ((DWORD)-1)
#define INET_LOG_PERIOD_NONE          0
#define INET_LOG_PERIOD_DAILY         1
#define INET_LOG_PERIOD_WEEKLY        2
#define INET_LOG_PERIOD_MONTHLY       3
#define INET_LOG_PERIOD_HOURLY        4
#define INET_LOG_PERIOD_YEARLY        5     // unsupported

//
// Log Format
//

#define INET_LOG_FORMAT_INTERNET_STD  0
#define INET_LOG_FORMAT_NCSA          3
#define INET_LOG_FORMAT_BINARY        1
#define INET_LOG_FORMAT_CUSTOM        2
#define INET_LOG_FORMAT_EXTENDED      2


# define MAX_TABLE_NAME_LEN            ( 30) // Most DBs support only 30 bytes
# define MAX_USER_NAME_LEN             ( UNLEN + 1)
# define MAX_PASSWORD_LEN              ( PWLEN + 1)


typedef struct _INET_LOG_CONFIGURATION
{

    DWORD   inetLogType;    // type of log.

    // File specific logging. (valid if inetLogType == INET_LOG_TO_FILE)
    DWORD   ilPeriod;              // one of Log File Periods

    // Empty string means do not modify existing default
    WCHAR   rgchLogFileDirectory[MAX_PATH]; // dest for log files

    // Zero value means do not modify the existing default.
    DWORD   cbSizeForTruncation;   // max size for each log file.


    // Sql specific logging (valid if inetLogType == INET_LOG_TO_SQL)
    // Empty string means do not modify existing default

    // rgchDataSource last 4 bytes will be the ilFormat for the log format
    // rgchDataSource second last 4 bytes will be the binary mask for the binary logging format

    WCHAR   rgchDataSource[MAX_PATH];    // ODBC data source name
    WCHAR   rgchTableName[MAX_TABLE_NAME_LEN];    // table name on data source
    WCHAR   rgchUserName[MAX_USER_NAME_LEN];
                                         // name of user for ODBC connections
    WCHAR   rgchPassword[MAX_PASSWORD_LEN];     // password for ODBC connection

} INET_LOG_CONFIGURATION, * LPINET_LOG_CONFIGURATION;


//
// Global statistics
//

typedef struct _INETA_CACHE_STATISTICS {

    //
    //  These are file handle cache counters (global only)
    //
    DWORD FilesCached;         // # of files currently in the cache
    DWORD TotalFilesCached;    // # of files added to the cache ever
    DWORD FileHits;            // cache hits
    DWORD FileMisses;          // cache misses
    DWORD FileFlushes;         // flushes due to dir change or other
    DWORDLONG CurrentFileCacheSize;// Current file cache size
    DWORDLONG MaximumFileCacheSize;// Maximum file cache size
    DWORD FlushedEntries;      // # of flushed entries still kicking around
    DWORD TotalFlushed;        // # of entries ever flushed from the cache

    //
    //  These are URI cache counters (global only)
    //
    DWORD URICached;           // # of files currently in the cache
    DWORD TotalURICached;      // # of files added to the cache ever
    DWORD URIHits;             // cache hits
    DWORD URIMisses;           // cache misses
    DWORD URIFlushes;          // flushes due to dir change or other
    DWORD TotalURIFlushed;     // # of entries ever flushed from the cache

    //
    //  These are blob cache counters (global only)
    //
    DWORD BlobCached;          // # of files currently in the cache
    DWORD TotalBlobCached;     // # of files added to the cache ever
    DWORD BlobHits;            // cache hits
    DWORD BlobMisses;          // cache misses
    DWORD BlobFlushes;         // flushes due to dir change or other
    DWORD TotalBlobFlushed;    // # of entries ever flushed from the cache

} INETA_CACHE_STATISTICS, *LPINETA_CACHE_STATISTICS;

typedef struct _INETA_ATQ_STATISTICS {

    // Numbers related to Atq Blocking, Rejections of requests
    DWORD         TotalBlockedRequests;
    DWORD         TotalRejectedRequests;
    DWORD         TotalAllowedRequests;
    DWORD         CurrentBlockedRequests;
    DWORD         MeasuredBandwidth;

} INETA_ATQ_STATISTICS, *LPINETA_ATQ_STATISTICS;

//
// service types for InternetConnect() and dirlist
//

#define INTERNET_SERVICE_FTP    1
#define INTERNET_SERVICE_GOPHER 2
#define INTERNET_SERVICE_HTTP   3


#ifdef __cplusplus
}
#endif  // _cplusplus


#endif  // _INETCOM_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\inc\infoimp.h ===
/*++

   Copyright    (c)    1994    Microsoft Corporation

   Module  Name :

        infoimp.h

   Abstract:
        This file allows us to include standard system headers files
          in the .idl file.
        The main .idl file imports a file called "imports.idl". This
          allows the .idl file to use the types defined in these headers.
        It also causes the following lines to be added to the MIDL generated
          files:
            # include "infoimp.h"

        Thus the routines and types defined here are available for RPC
            stub routines as well.

   Author:

           Murali R. Krishnan    ( MuraliK )    10-Nov-1994

   Project:

           Information Services Generic Imports file

   Revision History:

--*/

# ifndef _INFO_IMPORTS_H_
# define _INFO_IMPORTS_H_

# include <windef.h>
# include <lmcons.h>

#ifdef MIDL_PASS

#define  LPWSTR [string]  wchar_t *
#define  LPSTR  [string]  char*
#define  BOOL   DWORD

#endif // MIDL_PASS


#include "inetcom.h"
#include "inetinfo.h"
#include "apiutil.h"  // defines MIDL_user_allocate() & MIDL_user_free()

#endif // _INFO_IMPORTS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\inc\inetsvcs.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    inetsvcs.h

Abstract:

    Header file for Internet Services common data/functions.

Author:

    Murali R. Krishnan (MuraliK)   20-Feb-1996  - Migrated from old tcpsvcs.h

Revision History:

--*/

#ifndef _INETSVCS_H_
#define _INETSVCS_H_

//
// Service DLLs are loaded into master service executable (eg: inetinfo.exe)
//   All the dlls should export this entry point
//    defined by INETSVCS_ENTRY_POINT
//
// Note that INETSVCS_ENTRY_POINT_STRING is always ANSI, because that's
// what GetProcAddress takes.
//

#define INETSVCS_ENTRY_POINT         ServiceEntry
#define INETSVCS_ENTRY_POINT_STRING  "ServiceEntry"

//
// Start and stop RPC server entry point prototype.
//

typedef
DWORD
(*PTCPSVCS_START_RPC_SERVER_LISTEN) (
    VOID
    );

typedef
DWORD
(*PTCPSVCS_STOP_RPC_SERVER_LISTEN) (
    VOID
    );

//
// Structure containing "global" data for the various DLLs.
//

typedef struct _TCPSVCS_GLOBAL_DATA {

    //
    // Entry points provided by TCPSVCS.EXE.
    //

    PTCPSVCS_START_RPC_SERVER_LISTEN  StartRpcServerListen;
    PTCPSVCS_STOP_RPC_SERVER_LISTEN   StopRpcServerListen;

} TCPSVCS_GLOBAL_DATA, *PTCPSVCS_GLOBAL_DATA;

//
// Service DLL entry point prototype.
//

typedef
VOID
(*PINETSVCS_SERVICE_DLL_ENTRY) (
    IN DWORD argc,
    IN LPSTR argv[],
    IN PTCPSVCS_GLOBAL_DATA pGlobalData
    );


#ifndef _NO_TRACING_
#define IIS_PRINTF( x )        { char buff[256]; wsprintf x; DBGPRINTF( (DBG_CONTEXT, buff )); }
#else
#if DBG
#define IIS_PRINTF( x )        { char buff[256]; wsprintf x; OutputDebugString( buff ); }
#else
#define IIS_PRINTF( x )
#endif
#endif

#define BUG_PRINTF( x )        { char buff[256]; wsprintf x; OutputDebugString( buff ); }


#define INIT_LOCK(_lock)        InitializeCriticalSection( _lock );
#define DELETE_LOCK(_lock)      DeleteCriticalSection( _lock );
#define ACQUIRE_LOCK(_lock)     EnterCriticalSection( _lock );
#define RELEASE_LOCK(_lock)     LeaveCriticalSection( _lock );

#endif	// ifndef _INETSVCS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\inc\inetsec.h ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    inetsec.h

Abstract:

    Contains prototype and data definitions for user security objects
    creation and access check functions.

    Adapted the code from \nt\private\net\inc\secobj.h

Author:

    Madan Appiah (madana)  19-Sep-1995

Environment:

    User Mode - Win32

Revision History:

--*/

#ifndef _INETSEC_H_
#define _INETSEC_H_

#ifdef __cplusplus
extern "C" {
#endif

//
// Global declarations
//

//
// NT well-known SIDs
//

extern PSID NullSid;                   // No members SID
extern PSID WorldSid;                  // All users SID
extern PSID LocalSid;                  // NT local users SID
extern PSID NetworkSid;                // NT remote users SID
extern PSID LocalSystemSid;            // NT system processes SID
extern PSID BuiltinDomainSid;          // Domain Id of the Builtin Domain

//
// Well Known Aliases.
//
// These are aliases that are relative to the built-in domain.
//

extern PSID LocalAdminSid;             // NT local admins SID
extern PSID AliasAdminsSid;            // Administrator Sid
extern PSID AliasUsersSid;             // User Sid
extern PSID AliasGuestsSid;            // Guest Sid
extern PSID AliasPowerUsersSid;        // Power User Sid
extern PSID AliasAccountOpsSid;        // Account Operator Sid
extern PSID AliasSystemOpsSid;         // System Operator Sid
extern PSID AliasPrintOpsSid;          // Print Operator Sid
extern PSID AliasBackupOpsSid;         // Backup Operator Sid


//
// Structure to hold information about an ACE to be created
//

typedef struct {
    BYTE AceType;
    BYTE InheritFlags;
    BYTE AceFlags;
    ACCESS_MASK Mask;
    PSID *Sid;
} ACE_DATA, *PACE_DATA;

//
// Function prototypes
//

DWORD
INetCreateWellKnownSids(
    VOID
    );

VOID
INetFreeWellKnownSids(
    VOID
    );

DWORD
INetCreateSecurityObject(
    IN  PACE_DATA AceData,
    IN  ULONG AceCount,
    IN  PSID OwnerSid,
    IN  PSID GroupSid,
    IN  PGENERIC_MAPPING GenericMapping,
    OUT PSECURITY_DESCRIPTOR *NewDescriptor
    );

DWORD
INetDeleteSecurityObject(
    IN PSECURITY_DESCRIPTOR *Descriptor
    );

#ifdef UNICODE
#define INetAccessCheckAndAudit  INetAccessCheckAndAuditW
#else
#define INetAccessCheckAndAudit  INetAccessCheckAndAuditA
#endif // !UNICODE

DWORD
INetAccessCheckAndAuditA(
    IN  LPCSTR SubsystemName,
    IN  LPSTR ObjectTypeName,
    IN  PSECURITY_DESCRIPTOR SecurityDescriptor,
    IN  ACCESS_MASK DesiredAccess,
    IN  PGENERIC_MAPPING GenericMapping
    );

DWORD
INetAccessCheckAndAuditW(
    IN  LPCWSTR SubsystemName,
    IN  LPWSTR ObjectTypeName,
    IN  PSECURITY_DESCRIPTOR SecurityDescriptor,
    IN  ACCESS_MASK DesiredAccess,
    IN  PGENERIC_MAPPING GenericMapping
    );

DWORD
INetAccessCheck(
    IN  PSECURITY_DESCRIPTOR SecurityDescriptor,
    IN  ACCESS_MASK DesiredAccess,
    IN  PGENERIC_MAPPING GenericMapping
    );

#ifdef __cplusplus
}
#endif


#endif  // _INETSEC_H_


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\inc\iscaptrc.h ===
#ifndef _ISCAPTRC_H
#define _ISCAPTRC_H
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    iscaptrc.h

Abstract:

    Include file to contain variables required for capacity planning tracing
    of IIS.

Author:

    07-Nov-1998  SaurabN

Revision History:

--*/

//
//
//
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <wtypes.h>

#ifdef __cplusplus
extern "C"
{
#endif // __cplusplus

#include <wmistr.h>
#include <evntrace.h>

#ifdef __cplusplus
}
#endif // __cplusplus

# if !defined( dllexp)
# define dllexp               __declspec( dllexport)
# endif // !defined( dllexp)

dllexp
ULONG
_stdcall
IISInitializeCapTrace(
    PVOID Param
    );

dllexp 
DWORD 
GetIISCapTraceFlag();

dllexp 
TRACEHANDLE 
GetIISCapTraceLoggerHandle();

dllexp 
VOID 
SetIISCapTraceFlag(DWORD dwFlag);

typedef struct _IIS_CAP_TRACE_HEADER
{
	EVENT_TRACE_HEADER	TraceHeader;
	MOF_FIELD			TraceContext;

} IIS_CAP_TRACE_HEADER, *PIIS_CAP_TRACE_HEADER;

typedef struct _IIS_CAP_TRACE_INFO
{
	IIS_CAP_TRACE_HEADER	IISCapTraceHeader;
	MOF_FIELD				MofFields[3];
	
} IIS_CAP_TRACE_INFO, *PIIS_CAP_TRACE_INFO;

#endif /* _ISCAPTRC_H*/

#define IIS_CAP_TRACE_VERSION            1

//
// This is the control Guid for the group of Guids traced below
//

// {7380A4C4-7911-11d2-8BD7-080009DCC2FA}

DEFINE_GUID(IISCapControlGuid, 
0x7380a4c4, 0x7911, 0x11d2, 0x8b, 0xd7, 0x8, 0x0, 0x9, 0xdc, 0xc2, 0xfa);

//
// This is the trace guid
//

// {7380A4C5-7911-11d2-8BD7-080009DCC2FA}

DEFINE_GUID(IISCapTraceGuid, 
0x7380a4c5, 0x7911, 0x11d2, 0x8b, 0xd7, 0x8, 0x0, 0x9, 0xdc, 0xc2, 0xfa);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\inc\irtlmisc.h ===
/*++

   Copyright    (c)    1998    Microsoft Corporation

   Module  Name :
       irtlmisc.h

   Abstract:
       Declares miscellaneous functions and classes in IisRtl.DLL

   Author:
       George V. Reilly      (GeorgeRe)     06-Jan-1998

   Environment:
       Win32 - User Mode

   Project:
       Internet Information Server RunTime Library

   Revision History:

--*/


#ifndef __IRTLMISC_H__
#define __IRTLMISC_H__

#include <windows.h>

//--------------------------------------------------------------------
// These declarations are needed to export the template classes from
// IisRtl.DLL and import them into other modules.

#ifndef IRTL_DLLEXP
# ifdef DLL_IMPLEMENTATION
#  define IRTL_DLLEXP __declspec(dllexport)
#  ifdef IMPLEMENTATION_EXPORT
#   define IRTL_EXPIMP
#  else
#   undef  IRTL_EXPIMP
#  endif 
# elif defined LIB_IMPLEMENTATION
#  define IRTL_DLLEXP
#  define IRTL_EXPIMP extern
# else
#  define IRTL_DLLEXP __declspec(dllimport)
#  define IRTL_EXPIMP extern
# endif // !DLL_IMPLEMENTATION 
#endif // !IRTL_DLLEXP



//--------------------------------------------------------------------
// Miscellaneous functions

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus


// Heap routines
    
// Private IIS heap
HANDLE
WINAPI 
IisHeap();

// Allocate dwBytes
LPVOID
WINAPI
IisMalloc(
    IN SIZE_T dwBytes);

// Allocate dwBytes. Memory is zeroed
LPVOID
WINAPI
IisCalloc(
    IN SIZE_T dwBytes);

// Reallocate lpMem to dwBytes
LPVOID
WINAPI
IisReAlloc(
    IN LPVOID lpMem,
    IN SIZE_T dwBytes);

// Free lpMem
BOOL
WINAPI
IisFree(
    IN LPVOID lpMem);

// additional IISRTL initialization
BOOL
WINAPI 
InitializeIISRTL();

// call before unloading IISRTL
void
WINAPI 
TerminateIISRTL();

// case-insensitive strstr
IRTL_DLLEXP const char* stristr(const char* pszString, const char* pszSubString);

// how many CPUs on this machine?
inline int NumProcessors()
{
    static int s_nCPUs = 0;
    
    if (s_nCPUs == 0)
    {
        SYSTEM_INFO si;
        GetSystemInfo(&si);
        s_nCPUs = si.dwNumberOfProcessors;
    }
    return s_nCPUs;
}


// how many CPUs on this machine?
inline int ProcessorType()
{
    static int s_nProcessorType = 0;
    
    if (s_nProcessorType == 0)
    {
        SYSTEM_INFO si;
        GetSystemInfo(&si);
        s_nProcessorType = si.dwProcessorType;
    }
    return s_nProcessorType;
}


#ifdef __cplusplus
}
#endif // __cplusplus

#endif // __IRTLMISC_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\inc\irtldbg.h ===
/*++

   Copyright    (c)    1998    Microsoft Corporation

   Module  Name :
       irtldbg.h

   Abstract:
       Some simple debugging macros that look and behave a lot like their
       namesakes in MFC.  These macros should work in both C and C++ and do
       something useful with almost any Win32 compiler.

   Author:
       George V. Reilly      (GeorgeRe)     06-Jan-1998

   Environment:
       Win32 - User Mode

   Project:
       Internet Information Server RunTime Library

   Revision History:

--*/

#ifndef __IRTLDBG_H__
#define __IRTLDBG_H__

#ifndef __IRTLMISC_H__
# include <irtlmisc.h>
#endif

/* Ensure that MessageBoxes can popup */
# define RUNNING_AS_SERVICE 1

#include <tchar.h>


// Compile-time (not run-time) assertion. Code will not compile if
// expr is false. Note: there is no non-debug version of this; we
// want this for all builds. The compiler optimizes the code away.
template <bool> struct static_checker;
template <> struct static_checker<true> {};  // specialize only for `true'
#define STATIC_ASSERT(expr) static_checker< (expr) >()


# ifndef _AFX
  /* Assure compatiblity with MFC */

# ifdef _DEBUG
#  ifndef USE_DEBUG_CRTS
    /* IIS (and NT) do not ship msvcrtD.dll, per the VC license,
     * so we can't use the assertion code from <crtdbg.h>.  Use similar
     * macros from <pudebug.h> instead. */
#   include <pudebug.h>

    /* workaround for /W4 warnings about 'constant expressions' */
#   define IRTLASSERT(f)                                    \
    ((void) ((f) || (PuDbgAssertFailed(DBG_CONTEXT, #f), 0) ))

#  elif defined(_MSC_VER)  &&  (_MSC_VER >= 1000)
    /* Use the new debugging tools in Visual C++ 4.x */
#   include <crtdbg.h>
    /* _ASSERTE will give a more meaningful message, but the string takes
     * space.  Use _ASSERT if this is an issue. */
#   define IRTLASSERT(f) _ASSERTE(f)
#  else
#   include <assert.h>
#   define IRTLASSERT(f) assert(f)
#  endif

#  define IRTLVERIFY(f)           IRTLASSERT(f)
#  define DEBUG_ONLY(f)           (f)
#  define TRACE                   IrtlTrace
#  define TRACE0(psz)             IrtlTrace(_T("%s"), _T(psz))
#  define TRACE1(psz, p1)         IrtlTrace(_T(psz), p1)
#  define TRACE2(psz, p1, p2)     IrtlTrace(_T(psz), p1, p2)
#  define TRACE3(psz, p1, p2, p3) IrtlTrace(_T(psz), p1, p2, p3)
#  define ASSERT_VALID(pObj)  \
     do {IRTLASSERT((pObj) != NULL); (pObj)->AssertValid();} while (0)
#  define DUMP(pObj)  \
     do {IRTLASSERT((pObj) != NULL); (pObj)->Dump();} while (0)

# else /* !_DEBUG */

  /* These macros should all compile away to nothing */
#  define IRTLASSERT(f)           ((void)0)
#  define IRTLVERIFY(f)           ((void)(f))
#  define DEBUG_ONLY(f)           ((void)0)
#  define TRACE                   1 ? (void)0 : IrtlTrace
#  define TRACE0(psz)
#  define TRACE1(psz, p1)
#  define TRACE2(psz, p1, p2)
#  define TRACE3(psz, p1, p2, p3)
#  define ASSERT_VALID(pObj)      ((void)0)
#  define DUMP(pObj)              ((void)0)

# endif /* !_DEBUG */


# define ASSERT_POINTER(p, type) \
    IRTLASSERT(((p) != NULL)  &&  IsValidAddress((p), sizeof(type), FALSE))

# define ASSERT_NULL_OR_POINTER(p, type) \
    IRTLASSERT(((p) == NULL)  ||  IsValidAddress((p), sizeof(type), FALSE))

#define ASSERT_STRING(s) \
    IRTLASSERT(((s) != NULL)  &&  IsValidString((s), -1))

#define ASSERT_NULL_OR_STRING(s) \
    IRTLASSERT(((s) == NULL)  ||  IsValidString((s), -1))


/* Declarations for non-Windows apps */

# ifndef _WINDEF_
typedef void*           LPVOID;
typedef const void*     LPCVOID;
typedef unsigned int    UINT;
typedef int             BOOL;
typedef const char*     LPCTSTR;
# endif /* _WINDEF_ */

# ifndef TRUE
#  define FALSE  0
#  define TRUE   1
# endif


# ifdef __cplusplus
extern "C" {

/* Low-level sanity checks for memory blocks */
IRTL_DLLEXP BOOL IsValidAddress(LPCVOID pv, UINT nBytes, BOOL fReadWrite = TRUE);
IRTL_DLLEXP BOOL IsValidString(LPCTSTR ptsz, int nLength = -1);

}

# else /* !__cplusplus */

/* Low-level sanity checks for memory blocks */
IRTL_DLLEXP BOOL IsValidAddress(LPCVOID pv, UINT nBytes, BOOL fReadWrite);
IRTL_DLLEXP BOOL IsValidString(LPCTSTR ptsz, int nLength);

# endif /* !__cplusplus */

#endif /* !_AFX */


/* Writes trace messages to debug stream */
extern
#ifdef __cplusplus
"C"
#endif /* !__cplusplus */
IRTL_DLLEXP
void __cdecl
IrtlTrace(
    LPCTSTR pszFormat,
    ...);


#ifdef _DEBUG
# define IRTL_DEBUG_INIT()            IrtlDebugInit()
# define IRTL_DEBUG_TERM()            IrtlDebugTerm()
#else /* !_DEBUG */
# define IRTL_DEBUG_INIT()            ((void)0)
# define IRTL_DEBUG_TERM()            ((void)0)
#endif /* !_DEBUG */


#ifdef __cplusplus
extern "C" {
#endif /* __cplusplus */

/* should be called from main(), WinMain(), or DllMain() */
IRTL_DLLEXP void
IrtlDebugInit();

IRTL_DLLEXP void
IrtlDebugTerm();

#ifdef __cplusplus
}
#endif /* __cplusplus */

#endif /* __IRTLDBG_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\inc\logconst.h ===
/*++

   Copyright    (c)    1997    Microsoft Corporation

   Module  Name :

       logconst.h

   Abstract:

        Contains the constant declarations for logging.

   Author:

        Unknown

--*/

#ifndef _LOGCONST_H_
#define _LOGCONST_H_

//
// Field masks for extended logging
//      Fields are logged in order of increasing mask value
//

#define EXTLOG_DATE                 MD_EXTLOG_DATE
#define EXTLOG_TIME                 MD_EXTLOG_TIME
#define EXTLOG_CLIENT_IP            MD_EXTLOG_CLIENT_IP
#define EXTLOG_USERNAME             MD_EXTLOG_USERNAME
#define EXTLOG_SITE_NAME            MD_EXTLOG_SITE_NAME
#define EXTLOG_COMPUTER_NAME        MD_EXTLOG_COMPUTER_NAME
#define EXTLOG_SERVER_IP            MD_EXTLOG_SERVER_IP
#define EXTLOG_METHOD               MD_EXTLOG_METHOD
#define EXTLOG_URI_STEM             MD_EXTLOG_URI_STEM
#define EXTLOG_URI_QUERY            MD_EXTLOG_URI_QUERY
#define EXTLOG_HTTP_STATUS          MD_EXTLOG_HTTP_STATUS
#define EXTLOG_WIN32_STATUS         MD_EXTLOG_WIN32_STATUS
#define EXTLOG_BYTES_SENT           MD_EXTLOG_BYTES_SENT
#define EXTLOG_BYTES_RECV           MD_EXTLOG_BYTES_RECV
#define EXTLOG_TIME_TAKEN           MD_EXTLOG_TIME_TAKEN
#define EXTLOG_SERVER_PORT          MD_EXTLOG_SERVER_PORT
#define EXTLOG_USER_AGENT           MD_EXTLOG_USER_AGENT
#define EXTLOG_COOKIE               MD_EXTLOG_COOKIE
#define EXTLOG_REFERER              MD_EXTLOG_REFERER
#define EXTLOG_PROTOCOL_VERSION     MD_EXTLOG_PROTOCOL_VERSION
#define EXTLOG_HOST                 MD_EXTLOG_HOST

#define DEFAULT_EXTLOG_FIELDS       (EXTLOG_CLIENT_IP | \
                                     EXTLOG_TIME      | \
                                     EXTLOG_METHOD    | \
                                     EXTLOG_URI_STEM  | \
                                     EXTLOG_HTTP_STATUS)

#define EXTLOG_VERSION              "1.0"

//
// names associated with fields
//

#define EXTLOG_CLIENT_IP_ID         "c-ip"
#define EXTLOG_SERVER_IP_ID         "s-ip"
#define EXTLOG_DATE_ID              "date"
#define EXTLOG_TIME_ID              "time"
#define EXTLOG_TIME_TAKEN_ID        "time-taken"
#define EXTLOG_METHOD_ID            "cs-method"
#define EXTLOG_URI_STEM_ID          "cs-uri-stem"
#define EXTLOG_URI_QUERY_ID         "cs-uri-query"
#define EXTLOG_HTTP_STATUS_ID       "sc-status"
#define EXTLOG_WIN32_STATUS_ID      "sc-win32-status"
#define EXTLOG_USERNAME_ID          "cs-username"
#define EXTLOG_COOKIE_ID            "cs(Cookie)"
#define EXTLOG_USER_AGENT_ID        "cs(User-Agent)"
#define EXTLOG_REFERER_ID           "cs(Referer)"
#define EXTLOG_COMPUTER_NAME_ID     "s-computername"
#define EXTLOG_SITE_NAME_ID         "s-sitename"
#define EXTLOG_BYTES_SENT_ID        "sc-bytes"
#define EXTLOG_BYTES_RECV_ID        "cs-bytes"
#define EXTLOG_SERVER_PORT_ID       "s-port"
#define EXTLOG_PROTOCOL_VERSION_ID  "cs-version"
#define EXTLOG_HOST_ID              "cs-host"
#define EXTLOG_HTTP_SUB_STATUS_ID   "sc-substatus"

#endif // _LOGCONST_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\inc\llsapi.h ===
/*++

Copyright (c) 1994-95  Microsoft Corporation

Module Name:

   llsapi.h

Abstract:

   License logging server's RPC API's.

Author:

   Arthur Hanson (arth) 21-Mar-1995

Environment:

   User Mode - Win32

Revision History:

   Jeff Parham (jeffparh) 04-Dec-1995
      o  Added type definitions, macros, and prototypes for extended RPC APIs
         and license certificate APIs (available only post-3.51).
      o  Corrected prototypes for LlsServerEnumW(), LlsServerEnumA(),
         LlsLocalProductInfoGetW(), and LlsLocalProductInfoGetA().

--*/

#ifndef _LLSAPI_H
#define _LLSAPI_H

#ifdef __cplusplus
extern "C" {
#endif


#define LLS_FLAG_LICENSED           0x0001
#define LLS_FLAG_UPDATE             0x0002
#define LLS_FLAG_SUITE_USE          0x0004
#define LLS_FLAG_SUITE_AUTO         0x0008

#define LLS_FLAG_PRODUCT_PERSEAT    0x0010
#define LLS_FLAG_PRODUCT_SWITCH     0x0020

#define LLS_FLAG_DELETED            0x1000


typedef PVOID LLS_HANDLE, *PLLS_HANDLE;
typedef PVOID LLS_REPL_HANDLE, *PLLS_REPL_HANDLE;

#define LLS_INVALID_LICENSE_HANDLE  ( 0xFFFFFFFF )

#define LLS_NUM_SECRETS             ( 4 )

typedef struct _LLS_LICENSE_INFO_0 {
   LPTSTR Product;
   LONG   Quantity;
   DWORD  Date;
   LPTSTR Admin;
   LPTSTR Comment;
} LLS_LICENSE_INFO_0, *PLLS_LICENSE_INFO_0;

typedef struct _LLS_LICENSE_INFO_1 {
   LPTSTR Product;
   LPTSTR Vendor;
   LONG   Quantity;
   DWORD  MaxQuantity;
   DWORD  Date;
   LPTSTR Admin;
   LPTSTR Comment;
   DWORD  AllowedModes;
   DWORD  CertificateID;
   LPTSTR Source;
   DWORD  ExpirationDate;
   DWORD  Secrets[ LLS_NUM_SECRETS ];
} LLS_LICENSE_INFO_1, *PLLS_LICENSE_INFO_1;

typedef struct _LLS_PRODUCT_INFO_0 {
   LPTSTR Product;
} LLS_PRODUCT_INFO_0, *PLLS_PRODUCT_INFO_0;

typedef struct _LLS_PRODUCT_INFO_1 {
   LPTSTR Product;
   ULONG  Purchased;
   ULONG  InUse;
   ULONG  ConcurrentTotal;
   ULONG  HighMark;
} LLS_PRODUCT_INFO_1, *PLLS_PRODUCT_INFO_1;

typedef struct _LLS_PRODUCT_USER_INFO_0 {
   LPTSTR User;
} LLS_PRODUCT_USER_INFO_0, *PLLS_PRODUCT_USER_INFO_0;

typedef struct _LLS_PRODUCT_USER_INFO_1 {
   LPTSTR User;
   DWORD  Flags;
   DWORD  LastUsed;
   ULONG  UsageCount;
} LLS_PRODUCT_USER_INFO_1, *PLLS_PRODUCT_USER_INFO_1;


typedef struct _LLS_PRODUCT_LICENSE_INFO_0 {
   LONG   Quantity;
   DWORD  Date;
   LPTSTR Admin;
   LPTSTR Comment;
} LLS_PRODUCT_LICENSE_INFO_0, *PLLS_PRODUCT_LICENSE_INFO_0;

typedef struct _LLS_PRODUCT_LICENSE_INFO_1 {
   LONG   Quantity;
   DWORD  MaxQuantity;
   DWORD  Date;
   LPTSTR Admin;
   LPTSTR Comment;
   DWORD  AllowedModes;
   DWORD  CertificateID;
   LPTSTR Source;
   DWORD  ExpirationDate;
   DWORD  Secrets[ LLS_NUM_SECRETS ];
} LLS_PRODUCT_LICENSE_INFO_1, *PLLS_PRODUCT_LICENSE_INFO_1;

typedef struct _LLS_USER_INFO_0 {
   LPTSTR Name;
} LLS_USER_INFO_0, *PLLS_USER_INFO_0;

typedef struct _LLS_USER_INFO_1 {
   LPTSTR Name;
   DWORD  Flags;
   LPTSTR Group;
   ULONG  Licensed;
   ULONG  UnLicensed;
} LLS_USER_INFO_1, *PLLS_USER_INFO_1;

typedef struct _LLS_USER_INFO_2 {
   LPTSTR Name;
   DWORD  Flags;
   LPTSTR Group;
   ULONG  Licensed;
   ULONG  UnLicensed;
   LPTSTR Products;
} LLS_USER_INFO_2, *PLLS_USER_INFO_2;

typedef struct _LLS_USER_PRODUCT_INFO_0 {
   LPTSTR Product;
} LLS_USER_PRODUCT_INFO_0, *PLLS_USER_PRODUCT_INFO_0;

typedef struct _LLS_USER_PRODUCT_INFO_1 {
   LPTSTR Product;
   DWORD  Flags;
   DWORD  LastUsed;
   ULONG  UsageCount;
} LLS_USER_PRODUCT_INFO_1, *PLLS_USER_PRODUCT_INFO_1;

typedef struct _LLS_GROUP_INFO_0 {
   LPTSTR Name;
} LLS_GROUP_INFO_0, *PLLS_GROUP_INFO_0;

typedef struct _LLS_GROUP_INFO_1 {
   LPTSTR Name;
   LPTSTR Comment;
   ULONG  Licenses;
} LLS_GROUP_INFO_1, *PLLS_GROUP_INFO_1;


#define LLS_REPLICATION_TYPE_DELTA  0
#define LLS_REPLICATION_TYPE_TIME   1

#define LLS_MODE_LICENSE_SERVER     0
#define LLS_MODE_PDC                1
#define LLS_MODE_ENTERPRISE_SERVER  2

typedef struct _LLS_SERVICE_INFO_0 {
   DWORD Version;
   DWORD TimeStarted;
   DWORD Mode;
   LPTSTR ReplicateTo;
   LPTSTR EnterpriseServer;
   DWORD ReplicationType;
   DWORD ReplicationTime;
   DWORD UseEnterprise;
   DWORD LastReplicated;
} LLS_SERVICE_INFO_0, *PLLS_SERVICE_INFO_0;

typedef struct _LLS_CONNECT_INFO_0 {
   LPTSTR Domain;
   LPTSTR EnterpriseServer;
} LLS_CONNECT_INFO_0, *PLLS_CONNECT_INFO_0;


typedef struct _LLS_SERVER_PRODUCT_INFO_0 {
   LPTSTR Name;
} LLS_SERVER_PRODUCT_INFO_0, *PLLS_SERVER_PRODUCT_INFO_0;

typedef struct _LLS_SERVER_PRODUCT_INFO_1 {
   LPTSTR Name;
   DWORD Flags;
   ULONG MaxUses;
   ULONG MaxSetUses;
   ULONG HighMark;
} LLS_SERVER_PRODUCT_INFO_1, *PLLS_SERVER_PRODUCT_INFO_1;


typedef struct _LLS_SERVER_INFO_0 {
   LPTSTR Name;
} LLS_SERVER_INFO_0, *PLLS_SERVER_INFO_0;

typedef struct _LLS_CERTIFICATE_CLAIM_INFO_0
{
   TCHAR    ServerName[ 1 + MAX_COMPUTERNAME_LENGTH ];
   LONG     Quantity;
} LLS_CERTIFICATE_CLAIM_INFO_0, *PLLS_CERTIFICATE_CLAIM_INFO_0;

typedef struct _LLS_LOCAL_SERVICE_INFO_0
{
   LPTSTR   KeyName;
   LPTSTR   DisplayName;
   LPTSTR   FamilyDisplayName;
   DWORD    Mode;
   DWORD    FlipAllow;
   DWORD    ConcurrentLimit;
   DWORD    HighMark;
} LLS_LOCAL_SERVICE_INFO_0, *PLLS_LOCAL_SERVICE_INFO_0;

#define LLS_LICENSE_MODE_PER_SEAT            ( 0 )
#define LLS_LICENSE_MODE_PER_SERVER          ( 1 )

#define LLS_LICENSE_MODE_ALLOW_PER_SEAT      ( 1 )
#define LLS_LICENSE_MODE_ALLOW_PER_SERVER    ( 2 )

#define LLS_LICENSE_FLIP_ALLOW_PER_SEAT      ( 1 )
#define LLS_LICENSE_FLIP_ALLOW_PER_SERVER    ( 2 )


// capability flags; query with LlsCapabilityIsSupported
#define LLS_CAPABILITY_SECURE_CERTIFICATES         (  0 )
#define LLS_CAPABILITY_REPLICATE_CERT_DB           (  1 )
#define LLS_CAPABILITY_REPLICATE_PRODUCT_SECURITY  (  2 )
#define LLS_CAPABILITY_REPLICATE_USERS_EX          (  3 )
#define LLS_CAPABILITY_SERVICE_INFO_GETW           (  4 )
#define LLS_CAPABILITY_LOCAL_SERVICE_API           (  5 )
#define LLS_CAPABILITY_MAX                         ( 32 )


//***************************************************
//* Nt LS API data constants
//* (for use with LlsLicenseRequest() API)
//***************************************************

#define NT_LS_USER_NAME               ((ULONG) 0)  // username only
#define NT_LS_USER_SID                ((ULONG) 1)  // SID only


#ifndef NO_LLS_APIS
//
// Connection control API's
//

NTSTATUS
NTAPI
LlsConnectW(
   IN  LPWSTR Server,
   OUT PLLS_HANDLE Handle
   );

NTSTATUS
NTAPI
LlsConnectA(
   IN  LPSTR Server,
   OUT PLLS_HANDLE Handle
   );
#ifdef UNICODE
#  define LlsConnect LlsConnectW
#else
#  define LlsConnect LlsConnectA
#endif

typedef NTSTATUS (NTAPI *PLLS_CONNECT_W)( LPWSTR, PLLS_HANDLE );
typedef NTSTATUS (NTAPI *PLLS_CONNECT_A)( LPSTR,  PLLS_HANDLE );

NTSTATUS
NTAPI
LlsConnectEnterpriseW(
   IN  LPWSTR Focus,
   OUT PLLS_HANDLE Handle,
   IN  DWORD Level,
   OUT LPBYTE *bufptr
   );

NTSTATUS
NTAPI
LlsConnectEnterpriseA(
   IN  LPSTR Focus,
   OUT PLLS_HANDLE Handle,
   IN  DWORD Level,
   OUT LPBYTE *bufptr
   );
#ifdef UNICODE
#define LlsConnectEnterprise LlsConnectEnterpriseW
#else
#define LlsConnectEnterprise LlsConnectEnterpriseA
#endif

typedef NTSTATUS (NTAPI *PLLS_CONNECT_ENTERPRISE_W)( LPWSTR, PLLS_HANDLE, DWORD, LPBYTE * );
typedef NTSTATUS (NTAPI *PLLS_CONNECT_ENTERPRISE_A)( LPSTR,  PLLS_HANDLE, DWORD, LPBYTE * );

NTSTATUS 
NTAPI
LlsClose(        
   IN LLS_HANDLE Handle
   );

typedef NTSTATUS (NTAPI *PLLS_CLOSE)( LLS_HANDLE );

NTSTATUS 
NTAPI
LlsFreeMemory(
    IN PVOID bufptr
    );

typedef NTSTATUS (NTAPI *PLLS_FREE_MEMORY)( PVOID );

NTSTATUS
NTAPI
LlsEnterpriseServerFindW(
   IN  LPWSTR Focus,
   IN  DWORD Level,
   OUT LPBYTE *bufptr
   );

NTSTATUS
NTAPI
LlsEnterpriseServerFindA(
   IN  LPSTR Focus,
   IN  DWORD Level,
   OUT LPBYTE *bufptr
   );
#ifdef UNICODE
#define LlsEnterpriseServerFind LlsEnterpriseServerFindW
#else
#define LlsEnterpriseServerFind LlsEnterpriseServerFindA
#endif

//
// License control API's
//

// Enum purchase history of licenses for all products.
NTSTATUS
NTAPI
LlsLicenseEnumW(
   IN     LLS_HANDLE Handle,
   IN     DWORD      Level,     // Level 0 supported
   OUT    LPBYTE*    bufptr,    
   IN     DWORD      prefmaxlen,
   OUT    LPDWORD    EntriesRead,
   OUT    LPDWORD    TotalEntries,
   IN OUT LPDWORD    ResumeHandle
   );

NTSTATUS
NTAPI
LlsLicenseEnumA(
   IN     LLS_HANDLE Handle,
   IN     DWORD      Level,     // Level 0 supported
   OUT    LPBYTE*    bufptr,    
   IN     DWORD      prefmaxlen,
   OUT    LPDWORD    EntriesRead,
   OUT    LPDWORD    TotalEntries,
   IN OUT LPDWORD    ResumeHandle
   );
#ifdef UNICODE
#define LlsLicenseEnum LlsLicenseEnumW
#else
#define LlsLicenseEnum LlsLicenseEnumA
#endif

// Add purchase of license for a product.
NTSTATUS
NTAPI
LlsLicenseAddW(
   IN LLS_HANDLE Handle,
   IN DWORD      Level,         // Level 0 supported
   IN LPBYTE     bufptr
   );

NTSTATUS
NTAPI
LlsLicenseAddA(
   IN LLS_HANDLE Handle,
   IN DWORD      Level,         // Level 0 supported
   IN LPBYTE     bufptr
   );
#ifdef UNICODE
#define LlsLicenseAdd LlsLicenseAddW
#else
#define LlsLicenseAdd LlsLicenseAddA
#endif

typedef NTSTATUS (NTAPI *PLLS_LICENSE_ADD_W)( LLS_HANDLE, DWORD, LPBYTE );
typedef NTSTATUS (NTAPI *PLLS_LICENSE_ADD_A)( LLS_HANDLE, DWORD, LPBYTE );

//
// Product control API's
//
// Product is SQL, BackOffice, Exchange, Etc. (Even though BackOffice isn't
// a product - we count it like one to keep things simplistic.
//

// Enum all products with purchase and InUse info.
NTSTATUS
NTAPI
LlsProductEnumW(
   IN     LLS_HANDLE Handle,
   IN     DWORD      Level,     // Levels 0,1 supported
   OUT    LPBYTE*    bufptr,
   IN     DWORD      prefmaxlen,
   OUT    LPDWORD    EntriesRead,
   OUT    LPDWORD    TotalEntries,
   IN OUT LPDWORD    ResumeHandle
   );

NTSTATUS
NTAPI
LlsProductEnumA(
   IN     LLS_HANDLE Handle,
   IN     DWORD      Level,     // Levels 0,1 supported
   OUT    LPBYTE*    bufptr,
   IN     DWORD      prefmaxlen,
   OUT    LPDWORD    EntriesRead,
   OUT    LPDWORD    TotalEntries,
   IN OUT LPDWORD    ResumeHandle
   );
#ifdef UNICODE
#define LlsProductEnum LlsProductEnumW
#else
#define LlsProductEnum LlsProductEnumA
#endif

// Add purchase of license for a product.
NTSTATUS
NTAPI
LlsProductAddW(
   IN LLS_HANDLE Handle,
   IN LPWSTR ProductFamily,
   IN LPWSTR Product,
   IN LPWSTR Version
   );

NTSTATUS
NTAPI
LlsProductAddA(
   IN LLS_HANDLE Handle,
   IN LPSTR ProductFamily,
   IN LPSTR Product,
   IN LPSTR Version
   );
#ifdef UNICODE
#define LlsProductAdd LlsProductAddW
#else
#define LlsProductAdd LlsProductAddA
#endif

// For a particular product enum all users.
NTSTATUS
NTAPI
LlsProductUserEnumW(
   IN     LLS_HANDLE Handle,
   IN     LPWSTR     Product,
   IN     DWORD      Level,     // Levels 0,1 supported
   OUT    LPBYTE*    bufptr,
   IN     DWORD      prefmaxlen,
   OUT    LPDWORD    EntriesRead,
   OUT    LPDWORD    TotalEntries,
   IN OUT LPDWORD    ResumeHandle
   );

NTSTATUS
NTAPI
LlsProductUserEnumA(
   IN     LLS_HANDLE Handle,
   IN     LPSTR      Product,
   IN     DWORD      Level,     // Levels 0,1 supported
   OUT    LPBYTE*    bufptr,
   IN     DWORD      prefmaxlen,
   OUT    LPDWORD    EntriesRead,
   OUT    LPDWORD    TotalEntries,
   IN OUT LPDWORD    ResumeHandle
   );
#ifdef UNICODE
#define LlsProductUserEnum LlsProductUserEnumW
#else
#define LlsProductUserEnum LlsProductUserEnumA
#endif

// For a particular product enum all license purchases.
NTSTATUS
NTAPI
LlsProductLicenseEnumW(
   IN     LLS_HANDLE Handle,
   IN     LPWSTR     Product,
   IN     DWORD      Level,     // Level 0 supported
   OUT    LPBYTE*    bufptr,   
   IN     DWORD      prefmaxlen, 
   OUT    LPDWORD    EntriesRead,
   OUT    LPDWORD    TotalEntries,
   IN OUT LPDWORD    ResumeHandle
   );

NTSTATUS
NTAPI
LlsProductLicenseEnumA(
   IN     LLS_HANDLE Handle,
   IN     LPSTR      Product,
   IN     DWORD      Level,     // Level 0 supported
   OUT    LPBYTE*    bufptr,   
   IN     DWORD      prefmaxlen, 
   OUT    LPDWORD    EntriesRead,
   OUT    LPDWORD    TotalEntries,
   IN OUT LPDWORD    ResumeHandle
   );
#ifdef UNICODE
#define LlsProductLicenseEnum LlsProductLicenseEnumW
#else
#define LlsProductLicenseEnum LlsProductLicenseEnumA
#endif


// For given product enum all servers with concurrent limits
NTSTATUS
NTAPI
LlsProductServerEnumW(
   IN     LLS_HANDLE Handle,
   IN     LPWSTR     Product,
   IN     DWORD      Level,     // Levels 0,1 supported
   OUT    LPBYTE*    bufptr,      
   IN     DWORD      prefmaxlen,  
   OUT    LPDWORD    EntriesRead,
   OUT    LPDWORD    TotalEntries,
   IN OUT LPDWORD    ResumeHandle
   );

NTSTATUS
NTAPI
LlsProductServerEnumA(
   IN     LLS_HANDLE Handle,
   IN     LPSTR      Product,
   IN     DWORD      Level,     // Levels 0,1 supported
   OUT    LPBYTE*    bufptr,      
   IN     DWORD      prefmaxlen,  
   OUT    LPDWORD    EntriesRead,
   OUT    LPDWORD    TotalEntries,
   IN OUT LPDWORD    ResumeHandle
   );
#ifdef UNICODE
#define LlsProductServerEnum LlsProductServerEnumW
#else
#define LlsProductServerEnum LlsProductServerEnumA
#endif
//
//  User control API's
//  A user can be a mapped user or a normal user
//

// Enums all users
NTSTATUS
NTAPI
LlsUserEnumW(
   IN     LLS_HANDLE Handle,
   IN     DWORD      Level,     // Levels 0,1 supported
   OUT    LPBYTE*    bufptr,
   IN     DWORD      prefmaxlen,
   OUT    LPDWORD    EntriesRead,
   OUT    LPDWORD    TotalEntries,
   IN OUT LPDWORD    ResumeHandle
   );

NTSTATUS
NTAPI
LlsUserEnumA(
   IN     LLS_HANDLE Handle,
   IN     DWORD      Level,     // Levels 0,1 supported
   OUT    LPBYTE*    bufptr,
   IN     DWORD      prefmaxlen,
   OUT    LPDWORD    EntriesRead,
   OUT    LPDWORD    TotalEntries,
   IN OUT LPDWORD    ResumeHandle
   );
#ifdef UNICODE
#define LlsUserEnum LlsUserEnumW
#else
#define LlsUserEnum LlsUserEnumA
#endif

// Info is Group and whether to force back-office license
NTSTATUS
NTAPI
LlsUserInfoGetW(
   IN  LLS_HANDLE Handle,
   IN  LPWSTR     User,
   IN  DWORD      Level,    // Level 1 supported
   OUT LPBYTE*    bufptr
   );

NTSTATUS
NTAPI
LlsUserInfoGetA(
   IN  LLS_HANDLE Handle,
   IN  LPSTR      User,
   IN  DWORD      Level,    // Level 1 supported
   OUT LPBYTE*    bufptr
   );
#ifdef UNICODE
#define LlsUserInfoGet LlsUserInfoGetW
#else
#define LlsUserInfoGet LlsUserInfoGetA
#endif

NTSTATUS
NTAPI
LlsUserInfoSetW(
   IN LLS_HANDLE Handle,
   IN LPWSTR     User,
   IN DWORD      Level,
   IN LPBYTE     bufptr     // Level 1 supported
   );

NTSTATUS
NTAPI
LlsUserInfoSetA(
   IN LLS_HANDLE Handle,
   IN LPSTR      User,
   IN DWORD      Level,
   IN LPBYTE     bufptr     // Level 1 supported
   );
#ifdef UNICODE
#define LlsUserInfoSet LlsUserInfoSetW
#else
#define LlsUserInfoSet LlsUserInfoSetA
#endif

NTSTATUS
NTAPI
LlsUserDeleteW(
   IN LLS_HANDLE Handle,
   IN LPWSTR     User
   );

NTSTATUS
NTAPI
LlsUserDeleteA(
   IN LLS_HANDLE Handle,
   IN LPSTR     User
   );
#ifdef UNICODE
#define LlsUserDelete LlsUserDeleteW
#else
#define LlsUserDelete LlsUserDeleteA
#endif

// For a given user enums all license useages
NTSTATUS
NTAPI
LlsUserProductEnumW(
   IN     LLS_HANDLE Handle,
   IN     LPWSTR     User,
   IN     DWORD      Level,     // Levels 0,1 supported
   OUT    LPBYTE*    bufptr,
   IN     DWORD      prefmaxlen,
   OUT    LPDWORD    EntriesRead,
   OUT    LPDWORD    TotalEntries,
   IN OUT LPDWORD    ResumeHandle
   );

NTSTATUS
NTAPI
LlsUserProductEnumA(
   IN     LLS_HANDLE Handle,
   IN     LPSTR      User,
   IN     DWORD      Level,     // Levels 0,1 supported
   OUT    LPBYTE*    bufptr,
   IN     DWORD      prefmaxlen,
   OUT    LPDWORD    EntriesRead,
   OUT    LPDWORD    TotalEntries,
   IN OUT LPDWORD    ResumeHandle
   );
#ifdef UNICODE
#define LlsUserProductEnum LlsUserProductEnumW
#else
#define LlsUserProductEnum LlsUserProductEnumA
#endif

// For a given user deletes a license useage
NTSTATUS
NTAPI
LlsUserProductDeleteW(
   IN LLS_HANDLE Handle,
   IN LPWSTR     User,
   IN LPWSTR     Product
   );

NTSTATUS
NTAPI
LlsUserProductDeleteA(
   IN LLS_HANDLE Handle,
   IN LPSTR      User,
   IN LPSTR      Product
   );
#ifdef UNICODE
#define LlsUserProductDelete LlsUserProductDeleteW
#else
#define LlsUserProductDelete LlsUserProductDeleteA
#endif

//
// Group control API's
//

// Enums all user Groups
NTSTATUS
NTAPI
LlsGroupEnumW(
   IN     LLS_HANDLE Handle,
   IN     DWORD      Level,     // Levels 0,1 supported
   OUT    LPBYTE*    bufptr,
   IN     DWORD      prefmaxlen,
   OUT    LPDWORD    EntriesRead,
   OUT    LPDWORD    TotalEntries,
   IN OUT LPDWORD    ResumeHandle
   );

NTSTATUS
NTAPI
LlsGroupEnumA(
   IN     LLS_HANDLE Handle,
   IN     DWORD      Level,     // Levels 0,1 supported
   OUT    LPBYTE*    bufptr,
   IN     DWORD      prefmaxlen,
   OUT    LPDWORD    EntriesRead,
   OUT    LPDWORD    TotalEntries,
   IN OUT LPDWORD    ResumeHandle
   );
#ifdef UNICODE
#define LlsGroupEnum LlsGroupEnumW
#else
#define LlsGroupEnum LlsGroupEnumA
#endif

// For given Group gets info, info is name, comment and # licenses used
NTSTATUS
NTAPI
LlsGroupInfoGetW(
   IN  LLS_HANDLE Handle,
   IN  LPWSTR     Group,
   IN  DWORD      Level,    // Level 1 supported
   OUT LPBYTE*    bufptr
   );

NTSTATUS
NTAPI
LlsGroupInfoGetA(
   IN  LLS_HANDLE Handle,
   IN  LPSTR      Group,
   IN  DWORD      Level,    // Level 1 supported
   OUT LPBYTE*    bufptr
   );
#ifdef UNICODE
#define LlsGroupInfoGet LlsGroupInfoGetW
#else
#define LlsGroupInfoGet LlsGroupInfoGetA
#endif

NTSTATUS
NTAPI
LlsGroupInfoSetW(
   IN LLS_HANDLE Handle,
   IN LPWSTR     Group,
   IN DWORD      Level,     // Level 1 supported
   IN LPBYTE     bufptr
   );

NTSTATUS
NTAPI
LlsGroupInfoSetA(
   IN LLS_HANDLE Handle,
   IN LPSTR      Group,
   IN DWORD      Level,     // Level 1 supported
   IN LPBYTE     bufptr
   );
#ifdef UNICODE
#define LlsGroupInfoSet LlsGroupInfoSetW
#else
#define LlsGroupInfoSet LlsGroupInfoSetA
#endif

// For given Group enum all users
NTSTATUS
NTAPI
LlsGroupUserEnumW(
   IN     LLS_HANDLE Handle,
   IN     LPWSTR     Group,
   IN     DWORD      Level,     // Levels 0,1 supported
   OUT    LPBYTE*    bufptr,      
   IN     DWORD      prefmaxlen,  
   OUT    LPDWORD    EntriesRead,
   OUT    LPDWORD    TotalEntries,
   IN OUT LPDWORD    ResumeHandle
   );

NTSTATUS
NTAPI
LlsGroupUserEnumA(
   IN     LLS_HANDLE Handle,
   IN     LPSTR      Group,
   IN     DWORD      Level,     // Levels 0,1 supported
   OUT    LPBYTE*    bufptr,      
   IN     DWORD      prefmaxlen,  
   OUT    LPDWORD    EntriesRead,
   OUT    LPDWORD    TotalEntries,
   IN OUT LPDWORD    ResumeHandle
   );
#ifdef UNICODE
#define LlsGroupUserEnum LlsGroupUserEnumW
#else
#define LlsGroupUserEnum LlsGroupUserEnumA
#endif

// Add user to given Group
NTSTATUS
NTAPI
LlsGroupUserAddW(
   IN LLS_HANDLE Handle,
   IN LPWSTR     Group,
   IN LPWSTR     User
   );

NTSTATUS
NTAPI
LlsGroupUserAddA(
   IN LLS_HANDLE Handle,
   IN LPSTR      Group,
   IN LPSTR      User
   );
#ifdef UNICODE
#define LlsGroupUserAdd LlsGroupUserAddW
#else
#define LlsGroupUserAdd LlsGroupUserAddA
#endif

// Delete user from given Group
NTSTATUS
NTAPI
LlsGroupUserDeleteW(
   IN LLS_HANDLE Handle,
   IN LPWSTR     Group,
   IN LPWSTR     User
   );

NTSTATUS
NTAPI
LlsGroupUserDeleteA(
   IN LLS_HANDLE Handle,
   IN LPSTR      Group,
   IN LPSTR      User
   );
#ifdef UNICODE
#define LlsGroupUserDelete LlsGroupUserDeleteW
#else
#define LlsGroupUserDelete LlsGroupUserDeleteA
#endif

// Add a given Group
NTSTATUS
NTAPI
LlsGroupAddW(
   IN LLS_HANDLE Handle,
   IN DWORD      Level,    // Level 1 supported
   IN LPBYTE     bufptr
   );

NTSTATUS
NTAPI
LlsGroupAddA(
   IN LLS_HANDLE Handle,
   IN DWORD      Level,    // Level 1 supported
   IN LPBYTE     bufptr
   );
#ifdef UNICODE
#define LlsGroupAdd LlsGroupAddW
#else
#define LlsGroupAdd LlsGroupAddA
#endif

NTSTATUS
NTAPI
LlsGroupDeleteW(
   IN LLS_HANDLE Handle,
   IN LPWSTR     Group
   );

NTSTATUS
NTAPI
LlsGroupDeleteA(
   IN LLS_HANDLE Handle,
   IN LPSTR      Group
   );
#ifdef UNICODE
#define LlsGroupDelete LlsGroupDeleteW
#else
#define LlsGroupDelete LlsGroupDeleteA
#endif


//
// Service control API's
//

NTSTATUS
NTAPI
LlsServiceInfoGetW(
   IN  LLS_HANDLE Handle,
   IN  DWORD      Level,
   OUT LPBYTE*    bufptr
   );

NTSTATUS
NTAPI
LlsServiceInfoGetA(
   IN  LLS_HANDLE Handle,
   IN  DWORD      Level,
   OUT LPBYTE*    bufptr
   );
#ifdef UNICODE
#define LlsServiceInfoGet LlsServiceInfoGetW
#else
#define LlsServiceInfoGet LlsServiceInfoGetA
#endif

NTSTATUS
NTAPI
LlsServiceInfoSetW(
   IN LLS_HANDLE Handle,
   IN DWORD      Level,
   IN LPBYTE     bufptr
   );

NTSTATUS
NTAPI
LlsServiceInfoSetA(
   IN LLS_HANDLE Handle,
   IN DWORD      Level,
   IN LPBYTE     bufptr
   );
#ifdef UNICODE
#define LlsServiceInfoSet LlsServiceInfoSetW
#else
#define LlsServiceInfoSet LlsServiceInfoSetA
#endif


//
// Server Table Stuff (Replicated Server / Product Tree)
//
NTSTATUS
NTAPI
LlsServerEnumW(
   IN     LLS_HANDLE Handle,
   IN     LPWSTR     Server,
   IN     DWORD      Level,     // Levels 0,1 supported
   OUT    LPBYTE*    bufptr,      
   IN     DWORD      prefmaxlen,  
   OUT    LPDWORD    EntriesRead,
   OUT    LPDWORD    TotalEntries,
   IN OUT LPDWORD    ResumeHandle
   );

NTSTATUS
NTAPI
LlsServerEnumA(
   IN     LLS_HANDLE Handle,
   IN     LPSTR      Server,
   IN     DWORD      Level,     // Levels 0,1 supported
   OUT    LPBYTE*    bufptr,      
   IN     DWORD      prefmaxlen,  
   OUT    LPDWORD    EntriesRead,
   OUT    LPDWORD    TotalEntries,
   IN OUT LPDWORD    ResumeHandle
   );
#ifdef UNICODE
#define LlsServerEnum LlsServerEnumW
#else
#define LlsServerEnum LlsServerEnumA
#endif


NTSTATUS
NTAPI
LlsServerProductEnumW(
   IN     LLS_HANDLE Handle,
   IN     LPWSTR     Server,
   IN     DWORD      Level,     // Levels 0,1 supported
   OUT    LPBYTE*    bufptr,      
   IN     DWORD      prefmaxlen,  
   OUT    LPDWORD    EntriesRead,
   OUT    LPDWORD    TotalEntries,
   IN OUT LPDWORD    ResumeHandle
   );

NTSTATUS
NTAPI
LlsServerProductEnumA(
   IN     LLS_HANDLE Handle,
   IN     LPSTR      Server,
   IN     DWORD      Level,     // Levels 0,1 supported
   OUT    LPBYTE*    bufptr,      
   IN     DWORD      prefmaxlen,  
   OUT    LPDWORD    EntriesRead,
   OUT    LPDWORD    TotalEntries,
   IN OUT LPDWORD    ResumeHandle
   );
#ifdef UNICODE
#define LlsServerUserEnum LlsServerUserEnumW
#else
#define LlsServerUserEnum LlsServerUserEnumA
#endif


//
// Concurrent (Per-Server) mode API's (these will interact with the registry
// on the remote system).
//
NTSTATUS
NTAPI
LlsLocalProductEnumW(
   IN     LLS_HANDLE Handle,
   IN     DWORD      Level,     // Levels 0,1 supported
   OUT    LPBYTE*    bufptr,      
   IN     DWORD      prefmaxlen,  
   OUT    LPDWORD    EntriesRead,
   OUT    LPDWORD    TotalEntries,
   IN OUT LPDWORD    ResumeHandle
   );

NTSTATUS
NTAPI
LlsLocalProductEnumA(
   IN     LLS_HANDLE Handle,
   IN     DWORD      Level,     // Levels 0,1 supported
   OUT    LPBYTE*    bufptr,      
   IN     DWORD      prefmaxlen,  
   OUT    LPDWORD    EntriesRead,
   OUT    LPDWORD    TotalEntries,
   IN OUT LPDWORD    ResumeHandle
   );
#ifdef UNICODE
#define LlsLocalProductEnum LlsLocalProductEnumW
#else
#define LlsLocalProductEnum LlsLocalProductEnumA
#endif


NTSTATUS
NTAPI
LlsLocalProductInfoGetW(
   IN LLS_HANDLE Handle,
   IN LPWSTR     Product,
   IN DWORD      Level,
   OUT LPBYTE*   bufptr
   );

NTSTATUS
NTAPI
LlsLocalProductInfoGetA(
   IN LLS_HANDLE Handle,
   IN LPSTR      Product,
   IN DWORD      Level,
   OUT LPBYTE*   bufptr
   );
#ifdef UNICODE
#define LlsLocalProductInfoGet LlsLocalProductInfoGetW
#else
#define LlsLocalProductInfoGet LlsLocalProductInfoGetA
#endif


NTSTATUS
NTAPI
LlsLocalProductInfoSetW(
   IN LLS_HANDLE Handle,
   IN LPWSTR     Product,
   IN DWORD      Level,
   IN LPBYTE     bufptr
   );

NTSTATUS
NTAPI
LlsLocalProductInfoSetA(
   IN LLS_HANDLE Handle,
   IN LPSTR      Product,
   IN DWORD      Level,
   IN LPBYTE     bufptr
   );
#ifdef UNICODE
#define LlsLocalProductInfoSet LlsLocalProductInfoSetW
#else
#define LlsLocalProductInfoSet LlsLocalProductInfoSetA
#endif


//////////////////////////////////////////////////////////////////////////////
//  LLS EXTENDED API  //
////////////////////////

BOOL
NTAPI
LlsCapabilityIsSupported(
   LLS_HANDLE  Handle,
   DWORD       Capability );

typedef BOOL (NTAPI *PLLS_CAPABILITY_IS_SUPPORTED)( LLS_HANDLE, DWORD );

NTSTATUS
NTAPI
LlsProductSecurityGetW(
   IN LLS_HANDLE  Handle,
   IN LPWSTR      Product,
   OUT LPBOOL     pSecurity
   );

NTSTATUS
NTAPI
LlsProductSecurityGetA(
   IN LLS_HANDLE  Handle,
   IN LPSTR       Product,
   OUT LPBOOL     pSecurity
   );

typedef NTSTATUS (NTAPI *PLLS_PRODUCT_SECURITY_GET_W)( LLS_HANDLE, LPWSTR, LPBOOL );
typedef NTSTATUS (NTAPI *PLLS_PRODUCT_SECURITY_GET_A)( LLS_HANDLE, LPSTR,  LPBOOL );

#ifdef UNICODE
#  define LlsProductSecurityGet LlsProductSecurityGetW
#else
#  define LlsProductSecurityGet LlsProductSecurityGetA
#endif

NTSTATUS
NTAPI
LlsProductSecuritySetW(
   IN LLS_HANDLE  Handle,
   IN LPWSTR      Product
   );

NTSTATUS
NTAPI
LlsProductSecuritySetA(
   IN LLS_HANDLE  Handle,
   IN LPSTR       Product
   );

typedef NTSTATUS (NTAPI *PLLS_PRODUCT_SECURITY_SET_W)( LLS_HANDLE, LPWSTR );
typedef NTSTATUS (NTAPI *PLLS_PRODUCT_SECURITY_SET_A)( LLS_HANDLE, LPSTR  );

#ifdef UNICODE
#  define LlsProductSecuritySet LlsProductSecuritySetW
#else
#  define LlsProductSecuritySet LlsProductSecuritySetA
#endif

NTSTATUS
NTAPI
LlsProductLicensesGetW(
   IN LLS_HANDLE         Handle,
   IN LPWSTR             DisplayName,
   IN DWORD              Mode,
   OUT LPDWORD           pQuantity );

NTSTATUS
NTAPI
LlsProductLicensesGetA(
   IN LLS_HANDLE         Handle,
   IN LPSTR              DisplayName,
   IN DWORD              Mode,
   OUT LPDWORD           pQuantity );

typedef NTSTATUS (NTAPI *PLLS_PRODUCT_LICENSES_GET_W)( LLS_HANDLE, LPWSTR, DWORD, LPDWORD );
typedef NTSTATUS (NTAPI *PLLS_PRODUCT_LICENSES_GET_A)( LLS_HANDLE, LPSTR,  DWORD, LPDWORD );

#ifdef UNICODE
#  define LlsProductLicensesGet LlsProductLicensesGetW
#else
#  define LlsProductLicensesGet LlsProductLicensesGetA
#endif

NTSTATUS
NTAPI
LlsCertificateClaimEnumW(
   IN LLS_HANDLE        Handle,
   IN DWORD             LicenseLevel,
   IN LPBYTE            pLicenseInfo,
   IN DWORD             TargetLevel,
   OUT LPBYTE *         ppTargets,
   OUT LPDWORD          pNumTargets );

NTSTATUS
NTAPI
LlsCertificateClaimEnumA(
   IN LLS_HANDLE        Handle,
   IN DWORD             LicenseLevel,
   IN LPBYTE            pLicenseInfo,
   IN DWORD             TargetLevel,
   OUT LPBYTE *         ppTargets,
   OUT LPDWORD          pNumTargets );

typedef NTSTATUS (NTAPI *PLLS_CERTIFICATE_CLAIM_ENUM_W)( LLS_HANDLE, DWORD, LPBYTE, DWORD, LPBYTE *, LPDWORD );
typedef NTSTATUS (NTAPI *PLLS_CERTIFICATE_CLAIM_ENUM_A)( LLS_HANDLE, DWORD, LPBYTE, DWORD, LPBYTE *, LPDWORD );

#ifdef UNICODE
#  define LlsCertificateClaimEnum LlsCertificateClaimEnumW
#else
#  define LlsCertificateClaimEnum LlsCertificateClaimEnumA
#endif

NTSTATUS
NTAPI
LlsCertificateClaimAddCheckW(
   IN LLS_HANDLE        Handle,
   IN DWORD             LicenseLevel,
   IN LPBYTE            pLicenseInfo,
   OUT LPBOOL           pMayInstall );

NTSTATUS
NTAPI
LlsCertificateClaimAddCheckA(
   IN LLS_HANDLE        Handle,
   IN DWORD             LicenseLevel,
   IN LPBYTE            pLicenseInfo,
   OUT LPBOOL           pMayInstall );

typedef NTSTATUS (NTAPI *PLLS_CERTIFICATE_CLAIM_ADD_CHECK_W)( LLS_HANDLE, DWORD, LPBYTE, LPBOOL );
typedef NTSTATUS (NTAPI *PLLS_CERTIFICATE_CLAIM_ADD_CHECK_A)( LLS_HANDLE, DWORD, LPBYTE, LPBOOL );

#ifdef UNICODE
#  define LlsCertificateClaimAddCheck LlsCertificateClaimAddCheckW
#else
#  define LlsCertificateClaimAddCheck LlsCertificateClaimAddCheckA
#endif

NTSTATUS
NTAPI
LlsCertificateClaimAddW(
   IN LLS_HANDLE        Handle,
   IN LPWSTR            ServerName,
   IN DWORD             LicenseLevel,
   IN LPBYTE            pLicenseInfo );

NTSTATUS
NTAPI
LlsCertificateClaimAddA(
   IN LLS_HANDLE        Handle,
   IN LPSTR             ServerName,
   IN DWORD             LicenseLevel,
   IN LPBYTE            pLicenseInfo );

typedef NTSTATUS (NTAPI *PLLS_CERTIFICATE_CLAIM_ADD_W)( LLS_HANDLE, LPWSTR, DWORD, LPBYTE );
typedef NTSTATUS (NTAPI *PLLS_CERTIFICATE_CLAIM_ADD_A)( LLS_HANDLE, LPSTR,  DWORD, LPBYTE );

#ifdef UNICODE
#  define LlsCertificateClaimAdd LlsCertificateClaimAddW
#else
#  define LlsCertificateClaimAdd LlsCertificateClaimAddA
#endif


NTSTATUS
NTAPI
LlsReplicationCertDbAddW(
   LLS_REPL_HANDLE            ReplHandle,
   DWORD                      Level,
   LPVOID                     Certificates );

typedef NTSTATUS (NTAPI *PLLS_REPLICATION_CERT_DB_ADD_W)( LLS_REPL_HANDLE, DWORD, LPVOID );


NTSTATUS
NTAPI
LlsReplicationProductSecurityAddW(
   LLS_REPL_HANDLE            ReplHandle,
   DWORD                      Level,
   LPVOID                     SecureProducts );

typedef NTSTATUS (NTAPI *PLLS_REPLICATION_PRODUCT_SECURITY_ADD_W)( LLS_REPL_HANDLE, DWORD, LPVOID );


NTSTATUS
NTAPI
LlsReplicationUserAddExW(
   LLS_REPL_HANDLE            ReplHandle,
   DWORD                      Level,
   LPVOID                     Users );

typedef NTSTATUS (NTAPI *PLLS_REPLICATION_USER_ADD_EX_W)( LLS_REPL_HANDLE, DWORD, LPVOID );


NTSTATUS
NTAPI
LlsLocalServiceEnumW(
   LLS_HANDLE Handle,
   DWORD      Level,
   LPBYTE*    bufptr,
   DWORD      PrefMaxLen,
   LPDWORD    EntriesRead,
   LPDWORD    TotalEntries,
   LPDWORD    ResumeHandle );

NTSTATUS
NTAPI
LlsLocalServiceEnumA(
   LLS_HANDLE Handle,
   DWORD      Level,
   LPBYTE*    bufptr,
   DWORD      PrefMaxLen,
   LPDWORD    EntriesRead,
   LPDWORD    TotalEntries,
   LPDWORD    ResumeHandle );

#ifdef UNICODE
#  define LlsLocalServiceEnum LlsLocalServiceEnumW
#else
#  define LlsLocalServiceEnum LlsLocalServiceEnumA
#endif

NTSTATUS
NTAPI
LlsLocalServiceAddW(
   LLS_HANDLE  Handle,
   DWORD       Level,
   LPBYTE      bufptr );

NTSTATUS
NTAPI
LlsLocalServiceAddA(
   LLS_HANDLE  Handle,
   DWORD       Level,
   LPBYTE      bufptr );

#ifdef UNICODE
#  define LlsLocalServiceAdd LlsLocalServiceAddW
#else
#  define LlsLocalServiceAdd LlsLocalServiceAddA
#endif

NTSTATUS
NTAPI
LlsLocalServiceInfoSetW(
   LLS_HANDLE Handle,
   LPWSTR     KeyName,
   DWORD      Level,
   LPBYTE     bufptr );

NTSTATUS
NTAPI
LlsLocalServiceInfoSetA(
   LLS_HANDLE  Handle,
   LPSTR       KeyName,
   DWORD       Level,
   LPBYTE      bufptr );

#ifdef UNICODE
#  define LlsLocalServiceInfoSet LlsLocalServiceInfoSetW
#else
#  define LlsLocalServiceInfoSet LlsLocalServiceInfoSetA
#endif

NTSTATUS
NTAPI
LlsLocalServiceInfoGetW(
   LLS_HANDLE  Handle,
   LPWSTR      KeyName,
   DWORD       Level,
   LPBYTE *    pbufptr );

NTSTATUS
NTAPI
LlsLocalServiceInfoGetA(
   LLS_HANDLE  Handle,
   DWORD       Level,
   LPSTR       KeyName,
   LPBYTE *    pbufptr );

#ifdef UNICODE
#  define LlsLocalServiceInfoGet LlsLocalServiceInfoGetW
#else
#  define LlsLocalServiceInfoGet LlsLocalServiceInfoGetA
#endif

NTSTATUS
NTAPI
LlsLicenseRequestW(
   LLS_HANDLE  Handle,
   LPWSTR      Product,
   ULONG       VersionIndex,
   BOOLEAN     IsAdmin,
   ULONG       DataType,
   ULONG       DataSize,
   PBYTE       Data,
   LPDWORD     pLicenseHandle );

NTSTATUS
NTAPI
LlsLicenseRequestA(
   LLS_HANDLE  Handle,
   LPSTR       Product,
   ULONG       VersionIndex,
   BOOLEAN     IsAdmin,
   ULONG       DataType,
   ULONG       DataSize,
   PBYTE       Data,
   LPDWORD     pLicenseHandle );

#ifdef UNICODE
#  define LlsLicenseRequest LlsLicenseRequestW
#else
#  define LlsLicenseRequest LlsLicenseRequestA
#endif

NTSTATUS
NTAPI
LlsLicenseFree(
   LLS_HANDLE  Handle,
   DWORD       LicenseHandle );

//////////////////////////////////////////////////////////////////////////////
//  CCF API  //
///////////////

#define CCF_ENTER_FLAG_PER_SEAT_ONLY         ( 1 )
#define CCF_ENTER_FLAG_PER_SERVER_ONLY       ( 2 )
#define CCF_ENTER_FLAG_SERVER_IS_ES          ( 4 )

// prototype for certificate source enter API
typedef DWORD (APIENTRY *PCCF_ENTER_API)(    HWND     hWndParent,
                                             LPCSTR   pszServerName,
                                             LPCSTR   pszProductName,
                                             LPCSTR   pszVendor,
                                             DWORD    dwFlags );

DWORD APIENTRY CCFCertificateEnterUI(        HWND     hWndParent,
                                             LPCSTR   pszServerName,
                                             LPCSTR   pszProductName,
                                             LPCSTR   pszVendor,
                                             DWORD    dwFlags,
                                             LPCSTR   pszSourceToUse );

// prototype for certificate source remove API
typedef DWORD (APIENTRY *PCCF_REMOVE_API)(   HWND     hWndParent,
                                             LPCSTR   pszServerName,
                                             DWORD    dwFlags,
                                             DWORD    dwLicenseLevel,
                                             LPVOID   lpvLicenseInfo );

DWORD APIENTRY CCFCertificateRemoveUI(       HWND     hWndParent,
                                             LPCSTR   pszServerName,
                                             LPCSTR   pszProductName,
                                             LPCSTR   pszVendor,
                                             DWORD    dwFlags,
                                             LPCSTR   pszSourceToUse );

#endif

//
// Registry values
//

#define REG_KEY_LICENSE  TEXT("SYSTEM\\CurrentControlSet\\Services\\LicenseInfo")
#define REG_KEY_CONFIG   TEXT("SYSTEM\\CurrentControlSet\\Services\\LicenseService\\Parameters")

#define REG_VALUE_NAME     TEXT("DisplayName")
#define REG_VALUE_FAMILY   TEXT("FamilyDisplayName")
#define REG_VALUE_MODE     TEXT("Mode")
#define REG_VALUE_FLIP     TEXT("FlipAllow")
#define REG_VALUE_LIMIT    TEXT("ConcurrentLimit")
#define REG_VALUE_HIGHMARK TEXT("LocalKey")

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\inc\lkrhash.h ===
/*++

   Copyright    (c) 1998-2001    Microsoft Corporation

   Module  Name :
       LKRhash.h

   Abstract:
       Declares LKRhash: a fast, scalable, cache- and MP-friendly hash table

   Author:
       Paul (Per-Ake) Larson, palarson@microsoft.com, July 1997
       Murali R. Krishnan    (MuraliK)
       George V. Reilly      (GeorgeRe)     06-Jan-1998

   Environment:
       Win32 - User Mode

   Project:
       Internet Information Services Rearchitecture Core Library

   Revision History:
       10/01/1998 - Change name from LKhash to LKRhash

--*/


#define LKR_STL_ITERATORS 1

// #define LKR_DEPRECATED_ITERATORS
#define LKR_APPLY_IF
#undef  LKR_COUNTDOWN

#define __HASHFN_NO_NAMESPACE__
#define __LKRHASH_NO_NAMESPACE__

#ifndef LKR_TABLE_LOCK
# define LKR_TABLE_LOCK  CReaderWriterLock3
#endif // !LKR_TABLE_LOCK

#ifndef LKR_BUCKET_LOCK
# ifdef LKR_DEPRECATED_ITERATORS
#  define LKR_BUCKET_LOCK CReaderWriterLock3
# else // !LKR_DEPRECATED_ITERATORS
#  define LKR_BUCKET_LOCK CReaderWriterLock2
# endif // !LKR_DEPRECATED_ITERATORS
#endif // !LKR_BUCKET_LOCK


#ifndef __LKRHASH_H__
#define __LKRHASH_H__

//=====================================================================
//  The class CLKRLinearHashTable defined in this file provides dynamic hash
//  tables, i.e. tables that grow and shrink dynamically with
//  the number of records in the table.
//  The basic method used is linear hashing, as explained in:
//
//    P.-A. Larson, Dynamic Hash Tables, Comm. of the ACM, 31, 4 (1988)
//
//  This version has the following characteristics:
//  - It is thread-safe and uses spin locks for synchronization.
//  - It was designed to support very high rates of concurrent
//    operations (inserts/deletes/lookups).  It achieves this by
//    (a) partitioning a CLKRHashTable into a collection of
//        CLKRLinearHashTables to reduce contention on the global table lock.
//    (b) minimizing the hold time on a table lock, preferring to lock
//        down a bucket chain instead.
//  - The design is L1 cache-conscious.  See CNodeClump.
//  - It is designed for sets varying in size from a dozen
//    elements to several million.
//
//  Main classes:
//    CLKRLinearHashTable: thread-safe linear hash table
//    CLKRHashTable:       collection of CLKRLinearHashTables
//    CTypedHashTable:     typesafe wrapper for CLKRHashTable
//
//
//  Paul Larson, palarson@microsoft.com, July 1997
//   Original implementation with input from Murali R. Krishnan,
//   muralik@microsoft.com.
//
//  George V. Reilly, georgere@microsoft.com, Dec 1997-Jan 1998
//   Massive cleanup and rewrite.  Added templates.
//=====================================================================


// 1) Linear Hashing
// ------------------
//
// Linear hash tables grow and shrink dynamically with the number of
// records in the table.  The growth or shrinkage is smooth: logically,
// one bucket at a time but physically in larger increments
// (64 buckets).  An insertion (deletion) may cause an expansion
// (contraction) of the table.  This causes relocation of a small number
// of records (at most one bucket worth).  All operations (insert,
// delete, lookup) take constant expected time, regardless of the
// current size or the growth of the table.
//
// 2) LKR extensions to Linear hash table
// --------------------------------------
//
// Larson-Krishnan-Reilly extensions to Linear hash tables for multiprocessor
// scalability and improved cache performance.
//
// Traditional implementations of linear hash tables use one global lock
// to prevent interference between concurrent operations
// (insert/delete/lookup) on the table.  The single lock easily becomes
// the bottleneck in SMP scenarios when multiple threads are used.
//
// Traditionally, a (hash) bucket is implemented as a chain of
// single-item nodes.  Every operation results in chasing down a chain
// looking for an item. However, pointer chasing is very slow on modern
// systems because almost every jump results in a cache miss. L2 (or L3)
// cache misses are very expensive in missed CPU cycles and the cost is
// increasing (going to 100s of cycles in the future).
//
// LKR extensions offer
//    1) Partitioning (by hashing) of records among multiple subtables.
//       Each subtable has locks but there is no global lock.  Each
//       subtable receives a much lower rate of operations, resulting in
//       fewer conflicts.
//
//    2) Improved cache locality by grouping keys and their hash values
//       into contigous chunks that fit exactly into one (or a few)
//       cache lines.
//
// Specifically the implementation that exists here achieves this using
// the following techniques.
//
// Class CLKRHashTable is the top-level data structure that dynamically
// creates m_cSubTables linear hash tables. The CLKRLinearHashTables act as
// the subtables to which items and accesses are fanned out. A good
// hash function multiplexes requests uniformly to various subtables,
// thus minimizing traffic to any single subtable. The implemenation
// uses a home-grown version of bounded spinlocks, that is, a thread
// does not spin on a lock indefinitely, instead yielding after a
// predetermined number of loops.
//
// Each CLKRLinearHashTable consists of a CDirEntry pointing to segments
// each holding m_dwSegSize CBuckets. Each CBucket in turn consists of a
// chain of CNodeClumps.  Each CNodeClump contains a group of
// NODES_PER_CLUMP hash values (aka hash keys or signatures) and
// pointers to the associated data items.  Keeping the signatures
// together increases the cache locality in scans for lookup.
//
// Traditionally, people store a link-list element right inside the
// object that is hashed and use this link-list for the chaining of data
// blocks.  However, keeping just the pointers to the data object and
// not chaining through them limits the need for bringing in the data
// object to the cache.  We need to access the data object only if the
// hash values match. This limits the cache-thrashing behaviour
// exhibited by conventional implementations.  It has the additional
// benefit that the objects themselves do not need to be modified
// in order to be collected in the hash table (i.e., it's non-invasive).


//--------------------------------------------------------------------
// TODO
// * Provide support for multiple, identical keys. Needed for EqualRange,
//   hash_multiset, and hash_multimap.
// * Provide implementations of the STL collection classes: hash_map,
//   hash_set, hash_multimap, and hash_multiset.
// * Make exception-safe.
// * Use auto_ptrs.
// * Add some kind of auto object for readlocking or writelocking a table,
//   so that the table automatically gets unlocked by auto-obj's destructor.
// * Provide a C API wrapper
// * Port to kernel mode (will require different locks, at the very least)
// * Port to managed code (Chris Tracy has started on this)
// * Typedef hash signatures (currently DWORDs)
// * Make available as a static library as well as a DLL
//--------------------------------------------------------------------



#ifndef __IRTLDBG_H__
# include <irtldbg.h>
#endif

#ifndef __LSTENTRY_H__
# include <lstentry.h>
#endif

#ifndef __HASHFN_H__
# include <hashfn.h>
#endif

#include <limits.h>


#ifdef LKR_STL_ITERATORS

// needed for std::forward_iterator_tag, etc
# include <iterator>

// The iterators have very verbose tracing. Don't want it on all the time
// in debug builds.
# if defined(IRTLDEBUG)  &&  (LKR_STL_ITERATORS >= 2)
#  define LKR_ITER_TRACE  IrtlTrace
# else // !defined(IRTLDEBUG)  ||  LKR_STL_ITERATORS < 2
#  define LKR_ITER_TRACE  1 ? (void)0 : IrtlTrace
# endif // !defined(IRTLDEBUG)  ||  LKR_STL_ITERATORS < 2

#endif // LKR_STL_ITERATORS


// Used to initialize and destroy custom allocators
extern "C" bool LKRHashTableInit();
extern "C" void LKRHashTableUninit();


enum LK_TABLESIZE {
    LK_SMALL_TABLESIZE=  1,     // < 200 elements
    LK_MEDIUM_TABLESIZE= 2,     // 200...10,000 elements
    LK_LARGE_TABLESIZE=  3,     // 10,000+ elements
};


// Default values for the hashtable constructors
enum {
#ifndef _WIN64
    LK_DFLT_MAXLOAD=     6, // Default upperbound on average chain length.
#else // _WIN64
    LK_DFLT_MAXLOAD=     4, // 64-byte nodes => NODES_PER_CLUMP = 4
#endif // _WIN64
    LK_DFLT_INITSIZE=LK_MEDIUM_TABLESIZE, // Default initial size of hash table
    LK_DFLT_NUM_SUBTBLS= 0, // Use a heuristic to choose #subtables
};


// build fix hack
enum {
     DFLT_LK_MAXLOAD=     LK_DFLT_MAXLOAD,
     DFLT_LK_INITSIZE=    LK_DFLT_INITSIZE,
     DFLT_LK_NUM_SUBTBLS= LK_DFLT_NUM_SUBTBLS,
};


//--------------------------------------------------------------------
// Possible return codes from public member functions of
// CLKRLinearHashTable, CLKRHashTable, and CTypedHashTable

enum LK_RETCODE {
    // severe errors < 0
    LK_UNUSABLE = -99,  // Table corrupted: all bets are off
    LK_ALLOC_FAIL,      // ran out of memory
    LK_BAD_ITERATOR,    // invalid iterator; e.g., points to another table
    LK_BAD_RECORD,      // invalid record; e.g., NULL for InsertRecord
    LK_BAD_PARAMETERS,  // invalid parameters; e.g., NULL fnptrs to ctor
    LK_NOT_INITIALIZED, // LKRHashTableInit was not called

    LK_SUCCESS = 0,     // everything's okay
    LK_KEY_EXISTS,      // key already present for InsertRecord(no-overwrite)
    LK_NO_SUCH_KEY,     // key not found
    LK_NO_MORE_ELEMENTS,// iterator exhausted
};

#define LK_SUCCEEDED(lkrc)  ((lkrc) >= LK_SUCCESS)


#ifdef LKR_APPLY_IF

//--------------------------------------------------------------------
// Return codes from PFnRecordPred.

enum LK_PREDICATE {
    LKP_ABORT = 1,           // Stop walking the table immediately
    LKP_NO_ACTION = 2,       // No action, just keep walking
    LKP_PERFORM = 3,         // Perform action and continue walking
    LKP_PERFORM_STOP = 4,    // Perform action, then stop
    LKP_DELETE = 5,          // Delete record and keep walking
    LKP_DELETE_STOP = 6,     // Delete record, then stop
};


//--------------------------------------------------------------------
// Return codes from PFnRecordAction.

enum LK_ACTION {
    LKA_ABORT = 1,          // Stop walking the table immediately
    LKA_FAILED = 2,         // Action failed; continue walking the table
    LKA_SUCCEEDED = 3,      // Action succeeded; continue walking the table
};

#endif // LKR_APPLY_IF

#if defined(LKR_DEPRECATED_ITERATORS) || defined(LKR_APPLY_IF)
//--------------------------------------------------------------------
// Parameter to Apply and ApplyIf.

enum LK_LOCKTYPE {
    LKL_READLOCK = 1,       // Lock the table for reading (for constness)
    LKL_WRITELOCK = 2,      // Lock the table for writing
};

#endif // LKR_DEPRECATED_ITERATORS || LKR_APPLY_IF



//--------------------------------------------------------------------
// Global table lock code.  This is only used to measure how much of a
// slowdown having a global lock on the CLKRHashTable causes.  It is
// *never* used in production code.


// #define LKRHASH_GLOBAL_LOCK CCritSec

#ifdef LKRHASH_GLOBAL_LOCK

# define LKRHASH_GLOBAL_LOCK_DECLARATIONS()         \
    typedef LKRHASH_GLOBAL_LOCK GlobalLock;  \
    mutable GlobalLock m_lkGlobal;

# define LKRHASH_GLOBAL_READ_LOCK()     m_lkGlobal.ReadLock()
# define LKRHASH_GLOBAL_WRITE_LOCK()    m_lkGlobal.WriteLock()
# define LKRHASH_GLOBAL_READ_UNLOCK()   m_lkGlobal.ReadUnlock()
# define LKRHASH_GLOBAL_WRITE_UNLOCK()  m_lkGlobal.WriteUnlock()

#else // !LKRHASH_GLOBAL_LOCK

# define LKRHASH_GLOBAL_LOCK_DECLARATIONS()

// These ones will be optimized away by the compiler
# define LKRHASH_GLOBAL_READ_LOCK()     ((void)0)
# define LKRHASH_GLOBAL_WRITE_LOCK()    ((void)0)
# define LKRHASH_GLOBAL_READ_UNLOCK()   ((void)0)
# define LKRHASH_GLOBAL_WRITE_UNLOCK()  ((void)0)

#endif // !LKRHASH_GLOBAL_LOCK



//--------------------------------------------------------------------
// Statistical information returned by GetStatistics
//--------------------------------------------------------------------

#ifdef LOCK_INSTRUMENTATION

class IRTL_DLLEXP CAveragedLockStats : public CLockStatistics
{
public:
    int m_nItems;

    CAveragedLockStats()
        : m_nItems(1)
    {}
};

#endif // LOCK_INSTRUMENTATION



class IRTL_DLLEXP CLKRHashTableStats
{
public:
    int      RecordCount;           // number of records in the table
    int      TableSize;             // table size in number of slots
    int      DirectorySize;         // number of entries in directory
    int      LongestChain;          // longest hash chain in the table
    int      EmptySlots;            // number of unused hash slots
    double   SplitFactor;           // fraction of buckets split
    double   AvgSearchLength;       // average length of a successful search
    double   ExpSearchLength;       // theoretically expected length
    double   AvgUSearchLength;      // average length of an unsuccessful search
    double   ExpUSearchLength;      // theoretically expected length
    int      NodeClumpSize;         // number of slots in a node clump
    int      CBucketSize;           // sizeof(CBucket)

#ifdef LOCK_INSTRUMENTATION
    CAveragedLockStats      m_alsTable;  // stats for table lock
    CAveragedLockStats      m_alsBucketsAvg; // avg of stats for bucket locks
    CGlobalLockStatistics   m_gls;      // global statistics for all locks
#endif // LOCK_INSTRUMENTATION

    enum {
        MAX_BUCKETS = 40,
    };

    // histogram of bucket lengths
    LONG    m_aBucketLenHistogram[MAX_BUCKETS];

    CLKRHashTableStats()
        : RecordCount(0),
          TableSize(0),
          DirectorySize(0),
          LongestChain(0),
          EmptySlots(0),
          SplitFactor(0.0),
          AvgSearchLength(0.0),
          ExpSearchLength(0.0),
          AvgUSearchLength(0.0),
          ExpUSearchLength(0.0),
          NodeClumpSize(1),
          CBucketSize(0)
    {
        for (int i = MAX_BUCKETS;  --i >= 0;  )
            m_aBucketLenHistogram[i] = 0;
    }

    static const LONG*
    BucketSizes()
    {
        static const LONG  s_aBucketSizes[MAX_BUCKETS] = {
                   1,    2,    3,    4,    5,    6,    7,      8,        9,
            10,   11,   12,   13,   14,   15,   16,   17,     18,       19,
            20,   21,   22,   23,   24,   25,   30,   40,     50,       60,
            70,   80,   90,  100,  200,  500, 1000,10000, 100000, LONG_MAX,
        };

        return s_aBucketSizes;
    }

    static LONG
    BucketSize(
        LONG nBucketIndex)
    {
        IRTLASSERT(0 <= nBucketIndex  &&  nBucketIndex < MAX_BUCKETS);
        return BucketSizes()[nBucketIndex];
    }

    static LONG
    BucketIndex(
        LONG nBucketLength)
    {
        const LONG* palBucketSizes = BucketSizes();
        LONG i = 0;
        while (palBucketSizes[i] < nBucketLength)
            ++i;
        if (i == MAX_BUCKETS  ||  palBucketSizes[i] > nBucketLength)
            --i;
        IRTLASSERT(0 <= i  &&  i < MAX_BUCKETS);
        return i;
    }
};



// Use types defined in recent versions of the Platform SDK in basetsd.h.
#ifndef _W64
typedef DWORD DWORD_PTR;   // integral type big enough to hold a pointer
#endif

//--------------------------------------------------------------------
// CLKRLinearHashTable deals with void* records.  These typedefs
// provide prototypes for functions that manipulate instances of
// those records.  CTypedHashTable and CStringTestHashTable (below) show a
// way to encapsulate these in typesafe wrappers.
//--------------------------------------------------------------------

// Given a record, return its key.  Assumes that the key is embedded in
// the record, or at least somehow derivable from the record.  For
// completely unrelated keys & values, a wrapper class should use
// something like STL's pair<key,value> template to aggregate them
// into a record.
typedef const DWORD_PTR (WINAPI *PFnExtractKey)  (const void* pvRecord);

// Given a key, return its hash signature.  The hashing functions in
// hashfn.h (or something that builds upon them) are suggested.
typedef DWORD       (WINAPI *PFnCalcKeyHash) (const DWORD_PTR pnKey);

// Compare two keys for equality; e.g., _stricmp, memcmp, operator==
typedef bool        (WINAPI *PFnEqualKeys)   (const DWORD_PTR pnKey1,
                                              const DWORD_PTR pnKey2);

// Increment the reference count of a record before returning it from
// FindKey.  It's necessary to do it in FindKey itself while the bucket
// is still locked, rather than one of the wrappers, to avoid race
// conditions.  Similarly, the reference count is incremented in
// InsertRecord and decremented in DeleteKey.  Finally, if an old record
// is overwritten in InsertRecord, its reference count is decremented.
//
// It's up to you to decrement the reference count when you're finished
// with it after retrieving it via FindKey and to determine the
// semantics of what this means.  The hashtable itself has no notion of
// reference counts; this is merely to help with the lifetime management
// of the record objects.
typedef void        (WINAPI *PFnAddRefRecord)(const void* pvRecord, int nIncr);

#ifdef LKR_APPLY_IF
// ApplyIf() and DeleteIf(): Does the record match the predicate?
typedef LK_PREDICATE (WINAPI *PFnRecordPred) (const void* pvRecord,
                                              void* pvState);

// Apply() et al: Perform action on record.
typedef LK_ACTION   (WINAPI *PFnRecordAction)(const void* pvRecord,
                                              void* pvState);
#endif // LKR_APPLY_IF



//--------------------------------------------------------------------
// Custom memory allocators
//--------------------------------------------------------------------


#ifndef LKR_NO_ALLOCATORS
# define LKRHASH_ACACHE 1
// # define LKRHASH_MANODEL 1
// # define LKRHASH_MADEL 1
// # define LKRHASH_ROCKALL_FAST 1

// # define LKRHASH_MEM_DEFAULT_ALIGN 32
#endif // !LKR_NO_ALLOCATORS

#ifndef LKRHASH_MEM_DEFAULT_ALIGN
# define LKRHASH_MEM_DEFAULT_ALIGN 8
#endif // !LKRHASH_MEM_DEFAULT_ALIGN

#if defined(LKRHASH_ACACHE)

# include <acache.hxx>
  typedef ALLOC_CACHE_HANDLER  CLKRhashAllocator;
# define LKRHASH_ALLOCATOR_NEW(C, N)                            \
    const ALLOC_CACHE_CONFIGURATION acc = { 1, N, sizeof(C) };  \
    C::sm_palloc = new ALLOC_CACHE_HANDLER("LKRhash:" #C, &acc);

#elif defined(LKRHASH_ROCKALL_FAST)

# include <FastHeap.hpp>

class FastHeap : public FAST_HEAP
{
public:
    FastHeap(
        SIZE_T cb)
        : m_cb(cb)
    {}

    LPVOID Alloc()
    { return New(m_cb, NULL, false); }

    BOOL   Free(LPVOID pvMem)
    { return Delete(pvMem); }

    SIZE_T m_cb;
};

  typedef FastHeap  CLKRhashAllocator;
# define LKRHASH_ALLOCATOR_NEW(C, N)                            \
    C::sm_palloc = new FastHeap(sizeof(C));

#else // no custom allocator

# undef LKRHASH_ALLOCATOR_NEW

#endif // no custom allocator



#ifdef LKRHASH_ALLOCATOR_NEW

// placed inline in the declaration of class C
# define LKRHASH_ALLOCATOR_DEFINITIONS(C)                       \
    protected:                                                  \
        static CLKRhashAllocator* sm_palloc;                    \
        friend class CLKRLinearHashTable;                       \
        friend bool LKRHashTableInit();                         \
        friend void LKRHashTableUninit();                       \
    public:                                                     \
        static void*  operator new(size_t s)                    \
        {                                                       \
            UNREFERENCED_PARAMETER(s);                          \
            IRTLASSERT(s == sizeof(C));                         \
            IRTLASSERT(sm_palloc != NULL);                      \
            return sm_palloc->Alloc();                          \
        }                                                       \
        static void   operator delete(void* pv)                 \
        {                                                       \
            IRTLASSERT(pv != NULL);                             \
            IRTLASSERT(sm_palloc != NULL);                      \
            sm_palloc->Free(pv);                                \
        }


// used in LKRHashTableInit()
# define LKRHASH_ALLOCATOR_INIT(C, N, f)                        \
    {                                                           \
        if (f)                                                  \
        {                                                       \
            IRTLASSERT(C::sm_palloc == NULL);                   \
            LKRHASH_ALLOCATOR_NEW(C, N);                        \
            f = (C::sm_palloc != NULL);                         \
        }                                                       \
    }


// used in LKRHashTableUninit()
# define LKRHASH_ALLOCATOR_UNINIT(C)                            \
    {                                                           \
        if (C::sm_palloc != NULL)                               \
        {                                                       \
            delete C::sm_palloc;                                \
            C::sm_palloc = NULL;                                \
        }                                                       \
    }


#else // !LKRHASH_ALLOCATOR_NEW

# define LKRHASH_ALLOCATOR_DEFINITIONS(C)
# define LKRHASH_ALLOCATOR_INIT(C, N, f)
# define LKRHASH_ALLOCATOR_UNINIT(C)

#endif // !LKRHASH_ALLOCATOR_NEW



#ifndef __LKRHASH_NO_NAMESPACE__
namespace LKRhash {
#endif // !__LKRHASH_NO_NAMESPACE__


//--------------------------------------------------------------------
// forward declarations

class IRTL_DLLEXP CLKRLinearHashTable;

class IRTL_DLLEXP CLKRHashTable;

template <class _Der, class _Rcd, class _Ky, class _HT
#ifdef LKR_DEPRECATED_ITERATORS
          , class _Iter
#endif // LKR_DEPRECATED_ITERATORS
          >
class CTypedHashTable;



// Class for nodes on a bucket chain.  Instead of a node containing
// one (signature, record-pointer, next-tuple-pointer) tuple, it
// contains _N_ such tuples.  (N-1 next-tuple-pointers are omitted.)
// This improves locality of reference greatly; i.e., it's L1
// cache-friendly.  It also reduces memory fragmentation and memory
// allocator overhead.  It does complicate the chain traversal code
// slightly, admittedly.
//
// This theory is beautiful.  In practice, however, CNodeClumps
// are *not* perfectly aligned on 32-byte boundaries by the memory
// allocators.  Experimental results indicate that we get a 2-3%
// speed improvement by using 32-byte-aligned blocks, but this must
// be considered against the average of 16 bytes wasted per block.

class CNodeClump
{
public:
    // Record slots per chunk - set so a chunk matches (one or
    // two) cache lines.  3 ==> 32 bytes, 7 ==> 64 bytes
    // Note: the default max load factor is 6.0, which implies that
    // there will seldom be more than one node clump in a chain.
    enum {
        BUCKET_BYTE_SIZE = 64,
        BUCKET_OVERHEAD  = sizeof(LKR_BUCKET_LOCK) + sizeof(CNodeClump*),
        NODE_SIZE        = sizeof(const void*) + sizeof(DWORD),
        NODES_PER_CLUMP  = (BUCKET_BYTE_SIZE - BUCKET_OVERHEAD) / NODE_SIZE
    };

    enum {
        // See if countdown loops are faster than countup loops for
        // traversing a CNodeClump. In practice, countup loops are faster.
#ifndef LKR_COUNTDOWN
        NODE_BEGIN = 0,
        NODE_END   = NODES_PER_CLUMP,
        NODE_STEP  = +1,
        // for (int x = 0;  x < NODES_PER_CLUMP;  ++x) ...
#else // LKR_COUNTDOWN
        NODE_BEGIN = NODES_PER_CLUMP-1,
        NODE_END   = -1,
        NODE_STEP  = -1,
        // for (int x = NODES_PER_CLUMP;  --x >= 0;  ) ...
#endif // LKR_COUNTDOWN
    };

    enum {
        // No number in 0..2^31-1 maps to this number after it has been
        // scrambled by HashFn::HashRandomizeBits
        HASH_INVALID_SIGNATURE = 31678523,
    };

    DWORD  m_dwKeySigs[NODES_PER_CLUMP]; // hash values computed from keys
    CNodeClump* m_pncNext;               // next node clump on the chain
    const void* m_pvNode[NODES_PER_CLUMP];// pointers to records

    CNodeClump()
    {
        Clear();
    }

    void
    Clear()
    {
        m_pncNext = NULL;  // no dangling pointers
        for (int i = NODES_PER_CLUMP;  --i >= 0; )
        {
            m_dwKeySigs[i] = HASH_INVALID_SIGNATURE;
            m_pvNode[i] = NULL;
        }
    }

    bool
    InvalidSignature(
        int i) const
    {
        IRTLASSERT(0 <= i  &&  i < NODES_PER_CLUMP);
        return (m_dwKeySigs[i] == HASH_INVALID_SIGNATURE);
    }

    bool
    IsEmptyNode(
        int i) const
    {
        IRTLASSERT(0 <= i  &&  i < NODES_PER_CLUMP);
        return (m_pvNode[i] == NULL);
    }

    bool
    IsEmptyAndInvalid(
        int i) const
    {
        return IsEmptyNode(i) && InvalidSignature(i);
    }

    bool
    IsEmptySlot(
        int i) const
    {
        return InvalidSignature(i);
    }

    bool
    IsLastClump() const
    {
        return (m_pncNext == NULL);
    }

#ifdef IRTLDEBUG
    // Don't want overhead of calls to dtor in retail build
    ~CNodeClump()
    {
        IRTLASSERT(IsLastClump());  // no dangling pointers
        for (int i = NODES_PER_CLUMP;  --i >= 0;  )
            IRTLASSERT(InvalidSignature(i)  &&  IsEmptyNode(i));
    }
#endif // IRTLDEBUG

    LKRHASH_ALLOCATOR_DEFINITIONS(CNodeClump);
}; // class CNodeClump



// Class for bucket chains of the hash table.  Note that the first
// nodeclump is actually included in the bucket and not dynamically
// allocated, which increases space requirements slightly but does
// improve performance.
class CBucket
{
private:
    typedef LKR_BUCKET_LOCK BucketLock;
    mutable BucketLock m_Lock;       // lock protecting this bucket

#ifdef LOCK_INSTRUMENTATION
    static LONG sm_cBuckets;

    static const char*
    _LockName()
    {
        LONG l = ++sm_cBuckets;
        // possible race condition but we don't care, as this is never
        // used in production code
        static char s_szName[CLockStatistics::L_NAMELEN];
        wsprintf(s_szName, "B%06x", 0xFFFFFF & l);
        return s_szName;
    }
#endif // LOCK_INSTRUMENTATION

public:
    CNodeClump    m_ncFirst;    // first CNodeClump of this bucket

#if defined(LOCK_INSTRUMENTATION) || defined(IRTLDEBUG)
    CBucket()
#ifdef LOCK_INSTRUMENTATION
        : m_Lock(_LockName())
#endif // LOCK_INSTRUMENTATION
    {
#ifdef IRTLDEBUG
        LOCK_LOCKTYPE lt = BucketLock::LockType();
        if (lt == LOCK_SPINLOCK  ||  lt == LOCK_FAKELOCK)
            IRTLASSERT(sizeof(*this) <= 64);
#endif IRTLDEBUG
    }
#endif // LOCK_INSTRUMENTATION || IRTLDEBUG

    void  WriteLock()           { m_Lock.WriteLock(); }
    void  ReadLock() const      { m_Lock.ReadLock(); }
    void  WriteUnlock() const   { m_Lock.WriteUnlock();   }
    void  ReadUnlock() const    { m_Lock.ReadUnlock();   }
    bool  IsWriteLocked() const { return m_Lock.IsWriteLocked(); }
    bool  IsReadLocked() const  { return m_Lock.IsReadLocked(); }
    bool  IsWriteUnlocked() const { return m_Lock.IsWriteUnlocked(); }
    bool  IsReadUnlocked() const  { return m_Lock.IsReadUnlocked(); }
    void  SetSpinCount(WORD wSpins) { m_Lock.SetSpinCount(wSpins); }
    WORD  GetSpinCount() const  { return m_Lock.GetSpinCount(); }
#ifdef LOCK_INSTRUMENTATION
    CLockStatistics LockStats() const {return m_Lock.Statistics();}
#endif // LOCK_INSTRUMENTATION
}; // class CBucket



// The hash table space is divided into fixed-size segments (arrays of
// CBuckets) and physically grows/shrinks one segment at a time.
//
// We provide small, medium, and large segments to better tune the
// overall memory requirements of the hash table according to the
// expected usage of an instance.

class CSegment
{
public:
    CBucket m_bktSlots[1];

    // See note at m_bktSlots2 in CSmallSegment below
    CBucket& Slot(DWORD i)
    { return m_bktSlots[i]; }
}; // class CSegment


// Small-sized segments contain 2^3 = 8 buckets => ~0.5Kb
class CSmallSegment : public CSegment
{
public:
    // Maximum table size equals MAX_DIRSIZE * SEGSIZE buckets.
    enum {
        SEGBITS  =            3,// number of bits extracted from a hash
                                // address for offset within a segment
        SEGSIZE  = (1<<SEGBITS),// segment size
        SEGMASK  = (SEGSIZE-1), // mask used for extracting offset bit
        INITSIZE = 1 * SEGSIZE, // #segments to allocate initially
    };

    // Hack: assumes immediately after CSegment::m_bktSlots, with no
    // padding. The STATIC_ASSERT in _AllocateSegment should cause a
    // compile-time error if this assumption is false.
    CBucket m_bktSlots2[SEGSIZE-1];

public:
    DWORD Bits() const      { return SEGBITS; }
    DWORD Size() const      { return SEGSIZE; }
    DWORD Mask() const      { return SEGMASK; }
    DWORD InitSize() const  { return INITSIZE;}

#ifdef IRTLDEBUG
    CSmallSegment()
    {
        IRTLASSERT(&Slot(1) == m_bktSlots2);
        IRTLASSERT(((DWORD_PTR)this & (LKRHASH_MEM_DEFAULT_ALIGN-1)) == 0);
        IRTLASSERT(sizeof(*this) == SEGSIZE * sizeof(CBucket));
    }
#endif // IRTLDEBUG

    LKRHASH_ALLOCATOR_DEFINITIONS(CSmallSegment);
}; // class CSmallSegment


// Medium-sized segments contain 2^6 = 64 buckets => ~4Kb
class CMediumSegment : public CSegment
{
public:
    enum {
        SEGBITS  =            6,
        SEGSIZE  = (1<<SEGBITS),
        SEGMASK  = (SEGSIZE-1),
        INITSIZE = 2 * SEGSIZE,
    };

    CBucket m_bktSlots2[SEGSIZE-1];

public:
    DWORD Bits() const      { return SEGBITS; }
    DWORD Size() const      { return SEGSIZE; }
    DWORD Mask() const      { return SEGMASK; }
    DWORD InitSize() const  { return INITSIZE;}

#ifdef IRTLDEBUG
    CMediumSegment()
    {
        IRTLASSERT(&Slot(1) == m_bktSlots2);
        IRTLASSERT(((DWORD_PTR)this & (LKRHASH_MEM_DEFAULT_ALIGN-1)) == 0);
        IRTLASSERT(sizeof(*this) == SEGSIZE * sizeof(CBucket));
    }
#endif // IRTLDEBUG

    LKRHASH_ALLOCATOR_DEFINITIONS(CMediumSegment);
}; // class CMediumSegment


// Large-sized segments contain 2^9 = 512 buckets => ~32Kb
class CLargeSegment : public CSegment
{
public:
    enum {
        SEGBITS  =            9,
        SEGSIZE  = (1<<SEGBITS),
        SEGMASK  = (SEGSIZE-1),
        INITSIZE = 4 * SEGSIZE,
    };

    CBucket m_bktSlots2[SEGSIZE-1];

public:
    DWORD Bits() const      { return SEGBITS; }
    DWORD Size() const      { return SEGSIZE; }
    DWORD Mask() const      { return SEGMASK; }
    DWORD InitSize() const  { return INITSIZE;}

#ifdef IRTLDEBUG
    CLargeSegment()
    {
        IRTLASSERT(&Slot(1) == m_bktSlots2);
        IRTLASSERT(((DWORD_PTR)this & (LKRHASH_MEM_DEFAULT_ALIGN-1)) == 0);
        IRTLASSERT(sizeof(*this) == SEGSIZE * sizeof(CBucket));
    }
#endif // IRTLDEBUG

    LKRHASH_ALLOCATOR_DEFINITIONS(CLargeSegment);
}; // class CLargeSegment



// A directory keeps track of the segments comprising the hash table.
// The directory is just a variable-sized array of pointers to
// segments (CDirEntrys).
class CDirEntry
{
public:
    // MIN_DIRSIZE and MAX_DIRSIZE can be changed independently
    // of anything else.  Should be powers of two.
    enum {
        MIN_DIRSIZE =  (1<<3),   // minimum directory size
        MAX_DIRSIZE = (1<<20),   // maximum directory size
    };

    CSegment* m_pseg;

    CDirEntry()
        : m_pseg(NULL)
    {}

    ~CDirEntry()
    { delete m_pseg; }
}; // class CDirEntry



#ifdef LKR_STL_ITERATORS

class IRTL_DLLEXP CLKRLinearHashTable_Iterator;
class IRTL_DLLEXP CLKRHashTable_Iterator;


class IRTL_DLLEXP CLKRLinearHashTable_Iterator
{
    friend class CLKRLinearHashTable;
    friend class CLKRHashTable;
    friend class CLKRHashTable_Iterator;

protected:
    CLKRLinearHashTable* m_plht;        // which linear hash table?
    CNodeClump*          m_pnc;         // a CNodeClump in bucket
    DWORD                m_dwBucketAddr;// bucket index
    short                m_iNode;       // offset within m_pnc

    enum {
        NODES_PER_CLUMP = CNodeClump::NODES_PER_CLUMP,
        NODE_BEGIN      = CNodeClump::NODE_BEGIN,
        NODE_END        = CNodeClump::NODE_END,
        NODE_STEP       = CNodeClump::NODE_STEP,
    };

    CLKRLinearHashTable_Iterator(
        CLKRLinearHashTable* plht,
        CNodeClump*          pnc,
        DWORD                dwBucketAddr,
        short                iNode)
        : m_plht(plht),
          m_pnc(pnc),
          m_dwBucketAddr(dwBucketAddr),
          m_iNode(iNode)
    {
        LKR_ITER_TRACE(_TEXT("  LKLH::prot ctor, this=%p, plht=%p, ")
                       _TEXT("pnc=%p, ba=%d, in=%d\n"),
                       this, plht, pnc, dwBucketAddr, iNode);
    }

    inline void _AddRef(
        int nIncr) const;

    bool _Increment(
        bool fDecrementOldValue=true);

public:
    CLKRLinearHashTable_Iterator()
        : m_plht(NULL),
          m_pnc(NULL),
          m_dwBucketAddr(0),
          m_iNode(0)
    {
        LKR_ITER_TRACE(_TEXT("  LKLH::default ctor, this=%p\n"), this);
    }

    CLKRLinearHashTable_Iterator(
        const CLKRLinearHashTable_Iterator& rhs)
        : m_plht(rhs.m_plht),
          m_pnc(rhs.m_pnc),
          m_dwBucketAddr(rhs.m_dwBucketAddr),
          m_iNode(rhs.m_iNode)
    {
        LKR_ITER_TRACE(_TEXT("  LKLH::copy ctor, this=%p, rhs=%p\n"),
                       this, &rhs);
        _AddRef(+1);
    }

    CLKRLinearHashTable_Iterator& operator=(
        const CLKRLinearHashTable_Iterator& rhs)
    {
        LKR_ITER_TRACE(_TEXT("  LKLH::operator=, this=%p, rhs=%p\n"),
                       this, &rhs);
        rhs._AddRef(+1);
        this->_AddRef(-1);

        m_plht =         rhs.m_plht;
        m_pnc =          rhs.m_pnc;
        m_dwBucketAddr = rhs.m_dwBucketAddr;
        m_iNode =        rhs.m_iNode;

        return *this;
    }

    ~CLKRLinearHashTable_Iterator()
    {
        LKR_ITER_TRACE(_TEXT("  LKLH::dtor, this=%p, plht=%p\n"),
                       this, m_plht);
        _AddRef(-1);
    }

    bool Increment()
    {
        return IsValid()  ? _Increment()  :  false;

    }

    bool IsValid() const
    {
        bool fValid = (m_plht != NULL  &&  m_pnc != NULL
                       &&  0 <= m_iNode  &&  m_iNode < NODES_PER_CLUMP);
        if (fValid)
            fValid = (m_pnc->m_pvNode[m_iNode] != NULL);
        IRTLASSERT(fValid);
        return fValid;
    }

    const void* Record() const
    {
        IRTLASSERT(IsValid());
        return m_pnc->m_pvNode[m_iNode];
    }

    inline const DWORD_PTR Key() const;

    bool operator==(
        const CLKRLinearHashTable_Iterator& rhs) const
    {
        LKR_ITER_TRACE(_TEXT("  LKLH::operator==, this=%p, rhs=%p\n"),
                       this, &rhs);
        // m_pnc and m_iNode uniquely identify an iterator
        bool fEQ = ((m_pnc == rhs.m_pnc)    // most unique field
                    &&  (m_iNode == rhs.m_iNode));
        IRTLASSERT(!fEQ || ((m_plht == rhs.m_plht)
                            &&  (m_dwBucketAddr == rhs.m_dwBucketAddr)));
        return fEQ;
    }

    bool operator!=(
        const CLKRLinearHashTable_Iterator& rhs) const
    {
        LKR_ITER_TRACE(_TEXT("  LKLH::operator!=, this=%p, rhs=%p\n"),
                       this, &rhs);
        bool fNE = ((m_pnc != rhs.m_pnc)
                    ||  (m_iNode != rhs.m_iNode));
        //// IRTLASSERT(fNE == !this->operator==(rhs));
        return fNE;
    }
}; // class CLKRLinearHashTable_Iterator



class IRTL_DLLEXP CLKRHashTable_Iterator
{
    friend class CLKRHashTable;

protected:
    // order important to minimize size
    CLKRHashTable*                  m_pht;      // which hash table?
    CLKRLinearHashTable_Iterator    m_subiter;  // iterator into subtable
    short                           m_ist;      // index of subtable

    CLKRHashTable_Iterator(
        CLKRHashTable* pht,
        short          ist)
        : m_pht(pht),
          m_subiter(CLKRLinearHashTable_Iterator()), // zero
          m_ist(ist)
    {
        LKR_ITER_TRACE(_TEXT(" LKHT::prot ctor, this=%p, pht=%p, ist=%d\n"),
                       this, pht, ist);
    }

    bool _Increment(
        bool fDecrementOldValue=true);

public:
    CLKRHashTable_Iterator()
        : m_pht(NULL),
          m_subiter(CLKRLinearHashTable_Iterator()), // zero
          m_ist(0)
    {
        LKR_ITER_TRACE(_TEXT(" LKHT::default ctor, this=%p\n"), this);
    }

#ifdef IRTLDEBUG
    // Compiler does a perfectly adequate job of synthesizing these
    // methods.
    CLKRHashTable_Iterator(
        const CLKRHashTable_Iterator& rhs)
        : m_pht(rhs.m_pht),
          m_subiter(rhs.m_subiter),
          m_ist(rhs.m_ist)
    {
        LKR_ITER_TRACE(_TEXT(" LKHT::copy ctor, this=%p, rhs=%p\n"),
                       this, &rhs);
    }

    CLKRHashTable_Iterator& operator=(
        const CLKRHashTable_Iterator& rhs)
    {
        LKR_ITER_TRACE(_TEXT(" LKHT::operator=, this=%p, rhs=%p\n"),
                       this, &rhs);

        m_ist     = rhs.m_ist;
        m_subiter = rhs.m_subiter;
        m_pht     = rhs.m_pht;

        return *this;
    }

    ~CLKRHashTable_Iterator()
    {
        LKR_ITER_TRACE(_TEXT(" LKHT::dtor, this=%p, pht=%p\n"), this, m_pht);
    }
#endif

    bool Increment()
    {
        return IsValid()  ? _Increment()  :  false;

    }

    bool IsValid() const
    {

        bool fValid = (m_pht != NULL  &&  m_ist >= 0);
        IRTLASSERT(fValid);
        fValid = fValid  &&  (m_subiter.m_plht != NULL);
        IRTLASSERT(fValid);
        fValid = fValid  &&  (m_subiter.m_pnc != NULL);
        IRTLASSERT(fValid);
        fValid = fValid  &&  (0 <= m_subiter.m_iNode);
        IRTLASSERT(fValid);
        fValid = fValid  &&  (m_subiter.m_iNode < CNodeClump::NODES_PER_CLUMP);
        IRTLASSERT(fValid);

        if (fValid)
            fValid = (m_subiter.m_pnc->m_pvNode[m_subiter.m_iNode] != NULL);
        IRTLASSERT(fValid);
        return fValid;
    }

    const void* Record() const
    {
        IRTLASSERT(IsValid());
        return m_subiter.Record();
    }

    const DWORD_PTR Key() const
    {
        IRTLASSERT(IsValid());
        return m_subiter.Key();
    }

    bool operator==(
        const CLKRHashTable_Iterator& rhs) const
    {
        LKR_ITER_TRACE(_TEXT(" LKHT::operator==, this=%p, rhs=%p\n"),
                       this, &rhs);
        // m_pnc and m_iNode uniquely identify an iterator
        bool fEQ = ((m_subiter.m_pnc
                            == rhs.m_subiter.m_pnc)     // most unique field
                    &&  (m_subiter.m_iNode == rhs.m_subiter.m_iNode));
        IRTLASSERT(!fEQ
                   || ((m_ist == rhs.m_ist)
                       &&  (m_pht == rhs.m_pht)
                       &&  (m_subiter.m_plht == rhs.m_subiter.m_plht)
                       &&  (m_subiter.m_dwBucketAddr
                                == rhs.m_subiter.m_dwBucketAddr)));
        return fEQ;
    }

    bool operator!=(
        const CLKRHashTable_Iterator& rhs) const
    {
        LKR_ITER_TRACE(_TEXT(" LKHT::operator!=, this=%p, rhs=%p\n"),
                       this, &rhs);
        bool fNE = ((m_subiter.m_pnc != rhs.m_subiter.m_pnc)
                    ||  (m_subiter.m_iNode != rhs.m_subiter.m_iNode));
        //// IRTLASSERT(fNE == !this->operator==(rhs));
        return fNE;
    }
}; // class CLKRHashTable_Iterator

#endif // LKR_STL_ITERATORS



//--------------------------------------------------------------------
// CLKRLinearHashTable
//
// A thread-safe linear hash table.
//--------------------------------------------------------------------

class IRTL_DLLEXP CLKRLinearHashTable
{
public:
    typedef LKR_TABLE_LOCK  TableLock;
    typedef LKR_BUCKET_LOCK BucketLock;

#ifdef LKR_DEPRECATED_ITERATORS
    class CIterator;
    friend class CLKRLinearHashTable::CIterator;
#endif // LKR_DEPRECATED_ITERATORS

#ifdef LKR_STL_ITERATORS
    friend class CLKRLinearHashTable_Iterator;
    typedef CLKRLinearHashTable_Iterator Iterator;
#endif // LKR_STL_ITERATORS

private:
    friend class CNodeClump;
    friend class CLKRHashTable;

#ifdef LKRHASH_ALLOCATOR_NEW
    friend bool LKRHashTableInit();
    friend void LKRHashTableUninit();
#endif // LKRHASH_ALLOCATOR_NEW

#ifdef LKRHASH_INSTRUMENTATION
    // TODO
#endif // LKRHASH_INSTRUMENTATION


public:

    // aliases for convenience
    enum {
        NODES_PER_CLUMP        = CNodeClump::NODES_PER_CLUMP,
        MIN_DIRSIZE            = CDirEntry::MIN_DIRSIZE,
        MAX_DIRSIZE            = CDirEntry::MAX_DIRSIZE,
        NAME_SIZE              = 16,
        NODE_BEGIN             = CNodeClump::NODE_BEGIN,
        NODE_END               = CNodeClump::NODE_END,
        NODE_STEP              = CNodeClump::NODE_STEP,
        HASH_INVALID_SIGNATURE = CNodeClump::HASH_INVALID_SIGNATURE,
    };


private:

    //
    // Miscellaneous helper functions
    //

    // Convert a hash signature to a bucket address
    inline DWORD _BucketAddress(DWORD dwSignature) const
    {
        DWORD dwBktAddr = _H0(dwSignature);
        // Has this bucket been split already?
        if (dwBktAddr < m_iExpansionIdx)
            dwBktAddr = _H1(dwSignature);
        IRTLASSERT(dwBktAddr < m_cActiveBuckets);
        IRTLASSERT(dwBktAddr < (m_cDirSegs << m_dwSegBits));
        return dwBktAddr;
    }

    // See the Linear Hashing paper
    static DWORD _H0(DWORD dwSignature, DWORD dwBktAddrMask)
    { return dwSignature & dwBktAddrMask; }

    DWORD        _H0(DWORD dwSignature) const
    { return _H0(dwSignature, m_dwBktAddrMask0); }

    // See the Linear Hashing paper.  Preserves one bit more than _H0.
    static DWORD _H1(DWORD dwSignature, DWORD dwBktAddrMask)
    { return dwSignature & ((dwBktAddrMask << 1) | 1); }

    DWORD        _H1(DWORD dwSignature) const
    { return _H0(dwSignature, m_dwBktAddrMask1); }

    // In which segment within the directory does the bucketaddress lie?
    // (Return type must be lvalue so that it can be assigned to.)
    CSegment*&   _Segment(DWORD dwBucketAddr) const
    {
        const DWORD iSeg = dwBucketAddr >> m_dwSegBits;
        IRTLASSERT(m_paDirSegs != NULL  &&  iSeg < m_cDirSegs);
        return m_paDirSegs[iSeg].m_pseg;
    }

    // Offset within the segment of the bucketaddress
    DWORD        _SegIndex(DWORD dwBucketAddr) const
    { return (dwBucketAddr & m_dwSegMask); }

    // Convert a bucketaddress to a CBucket*
    inline CBucket* _Bucket(DWORD dwBucketAddr) const
    {
        IRTLASSERT(dwBucketAddr < m_cActiveBuckets);
        CSegment* const pseg = _Segment(dwBucketAddr);
        IRTLASSERT(pseg != NULL);
        return &(pseg->Slot(_SegIndex(dwBucketAddr)));
    }

    // Extract the key from a record
    const DWORD_PTR  _ExtractKey(const void* pvRecord) const
    {
        IRTLASSERT(pvRecord != NULL);
        IRTLASSERT(m_pfnExtractKey != NULL);
        return (*m_pfnExtractKey)(pvRecord);
    }

    // Hash the key
    DWORD        _CalcKeyHash(const DWORD_PTR pnKey) const
    {
        // Note pnKey==0 is acceptable, as the real key type could be an int
        IRTLASSERT(m_pfnCalcKeyHash != NULL);
        DWORD dwHash = (*m_pfnCalcKeyHash)(pnKey);
        // We forcibly scramble the result to help ensure a better distribution
#ifndef __HASHFN_NO_NAMESPACE__
        dwHash = HashFn::HashRandomizeBits(dwHash);
#else // !__HASHFN_NO_NAMESPACE__
        dwHash = ::HashRandomizeBits(dwHash);
#endif // !__HASHFN_NO_NAMESPACE__
        IRTLASSERT(dwHash != HASH_INVALID_SIGNATURE);
        return dwHash;
    }

    // Compare two keys for equality
    bool       _EqualKeys(const DWORD_PTR pnKey1, const DWORD_PTR pnKey2) const
    {
        IRTLASSERT(m_pfnEqualKeys != NULL);
        return (*m_pfnEqualKeys)(pnKey1, pnKey2);
    }

    // AddRef or Release a record.
    void         _AddRefRecord(const void* pvRecord, int nIncr) const
    {
        IRTLASSERT(pvRecord != NULL  &&  (nIncr == -1  ||  nIncr == +1));
        IRTLASSERT(m_pfnAddRefRecord != NULL);
        (*m_pfnAddRefRecord)(pvRecord, nIncr);
    }

    // Find a bucket, given its signature.
    CBucket*     _FindBucket(DWORD dwSignature, bool fLockForWrite) const;

    // Used by _FindKey so that the thread won't deadlock if the user has
    // already explicitly called table->WriteLock().
    bool _ReadOrWriteLock() const
    { return m_Lock.ReadOrWriteLock(); }

    void _ReadOrWriteUnlock(bool fReadLocked) const
    { m_Lock.ReadOrWriteUnlock(fReadLocked); }

    // Memory allocation wrappers to allow us to simulate allocation
    // failures during testing
    static CDirEntry* const
    _AllocateSegmentDirectory(
        size_t n);

    bool
    _FreeSegmentDirectory();

    static CNodeClump* const
    _AllocateNodeClump();

    static bool
    _FreeNodeClump(
        CNodeClump* pnc);

    CSegment* const
    _AllocateSegment() const;

    bool
    _FreeSegment(
        CSegment* pseg) const;

#ifdef LOCK_INSTRUMENTATION
    static LONG sm_cTables;

    static const char*
    _LockName()
    {
        LONG l = ++sm_cTables;
        // possible race condition but we don't care, as this is never
        // used in production code
        static char s_szName[CLockStatistics::L_NAMELEN];
        wsprintf(s_szName, "LH%05x", 0xFFFFF & l);
        return s_szName;
    }

    // Statistics for the table lock
    CLockStatistics _LockStats() const
    { return m_Lock.Statistics(); }
#endif // LOCK_INSTRUMENTATION

private:

    // Fields are ordered so as to minimize number of cache lines touched

    DWORD         m_dwSignature;    // debugging: id & corruption check
    CHAR          m_szName[NAME_SIZE];  // an identifier for debugging
    mutable LK_RETCODE m_lkrcState; // Internal state of table
    mutable TableLock m_Lock;       // Lock on entire linear hash table

    // type-specific function pointers
    PFnExtractKey   m_pfnExtractKey;    // Extract key from record
    PFnCalcKeyHash  m_pfnCalcKeyHash;   // Calculate hash signature of key
    PFnEqualKeys    m_pfnEqualKeys;     // Compare two keys
    PFnAddRefRecord m_pfnAddRefRecord;  // AddRef a record

    LK_TABLESIZE  m_lkts;           // "size" of table: small, medium, or large
    DWORD         m_dwSegBits;      // C{Small,Medium,Large}Segment::SEGBITS
    DWORD         m_dwSegSize;      // C{Small,Medium,Large}Segment::SEGSIZE
    DWORD         m_dwSegMask;      // C{Small,Medium,Large}Segment::SEGMASK
    double        m_MaxLoad;        // max load factor (average chain length)

    DWORD         m_dwBktAddrMask0; // mask used for address calculation
    DWORD         m_dwBktAddrMask1; // used in _H1 calculation
    DWORD         m_iExpansionIdx;  // address of next bucket to be expanded
    CDirEntry*    m_paDirSegs;      // directory of table segments
    DWORD         m_nLevel;         // number of table doublings performed
    DWORD         m_cDirSegs;       // segment directory size: varies between
                                    // MIN_DIRSIZE and MAX_DIRSIZE
    DWORD         m_cRecords;       // number of records in the table
    DWORD         m_cActiveBuckets; // number of buckets in use (table size)

    WORD          m_wBucketLockSpins;// default spin count for bucket locks

    const BYTE    m_nTableLockType; // for debugging: LOCK_SPINLOCK, etc
    const BYTE    m_nBucketLockType;// for debugging: LOCK_SPINLOCK, etc
    const CLKRHashTable* const m_phtParent;// Owning table. NULL => standalone

    const bool    m_fMultiKeys;     // Allow multiple identical keys?

#ifndef LKR_NO_GLOBAL_LIST
    static CLockedDoubleList sm_llGlobalList;// All active CLKRLinearHashTables
    CListEntry    m_leGlobalList;
#endif // !LKR_NO_GLOBAL_LIST

    void        _InsertThisIntoGlobalList()
    {
#ifndef LKR_NO_GLOBAL_LIST
        // Only add standalone CLKRLinearHashTables to global list.
        // CLKRHashTables have their own global list.
        if (m_phtParent == NULL)
            sm_llGlobalList.InsertHead(&m_leGlobalList);
#endif // !LKR_NO_GLOBAL_LIST
    }

    void        _RemoveThisFromGlobalList()
    {
#ifndef LKR_NO_GLOBAL_LIST
        if (m_phtParent == NULL)
            sm_llGlobalList.RemoveEntry(&m_leGlobalList);
#endif // !LKR_NO_GLOBAL_LIST
    }

    // Non-trivial implementation functions
    LK_RETCODE   _InsertRecord(const void* pvRecord, DWORD dwSignature,
                               bool fOverwrite
#ifdef LKR_STL_ITERATORS
                             , Iterator* piterResult=NULL
#endif // LKR_STL_ITERATORS
                               );
    LK_RETCODE   _DeleteKey(const DWORD_PTR pnKey, DWORD dwSignature);
    LK_RETCODE   _DeleteRecord(const void* pvRecord, DWORD dwSignature);
    bool         _DeleteNode(CBucket* pbkt, CNodeClump*& rpnc,
                             CNodeClump*& rpncPrev, int& riNode);
    LK_RETCODE   _FindKey(const DWORD_PTR pnKey, DWORD dwSignature,
                          const void** ppvRecord
#ifdef LKR_STL_ITERATORS
                        , Iterator* piterResult=NULL
#endif // LKR_STL_ITERATORS
                          ) const;
    LK_RETCODE   _FindRecord(const void* pvRecord, DWORD dwSignature) const;

    // returns count of errors in compacted state => 0 is good
    int          _IsNodeCompact(CBucket* const pbkt) const;


#ifdef LKR_APPLY_IF
    // Predicate functions
    static LK_PREDICATE WINAPI
    _PredTrue(const void* /*pvRecord*/, void* /*pvState*/)
    { return LKP_PERFORM; }

    DWORD        _Apply(PFnRecordAction pfnAction, void* pvState,
                        LK_LOCKTYPE lkl, LK_PREDICATE& rlkp);
    DWORD        _ApplyIf(PFnRecordPred   pfnPredicate,
                          PFnRecordAction pfnAction, void* pvState,
                          LK_LOCKTYPE lkl, LK_PREDICATE& rlkp);
    DWORD        _DeleteIf(PFnRecordPred pfnPredicate, void* pvState,
                           LK_PREDICATE& rlkp);
#endif // LKR_APPLY_IF

    void         _Clear(bool fShrinkDirectory);
    LK_RETCODE   _SetSegVars(LK_TABLESIZE lkts, DWORD cInitialBuckets);
    LK_RETCODE   _Expand();
    LK_RETCODE   _Contract();
    LK_RETCODE   _SplitRecordSet(CNodeClump* pncOldTarget,
                                 CNodeClump* pncNewTarget,
                                 DWORD       iExpansionIdx,
                                 DWORD       dwBktAddrMask,
                                 DWORD       dwNewBkt,
                                 CNodeClump* pncFreeList);
    LK_RETCODE   _MergeRecordSets(CBucket*    pbktNewTarget,
                                  CNodeClump* pncOldList,
                                  CNodeClump* pncFreeList);

    // Private copy ctor and op= to prevent compiler synthesizing them.
    // TODO: implement these properly; they could be useful.
    CLKRLinearHashTable(const CLKRLinearHashTable&);
    CLKRLinearHashTable& operator=(const CLKRLinearHashTable&);

private:
    // This ctor is used by CLKRHashTable
    CLKRLinearHashTable(
        LPCSTR          pszName,        // An identifier for debugging
        PFnExtractKey   pfnExtractKey,  // Extract key from record
        PFnCalcKeyHash  pfnCalcKeyHash, // Calculate hash signature of key
        PFnEqualKeys    pfnEqualKeys,   // Compare two keys
        PFnAddRefRecord pfnAddRefRecord,// AddRef in FindKey, etc
        double          maxload,        // Upperbound on average chain length
        DWORD           initsize,       // Initial size of hash table.
        CLKRHashTable*  phtParent,      // Owning table.
        bool            fMultiKeys      // Allow multiple identical keys?
        );

    LK_RETCODE
    _Initialize(
        PFnExtractKey   pfnExtractKey,
        PFnCalcKeyHash  pfnCalcKeyHash,
        PFnEqualKeys    pfnEqualKeys,
        PFnAddRefRecord pfnAddRefRecord,
        LPCSTR          pszName,
        double          maxload,
        DWORD           initsize);

public:
    CLKRLinearHashTable(
        LPCSTR          pszName,        // An identifier for debugging
        PFnExtractKey   pfnExtractKey,  // Extract key from record
        PFnCalcKeyHash  pfnCalcKeyHash, // Calculate hash signature of key
        PFnEqualKeys    pfnEqualKeys,   // Compare two keys
        PFnAddRefRecord pfnAddRefRecord,// AddRef in FindKey, etc
        double   maxload=LK_DFLT_MAXLOAD,// Upperbound on average chain length
        DWORD    initsize=LK_DFLT_INITSIZE, // Initial size of hash table.
        DWORD    num_subtbls=LK_DFLT_NUM_SUBTBLS, // for signature compatiblity
                                                  // with CLKRHashTable
        bool            fMultiKeys=false  // Allow multiple identical keys?
        );

    ~CLKRLinearHashTable();

    static const TCHAR* ClassName()
    {return _TEXT("CLKRLinearHashTable");}

    int                NumSubTables() const  {return 1;}

    bool               MultiKeys() const
    {
        return false;
        // return m_fMultiKeys;     // TODO: implement
    }

    static LK_TABLESIZE NumSubTables(DWORD& rinitsize, DWORD& rnum_subtbls);

    // Insert a new record into hash table.
    // Returns LK_SUCCESS if all OK, LK_KEY_EXISTS if same key already
    // exists (unless fOverwrite), LK_ALLOC_FAIL if out of space,
    // or LK_BAD_RECORD for a bad record.
    LK_RETCODE     InsertRecord(const void* pvRecord, bool fOverwrite=false)
    {
        if (!IsUsable())
            return m_lkrcState;

        if (pvRecord == NULL)
            return LK_BAD_RECORD;

        return _InsertRecord(pvRecord, _CalcKeyHash(_ExtractKey(pvRecord)),
                             fOverwrite);
    }

    // Delete record with the given key.
    // Returns LK_SUCCESS if all OK, or LK_NO_SUCH_KEY if not found
    LK_RETCODE     DeleteKey(const DWORD_PTR pnKey)
    {
        if (!IsUsable())
            return m_lkrcState;

        return _DeleteKey(pnKey, _CalcKeyHash(pnKey));
    }

    // Delete a record from the table, if present.
    // Returns LK_SUCCESS if all OK, or LK_NO_SUCH_KEY if not found
    LK_RETCODE     DeleteRecord(const void* pvRecord)
    {
        if (!IsUsable())
            return m_lkrcState;

        if (pvRecord == NULL)
            return LK_BAD_RECORD;

        return _DeleteRecord(pvRecord, _CalcKeyHash(_ExtractKey(pvRecord)));
    }

    // Find record with given key.
    // Returns:  LK_SUCCESS, if record found (record is returned in *ppvRecord)
    //           LK_BAD_RECORD, if ppvRecord is invalid
    //           LK_NO_SUCH_KEY, if no record with given key value was found
    //           LK_UNUSABLE, if hash table not in usable state
    // Note: the record is AddRef'd.  You must decrement the reference
    // count when you are finished with the record (if you're implementing
    // refcounting semantics).
    LK_RETCODE     FindKey(const DWORD_PTR pnKey,
                           const void** ppvRecord) const
    {
        if (!IsUsable())
            return m_lkrcState;

        if (ppvRecord == NULL)
            return LK_BAD_RECORD;

        return _FindKey(pnKey, _CalcKeyHash(pnKey), ppvRecord);
    }

    // Sees if the record is contained in the table
    // Returns:  LK_SUCCESS, if record found
    //           LK_BAD_RECORD, if pvRecord is invalid
    //           LK_NO_SUCH_KEY, if record is not in the table
    //           LK_UNUSABLE, if hash table not in usable state
    // Note: the record is *not* AddRef'd.
    LK_RETCODE     FindRecord(const void* pvRecord) const
    {
        if (!IsUsable())
            return m_lkrcState;

        if (pvRecord == NULL)
            return LK_BAD_RECORD;

        return _FindRecord(pvRecord, _CalcKeyHash(_ExtractKey(pvRecord)));
    }


#ifdef LKR_APPLY_IF
    // Walk the hash table, applying pfnAction to all records.
    // Locks the whole table for the duration with either a (possibly
    // shared) readlock or a writelock, according to lkl.
    // Loop is aborted if pfnAction returns LKA_ABORT.
    // Returns the number of successful applications.
    DWORD          Apply(PFnRecordAction pfnAction,
                         void*           pvState=NULL,
                         LK_LOCKTYPE     lkl=LKL_READLOCK);

    // Walk the hash table, applying pfnAction to any records that match
    // pfnPredicate.  Locks the whole table for the duration with either
    // a (possibly shared) readlock or a writelock, according to lkl.
    // Loop is aborted if pfnAction returns LKA_ABORT.
    // Returns the number of successful applications.
    DWORD          ApplyIf(PFnRecordPred   pfnPredicate,
                           PFnRecordAction pfnAction,
                           void*           pvState=NULL,
                           LK_LOCKTYPE     lkl=LKL_READLOCK);

    // Delete any records that match pfnPredicate.
    // Locks the table for the duration with a writelock.
    // Returns the number of deletions.
    //
    // Do *not* walk the hash table by hand with an iterator and call
    // DeleteKey.  The iterator will end up pointing to garbage.
    DWORD          DeleteIf(PFnRecordPred pfnPredicate,
                            void*         pvState=NULL);
#endif // LKR_APPLY_IF


    // Check table for consistency.  Returns 0 if okay, or the number of
    // errors otherwise.
    int            CheckTable() const;

    // Remove all data from the table
    void           Clear()
    {
        WriteLock();
        _Clear(true);
        WriteUnlock();
    }

    // Number of elements in the table
    DWORD          Size() const
    { return m_cRecords; }

    // Maximum possible number of elements in the table
    DWORD          MaxSize() const
    { return static_cast<DWORD>(m_MaxLoad * MAX_DIRSIZE * m_dwSegSize); }

    // Get hash table statistics
    CLKRHashTableStats GetStatistics() const;

    // Is the hash table usable?
    bool           IsUsable() const
    { return (m_lkrcState == LK_SUCCESS); }

    // Is the hash table consistent and correct?
    bool           IsValid() const
    {
        STATIC_ASSERT(((MIN_DIRSIZE & (MIN_DIRSIZE-1)) == 0)  // == (1 << N)
                      &&  ((1 << 3) <= MIN_DIRSIZE)
                      &&  (MIN_DIRSIZE < MAX_DIRSIZE)
                      &&  ((MAX_DIRSIZE & (MAX_DIRSIZE-1)) == 0)
                      &&  (MAX_DIRSIZE <= (1 << 30)));

        bool f = (m_lkrcState == LK_SUCCESS     // serious internal failure?
                  &&  m_paDirSegs != NULL
                  &&  MIN_DIRSIZE <= m_cDirSegs  &&  m_cDirSegs <= MAX_DIRSIZE
                  &&  (m_cDirSegs & (m_cDirSegs-1)) == 0
                  &&  m_pfnExtractKey != NULL
                  &&  m_pfnCalcKeyHash != NULL
                  &&  m_pfnEqualKeys != NULL
                  &&  m_pfnAddRefRecord != NULL
                  &&  m_cActiveBuckets > 0
                  &&  ValidSignature()
                  );
        if (!f)
            m_lkrcState = LK_UNUSABLE;
        return f;
    }

    // Set the spin count on the table lock
    void        SetTableLockSpinCount(WORD wSpins)
    { m_Lock.SetSpinCount(wSpins); }

    // Get the spin count on the table lock
    WORD        GetTableLockSpinCount() const
    { return m_Lock.GetSpinCount(); }

    // Set/Get the spin count on the bucket locks
    void        SetBucketLockSpinCount(WORD wSpins);
    WORD        GetBucketLockSpinCount() const;

    enum {
        SIGNATURE =      (('L') | ('K' << 8) | ('L' << 16) | ('H' << 24)),
        SIGNATURE_FREE = (('L') | ('K' << 8) | ('L' << 16) | ('x' << 24)),
    };

    bool
    ValidSignature() const
    { return m_dwSignature == SIGNATURE;}


    //
    // Lock manipulators
    //

    // Lock the table (exclusively) for writing
    void        WriteLock()
    { m_Lock.WriteLock(); }

    // Lock the table (possibly shared) for reading
    void        ReadLock() const
    { m_Lock.ReadLock(); }

    // Unlock the table for writing
    void        WriteUnlock() const
    { m_Lock.WriteUnlock(); }

    // Unlock the table for reading
    void        ReadUnlock() const
    { m_Lock.ReadUnlock(); }

    // Is the table already locked for writing?
    bool        IsWriteLocked() const
    { return m_Lock.IsWriteLocked(); }

    // Is the table already locked for reading?
    bool        IsReadLocked() const
    { return m_Lock.IsReadLocked(); }

    // Is the table unlocked for writing?
    bool        IsWriteUnlocked() const
    { return m_Lock.IsWriteUnlocked(); }

    // Is the table unlocked for reading?
    bool        IsReadUnlocked() const
    { return m_Lock.IsReadUnlocked(); }

    // Convert the read lock to a write lock
    void  ConvertSharedToExclusive() const
    { m_Lock.ConvertSharedToExclusive(); }

    // Convert the write lock to a read lock
    void  ConvertExclusiveToShared() const
    { m_Lock.ConvertExclusiveToShared(); }

    LKRHASH_ALLOCATOR_DEFINITIONS(CLKRLinearHashTable);


#ifdef LKR_DEPRECATED_ITERATORS

public:

    // Iterators can be used to walk the table.  To ensure a consistent
    // view of the data, the iterator locks the whole table.  This can
    // have a negative effect upon performance, because no other thread
    // can do anything with the table.  Use with care.
    //
    // You should not use an iterator to walk the table, calling DeleteKey,
    // as the iterator will end up pointing to garbage.
    //
    // Use Apply, ApplyIf, or DeleteIf instead of iterators to safely
    // walk the tree. Or use the STL-style iterators.
    //
    // Note that iterators acquire a reference to the record pointed to
    // and release that reference as soon as the iterator is incremented.
    // In other words, this code is safe:
    //     lkrc = ht.IncrementIterator(&iter);
    //     // assume lkrc == LK_SUCCESS for the sake of this example
    //     CMyHashTable::Record* pRec = iter.Record();
    //     Foo(pRec);  // uses pRec but doesn't hang on to it
    //     lkrc = ht.IncrementIterator(&iter);
    //
    // But this code is not safe because pRec is used out of the scope of
    // the iterator that provided it:
    //     lkrc = ht.IncrementIterator(&iter);
    //     CMyHashTable::Record* pRec = iter.Record();
    //     // Broken code: Should have called ht.AddRefRecord(pRec, +1) here
    //     lkrc = ht.IncrementIterator(&iter);
    //     Foo(pRec);   // Unsafe: because no longer have a valid reference
    //
    // If the record has no reference-counting semantics, then you can
    // ignore the above remarks about scope.


    class CIterator
    {
    protected:
        friend class CLKRLinearHashTable;

        CLKRLinearHashTable* m_plht;        // which linear hash table?
        DWORD               m_dwBucketAddr; // bucket index
        CNodeClump*         m_pnc;          // a CNodeClump in bucket
        int                 m_iNode;        // offset within m_pnc
        LK_LOCKTYPE         m_lkl;          // readlock or writelock?

    private:
        // Private copy ctor and op= to prevent compiler synthesizing them.
        // Must provide (bad) implementation because we export instantiations.
        