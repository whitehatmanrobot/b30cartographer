g * pIndex );
	STDMETHODIMP	FindIpIndex	( long lIpAddress, long lIpMask, long * pIndex );
	STDMETHODIMP	Clear		( );

	//////////////////////////////////////////////////////////////////////
	// Data:
	//////////////////////////////////////////////////////////////////////
private:
	long							m_cCount;
	CComPtr<ITcpAccessException> *	m_rgItems;

	HRESULT	AddItem ( ITcpAccessException * pNew );
};

class CTcpAccessException : 
	public CComDualImpl<ITcpAccessException, &IID_ITcpAccessException, &LIBID_NNTPADMLib>, 
	public ISupportErrorInfo,
	public CComObjectRoot
{
public:
	CTcpAccessException();
	virtual ~CTcpAccessException ();

	static HRESULT CreateNew ( LPWSTR strDnsName, ITcpAccessException ** ppNew );
	static HRESULT CreateNew ( DWORD dwIpAddress, DWORD dwIpMask, ITcpAccessException ** ppNew );

BEGIN_COM_MAP(CTcpAccessException)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ITcpAccessException)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()
//DECLARE_NOT_AGGREGATABLE(CTcpAccessException) 
// Remove the comment from the line above if you don't want your object to 
// support aggregation.  The default is to support it

// ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

// DECLARE_REGISTRY(CTcpAccessException, _T("Nntpadm.TcpAccessException.1"), _T("Nntpadm.TcpAccessException"), IDS_TCPACCESSEXCEPTION_DESC, THREADFLAGS_BOTH)
// ITcpAccessException
public:

	//////////////////////////////////////////////////////////////////////
	// Properties:
	//////////////////////////////////////////////////////////////////////

	STDMETHODIMP	get_IsDnsName	( BOOL * pfIsDnsName );
	STDMETHODIMP	get_IsIpAddress	( BOOL * pfIsIpAddress );

	STDMETHODIMP	get_DnsName	( BSTR * pstrDnsName );
	STDMETHODIMP	put_DnsName	( BSTR strDnsName );

	STDMETHODIMP	get_IpAddress	( long * plIpAddress );
	STDMETHODIMP	put_IpAddress	( long lIpAddress );

	STDMETHODIMP	get_IpMask	( long * plIpMask );
	STDMETHODIMP	put_IpMask	( long lIpMask );

	//////////////////////////////////////////////////////////////////////
	// Data:
	//////////////////////////////////////////////////////////////////////
private:
	CComBSTR	m_strDnsName;
	DWORD		m_dwIpAddress;
	DWORD		m_dwIpMask;
	BOOL		m_fIsDnsName;
	BOOL		m_fIsIpAddress;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\nntp\adminsso\metautil.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

	metautil.h

Abstract:

	Useful functions for dealing with the metabase.

Author:

	Magnus Hedlund (MagnusH)		--

Revision History:

--*/

#ifndef _METAUTIL_INCLUDED_
#define _METAUTIL_INCLUDED_

// Dependencies:

#include <iiscnfg.h>	// IIS Metabase Values
#include <iiscnfgp.h>
class CMultiSz;
class CMetabaseKey;

// Defaults:

#define MD_DEFAULT_TIMEOUT	5000

// Creating a metabase object:

HRESULT CreateMetabaseObject	( LPCWSTR wszMachine, IMSAdminBase ** ppMetabase );

// Metabase property manipulation:

BOOL StdGetMetabaseProp ( CMetabaseKey * pMB, DWORD dwID, BOOL fDefault, BOOL * pfOut, LPCWSTR wszPath = _T(""), DWORD dwUserType = IIS_MD_UT_SERVER, DWORD dwFlags = METADATA_INHERIT );
BOOL StdGetMetabaseProp ( CMetabaseKey * pMB, DWORD dwID, DWORD dwDefault, DWORD * pdwOut, LPCWSTR wszPath = _T(""), DWORD dwUserType = IIS_MD_UT_SERVER, DWORD dwFlags = METADATA_INHERIT );
BOOL StdGetMetabaseProp ( CMetabaseKey * pMB, DWORD dwID, LPCWSTR strDefault, BSTR * pstrOut, LPCWSTR wszPath = _T(""), DWORD dwUserType = IIS_MD_UT_SERVER, DWORD dwFlags = METADATA_INHERIT );
BOOL StdGetMetabaseProp ( CMetabaseKey * pMB, DWORD dwID, LPCWSTR mszDefault, CMultiSz * pmszOut, LPCWSTR wszPath = _T(""), DWORD dwUserType = IIS_MD_UT_SERVER, DWORD dwFlags = METADATA_INHERIT );

BOOL StdPutMetabaseProp ( CMetabaseKey * pMB, DWORD dwID, BOOL fValue, LPCWSTR wszPath = _T(""), DWORD dwUserType = IIS_MD_UT_SERVER, DWORD dwFlags = METADATA_INHERIT );
BOOL StdPutMetabaseProp ( CMetabaseKey * pMB, DWORD dwID, DWORD dwValue, LPCWSTR wszPath = _T(""), DWORD dwUserType = IIS_MD_UT_SERVER, DWORD dwFlags = METADATA_INHERIT );
BOOL StdPutMetabaseProp ( CMetabaseKey * pMB, DWORD dwID, BSTR strValue, LPCWSTR wszPath = _T(""), DWORD dwUserType = IIS_MD_UT_SERVER, DWORD dwFlags = METADATA_INHERIT );
BOOL StdPutMetabaseProp ( CMetabaseKey * pMB, DWORD dwID, CMultiSz * pmszValue, LPCWSTR wszPath = _T(""), DWORD dwUserType = IIS_MD_UT_SERVER, DWORD dwFlags = METADATA_INHERIT );

BOOL HasKeyChanged ( IMSAdminBase * pMetabase, METADATA_HANDLE hKey, const FILETIME * pftLastChanged, LPCWSTR wszSubKey = _T("") );

// Metabase lists:

BOOL IsValidIntegerSubKey ( LPCWSTR wszSubKey );

#endif // _METAUTIL_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\nntp\adminsso\metautil.cpp ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

	metautil.cpp

Abstract:

	Useful functions for dealing with the metabase

Author:

	Magnus Hedlund (MagnusH)		--

Revision History:

--*/

#include "stdafx.h"
#include "nntpcmn.h"

#include "cmultisz.h"
#include "oleutil.h"
#include "metautil.h"
#include "metakey.h"

// Metabase property manipulation:

BOOL StdGetMetabaseProp ( CMetabaseKey * pMB, DWORD dwID, BOOL fDefault, BOOL * pfOut, LPCWSTR wszPath, DWORD dwUserType, DWORD dwFlags )
{
	TraceQuietEnter ( "StdGetMetabaseProp<BOOL>" );

	HRESULT	hr;
	DWORD	dwTemp;

	hr = pMB->GetDword ( wszPath, dwID, &dwTemp, dwFlags, dwUserType );
	if ( hr == MD_ERROR_DATA_NOT_FOUND ) {
		// Couldn't find property, use defaults.
		DebugTraceX ( 0, "Using default for ID: %d", dwID );
		dwTemp = fDefault;
		hr = NOERROR;
	}
	BAIL_ON_FAILURE(hr);

	*pfOut = dwTemp;

Exit:
	if ( FAILED(hr) ) {
		ErrorTraceX ( 0, "Failed to get metabase property ID: %d, Error: %x", dwID, hr );
		SetLastError ( HRESULTTOWIN32 ( hr ) );
	}

	return SUCCEEDED(hr);
}

BOOL StdGetMetabaseProp ( CMetabaseKey * pMB, DWORD dwID, DWORD dwDefault, DWORD * pdwOut, LPCWSTR wszPath, DWORD dwUserType, DWORD dwFlags )
{
	TraceQuietEnter ( "StdGetMetabaseProp<DWORD>" );

	DWORD	dwTemp;
	HRESULT	hr;

	hr = pMB->GetDword ( wszPath, dwID, &dwTemp, dwFlags, dwUserType );
	if ( hr == MD_ERROR_DATA_NOT_FOUND ) {
		// Couldn't find property, use defaults.

		DebugTraceX ( 0, "Using default for ID: %d", dwID );
		dwTemp = dwDefault;
		hr = NOERROR;
	}
	BAIL_ON_FAILURE(hr);

	*pdwOut = dwTemp;

Exit:
	if ( FAILED(hr) ) {
		ErrorTraceX ( 0, "Failed to get metabase property ID: %d, Error: %x", dwID, hr );
		SetLastError ( HRESULTTOWIN32 ( hr ) );
	}

	return SUCCEEDED(hr);
}

BOOL StdGetMetabaseProp ( CMetabaseKey * pMB, DWORD dwID, LPCWSTR wszDefault, BSTR * pstrOut, LPCWSTR wszPath, DWORD dwUserType, DWORD dwFlags )
{
	TraceQuietEnter ( "StdGetMetabaseProp <BSTR>" );

	HRESULT	hr			= NOERROR;
	BSTR	strNew 		= NULL;
	DWORD	cbRequired	= 0;
	DWORD	cchRequired	= 0;
	BOOL	fUseDefault	= FALSE;

	// Get the length of the string to retrieve:
	hr = pMB->GetDataSize ( wszPath, dwID, STRING_METADATA, &cbRequired, dwFlags, dwUserType );
	cchRequired	= cbRequired / sizeof ( WCHAR );

	// Is the value there?
	if ( hr == MD_ERROR_DATA_NOT_FOUND ) {

		// No, so use the default that was passed in.
		DebugTraceX ( 0, "Using default for ID: %d", dwID );

		fUseDefault	= TRUE;
		hr = NOERROR;
	}
	BAIL_ON_FAILURE(hr);

	if ( !fUseDefault ) {

		strNew = ::SysAllocStringLen ( NULL, cbRequired );
		if ( !strNew ) {
			FatalTrace ( 0, "Out of memory" );
			BAIL_WITH_FAILURE(hr, E_OUTOFMEMORY);
		}

		// Get the metabase string:
		hr = pMB->GetString ( wszPath, dwID, strNew, cbRequired, dwFlags, dwUserType );
		BAIL_ON_FAILURE(hr);
	}

	if ( fUseDefault ) {
		// Use the default:
		DebugTraceX ( 0, "Using default for ID: %d", dwID );

		strNew = ::SysAllocString ( wszDefault );
		if ( !strNew ) {
			FatalTrace ( 0, "Out of memory" );
			BAIL_WITH_FAILURE(hr, E_OUTOFMEMORY);
		}
	}

	SAFE_FREE_BSTR ( *pstrOut );
	*pstrOut = strNew;

Exit:
	if ( FAILED(hr) ) {
		ErrorTraceX ( 0, "Failed to get metabase property ID: %d, Error: %x", dwID, hr );
		SetLastError ( HRESULTTOWIN32 ( hr ) );
	}
	return SUCCEEDED(hr);
}

BOOL StdGetMetabaseProp ( CMetabaseKey * pMB, DWORD dwID, LPCWSTR mszDefault, CMultiSz * pmszOut, LPCWSTR wszPath, DWORD dwUserType, DWORD dwFlags )
{
	TraceQuietEnter ( "StdGetMetabaseProp <CMultiSz>" );

	HRESULT	hr			= NOERROR;
	BSTR	strNew 		= NULL;
	DWORD	cbRequired	= 0;
	DWORD	cchRequired	= 0;
	BOOL	fUseDefault	= FALSE;
	LPWSTR	msz			= NULL;

	// Get the length of the string to retrieve:
	hr = pMB->GetDataSize ( wszPath, dwID, MULTISZ_METADATA, &cbRequired, dwFlags, dwUserType );
	cchRequired	= cbRequired / sizeof ( WCHAR );

	// Is the value there?
	if ( hr == MD_ERROR_DATA_NOT_FOUND ) {

		// No, so use the default that was passed in.
		DebugTraceX ( 0, "Using default for ID: %d", dwID );

		fUseDefault	= TRUE;
		hr = NOERROR;
	}
	BAIL_ON_FAILURE(hr);

	if ( !fUseDefault ) {

		msz = new WCHAR [ cchRequired ];
		if ( !msz ) {
			FatalTrace ( 0, "Out of memory" );
			BAIL_WITH_FAILURE(hr, E_OUTOFMEMORY);
		}

		// Get the metabase string:
		hr = pMB->GetData ( wszPath, dwID, dwUserType, MULTISZ_METADATA, msz, &cbRequired, dwFlags );
		BAIL_ON_FAILURE(hr);

		*pmszOut = msz;
	}

	if ( fUseDefault ) {
		// Use the default:
		DebugTraceX ( 0, "Using default for ID: %d", dwID );

		*pmszOut = mszDefault;
	}

	if ( !*pmszOut ) {
		BAIL_WITH_FAILURE(hr, E_OUTOFMEMORY);
	}

Exit:
	delete msz;

	if ( FAILED(hr) ) {
		ErrorTraceX ( 0, "Failed to get metabase property ID: %d, Error: %x", dwID, hr );
		SetLastError ( HRESULTTOWIN32 ( hr ) );
	}
	return SUCCEEDED(hr);
}

BOOL StdPutMetabaseProp ( CMetabaseKey * pMB, DWORD dwID, BOOL fValue, LPCWSTR wszPath, DWORD dwUserType, DWORD dwFlags )
{
	TraceQuietEnter ( "StdPutMetabaseProp <BOOL>" );

	HRESULT		hr;

	hr = pMB->SetDword ( wszPath, dwID, fValue, dwFlags, dwUserType );

	if ( FAILED(hr) ) {
		ErrorTraceX ( 0, "Failed to put metabase property ID: %d, Error: %x", dwID, hr );
		SetLastError ( HRESULTTOWIN32 ( hr ) );
	}

	return SUCCEEDED(hr);
}

BOOL StdPutMetabaseProp ( CMetabaseKey * pMB, DWORD dwID, DWORD dwValue, LPCWSTR wszPath, DWORD dwUserType, DWORD dwFlags )
{
	TraceQuietEnter ( "StdPutMetabaseProp <DWORD>" );

	HRESULT		hr;

	hr = pMB->SetDword ( wszPath, dwID, dwValue, dwFlags, dwUserType );

	if ( FAILED(hr) ) {
		ErrorTraceX ( 0, "Failed to put metabase property ID: %d, Error: %x", dwID, hr );
		SetLastError ( HRESULTTOWIN32 ( hr ) );
	}

	return SUCCEEDED(hr);
}

BOOL StdPutMetabaseProp ( CMetabaseKey * pMB, DWORD dwID, BSTR strValue, LPCWSTR wszPath, DWORD dwUserType, DWORD dwFlags )
{
	TraceQuietEnter ( "StdPutMetabaseProp <BSTR>" );

	_ASSERT ( strValue );

	HRESULT		hr;

	if ( !strValue ) {
		// Just skip it, but log the trace.
		FatalTrace ( 0, "strValue should not be NULL here" );
		return TRUE;
	}

	hr = pMB->SetString ( wszPath, dwID, strValue, dwFlags, dwUserType );
	BAIL_ON_FAILURE (hr);

Exit:
	if ( FAILED(hr) ) {
		ErrorTraceX ( 0, "Failed to put metabase property ID: %d, Error: %x", dwID, hr );
		SetLastError ( HRESULTTOWIN32 ( hr ) );
	}

	return SUCCEEDED(hr);
}

BOOL StdPutMetabaseProp ( CMetabaseKey * pMB, DWORD dwID, CMultiSz * pmszValue, LPCWSTR wszPath, DWORD dwUserType, DWORD dwFlags )
{
	TraceQuietEnter ( "StdPutMetabaseProp <BSTR>" );

	_ASSERT ( pmszValue );

	if ( !*pmszValue ) {
		// Just skip it, but log the trace.
		FatalTrace ( 0, "strValue should not be NULL here" );
		return TRUE;
	}

	HRESULT		hr;
	DWORD		cbMultiSz;
	LPCWSTR		wszValue;

	cbMultiSz	= pmszValue->SizeInBytes ();
	wszValue	= *pmszValue;

	hr = pMB->SetData ( wszPath, dwID, dwUserType, MULTISZ_METADATA, (void *) wszValue, cbMultiSz, dwFlags );
	BAIL_ON_FAILURE (hr);

Exit:
	if ( FAILED(hr) ) {
		ErrorTraceX ( 0, "Failed to put metabase property ID: %d, Error: %x", dwID, hr );
		SetLastError ( HRESULTTOWIN32 ( hr ) );
	}

	return SUCCEEDED(hr);
}

BOOL HasKeyChanged ( IMSAdminBase * pMetabase, METADATA_HANDLE hKey, const FILETIME * pftLastChanged, LPCWSTR wszSubKey )
{
	TraceFunctEnter ( "HasKeyChanged" );

	FILETIME		ftNew;
	HRESULT			hr		= NOERROR;
	BOOL			fResult	= FALSE;

	if ( pftLastChanged->dwHighDateTime == 0 && pftLastChanged->dwLowDateTime == 0 ) {
		ErrorTrace ( 0, "Last changed time is NULL" );

		// No setting, so say it hasn't changed:
		goto Exit;
	}

	hr = pMetabase->GetLastChangeTime ( hKey, wszSubKey, &ftNew, FALSE );
	if ( FAILED (hr) ) {
		ErrorTrace ( 0, "Failed to get last change time: %x", hr );

		// This is an unexpected error.  Ignore it.
		goto Exit;
	}

	// Has the metabase been changed since last time?

	// Time can't go backwards:
	_ASSERT ( ftNew.dwHighDateTime >= pftLastChanged->dwHighDateTime );
	_ASSERT ( ftNew.dwLowDateTime >= pftLastChanged->dwLowDateTime ||
			ftNew.dwHighDateTime > pftLastChanged->dwHighDateTime );

	if ( ftNew.dwHighDateTime	!= pftLastChanged->dwHighDateTime ||
		 ftNew.dwLowDateTime	!= pftLastChanged->dwLowDateTime ) {

		fResult = TRUE;
	}

Exit:
	TraceFunctLeave ();
	return FALSE;
}

BOOL IsValidIntegerSubKey ( LPCWSTR wszSubKey )
{
	TraceQuietEnter ( "IsValidIntegerSubKey" );

	WCHAR	wszIntegerKey [ METADATA_MAX_NAME_LEN ];
	DWORD	dwItemValue;

	dwItemValue = _wtoi ( wszSubKey );
	wsprintf ( wszIntegerKey, _T("%d"), dwItemValue );

	// If the key is nonzero AND
	// The key is just the itoa value of the number:
	if ( dwItemValue != 0 &&
		 lstrcmp ( wszIntegerKey, wszSubKey ) == 0 ) {

		 return TRUE;
	}
	else {
		return FALSE;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\nntp\adminsso\metafact.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

	metafact.h

Abstract:

	Defines the CMetabaseFactory class.  This class deals with creating
	metabase objects, on either the local machine or a remote machine.

	The class provides a simple caching scheme where it will keep the name of
	the server the object was created on.

Author:

	Magnus Hedlund (MagnusH)		--

Revision History:

--*/

#ifndef _METAFACT_INCLUDED_
#define _METAFACT_INCLUDED_

class CMetabaseFactory
{
public:
	CMetabaseFactory ();
	~CMetabaseFactory ();

	HRESULT	GetMetabaseObject	( LPCWSTR wszServer, IMSAdminBase ** ppMetabase );
	// You must call (*ppMetabase)->Release() after using the metabase object.

private:
	BOOL	IsCachedMetabase	( LPCWSTR wszServer );
	BOOL	SetServerName		( LPCWSTR wszServer );
	void	DestroyMetabaseObject	( );
	
	LPWSTR		m_wszServerName;
	IMSAdminBase *	m_pMetabase;
};

#endif // _METAFACT_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\nntp\adminsso\metafact.cpp ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

	metafact.cpp

Abstract:

	The CMetabaseFactory class.

Author:

	Magnus Hedlund (MagnusH)		--

Revision History:

--*/

#include "stdafx.h"
#include "nntpcmn.h"
#include "oleutil.h"

#include "metautil.h"
#include "metafact.h"

CMetabaseFactory::CMetabaseFactory ( ) :
	m_wszServerName	( NULL ),
	m_pMetabase		( NULL )
{
}

CMetabaseFactory::~CMetabaseFactory ()
{
	if ( m_wszServerName ) {
		delete m_wszServerName;
		m_wszServerName = NULL;
	}

	DestroyMetabaseObject ( );
}

//$-------------------------------------------------------------------
//
//	CMetabaseFactory::DestroyMetabaseObject
//
//	Description:
//
//		Destroys the current metabase object.  This includes calling
//		the terminate routine on the metabase.
//
//--------------------------------------------------------------------

void CMetabaseFactory::DestroyMetabaseObject ( )
{
	TraceQuietEnter ( "CMetabaseFactory::DestroyMetabaseObject" );
	
	if ( m_pMetabase ) {
		_VERIFY ( m_pMetabase->Release () == 0 );
		m_pMetabase = NULL;
	}
}

//$-------------------------------------------------------------------
//
//	CMetabaseFactory::GetMetabaseObject
//
//	Description:
//
//		Returns an interface to the metabase.  If the metabase object
//		hasn't been created on the same machine, it is created.
//
//	Parameters:
//
//		wszServer - remote machine to create object on, or NULL for local machine.
//		ppMetabaseResult - returns the interface pointer if successful.
//			client has the responsibility to Release this pointer.
//
//	Returns:
//
//		hresult.
//
//--------------------------------------------------------------------

HRESULT	CMetabaseFactory::GetMetabaseObject	( LPCWSTR wszServer, IMSAdminBase ** ppMetabaseResult )
{
	TraceFunctEnter ( "CMetabaseFactory::GetMetabaseObject" );

	// Validate parameters:
	_ASSERT ( ppMetabaseResult != NULL );
	_ASSERT ( IS_VALID_OUT_PARAM ( ppMetabaseResult ) );

	if ( ppMetabaseResult == NULL ) {
		FatalTrace ( (LPARAM) this, "Bad Return Pointer" );

		TraceFunctLeave ();
		return E_POINTER;
	}
	
	// Variables:
	HRESULT				hr	= NOERROR;
	CComPtr<IMSAdminBase>	pNewMetabase;

	// Zero the out parameter:
	*ppMetabaseResult = NULL;

	// A server name of "" should be NULL:
	if ( wszServer && *wszServer == NULL ) {
		wszServer = NULL;
	}

	if ( IsCachedMetabase ( wszServer ) ) {
		// We've already got this metabase pointer.  Just return it.

		DebugTrace ( (LPARAM) this, "Returning Cached metabase" );
		_ASSERT ( m_pMetabase );

		*ppMetabaseResult = m_pMetabase;
		m_pMetabase->AddRef ();

		hr = NOERROR;
		goto Exit;
	}

	// We have to create the metabase object:
	StateTrace ( (LPARAM) this, "Creating new metabase" );

	// Destroy the old metabase object:
	DestroyMetabaseObject ( );

	// Setup the server name field:
	if ( !SetServerName ( wszServer ) ) {
		hr = E_OUTOFMEMORY;
		goto Exit;
	}

	// m_wszServer = NULL is valid, it means the local machine.

	hr = CreateMetabaseObject ( m_wszServerName, &pNewMetabase );
	if ( FAILED(hr) ) {
		goto Exit;
	}

	// Save the metabase pointer:
	m_pMetabase	= pNewMetabase;
	pNewMetabase.p->AddRef ();

	// Return the interface pointer:
	*ppMetabaseResult = pNewMetabase;
	pNewMetabase.p->AddRef ();

Exit:
	TraceFunctLeave ();
	return hr;

	// pMetabase will be released automatically.
}

//$-------------------------------------------------------------------
//
//	CMetabaseFactory::IsCachedMetabase
//
//	Description:
//
//		Returns TRUE if we have a metabase for the given server
//
//	Parameters:
//
//		wszServer - remote machine or NULL
//
//	Returns:
//
//		TRUE if we have a pointer already, FALSE otherwise.
//
//--------------------------------------------------------------------

BOOL CMetabaseFactory::IsCachedMetabase ( LPCWSTR wszServer )
{
	if ( !m_pMetabase ) {
		// We don't even have a cached metabase object.
		return FALSE;
	}

	if (
		// Both are the local machine OR
		( m_wszServerName == NULL && wszServer == NULL ) ||
		// Both are the same remote machine
		( m_wszServerName && wszServer && !lstrcmpi ( m_wszServerName, wszServer ) ) ) {

		// It's a match
		return TRUE;
	}

	// No dice...
	return FALSE;
}

//$-------------------------------------------------------------------
//
//	CMetabaseFactory::SetServerName
//
//	Description:
//
//		Sets the m_wszServerName string.
//
//	Parameters:
//
//		wszServer - The new servername.  Can be NULL.
//
//	Returns:
//
//		FALSE on failure due to lack of memory.
//
//--------------------------------------------------------------------

BOOL CMetabaseFactory::SetServerName ( LPCWSTR wszServer ) 
{
	TraceQuietEnter ( "CMetabaseFactory::SetServerName" );

	delete m_wszServerName;
	m_wszServerName = NULL;

	if ( wszServer != NULL ) {
		_ASSERT ( IS_VALID_STRING ( wszServer ) );

		m_wszServerName = new WCHAR [ lstrlen ( wszServer ) + 1 ];

		if ( m_wszServerName == NULL ) {
			FatalTrace ( (LPARAM) this, "Out of Memory" );
			return FALSE;
		}

		lstrcpy ( m_wszServerName, wszServer );
	}
	
	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\nntp\adminsso\nntpcmn.h ===
// Common header file for the Nntp administration objects.

//
// Dependencies:
//

//
// Should put these files in the stdafx.h
//

#include "iadm.h"
#include "nntpadm.h"
#include "resource.h"

// Constants:

#define HELP_FILE_NAME		_T("nntpadm.hlp")

// Exception creation:

#define NntpCreateException(nDescriptionId) 	\
	CreateException ( 						\
		_Module.GetResourceInstance(), 		\
		THIS_FILE_IID, 						\
		HELP_FILE_NAME,						\
		THIS_FILE_HELP_CONTEXT,				\
		THIS_FILE_PROG_ID,					\
		(nDescriptionId) 					\
		)

#define NntpCreateExceptionFromHresult(hr)	\
	CreateExceptionFromHresult (			\
		_Module.GetResourceInstance(),		\
		THIS_FILE_IID,						\
		HELP_FILE_NAME,						\
		THIS_FILE_HELP_CONTEXT,				\
		THIS_FILE_PROG_ID,					\
		(hr)								\
		)

#define NntpCreateExceptionFromWin32Error(error)	\
	CreateExceptionFromWin32Error (					\
		_Module.GetResourceInstance(),				\
		THIS_FILE_IID,								\
		HELP_FILE_NAME,								\
		THIS_FILE_HELP_CONTEXT,						\
		THIS_FILE_PROG_ID,							\
		(error)										\
		)

// Property validation:

#define VALIDATE_STRING(string, maxlen) \
	if ( !PV_MaxChars ( (string), (maxlen) ) ) {	\
		return NntpCreateException ( IDS_NNTPEXCEPTION_STRING_TOO_LONG );	\
	}

#define VALIDATE_DWORD(dw, dwMin, dwMax)	\
	if ( !PV_MinMax ( (DWORD) (dw), (DWORD) (dwMin), (DWORD) (dwMax) ) ) {	\
		return NntpCreateException ( IDS_NNTPEXCEPTION_PROPERTY_OUT_OF_RANGE );	\
	}

#define VALIDATE_LONG(l, lMin, lMax)	\
	if ( !PV_MinMax ( (l), (lMin), (lMax) ) ) {	\
		return NntpCreateException ( IDS_NNTPEXCEPTION_PROPERTY_OUT_OF_RANGE );	\
	}

#define CHECK_FOR_SET_CURSOR(fEnumerated,fSetCursor)	\
{							\
	if ( !fEnumerated ) {	\
		return NntpCreateException ( IDS_NNTPEXCEPTION_DIDNT_ENUMERATE );	\
	}						\
							\
	if ( !fSetCursor ) {	\
		return NntpCreateException ( IDS_NNTPEXCEPTION_DIDNT_SET_CURSOR );	\
	}						\
}

// Metabase paths:

inline void GetMDInstancePath ( LPWSTR wszInstancePath, DWORD dwServiceInstance )
{
	wsprintf ( wszInstancePath, _T("%s%d/"), NNTP_MD_ROOT_PATH, dwServiceInstance );
}

//
//  Constants:
//

#define MAX_SLEEP_INST      30000
#define SLEEP_INTERVAL      500

#define MD_SERVICE_NAME      _T("NntpSvc")
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\nntp\adminsso\oleutil.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

	oleutil.h

Abstract:

	Defines some useful functions for dealing with OLE.

Author:

	Magnus Hedlund (MagnusH)		--

Revision History:

--*/

#ifndef _OLEUTIL_INCLUDED_
#define _OLEUTIL_INCLUDED_

// Dependencies:

class CMultiSz;

// Common Property Operations:

HRESULT StdPropertyGet			( const BSTR strProperty, BSTR * ppstrOut );
HRESULT StdPropertyGet			( long lProperty, long * plOut );
HRESULT StdPropertyGet			( DATE dateProperty, DATE * pdateOut );
inline HRESULT StdPropertyGet	( DWORD lProperty, DWORD * pdwOut );
inline HRESULT StdPropertyGet	( BOOL fProperty, BOOL * plOut );
HRESULT StdPropertyGet			( const CMultiSz * pmszProperty, SAFEARRAY ** ppsaStrings );
HRESULT	StdPropertyGetBit		( DWORD bvBitVector, DWORD dwBit, BOOL * pfOut );

HRESULT StdPropertyPut			( BSTR * pstrProperty, const BSTR strNew, DWORD * pbvChangedProps = NULL, DWORD dwBitMask = 0 );
HRESULT StdPropertyPut			( long * plProperty, long lNew, DWORD * pbvChangedProps = NULL, DWORD dwBitMask = 0 );
HRESULT StdPropertyPut			( DATE * pdateProperty, DATE dateNew, DWORD * pbvChangedProps = NULL, DWORD dwBitMask = 0 );
inline HRESULT StdPropertyPut	( DWORD * plProperty, long lNew, DWORD * pbvChangedProps = NULL, DWORD dwBitMask = 0 );
inline HRESULT StdPropertyPut	( BOOL * pfProperty, BOOL fNew, DWORD * pbvChangedProps = NULL, DWORD dwBitMask = 0 );
HRESULT StdPropertyPut			( CMultiSz * pmszProperty, SAFEARRAY * psaStrings, DWORD * pbvChangedProps = NULL, DWORD dwBitMask = 0 );
HRESULT	StdPropertyPutBit		( DWORD * pbvBitVector, DWORD dwBit, BOOL fIn );
inline HRESULT StdPropertyPutServerName	( BSTR * pstrProperty, const BSTR strNew, DWORD * pbvChangedProps = NULL, DWORD dwBitMask = 0 );

HRESULT LongArrayToVariantArray ( SAFEARRAY * psaLongs, SAFEARRAY ** ppsaVariants );
HRESULT StringArrayToVariantArray ( SAFEARRAY * psaStrings, SAFEARRAY ** ppsaVariants );
HRESULT VariantArrayToStringArray ( SAFEARRAY * psaVariants, SAFEARRAY ** ppsaStrings );

// Property Field Validation: (based on the mfc DDV_ routines)
// These routines return FALSE if the validation fails.

BOOL PV_MaxChars	( const BSTR strProperty,	DWORD nMaxChars );
BOOL PV_MinMax		( int nProperty,			int nMin,		int nMax );
BOOL PV_MinMax		( DWORD dwProperty,			DWORD dwMin,	DWORD dwMax );
BOOL PV_Boolean		( BOOL fProperty );

// Handing off IDispatch pointers:

template<class T> HRESULT StdPropertyHandoffIDispatch ( 
	REFCLSID clisd, 
	REFIID riid, 
	T ** ppIAdmin, 
	IDispatch ** ppIDispatchResult 
	);

HRESULT StdPropertyGetIDispatch ( REFCLSID clsid, IDispatch ** ppIDispatchResult );

// Internet addresses <-> Strings

BOOL InetAddressToString ( DWORD dwAddress, LPWSTR wszAddress, DWORD cAddress );
BOOL StringToInetAddress ( LPCWSTR wszAddress, DWORD * pdwAddress );

//--------------------------------------------------------------------
// Inlined functions:
//--------------------------------------------------------------------

inline HRESULT StdPropertyGet ( DWORD lProperty, DWORD * pdwOut )
{
	return StdPropertyGet ( (long) lProperty, (long *) pdwOut );
}

inline HRESULT StdPropertyGet ( BOOL fProperty, BOOL * plOut )
{
	// Make sure it's our kind of boolean:
	fProperty = !!fProperty;

	return StdPropertyGet ( (long) fProperty, (long *) plOut );
}

inline HRESULT StdPropertyPut ( DWORD * plProperty, long lNew, DWORD * pbvChangedProps, DWORD dwBitMask )
{
	return StdPropertyPut ( (long *) plProperty, lNew, pbvChangedProps, dwBitMask );
}

inline HRESULT StdPropertyPut ( BOOL * pfProperty, BOOL fNew, DWORD * pbvChangedProps, DWORD dwBitMask )
{
	// Make sure it's our kind of boolean:
	fNew = !!fNew;

	return StdPropertyPut ( (long *) pfProperty, (long) fNew, pbvChangedProps, dwBitMask );
}

inline HRESULT StdPropertyPutServerName ( BSTR * pstrProperty, const BSTR strNew, DWORD * pbvChangedProps, DWORD dwBitMask )
{
    if ( strNew && lstrcmpi ( strNew, _T("localhost") ) == 0 ) {
        // Special case: localhost => ""

        return StdPropertyPut ( pstrProperty, _T(""), pbvChangedProps, dwBitMask );
    }

    return StdPropertyPut ( pstrProperty, strNew, pbvChangedProps, dwBitMask );
}

template<class T>
HRESULT StdPropertyHandoffIDispatch ( REFCLSID clsid, REFIID riid, T ** ppIAdmin, IDispatch ** ppIDispatchResult )
{
	// Validate parameters:
	_ASSERT ( ppIAdmin != NULL );
	_ASSERT ( ppIDispatchResult != NULL );

	if ( ppIAdmin == NULL || ppIDispatchResult == NULL ) {
		return E_POINTER;
	}

	// Variables:
	HRESULT	hr = NOERROR;
	CComPtr<T>	pIAdmin;

	// Zero the out parameters:
	*ppIAdmin 			= NULL;
	*ppIDispatchResult	= NULL;

	// Get the IDispatch pointer to return:
	hr = StdPropertyGetIDispatch ( 
		clsid, 
		ppIDispatchResult
		);
	if ( FAILED (hr) ) {
		goto Error;
	}

	// Get the specific interface pointer:
	hr = (*ppIDispatchResult)->QueryInterface ( riid, (void **) &pIAdmin );
	if ( FAILED (hr) ) {
		goto Error;
	}

	*ppIAdmin = pIAdmin;
	pIAdmin.p->AddRef ();

	return hr;

Error:
	SAFE_RELEASE ( *ppIDispatchResult );
	*ppIDispatchResult = NULL;

	return hr;

	// Destructor releases pINntpAdminExpiration
}

#endif // _OLEUTIL_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\nntp\adminsso\rebuild.h ===
// Rebuild.h : Declaration of the CNntpAdminRebuild


/////////////////////////////////////////////////////////////////////////////
// nntpadm

class CNntpAdminRebuild : 
	public INntpAdminRebuild,
	public IPrivateUnknown,
	public IPrivateDispatch,
	public IADsExtension,
	public INonDelegatingUnknown,
	public ISupportErrorInfo,
	public CComObjectRoot,
	public CComCoClass<CNntpAdminRebuild,&CLSID_CNntpAdminRebuild>
{
public:
	CNntpAdminRebuild();
	virtual ~CNntpAdminRebuild ();
BEGIN_COM_MAP(CNntpAdminRebuild)
	COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(IADs)
	COM_INTERFACE_ENTRY(INntpAdminRebuild)
	COM_INTERFACE_ENTRY(IADsExtension)
	COM_INTERFACE_ENTRY(IPrivateUnknown)
	COM_INTERFACE_ENTRY(IPrivateDispatch)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()
//DECLARE_NOT_AGGREGATABLE(CNntpAdminRebuild) 
// Remove the comment from the line above if you don't want your object to 
// support aggregation.  The default is to support it

DECLARE_REGISTRY(CNntpAdminRebuild, _T("Nntpadm.Rebuild.1"), _T("Nntpadm.Rebuild"), IDS_NNTPADMINREBUILD_DESC, THREADFLAGS_BOTH)
// ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

	//
	// This declares methods for the following:
	// IADsExtension
	// IUnknown
	// IDispatch
	// IPrivateUnknown
	// IPrivateDispatch
	//
	#define THIS_LIBID	LIBID_NNTPADMLib
	#define THIS_IID	IID_INntpAdminRebuild
	#include "adsimp.inl"
	#undef	THIS_LIBID
	#undef	THIS_IID

// INntpAdminRebuild
public:

    //
    //  IADs methods:
    //

    DECLARE_IADS_METHODS()

	//////////////////////////////////////////////////////////////////////
	// Properties:
	//////////////////////////////////////////////////////////////////////

	// Which service to configure:

	STDMETHODIMP	get_Server			( BSTR * pstrServer );
	STDMETHODIMP	put_Server			( BSTR strServer );

	STDMETHODIMP	get_ServiceInstance	( long * plServiceInstance );
	STDMETHODIMP	put_ServiceInstance	( long lServiceInstance );

	STDMETHODIMP	get_Verbose	( BOOL * pfVerbose );
	STDMETHODIMP	put_Verbose	( BOOL fVerbose );

	STDMETHODIMP	get_CleanRebuild	( BOOL * pfCleanRebuild );
	STDMETHODIMP	put_CleanRebuild	( BOOL fCleanRebuild );

	STDMETHODIMP	get_DontDeleteHistory	( BOOL * pfDontDeleteHistory );
	STDMETHODIMP	put_DontDeleteHistory	( BOOL fDontDeleteHistory );

	STDMETHODIMP	get_ReuseIndexFiles	( BOOL * pfReuseIndexFiles );
	STDMETHODIMP	put_ReuseIndexFiles	( BOOL fReuseIndexFiles );

	STDMETHODIMP	get_OmitNonLeafDirs	( BOOL * pfOmitNonLeafDirs );
	STDMETHODIMP	put_OmitNonLeafDirs	( BOOL fOmitNonLeafDirs );

	STDMETHODIMP	get_GroupFile	( BSTR * pstrGroupFile );
	STDMETHODIMP	put_GroupFile	( BSTR strGroupFile );

	STDMETHODIMP	get_ReportFile	( BSTR * pstrReportFile );
	STDMETHODIMP	put_ReportFile	( BSTR strReportFile );

	STDMETHODIMP	get_NumThreads	( long * plNumThreads );
	STDMETHODIMP	put_NumThreads	( long lNumThreads );

	//////////////////////////////////////////////////////////////////////
	// Methods:
	//////////////////////////////////////////////////////////////////////

    STDMETHODIMP    Default         ( );
	STDMETHODIMP	StartRebuild	( );
	STDMETHODIMP	GetProgress		( long * pdwProgress );
	STDMETHODIMP	Cancel			( );

	//////////////////////////////////////////////////////////////////////
	// Data:
	//////////////////////////////////////////////////////////////////////
private:

	// Property variables:
    CIADsImpl   m_iadsImpl;

	BOOL		m_fVerbose;
	BOOL		m_fCleanRebuild;
	BOOL		m_fDontDeleteHistory;
	BOOL		m_fReuseIndexFiles;
	BOOL		m_fOmitNonLeafDirs;
	CComBSTR	m_strGroupFile;
	CComBSTR	m_strReportFile;
	DWORD		m_dwNumThreads;

	//
	//	Status variables:
	//

	BOOL		m_fRebuildInProgress;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\nntp\adminsso\nntpadm.cpp ===
// nntpadm.cpp : Implementation of DLL Exports.

// You will need the NT SUR Beta 2 SDK or VC 4.2 in order to build this 
// project.  This is because you will need MIDL 3.00.15 or higher and new
// headers and libs.  If you have VC 4.2 installed, then everything should
// already be configured correctly.

// Note: Proxy/Stub Information
//		To build a separate proxy/stub DLL, 
//		run nmake -f nntpadmps.mak in the project directory.

#include "stdafx.h"
#include "nntpcmn.h"

#include "admin.h"
#include "expire.h"
#include "feeds.h"
#include "groups.h"
#include "rebuild.h"
#include "sessions.h"
#include "server.h"
#include "vroots.h"

/*
#include "propcach.h"
#include "service.h"
#include "virsrv.h"
*/

#include "regmacro.h"

CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
	OBJECT_ENTRY(CLSID_CNntpAdmin, CNntpAdmin)
	OBJECT_ENTRY(CLSID_CNntpVirtualServer, CNntpVirtualServer)
	OBJECT_ENTRY(CLSID_CNntpAdminFeeds, CNntpAdminFeeds)
	OBJECT_ENTRY(CLSID_CNntpAdminExpiration, CNntpAdminExpiration)
	OBJECT_ENTRY(CLSID_CNntpAdminGroups, CNntpAdminGroups)
	OBJECT_ENTRY(CLSID_CNntpAdminSessions, CNntpAdminSessions)
	OBJECT_ENTRY(CLSID_CNntpAdminRebuild, CNntpAdminRebuild)
	OBJECT_ENTRY(CLSID_CNntpVirtualRoot, CNntpVirtualRoot)
	OBJECT_ENTRY(CLSID_CNntpFeed, CNntpFeed)
	OBJECT_ENTRY(CLSID_CNntpOneWayFeed, CNntpOneWayFeed)
//	OBJECT_ENTRY(CLSID_CNntpService, CNntpAdminService)
//	OBJECT_ENTRY(CLSID_CAdsNntpVirtualServer, CAdsNntpVirtualServer)
END_OBJECT_MAP()

BEGIN_EXTENSION_REGISTRATION_MAP
	EXTENSION_REGISTRATION_MAP_ENTRY(IIsNntpExpires, NntpAdminExpiration)
	EXTENSION_REGISTRATION_MAP_ENTRY(IIsNntpFeeds, NntpAdminFeeds)
	EXTENSION_REGISTRATION_MAP_ENTRY(IIsNntpGroups, NntpAdminGroups)
	EXTENSION_REGISTRATION_MAP_ENTRY(IIsNntpRebuild, NntpAdminRebuild)
	EXTENSION_REGISTRATION_MAP_ENTRY(IIsNntpSessions, NntpAdminSessions)
END_EXTENSION_REGISTRATION_MAP

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
	if (dwReason == DLL_PROCESS_ATTACH)
	{
//		InitAsyncTrace ();
		
		_Module.Init(ObjectMap, hInstance);
		DisableThreadLibraryCalls(hInstance);
	}
	else if (dwReason == DLL_PROCESS_DETACH) {
//		TermAsyncTrace ();
		
		_Module.Term();
	}
	return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
	return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
	return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
	// register extensions
	RegisterExtensions();

	// registers object, typelib and all interfaces in typelib
	return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
	// register extensions
	UnregisterExtensions();

	_Module.UnregisterServer();
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\nntp\adminsso\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by nntpadm.rc
//
#define IDS_NNTPADMIN_DESC				1
#define IDS_NNTPADMINSERVER_DESC		2
#define IDS_NNTPADMINSERVICE_DESC		3
#define IDS_NNTPADMINFEEDS_DESC			4
#define IDS_NNTPADMINEXPIRATION_DESC	5
#define IDS_NNTPADMINGROUPS_DESC		6
#define IDS_NNTPADMINSESSIONS_DESC		7
#define IDS_NNTPADMINREBUILD_DESC		8
#define IDS_NNTPVIRTUALROOT_DESC		9
#define IDS_NNTPFEED_DESC		        10
#define IDS_NNTPONEWAYFEED_DESC		    11
#define IDS_TCPACCESS_DESC              12
#define IDS_TCPACCESSEXCEPTIONS_DESC    13
#define IDS_TCPACCESSEXCEPTION_DESC     14

// Exceptions:

#define IDS_NNTPEXCEPTION_DIDNT_ENUMERATE						200
#define IDS_NNTPEXCEPTION_DIDNT_SET_CURSOR						201
#define IDS_NNTPEXCEPTION_INVALID_INDEX							202
#define IDS_NNTPEXCEPTION_MUST_SUPPLY_USERNAME_OR_IPADDRESS		203
#define IDS_NNTPEXCEPTION_SERVICE_INSTANCE_CANT_BE_ZERO			204
#define IDS_NNTPEXCEPTION_DIDNT_CALL_GET						205
#define IDS_NNTPEXCEPTION_STRING_TOO_LONG						206
#define IDS_NNTPEXCEPTION_PROPERTY_OUT_OF_RANGE					207
#define IDS_NNTPEXCEPTION_DIDNT_FIND							208
#define IDS_NNTPEXCEPTION_ALREADY_BUILDING						209
#define IDS_NNTPEXCEPTION_CANT_DELETE_DEFAULT_INSTANCE			210
#define IDS_NNTPEXCEPTION_VROOT_ALREADY_EXISTS                  211

#define IDS_FEED_PARM_ERR_BASE			300
#define IDS_FEED_PARM_FEEDTYPE			(IDS_FEED_PARM_ERR_BASE + 0)
#define IDS_FEED_PARM_STARTTIME			(IDS_FEED_PARM_ERR_BASE + 1)
#define IDS_FEED_PARM_FEEDID			(IDS_FEED_PARM_ERR_BASE + 2)
#define IDS_FEED_PARM_FEEDINTERVAL		(IDS_FEED_PARM_ERR_BASE + 3)
#define IDS_FEED_PARM_NEWSGROUPS		(IDS_FEED_PARM_ERR_BASE + 4)
#define IDS_FEED_PARM_DISTRIBUTION		(IDS_FEED_PARM_ERR_BASE + 5)
#define IDS_FEED_PARM_SERVERNAME		(IDS_FEED_PARM_ERR_BASE + 6)
#define IDS_FEED_PARM_AUTOCREATE		(IDS_FEED_PARM_ERR_BASE + 7)
#define IDS_FEED_PARM_ENABLED			(IDS_FEED_PARM_ERR_BASE + 8)
#define IDS_FEED_PARM_UUCPNAME			(IDS_FEED_PARM_ERR_BASE + 9)
#define IDS_FEED_PARM_TEMPDIR			(IDS_FEED_PARM_ERR_BASE + 10)
#define IDS_FEED_PARM_MAXCONNECT		(IDS_FEED_PARM_ERR_BASE + 11)
#define IDS_FEED_PARM_SESSIONSECURITY	(IDS_FEED_PARM_ERR_BASE + 12)
#define IDS_FEED_PARM_AUTHTYPE			(IDS_FEED_PARM_ERR_BASE + 13)
#define IDS_FEED_PARM_ACCOUNTNAME		(IDS_FEED_PARM_ERR_BASE + 14)
#define IDS_FEED_PARM_PASSWORD			(IDS_FEED_PARM_ERR_BASE + 15)
#define IDS_FEED_PARM_CONCURRENTSESSION	(IDS_FEED_PARM_ERR_BASE + 16)
#define IDS_FEED_PARM_ALLOW_CONTROL		(IDS_FEED_PARM_ERR_BASE + 17)
#define IDS_FEED_PARM_OUTGOING_PORT		(IDS_FEED_PARM_ERR_BASE + 18)
#define IDS_FEED_PARM_FEEDPAIR_ID		(IDS_FEED_PARM_ERR_BASE + 19)

#define IDS_UNKNOWN_ERROR                                       500

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\nntp\adminsso\oleutil.cpp ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

	oleutil.cpp

Abstract:

	Provides Useful functions for dealing with OLE.

Author:

	Magnus Hedlund (MagnusH)		--

Revision History:

--*/

#include "stdafx.h"
#include "iadm.h"
#include "oleutil.h"
#include "cmultisz.h"
#include "resource.h"

//$-------------------------------------------------------------------
//
//	UpdateChangedMask
//
//	Description:
//
//		Marks a field as changed in the given bit vector
//
//	Parameters:
//
//		pbvChangedProps - points to the bit vector
//		dwBitMask - Bit to turn on. (must have only one bit on)
//
//--------------------------------------------------------------------

static void UpdateChangedMask ( DWORD * pbvChangedProps, DWORD dwBitMask )
{
	if ( pbvChangedProps == NULL ) {
		// Legal, means that the caller doesn't want change tracking.

		return;
	}

	_ASSERT ( dwBitMask != 0 );

	*pbvChangedProps |= dwBitMask;
}

HRESULT LongArrayToVariantArray ( SAFEARRAY * psaLongs, SAFEARRAY ** ppsaVariants )
{
	_ASSERT ( psaLongs );

	HRESULT		hr	= NOERROR;
	long		lLBound	= 0;
	long		lUBound	= 0;
	long		i;
	SAFEARRAYBOUND	bounds;
	SAFEARRAY *	psaVariants;

	*ppsaVariants = NULL;

	_ASSERT ( SafeArrayGetDim ( psaLongs ) == 1 );

	SafeArrayGetLBound ( psaLongs, 1, &lLBound );
	SafeArrayGetUBound ( psaLongs, 1, &lUBound );

	bounds.lLbound = lLBound;
	bounds.cElements = lUBound - lLBound + 1;

	psaVariants = SafeArrayCreate ( VT_VARIANT, 1, &bounds );

	for ( i = lLBound; i <= lUBound; i++ ) {
		VARIANT		var;
		long		lTemp;

		VariantInit ( &var );

		hr = SafeArrayGetElement ( psaLongs, &i, &lTemp );
		if ( FAILED(hr) ) {
			goto Exit;
		}

		V_VT (&var) = VT_I4;
		V_I4 (&var) = lTemp;

		hr = SafeArrayPutElement ( psaVariants, &i, &var );
		if ( FAILED(hr) ) {
			goto Exit;
		}

		VariantClear ( &var );
	}

	*ppsaVariants	= psaVariants;
Exit:
	return hr;
}

HRESULT StringArrayToVariantArray ( SAFEARRAY * psaStrings, SAFEARRAY ** ppsaVariants )
{
	_ASSERT ( psaStrings );

	HRESULT		hr	= NOERROR;
	long		lLBound	= 0;
	long		lUBound	= 0;
	long		i;
	SAFEARRAYBOUND	bounds;
	SAFEARRAY *	psaVariants;

	*ppsaVariants = NULL;

	_ASSERT ( SafeArrayGetDim ( psaStrings ) == 1 );

	SafeArrayGetLBound ( psaStrings, 1, &lLBound );
	SafeArrayGetUBound ( psaStrings, 1, &lUBound );

	bounds.lLbound = lLBound;
	bounds.cElements = lUBound - lLBound + 1;

	psaVariants = SafeArrayCreate ( VT_VARIANT, 1, &bounds );

	for ( i = lLBound; i <= lUBound; i++ ) {
		VARIANT		var;
		CComBSTR	strTemp;

		VariantInit ( &var );

		hr = SafeArrayGetElement ( psaStrings, &i, &strTemp );
		if ( FAILED(hr) ) {
			goto Exit;
		}

		V_VT (&var) = VT_BSTR;
		V_BSTR (&var) = ::SysAllocString ( strTemp );

		hr = SafeArrayPutElement ( psaVariants, &i, &var );
		if ( FAILED(hr) ) {
			goto Exit;
		}

		VariantClear ( &var );
	}

	*ppsaVariants	= psaVariants;
Exit:
	return hr;
}

HRESULT VariantArrayToStringArray ( SAFEARRAY * psaVariants, SAFEARRAY ** ppsaStrings )
{
	_ASSERT ( psaVariants );

	HRESULT		hr	= NOERROR;
	long		lLBound	= 0;
	long		lUBound	= 0;
	long		i;
	SAFEARRAYBOUND	bounds;
	SAFEARRAY *	psaStrings;

	_ASSERT ( SafeArrayGetDim ( psaVariants ) == 1 );
	
	*ppsaStrings = NULL;

	SafeArrayGetLBound ( psaVariants, 1, &lLBound );
	SafeArrayGetUBound ( psaVariants, 1, &lUBound );

	bounds.lLbound = lLBound;
	bounds.cElements = lUBound - lLBound + 1;

	psaStrings = SafeArrayCreate ( VT_BSTR, 1, &bounds );

	for ( i = lLBound; i <= lUBound; i++ ) {
		VARIANT		var;
		CComBSTR	strTemp;

		VariantInit ( &var );

		hr = SafeArrayGetElement ( psaVariants, &i, &var );
		if ( FAILED(hr) ) {
			goto Exit;
		}

		strTemp = V_BSTR (&var);

		hr = SafeArrayPutElement ( psaStrings, &i, strTemp );
		if ( FAILED(hr) ) {
			goto Exit;
		}

		VariantClear (&var);
	}

	*ppsaStrings = psaStrings;
Exit:
	return hr;
}

//$-------------------------------------------------------------------
//
//	StdPropertyGet < BSTR, long, DWORD, DATE >
//
//	Description:
//
//		Performs a default Property Get on a BSTR, long, DWORD or 
//		Ole DATE.
//
//	Parameters:
//
//		Property	- The property to get.
//		pOut		- The resulting copy.
//
//	Returns:
//
//		E_POINTER		- invalid arguments
//		E_OUTOFMEMORY	- Not enough memory to copy
//		NOERROR			- success.
//
//--------------------------------------------------------------------

HRESULT StdPropertyGet ( const BSTR strProperty, BSTR * pstrOut )
{
	TraceQuietEnter ( "StdPropertyGet <BSTR>" );

	_ASSERT ( pstrOut != NULL );
	_ASSERT ( IS_VALID_OUT_PARAM ( pstrOut ) );

	if ( pstrOut == NULL ) {
		FatalTrace ( 0, "Bad return pointer" );
		return E_POINTER;
	}

	*pstrOut = NULL;

	if ( strProperty == NULL ) {

		// If the property is NULL, use a blank string:
		*pstrOut = ::SysAllocString ( _T("") );
	}
	else {
		_ASSERT ( IS_VALID_STRING ( strProperty ) );

		// Copy the property into the result:
		*pstrOut = ::SysAllocString ( strProperty );
	}

	if ( *pstrOut == NULL ) {

		// Allocation failed.
		FatalTrace ( 0, "Out of memory" );

		return E_OUTOFMEMORY;
	}

	return NOERROR;
}

HRESULT StdPropertyGet ( long lProperty, long * plOut )
{
	TraceQuietEnter ( "StdPropertyGet <long>" );

	_ASSERT ( plOut != NULL );
	_ASSERT ( IS_VALID_OUT_PARAM ( plOut ) );

	if ( plOut == NULL ) {
		FatalTrace ( 0, "Bad return pointer" );

		return E_POINTER;
	}

	*plOut = lProperty;
	return NOERROR;
}

HRESULT StdPropertyGet ( DATE dateProperty, DATE * pdateOut )
{
	TraceQuietEnter ( "StdPropertyGet <DATE>" );

	_ASSERT ( pdateOut != NULL );
	_ASSERT ( IS_VALID_OUT_PARAM ( pdateOut ) );

	if ( pdateOut == NULL ) {
		FatalTrace ( 0, "Bad return pointer" );

		return E_POINTER;
	}
	
	*pdateOut = dateProperty;
	return NOERROR;
}

HRESULT StdPropertyGet ( const CMultiSz * pmszProperty, SAFEARRAY ** ppsaStrings )
{
	TraceFunctEnter ( "StdPropertyGet <MULTI_SZ>" );

	_ASSERT ( pmszProperty );
	_ASSERT ( IS_VALID_OUT_PARAM ( ppsaStrings ) );

	HRESULT		hr	= NOERROR;

	*ppsaStrings = pmszProperty->ToSafeArray ( );

	if ( *ppsaStrings == NULL ) {
		hr = E_OUTOFMEMORY;
		goto Exit;
	}

Exit:
	TraceFunctLeave ();
	return hr;
}

HRESULT	StdPropertyGetBit ( DWORD bvBitVector, DWORD dwBit, BOOL * pfOut )
{
	_ASSERT ( IS_VALID_OUT_PARAM ( pfOut ) );

	if ( !pfOut ) {
		return E_POINTER;
	}

	*pfOut	= GetBitFlag ( bvBitVector, dwBit );

	return NOERROR;
}

//$-------------------------------------------------------------------
//
//	StdPropertyPut <BSTR, long, DWORD or DATE>
//
//	Description:
//
//		Performs a default Property Put on a BSTR, long, DWORD or
//		Ole date.
//
//	Parameters:
//
//		pProperty	- The property to put.
//		New			- The new value.
//		pbvChangedProps [optional] - Bit Vector which holds which
//				properties have changed.
//		dwBitMask [optional] - This property's bitmask for the 
//				changed bit vector.
//
//	Returns:
//
//		E_POINTER - invalid arguments
//		E_OUTOFMEMORY - Not enough memory to copy
//		NOERROR - success.
//
//--------------------------------------------------------------------

HRESULT StdPropertyPut ( 
	BSTR * pstrProperty, 
	const BSTR strNew, 
	DWORD * pbvChangedProps, // = NULL 
	DWORD dwBitMask // = 0 
	)
{
	TraceQuietEnter ( "StdPropertyPut <BSTR>" );

	// Validate Parameters:
	_ASSERT ( pstrProperty != NULL );
	_ASSERT ( IS_VALID_OUT_PARAM ( pstrProperty ) );

	_ASSERT ( strNew != NULL );
	_ASSERT ( IS_VALID_STRING ( strNew ) );

	if ( pstrProperty == NULL ) {
		FatalTrace ( 0, "Bad property pointer" );
		return E_POINTER;
	}

	if ( strNew == NULL ) {
		FatalTrace ( 0, "Bad pointer" );
		return E_POINTER;
	}

	HRESULT	hr	= NOERROR;
	BSTR	strCopy = NULL;

	// Copy the new string:
	strCopy = ::SysAllocString ( strNew );

	if ( strCopy == NULL ) {
		hr = E_OUTOFMEMORY;

		FatalTrace ( 0, "Out of memory" );
		goto Error;
	}

	// Update the changed bit, if necessary:
	if ( *pstrProperty && lstrcmp ( *pstrProperty, strCopy ) != 0 ) {
		UpdateChangedMask ( pbvChangedProps, dwBitMask );
	}

	// Replace the old property with the new one.
	SAFE_FREE_BSTR ( *pstrProperty );

	*pstrProperty = strCopy;

Error:
	return hr;
}

HRESULT StdPropertyPut ( 
	long * plProperty, 
	long lNew, 
	DWORD * pbvChangedProps, // = NULL 
	DWORD dwBitMask // = 0
	)
{
	TraceQuietEnter ( "StdPropertyPut <long>" );

	_ASSERT ( plProperty != NULL );
	_ASSERT ( IS_VALID_OUT_PARAM ( plProperty ) );

	if ( plProperty == NULL ) {
		FatalTrace ( 0, "Bad pointer" );
		return E_POINTER;
	}

	if ( *plProperty != lNew ) {
		UpdateChangedMask ( pbvChangedProps, dwBitMask );
	}

	*plProperty = lNew;
	return NOERROR;
}

HRESULT StdPropertyPut ( 
	DATE * pdateProperty, 
	DATE dateNew, 
	DWORD * pbvChangedProps, // = NULL
	DWORD dwBitMask // = 0
	)
{
	TraceQuietEnter ( "StdPropertyPut <DATE>" );

	_ASSERT ( pdateProperty != NULL );
	_ASSERT ( IS_VALID_OUT_PARAM ( pdateProperty ) );

	if ( pdateProperty == NULL ) {
		FatalTrace ( 0, "Bad pointer" );
		return E_POINTER;
	}

	if ( *pdateProperty != dateNew ) {
		UpdateChangedMask ( pbvChangedProps, dwBitMask );
	}

	*pdateProperty = dateNew;
	return NOERROR;
}

HRESULT StdPropertyPut ( CMultiSz * pmszProperty, SAFEARRAY * psaStrings, DWORD * pbvChangedProps, DWORD dwBitMask )
{
	TraceFunctEnter ( "StdPropertyPut <MULTI_SZ>" );

	_ASSERT ( IS_VALID_IN_PARAM ( psaStrings ) );
	_ASSERT ( IS_VALID_OUT_PARAM ( pmszProperty ) );

	if ( psaStrings == NULL ) {
		FatalTrace ( 0, "Bad return pointer" );

		TraceFunctLeave ();
		return E_POINTER;
	}

	HRESULT		hr	= NOERROR;

	pmszProperty->FromSafeArray ( psaStrings );

	if ( !*pmszProperty ) {
		hr = E_OUTOFMEMORY;
		goto Exit;
	}

	// Don't want to deal with comparing these properties:
	UpdateChangedMask ( pbvChangedProps, dwBitMask );

Exit:
	TraceFunctLeave ();
	return hr;
}

HRESULT	StdPropertyPutBit ( DWORD * pbvBitVector, DWORD dwBit, BOOL fIn )
{
	_ASSERT ( IS_VALID_OUT_PARAM ( pbvBitVector ) );
	_ASSERT ( dwBit );

	SetBitFlag ( pbvBitVector, dwBit, fIn );

	return NOERROR;
}

//$-------------------------------------------------------------------
//
//	PV_MaxChars
//
//	Description:
//
//		Validates a string to make sure it's not too long.
//
//	Parameters:
//
//		strProperty - the string to check
//		nMaxChars - the maximum number of characters in the string,
//			not including the NULL terminator.
//
//	Returns:
//
//		FALSE if the string is too long.
//
//--------------------------------------------------------------------

BOOL PV_MaxChars ( const BSTR strProperty, DWORD nMaxChars )
{
	TraceQuietEnter ( "PV_MaxChars" );

	_ASSERT ( strProperty != NULL );
	_ASSERT ( IS_VALID_STRING ( strProperty ) );

	_ASSERT ( nMaxChars > 0 );

	if ( strProperty == NULL ) {
		// This error should be caught somewhere else.
		return TRUE;
	}

	if ( (DWORD) lstrlen ( strProperty ) > nMaxChars ) {
		ErrorTrace ( 0, "String too long" );
		return FALSE;
	}

	return TRUE;
}

//$-------------------------------------------------------------------
//
//	PV_MinMax <int, dword>
//
//	Description:
//
//		Makes sure a property is within a given range.
//
//	Parameters:
//
//		nProperty - the value to test
//		nMin - The minimum value the property could have
//		nMax - The maximum value the property could have
//
//	Returns:
//
//		TRUE if the property is in the range (inclusive).
//
//--------------------------------------------------------------------

BOOL PV_MinMax ( int nProperty, int nMin, int nMax )
{
	TraceQuietEnter ( "PV_MinMax" );

	_ASSERT ( nMin <= nMax );

	if ( nProperty < nMin || nProperty > nMax ) {
		ErrorTrace ( 0, "Integer out of range" );
		return FALSE;
	}
	return TRUE;
}

BOOL PV_MinMax ( DWORD dwProperty, DWORD dwMin, DWORD dwMax )
{
	TraceQuietEnter ( "PV_MinMax" );

	_ASSERT ( dwMin <= dwMax );

	if ( dwProperty < dwMin || dwProperty > dwMax ) {

		ErrorTrace ( 0, "Dword out of range" );
		return FALSE;
	}
	return TRUE;
}

BOOL PV_Boolean		( BOOL fProperty )
{
	TraceQuietEnter ( "PV_Boolean" );

	if ( fProperty != TRUE && fProperty != FALSE ) {

		ErrorTrace ( 0, "Boolean property is not true or false" );
		return FALSE;
	}

	return TRUE;
}

//$-------------------------------------------------------------------
//
//	StdPropertyGetIDispatch
//
//	Description:
//
//		Gets a IDispatch pointer for the given cLSID
//
//	Parameters:
//
//		clsid		- OLE CLSID of the object
//		ppIDipsatch	- the IDispatch pointer to that object.
//
//	Returns:
//
//		E_POINTER	- invalid argument
//		NOERROR		- Success
//		Others - defined by CoCreateInstance.
//
//--------------------------------------------------------------------

HRESULT StdPropertyGetIDispatch ( 
	REFCLSID clsid, 
	IDispatch ** ppIDispatch 
	)
{
	TraceFunctEnter ( "StdPropertyGetIDispatch" );

	CComPtr<IDispatch>	pNewIDispatch;
	HRESULT				hr = NOERROR;

	_ASSERT ( ppIDispatch );

	if ( ppIDispatch == NULL ) {
		FatalTrace ( 0, "Bad return pointer" );
		TraceFunctLeave ();
		return E_POINTER;
	}

	*ppIDispatch = NULL;

	hr = ::CoCreateInstance ( 
		clsid,
		NULL, 
		CLSCTX_ALL, 
		IID_IDispatch,
		(void **) &pNewIDispatch
		);

	if ( FAILED (hr) ) {
		DebugTraceX ( 0, "CoCreate(IDispatch) failed %x", hr );
		FatalTrace ( 0, "Failed to create IDispatch" );
		goto Exit;
	}

	*ppIDispatch = pNewIDispatch;
	pNewIDispatch.p->AddRef ();

Exit:
	TraceFunctLeave ();
	return hr;

	// Destructor releases pNewIDispatch
}

//$-------------------------------------------------------------------
//
//	InetAddressToString
//
//	Description:
//
//		Converts a DWORD with an ip address to a string in the form
//		"xxx.xxx.xxx.xxx"
//
//	Parameters:
//
//		dwAddress	- The address to convert
//		wszAddress	- The resulting string
//		cAddress	- The maximum size of the resulting string
//
//	Returns:
//
//		TRUE if succeeded, FALSE otherwise.
//
//--------------------------------------------------------------------

BOOL InetAddressToString ( DWORD dwAddress, LPWSTR wszAddress, DWORD cAddress )
{
	TraceFunctEnter ( "InetAddressToString" );

	_ASSERT ( wszAddress );

	if ( wszAddress == NULL ) {
		FatalTrace ( 0, "Bad pointer" );
		TraceFunctLeave ();
		return FALSE;
	}

	struct in_addr	addr;
	LPSTR			szAnsiAddress;
	DWORD			cchCopied;

	addr.s_addr = dwAddress;

	szAnsiAddress = inet_ntoa ( addr );

	if ( szAnsiAddress == NULL ) {
		ErrorTraceX ( 0, "inet_ntoa failed: %x", GetLastError() );
		TraceFunctLeave ();
		return FALSE;
	}

	cchCopied = MultiByteToWideChar ( 
		CP_ACP, 
		MB_PRECOMPOSED,
		szAnsiAddress,
		-1,
		wszAddress,
		cAddress
		);

	if ( cchCopied == 0 ) {
		ErrorTraceX ( 0, "MultiByteToWideChar failed: %x", GetLastError() );
		TraceFunctLeave ();
		return FALSE;
	}

	TraceFunctLeave ();
	return TRUE;
}

//$-------------------------------------------------------------------
//
//	StringToInetAddress
//
//	Description:
//
//		Converts a string in the form "xxx.xxx.xxx.xxx" to a DWORD
//		IP Address.
//
//	Parameters:
//
//		wszAddress	- The string to convert
//		pdwAddress	- The resulting address
//
//	Returns:
//
//		TRUE if succeeded, FALSE otherwise.
//
//--------------------------------------------------------------------

BOOL StringToInetAddress ( LPCWSTR wszAddress, DWORD * pdwAddress )
{
	TraceFunctEnter ( "StringToInetAddress" );

	_ASSERT ( wszAddress );
	_ASSERT ( pdwAddress );

	if ( wszAddress == NULL ) {
		FatalTrace ( 0, "Bad pointer" );
		TraceFunctLeave ();
		return FALSE;
	}

	if ( pdwAddress == NULL ) {
		FatalTrace ( 0, "Bad return pointer" );
		TraceFunctLeave ();
		return FALSE;
	}

	char	szAnsiAddress[100];
	DWORD	cchCopied;

	*pdwAddress = 0;

	cchCopied = WideCharToMultiByte ( 
		CP_ACP, 
		0, 
		wszAddress, 
		-1, 
		szAnsiAddress, 
		sizeof ( szAnsiAddress ),
		NULL,
		NULL
		);

	if ( cchCopied == 0 ) {
		ErrorTraceX ( 0, "MultiByteToWideChar failed: %x", GetLastError() );
		TraceFunctLeave ();
		return FALSE;
	}

	*pdwAddress = inet_addr ( szAnsiAddress );

	if ( !*pdwAddress ) {
		ErrorTraceX ( 0, "inet_addr failed: %x", GetLastError () );
	}

	TraceFunctLeave ();
	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\nntp\adminsso\rebuild.cpp ===
// Rebuild.cpp : Implementation of CNntpAdminRebuild.

#include "stdafx.h"
#include "nntpcmn.h"
#include "oleutil.h"
#include "Rebuild.h"

#include "nntptype.h"
#include "nntpapi.h"

#include <lmapibuf.h>

//
//  Defaults:
//

#define DEFAULT_VERBOSE                 ( FALSE )
#define DEFAULT_CLEAN_REBUILD           ( TRUE )
#define DEFAULT_DONT_DELETE_HISTORY     ( FALSE )
#define DEFAULT_REUSE_INDEX_FILES       ( TRUE )
#define DEFAULT_OMIT_NON_LEAF_DIRS      ( TRUE )
#define DEFAULT_GROUP_FILE              ( NULL )
#define DEFAULT_REPORT_FILE             ( _T("nntpbld.log") )
#define DEFAULT_NUM_THREADS             ( 0 )

// Must define THIS_FILE_* macros to use NntpCreateException()

#define THIS_FILE_HELP_CONTEXT		0
#define THIS_FILE_PROG_ID			_T("Nntpadm.Rebuild.1")
#define THIS_FILE_IID				IID_INntpAdminRebuild

/////////////////////////////////////////////////////////////////////////////
//

//
// Use a macro to define all the default methods
//
DECLARE_METHOD_IMPLEMENTATION_FOR_STANDARD_EXTENSION_INTERFACES(NntpAdminRebuild, CNntpAdminRebuild, IID_INntpAdminRebuild)

STDMETHODIMP CNntpAdminRebuild::InterfaceSupportsErrorInfo(REFIID riid)
{
	static const IID* arr[] = 
	{
		&IID_INntpAdminRebuild,
	};

	for (int i=0;i<sizeof(arr)/sizeof(arr[0]);i++)
	{
		if (InlineIsEqualGUID(*arr[i],riid))
			return S_OK;
	}
	return S_FALSE;
}

CNntpAdminRebuild::CNntpAdminRebuild () :
	m_fVerbose				( FALSE ),
	m_fCleanRebuild			( FALSE ),
	m_fDontDeleteHistory	( FALSE ),
	m_fReuseIndexFiles		( FALSE ),
	m_fOmitNonLeafDirs		( FALSE ),
	m_dwNumThreads			( 0 ),

	m_fRebuildInProgress	( FALSE )

	// CComBSTR's are initialized to NULL by default.
{
	InitAsyncTrace ( );

    m_iadsImpl.SetService ( MD_SERVICE_NAME );
    m_iadsImpl.SetName ( _T("Rebuild") );
    m_iadsImpl.SetClass ( _T("IIsNntpRebuild") );
}

CNntpAdminRebuild::~CNntpAdminRebuild ()
{
	// All CComBSTR's are freed automatically.
	TermAsyncTrace ( );
}

//
//  IADs methods:
//

DECLARE_SIMPLE_IADS_IMPLEMENTATION(CNntpAdminRebuild,m_iadsImpl)

//
//	Properties:
//

STDMETHODIMP CNntpAdminRebuild::get_Verbose ( BOOL * pfVerbose )
{
	return StdPropertyGet ( m_fVerbose, pfVerbose );
}

STDMETHODIMP CNntpAdminRebuild::put_Verbose ( BOOL fVerbose )
{
	return StdPropertyPut ( &m_fVerbose, fVerbose );
}

STDMETHODIMP CNntpAdminRebuild::get_CleanRebuild ( BOOL * pfCleanRebuild )
{
	return StdPropertyGet ( m_fCleanRebuild, pfCleanRebuild );
}

STDMETHODIMP CNntpAdminRebuild::put_CleanRebuild ( BOOL fCleanRebuild )
{
	return StdPropertyPut ( &m_fCleanRebuild, fCleanRebuild );
}

STDMETHODIMP CNntpAdminRebuild::get_DontDeleteHistory ( BOOL * pfDontDeleteHistory )
{
	return StdPropertyGet ( m_fDontDeleteHistory, pfDontDeleteHistory );
}

STDMETHODIMP CNntpAdminRebuild::put_DontDeleteHistory ( BOOL fDontDeleteHistory )
{
	return StdPropertyPut ( &m_fDontDeleteHistory, fDontDeleteHistory );
}

STDMETHODIMP CNntpAdminRebuild::get_ReuseIndexFiles ( BOOL * pfReuseIndexFiles )
{
	return StdPropertyGet ( (DWORD) m_fReuseIndexFiles, (DWORD *) pfReuseIndexFiles );
}

STDMETHODIMP CNntpAdminRebuild::put_ReuseIndexFiles ( BOOL fReuseIndexFiles )
{
	return StdPropertyPut ( (DWORD *) &m_fReuseIndexFiles, (DWORD) fReuseIndexFiles );
}

STDMETHODIMP CNntpAdminRebuild::get_OmitNonLeafDirs ( BOOL * pfOmitNonLeafDirs )
{
	return StdPropertyGet ( m_fOmitNonLeafDirs, pfOmitNonLeafDirs );
}

STDMETHODIMP CNntpAdminRebuild::put_OmitNonLeafDirs ( BOOL fOmitNonLeafDirs )
{
	return StdPropertyPut ( &m_fOmitNonLeafDirs, fOmitNonLeafDirs );
}

STDMETHODIMP CNntpAdminRebuild::get_GroupFile ( BSTR * pstrGroupFile )
{
	return StdPropertyGet ( m_strGroupFile, pstrGroupFile );
}

STDMETHODIMP CNntpAdminRebuild::put_GroupFile ( BSTR strGroupFile )
{
	return StdPropertyPut ( &m_strGroupFile, strGroupFile );
}

STDMETHODIMP CNntpAdminRebuild::get_ReportFile ( BSTR * pstrReportFile )
{
	return StdPropertyGet ( m_strReportFile, pstrReportFile );
}

STDMETHODIMP CNntpAdminRebuild::put_ReportFile ( BSTR strReportFile )
{
	return StdPropertyPut ( &m_strReportFile, strReportFile );
}

STDMETHODIMP CNntpAdminRebuild::get_NumThreads ( long * plNumThreads )
{
	return StdPropertyGet ( m_dwNumThreads, plNumThreads );
}

STDMETHODIMP CNntpAdminRebuild::put_NumThreads ( long lNumThreads )
{
	return StdPropertyPut ( &m_dwNumThreads, lNumThreads );
}

//////////////////////////////////////////////////////////////////////
// Methods:
//////////////////////////////////////////////////////////////////////

STDMETHODIMP CNntpAdminRebuild::Default ( )
{
    HRESULT     hr  = NOERROR;

    m_fVerbose              = DEFAULT_VERBOSE;
    m_fCleanRebuild         = DEFAULT_CLEAN_REBUILD;
    m_fDontDeleteHistory    = DEFAULT_DONT_DELETE_HISTORY;
    m_fReuseIndexFiles      = DEFAULT_REUSE_INDEX_FILES;
    m_fOmitNonLeafDirs      = DEFAULT_OMIT_NON_LEAF_DIRS;
//    m_strGroupFile          = DEFAULT_GROUP_FILE;
    m_strReportFile         = DEFAULT_REPORT_FILE;
    m_dwNumThreads          = DEFAULT_NUM_THREADS;

    return hr;
}

STDMETHODIMP CNntpAdminRebuild::StartRebuild ( )
{
	TraceFunctEnter ( "CNntpAdminRebuild::StartRebuild" );

	HRESULT			hr		= NOERROR;
	NNTPBLD_INFO	bldinfo;
	DWORD			dwError;

	if ( m_fRebuildInProgress ) {
		return NntpCreateException ( IDS_NNTPEXCEPTION_ALREADY_BUILDING );
	}

	ZeroMemory ( &bldinfo, sizeof (bldinfo) );

	bldinfo.Verbose			= !!m_fVerbose;
	bldinfo.DoClean			= !!m_fCleanRebuild;
	bldinfo.NoHistoryDelete	= !!m_fDontDeleteHistory;
	bldinfo.ReuseIndexFiles	= m_fReuseIndexFiles;
	bldinfo.OmitNonleafDirs	= !!m_fOmitNonLeafDirs;
	bldinfo.szGroupFile		= m_strGroupFile;
	bldinfo.cbGroupFile		= STRING_BYTE_LENGTH ( m_strGroupFile );
	bldinfo.szReportFile	= m_strReportFile;
	bldinfo.cbReportFile	= STRING_BYTE_LENGTH ( m_strReportFile );
	bldinfo.NumThreads		= m_dwNumThreads;

	dwError = NntpStartRebuild (
        m_iadsImpl.QueryComputer(),
        m_iadsImpl.QueryInstance(),
        &bldinfo,
        NULL
        );

	if ( dwError == NOERROR ) {
		// We've successfully started a rebuild.

		m_fRebuildInProgress = TRUE;
	}
	else {
		_ASSERT ( dwError != NOERROR );
	
		hr = RETURNCODETOHRESULT ( dwError );
	}

	TRACE_HRESULT(hr);
	TraceFunctLeave ();
	return hr;
}

STDMETHODIMP CNntpAdminRebuild::GetProgress ( long * pdwProgress )
{
	TraceFunctEnter ( "CNntpAdminRebuild::GetProgress" );

	HRESULT			hr		= NOERROR;
	DWORD			dwError;
	DWORD			dwProgress;

	_ASSERT ( IS_VALID_OUT_PARAM ( pdwProgress ) );

	if ( pdwProgress == NULL ) {
		return E_POINTER;
	}

	*pdwProgress	= 0;

	// Should I send back an exception if the build is finished?
	if ( !m_fRebuildInProgress ) {
		*pdwProgress	= 100;
		return NOERROR;
	}

	dwError = NntpGetBuildStatus (
        m_iadsImpl.QueryComputer(),
        m_iadsImpl.QueryInstance(),
        FALSE,
        &dwProgress
        );

	if ( dwError == NOERROR ) {
		*pdwProgress	= dwProgress;
	}
	else {
		_ASSERT ( dwError != NOERROR );

		hr = RETURNCODETOHRESULT ( dwError );
	}

	// Are we still rebuilding?
	if ( dwError != NOERROR || dwProgress == 100 ) {
		// The rebuild is finished.
		m_fRebuildInProgress = FALSE;
	}

	TRACE_HRESULT(hr);
	TraceFunctLeave ();
	return hr;
}

STDMETHODIMP CNntpAdminRebuild::Cancel ( )
{
	TraceFunctEnter ( "CNntpAdminRebuild::Cancel" );

	HRESULT			hr		= NOERROR;
	DWORD			dwError;
	DWORD			dwProgress;

	// Should I send back an exception if the build is finished?
	if ( !m_fRebuildInProgress ) {
		return NOERROR;
	}

	dwError = NntpGetBuildStatus (
        m_iadsImpl.QueryComputer(),
        m_iadsImpl.QueryInstance(),
        TRUE,
        &dwProgress
        );

	if ( dwError != NOERROR ) {
		hr = RETURNCODETOHRESULT ( dwError );
	}

	// Cancel always stops a rebuild:
	m_fRebuildInProgress	= FALSE;

	TRACE_HRESULT(hr);
	TraceFunctLeave ();
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\nntp\adminsso\server.cpp ===
// server.cpp : Implementation of CnntpadmApp and DLL registration.

#include "stdafx.h"
#include <lmcons.h>
#include <sddl.h>
#include "nntpcmn.h"

#include "oleutil.h"
#include "cmultisz.h"
#include "metautil.h"
#include "metakey.h"
#include "server.h"

// Must define THIS_FILE_* macros to use NntpCreateException()

#define THIS_FILE_HELP_CONTEXT		0
#define THIS_FILE_PROG_ID			_T("Nntpadm.VirtualServer.1")
#define THIS_FILE_IID				IID_INntpVirtualServer

// Bitmasks for changed fields:

#define CHNG_ARTICLETIMELIMIT			0x00000001
#define CHNG_HISTORYEXPIRATION			0x00000002
#define CHNG_HONORCLIENTMSGIDS			0x00000004
#define CHNG_SMTPSERVER					0x00000008
#define CHNG_ALLOWCLIENTPOSTS			0x00000010
#define CHNG_ALLOWFEEDPOSTS				0x00000020
#define CHNG_ALLOWCONTROLMSGS			0x00000040
#define CHNG_DEFAULTMODERATORDOMAIN		0x00000080
#define CHNG_COMMANDLOGMASK				0x00000100
#define CHNG_DISABLENEWNEWS				0x00000200
#define CHNG_NEWSCRAWLERTIME			0x00000400
#define CHNG_SHUTDOWNLATENCY			0x00000800

#define CHNG_CLIENTPOSTHARDLIMIT		0x00001000
#define CHNG_CLIENTPOSTSOFTLIMIT		0x00002000
#define CHNG_FEEDPOSTHARDLIMIT			0x00004000
#define CHNG_FEEDPOSTSOFTLIMIT			0x00008000

#define CHNG_GROUPHELPFILE				0x00010000
#define CHNG_GROUPLISTFILE				0x00020000
#define CHNG_ARTICLETABLEFILE			0x00040000
#define CHNG_HISTORYTABLEFILE			0x00080000
#define CHNG_MODERATORFILE				0x00100000
#define CHNG_XOVERTABLEFILE				0x00200000
#define CHNG_DISPLAYNAME				0x00400000
#define CHNG_ERRORCONTROL				0x00800000
#define CHNG_CLEANBOOT					0x01000000
#define CHNG_UUCPNAME					0x02000000
#define CHNG_ORGANIZATION				0x04000000
#define CHNG_AUTOSTART					0x08000000

#define CHNG_COMMENT					0x10000000
#define CHNG_BINDING					0x20000000
#define CHNG_SECUREPORT					0x40000000
#define CHNG_MAXCONNECTIONS				0x80000000

#define CHNG2_CONNECTIONTIMEOUT				0x00000001
#define CHNG2_ANONYMOUSUSERNAME				0x00000002
#define CHNG2_ANONYMOUSUSERPASS				0x00000004
#define CHNG2_PICKUPDIRECTORY				0x00000008
#define CHNG2_FAILEDPICKUPDIRECTORY			0x00000010
#define CHNG2_HOMEDIRECTORY					0x00000020
#define CHNG2_NTAUTHENTICATION_PROVIDERS	0x00000040
#define CHNG2_AUTHORIZATION					0x00000080
#define CHNG2_ENABLELOGGING					0x00000100
#define CHNG2_SSLACCESS						0x00000200
#define CHNG2_AUTOSYNCPASSWORD				0x00000400
#define CHNG2_ADMINEMAIL                    0x00000800
#define CHNG2_CLUSTERENABLED                0x00001000
#define CHNG2_ADMINACL						0x00002000



#define NNTP_DEF_ADMIN_EMAIL            _T( "" )
#define NNTP_DEF_NTAUTHENTICATION_PROVIDERS		_T("NTLM\0")
#define NNTP_DEF_AUTHORIZATION			( 0 )
#define NNTP_DEF_ENABLE_LOGGING			( FALSE )
#define NNTP_DEF_SECURE_BINDINGS		( _T("\0") )

// Parameter ranges:

#define MAXLEN_SERVER					( 256 )
#define MIN_ARTICLETIMELIMIT			( (DWORD) 0 )
#define MAX_ARTICLETIMELIMIT			( (DWORD) -1 )
#define MIN_HISTORYEXPIRATION			( (DWORD) 0 )
#define MAX_HISTORYEXPIRATION			( (DWORD) -1 )
#define MAXLEN_SMTPSERVER				( 256 )
#define MAXLEN_DEFAULTMODERATORDOMAIN	( 256 )
#define MIN_COMMANDLOGMASK				( (DWORD) 0 )
#define MAX_COMMANDLOGMASK				( (DWORD) -1 )
#define MIN_NEWSCRAWLERTIME			( (DWORD) 1 )
#define MAX_NEWSCRAWLERTIME			( (DWORD) -1 )
#define MIN_SHUTDOWNLATENCY				( (DWORD) 1 )
#define MAX_SHUTDOWNLATENCY				( (DWORD) -1 )

//
// Administrator ACL:
//
static HRESULT AclToAdministrators ( LPCTSTR strServer, PSECURITY_DESCRIPTOR pSDRelative, SAFEARRAY ** ppsaAdmins );
static HRESULT AdministratorsToAcl ( LPCTSTR strServer, SAFEARRAY * psaAdmins, PSECURITY_DESCRIPTOR* ppSD, DWORD * pcbSD );

static HRESULT SidToString ( LPCWSTR strSystemName, PSID pSID, BSTR * pStr );
static HRESULT StringToSid ( LPCWSTR strSystemName, LPWSTR str, PSID * ppSID );

/////////////////////////////////////////////////////////////////////////////
//

CNntpVirtualServer::CNntpVirtualServer () :
	m_dwServiceInstance			( 0 ),

	m_dwClientPostHardLimit		( 0 ),
	m_dwClientPostSoftLimit		( 0 ),
	m_dwFeedPostHardLimit		( 0 ),
	m_dwFeedPostSoftLimit		( 0 ),
	m_dwEncryptionCapabilities	( 0 ),
	m_fAutoSyncPassword			( FALSE ),
	m_fErrorControl				( FALSE ),
	m_fCleanBoot				( FALSE ),
	m_fAutoStart				( FALSE ),
	m_psaAdmins					( NULL ),

	m_State						( NNTP_SERVER_STATE_UNKNOWN ),
	m_dwWin32ErrorCode			( NOERROR ),

	m_pPrivateBindings			( NULL ),
	m_pPrivateIpAccess			( NULL ),
//	m_pPrivateHomeDirectory		( NULL ),
	m_fGotProperties			( FALSE ),
	m_fClusterEnabled           ( FALSE ),
	m_bvChangedFields			( 0 ),
	m_bvChangedFields2			( 0 )
	// CComBSTR's are initialized to NULL by default.
{
	InitAsyncTrace ( );

	// Create the Ip Access collection:
	CComObject<CTcpAccess> *	pIpAccess;

	CComObject<CTcpAccess>::CreateInstance ( &pIpAccess );
	pIpAccess->QueryInterface ( IID_ITcpAccess, (void **) &m_pIpAccess );
	m_pPrivateIpAccess = pIpAccess;
}

CNntpVirtualServer::~CNntpVirtualServer ()
{
	// All CComBSTR's are freed automatically.

	if ( m_psaAdmins ) {
		SafeArrayDestroy ( m_psaAdmins );
	}

	TermAsyncTrace ( );
}

STDMETHODIMP CNntpVirtualServer::InterfaceSupportsErrorInfo(REFIID riid)
{
	static const IID* arr[] = 
	{
		&IID_INntpVirtualServer,
	};

	for (int i=0;i<sizeof(arr)/sizeof(arr[0]);i++)
	{
		if (InlineIsEqualGUID(*arr[i],riid))
			return S_OK;
	}
	return S_FALSE;
}

// Which service to configure:
	
STDMETHODIMP CNntpVirtualServer::get_Server ( BSTR * pstrServer )
{
	return StdPropertyGet ( m_strServer, pstrServer );
}

STDMETHODIMP CNntpVirtualServer::put_Server ( BSTR strServer )
{
	VALIDATE_STRING ( strServer, MAXLEN_SERVER );

	// If the server name changes, that means the client will have to
	// call Get again:

	// I assume this here:
	_ASSERT ( sizeof (DWORD) == sizeof (int) );
	
	return StdPropertyPutServerName ( &m_strServer, strServer, (DWORD *) &m_fGotProperties, 1 );
}

STDMETHODIMP CNntpVirtualServer::get_ServiceInstance ( long * plServiceInstance )
{
	return StdPropertyGet ( m_dwServiceInstance, plServiceInstance );
}

STDMETHODIMP CNntpVirtualServer::put_ServiceInstance ( long lServiceInstance )
{
	// If the service instance changes, that means the client will have to
	// call Get again:

	// I assume this here:
	_ASSERT ( sizeof (DWORD) == sizeof (int) );
	
	return StdPropertyPut ( &m_dwServiceInstance, lServiceInstance, (DWORD *) &m_fGotProperties, 1 );
}

// Other admin interfaces for virtual servers:

STDMETHODIMP CNntpVirtualServer::get_FeedsAdmin ( IDispatch ** ppIDispatch )
{
	HRESULT	hr = NOERROR;

	CComPtr<INntpAdminFeeds>	pINntpAdminFeeds;
	CComBSTR strTemp = _T("");
	if (!strTemp) 
	{
		hr = E_OUTOFMEMORY;
		goto Error;
	}
	hr = StdPropertyHandoffIDispatch (
		CLSID_CNntpAdminFeeds,
		IID_INntpAdminFeeds,
		&pINntpAdminFeeds, 
		ppIDispatch 
		);
	if ( FAILED(hr) ) {
		goto Error;
	}

	// Set default properties:
	hr = pINntpAdminFeeds->put_Server ( m_strServer ? m_strServer : strTemp );
	if ( FAILED (hr) ) {
		goto Error;
	}
	
	hr = pINntpAdminFeeds->put_ServiceInstance ( m_dwServiceInstance );
	if ( FAILED (hr) ) {
		goto Error;
	}

	return hr;

Error:
	SAFE_RELEASE ( *ppIDispatch );
	*ppIDispatch = NULL;

	return hr;

	// Destructor releases pINntpAdminFeeds
}

STDMETHODIMP CNntpVirtualServer::get_GroupsAdmin ( IDispatch ** ppIDispatch )
{
	HRESULT	hr = NOERROR;

	CComPtr<INntpAdminGroups>	pINntpAdminGroups;
	CComBSTR strTemp = _T("");
	if (!strTemp) 
	{
		hr = E_OUTOFMEMORY;
		goto Error;
	}
	hr = StdPropertyHandoffIDispatch (
		CLSID_CNntpAdminGroups,
		IID_INntpAdminGroups,
		&pINntpAdminGroups, 
		ppIDispatch 
		);
	if ( FAILED(hr) ) {
		goto Error;
	}

	// Set default properties:
	hr = pINntpAdminGroups->put_Server ( m_strServer ? m_strServer : strTemp );
	if ( FAILED (hr) ) {
		goto Error;
	}
	
	hr = pINntpAdminGroups->put_ServiceInstance ( m_dwServiceInstance );
	if ( FAILED (hr) ) {
		goto Error;
	}

	return hr;

Error:
	SAFE_RELEASE ( *ppIDispatch );
	*ppIDispatch = NULL;

	return hr;

	// Destructor releases pINntpAdminGroups
}

STDMETHODIMP CNntpVirtualServer::get_ExpirationAdmin ( IDispatch ** ppIDispatch )
{
	HRESULT	hr = NOERROR;

	CComPtr<INntpAdminExpiration>	pINntpAdminExpiration;
	CComBSTR strTemp = _T("");
	if (!strTemp) 
	{
		hr = E_OUTOFMEMORY;
		goto Error;
	}
	hr = StdPropertyHandoffIDispatch (
		CLSID_CNntpAdminExpiration,
		IID_INntpAdminExpiration,
		&pINntpAdminExpiration, 
		ppIDispatch 
		);
	if ( FAILED(hr) ) {
		goto Error;
	}

	// Set default properties:
	hr = pINntpAdminExpiration->put_Server ( m_strServer ? m_strServer : strTemp );
	if ( FAILED (hr) ) {
		goto Error;
	}
	
	hr = pINntpAdminExpiration->put_ServiceInstance ( m_dwServiceInstance );
	if ( FAILED (hr) ) {
		goto Error;
	}

	return hr;

Error:
	SAFE_RELEASE ( *ppIDispatch );
	*ppIDispatch = NULL;

	return hr;

	// Destructor releases pINntpAdminExpiration
}

STDMETHODIMP CNntpVirtualServer::get_SessionsAdmin ( IDispatch ** ppIDispatch )
{
	HRESULT	hr = NOERROR;

	CComPtr<INntpAdminSessions>	pINntpAdminSessions;
	CComBSTR strTemp = _T("");
	if (!strTemp) 
	{
		hr = E_OUTOFMEMORY;
		goto Error;
	}
	hr = StdPropertyHandoffIDispatch (
		CLSID_CNntpAdminSessions,
		IID_INntpAdminSessions,
		&pINntpAdminSessions, 
		ppIDispatch 
		);
	if ( FAILED(hr) ) {
		goto Error;
	}

	// Set default properties:
	hr = pINntpAdminSessions->put_Server ( m_strServer ? m_strServer : strTemp );
	if ( FAILED (hr) ) {
		goto Error;
	}
	
	hr = pINntpAdminSessions->put_ServiceInstance ( m_dwServiceInstance );
	if ( FAILED (hr) ) {
		goto Error;
	}

	return hr;

Error:
	SAFE_RELEASE ( *ppIDispatch );
	*ppIDispatch = NULL;

	return hr;

	// Destructor releases pINntpAdminSessions
}

STDMETHODIMP CNntpVirtualServer::get_RebuildAdmin ( IDispatch ** ppIDispatch )
{
	HRESULT	hr = NOERROR;

	CComPtr<INntpAdminRebuild>	pINntpAdminRebuild;
	CComBSTR strTemp = _T("");
	if (!strTemp) 
	{
		hr = E_OUTOFMEMORY;
		goto Error;
	}
	hr = StdPropertyHandoffIDispatch (
		CLSID_CNntpAdminRebuild,
		IID_INntpAdminRebuild,
		&pINntpAdminRebuild, 
		ppIDispatch 
		);
	if ( FAILED(hr) ) {
		goto Error;
	}

	// Set default properties:
	hr = pINntpAdminRebuild->put_Server ( m_strServer ? m_strServer : strTemp );
	if ( FAILED (hr) ) {
		goto Error;
	}
	
	hr = pINntpAdminRebuild->put_ServiceInstance ( m_dwServiceInstance );
	if ( FAILED (hr) ) {
		goto Error;
	}

	return hr;

Error:
	SAFE_RELEASE ( *ppIDispatch );
	*ppIDispatch = NULL;

	return hr;

	// Destructor releases pINntpAdminRebuild
}

STDMETHODIMP CNntpVirtualServer::get_VirtualRoots ( INntpVirtualRoots ** ppVirtualRoots )
{
	HRESULT	hr = NOERROR;
	CComObject<CNntpVirtualRoots> *	pVRoots	= NULL;

	*ppVirtualRoots	= NULL;

	hr = CComObject<CNntpVirtualRoots>::CreateInstance ( &pVRoots );
	if ( FAILED(hr) ) {
		goto Error;
	}

	// Set default properties:
	pVRoots->m_strServer			= m_strServer;
	pVRoots->m_dwServiceInstance	= m_dwServiceInstance;

	if ( m_strServer && !pVRoots->m_strServer ) {
		hr = E_OUTOFMEMORY;
		goto Error;
	}

	hr = pVRoots->QueryInterface ( IID_INntpVirtualRoots, (void **) ppVirtualRoots );

Error:
	if ( FAILED(hr) ) {
		delete pVRoots;
	}

	return hr;

	// Destructor releases pINntpAdminRebuild
}

STDMETHODIMP CNntpVirtualServer::get_VirtualRootsDispatch ( IDispatch ** ppVirtualRoots )
{
	HRESULT						hr;
	CComPtr<INntpVirtualRoots>	pVRoots;

	hr = get_VirtualRoots ( &pVRoots );
	BAIL_ON_FAILURE ( hr );

	hr = pVRoots->QueryInterface ( IID_IDispatch, (void **) ppVirtualRoots );
	BAIL_ON_FAILURE ( hr );

Exit:
	return hr;
}

STDMETHODIMP CNntpVirtualServer::get_TcpAccess ( ITcpAccess ** ppTcpAccess )
{
    return m_pIpAccess->QueryInterface ( IID_ITcpAccess, (void **) ppTcpAccess );
}

// Server overridable Properties:

STDMETHODIMP CNntpVirtualServer::get_ArticleTimeLimit ( long * plArticleTimeLimit )
{
	return StdPropertyGet ( m_dwArticleTimeLimit, plArticleTimeLimit );
}

STDMETHODIMP CNntpVirtualServer::put_ArticleTimeLimit ( long lArticleTimeLimit )
{
	return StdPropertyPut ( &m_dwArticleTimeLimit, lArticleTimeLimit, &m_bvChangedFields, CHNG_ARTICLETIMELIMIT );
}

STDMETHODIMP CNntpVirtualServer::get_HistoryExpiration ( long * plHistoryExpiration )
{
	return StdPropertyGet ( m_dwHistoryExpiration, plHistoryExpiration );
}

STDMETHODIMP CNntpVirtualServer::put_HistoryExpiration ( long lHistoryExpiration )
{
	return StdPropertyPut ( &m_dwHistoryExpiration, lHistoryExpiration, &m_bvChangedFields, CHNG_HISTORYEXPIRATION );
}

STDMETHODIMP CNntpVirtualServer::get_HonorClientMsgIDs ( BOOL * pfHonorClientMsgIDs )
{
	return StdPropertyGet ( m_fHonorClientMsgIDs, pfHonorClientMsgIDs );
}

STDMETHODIMP CNntpVirtualServer::put_HonorClientMsgIDs ( BOOL fHonorClientMsgIDs )
{
	return StdPropertyPut ( &m_fHonorClientMsgIDs, fHonorClientMsgIDs, &m_bvChangedFields, CHNG_HONORCLIENTMSGIDS );
}

STDMETHODIMP CNntpVirtualServer::get_SmtpServer ( BSTR * pstrSmtpServer )
{
	return StdPropertyGet ( m_strSmtpServer, pstrSmtpServer );
}

STDMETHODIMP CNntpVirtualServer::put_SmtpServer ( BSTR strSmtpServer )
{
	return StdPropertyPut ( &m_strSmtpServer, strSmtpServer, &m_bvChangedFields, CHNG_SMTPSERVER );
}

STDMETHODIMP CNntpVirtualServer::get_AdminEmail ( BSTR * pstrAdminEmail )
{
	return StdPropertyGet ( m_strAdminEmail, pstrAdminEmail );
}

STDMETHODIMP CNntpVirtualServer::put_AdminEmail ( BSTR strAdminEmail )
{
	return StdPropertyPut ( &m_strAdminEmail, strAdminEmail, &m_bvChangedFields2, CHNG2_ADMINEMAIL );
}

STDMETHODIMP CNntpVirtualServer::get_AllowClientPosts ( BOOL * pfAllowClientPosts )
{
	return StdPropertyGet ( m_fAllowClientPosts, pfAllowClientPosts );
}

STDMETHODIMP CNntpVirtualServer::put_AllowClientPosts ( BOOL fAllowClientPosts )
{
	return StdPropertyPut ( &m_fAllowClientPosts, fAllowClientPosts, &m_bvChangedFields, CHNG_ALLOWCLIENTPOSTS );
}

STDMETHODIMP CNntpVirtualServer::get_AllowFeedPosts ( BOOL * pfAllowFeedPosts )
{
	return StdPropertyGet ( m_fAllowFeedPosts, pfAllowFeedPosts );
}

STDMETHODIMP CNntpVirtualServer::put_AllowFeedPosts ( BOOL fAllowFeedPosts )
{
	return StdPropertyPut ( &m_fAllowFeedPosts, fAllowFeedPosts, &m_bvChangedFields, CHNG_ALLOWFEEDPOSTS );
}

STDMETHODIMP CNntpVirtualServer::get_AllowControlMsgs ( BOOL * pfAllowControlMsgs )
{
	return StdPropertyGet ( m_fAllowControlMsgs, pfAllowControlMsgs );
}

STDMETHODIMP CNntpVirtualServer::put_AllowControlMsgs ( BOOL fAllowControlMsgs )
{
	return StdPropertyPut ( &m_fAllowControlMsgs, fAllowControlMsgs, &m_bvChangedFields, CHNG_ALLOWCONTROLMSGS );
}

STDMETHODIMP CNntpVirtualServer::get_DefaultModeratorDomain ( BSTR * pstrDefaultModeratorDomain )
{
	return StdPropertyGet ( m_strDefaultModeratorDomain, pstrDefaultModeratorDomain );
}

STDMETHODIMP CNntpVirtualServer::put_DefaultModeratorDomain ( BSTR strDefaultModeratorDomain )
{
	return StdPropertyPut ( &m_strDefaultModeratorDomain, strDefaultModeratorDomain, &m_bvChangedFields, CHNG_DEFAULTMODERATORDOMAIN );
}

STDMETHODIMP CNntpVirtualServer::get_CommandLogMask ( long * plCommandLogMask )
{
	return StdPropertyGet ( m_dwCommandLogMask, plCommandLogMask );
}

STDMETHODIMP CNntpVirtualServer::put_CommandLogMask ( long lCommandLogMask )
{
	return StdPropertyPut ( &m_dwCommandLogMask, lCommandLogMask, &m_bvChangedFields, CHNG_COMMANDLOGMASK );
}

STDMETHODIMP CNntpVirtualServer::get_DisableNewnews ( BOOL * pfDisableNewnews )
{
	return StdPropertyGet ( m_fDisableNewnews, pfDisableNewnews );
}

STDMETHODIMP CNntpVirtualServer::put_DisableNewnews ( BOOL fDisableNewnews )
{
	return StdPropertyPut ( &m_fDisableNewnews, fDisableNewnews, &m_bvChangedFields, CHNG_DISABLENEWNEWS );
}

STDMETHODIMP CNntpVirtualServer::get_ExpireRunFrequency ( long * plExpireRunFrequency )
{
	return StdPropertyGet ( m_dwExpireRunFrequency, plExpireRunFrequency );
}

STDMETHODIMP CNntpVirtualServer::put_ExpireRunFrequency ( long lExpireRunFrequency )
{
	return StdPropertyPut ( &m_dwExpireRunFrequency, lExpireRunFrequency, &m_bvChangedFields, CHNG_NEWSCRAWLERTIME );
}

STDMETHODIMP CNntpVirtualServer::get_ShutdownLatency ( long * plShutdownLatency )
{
	return StdPropertyGet ( m_dwShutdownLatency, plShutdownLatency );
}

STDMETHODIMP CNntpVirtualServer::put_ShutdownLatency ( long lShutdownLatency )
{
	return StdPropertyPut ( &m_dwShutdownLatency, lShutdownLatency, &m_bvChangedFields, CHNG_SHUTDOWNLATENCY );
}

STDMETHODIMP CNntpVirtualServer::get_ClientPostHardLimit ( long * plClientPostHardLimit )
{
	return StdPropertyGet ( m_dwClientPostHardLimit, plClientPostHardLimit );
}

STDMETHODIMP CNntpVirtualServer::put_ClientPostHardLimit ( long lClientPostHardLimit )
{
	return StdPropertyPut ( &m_dwClientPostHardLimit, lClientPostHardLimit, &m_bvChangedFields, CHNG_CLIENTPOSTHARDLIMIT );
}

STDMETHODIMP CNntpVirtualServer::get_ClientPostSoftLimit ( long * plClientPostSoftLimit )
{
	return StdPropertyGet ( m_dwClientPostSoftLimit, plClientPostSoftLimit );
}

STDMETHODIMP CNntpVirtualServer::put_ClientPostSoftLimit ( long lClientPostSoftLimit )
{
	return StdPropertyPut ( &m_dwClientPostSoftLimit, lClientPostSoftLimit, &m_bvChangedFields, CHNG_CLIENTPOSTSOFTLIMIT );
}

STDMETHODIMP CNntpVirtualServer::get_FeedPostHardLimit ( long * plFeedPostHardLimit )
{
	return StdPropertyGet ( m_dwFeedPostHardLimit, plFeedPostHardLimit );
}

STDMETHODIMP CNntpVirtualServer::put_FeedPostHardLimit ( long lFeedPostHardLimit )
{
	return StdPropertyPut ( &m_dwFeedPostHardLimit, lFeedPostHardLimit, &m_bvChangedFields, CHNG_FEEDPOSTHARDLIMIT );
}

STDMETHODIMP CNntpVirtualServer::get_FeedPostSoftLimit ( long * plFeedPostSoftLimit )
{
	return StdPropertyGet ( m_dwFeedPostSoftLimit, plFeedPostSoftLimit );
}

STDMETHODIMP CNntpVirtualServer::put_FeedPostSoftLimit ( long lFeedPostSoftLimit )
{
	return StdPropertyPut ( &m_dwFeedPostSoftLimit, lFeedPostSoftLimit, &m_bvChangedFields, CHNG_FEEDPOSTSOFTLIMIT );
}

STDMETHODIMP CNntpVirtualServer::get_EnableLogging ( BOOL * pfEnableLogging )
{
	return StdPropertyGet ( m_fEnableLogging, pfEnableLogging );
}

STDMETHODIMP CNntpVirtualServer::put_EnableLogging ( BOOL fEnableLogging )
{
	return StdPropertyPut ( &m_fEnableLogging, fEnableLogging, &m_bvChangedFields2, CHNG2_ENABLELOGGING );
}

// Service-specific properties:

STDMETHODIMP CNntpVirtualServer::get_Organization ( BSTR * pstrOrganization )
{
	return StdPropertyGet ( m_strOrganization, pstrOrganization );
}

STDMETHODIMP CNntpVirtualServer::put_Organization ( BSTR strOrganization )
{
	return StdPropertyPut ( &m_strOrganization, strOrganization, &m_bvChangedFields, CHNG_ORGANIZATION );
}

STDMETHODIMP CNntpVirtualServer::get_UucpName ( BSTR * pstrUucpName )
{
	return StdPropertyGet ( m_strUucpName, pstrUucpName );
}

STDMETHODIMP CNntpVirtualServer::put_UucpName ( BSTR strUucpName )
{
	return StdPropertyPut ( &m_strUucpName, strUucpName, &m_bvChangedFields, CHNG_UUCPNAME );
}

STDMETHODIMP CNntpVirtualServer::get_GroupHelpFile ( BSTR * pstrGroupHelpFile )
{
	return StdPropertyGet ( m_strGroupHelpFile, pstrGroupHelpFile );
}

STDMETHODIMP CNntpVirtualServer::put_GroupHelpFile ( BSTR strGroupHelpFile )
{
	return StdPropertyPut ( &m_strGroupHelpFile, strGroupHelpFile, &m_bvChangedFields, CHNG_GROUPHELPFILE );
}

STDMETHODIMP CNntpVirtualServer::get_GroupListFile ( BSTR * pstrGroupListFile )
{
	return StdPropertyGet ( m_strGroupListFile, pstrGroupListFile );
}

STDMETHODIMP CNntpVirtualServer::put_GroupListFile ( BSTR strGroupListFile )
{
	return StdPropertyPut ( &m_strGroupListFile, strGroupListFile, &m_bvChangedFields, CHNG_GROUPLISTFILE );
}

STDMETHODIMP CNntpVirtualServer::get_GroupVarListFile( BSTR *pstrGroupListFile )
{
    return StdPropertyGet( m_strGroupVarListFile, pstrGroupListFile );
}

STDMETHODIMP CNntpVirtualServer::put_GroupVarListFile( BSTR strGroupVarListFile )
{
    return StdPropertyPut ( &m_strGroupVarListFile, strGroupVarListFile, &m_bvChangedFields, CHNG_GROUPLISTFILE );
}

STDMETHODIMP CNntpVirtualServer::get_ArticleTableFile ( BSTR * pstrArticleTableFile )
{
	return StdPropertyGet ( m_strArticleTableFile, pstrArticleTableFile );
}

STDMETHODIMP CNntpVirtualServer::put_ArticleTableFile ( BSTR strArticleTableFile )
{
	return StdPropertyPut ( &m_strArticleTableFile, strArticleTableFile, &m_bvChangedFields, CHNG_ARTICLETABLEFILE );
}

STDMETHODIMP CNntpVirtualServer::get_HistoryTableFile ( BSTR * pstrHistoryTableFile )
{
	return StdPropertyGet ( m_strHistoryTableFile, pstrHistoryTableFile );
}

STDMETHODIMP CNntpVirtualServer::put_HistoryTableFile ( BSTR strHistoryTableFile )
{
	return StdPropertyPut ( &m_strHistoryTableFile, strHistoryTableFile, &m_bvChangedFields, CHNG_HISTORYTABLEFILE );
}

STDMETHODIMP CNntpVirtualServer::get_ModeratorFile ( BSTR * pstrModeratorFile )
{
	return StdPropertyGet ( m_strModeratorFile, pstrModeratorFile );
}

STDMETHODIMP CNntpVirtualServer::put_ModeratorFile ( BSTR strModeratorFile )
{
	return StdPropertyPut ( &m_strModeratorFile, strModeratorFile, &m_bvChangedFields, CHNG_MODERATORFILE );
}

STDMETHODIMP CNntpVirtualServer::get_XOverTableFile ( BSTR * pstrXOverTableFile )
{
	return StdPropertyGet ( m_strXOverTableFile, pstrXOverTableFile );
}

STDMETHODIMP CNntpVirtualServer::put_XOverTableFile ( BSTR strXOverTableFile )
{
	return StdPropertyPut ( &m_strXOverTableFile, strXOverTableFile, &m_bvChangedFields, CHNG_XOVERTABLEFILE );
}

STDMETHODIMP CNntpVirtualServer::get_AutoStart ( BOOL * pfAutoStart )
{
	return StdPropertyGet ( m_fAutoStart, pfAutoStart );
}

STDMETHODIMP CNntpVirtualServer::put_AutoStart ( BOOL fAutoStart )
{
	return StdPropertyPut ( &m_fAutoStart, fAutoStart, &m_bvChangedFields, CHNG_AUTOSTART );
}

STDMETHODIMP CNntpVirtualServer::get_Comment ( BSTR * pstrComment )
{
    if ( m_strComment.Length() == 0 ) return StdPropertyGet( m_strUucpName, pstrComment );
    else return StdPropertyGet ( m_strComment, pstrComment );
}

STDMETHODIMP CNntpVirtualServer::put_Comment ( BSTR strComment )
{
	return StdPropertyPut ( &m_strComment, strComment, &m_bvChangedFields, CHNG_COMMENT );
}

STDMETHODIMP CNntpVirtualServer::get_Bindings ( INntpServerBindings ** ppBindings )
{
	TraceQuietEnter ( "CNntpVirtualServer::get_Bindings" );

	HRESULT		hr = NOERROR;

	if ( !m_pBindings ) {
		ErrorTrace ( 0, "Didn't call get first" );
		hr = NntpCreateException ( IDS_NNTPEXCEPTION_DIDNT_CALL_GET );
		goto Exit;
	}
	else {
		hr = m_pBindings->QueryInterface ( IID_INntpServerBindings, (void **) ppBindings );
		_ASSERT ( SUCCEEDED(hr) );
	}

Exit:
	TRACE_HRESULT(hr);
	TraceFunctLeave ();
	return hr;
}

STDMETHODIMP CNntpVirtualServer::get_BindingsDispatch ( IDispatch ** ppBindings )
{
	HRESULT							hr	= NOERROR;
	CComPtr<INntpServerBindings>	pBindings;

	hr = get_Bindings ( &pBindings );
	if ( FAILED(hr) ) {
		goto Exit;
	}

	hr = pBindings->QueryInterface ( IID_IDispatch, (void **) ppBindings );
	if ( FAILED(hr) ) {
		goto Exit;
	}

Exit:
	return hr;
}

STDMETHODIMP CNntpVirtualServer::get_SecurePort ( long * pdwSecurePort )
{
	return StdPropertyGet ( m_dwSecurePort, pdwSecurePort );
}

STDMETHODIMP CNntpVirtualServer::put_SecurePort ( long dwSecurePort )
{
	return StdPropertyPut ( &m_dwSecurePort, dwSecurePort, &m_bvChangedFields, CHNG_SECUREPORT );
}

STDMETHODIMP CNntpVirtualServer::get_MaxConnections ( long * pdwMaxConnections )
{
	return StdPropertyGet ( m_dwMaxConnections, pdwMaxConnections );
}

STDMETHODIMP CNntpVirtualServer::put_MaxConnections ( long dwMaxConnections )
{
	return StdPropertyPut ( &m_dwMaxConnections, dwMaxConnections, &m_bvChangedFields, CHNG_MAXCONNECTIONS );
}

STDMETHODIMP CNntpVirtualServer::get_ConnectionTimeout ( long * pdwConnectionTimeout )
{
	return StdPropertyGet ( m_dwConnectionTimeout, pdwConnectionTimeout );
}

STDMETHODIMP CNntpVirtualServer::put_ConnectionTimeout ( long dwConnectionTimeout )
{
	return StdPropertyPut ( &m_dwConnectionTimeout, dwConnectionTimeout, &m_bvChangedFields2, CHNG2_CONNECTIONTIMEOUT );
}

STDMETHODIMP CNntpVirtualServer::get_AnonymousUserName ( BSTR * pstrAnonymousUserName )
{
	return StdPropertyGet ( m_strAnonymousUserName, pstrAnonymousUserName );
}

STDMETHODIMP CNntpVirtualServer::put_AnonymousUserName ( BSTR strAnonymousUserName )
{
	return StdPropertyPut ( &m_strAnonymousUserName, strAnonymousUserName, &m_bvChangedFields2, CHNG2_ANONYMOUSUSERNAME );
}

STDMETHODIMP CNntpVirtualServer::get_AnonymousUserPass ( BSTR * pstrAnonymousUserPass )
{
	return StdPropertyGet ( m_strAnonymousUserPass, pstrAnonymousUserPass );
}

STDMETHODIMP CNntpVirtualServer::put_AnonymousUserPass ( BSTR strAnonymousUserPass )
{
	return StdPropertyPut ( &m_strAnonymousUserPass, strAnonymousUserPass, &m_bvChangedFields2, CHNG2_ANONYMOUSUSERPASS );
}

STDMETHODIMP CNntpVirtualServer::get_AutoSyncPassword ( BOOL * pfAutoSyncPassword )
{
	return StdPropertyGet ( m_fAutoSyncPassword, pfAutoSyncPassword );
}

STDMETHODIMP CNntpVirtualServer::put_AutoSyncPassword ( BOOL fAutoSyncPassword )
{
	return StdPropertyPut ( &m_fAutoSyncPassword, fAutoSyncPassword, &m_bvChangedFields2, CHNG2_AUTOSYNCPASSWORD );
}

STDMETHODIMP CNntpVirtualServer::get_PickupDirectory ( BSTR * pstrPickupDirectory )
{
	return StdPropertyGet ( m_strPickupDirectory, pstrPickupDirectory );
}

STDMETHODIMP CNntpVirtualServer::put_PickupDirectory ( BSTR strPickupDirectory )
{
	return StdPropertyPut ( &m_strPickupDirectory, strPickupDirectory, &m_bvChangedFields2, CHNG2_PICKUPDIRECTORY );
}

STDMETHODIMP CNntpVirtualServer::get_FailedPickupDirectory ( BSTR * pstrFailedPickupDirectory )
{
	return StdPropertyGet ( m_strFailedPickupDirectory, pstrFailedPickupDirectory );
}

STDMETHODIMP CNntpVirtualServer::put_FailedPickupDirectory ( BSTR strFailedPickupDirectory )
{
	return StdPropertyPut ( &m_strFailedPickupDirectory, strFailedPickupDirectory, &m_bvChangedFields2, CHNG2_FAILEDPICKUPDIRECTORY );
}

STDMETHODIMP CNntpVirtualServer::get_AuthAnonymous ( BOOL * pfAuthAnonymous )
{
	return StdPropertyGetBit ( m_bvAuthorization, MD_AUTH_ANONYMOUS, pfAuthAnonymous );
}

STDMETHODIMP CNntpVirtualServer::put_AuthAnonymous ( BOOL fAuthAnonymous )
{
	return StdPropertyPutBit ( &m_bvAuthorization, MD_AUTH_ANONYMOUS, fAuthAnonymous );
}

STDMETHODIMP CNntpVirtualServer::get_AuthBasic ( BOOL * pfAuthBasic )
{
	return StdPropertyGetBit ( m_bvAuthorization, MD_AUTH_BASIC, pfAuthBasic );
}

STDMETHODIMP CNntpVirtualServer::put_AuthBasic ( BOOL fAuthBasic )
{
	return StdPropertyPutBit ( &m_bvAuthorization, MD_AUTH_BASIC, fAuthBasic );
}

STDMETHODIMP CNntpVirtualServer::get_AuthMCISBasic ( BOOL * pfAuthMCISBasic )
{
	*pfAuthMCISBasic = FALSE;
	return NOERROR;
//	return StdPropertyGetBit ( m_bvAuthorization, MD_AUTH_MCIS_BASIC, pfAuthMCISBasic );
}

STDMETHODIMP CNntpVirtualServer::put_AuthMCISBasic ( BOOL fAuthMCISBasic )
{
	return NOERROR;
//	return StdPropertyPutBit ( &m_bvAuthorization, MD_AUTH_MCIS_BASIC, fAuthMCISBasic );
}

STDMETHODIMP CNntpVirtualServer::get_AuthNT ( BOOL * pfAuthNT )
{
	return StdPropertyGetBit ( m_bvAuthorization, MD_AUTH_NT, pfAuthNT );
}

STDMETHODIMP CNntpVirtualServer::put_AuthNT ( BOOL fAuthNT )
{
	return StdPropertyPutBit ( &m_bvAuthorization, MD_AUTH_NT, fAuthNT );
}

STDMETHODIMP CNntpVirtualServer::get_SSLNegotiateCert ( BOOL * pfNegotiateCert )
{
	return StdPropertyGetBit ( m_bvSslAccess, MD_ACCESS_NEGO_CERT, pfNegotiateCert );
}

STDMETHODIMP CNntpVirtualServer::put_SSLNegotiateCert ( BOOL fNegotiateCert )
{
	return StdPropertyPutBit ( &m_bvSslAccess, MD_ACCESS_NEGO_CERT, fNegotiateCert ); // , &m_bvChangedFields2, CHNG2_SSLACCESS  );
}

STDMETHODIMP CNntpVirtualServer::get_SSLRequireCert ( BOOL * pfRequireCert )
{
	return StdPropertyGetBit ( m_bvSslAccess, MD_ACCESS_REQUIRE_CERT, pfRequireCert );
}

STDMETHODIMP CNntpVirtualServer::put_SSLRequireCert ( BOOL fRequireCert )
{
	return StdPropertyPutBit ( &m_bvSslAccess, MD_ACCESS_REQUIRE_CERT, fRequireCert ); // , &m_bvChangedFields2, CHNG2_SSLACCESS  );
}

STDMETHODIMP CNntpVirtualServer::get_SSLMapCert ( BOOL * pfMapCert )
{
	return StdPropertyGetBit ( m_bvSslAccess, MD_ACCESS_MAP_CERT, pfMapCert );
}

STDMETHODIMP CNntpVirtualServer::put_SSLMapCert ( BOOL fMapCert )
{
	return StdPropertyPutBit ( &m_bvSslAccess, MD_ACCESS_MAP_CERT, fMapCert ); // , &m_bvChangedFields2, CHNG2_SSLACCESS  );
}

/*

STDMETHODIMP CNntpVirtualServer::get_AuthenticationProviders ( SAFEARRAY ** ppsastrProviders )
{
	return StdPropertyGet ( &m_mszProviders, ppsastrProviders );
}

STDMETHODIMP CNntpVirtualServer::put_AuthenticationProviders ( SAFEARRAY * psastrProviders )
{
	return StdPropertyPut ( &m_mszProviders, psastrProviders );
}

STDMETHODIMP CNntpVirtualServer::get_AuthenticationProvidersVariant ( SAFEARRAY ** ppsavarAuthProviders )
{
	HRESULT			hr;
	SAFEARRAY *		psastrAuthProviders	= NULL;

	hr = get_AuthenticationProviders ( &psastrAuthProviders );
	if ( FAILED(hr) ) {
		goto Exit;
	}

	hr = StringArrayToVariantArray ( psastrAuthProviders, ppsavarAuthProviders );

Exit:
	if ( psastrAuthProviders ) {
		SafeArrayDestroy ( psastrAuthProviders );
	}

	return hr;
}

STDMETHODIMP CNntpVirtualServer::put_AuthenticationProvidersVariant ( SAFEARRAY * psavarAuthProviders )
{
	HRESULT			hr;
	SAFEARRAY *		psastrAuthProviders	= NULL;

	hr = VariantArrayToStringArray ( psavarAuthProviders, &psastrAuthProviders );
	if ( FAILED(hr) ) {
		goto Exit;
	}

	hr = put_AuthenticationProviders ( psastrAuthProviders );

Exit:
	if ( psastrAuthProviders ) {
		SafeArrayDestroy ( psastrAuthProviders );
	}

	return hr;
}

*/

STDMETHODIMP CNntpVirtualServer::get_Administrators ( SAFEARRAY ** ppsastrAdmins )
{
	TraceFunctEnter ( "CNntpVS::get_Administrators" );

	HRESULT		hr	= NOERROR;

    if ( m_psaAdmins ) {
	    hr = SafeArrayCopy ( m_psaAdmins, ppsastrAdmins );
    }
    else {
        *ppsastrAdmins = NULL;
        hr = NOERROR;
    }

	TraceFunctLeave ();
	return hr;
}

STDMETHODIMP CNntpVirtualServer::put_Administrators ( SAFEARRAY * psastrAdmins )
{
	TraceFunctEnter ( "CNntpVS::put_Administrators" );

	HRESULT		hr	= NOERROR;

	if ( m_psaAdmins ) {
		SafeArrayDestroy ( m_psaAdmins );
	}

    if ( psastrAdmins ) {
    	hr = SafeArrayCopy ( psastrAdmins, &m_psaAdmins );
    }
    else {
        m_psaAdmins = NULL;
        hr = NOERROR;
    }

    m_bvChangedFields2 |= CHNG2_ADMINACL;

	TraceFunctLeave ();
	return hr;
}

STDMETHODIMP CNntpVirtualServer::get_AdministratorsVariant ( SAFEARRAY ** ppsavarAdmins )
{
	HRESULT			hr;
	SAFEARRAY *		psastrAdmins	= NULL;

	hr = get_Administrators ( &psastrAdmins );
	if ( FAILED(hr) ) {
		goto Exit;
	}

	hr = StringArrayToVariantArray ( psastrAdmins, ppsavarAdmins );

Exit:
	if ( psastrAdmins ) {
		SafeArrayDestroy ( psastrAdmins );
	}

	return hr;
}

STDMETHODIMP CNntpVirtualServer::put_AdministratorsVariant ( SAFEARRAY * psavarAdmins )
{
	HRESULT			hr;
	SAFEARRAY *		psastrAdmins	= NULL;

	hr = VariantArrayToStringArray ( psavarAdmins, &psastrAdmins );
	if ( FAILED(hr) ) {
		goto Exit;
	}

	hr = put_Administrators ( psastrAdmins );

Exit:
	if ( psastrAdmins ) {
		SafeArrayDestroy ( psastrAdmins );
	}

	return hr;
}

STDMETHODIMP CNntpVirtualServer::get_ClusterEnabled ( BOOL *pfClusterEnabled )
{
	return StdPropertyGet ( m_fClusterEnabled, pfClusterEnabled );
}

STDMETHODIMP CNntpVirtualServer::put_ClusterEnabled ( BOOL fClusterEnabled )
{
	return StdPropertyPut ( &m_fClusterEnabled, fClusterEnabled, &m_bvChangedFields2, CHNG2_CLUSTERENABLED);
}

STDMETHODIMP CNntpVirtualServer::get_State ( NNTP_SERVER_STATE * pState )
{
	if ( pState == NULL ) {
		return E_POINTER;
	}
	*pState = m_State;
	return NOERROR;
}

STDMETHODIMP CNntpVirtualServer::get_Win32ErrorCode ( long * plWin32ErrorCode )
{
	return StdPropertyGet ( m_dwWin32ErrorCode, plWin32ErrorCode );
}

/*
STDMETHODIMP CNntpVirtualServer::get_DisplayName ( BSTR * pstrDisplayName )
{
	return StdPropertyGet ( m_strDisplayName, pstrDisplayName );
}

STDMETHODIMP CNntpVirtualServer::put_DisplayName ( BSTR strDisplayName )
{
	return StdPropertyPut ( &m_strDisplayName, strDisplayName );
}

STDMETHODIMP CNntpVirtualServer::get_ErrorControl ( BOOL * pfErrorControl )
{
	return StdPropertyGet ( m_fErrorControl, pfErrorControl );
}

STDMETHODIMP CNntpVirtualServer::put_ErrorControl ( BOOL fErrorControl )
{
	return StdPropertyPut ( &m_fErrorControl, fErrorControl );
}

STDMETHODIMP CNntpVirtualServer::get_CleanBoot ( BOOL * pfCleanBoot )
{
	return StdPropertyGet ( m_fCleanBoot, pfCleanBoot );
}

STDMETHODIMP CNntpVirtualServer::put_CleanBoot ( BOOL fCleanBoot )
{
	return StdPropertyPut ( &m_fCleanBoot, fCleanBoot );
}

STDMETHODIMP CNntpVirtualServer::get_EncryptionCapabilitiesMask ( long * plEncryptionCapabilitiesMask )
{
	return StdPropertyGet ( m_dwEncryptionCapabilities, plEncryptionCapabilitiesMask );
}

STDMETHODIMP CNntpVirtualServer::put_EncryptionCapabilitiesMask ( long lEncryptionCapabilitiesMask )
{
	return StdPropertyPut ( &m_dwEncryptionCapabilities, lEncryptionCapabilitiesMask, &m_bvChangedFields, CHNG_ENCRYPTIONCAPABILITIES );
}
*/

//////////////////////////////////////////////////////////////////////
// Methods:
//////////////////////////////////////////////////////////////////////

//$-------------------------------------------------------------------
//
//	CNntpVirtualServer::Get
//
//	Description:
//
//		Gets server properties from the metabase.
//
//	Parameters:
//
//		(property) m_strServer
//		(property) m_dwServiceInstance - which NNTP to talk to.
//		pErr - Resulting error code.  This can be translated to a
//			string through the INntpAdmin interface.
//
//	Returns:
//
//		E_POINTER, DISP_E_EXCEPTION, E_OUTOFMEMORY or NOERROR.  
//		Additional error conditions are returned through the pErr value.
//
//--------------------------------------------------------------------

STDMETHODIMP CNntpVirtualServer::Get ( )
{
	TraceFunctEnter ( "CNntpVirtualServer::Get" );

	HRESULT								hr			= NOERROR;
	CComPtr<IMSAdminBase>				pmetabase;
	CComObject<CNntpServerBindings> *	pBindings	= NULL;

	// Validate Server & Service Instance:

	// Create the bindings collection:
	m_pBindings.Release ();

	hr = CComObject<CNntpServerBindings>::CreateInstance ( &pBindings );
	if ( FAILED(hr) ) {
		FatalTrace ( (LPARAM) this, "Could not create bindings collection" );
		goto Exit;
	}

	hr = pBindings->QueryInterface ( IID_INntpServerBindings, (void **) &m_pBindings );
	_ASSERT ( SUCCEEDED(hr) );
	if ( FAILED(hr) ) {
		goto Exit;
	}

	m_pPrivateBindings	= pBindings;

	// Talk to the metabase:
	hr = m_mbFactory.GetMetabaseObject ( m_strServer, &pmetabase );
	if ( FAILED(hr) ) {
		goto Exit;
	}

	hr = GetPropertiesFromMetabase ( pmetabase );
	if ( FAILED(hr) ) {
		goto Exit;
	}

	StateTrace ( 0, "Successfully got service properties" );
	m_fGotProperties	= TRUE;
	m_bvChangedFields	= 0;
	m_bvChangedFields2	= 0;

Exit:
	TRACE_HRESULT(hr);
	TraceFunctLeave ();
	return hr;

	// CComPtr automatically releases the metabase handle.
}

//$-------------------------------------------------------------------
//
//	CNntpVirtualServer::Set
//
//	Description:
//
//		Sends server properties to the metabase.
//
//	Parameters:
//
//		(property) m_strServer
//		fFailIfChanged - return an error if the metabase has changed?
//		pErr - Resulting error code.  This can be translated to a
//			string through the INntpAdmin interface.
//
//	Returns:
//
//		E_POINTER, DISP_E_EXCEPTION, E_OUTOFMEMORY or NOERROR.  
//		Additional error conditions are returned through the pErr value.
//
//--------------------------------------------------------------------

STDMETHODIMP CNntpVirtualServer::Set ( BOOL fFailIfChanged)
{
	TraceFunctEnter ( "CNntpVirtualServer::Set" );

	HRESULT	hr	= NOERROR;
	CComPtr<IMSAdminBase>	pmetabase;
	
	// Make sure the client call Get first:
	if ( !m_fGotProperties ) {
		ErrorTrace ( 0, "Didn't call get first" );
		return NntpCreateException ( IDS_NNTPEXCEPTION_DIDNT_CALL_GET );
	}

	// Validate Server & Service Instance:
	if ( m_dwServiceInstance == 0 ) {
		return NntpCreateException ( IDS_NNTPEXCEPTION_SERVICE_INSTANCE_CANT_BE_ZERO );
	}

	if ( !m_fGotProperties ) {
		return NntpCreateException ( IDS_NNTPEXCEPTION_DIDNT_CALL_GET );
	}

	// Validate data members:
	if ( !ValidateStrings () ) {
		// !!!magnush - what about the case when any strings are NULL?
		hr = E_OUTOFMEMORY;
		goto Exit;
	}

	if ( !ValidateProperties ( ) ) {
		hr = RETURNCODETOHRESULT ( ERROR_INVALID_PARAMETER );
		goto Exit;
	}

	hr = m_mbFactory.GetMetabaseObject ( m_strServer, &pmetabase );
	if ( FAILED(hr) ) {
		goto Exit;
	}

	hr = SendPropertiesToMetabase ( fFailIfChanged, pmetabase );
	if ( FAILED(hr) ) {
		goto Exit;
	}

	StateTrace ( 0, "Successfully set service properties" );

Exit:
	TRACE_HRESULT(hr);
	TraceFunctLeave ();
	return hr;
}

HRESULT CNntpVirtualServer::ControlService (
	IMSAdminBase *	pMetabase,
	DWORD			ControlCode,
	DWORD			dwDesiredState,
	DWORD			dwPendingState
	)
{
	TraceFunctEnter ( "CNntpVirtualServer::ControlService" );

	HRESULT	hr				= NOERROR;
	DWORD	dwCurrentState	= dwPendingState;
	DWORD	dwOldState		= dwPendingState;
	DWORD	dwSleepTotal	= 0;

	hr = CheckServiceState ( pMetabase, &dwCurrentState );
	BAIL_ON_FAILURE(hr);

	if ( dwCurrentState == dwDesiredState ) {
		// Nothing to do...
		goto Exit;
	}

	dwOldState	= dwCurrentState;

	//
	//	Special case: trying to start a paused service:
	//

	if ( dwDesiredState == MD_SERVER_STATE_STARTED &&
		dwCurrentState == MD_SERVER_STATE_PAUSED ) {

		ControlCode		= MD_SERVER_COMMAND_CONTINUE;
		dwPendingState	= MD_SERVER_STATE_CONTINUING;
	}
	
	hr = WriteStateCommand ( pMetabase, ControlCode );
	BAIL_ON_FAILURE(hr);

	for (	dwSleepTotal = 0, dwCurrentState = dwPendingState;
			(dwCurrentState == dwPendingState || dwCurrentState == dwOldState) && (dwSleepTotal < MAX_SLEEP_INST); 
			dwSleepTotal += SLEEP_INTERVAL
		) {

		Sleep ( SLEEP_INTERVAL );

		hr = CheckServiceState ( pMetabase, &dwCurrentState );
		BAIL_ON_FAILURE(hr);

        if ( m_dwWin32ErrorCode != NOERROR ) {
            //
            // The service gave an error code.
            //

            break;
        }
	}

	if ( dwSleepTotal >= MAX_SLEEP_INST ) {
		hr = HRESULT_FROM_WIN32 ( ERROR_SERVICE_REQUEST_TIMEOUT );
		goto Exit;
	}

Exit:
	m_State = TranslateServerState ( dwCurrentState );

	TraceFunctLeave ();
	return hr;
}

HRESULT CNntpVirtualServer::WriteStateCommand ( IMSAdminBase * pMetabase, DWORD ControlCode )
{
	HRESULT			hr	= NOERROR;
	CMetabaseKey	metabase	( pMetabase );
	WCHAR			wszInstancePath [ METADATA_MAX_NAME_LEN ];

	GetMDInstancePath ( wszInstancePath, m_dwServiceInstance );

	hr = metabase.Open ( wszInstancePath, METADATA_PERMISSION_WRITE );

	hr = StdPutMetabaseProp ( &metabase, MD_WIN32_ERROR, NOERROR, _T(""), IIS_MD_UT_SERVER, METADATA_VOLATILE );
	BAIL_ON_FAILURE (hr);

	hr = StdPutMetabaseProp ( &metabase, MD_SERVER_COMMAND, ControlCode );
	BAIL_ON_FAILURE (hr);

    hr = metabase.Save ();
    BAIL_ON_FAILURE(hr);

Exit:
	return hr;
}

HRESULT CNntpVirtualServer::CheckServiceState ( IMSAdminBase * pMetabase, DWORD * pdwState )
{
	HRESULT			hr	= NOERROR;
	CMetabaseKey	metabase ( pMetabase );
	WCHAR			wszInstancePath [ METADATA_MAX_NAME_LEN ];

	*pdwState	= MD_SERVER_STATE_INVALID;

	GetMDInstancePath ( wszInstancePath, m_dwServiceInstance );

	hr = metabase.Open ( wszInstancePath );
	BAIL_ON_FAILURE(hr);

	m_dwWin32ErrorCode = NOERROR;

	metabase.GetDword ( MD_SERVER_STATE, pdwState );
	metabase.GetDword ( MD_WIN32_ERROR, &m_dwWin32ErrorCode );

Exit:
	return hr;
}

STDMETHODIMP CNntpVirtualServer::Start ( )
{
	TraceFunctEnter ( "CNntpVirtualServer::Start" );

	HRESULT					hr		= NOERROR;
	CComPtr<IMSAdminBase>	pmetabase;

	hr = m_mbFactory.GetMetabaseObject ( m_strServer, &pmetabase );
	if ( FAILED(hr) ) {
		goto Exit;
	}

	hr = ControlService ( 
		pmetabase, 
		MD_SERVER_COMMAND_START, 
		MD_SERVER_STATE_STARTED, 
		MD_SERVER_STATE_STARTING 
		);

Exit:
	TraceFunctLeave ();
	return hr;
}

STDMETHODIMP CNntpVirtualServer::Pause ( )
{
	TraceFunctEnter ( "CNntpVirtualServer::Start" );

	HRESULT					hr		= NOERROR;
	CComPtr<IMSAdminBase>	pmetabase;

	hr = m_mbFactory.GetMetabaseObject ( m_strServer, &pmetabase );
	if ( FAILED(hr) ) {
		goto Exit;
	}

	hr = ControlService ( 
		pmetabase, 
		MD_SERVER_COMMAND_PAUSE, 
		MD_SERVER_STATE_PAUSED, 
		MD_SERVER_STATE_PAUSING 
		);

Exit:
	TraceFunctLeave ();
	return hr;
}

STDMETHODIMP CNntpVirtualServer::Continue ( )
{
	TraceFunctEnter ( "CNntpVirtualServer::Start" );

	HRESULT					hr		= NOERROR;
	CComPtr<IMSAdminBase>	pmetabase;

	hr = m_mbFactory.GetMetabaseObject ( m_strServer, &pmetabase );
	if ( FAILED(hr) ) {
		goto Exit;
	}

	hr = ControlService ( 
		pmetabase, 
		MD_SERVER_COMMAND_CONTINUE, 
		MD_SERVER_STATE_STARTED, 
		MD_SERVER_STATE_CONTINUING 
		);

Exit:
	TraceFunctLeave ();
	return hr;
}

STDMETHODIMP CNntpVirtualServer::Stop ( )
{
	TraceFunctEnter ( "CNntpVirtualServer::Start" );

	HRESULT					hr		= NOERROR;
	CComPtr<IMSAdminBase>	pmetabase;

	hr = m_mbFactory.GetMetabaseObject ( m_strServer, &pmetabase );
	if ( FAILED(hr) ) {
		goto Exit;
	}

	hr = ControlService ( 
		pmetabase, 
		MD_SERVER_COMMAND_STOP, 
		MD_SERVER_STATE_STOPPED, 
		MD_SERVER_STATE_STOPPING 
		);

Exit:
	TraceFunctLeave ();
	return hr;
}

//$-------------------------------------------------------------------
//
//	CNntpVirtualServer::GetPropertiesFromMetabase
//
//	Description:
//
//		Asks the metabase for each property in this class.
//		This class's properties come from /LM/NntpSvc/
//
//	Parameters:
//
//		pMetabase - The metabase object
//		pErr - Resulting error code.
//
//	Returns:
//
//		E_OUTOFMEMORY or an error code in pErr.
//
//--------------------------------------------------------------------

HRESULT CNntpVirtualServer::GetPropertiesFromMetabase ( IMSAdminBase * pMetabase)
{
	TraceFunctEnter ( "CNntpVirtualServer::GetPropertiesFromMetabase" );

	HRESULT			hr	= NOERROR;
	CMetabaseKey	metabase	( pMetabase );
	WCHAR			wszInstancePath [ METADATA_MAX_NAME_LEN ];
	DWORD			dwServerState	= MD_SERVER_STATE_STOPPED;
	CMultiSz		mszBindings;
	CMultiSz		mszSecureBindings;
	PSECURITY_DESCRIPTOR    pSD     = NULL;
	DWORD		            cbSD    = 0;
	BOOL					fRet;

	GetMDInstancePath ( wszInstancePath, m_dwServiceInstance );

	hr = metabase.Open ( wszInstancePath );

	if ( FAILED(hr) ) {
		ErrorTraceX ( (LPARAM) this, "Failed to open service instance key, %x", hr );

		// Return some kind of error code here:
//		hr = NntpCreateExceptionFromWin32Error ( hr );
		goto Exit;
	}

	fRet = TRUE;

	// Overridable server properties:
	fRet = StdGetMetabaseProp ( &metabase, MD_ARTICLE_TIME_LIMIT,	NNTP_DEF_ARTICLETIMELIMIT,		&m_dwArticleTimeLimit )		&& fRet;
	fRet = StdGetMetabaseProp ( &metabase, MD_HISTORY_EXPIRATION,	NNTP_DEF_HISTORYEXPIRATION,		&m_dwHistoryExpiration )	&& fRet;
	fRet = StdGetMetabaseProp ( &metabase, MD_HONOR_CLIENT_MSGIDS,	NNTP_DEF_HONORCLIENTMSGIDS,		&m_fHonorClientMsgIDs )		&& fRet;
	fRet = StdGetMetabaseProp ( &metabase, MD_SMTP_SERVER,			NNTP_DEF_SMTPSERVER,				&m_strSmtpServer )			&& fRet;
	fRet = StdGetMetabaseProp ( &metabase, MD_ADMIN_EMAIL,			NNTP_DEF_ADMIN_EMAIL,				&m_strAdminEmail )			&& fRet;
	fRet = StdGetMetabaseProp ( &metabase, MD_ALLOW_CLIENT_POSTS,	NNTP_DEF_ALLOWCLIENTPOSTS,		&m_fAllowClientPosts )		&& fRet;
	fRet = StdGetMetabaseProp ( &metabase, MD_ALLOW_FEED_POSTS,		NNTP_DEF_ALLOWFEEDPOSTS,			&m_fAllowFeedPosts )		&& fRet;
	fRet = StdGetMetabaseProp ( &metabase, MD_ALLOW_CONTROL_MSGS,	NNTP_DEF_ALLOWCONTROLMSGS,		&m_fAllowControlMsgs )		&& fRet;
	fRet = StdGetMetabaseProp ( &metabase, MD_DEFAULT_MODERATOR,	NNTP_DEF_DEFAULTMODERATORDOMAIN,	&m_strDefaultModeratorDomain )	&& fRet;
	fRet = StdGetMetabaseProp ( &metabase, MD_NNTP_COMMAND_LOG_MASK, NNTP_DEF_COMMANDLOGMASK,			&m_dwCommandLogMask )		&& fRet;
	fRet = StdGetMetabaseProp ( &metabase, MD_DISABLE_NEWNEWS,		NNTP_DEF_DISABLENEWNEWS,			&m_fDisableNewnews )		&& fRet;
	fRet = StdGetMetabaseProp ( &metabase, MD_NEWS_CRAWLER_TIME,	NNTP_DEF_NEWSCRAWLERTIME,		&m_dwExpireRunFrequency )	&& fRet;
	fRet = StdGetMetabaseProp ( &metabase, MD_SHUTDOWN_LATENCY,		NNTP_DEF_SHUTDOWNLATENCY,		&m_dwShutdownLatency )		&& fRet;
	fRet = StdGetMetabaseProp ( &metabase, MD_LOG_TYPE,				NNTP_DEF_ENABLE_LOGGING,		&m_fEnableLogging )			&& fRet;

	fRet = StdGetMetabaseProp ( &metabase, MD_CLIENT_POST_HARD_LIMIT,	NNTP_DEF_CLIENTPOSTHARDLIMIT,	&m_dwClientPostHardLimit )	&& fRet;
	fRet = StdGetMetabaseProp ( &metabase, MD_CLIENT_POST_SOFT_LIMIT,	NNTP_DEF_CLIENTPOSTSOFTLIMIT,	&m_dwClientPostSoftLimit )	&& fRet;
	fRet = StdGetMetabaseProp ( &metabase, MD_FEED_POST_HARD_LIMIT,		NNTP_DEF_FEEDPOSTHARDLIMIT,		&m_dwFeedPostHardLimit )	&& fRet;
	fRet = StdGetMetabaseProp ( &metabase, MD_FEED_POST_SOFT_LIMIT,		NNTP_DEF_FEEDPOSTSOFTLIMIT,		&m_dwFeedPostSoftLimit )	&& fRet;

	// Service-specific properties:
	fRet = StdGetMetabaseProp ( &metabase, MD_GROUP_HELP_FILE,		NNTP_DEF_GROUPHELPFILE,			&m_strGroupHelpFile )		&& fRet;
	fRet = StdGetMetabaseProp ( &metabase, MD_GROUP_LIST_FILE,		NNTP_DEF_GROUPLISTFILE,			&m_strGroupListFile )		&& fRet;
	fRet = StdGetMetabaseProp ( &metabase, MD_GROUPVAR_LIST_FILE,   NNTP_DEF_GROUPVARLISTFILE,      &m_strGroupVarListFile)     && fRet;
	fRet = StdGetMetabaseProp ( &metabase, MD_ARTICLE_TABLE_FILE,	NNTP_DEF_ARTICLETABLEFILE,		&m_strArticleTableFile )	&& fRet;
	fRet = StdGetMetabaseProp ( &metabase, MD_HISTORY_TABLE_FILE,	NNTP_DEF_HISTORYTABLEFILE,		&m_strHistoryTableFile )	&& fRet;
	fRet = StdGetMetabaseProp ( &metabase, MD_MODERATOR_FILE,		NNTP_DEF_MODERATORFILE,			&m_strModeratorFile )		&& fRet;
	fRet = StdGetMetabaseProp ( &metabase, MD_XOVER_TABLE_FILE,		NNTP_DEF_XOVERTABLEFILE,			&m_strXOverTableFile )		&& fRet;
	fRet = StdGetMetabaseProp ( &metabase, MD_NNTP_UUCP_NAME,		NNTP_DEF_UUCPNAME,				&m_strUucpName )			&& fRet;
	fRet = StdGetMetabaseProp ( &metabase, MD_NNTP_ORGANIZATION,	NNTP_DEF_ORGANIZATION,			&m_strOrganization )		&& fRet;
	fRet = StdGetMetabaseProp ( &metabase, MD_SERVER_AUTOSTART,		NNTP_DEF_AUTOSTART,				&m_fAutoStart )				&& fRet;

	fRet = StdGetMetabaseProp ( &metabase, MD_SERVER_COMMENT,		NNTP_DEF_COMMENT,				&m_strComment )				&& fRet;
#if 0
	fRet = StdGetMetabaseProp ( &metabase, MD_SECURE_PORT,			NNTP_DEF_SECUREPORT,				&m_dwSecurePort )			&& fRet;
#endif
	fRet = StdGetMetabaseProp ( &metabase, MD_MAX_CONNECTIONS,		NNTP_DEF_MAXCONNECTIONS,			&m_dwMaxConnections )		&& fRet;
	fRet = StdGetMetabaseProp ( &metabase, MD_CONNECTION_TIMEOUT,	NNTP_DEF_CONNECTIONTIMEOUT,		&m_dwConnectionTimeout )	&& fRet;
	fRet = StdGetMetabaseProp ( &metabase, MD_ANONYMOUS_USER_NAME,	NNTP_DEF_ANONYMOUSUSERNAME,		&m_strAnonymousUserName )	&& fRet;
	if ( fRet && !StdGetMetabaseProp ( &metabase, MD_ANONYMOUS_PWD,		NNTP_DEF_ANONYMOUSUSERPASS,		&m_strAnonymousUserPass, _T(""), IIS_MD_UT_FILE, METADATA_INHERIT | METADATA_SECURE ) ) {
		m_strAnonymousUserPass = _T("");
		fRet = TRUE;
	}
	fRet = StdGetMetabaseProp ( &metabase, MD_ANONYMOUS_USE_SUBAUTH,	FALSE,						&m_fAutoSyncPassword )		&& fRet;
	fRet = StdGetMetabaseProp ( &metabase, MD_PICKUP_DIRECTORY,		NNTP_DEF_PICKUPDIRECTORY,		&m_strPickupDirectory )		&& fRet;
	fRet = StdGetMetabaseProp ( &metabase, MD_FAILED_PICKUP_DIRECTORY,	NNTP_DEF_FAILEDPICKUPDIRECTORY,	&m_strFailedPickupDirectory )	&& fRet;

	fRet = StdGetMetabaseProp ( &metabase, MD_SERVER_STATE,			MD_SERVER_STATE_INVALID,		&dwServerState )			&& fRet;
	fRet = StdGetMetabaseProp ( &metabase, MD_SERVER_BINDINGS,		NNTP_DEF_BINDINGS,				&mszBindings )				&& fRet;
	fRet = StdGetMetabaseProp ( &metabase, MD_SECURE_BINDINGS,		NNTP_DEF_SECURE_BINDINGS,		&mszSecureBindings )		&& fRet;
	fRet = StdGetMetabaseProp ( &metabase, MD_WIN32_ERROR,			NOERROR,						&m_dwWin32ErrorCode,
			_T(""), IIS_MD_UT_SERVER, METADATA_VOLATILE)		&& fRet;

	fRet = StdGetMetabaseProp ( &metabase, MD_AUTHORIZATION,		NNTP_DEF_AUTHORIZATION,			&m_bvAuthorization )	&& fRet;
	fRet = StdGetMetabaseProp ( &metabase, MD_SSL_ACCESS_PERM,		0,								&m_bvSslAccess )		&& fRet;
//	fRet = StdGetMetabaseProp ( &metabase, MD_NTAUTHENTICATION_PROVIDERS,	NNTP_DEF_NTAUTHENTICATION_PROVIDERS,	&m_mszProviders ) && fRet;
	fRet = StdGetMetabaseProp ( &metabase, MD_CLUSTER_ENABLED,		NNTP_DEF_CLUSTERENABLED,		&m_fClusterEnabled )	&& fRet;

	//	Get the admin ACL
	pSD     = NULL;
	cbSD    = 0;

	hr = metabase.GetDataSize ( _T(""), MD_ADMIN_ACL, BINARY_METADATA, &cbSD );
	if ( SUCCEEDED(hr) ) {
		_ASSERT ( cbSD != 0 );
		pSD = (PSECURITY_DESCRIPTOR) new char [ cbSD ];
		hr = metabase.GetBinary ( MD_ADMIN_ACL, pSD, cbSD );
	}
	hr = NOERROR;

	//
	//	Get the tcp access restrictions:
	//

	hr = m_pPrivateIpAccess->GetFromMetabase ( &metabase );
	BAIL_ON_FAILURE(hr);

	// Check all property strings:
	// If any string is NULL, it is because we failed to allocate memory:
	if ( !ValidateStrings () || !mszBindings) {

		hr = E_OUTOFMEMORY;
		goto Exit;
	}

	// We can only fail from memory allocations:
	_ASSERT ( fRet );

	// Extract the server state:
	m_State = TranslateServerState ( dwServerState );

	// Save the last changed time for this key:
	m_ftLastChanged.dwHighDateTime	= 0;
	m_ftLastChanged.dwLowDateTime	= 0;

	hr = pMetabase->GetLastChangeTime ( metabase.QueryHandle(), _T(""), &m_ftLastChanged, FALSE );
	if ( FAILED (hr) ) {
		ErrorTraceX ( (LPARAM) this, "Failed to get last change time: %x", hr );
		// Ignore this error.
		hr = NOERROR;
	}

	metabase.Close();

	// Extract the bindings:
	hr = MDBindingsToIBindings ( &mszBindings, TRUE, m_pBindings );
	BAIL_ON_FAILURE(hr);

	hr = MDBindingsToIBindings ( &mszSecureBindings, FALSE, m_pBindings );
	BAIL_ON_FAILURE(hr);

	// Extract the Administrator list:
	if ( m_psaAdmins ) {
		SafeArrayDestroy ( m_psaAdmins );
		m_psaAdmins	= NULL;
	}
	if ( pSD ) {
		hr = AclToAdministrators ( m_strServer, pSD, &m_psaAdmins );
		BAIL_ON_FAILURE(hr);
	}

	// Validate the data received from the metabase:
	_ASSERT ( ValidateStrings () );
	_ASSERT ( ValidateProperties( ) );

	if ( !ValidateProperties( ) ) {
		CorrectProperties ();
	}

Exit:
	delete (char*) pSD;

	TraceFunctLeave ();
	return hr;

	// MB automatically closes its handle
}

//$-------------------------------------------------------------------
//
//	CNntpVirtualServer::SendPropertiesToMetabase
//
//	Description:
//
//		Saves each property to the metabase.
//		This class's properties go into /LM/NntpSvc/
//
//	Parameters:
//
//		fFailIfChanged	- Return a failure code if the metabase
//			has changed since last get.
//		pMetabase - the metabase object.
//		pErr - resulting error code.
//
//	Returns:
//
//		E_OUTOFMEMORY or resulting error code in pErr.
//
//--------------------------------------------------------------------

HRESULT CNntpVirtualServer::SendPropertiesToMetabase ( 
	BOOL fFailIfChanged, 
	IMSAdminBase * pMetabase
	)
{
	TraceFunctEnter ( "CNntpVirtualServer::SendPropertiesToMetabase" );

	HRESULT			hr	= NOERROR;
	CMetabaseKey	metabase	( pMetabase );
	WCHAR			wszInstancePath [ METADATA_MAX_NAME_LEN ];
	CMultiSz		mszBindings;
	CMultiSz		mszSecureBindings;
	BOOL			fRet;

	//
	//	Set the admin acl:
	//

	PSECURITY_DESCRIPTOR    pSD     = NULL;
	DWORD	                cbSD    = 0;

	if ( m_bvChangedFields2 & CHNG2_ADMINACL ) {
	    if ( m_psaAdmins ) {
		    hr = AdministratorsToAcl ( m_strServer, m_psaAdmins, &pSD, &cbSD );
		    BAIL_ON_FAILURE(hr);
	    }
	}

	//
	//	Open the metabase key:
	//

	GetMDInstancePath ( wszInstancePath, m_dwServiceInstance );

	hr = metabase.Open ( wszInstancePath, METADATA_PERMISSION_WRITE );
	if ( FAILED(hr) ) {
		ErrorTraceX ( (LPARAM) this, "Failed to open instance key, %x", hr );

		// !!!magnush - Should we return a simple Service doesn't exist error code?
//		hr = NntpCreateExceptionFromWin32Error ( GetLastError () );
		goto Exit;
	}

	// Does the client care if the key has changed?
	if ( fFailIfChanged ) {

		//	Did the key change?
		if ( HasKeyChanged ( pMetabase, metabase.QueryHandle(), &m_ftLastChanged ) ) {

			StateTrace ( (LPARAM) this, "Metabase has changed, not setting properties" );
			// !!!magnush - Return the appropriate error code:
			hr = E_FAIL;
			goto Exit;
		}
	}

	// Extract the bindings:
	hr = IBindingsToMDBindings ( m_pBindings, TRUE, &mszBindings );
	BAIL_ON_FAILURE(hr);

	hr = IBindingsToMDBindings ( m_pBindings, FALSE, &mszSecureBindings );
	BAIL_ON_FAILURE(hr);

	//
	//	The general procedure here is to keep setting metabase properties
	//	as long as nothing has gone wrong.  This is done by short-circuiting
	//	the statement by ANDing it with the status code.  This makes the code
	//	much more concise.
	//

	fRet = TRUE;

	// Overridable server properties:
	if ( m_bvChangedFields & CHNG_ARTICLETIMELIMIT ) {
		fRet = fRet && StdPutMetabaseProp ( &metabase, MD_ARTICLE_TIME_LIMIT,	m_dwArticleTimeLimit );
	}

	if ( m_bvChangedFields & CHNG_HISTORYEXPIRATION ) {
		fRet = fRet && StdPutMetabaseProp ( &metabase, MD_HISTORY_EXPIRATION,	m_dwHistoryExpiration );
	}

	if ( m_bvChangedFields & CHNG_HONORCLIENTMSGIDS ) {
		fRet = fRet && StdPutMetabaseProp ( &metabase, MD_HONOR_CLIENT_MSGIDS,	m_fHonorClientMsgIDs );
	}

	if ( m_bvChangedFields & CHNG_SMTPSERVER ) {
		fRet = fRet && StdPutMetabaseProp ( &metabase, MD_SMTP_SERVER,			m_strSmtpServer );
	}

	if ( m_bvChangedFields2 & CHNG2_ADMINEMAIL) {
		fRet = fRet && StdPutMetabaseProp ( &metabase, MD_ADMIN_EMAIL,			m_strAdminEmail );
	}

	if ( m_bvChangedFields & CHNG_ALLOWCLIENTPOSTS ) {
		fRet = fRet && StdPutMetabaseProp ( &metabase, MD_ALLOW_CLIENT_POSTS,	m_fAllowClientPosts );
	}

	if ( m_bvChangedFields & CHNG_ALLOWFEEDPOSTS ) {
		fRet = fRet && StdPutMetabaseProp ( &metabase, MD_ALLOW_FEED_POSTS,		m_fAllowFeedPosts );
	}

	if ( m_bvChangedFields & CHNG_ALLOWCONTROLMSGS ) {
		fRet = fRet && StdPutMetabaseProp ( &metabase, MD_ALLOW_CONTROL_MSGS,	m_fAllowControlMsgs );
	}

	if ( m_bvChangedFields & CHNG_DEFAULTMODERATORDOMAIN ) {
		fRet = fRet && StdPutMetabaseProp ( &metabase, MD_DEFAULT_MODERATOR,	m_strDefaultModeratorDomain );
	}

	if ( m_bvChangedFields & CHNG_COMMANDLOGMASK ) {
		fRet = fRet && StdPutMetabaseProp ( &metabase, MD_NNTP_COMMAND_LOG_MASK,m_dwCommandLogMask );
	}

	if ( m_bvChangedFields & CHNG_DISABLENEWNEWS ) {
		fRet = fRet && StdPutMetabaseProp ( &metabase, MD_DISABLE_NEWNEWS,		m_fDisableNewnews );
	}

	if ( m_bvChangedFields & CHNG_NEWSCRAWLERTIME ) {
		fRet = fRet && StdPutMetabaseProp ( &metabase, MD_NEWS_CRAWLER_TIME,	m_dwExpireRunFrequency );
	}

	if ( m_bvChangedFields & CHNG_SHUTDOWNLATENCY ) {
		fRet = fRet && StdPutMetabaseProp ( &metabase, MD_SHUTDOWN_LATENCY,		m_dwShutdownLatency );
	}

	if ( m_bvChangedFields & CHNG_CLIENTPOSTHARDLIMIT ) {
		fRet = fRet && StdPutMetabaseProp ( &metabase, MD_CLIENT_POST_HARD_LIMIT,	m_dwClientPostHardLimit );
	}

	if ( m_bvChangedFields & CHNG_CLIENTPOSTSOFTLIMIT ) {
		fRet = fRet && StdPutMetabaseProp ( &metabase, MD_CLIENT_POST_SOFT_LIMIT,	m_dwClientPostSoftLimit );
	}

	if ( m_bvChangedFields & CHNG_FEEDPOSTHARDLIMIT ) {
		fRet = fRet && StdPutMetabaseProp ( &metabase, MD_FEED_POST_HARD_LIMIT,		m_dwFeedPostHardLimit );
	}

	if ( m_bvChangedFields & CHNG_FEEDPOSTSOFTLIMIT ) {
		fRet = fRet && StdPutMetabaseProp ( &metabase, MD_FEED_POST_SOFT_LIMIT,		m_dwFeedPostSoftLimit );
	}

	if ( m_bvChangedFields2 & CHNG2_ENABLELOGGING ) {
		fRet = fRet && StdPutMetabaseProp ( &metabase, MD_LOG_TYPE,					m_fEnableLogging );
	}

	// Service specific properties:
	if ( m_bvChangedFields & CHNG_GROUPHELPFILE ) {
		fRet = fRet && StdPutMetabaseProp ( &metabase, MD_GROUP_HELP_FILE,		m_strGroupHelpFile );
	}

	if ( m_bvChangedFields & CHNG_GROUPLISTFILE ) {
		fRet = fRet && StdPutMetabaseProp ( &metabase, MD_GROUP_LIST_FILE,		m_strGroupListFile );
		// BUGBUG: we share this change field, since Magnus didn't leave more space for
		// change bit
		fRet = fRet && StdPutMetabaseProp ( &metabase, MD_GROUPVAR_LIST_FILE,   m_strGroupVarListFile );
	}

	if ( m_bvChangedFields & CHNG_ARTICLETABLEFILE ) {
		fRet = fRet && StdPutMetabaseProp ( &metabase, MD_ARTICLE_TABLE_FILE,	m_strArticleTableFile );
	}

	if ( m_bvChangedFields & CHNG_HISTORYTABLEFILE ) {
		fRet = fRet && StdPutMetabaseProp ( &metabase, MD_HISTORY_TABLE_FILE,	m_strHistoryTableFile );
	}

	if ( m_bvChangedFields & CHNG_MODERATORFILE ) {
		fRet = fRet && StdPutMetabaseProp ( &metabase, MD_MODERATOR_FILE,		m_strModeratorFile );
	}

	if ( m_bvChangedFields & CHNG_XOVERTABLEFILE ) {
		fRet = fRet && StdPutMetabaseProp ( &metabase, MD_XOVER_TABLE_FILE,		m_strXOverTableFile );
	}

	if ( m_bvChangedFields & CHNG_UUCPNAME ) {
		fRet = fRet && StdPutMetabaseProp ( &metabase, MD_NNTP_UUCP_NAME,		m_strUucpName );
	}

	if ( m_bvChangedFields & CHNG_ORGANIZATION ) {
		fRet = fRet && StdPutMetabaseProp ( &metabase, MD_NNTP_ORGANIZATION,	m_strOrganization );
	}

	if ( m_bvChangedFields & CHNG_AUTOSTART ) {
		fRet = fRet && StdPutMetabaseProp ( &metabase, MD_SERVER_AUTOSTART,		m_fAutoStart );
	}

	if ( m_bvChangedFields & CHNG_COMMENT ) {
		fRet = fRet && StdPutMetabaseProp ( &metabase, MD_SERVER_COMMENT,		m_strComment );
	}

#if 0
	if ( m_bvChangedFields & CHNG_SECUREPORT ) {
		fRet = fRet && StdPutMetabaseProp ( &metabase, MD_SECURE_PORT,			m_dwSecurePort );
	}
#endif

	if ( m_bvChangedFields & CHNG_MAXCONNECTIONS ) {
		fRet = fRet && StdPutMetabaseProp ( &metabase, MD_MAX_CONNECTIONS,		m_dwMaxConnections );
	}

	if ( m_bvChangedFields2 & CHNG2_CONNECTIONTIMEOUT ) {
		fRet = fRet && StdPutMetabaseProp ( &metabase, MD_CONNECTION_TIMEOUT,	m_dwConnectionTimeout );
	}

	if ( m_bvChangedFields2 & CHNG2_ANONYMOUSUSERNAME ) {
		fRet = fRet && StdPutMetabaseProp ( &metabase, MD_ANONYMOUS_USER_NAME,	m_strAnonymousUserName, _T(""), IIS_MD_UT_FILE );
	}

	if ( m_bvChangedFields2 & CHNG2_ANONYMOUSUSERPASS ) {
		fRet = fRet && StdPutMetabaseProp ( &metabase, MD_ANONYMOUS_PWD,		m_strAnonymousUserPass, _T(""), IIS_MD_UT_FILE, METADATA_INHERIT | METADATA_SECURE );
	}

	if ( m_bvChangedFields2 & CHNG2_AUTOSYNCPASSWORD ) {
		fRet = fRet && StdPutMetabaseProp ( &metabase, MD_ANONYMOUS_USE_SUBAUTH,	m_fAutoSyncPassword, _T(""), IIS_MD_UT_FILE );
	}

	if ( m_bvChangedFields2 & CHNG2_PICKUPDIRECTORY ) {
		fRet = fRet && StdPutMetabaseProp ( &metabase, MD_PICKUP_DIRECTORY,		m_strPickupDirectory );
	}

	if ( m_bvChangedFields2 & CHNG2_FAILEDPICKUPDIRECTORY ) {
		fRet = fRet && StdPutMetabaseProp ( &metabase, MD_FAILED_PICKUP_DIRECTORY,	m_strFailedPickupDirectory );
	}

	if ( m_bvChangedFields2 & CHNG2_CLUSTERENABLED ) {
		fRet = fRet && StdPutMetabaseProp ( &metabase, MD_CLUSTER_ENABLED,	m_fClusterEnabled );
	}

//	if ( m_bvChangedFields & CHNG_AUTHORIZATION ) {
		fRet = fRet && StdPutMetabaseProp ( &metabase, MD_AUTHORIZATION,		m_bvAuthorization, _T(""), IIS_MD_UT_FILE );
//	}

//	if ( m_bvChangedFields & CHNG2_SSLACCESS ) {
		fRet = fRet && StdPutMetabaseProp ( &metabase, MD_SSL_ACCESS_PERM,		m_bvSslAccess, _T(""), IIS_MD_UT_FILE );
//	}

//	if ( m_bvChangedFields & CHNG_NTAUTHENTICATION_PROVIDERS ) {
//		fRet = fRet && StdPutMetabaseProp ( &metabase, MD_NTAUTHENTICATION_PROVIDERS,	&m_mszProviders );
//	}

//	if ( m_bvChangedFields & CHNG_BINDINGS ) {
		fRet = fRet && StdPutMetabaseProp ( &metabase, MD_SERVER_BINDINGS,		&mszBindings );
//	}

//	if ( m_bvChangedFields & CHNG_SECURE_BINDINGS ) {
		fRet = fRet && StdPutMetabaseProp ( &metabase, MD_SECURE_BINDINGS,		&mszSecureBindings );
//	}

	if ( m_bvChangedFields2 & CHNG2_ADMINACL ) {
		if ( pSD ) {
		    if (fRet) {
		        hr = metabase.SetBinary ( MD_ADMIN_ACL, pSD, cbSD,
		            METADATA_INHERIT | METADATA_REFERENCE | METADATA_SECURE, IIS_MD_UT_FILE );
		        if (FAILED(hr)) {
		            fRet = FALSE;
		            goto Exit;
		        }
		    }
		}
		else {
			pMetabase->DeleteData ( metabase.QueryHandle(), _T(""), MD_ADMIN_ACL, BINARY_METADATA );
		}
	}

//	if ( m_bvChangedFields & CHNG_IPACCESS ) {
		hr = m_pPrivateIpAccess->SendToMetabase ( &metabase );
		BAIL_ON_FAILURE(hr);
//	}

	if ( !fRet ) {
		hr = RETURNCODETOHRESULT ( GetLastError () );
		goto Exit;
	}

	// Save the data to the metabase:
	hr = metabase.Save ();
    BAIL_ON_FAILURE(hr);

	// Save the last changed time for this key:
	m_ftLastChanged.dwHighDateTime	= 0;
	m_ftLastChanged.dwLowDateTime	= 0;

	hr = pMetabase->GetLastChangeTime ( metabase.QueryHandle(), _T(""), &m_ftLastChanged, FALSE );
	if ( FAILED (hr) ) {
		ErrorTraceX ( (LPARAM) this, "Failed to get last change time: %x", hr );
		// Ignore this error.
		hr = NOERROR;
	}

Exit:
	delete (char *) pSD;

	TraceFunctLeave ();
	return hr;

	// MB automatically closes its handle
}

//$-------------------------------------------------------------------
//
//	CNntpVirtualServer::ValidateStrings
//
//	Description:
//
//		Checks to make sure each string property is non-null.
//
//	Returns:
//
//		FALSE if any string property is NULL.
//
//--------------------------------------------------------------------

BOOL CNntpVirtualServer::ValidateStrings ( ) const
{
	TraceFunctEnter ( "CNntpVirtualServer::ValidateStrings" );

	// Check all property strings:
	// If any string is NULL, return FALSE:
	if ( 
		!m_strSmtpServer ||
		!m_strDefaultModeratorDomain	||
		!m_strGroupHelpFile		||
		!m_strGroupListFile		||
		!m_strGroupVarListFile  ||
		!m_strArticleTableFile	||
		!m_strHistoryTableFile	||
		!m_strModeratorFile		||
		!m_strXOverTableFile	||
		!m_strUucpName			||
		!m_strOrganization		||
		!m_strComment			||
		!m_strAnonymousUserName	||
		!m_strAnonymousUserPass ||
		!m_strPickupDirectory	||
		!m_strFailedPickupDirectory
		) {

		ErrorTrace ( (LPARAM) this, "String validation failed" );

		TraceFunctLeave ();
		return FALSE;
	}

	_ASSERT ( IS_VALID_STRING ( m_strSmtpServer ) );
	_ASSERT ( IS_VALID_STRING ( m_strDefaultModeratorDomain ) );
	_ASSERT ( IS_VALID_STRING ( m_strGroupHelpFile ) );
	_ASSERT ( IS_VALID_STRING ( m_strGroupListFile ) );
	_ASSERT ( IS_VALID_STRING ( m_strGroupVarListFile ) );
	_ASSERT ( IS_VALID_STRING ( m_strArticleTableFile ) );
	_ASSERT ( IS_VALID_STRING ( m_strHistoryTableFile ) );
	_ASSERT ( IS_VALID_STRING ( m_strModeratorFile ) );
	_ASSERT ( IS_VALID_STRING ( m_strXOverTableFile ) );
	_ASSERT ( IS_VALID_STRING ( m_strUucpName ) );
	_ASSERT ( IS_VALID_STRING ( m_strOrganization ) );
	_ASSERT ( IS_VALID_STRING ( m_strComment ) );
	_ASSERT ( IS_VALID_STRING ( m_strAnonymousUserName ) );
	_ASSERT ( IS_VALID_STRING ( m_strAnonymousUserPass ) );
	_ASSERT ( IS_VALID_STRING ( m_strPickupDirectory ) );
	_ASSERT ( IS_VALID_STRING ( m_strFailedPickupDirectory ) );

	TraceFunctLeave ();
	return TRUE;
}

//$-------------------------------------------------------------------
//
//	CNntpVirtualServer::ValidateProperties
//
//	Description:
//
//		Checks to make sure all parameters are valid.
//
//	Parameters:
//
//		pErr - resulting error code.
//
//	Returns:
//
//		FALSE if any property was not valid.  In this case pErr
//		will contain an error that describes the invalid condition.
//
//--------------------------------------------------------------------

BOOL CNntpVirtualServer::ValidateProperties ( ) const
{
	BOOL	fRet	= TRUE;
	
	_ASSERT ( ValidateStrings () );

	fRet = fRet && PV_MinMax	( m_dwArticleTimeLimit, MIN_ARTICLETIMELIMIT, MAX_ARTICLETIMELIMIT );
	fRet = fRet && PV_MinMax	( m_dwHistoryExpiration, MIN_HISTORYEXPIRATION, MAX_HISTORYEXPIRATION );
	fRet = fRet && PV_Boolean	( m_fHonorClientMsgIDs );
	fRet = fRet && PV_MaxChars	( m_strSmtpServer, MAXLEN_SMTPSERVER );
	fRet = fRet && PV_Boolean	( m_fAllowClientPosts );
	fRet = fRet && PV_Boolean	( m_fAllowFeedPosts );
	fRet = fRet && PV_Boolean	( m_fAllowControlMsgs );
	fRet = fRet && PV_MaxChars	( m_strDefaultModeratorDomain, MAXLEN_DEFAULTMODERATORDOMAIN );
	fRet = fRet && PV_MinMax	( m_dwCommandLogMask, MIN_COMMANDLOGMASK, MAX_COMMANDLOGMASK );
	fRet = fRet && PV_Boolean	( m_fDisableNewnews );
	fRet = fRet && PV_MinMax	( m_dwExpireRunFrequency, MIN_NEWSCRAWLERTIME, MAX_NEWSCRAWLERTIME );
	fRet = fRet && PV_MinMax	( m_dwShutdownLatency, MIN_SHUTDOWNLATENCY, MAX_SHUTDOWNLATENCY );
	fRet = fRet && PV_Boolean	( m_fAutoStart );
	fRet = fRet && PV_Boolean	( m_fClusterEnabled );

	return fRet;
}

void CNntpVirtualServer::CorrectProperties ( )
{
	if ( m_strServer && !PV_MaxChars	( m_strServer, MAXLEN_SERVER ) ) {
		m_strServer[ MAXLEN_SERVER - 1 ] = NULL;
	}
	if ( !PV_MinMax	( m_dwArticleTimeLimit, MIN_ARTICLETIMELIMIT, MAX_ARTICLETIMELIMIT ) ) {
		m_dwArticleTimeLimit	= NNTP_DEF_ARTICLETIMELIMIT;
	}
	if ( !PV_MinMax	( m_dwHistoryExpiration, MIN_HISTORYEXPIRATION, MAX_HISTORYEXPIRATION ) ) {
		m_dwHistoryExpiration	= NNTP_DEF_HISTORYEXPIRATION;
	}
	if ( !PV_Boolean	( m_fHonorClientMsgIDs ) ) {
		m_fHonorClientMsgIDs	= !!m_fHonorClientMsgIDs;
	}
	if ( !PV_MaxChars	( m_strSmtpServer, MAXLEN_SMTPSERVER ) ) {
		m_strSmtpServer[ MAXLEN_SMTPSERVER - 1 ] = NULL;
	}
	if ( !PV_Boolean	( m_fAllowClientPosts ) ) {
		m_fAllowClientPosts	= !!m_fAllowClientPosts;
	}
	if ( !PV_Boolean	( m_fAllowFeedPosts ) ) {
		m_fAllowFeedPosts	= !!m_fAllowFeedPosts;
	}
	if ( !PV_Boolean	( m_fAllowControlMsgs ) ) {
		m_fAllowControlMsgs	= !!m_fAllowControlMsgs;
	}
	if ( !PV_MaxChars	( m_strDefaultModeratorDomain, MAXLEN_DEFAULTMODERATORDOMAIN ) ) {
		m_strDefaultModeratorDomain[ MAXLEN_DEFAULTMODERATORDOMAIN - 1] = NULL;
	}
	if ( !PV_MinMax	( m_dwCommandLogMask, MIN_COMMANDLOGMASK, MAX_COMMANDLOGMASK ) ) {
		m_dwCommandLogMask	= NNTP_DEF_COMMANDLOGMASK;
	}
	if ( !PV_Boolean	( m_fDisableNewnews ) ) {
		m_fDisableNewnews	= !!m_fDisableNewnews;
	}
	if ( !PV_MinMax	( m_dwExpireRunFrequency, MIN_NEWSCRAWLERTIME, MAX_NEWSCRAWLERTIME ) ) {
		m_dwExpireRunFrequency	= NNTP_DEF_NEWSCRAWLERTIME;
	}
	if ( !PV_MinMax	( m_dwShutdownLatency, MIN_SHUTDOWNLATENCY, MAX_SHUTDOWNLATENCY ) ) {
		m_dwShutdownLatency		= NNTP_DEF_SHUTDOWNLATENCY;
	}
	if ( !PV_Boolean	( m_fAutoStart ) ) {
		m_fAutoStart		= !!m_fAutoStart;
	}
	if ( !PV_Boolean	( m_fClusterEnabled ) ) {
		m_fClusterEnabled	= !!m_fClusterEnabled;
	}

	_ASSERT ( ValidateProperties ( ) );
}

NNTP_SERVER_STATE CNntpVirtualServer::TranslateServerState ( DWORD dwState )
{
	NNTP_SERVER_STATE	result	= NNTP_SERVER_STATE_UNKNOWN;

	switch ( dwState ) {
	case MD_SERVER_STATE_STARTING:
		result	= NNTP_SERVER_STATE_STARTING;
		break;

	case MD_SERVER_STATE_STARTED:
		result	= NNTP_SERVER_STATE_STARTED;
		break;

	case MD_SERVER_STATE_STOPPING:
		result	= NNTP_SERVER_STATE_STOPPING;
		break;

	case MD_SERVER_STATE_STOPPED:
		result	= NNTP_SERVER_STATE_STOPPED;
		break;

	case MD_SERVER_STATE_PAUSING:
		result	= NNTP_SERVER_STATE_PAUSING;
		break;

	case MD_SERVER_STATE_PAUSED:
		result	= NNTP_SERVER_STATE_PAUSED;
		break;

	case MD_SERVER_STATE_CONTINUING:
		result	= NNTP_SERVER_STATE_CONTINUING;
		break;

	case MD_SERVER_STATE_INVALID:
		result	= NNTP_SERVER_STATE_UNKNOWN;
		break;

	default:
		_ASSERT ( FALSE );
		break;
	}

	return result;
}

HRESULT AclToAdministrators ( LPCTSTR strServer, PSECURITY_DESCRIPTOR pSDRelative, SAFEARRAY ** ppsaAdmins )
{
    HRESULT         hr          = NOERROR;
    SAFEARRAY *     psaResult   = NULL;
    SAFEARRAYBOUND  rgsaBound[1];
    DWORD           cbAcl;
    long            cValidAdmins;
    long            cAdmins;
    long            i;
    long            iValid;

    PSECURITY_DESCRIPTOR pSD = NULL;
    PACL pAcl;
    BOOL fDaclPresent;
    BOOL fDaclDef;

    pSD = (PSECURITY_DESCRIPTOR)pSDRelative;
    if (pSD == NULL)
    {
        //
        // Empty...
        //
        return ERROR_SUCCESS;
    }

    if (!IsValidSecurityDescriptor(pSD))
    {
        return GetLastError();
    }

    _VERIFY(GetSecurityDescriptorDacl(pSD, &fDaclPresent, &pAcl, &fDaclDef));
    if (!fDaclPresent || pAcl == NULL)
    {
        return ERROR_SUCCESS;
    }

    if (!IsValidAcl(pAcl))
    {
        return GetLastError();
    }

    cAdmins = pAcl->AceCount;
    cbAcl   = pAcl->AclSize;

    //
    //  Count valid Acls:
    //

    for ( cValidAdmins = 0, i = 0; i < cAdmins; i++ ) {
        PVOID           pAce;
        PACE_HEADER     pAceHeader;

        if ( GetAce(pAcl, i, &pAce) ) {
            pAceHeader = (PACE_HEADER)pAce;

            if ( pAceHeader->AceType == ACCESS_ALLOWED_ACE_TYPE ) {
                ACCESS_MASK AccessMask;

                AccessMask = ((PACCESS_ALLOWED_ACE)pAce)->Mask;

                if ( AccessMask & FILE_GENERIC_WRITE ) {
                    // Only count admins with write access.

                    cValidAdmins++;
                }
            }
        }
    }

    rgsaBound[0].lLbound    = 0;
    rgsaBound[0].cElements  = cValidAdmins;
    psaResult = SafeArrayCreate ( VT_BSTR, 1, rgsaBound );

    if ( !psaResult ) {
        BAIL_WITH_FAILURE ( hr, E_OUTOFMEMORY );
    }

    for ( iValid = 0, i = 0; i < cAdmins; i++ ) {
        PVOID           pAce;
        PACE_HEADER     pAceHeader;
        PSID            pSID;

        if ( GetAce(pAcl, i, &pAce) ) {
            pAceHeader = (PACE_HEADER)pAce;

            if ( pAceHeader->AceType == ACCESS_ALLOWED_ACE_TYPE ) {
                ACCESS_MASK AccessMask;

                AccessMask = ((PACCESS_ALLOWED_ACE)pAce)->Mask;

                if ( AccessMask & FILE_GENERIC_WRITE ) {
                    CComBSTR    str;
                    pSID = (PSID)&((PACCESS_ALLOWED_ACE)pAce)->SidStart;

                    hr = SidToString ( strServer, pSID, &str );
                    BAIL_ON_FAILURE(hr);

                    hr = SafeArrayPutElement ( psaResult, &iValid, (PVOID) str );
                    BAIL_ON_FAILURE(hr);

                    iValid++;
                }
            }
        }
    }

    if ( *ppsaAdmins ) {
        SafeArrayDestroy ( *ppsaAdmins );
    }
    *ppsaAdmins = psaResult;

Exit:
    return hr;
}


PSID
GetOwnerSID()
/*++

Routine Description:

Arguments:

Return Value:

    Owner sid

--*/
{
    PSID pSID = NULL;

    SID_IDENTIFIER_AUTHORITY NtAuthority = SECURITY_NT_AUTHORITY;
    if (!AllocateAndInitializeSid(
        &NtAuthority,
        2,
        SECURITY_BUILTIN_DOMAIN_RID,
        DOMAIN_ALIAS_RID_ADMINS,
        0, 0, 0, 0, 0, 0,
        &pSID))
    {
        _ASSERT( 0 );
        //TRACEEOLID("Unable to get primary SID " << ::GetLastError());
    }

    return pSID;
}


HRESULT AdministratorsToAcl ( 
    LPCTSTR     strServer,
    SAFEARRAY * psaAdmins, 
    PSECURITY_DESCRIPTOR* ppSD, 
    DWORD * pcbSD 
    )
{
    HRESULT     hr  = NOERROR;
    long        lBound;
    long        uBound;
    long        i;
    BOOL        fRet;
    DWORD       cbAcl;
    PACL        pAclResult  = NULL;
    PSID        pSID;

    *ppSD   = NULL;
    *pcbSD  = 0;

    if ( psaAdmins == NULL ) {
        lBound = 0;
        uBound = -1;
    }
    else {
        SafeArrayGetLBound ( psaAdmins, 1, &lBound );
        SafeArrayGetUBound ( psaAdmins, 1, &uBound );
    }

    // Do we have an array of Domain\Usernames?
    if ( lBound > uBound ) {
        // Nothing in the array, so the ACL is NULL.
        goto Exit;
    }

    //
    // Calculate ACL size:
    //
    cbAcl = sizeof (ACL);

    for ( i = lBound; i <= uBound ; i++ ) {
        CComBSTR    str;

        pSID = NULL;

        SafeArrayGetElement ( psaAdmins, &i, &str );

        hr = StringToSid ( strServer, str, &pSID );

        if ( SUCCEEDED(hr) && IsValidSid(pSID)) {
            cbAcl += GetLengthSid ( pSID );
            cbAcl += sizeof ( ACCESS_ALLOWED_ACE );
            cbAcl -= sizeof (DWORD);
        }
        hr = NOERROR;

        delete pSID;
    }

    pAclResult = (PACL) new char [ cbAcl ];
    if ( !pAclResult ) {
        BAIL_WITH_FAILURE(hr, E_OUTOFMEMORY);
    }

    fRet = InitializeAcl ( pAclResult, cbAcl, ACL_REVISION );
    _ASSERT ( fRet );
    if ( !fRet ) {
        BAIL_WITH_FAILURE(hr, RETURNCODETOHRESULT(GetLastError() ) );
    }

    //
    //  Create ACL:
    //
    for ( i = lBound; i <= uBound; i++ ) {
        CComBSTR    str;
        PSID        pSID;

        pSID = NULL;

        SafeArrayGetElement ( psaAdmins, &i, &str );

        hr = StringToSid ( strServer, str, &pSID );
        if ( SUCCEEDED(hr) ) {
            fRet = AddAccessAllowedAce ( 
                pAclResult, 
                ACL_REVISION, 
                FILE_GENERIC_READ | FILE_GENERIC_WRITE | FILE_GENERIC_EXECUTE,
                pSID
                );

            if ( !fRet ) {
                BAIL_WITH_FAILURE(hr, RETURNCODETOHRESULT(GetLastError() ) );
            }
        }
        hr = NOERROR;

        delete pSID;
    }

    //
    // Build the security descriptor
    //
    PSECURITY_DESCRIPTOR pSD;
    pSD = new char[SECURITY_DESCRIPTOR_MIN_LENGTH];
    _VERIFY(InitializeSecurityDescriptor(pSD, SECURITY_DESCRIPTOR_REVISION));
    _VERIFY(SetSecurityDescriptorDacl(pSD, TRUE, pAclResult, FALSE));

    //
    // Set owner and primary group
    //
    pSID = GetOwnerSID();
    _ASSERT(pSID);
    _VERIFY(SetSecurityDescriptorOwner(pSD, pSID, TRUE));
    _VERIFY(SetSecurityDescriptorGroup(pSD, pSID, TRUE));

    //
    // Convert to self-relative
    //
    PSECURITY_DESCRIPTOR pSDSelfRelative;
    pSDSelfRelative = NULL;
    DWORD dwSize;
    dwSize = 0L;
    MakeSelfRelativeSD(pSD, pSDSelfRelative, &dwSize);
    pSDSelfRelative = new char[dwSize]; 
    MakeSelfRelativeSD(pSD, pSDSelfRelative, &dwSize);

    //
    // Clean up
    //
    delete (char*)pSD;
    FreeSid( pSID );


    _ASSERT ( SUCCEEDED(hr) );
    *ppSD   = pSDSelfRelative;
    *pcbSD  = dwSize;

Exit:
    if ( FAILED(hr) ) {
        delete pAclResult;
    }
    return hr;
}

HRESULT SidToString ( LPCWSTR strSystemName, PSID pSID, BSTR * pStr )
{
	HRESULT			hr 				= NOERROR;
	BOOL			fLookup;
	SID_NAME_USE	SidToNameUse;
	WCHAR			wszUsername [ PATHLEN ];
	DWORD			cbUsername		= sizeof ( wszUsername );
	WCHAR			wszDomain [ PATHLEN ];
	DWORD			cbDomain		= sizeof ( wszDomain );
	WCHAR			wszResult [ 2 * PATHLEN + 2 ];
	LPWSTR			pwszSid = NULL;

	fLookup = LookupAccountSid ( 
		strSystemName,
		pSID,
		wszUsername,
		&cbUsername,
		wszDomain,
		&cbDomain,
		&SidToNameUse
		);
		
	if ( !fLookup && GetLastError() != ERROR_NONE_MAPPED) {
		BAIL_WITH_FAILURE(hr, RETURNCODETOHRESULT (GetLastError ()) );
	}

	if (fLookup) {
		wsprintf ( wszResult, _T("%s\\%s"), wszDomain, wszUsername );
	} else {
		// Couldn't get the username.  Convert it to a string of the form .\S-1-5-xxx
		if (!ConvertSidToStringSid(pSID, &pwszSid)) {
			BAIL_WITH_FAILURE(hr, RETURNCODETOHRESULT (GetLastError ()) );
		}
		wsprintf(wszResult, _T(".\\%s"), pwszSid);
	}

	*pStr = ::SysAllocString ( wszResult );
	if (*pStr == NULL)
		hr = E_OUTOFMEMORY;

Exit:
	if (pwszSid) {
		LocalFree(pwszSid);
	}

	return hr;
}

HRESULT StringToSid ( LPCWSTR strSystemName, LPWSTR str, PSID * ppSID )
{
	HRESULT			hr	= NOERROR;
	BOOL			fLookup;
	WCHAR			wszRefDomain[PATHLEN];
	DWORD			cbRefDomain = sizeof ( wszRefDomain );
	DWORD			cbSid = 0;
	SID_NAME_USE	SidNameUse;
	BOOL			fIsSID = FALSE;
	PSID			pSID = NULL;

	*ppSID = NULL;

	//
	// If the string starts with .\, then a SID follows rather than a domain\user
	//

	if (str[0] == L'.' && str[1] == L'\\') {
		fIsSID = TRUE;
		str+=2;
	}

    if ( str[0] == '\\' ) {
        //
        //  Skip the initial \, this is for BUILTIN usernames:
        //

        str++;
    }

    _ASSERT ( str[0] != '\\' );

    if (fIsSID) {
    	if (!ConvertStringSidToSid(str, &pSID))
    		BAIL_WITH_FAILURE(hr, RETURNCODETOHRESULT(GetLastError()));

    	cbSid = GetLengthSid(pSID);
		*ppSID = (LPVOID) new char [ cbSid ];
		if ( !*ppSID ) {
			BAIL_WITH_FAILURE(hr, E_OUTOFMEMORY);
		}

		memcpy(*ppSID, pSID, cbSid);

    } else {

		fLookup = LookupAccountName	(
			strSystemName,
			str,
			*ppSID,
			&cbSid,
			wszRefDomain,
			&cbRefDomain,
			&SidNameUse
			);

		// First lookup will fail, but the size will be right:
		if ( GetLastError() != ERROR_INSUFFICIENT_BUFFER ) {
			BAIL_WITH_FAILURE(hr, RETURNCODETOHRESULT ( GetLastError () ) );
		}

		*ppSID = (LPVOID) new char [ cbSid ];
		if ( !*ppSID ) {
			BAIL_WITH_FAILURE(hr, E_OUTOFMEMORY);
		}

		fLookup = LookupAccountName	(
			strSystemName,
			str,
			*ppSID,
			&cbSid,
			wszRefDomain,
			&cbRefDomain,
			&SidNameUse
			);
    }

	if ( !fLookup ) {
		BAIL_WITH_FAILURE(hr, RETURNCODETOHRESULT ( GetLastError () ) );
	}

Exit:
	if (pSID) {
		LocalFree(pSID);
	}

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\nntp\adminsso\server.h ===
// server.h : Declaration of the CNntpVirtualServer


/////////////////////////////////////////////////////////////////////////////
// Dependencies:

#include "metafact.h"
#include "binding.h"
#include "vroots.h"
#include "ipaccess.h"

/////////////////////////////////////////////////////////////////////////////
// nntpadm

class CNntpVirtualServer : 
	public CComDualImpl<INntpVirtualServer, &IID_INntpVirtualServer, &LIBID_NNTPADMLib>, 
	public ISupportErrorInfo,
	public CComObjectRoot,
	public CComCoClass<CNntpVirtualServer,&CLSID_CNntpVirtualServer>
{
public:
	CNntpVirtualServer();
	virtual ~CNntpVirtualServer ();
	
BEGIN_COM_MAP(CNntpVirtualServer)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(INntpVirtualServer)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()
//DECLARE_NOT_AGGREGATABLE(CNntpVirtualServer) 
// Remove the comment from the line above if you don't want your object to 
// support aggregation.  The default is to support it

DECLARE_REGISTRY(CNntpVirtualServer, _T("Nntpadm.VirtualServer.1"), _T("Nntpadm.VirtualServer"), IDS_NNTPADMINSERVICE_DESC, THREADFLAGS_BOTH)
// ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

// INntpVirtualServer
public:

	//////////////////////////////////////////////////////////////////////
	// Properties:
	//////////////////////////////////////////////////////////////////////

	// Which service to configure:
	
	STDMETHODIMP	get_Server		( BSTR * pstrServer );
	STDMETHODIMP	put_Server		( BSTR strServer );

	STDMETHODIMP	get_ServiceInstance	( long * plServiceInstance );
	STDMETHODIMP	put_ServiceInstance	( long lServiceInstance );

	// Other admin interfaces for virtual server:

	STDMETHODIMP	get_FeedsAdmin		( IDispatch ** ppIDispatch );
	STDMETHODIMP	get_GroupsAdmin		( IDispatch ** ppIDispatch );
	STDMETHODIMP	get_SessionsAdmin	( IDispatch ** ppIDispatch );
	STDMETHODIMP	get_ExpirationAdmin	( IDispatch ** ppIDispatch );
	STDMETHODIMP	get_RebuildAdmin	( IDispatch ** ppIDispatch );

	STDMETHODIMP	get_VirtualRoots	( INntpVirtualRoots ** ppVirtualRoots );
	STDMETHODIMP	get_VirtualRootsDispatch	( IDispatch ** ppVirtualRoots );

	STDMETHODIMP	get_TcpAccess ( ITcpAccess ** ppTcpAccess );
/*
	STDMETHODIMP	get_HomeDirectory	( INntpVirtualRoot ** ppVirtualRoot );
	STDMETHODIMP	put_HomeDirectory	( INntpVirtualRoot * pVirtualRoot );
*/

	// Overridable server properties:

	STDMETHODIMP	get_ArticleTimeLimit	( long * plArticleTimeLimit );
	STDMETHODIMP	put_ArticleTimeLimit	( long lArticleTimeLimit );

	STDMETHODIMP	get_HistoryExpiration	( long * plHistoryExpiration );
	STDMETHODIMP	put_HistoryExpiration	( long lHistoryExpiration );

	STDMETHODIMP	get_HonorClientMsgIDs	( BOOL * pfHonorClientMsgIDs );
	STDMETHODIMP	put_HonorClientMsgIDs	( BOOL fHonorClientMsgIDs );

	STDMETHODIMP	get_SmtpServer	( BSTR * pstrSmtpServer );
	STDMETHODIMP	put_SmtpServer	( BSTR strSmtpServer );

	STDMETHODIMP	get_AdminEmail ( BSTR * pstrAdminEmail );
	STDMETHODIMP	put_AdminEmail ( BSTR strAdminEmail );

	STDMETHODIMP	get_AllowClientPosts	( BOOL * pfAllowClientPosts );
	STDMETHODIMP	put_AllowClientPosts	( BOOL fAllowClientPosts );

	STDMETHODIMP	get_AllowFeedPosts	( BOOL * pfAllowFeedPosts );
	STDMETHODIMP	put_AllowFeedPosts	( BOOL fAllowFeedPosts );

	STDMETHODIMP	get_ClientPostHardLimit ( long * plClientPostHardLimit );
	STDMETHODIMP	put_ClientPostHardLimit ( long lClientPostHardLimit );

	STDMETHODIMP	get_ClientPostSoftLimit ( long * plClientPostSoftLimit );
	STDMETHODIMP	put_ClientPostSoftLimit ( long lClientPostSoftLimit );

	STDMETHODIMP	get_FeedPostHardLimit ( long * plFeedPostHardLimit );
	STDMETHODIMP	put_FeedPostHardLimit ( long lFeedPostHardLimit );

	STDMETHODIMP	get_FeedPostSoftLimit ( long * plFeedPostSoftLimit );
	STDMETHODIMP	put_FeedPostSoftLimit ( long lFeedPostSoftLimit );

	STDMETHODIMP	get_AllowControlMsgs	( BOOL * pfAllowControlMsgs );
	STDMETHODIMP	put_AllowControlMsgs	( BOOL fAllowControlMsgs );

	STDMETHODIMP	get_DefaultModeratorDomain	( BSTR * pstrDefaultModeratorDomain );
	STDMETHODIMP	put_DefaultModeratorDomain	( BSTR strDefaultModeratorDomain );

	STDMETHODIMP	get_CommandLogMask	( long * plCommandLogMask );
	STDMETHODIMP	put_CommandLogMask	( long lCommandLogMask );

	STDMETHODIMP	get_DisableNewnews	( BOOL * pfDisableNewnews );
	STDMETHODIMP	put_DisableNewnews	( BOOL fDisableNewnews );

	STDMETHODIMP	get_ExpireRunFrequency	( long * plExpireRunFrequency );
	STDMETHODIMP	put_ExpireRunFrequency	( long lExpireRunFrequency );

	STDMETHODIMP	get_ShutdownLatency	( long * plShutdownLatency );
	STDMETHODIMP	put_ShutdownLatency	( long lShutdownLatency );

	STDMETHODIMP	get_EnableLogging	( BOOL * pfEnableLogging );
	STDMETHODIMP	put_EnableLogging	( BOOL fEnableLogging );
	
	// Service Properties:
	STDMETHODIMP	get_Organization ( BSTR * pstrOrganization );
	STDMETHODIMP	put_Organization ( BSTR strOrganization );

	STDMETHODIMP	get_UucpName ( BSTR * pstrUucpName );
	STDMETHODIMP	put_UucpName ( BSTR strUucpName );

	STDMETHODIMP	get_GroupHelpFile	( BSTR * pstrGroupHelpFile );
	STDMETHODIMP	put_GroupHelpFile	( BSTR strGroupHelpFile );

	STDMETHODIMP	get_GroupListFile	( BSTR * pstrGroupListFile );
	STDMETHODIMP	put_GroupListFile	( BSTR strGroupListFile );

	STDMETHODIMP    get_GroupVarListFile ( BSTR *pstrGroupVarListFile );
	STDMETHODIMP    put_GroupVarListFile ( BSTR strGroupVarListFile );

	STDMETHODIMP	get_ArticleTableFile	( BSTR * pstrArticleTableFile );
	STDMETHODIMP	put_ArticleTableFile	( BSTR strArticleTableFile );

	STDMETHODIMP	get_HistoryTableFile	( BSTR * pstrHistoryTableFile );
	STDMETHODIMP	put_HistoryTableFile	( BSTR strHistoryTableFile );

	STDMETHODIMP	get_ModeratorFile	( BSTR * pstrModeratorFile );
	STDMETHODIMP	put_ModeratorFile	( BSTR strModeratorFile );

	STDMETHODIMP	get_XOverTableFile	( BSTR * pstrXOverTableFile );
	STDMETHODIMP	put_XOverTableFile	( BSTR strXOverTableFile );

	STDMETHODIMP	get_AutoStart	( BOOL * pfAutoStart );
	STDMETHODIMP	put_AutoStart	( BOOL fAutoStart );

	STDMETHODIMP	get_Comment	( BSTR * pstrComment );
	STDMETHODIMP	put_Comment	( BSTR strComment );

	STDMETHODIMP	get_Bindings	( INntpServerBindings ** ppBindings );
	STDMETHODIMP	get_BindingsDispatch ( IDispatch ** ppDispatch );

	STDMETHODIMP	get_SecurePort	( long * pdwSecurePort );
	STDMETHODIMP	put_SecurePort	( long dwSecurePort );

	STDMETHODIMP	get_MaxConnections	( long * pdwMaxConnections );
	STDMETHODIMP	put_MaxConnections	( long dwMaxConnections );

	STDMETHODIMP	get_ConnectionTimeout	( long * pdwConnectionTimeout );
	STDMETHODIMP	put_ConnectionTimeout	( long dwConnectionTimeout );

	STDMETHODIMP	get_AnonymousUserName	( BSTR * pstrAnonymousUserName );
	STDMETHODIMP	put_AnonymousUserName	( BSTR strAnonymousUserName );

	STDMETHODIMP	get_AnonymousUserPass	( BSTR * pstrAnonymousUserPass );
	STDMETHODIMP	put_AnonymousUserPass	( BSTR strAnonymousUserPass );

	STDMETHODIMP	get_AutoSyncPassword	( BOOL * pfAutoSyncPassword );
	STDMETHODIMP	put_AutoSyncPassword	( BOOL fAutoSyncPassword );

	STDMETHODIMP	get_PickupDirectory	( BSTR * pstrPickupDirectory );
	STDMETHODIMP	put_PickupDirectory	( BSTR strPickupDirectory );

	STDMETHODIMP	get_FailedPickupDirectory	( BSTR * pstrFailedPickupDirectory );
	STDMETHODIMP	put_FailedPickupDirectory	( BSTR strFailedPickupDirectory );

	STDMETHODIMP	get_AuthAnonymous	( BOOL * pfAuthAnonymous );
	STDMETHODIMP	put_AuthAnonymous	( BOOL fAuthAnonymous );

	STDMETHODIMP	get_AuthBasic	( BOOL * pfAuthBasic );
	STDMETHODIMP	put_AuthBasic	( BOOL fAuthBasic );

	STDMETHODIMP	get_AuthMCISBasic	( BOOL * pfAuthMCISBasic );
	STDMETHODIMP	put_AuthMCISBasic	( BOOL fAuthMCISBasic );

	STDMETHODIMP	get_AuthNT	( BOOL * pfAuthNT );
	STDMETHODIMP	put_AuthNT	( BOOL fAuthNT );

	STDMETHODIMP	get_SSLNegotiateCert	( BOOL * pfSSLNegotiateCert );
	STDMETHODIMP	put_SSLNegotiateCert	( BOOL fSSLNegotiateCert );

	STDMETHODIMP	get_SSLRequireCert	( BOOL * pfSSLRequireCert );
	STDMETHODIMP	put_SSLRequireCert	( BOOL fSSLRequireCert );

	STDMETHODIMP	get_SSLMapCert	( BOOL * pfSSLMapCert );
	STDMETHODIMP	put_SSLMapCert	( BOOL fSSLMapCert );

/*
	STDMETHODIMP	get_AuthenticationProviders	( SAFEARRAY ** ppsastrProviders );
	STDMETHODIMP	put_AuthenticationProviders	( SAFEARRAY * psastrProviders );

	STDMETHODIMP	get_AuthenticationProvidersVariant	( SAFEARRAY ** ppsastrProviders );
	STDMETHODIMP	put_AuthenticationProvidersVariant	( SAFEARRAY * psastrProviders );
*/

/*
	STDMETHODIMP	get_NewsgroupsVariant	( SAFEARRAY ** ppsastrNewsgroups );
	STDMETHODIMP	put_NewsgroupsVariant	( SAFEARRAY * psastrNewsgroups );
*/

	STDMETHODIMP	get_Administrators ( SAFEARRAY ** ppsastrAdmins );
	STDMETHODIMP	put_Administrators ( SAFEARRAY * psastrAdmins );

	STDMETHODIMP	get_AdministratorsVariant ( SAFEARRAY ** ppsastrAdmins );
	STDMETHODIMP	put_AdministratorsVariant ( SAFEARRAY * psastrAdmins );

	STDMETHODIMP	get_ClusterEnabled	( BOOL *pfClusterEnabled );
	STDMETHODIMP	put_ClusterEnabled	( BOOL fClusterEnabled );

	//
	//	Service State Properties:
	//

	STDMETHODIMP	get_State			( NNTP_SERVER_STATE * pState );
	STDMETHODIMP	get_Win32ErrorCode	( long * plWin32ErrorCode );

/*
	STDMETHODIMP	get_EncryptionCapabilitiesMask ( long * plEncryptionCapabilitiesMask );
	STDMETHODIMP	put_EncryptionCapabilitiesMask ( long lEncryptionCapabilitiesMask );

	STDMETHODIMP	get_DisplayName	( BSTR * pstrDisplayName );
	STDMETHODIMP	put_DisplayName	( BSTR strDisplayName );

	STDMETHODIMP	get_ErrorControl	( BOOL * pfErrorControl );
	STDMETHODIMP	put_ErrorControl	( BOOL fErrorControl );

	STDMETHODIMP	get_CleanBoot	( BOOL * pfCleanBoot );
	STDMETHODIMP	put_CleanBoot	( BOOL fCleanBoot );
*/

	//////////////////////////////////////////////////////////////////////
	// Methods:
	//////////////////////////////////////////////////////////////////////

	STDMETHODIMP	Get ( );
	STDMETHODIMP	Set ( BOOL fFailIfChanged);

	STDMETHODIMP	Start		( );
	STDMETHODIMP	Pause		( );
	STDMETHODIMP	Continue	( );
	STDMETHODIMP	Stop		( );

	//////////////////////////////////////////////////////////////////////
	// Data:
	//////////////////////////////////////////////////////////////////////
private:

	// Properties:
	CComBSTR	m_strServer;
	DWORD		m_dwServiceInstance;

	DWORD		m_dwArticleTimeLimit;
	DWORD		m_dwHistoryExpiration;
	BOOL		m_fHonorClientMsgIDs;
	CComBSTR	m_strSmtpServer;
    CComBSTR    m_strAdminEmail;
	BOOL		m_fAllowClientPosts;
	BOOL		m_fAllowFeedPosts;
	BOOL		m_fAllowControlMsgs;
	CComBSTR	m_strDefaultModeratorDomain;
	DWORD		m_dwCommandLogMask;
	BOOL		m_fDisableNewnews;
	DWORD		m_dwExpireRunFrequency;
	DWORD		m_dwShutdownLatency;

	DWORD		m_dwClientPostHardLimit;
	DWORD		m_dwClientPostSoftLimit;
	DWORD		m_dwFeedPostHardLimit;
	DWORD		m_dwFeedPostSoftLimit;

	BOOL		m_fEnableLogging;
	CComBSTR	m_strGroupHelpFile;
	CComBSTR	m_strGroupListFile;
	CComBSTR    m_strGroupVarListFile;
	CComBSTR	m_strArticleTableFile;
	CComBSTR	m_strHistoryTableFile;
	CComBSTR	m_strModeratorFile;
	CComBSTR	m_strXOverTableFile;
	CComBSTR	m_strUucpName;
	CComBSTR	m_strOrganization;
	BOOL		m_fAutoStart;
	CComBSTR	m_strComment;
	DWORD		m_dwSecurePort;
	DWORD		m_dwMaxConnections;
	DWORD		m_dwConnectionTimeout;
	CComBSTR	m_strAnonymousUserName;
	CComBSTR	m_strAnonymousUserPass;
	BOOL		m_fAutoSyncPassword;
	CComBSTR	m_strPickupDirectory;
	CComBSTR	m_strFailedPickupDirectory;
	DWORD		m_bvAuthorization;
	DWORD		m_bvSslAccess;
	BOOL		m_fClusterEnabled;
//	CMultiSz	m_mszProviders;

	SAFEARRAY *	m_psaAdmins;

	// Service State:
	NNTP_SERVER_STATE	m_State;
	DWORD				m_dwWin32ErrorCode;

	// Tcp restrictions:
	CComPtr<ITcpAccess>		m_pIpAccess;
	CTcpAccess *				m_pPrivateIpAccess;

	// Bindings:
	CComPtr<INntpServerBindings>	m_pBindings;
	CNntpServerBindings *			m_pPrivateBindings;
/*
	CComPtr<INntpVirtualRoot>		m_pHomeDirectory;
	CNntpVirtualRoot *				m_pPrivateHomeDirectory;
*/

	// Unused so far:
	DWORD		m_dwEncryptionCapabilities;
	CComBSTR	m_strDisplayName;
	BOOL		m_fErrorControl;
	BOOL		m_fCleanBoot;

	// Status:
	BOOL		m_fGotProperties;
	DWORD		m_bvChangedFields;
	DWORD		m_bvChangedFields2;
	FILETIME	m_ftLastChanged;

	// Metabase:
	CMetabaseFactory	m_mbFactory;

	HRESULT 	GetPropertiesFromMetabase	( IMSAdminBase * pMetabase);
	HRESULT 	SendPropertiesToMetabase	( BOOL fFailIfChanged, IMSAdminBase * pMetabase);

	// State:
	HRESULT		ControlService 				( 
					IMSAdminBase *	pMetabase, 
					DWORD			ControlCode,
					DWORD			dwDesiredState,
					DWORD			dwPendingState
					);
	HRESULT		WriteStateCommand	( IMSAdminBase * pMetabase, DWORD dwCommand );
	HRESULT		CheckServiceState	( IMSAdminBase * pMetabase, DWORD * pdwState );
	NNTP_SERVER_STATE	TranslateServerState	( DWORD dwState );

	// Validation:
	BOOL		ValidateStrings ( ) const;
	BOOL		ValidateProperties ( ) const;
	void		CorrectProperties ( );
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\nntp\adminsso\version.h ===
#include "exver.h"

#define makeString(x) #x

#define CURRENT_BUILD_NUMBER    atoi(makeString(rmm))

const int HIGH_VERSION = 1;
const int LOW_VERSION = 0;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\nntp\adminsso\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#pragma warning( disable : 4511 )

#include <ctype.h>
extern "C"
{
    #include <nt.h>
    #include <ntrtl.h>
    #include <nturtl.h>
}

#include <winsock2.h>

//  Pull in the common admin object code:
#include <admcmn.h>

#include "nntpmeta.h"
#include "tigdflts.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\nntp\adminsso\vroots.h ===
// vroots.h : Declaration of the CNntpVirtualRoot & CNntpVirtualRoots classes.

#ifndef _VROOTS_INCLUDED_
#define _VROOTS_INCLUDED_

//
//	Dependencies:
//

#include "nntptype.h"
#include "nntpapi.h"
#include "metafact.h"
class CMetabaseKey;

//
//	A simple VRoot class:
//

class CVRoot
{
public:
	CVRoot ();

	CComBSTR	m_strNewsgroupSubtree;
	CComBSTR	m_strDirectory;
	DWORD		m_dwWin32Error;
	DWORD		m_bvAccess;
	DWORD		m_bvSslAccess;
	BOOL		m_fLogAccess;
	BOOL		m_fIndexContent;
	CComBSTR	m_strUNCUsername;
	CComBSTR	m_strUNCPassword;
	CComBSTR    m_strDriverProgId;
	CComBSTR    m_strGroupPropFile;
	CComBSTR    m_strMdbGuid;
	DWORD       m_dwUseAccount;
	BOOL        m_fDoExpire;
	BOOL        m_fOwnModerator;

	HRESULT	SetProperties ( INntpVirtualRoot * pVirtualRoot );
	inline HRESULT	SetProperties ( const CVRoot & VRoot )
	{
		return SetProperties ( 
			VRoot.m_strNewsgroupSubtree, 
			VRoot.m_strDirectory,
			VRoot.m_dwWin32Error,
			VRoot.m_bvAccess,
			VRoot.m_bvSslAccess,
			VRoot.m_fLogAccess,
			VRoot.m_fIndexContent,
			VRoot.m_strUNCUsername,
			VRoot.m_strUNCPassword,
			VRoot.m_strDriverProgId,
			VRoot.m_strGroupPropFile,
			VRoot.m_dwUseAccount,
			VRoot.m_fDoExpire,
			VRoot.m_fOwnModerator,
			VRoot.m_strMdbGuid
			);
	}

	HRESULT	GetFromMetabase ( CMetabaseKey * pMB, LPCWSTR wszKey, DWORD dwInstanceId, LPWSTR wszVRootPath );
	HRESULT SendToMetabase ( CMetabaseKey * pMB, LPCWSTR wszKey );

private:
	HRESULT	SetProperties ( 
		BSTR	strNewsgroupSubtree, 
		BSTR	strDirectory,
		DWORD	dwWin32Error,
		DWORD	bvAccess,
		DWORD	bvSslAccess,
		BOOL	fLogAcccess,
		BOOL	fIndexContent,
		BSTR	strUNCUsername,
		BSTR	strUNCPassword,
		BSTR    strDriverProgId,
		BSTR    strGroupPropFile,
		DWORD   dwUseAccount,
		BOOL    fDoExpire,
		BOOL    fOwnModerator,
		BSTR    strMdbGuid
		);

	// Don't call this:
	const CVRoot & operator= ( const CVRoot & );
};

/////////////////////////////////////////////////////////////////////////////
// The VRoot Object

class CNntpVirtualRoot : 
	public CComDualImpl<INntpVirtualRoot, &IID_INntpVirtualRoot, &LIBID_NNTPADMLib>, 
	public ISupportErrorInfo,
	public CComObjectRoot,
	public CComCoClass<CNntpVirtualRoot,&CLSID_CNntpVirtualRoot>
{
	friend class CNntpVirtualRoots;
	friend class CNntpVirtualServer;

public:
	CNntpVirtualRoot();
	virtual ~CNntpVirtualRoot ();
BEGIN_COM_MAP(CNntpVirtualRoot)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(INntpVirtualRoot)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()
//DECLARE_NOT_AGGREGATABLE(CNntpVirtualRoot) 
// Remove the comment from the line above if you don't want your object to 
// support aggregation.  The default is to support it

// ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

DECLARE_REGISTRY(CNntpVirtualRoot, _T("Nntpadm.VirtualRoot.1"), _T("Nntpadm.VirtualRoot"), IDS_NNTPVIRTUALROOT_DESC, THREADFLAGS_BOTH)
// INntpVirtualRoot
public:

	//////////////////////////////////////////////////////////////////////
	// Properties:
	//////////////////////////////////////////////////////////////////////

	STDMETHODIMP	get_NewsgroupSubtree	( BSTR * pstrNewsgroupSubtree );
	STDMETHODIMP	put_NewsgroupSubtree	( BSTR strNewsgroupSubtree );

	STDMETHODIMP	get_Directory	( BSTR * pstrDirectory );
	STDMETHODIMP	put_Directory	( BSTR strDirectory );

	STDMETHODIMP	get_Win32Error	( long * plWin32Error );

	STDMETHODIMP	get_AllowPosting	( BOOL * pfAllowPosting );
	STDMETHODIMP	put_AllowPosting	( BOOL fAllowPosting );

	STDMETHODIMP	get_RestrictGroupVisibility	( BOOL * pfRestrictGroupVisibility );
	STDMETHODIMP	put_RestrictGroupVisibility	( BOOL fRestrictGroupVisibility );

	STDMETHODIMP	get_LogAccess	( BOOL * pfLogAccess );
	STDMETHODIMP	put_LogAccess	( BOOL fLogAccess );

	STDMETHODIMP	get_IndexContent	( BOOL * pfIndexContent );
	STDMETHODIMP	put_IndexContent	( BOOL fIndexContent );

	STDMETHODIMP	get_RequireSsl	( BOOL * pfRequireSsl );
	STDMETHODIMP	put_RequireSsl	( BOOL fRequireSsl );

	STDMETHODIMP	get_Require128BitSsl	( BOOL * pfRequire128BitSsl );
	STDMETHODIMP	put_Require128BitSsl	( BOOL fRequire128BitSsl );

	STDMETHODIMP	get_UNCUsername	( BSTR * pstrUNCUsername );
	STDMETHODIMP	put_UNCUsername	( BSTR strUNCUsername );

	STDMETHODIMP	get_UNCPassword	( BSTR * pstrUNCPassword );
	STDMETHODIMP	put_UNCPassword	( BSTR strUNCPassword );

	STDMETHODIMP    get_DriverProgId( BSTR *pstrDriverProgId );
	STDMETHODIMP    put_DriverProgId( BSTR strDriverProgId );

	STDMETHODIMP    get_GroupPropFile( BSTR *pstrGRoupPropFile );
	STDMETHODIMP    put_GroupPropFile( BSTR strGroupPropFile );

	STDMETHODIMP    get_MdbGuid( BSTR *pstrMdbGuid );
	STDMETHODIMP    put_MdbGuid( BSTR strMdbGuid );

	STDMETHODIMP    get_UseAccount( DWORD *pdwUseAccount );
	STDMETHODIMP    put_UseAccount( DWORD dwUseAccount );

	STDMETHODIMP    get_OwnExpire( BOOL *fOwnExpire );
	STDMETHODIMP    put_OwnExpire( BOOL fOwnExpire );

	STDMETHODIMP    get_OwnModerator( BOOL *fOwnModerator );
	STDMETHODIMP    put_OwnModerator( BOOL fOwnModerator );

	//////////////////////////////////////////////////////////////////////
	// Data:
	//////////////////////////////////////////////////////////////////////
private:

/*
	inline HRESULT	SetProperties	( BSTR strNewsgroupSubtree, BSTR strDirectory )
	{
		return m_vroot.SetProperties ( strNewsgroupSubtree, strDirectory );
	}
*/

	inline HRESULT	SetProperties	( const CVRoot & VRoot )
	{
		return m_vroot.SetProperties ( VRoot );
	}

	// Property variables:
	CVRoot	m_vroot;
};

/////////////////////////////////////////////////////////////////////////////
// The VRoots Object

typedef HRESULT (* VROOT_ITERATOR) (
	CMetabaseKey *	pMB,
	LPCWSTR			wszPath,
	LPARAM			lParam
	);

class CNntpVirtualRoots : 
	public CComDualImpl<INntpVirtualRoots, &IID_INntpVirtualRoots, &LIBID_NNTPADMLib>, 
	public ISupportErrorInfo,
	public CComObjectRoot
{
	friend class CNntpVirtualRoot;
	friend class CNntpVirtualServer;

public:
	CNntpVirtualRoots();
	virtual ~CNntpVirtualRoots ();
BEGIN_COM_MAP(CNntpVirtualRoots)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(INntpVirtualRoots)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()
//DECLARE_NOT_AGGREGATABLE(CNntpVirtualRoots) 
// Remove the comment from the line above if you don't want your object to 
// support aggregation.  The default is to support it

// ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

// INntpVirtualRoots
public:

	//////////////////////////////////////////////////////////////////////
	// Properties:
	//////////////////////////////////////////////////////////////////////

	STDMETHODIMP	get_Server			( BSTR * pstrServer );
	STDMETHODIMP	put_Server			( BSTR strServer );

	STDMETHODIMP	get_ServiceInstance	( long * plServiceInstance );
	STDMETHODIMP	put_ServiceInstance	( long lServiceInstance );

	STDMETHODIMP	get_Count	( long * pdwCount );

	//////////////////////////////////////////////////////////////////////
	// Methods:
	//////////////////////////////////////////////////////////////////////

	STDMETHODIMP	Enumerate	( );
	STDMETHODIMP	Item	( long index, INntpVirtualRoot ** ppVRoot );
	STDMETHODIMP	ItemDispatch	( long index, IDispatch ** ppVRoot );
	STDMETHODIMP	Add		( INntpVirtualRoot * pVRoot );
	STDMETHODIMP	AddDispatch	( IDispatch * pVRoot );
	STDMETHODIMP	Set		( long index, INntpVirtualRoot * pVRoot );
	STDMETHODIMP	SetDispatch	( long index, IDispatch * pVRoot );
	STDMETHODIMP	Remove	( long index );
	STDMETHODIMP	Find	( BSTR strNewsgroupSubtree, long * pIndex );

private:
	HRESULT		Init ( BSTR strServer, DWORD dwServiceInstance );

	//////////////////////////////////////////////////////////////////////
	// Data:
	//////////////////////////////////////////////////////////////////////
private:

	// Property variables:
	long			m_dwCount;
	CVRoot *		m_rgVRoots;

	// Which service are we talking to:
	CComBSTR		m_strServer;
	DWORD			m_dwServiceInstance;

	// Metabase values:
	CMetabaseFactory	m_mbFactory;

	HRESULT GetVRootsFromMetabase ( IMSAdminBase * pMetabase );

	static HRESULT	IterateOverVroots (
		CMetabaseKey *	pMB,
		VROOT_ITERATOR	fpIterator,
		LPARAM			lParam,
		LPCWSTR			wszPath = _T("")
		);

	void GetMDVRootPath ( LPWSTR wszPath );
	void GetVRootName	( LPWSTR wszDisplayName, LPWSTR wszPathName );
};

#endif // _VROOTS_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\nntp\adminsso\vroots.cpp ===
// VirtualRoot.cpp : Implementation of CNntpVirtualRoot & CNntpVirtualRoots.

#include "stdafx.h"
#include "nntpcmn.h"
#include "cmultisz.h"
#include "vroots.h"
#include "oleutil.h"
#include "metautil.h"
#include "metakey.h"

#define THIS_FILE_HELP_CONTEXT      0
#define THIS_FILE_PROG_ID           _T("Nntpadm.VirtualServer.1")
#define THIS_FILE_IID               IID_INntpVirtualServer

#define DEFAULT_ACCESS_PERM		( 0 )

CVRoot::CVRoot () :
	m_dwWin32Error		( 0 ),
	m_bvAccess			( 0 ),
	m_bvSslAccess		( 0 ),
	m_fLogAccess		( TRUE ),
	m_fIndexContent		( TRUE ),
	m_dwUseAccount      ( 0 ),
	m_fDoExpire         ( FALSE ),
	m_fOwnModerator     ( FALSE )
{ 
}

HRESULT	CVRoot::SetProperties ( 
	BSTR	strNewsgroupSubtree, 
	BSTR	strDirectory,
	DWORD	dwWin32Error,
	DWORD	bvAccess,
	DWORD	bvSslAccess,
	BOOL	fLogAccess,
	BOOL	fIndexContent,
	BSTR	strUNCUsername,
	BSTR	strUNCPassword,
	BSTR    strDriverProgId,
	BSTR    strGroupPropFile,
	DWORD   dwUseAccount,
	BOOL    fDoExpire,
	BOOL    fOwnModerator,
	BSTR    strMdbGuid
	)
{
	_ASSERT ( IS_VALID_STRING ( strNewsgroupSubtree ) );
	_ASSERT ( IS_VALID_STRING ( strDirectory ) );
	_ASSERT ( IS_VALID_STRING ( strUNCUsername ) );
	_ASSERT ( IS_VALID_STRING ( strUNCPassword ) );
	_ASSERT ( IS_VALID_STRING ( strDriverProgId ) );
	_ASSERT ( IS_VALID_STRING ( strGroupPropFile ) );
	_ASSERT ( IS_VALID_STRING ( strMdbGuid ) );

	m_strNewsgroupSubtree	= strNewsgroupSubtree;
	m_strDirectory		= strDirectory;
	m_dwWin32Error		= dwWin32Error;
	m_bvAccess			= bvAccess;
	m_bvSslAccess		= bvSslAccess;
	m_fLogAccess		= fLogAccess;
	m_fIndexContent		= fIndexContent;
	m_strUNCUsername	= strUNCUsername;
	m_strUNCPassword	= strUNCPassword;
	m_strDriverProgId   = strDriverProgId;
	m_strGroupPropFile  = strGroupPropFile;
	m_dwUseAccount      = dwUseAccount;
	m_fDoExpire         = fDoExpire;
	m_fOwnModerator     = fOwnModerator,
	m_strMdbGuid        = strMdbGuid;

	if ( !m_strNewsgroupSubtree || !m_strDirectory || !m_strUNCUsername || !m_strUNCPassword ) {
		return E_OUTOFMEMORY;
	}

	return NOERROR;
}

HRESULT	CVRoot::SetProperties ( INntpVirtualRoot * pVirtualRoot )
{
	HRESULT		hr;

	BOOL		fAllowPosting;
	BOOL		fRestrictVisibility;
	BOOL		fRequireSsl;
	BOOL		fRequire128BitSsl;

	m_strDirectory.Empty ();
	m_strUNCUsername.Empty ();
	m_strUNCPassword.Empty ();
	m_strDriverProgId.Empty();
	m_strGroupPropFile.Empty();
	m_strMdbGuid.Empty();

	hr = pVirtualRoot->get_NewsgroupSubtree ( &m_strNewsgroupSubtree );
	BAIL_ON_FAILURE(hr);

	hr = pVirtualRoot->get_Directory ( &m_strDirectory );
	BAIL_ON_FAILURE(hr);

	hr = pVirtualRoot->get_Win32Error ( (long *) &m_dwWin32Error );
	BAIL_ON_FAILURE(hr);

	hr = pVirtualRoot->get_UNCUsername ( &m_strUNCUsername );
	BAIL_ON_FAILURE(hr);

	hr = pVirtualRoot->get_UNCPassword ( &m_strUNCPassword );
	BAIL_ON_FAILURE(hr);

	hr = pVirtualRoot->get_DriverProgId ( &m_strDriverProgId );
	BAIL_ON_FAILURE( hr );

	hr = pVirtualRoot->get_GroupPropFile ( &m_strGroupPropFile );
	BAIL_ON_FAILURE( hr );

	hr = pVirtualRoot->get_MdbGuid ( &m_strMdbGuid );
	BAIL_ON_FAILURE( hr );

	hr = pVirtualRoot->get_UseAccount( &m_dwUseAccount );
	BAIL_ON_FAILURE( hr );

	hr = pVirtualRoot->get_OwnExpire( &m_fDoExpire );
	BAIL_ON_FAILURE( hr );

	hr = pVirtualRoot->get_OwnModerator( &m_fOwnModerator );
	BAIL_ON_FAILURE( hr );

	hr = pVirtualRoot->get_LogAccess ( &m_fLogAccess );
	_ASSERT ( SUCCEEDED(hr) );

	hr = pVirtualRoot->get_IndexContent ( &m_fIndexContent );
	_ASSERT ( SUCCEEDED(hr) );


	hr = pVirtualRoot->get_AllowPosting ( &fAllowPosting );
	_ASSERT ( SUCCEEDED(hr) );

	hr = pVirtualRoot->get_RestrictGroupVisibility ( &fRestrictVisibility );
	_ASSERT ( SUCCEEDED(hr) );

	hr = pVirtualRoot->get_RequireSsl ( &fRequireSsl );
	_ASSERT ( SUCCEEDED(hr) );

	hr = pVirtualRoot->get_Require128BitSsl ( &fRequire128BitSsl );
	_ASSERT ( SUCCEEDED(hr) );

	SetBitFlag ( &m_bvAccess, MD_ACCESS_ALLOW_POSTING, fAllowPosting );
	SetBitFlag ( &m_bvAccess, MD_ACCESS_RESTRICT_VISIBILITY, fRestrictVisibility );

	SetBitFlag ( &m_bvSslAccess, MD_ACCESS_SSL, fRequireSsl );
	SetBitFlag ( &m_bvSslAccess, MD_ACCESS_SSL128, fRequire128BitSsl );

Exit:
	return hr;
}

HRESULT CVRoot::GetFromMetabase (   CMetabaseKey * pMB, 
                                    LPCWSTR     wszName,
                                    DWORD       dwInstanceId,
                                    LPWSTR      wszServerName )
{
	HRESULT		hr	= NOERROR;
	DWORD		dwDontLog		= TRUE;

	m_strDirectory.Empty();
	m_strUNCUsername.Empty();
	m_strUNCPassword.Empty();

	StdGetMetabaseProp ( pMB, MD_ACCESS_PERM, 0, &m_bvAccess, wszName );
	StdGetMetabaseProp ( pMB, MD_SSL_ACCESS_PERM, 0, &m_bvSslAccess, wszName );
	StdGetMetabaseProp ( pMB, MD_DONT_LOG, FALSE, &dwDontLog, wszName );
	StdGetMetabaseProp ( pMB, MD_IS_CONTENT_INDEXED, FALSE, &m_fIndexContent, wszName, IIS_MD_UT_FILE);
	StdGetMetabaseProp ( pMB, MD_VR_PATH, _T(""), &m_strDirectory, wszName );
	//StdGetMetabaseProp ( pMB, MD_WIN32_ERROR, 0, &m_dwWin32Error, wszName, IIS_MD_UT_FILE, METADATA_NO_ATTRIBUTES );
	StdGetMetabaseProp ( pMB, MD_VR_USERNAME, _T(""), &m_strUNCUsername, wszName );
	StdGetMetabaseProp ( pMB, MD_VR_PASSWORD, _T(""), &m_strUNCPassword, wszName, IIS_MD_UT_SERVER, METADATA_SECURE );
	StdGetMetabaseProp ( pMB, MD_VR_USE_ACCOUNT, 0,	&m_dwUseAccount, wszName );
	StdGetMetabaseProp ( pMB, MD_VR_DO_EXPIRE, FALSE, &m_fDoExpire, wszName );
	StdGetMetabaseProp ( pMB, MD_VR_OWN_MODERATOR, FALSE, &m_fOwnModerator, wszName );
	StdGetMetabaseProp ( pMB, MD_VR_DRIVER_PROGID, _T("NNTP.FSPrepare"), &m_strDriverProgId, wszName );
	StdGetMetabaseProp ( pMB, MD_FS_PROPERTY_PATH, m_strDirectory, &m_strGroupPropFile, wszName );
	StdGetMetabaseProp ( pMB, MD_EX_MDB_GUID, _T(""), &m_strMdbGuid, wszName );

	//
	// Get the win32 error code from RPC
	//
	DWORD dw = NntpGetVRootWin32Error( (LPWSTR)wszServerName, dwInstanceId, (LPWSTR)wszName, (LPDWORD)&m_dwWin32Error );
	switch (dw) {
	case ERROR_SERVICE_NOT_ACTIVE:
		m_dwWin32Error = dw;
		break;

	case NOERROR:
		break;

	default:
    	hr = HRESULT_FROM_WIN32( dw );
    	goto Exit;
	}

	m_strNewsgroupSubtree	= wszName;
	m_fLogAccess			= !dwDontLog;

	if ( !m_strNewsgroupSubtree || !m_strDirectory || !m_strUNCUsername || !m_strUNCPassword ) {
		hr = E_OUTOFMEMORY;
		goto Exit;
	}

Exit:
	return hr;
}

HRESULT CVRoot::SendToMetabase ( CMetabaseKey * pMB, LPCWSTR wszName ) 
{
	HRESULT		hr	= NOERROR;

    hr = pMB->SetString ( wszName, MD_KEY_TYPE, _T("IIsNntpVirtualDir"), METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER );
	BAIL_ON_FAILURE(hr);

	hr = pMB->SetString ( wszName, MD_VR_PATH, m_strDirectory, METADATA_INHERIT, IIS_MD_UT_FILE );
	BAIL_ON_FAILURE(hr);

	StdPutMetabaseProp ( pMB, MD_ACCESS_PERM, m_bvAccess, wszName, IIS_MD_UT_FILE );
	StdPutMetabaseProp ( pMB, MD_SSL_ACCESS_PERM, m_bvSslAccess, wszName, IIS_MD_UT_FILE );
	StdPutMetabaseProp ( pMB, MD_DONT_LOG, !m_fLogAccess, wszName, IIS_MD_UT_FILE );
	StdPutMetabaseProp ( pMB, MD_IS_CONTENT_INDEXED, m_fIndexContent, wszName, IIS_MD_UT_FILE );
	StdPutMetabaseProp ( pMB, MD_WIN32_ERROR, m_dwWin32Error, wszName, IIS_MD_UT_SERVER, METADATA_VOLATILE );
	StdPutMetabaseProp ( pMB, MD_VR_USERNAME, m_strUNCUsername, wszName, IIS_MD_UT_FILE );
	StdPutMetabaseProp ( pMB, MD_VR_PASSWORD, m_strUNCPassword, wszName, IIS_MD_UT_FILE, METADATA_SECURE | METADATA_INHERIT );
	StdPutMetabaseProp ( pMB, MD_VR_USE_ACCOUNT, m_dwUseAccount, wszName, IIS_MD_UT_SERVER );
	StdPutMetabaseProp ( pMB, MD_VR_DO_EXPIRE, m_fDoExpire, wszName, IIS_MD_UT_SERVER );
	StdPutMetabaseProp ( pMB, MD_VR_OWN_MODERATOR, m_fOwnModerator, wszName, IIS_MD_UT_SERVER );
	StdPutMetabaseProp ( pMB, MD_VR_DRIVER_PROGID, m_strDriverProgId, wszName, IIS_MD_UT_SERVER );
    StdPutMetabaseProp ( pMB, MD_FS_PROPERTY_PATH, m_strGroupPropFile, wszName, IIS_MD_UT_SERVER );	
    StdPutMetabaseProp ( pMB, MD_EX_MDB_GUID, m_strMdbGuid, wszName, IIS_MD_UT_SERVER );

Exit:
	return hr;
}

/////////////////////////////////////////////////////////////////////////////
//

STDMETHODIMP CNntpVirtualRoot::InterfaceSupportsErrorInfo(REFIID riid)
{
	static const IID* arr[] = 
	{
		&IID_INntpVirtualRoot,
	};

	for (int i=0;i<sizeof(arr)/sizeof(arr[0]);i++)
	{
		if (InlineIsEqualGUID(*arr[i],riid))
			return S_OK;
	}
	return S_FALSE;
}

CNntpVirtualRoot::CNntpVirtualRoot ()
	// CComBSTR's are initialized to NULL by default.
{
}

CNntpVirtualRoot::~CNntpVirtualRoot ()
{
	// All CComBSTR's are freed automatically.
}

//////////////////////////////////////////////////////////////////////
// Properties:
//////////////////////////////////////////////////////////////////////

STDMETHODIMP CNntpVirtualRoot::get_NewsgroupSubtree ( BSTR * pstrNewsgroupSubtree )
{
	return StdPropertyGet ( m_vroot.m_strNewsgroupSubtree, pstrNewsgroupSubtree );
}

STDMETHODIMP CNntpVirtualRoot::put_NewsgroupSubtree ( BSTR strNewsgroupSubtree )
{
    if ( wcslen( strNewsgroupSubtree ) > METADATA_MAX_NAME_LEN - 20 ) return CO_E_PATHTOOLONG;
	return StdPropertyPut ( &m_vroot.m_strNewsgroupSubtree, strNewsgroupSubtree );
}

STDMETHODIMP CNntpVirtualRoot::get_Directory ( BSTR * pstrDirectory )
{
	return StdPropertyGet ( m_vroot.m_strDirectory, pstrDirectory );
}

STDMETHODIMP CNntpVirtualRoot::put_Directory ( BSTR strDirectory )
{
	return StdPropertyPut ( &m_vroot.m_strDirectory, strDirectory );
}

STDMETHODIMP CNntpVirtualRoot::get_Win32Error ( long * plWin32Error )
{
	return StdPropertyGet ( m_vroot.m_dwWin32Error, plWin32Error );
}

STDMETHODIMP CNntpVirtualRoot::get_LogAccess ( BOOL * pfLogAccess )
{
	return StdPropertyGet ( m_vroot.m_fLogAccess, pfLogAccess );
}

STDMETHODIMP CNntpVirtualRoot::put_LogAccess ( BOOL fLogAccess )
{
	return StdPropertyPut ( &m_vroot.m_fLogAccess, fLogAccess );
}

STDMETHODIMP CNntpVirtualRoot::get_IndexContent ( BOOL * pfIndexContent )
{
	return StdPropertyGet ( m_vroot.m_fIndexContent, pfIndexContent );
}

STDMETHODIMP CNntpVirtualRoot::put_IndexContent ( BOOL fIndexContent )
{
	return StdPropertyPut ( &m_vroot.m_fIndexContent, fIndexContent );
}

STDMETHODIMP CNntpVirtualRoot::get_AllowPosting ( BOOL * pfAllowPosting )
{
	return StdPropertyGetBit ( m_vroot.m_bvAccess, MD_ACCESS_ALLOW_POSTING, pfAllowPosting );
}

STDMETHODIMP CNntpVirtualRoot::put_AllowPosting ( BOOL fAllowPosting )
{
	return StdPropertyPutBit ( &m_vroot.m_bvAccess, MD_ACCESS_ALLOW_POSTING, fAllowPosting );
}

STDMETHODIMP CNntpVirtualRoot::get_RestrictGroupVisibility ( BOOL * pfRestrictGroupVisibility )
{
	return StdPropertyGetBit ( m_vroot.m_bvAccess, MD_ACCESS_RESTRICT_VISIBILITY, pfRestrictGroupVisibility );
}

STDMETHODIMP CNntpVirtualRoot::put_RestrictGroupVisibility ( BOOL fRestrictGroupVisibility )
{
	return StdPropertyPutBit ( &m_vroot.m_bvAccess, MD_ACCESS_RESTRICT_VISIBILITY, fRestrictGroupVisibility );
}

	STDMETHODIMP	SSLNegotiateCert	( BOOL * pfSSLNegotiateCert );
	STDMETHODIMP	SSLNegotiateCert	( BOOL fSSLNegotiateCert );

	STDMETHODIMP	SSLRequireCert	( BOOL * pfSSLRequireCert );
	STDMETHODIMP	SSLRequireCert	( BOOL fSSLRequireCert );

	STDMETHODIMP	SSLMapCert	( BOOL * pfSSLMapCert );
	STDMETHODIMP	SSLMapCert	( BOOL fSSLMapCert );

STDMETHODIMP CNntpVirtualRoot::get_RequireSsl ( BOOL * pfRequireSsl )
{
	return StdPropertyGetBit ( m_vroot.m_bvSslAccess, MD_ACCESS_SSL, pfRequireSsl );
}

STDMETHODIMP CNntpVirtualRoot::put_RequireSsl ( BOOL fRequireSsl )
{
	return StdPropertyPutBit ( &m_vroot.m_bvSslAccess, MD_ACCESS_SSL, fRequireSsl );
}

STDMETHODIMP CNntpVirtualRoot::get_Require128BitSsl ( BOOL * pfRequire128BitSsl )
{
	return StdPropertyGetBit ( m_vroot.m_bvSslAccess, MD_ACCESS_SSL128, pfRequire128BitSsl );
}

STDMETHODIMP CNntpVirtualRoot::put_Require128BitSsl ( BOOL fRequire128BitSsl )
{
	return StdPropertyPutBit ( &m_vroot.m_bvSslAccess, MD_ACCESS_SSL128, fRequire128BitSsl );
}

STDMETHODIMP CNntpVirtualRoot::get_UNCUsername ( BSTR * pstrUNCUsername )
{
	return StdPropertyGet ( m_vroot.m_strUNCUsername, pstrUNCUsername );
}

STDMETHODIMP CNntpVirtualRoot::put_UNCUsername ( BSTR strUNCUsername )
{
	return StdPropertyPut ( &m_vroot.m_strUNCUsername, strUNCUsername );
}

STDMETHODIMP CNntpVirtualRoot::get_UNCPassword ( BSTR * pstrUNCPassword )
{
	return StdPropertyGet ( m_vroot.m_strUNCPassword, pstrUNCPassword );
}

STDMETHODIMP CNntpVirtualRoot::put_UNCPassword ( BSTR strUNCPassword )
{
	return StdPropertyPut ( &m_vroot.m_strUNCPassword, strUNCPassword );
}

STDMETHODIMP CNntpVirtualRoot::get_DriverProgId( BSTR *pstrDriverProgId )
{
    return StdPropertyGet( m_vroot.m_strDriverProgId, pstrDriverProgId );
}

STDMETHODIMP CNntpVirtualRoot::put_DriverProgId( BSTR strDriverProgId )
{
    return StdPropertyPut( &m_vroot.m_strDriverProgId, strDriverProgId );
}

STDMETHODIMP CNntpVirtualRoot::get_GroupPropFile( BSTR *pstrGroupPropFile )
{
    return StdPropertyGet( m_vroot.m_strGroupPropFile, pstrGroupPropFile );
}

STDMETHODIMP CNntpVirtualRoot::put_GroupPropFile( BSTR strGroupPropFile )
{
    return StdPropertyPut( &m_vroot.m_strGroupPropFile, strGroupPropFile );
}

STDMETHODIMP CNntpVirtualRoot::get_MdbGuid( BSTR *pstrMdbGuid )
{
    return StdPropertyGet( m_vroot.m_strMdbGuid, pstrMdbGuid );
}

STDMETHODIMP CNntpVirtualRoot::put_MdbGuid( BSTR strMdbGuid )
{
    return StdPropertyPut( &m_vroot.m_strMdbGuid, strMdbGuid );
}

STDMETHODIMP CNntpVirtualRoot::get_UseAccount( DWORD *pdwUseAccount )
{
    return StdPropertyGet( m_vroot.m_dwUseAccount, pdwUseAccount );
}

STDMETHODIMP CNntpVirtualRoot::put_UseAccount( DWORD dwUseAccount )
{
    return StdPropertyPut( &m_vroot.m_dwUseAccount, dwUseAccount );
}

STDMETHODIMP CNntpVirtualRoot::get_OwnExpire( BOOL *pfOwnExpire )
{
    return StdPropertyGet( m_vroot.m_fDoExpire, pfOwnExpire );
}

STDMETHODIMP CNntpVirtualRoot::put_OwnExpire( BOOL fOwnExpire )
{
    return StdPropertyPut( &m_vroot.m_fDoExpire, fOwnExpire );
}

STDMETHODIMP CNntpVirtualRoot::get_OwnModerator( BOOL *pfOwnModerator )
{
    return StdPropertyGet( m_vroot.m_fOwnModerator, pfOwnModerator );
}

STDMETHODIMP CNntpVirtualRoot::put_OwnModerator( BOOL fOwnModerator )
{
    return StdPropertyPut( &m_vroot.m_fOwnModerator, fOwnModerator );
}

/////////////////////////////////////////////////////////////////////////////
//

STDMETHODIMP CNntpVirtualRoots::InterfaceSupportsErrorInfo(REFIID riid)
{
	static const IID* arr[] = 
	{
		&IID_INntpVirtualRoots,
	};

	for (int i=0;i<sizeof(arr)/sizeof(arr[0]);i++)
	{
		if (InlineIsEqualGUID(*arr[i],riid))
			return S_OK;
	}
	return S_FALSE;
}

CNntpVirtualRoots::CNntpVirtualRoots () :
	m_dwCount			( 0 ),
	m_rgVRoots			( NULL ),
	m_dwServiceInstance	( 0 )
	// CComBSTR's are initialized to NULL by default.
{
}

CNntpVirtualRoots::~CNntpVirtualRoots ()
{
	// All CComBSTR's are freed automatically.

	delete [] m_rgVRoots;
}

HRESULT CNntpVirtualRoots::Init ( BSTR strServer, DWORD dwServiceInstance )
{
	m_strServer				= strServer;
	m_dwServiceInstance		= dwServiceInstance;

	if ( !m_strServer ) {
		return E_OUTOFMEMORY;
	}

	return NOERROR;
}

//////////////////////////////////////////////////////////////////////
// Properties:
//////////////////////////////////////////////////////////////////////

// Which service to configure:
	
STDMETHODIMP CNntpVirtualRoots::get_Server ( BSTR * pstrServer )
{
	return StdPropertyGet ( m_strServer, pstrServer );
}

STDMETHODIMP CNntpVirtualRoots::put_Server ( BSTR strServer )
{
	_ASSERT ( strServer );
	_ASSERT ( IS_VALID_STRING ( strServer ) );

	if ( strServer == NULL ) {
		return E_POINTER;
	}

	if ( lstrcmp ( strServer, _T("") ) == 0 ) {
		m_strServer.Empty();

		return NOERROR;
	}
	else {
		return StdPropertyPutServerName ( &m_strServer, strServer );
	}
}

STDMETHODIMP CNntpVirtualRoots::get_ServiceInstance ( long * plServiceInstance )
{
	return StdPropertyGet ( m_dwServiceInstance, plServiceInstance );
}

STDMETHODIMP CNntpVirtualRoots::put_ServiceInstance ( long lServiceInstance )
{
	return StdPropertyPut ( &m_dwServiceInstance, lServiceInstance );
}

STDMETHODIMP CNntpVirtualRoots::get_Count ( long * pdwCount )
{
	return StdPropertyGet ( m_dwCount, pdwCount );
}

//////////////////////////////////////////////////////////////////////
// Methods:
//////////////////////////////////////////////////////////////////////

STDMETHODIMP CNntpVirtualRoots::Enumerate ( )
{
	TraceFunctEnter ( "CNntpVirtualRoots::Enumerate" );

	HRESULT					hr	= NOERROR;
	CComPtr<IMSAdminBase>	pMetabase;

	// Clear the old enumeration:
	delete [] m_rgVRoots;
	m_rgVRoots	= NULL;
	m_dwCount	= 0;

	hr = m_mbFactory.GetMetabaseObject ( m_strServer, &pMetabase );
	if ( FAILED(hr) ) {
		goto Exit;
	}

	hr = GetVRootsFromMetabase ( pMetabase );
	if ( FAILED(hr) ) {
		goto Exit;
	}

Exit:
	TRACE_HRESULT(hr);
	TraceFunctLeave ();
	return hr;
}

STDMETHODIMP CNntpVirtualRoots::Item ( 
	long index, 
	INntpVirtualRoot ** ppVirtualRoot 
	)
{
	TraceFunctEnter ( "CNntpVirtualRoots::Item" );

	_ASSERT ( IS_VALID_OUT_PARAM ( ppVirtualRoot ) );

	*ppVirtualRoot = NULL;

	HRESULT							hr			= NOERROR;
	CComObject<CNntpVirtualRoot> *	pVirtualRoot	= NULL;

	if ( index < 0 || index >= m_dwCount ) {
		hr = NntpCreateException ( IDS_NNTPEXCEPTION_INVALID_INDEX );
		goto Exit;
	}

	hr = CComObject<CNntpVirtualRoot>::CreateInstance ( &pVirtualRoot );
	if ( FAILED(hr) ) {
		goto Exit;
	}

	_ASSERT ( pVirtualRoot );
	hr = pVirtualRoot->SetProperties ( m_rgVRoots[index] );
	if ( FAILED(hr) ) {
		goto Exit;
	}

	hr = pVirtualRoot->QueryInterface ( IID_INntpVirtualRoot, (void **) ppVirtualRoot );
	_ASSERT ( SUCCEEDED(hr) );

Exit:
	if ( FAILED(hr) ) {
		delete pVirtualRoot;
	}

	TRACE_HRESULT(hr);
	TraceFunctLeave ();
	return hr;
}

STDMETHODIMP CNntpVirtualRoots::Add ( 
	INntpVirtualRoot	* pVirtualRoot
	)
{
	TraceFunctEnter ( "CNntpVirtualRoots::Add" );

	_ASSERT ( IS_VALID_IN_PARAM ( pVirtualRoot ) );

	HRESULT					hr	= NOERROR;
	CVRoot *				rgNewVirtualRoots	= NULL;
	long					i;
	CComPtr<IMSAdminBase>	pMetabase;
	CVRoot					newVroot;
    WCHAR					wszName [ 2*METADATA_MAX_NAME_LEN ];
    WCHAR					wszVRootPath [ 2*METADATA_MAX_NAME_LEN ];

	//	Validate the new Virtual Root:
	hr = newVroot.SetProperties ( pVirtualRoot );
	if ( FAILED(hr) ) {
		return hr;
	}

	if ( !newVroot.m_strNewsgroupSubtree ||
		!newVroot.m_strNewsgroupSubtree[0] ) {

		return RETURNCODETOHRESULT ( ERROR_INVALID_PARAMETER );
	}

	//	Add the new virtual root to the metabase:
	GetVRootName ( newVroot.m_strNewsgroupSubtree, wszName );

	//
	// The sub tree itself should not exceed length METADATA_MAX_NAME_LEN
	//
	_ASSERT( wcslen( wszName ) <= METADATA_MAX_NAME_LEN );
	if ( wcslen( wszName ) > METADATA_MAX_NAME_LEN ) {
	    return CO_E_PATHTOOLONG;
	}

	hr = m_mbFactory.GetMetabaseObject ( m_strServer, &pMetabase );
	if ( FAILED(hr) ) {
		return hr;
	}

	CMetabaseKey mb ( pMetabase );
	
	GetMDVRootPath ( wszVRootPath );

    //
	// I trust wszVRootPath, it's shorter than METADATA_MAX_NAME_LEN
	//

    //
    //  Test to see if this item exists already:
    //

    WCHAR	wszTempPath [ 2 * METADATA_MAX_NAME_LEN + 1];

    wsprintf ( wszTempPath, _T("%s%s"), wszVRootPath, wszName );
    if ( wcslen( wszTempPath ) > METADATA_MAX_NAME_LEN ) {

        //
        // I can't handle it either
        //
        return CO_E_PATHTOOLONG;
    }

	hr = mb.Open ( wszTempPath );
	if ( SUCCEEDED(hr) ) {
        DWORD   cbVrootDir;

        if ( SUCCEEDED ( mb.GetDataSize (
                _T(""),
                MD_VR_PATH,
                STRING_METADATA,
                &cbVrootDir,
                METADATA_NO_ATTRIBUTES )
                ) ) {

            mb.Close();

		    hr = NntpCreateException ( IDS_NNTPEXCEPTION_VROOT_ALREADY_EXISTS );
            goto Exit;
        }
    }

	hr = mb.Open ( wszVRootPath, METADATA_PERMISSION_WRITE );
	BAIL_ON_FAILURE(hr);

/*
	hr = mb.CreateChild ( wszName );
	BAIL_ON_FAILURE(hr);
*/

	hr = newVroot.SendToMetabase ( &mb, wszName );
	BAIL_ON_FAILURE(hr);

	hr = mb.Save ();
	BAIL_ON_FAILURE(hr);

	//	Allocate the new VirtualRoot array:
	rgNewVirtualRoots	= new CVRoot [ m_dwCount + 1 ];
	if ( !rgNewVirtualRoots ) {
		hr = E_OUTOFMEMORY;
		goto Exit;
	}

	//	Copy the old VirtualRoots to the new array:
	for ( i = 0; i < m_dwCount; i++ ) {
		hr = rgNewVirtualRoots[i].SetProperties ( m_rgVRoots[i] );
		if ( FAILED (hr) ) {
			goto Exit;
		}
	}

	//	Add the new VirtualRoot to the end of the array:
	hr = rgNewVirtualRoots[m_dwCount].SetProperties ( pVirtualRoot );
	if ( FAILED(hr) ) {
		goto Exit;
	}

	_ASSERT ( SUCCEEDED(hr) );
	delete [] m_rgVRoots;
	m_rgVRoots = rgNewVirtualRoots;
	m_dwCount++;

Exit:
	TraceFunctLeave ();
	return hr;
}

STDMETHODIMP CNntpVirtualRoots::Set ( 
	long index, 
	INntpVirtualRoot * pVirtualRoot 
	)
{
	TraceFunctEnter ( "CNntpVirtualRoots::ChangeVirtualRoot" );

	HRESULT		hr	= NOERROR;

	CComBSTR	strNewsgroupSubtree;
	CComBSTR	strDirectory;
	CVRoot		temp;
	CComPtr<IMSAdminBase>	pMetabase;
	WCHAR		wszVRootPath [ METADATA_MAX_NAME_LEN ];
	WCHAR		wszName [ METADATA_MAX_NAME_LEN ];

	// Send the new virtual root to the metabase:
	hr = m_mbFactory.GetMetabaseObject ( m_strServer, &pMetabase );
	if ( FAILED(hr) ) {
		return hr;
	}

	CMetabaseKey	mb ( pMetabase );

	if ( index < 0 || index >= m_dwCount ) {
		hr = NntpCreateException ( IDS_NNTPEXCEPTION_INVALID_INDEX );
		goto Exit;
	}

	hr = temp.SetProperties ( pVirtualRoot );
	if ( FAILED(hr) ) {
		goto Exit;
	}

	GetMDVRootPath ( wszVRootPath );

	hr = mb.Open ( wszVRootPath, METADATA_PERMISSION_WRITE );
	BAIL_ON_FAILURE(hr);

	GetVRootName ( temp.m_strNewsgroupSubtree, wszName );

	hr = temp.SendToMetabase ( &mb, wszName );
	BAIL_ON_FAILURE(hr);

	hr = m_rgVRoots[index].SetProperties ( pVirtualRoot );
	BAIL_ON_FAILURE(hr);

Exit:
	TraceFunctLeave ();
	return hr;
}

STDMETHODIMP CNntpVirtualRoots::Remove ( long index )
{
	TraceFunctEnter ( "CNntpVirtualRoots::Remove" );

	HRESULT		hr	= NOERROR;
	CVRoot	temp;
	long		cPositionsToSlide;
	CComPtr<IMSAdminBase>	pMetabase;
    WCHAR		wszName [ METADATA_MAX_NAME_LEN ];
    WCHAR		wszVRootPath [ METADATA_MAX_NAME_LEN ];

	if ( index < 0 || index >= m_dwCount ) {
		return NntpCreateException ( IDS_NNTPEXCEPTION_INVALID_INDEX );
	}

	// Delete the virtual root from the metabase:

	hr = m_mbFactory.GetMetabaseObject ( m_strServer, &pMetabase );
	if ( FAILED(hr) ) {
		return hr;
	}

	CMetabaseKey	mb ( pMetabase );
	
	GetMDVRootPath ( wszVRootPath );

	hr = mb.Open ( wszVRootPath, METADATA_PERMISSION_WRITE );
	BAIL_ON_FAILURE(hr);

	GetVRootName ( m_rgVRoots[index].m_strNewsgroupSubtree, wszName );

    hr = mb.DeleteAllData ( wszName );
	BAIL_ON_FAILURE(hr);

/*
	hr = mb.DestroyChild ( wszName );
	BAIL_ON_FAILURE(hr);
*/

	hr = mb.Save ();
	BAIL_ON_FAILURE(hr);

	mb.Close ();

	//	Slide the array down by one position:

	_ASSERT ( m_rgVRoots );

	cPositionsToSlide	= (m_dwCount - 1) - index;

	_ASSERT ( cPositionsToSlide < m_dwCount );

	if ( cPositionsToSlide > 0 ) {
		// Save the deleted VirtualRoot in temp:
		CopyMemory ( &temp, &m_rgVRoots[index], sizeof ( CVRoot ) );

		// Move the array down one:
		MoveMemory ( &m_rgVRoots[index], &m_rgVRoots[index + 1], sizeof ( CVRoot ) * cPositionsToSlide );

		// Put the deleted VirtualRoot on the end (so it gets destructed):
		CopyMemory ( &m_rgVRoots[m_dwCount - 1], &temp, sizeof ( CVRoot ) );

		// Zero out the temp VirtualRoot:
		ZeroMemory ( &temp, sizeof ( CVRoot ) );
	}

	m_dwCount--;

Exit:
	TraceFunctLeave ();
	return hr;
}

STDMETHODIMP CNntpVirtualRoots::Find ( BSTR strNewsgroupSubtree, long * pIndex )
{
	HRESULT		hr	= NOERROR;
	long		i;

	_ASSERT ( pIndex );
	*pIndex = -1;

	for ( i = 0; i < m_dwCount; i++ ) {

		if ( lstrcmp ( m_rgVRoots[i].m_strNewsgroupSubtree, strNewsgroupSubtree ) == 0 ) {
			*pIndex = i;
		}
	}

	return NOERROR;
}

static HRESULT CountVrootsIterator (
	CMetabaseKey * pMB,
	LPCWSTR wszVrootPath,
	LPARAM lParam
	)
{
	DWORD * pcVroots	= (DWORD *) lParam;

	(*pcVroots)++;

	return NOERROR;
}

typedef struct tagAddVrootsParms
{
	DWORD		cCount;
	CVRoot *	rgVroots;
	DWORD		dwCurrentIndex;
	LPWSTR      wszServerName;
	DWORD       dwInstanceId;
} ADD_VROOTS_PARMS;

static HRESULT AddVrootsIterator (
	CMetabaseKey * pMB,
	LPCWSTR wszVrootPath,
	LPARAM lParam
	)
{
	_ASSERT ( pMB );
	_ASSERT ( wszVrootPath );
	_ASSERT ( lParam );

	HRESULT				hr;
	ADD_VROOTS_PARMS *	pParms = (ADD_VROOTS_PARMS *) lParam;
	LPWSTR              wszServerName = pParms->wszServerName;
	DWORD               dwInstanceId = pParms->dwInstanceId;

	_ASSERT ( pParms->dwCurrentIndex < pParms->cCount );

	hr = pParms->rgVroots[pParms->dwCurrentIndex].GetFromMetabase (
		pMB,
		wszVrootPath,
		dwInstanceId,
		wszServerName
		);
	BAIL_ON_FAILURE(hr);

	pParms->dwCurrentIndex++;

Exit:
	return hr;
}

HRESULT CNntpVirtualRoots::GetVRootsFromMetabase ( IMSAdminBase * pMetabase )
{
	HRESULT				hr	= NOERROR;
	CMetabaseKey		mb ( pMetabase );
    WCHAR				wszVRootPath [ METADATA_MAX_NAME_LEN ];
    DWORD				cCount		= 0;
    CVRoot *			rgVroots	= NULL;
    ADD_VROOTS_PARMS	parms;

	//
	//	Initialize the metabase:
	//

	GetMDVRootPath ( wszVRootPath );

	hr = mb.Open ( wszVRootPath );
	BAIL_ON_FAILURE(hr);

	//
	//	Count the virtual roots:
	//

	hr = IterateOverVroots ( &mb, CountVrootsIterator, (LPARAM) &cCount );
	BAIL_ON_FAILURE(hr);

	//
	//	Create the virtual roots array:
	//

	rgVroots	= new CVRoot [ cCount ];
	if ( !rgVroots ) {
		hr = E_OUTOFMEMORY;
		goto Exit;
	}

	//
	//	Add the virtual roots to the array:
	//

	parms.cCount			= cCount;
	parms.rgVroots			= rgVroots;
	parms.dwCurrentIndex	= 0;
	parms.wszServerName     = m_strServer;
	parms.dwInstanceId      = m_dwServiceInstance;

	hr = IterateOverVroots ( &mb, AddVrootsIterator, (LPARAM) &parms );
	BAIL_ON_FAILURE(hr);

	_ASSERT ( SUCCEEDED(hr) );
	_ASSERT ( m_rgVRoots == NULL );
	m_rgVRoots 	= rgVroots;
	m_dwCount	= cCount;

Exit:
	if ( FAILED(hr) ) {
		delete [] rgVroots;
	}

	return hr;
}

HRESULT CNntpVirtualRoots::IterateOverVroots (
	CMetabaseKey *	pMB, 
	VROOT_ITERATOR	fpIterator,
	LPARAM			lParam,
	LPCWSTR			wszPath		// = _T("")
	)
{
	HRESULT		hr;
	WCHAR		wszSubKey[ METADATA_MAX_NAME_LEN ];
	WCHAR		wszSubPath[ METADATA_MAX_NAME_LEN ];
    BOOL        fRealVroot;
	DWORD		cbVrootDir;
	DWORD		i;

    //
	//	Is this a real vroot?
    //

    fRealVroot  =
        !*wszPath ||	// Always count the home directory
		SUCCEEDED ( pMB->GetDataSize ( 
				wszPath, 
				MD_VR_PATH, 
				STRING_METADATA, 
				&cbVrootDir, 
				METADATA_NO_ATTRIBUTES ) 
				);

    if ( fRealVroot ) {
		//	Call the iterator on this key:

		hr = (*fpIterator) ( pMB, wszPath, lParam );
		BAIL_ON_FAILURE(hr);
	}

	//
	//	Recurse down the tree:
	//

	for ( i = 0; ; ) {
		hr = pMB->EnumObjects ( wszPath, wszSubKey, i );

		if ( HRESULTTOWIN32(hr) == ERROR_NO_MORE_ITEMS ) {
			// This is expected, end the loop:

            if ( !fRealVroot && i == 0 ) {
                //
                //  This key isn't a vroot and has no children, so delete it.
                //

                hr = pMB->ChangePermissions ( METADATA_PERMISSION_WRITE );
                if ( SUCCEEDED(hr) ) {
                    hr = pMB->DeleteKey ( wszPath );
                }

                pMB->ChangePermissions ( METADATA_PERMISSION_READ );
                if ( SUCCEEDED(hr) ) {
                    hr = pMB->Save ();
                }

				if ( SUCCEEDED(hr) ) {
					//
					//	Tell our parent that this key was deleted.
					//

					hr = S_FALSE;
				}
				else {
					//
					//	Ignore any deleting problems:
					//

					hr = NOERROR;
				}
            }
			else {
				hr = NOERROR;
			}
			break;
		}
		BAIL_ON_FAILURE(hr);

		if ( *wszPath ) {
			if ( _snwprintf ( wszSubPath, sizeof(wszSubKey)/sizeof(wszSubKey[0]) - 1, _T("%s/%s"), wszPath, wszSubKey ) < 0 )
			{
				// Theoretically impossible because of the name length restriction of metabase
				// If it really happens, skip the recursive call and go on to the next one
				hr = NOERROR;
				i++;
				continue;
			}
			else
			{
				wszSubPath[sizeof(wszSubKey)/sizeof(wszSubKey[0]) - 1] = L'\0';
			}
		}
		else {
			wcscpy ( wszSubPath, wszSubKey );
		}

		hr = IterateOverVroots ( pMB, fpIterator, lParam, wszSubPath );
		BAIL_ON_FAILURE(hr);

		if ( hr != S_FALSE ) {
			//
			//	This means the child key still exists, so increment
			//	the counter and go on to the next one.
			//

			i++;
		}
		//
		//	Else the return code is S_FALSE, which means the current key
		//	has been deleted, shifting all indicies down by one.  Therefore,
		//	there is no need to increment i.
		//
	}

Exit:
	return hr;
}

void CNntpVirtualRoots::GetVRootName ( LPWSTR wszDisplayName, LPWSTR wszPathName )
{
	wcscpy ( wszPathName, wszDisplayName );
}

void CNntpVirtualRoots::GetMDVRootPath ( LPWSTR wszPath )
{
	GetMDInstancePath ( wszPath, m_dwServiceInstance );

	wcscat ( wszPath, _T("Root/") );
}

STDMETHODIMP CNntpVirtualRoots::ItemDispatch ( long index, IDispatch ** ppDispatch )
{
	HRESULT				hr;
	CComPtr<INntpVirtualRoot>	pVirtualRoot;

	hr = Item ( index, &pVirtualRoot );
	BAIL_ON_FAILURE ( hr );

	hr = pVirtualRoot->QueryInterface ( IID_IDispatch, (void **) ppDispatch );
	BAIL_ON_FAILURE ( hr );

Exit:
	return hr;
}

STDMETHODIMP CNntpVirtualRoots::AddDispatch ( IDispatch * pVirtualRoot )
{
	HRESULT				hr;
	CComPtr<INntpVirtualRoot>	pINntpVirtualRoot;

	hr = pVirtualRoot->QueryInterface ( IID_INntpVirtualRoot, (void **) &pINntpVirtualRoot );
	BAIL_ON_FAILURE(hr);

	hr = Add ( pINntpVirtualRoot );
	BAIL_ON_FAILURE(hr);

Exit:
	return hr;
}

STDMETHODIMP CNntpVirtualRoots::SetDispatch ( long lIndex, IDispatch * pVirtualRoot )
{
	HRESULT				hr;
	CComPtr<INntpVirtualRoot>	pINntpVirtualRoot;

	hr = pVirtualRoot->QueryInterface ( IID_INntpVirtualRoot, (void **) &pINntpVirtualRoot );
	BAIL_ON_FAILURE(hr);

	hr = Set ( lIndex, pINntpVirtualRoot );
	BAIL_ON_FAILURE(hr);

Exit:
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\nntp\adminsso\sessions.h ===
// sessions.h : Declaration of the CNntpAdminSessions


typedef struct _NNTP_SESSION_INFO * LPNNTP_SESSION_INFO;

/////////////////////////////////////////////////////////////////////////////
// nntpadm

class CNntpAdminSessions : 
	public INntpAdminSessions,
	public IPrivateUnknown,
	public IPrivateDispatch,
	public IADsExtension,
	public INonDelegatingUnknown,
	public ISupportErrorInfo,
	public CComObjectRoot,
	public CComCoClass<CNntpAdminSessions,&CLSID_CNntpAdminSessions>
{
public:
	CNntpAdminSessions();
	virtual ~CNntpAdminSessions ();
BEGIN_COM_MAP(CNntpAdminSessions)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(IADs)
	COM_INTERFACE_ENTRY(INntpAdminSessions)
	COM_INTERFACE_ENTRY(IADsExtension)
	COM_INTERFACE_ENTRY(IPrivateUnknown)
	COM_INTERFACE_ENTRY(IPrivateDispatch)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()
//DECLARE_NOT_AGGREGATABLE(CNntpAdminSessions) 
// Remove the comment from the line above if you don't want your object to 
// support aggregation.  The default is to support it

DECLARE_REGISTRY(CNntpAdminSessions, _T("Nntpadm.Sessions.1"), _T("Nntpadm.Sessions"), IDS_NNTPADMINSESSIONS_DESC, THREADFLAGS_BOTH)
// ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

	//
	// This declares methods for the following:
	// IADsExtension
	// IUnknown
	// IDispatch
	// IPrivateUnknown
	// IPrivateDispatch
	//
	#define THIS_LIBID	LIBID_NNTPADMLib
	#define THIS_IID	IID_INntpAdminSessions
	#include "adsimp.inl"
	#undef	THIS_LIBID
	#undef	THIS_IID

// INntpAdminSessions
public:

    //
    //  IADs methods:
    //

    DECLARE_IADS_METHODS()

	//////////////////////////////////////////////////////////////////////
	// Properties:
	//////////////////////////////////////////////////////////////////////

	// Which service to configure:
	
	STDMETHODIMP	get_Server			( BSTR * pstrServer );
	STDMETHODIMP	put_Server			( BSTR strServer );

	STDMETHODIMP	get_ServiceInstance	( long * plServiceInstance );
	STDMETHODIMP	put_ServiceInstance	( long lServiceInstance );

	STDMETHODIMP	get_Count			( long * plCount );

	STDMETHODIMP	get_Username		( BSTR * pstrUsername );
	STDMETHODIMP	put_Username		( BSTR strUsername );

	STDMETHODIMP	get_IpAddress		( BSTR * pstrIpAddress );
	STDMETHODIMP	put_IpAddress		( BSTR strIpAddress );

	STDMETHODIMP	get_IntegerIpAddress	( long * plIpAddress );
	STDMETHODIMP	put_IntegerIpAddress	( long lIpAddress );

	STDMETHODIMP	get_Port			( long * plPort );

	STDMETHODIMP	get_AuthenticationType	( long * plAuthenticationType );

	STDMETHODIMP	get_IsAnonymous		( BOOL * pfAnonymous );

	STDMETHODIMP	get_StartTime		( DATE * pdateStart );

	//////////////////////////////////////////////////////////////////////
	// Methods:
	//////////////////////////////////////////////////////////////////////

	STDMETHODIMP	Enumerate		( );
	STDMETHODIMP	GetNth			( long lIndex );
	STDMETHODIMP	Terminate		( );
	STDMETHODIMP	TerminateAll	( );

	//////////////////////////////////////////////////////////////////////
	// Data:
	//////////////////////////////////////////////////////////////////////
private:

	// Property variables:
    CIADsImpl   m_iadsImpl;

	DWORD		m_cCount;
	CComBSTR	m_strUsername;
	CComBSTR	m_strIpAddress;
	DWORD		m_dwIpAddress;
	DWORD		m_dwPort;
	DWORD		m_dwAuthenticationType;
	BOOL		m_fIsAnonymous;
	DATE		m_dateStartTime;

	// Service variables:
	BOOL		m_fSetCursor;
	LPNNTP_SESSION_INFO		m_pSessionInfo;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\nntp\adminsso\sessions.cpp ===
// sessions.cpp : Implementation of CnntpadmApp and DLL registration.

#include "stdafx.h"

#include "nntpcmn.h"
#include "oleutil.h"
#include "sessions.h"

#include "nntptype.h"
#include "nntpapi.h"

#include <lmapibuf.h>

// Must define THIS_FILE_* macros to use NntpCreateException()

#define THIS_FILE_HELP_CONTEXT		0
#define THIS_FILE_PROG_ID			_T("Nntpadm.Sessions.1")
#define THIS_FILE_IID				IID_INntpAdminSessions

/////////////////////////////////////////////////////////////////////////////
//

//
// Use a macro to define all the default methods
//
DECLARE_METHOD_IMPLEMENTATION_FOR_STANDARD_EXTENSION_INTERFACES(NntpAdminSessions, CNntpAdminSessions, IID_INntpAdminSessions)

STDMETHODIMP CNntpAdminSessions::InterfaceSupportsErrorInfo(REFIID riid)
{
	static const IID* arr[] = 
	{
		&IID_INntpAdminSessions,
	};

	for (int i=0;i<sizeof(arr)/sizeof(arr[0]);i++)
	{
		if (InlineIsEqualGUID(*arr[i],riid))
			return S_OK;
	}
	return S_FALSE;
}

CNntpAdminSessions::CNntpAdminSessions () :
	m_cCount				( 0 ),
	m_dwIpAddress			( 0 ),
	m_dwPort				( 0 ),
	m_dwAuthenticationType	( 0 ),
	m_fIsAnonymous			( FALSE ),
	m_dateStartTime			( 0 ),
	m_pSessionInfo			( NULL ),
	m_fSetCursor			( FALSE )
	// CComBSTR's are initialized to NULL by default.
{
	InitAsyncTrace ( );

    m_iadsImpl.SetService ( MD_SERVICE_NAME );
    m_iadsImpl.SetName ( _T("Sessions") );
    m_iadsImpl.SetClass ( _T("IIsNntpSessions") );
}

CNntpAdminSessions::~CNntpAdminSessions ()
{
	if ( m_pSessionInfo ) {
		NetApiBufferFree ( m_pSessionInfo );
	}

	// All CComBSTR's are freed automatically.
	TermAsyncTrace ( );
}

//
//  IADs methods:
//

DECLARE_SIMPLE_IADS_IMPLEMENTATION(CNntpAdminSessions,m_iadsImpl)

//
//	Properties:
//

STDMETHODIMP CNntpAdminSessions::get_Count ( long * plCount )
{
	// Count should check to be sure the client enumerated.

	return StdPropertyGet ( m_cCount, plCount );
}

STDMETHODIMP CNntpAdminSessions::get_Username ( BSTR * pstrUsername )
{
	return StdPropertyGet ( m_strUsername, pstrUsername );
}

STDMETHODIMP CNntpAdminSessions::put_Username ( BSTR strUsername )
{
	_ASSERT ( strUsername );
	_ASSERT ( IS_VALID_STRING ( strUsername ) );

	if ( strUsername == NULL ) {
		return E_POINTER;
	}

	if ( lstrcmp ( strUsername, _T("") ) == 0 ) {
		m_strUsername.Empty();

		return NOERROR;
	}
	else {
		return StdPropertyPut ( &m_strUsername, strUsername );
	}
}

STDMETHODIMP CNntpAdminSessions::get_IpAddress ( BSTR * pstrIpAddress )
{
	return StdPropertyGet ( m_strIpAddress, pstrIpAddress );
}

STDMETHODIMP CNntpAdminSessions::put_IpAddress ( BSTR strIpAddress )
{
	_ASSERT ( strIpAddress );
	_ASSERT ( IS_VALID_STRING ( strIpAddress ) );

	if ( strIpAddress == NULL ) {
		return E_POINTER;
	}

	if ( lstrcmp ( strIpAddress, _T("") ) == 0 ) {
		m_strIpAddress.Empty();
		m_dwIpAddress	= 0;

		return NOERROR;
	}
	else {
		// The IP Address value has two properties, so keep them in sync.
	
		StringToInetAddress ( strIpAddress, &m_dwIpAddress );

		return StdPropertyPut ( &m_strIpAddress, strIpAddress );
	}
}

STDMETHODIMP CNntpAdminSessions::get_IntegerIpAddress ( long * plIpAddress )
{
	return StdPropertyGet ( m_dwIpAddress, plIpAddress );
}

STDMETHODIMP CNntpAdminSessions::put_IntegerIpAddress ( long lIpAddress )
{
	HRESULT		hr					= NOERROR;
	WCHAR		wszAddress[100];
	DWORD		dwOldIpAddress		= m_dwIpAddress;

	hr = StdPropertyPut ( &m_dwIpAddress, lIpAddress );

	if ( FAILED (hr) ) {
		goto Exit;
	}

	// The IP Address value has two properties, so keep them in sync.

	if ( !InetAddressToString ( lIpAddress, wszAddress, 100 ) ) {
		hr = E_FAIL;
		goto Exit;
	}

	m_strIpAddress = wszAddress;

	if ( m_strIpAddress == NULL ) {
		hr = E_OUTOFMEMORY;
		goto Exit;
	}

Exit:

	if ( FAILED (hr) ) {
		// We failed, so put back the old IP address:

		m_dwIpAddress = dwOldIpAddress;
	}

	return hr;
}

STDMETHODIMP CNntpAdminSessions::get_Port ( long * plPort )
{
	CHECK_FOR_SET_CURSOR ( m_pSessionInfo != NULL, m_fSetCursor );

	return StdPropertyGet ( m_dwPort, plPort );
}

STDMETHODIMP CNntpAdminSessions::get_AuthenticationType ( long * plAuthenticationType )
{
	CHECK_FOR_SET_CURSOR ( m_pSessionInfo != NULL, m_fSetCursor );

	return StdPropertyGet ( m_dwAuthenticationType, plAuthenticationType );
}

STDMETHODIMP CNntpAdminSessions::get_IsAnonymous ( BOOL * pfAnonymous )
{
	CHECK_FOR_SET_CURSOR ( m_pSessionInfo != NULL, m_fSetCursor );

	return StdPropertyGet ( m_fIsAnonymous, pfAnonymous );
}

STDMETHODIMP CNntpAdminSessions::get_StartTime ( DATE * pdateStart )
{
	CHECK_FOR_SET_CURSOR ( m_pSessionInfo != NULL, m_fSetCursor );

	return StdPropertyGet ( m_dateStartTime, pdateStart );
}

//////////////////////////////////////////////////////////////////////
// Methods:
//////////////////////////////////////////////////////////////////////

STDMETHODIMP CNntpAdminSessions::Enumerate ( )
{
	TraceFunctEnter ( "CNntpAdminSessions::Enumerate" );

	// Variables:
	HRESULT					hr			= NOERROR;
	NET_API_STATUS			err;

	// Validate Server & Service Instance:
	if ( m_iadsImpl.QueryInstance() == 0 ) {
		return NntpCreateException ( IDS_NNTPEXCEPTION_SERVICE_INSTANCE_CANT_BE_ZERO );
	}

	// Enumerating loses the cursor:
	m_fSetCursor = FALSE;

	if ( m_pSessionInfo ) {
		NetApiBufferFree ( m_pSessionInfo );
	}

	// Call the enumerate sessions RPC:

	err = NntpEnumerateSessions (
        m_iadsImpl.QueryComputer(),
        m_iadsImpl.QueryInstance(),
		&m_cCount,
		&m_pSessionInfo
		);

	if ( err != NOERROR ) {
		hr = RETURNCODETOHRESULT ( err );
		goto Exit;
	}

Exit:
	TRACE_HRESULT(hr);
	TraceFunctLeave ();
	return hr;
}

STDMETHODIMP CNntpAdminSessions::GetNth ( long lIndex )
{
	TraceFunctEnter ( "CNntpAdminSessions::GetNth" );

	HRESULT		hr	= NOERROR;
    FILETIME    ftLocal;
	SYSTEMTIME	st;
	WCHAR		wszUsername[MAX_USER_NAME_LENGTH + 1];
	WCHAR		wszIpAddress[256];
	DWORD		cchCopied;

	*wszUsername = NULL;

	// Did we enumerate first?
	if ( m_pSessionInfo == NULL ) {

		return NntpCreateException ( IDS_NNTPEXCEPTION_DIDNT_ENUMERATE );
	}
	
	// Is the index valid?
	if ( lIndex < 0 || (DWORD) lIndex >= m_cCount ) {
		return NntpCreateException ( IDS_NNTPEXCEPTION_INVALID_INDEX );
	}

	//
	// Copy the properties from m_pSessionInfo [ lIndex ] to member variables:
	//

	// ( CComBSTR handles free-ing of old properties )

    FileTimeToLocalFileTime ( &m_pSessionInfo[ lIndex ].SessionStartTime, &ftLocal );
	FileTimeToSystemTime 	( &ftLocal, &st );
	SystemTimeToVariantTime	( &st, &m_dateStartTime );

	m_dwIpAddress			= m_pSessionInfo[ lIndex ].IPAddress;
	m_dwAuthenticationType	= m_pSessionInfo[ lIndex ].AuthenticationType;
	m_dwPort				= m_pSessionInfo[ lIndex ].PortConnected;
	m_fIsAnonymous			= m_pSessionInfo[ lIndex ].fAnonymous;

	cchCopied = MultiByteToWideChar ( 
		CP_ACP, 
		MB_PRECOMPOSED | MB_USEGLYPHCHARS,
		m_pSessionInfo[ lIndex ].UserName,
		-1,
		wszUsername,
		MAX_USER_NAME_LENGTH
		);

	m_strUsername = wszUsername;

	if ( m_strUsername == NULL ) {
		hr = E_OUTOFMEMORY;
		goto Exit;
	}

	InetAddressToString ( m_dwIpAddress, wszIpAddress, 256 );

	m_strIpAddress = wszIpAddress;

	if ( m_strIpAddress == NULL ) {
		hr = E_OUTOFMEMORY;
		goto Exit;
	}

	// GetNth sets the cursor:
	m_fSetCursor = TRUE;

Exit:
	TRACE_HRESULT(hr);
	TraceFunctLeave ();
	return hr;
}

STDMETHODIMP CNntpAdminSessions::Terminate ( )
{
	TraceFunctEnter ( "CNntpAdminSessions::Terminate" );

	HRESULT	hr = NOERROR;
	DWORD	err = NOERROR;
	char	szAnsiUsername[ MAX_USER_NAME_LENGTH + 1];
	char	szAnsiIpAddress[ 50 ];
	DWORD	cchCopied;

	szAnsiUsername[0]	= NULL;
	szAnsiIpAddress[0]	= NULL;

	// Validate Server & Service Instance:
	if ( m_iadsImpl.QueryInstance() == 0 ) {
		return NntpCreateException ( IDS_NNTPEXCEPTION_SERVICE_INSTANCE_CANT_BE_ZERO );
	}

	// Check Username & IpAddress parameters:
	if ( m_strUsername == NULL && m_strIpAddress == NULL ) {
		return NntpCreateException ( IDS_NNTPEXCEPTION_MUST_SUPPLY_USERNAME_OR_IPADDRESS );
	}

	// Translate the username & ipaddress to ANSI.
	if ( m_strUsername != NULL ) {
		cchCopied = WideCharToMultiByte ( 
			CP_ACP,
			0, 
			m_strUsername,
			-1,
			szAnsiUsername,
			MAX_USER_NAME_LENGTH,
			NULL,
			NULL
			);
	}

	if ( m_strIpAddress != NULL ) {
		cchCopied = WideCharToMultiByte ( 
			CP_ACP,
			0, 
			m_strIpAddress,
			-1,
			szAnsiIpAddress,
			50,
			NULL,
			NULL
			);
	}

	// Call the TerminateSession RPC:
	err = NntpTerminateSession ( 
        m_iadsImpl.QueryComputer(),
        m_iadsImpl.QueryInstance(),
		m_strUsername ? szAnsiUsername : NULL,
		m_strIpAddress ? szAnsiIpAddress : NULL
		);

	if ( err != NOERROR ) {
		hr = RETURNCODETOHRESULT ( err );
		goto Exit;
	}

Exit:
	TRACE_HRESULT(hr);
	TraceFunctLeave ();
	return hr;
}

STDMETHODIMP CNntpAdminSessions::TerminateAll ( )
{
	TraceFunctEnter ( "CNntpAdminSessions::TerminateAll" );

	// Did we enumerate first?

	HRESULT				hr			= NOERROR;
	DWORD				ErrResult 	= NOERROR;
	DWORD				Err			= NOERROR;
	DWORD				i;

	// Validate Server & Service Instance:
	if ( m_iadsImpl.QueryInstance() == 0 ) {
		return NntpCreateException ( IDS_NNTPEXCEPTION_SERVICE_INSTANCE_CANT_BE_ZERO );
	}

#if 0
	// Make sure the user has enumerated:
	if ( m_pSessionInfo == NULL ) {
		return NntpCreateException ( IDS_NNTPEXCEPTION_DIDNT_ENUMERATE );
	}
#endif

	// For Each Session:
	for ( i = 0; i < m_cCount; i++ ) {

		// Call the terminate session RPC:
		Err = NntpTerminateSession ( 
            m_iadsImpl.QueryComputer(),
            m_iadsImpl.QueryInstance(),
			m_pSessionInfo[ i ].UserName,
			NULL
			);

		if ( Err != 0 && ErrResult == 0 ) {
			ErrResult = Err;
		}
	}

	if ( ErrResult != NOERROR ) {
		hr = RETURNCODETOHRESULT ( ErrResult );
		goto Exit;
	}

Exit:
	TRACE_HRESULT(hr);
	TraceFunctLeave ();
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\nntp\core\fixprop\src\fixprop.cpp ===
/*++

Copyright (c) 1998-1999 Microsoft Corporation

Module Name:

    fixprop.cpp

Abstract:

    This module contains class declarations/definitions for

        CFixPropPersist

    **** Overview ****

    The class is the implementation of a fixed sized property
    storage.  It is mainly used for news group's fixed sized
    property.

	It's MT safe, except that group property consistency can
	not be guaranteed if two threads work on the same group.
	This is because this object assumes that group write/read
	access lock has already been implemented in group object
	and newstree.

Author:

    Kangrong Yan    ( KangYan )     7-5-1998

Revision History:

--*/
#include "stdinc.h"
#include "fixprop.h"
#include <time.h>


#define FLAG_WITH_ID_HIGH   0x00000001  // whether the file has id high
#define FLAG_IN_ORDER       0x00000002  // whether the file is in order
#define ID_HIGH_INIT        256

CPool   CFreeInfo::g_FreeInfoPool(FREEINFO_SIGNATURE);
LONG    CFixPropPersist::m_lRef = 0;
CShareLockNH  CFixPropPersist::m_sLock;

//
// Used to determine when we should update start hints.
//
void StartHintFunction(void);
static DWORD g_dwHintCounter=0;
static time_t g_tNextHint=0;



//
// Compare function for qsort
//

int __cdecl
CompareDataBlock(const void *pElem1, const void *pElem2) {

	// Update our hints roughly every five seconds.  We only check the
	// time every 100 compares or so..
	if( g_dwHintCounter++ % 100 == 0 ) {
		time_t now = time(NULL);
		if (now > g_tNextHint) {
			StartHintFunction();
			g_tNextHint = now + 5;
		}
	}

    return lstrcmp(
        (*(DATA_BLOCK**)pElem1)->szGroupName,
        (*(DATA_BLOCK**)pElem2)->szGroupName);

}

////////////////////////////////////////////////////////////////////
// CFreeInfo CPool Related methods
BOOL
CFreeInfo::InitClass()
{ return g_FreeInfoPool.ReserveMemory( MAX_FREEINFO_OBJECTS, MAX_FREEINFO_SIZE ); }

BOOL
CFreeInfo::TermClass()
{
	_ASSERT( g_FreeInfoPool.GetAllocCount() == 0 );
	return g_FreeInfoPool.ReleaseMemory();
}

//
// Constrcutor, destructor
//
CFixPropPersist::CFixPropPersist( 	IN LPSTR szStorageFile ) :
	m_FreeList( &CFreeInfo::m_pPrev, &CFreeInfo::m_pNext ),
	m_cCurrentMaxBlocks( 0 ),
	m_hStorageFile( INVALID_HANDLE_VALUE ),
	m_hBackupFile( INVALID_HANDLE_VALUE ),
	m_pvContext( NULL ),
	m_dwIdHigh( ID_HIGH_INVALID )
{
	TraceFunctEnter( "CFixPropPersist::CFixPropPersist" );
	_ASSERT( lstrlen( szStorageFile ) < sizeof(m_szStorageFile)  );
	lstrcpyn( m_szStorageFile, szStorageFile, sizeof(m_szStorageFile) / sizeof(m_szStorageFile[0]) );
	TraceFunctLeave();
}

CFixPropPersist::~CFixPropPersist()
{}

////////////////////////////////////////////////////////////////////
// Debug related methods
#ifdef DEBUG
VOID CFixPropPersist::DumpFreeList()
{
	CFreeInfo *pifFreeInfo = NULL;
	TFListEx<CFreeInfo>::Iterator it(&m_FreeList);

	while ( !it.AtEnd() ) {
		pifFreeInfo = it.Current();
		_ASSERT( pifFreeInfo );
		printf( "Offset: %d\n", pifFreeInfo->m_dwOffset );
		it.Next();
	}
}

VOID CFixPropPersist::Validate()
{
	CFreeInfo *pfiFreeInfo;
	TFListEx<CFreeInfo>::Iterator it(&m_FreeList, TRUE );

	// Validate Free List elements
	while ( !it.AtEnd() ) {
		pfiFreeInfo = it.Current();
		_ASSERT( pfiFreeInfo );
		_ASSERT( pfiFreeInfo->m_dwOffset < m_cCurrentMaxBlocks );
		it.Next();
	}
}

#endif

/////////////////////////////////////////////////////////////////
// Initialization, Termination
BOOL CFixPropPersist::Init( IN BOOL bCreateIfNonExist,
							IN PVOID pvContext,
							OUT PDWORD pdwIdHigh,
							IN PFNENUMCALLBACK pfnEnumCallback )
/*++
Routine description:

	Initialization:
		If the storage file exists, try to load its free block info;
		else if asked to create a new storage file, create a file
		with ALLOC_GRANURALITY blocks and pre-set them to be free,
		link them into free list.  If not asked to create a new file
		but the file doesn't already exist, I'll fail. :(

	It can only be called once,by one thread, before using all other
	interfaces.

Arguments:

	IN BOOL bCreateIfNonExist - Shall I create a new file if it doesn't exist ?
	IN PVOID pvContext - Context passed in by user
	OUT PDWORD pdwIdHigh - The group id high; if 0xffffffff, the file is with old
	                        format
	IN PFNENUMCALLBACK pfnEnumCallback - What to do with enumerated group info?

Return value:

	TRUE on success, FALES otherwise, check LastError for detailed
	error info.
--*/
{
	TraceFunctEnter( "CFixPropPersist::Init" );

	DATA_BLOCK	dbBuffer;
	DWORD		dwBytesRead = 0;
	DWORD		dwBytesWritten = 0;
	DWORD		i;
	BOOL		bIsFreeBlock = FALSE;
	BOOL		bSuccess = FALSE;
	CFreeInfo	*pfiFreeInfo = NULL;
	HANDLE		hStorageFile = INVALID_HANDLE_VALUE;
	LARGE_INTEGER liLeadingDwords;
	BOOL        bSucceeded = FALSE;
	BOOL        bInOrder = FALSE;

	DWORD       dwHeaderLength = 0;
	HANDLE      hMap = NULL;
	LPVOID      pMap = NULL;
	DWORD       *pdwHeader;
	DATA_BLOCK  **pInUseBlocks = NULL;

	SetLastError( NO_ERROR );

	if (pdwIdHigh) *pdwIdHigh = ID_HIGH_INIT + 1;

	m_sLock.ExclusiveLock();

	// Init CPool stuff first
	if ( InterlockedIncrement( &m_lRef ) == 1 ) {
    	if ( !CFreeInfo::InitClass() ) {
	    	ErrorTrace(0, "Init cpool fail" );
		    if ( GetLastError() == NO_ERROR )
			    SetLastError( ERROR_OUTOFMEMORY );
    		goto Exit;
	    }
	}

	// Set Context pointer
	m_pvContext = pvContext;

	// Detect if we are going to use the ordered group.lst or
	// the non-ordered
	if ( !ProbeForOrder( bInOrder ) ) {
	    ErrorTrace( 0, "Probe for order failed %d", GetLastError() );
	    goto Exit;
	}

	// Open storage file to scan and build free list
	_ASSERT( hStorageFile == INVALID_HANDLE_VALUE );
	_ASSERT( lstrlen( m_szStorageFile ) < sizeof(m_szStorageFile) /sizeof( m_szStorageFile[0]) );
	hStorageFile = CreateFile(
	    m_szStorageFile,
	    GENERIC_READ,
	    FILE_SHARE_READ,	// no one else can write
	    NULL,
	    OPEN_EXISTING,
	    bInOrder ? FILE_FLAG_SEQUENTIAL_SCAN : FILE_FLAG_RANDOM_ACCESS,
	    NULL );

	if ( hStorageFile == INVALID_HANDLE_VALUE ) { // then I create it
		if ( bCreateIfNonExist ) {
			hStorageFile = CreateFile(	m_szStorageFile,
											GENERIC_WRITE,
											FILE_SHARE_READ, // no one else can write
											NULL,
											CREATE_ALWAYS,
											FILE_FLAG_SEQUENTIAL_SCAN,
											NULL );
			if ( hStorageFile != INVALID_HANDLE_VALUE ) {

				// Put two DWORD's into the file first:
				// One is the signature, the other
				// reserved - no use for now
				dwBytesWritten = 0;
				liLeadingDwords.LowPart = FIXPROP_SIGNATURE;
				liLeadingDwords.HighPart = FLAG_WITH_ID_HIGH;	// reserved
				if( !::WriteFile( 	hStorageFile,
									&liLeadingDwords,
									sizeof( LARGE_INTEGER ),
									&dwBytesWritten,
									NULL ) ||
						dwBytesWritten != sizeof( LARGE_INTEGER ) ) {
					ErrorTrace(0, "Write leading integer fail %d",
								GetLastError() );
					if ( GetLastError() == NO_ERROR )
						SetLastError( ERROR_WRITE_FAULT );
					goto Exit;
				}

				// Now write the idhigh
				m_dwIdHigh = ID_HIGH_INIT;
                if ( !::WriteFile(  hStorageFile,
                                    &m_dwIdHigh,
                                    sizeof( DWORD ),
                                    &dwBytesWritten,
                                    NULL ) ||
                        dwBytesWritten != sizeof( DWORD ) ) {
                    ErrorTrace( 0, "Write id high failed %d",
                                    GetLastError() );
                    if ( GetLastError() == NO_ERROR )
                        SetLastError( ERROR_WRITE_FAULT );
                    goto Exit;
                }

				// Every time pre-alloc ALLOC_GRANURALITY blocks
				// Prepare the init value for block
				*(dbBuffer.szGroupName) = 0;

				// Scan, write, and put to free list
				for ( i = 0; i < ALLOC_GRANURALITY; i++ ) {
					dwBytesWritten = 0;
					if ( ::WriteFile (	hStorageFile,
										&dbBuffer,
										sizeof( DATA_BLOCK ),
										&dwBytesWritten,
										NULL ) &&
						 dwBytesWritten == sizeof( DATA_BLOCK ) ) {

						// link it to free list
						pfiFreeInfo = new CFreeInfo;
						if ( pfiFreeInfo ) {
							pfiFreeInfo->m_dwOffset = i ;
							m_FreeList.PushFront( pfiFreeInfo );
							m_cCurrentMaxBlocks++;
							pfiFreeInfo = NULL;
						} else { // pfiFreeInfo == NULL
							SetLastError( ERROR_OUTOFMEMORY );
							ErrorTrace(	0,
										"Create Free Info fail %d",
										GetLastError() );
							break;
						}
					} else { // Write file fail
						ErrorTrace(0, "Write file fail %d", GetLastError() );
						if ( GetLastError() == NO_ERROR )
							SetLastError( ERROR_WRITE_FAULT );
						break;
					}
				}

			} else { // Create file fail
				ErrorTrace(0, "Create new storage file fail %d", GetLastError());
				if ( GetLastError() == NO_ERROR )
					SetLastError( ERROR_OPEN_FILES );
			    goto Exit;
			}
		} else { // !bCreateIfNonExist
			ErrorTrace(0, "Storage file not found %d", GetLastError() );
			if ( GetLastError() == NO_ERROR )
				SetLastError( ERROR_OPEN_FILES );
		    goto Exit;
		}
	} else { // File already exists and open succeeded

		_ASSERT( m_cCurrentMaxBlocks == 0 );	// not set yet

        DWORD dwFileSizeLow;
		DWORD dwFileSizeHigh;

		dwFileSizeLow = GetFileSize(hStorageFile, &dwFileSizeHigh);
		if (dwFileSizeLow == 0 || dwFileSizeHigh != 0) {
			ErrorTrace(0, "Bad group.lst size");
			SetLastError(ERROR_INVALID_DATA);
			goto Exit;
		}

		hMap = CreateFileMapping(
		  hStorageFile,                 // handle to file to map
		  NULL,                         // optional security attributes
		  PAGE_READONLY | SEC_COMMIT,   // protection for mapping object
		  0,                            // high-order 32 bits of object size
		  0,                            // low-order 32 bits of object size
		  NULL                          // name of file-mapping object
		);

        if (hMap == NULL) {
            ErrorTrace(0, "Couldn't map group.lst, err %d", GetLastError());
            goto Exit;
        }

		pMap = MapViewOfFile(hMap, FILE_MAP_READ, 0, 0, 0);
		if (pMap == NULL) {
		    ErrorTrace(0, "Couldn't map group.lst, err %d", GetLastError());
		    goto Exit;
		}

        pdwHeader = (DWORD*)pMap;
		dwHeaderLength = 2*sizeof(DWORD);

		// Check file signature
        if (FIXPROP_SIGNATURE != pdwHeader[0]) {
			ErrorTrace(0, "Loading file fail %d", GetLastError() );
			SetLastError( ERROR_OLD_WIN_VERSION ); // BUGBUG: fake err code, just used
			                                       // internally
            goto Exit;
        }

		// For files that has id high, load it
		if (pdwHeader[1] & FLAG_WITH_ID_HIGH ) {
		    m_dwIdHigh = pdwHeader[2];
		    dwHeaderLength += sizeof(DWORD);
        }

        _ASSERT( m_dwIdHigh >= ID_HIGH_INIT );

        if ( pdwIdHigh ) *pdwIdHigh = m_dwIdHigh + 1;

        //
        // Determine how many data blocks are in the file and allocate an
        // array of pointers for use by qsort
        //

		dwFileSizeLow -= dwHeaderLength;
		if ((dwFileSizeLow % sizeof(DATA_BLOCK)) != 0) {
		    ErrorTrace(0, "Filesize(%d) not multiple of DATA_BLOCK(%d)",
		        dwFileSizeLow, sizeof(DATA_BLOCK));
		    SetLastError(ERROR_INVALID_DATA);
		    goto Exit;
		}
		DWORD cDataBlocks = dwFileSizeLow / sizeof(DATA_BLOCK);
		DATA_BLOCK* pBlock = (DATA_BLOCK*)((char*)pMap + dwHeaderLength);

		pInUseBlocks = XNEW DATA_BLOCK* [cDataBlocks];
		if (pInUseBlocks == NULL) {
		    goto Exit;
		}

		DWORD cInUseBlocks = 0;

		for (DWORD i2=0; i2<cDataBlocks; i2++) {

	        // Update our hints roughly every five seconds.  We only check the
	        // time every 100 groups or so..
	        if( (i2 % 100) == 0 ) {
		        time_t now = time(NULL);
		        if (now > g_tNextHint) {
			        StartHintFunction();
			        g_tNextHint = now + 5;
		        }
	        }

			if (pBlock[i2].szGroupName[0] == 0) {
                // Free block
				pfiFreeInfo = new CFreeInfo;
				if ( pfiFreeInfo ) {
					pfiFreeInfo->m_dwOffset = i2;
					m_FreeList.PushFront( pfiFreeInfo );
					pfiFreeInfo = NULL;
				} else { // new fail
					ErrorTrace(0, "Alloc CFreeInfo fail" );
					SetLastError( ERROR_OUTOFMEMORY );
					break;	// no point continuing
				}
			} else {
				// In use block
				pInUseBlocks[cInUseBlocks++] = &pBlock[i2];
			}

		}

        // Sort the array
        if (!bInOrder) {
    		qsort(pInUseBlocks, cInUseBlocks, sizeof(DATA_BLOCK*), CompareDataBlock);
        }

        //
        // Now call the callback if one is provided.  We let it know that
        // the data's in order to speed up the insertions.
        //
		if ( pfnEnumCallback ) {
		    for (i=0; i<cInUseBlocks; i++) {
		        DWORD idx = (DWORD)(pInUseBlocks[i] - &pBlock[0]);

			    if ( !pfnEnumCallback( pBlock[idx], m_pvContext, idx, TRUE ) &&
				        GetLastError() != ERROR_INVALID_NAME &&
						GetLastError() != ERROR_ALREADY_EXISTS  ) {
					ErrorTrace(0, "Enumerate call back fail" );
					if ( GetLastError() == NO_ERROR ) {
						SetLastError( ERROR_INVALID_FUNCTION );
					}
					goto Exit;
				}
			}
		}

        m_cCurrentMaxBlocks = cDataBlocks;

	}

	_VERIFY( CloseHandle( hStorageFile ) );
	hStorageFile = INVALID_HANDLE_VALUE;

	// Last thing to do: Create the member handle for future async use
	_ASSERT( INVALID_HANDLE_VALUE == hStorageFile );
	_ASSERT( INVALID_HANDLE_VALUE == m_hStorageFile );

	m_hStorageFile = CreateFile(    m_szStorageFile,
		                            GENERIC_WRITE | GENERIC_READ,
									FILE_SHARE_READ, // no one else
													 // can write
									NULL,
									OPEN_EXISTING,
									FILE_FLAG_OVERLAPPED,
									NULL );
	if ( INVALID_HANDLE_VALUE == m_hStorageFile ) {
		if ( GetLastError() ==  NO_ERROR )
			SetLastError( ERROR_OPEN_FILES );
			goto Exit;
	}

	bSucceeded = TRUE;

Exit:

    DWORD gle = GetLastError();

    if (pMap != NULL) {
        _VERIFY(UnmapViewOfFile(pMap));
    }

    if (hMap != NULL) {
        _VERIFY(CloseHandle(hMap));
    }

    if (hStorageFile != INVALID_HANDLE_VALUE) {
        _VERIFY(CloseHandle(hStorageFile));
    }

    if (pInUseBlocks) {
        XDELETE [] pInUseBlocks;
    }

    if ( !bSucceeded ) {

        CleanFreeList();

        if ( InterlockedDecrement( &m_lRef ) == 0 ) {
            CFreeInfo::TermClass();
        }

    }

    m_sLock.ExclusiveUnlock();

	// Now we are done, return if we have been successful
	TraceFunctLeave();
	SetLastError(gle);
	return bSucceeded;
}

void
CFixPropPersist::CleanFreeList()
{
    CFreeInfo *pfiPtr = NULL;

    while( !m_FreeList.IsEmpty() ) {
        pfiPtr = m_FreeList.PopBack();
        _ASSERT( pfiPtr );
        if (pfiPtr) delete pfiPtr;
    }
}

BOOL CFixPropPersist::Term()
{
	CFreeInfo *pfiPtr = NULL;
	BOOL    b = TRUE;

    m_sLock.ExclusiveLock();
#if defined( DEBUG )
	Validate();
#endif

	SetLastError( NO_ERROR );

	// Close file handle
	_ASSERT( INVALID_HANDLE_VALUE != m_hStorageFile );
	_VERIFY( CloseHandle( m_hStorageFile ) );

	// Cleanup Free list
    CleanFreeList();

	// Terminate CPool stuff
	if ( InterlockedDecrement( &m_lRef ) == 0 ) {
	    b = CFreeInfo::TermClass();
	}

	m_sLock.ExclusiveUnlock();
	return b;
}

///////////////////////////////////////////////////////////////
// File read / write
BOOL CFixPropPersist::ReadFile( IN OUT PBYTE pbBuffer,
								IN DWORD	dwOffset,
								IN DWORD    dwSize,
								IN BOOL     bReadBlock )
/*++
Routine description:

	Read block from specified offset.

Arguments:

	IN DWORD dwOffset - Where into the file to read from ?
						If it's 0, then no seek is needed.
	IN OUT DATA_BLOCK& dbBuffer - Where to read the stuff into ?

Return value:

	TRUE on success, FALSE otherwise
--*/
{
	TraceFunctEnter( "CFixPropPersist::ReadFile" );
	_ASSERT( INVALID_HANDLE_VALUE != m_hStorageFile );
	_ASSERT( dwOffset < m_cCurrentMaxBlocks );
#if defined( DEBUG )
	Validate();
#endif

	DWORD dwErr = 0;
	LARGE_INTEGER	liOffset;
	BOOL	bSuccess = FALSE;
	DWORD   dwBytesRead = 0;

	SetLastError( NO_ERROR );

    if ( !bReadBlock ) {
        liOffset.QuadPart = sizeof( LARGE_INTEGER );
    } else {
        if ( ID_HIGH_INVALID != m_dwIdHigh ) {
            liOffset.QuadPart = sizeof( LARGE_INTEGER)
                                    + sizeof( DWORD ) +
                                    dwOffset * sizeof( DATA_BLOCK );
        } else {
        	liOffset.QuadPart =  sizeof( LARGE_INTEGER ) +
		    					dwOffset * sizeof( DATA_BLOCK );
        }
    }

    if ( AsyncRead( pbBuffer, liOffset, dwSize ) )
        bSuccess = TRUE;

	TraceFunctLeave();
	return bSuccess;
}

BOOL CFixPropPersist::WriteFile(	IN PBYTE    pbBuffer,
									IN DWORD	dwOffset,
									IN DWORD    dwSize,
									IN BOOL     bWriteBlock )
/*++
Routine description:

	Write block from specified offset.

Arguments:

	IN DWORD dwOffset - Where into the file to write from ?
						If it's 0, then no pre-seek is needed
	IN DATA_BLOCK& dbBuffer - Where to write the stuff from ?

Return value:

	TRUE on success, FALSE otherwise
--*/
{
	TraceFunctEnter( "CFixPropPersist::WriteFile" );
	_ASSERT( INVALID_HANDLE_VALUE != m_hStorageFile );
	_ASSERT( dwOffset < m_cCurrentMaxBlocks );
#if defined ( DEBUG )
	Validate();
#endif

	DWORD dwErr = 0;
	LARGE_INTEGER   liOffset;
	BOOL    bSuccess;

	SetLastError( NO_ERROR );

    if ( !bWriteBlock ) {
        liOffset.QuadPart = sizeof( LARGE_INTEGER );
    } else {
        if ( ID_HIGH_INVALID != m_dwIdHigh  ) {
            liOffset.QuadPart = sizeof( LARGE_INTEGER)
                                    + sizeof( DWORD ) +
                                    dwOffset * sizeof( DATA_BLOCK );
        } else {
        	liOffset.QuadPart =  sizeof( LARGE_INTEGER ) +
		    					dwOffset * sizeof( DATA_BLOCK );
        }
    }

	bSuccess = FALSE;
	if ( AsyncWrite( pbBuffer, liOffset, dwSize ) ) {
	    bSuccess = TRUE ;
	}

	TraceFunctLeave();
	return bSuccess;
}

BOOL
CFixPropPersist::AsyncRead( PBYTE           pbBuffer,
                            LARGE_INTEGER   liOffset,
                            DWORD           dwSize )
/*++
Routine description:

    Does an async read and event wait on the file

Arguments:

    LPSTR   pbBuffer -      Buffer for read
    LARGE_INTEGER liOffset -    Read offset
    DWORD   dwSize - Size to read

Return value:

    TRUE - Succeeded
    FALSE - Failed
--*/
{
    TraceFunctEnter( "CFixPropPersist::AsyncRead" );
    _ASSERT( pbBuffer );

    OVERLAPPED  ovl;
    BOOL        bSuccess = FALSE;
    DWORD       dwBytesRead = 0;

    ZeroMemory( &ovl, sizeof( ovl ) );

   	ovl.Offset = liOffset.LowPart;
	ovl.OffsetHigh = liOffset.HighPart;
	ovl.hEvent = GetPerThreadEvent();
	if ( NULL == ovl.hEvent ) {
	    _ASSERT( FALSE && "Event NULL" );
	    ErrorTrace( 0, "CreateEvent failed %d", GetLastError() );
	    return FALSE;
	}

	bSuccess = FALSE;
	if ( ::ReadFile(	m_hStorageFile,
					pbBuffer,
					dwSize,
					NULL,
					&ovl ) ||
		GetLastError() == ERROR_IO_PENDING ) {
		WaitForSingleObject( ovl.hEvent, INFINITE );
		if ( GetOverlappedResult(  m_hStorageFile,
		                            &ovl,
		                            &dwBytesRead,
		                            FALSE ) ) {
		    // bytes read should be the same as we specified
		    if ( dwBytesRead == dwSize ) {
                bSuccess = TRUE;
            }
        }
    } else {
        _VERIFY( ResetEvent( ovl.hEvent ) );
    }

	_ASSERT( ovl.hEvent );
	//_VERIFY( CloseHandle( ovl.hEvent ) );

    TraceFunctLeave();
	return bSuccess;
}

BOOL
CFixPropPersist::AsyncWrite( PBYTE           pbBuffer,
                             LARGE_INTEGER   liOffset,
                             DWORD           dwSize )
/*++
Routine description:

    Does an async write and event wait on the file

Arguments:

    LPSTR   pbBuffer -      Buffer for write
    LARGE_INTEGER liOffset -    Write offset
    DWORD   dwSize - Size to write

Return value:

    TRUE - Succeeded
    FALSE - Failed
--*/
{
    TraceFunctEnter( "CFixPropPersist::AsyncRead" );
    _ASSERT( pbBuffer );

    OVERLAPPED  ovl;
    BOOL        bSuccess = FALSE;
    DWORD       dwBytesWritten = 0;

    ZeroMemory( &ovl, sizeof( ovl ) );

   	ovl.Offset = liOffset.LowPart;
	ovl.OffsetHigh = liOffset.HighPart;
	ovl.hEvent = GetPerThreadEvent();
	if ( NULL == ovl.hEvent ) {
	    _ASSERT( FALSE && "Thread event NULL" );
	    ErrorTrace( 0, "CreateEvent failed %d", GetLastError() );
	    return FALSE;
	}

	bSuccess = FALSE;
	if ( ::WriteFile(	m_hStorageFile,
					pbBuffer,
					dwSize,
					NULL,
					&ovl ) ||
		    GetLastError() == ERROR_IO_PENDING ) {
		WaitForSingleObject( ovl.hEvent, INFINITE );
		if ( GetOverlappedResult(  m_hStorageFile,
		                            &ovl,
		                            &dwBytesWritten,
		                            FALSE ) ) {
		    // bytes read should be the same as we specified
		    if ( dwBytesWritten == dwSize ) {
                bSuccess = TRUE;
            }
        } else {
            _ASSERT( 0 );
        }
    }  else {
        _VERIFY( ResetEvent( ovl.hEvent ) );
    }

	_ASSERT( ovl.hEvent );
	//_VERIFY( CloseHandle( ovl.hEvent ) );

    TraceFunctLeave();
	return bSuccess;
}


BOOL CFixPropPersist::ExtendFile( 	IN DWORD cBlocks )
/*++
Routine description:

	Extend the file.

Arguments:

	IN DWORD cBlocks - Number of blocks to extend

Return value:

	TRUE on success, FALSE otherwise
--*/
{
	TraceFunctEnter( "CFixPropPersist::ExtendFile" );
	_ASSERT( INVALID_HANDLE_VALUE != m_hStorageFile );
	_ASSERT( cBlocks > 0 );
#if defined( DEBUG )
	Validate();
#endif

	DATA_BLOCK 	dbBuffer;
	DWORD		i;
	LARGE_INTEGER   liOffset;
	BOOL    bSuccess = TRUE;

	SetLastError( NO_ERROR );

	// Fill up overlapped structure
	*(dbBuffer.szGroupName) = 0;	// set it to free

	for( i = 0; i < cBlocks && bSuccess; i++ ) {

		if ( m_dwIdHigh != ID_HIGH_INVALID ) {
    		liOffset.QuadPart =  sizeof( LARGE_INTEGER ) +
    		                        + sizeof( DWORD ) +
	    	                        ( i + m_cCurrentMaxBlocks ) *
								sizeof( DATA_BLOCK );
		} else {
		    liOffset.QuadPart = sizeof( LARGE_INTEGER ) +
		                            ( i + m_cCurrentMaxBlocks ) *
		                            sizeof( DATA_BLOCK );
		}

		bSuccess = FALSE;
		if ( AsyncWrite(    PBYTE(&dbBuffer),
		                    liOffset,
		                    sizeof( DATA_BLOCK ) ) ){
		    bSuccess = TRUE ;
		    m_cCurrentMaxBlocks++;
		}
	}

	TraceFunctLeave();
	return bSuccess;
}

/////////////////////////////////////////////////////////////////
// File seek methods
DWORD CFixPropPersist::SeekByName( 	IN LPSTR szGroupName )
/*++
Routine description:

	Seek the file pointer associated with the handle by group name.
	This is used when the group property bag doesn't have offset
	information.

Arguments:

	IN LPSTR szGroupName - The name to match and find.

Return value:

	Offset, on success, 0xffffffff if failed
--*/
{
	TraceFunctEnter( "CFixPropPersist::SeekByName" );
	_ASSERT( INVALID_HANDLE_VALUE != m_hStorageFile );
	_ASSERT( szGroupName );
	_ASSERT( lstrlen( szGroupName ) < GROUPNAME_LEN_MAX );
#if defined( DEBUG )
	Validate();
#endif

	DWORD 		i;
	DATA_BLOCK	dbBuffer;
	LARGE_INTEGER   liOffset;
	DWORD           bSuccess = TRUE;

	SetLastError( NO_ERROR );

	for ( i = 0; i < m_cCurrentMaxBlocks && bSuccess; i++ ) {

        if ( m_dwIdHigh != ID_HIGH_INVALID ) {
    		liOffset.QuadPart =  sizeof( LARGE_INTEGER ) +
    		                        sizeof( DWORD ) +
	    	                        i * sizeof( DATA_BLOCK );
	    } else {
	        liOffset.QuadPart = sizeof( LARGE_INTEGER ) +
	                                i * sizeof( DATA_BLOCK );
	    }

        bSuccess = FALSE;
		if ( AsyncRead( PBYTE(&dbBuffer), liOffset, sizeof( DATA_BLOCK ) ) ) {
		    bSuccess = TRUE;
			if ( strcmp( dbBuffer.szGroupName, szGroupName ) == 0 ) {
				return i;
			}
		}
	}

	// Unfortunately, not found
	TraceFunctLeave();
	return 0xffffffff;
}

DWORD CFixPropPersist::SeekByGroupId( 	IN DWORD dwGroupId,
										IN LPSTR szGroupName)
/*++
Routine description:

	Seek the file pointer associated with the handle by group id.
	This is used when the group property bag doesn't have offset
	information.

Arguments:

	IN DWORD dwGroupId - The group id to match and find.
	IN LPSTR szGroupName - The group name to verify with

Return value:

	Offset, on success, 0xffffffff if failed
--*/
{
	TraceFunctEnter( "CFixPropPersist::SeekByGroupId" );
	_ASSERT( INVALID_HANDLE_VALUE != m_hStorageFile );
#if defined( DEBUG )
	Validate();
#endif

	DWORD 		i;
	DATA_BLOCK	dbBuffer;
	LARGE_INTEGER   liOffset;
	BOOL            bSuccess = TRUE;

	SetLastError( NO_ERROR );

	for ( i = 0; i < m_cCurrentMaxBlocks && bSuccess; i++ ) {

	    if ( m_dwIdHigh != ID_HIGH_INVALID ) {
    	    liOffset.QuadPart =  sizeof( LARGE_INTEGER ) +
    	                            sizeof( DWORD ) +
	                                i * sizeof( DATA_BLOCK );
	    } else {
	        liOffset.QuadPart = sizeof( LARGE_INTEGER ) +
	                                i * sizeof( DATA_BLOCK );
	    }

        bSuccess = FALSE;
        if ( AsyncRead( PBYTE(&dbBuffer), liOffset, sizeof( DATA_BLOCK ) ) ) {
            bSuccess = TRUE;
	        if ( dbBuffer.dwGroupId == dwGroupId ) {
				if ( strcmp( dbBuffer.szGroupName, szGroupName ) == 0 )
	            	return i;
	        }
	    }
	}

	// Unfortunately, not found
	TraceFunctLeave();
	return 0xffffffff;
}

DWORD	CFixPropPersist::SeekByBest( 	IN INNTPPropertyBag *pPropBag )
/*++
Routine description:

	Seek the file pointer by best methods:

Arguments:

	IN INNTPPropertyBag *pPropBag - Group's property bag.

Return value:

	Offset, if succeeded, 0xffffffff otherwise
--*/
{
	TraceFunctEnter( "CFixPropPersist::SeekByBest" );
	_ASSERT( m_hStorageFile );
	_ASSERT( pPropBag );
#if defined( DEBUG )
	Validate();
#endif

	DWORD 	dwOffset = 0;
	DWORD	dwGroupId;
	HRESULT	hr;
	BOOL	bFound = FALSE;
	DATA_BLOCK	dbBuffer;
	LARGE_INTEGER   liOffset;

	SetLastError( NO_ERROR );

    //
	// Get group id, we'll use group id to check if the group property
	// we got back is what we want, since group id is the only key to
	// uniquely identify a group
	//

	hr = pPropBag->GetDWord( NEWSGRP_PROP_GROUPID, &dwGroupId );
	if ( FAILED( hr ) ) {	// fatal
		ErrorTrace(0, "Group without id %x", hr );
		SetLastError( ERROR_INVALID_DATA );
		return 0xffffffff;
	}

	// Try to get offset from the bag
	dwOffset = GetGroupOffset( pPropBag );
	if ( dwOffset != 0xffffffff ) {	// use offset to seek

		if ( m_dwIdHigh != ID_HIGH_INVALID ) {
    		liOffset.QuadPart =  sizeof( LARGE_INTEGER ) +
    		                        sizeof( DWORD ) +
		                        dwOffset * sizeof( DATA_BLOCK );
		} else {
		    liOffset.QuadPart = sizeof( LARGE_INTEGER ) +
		                            dwOffset * sizeof( DATA_BLOCK );
		}

        if ( AsyncRead( PBYTE(&dbBuffer), liOffset, sizeof( DATA_BLOCK ) ) ) {
			if ( dwGroupId == dbBuffer.dwGroupId ) {
				// We found it, set file pointer back one block
				bFound = TRUE;
			}
		}
	}	// offset property exists


	if ( bFound )
		return dwOffset;
	else return 0xffffffff;
}

BOOL
CFixPropPersist::ProbeForOrder( BOOL& bInOrder )
/*++
Routine description:

    Probe the group.lst.ord to see if it's a good one ( in order and
    not corrupted ).  If it is, move it to group.lst, otherwise ,
    delete it.

Arguments:

    BOOL& bInOrder - Is the group.lst.ord good ?

Return value:

    TRUE succeeded, FALSE otherwise
--*/
{
    TraceFunctEnter( "CFixPropPersist::ProbeForOrder" );

    CHAR    szBackupFile[MAX_PATH+1];
    HANDLE  hFile = INVALID_HANDLE_VALUE;
    LARGE_INTEGER   lFlags;
    DWORD   dwRead = 0;

    // Try open the backup file
    lstrcpyn( szBackupFile, m_szStorageFile, sizeof(szBackupFile) - sizeof(".ord") + 1);
    strcat( szBackupFile, ".ord" );
    _ASSERT( strlen( szBackupFile ) < MAX_PATH + 1 );

    hFile = ::CreateFile(   szBackupFile,
                            GENERIC_READ,
                            FILE_SHARE_READ,
                            NULL,
                            OPEN_EXISTING,
                            FILE_FLAG_SEQUENTIAL_SCAN,
                            NULL );
    if ( INVALID_HANDLE_VALUE == hFile ) {

        // No order
        bInOrder = FALSE;
        goto Exit;
    }

    // Probe the flag to see if it's in good shape
    if ( !::ReadFile(   hFile,
                        &lFlags,
                        sizeof( LARGE_INTEGER ),
                        &dwRead,
                        NULL )  ||
        sizeof( LARGE_INTEGER ) != dwRead ) {

        // No order
        bInOrder = FALSE;
        goto Exit;
    }

    if ( lFlags.HighPart & FLAG_IN_ORDER )
        bInOrder = TRUE;
    else bInOrder = FALSE;

Exit:

    // Close the file handle, if necessary
    if ( INVALID_HANDLE_VALUE != hFile )
        _VERIFY( CloseHandle( hFile ) );

    // If in order, we do move file
    if ( bInOrder ) {


        if ( CopyFile( szBackupFile, m_szStorageFile, FALSE ) ) {
            DeleteFile( szBackupFile );
            TraceFunctLeave();
            return TRUE;
        }
    }

    // Either in order and move file failed or not in order
    // Delete the back up file, failure is fine
    DeleteFile( szBackupFile );

    bInOrder = FALSE;

    return TRUE;
}

///////////////////////////////////////////////////////////////
// Public methods
BOOL CFixPropPersist::AddGroup( IN INNTPPropertyBag* pPropBag )
/*++
Routine description:

	Add a group's fixed sized properties into storage.

Arguments:

	IN INNTPPropertyBag* pPropBag - The group's property bag.

Return value:

	TRUE on success, FALSE otherwise
--*/
{
	TraceFunctEnter( "CFixPropPersist::AddGroup" );
	_ASSERT( pPropBag );
#if defined( DEBUG )
	Validate();
#endif

	DWORD		i;
	DATA_BLOCK	dbBuffer;
	CFreeInfo	*pfiFreeInfo = NULL;
	DWORD		cOldMaxBlocks;
	HRESULT 	hr;
	DWORD       dwGroupId;

	// Clear error flag
	SetLastError( NO_ERROR );

	// prepare the buffer
	Group2Buffer( dbBuffer, pPropBag, ALL_FIX_PROPERTIES );
	dwGroupId = dbBuffer.dwGroupId;
	//_ASSERT( dwGroupId >= ID_HIGH_INIT );

	// Try to pop one free block from free list
	ExclusiveLockFreeList();
	pfiFreeInfo = m_FreeList.PopBack();
	ExclusiveUnlockFreeList();
	if ( NULL == pfiFreeInfo ) {	// I have got to extend the file
		//
		// Try to grab expanding lock - we don't want more than one
		// guy expanding the file
		//
		m_FileExpandLock.ExclusiveLock();

		//
		// Do I really need to extend the file ?
		//
		ExclusiveLockFreeList();
		pfiFreeInfo = m_FreeList.PopBack();
		ExclusiveUnlockFreeList();
		if( NULL == pfiFreeInfo ) {	// I must do it and only I am doint it

			// Extend it
			cOldMaxBlocks = m_cCurrentMaxBlocks;	// save it
			if ( !ExtendFile( ALLOC_GRANURALITY ) ) {
				ErrorTrace( 0, "Extend file fail %d", GetLastError() );
				m_FileExpandLock.ExclusiveUnlock();
				return FALSE;
			}

			// consume the first block for myself
			if ( !WriteFile( PBYTE(&dbBuffer), cOldMaxBlocks ) ) {
				ErrorTrace( 0, "Write file fail %d", GetLastError() );
				m_FileExpandLock.ExclusiveUnlock();
				return FALSE;
			}

			// Set offset info into propeerty bag
			hr = pPropBag->PutDWord( 	NEWSGRP_PROP_FIXOFFSET,
										cOldMaxBlocks );
			if ( FAILED( hr ) ) {
				ErrorTrace(0, "Set group property fail %x", hr );
				m_FileExpandLock.ExclusiveUnlock();
				return FALSE;
			}

			// Link all other free blocks into free list
			for ( i = 1; i < ALLOC_GRANURALITY; i++ ) {
				pfiFreeInfo = new CFreeInfo;
				if( NULL == pfiFreeInfo ) {
					ErrorTrace(0, "Out of memory" );
					SetLastError( ERROR_OUTOFMEMORY );
					m_FileExpandLock.ExclusiveUnlock();
					return FALSE;
				}

				pfiFreeInfo->m_dwOffset = cOldMaxBlocks + i ;
				ExclusiveLockFreeList();
				m_FreeList.PushFront( pfiFreeInfo );
				ExclusiveUnlockFreeList();
				pfiFreeInfo = NULL;
			}

			// Ok, now it's time to release the lock
			m_FileExpandLock.ExclusiveUnlock();
		} else
			m_FileExpandLock.ExclusiveUnlock();
	} // if

	if ( NULL != pfiFreeInfo ) { // I didn't expand it

		// write the block
		if ( !WriteFile( PBYTE(&dbBuffer), pfiFreeInfo->m_dwOffset ) ) {
			ErrorTrace(0, "Write file fail %d", GetLastError() );
			return FALSE;
		}

		// Load offset into bag
		hr = pPropBag->PutDWord(    NEWSGRP_PROP_FIXOFFSET,
									pfiFreeInfo->m_dwOffset );
		if ( FAILED( hr ) ) {
   			ErrorTrace(0, "Set group property fail %x", hr );
			return FALSE;
		}

		// Free the free info node
		delete pfiFreeInfo;

		// I am done
	}

    // If the file has id high, we adjust it
    if ( ID_HIGH_INVALID != m_dwIdHigh ) {
        ExclusiveLockIdHigh();
        if ( m_dwIdHigh < dwGroupId ) {
            if ( !WriteFile( PBYTE( &dwGroupId ), 0, sizeof( DWORD ), FALSE ) ){
                ErrorTrace( 0, "Write id high failed %d", GetLastError() );
                ExclusiveUnlockIdHigh();
                return FALSE;
            }
            m_dwIdHigh = dwGroupId;
        }
        ExclusiveUnlockIdHigh();
    }

	TraceFunctLeave();
	return TRUE;
}

BOOL CFixPropPersist::RemoveGroup(	IN INNTPPropertyBag *pPropBag )
/*++
Routine description:

	Remove the group from the property file.

Arguments:

	IN INNTPPropertyBag *pPropBag - The group's property bag.

Return value:

	TRUE if succeeded, FALSE otherwise
--*/
{
	TraceFunctEnter( "CFixPropPersist::RemoveGroup" );
	_ASSERT( pPropBag );
#if defined( DEBUG )
	Validate();
#endif

	DWORD	dwOffset = 0xffffffff;
	DWORD   dwLockOffset = 0xffffffff;
	DATA_BLOCK dbBuffer;
	CFreeInfo *pfiFreeInfo = NULL;

	SetLastError( NO_ERROR );

	//
	// Grab the exclusive lock to the offset to remove
	//

	dwLockOffset = ExclusiveLock( pPropBag );
	if ( 0xffffffff == dwLockOffset ) {

	    //
	    // Somehow we failed in grabbing the exclusive lock
	    //

	    ErrorTrace( 0, "Grab offset exclusive lock failed" );
	    return FALSE;
	}

	// Seek by best
	dwOffset = SeekByBest( pPropBag );
	if ( 0xffffffff == dwOffset ) {	// fatal
		ErrorTrace(0, "Seek by best fail %d", GetLastError() );
		ExclusiveUnlock( dwLockOffset );
		return FALSE;
	}

	_ASSERT( dwOffset == dwLockOffset );

	// Should set it free in file first
	*(dbBuffer.szGroupName) = 0;
	if ( !WriteFile( PBYTE(&dbBuffer), dwOffset ) ) {	// fatal
		ErrorTrace( 0, "Write file fail %d" , GetLastError() );
		ExclusiveUnlock( dwLockOffset );
		return FALSE;
	}

	ExclusiveUnlock( dwLockOffset );

	// Add it to free list
	pfiFreeInfo = new CFreeInfo;
	if ( NULL == pfiFreeInfo ) {
		ErrorTrace( 0, "Alloc free info fail" );
		SetLastError( ERROR_OUTOFMEMORY );
		return FALSE;
	}
	pfiFreeInfo->m_dwOffset = dwOffset;
	ExclusiveLockFreeList();
	m_FreeList.PushFront( pfiFreeInfo );
	ExclusiveUnlockFreeList();

	// Done.
	TraceFunctLeave();
	return TRUE;
}

BOOL CFixPropPersist::GetGroup( IN INNTPPropertyBag *pPropBag, IN DWORD dwFlag )
/*++
Routine description:

	Get group properties from the property file.

Arguments:

	IN INNTPPropertyBag *pPropBag - Where to put the properties into
	IN DWORD dwFlag - Bit mask of what property to get

Return value:

	TRUE if succeeded, FALSE otherwise
--*/
{
	TraceFunctEnter( "CFixPropPersist::GetGroup" );
	_ASSERT( pPropBag );
#if defined( DEBUG )
	Validate();
#endif

	SetLastError ( NO_ERROR );

	DWORD	dwOffset = 0xffffffff;
	DWORD   dwLockOffset = 0xffffffff;
	DATA_BLOCK dbBuffer;

    //
    // Lock the offset for read access
    //

    dwLockOffset = ShareLock( pPropBag );
    if ( 0xffffffff == dwLockOffset ) {
        ErrorTrace( 0, "Grabbing share lock for group offset failed" );
        return FALSE;
    }

	// Seek by best
	dwOffset = SeekByBest( pPropBag );
	if ( 0xffffffff == dwOffset )  {
		ErrorTrace( 0, "Seek by best fail" );
		ShareUnlock( dwLockOffset );
		return FALSE;
	}

	_ASSERT( dwLockOffset == dwOffset );

	// Read the whole block
	if( !ReadFile( PBYTE(&dbBuffer), dwOffset ) ) {
		ErrorTrace( 0, "Read file fail %d", GetLastError() );
		ShareUnlock( dwLockOffset );
		return FALSE;
	}

	ShareUnlock( dwLockOffset );

	_ASSERT( *(dbBuffer.szGroupName) );

	// Load into group property bag based on flag
	Buffer2Group( dbBuffer, pPropBag, dwFlag );

	// Done
	TraceFunctLeave();
	return TRUE;
}

BOOL CFixPropPersist::SetGroup( IN INNTPPropertyBag *pPropBag, IN DWORD dwFlag)
/*++
Routine description:

	Set group properties into the file.

Arguments:

	IN INNTPPropertyBag *pProgBag - The group's property bag
	IN DWORD dwFlag - Bit mask of properties to set

Return value:

	TRUE if succeeded, FALSE otherwise
--*/
{
	TraceFunctEnter( "CFixPropPersist::SetGroup" );
	_ASSERT( pPropBag );
#if defined( DEBUG )
	Validate();
#endif

	SetLastError ( NO_ERROR );

	DWORD	dwOffset = 0xffffffff;
	DWORD   dwLockOffset = 0xffffffff;
	DATA_BLOCK dbBuffer;
	DWORD   dwIdGroup;

	//
	// Grab write lock for access the offset in group.lst
	//

	dwLockOffset = ExclusiveLock( pPropBag );
	if ( 0xffffffff == dwLockOffset ) {
	    ErrorTrace( 0, "Grab exlcusive lock for offset failed" );
	    return FALSE;
	}

	// Seek by best
	dwOffset = SeekByBest( pPropBag );
	if ( 0xffffffff == dwOffset )  {
		ErrorTrace( 0, "Seek by best fail" );
		ExclusiveUnlock( dwLockOffset );
		return FALSE;
	}

	_ASSERT( dwOffset == dwLockOffset );

	// Read the whole block
	if ( dwFlag != ALL_FIX_PROPERTIES ) {
		if( !ReadFile( PBYTE(&dbBuffer), dwOffset ) ) {
			ErrorTrace( 0, "Read file fail %d", GetLastError() );
			ExclusiveUnlock( dwLockOffset );
			return FALSE;
		}
		_ASSERT( *(dbBuffer.szGroupName) );
	}

	// Set the block
	Group2Buffer( dbBuffer, pPropBag, dwFlag );
	dwIdGroup = dbBuffer.dwGroupId;

	// Write the block back
	if ( !WriteFile( PBYTE(&dbBuffer), dwOffset ) ) {
		ErrorTrace(0, "Write file fail %d", GetLastError() );
		ExclusiveUnlock( dwLockOffset );
		return FALSE;
	}

	ExclusiveUnlock( dwLockOffset );

    // If the file has id high, we maintain it
    if ( ID_HIGH_INVALID != m_dwIdHigh ) {
        ExclusiveLockIdHigh();
        if ( m_dwIdHigh < dwIdGroup ) {
            if ( !WriteFile( PBYTE( &dwIdGroup ), 0, sizeof( DWORD ), FALSE ) ) {
                ErrorTrace( 0, "Write id high failed %d", GetLastError() );
                ExclusiveUnlockIdHigh();
                return FALSE;
            }
            m_dwIdHigh = dwIdGroup;
        }
        ExclusiveUnlockIdHigh();
    }

	// done
	TraceFunctLeave();
	return TRUE;
}

BOOL
CFixPropPersist::SaveTreeInit()
/*++
Routine description:

    This method gets called when the newstree tries to shutdown.  It asks
    CFixPropPersist to get prepared to save the whole tree to a backup
    file ( groups are added into this backup file in order ).  On next
    startup, if the ordered file is good, we'll notify the newstree to
    do "AppendList" instead of "InsertList" so that we can load the whole
    tree much faster.

Arguments:

    None.

Return value:

    TRUE, succeeded, FALSE otherwise
--*/
{
    TraceFunctEnter( "CFixPropPersist::SaveTreeInit" );
    CHAR    szBackupFile[MAX_PATH+1];
    DWORD   rgdw[3];
    DWORD   dwWritten = 0;

    // Nobody should have called this before
    _ASSERT( INVALID_HANDLE_VALUE == m_hBackupFile );
    if ( INVALID_HANDLE_VALUE != m_hBackupFile ) {
        ErrorTrace( 0, "SaveTreeInit already initialized" );
        SetLastError( ERROR_ALREADY_INITIALIZED );
        return FALSE;
    }

    // Create the backfile
    lstrcpyn( szBackupFile, m_szStorageFile, sizeof(szBackupFile)-sizeof(".ord")+1 );
    strcat( szBackupFile, ".ord" );
    _ASSERT( strlen( szBackupFile ) < MAX_PATH+1 );
    m_hBackupFile = ::CreateFile( szBackupFile,
                                GENERIC_WRITE,
                                0,      // not shared by anybody else
                                NULL,
                                CREATE_ALWAYS,
                                FILE_FLAG_SEQUENTIAL_SCAN,
                                NULL );
    if ( INVALID_HANDLE_VALUE == m_hBackupFile ) {
        ErrorTrace( 0, "Creating backup file failed %d", GetLastError() );
        return FALSE;
    }

    // Write the three dwords - signature ( 2 ) and id-high ( 1 )
    // they are all zero now, these values will be set on SaveTreeClose
    ZeroMemory( rgdw, 3 * sizeof( DWORD ) );
    if ( !::WriteFile(    m_hBackupFile,
                        rgdw,
                        3 * sizeof( DWORD ),
                        &dwWritten,
                        NULL ) ||
         dwWritten != sizeof( DWORD ) * 3 ) {
         ErrorTrace( 0, "Write group.lst.ord header failed %d", GetLastError() );
         _VERIFY( CloseHandle( m_hBackupFile ) );
         return FALSE;
     }

     // OK, now it's ready, leave the handle open
     TraceFunctLeave();
     return TRUE;
}

BOOL
CFixPropPersist::SaveGroup( INNTPPropertyBag *pPropBag )
/*++
Routine Description:

    Save the group into the back up.   This function only gets called
    when shutting down a newstree

    The convention for fixprop is fixprop never has to release
    the property bag itself.

Arguments:

    INNTPPropertyBag *pPropBag - The group to be saved.

Return value:

    TRUE - Success, FALSE otherwise
--*/
{
    TraceQuietEnter( "CFixPropPersist::SaveGroup" );
    _ASSERT( pPropBag );

    DATA_BLOCK  dbBuffer;
    DWORD       dwWritten = 0;

    // Make sure we have been initialized
    _ASSERT( m_hBackupFile != INVALID_HANDLE_VALUE );
    if ( INVALID_HANDLE_VALUE == m_hBackupFile ) {
        ErrorTrace( 0, "Try to save group before init savetree" );
        SetLastError( ERROR_INVALID_HANDLE );
        return FALSE;
    }

    // Convert the bag to buffer
    Group2Buffer( dbBuffer, pPropBag, ALL_FIX_PROPERTIES );

    // Do a writefile to save the
    if ( !::WriteFile(  m_hBackupFile,
                        &dbBuffer,
                        sizeof( DATA_BLOCK ),
                        &dwWritten,
                        NULL ) ||
         dwWritten != sizeof( DATA_BLOCK ) ) {
         ErrorTrace( 0, "Write file in savegroup failed %d", GetLastError() );
         return FALSE;
    }

    // that's it
    return TRUE;
}

BOOL
CFixPropPersist::SaveTreeClose( BOOL bEffective )
/*++
Routine description:

    Terminate the save tree operation.  Things done in this function:
    1. Set signature 2. Set flags 3. Set id high 4. Close handle

Arguments:

    None.

Return value:

    TRUE, if succeeded, FALSE otherwise
--*/
{
    TraceFunctEnter( "CFixPropPersist::SaveTreeClose" );

    // Still, we should already have been initialized
    _ASSERT( INVALID_HANDLE_VALUE != m_hBackupFile );
    if ( INVALID_HANDLE_VALUE == m_hBackupFile ) {
        ErrorTrace( 0, "Try to close Save tree before initialized" );
        SetLastError( ERROR_INVALID_HANDLE );
        return FALSE;
    }

    // If effective is false, we only need to close the handle
    // it must be without good order flag, so that next
    // time the server is up, it won't be picked up as the group
    // list file
    if ( !bEffective ) {
        CloseHandle( m_hBackupFile );
        return TRUE;
    }

    DWORD   rgdw[3];
    DWORD   dwMoved = 0xffffffff;
    DWORD   dwWritten = 0;

    // Set signature
    PLARGE_INTEGER(rgdw)->LowPart = FIXPROP_SIGNATURE;
    PLARGE_INTEGER(rgdw)->HighPart = FLAG_WITH_ID_HIGH | FLAG_IN_ORDER;
    rgdw[2] = m_dwIdHigh;

    // Reset the file pointer
    dwMoved = SetFilePointer(   m_hBackupFile,
                                0,
                                0,
                                FILE_BEGIN );
    if ( dwMoved == 0 ) {   // Succeeded

        if ( ::WriteFile(   m_hBackupFile,
                            rgdw,
                            sizeof( DWORD ) * 3,
                            &dwWritten,
                            NULL ) &&
             dwWritten == sizeof( DWORD ) * 3 ) {

             // Close the handle and return
             _VERIFY( CloseHandle( m_hBackupFile ) );
             m_hBackupFile = INVALID_HANDLE_VALUE;
             return TRUE;

        }
    }

    ErrorTrace( 0, "Write flags failed %d", GetLastError() );
    _VERIFY( CloseHandle( m_hBackupFile ) );
    m_hBackupFile = INVALID_HANDLE_VALUE;
    return FALSE;
}

DWORD
CFixPropPersist::GetGroupOffset(    INNTPPropertyBag *pPropBag )
/*++
Routine description:

    Get the offset in group.lst for the given group.  The offset
    should be the property bag already.

Arguments:

    INNTPPropertyBag *pPropBag - The newsgroup's property bag

Return value:

    The offset.  0xffffffff if the offset is missing from the property
    bag ( in dbg this is going to cause assert ).
--*/
{
    TraceFunctEnter( "CFixPropPersist::GetGroupOffset" );
    _ASSERT( pPropBag );

    HRESULT hr = S_OK;
    DWORD   dwOffset = 0xffffffff;

    hr = pPropBag->GetDWord(    NEWSGRP_PROP_FIXOFFSET, &dwOffset );
    if ( FAILED( hr ) ) {
        _ASSERT( FALSE && "Group should have offset" );
        return 0xffffffff;
    } else
        return dwOffset;
}

DWORD
CFixPropPersist::ShareLock(    INNTPPropertyBag *pPropBag )
/*++
Routine description:

    Lock the read access to the group's offset in group.lst

Arguments:

    pPropBag - The group's property bag

Return value:

    Group's offset if succeeded, 0xffffffff if failed
--*/
{
    TraceFunctEnter( "CFixPropPersist::ShareLock" );
    _ASSERT( pPropBag );

    DWORD   dwOffset = GetGroupOffset( pPropBag );
    if ( dwOffset != 0xffffffff ) {
        m_rgLockArray[dwOffset%GROUP_LOCK_ARRAY_SIZE].ShareLock();
    }

    TraceFunctLeave();
    return dwOffset;
}

void
CFixPropPersist::ShareUnlock( DWORD dwOffset )
/*++
Routine description:

    Unlock the read access to the offset in group.lst

Arguments:

    dwOffset - The offset to unlock

Return value:

    None
--*/
{
    TraceFunctEnter( "CFixPropPersist::ShareUnlock" );
    _ASSERT( 0xffffffff != dwOffset );

    m_rgLockArray[dwOffset%GROUP_LOCK_ARRAY_SIZE].ShareUnlock();
    TraceFunctLeave();
}

DWORD
CFixPropPersist::ExclusiveLock(    INNTPPropertyBag *pPropBag )
/*++
Routine description:

    Lock the write access to the group's offset in group.lst

Arguments:

    pPropBag - The group's property bag

Return value:

    Group's offset if succeeded, 0xffffffff if failed
--*/
{
    TraceFunctEnter( "CFixPropPersist::ExclusiveLock" );
    _ASSERT( pPropBag );

    DWORD   dwOffset = GetGroupOffset( pPropBag );
    if ( dwOffset != 0xffffffff ) {
        m_rgLockArray[dwOffset%GROUP_LOCK_ARRAY_SIZE].ExclusiveLock();
    }

    TraceFunctLeave();
    return dwOffset;
}

void
CFixPropPersist::ExclusiveUnlock( DWORD dwOffset )
/*++
Routine description:

    Unlock the write access to the offset in group.lst

Arguments:

    dwOffset - The offset to unlock

Return value:

    None
--*/
{
    TraceFunctEnter( "CFixPropPersist::ExclusiveUnlock" );
    _ASSERT( 0xffffffff != dwOffset );

    m_rgLockArray[dwOffset%GROUP_LOCK_ARRAY_SIZE].ExclusiveUnlock();
    TraceFunctLeave();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\nntp\core\fixprop\src\stdinc.h ===
#ifndef	_STDINC_H_
#define	_STDINC_H_

//
// disables a browser info warning that breaks the build
//
#pragma warning (disable:4786)

//
// disables redundant warning about / in // comments
//
#pragma warning (disable:4010)

#ifdef __cplusplus
extern "C" {
#endif

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>

#ifdef __cplusplus
};
#endif

#include <malloc.h>
#include <nntptype.h>
#include <nntps.h>
#include <nntpapi.h>
#include <tigdflts.h>
#include <nntpmeta.h>

#include "dbgtrace.h"
//#include "resource.h"

#include "tigtypes.h"
#include "fsconst.h"
#include "crchash.h"

#ifdef PROFILING
#include "icapexp.h"
#endif

typedef char *LPMULTISZ;

#include "instwpex.h"
#include "nntpvr.h"
#include "group.h"
#include <instwpex.h>
#include "nwstree.h"
#include "nntpbag.h"
#include <rwnew.h>

#pragma hdrstop

#endif	// _STDINC_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\nntp\core\fixprop\src\makefile.inc ===
$(O)\mailmsg.h : $(STAXINC)\export\mailmsg.idl
    $(MIDL) \
    $(PACKING) \
    $(INCPATH0) \
    -char unsigned \
    -ms_ext -c_ext \
    -proxy $(PASS0_SOURCEDIR)\mailmsg_p.c \
    -dlldata $(PASS0_SOURCEDIR)\dlldata.c \
    -iid $(MIDL_UUIDDIR)\mailmsg_i.c \
    -header $@ \
    -tlb $(O)\mailmsg.tlb \
    -cpp_cmd $(TARGET_CPP) \
    $(C_DEFINES) \
    $(MIDL_FLAGS) \
    $(MIDL_OPTIMIZATION) \
    $**
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\nntp\core\flatfile\src\flatfile.cpp ===
#include <windows.h>
#include <randfail.h>
#include <stdlib.h>
#include <string.h>
#include <search.h>
#include "abtype.h"
#include "dbgtrace.h"
#include "writebuf.h"
#include "flatfile.h"

//
// the constructor needs to save the filename into the objects memory, reset
// the variables used for buffered reading, and initialize the hash function
//

#pragma warning(disable:4355)

CFlatFile::CFlatFile(LPSTR szFilename,
					 LPSTR szExtension,
					 void *pContext,
					 PFN_OFFSET_UPDATE pfnOffsetUpdate,
					 DWORD dwSignature,
                     BOOL fClear,
					 DWORD dwFileFlags) : m_wbBuffer( this )
{
    TraceQuietEnter("CFlatFile::CFlatFile");

	_ASSERT(pfnOffsetUpdate != NULL);

    _snprintf( m_szFilename, sizeof(m_szFilename)/sizeof(m_szFilename[0]) - 1, "%s%s", szFilename, szExtension);
    m_szFilename[sizeof(m_szFilename)/sizeof(m_szFilename[0]) - 1] = '\0';
    lstrcpyn(m_szBaseFilename, szFilename, sizeof(m_szBaseFilename)/sizeof(m_szBaseFilename[0]));

    m_cBuffer = 0;
    m_iBuffer = 0;
    m_iFile = sizeof(FLATFILE_HEADER);
    m_fClearOnOpen = fClear;
    m_dwFileFlags = dwFileFlags;
    m_cRecords = 0;
    m_cDeletedRecords = 0;
	m_hFile = INVALID_HANDLE_VALUE;
	m_pfnOffsetUpdate = pfnOffsetUpdate;
	m_dwSignature = dwSignature;
	m_pContext = pContext;
	m_fOpen = FALSE;
}

//
// free any allocated memory
//
CFlatFile::~CFlatFile(void) {
    TraceQuietEnter("CFlatFile::~CFlatFile");

	CloseFile();

}

//
// Enable the write buffer
//
VOID
CFlatFile::EnableWriteBuffer( DWORD cbBuffer )
{
    m_wbBuffer.Enable( cbBuffer );
}

//
// Check to see if the file has been opened
//
BOOL
CFlatFile::IsFileOpened()
{
    return m_fOpen;
}

//
// open a file.  assumes the lock is already held by the caller
//
HRESULT CFlatFile::OpenFile(LPSTR szFilename, DWORD dwOpenMode, DWORD dwFlags) {
    TraceFunctEnter("CFlatFile::OpenFile");

    LPSTR szFn = (szFilename == NULL) ? m_szFilename : szFilename;
    BOOL fDLFile = (lstrcmp(m_szFilename, szFn) == 0);
    FLATFILE_HEADER header;
	HRESULT hr;

    DebugTrace((DWORD_PTR) this, "OpenFile(%s, %lu, %lu)", szFilename, dwOpenMode, dwFlags);

	if (m_hFile != INVALID_HANDLE_VALUE) ret(S_OK);

    if (m_fClearOnOpen) {
    	dwOpenMode = CREATE_ALWAYS;
        m_fClearOnOpen = FALSE;
    }
    dwFlags |= m_dwFileFlags;

    SetLastError(NO_ERROR);

    m_hFile = CreateFile(szFn, GENERIC_READ | GENERIC_WRITE,
                       FILE_SHARE_READ, NULL, dwOpenMode,
                       FILE_ATTRIBUTE_NORMAL | dwFlags, NULL);
    if (m_hFile == INVALID_HANDLE_VALUE) {
        ErrorTrace((DWORD_PTR) this, "Couldn't open file %s, ec = 0x%08X\n", szFn, GetLastError());
		ret(HRESULT_FROM_WIN32(GetLastError()));
    }

    _ASSERT(GetLastError() != ERROR_FILE_EXISTS);

    // see if we need to put a header record (if this is a new file)
    if (FAILED(GetFileHeader(&header))) {
        header.dwFlags = 0;
        header.dwSignature = m_dwSignature;
		hr = SetFileHeader(&header);
		if (FAILED(hr)) {
			DebugTrace((DWORD_PTR) this, "SetFileHandle failed with 0x%x", hr);
			ret(hr);
		}
    }

	if (header.dwSignature != m_dwSignature) {
		CloseFile();
		ret(HRESULT_FROM_WIN32(ERROR_INVALID_DATA));
	}

    m_fOpen = TRUE;
    TraceFunctLeave();
    ret(S_OK);
}

void CFlatFile::CloseFile() {
    if ( m_wbBuffer.NeedFlush() ) m_wbBuffer.FlushFile();
	if (m_hFile != INVALID_HANDLE_VALUE) {
		CloseHandle(m_hFile);
		m_hFile = INVALID_HANDLE_VALUE;
	}
	m_fOpen = FALSE;
}

//
// add a new record to the current file
//
HRESULT CFlatFile::InsertRecord(LPBYTE pData, DWORD cData, DWORD *piOffset, DWORD dwVer ) {
    RECORD rec;
    DWORD cRec;
	HRESULT hr;

    TraceQuietEnter("CFlatFile::InsertRecord");

    _ASSERT(cData <= MAX_RECORD_SIZE);
    if (cData > MAX_RECORD_SIZE) return HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);
    	
    // DebugTrace((DWORD_PTR) this, "adding a new record");
    // BinaryTrace((DWORD_PTR) this, pData, cData);

    // build a record and write to the data file
    // (note that we could do this more efficently with two writes (one
    // with the header and one with the record data), but it wouldn't
    // be atomic, so we could end up with an invalid file more easily.)
    cRec = RECORD_HEADER_SIZE + cData;

    //
    // Set header values
    //
    rec.fDeleted = FALSE;
    rec.cData = cData;

    //
    // OK, I'll use the high 16 bit of cData to set the version number
    //
    dwVer <<= 16;
    rec.cData |= dwVer;

    //
    // Now do the copy
    //
    memcpy(rec.pData, pData, cData);
	DWORD iOffset;
	hr = WriteNBytesTo((LPBYTE) &rec, cRec, &iOffset);
	if (SUCCEEDED(hr)) {
		m_pfnOffsetUpdate(m_pContext, pData, cData, iOffset);
		m_cRecords++;
		if (piOffset != NULL) *piOffset = iOffset;
	}
	ret(hr);
}

//
// mark a record for deletion given its offset (returned from GetNextRecord)
//
// assumes that the file lock is held
//
HRESULT CFlatFile::DeleteRecord(DWORD iOffset) {
    TraceQuietEnter("CFlatFile::DeleteRecord");

    RECORDHDR rec;
	HRESULT hr;

    //
    // read the record header
    //
    hr = ReadNBytesFrom((PBYTE) &rec, sizeof(rec), iOffset);
    if (FAILED(hr)) {
        ErrorTrace((DWORD_PTR) this, "Couldn't read record header, hr = 0x%08X", hr);
        ret(hr);
    }

    //
    // write out the header with the delete flat set
    //
    rec.fDeleted = TRUE;
    hr = WriteNBytesTo((PBYTE) &rec, sizeof(rec), NULL, iOffset);
	if (SUCCEEDED(hr)) m_cDeletedRecords++;
	ret(hr);
}

//
// update the file header
//
HRESULT CFlatFile::SetFileHeader(FLATFILE_HEADER *pHeader) {
    TraceQuietEnter("CFlatFile::SetFileHeader");

    ret(WriteNBytesTo((PBYTE) pHeader, sizeof(FLATFILE_HEADER), NULL, 0));
}

//
// read the file header
//
HRESULT CFlatFile::GetFileHeader(FLATFILE_HEADER *pHeader) {
    TraceQuietEnter("CFlatFile::GetFileHeader");

    ret(ReadNBytesFrom((PBYTE) pHeader, sizeof(FLATFILE_HEADER), 0));
}

//
// Dirty the integrity flag: we reuse the high 16bit of the flatfile's header
// flag.
//
HRESULT CFlatFile::DirtyIntegrityFlag()
{
    TraceQuietEnter( "CFlatFile::DirtyIntegrityFlag" );

    FLATFILE_HEADER ffHeader;
    HRESULT         hr = S_OK;

    //
    // Read the header first
    //
    hr = GetFileHeader( &ffHeader );
    if ( FAILED( hr ) ) {
        ErrorTrace( 0, "Read header from flatfile failed %x", hr );
        return hr;
    }

    //
    // Now set the bad flag to the header
    //
    ffHeader.dwFlags |= FF_FILE_BAD;

    //
    // And set it back
    //
    hr = SetFileHeader( &ffHeader );
    if ( FAILED( hr ) ) {
        ErrorTrace( 0, "Set header into flatfile failed %x", hr );
        return hr;
    }

    return hr;
}

//
// Set the integrity flag, to indicate that the file is good.
//
HRESULT CFlatFile::SetIntegrityFlag()
{
    TraceQuietEnter( "CFlatFile::SetIntegrityFlag" );

    FLATFILE_HEADER ffHeader;
    HRESULT         hr = S_OK;

    //
    // Read the header first
    //
    hr = GetFileHeader( &ffHeader );
    if ( FAILED( hr ) ) {
        ErrorTrace( 0, "Read header from flatfile failed %x", hr );
        return hr;
    }

    //
    // Now set the good flag to the header
    //
    ffHeader.dwFlags &= FF_FILE_GOOD;

    //
    // Set it back
    //
    hr = SetFileHeader( &ffHeader );
    if ( FAILED( hr ) ) {
        ErrorTrace( 0, "Set file header failed %x", hr );
        return hr;
    }

    return hr;
}

//
// Ask the flat file whether the file is in good integrity ?
//
BOOL
CFlatFile::FileInGoodShape()
{
    TraceQuietEnter( "CFlatFile::FileInGoodShape" );

    FLATFILE_HEADER ffHeader;
    HRESULT         hr = S_OK;
    DWORD           dwFlag;

    //
    // Read the header first, if read failed, the file is not
    // in good shape
    //
    hr = GetFileHeader( &ffHeader );
    if ( FAILED( hr ) ) {
        ErrorTrace( 0, "Header can not be read from flatfile %x", hr );
        return FALSE;
    }

    //
    // Now test the flag
    //
    dwFlag = ffHeader.dwFlags & FF_FILE_BAD;

    return 0 == dwFlag;
}

//
// get the first record from the file.
//
// arguments:
// 	pData - the data from the record
//  cData [in] - the size of pData
//  cData [out] - the amount of data put into pData
//  piByteOffset - the offset of this record in the file
// returns:
//  S_OK - retreived record
//  S_FALSE - end of file
//  else - error
//
HRESULT CFlatFile::GetFirstRecord(LPBYTE pData, DWORD *pcData, DWORD *piByteOffset, DWORD* pdwVer)
{
	HRESULT hr;

    TraceQuietEnter("CFlatFile::GetFirstRecord");

	// reset the read buffer
	m_cBuffer = 0;
	m_iBuffer = 0;

    // skip the file header
    m_iFile = sizeof(FLATFILE_HEADER);
    m_cRecords = 0;
    m_cDeletedRecords = 0;

    ret(GetNextRecord(pData, pcData, piByteOffset, pdwVer));
}

//
// get the next record from the file
//
// arguments are the same as GetFirstRecord()
//
HRESULT CFlatFile::GetNextRecord(LPBYTE pData, DWORD *pcData, DWORD *piByteOffset, DWORD* pdwVer) {
    RECORDHDR rec;
	HRESULT hr;
	DWORD   dwMaskLength = 0x0000FFFF;
	DWORD   dwMaskVer = 0xFFFF0000;
	DWORD   cRec;

    TraceQuietEnter("CFlatFile::GetNextRecord");

    //
    // look for the next undeleted record
    //
    do {
        if (piByteOffset != NULL) *piByteOffset = m_iFile + m_iBuffer;

        hr = ReadNextNBytes((LPBYTE) &rec, RECORD_HEADER_SIZE);
		if (hr == HRESULT_FROM_WIN32(ERROR_HANDLE_EOF)) {
			ret(S_FALSE);
		} else if (FAILED(hr)) {
			ret(hr);
		}

        m_cRecords++;
        cRec = rec.cData & dwMaskLength;
        if (rec.fDeleted) {
            // DebugTrace((DWORD_PTR) this, "skipping deleted record");
            //
            // seek ahead of this record
            //
            m_iBuffer += cRec;
            m_cDeletedRecords++;
        } else {
            if (*pcData < cRec) {
				// BUGBUG - we'll skip the record if the user doesn't have
				// space
				_ASSERT(m_iBuffer >= sizeof(RECORDHDR));
                m_iBuffer -= sizeof(RECORDHDR);
				ret(HRESULT_FROM_WIN32(ERROR_MORE_DATA));
            } else {

                //
                // Chop off the real data length
                //
                *pcData = cRec;

                //
                // Chop off the version number, if needed
                //
                if ( pdwVer )
                    *pdwVer = ( rec.cData & dwMaskVer ) >> 16;

                //
                // Get the actual record
                //
				hr = ReadNextNBytes(pData, *pcData);
                if (FAILED(hr)) {
                    _ASSERT(FALSE);
                    DebugTrace((DWORD_PTR) this, "file corrupt");
                    ret(hr);
                }
            }
        }
    } while (rec.fDeleted);

    ret(S_OK);
}

//
// read N bytes starting at an offset
//
// if pcDidRead is NULL then its an error to not read cData bytes, otherwise
// pcDidRead will have the number of bytes read
//
HRESULT CFlatFile::ReadNBytesFrom(LPBYTE pData,
								  DWORD cData,
								  DWORD iOffset,
								  DWORD *pcDidRead)
{
    TraceQuietEnter("CFlatFile::ReadNBytesFrom");

    DWORD cDidRead;
	HRESULT hr;

    // open the file
	if (m_hFile == INVALID_HANDLE_VALUE) {
	    hr = OpenFile();
		if (FAILED(hr)) {
			ErrorTrace((DWORD_PTR) this, "OpenFile() failed with 0x%x", hr);
			ret(hr);
		}
	}

	// If the write buffer needs flush, flush it
	if ( m_wbBuffer.NeedFlush() ) {
	    hr = m_wbBuffer.FlushFile();
	    if ( FAILED( hr ) ) {
	        ErrorTrace( 0, "FlusFile in ReadNBytesFrom failed %x", hr );
	        ret( hr );
	    }
	}

    // seek to the proper offset in the file
    if (SetFilePointer(m_hFile, iOffset, NULL, FILE_BEGIN) == 0xffffffff) {
		ErrorTrace((DWORD_PTR) this, "SetFilePointer failed, ec = %lu", GetLastError());
        ret(HRESULT_FROM_WIN32(GetLastError()));
    }

    // read the next chunk from it
    if (!ReadFile(m_hFile, pData, cData, &cDidRead, NULL)) {
		ErrorTrace((DWORD_PTR) this, "ReadFile failed, ec = %lu", GetLastError());
        ret(HRESULT_FROM_WIN32(GetLastError()));
    }

    if (pcDidRead == NULL) {
        ret((cData == cDidRead) ? S_OK : HRESULT_FROM_WIN32(ERROR_HANDLE_EOF));
    } else {
        *pcDidRead = cDidRead;
        ret(S_OK);
    }
}

//
// write N bytes starting at an offset
//
// if pcDidWrite is NULL then its an error to not written cData bytes,
// otherwise pcDidWrite will have the number of bytes writte
//
HRESULT CFlatFile::WriteNBytesTo(
                        LPBYTE pData,
                        DWORD cData,
                        DWORD *piOffset,
                        DWORD iOffset,
                        DWORD *pcDidWrite)
{
    return m_wbBuffer.WriteFileBuffer(
                    iOffset,
                    pData,
                    cData,
                    piOffset,
                    pcDidWrite );
}

//
// write N bytes starting at an offset
//
// if pcDidWrite is NULL then its an error to not written cData bytes,
// otherwise pcDidWrite will have the number of bytes writte
//
HRESULT CFlatFile::WriteNBytesToInternal(
                                 LPBYTE pData,
								 DWORD cData,
								 DWORD *piOffset,
                              	 DWORD iOffset,
								 DWORD *pcDidWrite)
{
    TraceQuietEnter("CFlatFile::WriteNBytesTo");

    DWORD cDidWrite;
	HRESULT hr;

    // open the file
	if (m_hFile == INVALID_HANDLE_VALUE) {
    	hr = OpenFile();
    	if (FAILED(hr)) ret(hr);
	}

    // seek to the proper offset in the file
    DWORD dwOffset;
    if (iOffset == INFINITE) {
        dwOffset = SetFilePointer(m_hFile, 0, NULL, FILE_END);
        if (piOffset != NULL) *piOffset = dwOffset;
    } else {
        dwOffset = SetFilePointer(m_hFile, iOffset, NULL, FILE_BEGIN);
        _ASSERT(piOffset == NULL);
    }
    if (dwOffset == 0xffffffff) {
		ErrorTrace((DWORD_PTR) this, "SetFilePointer failed, ec = %lu", GetLastError());
        ret(HRESULT_FROM_WIN32(GetLastError()));
    }

    // write data to it
    if (!WriteFile(m_hFile, pData, cData, &cDidWrite, NULL)) {
		ErrorTrace((DWORD_PTR) this, "WriteFile failed, ec = %lu", GetLastError());
        ret(HRESULT_FROM_WIN32(GetLastError()));
    }

    if (pcDidWrite == NULL) {
        ret((cData == cDidWrite) ? S_OK : E_FAIL);
    } else {
        *pcDidWrite = cDidWrite;
        ret(S_OK);
    }
}

//
// Reload the read buffer
//
HRESULT
CFlatFile::ReloadReadBuffer()
{
    TraceQuietEnter( "CFlatFile::ReloadReadBuffer" );

    HRESULT hr = S_OK;

    m_cBuffer = 0;
    hr = ReadNBytesFrom( m_pBuffer, FF_BUFFER_SIZE, m_iFile, &m_cBuffer );
    if ( FAILED( hr ) ) {
        ErrorTrace( 0, "ReadNBytesFrom in ReloadReadBuffer failed %x", hr );
        return hr;
    }

    if ( 0 == m_cBuffer ) {
        DebugTrace( 0, "Reaching end of file" );
        return HRESULT_FROM_WIN32( ERROR_HANDLE_EOF );
    }

    return S_OK;
}

//
// read the next chunk of the file into the temporary buffer
//
HRESULT CFlatFile::ReadNextNBytes(LPBYTE pData, DWORD cData) {
    TraceQuietEnter("CFlatFile::ReadNextNBytes");

    _ASSERT(cData < MAX_RECORD_SIZE);
	HRESULT hr;

    // DebugTrace((DWORD_PTR) this, "want %lu bytes of data", cData);

    //
    // If a read comes after writes, we'll flush anyway if write buffer
    // is enabled
    //
    if ( m_wbBuffer.NeedFlush() ) {
        hr = m_wbBuffer.FlushFile();
        if ( FAILED( hr ) ) {
            return hr;
        }

        if ( S_OK == hr ) {

            //
            // We need to reload the read buffer as well
            //

            hr = ReloadReadBuffer();
            if ( FAILED( hr ) ) {
                return hr;
            }
        }
    }

    // if they want to read more bytes then the buffer has remaining in
    // it then read into the buffer starting from the current location
    if (m_cBuffer > FF_BUFFER_SIZE ||
        m_iBuffer > m_cBuffer ||
        cData > (m_cBuffer - m_iBuffer))
    {
        m_iFile += m_iBuffer;
        hr = ReloadReadBuffer();
        if ( FAILED( hr ) ) {
            ErrorTrace( 0, "ReadLoadReadBuffer in ReadNextNBytes failed %x", hr );
            return hr;
        }
        m_iBuffer = 0;
    }

    // copy their data and return
    if (cData <= m_cBuffer - m_iBuffer) {
        memcpy(pData, m_pBuffer + m_iBuffer, cData);
        m_iBuffer += cData;
        ret(S_OK);
    } else {
		// this can only happen if cData > MAX_RECORD_SIZE
		_ASSERT(FALSE);
        ret(E_FAIL);
    }
}

//
// Make a new flatfile which doesn't have any space wasted due to deleted
// records.
//
// This is implemented by making a new file from scratch and copying
// undeleted records into the new file.  It would be possible to do this
// in place, but that wouldn't be as error-proof... the system could
// crash during the compaction and leave behind an invalid file.
//
HRESULT CFlatFile::Compact() {
    TraceQuietEnter("CFlatFile::Compact");

    BYTE pThisData[MAX_RECORD_SIZE];
    DWORD cThisData;
    char szNewFilename[FILENAME_MAX];
    char szBakFilename[FILENAME_MAX];
    CFlatFile newff(m_szBaseFilename,
                    NEW_FF_EXT,
                    m_pContext,
                    m_pfnOffsetUpdate,
                    FLATFILE_SIGNATURE,
                    TRUE,
                    FILE_FLAG_SEQUENTIAL_SCAN );

    FLATFILE_HEADER header;
	HRESULT hr;

    lstrcpyn(szNewFilename, m_szBaseFilename, sizeof(szNewFilename) -sizeof(NEW_FF_EXT) + 1);
    lstrcat(szNewFilename, NEW_FF_EXT);

    lstrcpyn(szBakFilename, m_szBaseFilename, sizeof(szBakFilename) -sizeof(BAK_FF_EXT) + 1);
    lstrcat(szBakFilename, BAK_FF_EXT);

    DebugTrace((DWORD_PTR) this, "Compacting flat file %s", m_szFilename);
    DebugTrace((DWORD_PTR) this, "szNewFilename = %s, szBakFilename = %s",
        szNewFilename, szBakFilename);

    //
    // Enable write buffer for the new header since I know that only
    // sequential writes will happen to this file
    //

    newff.EnableWriteBuffer( FF_BUFFER_SIZE );

    // write a file header (we need to make sure that the newff file
    // is actually created).
    header.dwFlags = 0;
    header.dwSignature = m_dwSignature;
	hr = newff.SetFileHeader(&header);
	if (FAILED(hr)) ret(hr);

    //
    // get each record from the current file and add it to the new one
    //
    cThisData = MAX_RECORD_SIZE;
	hr = GetFirstRecord(pThisData, &cThisData);
	DWORD cRecords = 0;
	while (hr == S_OK) {
		hr = newff.InsertRecord(pThisData, cThisData);
		if (FAILED(hr)) {
			ErrorTrace((DWORD_PTR) this, "out of disk space during compaction");
			newff.DeleteAll();
			ret(hr);		
		}

		cRecords++;

        cThisData = MAX_RECORD_SIZE;
		hr = GetNextRecord(pThisData, &cThisData);
	}

	m_cDeletedRecords = 0;
	m_cRecords = cRecords;

    //
    // before we move files around we need to make sure that we close
    // the current flatfile and new flatfile for sure.
    //
    CloseFile();
    newff.CloseFile();

    //
    // old -> bitbucket ; current -> old ; new -> current
    //
    DebugTrace((DWORD_PTR) this, "erasing %s", szBakFilename);
    if (DeleteFile(szBakFilename) || GetLastError() == ERROR_FILE_NOT_FOUND) {
        DebugTrace((DWORD_PTR) this, "moving %s to %s", m_szFilename, szBakFilename);
        if (MoveFile(m_szFilename, szBakFilename)) {
            DebugTrace((DWORD_PTR) this, "moving %s to %s", szNewFilename, m_szFilename);
            if (MoveFile(szNewFilename, m_szFilename)) {
                ret(S_OK);
            }
        }
    }

    newff.DeleteAll();

    ErrorTrace((DWORD_PTR) this, "Last operation failed, ec = %08X", GetLastError());
    _ASSERT(FALSE);
	ret(HRESULT_FROM_WIN32(GetLastError()));
}

//
// remove the flat file from disk (which removes all members)
//
void CFlatFile::DeleteAll(void) {
    TraceQuietEnter("CFlatFile::DeleteAll");

    CloseFile();
    DeleteFile(m_szFilename);

}


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\nntp\core\include\artglbs.h ===
extern DWORD numField;
extern DWORD numPCString;
extern DWORD numDateField;
extern DWORD numFromPeerArt;
extern DWORD ArticleTimeLimitSeconds;
extern DWORD numArticle;
extern DWORD numPCParse;
extern DWORD numMapFile;

extern const char szNLChars[];
extern const char szWSNullChars[];
extern const char szNLChars[];
extern const char szWSNLChars[];
extern const char szWSChars[];
extern const char StrNewLine[];
extern const char StrTermLine[];

extern DEBUG_PRINTS* g_pDebug;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\nntp\core\flatfile\src\writebuf.cpp ===
/*++

Copyright (c) 1999 Microsoft Corporation

Module Name:

    writebuf.cpp

Abstract:

    This module contains class declarations/definitions for

        CFlatFileWriteBuf
        
    **** Overview ****

    The write buffer that buffers up a batch of writes for flatfile.
    Using sequential scan is good for reads, but may not be sufficient
    for sequential writes.  This buffer is only enabled when data
    being written to the file is not critical ( meaning losing of data
    is OK if the system crashes ).
    
Author:

    Kangrong Yan    ( KangYan )     5-6-1999

Revision History:

--*/
#include <windows.h>
#include <xmemwrpr.h>
#include "writebuf.h"
#include "flatfile.h"

CFlatFileWriteBuf::CFlatFileWriteBuf( CFlatFile* pParentFile )
{
    m_pParentFile = pParentFile;
    m_pbBuffer = NULL;
    m_cbBuffer = 0;
    m_iStart = m_iEnd = 0;
}

CFlatFileWriteBuf::~CFlatFileWriteBuf()
{
    if ( m_pbBuffer )
        FreePv( m_pbBuffer );

    //
    // We must have been flushed
    //
    
    _ASSERT( m_iStart == m_iEnd );
}

VOID
CFlatFileWriteBuf::Enable( DWORD cbData )
{
    //
    // You cannot enable twice
    //

    _ASSERT( NULL == m_pbBuffer );
    _ASSERT( 0 == m_cbBuffer );
    _ASSERT( m_iStart == 0 );
    _ASSERT( m_iEnd == 0 );

    m_pbBuffer = (PBYTE)PvAlloc( cbData );
    if ( m_pbBuffer ) m_cbBuffer = cbData;
}

HRESULT
CFlatFileWriteBuf::WriteFileReal(
                    const DWORD dwOffset,
                    const PBYTE pbBuffer,
                    const DWORD cbBuffer,
                    PDWORD      pdwOffset,
                    PDWORD      pcbWritten
                    )
/*++
Routine description:

    Write the contents directly into the file

Arguments:

    dwOffset    - The offset into the flatfile where we want to write the bytes
    pbBuffer    - Pointer to the source buffer
    cbBuffer    - Number of bytes to be written
    pdwOffset   - If non-null, to return the real offset
    pcbWritten  - If non-null, to return bytes written

Return value:

    S_OK    - If succeeded
    Other error code otherwise
--*/
{
    TraceQuietEnter("CFlatFileWriteBuf::WriteFileReal");
    _ASSERT( pbBuffer );
    _ASSERT( m_pParentFile );

    HRESULT hr = S_OK;
    DWORD   dwOffsetWritten = dwOffset;

    //
    // Just let our parent handle it
    //
    hr = m_pParentFile->WriteNBytesToInternal(
                                 pbBuffer,
								 cbBuffer,
								 dwOffset == INFINITE ? &dwOffsetWritten : NULL,
                              	 dwOffset,
								 pcbWritten );
    if ( FAILED( hr ) ) {
        ErrorTrace( 0, "WriteNBytesToInternal failed with 0x%x", hr );
    } else {

        //
        // We must have been flushed before directly writing to the file
        //

        _ASSERT( m_iStart == m_iEnd );

        //
        // Adjust m_iStart, m_iEnd to track offset
        //

        m_iStart = m_iEnd = dwOffsetWritten + cbBuffer;
        if ( pdwOffset ) *pdwOffset = dwOffsetWritten;
    }

    return hr;
}

//
// Compute the buffer available
//

DWORD
CFlatFileWriteBuf::BufferAvail() const
{
    return m_cbBuffer - ( m_iEnd - m_iStart );
}

BOOL
CFlatFileWriteBuf::NeedFlush( 
                    const DWORD dwOffset,
                    const DWORD cbData 
                    ) const
/*++
Routine description:

    Check to see if the request for writing ( dwOffset, cbData ) will
    cause the buffer to be flushed to file first

Arguments:

    dwOffset    - The offset in file we attempt to write to
    cbData      - The length of data we attempt to write to

Return value:

    TRUE if we do need to flush, FALSE otherwise
--*/
{
    if ( !NeedFlush() ) {

        //
        // If we are not enabled, or we are empty, no need to flush
        //

        return FALSE;
    }
    
    if (    dwOffset != INFINITE && dwOffset != m_iEnd || 
            BufferAvail() < cbData ) {

        //
        // If the offset we are writing to is not consecutive with
        // where we have written up to, or if the buffer remained is
        // too small, it must be flushed
        //

        return TRUE;
    }

    //
    // All other case, we don't need to flush
    //

    return FALSE;
}

BOOL
CFlatFileWriteBuf::NeedFlush() const
/*++
Routine description:

    Check to see if the request for writing ( dwOffset, cbData ) will
    cause the buffer to be flushed to file first

Arguments:

    dwOffset    - The offset in file we attempt to write to
    cbData      - The length of data we attempt to write to

Return value:

    TRUE if we do need to flush, FALSE otherwise
--*/
{
    if ( !IsEnabled() || m_iEnd == m_iStart ) {

        //
        // If we are not enabled, or we are empty, no need to flush
        //

        return FALSE;
    } else
        return TRUE;
}

HRESULT
CFlatFileWriteBuf::FlushFile()
/*++
Routine description:

    Flush the buffer into the file

Arguments:

    None.

Return value:

    S_OK if flushed, S_FALSE if no need to flush
    other error code if fatal
--*/
{
    TraceFunctEnter( "CFlatFileWriteBuf::FlushFile" );
    
    HRESULT     hr = S_OK;

    //
    // Let our parent handle it
    //
    
    _ASSERT( m_iEnd >= m_iStart );

    if ( m_iEnd > m_iStart ) {
        hr = m_pParentFile->WriteNBytesToInternal(
                                 m_pbBuffer,
								 m_iEnd - m_iStart,
								 NULL,
                              	 m_iStart,
								 NULL );
        if ( FAILED( hr ) ) {
            ErrorTrace( 0, "WriteNBytesToInternal failed with 0x%x", hr );
        } else {
            m_iStart = m_iEnd;
        }
    } else 
        hr = S_FALSE;
    
    TraceFunctLeave();
    return hr;
}

BOOL
CFlatFileWriteBuf::IsEnabled() const
/*++
Routine description:

    Check to see if we are enabled

Arguments:

    None.

Return value:

    TRUE if we are enabled, FALSE otherwise
--*/
{
    if ( m_pbBuffer && m_pParentFile->IsFileOpened() ) {
        return TRUE;
    } else {
        return FALSE;
    }
}

VOID
CFlatFileWriteBuf::FillBuffer(
                    const DWORD     dwOffset,
                    const PBYTE     pbBuffer,
                    const DWORD     cbBuffer,
                    PDWORD          pdwOffset,
                    PDWORD          pcbWritten
                    )
/*++
Routine description:

    Fill the stuff into the buffer

Arguments:

    dwOffset    - The offset into the flatfile where we want to write the bytes
    pbBuffer    - Pointer to the source buffer
    cbBuffer    - Number of bytes to be written
    pdwOffset   - If non-null, to return the real offset
    pcbWritten  - If non-null, to return bytes written

Return value:

    S_OK    - If succeeded
    Other error code otherwise
--*/
{
    TraceQuietEnter( "CFlatFileWriteBuf::FillBuffer" );
    _ASSERT( pbBuffer );
    _ASSERT( IsEnabled() );
    _ASSERT( m_iEnd >= m_iStart );
    _ASSERT( m_iEnd == m_iStart || m_iEnd == dwOffset || dwOffset == INFINITE );
    _ASSERT( BufferAvail() >= cbBuffer );
    _ASSERT( m_cbBuffer > 0 );

    DWORD iStart = m_iEnd - m_iStart;

    CopyMemory( m_pbBuffer + iStart, pbBuffer, cbBuffer );

    if ( dwOffset != INFINITE && m_iEnd == m_iStart ) {
        m_iStart = m_iEnd = dwOffset;
    }

    if ( pdwOffset ) 
        *pdwOffset = ( dwOffset == INFINITE ) ? m_iEnd : dwOffset;
    if ( pcbWritten ) 
        *pcbWritten = cbBuffer;
    
    m_iEnd += cbBuffer;
    _ASSERT( m_iEnd - m_iStart <= m_cbBuffer );

}

HRESULT
CFlatFileWriteBuf::WriteFileBuffer( 
                    const DWORD     dwOffset,
                    const PBYTE     pbBuffer,
                    const DWORD     cbBuffer,
                    PDWORD          pdwOffset,
                    PDWORD          pcbWritten
                    )
/*++
Routine description:

    Write byte range into the flat file buffer, which could cause
    buffer flush first if need be

Arguments:

    dwOffset    - The offset into the flatfile where we want to write the bytes
    pbBuffer    - Pointer to the source buffer
    cbBuffer    - Number of bytes to be written
    pdwOffset   - If non-null, to return the real offset
    pcbWritten  - If non-null, to return bytes written

Return value:

    S_OK    - If succeeded
    Other error code otherwise
--*/
{
    TraceQuietEnter( "CFlatFileWriteBuf::WriteFile" );
    _ASSERT( pbBuffer );

    HRESULT hr = S_OK;

    if ( NeedFlush( dwOffset, cbBuffer ) ) {

        // 
        // If we need to flush the buffer first, we'll do so
        //

        hr = FlushFile();
        if ( FAILED( hr ) ) {
            ErrorTrace( 0, "Flush file failed with 0x%x", hr );
            goto Exit;
        }
    }
        
    if ( !IsEnabled() || cbBuffer > m_cbBuffer ) {

        //
        // If we are not enabled, or our buffer is not big enough,
        // we'll write directly into the file
        //

        hr = WriteFileReal( dwOffset, pbBuffer, cbBuffer, pdwOffset, pcbWritten );
        if ( FAILED( hr ) ) {
            ErrorTrace( 0, "WriteFileReal failed with 0x%x", hr );
        }
        goto Exit;
    }

    //
    // Now we can copy the content into our buffer
    //

    FillBuffer( dwOffset, pbBuffer, cbBuffer, pdwOffset, pcbWritten );

Exit:

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\nntp\core\include\artutil.h ===
typedef char* CHARPTR;

BOOL ValidateFileBytes( HANDLE );
BOOL ValidateFileBytes( LPSTR, BOOL );
BOOL fMultiSzRemoveDupI(char * multiSz, DWORD & c, CAllocator * pAllocator);
VOID vStrCopyInc( char * , char* & );
BOOL FValidateMessageId( LPSTR );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\nntp\core\include\cbuffer.h ===
/*++

	buffer.h

	This file contains the class definitions for buffers in the NNTP server.

	A CBuffer is a reference counted buffer which is variable sized.
	CBuffer's will be created in one of several standard sizes, the size 
	stored in the m_cbTotal field.

--*/

#ifndef	_CBUFFER_H_
#define	_CBUFFER_H_

#include	"gcache.h"

class CSmallBufferCache;
class CMediumBufferCache;

//
//  The largest buffer we will use - must be big enough to hold
//  encrypted SSL blobs in contiguous chunks
//
extern  DWORD   cbLargeBufferSize ;

//
//  Medium size buffers - will be used for commands which generate large
//  responses, and when sending files through SSL
//
extern  DWORD   cbMediumBufferSize ;

//
//  Small buffers - used to read client commands and send small responses.
//
extern  DWORD   cbSmallBufferSize ;

//
//	Buffer management class - this class can represent buffers 
//	of various sizes.   The buffer is Ref counted, and contains the total
//	size of the buffer.
//
class	CBuffer	: public	CRefCount	{
public : 
	unsigned	m_cbTotal ;		//	Total size of the buffer
	char		m_rgBuff[1] ;		//	Variable size arrary
private : 

	//
	//	Related classes for memory management of CBuffer's
	//
	friend	class	CBufferAllocator ;
	static	BOOL				gTerminate ;
	static	CBufferAllocator	gAllocator ;

	//
	//	Not allowed to construct CBuffer's without providing a size for m_cbTotal - 
	//	hence this constructor is made private !
	//
	CBuffer() ;
public : 

	//
	//	Default cache's to allocate and release buffers to and from
	//
	static	CSmallBufferCache*	gpDefaultSmallCache ;	// small buffers
	static	CMediumBufferCache*	gpDefaultMediumCache ;	// medium buffers

	//
	//	When constructing a CBuffer - specify the actual size of the m_rgBuff area !
	//
	CBuffer( int cbTotal ) : m_cbTotal(cbTotal) {}

	//
	//	These functions set up and tear down the memory management structures for CBuffer's
	//
	static	BOOL	InitClass() ;
	static	BOOL	TermClass() ;

	//
	//	The following functions handle memory management of CBuffer's.
	//	This version of new will do its best to get a cached buffer for us.
	//
	void*	operator	new( 
							size_t	size, 
							DWORD	cb, 
							DWORD	&cbOut,	
							CSmallBufferCache*	pCache = gpDefaultSmallCache,
							CMediumBufferCache*	pMedium = gpDefaultMediumCache
							) ;

	//
	//	Delete will release to our default cache's if possible
	//	other directly to the underlying allocator
	//
	void	operator	delete(	
							void *pv 
							) ;	

	//
	//
	//
	static	void		Destroy(	
							CBuffer*	pbuffer,	
							CSmallBufferCache*	pCache 
							) ;

} ;

class	CBufferAllocator	:	public	CClassAllocator	{
//
//	This class wraps up our calls to the general purpose 
//	CBuffer allocator.  We do this so that we can build CCache
//	derived allocation caches.  (CSmallBufferCache and CMediumBufferCache)
//
//	Basically, we will maintain 3 CPool objects from which we
//	will manage all allocations.  Buffers will come in one of 3 sizes
//	Small buffers - use these when getting client commands
//	Medium buffers - used fo receive client postings, send large command 
//		responses, transmit SSL encrypted files
//	Large buffers - used to handle worst case SSL encrypted blobs (32K)
//
private: 
	//
	//	Constant for the number of possible buffer sizes
	//
	enum	CBufferConstants	{
		MAX_BUFFER_SIZES = 3, 
	} ;

	//	
	//	Array of CPool's from which we allocate buffers
	//
	static	CPool	rgPool[MAX_BUFFER_SIZES] ;
	
	//
	//	Our constructor is private - because there is only one of us !
	//
	CBufferAllocator()	{}

	//
	//	CBuffer gets to be our friend
	//
	friend	class	CBuffer ;

	//
	//	CSmallBufferCache knows about our different CPools
	//
	friend	class	CSmallBufferCache ;

	//
	//	CMediumBufferCache knows about our different CPools
	//	
	friend	class	CMediumBufferCache ;

public : 
	//
	//	Array of sizes - tells us what size buffer we get from each CPool
	//
	static	DWORD	rgPoolSizes[MAX_BUFFER_SIZES] ;

	//
	//	Set up all of our CPools
	//
	static	BOOL	InitClass() ;

	//
	//	Release every bit of memory in our CPools
	//
	static	BOOL	TermClass() ;

	//
	//	Allocate a single buffer.
	//	cbOut gets the 'TRUE' size of the buffer allocated.
	//
	LPVOID	Allocate(	DWORD	cb, DWORD&	cbOut = CClassAllocator::cbJunk ) ;

	//
	//	Release an allocated buffer - automagically goes to correct CPool
	//
	void	Release( void *lpv ) ;

#if 1
	int		GetPoolIndex(	void*	lpv ) ;
	void	Erase(	void*	lpv ) ;
	BOOL	EraseCheck(	void*	lpv ) ;
	BOOL	RangeCheck( void*	lpv ) ;
	BOOL	SizeCheck(	DWORD	cb ) ;
#endif
} ;

class	CSmallBufferCache :	public	CCache	{
//
//	This class is used within CIODriver's and the like to keep
//	a cache of buffers around.  Mostly, we're trying to avoid
//	the synchronization costs it would take to put buffers on and
//	off of CPool Queues.
//
private : 
	//
	//	Pointer to the one and only BufferAllocator we will use to 
	//	allocate buffers.  This needs to be derived from CAllocator so 
	//	we can use CCache as a base class.
	//
	static	CBufferAllocator*	BufferAllocator ;

	//
	//	This is our storage space - hold pointers to SMALL buffers only here.
	//
	void*	lpv[4] ;
public : 
	//
	//	Initialize class globals - always succeeds !!
	//
	static	void	InitClass(	CBufferAllocator*	Allocator )	{	BufferAllocator = Allocator ; }

	//
	//	Initialize a CSmallBufferCache()
	//
	inline	CSmallBufferCache(	) :		CCache( lpv, 4 )	{} ;
	
	//
	//	Release anything we may have in the cache and then fall on our sword
	//
	inline	~CSmallBufferCache( ) {		Empty( BufferAllocator ) ;	}
	
	//
	//	Return a buffer to its origin
	//
	inline void	Free(	void*	lpv ) ; 

	//
	//	Allocate a small buffer
	//
	inline	void*	Alloc(	DWORD	size,	DWORD&	cbOut=CCache::cbJunk ) ; 
} ;

class	CMediumBufferCache : public	CCache	{
//
//	This class is just like CSmallBufferCache, except that we handle MEDIUM
//	sized buffers only !
//
private : 
	//
	//	The CBufferAllocator object from which we can get all our buffers
	//
	static	CBufferAllocator*	BufferAllocator ;

	//
	//	Storage space for cache.
	//
	void*	lpv[4] ;
public : 

	//
	//	Initialize class static members - easily done and always successfull
	//
	static	void	InitClass(	CBufferAllocator*	Allocator )	{	BufferAllocator = Allocator ; }

	//
	//	Initialize our Cache
	//
	inline	CMediumBufferCache(	) :		CCache( lpv, 4 )	{} ;

	//
	//	Release everything in our cache
	//
	inline	~CMediumBufferCache( ) {		Empty( BufferAllocator ) ;	}
	
	//
	//	Free memory back to the Allocator if our cache is full
	//
	inline void	Free(	void*	lpv ) ; 

	//
	//	Allocate from our cache preferably
	//
	inline	void*	Alloc(	DWORD	size,	DWORD&	cbOut=CCache::cbJunk ) ; 
} ;

void
CSmallBufferCache::Free(	
					void*	lpv 
					) {
/*++

Routine Description : 

	Return a previously allocated buffer either to our cache or the 
	general allocator.

Arguments : 

	lpv - the released memory

Return Value : 

	None.

--*/

	CPool**	pPool = (CPool**)lpv ;
	if( pPool[-1] == &CBufferAllocator::rgPool[0] ) {
		CCache::Free( lpv,	BufferAllocator ) ;
	}	else	{
		BufferAllocator->Release( lpv ) ;
	}
}

void*
CSmallBufferCache::Alloc(	
					DWORD	size,	
					DWORD&	cbOut 
					)		{
/*++

Routine Description : 

	Allocate out of our cache if possible a buffer of the requested minimum size.
	If this is larger than what we hold in our cache - go to the general allocator.

Arguments : 

	size - requested size
	cbOut - actual size of the block returned.

Return Value : 

	Pointer to allocated block (NULL on failure).

--*/
	if(	(size + sizeof( CPool*)) < CBufferAllocator::rgPoolSizes[0] ) {
		cbOut = CBufferAllocator::rgPoolSizes[0] - sizeof( CPool * ) ;
		return	CCache::Alloc( size, BufferAllocator ) ;
	}	
	return	BufferAllocator->Allocate( size, cbOut ) ;
}	

void
CMediumBufferCache::Free(	
					void*	lpv 
					) {
/*++

Routine Description : 

	Return a previously allocated buffer either to our cache or the 
	general allocator.

Arguments : 

	lpv - the released memory

Return Value : 

	None.

--*/

	CPool**	pPool = (CPool**)lpv ;
	if( pPool[-1] == &CBufferAllocator::rgPool[1] ) {
		CCache::Free( lpv,	BufferAllocator ) ;
	}	else	{
		BufferAllocator->Release( lpv ) ;
	}
}

void*
CMediumBufferCache::Alloc(	
					DWORD	size,	
					DWORD&	cbOut 
					)		{
/*++

Routine Description : 

	Allocate out of our cache if possible a buffer of the requested minimum size.
	If this is larger than what we hold in our cache - go to the general allocator.

Arguments : 

	size - requested size
	cbOut - actual size of the block returned.

Return Value : 

	Pointer to allocated block (NULL on failure).

--*/
	DWORD	cb = size + sizeof( CPool*) ;
	if(	cb < CBufferAllocator::rgPoolSizes[1] &&
		cb > CBufferAllocator::rgPoolSizes[0] ) {
		cbOut = CBufferAllocator::rgPoolSizes[1] - sizeof( CPool * ) ;
		return	CCache::Alloc( size, BufferAllocator ) ;
	}	
	return	BufferAllocator->Allocate( size, cbOut ) ;
}	

typedef    CRefPtr< CBuffer >      CBUFPTR;

#endif	//	_PACKET_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\nntp\core\include\drvid.h ===
///////////////////////////////////////////////////////////////////////////
// This file defines prop id's that drivers need ( FSDriver and EXDriver )
//

#include "mailmsgprops.h"

///////////////////////////////////////////////////////////////////////////
//  IMSG Store Driver ID's
//  Base: 0xc0000010
#define IMSG_SERIAL_ID          0xc0000010	// used for post across stores
#define IMSG_IFS_HANDLE         0xc0000011	// should go away eventually
#define IMSG_SECONDARY_GROUPS   IMMPID_NMP_SECONDARY_GROUPS
#define IMSG_SECONDARY_ARTNUM   IMMPID_NMP_SECONDARY_ARTNUM
#define	IMSG_PRIMARY_GROUP		IMMPID_NMP_PRIMARY_GROUP
#define IMSG_PRIMARY_ARTID		IMMPID_NMP_PRIMARY_ARTID
#define IMSG_POST_TOKEN         IMMPID_NMP_POST_TOKEN
#define IMSG_NEWSGROUP_LIST		IMMPID_NMP_NEWSGROUP_LIST
#define IMSG_HEADERS			IMMPID_NMP_HEADERS
#define IMSG_NNTP_PROCESSING	IMMPID_NMP_NNTP_PROCESSING

#define NNTP_PROCESS_POST		NMP_PROCESS_POST
#define NNTP_PROCESS_CONTROL	NMP_PROCESS_CONTROL
#define NNTP_PROCESS_MODERATOR	NMP_PROCESS_MODERATOR

///////////////////////////////////////////////////////////////////////////
// Common group property id's for both drivers
#define	NEWSGRP_PROP_SECDESC	0xc0002000	// group level security descriptor	

///////////////////////////////////////////////////////////////////////////
// FSDriver specific group property id's
#define NEWSGRP_PROP_FSOFFSET   0xc0001000	// offset into driver owned property file

///////////////////////////////////////////////////////////////////////////
// ExDriver specific group property id's
#define NEWSGRP_PROP_FID        0xc0000001	// Folder ID
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\nntp\core\include\article.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    article.h

Abstract:

    This module contains class declarations/definitions for

		CArticle
        CField
			CDateField
			CFromField
			CMessageIDField
			CSubjectField
			CNewsgroupsField
			CPathField
			CXrefField
			CFollowupToField
			CReplyToField
			CApprovedField
			CSenderField
			CExpiresField
			COrganizationField
			CSummaryField
			CReferencesField
            CControlField
			CLinesField
			CDistributionField
			CKeywordsField
			CNNTPPostingHostField
			CXAuthLoginNameField
		CNAMEREFLIST


    **** Overview ****

    An CArticle object provides an software interface for viewing
	and editing a netnews article.
	
	An object is initialized by
	giving it a handle or filename for a file containing a Netnews
	article. During initialization the article is "preparsed".
	Preparsing consists of memory mapping the file and then
	finding the location of
	    1. The gap that may preceed the article in the file.
		2. The article in the file.
		3. The article's header
		4. The article's body.

	Also for every header line in the header, the preparsing creates an
	entry in an array that records the location of:
		1. The header line
		2. The keyword
		4. The value

	All these locations are represented with Pointer/Counter Strings (See
	CPCString in pcstring.h.) This representation has just to parts
		1. A char pointer to the start of the item in the memory mapped file..
		2. A dword containing the length of the item.


  **** Fields ****

	Each CArticle object can also have several CField subobjects. These
	subobjects specialize in parsing and editing specific types of fields.
	For example, the CNewsgroupsField object knows how to validate, get,
	and set the "Newsgroups: " field.

  **** Derivied Objects ****

	Every type of feed (e.g. FromClient, FromPeer, etc) defines its own CArticle
	object with the CField subobjects that it needs. For example, for FromClient
	feeds there is a CFromClientArticle (defined in fromclnt.h) with a
	CFromClientFromField (also defined in fromclnt.h) that does very strict
	parsing of the article's "From: " field.

  **** Editing an Article ****

	The header of an article can be edited by deleting old headers and adding
	new ones. Headers are deleted just may marking an field in the array of
	header values. Headers are added by adding a new entry to the array. This
	entry can't just point to the memory-mapped file, so it instead points
	to dynamically allocated memory.

	When an article is "saved" (or "flushed"), the actual image on disk is
	changed to reflected the changes made.



Author:

    Carl Kadie (CarlK)     10-Oct-1995

Revision History:

--*/

#ifndef	_ARTICLE_H_
#define	_ARTICLE_H_

#include <pcstring.h>
#include <artcore.h>

//
// CPool Signature
//

#define ARTICLE_SIGNATURE (DWORD)'2195'

class CNntpServerInstanceWrapper;

//
// CArticle now derives from CArticleCore.  CArticleCore has all the
// properties and methods that provide the basic article parse functionality.
// CArticleCore is instantiable because it has no pure virtual mehtods.
// CArticle defines interfaces to be implemented by different type of
// articles ( fromclnt, frompeer, etc ) by adding pure virtual functions
// and instance related members to CArticleCore.
//
class CArticle : public CArticleCore {

private :

	// Used for memory allocation
	static	CPool	gArticlePool ;

protected:

//
// Public Members
//
public :

	// Used for memory allocation
	static	BOOL	InitClass() ;
	static	BOOL	TermClass() ;
	void*	operator	new(	size_t	size ) ;
	void	operator	delete( void *pv ) ;

	//
	//   Constructor
    //  Initialization Interface -
    //   The following functions are used to create & destroy newsgroup objects
    //
    // Lightweight Constructors -
    // These constructors do very simple initialization.  The Init() functions
    // need to be called to get a functional newsgroup.
    //
    CArticle();

   	//
   	//   Destructor
   	//

    virtual ~CArticle() ;



    //
    //  the virtual server instance for this article
    //
    CNntpServerInstanceWrapper *m_pInstance ;

    //
    //  If an incoming article was small enough to fit entirely into
    //  a memory buffer - call this function !
    //

    BOOL    fInit(
                char*       pchHead,
                DWORD       cbHead,
                DWORD       cbArticle,
                DWORD       cbBufferTotal,
                CAllocator* pAllocator,
                CNntpServerInstanceWrapper *pInstance,
                CNntpReturn&    nntpReturn
                ) {
        m_pInstance = pInstance;
        return CArticleCore::fInit(     pchHead,
                                        cbHead,
                                        cbArticle,
                                        cbBufferTotal,
                                        pAllocator,
                                        nntpReturn );
        }

    //
    //  If an incoming article was so large that it did not fit into
    //  a memory buffer call this initialization function !
    //

    BOOL    fInit(
            char*       pchHead,
            DWORD       cbHead,
            DWORD       cbArticle,
            DWORD       cbBufferTotal,
            HANDLE      hFile,
            LPSTR       lpstrFileName,
            DWORD       ibHeadOffset,
            CAllocator* pAllocator,
            CNntpServerInstanceWrapper *pInstance,
            CNntpReturn&    nntpReturn
            ) {
        m_pInstance = pInstance;
        return CArticleCore::fInit( pchHead,
                                    cbHead,
                                    cbArticle,
                                    cbBufferTotal,
                                    hFile,
                                    lpstrFileName,
                                    ibHeadOffset,
                                    pAllocator,
                                    nntpReturn );
    }

    //
    // Give either file name or file handle, initialize article object
    //
    BOOL fInit(
			const char * szFilename,
			CNntpReturn & nntpReturn,
			CAllocator * pAllocator,
			CNntpServerInstanceWrapper *pInstance,
			HANDLE hFile = INVALID_HANDLE_VALUE,
			DWORD	cBytesGapSize = cchUnknownGapSize,
			BOOL    fCacheCreate = FALSE
			) {
	    m_pInstance = pInstance;
	    return CArticleCore::fInit( szFilename,
	                                nntpReturn,
	                                pAllocator,
	                                hFile,
	                                cBytesGapSize,
	                                fCacheCreate );
	}

    //
    //  Pass the article to a mail provider (for postings to moderated groups)
    //
    BOOL    fMailArticle(
            LPSTR   lpModerator
            //class CSecurityCtx*   pSecurity,
            //BOOL  fIsSecure
            ) ;

    //
    //   A virtual function for validating articles
    //

    virtual BOOL fValidate(
            CPCString& pcHub,
            const char * szCommand,
            CInFeed*    pInFeed,
            CNntpReturn & nntpr )   = 0;

    //
    // A virtual function for processing the arguments to
    // the Post, IHave, XReplic, etc line used to transfer
    // this article to this machine.
    //
    virtual BOOL fCheckCommandLine(
             char const * szCommand,
             CNntpReturn & nntpr
                ) = 0;

    //
    //   Depending on the type of the feed, modify the headers.
    // This includes deleting headers that we don't want (for example,
    // xref) and adding headers we do want Organization, PostingHost, Path,
    // MessageID as appropriate for the type of feed. It will leave space for
    // the XRef value.
    //

    virtual BOOL fMungeHeaders(
             CPCString& pcHub,
             CPCString& pcDNS,
             CNAMEREFLIST & namerefgrouplist,
             DWORD remoteIpAddress,
             CNntpReturn & nntpReturn,
             PDWORD pdwLinesOffset = NULL ) = 0;

    //
    // Returns the message id of the article if it is available
    //

    virtual const char * szMessageID(void) = 0;

    // Return the control message type in the control header of this article
    // Derived classes should redefine this to return the actual message type
    virtual CONTROL_MESSAGE_TYPE cmGetControlMessage(void) {
             _ASSERT(FALSE);
              return (CONTROL_MESSAGE_TYPE)MAX_CONTROL_MESSAGES;    // guaranteed to NOT be a control message
            };

    // Return the newsgroups listed in the article's Newsgroups field
    // in multisz form.
    // This function is redefined where needed by the derived classes.
    virtual const char * multiszNewsgroups(void) {
              _ASSERT(FALSE);
              return "";
            };

    // Return the newsgroups listed in the article's Newsgroups field
    // in CNAMEREFLIST form.
    // This function is redefined where needed by the derived classes.
    virtual CNAMEREFLIST * pNamereflistGet(void)    {
             _ASSERT(FALSE);
              return (CNAMEREFLIST *) NULL;
            };

    // the number of newsgroups listed in the article's Newsgroups field.
    virtual DWORD cNewsgroups(void) = 0;

    // Return the path items listed in the article's Path field
    // in multisz form.
    // This function is redefined where needed by the derived classes.
    virtual const char * multiszPath(void) {
          _ASSERT(FALSE);
          return "";
         };

    // the number of path items listed in the article's Path field.
    virtual DWORD cPath(void) = 0;

#if 0
    //  The content of the date header
    virtual const char* GetDate( DWORD  &cbDate ) = 0 ;
#endif

};

extern const unsigned cbMAX_ARTICLE_SIZE;

#ifndef	_NO_TEMPLATES_

#ifndef _ARTICLE_TEMPLATE_
#define _ARTICLE_TEMPLATE_
typedef CRefPtr< CArticle > CARTPTR ;
#endif

#else

DECLARE_TYPE( CArticle ) 

typedef	class	INVOKE_SMARTPTR( CArticle )	CARTPTR ;

#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\nntp\core\include\ddroplst.h ===
#ifndef __DDROPLST_H__
#define __DDROPLST_H__

#include "fhash.h"
#include "listmacr.h"
#include "dbgtrace.h"
#include <dbgutil.h>
#include <iiscnfgp.h>
#include <ole2.h>
#include <imd.h>
#include <mb.hxx>
#include <xmemwrpr.h>

class CDDropGroupSet;

//
// this class holds a group name and its position in a group list
//
class CDDropGroupName {
	public:
		CDDropGroupName(LPCSTR szNewsgroup) {
			lstrcpyn(m_szNewsgroup, szNewsgroup, sizeof(m_szNewsgroup));
		}
		~CDDropGroupName() {
		}
		PLIST_ENTRY GetListEntry() { 
			return &m_le; 
		}
		LPSTR GetNewsgroup() {
			return m_szNewsgroup;
		}
	private:
		CDDropGroupName() {
			_ASSERT(FALSE);
		}
		// the name of this newsgroup
		char		m_szNewsgroup[MAX_PATH];
		// all entries are in a linked list so that they can be enumerated
		LIST_ENTRY	m_le;

	friend class CDDropGroupSet;
};

// 
// this class wraps CDDropGroupName so that it may be saved into hash
// tables
//
class CDDropGroupNameHE {
	public:
		CDDropGroupNameHE() {
			m_pDDropGroupName = NULL;
		}
		CDDropGroupNameHE(CDDropGroupName *pDDropGroupName) {
			m_pDDropGroupName = pDDropGroupName;
		}
		CDDropGroupNameHE(CDDropGroupNameHE &src) {
			m_pDDropGroupName = src.m_pDDropGroupName;
		}		
		~CDDropGroupNameHE() {
		}
		CDDropGroupName *GetDDropGroupName() { 
			return m_pDDropGroupName; 
		}
		LPCSTR GetKey() {
			return m_pDDropGroupName->GetNewsgroup();
		}
		int MatchKey(LPCSTR szNewsgroup) {
			return (0 == lstrcmp(m_pDDropGroupName->GetNewsgroup(), szNewsgroup));
		}
	private:
		CDDropGroupName *m_pDDropGroupName;
};

typedef TFHash<CDDropGroupNameHE, LPCSTR> CHASH_DDROP_GROUPS, *PCHASH_DDROP_GROUPS;

//
// this class implements a set of newsgroups that should be dropped.  
//
// public methods:
//      AddGroup() - add a group to the set
//      RemoveGroup() - remove a group from the set
//      IsGroupMember() - is this group a member of the set?
//
class CDDropGroupSet {
	public:
		CDDropGroupSet() {
			InitializeListHead(&m_leHead);
			InitializeCriticalSection(&m_cs);
		}

		~CDDropGroupSet() {
			LIST_ENTRY *ple;				// the current newsgroup 
			CDDropGroupName *pGN;			
			EnterCriticalSection(&m_cs);
			//clear the CDDropGroupName object
			ple = m_leHead.Flink;
			while (ple != &m_leHead) {
				pGN = CONTAINING_RECORD(ple, CDDropGroupName, m_le);
				ple = ple->Flink;
				XDELETE pGN;
				pGN = NULL;
			}
			
			m_hash.Clear();
			LeaveCriticalSection(&m_cs);
			DeleteCriticalSection(&m_cs);
		}

		//
		// arguments:
		//  pfnHash - a pointer to the hash function, which takes a
		//            newsgroup as an argument and returns a DWORD
		//
		BOOL Init(DWORD (*pfnHash)(const LPCSTR &szNewsgroup)) {
			return m_hash.Init(20, 10, pfnHash);
		}

		//
		// arguments:
		//  pMB - a pointer to a class MB object which is pointing to
		//        the group load/save path in the metabase
		BOOL LoadDropGroupsFromMB(MB *pMB) {
			TraceFunctEnter("CDDropGroupSet::LoadDropGroupsFromMB");

			DWORD dwPropID = 0;
			BOOL fSuccessful = TRUE;

			DebugTrace(0, "starting to enum list of dropped groups");
			while (fSuccessful) {
				char szNewsgroup[MAX_PATH];
				DWORD cbNewsgroup = sizeof(szNewsgroup);

				if (!pMB->GetString("", dwPropID++, IIS_MD_UT_SERVER, szNewsgroup, &cbNewsgroup)) {
					DebugTrace(0, "done loading drop groups");
					break;
				}

				DebugTrace(0, "found group %s", szNewsgroup);
				if (!AddGroup(szNewsgroup)) fSuccessful = FALSE;
			}

			TraceFunctLeave();
			return fSuccessful;
		}

		//
		// arguments:
		//  pMB - a pointer to a class MB object which is pointing to
		//        the group load/save path in the metabase
		BOOL SaveDropGroupsToMB(MB *pMB) {
			TraceFunctEnter("CDDropGroupSet::SaveDropGroupsToMB");

			LIST_ENTRY *ple;				// the current newsgroup 
			DWORD dwPropID = 0;				// the current property ID
			BOOL fSuccessful = TRUE;

			while (1) {
				if (!pMB->DeleteData("", dwPropID++, IIS_MD_UT_SERVER, STRING_METADATA)) {
					break;
				}
			}

			dwPropID = 0;

			EnterCriticalSection(&m_cs);
			ple = m_leHead.Flink;
			DebugTrace(0, "saving groups to MB");
			while (ple != &m_leHead && fSuccessful) {
				CDDropGroupName *pGN;
				pGN = CONTAINING_RECORD(ple, CDDropGroupName, m_le);
				ple = ple->Flink;

				DebugTrace(0, "saving group %s", pGN->GetNewsgroup());

				fSuccessful = pMB->SetString("", dwPropID++, IIS_MD_UT_SERVER, 
									    pGN->GetNewsgroup());
			}
			DebugTrace(0, "Saved all groups");
			LeaveCriticalSection(&m_cs);
			if (fSuccessful) fSuccessful = pMB->Save();

			return fSuccessful;
		}

		BOOL AddGroup(LPCSTR szNewsgroup) {
			if (m_hash.SearchKey(szNewsgroup) == NULL) {
				CDDropGroupName *pGroupName = XNEW CDDropGroupName(szNewsgroup);
				CDDropGroupNameHE he(pGroupName);

				EnterCriticalSection(&m_cs);
				m_hash.Insert(he);
				InsertHeadList(&m_leHead, pGroupName->GetListEntry());
				LeaveCriticalSection(&m_cs);
				return TRUE;
			} else {
				return FALSE;
			}
		}

		BOOL RemoveGroup(LPCSTR szNewsgroup) {
			CDDropGroupNameHE *pHE;
			CDDropGroupName *pGroupName;

			pHE = m_hash.SearchKey(szNewsgroup);
			if (pHE != NULL) {
				pGroupName = pHE->GetDDropGroupName();
				if (pGroupName != NULL) {
					EnterCriticalSection(&m_cs);
					RemoveEntryList(pGroupName->GetListEntry());
					m_hash.Delete(szNewsgroup);
					LeaveCriticalSection(&m_cs);
					return TRUE;
				} else {
					return FALSE;
				}
			} else {
				return FALSE;
			}		
		}

		BOOL IsGroupMember(LPCSTR szNewsgroup) {
			CDDropGroupNameHE *pHE;

			pHE = m_hash.SearchKey(szNewsgroup);
			return (pHE != NULL);
		}

	private:
		CHASH_DDROP_GROUPS	m_hash;
		LIST_ENTRY			m_leHead;
		CRITICAL_SECTION	m_cs;

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\nntp\core\include\cfeed.h ===
#ifndef	_CFEED_H_
#define	_CFEED_H_

//
// CPool Signature
//

#define FEED_SIGNATURE (DWORD)'3702'

//
// The states of an Feed object
//

typedef enum _FEED_STATE {
	ifsInitialized,
	ifsUninitialized,
} FEED_STATE;


class	CFeed 	{
private : 

	//
	// For memory allocation
	//

	static	CPool	gFeedPool ;

protected : 

	//
	//	The number of events logged on this session of this feed.
	//
	
	DWORD	m_cEventsLogged ;

//
//Public Members
//

public :

	//
	// For memory allocation
	//

#ifndef _UNIT_TEST_
	void*	operator	new(	size_t size ) ;
	void	operator	delete(	void*	pv ) ;
	static	BOOL	InitClass( ) ;
	static	BOOL	TermClass( ) ;
#endif


	//
	// Constructor
    //  Initialization Interface -
    //   The following functions are used to create & destroy newsgroup objects.
    //
    // These constructors do very simple initialization.  The Init() functions
    // need to be called to get a functional newsgroup.
    //
	CFeed():
			m_feedState(ifsUninitialized),
			m_cEventsLogged( 0 )
			{};

	// Destructor
	virtual ~CFeed(void) {};

	//
	// Access function that gives the completion context
	//

	PVOID	feedCompletionContext(void) {
			return m_feedCompletionContext;
			}


	//
	//	Log errors that occur associated with feed processing.
	//	we will put a cap on the number of errrs logged.
	//
	
	virtual	void	LogFeedEvent(
			DWORD	idMessage, 	
			LPSTR	lpstrMessageId,
			DWORD   dwInstanceId
			) ;

	//
	//	Return a string that can be used to log errors indicating
	//	what type of feed was processing the articles etc...
	//
	virtual	LPSTR	FeedType()	{
				return	"UNSUPPORTED" ;
				}

//
// Protected Members
//

protected :

	//
	// The state of the feed object.
	//

	FEED_STATE m_feedState;

	

    //
    // Feed manager completion context.  This is passed back
    // to the feed manager after a feed completes.
    //

    PVOID m_feedCompletionContext;



};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\nntp\core\include\dirnot.h ===
#ifndef _DIRNOT_HXX_
#define _DIRNOT_HXX_

#include <atq.h>
#include <windows.h>
#include <wtypes.h>
#include <cpool.h>
#include <xmemwrpr.h>
#include <rwnew.h>

// forward 
class IDirectoryNotification;

// prototype completion function
typedef BOOL (*PDIRNOT_COMPLETE_FN)(PVOID pContext, WCHAR *pszFilename);
typedef HRESULT (*PDIRNOT_SECOND_COMPLETE_FN)( IDirectoryNotification *pDirNot );
typedef VOID (*PFN_SHUTDOWN_FN)(VOID);

class CRetryQ;

class IDirectoryNotification {
	public:
		static HRESULT GlobalInitialize(DWORD cRetryTimeout, 
										DWORD cMaxInstances, 
										DWORD cInstanceSize,
										PFN_SHUTDOWN_FN	pfnShutdown);
		static HRESULT GlobalShutdown(void);
		IDirectoryNotification();
		~IDirectoryNotification();
		HRESULT Initialize( WCHAR *pszDirectory, 
		                    PVOID pContext, 
		                    BOOL  bWatchSubTree,
		                    DWORD dwNotifyFilter,  
		                    DWORD dwChangeAction,
						    PDIRNOT_COMPLETE_FN pfnComplete,
						    PDIRNOT_SECOND_COMPLETE_FN pfnSecondComplete = DoFindFile,
						    BOOL bAppendStartRetry = TRUE
						    );
		static VOID DirNotCompletion(PVOID pAtqContext, DWORD cWritten,
									 DWORD dwCompletionStatus, 
									 OVERLAPPED *lpOverlapped);
		BOOL CallCompletionFn(PVOID pContext, WCHAR *pszFilename) {
			return m_pfnComplete(pContext, pszFilename);
		}
		BOOL CallSecondCompletionFn( IDirectoryNotification *pDirNot ) {
		    return m_pfnSecondComplete( pDirNot );
		}
		static HRESULT DoFindFile( IDirectoryNotification *pDirNot );
		HRESULT Shutdown(void);
		void CleanupQueue(void);
		BOOL IsShutdown(void) { return m_fShutdown; }
		PVOID GetInitializedContext() { return m_pContext; }
	private:
		HRESULT PostDirNotification();

		HANDLE m_hDir;						// handle to the directory
		PATQ_CONTEXT m_pAtqContext;			// ATQ context for directory
		LONG m_cPendingIo;					// the number of outstanding IOs
		PDIRNOT_COMPLETE_FN m_pfnComplete;	// pointer to completion function
		PDIRNOT_SECOND_COMPLETE_FN m_pfnSecondComplete; // function to call when FindFirst/FindNext
		static PFN_SHUTDOWN_FN	m_pfnShutdown;	// shutdown fn to be called for stop hints etc
		PVOID m_pContext;					// pointer to context
		WCHAR m_szPathname[MAX_PATH + 1];	// the path we are running against
		DWORD m_cPathname;					// the length of m_szPathname
		static CRetryQ *g_pRetryQ;			// the retry queue
		BOOL m_fShutdown;					// set to true when shutdown starts
		HANDLE m_heNoOutstandingIOs;		// set when the last IO completes
		CShareLockNH m_rwShutdown;			// r/w lock used to synch shutdown
		BOOL m_bWatchSubTree;               // Do we need to watch sub tree ?
		DWORD m_dwNotifyFilter;             // Notify filter
		DWORD m_dwChangeAction;             // Change action that I care about

		LONG IncPendingIoCount() { return InterlockedIncrement(&m_cPendingIo); }
		LONG DecPendingIoCount() { 
			TraceQuietEnter("IDirectoryNotification::DecPendingIoCount");
			LONG x = InterlockedDecrement(&m_cPendingIo); 
			if (x == 0) {
				DebugTrace(0, "no more outstanding IOs\n");
				SetEvent(m_heNoOutstandingIOs);
			}
			return x;
		}
};

class CDirNotBuffer;

typedef struct _DIRNOT_OVERLAPPED {
    OVERLAPPED Overlapped;
    CDirNotBuffer *pBuffer;
} DIRNOT_OVERLAPPED;

#define	DIRNOT_BUFFER_SIGNATURE		'tNrD'

class CDirNotBuffer {
    public:
		static CPool* g_pDirNotPool;

        CDirNotBuffer(IDirectoryNotification *pDirNot) {
			m_pDirNot = pDirNot;
			ZeroMemory(&m_Overlapped, sizeof(m_Overlapped));
			m_Overlapped.pBuffer = this;
		}

        ~CDirNotBuffer(void) {
		}

        //
        // override mem functions to use CPool functions
        //
        void* operator new(size_t cSize) { return g_pDirNotPool->Alloc(); }
        void operator delete(void *pInstance) { g_pDirNotPool->Free(pInstance); }

        //
        // get the max number of bytes in the buffer
        //
        DWORD GetMaxSize() { return g_pDirNotPool->GetInstanceSize(); }
        //
        // get a pointer to the buffers data area
        //
        LPBYTE GetData() { return (LPBYTE) &m_Buffer; }
		//
		// get the size of the buffer data area
        //
		DWORD GetMaxDataSize() { 
			return (GetMaxSize() - sizeof(CDirNotBuffer) + sizeof(m_Buffer)); 
		}
		// 
		// get the parent IDirectoryNotification class that created this
		//
		IDirectoryNotification *GetParent() {
			return m_pDirNot;
		}

		//
		// signature for the class
		//
		DWORD m_dwSignature;
        //
        // the extended IO overlap structure
        //      In order for the completion port to work, the overlap
        //       structure is extended to add one pointer to the 
        //       associated CBuffer object
        //
        DIRNOT_OVERLAPPED m_Overlapped;

    private:
		// 
		// pointer to the IDirectoryNotification that started this all
		//
		IDirectoryNotification *m_pDirNot;
		//
		// the buffer itself.  total size is set by reg key
		//
		WCHAR m_Buffer[1];

		friend IDirectoryNotification;
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\nntp\core\include\fixprop.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

	fixprop.h

Abstract:

	This module contains class declarations/definitions for

		CFixPropPersist

	**** Overview ****

	The class is the implementation of a fixed sized property
	storage.  It is mainly used for news group's fixed sized
	property.

Author:

	Kangrong Yan	( KangYan )		7-5-1998

Revision History:

--*/

#ifndef _FIXPROP_H_
#define _FIXPROP_H_

#include <tflistex.h>
#include <cpool.h>
#include <group.h>
#include <xmemwrpr.h>

#define GROUPNAME_LEN_MAX 512
#define ALLOC_GRANURALITY 64
#define ID_HIGH_INVALID     0xffffffff
#define FIXPROP_SIGNATURE DWORD('fixp' )
#define FREEINFO_SIGNATURE DWORD('free')

#define ALL_FIX_PROPERTIES	( 	FIX_PROP_NAME | 		\
								FIX_PROP_NAMELEN | 		\
								FIX_PROP_GROUPID |		\
								FIX_PROP_LASTARTICLE |	\
								FIX_PROP_FIRSTARTICLE |	\
								FIX_PROP_ARTICLECOUNT |	\
								FIX_PROP_READONLY |		\
								FIX_PROP_ISSPECIAL |	\
								FIX_PROP_DATELOW |		\
								FIX_PROP_DATEHIGH )		

#define ALL_BUT_NAME_AND_LEN ( 	ALL_FIX_PROPERTIES & 	\
								(~FIX_PROP_NAME) &	\
								(~FIX_PROP_NAMELEN ) )	

//
// Manage free list
//
class CFreeInfo { //fi
public:
	CFreeInfo 	*m_pNext;
	CFreeInfo 	*m_pPrev;
	CFreeInfo(): m_pNext( NULL ),
				 m_pPrev( NULL ),
				 m_dwOffset( 0 ) {}
	DWORD		m_dwOffset;

	// Used for memory allocation
	BOOL m_bFromPool;
	static BOOL InitClass();
	static BOOL TermClass();
	inline void* operator new( size_t size );
	inline void  operator delete( void *pv );

private:
	static CPool g_FreeInfoPool;
};

//
// Manage file handle pool
// It's not CPool'd, because the handle pool is very small
// and there are not many re-new operations
//
/*
class CFileHandle { //fh
public:
	CFileHandle	*m_pNext;
	CFileHandle *m_pPrev;
	CFileHandle(): 	m_pNext( NULL ),
					m_pPrev( NULL ),
					m_hFile( INVALID_HANDLE_VALUE ),
					m_bFromPool( TRUE ) {}
	HANDLE	m_hFile;	
	BOOL	m_bFromPool;
};
*/

#define MAX_FREEINFO_SIZE  sizeof( CFreeInfo )
#define MAX_FREEINFO_OBJECTS ALLOC_GRANURALITY // If exceed, use normal new

//
// Block for fixed group properties
//
struct DATA_BLOCK {	//db
	CHAR		szGroupName[GROUPNAME_LEN_MAX+1]; // Null means free
	DWORD		dwGroupNameLen;	
	DWORD		dwGroupId;
	DWORD		dwHighWaterMark;
	DWORD		dwLowWaterMark;
	DWORD		dwArtCount;
	BOOL		bReadOnly;
	BOOL		bSpecial;
	FILETIME	ftCreateDate;
};

//
//  Private overlapped struct for additional fields like IoSize
//

typedef struct _OVERLAPPED_EXT
{
		    OVERLAPPED  ovl;            // NT OVERLAPPED struct
			DWORD       dwIoSize;       // size of IO submitted
} OVERLAPPED_EXT;

//
// Callback function used by those who init me:
// I will call this function for every group property
// block that I have enumerated
//
typedef
BOOL (*PFNENUMCALLBACK)( DATA_BLOCK&, PVOID, DWORD, BOOL );

//
// This object is not multi-thread safe for group operations
// because it assumes that the mutual exclusion is done by
// the news group object
//
// It is mt safe for free list and file expansion operation.
//
class CFixPropPersist { //fp
public:

	//
	// Constructor, destructor
	//
	CFixPropPersist( IN LPSTR szStorageFile );
	~CFixPropPersist();

	//
	// Init, Term
	//
	BOOL Init( 	IN BOOL bCreateIfNonExist,
				IN PVOID pvContext,
				OUT PDWORD pdwIdHigh,
				IN PFNENUMCALLBACK = NULL );
	BOOL Term();

	//
	// Add, Remove, Get, Set operations
	//
	BOOL AddGroup( 	IN INNTPPropertyBag *pPropBag );
	BOOL RemoveGroup( IN INNTPPropertyBag *pPropBag );
	BOOL GetGroup( IN OUT INNTPPropertyBag *pPropBag, DWORD dwPropertyFlag );
	BOOL SetGroup( IN INNTPPropertyBag *pPropBag, DWORD dwPropertyFlag );
	BOOL SaveTreeInit();
	BOOL SaveGroup( INNTPPropertyBag *pPropBag );
	BOOL SaveTreeClose( BOOL bEffective );

#if defined(DEBUG)
#ifdef __TESTFF_CPP__
	friend int __cdecl main( int, char** );
#endif
	VOID Validate();	// assert on fail, no return value
	VOID DumpFreeList();
	VOID DumpGroups();
#endif	

private:

	// No default constructor allowed
	CFixPropPersist();

	CHAR	m_szStorageFile[MAX_PATH+1];	// file path for the storage
	HANDLE  m_hStorageFile;				// default file handle object
	HANDLE  m_hBackupFile;              // backup file that has ordered groups
	DWORD	m_cCurrentMaxBlocks;		// how many blocks are there
										// in the file ?
	PVOID	m_pvContext;				// Whatever context passed in
										// by init
	CShareLockNH m_FileExpandLock;		// only used for file expansion
	TFListEx<CFreeInfo> m_FreeList;		// Free list
	DWORD	m_dwIdHigh;					// Current max id high

	//
	// Lock array for read / write synchronization: we'll use
	// offset's modular as index into the array
	//

	CShareLockNH m_rgLockArray[GROUP_LOCK_ARRAY_SIZE];

	//
	// Lock/unlock wrappers for lock array
	//

	DWORD   ShareLock( INNTPPropertyBag *pPropBag );
	void    ShareUnlock( DWORD dwOffset );
	DWORD   ExclusiveLock( INNTPPropertyBag *pPropBag );
	void    ExclusiveUnlock( DWORD dwOffset );

	//
	// Free info list lock
	//

	CShareLockNH    m_FreeListLock;

	//
	// Wrappers for locking/unlocking free list
	//
	
	void ShareLockFreeList() { m_FreeListLock.ShareLock(); }
	void ShareUnlockFreeList() { m_FreeListLock.ShareUnlock(); }
	void ExclusiveLockFreeList() { m_FreeListLock.ExclusiveLock(); }
	void ExclusiveUnlockFreeList() { m_FreeListLock.ExclusiveUnlock(); }

	//
	// Id high lock
	//

    CShareLockNH    m_IdHighLock;

    //
    // Wrappers for locking/unlocking id high
    //

    void ShareLockIdHigh() { m_IdHighLock.ShareLock(); }
    void ShareUnlockIdHigh() { m_IdHighLock.ShareUnlock(); }
    void ExclusiveLockIdHigh() { m_IdHighLock.ExclusiveLock(); }
    void ExclusiveUnlockIdHigh() { m_IdHighLock.ExclusiveUnlock(); }

	//
	// Utility
	//
	inline static VOID Group2Buffer(DATA_BLOCK& dbBuffer,
									INNTPPropertyBag *pPropBag,
									DWORD	dwFlag );
	inline static VOID Buffer2Group(DATA_BLOCK& dbBuffer,
									INNTPPropertyBag *pPropBag,
									DWORD	dwFlag );
	BOOL ReadFile( PBYTE, DWORD dwOffset, DWORD dwSize = sizeof( DATA_BLOCK ), BOOL bReadBlock = TRUE );
	BOOL WriteFile( PBYTE, DWORD dwOffset, DWORD dwSize = sizeof( DATA_BLOCK ), BOOL bWriteBlock = TRUE);
	BOOL CFixPropPersist::AsyncRead( PBYTE pbBuffer, LARGE_INTEGER   liOffset, DWORD dwSize );
    BOOL CFixPropPersist::AsyncWrite( PBYTE pbBuffer, LARGE_INTEGER liOffset, DWORD dwSize );
	BOOL ExtendFile( DWORD cBlocks );
	DWORD SeekByName( LPSTR );
	DWORD SeekByGroupId( DWORD, LPSTR );
	DWORD SeekByBest( INNTPPropertyBag * );
	BOOL ProbeForOrder( BOOL& );
	DWORD GetGroupOffset( INNTPPropertyBag * );

	// Clean the free info list
	void CleanFreeList();

	// static ref count for initilization
	static LONG    m_lRef;

	// static lock for init / term synchronization
	static CShareLockNH m_sLock;
};

#include "fixprop.inl"

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\nntp\core\include\gcache.h ===
#ifndef	_GCACHE_H_
#define	_GCACHE_H_


class	CClassAllocator	{
protected :
	static	DWORD	cbJunk ;
	CClassAllocator() ;
	virtual	~CClassAllocator() ;
public :
	virtual	LPVOID		Allocate(	DWORD	cb,	DWORD&	cbOut = cbJunk ) = 0 ;
	virtual	void		Release(	void*	lpv ) = 0 ;
#ifdef	DEBUG
	virtual	void		Erase( LPVOID	lpv ) ;
	virtual	BOOL		EraseCheck(	LPVOID	lpv ) ;
	virtual	BOOL		RangeCheck( LPVOID	lpv ) ;
	virtual	BOOL		SizeCheck(	DWORD	cb ) ;
#endif
} ;
	

class	CCache	{
private :
	void**	m_pCache ;
	DWORD	m_clpv ;

	void*	InternalFree(	void*	lpv ) ;
	void*	InternalAlloc() ;

protected :
	static	DWORD	cbJunk ;

	CCache(	void**	pCache,	DWORD	size ) ;
	~CCache() ;

	void	Free(	void*	lpv,	CClassAllocator*	pAllocator ) ;
	void*	Alloc(	DWORD	size,	CClassAllocator*	pAllocator,	DWORD&	cbOut = cbJunk ) ;
	void*	Empty( ) ;
	void	Empty(	CClassAllocator*	pAllocator ) ;
} ;


#ifdef	UNIT_TEST

class	CClientAllocator : public	CClassAllocator	{
public :
	LPVOID		Allocate(	DWORD	cb, DWORD	&cbOut = CClassAllocator::cbJunk ) ;
	void		Release(	void*	lpv ) ;
} ;

class	CClientCache : public	CCache	{
private :
	static	CClassAllocator*	gAllocator ;
public :
	static	BOOL	InitClass(	CClassAllocator*	gAllocator ) ;

	CClientCache(	void**	ppCache,	DWORD	size ) ;
   ~CClientCache() ;
	inline	void	Free(	void*	lpv )	{	CCache::Free( lpv, gAllocator ) ;	}
	inline	void*	Alloc(	DWORD	size )	{	return	CCache::Alloc(	size,	gAllocator ) ;}

} ;

class	CacheClient	{
private :
	static	CClientAllocator	MyAllocator ;
public :
	static	BOOL	InitClass() ;
	
	void*	operator	new(	size_t	size,	CClientCache&	pCache )	{	return	pCache.Alloc( size ) ; }
	static	void		Destroy(	CacheClient*	pClient, CClientCache&	pCache )	{	pClient->CacheClient::~CacheClient() ;	pCache.Free( pClient ) ; }

	char	*lpstr ;

	CacheClient(	LPSTR	lpstr ) ;
	~CacheClient() ;
} ;

#endif	// UNIT_TEST

#endif	// _GCACHE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\nntp\core\include\fromclnt.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    fromclnt.h

Abstract:

    This module contains class declarations/definitions for

		CFromClientFeed

		CFromClientArticle

		CFromClientDateField
		CFromClientExpiresField
        CControlField
		CFromClientFromField
		CFromClientMessageIDField
		CFromClientSubjectField
		CFromClientNNTPPostingHostField
		CFromClientPathField
		CFromClientXrefField
		CFromClientFollowupToField
		CFromClientReplyToField
		CFromClientApprovedField
		CFromClientSenderField
		CFromClientXAuthLoginNameField
		CFromClientOrganizationField
		CFromClientSummaryField
		CFromClientNewsgroupsField
		CFromClientReferencesField
		CFromClientLinesField
		CFromClientDistributionField
		CFromClientKeywordsField


    **** Overview ****

	This derives classes from CInFeed, CArticle, and CField
	that will be used to process articles from clients. Mostly,
	it just defines various CField-derived objects.

Author:

    Carl Kadie (CarlK)     05-Dec-1995

Revision History:


--*/

#ifndef	_FROMCLNT_H_
#define	_FROMCLNT_H_

//
//!!!CLIENT LATER - note: not supported yet: control messages
//!!!CLIENT LATER - note: not supported yet: length check (from peer or client)
//!!!CLIENT LATER - note: not supported yet:  character set check
//!!!CLIENT LATER - note: not supported yet: signiture check
//!!!CLIENT NEXT - need both uupc hub name (in lower case) for path and xref *and* local-machine domain name for message-id
//!!!CLIENT NEXT - are dups allowed of any fields?
//!!!CLIENT LATER - reorder lines on output to put more important lines (like message-id) first
//


//
// Forward defintion
//

class	CFromClientArticle;

//
// Tells how to process the Date field in articles from the clients
//

class CFromClientDateField : public CDateField {
public:

	//
	// There should only be one such field in articles from clients.
	//

	BOOL fFind(
			CArticleCore & article,
			CNntpReturn & nntpReturn)
		{
			return fFindOneOrNone(article, nntpReturn);
		};

	//
	// The field should be strictly parsed.
	//

	BOOL fParse(
		    CArticleCore & article, 
			CNntpReturn & nntpReturn)
		{
			return fStrictDateParse(m_pc, FALSE, nntpReturn);
		};

	//
	// How to set the field.
	//

	BOOL fSet(
			CFromClientArticle & article,
			CNntpReturn & nntpReturn
			);
};

//
// Tells how to process the Expires field in articles from the clients
//

class CFromClientExpiresField : public CExpiresField {
public:

	//
	// There should only be one such field in articles from clients.
	//

	BOOL fFind(
			CArticleCore & article,
			CNntpReturn & nntpReturn)
		{
			return fFindOneOrNone(article, nntpReturn);
		};

	//
	// The field should be strictly parsed.
	//

	BOOL fParse(
		    CArticleCore & article, 
			CNntpReturn & nntpReturn)
		{
			// if this is not a strict RFC 822 date, check if it is a proper relative date
			if(!fStrictDateParse(m_pc, TRUE, nntpReturn))
				return fRelativeDateParse(m_pc, TRUE, nntpReturn);
			return TRUE;
		};

};

/*
 This header line, if presented, has the same format as "From".  Same set of test cases would apply.  Besides, Tigris server should use this header line to reply to poster/sender, if presented.  This test case should be handled by Server State Integrity Test.
 */
//
// Tells how to process the From field in articles from the clients
//

class CFromClientFromField : public CFromField {
public:

//
// commenting out becuase this code doesn't allow messages that meet
// rfc1468 to be parsed.  we want to just use the default.
//
#if 0
	//
	// The field should be strictly parsed.
	//

	BOOL fParse(
	        CArticleCore & article, 
			CNntpReturn & nntpReturn)
		{
			return fSimpleFromParse(m_pc, FALSE, nntpReturn);
		};
#endif

};

//
// Tells how to process the MessageID field in articles from the clients
//

class CFromClientMessageIDField : public CMessageIDField {
public:

	//
	// How to set the field.
	//

	BOOL fSet(
			CFromClientArticle & article,
			CPCString & pcHub,
			CNntpReturn & nntpReturn
			);

	//
	// There should only be one such field in articles from clients.
	//
	BOOL fFind(
			CArticleCore & article,
			CNntpReturn & nntpReturn)
		{
			return fFindOneOrNone(article, nntpReturn);
		};


};

//
// Tells how to process the Subject field in articles from the clients
//

class CFromClientSubjectField : public CSubjectField {
public:

	//
	// Parse with ParseSimple
	//

	BOOL fParse(
		    CArticleCore & article, 
			CNntpReturn & nntpReturn)
		{
			return fParseSimple(TRUE, m_pc, nntpReturn);
		};

	friend CArticleCore;
	friend CArticle;

};




//
// Tells how to process the NNTPPostingHost field in articles from the clients
//

class CFromClientNNTPPostingHostField : public CNNTPPostingHostField {
public:

	//
	//	NNTP-Posting-Host field should NOT be present in clients
	//
	BOOL fFind(
			CArticleCore & article,
			CNntpReturn & nntpReturn)
		{
			return fFindNone(article, nntpReturn);
		};

	//
	// How to set the field.
	//

	BOOL fSet(
			CFromClientArticle & article,
			DWORD remoteIpAddress,
			CNntpReturn & nntpReturn
			);
};

//
// Tells how to process the Path field in articles from the clients
//

class CFromClientPathField : public CPathField {
public:


	//
	//	Path field need not be present from clients
	//
	BOOL fFind(
			CArticleCore & article,
			CNntpReturn & nntpReturn)
		{
			return fFindOneOrNone(article, nntpReturn);
		};

	//
	// How to set the field.
	//
	
	BOOL fSet(
			CFromClientArticle & article,
			CPCString & pcHub, CNntpReturn & nntpReturn
			);
};

//
// Tells how to process the Xref field in articles from the clients
//
// Just use the defaults.
//

class CFromClientXrefField : public CXrefField {
public:
};


//
// Tells how to process the FollowupTo field in articles from the clients
//

class CFromClientFollowupToField : public CFollowupToField {

public:

	//
	// Constructor
	//

	CFromClientFollowupToField():
			m_multiSzFollowupTo(NULL),
			m_cFollowupTo((DWORD) -1),
			m_pAllocator(NULL)
			{};

	//
	// Destructor
	//


	virtual ~CFromClientFollowupToField(void){
				if (fsParsed == m_fieldState)
				{
					_ASSERT(m_pAllocator);
					m_pAllocator->Free(m_multiSzFollowupTo);
				}
			};


	//
	// There should only be one such field in articles from clients.
	//

	BOOL fFind(
			CArticleCore & article,
			CNntpReturn & nntpReturn)
		{
			return fFindOneOrNone(article, nntpReturn);
		};

	//
	// Parse strictly
	//

	BOOL fParse(
		   CArticleCore & article,
			CNntpReturn & nntpReturn)
		{
			//
			// Record the allocator
			//

			m_pAllocator = article.pAllocator();

			return fStrictNewsgroupsParse(TRUE, m_multiSzFollowupTo, 
						m_cFollowupTo, article, nntpReturn);
		};

private:

	//
	// Points to a list of path items to follow up to
	//

	char * m_multiSzFollowupTo;

	//
	// The number of path items in the FollowupTo value.
	//

	DWORD m_cFollowupTo;

	//
	// Where to allocate from
	//

	CAllocator * m_pAllocator;


};


/*
 This header line, if presented, has the same format as "From".
 */
//
// Tells how to process the ReplyTo field in articles from the clients
//

class CFromClientReplyToField : public CReplyToField {
public:

	//
	// There should only be one such field in articles from clients.
	//

	BOOL fFind(
			CArticleCore & article,
			CNntpReturn & nntpReturn)
		{
			return fFindOneOrNone(article, nntpReturn);
		};

	//
	// The field should be strictly parsed.
	//

	BOOL fParse(
		    CArticleCore & article, 
			CNntpReturn & nntpReturn)
		{
			return fStrictFromParse(m_pc, TRUE, nntpReturn);
		};

};

//
// Tells how to process the Approved field in articles from the clients
//

class CFromClientApprovedField : public CApprovedField {
public:

	//
	// There should only be one such field in articles from clients.
	//

	BOOL fFind(
			CArticleCore & article,
			CNntpReturn & nntpReturn)
		{
			return fFindOneOrNone(article, nntpReturn);
		};

	//
	// Parse with ParseSimple
	//

	BOOL fParse(
		    CArticleCore & article, 
			CNntpReturn & nntpReturn)
		{
			return fParseSimple(FALSE, m_pc, nntpReturn);
		};
};

/* This header line, if presented, has the format as "From" and "Reply-To".  It is presented only if the poster/sender manually enters "From" header line. */
//
// Tells how to process the Sender field in articles from the clients
//

class CFromClientSenderField	: public CSenderField {
public:

	//
	// There should only be one such field in articles from clients.
	//

	BOOL fFind(
			CArticleCore & article,
			CNntpReturn & nntpReturn)
		{
			return fFindOneOrNone(article, nntpReturn);
		};

	//
	// The field should be strictly parsed.
	//

	BOOL fParse(
		    CArticleCore & article, 
			CNntpReturn & nntpReturn)
		{
			return fStrictFromParse(m_pc, TRUE, nntpReturn);
		};
};


//
// Tells how to process the XAuthLoginName field in articles from the clients
//

class CFromClientXAuthLoginNameField	: public CXAuthLoginNameField {
public:

	//
	// How to set the field.
	//
	
	BOOL fSet(
			CFromClientArticle & article,
			CNntpReturn & nntpReturn
			);
};

//
// Tells how to process the Organization field in articles from the clients
//

class CFromClientOrganizationField : public COrganizationField {
public:

	//
	// There should only be one such field in articles from clients.
	//

	BOOL fFind(
			CArticleCore & article,
			CNntpReturn & nntpReturn)
		{
			return fFindOneOrNone(article, nntpReturn);
		};

	//
	// Parse with ParseSimple
	//

	BOOL fParse(
		    CArticleCore & article, 
			CNntpReturn & nntpReturn)
		{
			return fParseSimple(TRUE, m_pc, nntpReturn);
		};

	//
	// How to set the field.
	//
	
	BOOL fSet(
			CFromClientArticle & article,
			CNntpReturn & nntpReturn
			);
};

//
// Tells how to process the Summary field in articles from the clients
//

class CFromClientSummaryField : public CSummaryField {
public:

	//
	// There should only be one such field in articles from clients.
	//

	BOOL fFind(
			CArticleCore & article,
			CNntpReturn & nntpReturn)
		{
			return fFindOneOrNone(article, nntpReturn);
		};

	//
	// Parse with ParseSimple
	//

	BOOL fParse(
		    CArticleCore & article, 
			CNntpReturn & nntpReturn)
		{
			return fParseSimple(TRUE, m_pc, nntpReturn);
		};
};

//
// Tells how to process the Newsgroups field in articles from the clients
//

class CFromClientNewsgroupsField : public CNewsgroupsField {

public:

	//
	// Parse strictly
	//

	BOOL fParse(
					CArticleCore & article,
					CNntpReturn & nntpReturn)
		{
			//
			// Record the allocator
			//

			m_pAllocator = article.pAllocator();

			return fStrictNewsgroupsParse(FALSE, m_multiSzNewsgroups,
							m_cNewsgroups, article, nntpReturn);
		};

	//
	// How to set the field.
	//
	
	BOOL fSet(
			CFromClientArticle & article,
			CNntpReturn & nntpReturn
			);

};



//
// Tells how to process the References field in articles from the clients
//

class CFromClientReferencesField : public CReferencesField {
public:

	//
	// Constructor
	//

	CFromClientReferencesField():
			m_multiSzReferences(NULL),
			m_cReferences((DWORD) -1),
			m_pAllocator(NULL)
			{};

	//
	//   Deconstructor
	//

	virtual ~CFromClientReferencesField(void){
				if (fsParsed == m_fieldState)
				{
					_ASSERT(m_pAllocator);
					m_pAllocator->Free(m_multiSzReferences);
				}
			};


	//
	// There should only be one such field in articles from clients.
	//

	BOOL fFind(
			CArticleCore & article,
			CNntpReturn & nntpReturn)
		{
			return fFindOneOrNone(article, nntpReturn);
		};

	//
	// How to parse
	//

	BOOL fParse(
	    CArticleCore & article, 
		CNntpReturn & nntpReturn
		);

private:

	//
	// A pointer to a list of the references
	//

	char * m_multiSzReferences;

	//
	// The number of references
	//

	DWORD m_cReferences;

	//
	// Where to allocate from
	//

	CAllocator * m_pAllocator;

};



//
// Tells how to process the Lines field in articles from the clients
//

class CFromClientLinesField : public CLinesField {
public:


	//
	// How to parse
	//

	BOOL fParse(
		    CArticleCore & article, 
			CNntpReturn & nntpReturn
			);
};

//
// Tells how to process the Distribution field in articles from the clients
//

class CFromClientDistributionField : public CDistributionField {

public:


	//
	// Parse strictly
	//

	BOOL fParse(
					CArticleCore & article,
					CNntpReturn & nntpReturn);

	//
	// How to set the field.
	//
	
	BOOL fSet(
			CFromClientArticle & article,
			CNntpReturn & nntpReturn
			);

};


//
// Tells how to process the Keywords field in articles from the clients
//

class CFromClientKeywordsField : public CKeywordsField {
public:

	//
	// There should only be one such field in articles from clients.
	//

	BOOL fFind(
			CArticleCore & article,
			CNntpReturn & nntpReturn)
		{
			return fFindOneOrNone(article, nntpReturn);
		};

	//
	// Parse with ParseSimple
	//

	BOOL fParse(
		    CArticleCore & article, 
			CNntpReturn & nntpReturn)
		{
			return fParseSimple(TRUE, m_pc, nntpReturn);
		};
};

//
//
//
// CFromClientArticle - class for manipulating articles from the client.
//

class	CFromClientArticle  : public CArticle {
public:

	//
	// Constructor
	//

	CFromClientArticle(
			char * szLoginName)
		{
			m_szLoginName = szLoginName;
		}

	//
	// Destructor
	//
	virtual ~CFromClientArticle(void) {};

	//
	// The function for validating articles from Clients
	// Check that required headers are there (Newsgroups, From)
	//  this will mean checking for necessary
	//  headers (Newsgroups, Subject, From, ???).
	//

	BOOL fValidate(
			CPCString& pcHub,
			const char * szCommand,
			class	CInFeed*	pInFeed,
			CNntpReturn & nntpReturn
			);

	//
	// Always returns TRUE
	//

	BOOL fCheckCommandLine(
			char const * szCommand,
			CNntpReturn & nntpr)
		{
			return nntpr.fSetOK(); //!!!FROMMASTER NEXT may want to implement this
		} 

	//
	// Modify the headers.
	// Add MessageID, Organization (if necessary), NNTP-Posting-Host,
	// X-Authenticated-User, Modify path
	//

	BOOL fMungeHeaders(
			 CPCString& pcHub,
			 CPCString& pcDNS,
			 CNAMEREFLIST & grouplist,
			 DWORD remoteIpAddress,
			 CNntpReturn & nntpr,
			 PDWORD pdwLinesOffset = NULL
			 );

	//
	// Return the article's messageid
	//

	const char * szMessageID(void) {
			return m_fieldMessageID.szGet();
			};

    // Return the control message type in the control header of this article
	CONTROL_MESSAGE_TYPE cmGetControlMessage(void) {
			return m_fieldControl.cmGetControlMessage();
			};

	//
	// Return the article's path items
	//

	const char * multiszNewsgroups(void) {
			return m_fieldNewsgroups.multiSzGet();
			};

	//
	// Return number of newsgroups
	//

	DWORD cNewsgroups(void) {
			return m_fieldNewsgroups.cGet();
			};

	//
	// Return the article's path items
	//

	const char * multiszPath(void) {
			return m_fieldPath.multiSzGet();
			};

	//
	// Return number of path items
	//

	DWORD cPath(void) {
			return m_fieldPath.cGet();
			};

#if 0 
	const char*	GetDate( DWORD&	cbDate )	{
			CPCString	string = m_fieldDate.pcGet() ;
			cbDate = string.m_cch ;
			return	string.m_pch ;
	}
#endif

	friend CFromClientXAuthLoginNameField;

	//
	// For unit testing
	//

	friend int __cdecl main(int argc, char *argv[ ]);

protected :

	//
	// The fields that will be found, parsed, or set
	//

	CFromClientDateField			m_fieldDate;
	CFromClientFromField			m_fieldFrom;
	CFromClientMessageIDField		m_fieldMessageID;
	CFromClientSubjectField			m_fieldSubject;
	CFromClientNewsgroupsField		m_fieldNewsgroups;
	CFromClientPathField			m_fieldPath;
	CFromClientXrefField			m_fieldXref;
	CFromClientFollowupToField		m_fieldFollowupTo;
	CFromClientReplyToField			m_fieldReplyTo;
	CFromClientApprovedField		m_fieldApproved;
	CFromClientSenderField			m_fieldSender;
	CFromClientOrganizationField	m_fieldOrganization;
	CFromClientNNTPPostingHostField	m_fieldNNTPPostingHost;
	CFromClientXAuthLoginNameField	m_fieldXAuthLoginName;
	CFromClientSummaryField			m_fieldSummary;
	CFromClientReferencesField		m_fieldReferences;
	CFromClientKeywordsField		m_fieldKeyword;
 	CFromClientDistributionField	m_fieldDistribution;
    CControlField                   m_fieldControl;
 	CFromClientLinesField			m_fieldLines;
 	CFromClientExpiresField			m_fieldExpires;
 
	//
	// Open the article's file in Read/Write mode.
	//

	BOOL fReadWrite(void) {
			return TRUE;
			}

	//
	// Check the length of the article body.
	//

	BOOL fCheckBodyLength(
			CNntpReturn & nntpReturn
			);

	//
	// Require that the character following "Field Name:" is a space
	//

	BOOL fCheckFieldFollowCharacter(
			char chCurrent)
		{
			return ' ' == chCurrent;
		}

	//
	// A pointer to the poster's login name.
	//

	char * m_szLoginName;
};



//
//
//
// CFromClientFeed - for processing incomming articles from clients.
//

class	CFromClientFeed:	public CInFeed 	{

//
// Public Members
//

public :

	//
	// Constructor
	//

	CFromClientFeed(void){};

	//
	// Destructor
	//

	virtual ~CFromClientFeed(void) {};

	//
	//	Return a string that can be used to log errors indicating
	//	what type of feed was processing the articles etc...
	//
	LPSTR	FeedType()	{
				return	"From Client" ;
				}


	//
	// virtual function that tells if this command is allowed.
	//

	BOOL fIsPostLegal(void) {
			return TRUE;
			};

	//
	// virtual function that tells if this command is allowed.
	//

	BOOL fIsXReplicLegal(void) {
			return FALSE;
			};

	//
	// virtual function that tells if this command is allowed.
	//

	BOOL fIsIHaveLegal(void) {
			return FALSE;
			};

	//
	// function that tells fPost path that we can email moderators !
	//

    BOOL fModeratorChecks(void )    {
            return  TRUE ;
            }

	BOOL	fAcceptPosts( CNntpServerInstanceWrapper *pInstance )	
	{	return	pInstance->AllowClientPosts() ;	}


	DWORD	cbHardLimit( CNntpServerInstanceWrapper *pInstance )	
	{	return	pInstance->ServerHardLimit() ;	}

	DWORD	cbSoftLimit( CNntpServerInstanceWrapper *pInstance )	
	{	return	pInstance->ServerSoftLimit() ;	}	

	BOOL	fAllowControlMessages( CNntpServerInstanceWrapper *pInstance )	
	{	return	pInstance->AllowControlMessages() ;	}

	//
	// static function which handles picking up files from the pickup
	// directory
	//
	static BOOL PickupFile(PVOID pServerInstance, WCHAR *wszFilename);

protected:

	//
	// Function to create an article of type CFromClientArticle
	//

	CARTPTR pArticleCreate(void) {
			_ASSERT(ifsInitialized == m_feedState);
			return new CFromClientArticle(m_szLoginName);
			};

	//
	// Records the mesage id in the hash table
	//

	BOOL fRecordMessageIDIfNecc(
			CNntpServerInstanceWrapper * pInstance,
			const char * szMessageID,
			CNntpReturn & nntpReturn
			);

	//
	// The return code for article's with no groups that we have.
	//

	NRC	nrcNoGroups(void) {
			return nrcArticleNoSuchGroups;
			};

	//
	// Return code for accepted articles
	//

	NRC	nrcArticleAccepted(BOOL	fStandardPath) {
			return nrcArticlePostedOK;
			};

	//
	// Return code for rejected articles.
	//

	NRC	nrcArticleRejected(BOOL	fStandardPath) {
			return nrcPostFailed;
			};

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\nntp\core\include\grouplst.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    grouplst.h

Abstract:

    This module contains class declarations/definitions for

		CGroupList




    **** Overview ****

	This defines list object using templates and object.
	This list will be used to represent list of newsgroup objects
	and lists of newsgroup information (name, groupid, article id).

    It is designed to be as much like the MPC List type as possible.

Author:

    Carl Kadie (CarlK)     29-Oct-1995

Revision History:


--*/

#ifndef	_GROUPLST_H_
#define	_GROUPLST_H_

#include <xmemwrpr.h>
#include "tigmem.h"

//
// The type of a position in the list.
//

typedef void * POSITION;

//
//
//
// CGroupList - template class defining a simple list.
//

#ifndef	_NO_TEMPLATES_

template<class ITEM>
class CGroupList {

public :

   //
   // Constructor - creates a null GroupList
   //

	CGroupList() ;

	//
	// Init - the maximum size of the list must be given
	//

	BOOL fInit(
			DWORD cMax,
			CAllocator * pAllocator
		) ;

	BOOL fAsBeenInited(void) ;
		   
    //
	// Destructor - the memory allocated for the list is freed.
	//

	~CGroupList(void) ;

	//
	// Returns the head position
	//

	POSITION GetHeadPosition() ;

	//
	// Get current item and move the POSITION to the next item
	//

	ITEM * GetNext(POSITION & pos);

	//
	// Get the current item.
	//

	ITEM * Get(POSITION & pos);

	//
	// Get the first item.
	//

	ITEM * GetHead();

	//
	// True if the list is empty
	//

	BOOL IsEmpty() ;

	//
	// Add an item to the end of the list.
	//

	POSITION AddTail(ITEM & item);

	//
	// sort the array of items.  fncmp should take two pointers to ITEMs 
	// and act like strcmp
	//

	void Sort(int (__cdecl *fncmp)(const void *, const void *));

	//
	// Remove all the items in the list
	//

	void RemoveAll() ;

	//
	// Remove the item from the list
	//

	void Remove(POSITION & pos) ;
	

	//
	// Return the size of the list
	//

	DWORD GetCount(void) ;

private:

	//
	// One more than the number of items allowed in the list
	//

	DWORD m_cMax;

	//
	// The index of the last item i the list
	//

	DWORD m_cLast;

	//
	// Pointer to the dynamically allocated array of items
	//

	ITEM * m_rgpItem;

	//
	// Pointer to the memory allocator
	//
	CAllocator * m_pAllocator;

	//
	// This stops call-by-value calls
	//

	CGroupList( CGroupList& ) ;
};

#else

#define	DECLARE_GROUPLST( ITEM )	\
class CGroupList ## ITEM {	\
public :	\
	CGroupList ## ITEM () ;	\
	BOOL fInit(	\
			DWORD cMax,	\
			CAllocator * pAllocator	\
		) ;	\
	BOOL fAsBeenInited(void) ;	\
	~CGroupList ## ITEM (void) ;	\
	POSITION GetHeadPosition() ;	\
	ITEM * GetNext(POSITION & pos);	\
	ITEM * Get(POSITION & pos);	\
	ITEM * GetHead();	\
	BOOL IsEmpty() ;	\
	POSITION AddTail(ITEM & item);	\
	POSITION Remove();	\
	void RemoveAll() ;	\
	DWORD GetCount(void);	\
private:	\
	DWORD m_cMax;	\
	DWORD m_cLast;	\
	ITEM * m_rgpItem;	\
	CAllocator * m_pAllocator;	\
	CGroupList ## ITEM ( CGroupList ## ITEM & ) ;	\
};

#define	INVOKE_GROUPLST( ITEM )	CGroupList ## ITEM


#endif

#include "grouplst.inl"

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\nntp\core\include\group.h ===
#ifndef __GROUP_H__
#define __GROUP_H__

#include "nntpvr.h"
#include <refptr2.h>
#include "nntpbag.h"

class CNewsTreeCore;

#define GROUP_LOCK_ARRAY_SIZE 256
#define CACHE_HIT_THRESHOLD 16
#define CACHE_HIT_MAX       256

//
// reference counting works on this object as follows:
//
// In CNewsTreeCore there should be one reference for this object when it is
// in the linked list and hash tables.  This reference is the first reference
// on the object which is obtained when it is created.  This reference is
// removed when the object is no longer in the hash tables.  It will remove
// itself from the list when its reference count goes to 0.
//
// Other users of this object should use the CRefPtr2 class to manage the
// reference count.  The Property Bag also uses the same reference count,
// so the newsgroup won't be destroyed as long as someone has a reference
// to its property bag.
//

// signature for healthy group objects
#define CNEWSGROUPCORE_SIGNATURE		(DWORD) 'CprG'
// signature for deleted group objects
#define CNEWSGROUPCORE_SIGNATURE_DEL	(DWORD) 'GrpC'

class CNewsGroupCore : public CRefCount2 {
	public:

        friend class CNNTPPropertyBag;

        //
        // For debug version, we'll wrap its AddRef and Release
        // to spit out some dbg traces, since this guys is very
        // often leaked
        //

#ifdef NEVER
#error Why is NEVER defined?
        LONG AddRef()
        {
            TraceQuietEnter("CNewsGroupCore::AddRef");
            DebugTrace( 0,
                        "Group %s AddRef to %d", 
                        m_pszGroupName,
                        m_cRefs + 1 );
            return CRefCount2::AddRef();
        }

        void Release()
        {
            TraceQuietEnter("CNewsGroupCore::Release" );
            DebugTrace( 0, 
                        "Group %s Release to %d",
                        m_pszGroupName,
                        m_cRefs - 1 );
            CRefCount2::Release();
        }
#endif

		CNewsGroupCore(CNewsTreeCore *pNewsTree) {
			TraceQuietEnter("CNewsGroupCore::CNewsGroupCore");

			m_dwSignature = CNEWSGROUPCORE_SIGNATURE;
			m_pNewsTree = pNewsTree;
			m_pNext = NULL;
			m_pPrev = NULL;
			m_pVRoot = NULL;
			m_iLowWatermark = 1;
			m_iHighWatermark = 0;
			m_cMessages = 0;
			m_pszGroupName = NULL;
			m_cchGroupName = 0;
			m_pszNativeName = NULL;
			m_dwGroupId = 0;
			m_fReadOnly = FALSE;
			m_fDeleted = FALSE;
			m_fSpecial = FALSE;
			m_pNextByName = NULL;
			m_pNextById = NULL;
			m_dwHashId = 0;
			m_iOffset = 0;
			m_pszHelpText = NULL;
			m_pszModerator = NULL;
			m_pszPrettyName = NULL;
			m_cchHelpText = 0;
			m_cchModerator = 0;
			m_cchPrettyName = 0;
			m_iOffset = 0;
			m_fVarPropChanged = TRUE;
			m_fDecorateVisited = FALSE;
			m_fControlGroup = FALSE;
			m_dwCacheHit = 0;
            m_artXoverExpireLow = 0;
            m_fAllowExpire = FALSE;
            m_fAllowPost = FALSE;
            m_PropBag.Init( this, &m_cRefs );
		}

		virtual ~CNewsGroupCore();

#ifdef DEBUG
		void VerifyGroup() {
            _ASSERT( m_iLowWatermark >= 1 );
			_ASSERT(m_pNewsTree != NULL);
		}
#else
		void VerifyGroup() { }
#endif

		//
		// these classes grab the appropriate lock
		//
		void ShareLock() {
			VerifyGroup();
			m_rglock[m_dwGroupId % GROUP_LOCK_ARRAY_SIZE].ShareLock();
		}
		void ShareUnlock() {
			VerifyGroup();
			m_rglock[m_dwGroupId % GROUP_LOCK_ARRAY_SIZE].ShareUnlock();
		}
		void ExclusiveLock() {
			// we don't do a verify here because this is called before
			// Init has done its magic
			m_rglock[m_dwGroupId % GROUP_LOCK_ARRAY_SIZE].ExclusiveLock();
		}
		void ExclusiveUnlock() {
			VerifyGroup();
			m_rglock[m_dwGroupId % GROUP_LOCK_ARRAY_SIZE].ExclusiveUnlock();
		}
        void ExclusiveToShared() {
            VerifyGroup();
            m_rglock[m_dwGroupId % GROUP_LOCK_ARRAY_SIZE].ExclusiveToShared();
        }
        BOOL SharedToExclusive() {
            VerifyGroup();
            return m_rglock[m_dwGroupId % GROUP_LOCK_ARRAY_SIZE].SharedToExclusive();
        }

		//
		// these two classes wrap the locking and unlocking process for us
		// when they are created on the stack in accessor methods
		//
		class CGrabShareLock {
			public:
				CGrabShareLock(CNewsGroupCore *pThis) {
					m_pThis = pThis;
					m_pThis->ShareLock();
				}
				~CGrabShareLock() {
					m_pThis->ShareUnlock();
				}
			private:
				CNewsGroupCore *m_pThis;
		};

		//
		// initialize with good values
		//
		BOOL Init(char *pszGroupName,
				  char *pszNativeName,
				  DWORD dwGroupId,
				  NNTPVROOTPTR pVRoot,
				  BOOL fSpecial = FALSE)
		{

			BOOL fOK = TRUE;
			m_dwGroupId = dwGroupId;

			ExclusiveLock();

			m_pVRoot = pVRoot;
			if (m_pVRoot) m_pVRoot->AddRef();

			_ASSERT(pszGroupName != NULL);
			m_cchGroupName = strlen(pszGroupName) + 1 ;
			m_pszGroupName = XNEW char[m_cchGroupName + 1];
			if (!m_pszGroupName) {
				SetLastError(ERROR_NOT_ENOUGH_MEMORY);
				fOK = FALSE;
				goto Exit;
			}
			strcpy(m_pszGroupName, pszGroupName);

			// check to see if this is one of the three control groups
			if ((strcmp(m_pszGroupName, "control.cancel") == 0) ||
			    (strcmp(m_pszGroupName, "control.newgroup") == 0) ||
				(strcmp(m_pszGroupName, "control.rmgroup") == 0))
			{
				m_fControlGroup = TRUE;
			}

			// make sure that both names are the same except for case
			if (pszNativeName != NULL) {
				_ASSERT(_stricmp(pszNativeName, pszGroupName) == 0);
				m_pszNativeName = XNEW char[m_cchGroupName + 1];
				if (!m_pszNativeName) {
					SetLastError(ERROR_NOT_ENOUGH_MEMORY);
					fOK = FALSE;
					goto Exit;
				}
				strcpy(m_pszNativeName, pszNativeName);
			} else {
				m_pszNativeName = NULL;
			}

		    m_dwHashId = CRCHash((BYTE *) m_pszGroupName, m_cchGroupName);

			m_fSpecial = fSpecial;

			GetSystemTimeAsFileTime(&m_ftCreateDate);

Exit:
			ExclusiveUnlock();

			return fOK;
		}

		//
		// update our vroot pointer.  takes place at vroot rescans
		//
		void UpdateVRoot(CNNTPVRoot *pVRoot) {
			ExclusiveLock();
			if (m_pVRoot) m_pVRoot->Release();
			m_pVRoot = pVRoot;
			if (m_pVRoot) m_pVRoot->AddRef();
			ExclusiveUnlock();
		}

		//
		// save a group property bag into the fixed length file
		//
		void SaveFixedProperties();

        // accessor function for property bag interface
        INNTPPropertyBag* GetPropertyBag() {
			// no reason to grab lock here
            m_PropBag.AddRef();
            return &m_PropBag;
        }

		//
		// accessor functions to get group properties
		//
		CNewsTreeCore *GetTree() {
			// no lock necessary
			return m_pNewsTree;
		}

		DWORD GetLowWatermark() {
			CGrabShareLock lock(this);
#ifdef DEBUG
            VerifyGroup();
#endif
			return m_iLowWatermark;
		}

		DWORD GetHighWatermark() {
#ifdef DEBUG
            VerifyGroup();
#endif
			CGrabShareLock lock(this);
			return m_iHighWatermark;
		}

		DWORD GetMessageCount() {
			CGrabShareLock lock(this);
			return m_cMessages;
		}

		BOOL IsReadOnly() {
			CGrabShareLock lock(this);
			return m_fReadOnly;
		}

		BOOL IsAllowPost() {
		    CGrabShareLock lock(this);
		    return m_fAllowPost;
		}

		char *GetGroupName() {
			// this can't change, so locking isn't necessary
			return m_pszGroupName;
		}

		DWORD GetGroupNameLen() {
			// this can't change, so locking isn't necessary
			return m_cchGroupName;
		}

		char *&GetName() {
			// this can't change, so locking isn't necessary
			return m_pszGroupName;
		}

		char *GetNativeName() {
			// this can't change, so locking isn't necessary
			return (m_pszNativeName == NULL) ? m_pszGroupName : m_pszNativeName;
		}

		DWORD GetGroupId() {
			// this can't change, so locking isn't necessary
			return m_dwGroupId;
		}

		DWORD GetGroupNameHash() {
			// this can't change, so locking isn't necessary
			return m_dwHashId;
		}

		BOOL IsDeleted() {
			CGrabShareLock lock(this);
			return m_fDeleted;
		}

		BOOL IsSpecial() {
			CGrabShareLock lock(this);
			return m_fSpecial;
		}

		BOOL IsAllowExpire() {
		    CGrabShareLock lock(this);
		    return m_fAllowExpire;
		}

		DWORD GetRefCount() {
			CGrabShareLock lock(this);
			return m_cRefs;
		}

		FILETIME GetCreateDate() {
			CGrabShareLock lock(this);
			return m_ftCreateDate;
		}

		LPCSTR GetPrettyName(DWORD *pcch = NULL) {
			CGrabShareLock lock(this);
			if (pcch) *pcch = m_cchPrettyName;
			return m_pszPrettyName;
		}

		LPCSTR GetModerator(DWORD *pcch = NULL) {
			CGrabShareLock lock(this);
			if (pcch) *pcch = m_cchModerator;
			return m_pszModerator;
		}

		DWORD GetCacheHit() {
		    CGrabShareLock lock(this);
		    return m_dwCacheHit;
		}

		ARTICLEID GetExpireLow() {
		    CGrabShareLock lock(this);
		    return m_artXoverExpireLow;
		}

		BOOL
		IsModerated()	{
			CGrabShareLock	lock(this) ;
			return	m_pszModerator != 0 && *m_pszModerator != 0;
		}

		LPCSTR GetHelpText(DWORD *pcch = NULL) {
			CGrabShareLock lock(this);
			if (pcch) *pcch = m_cchHelpText;
			return m_pszHelpText;
		}

		BOOL DidVarPropsChange() {
			return m_fVarPropChanged;
		}

		DWORD GetVarOffset() {
			return m_iOffset;
		}

		BOOL GetDecorateVisitedFlag() {
			CGrabShareLock lock(this);
			return m_fDecorateVisited; // || m_fControlGroup;
		}

		CNNTPVRoot *GetVRoot() {
			CGrabShareLock lock(this);
			if (m_pVRoot) m_pVRoot->AddRef();
			return m_pVRoot;
		}

		CNNTPVRoot *GetVRootWithoutLock() {
		    if ( m_pVRoot ) m_pVRoot->AddRef();
		    return m_pVRoot;
		}

		CNNTPVRoot *GetVRootWithoutRef() {
		    CGrabShareLock lock(this);
		    return m_pVRoot;
		}

		//
		// accessors to set group properties
		//
		void SetSpecial( BOOL f ) {
			ExclusiveLock();
			m_fSpecial = f;
			ExclusiveUnlock();
		}

		void SetCreateDate( FILETIME ft ) {
			ExclusiveLock();
			m_ftCreateDate = ft;
			ExclusiveUnlock();
		}

		void SetLowWatermark(DWORD i) {
			ExclusiveLock();
			m_iLowWatermark = i;
#ifdef DEBUG
            VerifyGroup();
#endif
			ExclusiveUnlock();
		}

		void SetHighWatermark(DWORD i) {
			ExclusiveLock();
			m_iHighWatermark = i;
#ifdef DEBUG
            VerifyGroup();
#endif
			ExclusiveUnlock();
		}

		void SetMessageCount(DWORD c) {
			ExclusiveLock();
			m_cMessages = c;
			ExclusiveUnlock();
		}

		void BumpArticleCount( DWORD dwArtId ) {
		    ExclusiveLock();

		    //
		    // Update low watermark
		    //
            if ( m_cMessages == 0 ) {	
                m_iLowWatermark = dwArtId;
            } else {
                if ( dwArtId < m_iLowWatermark )
                    m_iLowWatermark = dwArtId;
            }

            //
            // Update high watermark: this is redundant
            // for most inbound but only useful for 
            // rebuild
            //
            if ( dwArtId > m_iHighWatermark )
                m_iHighWatermark = dwArtId;
                
		    m_cMessages++;
		    ExclusiveUnlock();
		    SaveFixedProperties();
		}

		void SetReadOnly(BOOL f) {
			ExclusiveLock();
			m_fReadOnly = f;
			ExclusiveUnlock();
		}

		void SetCacheHit( DWORD dwCacheHit ) {
		    ExclusiveLock();
		    m_dwCacheHit = dwCacheHit;
		    ExclusiveUnlock();
		}

		void SetExpireLow( ARTICLEID artExpireLow ) {
		    ExclusiveLock();
		    m_artXoverExpireLow = artExpireLow;
		    ExclusiveUnlock();
		}

		void SetAllowExpire( BOOL f) {
		    ExclusiveLock();
		    m_fAllowExpire = f;
		    ExclusiveUnlock();
		}
		
		void SetAllowPost( BOOL f) {
		    ExclusiveLock();
		    m_fAllowPost = f;
		    ExclusiveUnlock();
		}

		void MarkDeleted() {
			ExclusiveLock();
			m_fDeleted = TRUE;
			m_fVarPropChanged = TRUE;
			ExclusiveUnlock();
		}

		void SavedVarProps() {
			ExclusiveLock();
			m_fVarPropChanged = FALSE;
			ExclusiveUnlock();
		}

		void ChangedVarProps() {
		    ExclusiveLock();
		    m_fVarPropChanged = TRUE;
		    ExclusiveUnlock();
		}

		void SetVarOffset(DWORD dwOffset) {
			ExclusiveLock();
			m_iOffset = dwOffset;
			ExclusiveUnlock();
		}

		void SetDecorateVisitedFlag(BOOL f) {
			ExclusiveLock();
			m_fDecorateVisited = f;
			ExclusiveUnlock();
		}

		void HitCache() {
		    ExclusiveLock();
		    if ( m_dwCacheHit < CACHE_HIT_MAX ) m_dwCacheHit++;
		    ExclusiveUnlock();
		}

		void TouchCacheHit() {
		    ExclusiveLock();
		    if ( m_dwCacheHit > 0 ) m_dwCacheHit--;
		    ExclusiveUnlock();
		}

		BOOL
		ComputeXoverCacheDir(	char*	szPath,
								BOOL&	fFlatDir,
								BOOL	fLocksHeld = FALSE
								) ;

		BOOL ShouldCacheXover();

		// these can return an error if a memory allocation failed.  If you
		// pass in NULL as the string then the property will go away
		BOOL SetHelpText(LPCSTR szHelpText, int cch = -1);
		BOOL SetModerator(LPCSTR szModerator, int cch = -1);
		BOOL SetPrettyName(LPCSTR szPrettyName, int cch = -1);
		BOOL SetNativeName(LPCSTR szNativeName, int cch = -1);

		BOOL SetDriverStringProperty(   DWORD   cProperties,
		                                DWORD   rgidProperties[] );


		// accessor functions for vroot properties
		BOOL IsContentIndexed() {
			if (m_pVRoot) return m_pVRoot->IsContentIndexed();
			else return FALSE;
		}
		DWORD GetAccessMask() {
			if (m_pVRoot) return m_pVRoot->GetAccessMask();
			else return 0;
		}
		DWORD GetSSLAccessMask() {
			if (m_pVRoot) return m_pVRoot->GetSSLAccessMask();
			else return 0;
		}

		// these are used by the CNewsTree hash table
		int MatchKey(LPSTR lpstrMatch) { return (lstrcmp(lpstrMatch, m_pszGroupName) == 0); }
		int MatchKeyId(DWORD dwMatch) { return (dwMatch == m_dwGroupId); }
		LPSTR GetKey() { return m_pszGroupName; }
		DWORD GetKeyId() { return m_dwGroupId; }
		
		CNewsGroupCore	*m_pNextByName;
		CNewsGroupCore	*m_pNextById;

		// these are used for the linked list kept by the newstree
		CNewsGroupCore *m_pNext;
		CNewsGroupCore *m_pPrev;

		// hash the ID
		static DWORD ComputeIdHash(DWORD id) {
			return id;
		}

		// hash the name
		static DWORD ComputeNameHash(LPSTR lpstr) {
			return CRCHash((BYTE *) lpstr, lstrlen(lpstr));
		}

		void InsertArticleId(ARTICLEID artid) ;
		ARTICLEID AllocateArticleId();

		BOOL DeletePhysicalArticle(ARTICLEID artid) { return FALSE; }
		BOOL AddReferenceTo(ARTICLEID, CArticleRef&);

		BOOL IsGroupAccessible( HANDLE hClientToken,
		                        DWORD   dwAccessDesired );

		BOOL RebuildGroup(  HANDLE hClientToken );

		BOOL WatermarkConsistent()
		{
		    if ( m_cMessages > 0 ) {
		        if ( m_iHighWatermark - m_iLowWatermark < m_cMessages - 1 ) {
				    _ASSERT( FALSE && "Article count inconsistent" );
				    m_cMessages = m_iHighWatermark - m_iLowWatermark + 1;
			    }
		    }
		    return TRUE;
		}

	protected:
		DWORD			m_dwSignature;
		// our array of locks
		static	CShareLockNH	m_rglock[GROUP_LOCK_ARRAY_SIZE];
		// parent newstree
		CNewsTreeCore	*m_pNewsTree;
		// parent vroot
		CNNTPVRoot 		*m_pVRoot;
        // property bag
        CNNTPPropertyBag m_PropBag;
		// high, low, count
		ARTICLEID		m_iLowWatermark;
		ARTICLEID		m_iHighWatermark;
		DWORD   		m_cMessages;
		// group name
		LPSTR			m_pszGroupName;
		DWORD			m_cchGroupName;
		// group name, with capitalization
		LPSTR			m_pszNativeName;
		// group ID
		DWORD			m_dwGroupId;
		DWORD			m_dwHashId;		// should become dwGroupId
		// read only?
		BOOL			m_fReadOnly;
		// deleted?
		BOOL			m_fDeleted;
		// is special?
		BOOL			m_fSpecial;
		// Creation date
		FILETIME		m_ftCreateDate;

		// offset into the variable length file
		DWORD			m_iOffset;
		BOOL			m_fVarPropChanged;
		// prettyname
		LPSTR			m_pszPrettyName;
		DWORD			m_cchPrettyName;
		// moderator
		LPSTR			m_pszModerator;
		DWORD			m_cchModerator;
		// help text (description)
		LPSTR			m_pszHelpText;
		DWORD			m_cchHelpText;

		// Xover Cache Hit count
		DWORD           m_dwCacheHit;

		// Can we take expire ?
		BOOL            m_fAllowExpire;

		// non-persistent property to turn off posting
		BOOL            m_fAllowPost;

		// this BOOL is set to FALSE before doing a decorate newstree.  it
		// then is set to TRUE when the group is visited during a decorate
		// after the decorate all groups which have this set to FALSE are
		// removed
		BOOL			m_fDecorateVisited;

		// this is set if the group name is control.newgroup, control.rmgroup
		// or control.cancel.  it is used to force m_fDecorateVisited to
		// always be TRUE
		BOOL			m_fControlGroup;

        //
	    //	The articleid of the lowest Xover number Xover entry we may have
	    //	This should always be less than m_artLow, and if errors occurr deleting
	    //	files may be much lower.  We hang onto this number so that we can
	    //	retry expirations if we hit snags !
	    //	This member variable should only be accessed on the expiration thread !
	    //
	    ARTICLEID	m_artXoverExpireLow ;

		friend class CGrabShareLock;
		friend class CGrabExclusiveLock;

};

typedef CRefPtr2<CNewsGroupCore> CGRPCOREPTR;
typedef CRefPtr2HasRef<CNewsGroupCore> CGRPCOREPTRHASREF;

extern		BOOL	MatchGroup( LPMULTISZ	multiszPatterns,	LPSTR	lpstrGroup ) ;	

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\nntp\core\include\frommstr.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    frommstr.h

Abstract:

    This module contains class declarations/definitions for

	CFromMasterFeed
	CFromMasterArticle

	CFromMasterMessageIDField
	CFromMasterXrefField


    **** Overview ****

	This derives classes from CInFeed, CArticle, and CField
	that will be used to process articles from masters. Mostly,
	it just defines various CField-derived objects.

Author:

    Carl Kadie (CarlK)     05-Dec-1995

Revision History:


--*/

#ifndef	_FROMMASTER_H_
#define	_FROMMASTER_H_

//
// Tells how to process the MessageID field in articles from the clients
//
// Just use the defaults.
//

class CFromMasterMessageIDField : public CMessageIDField {
};

//
// Tells how to process the Xref field in articles from the clients
//

class CFromMasterXrefField : public CXrefField {

	//
	// How to parse xref lines in articles from the master
	//

	virtual BOOL fParse(
		CArticleCore & article, 
		CNntpReturn & nntpReturn
		);


};

//
//
//
// CFromMasterArticle - class for manipulating articles from the master.
//

class	CFromMasterArticle  : public CArticle {
private: 

	DWORD	m_cNewsgroups ;

public:

	//
	// Parse the fields of the article that need parsing.
	//

	BOOL	fParse(
		    CArticleCore & article, 
			CNntpReturn & nntpr
			);

	//
	// The function for validating articles from Masters
	//  Check for duplicate messageid, check that xref is right..
	//

	BOOL	fValidate(
			CPCString& pcHub,
			const char * szCommand,
			CInFeed*	pInFeed,
			CNntpReturn & nntpr
			);



	//
	// Modify the headers.
	// Do nothing.
	//

	BOOL fMungeHeaders(
			 CPCString& pcHub,
			 CPCString& pcDNS,
			 CNAMEREFLIST & namerefgrouplist,
			 DWORD remoteIpAddress,
			 CNntpReturn & nntpReturn,
             PDWORD pdwLinesOffset = NULL
			 );

	//
	// Check the arguments to the Xreplic command
	//

	BOOL	fCheckCommandLine(
			char const * szCommand,
			CNntpReturn & nntpr
			);

	//
	// Returns the message id of the article if it is available
	//

	const char * szMessageID(void) {
			return m_fieldMessageID.szGet();
			};

    // Return the control message type in the control header of this article
	CONTROL_MESSAGE_TYPE cmGetControlMessage(void) {
			return m_fieldControl.cmGetControlMessage();
			};

	//
	// Returns the list of newsgroups
	//

	CNAMEREFLIST * pNamereflistGet(void) {
			return m_fieldXref.pNamereflistGet();
			};

	//
	// Returns the number of newsgroups
	//

	DWORD cNewsgroups(void) {
			//return m_fieldXref.cGet();
			return	m_cNewsgroups ;
			};

	//
	// This function should not be called.
	//

	const char * multiszNewsgroups(void) {
#if 0
			//
			// dir drop calls this - needs to handle empty string
			//
			_ASSERT(FALSE);
#endif
			return "";
			};

	//
	// Return 0 (take anything), so we don't need to parse the Path line
	//

	const char * multiszPath(void) {
			return m_fieldPath.multiSzGet();
			};

#if 0 
	const char *	GetDate( DWORD	&cb ) {
			cb = 0 ;
			return	NULL ;
	}
#endif

	//
	// Return NULLNULL (take anything, so we don't need to parse the Path line
	//

	DWORD cPath(void) {
			return 0;
			};


protected :

	//
	// The fields that will be found, parsed, or set
	//

	CFromMasterMessageIDField		m_fieldMessageID;
	CFromMasterXrefField			m_fieldXref;
	CPathField						m_fieldPath ;
    CControlField                   m_fieldControl;

	//
	// The file should be opened in read/write mode
	//

	BOOL fReadWrite(void) {
			return TRUE;
			}

	//
	// Accept any length
	//

	BOOL fCheckBodyLength(
			CNntpReturn & nntpReturn)
		{
			return nntpReturn.fSetOK();
		};

	//
	// The character following "Field Name:" can be anything
	//

	BOOL fCheckFieldFollowCharacter(
			char chCurrent) 
		{
			return TRUE;
		}

	//
	// For unit testing
	//

	friend int __cdecl main(int argc, char *argv[ ]);
};



//
//
//
// CFromMasterFeed - for processing incomming articles from the master.
//

class	CFromMasterFeed:	public CInFeed 	{

//
// Public Members
//

public :

	//
	//	Return a string that can be used to log errors indicating
	//	what type of feed was processing the articles etc...
	//
	LPSTR	FeedType()	{
				return	"From Master" ;
				}


	//
	// function that tells if this command is allowed.
	//

	BOOL fIsPostLegal(void) {
			return FALSE;
			};

	//
	// function that tells if this command is allowed.
	//

	BOOL fIsXReplicLegal(void) {
			return TRUE;
			};

		//
		// function that tells if this command is allowed.
		//

	BOOL fIsIHaveLegal(void) {
			return FALSE;
			};

	//
	// Init the feed.
	//

	BOOL fInit(
			CNntpReturn & nntpReturn
			);

	//
	// Returns a list of the newsgroups of the current article
	//

	CNAMEREFLIST * pNamereflistGet(void);

//
// Private Members
//

protected:

	//
	// Creates an article of the right type.
	//

	CARTPTR pArticleCreate(void){
			return new CFromMasterArticle();
			};

	//
	// Message ID's don't need to be recorded, so just return OK
	//

	BOOL fRecordMessageIDIfNecc(
			CNntpServerInstanceWrapper * pInstance,
			const char * szMessageID,
			CNntpReturn & nntpReturn)
		{
			return nntpReturn.fSetOK();
		}

	//
	// Given an article, returns lists of the newsgroups to post to.
	//

	BOOL fCreateGroupLists(
			CNewsTreeCore* pNewstree,
			CARTPTR & pArticle,
			CNEWSGROUPLIST & grouplist,
			CNAMEREFLIST * pNamereflist,
			LPMULTISZ	multiszCommandLine,
            CPCString& pcHub,
			CNntpReturn & nntpReturn
			);

    //
	//	Do nothing - moderated checks are done by the MASTER
	//  or by the SLAVE on the client path.
    //
    BOOL    fModeratedCheck(
		CARTPTR & pArticle,
		CNEWSGROUPLIST & grouplist,
        BOOL fCheckApproved,
		CNntpReturn & nntpReturn
		)
	{
		return nntpReturn.fSetOK();
	}

    //
    //  Do nothing. Accept whatever the master sends
	//  An empty grouplist implies missing control.* groups
    //

    BOOL fAdjustGrouplist(
			CNewsTreeCore* pNewstree,
            CARTPTR & pArticle,
	        CNEWSGROUPLIST & grouplist,
		    CNAMEREFLIST * pNamereflist,
		    CNntpReturn & nntpReturn)
	{
		// grouplist should not be empty at this stage !
		if( grouplist.IsEmpty() ) {
		    nntpReturn.fSet(nrcControlNewsgroupMissing);
		}

		return nntpReturn.fIsOK();
	}

	//
	// Do nothing. This would have been created in fCreateGroupLists
    //

	BOOL fCreateNamerefLists(
			CARTPTR & pArticle,
			CNEWSGROUPLIST & grouplist,
			CNAMEREFLIST * pNamereflist,
			CNntpReturn & nntpReturn)
	{
		return nntpReturn.fSetOK();
	}

	//
	// Says to return an error if the article doesn't have an newsgroups to post to.
	//

	NRC nrcNoGroups(void) {
			return nrcArticleNoSuchGroups;
			};

	//
	// The return code for accepting an article
	//

	NRC	nrcArticleAccepted(BOOL	fStandardPath) {
			return nrcArticleTransferredOK;
			};

	//
	// The return code for rejecting an article.
	//

	NRC	nrcArticleRejected(BOOL	fStandardPath) {
			return nrcTransferFailedGiveUp;
			};

	virtual void SortNameRefList( CNAMEREFLIST &namereflist ) {
	    namereflist.Sort( comparenamerefs );
	}

private:

    static int __cdecl comparenamerefs( const void *pvNameRef1, const void *pvNameRef2 ) {
        LPVOID pvKey1 = ((NAME_AND_ARTREF*)pvNameRef1)->artref.m_compareKey;
        LPVOID pvKey2 = ((NAME_AND_ARTREF*)pvNameRef2)->artref.m_compareKey;

        if ( pvKey1 < pvKey2 )
            return -1;
        else if ( pvKey1 == pvKey2 )
            return 0;
        else return 1;
    }

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\nntp\core\include\frmstore.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    fromclnt.h

Abstract:

    This module contains class declarations/definitions for

		CFromStoreFeed

		CFromStoreArticle

		CFromStoreDateField
		CFromStoreExpiresField
        CControlField
		CFromStoreFromField
		CFromStoreMessageIDField
		CFromStoreSubjectField
		CFromStoreNNTPPostingHostField
		CFromStorePathField
		CFromStoreXrefField
		CFromStoreFollowupToField
		CFromStoreReplyToField
		CFromStoreApprovedField
		CFromStoreSenderField
		CFromStoreXAuthLoginNameField
		CFromStoreOrganizationField
		CFromStoreSummaryField
		CFromStoreNewsgroupsField
		CFromStoreReferencesField
		CFromStoreLinesField
		CFromStoreDistributionField
		CFromStoreKeywordsField


    **** Overview ****

	This derives classes from CInFeed, CArticle, and CField
	that will be used to process articles from clients. Mostly,
	it just defines various CField-derived objects.

Author:

    Carl Kadie (CarlK)     05-Dec-1995

Revision History:


--*/

#ifndef	_FROMSTORE_H_
#define	_FROMSTORE_H_

//
//!!!CLIENT LATER - note: not supported yet: control messages
//!!!CLIENT LATER - note: not supported yet: length check (from peer or client)
//!!!CLIENT LATER - note: not supported yet:  character set check
//!!!CLIENT LATER - note: not supported yet: signiture check
//!!!CLIENT NEXT - need both uupc hub name (in lower case) for path and xref *and* local-machine domain name for message-id
//!!!CLIENT NEXT - are dups allowed of any fields?
//!!!CLIENT LATER - reorder lines on output to put more important lines (like message-id) first
//


//
// Forward defintion
//

class	CFromStoreArticle;

//
// Tells how to process the Date field in articles from the clients
//

class CFromStoreDateField : public CDateField {
public:

	//
	// There should only be one such field in articles from clients.
	//

	BOOL fFind(
			CArticleCore & article,
			CNntpReturn & nntpReturn)
		{
			return fFindOneOrNone(article, nntpReturn);
		};

	//
	// The field should be strictly parsed.
	//

	BOOL fParse(
		    CArticleCore & article, 
			CNntpReturn & nntpReturn)
		{
			return fStrictDateParse(m_pc, FALSE, nntpReturn);
		};

	//
	// How to set the field.
	//

	BOOL fSet(
			CFromStoreArticle & article,
			CNntpReturn & nntpReturn
			);
};

//
// Tells how to process the Expires field in articles from the clients
//

class CFromStoreExpiresField : public CExpiresField {
public:

	//
	// There should only be one such field in articles from clients.
	//

	BOOL fFind(
			CArticleCore & article,
			CNntpReturn & nntpReturn)
		{
			return fFindOneOrNone(article, nntpReturn);
		};

	//
	// The field should be strictly parsed.
	//

	BOOL fParse(
		    CArticleCore & article, 
			CNntpReturn & nntpReturn)
		{
			// if this is not a strict RFC 822 date, check if it is a proper relative date
			if(!fStrictDateParse(m_pc, TRUE, nntpReturn))
				return fRelativeDateParse(m_pc, TRUE, nntpReturn);
			return TRUE;
		};

};

/*
 This header line, if presented, has the same format as "From".  Same set of test cases would apply.  Besides, Tigris server should use this header line to reply to poster/sender, if presented.  This test case should be handled by Server State Integrity Test.
 */
//
// Tells how to process the From field in articles from the clients
//

class CFromStoreFromField : public CFromField {
public:

//
// commenting out becuase this code doesn't allow messages that meet
// rfc1468 to be parsed.  we want to just use the default.
//
#if 0
	//
	// The field should be strictly parsed.
	//

	BOOL fParse(
	        CArticleCore & article, 
			CNntpReturn & nntpReturn)
		{
			return fSimpleFromParse(m_pc, FALSE, nntpReturn);
		};
#endif

};

//
// Tells how to process the MessageID field in articles from the clients
//

class CFromStoreMessageIDField : public CMessageIDField {
public:

	//
	// How to set the field.
	//

	BOOL fSet(
			CFromStoreArticle & article,
			CPCString & pcHub,
			CNntpReturn & nntpReturn
			);

	//
	// There should only be one such field in articles from clients.
	//
	BOOL fFind(
			CArticleCore & article,
			CNntpReturn & nntpReturn)
		{
			return fFindOneOrNone(article, nntpReturn);
		};


};

//
// Tells how to process the Subject field in articles from the clients
//

class CFromStoreSubjectField : public CSubjectField {
public:

	//
	// Parse with ParseSimple
	//

	BOOL fParse(
		    CArticleCore & article, 
			CNntpReturn & nntpReturn)
		{
			return fParseSimple(TRUE, m_pc, nntpReturn);
		};

	friend CArticleCore;
	friend CArticle;

};




//
// Tells how to process the NNTPPostingHost field in articles from the clients
//

class CFromStoreNNTPPostingHostField : public CNNTPPostingHostField {
public:

	//
	//	NNTP-Posting-Host field should NOT be present in clients
	//
	BOOL fFind(
			CArticleCore & article,
			CNntpReturn & nntpReturn)
		{
			return fFindNone(article, nntpReturn);
		};

	//
	// How to set the field.
	//

	BOOL fSet(
			CFromStoreArticle & article,
			DWORD remoteIpAddress,
			CNntpReturn & nntpReturn
			);
};

//
// Tells how to process the Path field in articles from the clients
//

class CFromStorePathField : public CPathField {
public:


	//
	//	Path field need not be present from clients
	//
	BOOL fFind(
			CArticleCore & article,
			CNntpReturn & nntpReturn)
		{
			return fFindOneOrNone(article, nntpReturn);
		};

	//
	// How to set the field.
	//
	
	BOOL fSet(
			CFromStoreArticle & article,
			CPCString & pcHub, CNntpReturn & nntpReturn
			);
};

//
// Tells how to process the Xref field in articles from the clients
//
// Just use the defaults.
//

class CFromStoreXrefField : public CXrefField {
public:
};


//
// Tells how to process the FollowupTo field in articles from the clients
//

class CFromStoreFollowupToField : public CFollowupToField {

public:

	//
	// Constructor
	//

	CFromStoreFollowupToField():
			m_multiSzFollowupTo(NULL),
			m_cFollowupTo((DWORD) -1),
			m_pAllocator(NULL)
			{};

	//
	// Destructor
	//


	virtual ~CFromStoreFollowupToField(void){
				if (fsParsed == m_fieldState)
				{
					_ASSERT(m_pAllocator);
					m_pAllocator->Free(m_multiSzFollowupTo);
				}
			};


	//
	// There should only be one such field in articles from clients.
	//

	BOOL fFind(
			CArticleCore & article,
			CNntpReturn & nntpReturn)
		{
			return fFindOneOrNone(article, nntpReturn);
		};

	//
	// Parse strictly
	//

	BOOL fParse(
		   CArticleCore & article,
			CNntpReturn & nntpReturn)
		{
			//
			// Record the allocator
			//

			m_pAllocator = article.pAllocator();

			return fStrictNewsgroupsParse(TRUE, m_multiSzFollowupTo, 
						m_cFollowupTo, article, nntpReturn);
		};

private:

	//
	// Points to a list of path items to follow up to
	//

	char * m_multiSzFollowupTo;

	//
	// The number of path items in the FollowupTo value.
	//

	DWORD m_cFollowupTo;

	//
	// Where to allocate from
	//

	CAllocator * m_pAllocator;


};


/*
 This header line, if presented, has the same format as "From".
 */
//
// Tells how to process the ReplyTo field in articles from the clients
//

class CFromStoreReplyToField : public CReplyToField {
public:

	//
	// There should only be one such field in articles from clients.
	//

	BOOL fFind(
			CArticleCore & article,
			CNntpReturn & nntpReturn)
		{
			return fFindOneOrNone(article, nntpReturn);
		};

	//
	// The field should be strictly parsed.
	//

	BOOL fParse(
		    CArticleCore & article, 
			CNntpReturn & nntpReturn)
		{
			return fStrictFromParse(m_pc, TRUE, nntpReturn);
		};

};

//
// Tells how to process the Approved field in articles from the clients
//

class CFromStoreApprovedField : public CApprovedField {
public:

	//
	// There should only be one such field in articles from clients.
	//

	BOOL fFind(
			CArticleCore & article,
			CNntpReturn & nntpReturn)
		{
			return fFindOneOrNone(article, nntpReturn);
		};

	//
	// Parse with ParseSimple
	//

	BOOL fParse(
		    CArticleCore & article, 
			CNntpReturn & nntpReturn)
		{
			return fParseSimple(FALSE, m_pc, nntpReturn);
		};
};

/* This header line, if presented, has the format as "From" and "Reply-To".  It is presented only if the poster/sender manually enters "From" header line. */
//
// Tells how to process the Sender field in articles from the clients
//

class CFromStoreSenderField	: public CSenderField {
public:

	//
	// There should only be one such field in articles from clients.
	//

	BOOL fFind(
			CArticleCore & article,
			CNntpReturn & nntpReturn)
		{
			return fFindOneOrNone(article, nntpReturn);
		};

	//
	// The field should be strictly parsed.
	//

	BOOL fParse(
		    CArticleCore & article, 
			CNntpReturn & nntpReturn)
		{
			return fStrictFromParse(m_pc, TRUE, nntpReturn);
		};
};


//
// Tells how to process the XAuthLoginName field in articles from the clients
//

class CFromStoreXAuthLoginNameField	: public CXAuthLoginNameField {
public:

	//
	// How to set the field.
	//
	
	BOOL fSet(
			CFromStoreArticle & article,
			CNntpReturn & nntpReturn
			);
};

//
// Tells how to process the Organization field in articles from the clients
//

class CFromStoreOrganizationField : public COrganizationField {
public:

	//
	// There should only be one such field in articles from clients.
	//

	BOOL fFind(
			CArticleCore & article,
			CNntpReturn & nntpReturn)
		{
			return fFindOneOrNone(article, nntpReturn);
		};

	//
	// Parse with ParseSimple
	//

	BOOL fParse(
		    CArticleCore & article, 
			CNntpReturn & nntpReturn)
		{
			return fParseSimple(TRUE, m_pc, nntpReturn);
		};

	//
	// How to set the field.
	//
	
	BOOL fSet(
			CFromStoreArticle & article,
			CNntpReturn & nntpReturn
			);
};

//
// Tells how to process the Summary field in articles from the clients
//

class CFromStoreSummaryField : public CSummaryField {
public:

	//
	// There should only be one such field in articles from clients.
	//

	BOOL fFind(
			CArticleCore & article,
			CNntpReturn & nntpReturn)
		{
			return fFindOneOrNone(article, nntpReturn);
		};

	//
	// Parse with ParseSimple
	//

	BOOL fParse(
		    CArticleCore & article, 
			CNntpReturn & nntpReturn)
		{
			return fParseSimple(TRUE, m_pc, nntpReturn);
		};
};

//
// Tells how to process the Newsgroups field in articles from the clients
//

class CFromStoreNewsgroupsField : public CNewsgroupsField {

public:

	//
	// Parse strictly
	//

	BOOL fParse(
					CArticleCore & article,
					CNntpReturn & nntpReturn)
		{
			//
			// Record the allocator
			//

			m_pAllocator = article.pAllocator();

			return fStrictNewsgroupsParse(FALSE, m_multiSzNewsgroups,
							m_cNewsgroups, article, nntpReturn);
		};

	//
	// How to set the field.
	//
	
	BOOL fSet(
			CFromStoreArticle & article,
			CNntpReturn & nntpReturn
			);

};



//
// Tells how to process the References field in articles from the clients
//

class CFromStoreReferencesField : public CReferencesField {
public:

	//
	// Constructor
	//

	CFromStoreReferencesField():
			m_multiSzReferences(NULL),
			m_cReferences((DWORD) -1),
			m_pAllocator(NULL)
			{};

	//
	//   Deconstructor
	//

	virtual ~CFromStoreReferencesField(void){
				if (fsParsed == m_fieldState)
				{
					_ASSERT(m_pAllocator);
					m_pAllocator->Free(m_multiSzReferences);
				}
			};


	//
	// There should only be one such field in articles from clients.
	//

	BOOL fFind(
			CArticleCore & article,
			CNntpReturn & nntpReturn)
		{
			return fFindOneOrNone(article, nntpReturn);
		};

	//
	// How to parse
	//

	BOOL fParse(
	    CArticleCore & article, 
		CNntpReturn & nntpReturn
		);

private:

	//
	// A pointer to a list of the references
	//

	char * m_multiSzReferences;

	//
	// The number of references
	//

	DWORD m_cReferences;

	//
	// Where to allocate from
	//

	CAllocator * m_pAllocator;

};



//
// Tells how to process the Lines field in articles from the clients
//

class CFromStoreLinesField : public CLinesField {
public:


	//
	// How to parse
	//

	BOOL fParse(
		    CArticleCore & article, 
			CNntpReturn & nntpReturn
			);
};

//
// Tells how to process the Distribution field in articles from the clients
//

class CFromStoreDistributionField : public CDistributionField {

public:


	//
	// Parse strictly
	//

	BOOL fParse(
					CArticleCore & article,
					CNntpReturn & nntpReturn);

	//
	// How to set the field.
	//
	
	BOOL fSet(
			CFromStoreArticle & article,
			CNntpReturn & nntpReturn
			);

};


//
// Tells how to process the Keywords field in articles from the clients
//

class CFromStoreKeywordsField : public CKeywordsField {
public:

	//
	// There should only be one such field in articles from clients.
	//

	BOOL fFind(
			CArticleCore & article,
			CNntpReturn & nntpReturn)
		{
			return fFindOneOrNone(article, nntpReturn);
		};

	//
	// Parse with ParseSimple
	//

	BOOL fParse(
		    CArticleCore & article, 
			CNntpReturn & nntpReturn)
		{
			return fParseSimple(TRUE, m_pc, nntpReturn);
		};
};

//
//
//
// CFromStoreArticle - class for manipulating articles from the client.
//

class	CFromStoreArticle  : public CArticleCore {
private :

	// Used for memory allocation
	static	CPool	g_ArticlePool ;

public:

	// Used for memory allocation
	static	BOOL	InitClass() ;
	static	BOOL	TermClass() ;
	void*	operator	new(	size_t	size ) ;
	void	operator	delete( void *pv ) ;

	//
	//   Constructor
    //  Initialization Interface -
    //   The following functions are used to create & destroy newsgroup objects.
    //
    // Lightweight Constructors -
    // These constructors do very simple initialization.  The Init() functions
    // need to be called to get a functional newsgroup.
    //

	CFromStoreArticle(char *pszLoginName = NULL) : CArticleCore()
        {
            m_szLoginName = pszLoginName;
        }

	//
	// Destructor
	//
	virtual ~CFromStoreArticle(void) {}

	//
	// The function for validating articles from Stores
	// Check that required headers are there (Newsgroups, From)
	//  this will mean checking for necessary
	//  headers (Newsgroups, Subject, From, ???).
	//

	BOOL fValidate(
			//CPCString& pcHub,
			//const char * szCommand,
			//class	CInFeed*	pInFeed,
			CNntpReturn & nntpReturn
			);

	//
	// Always returns TRUE
	//

	BOOL fCheckCommandLine(
			char const * szCommand,
			CNntpReturn & nntpr)
		{
			return nntpr.fSetOK(); //!!!FROMMASTER NEXT may want to implement this
		} 

	//
	// Modify the headers.
	// Add MessageID, Organization (if necessary), NNTP-Posting-Host,
	// X-Authenticated-User, Modify path
	//

	BOOL fMungeHeaders(
			 CPCString& pcHub,
			 CPCString& pcDNS,
			 //CNAMEREFLIST & grouplist,
			 DWORD remoteIpAddress,
			 CNntpReturn & nntpr
			 );

	//
	// Return the article's messageid
	//

	const char * szMessageID(void) {
			return m_fieldMessageID.szGet();
			};

    // Return the control message type in the control header of this article
	CONTROL_MESSAGE_TYPE cmGetControlMessage(void) {
			return m_fieldControl.cmGetControlMessage();
			};

	//
	// Return the article's path items
	//

	const char * multiszNewsgroups(void) {
			return m_fieldNewsgroups.multiSzGet();
			};

	//
	// Return number of newsgroups
	//

	DWORD cNewsgroups(void) {
			return m_fieldNewsgroups.cGet();
			};

	//
	// Return the article's path items
	//

	const char * multiszPath(void) {
			return m_fieldPath.multiSzGet();
			};

	//
	// Return number of path items
	//

	DWORD cPath(void) {
			return m_fieldPath.cGet();
			};

#if 0 
	const char*	GetDate( DWORD&	cbDate )	{
			CPCString	string = m_fieldDate.pcGet() ;
			cbDate = string.m_cch ;
			return	string.m_pch ;
	}
#endif

	friend CFromStoreXAuthLoginNameField;

	//
	// For unit testing
	//

	friend int __cdecl main(int argc, char *argv[ ]);

protected :

	//
	// The fields that will be found, parsed, or set
	//

	CFromStoreDateField			m_fieldDate;
	CFromStoreFromField			m_fieldFrom;
	CFromStoreMessageIDField		m_fieldMessageID;
	CFromStoreSubjectField			m_fieldSubject;
	CFromStoreNewsgroupsField		m_fieldNewsgroups;
	CFromStorePathField			m_fieldPath;
	CFromStoreXrefField			m_fieldXref;
	CFromStoreFollowupToField		m_fieldFollowupTo;
	CFromStoreReplyToField			m_fieldReplyTo;
	CFromStoreApprovedField		m_fieldApproved;
	CFromStoreSenderField			m_fieldSender;
	CFromStoreOrganizationField	m_fieldOrganization;
	CFromStoreNNTPPostingHostField	m_fieldNNTPPostingHost;
	CFromStoreXAuthLoginNameField	m_fieldXAuthLoginName;
	CFromStoreSummaryField			m_fieldSummary;
	CFromStoreReferencesField		m_fieldReferences;
	CFromStoreKeywordsField		m_fieldKeyword;
 	CFromStoreDistributionField	m_fieldDistribution;
    CControlField                   m_fieldControl;
 	CFromStoreLinesField			m_fieldLines;
 	CFromStoreExpiresField			m_fieldExpires;
 
	//
	// Open the article's file in Read/Write mode.
	//

	BOOL fReadWrite(void) {
			return FALSE;
			}

	//
	// Check the length of the article body.
	//

	BOOL fCheckBodyLength(
			CNntpReturn & nntpReturn
			);

	//
	// Require that the character following "Field Name:" is a space
	//

	BOOL fCheckFieldFollowCharacter(
			char chCurrent)
		{
			return ' ' == chCurrent;
		}

	//
	// A pointer to the poster's login name.
	//

	char * m_szLoginName;
};


#if 0 // CFromStoreFeed

//
//
//
// CFromStoreFeed - for processing incomming articles from clients.
//

class	CFromStoreFeed:	public CInFeed 	{

//
// Public Members
//

public :

	//
	// Constructor
	//

	CFromStoreFeed(void){};

	//
	// Destructor
	//

	virtual ~CFromStoreFeed(void) {};

	//
	//	Return a string that can be used to log errors indicating
	//	what type of feed was processing the articles etc...
	//
	LPSTR	FeedType()	{
				return	"From Store" ;
				}


	//
	// virtual function that tells if this command is allowed.
	//

	BOOL fIsPostLegal(void) {
			return TRUE;
			};

	//
	// virtual function that tells if this command is allowed.
	//

	BOOL fIsXReplicLegal(void) {
			return FALSE;
			};

	//
	// virtual function that tells if this command is allowed.
	//

	BOOL fIsIHaveLegal(void) {
			return FALSE;
			};

	//
	// function that tells fPost path that we can email moderators !
	//

    BOOL fModeratorChecks(void )    {
            return  TRUE ;
            }

	BOOL	fAcceptPosts( CNntpServerInstanceWrapper *pInstance )	
#ifdef BUGBUG
	{	return	pInstance->FAllowStorePosts() ;	}
#else
	{ return TRUE; }
#endif


	DWORD	cbHardLimit( CNntpServerInstanceWrapper *pInstance )	
#ifdef BUGBUG
	{	return	pInstance->ServerHardLimit() ;	}
#else 
	{ return 1000000000; }
#endif

	DWORD	cbSoftLimit( CNntpServerInstanceWrapper *pInstance )	
#ifdef BUGBUG
	{	return	pInstance->ServerSoftLimit() ;	}	
#else 
	{ return 1000000000; }
#endif

	BOOL	fAllowControlMessages( CNntpServerInstanceWrapper *pInstance )	
#ifdef BUGBUG
	{	return	pInstance->FAllowControlMessages() ;	}
#else
	{ return TRUE; }
#endif

	//
	// static function which handles picking up files from the pickup
	// directory
	//
	static BOOL PickupFile(PVOID pServerInstance, WCHAR *wszFilename);

protected:

	//
	// Function to create an article of type CFromStoreArticle
	//

	CARTPTR pArticleCreate(void) {
			_ASSERT(ifsInitialized == m_feedState);
			return new CFromStoreArticle(m_szLoginName);
			};

	//
	// Records the mesage id in the hash table
	//

	BOOL fRecordMessageIDIfNecc(
			CNntpServerInstanceWrapper * pInstance,
			const char * szMessageID,
			CNntpReturn & nntpReturn
			);

	//
	// The return code for article's with no groups that we have.
	//

	NRC	nrcNoGroups(void) {
			return nrcArticleNoSuchGroups;
			};

	//
	// Return code for accepted articles
	//

	NRC	nrcArticleAccepted(BOOL	fStandardPath) {
			return nrcArticlePostedOK;
			};

	//
	// Return code for rejected articles.
	//

	NRC	nrcArticleRejected(BOOL	fStandardPath) {
			return nrcPostFailed;
			};

};

#endif // #if 0 CFromStoreFeed

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\nntp\core\include\frompeer.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    frompeer.h

Abstract:

    This module contains class declarations/definitions for

		CFromPeerFeed

		CFromPeerArticle

		CFromPeerDateField
		CFromPeerLinesField
		CFromPeerFromField
		CFromPeerMessageIDField
		CFromPeerSubjectField
		CFromPeerNewsgroupsField
		CFromPeerPathField
		CFromPeerXrefField



    **** Overview ****

	This derives classes from CInFeed, CArticle, and CField
	that will be used to process articles from peers. Mostly,
	it just defines various CField-derived objects.

Author:

    Carl Kadie (CarlK)     05-Dec-1995

Revision History:


--*/

#ifndef	_FROMPEER_H_
#define	_FROMPEER_H_

//
// Tells how to process the Date field in articles from the clients
//
// Just use the defaults.
//

class CFromPeerDateField : public CDateField {
};


//
// Tells how to process the Lines field in articles from the clients
//
// Just use the defaults.
//

class CFromPeerLinesField : public CLinesField {
};

//
// Tells how to process the From field in articles from the clients
//
// Just use the defaults.
//

class CFromPeerFromField : public CFromField {
};

//
// Tells how to process the MessageID field in articles from the clients
//
// Just use the defaults.
//

class CFromPeerMessageIDField : public CMessageIDField {
};

//
// Tells how to process the Subject field in articles from the clients
//
// Just use the defaults.
//

class CFromPeerSubjectField : public CSubjectField {
};

//
// Tells how to process the Newsgroups field in articles from the clients
//
// Just use the defaults.
//

class CFromPeerNewsgroupsField : public CNewsgroupsField {
};


//
// Tells how to process the Distribution field in articles from the clients
//
// Just use the defaults.
//

class CFromPeerDistributionField : public CDistributionField {
};

//
// Tells how to process the Path field in articles from the clients
//
// Just use the defaults.
//

class CFromPeerPathField : public CPathField {
};

//
// Tells how to process the Xref field in articles from the clients
//
// Just use the defaults.
//

class CFromPeerXrefField : public CXrefField {
};


//
//
//
// CFromPeerArticle - class for manipulating articles from a peer.
//

class	CFromPeerArticle  : public CArticle {
public:

    CFromPeerArticle(void ) {
        numFromPeerArt++;
    }

    ~CFromPeerArticle(void ) {
        numFromPeerArt--;
    }


	//
	// The function for validating articles from Peers
	//  Required Headers: Newsgroups, From, Date, MessageID, Subject, ???
	//  Check for duplicate message.
	//

	BOOL fValidate(
			CPCString& pcHub,
			const char * szCommand,
			class	CInFeed*	pInFeed,
			CNntpReturn & nntpr
			);

	//
	// Modify the headers.
	// Add path. Remove xref and other unwanted headers.
	//

	BOOL fMungeHeaders(
			 CPCString& pcHub,
			 CPCString& pcDNS,
			 CNAMEREFLIST & namerefgrouplist,
			 DWORD remoteIpAddress,
			 CNntpReturn & nntpReturn,
             PDWORD pdwLinesOffset = NULL
			 );

	//
	// Check the argument to IHave command
	//

	BOOL fCheckCommandLine(
			char const * szCommand,
			CNntpReturn & nntpr)
		{
			return nntpr.fSetOK(); //!!!FROMMASTER LATER may want to implement this
		}

	//
	// Returns the message id of the article if it is available
	//

	const char * szMessageID(void) {
			return m_fieldMessageID.szGet();
			};

    //
    // Return the control message type in the control header of this article
    //
	CONTROL_MESSAGE_TYPE cmGetControlMessage(void) {
			return m_fieldControl.cmGetControlMessage();
			};

    //
	// Returns the article's newsgroups
	//
	const char * multiszNewsgroups(void) {
			return m_fieldNewsgroups.multiSzGet();
			};

	//
	// Returns the number of newsgroups the article will be posted to.
	//
	DWORD cNewsgroups(void) {
			return m_fieldNewsgroups.cGet();
			};

	//
	// Returns the article's distribution
	//
	const char * multiszDistribution(void) {
			return m_fieldDistribution.multiSzGet();
			};

	//
	// Returns the number of distribution the article will be posted to.
	//
	DWORD cDistribution(void) {
			return m_fieldDistribution.cGet();
			};

	//
	// Return the article's path items
	//

	const char * multiszPath(void) {
			return m_fieldPath.multiSzGet();
			};


	//
	// Return number of path items
	//

	DWORD cPath(void) {
			return m_fieldPath.cGet();
			};

#if 0 
	const char*	GetDate( DWORD&	cbDate )	{
			CPCString	string = m_fieldDate.pcGet() ;
			cbDate = string.m_cch ;
			return	string.m_pch ;
	}
#endif

protected :


	//
	// The fields that will be found, parsed, or set
	//

    CControlField               m_fieldControl;
	CFromPeerDateField			m_fieldDate;
	CFromPeerLinesField			m_fieldLines;
	CFromPeerFromField			m_fieldFrom;
	CFromPeerMessageIDField		m_fieldMessageID;
	CFromPeerSubjectField		m_fieldSubject;
	CFromPeerNewsgroupsField	m_fieldNewsgroups;
	CFromPeerDistributionField	m_fieldDistribution;
	CFromPeerPathField			m_fieldPath;
	CFromPeerXrefField			m_fieldXref;

	//
	// The file should be opened in read/write mode
	//

	BOOL fReadWrite(void) {
			return TRUE;
			}

	//
	// Accept any length
	//

	BOOL fCheckBodyLength(
			CNntpReturn & nntpReturn)
		{
			return nntpReturn.fSetOK();
		};

	//
	// The character following "Field Name:" can be anything
	//

	BOOL fCheckFieldFollowCharacter(
			char chCurrent)
		{
			return TRUE;
		}

	//
	// For unit testing
	//

	friend int __cdecl main(int argc, char *argv[ ]);

    //
    // For hash table rebuild
    //

    friend BOOL ParseFile(
					CNewsTreeCore* pTree,
                    PCHAR FileName,
                    GROUPID GroupId,
                    ARTICLEID ArticleId,
                    PFILETIME CreationTime
                    );
};



//
//
//
// CFromPeerFeed - for processing incomming articles from a peer.
//


class	CFromPeerFeed:	public CInFeed 	{

	LPSTR	m_lpstrCurrentGroup ;


//
// Public Members
//

public :

	//
	//	function that preserves the current group string we want to work on in our
	//	MULTI_SZ newsgroup pattern
	//
	inline	void	SetCurrentGroupString(	LPSTR	lpstr )	{	m_lpstrCurrentGroup = lpstr ; }

	//
	//	Get the current group string as set by SetCurrentGroupString
	//
	inline	LPSTR	GetCurrentGroupString(	)	{	return	m_lpstrCurrentGroup ;	}

	//
	//	Return a string that can be used to log errors indicating
	//	what type of feed was processing the articles etc...
	//
	virtual	LPSTR	FeedType()	{
				return	"From Peer" ;
				}

	//
	// function that tells if this command is allowed.
	//

	BOOL fIsPostLegal(void) {
			return FALSE;
			};

	//
	// function that tells if this command is allowed.
	//

	BOOL fIsXReplicLegal(void) {
			return FALSE;
			};

		//
		// function that tells if this command is allowed.
		//

	BOOL fIsIHaveLegal(void) {
			return TRUE;
			};

//
// Private Members
//

protected:

	//
	// Create an article of the correct type.
	//

	CARTPTR pArticleCreate(void){
			return new CFromPeerArticle();
			};

	//
	// Don't need to record the message id because it will be
	// record when the message id field gets parsed.
	//

	BOOL fRecordMessageIDIfNecc(
			CNntpServerInstanceWrapper * pInstance,
			const char * szMessageID,
			CNntpReturn & nntpReturn)
		{
			return nntpReturn.fSetOK();
		}

	//
	// Following is from RFC 977:
	// The server may elect not to post or forward the article if after 
	// further examination of the article it deems it inappropriate to do so. 
	// The 436 or 437 error codes may be returned as appropriate to the situation. 
	// Reasons for such subsequent rejection of an article may include such problems as 
	// inappropriate newsgroups or distributions, disk space limitations, article lengths, 
	// garbled headers, and the like. 	
	//

	NRC	nrcNoGroups(void) {
			return nrcArticleNoSuchGroups;
			};

	//
	// The return code for accepted articles.
	//

	NRC	nrcArticleAccepted(BOOL	fStandardPath) {
			if( fStandardPath ) 
				return nrcArticleTransferredOK;
			else
				return	nrcSTransferredOK ;
			};

	//
	// The return code for rejected articles.
	//

	NRC	nrcArticleRejected(BOOL	fStandardPath) {
			if( fStandardPath ) 
				return nrcTransferFailedGiveUp;
			else
				return	nrcSArticleRejected ;
			};

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\nntp\core\include\fixprop.inl ===
////////////////////////////////////////////////////////
// Inline functions for CFreeInfo's new, delete
inline  void*
CFreeInfo::operator  new(    size_t  size )
{
    _ASSERT( size <= MAX_FREEINFO_SIZE ) ;

	CFreeInfo *ptr;

	ptr = (CFreeInfo*)g_FreeInfoPool.Alloc();
	if ( NULL == ptr )  {// use exchmem
		ptr = (CFreeInfo*)PvAlloc( size );
		if ( ptr ) ptr->m_bFromPool = FALSE;
	} else ptr->m_bFromPool = TRUE;
    return  ptr ;
}

inline  void
CFreeInfo::operator  delete( void*   pv )
{
	CFreeInfo *ptr = (CFreeInfo *)pv;

	if ( ptr->m_bFromPool )
    	g_FreeInfoPool.Free( pv ) ;
	else {
		FreePv( ptr );
	}
}

////////////////////////////////////////////////////////
// Inline functions for CFixPropPersist
inline VOID
CFixPropPersist::Group2Buffer(	IN DATA_BLOCK& dbBuffer,
								IN INNTPPropertyBag* pPropBag,
								IN DWORD dwFlag )
/*++
Routine description:

	Fill in the fixed property block with group property bag's
	values.  "dwFlag" tells me which properties to fill in.

Arguments:

	IN DATA_BLOCK& dbBuffer - Buffer to fill in
	IN INNTPPropertyBag* pPropBag - Property bag of the news group
	IN DWORD dwFlag - Bit mask that tells which properties to fill

Return value:

	TRUE on success, FALSE otherwise
--*/
{
	_ASSERT( pPropBag );
	HRESULT hr;
	DWORD	dwBufferLen;

	if ( ( dwFlag & FIX_PROP_NAME ) != 0 ) {
		dwBufferLen = GROUPNAME_LEN_MAX;
		hr = pPropBag->GetBLOB( 	NEWSGRP_PROP_NAME, 
									(UCHAR*)dbBuffer.szGroupName, 
									&dwBufferLen );
		_ASSERT( SUCCEEDED( hr ) ) ;
	}

	if ( ( dwFlag & FIX_PROP_NAMELEN ) != 0 ) {
		hr = pPropBag->GetDWord( 	NEWSGRP_PROP_NAMELEN, 
									&dbBuffer.dwGroupNameLen );
		_ASSERT( SUCCEEDED( hr ) ) ;
	}

	if ( ( dwFlag & FIX_PROP_GROUPID ) != 0 ) {
		hr = pPropBag->GetDWord(	NEWSGRP_PROP_GROUPID,
									&dbBuffer.dwGroupId );
		_ASSERT( SUCCEEDED( hr ) );
	}

	if ( ( dwFlag & FIX_PROP_LASTARTICLE ) != 0 ) {
		hr = pPropBag->GetDWord( 	NEWSGRP_PROP_LASTARTICLE, 
									&dbBuffer.dwHighWaterMark );
		_ASSERT( SUCCEEDED( hr ) );
	}

	if ( ( dwFlag & FIX_PROP_FIRSTARTICLE ) != 0 ) {
		hr = pPropBag->GetDWord(	NEWSGRP_PROP_FIRSTARTICLE,
									&dbBuffer.dwLowWaterMark );
		_ASSERT( SUCCEEDED( hr ) ) ;
	}

	if ( ( dwFlag & FIX_PROP_ARTICLECOUNT ) != 0 ) {
		hr = pPropBag->GetDWord( 	NEWSGRP_PROP_ARTICLECOUNT,
									&dbBuffer.dwArtCount );
		_ASSERT( SUCCEEDED( hr ) ) ;
	}

	if ( ( dwFlag & FIX_PROP_READONLY ) != 0 ) {
		hr = pPropBag->GetBool(	NEWSGRP_PROP_READONLY,
								&dbBuffer.bReadOnly );
		_ASSERT( SUCCEEDED( hr ) ) ;
	}

	if ( ( dwFlag & FIX_PROP_ISSPECIAL ) != 0 ) {
		hr = pPropBag->GetBool( NEWSGRP_PROP_ISSPECIAL,
								&dbBuffer.bSpecial );
		_ASSERT( SUCCEEDED( hr ) );
	}

	if ( ( dwFlag & FIX_PROP_DATELOW ) != 0 ) {
		hr = pPropBag->GetDWord(	NEWSGRP_PROP_DATELOW,
									&dbBuffer.ftCreateDate.dwLowDateTime );
		_ASSERT( SUCCEEDED( hr ) ) ;
	}

	if ( ( dwFlag & FIX_PROP_DATEHIGH ) != 0 ) {
		hr = pPropBag->GetDWord(	NEWSGRP_PROP_DATEHIGH,
									&dbBuffer.ftCreateDate.dwHighDateTime );
		_ASSERT( SUCCEEDED ( hr ) ) ;
	}
}

inline VOID
CFixPropPersist::Buffer2Group(	IN DATA_BLOCK& dbBuffer,
								IN INNTPPropertyBag* pPropBag,
								IN DWORD dwFlag )
/*++
Routine description:

	Load the properties from buffer into group.

Arguments:

	IN DATA_BLOCK& dbBuffer - Buffer to load property from
	IN INNTPPropertyBag* pPropBag - Property bag of the news group
	IN DWORD dwFlag - Bit mask that tells which properties to load

Return value:

	TRUE on success, FALSE otherwise
--*/
{
	_ASSERT( pPropBag );
	HRESULT hr;

	if ( ( dwFlag & FIX_PROP_NAME ) != 0 ) {
		_ASSERT( 0 ) ;	// not allowed
	}

	if ( ( dwFlag & FIX_PROP_NAMELEN ) != 0 ) {
		_ASSERT( 0 ) ;  // now allowed
	}

	if ( ( dwFlag & FIX_PROP_LASTARTICLE ) != 0 ) {
		hr = pPropBag->PutDWord( 	NEWSGRP_PROP_LASTARTICLE, 
									dbBuffer.dwHighWaterMark );
		_ASSERT( SUCCEEDED( hr ) );
	}

	if ( ( dwFlag & FIX_PROP_FIRSTARTICLE ) != 0 ) {
		hr = pPropBag->PutDWord(	NEWSGRP_PROP_FIRSTARTICLE,
									dbBuffer.dwLowWaterMark );
		_ASSERT( SUCCEEDED( hr ) ) ;
	}

	if ( ( dwFlag & FIX_PROP_GROUPID ) != 0 ) {
		hr = pPropBag->PutDWord( 	NEWSGRP_PROP_GROUPID,
									dbBuffer.dwGroupId );
		_ASSERT( SUCCEEDED( hr ) );
	}

	if ( ( dwFlag & FIX_PROP_ARTICLECOUNT ) != 0 ) {
		hr = pPropBag->PutDWord( 	NEWSGRP_PROP_ARTICLECOUNT,
									dbBuffer.dwArtCount );
		_ASSERT( SUCCEEDED( hr ) ) ;
	}

	if ( ( dwFlag & FIX_PROP_READONLY ) != 0 ) {
		hr = pPropBag->PutBool(	NEWSGRP_PROP_READONLY,
								dbBuffer.bReadOnly );
		_ASSERT( SUCCEEDED( hr ) ) ;
	}

	if ( ( dwFlag & FIX_PROP_ISSPECIAL ) != 0 ) {
		hr = pPropBag->PutBool( NEWSGRP_PROP_ISSPECIAL,
								dbBuffer.bSpecial );
		_ASSERT( SUCCEEDED( hr ) );
	}

	if ( ( dwFlag & FIX_PROP_DATELOW ) != 0 ) {
		hr = pPropBag->PutDWord(	NEWSGRP_PROP_DATELOW,
									dbBuffer.ftCreateDate.dwLowDateTime );
		_ASSERT( SUCCEEDED( hr ) ) ;
	}

	if ( ( dwFlag & FIX_PROP_DATEHIGH ) != 0 ) {
		hr = pPropBag->PutDWord(	NEWSGRP_PROP_DATEHIGH,
									dbBuffer.ftCreateDate.dwHighDateTime );
		_ASSERT( SUCCEEDED ( hr ) ) ;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\nntp\core\include\ihash.h ===
#ifndef	_IHASH_H_
#define	_IHASH_H_

#include <nntpdrv.h>

#ifndef	_HASHMAP_

typedef	void	(* HASH_FAILURE_PFN)(	LPVOID	lpv,
										BOOL	fRecoverable	) ;

#endif

#define     ART_HEAD_SIGNATURE          0xaaaaaaaa
#define     HIST_HEAD_SIGNATURE         0xbbbbbbbb
#define     XOVER_HEAD_SIGNATURE        0xcccccccc

#define     DEF_EXPIRE_INTERVAL         (3 * SEC_PER_WEEK) // 1 week

typedef enum
{
	stFileSystem,
	stJet
} StoreType;

class CStoreId : public STOREID {
	public:
		CStoreId() {
			cLen = 0;
#ifdef DEBUG
			ZeroMemory(pbStoreId, sizeof(pbStoreId));
#endif
		}
};


//
//		Initialize everything so that the NNTP Hash Library may run !
//		Call before anything else is called !!
//
BOOL
InitializeNNTPHashLibrary(DWORD dwCacheSize = 0) ;

//
//		Terminate the NNTP Hash Library
//
BOOL
TermNNTPHashLibrary() ;

//
//  Expose the function we use to compute hash values !!!
//
HASH_VALUE
INNHash(    LPBYTE  Key, 
            DWORD   Length ) ;  

//
//  Helper functions for when building nntpbld statistics !
//
//
DWORD 
GetArticleEntrySize( DWORD MsgIdLen ) ;

DWORD 
GetXoverEntrySize( DWORD VarLen ) ;


//
//	This class specifies the interface to the hash table 
//	which maps NNTP RFC 822 Message Id's to articles on the disk !
//
class	CMsgArtMap	{
public : 
	static CStoreId g_storeidDefault;

	//
	//	Destroy a CMsgArtMap object
	//
	virtual	~CMsgArtMap() = 0 ;

	//
	//	Delete a an entry in the hash table using the MessageID key
	//
	virtual	BOOL
	DeleteMapEntry(	
			LPCSTR	MessageID 
			) = 0 ;

	//
	//	Get all the info we have on a Message ID
	//
	virtual	BOOL
	GetEntryArticleId(
			LPCSTR	MessageID, 
			WORD&	HeaderOffset,
			WORD&	HeaderLength, 
			ARTICLEID&	ArticleId, 
			GROUPID&	GroupId,
			CStoreId	&storeid
			) = 0 ;
	
	//
	//	Initialize the hash table !
	//
	virtual	BOOL
	Initialize(			
			LPSTR	lpstrArticleFile, 
			HASH_FAILURE_PFN	pfn = 0, 
			BOOL	fNoBuffering = FALSE
			) = 0 ;

	//
	//	Insert an entry into the hash table
	//
	virtual	BOOL
	InsertMapEntry(
			LPCSTR		MessageID, 
			WORD		HeaderOffset = 0, 
			WORD		HeaderLength = 0,
			GROUPID		PrimaryGroup = INVALID_GROUPID,
			ARTICLEID	ArticleID = INVALID_ARTICLEID,
			CStoreId	&storeid = g_storeidDefault
			) = 0 ;

	//
	//	Modify an existing entry in the hash ttable
	//
	virtual	BOOL
	SetArticleNumber(
			LPCSTR	MessageID, 
			WORD	HeaderOffset, 
			WORD	HeaderLength, 
			GROUPID	Group, 
			ARTICLEID	AritlceId,
			CStoreId	&storeid = g_storeidDefault
			) = 0 ;

	//
	//	Check to see if a MessageID is present in the system !
	//
	virtual	BOOL
	SearchMapEntry(
			LPCSTR	MessageID
			) = 0 ;

	//
	//	Terminate everything 
	//
	virtual	void
	Shutdown(
			BOOL	fLocksHeld  = FALSE
			) = 0 ;

	//
	//	return the number of entries in the hash table
	//
	virtual	DWORD
	GetEntryCount() = 0 ;

	//
	//	Return TRUE if the table has been successfully initialized 
	//	and all interfaces should be working 
	//
	virtual	BOOL
	IsActive() = 0 ;

	//
	//	This creates an object conforming to this interface !
	//
	static	CMsgArtMap*	
	CreateMsgArtMap(StoreType st=stFileSystem) ;

} ;

#ifndef SEC_PER_WEEK
#define	SEC_PER_WEEK (60*60*24*7)
#endif

//
//	This class specifies the interface to the hash table which 
//	handles storing our history of Message-ID's which have been on 
//	the system!
//
class	CHistory	{
public : 

	//
	//	This function creates the threads which expire
	//	entries out of all the history tables which may 
	//	be created !
	//
	static	BOOL
	StartExpirationThreads(
				DWORD	CrawlerSleepTime = 30 		// Time to sleep between examining 
													// entries in seconds !
				) ;

	//
	//	This function terminates the threads which expire
	//	entries out of all the history tables which may be 
	//	created.
	//
	static	BOOL
	TermExpirationThreads() ;

	//
	//	Destroy the History table
	//
	virtual	~CHistory() = 0 ;

	//
	//	amount of time entries last in the history table
	//
	virtual	DWORD
	ExpireTimeInSec() = 0 ;


	//
	//	Delete a MessageID from this table
	//
	virtual	BOOL
	DeleteMapEntry(	
			LPSTR	MessageID 
			) = 0 ;

	//
	//	Initialize the Hash table
	//
	virtual	BOOL
	Initialize(			
			LPSTR	lpstrArticleFile, 
			BOOL	fCreateExpirationThread = FALSE,
			HASH_FAILURE_PFN	pfn = 0,
			DWORD	ExpireTimeInSec = DEF_EXPIRE_INTERVAL,	// how long entries live !
			DWORD	MaxPagesToCrawl = 4,					// Number of pages to examine
															// each time we run the expire thread !
			BOOL	fNoBuffering = FALSE
			) = 0 ;

	//
	//	Insert an entry into the hash table 
	//
	virtual	BOOL
	InsertMapEntry(
			LPCSTR	MessageID, 
			PFILETIME	BaseTime
			) = 0 ;

	//
	//	Check for the presence of a Message ID in the history table
	//
	virtual	BOOL
	SearchMapEntry(
			LPCSTR	MessageID
			) = 0 ;

	//
	//	Shutdown the hash table
	//
	virtual	void
	Shutdown(
			BOOL	fLocksHeld = FALSE
			) = 0 ;

	//
	//	Return the number of entries in the hash table
	//
	virtual	DWORD
	GetEntryCount() = 0 ;

	//
	//	Is the hash table initialized and functional ? 
	//
	virtual	BOOL
	IsActive() = 0 ;

	//
	//	Return a pointer to an object implementing this interface
	//
	static
	CHistory*	CreateCHistory(StoreType st=stFileSystem) ;
} ;


class	IExtractObject	{
public : 

	virtual	BOOL
	DoExtract(	GROUPID			PrimaryGroup,
				ARTICLEID		PrimaryArticle,
				PGROUP_ENTRY	pGroups,	
				DWORD			cGroups	
				) = 0 ;

} ;

//
//	Define a base class for the object that maintains our iteration state !
//
class	CXoverMapIterator	{
public : 
	virtual	~CXoverMapIterator()	{}
} ;


//
//	Specify the interface used to access data in the XOVER hash table
//
//
class	CXoverMap	{
public : 
	static CStoreId g_storeidDefault;

	//
	//	Destructor is virtual because most work done in a derived class
	//
	virtual
	~CXoverMap() = 0 ;

	//
	//	Create an entry for the primary article
	//
	virtual	BOOL
	CreatePrimaryNovEntry(
			GROUPID		GroupId, 
			ARTICLEID	ArticleId, 
			WORD		HeaderOffset, 
			WORD		HeaderLength, 
			PFILETIME	FileTime, 
			LPCSTR		szMessageId, 
			DWORD		cbMessageId,
			DWORD		cEntries, 
			GROUP_ENTRY	*pEntries,
			DWORD 		cStoreEntries = 0,
			CStoreId	*pStoreIds = NULL,
			BYTE		*rgcCrossposts = NULL		
			) = 0 ;
			

	//
	//	Create a Cross Posting entry that references the 
	//	specified primary entry !
	//
	virtual	BOOL
	CreateXPostNovEntry(
			GROUPID		GroupId, 
			ARTICLEID	ArticleId, 
			WORD		HeaderOffset, 
			WORD		HeaderLength,
			PFILETIME	FileTime,
			GROUPID		PrimaryGroupId, 
			ARTICLEID	PrimaryArticleId
			) = 0 ;

	//
	//	Delete an entry from the hash table!
	//
	virtual	BOOL
	DeleteNovEntry(
			GROUPID		GroupId, 
			ARTICLEID	ArticleId
			) = 0 ;

	//
	//	Get all the information stored about an entry 
	//
	virtual	BOOL
	ExtractNovEntryInfo(
			GROUPID		GroupId, 
			ARTICLEID	ArticleId, 
			BOOL		&fPrimary,
			WORD		&HeaderOffset, 
			WORD		&HeaderLength, 
			PFILETIME	FileTime,
			DWORD		&DataLen,
			PCHAR		MessageId, 
			DWORD 		&cStoreEntries,
			CStoreId	*pStoreIds,
			BYTE		*rgcCrossposts,
			IExtractObject*	pExtract = 0
			) = 0 ;	

	//
	//	Get the primary article and the message-id if necessary
	//
	virtual	BOOL
	GetPrimaryArticle(	
			GROUPID		GroupId, 
			ARTICLEID	ArticleId, 
			GROUPID&	GroupIdPrimary, 
			ARTICLEID&	ArticleIdPrimary, 
			DWORD		cbBuffer, 
			PCHAR		MessageId, 
			DWORD&		DataLen, 
			WORD&		HeaderOffset, 
			WORD&		HeaderLength,
			CStoreId	&storeid
			) = 0 ;

	//
	//	Check to see whether the specified entry exists - 
	//	don't care about its contents !
	//
	virtual	BOOL
	Contains(	
			GROUPID		GroupId, 
			ARTICLEID	ArticleId
			) = 0 ;

	//
	//	Get all the cross-posting information related to an article !
	//
	virtual	BOOL
	GetArticleXPosts(
			GROUPID		GroupId, 
			ARTICLEID	AritlceId, 
			BOOL		PrimaryOnly, 
			PGROUP_ENTRY	GroupList, 
			DWORD		&GroupListSize, 
			DWORD		&NumberOfGroups,
			PBYTE		rgcStoreCrossposts = NULL
			) = 0 ;

	//
	//	Initialize the hash table
	//
	virtual	BOOL
	Initialize(	
			LPSTR		lpstrXoverFile, 
			HASH_FAILURE_PFN	pfnHint = 0,
			BOOL	fNoBuffering = FALSE
			) = 0 ;

	virtual	BOOL
	SearchNovEntry(
			GROUPID		GroupId, 
			ARTICLEID	ArticleId, 
			PCHAR		XoverData, 
			PDWORD		DataLen,
            BOOL        fDeleteOrphans = FALSE
			) = 0 ;

	//
	//	Signal the hash table to shutdown
	//
	virtual	void
	Shutdown( ) = 0 ;

	//
	//	Return the number of entries in the hash table !
	//
	virtual	DWORD
	GetEntryCount() = 0 ;

	//
	//	Returns TRUE if the hash table is successfully 
	//	initialized and ready to do interesting stuff !!!
	//
	virtual	BOOL
	IsActive() = 0 ;

	//
	//	Define the interface for iterating over XOVER entries !
	//
	//	NOTE : This function returns 2 important items independently !
	//	The BOOL return value indicates whether the function
	//	successfully copied the requested data into the users 
	//	buffers.  
	//	pIterator returns the Iterator context to be used in future
	//	calls to GetNextNovEntry().  This can come back as 
	//	NON NULL even if the function returns FALSE.  This should 
	//	only occur if GetLastError() == ERROR_INSUFFICIENT_BUFFER.
	//	if this occurs, allocate larger buffers and call GetNextNovEntry().
	//
	//	If GetLastError() == ERROR_NO_MORE_ITEMS than there is nothing in the hashtable.
	//
	virtual
	BOOL
	GetFirstNovEntry(
				OUT	CXoverMapIterator*	&pIterator,
				OUT	GROUPID&	GroupId,
				OUT ARTICLEID&	ArticleId,
				OUT	BOOL&		fIsPrimary, 
				IN	DWORD		cbBuffer, 
				OUT	PCHAR	MessageId, 
				OUT	CStoreId&	storeid,
				IN	DWORD		cGroupBuffer,
				OUT	GROUP_ENTRY*	pGroupList,
				OUT	DWORD&		cGroups
				) = 0 ;


	//
	//	If this returns FALSE and GetLastError() == ERROR_INSUFFICIENT_BUFFER
	//	then the out buffers were too small to hold the requested items.
	//
	//	if GetLastError() == ERROR_NO_MORE_ITEMS there is nothing left to iterate.
	//	The user should delete the pIterator.
	//
	virtual
	BOOL
	GetNextNovEntry(		
				IN	CXoverMapIterator*	pIterator,
				OUT	GROUPID&	GroupId,
				OUT ARTICLEID&	ArticleId,
				OUT	BOOL&		fIsPrimary,
				IN	DWORD		cbBuffer, 
				OUT	PCHAR	MessageId, 
				OUT	CStoreId&	storeid,
				IN	DWORD		cGroupBuffer,
				OUT	GROUP_ENTRY*	pGroupList,
				OUT	DWORD&		cGroups
				) = 0 ;

	static	
	CXoverMap*	CreateXoverMap(StoreType st=stFileSystem) ;

} ;

// this is the maximum number of crossposts that we could possibly store
// in the xover hash table
#define MAX_NNTPHASH_CROSSPOSTS (4096 / (sizeof(DWORD) + sizeof(DWORD)))

// this is the maximum number of store ids that we could store.  it is
// 256 because we only use a BYTE to keep the count
#define MAX_NNTPHASH_STOREIDS 256

#endif	// _IHASH_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\nntp\core\include\grouplst.inl ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    grouplst.inl

Abstract:

	The inline code for the grouplst object.


Author:

    Carl Kadie (CarlK)     29-Oct-1995

Revision History:

--*/

template<class ITEM>
CGroupList< ITEM >::CGroupList(void	):
   m_cMax(0),
   m_cLast(0),
   m_pAllocator(NULL),
   m_rgpItem(NULL)
{};

template<class ITEM>
BOOL CGroupList<ITEM>::fInit(
		DWORD cMax,
		CAllocator * pAllocator
	)
{
   _ASSERT( cMax );
   m_cMax = cMax;
   m_cLast = 0;
   m_pAllocator = pAllocator;

   // If the list is re-initialized, delete the old list
   if (m_rgpItem && m_pAllocator)
		XDELETE[] m_rgpItem;

   m_rgpItem =  //!!!MEM(ITEM *) (m_pAllocator->Alloc(sizeof(ITEM) * cMax));
	   XNEW ITEM[cMax];

   return (m_rgpItem !=NULL);
};

template<class ITEM>
BOOL CGroupList<ITEM>::fAsBeenInited(void)
{
	return NULL != m_pAllocator;
}


//
// Destructor - the memory allocated for the list is freed.
//

template<class ITEM>
CGroupList<ITEM>::~CGroupList(void){
	if (m_rgpItem && m_pAllocator)
		XDELETE[] m_rgpItem;
		//!!!MEMm_pAllocator->Free((char *) m_rgpItem);
}

//
// Returns the head position
//

template<class ITEM>
POSITION CGroupList<ITEM>::GetHeadPosition()	{
	return (POSITION)(SIZE_T)(m_cLast?m_rgpItem:NULL);
};

template<class ITEM>
BOOL CGroupList<ITEM>::IsEmpty()	{
	return 0 == m_cLast;
};

//
// Remove all the items in the list
//

template<class ITEM>
void CGroupList<ITEM>::RemoveAll(){
	m_cLast = 0;
};

//
// Return the size of the list
//

template<class ITEM>
DWORD CGroupList<ITEM>::GetCount(void){
	return m_cLast;
}


template<class ITEM>
ITEM *
CGroupList<ITEM>::GetNext(
					POSITION & pos
					)
/*++

Routine Description:

	Returns the item at POSITION pos in the list and increments
	pos

Arguments:

	pos -- the current position


Return Value:

	The current item

--*/
{
	ITEM * pItem = (ITEM *) pos;
	ITEM *	pTemp = (ITEM *)pos ;
	pTemp ++ ;
	pos = (POSITION) pTemp ;
	if (pTemp >= m_rgpItem + m_cLast)
		pos = NULL;

	return pItem;
}


template<class ITEM>
ITEM *
CGroupList<ITEM>::GetHead(void)
/*++

Routine Description:

	Returns the first item

Arguments:

	None.


Return Value:

	The first item

--*/
{
	POSITION pos = GetHeadPosition();

	if (pos)
		return Get(pos);
	else
		return (ITEM *) 0;
};

/*++

Routine Description:

	Returns the item at POSITION pos

Arguments:

	pos -- the current position


Return Value:

	The current item

--*/
template<class ITEM>
ITEM *
CGroupList<ITEM>::Get(
					POSITION & pos
					)
{
	return  (ITEM *) pos;
}

/*++

Routine Description:

	Remove the item at POSITION pos

Arguments:

	pos -- the current position


Return Value:

	The current item

--*/
template<class ITEM>
void CGroupList<ITEM>::Remove(
					POSITION & pos
					)
{
	ITEM *	pTemp = (ITEM *)pos ;
	if (pTemp==NULL||m_cLast==0)
		return;
	pTemp++;
	while (pTemp<m_rgpItem + m_cLast)
	{
		*(pTemp-1) = *pTemp;
		pTemp++;
	}
	m_cLast--;
}
		
/*++

Routine Description:

	Adds an item to the tail of the list.

Arguments:

	item -- the item to add


Return Value:

	The position of the new last item.

--*/
template<class ITEM>
POSITION
CGroupList<ITEM>::AddTail(
    	ITEM & item
		)
{
	if (m_cLast >= m_cMax)
		return (POSITION) NULL;

	m_rgpItem[m_cLast++] = item;
	return (POSITION) &(m_rgpItem[m_cLast]);
}

template<class ITEM>
void
CGroupList<ITEM>::Sort(int (__cdecl *fncmp)(const void *, const void *)) {
	qsort(m_rgpItem, m_cLast, sizeof(ITEM), fncmp);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\nntp\core\include\isrpcexp.h ===
//
//  Dll initialization and termination
//

#ifndef dllexp
#define dllexp __declspec( dllexport )
#endif

dllexp
BOOL
InitializeServiceRpc(
				IN LPCSTR        pszServiceName,
                IN RPC_IF_HANDLE hRpcInterface
                );

dllexp
BOOL
CleanupServiceRpc(
               VOID
               );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\nntp\core\include\instwpex.h ===
#ifndef __INSTWPEX_H__
#define __INSTWPEX_H__
//
// This class wraps up the important stuff in PNNTP_SERVER_INSTANCE for
// use by the newstree
//

class CNewsGroupCore;

class CNntpServerInstanceWrapperEx {
    public:
        virtual void AdjustWatermarkIfNec( CNewsGroupCore *pGroup ) = 0;
        virtual void SetWin32Error( LPSTR szVRootPath, DWORD dwErr ) = 0;
        virtual PCHAR PeerTempDirectory() = 0 ;
        virtual BOOL EnqueueRmgroup( CNewsGroupCore *pGroup ) = 0;
        virtual DWORD GetInstanceId() = 0;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\nntp\core\include\instwrap.h ===
#ifndef __INSTWRAP_H__
#define __INSTWRAP_H__
//
// This class wraps up the important stuff in PNNTP_SERVER_INSTANCE for
// use by the posting path
//

class CMsgArtMap;
class CHistory;
class CXoverMap;
class CNewsTreeCore;

#include "nntpret.h"
#include "seo.h"

class CNntpServerInstanceWrapper {
	public:
		virtual BOOL AllowClientPosts() = 0;
		virtual BOOL AllowControlMessages() = 0;
		virtual DWORD FeedHardLimit() = 0;
		virtual DWORD FeedSoftLimit() = 0;
		virtual DWORD ServerHardLimit() = 0;
		virtual DWORD ServerSoftLimit() = 0;
		virtual void EnterRPCCritSec() = 0;
		virtual void LeaveRPCCritSet() = 0;
		virtual void EnterNewsgroupCritSec() = 0;
		virtual void LeaveNewsgroupCritSec() = 0;
		virtual CMsgArtMap *ArticleTable() = 0;
		virtual CHistory *HistoryTable() = 0;
		virtual CXoverMap *XoverTable() = 0;
		virtual char *NntpHubName() = 0;
		virtual DWORD HubNameSize() = 0;
		virtual char *NntpDNSName() = 0;
		virtual DWORD NntpDNSNameSize() = 0;
		virtual CNewsTreeCore *GetTree() = 0;
		virtual void BumpCounterControlMessagesFailed() = 0;
		virtual void BumpCounterArticlesReceived() = 0;
		virtual void BumpCounterArticlesPosted() = 0;
		virtual void BumpCounterModeratedPostingsSent() = 0;
		virtual void BumpCounterControlMessagesIn() = 0;
		virtual void IncrementFeedCounter(void *feedcompcontext, DWORD nrc) = 0;
		virtual BOOL ExpireArticle(ARTICLEID artid, GROUPID groupid, STOREID *pStoreId, CNntpReturn &nntpreturn, HANDLE hToken, BOOL fMust, BOOL fAnonymous ) = 0;
		virtual BOOL DeletePhysicalArticle(ARTICLEID artid, GROUPID groupid, STOREID *pStoreId, HANDLE hToken, BOOL fAnonymous ) = 0;
		virtual BOOL GetDefaultModerator(LPSTR pszNewsgroup, LPSTR pszDefaultModerator, PDWORD pcbDefaultModerator) = 0;
		virtual BOOL AddArticleToPushFeeds(CNEWSGROUPLIST &newsgroups, CArticleRef artrefFirst, char *multiszPath, CNntpReturn &nntpReturn) = 0;
		virtual BOOL GetSmtpAddress( LPSTR pszAddress, PDWORD pcbAddress ) = 0;
		virtual PCHAR PeerTempDirectory() = 0;
		virtual LPSTR QueryAdminEmail() = 0;
		virtual DWORD QueryAdminEmailLen() = 0;
		virtual DWORD QueryInstanceId() = 0;
		virtual IEventRouter *GetEventRouter() = 0;
		virtual HRESULT CreateMailMsgObject( IMailMsgProperties ** ppv) = 0;
		virtual BOOL MailArticle( CNewsGroupCore *, ARTICLEID, LPSTR ) = 0;
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\nntp\core\include\nntpbld.h ===
#ifndef _NNTPBLD_H_

//
//	Cancel states - redefined for rootscan lib !
//
#define NNTPBLD_CMD_NOCANCEL		0
#define NNTPBLD_CMD_CANCEL_PENDING	1
#define NNTPBLD_CMD_CANCEL			2

#define NNTPBLD_DEGREE_THOROUGH                 0x00000000
#define NNTPBLD_DEGREE_STANDARD                 0x00000001
#define NNTPBLD_DEGREE_MEDIUM                   0x00000010

typedef struct _NNTPBLD_PARAMS
{
	IIS_VROOT_TABLE*	pTable;
	LPSTR				szFile;
	HANDLE				hOutputFile;
	BOOL				fRejectEmpties;
	//BOOL				DeleteIndexFiles;
	DWORD				ReuseIndexFiles;
	LPDWORD 			pdwTotalFiles;
	LPDWORD 			pdwCancelState;
	LPSTR				szErrString;
	
} NNTPBLD_PARAMS, *PNNTPBLD_PARAMS;

BOOL
ScanRoot(	
    PVOID          pvContext,
    MB *           pmb,
    VIRTUAL_ROOT * pvr
    );

#endif	// _NNTPBLD_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\nntp\core\include\nntpbag.h ===
// NNTPPropertyBag.h : Declaration of the CNNTPPropertyBag

#ifndef __NNTPPROPERTYBAG_H_
#define __NNTPPROPERTYBAG_H_

#include "nntpdrv.h"
#include <propbag.h>

#define MAX_GROUP_PROPERTIES 64

/////////////////////////////////////////////////////////////////////////////
// Bag ID Definitions:  
// 
// Properties on the newsgroup object
#define NEWSGRP_PROP_NATIVENAME         0x00000001
#define NEWSGRP_PROP_NAME               0x00000002
#define NEWSGRP_PROP_GROUPID            0x00000004
#define NEWSGRP_PROP_LASTARTICLE        0x00000008
#define NEWSGRP_PROP_FIRSTARTICLE       0x00000010
#define NEWSGRP_PROP_ARTICLECOUNT       0x00000020
#define NEWSGRP_PROP_READONLY           0x00000040
#define NEWSGRP_PROP_NAMELEN			0x00000080
#define NEWSGRP_PROP_ISSPECIAL			0x00000100
#define NEWSGRP_PROP_DATELOW			0x00000200
#define NEWSGRP_PROP_DATEHIGH			0x00000400
#define NEWSGRP_PROP_PRETTYNAME			0x00002000
#define NEWSGRP_PROP_DESC				0x00004000
#define NEWSGRP_PROP_MODERATOR			0x00008000

// Properties that are in the bag
#define NEWSGRP_PROP_FIXOFFSET			0x80000001

#define FIX_PROP_NAME			0x00000001
#define FIX_PROP_GROUPID		0x00000002
#define FIX_PROP_LASTARTICLE	0x00000004
#define FIX_PROP_FIRSTARTICLE	0x00000008
#define FIX_PROP_ARTICLECOUNT	0x00000010
#define FIX_PROP_READONLY		0x00000020
#define FIX_PROP_NAMELEN		0x00000040
#define FIX_PROP_ISSPECIAL		0x00000080
#define FIX_PROP_DATELOW		0x00000100
#define FIX_PROP_DATEHIGH		0x00000200
#define FIX_PROP_FIXOFFSET		0x00000400

#define DRIVER_OWNED_MASK	0x80000000

#define DRIVER_OWNED( propid ) (( DRIVER_OWNED_MASK & propid ) != 0 )

class CNewsGroupCore;

/////////////////////////////////////////////////////////////////////////////
// CNNTPPropertyBag
class CNNTPPropertyBag :   public INNTPPropertyBag
{
	enum STRING_COMP_RESULTS {
		SAME = 0,
		DIFFER_IN_CASE,
		DIFFER 
	};

private:
    //
    // Pointer to the newsgroup object
    //
    CNewsGroupCore* m_pParentGroup;

    //
    // Reference counting.  we use our parent objects reference count, so
	// that it won't get deleted out from under us.
    //
    LONG   *m_pcRef;

	// 
	// The property bag for driver related properties
	//
    CPropBag m_PropBag;

	//
	// Have any properties changed?
	// 
	BOOL	m_fPropChanges;

	//
	// Static utility functions
	//
	static STRING_COMP_RESULTS ComplexStringCompare( LPCSTR sz1, LPCSTR sz2, DWORD dwLen );

public:
    //
    // Constructors
    //
    CNNTPPropertyBag( CNewsGroupCore* pParent = NULL , LONG *pcRef = NULL) 
    {
        m_pParentGroup = pParent;
		if (pParent != NULL) {
			_ASSERT(pcRef != NULL);
			m_pcRef = pcRef;
		}
		m_pcRef = NULL;
		m_fPropChanges = FALSE;
    }

    //
    // Initialization function
    //
    VOID Init( CNewsGroupCore* pParent, LONG *pcRef  ) {
        m_pParentGroup = pParent;
		_ASSERT(pcRef != NULL);
		m_pcRef = pcRef;
    }

	CNewsGroupCore *GetGroup() { return m_pParentGroup; }

// INNTPPropertyBag
public:
    STDMETHOD(Validate)();
	STDMETHOD(RemoveProperty)(IN DWORD dwID);
    STDMETHOD(GetBool)(IN DWORD dwID, OUT PBOOL pfValue );
    STDMETHOD(PutBool)(IN DWORD dwID, IN BOOL fValue );
	STDMETHOD(GetInterface)(IN DWORD dwID, IN OUT IUnknown** ppunkValue);
	STDMETHOD(PutInterface)(IN DWORD dwID, IN IUnknown* punkValue);
	STDMETHOD(GetDWord)(IN DWORD dwID, OUT PDWORD pdwValue);
	STDMETHOD(PutDWord)(IN DWORD dwID, IN DWORD dwValue);
	STDMETHOD(GetBLOB)(IN DWORD dwID, OUT PBYTE pbValue, OUT PDWORD pcbValue);
	STDMETHOD(PutBLOB)(IN DWORD dwID,  IN DWORD cbValue, IN PBYTE pbValue);

    //
    // Implementation of IUnknown
    //
    HRESULT __stdcall QueryInterface( const IID& iid, VOID** ppv )
    {
		_ASSERT(m_pcRef != NULL);
        if ( iid == IID_IUnknown ) {
            *ppv = static_cast<INNTPPropertyBag*>(this);
        } else if ( iid == IID_INNTPPropertyBag ) {
            *ppv = static_cast<INNTPPropertyBag*>(this);
        } else {
            *ppv = NULL;
            return E_NOINTERFACE;
        }
        reinterpret_cast<IUnknown*>(*ppv)->AddRef();
        return S_OK;
    }

    ULONG __stdcall AddRef()
    {
		_ASSERT(m_pcRef != NULL);
        return InterlockedIncrement( m_pcRef );
    }

    ULONG __stdcall Release();
};

#endif //__NNTPPROPERTYBAG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\nntp\core\include\infeed.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    infeed.h

Abstract:

    This module contains class declarations/definitions for

		CInFeed

    **** Overview ****

	A CInFeed object accepts articles, processes them using CArticle,
	and then posts them to the newstree.


Author:

    Carl Kadie (CarlK)     25-Oct-1995

Revision History:


--*/


#ifndef	_INFEED_H_
#define	_INFEED_H_

#include	"grouplst.h"
#include	"artcore.h"
#include	"article.h"

extern       BOOL    gHonorClientMessageIDs;
extern       BOOL    gHonorApprovedHeaders;
extern       BOOL    gEnableNntpPostingHost;
extern       BOOL    gHonorClientDateHeader;

//
// CPool Signature
//

#define FEED_SIGNATURE (DWORD)'3702'

//
// Defines the longest login name a user can have.
//

const DWORD cMaxLoginName = MAX_PATH; //!!!CLIENT NEXT what is the longest allowed?


//
// Define the type of smart pointers to newsgroup objects.
//
class CPostContext;

//
// the CGroupList holds an array of these objects.  the array has a
// group pointer and the store driver for that pointer for each of the
// groups that we are crossposting to.
//
class CPostGroupPtr {
	public:
		CPostGroupPtr(CGRPCOREPTR pGroup = NULL) : m_pGroup(pGroup) {
			if (m_pGroup != NULL) {
				// this does an AddRef for us
				m_pVRoot = pGroup->GetVRoot();
				m_pStoreDriver = m_pVRoot->GetStoreDriver();
				_ASSERT(m_pVRoot != NULL);
			} else {
				m_pVRoot = NULL;
				m_pStoreDriver = NULL;
			}
		}

		CPostGroupPtr &operator=(CPostGroupPtr &rhs) {
			CNNTPVRoot *pTempRoot = m_pVRoot;
			IMailMsgStoreDriver *pTempDriver = m_pStoreDriver;
			m_pGroup = rhs.m_pGroup;
			m_pVRoot = rhs.m_pVRoot;
			m_pStoreDriver = rhs.m_pStoreDriver;
			if (m_pVRoot) m_pVRoot->AddRef();
			if (m_pStoreDriver) m_pStoreDriver->AddRef();
			if (pTempRoot) pTempRoot->Release();
			if (pTempDriver) pTempDriver->Release();
			return *this;
		}

		~CPostGroupPtr() {
		    Cleanup();
		}

		void Cleanup() {
		    if ( m_pVRoot ) {
		        m_pVRoot->Release();
		        m_pVRoot = NULL;
		    }
		    if ( m_pStoreDriver ) {
		        m_pStoreDriver->Release();
		        m_pStoreDriver = NULL;
		    }

		    //
		    // don't worry about m_pGroup, he is a smart pointer
		    //
		}

		IMailMsgStoreDriver *GetStoreDriver() {
		    if ( m_pStoreDriver ) {
    			m_pStoreDriver->AddRef();
    	    }
			return m_pStoreDriver;
		}

		CGRPCOREPTR	m_pGroup;
		IMailMsgStoreDriver *m_pStoreDriver;
		CNNTPVRoot *m_pVRoot;
};

typedef CGroupList< CPostGroupPtr > CNEWSGROUPLIST;


#include "instwrap.h"


//
//	Utility function - used to save logging information !
//
void	SaveGroupList(	char*	pchGroups,	DWORD	cbGroups,	CNEWSGROUPLIST&	grouplist ) ;

void SelectToken(
	CSecurityCtx *pSecurityCtx,
	CEncryptCtx *pEncryptCtx,
	HANDLE *phToken);

class	CInFeed:	public CFeed 	{

protected :
	//
	// This is the function that creates an article of the approprate type
	// for this feed.
	//

	virtual CARTPTR pArticleCreate(void) = 0;

	//
	// A multisz containing the newnews pattern
	//

	LPSTR m_multiszNewnewsPattern;

	//
	// True if the newnews feed should automatically create all
	// newsgroups available on the peer server.
	//

	BOOL m_fCreateAutomatically;

    //
    // newnews time/date
    //

    CHAR m_newNewsTime[7];
    CHAR m_newNewsDate[7];

	//
	// The directory into which articles should be placed pending
	// processing.
	//

	LPSTR m_szTempDirectory;

	//
	// The size of the gap in the file before the article for incomming articles.
	//

	DWORD	m_cInitialBytesGapSize;

	//
	//	Should we do impersonations etc... when articles arrive on this
	//	feed ?
	//

	BOOL	m_fDoSecurityChecks ;

	//
	//	Should we apply control messages that arrive on this feed ?
	//

	BOOL	m_fAllowControlMessages ;

	//
	//	A Timestamp computed when the feed is started that is used
	//	so pull feeds can get appropriate overlap of pull times !
	//

	FILETIME	m_NextTime ;

	//
	// the feed ID from the feedmgr
	//
	DWORD		m_dwFeedId;

	// Is this an accept feed from slave/peer?
	BOOL	m_fAcceptFeedFromSlavePeer;


	// the list of groups we accepts from this client. only assigned in an accept feed
	// there could be multiple feed block from one server, this multisz contains all of them
	LPSTR m_multiszAcceptGroups;

//
// Public Members
//

public :


	//
	// Constructor
	//

	CInFeed(void) : m_cInitialBytesGapSize( 0 ),
					m_fDoSecurityChecks( FALSE ),
					m_multiszAcceptGroups( NULL ),
					m_fAcceptFeedFromSlavePeer( FALSE )
	       {
				m_szLoginName[cMaxLoginName-1] = '\0';
				ZeroMemory( &m_NextTime, sizeof( m_NextTime ) ) ;
			};


	//
	// Destructor
	//

	virtual ~CInFeed(void) {if (m_multiszAcceptGroups) {XDELETE m_multiszAcceptGroups;}};


	//
	// This will generally be called by a session.
	// FeedTypes are: FromClient, FromMaster, FromSlave, FromPeer
	// UserID is only for FromClient
	//

	//
	// This is called by a session. All but one of the CFeed's
	// will be NULL. The domain name and security information can be
	// retrieved from the socket. Internally this calls
	// feedman's fInitPassiveInFeed to find the type.
	//
	// OR
	// This will generally be called by the feedman for active infeeds
	//

	BOOL fInit(
			PVOID feedCompletionContext,
			const char * szTempDirectory,
			const char * multiszNewnewsPattern,
			DWORD cInitialBytesGapSize,
			BOOL fCreateAutomatically,
			BOOL fDoSecurityCheck,
			BOOL fAllowControlMessages,
			DWORD dwFeedId,
			BOOL fAcceptFeedFromSlavePeer = FALSE
			);


	//
	// Access function that tells the pattern for newnews queries
	//

	char *	multiszNewnewsPattern(void)	{
			return	m_multiszNewnewsPattern;
			}

	//
	// Function that tells session where to put incoming articles
	//

	char *	szTempDirectory(void);

		//
	// Access function that tells if newsgroups should be created automatically
	// if the newnews host has them.
	//

	BOOL	fCreateAutomatically()		{
			return	m_fCreateAutomatically;
			}

	//
	//	Save a time stamp
	//
	void
	SubmitFileTime(	FILETIME&	filetime ) {
		m_NextTime = filetime ;
	}

	//
	//
	//
	FILETIME
	GetSubmittedFileTime() {
		return	m_NextTime ;
	}

	//
	// function that tells session how must of a gap to leave in files.
	//

	DWORD	cInitialBytesGapSize(void);
	//
	// Access function that tells the time of the last newnews, xreplic, ihave, etc
	//

	char * newNewsTime(void) {
			return m_newNewsTime;
			}

	//
	// Access function that tells the date of the last newnews, xreplic, ihave, etc
	//

	char * newNewsDate(void) {
			return m_newNewsDate;
			}

	//
	// Use to set the LoginName of the user
	//

	BOOL SetLoginName(
		   char * szLoginName
		   );

	//
	//	Return a string that can be used to log errors indicating
	//	what type of feed was processing the articles etc...
	//
	LPSTR	FeedType()	{
				return	"Inbound Feed" ;
				}

	DWORD	FeedId() {
				return m_dwFeedId;
	}


	//
	// virtual function that tells if this command is allowed.
	//

	virtual BOOL	fIsPostLegal(void) = 0;

	//
	// virtual function that tells if this command is allowed.
	//

	virtual BOOL	fIsXReplicLegal(void) = 0;

	//
	// virtual function that tells if this command is allowed.
	//

	virtual BOOL	fIsIHaveLegal(void)  = 0;

    //
    // virtual function that tells whether we do moderated stuff - default don't
    //
    virtual BOOL    fModeratorChecks(void )     { return    FALSE ; }

	//
	//	virtual function that tells whether we should be doing
	//	access checks for incoming articles on this feed
	//
	virtual	BOOL	fDoSecurityChecks(void) {	return	m_fDoSecurityChecks ; }

	//
	//	virtual function that tells if this feed accepts posts !
	//
	virtual	BOOL	fAcceptPosts( CNntpServerInstanceWrapper * pInstance )
#ifdef BUGBUG
	{	return	pInstance->FAllowFeedPosts() ;	}
#else
	{	return	TRUE;	}
#endif

	//
	//	virtual function that tells if this feed allows control messages !
	//
	virtual	BOOL	fAllowControlMessages( CNntpServerInstanceWrapper * pInstance )
	{	return	m_fAllowControlMessages ;	}

	//
	//	virtual function that get the feed size limits on posts
	//
	virtual	DWORD	cbHardLimit(  CNntpServerInstanceWrapper * pInstance  )
#ifdef BUGBUG
	{	return	pInstance->FeedHardLimit() ;		}
#else
	{ return 10000000; }
#endif

	virtual	DWORD	cbSoftLimit(  CNntpServerInstanceWrapper * pInstance  )
#ifdef BUGBUG
	{	return	pInstance->FeedSoftLimit() ;		}
#else
	{ return 10000000; }
#endif

	//
	// PostEarly - this is called by the protocol when the headers have been
	// 			   received.
	//
	// arguments:
	//   pInstance - a pointer to the instance wrapper
	//   pSecurityContext - the security context of the client
	//   fAnonymous - is the client anonymous?
	//   szCommandLine - the command line used to generate this post
	//   pbufHeaders - pointer to a CBuffer containing the headers.  the posting
	//                 path will reformat the headers and put them back into
	//                 this buffer.  it also keeps a reference on the buffer.
	//   cbHeaders - the size of pbufHeaders when the call is made
	//   pcbHeadersOut - the size of pbufHeaders when the call is complete
	//   phFile - a returned file handle which the headers and article can be
	//            written
	//   ppvContext - a context pointer for the protocol to give to us when
	//                the rest of the article is received.
	//

	BOOL PostEarly(
		CNntpServerInstanceWrapper			*pInstance,
		CSecurityCtx                        *pSecurityCtx,
		CEncryptCtx                         *pEncryptCtx,
		BOOL								fAnonymous,
		const LPMULTISZ						szCommandLine,
		CBUFPTR								&pbufHeaders,
		DWORD								iHeaderOffset,
		DWORD								cbHeaders,
		DWORD								*piHeadersOutOffset,
		DWORD								*pcbHeadersOut,
		PFIO_CONTEXT						*ppFIOContext,
		void								**ppvContext,
		DWORD								&dwSecondary,
		DWORD								dwRemoteIP,
		CNntpReturn							&nntpreturn,
		char								*pNewsgroups,
		DWORD								cbNewsgroups,
		BOOL								fStandardPath = TRUE,
		BOOL								fPostToStore = TRUE);

	//
	// This is called by the server when the remained of the article has
	// been received.  It passes in the same ppvContext.
	//
	BOOL PostCommit(CNntpServerInstanceWrapper *pInstance,
	                void *pvContext,
	                HANDLE hToken,
	                DWORD &dwSecondary,
	                CNntpReturn &nntpReturn,
					BOOL fAnonymous,
					INntpComplete*	pComplete=0
					);

	//
	// Apply moderator
	//
	void    ApplyModerator( CPostContext   *pContext,
                             CNntpReturn    &nntpReturn );

	// Add a multisz to m_multiszAcceptGroups
	BOOL AddMultiszAcceptGroups(LPSTR multiszAcceptGroups);

	// Check if the input "Newsgroups" header contains a newsgroup that is going to be accepted (comparing against m_multiszAcceptGroups).
	BOOL CheckAcceptGroups (const char *multiszNewsgroups);
	//
	// This is called by the server if the post was aborted for any
	// reason
	//
	BOOL PostCancel(void *pvContext,
					DWORD &dwSecondary,
					CNntpReturn &nntpReturn);

	//
	// This calls down to PostEarly/PostCommit and is used for directory
	// pickup articles and feed articles
	//
	BOOL PostPickup(CNntpServerInstanceWrapper			*pInstance,
					CSecurityCtx                        *pSecurityCtx,
					CEncryptCtx                         *pEncryptCtx,
					BOOL								fAnonymous,
					HANDLE								hArticle,
					DWORD								&dwSecondary,
					CNntpReturn							&nntpreturn,
					BOOL								fPostToStore = TRUE);

	//
	// These are the functions that we give the mail message for binding
	// ATQ, etc
	//
	static BOOL MailMsgAddAsyncHandle(struct _ATQ_CONTEXT_PUBLIC	**ppatqContext,
								 	  PVOID							pEndpointObject,
								 	  PVOID							pClientContext,
								 	  ATQ_COMPLETION 				pfnCompletion,
								 	  DWORD							cTimeout,
								 	  HANDLE						hAsyncIO);

	static void MailMsgFreeContext(struct _ATQ_CONTEXT_PUBLIC		*pAtqContext,
							  	   BOOL								fReuseContext);

	static void MailMsgCompletionFn(PVOID		pContext,
									DWORD		cBytesWritten,
									DWORD		dwComplStatus,
									OVERLAPPED 	*lpo)
	{
		_ASSERT(FALSE);
	}

	//
	//	Log errors that occur processing articles
	//

	void	LogFeedEvent(
			DWORD	idMessage,
			LPSTR	lpstrMessageId,
			DWORD   dwInstanceId
			) ;


	//
	// bump up the counters in the feed block
	//
	virtual void IncrementFeedCounter(CNntpServerInstanceWrapper *pInstance, DWORD nrc) {
		pInstance->IncrementFeedCounter(m_feedCompletionContext, nrc);
	}

    //
    // Cancel an article given the message id
    //
    virtual BOOL fApplyCancelArticle(
			CNntpServerInstanceWrapper * pInstance,
			CSecurityCtx *pSecurityCtx,
			CEncryptCtx *pEncryptCtx,
			BOOL fAnonymous,
            CPCString & pcValue,
			CNntpReturn & nntpReturn
			)
	{
		return fApplyCancelArticleInternal( pInstance, pSecurityCtx, pEncryptCtx, fAnonymous, pcValue, TRUE, nntpReturn );
	}

	virtual void CommitPostToStores(CPostContext *pContext, CNntpServerInstanceWrapper *pInstance);
	BOOL WriteMapEntries(HRESULT hr,
						 CPostContext *pContext,
	                	 DWORD &dwSecondary,
	                	 CNntpReturn &nntpReturn);

protected:

	//
	// Does post of the work of processing an article.
	//

	virtual BOOL fPostInternal (
			CNntpServerInstanceWrapper *  pInstance,
			const LPMULTISZ szCommandLine,
			CSecurityCtx    *pSecurityCtx,
			CEncryptCtx     *pEncryptCtx,
			BOOL fAnonymous,
			CARTPTR	& pArticle,
			CNEWSGROUPLIST &grouplist,
			CNAMEREFLIST &namereflist,
			IMailMsgProperties *pMsg,
			CAllocator & allocator,
			char * & multiszPath,
			char*	pchGroups,
			DWORD	cbGroups,
			DWORD	remoteIpAddress,
			CNntpReturn & nntpReturn,
			PFIO_CONTEXT *ppFIOContext,
			BOOL *pfBoundToStore,
			DWORD* pdwOperations,
			BOOL *pfPostToMod,
			LPSTR   szModerator
			);

	HRESULT FillInMailMsg(IMailMsgProperties *pMsg,
						  CNNTPVRoot *pVRoot,
						  CNEWSGROUPLIST *pGrouplist,
						  CNAMEREFLIST *pNamereflist,
						  HANDLE    hToken,
                          char*     pszApprovedHeader);

	HRESULT SyncCommitPost(CNNTPVRoot *pVRoot,
						   IUnknown *punkMessage,
						   HANDLE hToken,
						   STOREID *pStoreId,
						   BOOL fAnonymous);

	HRESULT FillMailMsg(IMailMsgProperties *pMsg,
                        DWORD *rgArticleIds,
                        INNTPPropertyBag **rgpGroupBags,
                        DWORD cCrossposts,
                        HANDLE hToken,
                        char*     pszApprovedHeader);


    //
    //  Calculate the amount of space available for xover data
    //

    virtual DWORD CalculateXoverAvail(
            CARTPTR & pArticle,
            CPCString& pcHub
			);

	//
	// Given an article, this creats lists of the newsgroups to post to.
	//

	virtual	BOOL fCreateGroupLists(
			CNewsTreeCore* pNewstree,
			CARTPTR & pArticle,
			CNEWSGROUPLIST & grouplist,
			CNAMEREFLIST * pNamereflist,
			LPMULTISZ	multiszCommandLine,
            CPCString& pcHub,
			CNntpReturn & nntpReturn
			);

	//
	// Given an article, this creates the nameref lists
	//

	virtual	BOOL fCreateNamerefLists(
			CARTPTR & pArticle,
			CNEWSGROUPLIST & grouplist,
			CNAMEREFLIST * pNamereflist,
			CNntpReturn & nntpReturn
			);

    //
    // Given an article and a newsgroup list, this checks for moderated attributes
    // and sends the article (via a defined interface - default SMTP) to a moderator
    //
    virtual BOOL    fModeratedCheck(
            CNntpServerInstanceWrapper *pInstance,
            CARTPTR & pArticle,
			CNEWSGROUPLIST & grouplist,
            BOOL fCheckApproved,
			CNntpReturn & nntpReturn,
			LPSTR   szModerator
			);



    //  Following two functions are splitted from fApplyControlMessage().
    //  Used by PostEarly() and CommitPost().
    virtual BOOL    fApplyControlMessageEarly(
            CARTPTR & pArticle,
		    CSecurityCtx *pSecurityCtx,
		    CEncryptCtx *pEncryptCtx,
			BOOL fAnonymous,
		    CNEWSGROUPLIST & grouplist,
			CNAMEREFLIST * pNamereflist,
			CNntpReturn & nntpReturn
			);
    virtual BOOL    fApplyControlMessageCommit(
            CARTPTR & pArticle,
		    CSecurityCtx *pSecurityCtx,
		    CEncryptCtx *pEncryptCtx,
			BOOL fAnonymous,
		    CNEWSGROUPLIST & grouplist,
			CNAMEREFLIST * pNamereflist,
			CNntpReturn & nntpReturn
			);
    //
    //  Adjust the grouplist to include control.* groups only
    //
    virtual BOOL fAdjustGrouplist(
		CNewsTreeCore* pTree,
        CARTPTR & pArticle,
	    CNEWSGROUPLIST & grouplist,
		CNAMEREFLIST * pNamereflist,
		CNntpReturn & nntpReturn
		);

    //
    // Add a new newsgroup in response to a newgroup control message
    //
    virtual BOOL fApplyNewgroup(
			CNntpServerInstanceWrapper * pInstance,
			CSecurityCtx *pSecurityCtx,
			CEncryptCtx *pEncryptCtx,
			BOOL fAnonymous,
            CPCString & pcValue,
            CPCString & pcBody,
			CNntpReturn & nntpReturn
			)
	{
		BOOL fRet ;
		pInstance->EnterNewsgroupCritSec() ;
		fRet = fApplyNewgroupInternal( pInstance, pSecurityCtx, pEncryptCtx, fAnonymous, pcValue, pcBody, TRUE, nntpReturn );
		pInstance->LeaveNewsgroupCritSec();
		return fRet ;
	}

    //
    // Remove a newsgroup in response to a rmgroup control message
    //
    virtual BOOL fApplyRmgroup(
			CNntpServerInstanceWrapper * pInstance,
			CSecurityCtx *pSecurityCtx,
			CEncryptCtx *pEncryptCtx,
            CPCString & pcValue,
			CNntpReturn & nntpReturn
			)
	{
		BOOL fRet ;
		pInstance->EnterNewsgroupCritSec() ;
		fRet = fApplyRmgroupInternal( pInstance, pSecurityCtx, pEncryptCtx, pcValue, TRUE, nntpReturn );
		pInstance->LeaveNewsgroupCritSec() ;
		return fRet ;
	}

    //
    // Cancel an article given the message id - internal
    //
    virtual BOOL fApplyCancelArticleInternal(
			CNntpServerInstanceWrapper * pInstance,
			CSecurityCtx *pSecurityCtx,
			CEncryptCtx *pEncryptCtx,
			BOOL fAnonymous,
            CPCString & pcValue,
			BOOL fApply,					// FALSE for SlaveFromClient feeds, TRUE otherwise
			CNntpReturn & nntpReturn
			);

    //
    // Add a new newsgroup in response to a newgroup control message - internal
    //
    virtual BOOL fApplyNewgroupInternal(
			CNntpServerInstanceWrapper * pInstance,
			CSecurityCtx *pSecurityCtx,
			CEncryptCtx *pEncryptCtx,
			BOOL fAnonymous,
            CPCString & pcValue,
            CPCString & pcBody,
			BOOL fApply,					// FALSE for SlaveFromClient feeds, TRUE otherwise
			CNntpReturn & nntpReturn
			);

    //
    // Remove a newsgroup in response to a rmgroup control message - internal
    //
    virtual BOOL fApplyRmgroupInternal(
			CNntpServerInstanceWrapper * pInstance,
			CSecurityCtx *pSecurityCtx,
			CEncryptCtx *pEncryptCtx,
            CPCString & pcValue,
			BOOL fApply,					// FALSE for SlaveFromClient feeds, TRUE otherwise
			CNntpReturn & nntpReturn
			);

	//
	//	Given a newsgroup list, and a ClientContext, check that the poster has
	//	the necessary access to all of the newsgroups.
	//
	virtual	BOOL	fSecurityCheck(
		    CSecurityCtx *pSecurityCtx,
		    CEncryptCtx *pEncryptCtx,
			CNEWSGROUPLIST&	grouplist,
			CNntpReturn&	nntpReturn
			) ;

	//
	// Move a message id from the Article Table to the History Table
	// (if neccessary)
	//

	BOOL fMoveMessageIDIfNecc(
			CNntpServerInstanceWrapper *	pInstance,
			const char * szMessageID,
			CNntpReturn & nntpReturn,
			HANDLE  hToken,
			BOOL	fAnonymous
			);


    //
	// If it is necessary ot record the message id, this function
	// will do it.
	//

	virtual BOOL fRecordMessageIDIfNecc(
			CNntpServerInstanceWrapper * pInstance,
			const char * szMessageID,
			CNntpReturn & nntpReturn
			) = 0;

	//
	// Tells if it is OK to have none of the groups we carry in the
	// Newsgroups: field.
	//

	virtual NRC		nrcNoGroups(void) = 0;

	//
	// Tells what the return code is for accepting an article.
	//

	virtual NRC		nrcArticleAccepted(BOOL	fStandardPath) = 0;

	//
	// Tells what the return code is for rejecting an article
	//

	virtual NRC		nrcArticleRejected(BOOL	fStandardPath) = 0;

	//
	// sort the group list
	//
	virtual void SortNameRefList( CNAMEREFLIST &namereflist ) {
	    //
	    // For other than from master, we do nothing here
	    //
	}

    //
    // Check to see if a post was made to a moderated group
    //
	BOOL ShouldBeSentToModerator(   CNntpServerInstanceWrapper *pInstance,
                                    CPostContext *pContext );

    //
    // Send the article to the moderator
    //
    BOOL SendToModerator(   CNntpServerInstanceWrapper *pInstance,
                            CPostContext *pContext );

	//
	// The user's login name
	//

	char m_szLoginName[cMaxLoginName];
};

//
// we pass this back to the protocol as our context pointer.
//
#define ARTICLE_BUF_SIZE 8192
class CPostContext : public CRefCount2 {
	public:
		class CPostComplete : public CNntpComplete {
			public:
			    friend class CSlaveFromClientFeed;
				CPostComplete(CInFeed *pInFeed,
							  CPostContext *pContext,
							  INntpComplete *pPostCompletion,
							  BOOL fAnonymous,
							  DWORD &dwSecondary,
							  CNntpReturn &nntpReturn);
				void Destroy();

				// Do i need to write map entries
				BOOL m_fWriteMapEntries;

			private:
				// pointer to the post context which owns us
				CPostContext *m_pContext;

				// pointer to our feed object
				CInFeed *m_pInFeed;

				// the completion object which we will release when
				// everything is done
				INntpComplete *m_pPostCompletion;

				// is this coming through an anonymous client?
				BOOL m_fAnonymous;

				// references to our return code variables
				DWORD &m_dwSecondary;
				CNntpReturn &m_nntpReturn;

			friend CInFeed::PostCommit(CNntpServerInstanceWrapper *, void *, HANDLE, DWORD &, CNntpReturn &, BOOL, INntpComplete*);
		};

		char 							m_rgchBuffer[ARTICLE_BUF_SIZE];
		CHAR                            m_szModerator[MAX_MODERATOR_NAME+1];
		CAllocator						m_allocator;

		class CSecurityCtx				*m_pSecurityContext;
		class CEncryptCtx				*m_pEncryptContext;
		BOOL							m_fAnonymous;
		CNntpServerInstanceWrapper		*m_pInstance;
		CBUFPTR							m_pbufHeaders;
		DWORD							m_cbHeaders;
		PFIO_CONTEXT					m_pFIOContext;
		CARTPTR							m_pArticle;
		CNEWSGROUPLIST					m_grouplist;
		CNAMEREFLIST 					m_namereflist;
		CPostGroupPtr					*m_pPostGroupPtr;
		NAME_AND_ARTREF					*m_pNameref;
		BOOL							m_fStandardPath;
		BOOL							m_fBound;
		char							*m_multiszPath;
		DWORD							m_dwOperations;

		IMailMsgProperties				*m_pMsg;

		CStoreId 						*m_rgStoreIds;
		BYTE 							*m_rgcCrossposts;
		// the number of entries in m_rgStoreIds (so its the count of stores
		// that we've commited against).
		DWORD 							m_cStoreIds;
		// the total number of stores which this message should go into
		DWORD							m_cStores;
		HANDLE							m_hToken;

		POSITION 						m_posGrouplist;
		POSITION						m_posNamereflist;

		// the completion object which we hand off to drivers
		CPostComplete					m_completion;

		// Whether I was posted to a moderated group
		BOOL                            m_fPostToMod;

		CPostContext(
			CInFeed						*pInFeed,
			INntpComplete				*pCompletion,
			CNntpServerInstanceWrapper	*pInstance,
			CSecurityCtx				*pSecurityContext,
			CEncryptCtx					*pEncryptContext,
			BOOL						fAnonymous,
			CBUFPTR						&pbufHeaders,
			DWORD						cbHeaders,
			BOOL						fStandardPath,
			DWORD						&dwSecondary,
			CNntpReturn					&nntpReturn
			) : m_pArticle(NULL),
			  	m_pInstance(pInstance),
				m_pSecurityContext(pSecurityContext),
				m_pEncryptContext(pEncryptContext),
				m_fAnonymous(fAnonymous),
			  	m_pbufHeaders(pbufHeaders),
			  	m_cbHeaders(cbHeaders),
			  	m_pFIOContext(NULL),
			  	m_allocator(m_rgchBuffer, ARTICLE_BUF_SIZE),
				m_pMsg(NULL),
				m_fStandardPath(fStandardPath),
				m_fBound(FALSE),
				m_multiszPath(NULL),
				m_rgStoreIds(NULL),
				m_rgcCrossposts(NULL),

#if _MSC_VER >= 1200
#pragma warning(push)
#endif
#pragma warning(disable:4355)

				m_completion(pInFeed, this, pCompletion, fAnonymous, dwSecondary, nntpReturn),

#if _MSC_VER >= 1200
#pragma warning(pop)
#else
#pragma warning(default:4355)
#endif

				m_pPostGroupPtr(NULL),
				m_pNameref(NULL),
				m_dwOperations(0xffffffff),
				m_fPostToMod( FALSE )
		{
			m_szModerator[0]='\0';
		}

		~CPostContext() {
			if (m_rgStoreIds) {
				m_allocator.Free((char *) m_rgStoreIds);
				m_rgStoreIds = NULL;
			}
			if (m_rgcCrossposts) {
				m_allocator.Free((char *) m_rgcCrossposts);
				m_rgcCrossposts = NULL;
			}
			if (m_multiszPath) {
				m_allocator.Free(m_multiszPath);
				m_multiszPath = NULL;
			}
			CleanupMailMsgObject();
		}

		void CleanupMailMsgObject() {
		    if (m_pMsg) {
				if (m_fBound) {
					IMailMsgQueueMgmt *pQueueMgmt;
					HRESULT hr;
					hr = m_pMsg->QueryInterface(IID_IMailMsgQueueMgmt,
												(void **)&pQueueMgmt);
					if (SUCCEEDED(hr)) {
						pQueueMgmt->ReleaseUsage();
						/// pQueueMgmt->Release();
					}
				}
				m_pMsg->Release();
				m_pMsg = NULL;
			}
	    }
};

//
//	Puts an article in the news tree.
//

BOOL gFeedManfPost(
			CNntpServerInstanceWrapper *pInstance,
			CNEWSGROUPLIST& newsgroups,
			CNAMEREFLIST& namerefgroups,
			class	CSecurityCtx*	pSecurity,
			BOOL	fIsSecureSession,
			CArticle* pArticle,
			CStoreId *rgStoreIds,
			BYTE *rgcCrossposts,
			DWORD cStoreIds,
			const CPCString & pcXOver,
			CNntpReturn & nntpReturn,
			DWORD dwFeedId,
			char *pszMessageId = NULL,
			WORD HeaderLength = 0
			);


//
// Does most of gFeedManfPost's work
//

BOOL gFeedManfPostInternal(
			CNntpServerInstanceWrapper * pInstance,
			CNEWSGROUPLIST& newsgroups,
			CNAMEREFLIST& namerefgroups,
			const CPCString & pcXOver,
			POSITION & pos1,
			POSITION & pos2,
			CGRPCOREPTR * ppGroup,
			NAME_AND_ARTREF * pNameRef,
			CArticleRef * pArtrefFirst,
			const char * szMessageID,
			GROUPID * rgGroupID,
			WORD	HeaderOffset,
			WORD	HeaderLength,
			FILETIME FileTime,
			CNntpReturn & nntpReturn
			);

class CDummyMailMsgPropertyStream : public IMailMsgPropertyStream {
	public:
		CDummyMailMsgPropertyStream() : m_cRef(1) {}

		//
		// Implementation of IMailMsgPropertyStream
		//
		HRESULT __stdcall GetSize(IMailMsgProperties *pMsg, DWORD *pcSize, IMailMsgNotify *pNotify) {
			*pcSize = 0;
			return S_OK;
		}

		HRESULT __stdcall ReadBlocks(IMailMsgProperties *pMsg,
									 DWORD cCount,
									 DWORD *rgiData,
									 DWORD *rgcData,
									 BYTE **rgpbData,
									 IMailMsgNotify *pNotify)
		{
			_ASSERT(FALSE);
			return E_NOTIMPL;
		}

		HRESULT __stdcall WriteBlocks(IMailMsgProperties *pMsg,
									  DWORD cCount,
									  DWORD *rgiData,
									  DWORD *rgcData,
									  BYTE **rgpbData,
									  IMailMsgNotify *pNotify)
		{
			//_ASSERT(FALSE);
			return S_OK;
		}

	    //
	    // Implementation of IUnknown
	    //
	    HRESULT __stdcall QueryInterface( const IID& iid, VOID** ppv )
	    {
	        if ( iid == IID_IUnknown ) {
	            *ppv = static_cast<IUnknown*>(this);
	        } else if ( iid == IID_IMailMsgPropertyStream ) {
	            *ppv = static_cast<IMailMsgPropertyStream*>(this);
	        } else {
	            *ppv = NULL;
	            return E_NOINTERFACE;
	        }
	        reinterpret_cast<IUnknown*>(*ppv)->AddRef();
	        return S_OK;
	    }

	    ULONG __stdcall AddRef()
	    {
	        return InterlockedIncrement( &m_cRef );
	    }

	    ULONG __stdcall Release()
	    {
			ULONG x = InterlockedDecrement(&m_cRef);
	        if (x == 0) XDELETE this;
	        return x;
	    }

        HRESULT __stdcall CancelWriteBlocks(IMailMsgProperties *pMsg) { return S_OK; }
		HRESULT __stdcall StartWriteBlocks(IMailMsgProperties *pMsg, DWORD x, DWORD y) { return S_OK; }
		HRESULT __stdcall EndWriteBlocks(IMailMsgProperties *pMsg) { return S_OK; }

	private:
		long m_cRef;
};

//
// This is the type of a smart pointer to a feed object.
//

#if 0
#ifndef	_NO_TEMPLATES_

typedef CRefPtr< CFeed >  CFEEDPTR ;

#else

DECLARE_TYPE( CFeed )
typedef	class INVOKE_SMARTPTR( CFeed )	CFEEDPTR ;

#endif
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\nntp\core\include\nntptype.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    nntptype.h

Abstract:

    This file contains information about the MSN Replication Service Admin
        APIs.

Author:

    Johnson Apacible (johnsona)         10-Sept-1995

--*/


#ifndef _NNTPTYPE_
#define _NNTPTYPE_

#ifdef __cplusplus
extern "C" {
#endif

typedef DWORD FEED_TYPE;

#define FEED_TYPE_INVALID           0xffffffff

//
// Function types
//
typedef
BOOL
(*GET_DEFAULT_DOMAIN_NAME_FN)(PCHAR,DWORD);

//
// Type of feed we are managing
//

#define FEED_TYPE_PULL              0x00000000
#define FEED_TYPE_PUSH              0x00000001
#define FEED_TYPE_PASSIVE           0x00000002
#define FEED_ACTION_MASK            0x0000000f

//
// Type of server we are talking to
//

#define FEED_TYPE_PEER              0x00000000
#define FEED_TYPE_MASTER            0x00000010
#define FEED_TYPE_SLAVE             0x00000020
#define FEED_REMOTE_MASK            0x000000f0

//
// Should this go through a secure channel like SSL?
//

#define FEED_TYPE_SSL               0x00000100

//
// Valid bits
//

#define FEED_TYPE_MASK              (FEED_TYPE_PULL | FEED_TYPE_PUSH | \
                                    FEED_TYPE_PASSIVE | FEED_TYPE_PEER | \
                                    FEED_TYPE_MASTER | FEED_TYPE_SLAVE | \
                                    FEED_TYPE_SSL)


//
// Macros
//

#define FEED_IS_SSL( _x )           (((_x) & FEED_TYPE_SSL) != 0)
#define FEED_IS_SLAVE( _x )         (((_x) & FEED_TYPE_SLAVE) != 0)
#define FEED_IS_MASTER( _x )        (((_x) & FEED_TYPE_MASTER) != 0)
#define FEED_IS_PEER( _x )          (((_x) & 0x000000f0) == 0)
#define FEED_IS_PULL( _x )          (((_x) & 0x0000000f) == 0)
#define FEED_IS_PUSH( _x )          (((_x) & FEED_TYPE_PUSH) != 0)
#define FEED_IS_PASSIVE( _x )       (((_x) & FEED_TYPE_PASSIVE) != 0)

//
//  Simple types.
//

#define CHAR char                       // For consitency with other typedefs.

typedef DWORD APIERR;                   // An error code from a Win32 API.
typedef INT SOCKERR;                    // An error code from WinSock.

#ifdef __cplusplus
}
#endif

#endif _NNTPTYPE_


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\nntp\core\include\nntperr.h ===
/************************************************************************
*                                                                       *
*   nntperr.h -- HRESULT  code definitions for NNTP  					*
*                                                                       *
*   Copyright (c) 1991-1998, Microsoft Corp. All rights reserved.       *
*                                                                       * 
*   Facility code: 0x20 ( for NNTP )	                                *
*                                                                       *
************************************************************************/
#ifndef _NNTPERR_H_
#define _NNTPERR_H_
#include <winerror.h>

//
// MessageId: NNTP_E_CREATE_DRIVER	
//
// MessageText:
//
// Create store driver failed.
//
#define NNTP_E_CREATE_DRIVER		_HRESULT_TYPEDEF_(0x80200001L)

//
// MessageId: NNTP_E_DRIVER_ALREADY_INITIALIZED
//
// MessageText:
//
// Driver has already been initialized.
//
#define NNTP_E_DRIVER_ALREADY_INITIALIZED	_HRESULT_TYPEDEF_(0x80200002L)

//
// MessageId: NNTP_E_DRIVER_NOT_INITIALIZED
//
// MessageText:
//
// Driver has not been initialized yet.
//
#define NNTP_E_DRIVER_NOT_INITIALIZED	_HRESULT_TYPEDEF_(0x80200003L)

//
// MessageId: NNTP_E_REMOTE_STORE_DOWN
//
// MessageText:
//
// The remote store has been shutdown
//
#define NNTP_E_REMOTE_STORE_DOWN	_HRESULT_TYPEDEF_(0x80200004L)

//
// MessageId: NNTP_E_GROUP_CORRUPT
//
// MessageText:
//
// The group properties are corrupted
//
#define NNTP_E_GROUP_CORRUPT		_HRESULT_TYPEDEF_(0x80200005)

//
// MessageId: NNTP_E_PARTIAL_COMPLETE
//
// Message Text:
//
// Only part of the operation succeeded
//
#define NNTP_E_PARTIAL_COMPLETE		_HRESULT_TYPEDEF_(0x80200006)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\nntp\core\include\nntpcons.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    nntpcons.h

Abstract:

    This module contains global constants for the NNTP server.

Author:

    Johnson Apacible (JohnsonA)     26-Sept-1995

Revision History:

--*/

#ifndef _NNTPCONS_
#define _NNTPCONS_

//
// manifest constants
//

#define     KB                          1024
#define     MEG                         (KB * KB)
#define     MAX_NNTP_LINE               512
//
// convert to seconds
//

#define     SEC_PER_MIN                 (60)
#define     SEC_PER_HOUR                (60* SEC_PER_MIN)
#define     SEC_PER_DAY                 (24* SEC_PER_HOUR)
#define     SEC_PER_WEEK                (7 * SEC_PER_DAY)

//
// Port numbers
//

#define     NNTP_PORT                   119
#define     NNTP_SSL_PORT               563

//
// Id values
//

#define     GROUPID_INVALID             0xffffffff
#define     GROUPID_DELETED             0xfffffffe

#define     ARTICLEID_INVALID           0xffffffff

//
// Secret data name
//

#define NNTP_SSL_CERT_SECRET    L"NNTP_CERTIFICATE"
#define NNTP_SSL_PKEY_SECRET    L"NNTP_PRIVATE_KEY"
#define NNTP_SSL_PWD_SECRET     L"NNTP_SSL_PASSWORD"

//
// Default pull date/time
//

#define DEF_PULL_TIME           "000000"

//
// Maximum xover reference
//

#define MAX_REFERENCES_FIELD             512

//
//	Newsgroup constants
//
//

const   DWORD   MAX_NEWSGROUP_NAME = 512 ;
const	DWORD	MAX_DESCRIPTIVE_TEXT = 512 ;
const	DWORD	MAX_MODERATOR_NAME = 512 ;
const	DWORD	MAX_VOLUMES = 1;
const	DWORD	MAX_PRETTYNAME_TEXT = 72 ;

//
//  Maximmum number of CSessionSocket objects !
//
#define MAX_SESSIONS    15000

//
//  Maximum number of CPacket derived objects
//
#define MAX_PACKETS     (20 * MAX_SESSIONS)

//
//  Maximum number of Buffers
//
#define MAX_BUFFERS     (MAX_SESSIONS * 8)

//
//  Maximum number of CChannel derived objects
//
#define MAX_CHANNELS    (8 * MAX_SESSIONS)

//
//  Maximum number of CInFeed derived objects
//
#define MAX_FEEDS   MAX_SESSIONS

//
//  Maximum number of CSessionState Derived Objects !
//
#define MAX_STATES      (3 * MAX_SESSIONS)

#endif // _NNTPCONS_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\nntp\core\include\nntpmacr.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    nntpmacr.h

Abstract:

    This module contains macross for the NNTP server.

Author:

    Johnson Apacible (JohnsonA)     26-Sept-1995

Revision History:

--*/

#ifndef _NNTPMACR_
#define _NNTPMACR_


#define ALLOCATE_HEAP( nBytes ) LocalAlloc( 0, nBytes )
#define FREE_HEAP( _heap )      LocalFree( (PVOID)(_heap) )

//
// try/finally macros
//

#define START_TRY               __try {
#define END_TRY                 }
#define TRY_EXCEPT              } __except(EXCEPTION_EXECUTE_HANDLER) {
#define START_FINALLY           } __finally {

//
// tracing
//

#define INIT_TRACE              InitAsyncTrace( )
#define TERM_TRACE              TermAsyncTrace( )
#define ENTER( _x_ )            TraceFunctEnter( _x_ );
#define LEAVE                   TraceFunctLeave( );

//
// Convert FILETIME TO LIs
//

#define LI_FROM_FILETIME( _pLi, _pFt ) {               \
            (_pLi)->LowPart = (_pFt)->dwLowDateTime;   \
            (_pLi)->HighPart = (_pFt)->dwHighDateTime; \
            }

#define FILETIME_FROM_LI( _pFt, _pLi ) {               \
            (_pFt)->dwLowDateTime = (_pLi)->LowPart;   \
            (_pFt)->dwHighDateTime = (_pLi)->HighPart; \
            }

//
// LockStatistics
//

#define LockStatistics( pInst )						ACQUIRE_LOCK( &pInst->m_StatLock );
#define UnlockStatistics( pInst )					RELEASE_LOCK( &pInst->m_StatLock );
#define IncrementStat( pInst, _x )					((pInst->m_NntpStats). ## _x)++;
#define DecrementStat( pInst, _x )					((pInst->m_NntpStats). ## _x)--;
#define InterlockedIncrementStat( pInst, _x )		InterlockedIncrement((LPLONG)&((pInst->m_NntpStats). ## _x));
#define InterlockedDecrementStat( pInst, _x )		InterlockedDecrement((LPLONG)&((pInst->m_NntpStats). ## _x));
#define InterlockedExchangeAddStat( pInst, _x, _y )	InterlockedExchangeAdd( (PLONG)&((pInst->m_NntpStats). ## _x), (LONG)(_y) )
#define AddByteStat( pInst, _x, _y ) \
        if( (ULONG)InterlockedExchangeAdd( (PLONG)&(((pInst->m_NntpStats). ## _x).LowPart), (LONG)(_y)) \
			> ( ULONG_MAX - (ULONG)(_y) ) ) InterlockedIncrement( (LPLONG)&(((pInst->m_NntpStats). ## _x).HighPart) );

//
// debug constants\macros
//

#define  NNTP_DEBUG_REGISTRY        0x00000004
#define  NNTP_DEBUG_EXPIRE          0x00000008
#define  NNTP_DEBUG_LOCKS           0x00000010
#define  NNTP_DEBUG_ARTMAP          0x00000020
#define  NNTP_DEBUG_HISTORY         0x00000040
#define  NNTP_DEBUG_HEAP            0x00000080
#define  NNTP_DEBUG_HASH            0x00000100
#define  NNTP_DEBUG_SECURITY        0x00000200
#define  NNTP_DEBUG_FEEDMGR         0x00000400
#define  NNTP_DEBUG_FEEDBLOCK       0x00000800

extern DWORD DebugLevel;
#define DO_DEBUG( flag ) \
    if ( DebugLevel & (NNTP_DEBUG_ ## flag) )

//
// on debug build define all inline functions as regular functions.
// copied from msndef.h
//

#if DBG
#define INLINE
#else
#define INLINE      inline
#endif

//
// from extcmk2.h
//

#define fCharInSet(ch, set) (NULL !=strchr(set, ch))
#define STRLEN(sz) (sizeof(sz)-1)
#define	fWhitespace(ch) fCharInSet(ch, szWSChars)
#define	fWhitespaceNull(ch) fCharInSet(ch, szWSNullChars)
#define	fWhitespaceNewLine(ch) fCharInSet(ch, szWSNLChars)
#define	fNewLine(ch) ( ( ch != '\0' ) && fCharInSet(ch, szNLChars) )

#ifndef	Assert
#define Assert _ASSERT
#endif

//
//	Virtual Server scoping macros
//
#define XOVER_TABLE(   pTree )		((pTree->GetVirtualServer())->XoverTable())
#define ARTICLE_TABLE( pTree )		((pTree->GetVirtualServer())->ArticleTable())
#define HISTORY_TABLE( pTree )		((pTree->GetVirtualServer())->HistoryTable())
#define XOVER_CACHE( pTree )		((pTree->GetVirtualServer())->XoverCache())
#define EXPIRE_OBJECT( pTree )		((pTree->GetVirtualServer())->ExpireObject())
#define INST( pS )					((pS->m_context).m_pInstance)

//
//	Delete macros
//
#define DELETE_CHK( ptr )	if( ptr ) { delete ptr ; ptr = NULL ; }

#endif // _NNTPMACR_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\nntp\core\include\nntpmeta.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

	nntpmeta.h

Abstract:

	Defines the metabase IDs used by the NNTP service.

	See iiscnfg.h for IIS metabase IDs.
	See the metabase spreadsheet (on \\isbu\tigris) for parameter 
	ranges, and     descriptions of these properties.

Author:

	Magnus Hedlund (MagnusH)                --

Revision History:

	Kangrong Yan ( KangYan )  Feb 18, 1998	Added feed admin related property id's.
	AWetmore - Mar 24, 1998 - Added VRoot keys
	KangYan - May 16, 1998 - Added FS Driver related VRoot keys
	SNeely	12/28/2000 - Cleaned up definitions, removed unnecessary keys


NOTE:  WHEN UPDATING THIS FILE, BE SURE TO ALSO UPDATE THE SCHEMA IN
		ADMIN\ADSI\ADSIIS\GLOBDATA.CXX.

--*/

#ifndef _NNTPMETA_INCLUDED_
#define _NNTPMETA_INCLUDED_

//
// Pickup IIS values:
//

#include "iiscnfg.h"

//--------------------------------------------------------------------
//
//              Reserved Ranges:
//
//      See the iiscnfg.h file for IIS IDs.
//
//      IIS has reserved the range of IDs for news.
//
//--------------------------------------------------------------------

#ifndef NNTP_MD_ID_BEGIN_RESERVED
#define NNTP_MD_ID_BEGIN_RESERVED   0x0000b000
#endif

#ifndef NNTP_MD_ID_END_RESERVED
#define NNTP_MD_ID_END_RESERVED     0x0000bfff
#endif

//--------------------------------------------------------------------
// NNTP Server properties           (45056 -> 45155)
// NNTP Instance properties         (45156 -> 46155)
// NNTP Virtual root properties     (46156 -> 47155)
// NNTP File properties             (47156 -> 49151)
//--------------------------------------------------------------------

#define NNTP_MD_SERVER_BASE                (NNTP_MD_ID_BEGIN_RESERVED)
#define NNTP_MD_SERVICE_INSTANCE_BASE      (NNTP_MD_SERVER_BASE + 100)
#define NNTP_MD_VIRTUAL_ROOT_BASE          (NNTP_MD_SERVICE_INSTANCE_BASE + 1000)
#define NNTP_MD_FILE_BASE                  (NNTP_MD_VIRTUAL_ROOT_BASE + 1000)

//--------------------------------------------------------------------
//
//      User Types:
//
//--------------------------------------------------------------------

//
//      NNTP should use IIS_MD_UT_SERVER for all of its server properties,
//      and IIS_MD_UT_FILE for file properties.
//

//--------------------------------------------------------------------
//
//      Metabase Path Strings
//
//--------------------------------------------------------------------

#ifdef UNICODE

#define NNTP_MD_ROOT_PATH                       _T("/LM/NntpSvc/")
#define NNTP_MD_FEED_PATH                       _T("Feeds/")
#define NNTP_MD_EXPIRES_PATH                    _T("Expires/")

#else

#define NNTP_MD_ROOT_PATH                       "/LM/NntpSvc/"
#define NNTP_MD_FEED_PATH                       "Feeds/"
#define NNTP_MD_EXPIRES_PATH                    "Expires/"

#endif // UNICODE

//--------------------------------------------------------------------
//
//      Metabase IDs
//
//--------------------------------------------------------------------

//
//      Server (/LM/NntpSvc/) Properties:
//

// IIS Property identifiers that NNTP reuses:

// #define MD_HOSTNAME                     (IIS_MD_SERVER_BASE+10 )
// #define MD_IP_ADDRESS                   (IIS_MD_SERVER_BASE+11 )
// #define MD_PORT                         (IIS_MD_SERVER_BASE+12 )
// #define MD_CONNECTION_TIMEOUT           (IIS_MD_SERVER_BASE+13 )
// #define MD_MAX_CONNECTIONS              (IIS_MD_SERVER_BASE+14 )
// #define MD_SERVER_COMMENT               (IIS_MD_SERVER_BASE+15 )
// #define MD_AUTHORIZATION                (IIS_MD_FILE_PROP_BASE )
// #define MD_NTAUTHENTICATION_PROVIDERS   (IIS_MD_HTTP_BASE+21 )

// All of these properties are overridable on the service instance level.
// These properties should be added with MD_IIS_UT_SERVER type and 
// METADATA_INHERIT flags.

#define MD_ARTICLE_TIME_LIMIT                   (NNTP_MD_SERVER_BASE +   0)	// not impl	// 45056
#define MD_HISTORY_EXPIRATION                   (NNTP_MD_SERVER_BASE +   1)	// not impl
#define MD_HONOR_CLIENT_MSGIDS                  (NNTP_MD_SERVER_BASE +   2)	// not impl
#define MD_SMTP_SERVER                          (NNTP_MD_SERVER_BASE +   3)
#define MD_ADMIN_EMAIL                          (NNTP_MD_SERVER_BASE +   4)
#define MD_ADMIN_NAME                           (NNTP_MD_SERVER_BASE +   5)	// not impl
#define MD_ALLOW_CLIENT_POSTS                   (NNTP_MD_SERVER_BASE +   6)
#define MD_ALLOW_FEED_POSTS                     (NNTP_MD_SERVER_BASE +   7)
#define MD_ALLOW_CONTROL_MSGS                   (NNTP_MD_SERVER_BASE +   8)
#define MD_DEFAULT_MODERATOR                    (NNTP_MD_SERVER_BASE +   9)
//#define MD_ANONYMOUS_USERNAME                   (NNTP_MD_SERVER_BASE +  10)
#define MD_NNTP_COMMAND_LOG_MASK                (NNTP_MD_SERVER_BASE +  11)	// not impl
#define MD_DISABLE_NEWNEWS                      (NNTP_MD_SERVER_BASE +  12)
#define MD_NEWS_CRAWLER_TIME                    (NNTP_MD_SERVER_BASE +  13)	// not impl
#define MD_SHUTDOWN_LATENCY                     (NNTP_MD_SERVER_BASE +  14)	// not impl
//#define MD_ALLOW_ANONYMOUS                   (NNTP_MD_SERVER_BASE +  15)
//#define MD_QUERY_IDQ_PATH                       (NNTP_MD_SERVER_BASE +  16)

//
//      Service Instance (/LM/NntpSvc/{Instance}/) Properties:
//

// IIS Property identifiers that NNTP reuses:

// IIS Logging properties:
// #define MD_LOG_TYPE                     (IIS_MD_LOG_BASE+0  )
// #define MD_LOGFILE_DIRECTORY            (IIS_MD_LOG_BASE+1  )
// #define MD_LOGFILE_NAME                 (IIS_MD_LOG_BASE+2  )
// #define MD_LOGFILE_PERIOD               (IIS_MD_LOG_BASE+3  )
// #define MD_LOGFILE_TRUNCATE_SIZE        (IIS_MD_LOG_BASE+4  )
// #define MD_LOGFILE_BATCH_SIZE           (IIS_MD_LOG_BASE+5  )
// #define MD_LOGFILE_FIELD_MASK           (IIS_MD_LOG_BASE+6  )
// #define MD_LOGSQL_DATA_SOURCES          (IIS_MD_LOG_BASE+7  )
// #define MD_LOGSQL_TABLE_NAME            (IIS_MD_LOG_BASE+8  )
// #define MD_LOGSQL_USER_NAME             (IIS_MD_LOG_BASE+9  )
// #define MD_LOGSQL_PASSWORD              (IIS_MD_LOG_BASE+10 )
// #define MD_LOG_PLUGIN_ORDER             (IIS_MD_LOG_BASE+11 )
// #define MD_LOG_STATE                    (IIS_MD_LOG_BASE+12 )
// #define MD_LOG_FIELD_MASK               (IIS_MD_LOG_BASE+13 )
// #define MD_LOG_FORMAT                   (IIS_MD_LOG_BASE+14 )

#define MD_GROUP_HELP_FILE                      (NNTP_MD_SERVICE_INSTANCE_BASE +   0)		// 45156
#define MD_GROUP_LIST_FILE                      (NNTP_MD_SERVICE_INSTANCE_BASE +   1)
#define MD_ARTICLE_TABLE_FILE                   (NNTP_MD_SERVICE_INSTANCE_BASE +   2)
#define MD_HISTORY_TABLE_FILE                   (NNTP_MD_SERVICE_INSTANCE_BASE +   3)
#define MD_MODERATOR_FILE                       (NNTP_MD_SERVICE_INSTANCE_BASE +   4)
#define MD_XOVER_TABLE_FILE                     (NNTP_MD_SERVICE_INSTANCE_BASE +   5)
//#define MD_DISPLAY_NAME                         (NNTP_MD_SERVICE_INSTANCE_BASE +   6)
//#define MD_ERROR_CONTROL                        (NNTP_MD_SERVICE_INSTANCE_BASE +   7)
//#define MD_SERVER_UUCP_NAME                     (NNTP_MD_SERVICE_INSTANCE_BASE +   8)
#define MD_CLIENT_POST_HARD_LIMIT               (NNTP_MD_SERVICE_INSTANCE_BASE +   9)
#define MD_CLIENT_POST_SOFT_LIMIT               (NNTP_MD_SERVICE_INSTANCE_BASE +  10)
#define MD_FEED_POST_HARD_LIMIT                 (NNTP_MD_SERVICE_INSTANCE_BASE +  11)
#define MD_FEED_POST_SOFT_LIMIT                 (NNTP_MD_SERVICE_INSTANCE_BASE +  12)
//#define MD_CLEAN_BOOT                           (NNTP_MD_SERVICE_INSTANCE_BASE +  13)
#define MD_NNTP_UUCP_NAME               		(NNTP_MD_SERVICE_INSTANCE_BASE +  14)
#define MD_NNTP_ORGANIZATION            		(NNTP_MD_SERVICE_INSTANCE_BASE +  15)	// not impl
#define MD_LIST_FILE                            (NNTP_MD_SERVICE_INSTANCE_BASE +  16)
#define MD_PICKUP_DIRECTORY                     (NNTP_MD_SERVICE_INSTANCE_BASE +  17)
#define MD_FAILED_PICKUP_DIRECTORY              (NNTP_MD_SERVICE_INSTANCE_BASE +  18)
#define MD_NNTP_SERVICE_VERSION                 (NNTP_MD_SERVICE_INSTANCE_BASE +  19)
#define MD_DROP_DIRECTORY                       (NNTP_MD_SERVICE_INSTANCE_BASE +  20)
//#define MD_X_SENDER                             (NNTP_MD_SERVICE_INSTANCE_BASE +  21)
#define MD_PRETTYNAMES_FILE                     (NNTP_MD_SERVICE_INSTANCE_BASE +  22)
#define MD_NNTP_CLEARTEXT_AUTH_PROVIDER         (NNTP_MD_SERVICE_INSTANCE_BASE +  23)
#define MD_FEED_REPORT_PERIOD					(NNTP_MD_SERVICE_INSTANCE_BASE +  24)
#define MD_MAX_SEARCH_RESULTS					(NNTP_MD_SERVICE_INSTANCE_BASE +  25)
#define MD_GROUPVAR_LIST_FILE                   (NNTP_MD_SERVICE_INSTANCE_BASE +  26)

//
//      Feed (/LM/NntpSvc/{Instance}/Feeds/{FeedID}/) Properties:
//

#define MD_FEED_SERVER_NAME                     (NNTP_MD_SERVICE_INSTANCE_BASE + 300)		// 45456
#define MD_FEED_TYPE                            (NNTP_MD_SERVICE_INSTANCE_BASE + 301)
#define MD_FEED_NEWSGROUPS                      (NNTP_MD_SERVICE_INSTANCE_BASE + 302)
#define MD_FEED_SECURITY_TYPE                   (NNTP_MD_SERVICE_INSTANCE_BASE + 303)
#define MD_FEED_AUTHENTICATION_TYPE             (NNTP_MD_SERVICE_INSTANCE_BASE + 304)
#define MD_FEED_ACCOUNT_NAME                    (NNTP_MD_SERVICE_INSTANCE_BASE + 305)
#define MD_FEED_PASSWORD                        (NNTP_MD_SERVICE_INSTANCE_BASE + 306)
#define MD_FEED_START_TIME_HIGH                 (NNTP_MD_SERVICE_INSTANCE_BASE + 307)
#define MD_FEED_START_TIME_LOW                  (NNTP_MD_SERVICE_INSTANCE_BASE + 308)
#define MD_FEED_INTERVAL                        (NNTP_MD_SERVICE_INSTANCE_BASE + 309)
#define MD_FEED_ALLOW_CONTROL_MSGS              (NNTP_MD_SERVICE_INSTANCE_BASE + 310)
#define MD_FEED_CREATE_AUTOMATICALLY            (NNTP_MD_SERVICE_INSTANCE_BASE + 311)
#define MD_FEED_DISABLED                        (NNTP_MD_SERVICE_INSTANCE_BASE + 312)
#define MD_FEED_DISTRIBUTION                    (NNTP_MD_SERVICE_INSTANCE_BASE + 313)
#define MD_FEED_CONCURRENT_SESSIONS             (NNTP_MD_SERVICE_INSTANCE_BASE + 314)
#define MD_FEED_MAX_CONNECTION_ATTEMPTS         (NNTP_MD_SERVICE_INSTANCE_BASE + 315)
#define MD_FEED_UUCP_NAME                       (NNTP_MD_SERVICE_INSTANCE_BASE + 316)
#define MD_FEED_TEMP_DIRECTORY                  (NNTP_MD_SERVICE_INSTANCE_BASE + 317)
#define MD_FEED_NEXT_PULL_HIGH                  (NNTP_MD_SERVICE_INSTANCE_BASE + 318)
#define MD_FEED_NEXT_PULL_LOW                   (NNTP_MD_SERVICE_INSTANCE_BASE + 319)
#define MD_FEED_PEER_TEMP_DIRECTORY             (NNTP_MD_SERVICE_INSTANCE_BASE + 320)
#define MD_FEED_PEER_GAP_SIZE                   (NNTP_MD_SERVICE_INSTANCE_BASE + 321)
#define MD_FEED_OUTGOING_PORT                   (NNTP_MD_SERVICE_INSTANCE_BASE + 322)
#define MD_FEED_FEEDPAIR_ID                     (NNTP_MD_SERVICE_INSTANCE_BASE + 323)
#define MD_FEED_HANDSHAKE						(NNTP_MD_SERVICE_INSTANCE_BASE + 324)
#define MD_FEED_ADMIN_ERROR						(NNTP_MD_SERVICE_INSTANCE_BASE + 325)
#define MD_FEED_ERR_PARM_MASK					(NNTP_MD_SERVICE_INSTANCE_BASE + 326)

//
//      Expiration (/LM/NntpSvc/{Instance}/Expires/{ExpireID}/) Properties:
//

#define MD_EXPIRE_SPACE                 (NNTP_MD_SERVICE_INSTANCE_BASE + 500)		// 45656
#define MD_EXPIRE_TIME                  (NNTP_MD_SERVICE_INSTANCE_BASE + 501)
#define MD_EXPIRE_NEWSGROUPS            (NNTP_MD_SERVICE_INSTANCE_BASE + 502)
#define MD_EXPIRE_POLICY_NAME           (NNTP_MD_SERVICE_INSTANCE_BASE + 503)

//
//      Virtual Root Properties:
//

// IIS Property identifiers that NNTP reuses:

#define MD_ACCESS_ALLOW_POSTING             (MD_ACCESS_WRITE)
#define MD_ACCESS_RESTRICT_VISIBILITY       (MD_ACCESS_EXECUTE)
#define	MD_VR_DRIVER_CLSID					(NNTP_MD_VIRTUAL_ROOT_BASE + 0)			// 46156
#define	MD_VR_DRIVER_PROGID					(NNTP_MD_VIRTUAL_ROOT_BASE + 1)
#define MD_FS_PROPERTY_PATH					(NNTP_MD_VIRTUAL_ROOT_BASE + 2)
//#define MD_FS_TEST_SERVER					(NNTP_MD_VIRTUAL_ROOT_BASE + 3)
#define MD_FS_VROOT_PATH					(MD_VR_PATH)
// MD_VR_USE_ACCOUNT:
//    0 - Don't use the account in vroot, use whatever the server passes in;
//    1 - Use the vroot account
#define MD_VR_USE_ACCOUNT                  (NNTP_MD_VIRTUAL_ROOT_BASE + 4)
#define MD_VR_DO_EXPIRE                     (NNTP_MD_VIRTUAL_ROOT_BASE + 5)
#define MD_EX_MDB_GUID                      (NNTP_MD_VIRTUAL_ROOT_BASE + 6)
#define MD_VR_OWN_MODERATOR               (NNTP_MD_VIRTUAL_ROOT_BASE + 7)

//#define MD_VR_USERNAME                      (IIS_MD_VR_BASE+2 )
//#define MD_VR_PASSWORD                      (IIS_MD_VR_BASE+3 )

//
//      Files Properties:
//

//
//		ADSI object names
//

#define NNTP_ADSI_OBJECT_FEEDS			"IIsNntpFeeds"
#define NNTP_ADSI_OBJECT_FEED			"IIsNntpFeed"
#define NNTP_ADSI_OBJECT_EXPIRES		"IIsNntpExpiration"
#define NNTP_ADSI_OBJECT_EXPIRE			"IIsNntpExpire"
#define NNTP_ADSI_OBJECT_GROUPS			"IIsNntpGroups"
#define NNTP_ADSI_OBJECT_SESSIONS		"IIsNntpSessions"
#define NNTP_ADSI_OBJECT_REBUILD		"IIsNntpRebuild"

#endif // _NNTPMETA_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\nntp\core\include\nntputil.h ===
/*++

Copyright (c) 1995-1999  Microsoft Corporation

Module Name:

    nnprocs.h

Abstract:

    This module contains function prototypes used by the NNTP server.

Author:

    Johnson Apacible (JohnsonA)     12-Sept-1995

Revision History:

    Kangrong Yan ( KangYan )    28-Feb-1998
        Added one prototype for fixed length Unicode-Ascii convertion func.

--*/

#ifndef	_NNUTIL_
#define	_NNUTIL_

//
// svcsupp.cpp
//

DWORD
multiszLength(
      char const * multisz
      );

const char *
multiszCopy(
    char const * multiszTo,
    const char * multiszFrom,
    DWORD dwCount
    );

char *
szDownCase(
           char * sz,
           char * szBuf
           );


DWORD
MultiListSize(
    LPSTR *List
    );

VOID
CopyStringToBuffer (
    IN PCHAR String,
    IN PCHAR FixedStructure,
    IN OUT LPWSTR *EndOfVariableData,
    OUT LPWSTR *VariableDataPointer
    );

BOOL
VerifyMultiSzListW(
    LPBYTE List,
    DWORD ListSize
    );

LPSTR *
AllocateMultiSzTable(
                IN PCHAR List,
                IN DWORD cbList,
                IN BOOL IsUnicode
                );

LPSTR	*
ReverseMultiSzTable(
	IN	LPSTR*	plpstr
	) ;

LPSTR*
CopyMultiList(	
	IN LPSTR*	List 
	) ;

LPSTR*
MultiSzTableFromStrA(	
	LPCSTR	lpstr 
	) ;

LPSTR*
MultiSzTableFromStrW(	
	LPWSTR	lpwstr 
	) ;

LPSTR
LpstrFromMultiSzTableA(	
	LPSTR*	plpstr 
	) ;

LPWSTR
LpwstrFromMultiSzTableA( 
	LPSTR*	plpstr 
	) ;

BOOL
MultiSzIntersect(	
	LPSTR*	plpstr,	
	LPSTR	szmulti 
	) ;

VOID
CopyUnicodeStringIntoAscii(
        IN LPSTR AsciiString,
        IN LPWSTR UnicodeString
        );
VOID
CopyNUnicodeStringIntoAscii(
        IN LPSTR AsciiString,
        IN LPWSTR UnicodeString,
		IN DWORD dwUnicodeLen,
		IN DWORD dwAsciiLen
		);

LPWSTR
CopyAsciiStringIntoUnicode(
        IN LPWSTR UnicodeString,
        IN LPSTR AsciiString
        );

VOID
CopyNAsciiStringIntoUnicode(
        IN LPWSTR UnicodeString,
        IN LPSTR AsciiString,
        IN DWORD dwAsciiLen,
        IN DWORD dwUnicodeLen);

void
FillLpwstrFromMultiSzTable(
	LPSTR*	plpstr,
	LPWSTR	lpwstr 
	) ;

void
FillLpstrFromMultiSzTable(
	LPSTR*	plpstr,
	LPSTR	lpstrFill
	) ;

BOOL 
OperatorAccessCheck( 
    LPCSTR lpMBPath, 
    DWORD Access 
    ) ;

#define TsApiAccessCheckEx( x, y, z ) (OperatorAccessCheck( (x), y ) ? NO_ERROR : TsApiAccessCheck( z ) );

//
// svcstat.c
//


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\nntp\core\include\nntps.h ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1993                **/
/**********************************************************************/

/*
    nntps.h

    This file contains constants & type definitions shared between the
    NNTP Service, Installer, and Administration UI.


    FILE HISTORY:
        KeithMo     10-Mar-1993 Created.

*/


#ifndef _NNTPS_H_
#define _NNTPS_H_

#ifdef __cplusplus
extern "C"
{
#endif  // _cplusplus

#if !defined(MIDL_PASS)
#include <winsock.h>
#endif

#define IPPORT_NNTP                     119

//
//  Name of the log file, used for logging file accesses.
//

#define NNTP_LOG_FILE                  TEXT("NNTPSVC.LOG")


//
//  Configuration parameters registry key.
//

#define	NNTP_PARAMETERS_KEY_A   "System\\CurrentControlSet\\Services\\NNTPSvc\\Parameters"
#define	NNTP_PARAMETERS_KEY_W   L"System\\CurrentControlSet\\Services\\NNTPSvc\\Parameters"
#define NNTP_PARAMETERS_KEY \
            TEXT("System\\CurrentControlSet\\Services\\NntpSvc\\Parameters")


//
//  Performance key.
//

#define NNTP_PERFORMANCE_KEY \
            TEXT("System\\CurrentControlSet\\Services\\NntpSvc\\Performance")

#if 0
//
//  Configuration value names.
//

#define W3_CHECK_FOR_WAISDB            TEXT("CheckForWAISDB")
#define W3_DEBUG_FLAGS                 TEXT("DebugFlags")
#define W3_DIR_BROWSE_CONTROL          TEXT("Dir Browse Control")
#define W3_DIR_ICON                    TEXT("Folder Image")
#define W3_DIR_ICON_W                  L"Folder Image"
#define W3_DEFAULT_FILE                TEXT("Default Load File")
#define W3_DEFAULT_FILE_W              L"Default Load File"
#define W3_SERVER_AS_PROXY             TEXT("ServerAsProxy")
#define W3_CATAPULT_USER               TEXT("CatapultUser")
#define W3_CATAPULT_USER_W             L"CatapultUser"
#define W3_SCRIPT_TIMEOUT              "ScriptTimeout"
#define W3_CACHE_EXTENSIONS            "CacheExtensions"
#define W3_SSI_ENABLED                 "ServerSideIncludesEnabled"
#define W3_SSI_EXTENSION               "ServerSideIncludesExtension"
#define W3_SSI_EXTENSION_W             L"ServerSideIncludesExtension"
#define W3_GLOBAL_EXPIRE               "GlobalExpire"
#define W3_PROVIDER_LIST               "NTAuthenticationProviders"
#endif

//
//  Name of the LSA Secret Object containing the password for
//  anonymous logon.
//

#define NNTP_ANONYMOUS_SECRET         TEXT("NNTP_ANONYMOUS_DATA")
#define NNTP_ANONYMOUS_SECRET_A       "NNTP_ANONYMOUS_DATA"
#define NNTP_ANONYMOUS_SECRET_W       L"NNTP_ANONYMOUS_DATA"

//
//  The set of password/virtual root pairs
//

#define NNTP_ROOT_SECRET_W            L"NNTP_ROOT_DATA"

#ifdef __cplusplus
}
#endif  // _cplusplus

#endif  // _NNTPS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\nntp\core\include\nntpvr.h ===
#ifndef __TESTVR_H__
#define __TESTVR_H__

#include <iiscnfg.h>
#include <vroot.h>
#include <stdio.h>
#include <nntpdrv.h>
#include <filehc.h>
#include "mailmsg.h"

class CNNTPVRoot;
class CNewsGroupCore;

extern GET_DEFAULT_DOMAIN_NAME_FN pfnGetDefaultDomainName;
extern HANDLE   g_hProcessImpersonationToken;

//
// The base implementation of the completion object.  It implements the 
// following:
//  * AddRef
//  * Release
//  * QueryInterface
//  * SetResult
//
class CNntpComplete : public INntpComplete {
	public:
		// IUnknown:
		ULONG __stdcall AddRef();
		ULONG __stdcall Release();
	    HRESULT __stdcall QueryInterface(const IID& iid, VOID** ppv);

		// INntpComplete:
		void __stdcall SetResult(HRESULT hr);

		// non COM methods
		//
		//	Retrieve the HRESULT the Driver deposited for us !
		//
		HRESULT GetResult();
		//
		//	Get the VRoot this completion is bound to !
		//
		CNNTPVRoot *GetVRoot();
		//
		//	Construct us - we may be constructed bound to a particular
		//	vroot!
		//
		CNntpComplete(CNNTPVRoot *pVRoot = NULL);
		//
		//	Bind us to a particular Vroot - we'll hold a reference
		//	on the VRoot object as long as we're pending !
		//
		void SetVRoot(CNNTPVRoot *pVRoot);

		// 
		//  Wraps releasing property bag, to do some bookkeeping
		//
		void _stdcall ReleaseBag( INNTPPropertyBag *pPropBag )
		{
		    DecGroupCounter();
		    pPropBag->Release();
		}

        //
		// Inc, Dec group counter
		//
		void BumpGroupCounter()
		{
#ifdef DEBUG
            m_cGroups++;
#endif
        }

        void DecGroupCounter()
        {
#ifdef DEBUG
            _ASSERT( m_cGroups > 0 );
            m_cGroups--;
#endif
        }

		virtual ~CNntpComplete();
		//
		//	Derived classes may handle our allocation and destruction
		//	differently - i.e. a CNntpComplete object may be used several
		//	times, being re-used instead of destroyed when the ref count 
		//	reaches 0 !
		//
		virtual void Destroy();
		//
		//	This should only be called when our refcount has reached zero - 
		//	we will reset the Completion object to its fresh after construction
		//	state so that we can be re-used for another store operation !
		//
		virtual	void	Reset() ;

	protected:
		LONG m_cRef;
		HRESULT m_hr;
		CNNTPVRoot *m_pVRoot;

		// A counter that helps find out property bag leaks, dbg build only
#ifdef DEBUG
		LONG m_cGroups;
#endif
};

// the completion object for newstree decoration
/*
class CNntpSyncCompleteEx : public CNntpComplete {
	public:
		CNntpSyncComplete(    CNNTPVRoot *pVR, 	// the current vroot
							  HRESULT *phr );	// signalled when done
		~CNntpSyncComplete();
	private:
		// we write the value in GetResult() into this pointer
		HRESULT *m_phr;
		// we signal this handle when the create group is complete
		HANDLE m_heDone;
};
*/

// Class definition for the completion object.
// It derives INntpComplete, but implements a blocking completion
class CNntpSyncComplete : public CNntpComplete {  //sc
private:
	HANDLE 	m_hEvent;

#if defined( DEBUG )
	//
	// for debugging purpose, assert user should call IsGood
	//
	BOOL    m_bIsGoodCalled;
#endif
	
	//
	//	These objects can only be made on the stack !
	//
	void*	operator	new( size_t size ) ;
	void	operator	delete( void* )	{}
public:
    // Constructor and destructors
	CNntpSyncComplete::CNntpSyncComplete(	CNNTPVRoot*	pVRoot = 0 ) : 
    	CNntpComplete( pVRoot )	{
    	AddRef() ;
    	_VERIFY( m_hEvent = GetPerThreadEvent() );
    	//m_hEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
#if defined( DEBUG )
        m_bIsGoodCalled = FALSE;
#endif
	    TraceQuietEnter( "CDriverSyncComplete::CDriverSyncComplete" );
    }

	CNntpSyncComplete::~CNntpSyncComplete()    {
        //_VERIFY( CloseHandle( m_hEvent ) );
    }

    // Reset the completion object
    VOID
    Reset()
    {
    	CNntpComplete::Reset() ;
    	_ASSERT( m_hEvent != 0 ) ;
    	AddRef() ;
	}

	BOOL
	IsGood()	{
#if defined( DEBUG )
        m_bIsGoodCalled = TRUE;
#endif
		return	m_hEvent != 0 ;
	}

	void
	Destroy()	{
		//
		//	Do Nothing !
		//
		SetEvent( m_hEvent ) ;
	}

    // Wait for the completion 
	HRESULT
    WaitForCompletion()
    {
		_ASSERT( m_hEvent );
		_ASSERT( m_bIsGoodCalled );
		LONG    lRef;
		if ( ( lRef = InterlockedDecrement( &m_cRef ) ) == 0 ) {
			// It has been completed, I don't need to wait,
		} else if ( lRef == 1 ) {   
			if( m_hEvent == NULL ) 
				return	E_FAIL ;
			// still waiting for completion
			DWORD dw = WaitForSingleObject( m_hEvent, INFINITE );
		} else {
			_ASSERT( 0 );
			return	E_FAIL ;
		}
		return	GetResult() ;
	}
};

//
// Our implementation of the VRoot object.  
//
class CNNTPVRoot : public CIISVRootTmpl<INewsTree *> {
	public:

	    enum DRIVERSTATE {
			VROOT_STATE_UNINIT,
			VROOT_STATE_CONNECTING,
			VROOT_STATE_CONNECTED,
		};

	    enum LOGON_INFO {
            VROOT_LOGON_DEFAULT,
            VROOT_LOGON_UNC,
            VROOT_LOGON_EX
        };
        
		CNNTPVRoot();
		~CNNTPVRoot();

		//
		// drop references to any drivers that we have loaded and put the
		// vroot into the VROOT_STATE_UNINIT state
		//
		void DropDriver();

		//
		// read our parameters out of the metabase and put the driver into
		// VROOT_STATE_CONNECTING
		//
		virtual HRESULT ReadParameters(IMSAdminBase *pMB, METADATA_HANDLE hmb);

		//
		// Virtual function for handling orphan VRoot during VRootRescan/VRootDelete
		//
		void DispatchDropVRoot();

		//
		// Drop our connection to the driver so that we can cancel async
		// calls
		//
		virtual void CancelAsyncCalls() { DropDriver(); }

		//
		// given a group name figure out the path to the newsgroup.  
		//
		HRESULT MapGroupToPath(const char *pszGroup, 
							   char *pszPath, 
							   DWORD cchPath,
							   PDWORD pcchDirRoot,
							   PDWORD pcchVRoot);

		//
		// access the directory name
		//
		const char *GetDirectory(void) { return m_szDirectory; }

		// Get the vroot impersonation token
		HANDLE GetImpersonationHandle() { return m_hImpersonation; }

		// Get the logon info, or vroot type
		LOGON_INFO GetLogonInfo() { return m_eLogonInfo; }

		// Check if the vroot does expiration itself
		BOOL    HasOwnExpire() {
		    return m_bExpire;
		}

		// Logon the user configured in vroot
        HANDLE LogonUser( LPSTR, LPSTR );		
        BOOL CNNTPVRoot::CrackUserAndDomain(
            CHAR *   pszDomainAndUser,
            CHAR * * ppszUser,
            CHAR * * ppszDomain
            );

		//
		// Set the vroot's errorcode in the metabase
		//
		void SetVRootErrorCode(DWORD dwErrorCode);

		//
		// the next set of functions are just wrappers for the driver's
		// functions
		//
		void DecorateNewsTreeObject(CNntpComplete *punkCompletion);
		void CreateGroup(INNTPPropertyBag *pGroup, 
		                    CNntpComplete *punkCompletion, 
		                    HANDLE hToken,
		                    BOOL    fAnonymous );
		void RemoveGroup(INNTPPropertyBag *pGroup, CNntpComplete *punkCompletion);
		void SetGroup(  INNTPPropertyBag    *pGroup, 
                            DWORD       cProperties,
                            DWORD       idProperties[],
                            CNntpComplete *pCompletion );
        void CheckGroupAccess(  INNTPPropertyBag *pGroup,
                                HANDLE  hToken,
                                DWORD   dwAccessDesired,
                                CNntpComplete *pCompletion );

		//
		//	Wrap calls to Drivers to get Articles !
		//
		void GetArticle(CNewsGroupCore  *pPrimaryGroup,
						CNewsGroupCore  *pCurrentGroup,
						ARTICLEID		idPrimary,
						ARTICLEID		idCurrent,
						STOREID			storeid,
						FIO_CONTEXT		**ppfioContext,
						HANDLE          hImpersonate,
						CNntpComplete	*punkComplete,
                        BOOL            fAnonymous
						);

		//
		//	Wrap calls to Drivers to get XOVER information !
		//
		void	GetXover(	IN	CNewsGroupCore	*pGroup,
							IN	ARTICLEID		idMinArticle,
							IN	ARTICLEID		idMaxArticle,
							OUT	ARTICLEID		*pidLastArticle,
							OUT	char*			pBuffer, 
							IN	DWORD			cbIn,
							OUT	DWORD*			pcbOut,
							IN	HANDLE			hToken,
							IN	CNntpComplete*	punkComplete,
                            IN  BOOL            fAnonymous
							) ;

		//
		//	Wrap calls to the drivers to get the path for XOVER caching !
		//
		BOOL	GetXoverCacheDir(	
							IN	CNewsGroupCore*	pGroup,
							OUT	char*	pBuffer, 
							IN	DWORD	cbIn,
							OUT	DWORD*	pcbOut, 
							OUT	BOOL*	pfFlatDir
							) ;

        //
        // Wrap calls to Drivers to Get xhdr information
        //
        void	GetXhdr(	IN	CNewsGroupCore	*pGroup,
				    		IN	ARTICLEID		idMinArticle,
					    	IN	ARTICLEID		idMaxArticle,
    						OUT	ARTICLEID		*pidLastArticle,
    						LPSTR               szHeader,
	    					OUT	char*			pBuffer, 
		    				IN	DWORD			cbIn,
			    			OUT	DWORD*			pcbOut,
				    		IN	HANDLE			hToken,
					    	IN	CNntpComplete*	pComplete,
                            IN  BOOL            fAnonymous
    						);
        //
        // Wrap calls to Drivers to delete article
        //
		void DeleteArticle( INNTPPropertyBag    *pPropBag,
                            DWORD               cArticles,
                            ARTICLEID           rgidArt[],
                            STOREID             rgidStore[],
                            HANDLE              hClientToken,
                            PDWORD              piFailed,
                            CNntpComplete       *pComplete,
                            BOOL                fAnonymous );

        //
        // Wrap calls to drivers to rebuild a group
        //
        void RebuildGroup(  INNTPPropertyBag *pPropBag,
                            HANDLE          hClientToken,
                            CNntpComplete   *pComplete );

        //
        // Wrap calls to drivers to commit post
        //
		void CommitPost(IUnknown					*punkMessage,
					    STOREID						*pStoreId,
						STOREID						*rgOtherStoreIds,
						HANDLE                      hClientToken,
						CNntpComplete				*pComplete,
                        BOOL                        fAnonymous );

		//
		// get the store driver so that the protocol can do alloc message
		//
		IMailMsgStoreDriver *GetStoreDriver() {
			INntpDriver *pDriver;
			if ((pDriver = GetDriverHR()) != NULL) {
				IMailMsgStoreDriver *pStoreDriver = NULL;
				if (FAILED(pDriver->QueryInterface(IID_IMailMsgStoreDriver, 
											       (void**) &pStoreDriver)))
				{
					pStoreDriver = NULL;
				}
				pDriver->Release();
				return pStoreDriver;
			}
			return NULL;
		}

		//
		// get a pointer to the driver.  this should not be used for
		// driver operations... they should go through the wrapper functions
		// provided at the vroot level
		//
		INntpDriver *GetDriver() { return m_pDriver; }

		//
		// check to see if this vroot is configured with a driver.  mostly
		// here to make operations work even if the unit tests are configured
		// without a driver
		//
		BOOL IsDriver() { return m_clsidDriverPrepare != GUID_NULL; }

		//
		// Get and set methods for impersonation token
		void SetImpersonationToken( HANDLE hToken ) {
		    m_hImpersonation = hToken;
		}

		HANDLE  GetImpersonationToken() {
		    return m_hImpersonation;
		}

		BOOL InStableState()
		{ return ( m_eState == VROOT_STATE_CONNECTED || m_eState == VROOT_STATE_UNINIT); } 

		//
		// return TRUE if we are in the connected state, FALSE otherwise.
		// 
		BOOL CheckState();

		//
		// check if it's connected
		//
		BOOL IsConnected() { return m_eState == VROOT_STATE_CONNECTED; }

		//
		// Set decorate completed flag
		//
        void SetDecCompleted()
        { InterlockedExchange( &m_lDecCompleted, 1 ); }

        //
        // Set decorate is not completed
        //
        void SetDecStarted()
        { InterlockedExchange( &m_lDecCompleted, 0 ); }

        //
        // Test if dec is completed ?
        //
        BOOL DecCompleted()
        { 
            LONG l = InterlockedCompareExchange( &m_lDecCompleted,
                                                 TRUE,
                                                 TRUE );
            return ( l == 1 );
        }

        //
		// Get connection status win32 error code, called by rpc
		//
		DWORD   GetVRootWin32Error( PDWORD pdwWin32Error )
		{
		    //
		    // if connected, return OK
		    //
		    if ( m_eState == VROOT_STATE_CONNECTED )
		        *pdwWin32Error = NOERROR;
		    else {
		        // init it to be PIPE_NOT_CONNECTED
		        *pdwWin32Error = ERROR_PIPE_NOT_CONNECTED;

		        // Lets see if it's going to be overwritten by the real
		        // win32 error code
		        if ( m_dwWin32Error != NOERROR ) *pdwWin32Error = m_dwWin32Error;
		    }

		    return NOERROR;
		}

        
	private:
		// 
		// do a bunch of ASSERTs which verify that we are in a valid state
		//
#ifdef DEBUG
		void Verify();
#else 
		void Verify() { }
#endif

		//
		// check to see if the HRESULT is due to a driver going down.  if
		// so drop our connection to the driver and update our state
		//
		void UpdateState(HRESULT hr);

		//
		// start the connection process
		//
		HRESULT StartConnecting();

		//
		// this is inlined into the top of each driver function wrapper.
		// it verifies that we are in a correct state.  if we are in
		// a correct state then it returns TRUE.  if we aren't then
		// it sends an error to the completion object and returns FALSE.
		//
		INntpDriver *GetDriver( INntpComplete * pCompletion ) {
			INntpDriver *pDriver;
			m_lock.ShareLock();
			if (!CheckState()) {
				pDriver = NULL;
			} else {
				pDriver = m_pDriver;
				pDriver->AddRef();
			}
		    m_lock.ShareUnlock();
		    /*
			if (pDriver == NULL) {
			    pCompletion->SetResult(E_UNEXPECTED);
			    pCompletion->Release();
			}*/
			return pDriver;
		}

		INntpDriver *GetDriverHR(HRESULT *phr = NULL) {
			INntpDriver *pDriver;
			m_lock.ShareLock();
			if (!CheckState()) {
				pDriver = NULL;
			} else {
				pDriver = m_pDriver;
				pDriver->AddRef();
			}
		    m_lock.ShareUnlock();
			if (pDriver == NULL && phr != NULL) *phr = E_UNEXPECTED;
			return pDriver;
		}

#ifdef DEBUG
		// pointer to the driver for this vroot
		INntpDriver *m_pDriverBackup;
#endif

		// the metabase object
		IMSAdminBase *m_pMB;

		// the directory that contains this vroot
		char m_szDirectory[MAX_PATH];

		// the length of the directory string
		DWORD m_cchDirectory;

		// pointer to the connection interface for the driver
		INntpDriverPrepare *m_pDriverPrepare;

		// pointer to the driver for this vroot
		INntpDriver *m_pDriver;

		// the current state of the driver
		DRIVERSTATE m_eState;

		// Why is it not connected ?
		DWORD       m_dwWin32Error;

		// this lock is used to lock the driver pointers and the state
		CShareLockNH m_lock;

		// class id for the driver prepare interface
		CLSID m_clsidDriverPrepare;

        // Impersonation token, logged on to access UNC vroots
        HANDLE  m_hImpersonation;

        // Do I handle expiration ?
        BOOL    m_bExpire;

        // What type the vroot is ?
        LOGON_INFO  m_eLogonInfo;

        // is decorate completed ?
        LONG m_lDecCompleted;

	public:
		// the completion object for driver connection
		class CPrepareComplete : public CNntpComplete {
			public:
				CPrepareComplete(CNNTPVRoot *pVR) : 
					CNntpComplete(pVR), m_pDriver(NULL) {}
				~CPrepareComplete();
				INntpDriver *m_pDriver;
		};

		friend class CNntpComplete;
		friend class CNNTPVRoot::CPrepareComplete;

		// the completion object for newstree decoration
		class CDecorateComplete : public CNntpComplete {
			public:
				CDecorateComplete(CNNTPVRoot *pVR) : CNntpComplete(pVR) {}
				~CDecorateComplete();
                void CreateControlGroups( INntpDriver *pDriver );
                void CreateSpecialGroups( INntpDriver *pDriver );
		};

		friend class CNNTPVRoot::CDecorateComplete;
};

//
// we need to do this instead of a typedef so that we can forward declare
// the class in nntpinst.hxx
//
class CNNTPVRootTable : public CIISVRootTable<CNNTPVRoot, INewsTree *> {
	public:
		CNNTPVRootTable(INewsTree *pNewsTree, PFN_VRTABLE_SCAN_NOTIFY pfnNotify) : 
			CIISVRootTable<CNNTPVRoot, INewsTree *>(pNewsTree, pfnNotify) 
		{
		}

        //
        // Block until all the vroots are finished with connect
        //
        BOOL BlockUntilStable( DWORD dwWaitSeconds );

        //
        // check to see if all the vroots are connected
        //
        BOOL AllConnected();

        //
        // Call back function to check if a vroot is in stable state
        //
        static void BlockEnumerateCallback( PVOID pvContext, CVRoot *pVRoot );

        //
        // Call back function to check if a vroot is connected
        //
        static void CheckEnumerateCallback( PVOID pvContext, CVRoot *pVRoot );

        //
        // Call back function to check if vroot newstree decoration is completed
        //
        static void DecCompleteEnumCallback(   PVOID   pvContext, CVRoot  *pVRoot );

        //
        // Get instance wrapper
        //
        class	CNntpServerInstanceWrapperEx *GetInstWrapper() { 
		    return m_pInstWrapper;
		}

		//
		// Get the win32 error code for vroot connection
		//
		DWORD   GetVRootWin32Error( LPWSTR wszVRootPath, PDWORD pdwWin32Error );

		//
		// Initialization
		//
		HRESULT Initialize( LPCSTR pszMBPath, 
		                    class CNntpServerInstanceWrapperEx *pInstWrapper,
		                    BOOL fUpgrade ) {
            m_pInstWrapper = pInstWrapper;
            return CIISVRootTable<CNNTPVRoot, INewsTree*>::Initialize( pszMBPath, fUpgrade );
        }
        
	private:

	    //
	    // Server instance wrapper
	    //
	    class	CNntpServerInstanceWrapperEx *m_pInstWrapper;

};

typedef CRefPtr2<CNNTPVRoot> NNTPVROOTPTR;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\nntp\core\include\nntpret.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    nntpret.h

Abstract:

    This module contains class declarations/definitions for

		CNntpReturn

    **** Overview ****

	This defines an object for setting, passing around, and
	viewing NNTP-style return codes. Each object has a
	return code number and a return code string.

	It is designed to be efficient in the average case by
	not requiring copying or lookup of the most common
	codes (like nrcOK).

	!!! This should eventually be merged with the standard
	Microsoft Message Compiler so that localization would be
	possible.

Author:

    Carl Kadie (CarlK)     29-Oct-1995

Revision History:


--*/

#ifndef	_NNTPRET_H_
#define	_NNTPRET_H_

//
// The maximum size of a nntp return message
//
//	By default we send buffers of 512 characters, so make this
//	constant small enough to fit in that, and leave leg room for 
//	encryption, and other stuff.
//
const DWORD maxCchNntpLine = 400;

//
// The message for when the object as not yet been set.
//

const char szNotSet[] = "<return code not set>";

//
// The return message for when all is OK.
//

const char szOK[] = "All OK";

//
// The return codes. Some of these are defined by the
// NNTP spec.
//

typedef enum {

	nrcHelpFollows						= 100,
	nrcDateFollows						= 111,

	nrcServerReady						= 200,
	nrcServerReadyNoPosts				= 201,
	nrcSlaveStatusNoted					= 202,
	nrcExtensionsFollow					= 202,	// List extension data follows
	nrcModeStreamSupported				= 203,
	nrcGoodBye							= 205,

	nrcGroupSelected					= 211,

	nrcListGroupsFollows				= 215,

	nrcArticleFollows					= 220,
	nrcHeadFollows						= 221,
	nrcBodyFollows						= 222,
	nrcHeadFollowsRequestBody			= 223,	/* what the does this mean ? */
	nrcXoverFollows						= 224,

	nrcNewnewsFollows					= 230,
	nrcNewgroupsFollow					= 231,

	nrcSWantArticle						= 238, 
	nrcSTransferredOK					= 239,
	
	nrcArticleTransferredOK				= 235,
	nrcArticlePostedOK					= 240,

	nrcPostOK							= 340,
	nrcXReplicOK						= 341,
	nrcIHaveOK							= 335,

	nrcPassRequired						= 381,
	nrcLoggedOn							= 281,

	//
	// 4xx - Command was correct, but couldnt be performed for some reason.
	//

	nrcSNotAccepting					= 400,

	nrcNoSuchGroup						= 411,
	nrcNoGroupSelected					= 412,
	nrcNoCurArticle						= 420,
	nrcNoNextArticle					= 421, 
	nrcNoPrevArticle					= 422,
	nrcNoArticleNumber					= 423,
	nrcNoSuchArticle					= 430,
	nrcSTryAgainLater					= 431,
	nrcNotWanted						= 435,
	nrcTransferFailedTryAgain			= 436,
	nrcTransferFailedGiveUp				= 437,
	nrcSAlreadyHaveIt					= 438,
	nrcSArticleRejected					= 439,
	nrcPostingNotAllowed				= 440,
	nrcPostFailed						= 441,
    nrcPostModeratedFailed              = 442,
	nrcLogonFailure						= 451,
	nrcNoMatchesFound					= 460,
	nrcErrorPerformingSearch			= 462,
	nrcLogonRequired					= 480,
	nrcNoListgroupSelected				= 481,

	nrcSupportedProtocols				= 485,

	//
	// 5xx - Problem with command
	//

	nrcNotRecognized					= 500,
	nrcSyntaxError						= 501,
	nrcNoAccess							= 502,
	nrcServerFault						= 503,

	//
	// 6xx - Used here for internal error codes that should never be
	// shown to the outside
	//

	nrcOK								= 600,
	nrcArticleTooManyFieldOccurances	= 602,
	nrcArticleMissingField				= 603,
	nrcArticleBadField					= 604,
	nrcArticleIncompleteHeader			= 605,
	nrcArticleMissingHeader				= 606,
	nrcArticleFieldZeroValues			= 607,
	nrcArticleFieldMessIdNeedsBrack		= 608,
	nrcArticleFieldMissingValue			= 609,
	nrcArticleFieldIllegalNewsgroup		= 610,
	nrcArticleTooManyFields				= 611,
	nrcMemAllocationFailed				= 612,
	nrcArticleFieldMessIdTooLong		= 613,
	nrcErrorReadingReg					= 614,
	nrcArticleDupMessID					= 615,
	nrcArticleMappingFailed				= 616,
	nrcArticleAddLineBadEnding			= 617,
	nrcPathLoop							= 618,
	nrcArticleInitFailed				= 619,
	nrcNewsgroupInsertFailed			= 620,
	nrcNewsgroupAddRefToFailed			= 621,
	nrcHashSetArtNumSetFailed			= 622,
	nrcHashSetXrefFailed				= 623,
	nrcOpenFile							= 624,
	nrcArticleBadFieldFollowChar		= 625,
	nrcArticleBadChar					= 626,
	nrcDuplicateComponents				= 627,
	nrcArticleFieldIllegalComponent		= 628,
	nrcArticleBadMessageID				= 629,
	nrcArticleFieldBadChar				= 630,
	nrcArticleFieldDateIllegalValue		= 631,
	nrcArticleFieldDate4DigitYear		= 632,
	nrcArticleFieldAddressBad			= 633,
	nrcArticleXoverTooBig				= 634,
	nrcCreateNovEntryFailed				= 635,
	nrcArticleXrefBadHub				= 637,
	nrcArticleNoSuchGroups				= 638,
	nrcHashSetFailed					= 639,
	nrcArticleTableCantDel				= 640,
	nrcArticleTableError				= 641,
	nrcArticleTableDup					= 642,
	nrcCantAddToQueue					= 643,
	nrcSlaveGroupMissing				= 644,
	nrcInconsistentMasterIds			= 645,
	nrcInconsistentXref					= 646,
	nrcArticleDateTooOld				= 647,
	nrcArticleTooLarge					= 648,
    nrcIllegalControlMessage            = 649,
    nrcNotYetImplemented                = 650,
    nrcControlNewsgroupMissing          = 651,
    nrcBadNewsgroupNameLen              = 652,
    nrcNewsgroupDescriptionTooLong      = 653,
    nrcCreateNewsgroupFailed            = 654,
    nrcGetGroupFailed                   = 655,
    nrcControlMessagesNotAllowed        = 656,
	nrcHeaderTooLarge					= 657,
	nrcServerEventCancelledPost			= 658,

	nrcMsgIDInHistory					= 660,
	nrcMsgIDInArticle					= 661,
	nrcSystemHeaderPresent				= 662,

	//
	// Special value
	//

	nrcNotSet							= -1

} NNTP_RETURN_CODE;

// this macro takes an NNTP return code and checks to see if its an error
// code.  
#define NNTPRET_IS_ERROR(__dwErrorCode__) (__dwErrorCode__ >= 400 && __dwErrorCode__ < 600)

typedef NNTP_RETURN_CODE NRC;

//
//	Gets the NNTP Return code from a string. used for newnews feeds.
//

BOOL	ResultCode(
				   char*	szCode,
				   NRC&	nrcOut
				   ) ;

//
//
//
// CNntpReturn - class a return code (and message) object.
//

class CNntpReturn
{
public:

	//
	// Constructor
	//

	CNntpReturn(void) :
		  m_nrc(nrcNotSet),
		  m_sz(szNotSet)
		  {}

	//
	// Set the record code, while giving arguments to the message.
	//

	BOOL fSet(
			NRC nrc,
			...
			);

	//
	// fSetEx is a faster version of fSet (it lazy evaluates the
	// _vsnprintf that is in fSet).  This can _only_ be used if it
	// can be guaranteed that szArg is a string literal or a global
	// with an unchanging value (it saves this pointer).
	//
	BOOL fSetEx(
			NRC nrc,
			char const *szArg);

	//
	// Test if object is clear of if it has been set
	//

	BOOL fIsClear(void){
			return nrcNotSet == m_nrc;
			}

	//
	// Test if the object has the value nrcOK
	//

	BOOL fIsOK(void){
			_ASSERT(!fIsClear());
			return nrcOK == m_nrc;
			}

	//
	// Test if the object has any specified return code.
	//

	BOOL fIs(NRC nrc){
		return nrc == m_nrc;
		}

	//
	// Return FALSE while asserting that the return code is not OK.
	//

	BOOL fFalse(void){
		_ASSERT(!fIsOK());
		return FALSE;
		}

	//
	// Set the return code to be OK
	//

	BOOL fSetOK(void);

	//
	// Set the return code not to be set.
	//

	BOOL fSetClear(void);

	//
	// The return code
	//

	NNTP_RETURN_CODE	m_nrc;

	//
	// get the return string
	const char *szReturn();

protected:

	//
	// Format the message with the arguments given by fSet
	//

	void vSzFormat(char const * & szFormat, BOOL &fHasFormatCodes);

	//
	// The buffer used to hold message when necessary.
	//

	char	m_szBuf[maxCchNntpLine];

	//
	// The return message.  if this is set to NULL then we are in lazy
	// evaluation mode, and nrc and m_szArg should be used to build
	// m_sz only when it is required
	//

	char	const *		m_sz;

	//
	// the argument for lazy evaluation where the only argument is %s
	//
	char	const *		m_szArg;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\nntp\core\include\pcparse.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    pcparse.h

Abstract:

    This module contains class declarations/definitions for

		CPCParse

    **** Overview ****

	This defines an object for parsing RFC1036 items,
	specifically the From: and related lines. It works
	by treating each grammer rule as a function.

Author:

    Carl Kadie (CarlK)     29-Oct-1995

Revision History:


--*/

#ifndef	_PCPARSE_H_
#define	_PCPARSE_H_

//
// forward class def
//

class CPCParse;

//
//
//
// CPCParse - Parse a CPCString.
//

class CPCParse : public CPCString {
public :

	//
	// Constructor -- no string yet.
	//

	CPCParse(void)
		{ numPCParse++; };

	//
	// Constructor -- give pointer to string and length.
	//

	CPCParse(char * pch, DWORD cch):
		CPCString(pch, cch)
		{ numPCParse++; }

	~CPCParse() { numPCParse--; }

	//
	// Implement this grammer rule:
	//  From-content  = address [ space "(" paren-phrase ")" ] EOL
    //         /  [ plain-phrase space ] "<" address ">" EOL
    //

	BOOL fFromContent(void);


protected:

    //
    // address       = local-part "@" domain
	//      OR JUST  local-part
	// !!!X LATER - do we want a flag that tells if just local-part is acceptable?
	//

	BOOL fAddress(void);
	BOOL fStrictAddress(void);

	//
	// These functions accept one or more of tokens
	//

	BOOL fAtLeast1QuotedChar(void);
	BOOL fAtLeast1UnquotedChar(void);
	BOOL fAtLeast1UnquotedDotChar(void);
	BOOL fAtLeast1Space(void);
	BOOL fAtLeast1ParenChar(void);
	BOOL fAtLeast1CodeChar(void);
	BOOL fAtLeast1TagChar(void);
	BOOL fAtLeast1QuotedCharOrSpace(void);

    //
    // unquoted-word = 1*unquoted-char
    //

	BOOL fUnquotedWord(BOOL fAllowDots=FALSE)	{
			if( !fAllowDots )
				return fAtLeast1UnquotedChar();
			else
				return	fAtLeast1UnquotedDotChar() ;
			};


   //
   // quoted-word   = quote 1*( quoted-char / space ) quote
   //

	BOOL fQuotedWord(void);

	//
	// local-part    = unquoted-word *( "." unquoted-word )
	//

	BOOL fLocalPart(void);

	//
	//  domain        = unquoted-word *( "." unquoted-word )
	//

	BOOL fDomain(void) {
			return fLocalPart();
			}

    //
    // plain-word    = unquoted-word / quoted-word / encoded-word
    //

	BOOL fPlainWord(void) {
			return fUnquotedWord(TRUE) || fQuotedWord() || fEncodedWord();
			};

    //
    // plain-phrase  = plain-word *( space plain-word )
    //

	BOOL fPlainPhrase(void);

	//
	// one or more spaces (including tabs) or newlines
	//

	BOOL fSpace(void) {
			return fAtLeast1Space();
			};

    //
    // paren-char    = <ASCII printable character except ()<>\>
    //

	BOOL fParenChar(void);

	//
	// paren-phrase  = 1*( paren-char / space / encoded-word )
	//

	BOOL fParenPhrase(void);


	//
	// code-char     = <ASCII printable character except ?>
	// codes         = 1*code-char
	//

	BOOL fCodes(void)	{
			return fAtLeast1CodeChar();
			};

	//
	//  charset       = 1*tag-char
	//

	BOOL fCharset(void)		{
			return fAtLeast1TagChar();
			};

	//
	//   encoding      = 1*tag-char
	//

	BOOL fEncoding(void)	{
			return fCharset();
			};

	//
	//  encoded-word  = "=?" charset "?" encoding "?" codes "?="
	//

	BOOL fEncodedWord(void);

    //
    //  Looks at current char to see if it matches ch.
    //  Does not advance current ptr.
    //

    BOOL fIsChar(char ch);

	//
	// Parses a single character class
	//

	BOOL fParseSingleChar(char ch);

	//
	//  quoted-char   = <ASCII printable character except "()<>\>
	//

	BOOL fQuotedCharTest(char ch) {
			return isgraph((UCHAR)ch) && !fCharInSet(ch, "\"()<>\\");
			};

	//
	//  paren-char    = <ASCII printable character except ()<>\>
	//

	BOOL fParenCharTest(char ch) {

			// bugbug ... isgraph rejects spaces - which we want to include !
			return (isgraph((UCHAR)ch) || ch == ' ') && !fCharInSet(ch, "()<>\\");
			};

	//
	// unquoted-char = <ASCII printable character except !()<>@,;:\".[]>
	// bugbug: isgraph rejects spaces - this rejects certain from: headers
	// that INN accepts against the RFC.
	//

	BOOL fUnquotedCharTest(char ch) {
			return isgraph((UCHAR)ch) && !fCharInSet(ch, "!()<>@,;:\\\".[]");
			};

	//
	// unquoted-dot-char = <ASCII printable character except !()<>@,;:\"[]>
	//

	BOOL fUnquotedDotCharTest(char ch) {
			return isgraph((UCHAR)ch) && !fCharInSet(ch, "()<>@\\\"[]");
			};

	//
	// quoted-char / space
	//

	BOOL fQuotedCharOrSpaceTest(char ch) {
			return (fSpaceTest(ch) || fQuotedCharTest(ch));
			};

	BOOL fSpaceTest(char ch) {
			return fCharInSet((UCHAR)ch, " \t\n\r");
			};

	//
	// code-char     = <ASCII printable character except ?>
	//

	BOOL fCodeCharTest(char ch) {
			return isgraph((UCHAR)ch) && (ch != '?');
			};

	//
	// tag-char      = <ASCII printable character except !()<>@,;:\"[]/?=>
	//

	BOOL fTagCharTest(char ch) {
			return isgraph((UCHAR)ch) && !fCharInSet(ch, "!()<>@,;:\\\"[]/?=");
			};

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\nntp\core\include\parse.h ===
#ifndef __PARSE_H__
#define __PARSE_H__

#include <windows.h>

//
// this type is used to convert headers (in XPAT and NNTP SEARCH) and
// search keys (in NNTP SEARCH) into the appopriate Tripoli query strings.
//
typedef const struct SKEY_INFO_st {
	char *pszSearchKey;					// the HEADER name or IMAP search key
	char *pszPropertyName;				// the corresponding property name
										//   for the index server.  this should
										//   include the relationship operator
	char *pszRegexName;					// just like pszPropertyName, used for
										// regular expressions (will be NULL
										//   for search keys)
	DWORD eOperandType;					// the type of operand
	BOOL fSpecifiedNewsgroup;			// if this is TRUE then this header
										//   specifies a newsgroup
} SKEY_INFO;

typedef const struct MONTH_INFO_st MONTH_INFO;

//
// This is the base class which all translator's inherit from
//
class CQueryLanguageTranslator {
	public:
		//
		// Translate the input language (which must be in 7-bit ASCII) into
		// the Index Server's language (in Unicode).
		//
		// Returns a BOOL and GetLastError() style error code
		//
		virtual BOOL Translate(
			char *pszStatement, 		// the query statement
			char *pszCurrentNewsgroup,	// the currently selected group
			WCHAR *pwszOutput,			// a buffer to write the result into
			DWORD cOutput) = 0;			// the size of that buffer
	protected:
		//
		// make sure that a string only contains numeric digits
		//
		BOOL IsNumber(char *pszString);

		//
		// find information about a search key.  returns NULL on error
		//
		// EC is ERROR_FILE_NOT_FOUND if search key doesn't exist
		//
		SKEY_INFO *GetSearchKeyInfo(char *pszSearchKey, DWORD cSKInfo,
			SKEY_INFO *pSKInfo);

		//
		// add text to the output string.  at start *pcOutput is the number
		// of bytes in *ppwszOutput, at exit its the number of bytes remaining
		// after adding pszText.
		//
		BOOL WriteOutput(char *pszText, WCHAR **ppwszOutput, DWORD *pcOutput);

		//
		// add text to the output string.  at start *pcOutput is the number
		// of bytes in *ppwszOutput, at exit its the number of bytes remaining
		// after adding pszText.
		//
		// the source string is encoded in MIME-2 format.  output is written
		// in Unicode
		//
		BOOL WriteOutputM2(char *pszM2String, WCHAR **ppwszOutput,
			DWORD *pcOutput);

		//
		// move ppszStatement to point past characters found in pszSkiplist
		//
		// EC is ERROR_INVALID_DATA if the end of the string is reached
		//
		BOOL SkipChars(char **ppszStatement, char *pszSkiplist,
			BOOL fEndOfStringOkay = FALSE);

		//
		// get bytes in ppszStatement until we get to a character in the
		// endlist.  pchEndChar will get a copy of the end character that
		// was found.  ppszStatement will point one character past the end
		// character.
		//
		// EC is ERROR_INVALID_DATA if the end of the string is reached
		//
		char *GetCharsTill(char **ppszStatement, char *pszEndlist,
			BOOL fEndOfStringOkay = TRUE, char *pchEndChar = NULL);

		//
		// NULL terminated list of searchable HEADERs
		//
		static SKEY_INFO m_rgHeaders[];
		//
		// number of headers in the above list
		//
		static const DWORD m_cHeaders;

		//
		// translates a number from IMAP form to IS form
		//
		BOOL TranslateNumber(char **ppszStatement, WCHAR **ppwszOutput,
			DWORD *pcOutput);

		//
		// translates an IMAP AString from IMAP to IS query language
		//
		BOOL TranslateAString(char **ppszStatement, WCHAR **ppwszOutput,
			DWORD *pcOutput);

		//
		// NULL terminated table to convert IMAP months to IS months
		//
		static MONTH_INFO m_rgMonthTable[];

		//
		// gets and translates a date from a statement.  converts it
		// to Indexing Server's notation from the IMAP notation
		//
		BOOL TranslateDate(char **ppszStatement, WCHAR **ppwszOutput,
			DWORD *pcOutput);

		BOOL TranslateDateDay(char *pszField, char **ppszStatement,
			WCHAR **ppwszOutput, DWORD *pcOutput);

		//
		// he needs to get to the searchable headers
		//
		friend char *GetSearchHeader(DWORD iIndex);
};

//
// this class converts
//
class CXpatTranslator : public CQueryLanguageTranslator {
	public:
		//
		// translate an XPAT query into Tripoli
		//
		virtual BOOL Translate(
			char *pszStatement, 		// the query statement
			char *pszCurrentNewsgroup,	// the currently selected group
			WCHAR *pwszOutput,			// a buffer to write the result into
			DWORD cOutput);				// the size of that buffer

		DWORD GetLowArticleID(void) { return m_iLowArticleID; }
		DWORD GetHighArticleID(void) { return m_iHighArticleID; }
	private:
		//
		// currently Tripoli and our mime filter don't index the article
		// id.  using these methods the caller can figure out which article
		// ids the client was interested in and filter them out.
		//
#define ARTICLEID_INFINITE (DWORD) -1
		DWORD m_iLowArticleID;
		DWORD m_iHighArticleID;

};

//
// this class converts the NNTP SEARCH command into a Tripoli query
//
class CNntpSearchTranslator : public CQueryLanguageTranslator {
	public:
		//
		// translate from the IMAP/NNTP query language to the Indexing
		// Server's query language
		//
		// input is in 7-bit ASCII, output is in Unicode
		//
		virtual BOOL Translate(char *pszStatement, char *pszCurrentNewsgroup,
			WCHAR *pwszOutput, DWORD cOutput);
	private:
		//
		// translate a search key from the input statement.  the part to
		// start translating is passed in via ppszStatement.  this will
		// be updated to point past the part that has been translated.  it
		// point to a 0 byte string if there is nothing left to parse
		//
		BOOL TranslateSearchKey(char **ppszStatement, WCHAR **ppwszOutput,
			DWORD *pcOutput);

		//
		// translate an OR search key from the input statement.
		// *ppszStatement starts pointing after the OR, returns pointing
		// after the operands of the OR.
		//
		BOOL TranslateOR(char **ppszStatement, WCHAR **ppwszOutput, DWORD *pcOutput);

		//
		// translate a parenthesized list of terms to be anded from the
		// input statement
		//
		// *ppszStatement should point at the open paren.  when done it will
		// point to the character after the closing paren
		//
		BOOL TranslateAndList(char **ppszStatement, WCHAR **ppwszOutput,
			DWORD *pcOutput);

		//
		// translate newsgroup info in the form IN alt.*,comp.* to IS
		//
		BOOL TranslateIN(char **ppszStatement, WCHAR **ppwszOutput,
			DWORD *pcOutput);

		//
		// NULL terminated list of search keys
		//
		static SKEY_INFO m_rgSearchKeys[];

		//
		// the current newsgroup
		//
		char *m_pszNewsgroup;
		//
		// was a group ever specified?
		//
		BOOL m_fSpecifiedNewsgroup;
		//
		// should the current term be anded with the last?
		//
		BOOL m_fAndWithLast;
};

//
// returns the ith searchd header.  NULL if past limit
//
char *GetSearchHeader(DWORD iIndex);

// possible error codes
#define ERROR_SEARCH_P_BASE 				0xe0150000
// internal error (shouldn't ever occur)
#define ERROR_SEARCH_P_INTERNAL				ERROR_SEARCH_P_BASE + 0
// general syntax error
#define ERROR_SEARCH_P_SYNTAX_ERROR			ERROR_SEARCH_P_BASE + 1
// requires newsgroup
#define ERROR_SEARCH_P_NO_GROUP				ERROR_SEARCH_P_BASE + 2
// unsupported key/header passed in
#define ERROR_SEARCH_P_UNSUPPORTED_KEY		ERROR_SEARCH_P_BASE + 3

//
// the index server's words and special characters
//
#define IS_AND " & "
#define IS_OR " | "
#define IS_QUOTE "\""
#define IS_OPEN_PAREN "("
#define IS_CLOSE_PAREN ")"
#define IS_OPERATOR_GE ">="
#define IS_OPERATOR_LE "<="
#define IS_OPERATOR_EQ "="
#define IS_SPACE " "
#define IS_ARTICLE_ID "@NewsArticleID"
#define IS_MESSAGE_ID "@NewsMsgID"
#define IS_NEWSGROUP "@Newsgroups"
#define IS_NEWSGROUP_WILDMAT "#Newsgroups"
#define IS_REGEX "#"
#define IS_REGEX_CHAR '#'
#define IS_WILDMAT "*"
#define IS_ARTICLE_ID_EQ IS_ARTICLE_ID IS_OPERATOR_EQ
#define IS_ARTICLE_ID_LE IS_ARTICLE_ID IS_OPERATOR_LE
#define IS_ARTICLE_ID_GE IS_ARTICLE_ID IS_OPERATOR_GE
#define IS_MESSAGE_ID_EQ IS_MESSAGE_ID IS_SPACE
#define IS_NEWSGROUP_EQ IS_NEWSGROUP IS_SPACE

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\nntp\core\include\propbag.h ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

	propbag.h

Abstract:

	This module contains the definition of the property bag class.  
	Property bag is a dynamically extendable container for different
	types of properties.  

Author:

	Kangrong Yan ( KangYan )
	
Revision History:

	kangyan	05/31/98	created

--*/
#if !defined( _PROPBAG_H_ )
#define _PROPBAG_H_
#include <windows.h>
#include <dbgtrace.h>
#include <fhashex.h>
#include <unknwn.h>
#include <rwnew.h>
#include <stdio.h>
#include <xmemwrpr.h>

// Data object used for property hash table
class CProperty { // pr
public:

	CProperty() 
	{
		m_pNext = NULL;
		m_dwPropId = 0;

		ZeroMemory( &m_prop, sizeof( DATA ) );
		m_type = Invalid;

		m_cbProp = 0;
	}
	
	~CProperty() {
		if ( m_type == Blob ) {
			_ASSERT( m_cbProp > 0 );
			_ASSERT( m_prop.pbProp );
			XDELETE[] m_prop.pbProp;
		}
	}

	VOID
	Validate()
	{
		if ( Bool == m_type ) {
			if ( TRUE != m_prop.bProp && FALSE != m_prop.bProp )
			_ASSERT( FALSE );
		}

		if ( Blob == m_type ) {
			_ASSERT( NULL != m_prop.pbProp );
			_ASSERT( m_cbProp > 0 );
		}

		if ( Interface == m_type ) {
			_ASSERT ( NULL != m_prop.punkProp );
		}
	}
	
    CProperty *m_pNext;
    DWORD GetKey() { return m_dwPropId; }
    int MatchKey( DWORD dwOther ) { return ( dwOther == m_dwPropId ); }
    static DWORD HashFunc( DWORD k ) { return k; }

    DWORD m_dwPropId;
    union DATA {
        DWORD   	dwProp;
        BOOL    	bProp;
        IUnknown *	punkProp;
        PBYTE   	pbProp;
    } m_prop;
    enum TYPE {
    	Invalid = 0,
        Dword,
        Bool,
        Blob,
        Interface
    } m_type;
    DWORD m_cbProp;	// in case of BLOB
};

typedef TFHashEx< CProperty, DWORD, DWORD >  PROPERTYTABLE ;	//pt

// Class CPropBag
class CPropBag {	//bg
public:
	CPropBag( int cInitialSize = 16, int cIncrement = 8);
	~CPropBag();
	
	HRESULT PutDWord( DWORD dwPropId, DWORD dwVal );
	HRESULT GetDWord( DWORD dwPropId, PDWORD pdwVal );
	HRESULT PutBool( DWORD dwPropId, BOOL bVal );
	HRESULT GetBool( DWORD dwPropId, PBOOL pbVal );
	HRESULT PutBLOB( DWORD dwPropId, PBYTE pbVal, DWORD cbVal );
	HRESULT GetBLOB( DWORD dwPropId, PBYTE pbVal, PDWORD pcbVal );
	HRESULT PutInterface( DWORD dwPropId, IUnknown *punkVal ) { return E_NOTIMPL; }
	HRESULT GetInterface( DWORD dwPropId, IUnknown **ppunkVal ) { return E_NOTIMPL; }
	HRESULT RemoveProperty( DWORD dwPropId );
	VOID Validate() { 
#ifdef DEBUG
	    m_Lock.ShareLock();
		_ASSERT( m_ptTable.IsValid( TRUE ) );
		m_Lock.ShareUnlock();
#endif
	}
		
private:
	PROPERTYTABLE	m_ptTable;
	CShareLockNH    m_Lock; // synchronize reads / writes
	HRESULT         m_hr;   // reflects the property bag status
};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\nntp\core\include\smtpdll.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    fpost.h

Abstract:

	Definitions of the fPost interface

Author:

    Rajeev Rajan (RajeevR)     17-May-1996

Revision History:

--*/

#ifndef _SMTPDLL_H_
#define _SMTPDLL_H_

// Initialize the moderated provider interface
BOOL InitModeratedProvider();

// Terminate the moderated provider interface
BOOL TerminateModeratedProvider();

// Signal a change in the SMTP server
VOID SignalSmtpServerChange();

// Post an article to the moderator
BOOL fPostArticleEx(
		IN HANDLE	hFile,
        IN LPSTR	lpFileName,
		IN DWORD	dwOffset,
		IN DWORD	dwLength,
		IN char*	pchHead,
		IN DWORD	cbHead,
		IN char*	pchBody,
		IN DWORD	cbBody,
		IN LPSTR	lpModerator,
		IN LPSTR	lpSmtpAddress,
		IN DWORD	cbAddressSize,
		IN LPSTR	lpTempDirectory,
		IN LPSTR	lpFrom,
		IN DWORD	cbFrom
		);

// Post an article via SMTP persistent connection interface
BOOL fPostArticle(
		IN HANDLE	hFile,
		IN DWORD	dwOffset,
		IN DWORD	dwLength,
		IN char*	pchHead,
		IN DWORD	cbHead,
		IN char*	pchBody,
		IN DWORD	cbBody,
		IN LPSTR	lpModerator,
		IN LPSTR	lpSmtpAddress,
		IN DWORD	cbAddressSize,
		IN LPSTR	lpFrom,
		IN DWORD	cbFrom
		);

#endif	// _SMTPDLL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\nntp\core\include\nwstree.h ===
#ifndef _NWSTREE_H_
#define _NWSTREE_H_

#include        "nntpvr.h"
#include        "group.h"
#include        "fhashex.h"
#include        "fhash.h"
#include        "rwnew.h"
#include        "fixprop.h"
#include        "flatfile.h"

class CNewsTreeCore;

typedef TFHashEx<CNewsGroupCore, LPSTR, LPSTR> CHASHLPSTR;
typedef TFHashEx<CNewsGroupCore, GROUPID, GROUPID> CHASHGROUPID;

#define FIRST_RESERVED_GROUPID  1
#define LAST_RESERVED_GROUPID   256
#define FIRST_GROUPID                   257
#define MAX_HIGHMARK_GAP                100000

//
//      The CGroupIterator object is used to enumerate all newsgroups which match a specified pattern.
//
//      The CGroupIterator object is given an array of strings which contain 'wildmat' strings as specified
//      in RFC 977 for NNTP.
//      wildmat strings have the following pattern matching elements :
//              Range of characters ie:  com[p-z]
//              Asterisk ie:    comp.*   (matches all newsgroups descended from 'comp')
//              Negations ie:   !comp.*  (excludes all newsgroups descended from 'comp' )
//
//      The CGroupIterator will implement these semantics in the following way :
//
//              All newsgroups are held in the CNewsTree object in a doubly linked list in alphabetical order.
//              The CGroupIterator will hold onto a CRefPtr<> for the current newsgroup.
//              Because the CNewsGroup objects are reference counted, the current newsgroup can never be destroyed from
//              underneath the iterator.
//
//              When the user calls the Iterator's Next() or Prev() functions, we will simply follow next pointers
//              untill we find another newsgroup which matches the pattern and to which the user has access.
//
//              In order to determine whether the any given newsgroup matches the specified pattern, we will use the
//              wildmat() function that is part of the INN source.  We will have to call the wildmat() function for each
//              pattern string until we get a succesfull match.
//

class   CGroupIteratorCore : public INewsTreeIterator {
protected:
        CNewsTreeCore*  m_pTree ;                               // The newstree on which to iterate !
        LONG                    m_cRef;
        LPMULTISZ               m_multiszPatterns ;
        BOOL                    m_fIncludeSpecial ;

        CGRPCOREPTR             m_pCurrentGroup ;
        //
        //      Both m_fPastEnd and m_fPastBegin will be true if the list is empty !!
        //
        BOOL                    m_fPastEnd ;    // User advanced past the end of the list !!
        BOOL                    m_fPastBegin ;  // User advanced past beginning of list !!
        

        //
        //      Only the CNewsTreeCore Class can create CGroupIterator objects.
        //
        friend  class   CNewsTreeCore ;
        //
        //      Constructor
        //      
        //      The CGroupIterator constructor does no memory allocation - all of the arguments
        //      passed are allocated by the caller.  CGroupIterator will destroy the arguments within
        //      its destructor.
        //
        CGroupIteratorCore(     
                                CNewsTreeCore*  pTree,
                                LPMULTISZ               lpPatterns, 
                                CGRPCOREPTR&    pFirst, 
                                BOOL                    fIncludeSpecial
                                ) ;

        CGroupIteratorCore( 
                                CNewsTreeCore   *pTree,
                                CGRPCOREPTR             &pFirst
                                ) ;             

        void    NextInternal() ;

public :
        //
        //      Destructor
        //
        //      We will release all the objects passed to our constructor in here.
        //
        virtual ~CGroupIteratorCore( ) ;

        BOOL                    __stdcall IsBegin() ;
        BOOL                    __stdcall IsEnd() ;

        CGRPCOREPTRHASREF Current() { return (CNewsGroupCore *)m_pCurrentGroup; }

        HRESULT __stdcall Current(INNTPPropertyBag **ppGroup, INntpComplete *pProtocolComplete = NULL );
        
        // these can be overridden so that the server can do security checking
        // on groups while iterating
        virtual void    __stdcall Next() ;
        virtual void    __stdcall Prev() ;

    //
    // Implementation of IUnknown
    //
    HRESULT __stdcall QueryInterface( const IID& iid, VOID** ppv )
    {
        if ( iid == IID_IUnknown ) {
            *ppv = static_cast<IUnknown*>(this);
        } else if ( iid == IID_INewsTreeIterator ) {
            *ppv = static_cast<INewsTreeIterator*>(this);
        } else {
            *ppv = NULL;
            return E_NOINTERFACE;
        }
        reinterpret_cast<IUnknown*>(*ppv)->AddRef();
        return S_OK;
    }

    ULONG __stdcall AddRef()
    {
        return InterlockedIncrement( &m_cRef );
    }

    ULONG __stdcall Release()
    {
                ULONG x = InterlockedDecrement(&m_cRef);
        if ( x == 0 ) XDELETE this;
        return x;
    }
} ;

class   CNewsCompare    {
public :
    virtual BOOL    IsMatch( CNewsGroupCore * ) = 0 ;
    virtual DWORD   ComputeHash( ) = 0 ;
} ;

class   CNewsCompareId : public CNewsCompare    {
private :
    GROUPID m_id ;
public :
    CNewsCompareId( GROUPID ) ;
    CNewsCompareId( CNewsGroupCore * ) ;
    int     IsMatch( CNewsGroupCore * ) ;
    DWORD   ComputeHash( ) ;
} ;

class   CNewsCompareName : public   CNewsCompare    {
private :
    LPSTR   m_lpstr ;
public :
    CNewsCompareName( LPSTR ) ;
    CNewsCompareName( CNewsGroupCore * ) ;
    BOOL    IsMatch( CNewsGroupCore * ) ;
    DWORD   ComputeHash( ) ;
} ;

//
// this class implements the COM wrapper for CNewsTreeCore
//
class CINewsTree : public INewsTree
{
private:
    //
    // Pointer to the newsgroup object
    //
    CNewsTreeCore* m_pParentTree;

    //
    // Reference counting
    //
    LONG   m_cRef;

public:
    //
    // Constructors
    //
    CINewsTree(CNewsTreeCore *pParent = NULL) {
        m_pParentTree = pParent;
        m_cRef = 0;
    }

        HRESULT Init(CNewsTreeCore *pParent) {
        m_pParentTree = pParent;
                return S_OK;
        }

        CNewsTreeCore *GetTree() {
                return m_pParentTree;
        }


// INNTPPropertyBag
public:
        //
        // given a group ID find the matching group
        //
        HRESULT __stdcall FindGroupByID(
                DWORD                           dwGroupID,
                INNTPPropertyBag        **ppNewsgroupProps,
                INntpComplete       *pProtocolComplete = NULL           );

        // 
        // given a group name find the matching group.  if the group doesn't
        // exist and fCreateIfNotExist is set then a new group will be created.
        // the new group won't be available until CommitGroup() is called.
        // if the group is Release'd before CommitGroup was called then it
        // won't be added.
        //
        HRESULT __stdcall FindOrCreateGroupByName(
                LPSTR                           pszGroupName,
                BOOL                            fCreateIfNotExist,
                INNTPPropertyBag        **ppNewsgroupProps,
                INntpComplete       *pProtocolComplete = NULL,
                GROUPID             groupid = 0xffffffff,
                BOOL                fSetGroupId = FALSE
                );

        //
        // add a new group to the newstree
        //
        HRESULT __stdcall CommitGroup(INNTPPropertyBag *pNewsgroupProps);

        //
        // remove an entry
        //
        HRESULT __stdcall RemoveGroupByID(DWORD dwGroupID);
        HRESULT __stdcall RemoveGroupByName(LPSTR pszGroupName, LPVOID lpContext);


        //
        // enumerate across the list of keys.  
        //
        HRESULT __stdcall GetIterator(INewsTreeIterator **pIterator);

        //
        // get a pointer to the owning server object
        //
        HRESULT __stdcall GetNntpServer(INntpServer **ppNntpServer);

        //
        // this function will be used by drivers to make sure that they
        // are adding newsgroups that they properly own.
        //
        HRESULT __stdcall LookupVRoot(LPSTR pszGroup, INntpDriver **ppDriver);

    //
    // Implementation of IUnknown
    //
    HRESULT __stdcall QueryInterface( const IID& iid, VOID** ppv )
    {
        if ( iid == IID_IUnknown ) {
            *ppv = static_cast<IUnknown*>(this);
        } else if ( iid == IID_INewsTree ) {
            *ppv = static_cast<INewsTree*>(this);
        } else {
            *ppv = NULL;
            return E_NOINTERFACE;
        }
        reinterpret_cast<IUnknown*>(*ppv)->AddRef();
        return S_OK;
    }

    ULONG __stdcall AddRef()
    {
        return InterlockedIncrement( &m_cRef );
    }

    ULONG __stdcall Release()
    {
        if ( InterlockedDecrement( &m_cRef ) == 0 ) {
            _ASSERT( 0 );
        }

        return m_cRef;
    }
};

//-----------------------------------------------------------
//
// This class is used to find CNewsGroup objects.   There should only
// ever exist one object of this class.
//
// Group's can be found through two means :
//   1) Use the name of the group as it appears in an article
//       2) Using a Group ID number
//
// Group ID Numbers are used in Article Links.  A link from one article to another
// will contain a Group ID Number and Article Number to represent the link.
//
// We will maintain a Hash Table to find CNewsGroup objects based on newsgroup name.
// We will also maintain a Hash Table to find CNewsGroup objects based on Group ID.
//
// Finally, we will maintain a doubly linked list of CNewsGroups which is sorted by
//      name.  This linked list will be used to support pattern matching iterators.
//
class   CNewsTreeCore   {
protected :
        friend  class   CGroupIteratorCore;
        // this guy removes itself from the list of newsgroups
        friend  CNewsGroupCore::~CNewsGroupCore();
        friend  CNewsGroupCore::ComputeXoverCacheDir(   char* szPath, BOOL &fFlatDir, BOOL ) ;

        friend  VOID DbgPrintNewstree(CNewsTreeCore* ptree, DWORD nGroups);
        friend class CNNTPVRoot::CPrepareComplete;
        friend class CNNTPVRoot::CDecorateComplete;

        //
        // Instance wrapper to access instance stuff
        //
        CNntpServerInstanceWrapperEx *m_pInstWrapper;

        //
        //      C++ WARNING -- m_LockTables and m_LockHelpText are declared FIRST because
        //      we want them to be destroyed LAST (C++ says that members are destroyed in the
        //      reverse order they appear in the class declaration.)
        //
        //
        //      Reader/Writer lock for accessing hash tables
        //
        CShareLockNH m_LockTables;

        CINewsTree m_inewstree;

        //
        //      The first GROUPID reserved for 'special' newsgroups
        //      speciall == not visible to clients
        //
        GROUPID m_idStartSpecial;

        //
        //      The last GROUPID reserved for 'special' newsgroups
        //
        GROUPID m_idLastSpecial;

        //
        //      The GROUPID     reserved for 'slaves' to hold postings untill sent to the master
        //
        GROUPID m_idSlaveGroup;

        //
        //      The highest 'sepcial' GROUPID seen to date !
        //
        GROUPID m_idSpecialHigh;

        //
        //      The first GROUPID for use for newsgroups
        //      (must be larger than m_idLastSpecial)
        //
        GROUPID m_idStart;
        
        //
        //      The highest GROUPID we have to date 
        //
        GROUPID m_idHigh;

        //
        //      Newsgroups hashed by their name
        //
        CHASHLPSTR m_HashNames;

        //
        //      Newsgroups heashed by their ID
        //
        CHASHGROUPID m_HashGroupId;

        //
        //      Start of alphabetically sorted linked list !
        //
    CNewsGroupCore *m_pFirst;

        //
        //      Tail of alphabetically sorted linked list of newsgroups
        //
    CNewsGroupCore *m_pLast;
        
        //
        //      Number of newsgroups
        //
    int m_cGroups;

        //
        // Number of changes to the list of newsgroups since last visit
        //
        long m_cDeltas; 

        // 
        // our vroot table
        //
        CNNTPVRootTable *m_pVRTable;

        // 
        // the tree is stopping?
        //
        BOOL m_fStoppingTree;

        // 
        // should we reject invalid group names?
        //
        BOOL m_fRejectGenomeGroups;

        //
        // the file that we saved fixed size properties into
        //
        CFixPropPersist *m_pFixedPropsFile;

        //
        // the file that we saved variable sized properties into
        //
        CFlatFile *m_pVarPropsFile;

        //
        // pointer to the server object which we will pass into drivers
        //
        INntpServer *m_pServerObject;

        //
        // has the vroot table been initialized yet?
        //
        BOOL m_fVRTableInit;

        //
        //      Linked list manipulation functions
        //
    void InsertList(CNewsGroupCore *pGroup, CNewsGroupCore *pParent);
        void AppendList(CNewsGroupCore *pGroup);
    void RemoveList(CNewsGroupCore *pGroup);

        //
        //      These functions handle inserts into all lists and hash tables simultaneously !
        //
        BOOL Append(CNewsGroupCore      *pGroup);
    BOOL Insert(CNewsGroupCore *pGroup, CNewsGroupCore *pParent = NULL);
    BOOL InsertEx(CNewsGroupCore *pGroup);
    BOOL Remove(CNewsGroupCore *pGroup, BOOL fHaveExLock = FALSE);

        //
        // [in] szGroup = group name
        // [in] szNativeGroup = the native name
        // [out] groupid = set to the group id of the new group
        // [in] groupid = if fSetGroupId == TRUE then make this the group id
        // [in] fSpecial = create a special group
        // [out] ppGroup = contains the new group 
        // [in] fAddToGroupFiles = add this to the group files?
        // [in] fSetGroupId = if this is set then the group's ID will be groupid
        //
        BOOL    CreateGroupInternal(char *szGroup, 
                                                                char *szNativeGroup, 
                                                                GROUPID& groupid,
                                                                BOOL fAnonymous,
                                                                HANDLE hToken,
                                                                BOOL fSpecial = FALSE, 
                                                                CGRPCOREPTR *ppGroup = NULL,
                                                                BOOL fAddToGroupFiles = TRUE,
                                                                BOOL fSetGroupId = FALSE,
                                                                BOOL fCreateInStore = TRUE,
                                                                BOOL fAppend = FALSE );

    BOOL    CreateGroupInternalEx(LPSTR lpstrGroupName, 
                                                                  LPSTR lpstrNativeGroupName, 
                                                                  BOOL fSpecial = FALSE);

        BOOL    CreateSpecialGroups();

        // this is the callback used by DecorateNewsTree
        static void DropDriverCallback(void *pEnumContext,
                                                               CVRoot *pVRoot);

        //
        // this function is called for each group loaded from the fixed-record
        // file
        //
        static BOOL LoadTreeEnumCallback(DATA_BLOCK &block, void *pThis, DWORD dwOffset, BOOL bInOrder );

        //
        // this function is called when a group's entry in the variable
        // length file changes
        //
        static void FlatFileOffsetCallback(void *, BYTE *, DWORD, DWORD);

        //
        // read a record from the flatfile and update a group with the properties
        //
        HRESULT ParseFFRecord(BYTE *pData, DWORD cData, DWORD iOffset, DWORD dwVer);

        //
        // save a group into a flatfile record
        //
        HRESULT BuildFFRecord(CNewsGroupCore *pGroup, BYTE *pData, DWORD *pcData);

        // 
        // Parse the group properties from old group.lst entry
        //
        BOOL    ParseGroupParam(            char*, 
                                                DWORD, 
                                                DWORD&, 
                                                LPSTR,
                                                LPSTR,
                                                DWORD&,
                                                BOOL&,
                                                DWORD&,
                                                DWORD&,
                                                DWORD&,
                                                BOOL&,
                                                BOOL&,
                                                FILETIME& ) ;

protected:
        virtual CNewsGroupCore *AllocateGroup() {
                return new CNewsGroupCore(this);
        }

public :

    CNewsTreeCore(INntpServer *pServerObject = NULL);
        CNewsTreeCore(CNewsTreeCore&);
        virtual ~CNewsTreeCore();
        
    CNewsTreeCore *GetTree() { return this; }

        INewsTree *GetINewsTree() { 
                m_inewstree.AddRef(); 
                return &m_inewstree;
        }

    BOOL Init(CNNTPVRootTable *pVRTable, 
              CNntpServerInstanceWrapperEx *pInstWrapper,
                          BOOL& fFatal, 
                          DWORD cNumLocks, 
                          BOOL fRejectGenomeGroups);

        //
        // Load the newstree from disk
        //
        BOOL LoadTree(char *szFix, char *szVar, BOOL& fUpgrade, DWORD dwInsance = 0, BOOL fVerify = TRUE );

        // 
        // Load the newstree from old format group.lst
        BOOL OpenTree( LPSTR, DWORD, BOOL, BOOL&, BOOL );

        // 
        // save the newstree to disk
        //
        BOOL SaveTree( BOOL fTerminate = TRUE );

        //
        // save the properties in one group to disk
        //
        BOOL SaveGroup(INNTPPropertyBag *pBag);

        //
        //      this releases our references on the group objects
        //
        void TermTree();

        // this callback is called when the vroots are rescanned
        static void VRootRescanCallback(void *pThis);

        //
        //      Stop all background processing - kill any threads we started etc...
        //
    BOOL StopTree();

        //
        //      InitClass must be called before any CNewsGroup object is created or manipulated.
        //
        BOOL InitNewsgroupGlobals(DWORD cNumLocks);

        //
        //      Call after all article id allocation is complete
        //
        void TermNewsgroupGlobals();

        //
        //      Copy the file containing newsgroups to a backup
        //
        void RenameGroupFile();

        //
        // get a pointer to the server object
        //
        INntpServer *GetNntpServer() { return m_pServerObject; }

        // One critical section used for allocating article id's !!
        //CRITICAL_SECTION m_critLowAllocator;
        CRITICAL_SECTION m_critIdAllocator;

        //
        //      Number of Locks we are using to protect access to 
        //      our m_lpstrPath and fields
        //
        DWORD m_NumberOfLocks;

        //
        //      Pointer to array of locks - reference by computing
        //      modulus of m_groupId by gNumberOfLocks
        //
        CShareLockNH* m_LockPathInfo;

        //
        //      Indicate to background threads that the newstree has changed and needs to be saved.
        //
        void Dirty(); // mark the tree as needing to be saved !!


        //
        //      Used during bootup to figure out what the range of GROUPID's in the 
        //      group file is.
        //
        void ReportGroupId(GROUPID groupid);
        
        
        //---------------------------------
        // Group Location Interface - find a news Group for an article
        //
        
        // Find an article based on a string and its length
        CGRPCOREPTRHASREF GetGroup(const char *szGroupName, int cch ) ;
        CGRPCOREPTRHASREF GetGroupPreserveBuffer(const char     *szGroupName, int cch ) ;
        
        // Find a newsgroup given an CArticleRef
        CGRPCOREPTRHASREF GetGroup( CArticleRef& ) ;
        
        // Find a newsgroup based on its GROUPID
        CGRPCOREPTRHASREF GetGroupById( GROUPID groupid, BOOL fFirm = FALSE ) ;
        
        GROUPID GetSlaveGroupid() ;

        // Find the parent of a newsgroup
        CGRPCOREPTRHASREF GetParent( 
                                           IN  char* lpGroupName,
                                           IN  DWORD cbGroup,
                                           OUT DWORD& cbConsumed
                                           );
    //
    // The following function takes a list of strings which are
        // terminated by a double NULL and builds an iterator object
        // which can be used examine all the group objects.
    //
    CGroupIteratorCore *GetIterator(LPMULTISZ lpstrPattern,     
                                                                BOOL fIncludeSpecialGroups = FALSE);

        //----------------------------------
        //      Active NewsGroup Interface - Specify an interface for generating a
        //  list of active newsgroups and estimates of their contents.
        //
    CGroupIteratorCore *ActiveGroups(BOOL fReverse = FALSE);    

        //----------------------------------
    // Group Control interface - These functions can be used to remove
    // and add newsgroups.

    //
    // RemoveGroup is called once we've parsed an article that kills
    // a newsgroup or the Admin GUI decides to destroy an article.
    //
    virtual BOOL RemoveGroup(CNewsGroupCore *pGroup );

    //
    // Remove group from newstree only
    //
    BOOL RemoveGroupFromTreeOnly( CNewsGroupCore *pGroup );
    
        //
        // RemoveDriverGroup is called by the expire thread in the server
        // to physically remove a group from a driver
        //
        BOOL RemoveDriverGroup(CNewsGroupCore *pGroup );

    //
    // CreateGroup is called with the name of a new newsgroup which we've
    // gotten through a feed or from Admin. We are given only the name
    // of the new newsgroup.  We will find the parent group by removing
    // trailing ".Group" strings from the string we are passed.
    // We will clone the properties of this newsgroup to create our new
    // newsgroup.
    //
    BOOL CreateGroup(   LPSTR lpstrGroupName, 
                        BOOL fIsAllLowerCase,
                        HANDLE hToken,
                        BOOL fAnonymous ) {
                HRESULT hr;
                hr = FindOrCreateGroup( lpstrGroupName, 
                                        fIsAllLowerCase, 
                                        TRUE, 
                                        TRUE, 
                                        NULL,
                                        hToken,
                                        fAnonymous );
                if (hr == S_OK) {
                        return TRUE;
                } else {
                        if (hr == S_FALSE) {
                                SetLastError(ERROR_GROUP_EXISTS);
                        } else {
                                SetLastError(HRESULT_CODE(hr));
                        }
                        return FALSE;
                }
        }

        //
        // this function can find or create a group atomically.  
        //
        // parameters:
        //   lpstrGroupName - the name of the group to create
        //   fIsAllLowerCase - is the group name lower case?
        //   fCreateIfNotExist - should we create it if the group doesn't exist?
        //   ppExistingGroup - a pointer to get the existing group if it exists.
        //
        // return codes: S_OK = group was found.  S_FALSE = group was created.
        //               else = error.
        //
        HRESULT FindOrCreateGroup(LPSTR lpstrGroupName, 
                                                          BOOL fIsAllLowerCase,
                                                          BOOL fCreateIfNotExist,
                                                          BOOL fCreateInStore,
                                                          CGRPCOREPTR *ppExistingGroup,
                                                          HANDLE hToken,
                                                          BOOL fAnonymous,
                                                          GROUPID groupid = 0xffffffff,
                                                          BOOL fSetGroupId = FALSE );

    BOOL    HashGroupId(CNewsGroupCore *pGroup);

        //
        //      Check whether a GROUPID is in the 'special' range
        //

        BOOL IsSpecial(GROUPID groupid) {
                return  groupid >= m_idStartSpecial && groupid <= m_idLastSpecial;
        }

    int GetGroupCount( void ) { return m_cGroups; };
    void RemoveEx( CNewsGroupCore *pGroup ) ;

        //
        // find the controlling driver for a group and return it
        //
        HRESULT LookupVRoot(char *pszGroup, INntpDriver **ppDriver);

        //
        // Is the tree being stopped ?
        //
        BOOL IsStopping() { return m_fStoppingTree; }

};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\nntp\core\include\pcstring.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    pcstring.h

Abstract:

    This module contains class declarations/definitions for

		CPCString

    **** Overview ****

	A string data type defined with an object.
	Strings are represented by
	    1. A pointer to a character
		2. A length.

    No memory is allocated so this is compact and efficient.

Author:

    Carl Kadie (CarlK)     25-Oct-1995

Revision History:


--*/

#ifndef	_PCSTRING_H_
#define	_PCSTRING_H_

#include "artglbs.h"

//
//
//
// CPCString - A pointer/counter string.
//

class CPCString {
public :
	//
	// Constructor -- no string yet.
	//

	CPCString(void):
			m_pch(NULL),
			m_cch(0) {
            numPCString++;
            };

	//
	// Constructor -- give pointer to string and length.
	//

	CPCString(char * pch, DWORD cch):
			m_pch(pch),
			m_cch(cch) {
            numPCString++;
            };

	//
	// Constructor -- build on top of a sz string.
	//

	CPCString(char * sz):
			m_pch(sz),
			m_cch(lstrlen(sz)) {
            numPCString++;
            };

	virtual ~CPCString( ) { numPCString--; };

	//
	// The pointer to the start of the string	
	//

	char *	m_pch;

	//
	// The length of the string.
	//

	DWORD m_cch;

	//
	// A pointer to one character past the end of the string
	//

	char *	pchMax(void);

	//
	// Set the length of the string of a pointer one past the end of the string.
	//

	BOOL fSetCch(const char * pchMax);

	//
	// The the start of the string from the length and a pchMax
	//

	BOOL fSetPch(char * pchMax);

	//
	// Make the string the Null string.
	//

	void vSetNull() {
			m_pch=NULL;
			m_cch=0;
			};

	//
	// Test if the string is the null string.
	//

	BOOL fIsNull() {
			return NULL==m_pch && 0== m_cch;
			};

	//
	// Trim characters from the frount
	//

	DWORD dwTrimStart(const char * szSet);

	//
	// Trim characters from the end.
	//

	DWORD dwTrimEnd(const char * szSet);

	//
	// Compare to a sz string (ignoring case)
	//

	BOOL fEqualIgnoringCase(const char * sz);

	//
	// Check existence in a set of strings (ignoring case)
	//

	BOOL fExistsInSet(char ** rgsz, DWORD dwNumStrings);

	//
	// Create a multisz list by spliting the string.
	//

	void vSplitLine(const char * szDelimSet, char * multisz, DWORD	&	dwCount);	

	//
	// Append another CPCString
	//

	CPCString& operator << (const CPCString & pcNew);

	//
	// Append a sz string.
	//

	CPCString& operator << (const char * szNew);

	//
	// Append a character
	//

	CPCString& operator << (const char cNew);

	//
	// Append a number
	//

	CPCString& operator << (const DWORD cNew);

	//
	// Compare two CPCStrings.
	//

	BOOL operator == (const CPCString & pcNew)	{
			return m_pch == pcNew.m_pch && m_cch == pcNew.m_cch;
			};

	//
	// See if two CPCStrings are different
	//

	BOOL operator != (const CPCString & pcNew)	{
			return !(*this == pcNew);
			};
	
	//
	// Copy from a CPCString
	//

	void vCopy(CPCString & pcNew);

	//
	// Move (safe copy) from a CPCString)
	//

	void vMove(CPCString & pcNew);

	//
	// Copy to a sz
	//

	void vCopyToSz(char* sz);

	//
	// Copy to an sz of length cchMax
	//

	void vCopyToSz(char* sz, DWORD cchMax);

	//
	// Assert that this string is null terminated and return it
	//

	char *  sz(void);

	//
	// Null terminate this string (the null doesn't count toward length)
	//

	void vMakeSz(void);

	//
	// Check if this string is just plain ascii, if not return the 8-bit or null character
	//

	BOOL fCheckTextOrSpace(char & chBad);

	//
	// Shorten the string by skipping dwSkip characters in the front.
	//

	void vSkipStart(const DWORD dwSkip)	{
			m_pch += dwSkip;
			m_cch -= dwSkip;
			};

	//
	// Shorten the string by skipping dwSkip characters in the back.
	//

	void vSkipEnd(const DWORD dwSkip){
			m_cch -= dwSkip;
			};

	//
	// Shorten the string by skipping a CRLF terminated line
	//

	void vSkipLine(void);

	//
	// Append a CPCString, but not if too long.
	//

	BOOL fAppendCheck(const CPCString & pcNew, DWORD cchLast);

	//
	// Append a character, but not if too long
	//

	BOOL fAppendCheck(char ch, DWORD cchLast);

	//
	// Replace a set of characters to a single character
	//

	void vTr(const char * szFrom, char chTo);

	//
	// Get the next token, shorten the string
	//

	void vGetToken(const char *	szDelimSet, CPCString & pcToken);

	//
	// Get the next word, shorten the string
	//

	void vGetWord(CPCString & pcWord);

	//
	// Attach this string to a sz string.
	//

	void vInsert(char * sz)				{
			m_pch = sz;
			m_cch = lstrlen(m_pch);
			};

	//
	// Count the ocurrance of a character.
	//

	DWORD dwCountChar(
			char ch
			);

	//
	// Replace the current string with an sz of exactly
	// the same length.
	//

	void vReplace(
		   const char * sz
		   );
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\nntp\core\include\sfromcl.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    sfromcl.h

Abstract:

    This module contains class declarations/definitions for

!!!

    **** Overview ****

	This derives classes from CInFeed, CArticle, and CField
	that will be used by slaves to process articles from clients. Mostly,
	it just defines various CField-derived objects.

Author:

    Carl Kadie (CarlK)     07-Jan-1996

Revision History:


--*/

#ifndef	_SFROMCL_H_
#define	_SFROMCL_H_

#include "fromclnt.h"

//
//
//
// CSlaveFromClientArticle - class for manipulating articles.
// Note it is baded on CFromClientArticle not (directly) on CArticle.
//

class	CSlaveFromClientArticle  : public CFromClientArticle {
public:

	// Constructor
	CSlaveFromClientArticle(
		char * szLoginName):
		CFromClientArticle(szLoginName)
		{}

	// Modify the headers.
	// Add MessageID, Organization (if necessary), NNTP-Posting-Host,
	// X-Authenticated-User, Modify path, but don't add Xref
	BOOL fMungeHeaders(
		 CPCString& pcHub,
		 CPCString& pcDNS,
		 CNAMEREFLIST & grouplist,
		 DWORD remoteIpAddress,
		 CNntpReturn & nntpr,
         PDWORD pdwLinesOffset = NULL
		 );

	//
	// Message ID's don't need to be recorded, so just return OK
	//

	BOOL fRecordMessageIDIfNecc(
			CNntpServerInstanceWrapper * pInstance,
			const char * szMessageID,
			CNntpReturn & nntpReturn)
		{
			return nntpReturn.fSetOK();
		}

protected :

	//
	// Uses CFromClientArticle's field members
	//
};



// For slaves processing incoming articles from Clients
class	CSlaveFromClientFeed:	public CFromClientFeed 	{
// Public Members
public :

protected:

	// Create an article
	CARTPTR pArticleCreate(void) {
		Assert(ifsInitialized == m_feedState);
		return new CSlaveFromClientArticle(m_szLoginName);
		};

	// This verion of fPostInternal is different from
	// the standard one because
	//      1. Article numbers are not assigned
	//		2. The message id is not recorded
	//		3. The article is not put in the tree.
	//		4. Control messages are not applied
	virtual BOOL fPostInternal (
		CNntpServerInstanceWrapper * pInstance,
		const	LPMULTISZ	szCommandLine,
		CSecurityCtx *pSecurityCtx,
		CEncryptCtx *pEncryptCtx,
		BOOL fAnonymous,
		CARTPTR	& pArticle,
        CNEWSGROUPLIST &grouplist,
        CNAMEREFLIST &namereflist,
        IMailMsgProperties *pMsg,
		CAllocator & allocator,
		char *&	multiszPath,
		char*	pchGroups,
		DWORD	cbGroups,
		DWORD	remoteIpAddress,
		CNntpReturn & nntpReturn,
        PFIO_CONTEXT *ppFIOContext,
        BOOL *pfBoundToStore,
        DWORD *pdwOperations,
        BOOL *fPostToMod,
        LPSTR szModerator
		);

	HRESULT FillInMailMsg(  IMailMsgProperties *pMsg, 
							CNewsGroupCore *pGroup, 
							ARTICLEID   articleId,
							HANDLE       hToken,
                            char*       pszApprovedHeader );

	virtual void CommitPostToStores(CPostContext *pContext,
	                        CNntpServerInstanceWrapper *pInstance );

    //
    // Cancel an article given the message id
    //
    virtual BOOL fApplyCancelArticle(
			CNntpServerInstanceWrapper * pInstance,
			CSecurityCtx *pSecurityCtx,
			CEncryptCtx *pEncryptCtx,
			BOOL fAnonymous,
            CPCString & pcValue,
			CNntpReturn & nntpReturn
			)
	{
		return fApplyCancelArticleInternal( pInstance, pSecurityCtx, pEncryptCtx, fAnonymous, pcValue, FALSE, nntpReturn );
	}

    //
    // Add a new newsgroup in response to a newgroup control message
    //
    virtual BOOL fApplyNewgroup(
			CNntpServerInstanceWrapper * pInstance,
			CSecurityCtx *pSecurityCtx,
			CEncryptCtx *pEncryptCtx,
			BOOL fAnonymous,
            CPCString & pcValue,
            CPCString & pcBody,
			CNntpReturn & nntpReturn
			)
	{
		BOOL fRet ;
		pInstance->EnterNewsgroupCritSec() ;
		fRet = fApplyNewgroupInternal( pInstance, pSecurityCtx, pEncryptCtx, fAnonymous, pcValue, pcBody, FALSE, nntpReturn );
		pInstance->LeaveNewsgroupCritSec() ;
		return fRet ;
	}

    //
    // Remove a newsgroup in response to a rmgroup control message
    //
    virtual BOOL fApplyRmgroup(
			CNntpServerInstanceWrapper * pInstance,
			CSecurityCtx *pSecurityCtx,
			CEncryptCtx *pEncryptCtx,
            CPCString & pcValue,
			CNntpReturn & nntpReturn
			)
	{
		BOOL fRet ;
		pInstance->EnterNewsgroupCritSec();
		fRet = fApplyRmgroupInternal( pInstance, pSecurityCtx, pEncryptCtx, pcValue, FALSE, nntpReturn );
		pInstance->LeaveNewsgroupCritSec() ;
		return fRet ;
	}
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\nntp\core\include\rtscan.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:		

    rtscan.h

Abstract:

    This implements a generic root scan class.  Its difference from rootscan:
    1. Rootscan is not multi-thread safe, using SetCurrentDir; rtscan is;
    2. Rootscan has too much nntp specific stuff; rtscan doesn't;
    
Author:

    Kangrong Yan ( KangYan )    23-Oct-1998

Revision History:

--*/
#if !defined( _RTSCAN_H_ )
#define _RTSCAN_H_

//
// Interface that tells the root scan to stop before complete
//
class CCancelHint {

public:

    virtual BOOL IShallContinue() = 0;
};

//
// Base class to be derived by any one who wants to implement what he wants
// to do at certain points of directory scan.  This class will report the
// directories found in alphabetical order, but doesn't know whether the 
// directory found is a leaf or not.  If a derived class wants to know if
// the dir found is a leaf, he should do it himself.
//
class CRootScan {

public:

    //////////////////////////////////////////////////////////////////////////
    // Public methods
    //////////////////////////////////////////////////////////////////////////
    //
    // Constructor, destructors
    //
    CRootScan(  LPSTR       szRoot,
                CCancelHint *pCancelHint = NULL ) :
         m_pCancelHint( pCancelHint )
    {
        _ASSERT( strlen( szRoot ) <= MAX_PATH );
        strcpy( m_szRoot, szRoot );
    }

    //
    // Start the scan
    //
    BOOL DoScan();

protected:

    //////////////////////////////////////////////////////////////////////////
    // Protected methods
    //////////////////////////////////////////////////////////////////////////
    //
    // Interface function to be called to notify derived class that a 
    // directory has been found
    //
    virtual BOOL NotifyDir( LPSTR   szFullPath ) = 0;

private:

    //////////////////////////////////////////////////////////////////////////
    // Private variables
    //////////////////////////////////////////////////////////////////////////
    //
    // Root directory to scan from
    //
    CHAR    m_szRoot[MAX_PATH+1];

    //
    // Pointer to cancel hint interface
    //
    CCancelHint *m_pCancelHint;

    //////////////////////////////////////////////////////////////////////////
    // Private methods
    //////////////////////////////////////////////////////////////////////////
    BOOL IsChildDir( IN WIN32_FIND_DATA& FindData );
    BOOL MakeChildDirPath(  IN LPSTR    szPath,
                            IN LPSTR    szFileName,
                            OUT LPSTR   szOutBuffer,
                            IN DWORD    dwBufferSize );
    HANDLE FindFirstDir(    IN LPSTR                szRoot,
                            IN WIN32_FIND_DATA&     FindData );
    BOOL FindNextDir(    IN HANDLE           hFindHandle,
                         IN WIN32_FIND_DATA& FindData );
    BOOL RecursiveWalk( LPSTR szRoot );
};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\nntp\core\include\tigdflts.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    tigdflts.h

Abstract:

    Defines the defaults for metabase values used by the NNTP service.

    See nntpmeta.h for metabase IDs.
    See the metabase spreadsheet (on \\isbu\tigris) for parameter
    ranges, and descriptions of these properties.

Author:

    Magnus Hedlund (MagnusH)        --

Revision History:

--*/

#ifndef _TIGRIS_DEFAULTS_INCLUDED_
#define _TIGRIS_DEFAULTS_INCLUDED_

#define ONE_K		( 1024 )
#define ONE_MEG		( ONE_K * ONE_K )

#define NNTP_DEF_ARTICLETIMELIMIT		( 1138 )
#define NNTP_DEF_HISTORYEXPIRATION		( 1138 )
#define NNTP_DEF_NEWSCRAWLERTIME		( 1138 )
#define NNTP_DEF_SHUTDOWNLATENCY		( 1138 )

#define NNTP_DEF_HONORCLIENTMSGIDS		( TRUE )
#define NNTP_DEF_DISABLENEWNEWS			( TRUE )
#define NNTP_DEF_COMMANDLOGMASK			( (DWORD) -1 )
#define NNTP_DEF_ALLOWCLIENTPOSTS		( TRUE )
#define NNTP_DEF_ALLOWFEEDPOSTS			( TRUE )
#define NNTP_DEF_ALLOWCONTROLMSGS		( TRUE )

#define NNTP_DEF_CLIENTPOSTSOFTLIMIT	( 1000 * ONE_K )	// In bytes
#define NNTP_DEF_CLIENTPOSTHARDLIMIT	( 20 * ONE_MEG )	// In bytes
#define NNTP_DEF_FEEDPOSTSOFTLIMIT		( 1500 * ONE_K )	// In bytes
#define NNTP_DEF_FEEDPOSTHARDLIMIT		( 40 * ONE_MEG )	// In bytes

#define NNTP_DEF_AUTOSTART				( TRUE )
#define NNTP_DEF_BINDINGS				_T( ":119:\0" )
#define NNTP_DEF_SECUREPORT				( 563 )
#define NNTP_DEF_MAXCONNECTIONS			( 0x77359400 )
#define NNTP_DEF_CONNECTIONTIMEOUT		( 600 )
#define NNTP_DEF_FEED_REPORT_PERIOD		( 60 * 24)			// One hour
#define NNTP_DEF_MAX_SEARCH_RESULTS		( 1000 )
#define NNTP_DEF_CLUSTERENABLED                 ( FALSE )

/*

From nntpstr.cpp:

StrArtMapFile = "nntpfile\\article.hsh";
StrHisMapFile = "nntpfile\\history.hsh";
StrXoverMapFile = "nntpfile\\xover.hsh";
StrGrpHelpFile = "nntpfile\\descrip.txt" ;
StrGrpListFile = "nntpfile\\group.lst" ;
StrDefHashFile = "c:\\hash.hsh";
StrDefListFile = "c:\\listfile.txt";

*/

#define NNTP_DEF_ARTICLETABLEFILE		_T( "nntpfile\\article.hsh" )
#define NNTP_DEF_HISTORYTABLEFILE		_T( "nntpfile\\history.hsh" )
#define NNTP_DEF_XOVERTABLEFILE			_T( "nntpfile\\xover.hsh" )
#define NNTP_DEF_GROUPHELPFILE			_T( "nntpfile\\descrip.txt" )
#define NNTP_DEF_GROUPLISTFILE			_T( "nntpfile\\group.lst" )
#define NNTP_DEF_GROUPVARLISTFILE		_T( "nntpfile\\groupvar.lst" )
#define NNTP_DEF_MODERATORFILE			_T( "nntpfile\\moderatr.txt" )
#define NNTP_DEF_PRETTYNAMESFILE		_T( "nntpfile\\prettynm.txt" )
#define NNTP_DEF_LISTFILE				_T( "nntpfile\\listfile.txt" )
#define NNTP_DEF_DROPDIRECTORY			_T( "nntpfile\\drop" )

#define NNTP_DEF_ANONYMOUSUSERNAME		_T( "" )
#define NNTP_DEF_ANONYMOUSUSERPASS		_T( "" )
#define NNTP_DEF_DEFAULTMODERATORDOMAIN	_T( "" )
#define NNTP_DEF_SMTPSERVER				_T( "" )
#define NNTP_DEF_UUCPNAME				_T( "" )
#define NNTP_DEF_ORGANIZATION			_T( "" )
#define NNTP_DEF_COMMENT				_T( "" )
#define NNTP_DEF_PICKUPDIRECTORY		_T( "" )
#define NNTP_DEF_FAILEDPICKUPDIRECTORY	_T( "" )

#endif /* _TIGRIS_DEFAULTS_INCLUDED_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\nntp\core\include\syncomp.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:		

    syncomp.h

Abstract:

    This file defines and implements a synchronous completion object,
    which derives from INntpComplete.  It should be used on stack.
    
Author:

    Kangrong Yan ( KangYan )    12-July-1998

Revision History:

--*/
#ifndef _SYNCOMP_H_
#define _SYNCOMP_H_
#include <nntpdrv.h>

// Class definition for the completion object.
// It derives INntpComplete, but implements a blocking completion
class CDriverSyncComplete : public INntpComplete {  //sc

public:
    // Constructor and destructors
    CDriverSyncComplete::CDriverSyncComplete()
    {
	    TraceFunctEnter( "CDriverSyncComplete::CDriverSyncComplete" );
	    m_cRef = 0; 
	    m_hr = E_FAIL;
	    _VERIFY( m_hEvent = GetPerThreadEvent() );
	    TraceFunctLeave();
    }

    CDriverSyncComplete::~CDriverSyncComplete()
    {
    	_ASSERT( m_cRef == 0 );
    }

    // Set the result to completion object
    VOID STDMETHODCALLTYPE
    CDriverSyncComplete::SetResult( HRESULT hr )
    {
        _ASSERT( m_hEvent );
	    m_hr = hr;
    }

    // Reset the completion object
    VOID
    CDriverSyncComplete::Reset()
    {
        _ASSERT( m_hEvent );
    	m_hr = E_FAIL;
    }

    // Get the result from the completion object
    HRESULT 
    CDriverSyncComplete::GetResult()
    {
        _ASSERT( m_hEvent );
    	return m_hr;
    }

    // Wait for the completion 
    VOID
    CDriverSyncComplete::WaitForCompletion()
    {
	    _ASSERT( m_hEvent );
	    LONG    lRef;
	    
	    if ( ( lRef = InterlockedDecrement( &m_cRef ) ) == 0 ) {
	        // It has been completed, I don't need to wait,
	    } else if ( lRef == 1 ) {   
	        // still waiting for completion
	        WaitForSingleObject( m_hEvent, INFINITE );
	    } else {
	        _ASSERT( 0 );
	    }
    }

    VOID __stdcall
    ReleaseBag( INNTPPropertyBag *pPropBag )
    {}

	// IUnknown implementations
	HRESULT __stdcall QueryInterface( const IID& iid, VOID** ppv )
    {
        _ASSERT( m_hEvent );
        
        if ( iid == IID_IUnknown ) {
            *ppv = static_cast<INntpComplete*>(this);
        } else if ( iid == IID_INntpComplete ) {
            *ppv = static_cast<INntpComplete*>(this);
        } else {
            *ppv = NULL;
            return E_NOINTERFACE;
        }
        reinterpret_cast<IUnknown*>(*ppv)->AddRef();
        return S_OK;
    }

    ULONG __stdcall AddRef()
    {
        _ASSERT( m_hEvent );
        return InterlockedIncrement( &m_cRef );
    }
	
	ULONG __stdcall Release()
	{
		TraceFunctEnter( "CDriverSyncComplete::Complete" );
		_ASSERT( m_hEvent );
		
		LONG lRef;

		if ( ( lRef = InterlockedDecrement( &m_cRef ) ) == 0 ) {
		    // object owner gets there first and is waiting, we
		    // need to set event
			if ( !SetEvent( m_hEvent ) ) {
				FatalTrace( 0, "Set event failed %d", GetLastError() );
				_ASSERT( FALSE );
			}
		} else if ( lRef == 1 ) {
		    // We get there first, object owner will not wait for
		    // event, no need to set
		} else {
		    _ASSERT( 0 );
		}
		
	    TraceFunctLeave();
	    return m_cRef;
	}

	// This function is for debugging purpose
	ULONG   GetRef() 
	{ return m_cRef; }

private:
	HRESULT m_hr;
	LONG	m_cRef;
	HANDLE 	m_hEvent;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\nntp\core\include\tigmem.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    tigmem.h

Abstract:

    This module contains class declarations/definitions for

		CAllocator


    **** Overview ****

	This defines object that allocates (and deallocates)
	memory from a fixed buffer.

Author:

    Carl Kadie (CarlK)     12-Jan-1995

Revision History:


--*/

#ifndef	_TIGMEM_H_
#define	_TIGMEM_H_



class	CAllocator	{
private : 

	//
	//
	//


	char * m_pchPrivateBytes;


	DWORD m_cchMaxPrivateBytes;

	//
	// The offset to the next place to allocate from
	//

	DWORD	m_ichLastAlloc ;

	//
	// The number of allocations at the current moment
	//

	DWORD	m_cNumberOfAllocs ;

	//
	//!!! next could add this stuff
	//

#ifdef	DEBUG
	DWORD	m_cbAllocated ;

	static	DWORD	m_cbMaxBytesEver ;
	static	DWORD	m_cbAverage ;
	static	DWORD	m_cbStdDeviation ;
#endif

public : 

	CAllocator(
					   char * rgchBuffer,
					   DWORD cchMaxPrivateBytes
					   ):
		m_cNumberOfAllocs(0),
		m_ichLastAlloc(0),
		m_cchMaxPrivateBytes(cchMaxPrivateBytes),
		m_pchPrivateBytes(rgchBuffer)
		{};


	~CAllocator(void);

	DWORD	cNumberOfAllocs(void)
		{ 
			return m_cNumberOfAllocs;
		};

	char*	Alloc( size_t size );

	void	Free( char *pv );
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\nntp\core\include\tigtypes.h ===
/*++

    tigtypes.h

    This file contains the definitions of very basic types
    used within NNTPSVC.

--*/

#ifndef _TIGTYPES_H_
#define _TIGTYPES_H_


typedef DWORD   ARTICLEID ;
typedef DWORD   GROUPID ;
typedef DWORD   SERVERID ;

typedef DWORD   HASH_VALUE ;

#define	INVALID_ARTICLEID	((ARTICLEID)(~0))
#define INVALID_GROUPID     ((GROUPID)(~0))

//	
//	Structure used in some places to describe a article !
//
class   CArticleRef {
public : 
	CArticleRef(GROUPID group=INVALID_GROUPID, ARTICLEID article=INVALID_ARTICLEID):
		m_groupId(group),
		m_articleId(article)
		{};
	LPVOID      m_compareKey;
    GROUPID     m_groupId ;
    ARTICLEID   m_articleId ;
} ;

const CArticleRef NullArticleRef(INVALID_GROUPID, INVALID_ARTICLEID);


//
//
//
// list of posted groups
//
typedef struct _GROUP_ENTRY {

    GROUPID     GroupId;
    ARTICLEID   ArticleId;

} GROUP_ENTRY, *PGROUP_ENTRY;


//
//  This constant is used throughout the server to represent the longest Message Id we will process !
//
#define MAX_MSGID_LEN   255

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\nntp\core\include\wildmat.h ===
//---[ wildmat.h ]-------------------------------------------------------------
//
//  Description:
//      Provides support for the "wildmat" wildcard matching standard. Info
//      on this standard comes from the internet draft:
//
//      draft-barber-nntp-imp-03.txt
//      S. Barber
//      April, 1996
//
//  Copyright (C) Microsoft Corp. 1996.  All Rights Reserved.
//
// ---------------------------------------------------------------------------

#ifndef _WILDMAT_H_
#define _WILDMAT_H_

//---[ Prototypes ]------------------------------------------------------------

HRESULT HrMatchWildmat( const char *pszText, const char *pszPattern );

#endif // _WILDMAT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\nntp\core\propbag\src\propbag.cpp ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

	propbag.cpp

Abstract:

	This module contains the implementation of the property bag class.  
	Property bag is a dynamically extendable container for different
	types of properties.  

	It's not MT safe.  Proper synchronization should be done at a 
	higher level.

Author:

	Kangrong Yan ( KangYan )
	
Revision History:

	kangyan	05/31/98	created

--*/
#include <propbag.h>
#include <randfail.h>

// Constructor, destructor
CPropBag::CPropBag( int cInitialSize,	int cIncrement )
{
	_ASSERT( cInitialSize > 0 );
	_ASSERT( cIncrement > 0 );

	BOOL bSuccess;
	
	m_hr = S_OK;

	// Initialize the property hash table
	bSuccess = m_ptTable.Init(	&CProperty::m_pNext,
								cInitialSize,
								cIncrement,
								CProperty::HashFunc,
                                2,
                                CProperty::GetKey,
                                CProperty::MatchKey );
	_ASSERT( bSuccess );
	if ( !bSuccess ) {
	    if ( NO_ERROR != GetLastError() )
	        m_hr = HRESULT_FROM_WIN32( GetLastError() );
	    else m_hr = E_OUTOFMEMORY;
	}
}

CPropBag::~CPropBag()
{}

HRESULT
CPropBag::PutDWord( DWORD dwPropId, DWORD dwVal )
/*++
Routine Description:

	Set DWORD in the property bag.

Arguments:

	DWORD dwPropId - Property Id
	DWORD dwVal - Value to be set

Return value:

	S_OK - Success and property already exists
	S_FALSE - Success but property didn't exist 
--*/
{
	TraceQuietEnter( "CPropBag::PutDWord" );

	CProperty *pprProp = NULL;
	HRESULT hr = S_OK;

	if ( FAILED( m_hr ) ) return m_hr;

	m_Lock.ExclusiveLock();

	pprProp = m_ptTable.SearchKeyHash( dwPropId, dwPropId );
	if ( pprProp ) {	// Found, so set it
		_ASSERT( CProperty::Dword == pprProp->m_type );
		pprProp->Validate();
		_ASSERT( dwPropId == pprProp->m_dwPropId );
		if( CProperty::Dword == pprProp->m_type ) {
			hr = S_OK;
			(pprProp->m_prop).dwProp = dwVal;
		} else {
			hr = E_INVALIDARG;
			goto Exit;
		}
	} else { 	// we need to insert an entry
		hr = S_FALSE;
		pprProp = XNEW CProperty;
		if ( !pprProp ) {
			FatalTrace( 0, "Out of memory" );
			hr = E_OUTOFMEMORY;
			goto Exit;
		}

		pprProp->m_dwPropId = dwPropId;
		pprProp->m_type = CProperty::Dword;
		(pprProp->m_prop).dwProp = dwVal;

		if ( NULL == m_ptTable.InsertDataHash( dwPropId, *pprProp ) ) {
			ErrorTrace( 0, "Insert hash failed %d", GetLastError() );
			XDELETE pprProp;
			hr = E_OUTOFMEMORY;    //the only reason InsertDataHash fails is memory
		}
	}

Exit:

    m_Lock.ExclusiveUnlock();
	return hr;
}

HRESULT
CPropBag::GetDWord( DWORD dwPropId, PDWORD pdwVal )
/*++
Routine Description:

	Get DWORD from the property bag.

Arguments:

	DWORD dwPropId - Property Id
	PDWORD pdwVal - Buffer to set the value
	
Return value:

	S_OK - Success and property already exists
	E_INVALIDARG - if the property doesn't exist
--*/
{
	TraceQuietEnter( "CPropBag::GetDWord" );
	_ASSERT( pdwVal );

	CProperty *pprProp = NULL;
	HRESULT hr = S_OK;

	if ( FAILED( m_hr ) ) return m_hr;

	m_Lock.ShareLock();

	// Search for the entry in the hash table
	pprProp = m_ptTable.SearchKeyHash( dwPropId, dwPropId );
	if ( NULL == pprProp ) {	// doesn't exist
		DebugTrace( 0, "Property deosn't exist" );
		hr = HRESULT_FROM_WIN32( ERROR_NOT_FOUND );
		goto Exit;
	}

	// Retrieve value
	pprProp->Validate();
	_ASSERT( pprProp->m_type == CProperty::Dword );
	*pdwVal = (pprProp->m_prop).dwProp;
	
Exit:

    m_Lock.ShareUnlock();
	return hr;
}

HRESULT
CPropBag::PutBool( DWORD dwPropId, BOOL bVal )
/*++
Routine Description:

	Set a boolean in the property bag.

Arguments:

	DWORD dwPropId - Property Id
	BOOL bVal - The boolean value to be set
	
Return value:

	S_OK - Success and property already exists
	S_FALSE - Success but property didn't exist 
--*/
{
	TraceQuietEnter( "CPropBag::PutBool" );

	CProperty *pprProp = NULL;
	HRESULT hr = S_OK;

	if ( FAILED( m_hr ) ) return m_hr;

	m_Lock.ExclusiveLock();

	pprProp = m_ptTable.SearchKeyHash( dwPropId, dwPropId );
	if ( pprProp ) {	// Found, so set it
		_ASSERT( CProperty::Bool == pprProp->m_type );
		_ASSERT( dwPropId == pprProp->m_dwPropId );
		if( CProperty::Bool == pprProp->m_type ) {
			hr = S_OK;
			(pprProp->m_prop).bProp = bVal;
		} else {
			hr = E_INVALIDARG;
			goto Exit;
		}
	} else { 	// we need to insert an entry
		hr = S_FALSE;
		pprProp = XNEW CProperty;
		if ( !pprProp ) {
			FatalTrace( 0, "Out of memory" );
			hr = E_OUTOFMEMORY;
			goto Exit;
		}

		pprProp->m_dwPropId = dwPropId;
		pprProp->m_type = CProperty::Bool;
		(pprProp->m_prop).bProp = bVal;

		if ( NULL == m_ptTable.InsertDataHash( dwPropId, *pprProp ) ) {
			ErrorTrace( 0, "Insert hash failed %d", GetLastError() );
			XDELETE pprProp;
			hr = E_OUTOFMEMORY;    //the only reason InsertDataHash fails is memory
		}
	}

Exit:

    m_Lock.ExclusiveUnlock();
	return hr;
}

HRESULT
CPropBag::GetBool( DWORD dwPropId, PBOOL pbVal )
/*++
Routine Description:

	Get boolean from the property bag.

Arguments:

	DWORD dwPropId - Property Id
	pbVal - Buffer to set the value
	
Return value:

	S_OK - Success and property already exists
	E_INVALIDARG - if the property doesn't exist
--*/
{
	TraceQuietEnter( "CPropBag::GetBool" );
	_ASSERT( pbVal );

	CProperty *pprProp = NULL;
	HRESULT hr = S_OK;

	if ( FAILED( m_hr ) ) return m_hr;

	m_Lock.ShareLock();

	// Search for the entry in the hash table
	pprProp = m_ptTable.SearchKeyHash( dwPropId, dwPropId );
	if ( NULL == pprProp ) {	// doesn't exist
		DebugTrace( 0, "Property deosn't exist" );
		hr = HRESULT_FROM_WIN32( ERROR_NOT_FOUND );
		goto Exit;
	}

	// Retrieve value
	pprProp->Validate();
	_ASSERT( pprProp->m_type == CProperty::Bool );
	*pbVal = (pprProp->m_prop).bProp;
	
Exit:

    m_Lock.ShareUnlock();
	return hr;
}

HRESULT
CPropBag::PutBLOB( DWORD dwPropId, PBYTE pbVal, DWORD cbVal )
/*++
Routine Description:

	Set a blob in the property bag.

Arguments:

	DWORD dwPropId - Property Id
	PBYTE pbVal - Pointer to the blob
	DWORD cbVal - length of the blob
	
Return value:

	S_OK - Success and property already exists
	S_FALSE - Success but property didn't exist 
--*/
{
	TraceQuietEnter( "CPropBag::PutBLOB" );

	CProperty *pprProp = NULL;
	HRESULT hr = S_OK;

	if ( FAILED( m_hr ) ) return m_hr;

    m_Lock.ExclusiveLock();	

	pprProp = m_ptTable.SearchKeyHash( dwPropId, dwPropId );
	if ( pprProp ) {	// Found, so set it
		_ASSERT( CProperty::Blob == pprProp->m_type );
		pprProp->Validate();
		_ASSERT( dwPropId == pprProp->m_dwPropId );

		if ( CProperty::Blob != pprProp->m_type ) {
			hr = E_INVALIDARG;
			goto Exit;
		}
		
		if ( pprProp->m_cbProp < cbVal ) { // can not use the old buffer
			XDELETE[] (pprProp->m_prop).pbProp;
			(pprProp->m_prop).pbProp = XNEW BYTE[cbVal];
			if ( NULL == (pprProp->m_prop).pbProp ) {
				ErrorTrace( 0, "Out of memory" );
				hr = E_OUTOFMEMORY;
				goto Exit;
			} 
		}
			// Copy the content over
		CopyMemory( (pprProp->m_prop).pbProp, pbVal, cbVal );
		pprProp->m_cbProp = cbVal;
	} else { 	// we need to insert an entry
		hr = S_FALSE;
		pprProp = XNEW CProperty;
		if ( !pprProp ) {
			FatalTrace( 0, "Out of memory" );
			hr = E_OUTOFMEMORY;
			goto Exit;
		}

		pprProp->m_dwPropId = dwPropId;
		pprProp->m_type = CProperty::Blob;
		(pprProp->m_prop).pbProp = XNEW BYTE[cbVal];
		if ((pprProp->m_prop).pbProp == NULL) {
		    XDELETE pprProp;
			FatalTrace( 0, "Out of memory" );
			hr = E_OUTOFMEMORY;
			goto Exit;
		}

		CopyMemory( (pprProp->m_prop).pbProp, pbVal, cbVal );
		pprProp->m_cbProp = cbVal;

		if ( NULL == m_ptTable.InsertDataHash( dwPropId, *pprProp ) ) {
			ErrorTrace( 0, "Insert hash failed %d", GetLastError() );
			XDELETE (pprProp->m_prop).pbProp;
			XDELETE pprProp;
			hr = E_OUTOFMEMORY;    //the only reason InsertDataHash fails is memory
		}
	}

Exit:

    m_Lock.ExclusiveUnlock();
	return hr;
}

HRESULT
CPropBag::GetBLOB( DWORD dwPropId, PBYTE pbVal, PDWORD pcbVal )
/*++
Routine Description:

	Get boolean from the property bag.

Arguments:

	DWORD dwPropId - Property Id
	pbVal - Buffer to Get the value
	pcbVal - IN: buffer size; OUT: actual length
	
Return value:

	S_OK - Success and property already exists
	E_INVALIDARG - if the property doesn't exist
	TYPE_E_BUFFERTOOSMALL - The buffer is not big enough
--*/
{
	TraceQuietEnter( "CPropBag::GetBLOB" );
	_ASSERT( pbVal );
	_ASSERT( pcbVal );

	CProperty *pprProp = NULL;
	HRESULT hr = S_OK;

	if ( FAILED( m_hr ) ) return m_hr;

	m_Lock.ShareLock();

	// Search for the entry in the hash table
	pprProp = m_ptTable.SearchKeyHash( dwPropId, dwPropId );
	if ( NULL == pprProp ) {	// doesn't exist
		DebugTrace( 0, "Property doesn't exist" );
		hr = HRESULT_FROM_WIN32( ERROR_NOT_FOUND );
		goto Exit;
	}

	// Retrieve value
	pprProp->Validate();
	_ASSERT( pprProp->m_type == CProperty::Blob );

	// check if buffer large enough
	if ( *pcbVal < pprProp->m_cbProp ) {
		DebugTrace( 0, "Property Buffer not large enough" );
		*pcbVal = pprProp->m_cbProp;
		hr = TYPE_E_BUFFERTOOSMALL;
		goto Exit;
	}

	// now large enough, do the copy
	*pcbVal = pprProp->m_cbProp;
	CopyMemory( pbVal, (pprProp->m_prop).pbProp, pprProp->m_cbProp );

Exit:

    m_Lock.ShareUnlock();
	return hr;
}

HRESULT
CPropBag::RemoveProperty( DWORD dwPropId )
/*++
Routine Description:

	Remove a property from the property bag

Arguments:

	DWORD dwPropId - The property to remove

Return value:

	S_OK - Removed
	ERROR_NOT_FOUND - Doesn't exist
--*/
{
	TraceQuietEnter( "CPropBag::RemoveProperty" );

	HRESULT hr = S_OK;

	if ( FAILED( m_hr ) ) return m_hr;

	m_Lock.ExclusiveLock();
	
	if ( m_ptTable.Delete( dwPropId ) ) hr = S_OK;
	else hr = HRESULT_FROM_WIN32( ERROR_NOT_FOUND );

	m_Lock.ExclusiveUnlock();

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\nntp\core\rtscan2\src\rtscan.cpp ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:		

    rtscan.h

Abstract:

    This implements a generic root scan class.  Its difference from rootscan:
    1. Rootscan is not multi-thread safe, using SetCurrentDir; rtscan is;
    2. Rootscan has too much nntp specific stuff; rtscan doesn't;

Author:

    Kangrong Yan ( KangYan )    23-Oct-1998

Revision History:

--*/
#include <windows.h>
#include <dbgtrace.h>
#include <rtscan.h>

//////////////////////////////////////////////////////////////////////////////////
// Private Methods
//////////////////////////////////////////////////////////////////////////////////
BOOL
CRootScan::IsChildDir( IN WIN32_FIND_DATA& FindData )
/*++
Routine description:

    Is the found data of a child dir ? ( Stolen from Jeff Richter's book )

Arguments:

    IN WIN32_FIND_DATA& FindData    - The find data of a file or directory

Return value:

    TRUE - Yes;
    FALSE - No
--*/
{
    return(
        (FindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY ) &&
        (FindData.cFileName[0] != '.') );
}

BOOL
CRootScan::MakeChildDirPath(   IN LPSTR    szPath,
                               IN LPSTR    szFileName,
                               OUT LPSTR   szOutBuffer,
                               IN DWORD    dwBufferSize )
/*++
Routine description:

    Append "szFileName" to "szPath" to make a full path.

Arguments:

    IN LPSTR    szPath  - The prefix to append
    IN LPSTR    szFileName - The suffix to append
    OUT LPSTR   szOutBuffer - The output buffer for the full path
    IN DWORD    dwBufferSize - The buffer size prepared

Return value:

    TRUE if success, FALSE otherwise

--*/
{
	_ASSERT( szPath );
	_ASSERT( strlen( szPath ) <= MAX_PATH );
	_ASSERT( szFileName );
	_ASSERT( strlen( szFileName ) <= MAX_PATH );
    _ASSERT( szOutBuffer );
    _ASSERT( dwBufferSize > 0 );

    LPSTR   lpstrPtr;

    if ( dwBufferSize < (DWORD)( lstrlen( szPath ) + lstrlen( szFileName ) + 2 ) ) {
        SetLastError( ERROR_INSUFFICIENT_BUFFER );
        return FALSE;
    }

    lstrcpy( szOutBuffer, szPath );
    lpstrPtr = szOutBuffer + lstrlen( szPath );
    if ( *( lpstrPtr - 1 )  == '\\' ) lpstrPtr--;
    *(lpstrPtr++) = '\\';

    lstrcpy( lpstrPtr, szFileName );    // trailing null should already be appended

    return TRUE;
}

HANDLE
CRootScan::FindFirstDir(    IN LPSTR                szRoot,
                            IN WIN32_FIND_DATA&     FindData )
/*++
Routine description:

    Find the first child directory under "szRoot".
    ( Stolen from Jeff Richter's book )

Arguments:

    IN LPSTR            szRoot  - Under which root to look for first child directory ?
    IN WIN32_FIND_DATA& FindData- Found results

Return value:

    HANDLE of first found directory.
--*/
{
	_ASSERT( szRoot );
	_ASSERT( strlen( szRoot ) <= MAX_PATH );
	
    CHAR    szPath[MAX_PATH+1];
    HANDLE  hFindHandle;
    BOOL    fFound;

    if ( !MakeChildDirPath( szRoot, "*", szPath, MAX_PATH )) {
        hFindHandle = INVALID_HANDLE_VALUE;
        goto Exit;
    }

    hFindHandle = FindFirstFile( szPath, &FindData );
    if ( hFindHandle != INVALID_HANDLE_VALUE ) {
        fFound = IsChildDir( FindData );

        if ( !fFound )
            fFound = FindNextDir( hFindHandle, FindData );

        if ( !fFound ) {
            FindClose( hFindHandle );
            hFindHandle = INVALID_HANDLE_VALUE;
        }
    }

Exit:
    return hFindHandle;
}

BOOL
CRootScan::FindNextDir(      IN HANDLE           hFindHandle,
                             IN WIN32_FIND_DATA& FindData )
/*++
Routine description:

    Find the next child directory.
    ( Stolen from Jeff Richter's book )

Arguments:

    IN HANDLE hFindHandle           - Find handle returned by find first
    IN WIN32_FIND_DATA& FindData    - Found results

Return value:

    TRUE    - Found
    FALSE   - Not found
--*/
{
    BOOL    fFound = FALSE;

    do
        fFound = FindNextFile( hFindHandle, &FindData );
    while ( fFound && !IsChildDir( FindData ) );

    return fFound;
}

BOOL
CRootScan::RecursiveWalk( LPSTR szRoot )
/*++
Routine description:

    Recursively walk the whole directory tree, call the notify interface
    for every directory found.

Arguments:

    LPSTR szRoot - The root directory.

Return value:

    TRUE if succeeded, FALSE otherwise
--*/
{
    TraceFunctEnter( "CRootScan::RecursiveWalk" );

    WIN32_FIND_DATA FindData;
    DWORD           err;

    //
    // Open the find handle
    //
    HANDLE hFind = FindFirstDir( szRoot, FindData );
    BOOL fFind = ( INVALID_HANDLE_VALUE != hFind );
    CHAR    szPath[MAX_PATH+1];

    while( fFind ) {

        //
        // Make up a full path to the found dir
        //
        if ( !MakeChildDirPath( szRoot,
                                FindData.cFileName,
                                szPath,
                                MAX_PATH ) ) {
            ErrorTrace( 0, "Make child dir failed %d", GetLastError() );
            _VERIFY( FindClose( hFind ) );
            return FALSE;
        }



        //
        // OK, we should ask cancel hint to see whether we should
        // continue
        //
        if ( m_pCancelHint && !m_pCancelHint->IShallContinue() ) {

            //
            // We should stop here
            //
            DebugTrace( 0, "We have been cancelled" );
            _VERIFY( FindClose( hFind ) );
            SetLastError( ERROR_OPERATION_ABORTED );
            return FALSE;
        }

        //
        // Dig into the found directory
        //
        if ( !RecursiveWalk( szPath ) ) {

            //
            // Relay the failure all the way out
            //
            err = GetLastError();
            ErrorTrace( 0, "RecusiveWalk failed at %s with %d",
                        FindData.cFileName, err );
            _VERIFY( FindClose( hFind ) );
            SetLastError( err );
            return FALSE;
        }

        //
        // Call the notify interface (after we recursivewalk all subfolder)
        //
        if ( !NotifyDir( szPath ) ) {

            //
            // Failed in notify dir, we should terminate the whole walk
            //
            ErrorTrace( 0, "Notify failed at %s with %d", szPath, GetLastError() );
            _VERIFY( FindClose( hFind ) );
            return FALSE;
        }
        
        //
        // We should  ask the cancel hint again
        //
        if ( m_pCancelHint && !m_pCancelHint->IShallContinue() ) {

            //
            // We should stop here
            //
            DebugTrace( 0, "We have been cancelled" );
            _VERIFY( FindClose( hFind ) );
            SetLastError( ERROR_OPERATION_ABORTED );
            return FALSE;
        }

        //
        // OK, we still need to find more child dirs
        //
        fFind = FindNextDir( hFind, FindData );
    }

    //
    // Now we are done with walk of our children
    //
    if ( hFind != INVALID_HANDLE_VALUE )
        _VERIFY( FindClose( hFind ) );
    return TRUE;
}

//////////////////////////////////////////////////////////////////////////////////
// Public Methods
//////////////////////////////////////////////////////////////////////////////////
BOOL
CRootScan::DoScan()
{
    //
    // just do recursive walk without notifying myself
    // because VRoot should not be a newsgroup
    //
    return RecursiveWalk( m_szRoot );


}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\nntp\core\include\watchci.h ===
#ifndef __WATCHCI_H__
#define __WATCHCI_H__

//
// this the function prototype for the callback function.  
//
// this is called during ReadCIRegistry() and CheckForChanges() as follows:
// If there are registry changes then:
//	 fn(WATCHCI_FIRST_CHANGE, NULL)
//   for (each catalog that is tied to an nntp instance)
//		fn(nntp instance, catalog path)
//   end
//   fn(WATCHCI_LAST_CHANGE, NULL)
//
// if there are no registry changes then nothing is called.
//
// the first call to the callback is used to clear any state information
// that service has about tripoli catalogs (so that if an nntp instance
// isn't being indexed anymore it won't try and call against old catalogs)
//
typedef void (*PWATCHCI_NOT_FN)(DWORD iNNTPInstance, WCHAR *pwszCatalog);
#define WATCHCI_FIRST_CHANGE 0x0
#define WATCHCI_LAST_CHANGE 0xffffffff

struct CCIRoot {
	CCIRoot *m_pNext;
	CCIRoot *m_pPrev;
	DWORD m_dwInstance;
	WCHAR *m_pwszPath;

	CCIRoot(DWORD dwInstance, WCHAR *pwszPath) : 
		m_pNext(NULL), m_pPrev(NULL), 
		m_dwInstance(dwInstance), m_pwszPath(pwszPath) {
	}

	~CCIRoot() {}
};


class CWatchCIRoots {
	public:
		CWatchCIRoots();
		// pszCIRoots is the path in the registry where Tripoli stores
		// its information.
		// it is probably TEXT("System\CurrentControlSet\ContentIndex")
		HRESULT	Initialize(WCHAR *pwszCIRoots);
		HRESULT Terminate();
		HRESULT CheckForChanges(DWORD dwTimeout = 0);
		HRESULT GetCatalogName(DWORD dwInstance, DWORD cbSize, WCHAR *pwszBuffer);
		~CWatchCIRoots();

	private:
		HANDLE m_heRegNot;		// event handle triggered when registry changes
		HKEY m_hkCI;			// registry handle to tripoli
		TFList<CCIRoot> m_CIRootList;
		CShareLockNH m_Lock;
		long m_dwUpdateLock;
		DWORD m_dwTicksLastUpdate;

		HRESULT QueryCIValue(HKEY hkPrimary, HKEY hkSecondary, 
							 LPCTSTR szValueName, LPDWORD pResultType,
							 LPBYTE pbResult, LPDWORD pcbResult);
		HRESULT QueryCIValueDW(HKEY hkPrimary, HKEY hkSecondary, 
		                       LPCTSTR szValueName, LPDWORD pdwResult);
		HRESULT QueryCIValueSTR(HKEY hkPrimary, HKEY hkSecondary, 
								LPCTSTR szValueName, LPCTSTR pszResult,
								PDWORD pchResult);
		HRESULT ReadCIRegistry(void);
		void UpdateCatalogInfo(void);
		void EmptyList();
};

#define REGCI_CATALOGS TEXT("Catalogs")
#define REGCI_ISINDEXED TEXT("IsIndexingNNTPSvc")
#define REGCI_LOCATION TEXT("Location")
#define REGCI_NNTPINSTANCE TEXT("NNTPSvcInstance")

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\nntp\core\include\timeconv.h ===
/*-------------------------------------------------------------------------
  timeconv.h
  	Function prototypes for time conversion functions.


  Copyright (C) 1994  Microsoft Corporation.

  Author
  	Lindsay Harris	- lindsayh

  History
	14:08 on Wed 20 Apr 1994    -by-    Lindsay Harris   [lindsayh]
  	First version, now that there are 2 time functions!

  --------------------------------------------------------------------------*/

#if  !defined( _TIMECONV_H )

#define	_TIMECONV_H


/*
 *  Convert an ARPA/Internet time/date string to time_t format.  Used when
 *  generating the index data for Usenet news feed.
 */

DWORD   dwConvertAsciiTime( char * );


const DWORD cMaxArpaDate = 33;
/*
 *  Generate an ARPA/Internet time format string for current time.
 *  You must pass in a buffer of type char [cMaxArpaDate]
 */

char  *
GetArpaDate( char rgBuf[ cMaxArpaDate ] );

const DWORD cMaxMessageIDDate = 12;	// (64 / 6) + 2
/*
 *  Generate a time format string for current time that
 *  can be used to generate part of a message id.
 *  You must pass in a buffer of type char [cMaxMessageIDDate]
 */

char  *
GetMessageIDDate( DWORD GroupId, DWORD ArticleId, char rgBuf[ cMaxMessageIDDate ] );

/*
 *  Convert a structure of type SYSTEMTIME to a time_t value.
 *  Returns 0 if the date is before 1970.
 */

time_t SystemTimeToTime_T(SYSTEMTIME & st);

/*
 * Convert between changes in FILETIMEs and changes in time_t's (and visa versa)
 */

time_t dTime_tFromDFiletime(const FILETIME & li);

/*
 *   Add, Subtract, and Compare FILETIMES
 */

FILETIME filetimeSubtract(const FILETIME & ft1, const FILETIME & ft2);
BOOL filetimeGreaterThan(const FILETIME & ft1, const FILETIME & ft2);

#endif		// _TIMECONV_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\nntp\core\include\xover.h ===
/*++

  XOVER.H

	This file defines the interfaces used to cache XOVER information.


--*/


#ifndef	_XOVER_H_
#define	_XOVER_H_

#include	"tfdlist.h"

// This callback function is used to issue a stop hint during a
// long spin while shutting down so that the shutdown won't time
// out.
typedef void (*PSTOPHINT_FN)();

//
//	Initialization and termination functions - call before anything else in here !!
//
extern	BOOL	XoverCacheLibraryInit(DWORD cNumXixObjectsPerTable = 0) ;
extern	BOOL	XoverCacheLibraryTerm() ;



//
//	Maximum number of 'handles' we will have open !
//	This refers to the maximum number of CXoverIndex's
//	we will let clients keep open.
//
#ifndef	DEBUG
#define	MAX_HANDLES			512
#else
#define	MAX_HANDLES			32
#endif


class	CXoverIndex ;

//
//	For external users they should treat CXIDXPTR's as handles
//	AND never dereference them !!
//
class	HXOVER	{
private : 
	//
	//	Our friends can access this stuff !
	//
	friend	class	CXoverIndex ;
	friend	class	CXoverCacheImplementation ;

	class	CXoverIndex*	m_pIndex ;
	
	//
	//	Only two mechanisms for setting the CXoverIndex object pointer !
	//
	HXOVER(	class	CXoverIndex*	pIndex ) : 
		m_pIndex( pIndex ) {}

	//
	//	and we will support the assignment operator !
	//
	HXOVER&	operator=( class	CXoverIndex*	pIndex ) ;

	//
	//	let internal users dereference us !
	//
	class	CXoverIndex*	operator->()	const	{	
		return	m_pIndex ;
	}

	//
	//	When we need to call member function pointers use this : 
	//
	class	CXoverIndex*	Pointer()	const	{
		return	m_pIndex ;
	}

	BOOL	operator==(	class	CXoverIndex*	pRight )	const	{
		return	m_pIndex == pRight ;
	}

	BOOL	operator!=(	class	CXoverIndex*	pRight )	const	{
		return	m_pIndex != pRight ;
	}

public : 
	//
	//	Only default constructor is available to external users !
	//
	HXOVER() : m_pIndex( 0 )	{}

	//
	//	outside users don't get to do anything but declare and destroy !
	//
	~HXOVER() ;
} ;


class	CXoverCacheCompletion	{
private : 

	friend	class	CXoverCacheImplementation ;
	friend	class	CXoverIndex ;

	//
	//	this lets us keep track of all of these guys !
	//		
	DLIST_ENTRY		m_list ;

public : 

	//
	//	Helper function for internal use only !
	//
	inline	static
	DLIST_ENTRY*
	PendDLIST(	CXoverCacheCompletion*	p ) {
		return	&p->m_list ;
	}

	typedef		DLIST_ENTRY*	(*PFNDLIST)( class	CXoverCacheCompletion* pComplete ) ; 

	//
	//	Provide the XOVER Cache a way to do the real XOVER operation !
	//
	virtual	
	void
	DoXover(	ARTICLEID	articleIdLow,
				ARTICLEID	articleIdHigh,
				ARTICLEID*	particleIdNext, 
				LPBYTE		lpb, 
				DWORD		cb,
				DWORD*		pcbTransfer, 
				class	CNntpComplete*	pComplete
				) = 0 ;

	//
	//	this function is called when the operation completes !
	//
	virtual
	void
	Complete(	BOOL		fSuccess, 
				DWORD		cbTransferred, 
				ARTICLEID	articleIdNext
				) = 0 ;

	//
	//	Get the arguments for this XOVER operation !
	//
	virtual
	void
	GetArguments(	OUT	ARTICLEID&	articleIdLow, 
					OUT	ARTICLEID&	articleIdHigh,
					OUT	ARTICLEID&	articleIdGroupHigh,
					OUT	LPBYTE&		lpbBuffer, 
					OUT	DWORD&		cbBuffer
					) = 0 ;	

	//
	//	Get only the range of articles requested for this XOVER op !
	//
	virtual
	void
	GetRange(	OUT	GROUPID&	groupId,
				OUT	ARTICLEID&	articleIdLow,
				OUT	ARTICLEID&	articleIdHigh,
				OUT	ARTICLEID&	articleIdGroupHigh
				) = 0 ;

} ;
		


class	CXoverCache	{
public : 

	//
	//	Destructor
	//
	virtual ~CXoverCache() {}

	//
	//	Canonicalize the Article id 
	//
	virtual	ARTICLEID	
	Canonicalize(	
			ARTICLEID	artid 
			) = 0 ;

	//
	//	Initialize the Xover Cache
	//
	virtual	BOOL
	Init(		
#ifndef	DEBUG
		long	cMaxHandles = MAX_HANDLES,
#else
		long	cMaxHandles = 5,
#endif
		PSTOPHINT_FN pfnStopHint = NULL
		) = 0 ;

	//
	//	Shutdown the background thread and kill everything !
	//
	virtual	BOOL
	Term() = 0 ;

#if 0 
	//
	//	Add an Xover entry to the appropriate file !
	//
	virtual	BOOL
	AppendEntry(		
				IN	GROUPID	group,
				IN	LPSTR	szPath,
				IN	ARTICLEID	article,
				IN	LPBYTE	lpbEntry,
				IN	DWORD	Entry
				) = 0 ;
	//
	//	Given a buffer fill it up with the specified xover data !
	//
	virtual	DWORD
	FillBuffer(	
			IN	BYTE*		lpb,
			IN	DWORD		cb,
			IN	DWORD		groupid,
			IN	LPSTR		szPath,
			IN	BOOL		fFlatDir,
			IN	ARTICLEID	artidStart, 
			IN	ARTICLEID	artidFinish,
			OUT	ARTICLEID	&artidLast,
			OUT	HXOVER		&hXover
			) = 0 ;

	//
	//	Given a buffer fill it up with the specified 
	//	Listgroup data !
	//
	virtual	DWORD
	ListgroupFillBuffer(	
			IN	BYTE*		lpb,
			IN	DWORD		cb,
			IN	DWORD		groupid,
			IN	LPSTR		szPath,
			IN	BOOL		fFlatDir,
			IN	ARTICLEID	artidStart, 
			IN	ARTICLEID	artidFinish,
			OUT	ARTICLEID	&artidLast,
			OUT	HXOVER		&hXover
			) = 0 ;
#endif

	//
	//	This issues the asynchronous version of the XOVER request !
	//
	virtual	BOOL
	FillBuffer(
			IN	CXoverCacheCompletion*	pRequest,
			IN	LPSTR	szPath, 
			IN	BOOL	fFlatDir, 
			OUT	HXOVER&	hXover
			) = 0 ;	

	//
	//	Dump everything out of the cache !
	//
	virtual	BOOL	
	EmptyCache() = 0 ;

	//
	//	Dump all Cache entries for specified group from the cache !
	//	Note : when articleTop is 0 ALL cache entries are dropped, 
	//	whereas when its something else we will drop only cache entries
	//	which fall below articleTop
	//
	virtual	BOOL	
	FlushGroup(	
			IN	GROUPID	group,
			IN	ARTICLEID	articleTop = 0,
			IN	BOOL	fCheckInUse = TRUE
			) = 0 ;

	//
	//	Delete all Xover index files for the specified group
	//	to the specified article -id
	//
	virtual	BOOL	
	ExpireRange(
			IN	GROUPID	group,
			IN	LPSTR	szPath,
			IN	BOOL	fFlatDir,
			IN	ARTICLEID	articleLow, 
			IN	ARTICLEID	articleHigh,
			OUT	ARTICLEID&	articleNewLow
			) = 0 ;

	//
	//	Remove an Xover entry !
	//
	virtual	BOOL
	RemoveEntry(
			IN	GROUPID	group,
			IN	LPSTR	szPath,
			IN	BOOL	fFlatDir,
			IN	ARTICLEID	article
			) = 0 ;
	

	//
	//	This function creates an object which implements this interface !!
	//
	static	CXoverCache*	
	CreateXoverCache() ;

} ;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\nntp\driver\nntpfs\src\dllmain.cpp ===
#include "stdafx.h"
#include "resource.h"

#include "initguid.h"

#include "nntpdrv.h"
#include "nntpfs.h"
#include "fsdriver.h"
#include "fsthrd.h"

#define HEAP_INIT_SIZE (1024 * 1024)  // BUGBUG: this might be setable later 

CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
	OBJECT_ENTRY(CLSID_CNntpFSDriverPrepare, CNntpFSDriverPrepare)
END_OBJECT_MAP()


/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/) {

    BOOL    fSuccess = FALSE; 

	if (dwReason == DLL_PROCESS_ATTACH) {

        //
        // Create Global Heap - Add Ref to global heap, in fact
        //
        _VERIFY( fSuccess = CreateGlobalHeap(   NUM_EXCHMEM_HEAPS,
                                                    0,
                                                    HEAP_INIT_SIZE,
                                                    0 ) );
        if ( FALSE == fSuccess ) {
            SetLastError( ERROR_OUTOFMEMORY );
            return FALSE;
        }

         _Module.Init(ObjectMap, hInstance);
         DisableThreadLibraryCalls(hInstance);

        //
        // Initialize the global static lock
        //
		CNntpFSDriver::s_pStaticLock = XNEW CShareLockNH;
		if ( NULL == CNntpFSDriver::s_pStaticLock ) {
			SetLastError( ERROR_OUTOFMEMORY );
			return FALSE;
		}
	}
	else if (dwReason == DLL_PROCESS_DETACH) {

        //
        // Clean up the global lock
        //
		_ASSERT( CNntpFSDriver::s_pStaticLock );
		XDELETE CNntpFSDriver::s_pStaticLock;
        CNntpFSDriver::s_pStaticLock = NULL;

		_Module.Term();

        //
        // Destroy global heap, Dec ref, in fact
        //
        _VERIFY( DestroyGlobalHeap() );
	}
	return (TRUE);    // ok
}


/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void) {
	HRESULT hRes = (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
	return (hRes);
}


/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv) {
	HRESULT hRes = _Module.GetClassObject(rclsid,riid,ppv);
	return (hRes);
}


/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void) {
	// registers object, typelib and all interfaces in typelib
	HRESULT hRes = _Module.RegisterServer(TRUE);
	return (hRes);
}


/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void) {
	_Module.UnregisterServer();
	return (S_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\nntp\driver\nntpfs\src\fsdirwlk.cpp ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:		

    fsdirwlk.cpp

Abstract:

    This is the implementation for the file system store driver's rootscan.
    The rootscan ( or dirwalk ) is used in rebuild.

Author:

    Kangrong Yan ( KangYan )    23-Oct-1998

Revision History:

--*/
#include "stdafx.h"
#include "resource.h"
#include "nntpdrv.h"
#include "nntpfs.h"
#include "fsdriver.h"

BOOL
CNntpFSDriverRootScan::HasPatternFile(  LPSTR szPath,
                                        LPSTR szPattern )
/*++
Routine description:

    Check the directory to see if he has the files in given pattern.

Arguments:

    LPSTR szPath    - The dir path to check.
    LPSTR szPattern - The pattern to look for

Arguments:

    TRUE if it has the pattern, FALSE otherwise
--*/
{
    TraceFunctEnter( "CNntpFSDriverRootScan::HasPatternFile" );
    _ASSERT( szPath );
    _ASSERT( szPattern );

    CHAR    szFullPath[MAX_PATH+1];
    WIN32_FIND_DATA FindData;
    BOOL    fHasPattern = FALSE;

    //
    // Make up the final pattern - fully qualified
    //
    if ( SUCCEEDED( CNntpFSDriver::MakeChildDirPath(    szPath,
                                                        szPattern,
                                                        szFullPath,
                                                        MAX_PATH ) ) ){
        HANDLE hFind = INVALID_HANDLE_VALUE;
        hFind = FindFirstFile( szFullPath, &FindData );
        if ( INVALID_HANDLE_VALUE != hFind ) {

            fHasPattern = TRUE;
            
            _VERIFY( FindClose( hFind ) );
        }
    }

    //
    // Whether we had difficulty making full path or find first file failed,
    // we'll assume that the pattern is not found
    //
    TraceFunctLeave();
    return fHasPattern;
}

BOOL
CNntpFSDriverRootScan::HasSubDir( LPSTR szPath )
/*++
Routine description:

    Check the path to see if he has sub dir .

Arguments:

    LPSTR szPath - The path to check

Return value:

    TRUE if it does have sub dir, FALSE otherwise
--*/
{
    TraceFunctEnter( "CNntpFSDriverRootScan::HasSubDir" );
    _ASSERT( szPath );

    WIN32_FIND_DATA FindData;
    HANDLE          hFind = INVALID_HANDLE_VALUE;
    CHAR            szPattern[MAX_PATH+1];
    BOOL            fHasSubDir = FALSE;
    BOOL            fFound = FALSE;

    if ( SUCCEEDED( CNntpFSDriver::MakeChildDirPath(    szPath,
                                                        "*",
                                                        szPattern,
                                                        MAX_PATH ) ) ) {
        hFind = FindFirstFile( szPattern, &FindData );
        fFound = ( INVALID_HANDLE_VALUE != hFind );

        while ( fFound && !fHasSubDir ) {
        
            fHasSubDir = CNntpFSDriver::IsChildDir( FindData );

            if ( !fHasSubDir ) fFound = FindNextFile( hFind, &FindData );
        }

        if ( INVALID_HANDLE_VALUE != hFind ) _VERIFY( FindClose( hFind ) );
    }

    TraceFunctLeave();
    return fHasSubDir;
}

/*++
Routine description:

    If this directory is empty, remove the directory
    
Arguments:

    LPSTR szPath - The path to check

Return value:

    void
    
--*/
void
CNntpFSDriverRootScan::IfEmptyRemoveDirectory( LPSTR szPath )
{
	BOOL ret;
	// never remove temp directory
	if ( strstr( szPath, "_temp.files_" ) ) {
		return;
	}
	ret=CNntpFSDriver::IfEmptyRemoveDirectory(szPath);
	// return value is not important here. 
	// We don't recursively delete parent now. The RootScan will check parent later
	return;

}
        
BOOL
CNntpFSDriverRootScan::WeShouldSkipThisDir( LPSTR szPath )
/*++
Routine description:

    Check if we should skip this directory

Arguments:

    LPSTR szPath - The directory path

Return value:

    TRUE if we should skip this dir, FALSE if we shouldn't

--*/
{
	TraceFunctEnter( "CNntpFSDriverRootScan::WeShouldSkipThisDir" );
	_ASSERT( szPath );
	CHAR szFile[MAX_PATH];

	//
	// We should skip all directories that have _temp.files_ in it
	//
	if ( strstr( szPath, "_temp.files_" ) ) {
		return TRUE;
	}

	if (!m_bNeedToDropTagFile)
	{
		// tag files are initialized, we just check if newsgrp.tag is in this directory

		if ( FAILED( CNntpFSDriver::MakeChildDirPath( szPath, "newsgrp.tag", szFile, sizeof(szFile) ) ) ) 
		{
			// this should not happen
			ErrorTrace(0, "File path error failed in %s - %x", szPath, TYPE_E_BUFFERTOOSMALL );
			// skip this directory
			return TRUE;
		}	
		if(CNntpFSDriver::CheckFileExists(szFile)) return FALSE;
		else return TRUE;
	}
	else
	{
		//
		// Tag files are not present and we should put a tag file using our original rules
		// If we are asked not to skip any dir, we shouldn't skip it
		//
		if ( !m_fSkipEmpty ) {	
			return FALSE;
		}

		//
		// If we are asked to skip empty directories, then we should
		// check if this directory has any news messages
		//
		BOOL fNoMessage = !HasPatternFile( szPath, "*.nws" );
		if ( fNoMessage ) {
			//
			// We still don't want to skip leaves
			//
			if ( !HasSubDir( szPath) ) return FALSE;
			else return TRUE;
		} else 
			return FALSE;
	} 
}


BOOL
CNntpFSDriverRootScan::CreateGroupInTree(   LPSTR               szPath,
                                            INNTPPropertyBag    **ppPropBag)
/*++
Routine description:

    Create the news group in newstree

Arguments:

    LPSTR szPath - The path to be converted into a newsgroup name

Return value:

    TRUE if succeeded, FALSE otherwise
--*/
{
    TraceFunctEnter( "CNntpFSDriverRootScan::CreateGroupInTree" );
    _ASSERT( szPath );

    //
    // Lets ask the driver to do it, since he has better experience 
    // dealing with newstree
    //
    _ASSERT( m_pDriver );
    HRESULT hr = m_pDriver->CreateGroupInTree( szPath, ppPropBag);

    SetLastError( hr );
    return SUCCEEDED( hr );
}

BOOL
CNntpFSDriverRootScan::CreateGroupInVpp( INNTPPropertyBag *pPropBag )
/*++
Routine description;

    Create the group in vpp file

Arguments:

    INNTPPropertyBag *pPropBag - The group's property bag

Return Value:

    TRUE if succeeded, FALSE otherwise
--*/
{
    TraceFunctEnter( "CNntpFSDriverRootScan::CreateGroupInVpp" );
    _ASSERT( pPropBag );
    DWORD   dwOffset;

    //
    // Lets ask the driver to do it, since he has better experience
    // dealing with newstree
    //
    _ASSERT( m_pDriver );
    HRESULT hr = m_pDriver->CreateGroupInVpp( pPropBag, dwOffset );

    SetLastError( hr );
    return SUCCEEDED( hr );
}

BOOL
CNntpFSDriverRootScan::NotifyDir( LPSTR szPath )
/*++
Routine description:

    Handle the notification of each dir being found.  What we'll do 
    with this is to convert the path into group name and create it
    into newstree.  Notice that for those rebuilds that can use
    vpp file, when the vpp file is not corrupted, rootscan can be avoided.
    If we have to do rootscan, the only group property we have is group 
    name.  So we'll ask the newstree to assign group id, etc.  After
    the group has been created in the newstree, we'll set the properties
    into vpp file.

Arguments:

    LPSTR szPath - The path found

Return value:

    TRUE if succeeded, FALSE otherwise
--*/
{
    TraceFunctEnter( "CNntpFSDriverRootScan::NotifyDir" );
    _ASSERT( szPath );

    INNTPPropertyBag    *pPropBag = NULL;
    HANDLE              hDir = INVALID_HANDLE_VALUE;
    HRESULT             hr1, hr2;

    //
    // Check to see if we should skip this dir because it's empty
    //
    if ( WeShouldSkipThisDir( szPath ) ) {
        DebugTrace( 0, "Dir %s skipped", szPath );
        IfEmptyRemoveDirectory(szPath);
        return TRUE;
    }
    if ( m_bNeedToDropTagFile )
    {
        	hr1 = CNntpFSDriver::CreateAdminFileInDirectory(szPath, "newsgrp.tag");
		if ( FAILED( hr1 ) ) {
			ErrorTrace( 0, "create newsgrp.tag file in %s failed: %x", szPath, hr1 );
			return FALSE;
		}
    }
    //
    // We ask the newstree to create this group
    //
    if ( !CreateGroupInTree( szPath, &pPropBag ) ) {
        ErrorTrace( 0, "Create group in newstree failed %x", GetLastError() );
        // special case, just skip the invalid name directories instead of failing the entire thing
        if (HRESULT_FROM_WIN32(ERROR_INVALID_NAME) == GetLastError())
        {
            DebugTrace( 0, "Dir %s invalid name skipped", szPath );
            return TRUE;
        }
        else
            return FALSE;
    }

    _ASSERT( pPropBag );

    //
    // Create time is something that we can not get from anywhere else,
    // so we'll use the directory creation time
    //
    hDir = CreateFile(  szPath,
                        GENERIC_READ,
                        FILE_SHARE_READ,
                        0,
                        OPEN_EXISTING,
                        FILE_FLAG_BACKUP_SEMANTICS,
                        0 );
    if (hDir != INVALID_HANDLE_VALUE)
    {
        // Get directory info
        BY_HANDLE_FILE_INFORMATION  bhfi;
        if (!GetFileInformationByHandle( hDir, &bhfi ))
        {
            // Can't get directory info
            ErrorTrace(0,"err:%d Can't get dir info %s",GetLastError(),szPath);
            _ASSERT(FALSE);
            _VERIFY( CloseHandle( hDir ) );
            pPropBag->Release();
            return FALSE;
        }
        else
        {
            // get the creation date
            hr1 = pPropBag->PutDWord( NEWSGRP_PROP_DATELOW, bhfi.ftCreationTime.dwLowDateTime );
            hr2 = pPropBag->PutDWord( NEWSGRP_PROP_DATEHIGH,bhfi.ftCreationTime.dwHighDateTime );
            if ( FAILED( hr1 ) || FAILED( hr2 ) ) {
                ErrorTrace( 0, "Put creation date properties failed %x %x", hr1, hr2 );
                _VERIFY( CloseHandle( hDir ) );
                pPropBag->Release();
                return FALSE;
            }
        }
        
        // close handle
        if (hDir != INVALID_HANDLE_VALUE)
        {    _VERIFY( CloseHandle(hDir) );
            hDir = INVALID_HANDLE_VALUE;
        }
    }

    //
    // Remember: we have one reference on this bag, we should release it
    //

    //
    // We ask the driver to create it in vpp file
    //
    if ( !CreateGroupInVpp( pPropBag ) ) {
        ErrorTrace( 0, "Create group in vpp file failed %x", GetLastError() );
        pPropBag->Release();
        return FALSE;        
    }

    //
    // Release bag and return
    //
    pPropBag->Release();
    TraceFunctLeave();
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\nntp\driver\nntpfs\src\fsprep.cpp ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    fsprep.cpp

Abstract:

    This is the implementation for the file system store driver's
	prepare interface.

Author:

    Kangrong Yan ( KangYan )    16-March-1998

Revision History:

--*/

#include "stdafx.h"
#include "resource.h"
#include "nntpdrv.h"
#include "nntpfs.h"
#include "fsdriver.h"

#include <stdio.h>


//////////////////////////////////////////////////////////////////////////
// Interface Methods - CNntpFSDriverPrepare
//////////////////////////////////////////////////////////////////////////

HRESULT CNntpFSDriverPrepare::FinalConstruct() {
    return (CoCreateFreeThreadedMarshaler(GetControllingUnknown(),
										  &m_pUnkMarshaler.p));
}

VOID CNntpFSDriverPrepare::FinalRelease() {
    m_pUnkMarshaler.Release();
}

void STDMETHODCALLTYPE
CNntpFSDriverPrepare::Connect(  LPCWSTR	wszVRootPath,
								LPCSTR szGroupPrefix,
								IUnknown *punkMetabase,
								INntpServer *pServer,
								INewsTree *pINewsTree,
								INntpDriver **pIGoodDriver,
								INntpComplete *pICompletion,
								HANDLE  hToken,
								DWORD   dwFlag )
{
	TraceFunctEnter( "CNntpFSDriverPrepare::Connect" );
	_ASSERT( wszVRootPath );
	_ASSERT( lstrlenW( wszVRootPath ) <= MAX_PATH );
	_ASSERT( pServer );
	_ASSERT( pINewsTree );
	_ASSERT( pIGoodDriver );
	_ASSERT( pICompletion );

	HRESULT hr;
	CONNECT_CONTEXT *pConnectContext;
	CNntpFSDriverConnectWorkItem *pConnectWorkItem = NULL;

	if (lstrlenW(wszVRootPath) > MAX_PATH || strlen(szGroupPrefix) > MAX_NEWSGROUP_NAME) {
        hr = E_INVALIDARG;
        ErrorTrace( 0, "Bad parameter" );
        punkMetabase->Release();
        pServer->Release();
        pINewsTree->Release();
        pICompletion->SetResult( hr );
        pICompletion->Release();
        return;
	}

	// Save all the parameters
	wcscpy( m_wszVRootPath, wszVRootPath );
	strcpy( m_szGroupPrefix, szGroupPrefix );
	m_punkMetabase = punkMetabase;
	m_pServer = pServer;
	m_ppIGoodDriver = pIGoodDriver;
	m_pINewsTree = pINewsTree;
	m_hToken = hToken;
	m_dwConnectFlags = dwFlag;
	DWORD   dw;

    // Allocate the connect context
    pConnectContext = XNEW CONNECT_CONTEXT;
    _ASSERT( pConnectContext );
    if ( NULL == pConnectContext ) {
        hr = E_OUTOFMEMORY;
        ErrorTrace( 0, "Creating connect context out of memory" );
        punkMetabase->Release();
        pServer->Release();
        pINewsTree->Release();
        pICompletion->SetResult( hr );
        pICompletion->Release();
        //SetEvent( m_hConnect );
        return;
    }

    // else, set contexts
    pConnectContext->pPrepare = this;
    pConnectContext->pComplete = pICompletion;

    // Create the connect workitem to be queued to thread pool
    pConnectWorkItem = XNEW CNntpFSDriverConnectWorkItem( pConnectContext );
    if ( NULL == pConnectWorkItem ) {
        XDELETE pConnectContext;
        hr = E_OUTOFMEMORY;
        ErrorTrace( 0, "Allocate Connect workitem failed" );
        punkMetabase->Release();
        pServer->Release();
        pINewsTree->Release();
        pICompletion->SetResult( hr );
        pICompletion->Release();
        return;
    }

    // Now queue the work item to the thread pool
    _ASSERT( g_pNntpFSDriverThreadPool );
    AddRef();   // add ref to myself, connect internal will release it
    if ( !g_pNntpFSDriverThreadPool->PostWork( pConnectWorkItem ) ) {
        hr = HRESULT_FROM_WIN32( GetLastError() );
        hr = SUCCEEDED( hr ) ? E_UNEXPECTED : hr;
        ErrorTrace( 0, "Queue a connect work item failed %x", hr );
        XDELETE pConnectWorkItem;
        XDELETE pConnectContext;
        punkMetabase->Release();
        pServer->Release();
        pINewsTree->Release();
        pICompletion->SetResult( hr );
        pICompletion->Release();
        Release();
        return;
    }

	TraceFunctLeave();
	return;
}

DWORD WINAPI
CNntpFSDriverPrepare::ConnectInternal(	PVOID pvContext )
{
	TraceFunctEnter( "CNntpFSDriverPrepare::ConnectInternal" );
    _ASSERT( pvContext );
    CONNECT_CONTEXT *pConnectContext = (CONNECT_CONTEXT *)pvContext;
	CNntpFSDriverPrepare *pPrepare = pConnectContext->pPrepare;
	_ASSERT( pPrepare );
	INntpComplete *pComplete = pConnectContext->pComplete;
	_ASSERT( pComplete );

	_ASSERT( lstrlenW( pPrepare->m_wszVRootPath ) <= MAX_PATH );
	_ASSERT( pPrepare->m_pServer );
	_ASSERT( pPrepare->m_pINewsTree );
	_ASSERT( pPrepare->m_ppIGoodDriver );
	//_ASSERT( pPrepare->m_pICompletion );

	HRESULT 		hr = S_OK;
	INntpDriver 	*pIDriver = NULL;
	DWORD           cRetry = 0;
	INIT_CONTEXT    InitContext;

	// Create the driver instance
	IUnknown *pI = CreateDriverInstance();	// added one ref here
	if( NULL == pI ) {
	 	ErrorTrace(0, "Create driver instance fail" );
	 	hr = NNTP_E_CREATE_DRIVER;
		goto SetResult;
	}

	// QI: ref bumped again
	hr = pI->QueryInterface( IID_INntpDriver, (void**)&pIDriver );
	if ( FAILED( hr ) ) {
		ErrorTrace( 0, "QI failed %x", hr );
		pI->Release();
		goto SetResult;
	}

	// Release the IUnknown interface
	pI->Release();

    do {
        if ( FAILED( hr ) )  Sleep( INIT_RETRY_WAIT );

    	// Call the initialization
    	InitContext.m_dwFlag = pPrepare->m_dwConnectFlags;
	    hr = pIDriver->Initialize( 	pPrepare->m_wszVRootPath,
		    						pPrepare->m_szGroupPrefix,
			    					pPrepare->m_punkMetabase,
				    				pPrepare->m_pServer,
					    			pPrepare->m_pINewsTree,
						    		&InitContext,
						    		NULL,	// I don't use this flag yet
								    pPrepare->m_hToken
    								);

    } while ( hr == HRESULT_FROM_WIN32( ERROR_SHARING_VIOLATION )
                && !InterlockedCompareExchange( &pPrepare->m_lCancel, 0, 0 )
                && ++cRetry < MAX_RETRY );

	if ( FAILED( hr ) ) {
		    ErrorTrace( 0, "Driver initialization failed %x", hr );
    	   	goto SetResult;
    }

	// Prepare for return
	*pPrepare->m_ppIGoodDriver = pIDriver;	// now we only have one reference on the
								// good interface, which is owned by
								// the client - protocol
SetResult:

    // whether we failed or succeeded, we should release the metabase pointer
    pPrepare->m_punkMetabase->Release();

    // If we have failed, we should clean up a bunch of pointers
    if ( FAILED( hr ) ) {
        _ASSERT( pPrepare->m_pServer );
        pPrepare->m_pServer->Release();
        _ASSERT( pPrepare->m_pINewsTree );
        pPrepare->m_pINewsTree->Release();
        if ( pIDriver ) pIDriver->Release();
    }

	pComplete->SetResult( hr );

	//
	// Prepare object can go away now
	//
	pPrepare->Release();
    pComplete->Release();
	TraceFunctLeave();

	return 0;
}

/////////////////////////////////////////////////////////////////////////
// Private methods - CNntpFSDriverPrepare
/////////////////////////////////////////////////////////////////////////

//
// Create instance of good driver
//
IUnknown*
CNntpFSDriverPrepare::CreateDriverInstance()
{
	IUnknown *pI = static_cast<INntpDriver*>(XNEW CNntpFSDriver);
	if (pI != NULL)
		pI->AddRef();
	return pI;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\nntp\driver\nntpfs\src\fsthrd.h ===
/******************************************************************************

Copyright (c) 1998 Microsoft Corporation
All rights reserved.

Modula:

    fsthrd.h

Abstract:

    This thread pool object handles all FSDriver's thread pool works. 
    It derives from CThreadPool ( by RajeevR ).
    
Authors:

    KangYan      Kangrong Yan     Sept. 17, 1998

History:
    09/17/98    KangYan      Created

******************************************************************************/

#ifndef _FSTHRD_H_
#define _FSTHRD_H_
#include <thrdpl2.h>

//
// Class definition for file system driver's work item.
// Derived classes should implement what should be done
// by the thread
//
class CNntpFSDriverWorkItem   //fw
{
public:
    CNntpFSDriverWorkItem( PVOID pvContext ) : m_pvContext( pvContext ) {};
    virtual ~CNntpFSDriverWorkItem(){};
    virtual VOID Complete() = 0;

protected:

    PVOID   m_pvContext;
};


//
// Class definition for file system driver's thread pool
//
class CNntpFSDriverThreadPool : public CThreadPool  //fp
{
    
public:
    CNntpFSDriverThreadPool(){};
    ~CNntpFSDriverThreadPool(){};

protected:
    virtual VOID
    WorkCompletion( PVOID pvWorkContext) {
        //
        // I know that the WorkContext passed in must 
        // be CNntpFSDriverWorkItem
        //
        CNntpFSDriverWorkItem *pWorkItem = (CNntpFSDriverWorkItem*)pvWorkContext;
        _ASSERT( pWorkItem );

        pWorkItem->Complete();

        delete pWorkItem;
    }

    //
    // This function implements cleaning up of the thread pool
    //
    virtual VOID
    AutoShutdown() {

        //
        // Call the thread pool's terminate, notice that it should not wait for 
        // the handle of himself because thread pool's Terminate implementation
        // will skip our own thread handle
        //
        Terminate( FALSE, FALSE );

        //
        // Delete myself
        //
        XDELETE this;

        //
        // The pool is gone, decrement the module lock
        //
        _Module.Unlock();
    }
};

#endif // _FSTHRD_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\nntp\driver\nntpfs\src\fsdriver.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    fsdriver.h

Abstract:

    This is the definition for the file system store driver class.

Author:

    Kangrong Yan ( KangYan )    16-March-1998

Revision History:

--*/

#ifndef __FSDRIVER_H__
#define __FSDRIVER_H__

#include "nntpdrv.h"
#include <mailmsg.h>
#include <drvid.h>
#include "fsthrd.h"
#include <iadmw.h>
#include <artcore.h>
#include <rtscan.h>
#include <isquery.h>

//
// Macros for thread pool
//
#define POOL_MAX_THREADS 5      // BUGBUG: this might be setable from registry
#define POOL_START_THREADS 1    // BUGBUG: this might be setable later

//
// Macros
//
#define TERM_WAIT 500	
#define INIT_RETRY_WAIT 500
#define MAX_RETRY   10
#define MAX_GROUPNAME 1024
#define PROPBAG_BUFFERSIZE 516

//
// Variable lengthed group property record type
//
const DWORD HeaderSize =  10 * sizeof( USHORT ) + sizeof(DWORD) + sizeof(FILETIME);
const DWORD MaxRecordSize =   MAX_RECORD_SIZE - HeaderSize ;
const DWORD RecordContentOffset = HeaderSize;
const USHORT OffsetNone = 0;

#define RECORD_ACTUAL_LENGTH( _rec_ )		\
		( 	HeaderSize +					\
			(_rec_).cbGroupNameLen + 		\
			(_rec_).cbNativeNameLen +		\
			(_rec_).cbPrettyNameLen +		\
			(_rec_).cbDescLen +				\
			(_rec_).cbModeratorLen )
			
struct VAR_PROP_RECORD {	//vp
    DWORD   dwGroupId;
    FILETIME    ftCreateTime;
	USHORT	iGroupNameOffset;
	USHORT	cbGroupNameLen;
	USHORT	iNativeNameOffset;
	USHORT	cbNativeNameLen;
	USHORT	iPrettyNameOffset;
	USHORT	cbPrettyNameLen;
	USHORT	iDescOffset;
	USHORT	cbDescLen;
	USHORT	iModeratorOffset;
	USHORT	cbModeratorLen;
	BYTE	pData[MaxRecordSize];
};

// structure passed to CacheCreateFile callback function
// to tell the callback UNC identity and hToken
struct CREATE_FILE_ARG {
    BOOL    bUNC;
    HANDLE  hToken;
};

typedef struct {
    DWORD m_dwFlag;
} INIT_CONTEXT, *PINIT_CONTEXT;

//
// Extern variables
//
extern CNntpFSDriverThreadPool *g_pNntpFSDriverThreadPool;

//
// Implementation class for the driver's good interface.  The
// driver's good interface carries all the features that the
// protocol needs to talk to
//
class CNntpFSDriver :
	public INntpDriver,
	public IMailMsgStoreDriver,
	public INntpDriverSearch
{

    // INntpDriver
    public:

        enum InvalidateStatus {
    	    Invalidating,
    	    Invalidated
    	};

    	//
    	// Declare that CNntpFSDriverRootScan is our friend
    	//
    	friend class CNntpFSDriverRootScan;
    	//
    	// Static methods for the file system driver
    	//
    	static BOOL CreateThreadPool();
    	static VOID DestroyThreadPool();

		// Constructor, destructor
		CNntpFSDriver::CNntpFSDriver() :
				m_cRef(0),
				m_cUsages( 0 ),
				m_pffPropFile( NULL ),
				m_pINewsTree( NULL ),
				m_Status( DriverDown ),
				m_bUNC( FALSE ),
				m_dwFSType( FS_NTFS ),
				m_pDirNot( NULL ),
				m_lInvalidating( Invalidated ),
				m_fUpgrade( FALSE ),
				m_fIsSlaveGroup(FALSE)
				{ _Module.Lock(); }
		CNntpFSDriver::~CNntpFSDriver(){ _Module.Unlock(); }

		// Interface methods for IMailMsgStoreDriver
		HRESULT STDMETHODCALLTYPE
		AllocMessage(	IMailMsgProperties *pMsg,
						DWORD	dwFlags,
						IMailMsgPropertyStream **ppStream,
						PFIO_CONTEXT *ppFIOContentFile,
						IMailMsgNotify *pNotify );

		HRESULT STDMETHODCALLTYPE
		CloseContentFile(	IMailMsgProperties *pMsg,
							PFIO_CONTEXT pFIOContentFile );

		HRESULT STDMETHODCALLTYPE
		Delete(	IMailMsgProperties *pMsg,
				IMailMsgNotify *pNotify );

		HRESULT STDMETHODCALLTYPE
		EnumMessages( IMailMsgEnumMessages **ppEnum ) {
			return E_NOTIMPL;
		}

		HRESULT STDMETHODCALLTYPE
		ReAllocMessage( IMailMsgProperties *pOriginalMsg,
						IMailMsgProperties *pNewMsg,
						IMailMsgPropertyStream **ppStream,
						PFIO_CONTEXT *ppFIOContentFile,
						IMailMsgNotify *pNotify ) {
			return E_NOTIMPL;
		}

		HRESULT STDMETHODCALLTYPE
		ReOpen(	IMailMsgProperties *pMsg,
				IMailMsgPropertyStream **ppStream,
				PFIO_CONTEXT *ppFIOContentFile,
				IMailMsgNotify *pNotify ) {
			return E_NOTIMPL;
		}

		HRESULT STDMETHODCALLTYPE
		SupportWriteContent()
		{ return S_FALSE; }

		// Interface methods for INntpDriver
        HRESULT STDMETHODCALLTYPE
        Initialize( IN LPCWSTR pwszVRootPath,
        			IN LPCSTR pszGroupPrefix,
        			IN IUnknown *punkMetabase,
                    IN INntpServer *pServer,
                    IN INewsTree *pINewsTree,
                    IN PVOID	pvContext,
                    OUT DWORD *pdwNDS,
                    IN HANDLE   hToken );

        HRESULT STDMETHODCALLTYPE
        Terminate( OUT DWORD *pdwNDS );

        HRESULT STDMETHODCALLTYPE
        GetDriverStatus( DWORD *pdwNDS ) { return E_NOTIMPL; }

        HRESULT STDMETHODCALLTYPE
        StoreChangeNotify( IUnknown *punkSOCChangeList ) {return E_NOTIMPL;}

        void STDMETHODCALLTYPE
        CommitPost( IN IUnknown *punkMessage,  // IMsg pointer
                    IN STOREID *pStoreId,
                    IN STOREID *rgOtherStoreIDs,
                    IN HANDLE   hToken,
                    IN INntpComplete *pICompletion,
                    IN BOOL     fAnonymous );

        void STDMETHODCALLTYPE
        GetArticle( IN INNTPPropertyBag *pPrimaryGroup,
        			IN INNTPPropertyBag *pCurrentGroup,
        			IN ARTICLEID idPrimaryArt,
                    IN ARTICLEID idCurrentArt,
                    IN STOREID StoreId,
                    IN HANDLE   hToken,
                    void **pvFileHandleContext,
                    IN INntpComplete *pICompletion,
                    IN BOOL     fAnonymous );

        void STDMETHODCALLTYPE
        DeleteArticle( IN    INNTPPropertyBag *pGroupBag,
               IN    DWORD            cArticles,
               IN    ARTICLEID        rgidArt[],
               IN    STOREID          rgidStore[],
               IN    HANDLE           hToken,
               OUT   DWORD            *pdwLastSuccess,
               IN    INntpComplete    *pICompletion,
               IN    BOOL             fAnonymous );

        void STDMETHODCALLTYPE
        GetXover( IN INNTPPropertyBag *pPropBag,
                  IN ARTICLEID idMinArticle,
                  IN ARTICLEID idMaxArticle,
                  OUT ARTICLEID *idLastArticle,
                  OUT char* pBuffer,
                  IN DWORD cbin,
                  OUT DWORD *cbout,
                  HANDLE    hToken,
                  INntpComplete *pICompletion,
                  IN  BOOL  fAnonymous );

		HRESULT STDMETHODCALLTYPE
	    GetXoverCacheDirectory(
	    			IN	INNTPPropertyBag*	pPropBag,
					OUT	CHAR*	pBuffer,
					IN	DWORD	cbIn,
					OUT	DWORD	*pcbOut,
					OUT	BOOL*	fFlatDir
					) ;

        void STDMETHODCALLTYPE
        GetXhdr(	IN INNTPPropertyBag *punkPropBag,
        			IN ARTICLEID idMinArticle,
        			IN ARTICLEID idMaxArticle,
        			OUT ARTICLEID *idLastArticle,
        			IN char* pszHeader,
        			OUT char* pBuffer,
        			IN DWORD cbin,
        			OUT DWORD *cbout,
        			HANDLE  hToken,
        			INntpComplete *pICompletion,
        			IN  BOOL    fAnonymous );
        			
        void STDMETHODCALLTYPE
        RebuildGroup(   IN INNTPPropertyBag *pPropBag,
                        IN HANDLE           hToken,
                        IN INntpComplete *pComplete );

        HRESULT STDMETHODCALLTYPE
        SyncGroups( char **ppmtszGroup,
                    DWORD cGroup ) {return E_NOTIMPL;}

        void STDMETHODCALLTYPE
        DecorateNewsGroupObject( INNTPPropertyBag *pNewsGroup,
                                 DWORD  cProperties,
                                 DWORD *rgidProperties,
                                 INntpComplete *pICompletion )
        {}

        void STDMETHODCALLTYPE
        CheckGroupAccess(   IN    INNTPPropertyBag *pNewsGroup,
                    IN    HANDLE  hToken,
                    IN    DWORD   dwDesiredAccess,
                    IN    INntpComplete *pICompletion );

        void STDMETHODCALLTYPE
        SetGroupProperties( INNTPPropertyBag *pNewsGroup,
                            DWORD   cProperties,
                            DWORD   *rgidProperties,
                            HANDLE  hToken,
                            INntpComplete *pICompletion,
                            BOOL    fAnonymous );

        void STDMETHODCALLTYPE
        DecorateNewsTreeObject( IN HANDLE   hToken,
                                IN INntpComplete *pICompletion );
		
        void STDMETHODCALLTYPE
        CreateGroup( IN INNTPPropertyBag* punkPropBag,
                     IN HANDLE  hToken,
        			 IN INntpComplete* pICompletion,
        			 IN BOOL    fAnonymous );
        			
        void STDMETHODCALLTYPE
        RemoveGroup( IN INNTPPropertyBag *punkPropBag,
                     IN HANDLE  hToken,
        			 IN INntpComplete *pICompletion,
        			 IN BOOL    fAnonymous );

		// INntpDriverSearch
		void STDMETHODCALLTYPE
		MakeSearchQuery (
			IN	CHAR *pszSearchString,
			IN	INNTPPropertyBag *pGroupBag,
			IN	BOOL bDeepQuery,
			IN	WCHAR *pszColumns,
			IN	WCHAR *pszSortOrder,
			IN	LCID LocalID,
			IN	DWORD cMaxRows,
			IN	HANDLE hToken,
			IN	BOOL fAnonymous,
			IN	INntpComplete *pICompletion,
			OUT	INntpSearchResults **pINntpSearch,
			IN	LPVOID lpvContext
			);

		void STDMETHODCALLTYPE
		MakeXpatQuery (
			IN	CHAR *pszSearchString,
			IN	INNTPPropertyBag *pGroupBag,
			IN	BOOL bDeepQuery,
			IN	WCHAR *pszColumns,
			IN	WCHAR *pszSortOrder,
			IN	LCID LocalID,
			IN	DWORD cMaxRows,
			IN	HANDLE hToken,
			IN	BOOL fAnonymous,
			IN	INntpComplete *pICompletion,
			OUT	INntpSearchResults **pINntpSearch,
			OUT	DWORD *pLowArticleID,
			OUT	DWORD *pHighArticleID,
			IN	LPVOID lpvContext
			);

		BOOL STDMETHODCALLTYPE
		UsesSameSearchDatabase (
			IN	INntpDriverSearch *pDriver,
			IN	LPVOID lpvContext
			);

		void STDMETHODCALLTYPE
		GetDriverInfo(
			OUT	GUID *pDriverGUID,
			OUT	void **ppvDriverInfo,
			IN	LPVOID lpvContext
			);

		// Implementation of IUnknown interface
    	HRESULT __stdcall QueryInterface( const IID& iid, VOID** ppv )
    	{
    	    if ( iid == IID_IUnknown ) {
    	        *ppv = static_cast<INntpDriver*>(this);
    	    } else if ( iid == IID_INntpDriver ) {
    	        *ppv = static_cast<INntpDriver*>(this);
    	    } else if ( iid == IID_IMailMsgStoreDriver ) {
    	    	*ppv = static_cast<IMailMsgStoreDriver*>(this);
    	    } else if ( iid == IID_INntpDriverSearch ) {
    	    	*ppv = static_cast<INntpDriverSearch*>(this);
    	    } else {
    	        *ppv = NULL;
    	        return E_NOINTERFACE;
    	    }
    	    reinterpret_cast<IUnknown*>(*ppv)->AddRef();
    	    return S_OK;
    	}

    	ULONG __stdcall AddRef()
    	{
    	    return InterlockedIncrement( &m_cRef );
    	}
	
	    ULONG __stdcall Release()
	    {
	        if ( InterlockedDecrement( &m_cRef ) == 0 ) {
	        	Terminate( NULL );
				delete this;
				return 0;
	        }
	        return m_cRef;
	    }

	// public members:
		static CShareLockNH *s_pStaticLock;	
		static LONG    L_dwThreadPoolRef;

	// Private methods
	private:
		// static methods
		static HRESULT StaticInit();
		static VOID StaticTerm();
		static HRESULT MakeChildDirPath(   IN LPSTR    szPath,
                            IN LPSTR    szFileName,
                            OUT LPSTR   szOutBuffer,
                            IN DWORD    dwBufferSize );
        static VOID CopyAsciiStringIntoUnicode( LPWSTR, LPCSTR );
		static VOID CopyUnicodeStringIntoAscii( LPSTR, LPCWSTR );
		static BOOL IsChildDir( IN WIN32_FIND_DATA& FindData );
		static DWORD ByteSwapper(DWORD );
		static DWORD ArticleIdMapper( IN DWORD   dw );
		static BOOL DoesDriveExist( CHAR chDrive );
		static HRESULT GetString( 	IMSAdminBase *pMB,
                       		      	METADATA_HANDLE hmb,
		                          	DWORD dwId,
                             		LPWSTR szString,
                             		DWORD *pcString);
	//check whether a file already exists
	static BOOL CheckFileExists(CHAR *szFile);
	static BOOL SetAdminACL (CHAR *str);
        // check whether a directory already exists
        static BOOL CheckDirectoryExists(CHAR *szDir);
        // check if this user can create a subfolder in this directory
        static BOOL CheckCreateSubfolderPermission(CHAR *szDir, HANDLE hToken);
	// this is called by rebuild and rmgroup. if the directory is empty, remove it
	static BOOL IfEmptyRemoveDirectory(CHAR *szDir);
	// create an empty file (used when we drop tag files)
	static HRESULT CreateAdminFileInDirectory(CHAR *szDir, CHAR *szFile);

	static HRESULT DeleteFileInDirecotry(CHAR *szDir, CHAR *szFile);

	static HRESULT HresultFromWin32TakeDefault( DWORD  dwWin32ErrorDefault );
        // Flat file callback function
		static void OffsetUpdate( PVOID pvContext, BYTE* pData, DWORD cData, DWORD iNewOffset )
		{ printf ( "Offset %d\n", iNewOffset ) ;}

		// Callback function to create file handle
		static HANDLE CreateFileCallback(LPSTR, PVOID, PDWORD, PDWORD );

		// Callback for sec change notification
		static BOOL InvalidateGroupSec( PVOID pvContext, LPWSTR wszDir ) {
		    _ASSERT( pvContext );
		    return ((CNntpFSDriver *)pvContext)->InvalidateGroupSecInternal( wszDir );
		}

		// Callback when buffer for dirnot is too small
		static HRESULT InvalidateTreeSec( IDirectoryNotification *pDirNot ) {
		    _ASSERT( pDirNot );
		    CNntpFSDriver *pDriver = (CNntpFSDriver*)pDirNot->GetInitializedContext();
		    _ASSERT( pDriver );
		    return pDriver->InvalidateTreeSecInternal();
		}

        static BOOL AddTerminatedDot( HANDLE hFile );

        static void BackFillLinesHeader(    HANDLE  hFile,
                                            DWORD   dwHeaderLength,
                                            DWORD   dwLinesOffset );

		// non-static method to invalidate the secruity descriptor on newstree
		HRESULT InvalidateTreeSecInternal();

        // non-static method to invalidate the security descriptor on a group object
		BOOL InvalidateGroupSecInternal( LPWSTR wszDir );

		// non-static

        // Create all the directories in the path
        BOOL CreateDirRecursive( LPSTR szDir, HANDLE hToken = NULL, BOOL bInherit = FALSE);

	// drop tag files
	HRESULT InitializeTagFiles( INntpComplete *pComplete );
		// Function that reads the vroot info from metabase
		HRESULT ReadVrootInfo( IUnknown *punkMetabase );

		// property conversion between property bag and
		// flatfile record
		HRESULT Group2Record( IN VAR_PROP_RECORD&, IN INNTPPropertyBag* );
		HRESULT Record2Group( IN VAR_PROP_RECORD&, IN INNTPPropertyBag* )
		{ return E_NOTIMPL; }

		// group name and physical fs path conversion
		HRESULT GroupName2Path( LPSTR szGroupName, LPSTR szFullPath, unsigned cbBuffer );
		VOID Path2GroupName( LPSTR szGroupName, LPSTR szFullPath );

		// Convert group name, article id into full path of article file
        HRESULT ObtainFullPathOfArticleFile( IN LPSTR, IN DWORD, OUT LPSTR, IN OUT DWORD& );

        							
        HRESULT LoadGroupOffsets( INntpComplete * );

        // internal functions shared by both interfaces
        HRESULT AllocInternal(  IMailMsgProperties *pMsg,
                                PFIO_CONTEXT *ppFIOContentFile,
                                LPSTR   szFileName,
                                BOOL    b,
                                BOOL    fPrimaryStore,
                                HANDLE  hToken = NULL );
        HRESULT DeleteInternal( INNTPPropertyBag *, ARTICLEID );
        HRESULT	GetXoverInternal(   IN INNTPPropertyBag *pPropBag,
		                            IN ARTICLEID    idMinArticle,
        		                    IN ARTICLEID    idMaxArticle,
                		            OUT ARTICLEID   *pidLastArticle,
                		            IN LPSTR		szHeader,
                        		    OUT LPSTR       pcBuffer,
		                            IN DWORD        cbin,
        		                    OUT DWORD       *pcbout,
        		                    IN BOOL 		bIsXOver,
        		                    IN HANDLE       hToken,
        		                    IN INntpComplete *pComplete );

        // Load group's security descriptor
        HRESULT LoadGroupSecurityDescriptor(    INNTPPropertyBag    *pPropBag,
                                                LPSTR&              lpstrSecDesc,
                                                PDWORD              pcbSecDesc,
                                                BOOL                bSetProp,
                                                PBOOL               pbAllocated );

        // Get File system type and UNC vroot information
        DWORD GetFileSystemType(    IN  LPCSTR      pszRealPath,
                                    OUT LPDWORD     lpdwFileSystem,
                                    OUT PBOOL       pbUNC
                                );

        // Initialize the group property file
        HRESULT InitializeVppFile();

        // Terminate the group property file
        HRESULT TerminateVppFile();

        // Create a group in tree only, give the fs path
        HRESULT CreateGroupInTree( LPSTR szPath, INNTPPropertyBag **ppPropBag  );

        // Create the group in vpp file only
        HRESULT CreateGroupInVpp( INNTPPropertyBag *pPropBag, DWORD& dwOffset );

        // Create all the relevant groups into vpp
        HRESULT CreateGroupsInVpp( INntpComplete *);

        // Load groups into the newstree, could be from root scan or vpp file
        HRESULT LoadGroups( INntpComplete *pComplete, BOOL bNeedDropTagFile  );

        // Load groups from vpp file
        HRESULT LoadGroupsFromVpp( INntpComplete *pComplete, BOOL bNeedDropTagFile );

        // Post message into server hash tables
        HRESULT PostToServer(   LPSTR           szFileName,
                                LPSTR           szGroupName,
                                INntpComplete   *pProtocolComplete );

        // Parse xref line
        HRESULT ParseXRef(      HEADERS_STRINGS     *pHeaderXref,
                                LPSTR               szPrimaryName,
                                DWORD&              cCrossPosts,
                                INNTPPropertyBag    *rgpPropBag[],
                                ARTICLEID           rgArticleId[],
                                INntpComplete       *pProtocolComplete );

        // Get property bag from newstree, give "native name"
        INNTPPropertyBag * GetPropertyBag(  LPSTR   pchBegin,
                                            LPSTR   pchEnd,
                                            LPSTR   szGroupName,
                                            BOOL&   fIsNative,
                                            INntpComplete *pProtocolComplete );

        // Prepare for posting parameters
        HRESULT PreparePostParams(  LPSTR               szFileName,
                                    LPSTR               szGroupName,
                                    LPSTR               szMessageId,
                                    DWORD&              dwHeaderLen,
                                    DWORD&              cCrossPosts,
                                    INNTPPropertyBag    *rgpPropBag[],
                                    ARTICLEID           rgArticleId[],
                                    INntpComplete       *pProtocolComplete );

        // update group properties such as high/low watermark, article count
        HRESULT UpdateGroupProperties(  DWORD               cCrossPosts,
                                        INNTPPropertyBag    *rgpPropBag[],
                                        ARTICLEID           rgArticleId[] );


        HRESULT
        SetMessageContext(
            IMailMsgProperties* pMsg,
            char*               pszGroupName,
            DWORD               cbGroupName,
            PFIO_CONTEXT        pfioContext
            );
        HRESULT
            GetMessageContext(
            IMailMsgProperties* pMsg,
            LPSTR               szFileName,
            BOOL *              pfIsMyMessage,
            PFIO_CONTEXT        *ppFIOContentFile
            );

		// For debugging purpose
		VOID DumpGroups();

		BOOL IsSlaveGroup() { return m_fIsSlaveGroup; }

    // Private members
    private:
    	// driver up/down status
    	enum DriverStatus {
    		DriverUp,
    		DriverDown
    	};
    	
        CComPtr<IUnknown> m_pUnkMarshaler;

		// Driver status
		DriverStatus m_Status;
		
        // The object's refcount
		LONG m_cRef;		

		// The usage count and lock are used to
		// handle graceful termination of the dirver:
		LONG m_cUsages;

		// Interface pointer to nntp server
		INntpServer *m_pNntpServer;

		//Termination lock:
		CShareLockNH m_TermLock;
		INewsTree* m_pINewsTree;

		// a bunch of static variables
		static LONG s_cDrivers;	// How may driver instances are up now ?
		static DWORD s_SerialDistributor;
		static LONG s_lThreadPoolRef;

        //
        // Our vroot path ( in MB ).  We may store and retrieve our
        // store driver related private info under that MB path, such
        // as the vroot ( FS directory )
        //
		WCHAR m_wszMBVrootPath[MAX_PATH+1];

        // Absolute path of the vroot directory, in file system
        CHAR m_szFSDir[MAX_PATH+1];

        // Absolute path of the vroot group property file
        CHAR m_szPropFile[MAX_PATH+1];

        // property file lock
        CShareLockNH m_PropFileLock;

        // Flat file object pointer
        CFlatFile *m_pffPropFile;

		// The vroot prefix, such as "alt" in "alt.*"
        CHAR m_szVrootPrefix[MAX_GROUPNAME+1];

        // File system type: fat, ntfs ...
        DWORD   m_dwFSType;

        // Am I a UNC Vroot ?
        BOOL    m_bUNC;

        // Directory notification object
        IDirectoryNotification	*m_pDirNot;

        // Are we in invalidating sec desc mode of the whole tree ?
        LONG    m_lInvalidating;

        // Whether this vroot is from upgrade
        BOOL    m_fUpgrade;

        // Is this _slavegroup?
        BOOL	m_fIsSlaveGroup;
};

////////////////////////////////////////////////////////////////////////

#define MAX_SEARCH_RESULTS 9

class CNntpSearchResults :
	public CIndexServerQuery,		// That's one way to expose MakeQuery..
	public INntpSearchResults {

public:
	CNntpSearchResults(INntpDriverSearch *pDriverSearch);
	~CNntpSearchResults();

public:
	void STDMETHODCALLTYPE
	GetResults (
		IN OUT DWORD *pcResults,
		OUT	BOOL *pfMore,
		OUT	WCHAR **pGroupName,
		OUT	DWORD *pdwArticleID,
		IN	INntpComplete *pICompletion,
		IN	HANDLE	hToken,
		IN	BOOL  fAnonymous,
		IN	LPVOID lpvContext);

	// Implementation of IUnknown interface
	HRESULT __stdcall QueryInterface( const IID& iid, VOID** ppv )
	{
	    if ( iid == IID_IUnknown ) {
			*ppv = static_cast<INntpSearchResults*>(this);
		} else {
			*ppv = NULL;
			return E_NOINTERFACE;
		}
		reinterpret_cast<IUnknown*>(*ppv)->AddRef();
		return S_OK;
	}

	ULONG __stdcall AddRef()
	{
		return InterlockedIncrement( &m_cRef );
	}
	
	ULONG __stdcall Release()
	{
		if ( InterlockedDecrement( &m_cRef ) == 0 ) {
			delete this;
			return 0;
		}
		return m_cRef;
	}

private:				// Not permitted:
	CNntpSearchResults();
	CNntpSearchResults(const CNntpSearchResults&);
	CNntpSearchResults& operator=(const CNntpSearchResults&);

private:
	// Back pointer to the driver search
	// (Also used to hold the refcount for the driver)
	INntpDriverSearch *m_pDriverSearch;
	LONG m_cRef;
};

////////////////////////////////////////////////////////////////////////

//
// Class definition for implementation of prepare interface:
// Prepare interface is used to accept the protocol's connection,
// create driver, and return driver's good interface to the
// protocol.  The driver's good interface has all the features
// that the protocol needs to talk to the file system store.
//
class ATL_NO_VTABLE CNntpFSDriverPrepare :
    public INntpDriverPrepare,
    public CComObjectRoot,
    public CComCoClass<CNntpFSDriverPrepare, &CLSID_CNntpFSDriverPrepare>
{
    // The structure is used to pass connect context into the connecting
    // thread.  the flag is used for synchronization of who should
    // release the completion object
    struct CONNECT_CONTEXT {
        CNntpFSDriverPrepare *pPrepare;
        INntpComplete        *pComplete;
    };

    public:
        HRESULT FinalConstruct();
        VOID    FinalRelease();

    DECLARE_PROTECT_FINAL_CONSTRUCT();

    DECLARE_REGISTRY_RESOURCEID_EX( IDR_StdAfx,
                                    L"NNTP File System Driver Prepare Class",
                                    L"NNTP.FSPrepare.1",
                                    L"NNTP.FSPrepare" );

    DECLARE_GET_CONTROLLING_UNKNOWN();

	BEGIN_COM_MAP(CNntpFSDriverPrepare)
		COM_INTERFACE_ENTRY(INntpDriverPrepare)
		COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_pUnkMarshaler.p)
	END_COM_MAP()

	public:

	CNntpFSDriverPrepare() {
	    m_lCancel = 0;
        //m_hConnect = NULL;

        //
        // Create the global thread pool, if necessary
        //
        CNntpFSDriver::s_pStaticLock->ExclusiveLock();
        _VERIFY( CNntpFSDriver::CreateThreadPool() );
        CNntpFSDriver::s_pStaticLock->ExclusiveUnlock();
    }

    ~CNntpFSDriverPrepare() {
        CancelConnect();
        /*
        if ( m_hConnect ) {
            //WaitForSingleObject( m_hConnect, INFINITE );
            //CloseHandle( m_hConnect );
        }
        */

        //
        // We might the the person who is responsible for
        // shutdown the thread pool
        //
        CNntpFSDriver::s_pStaticLock->ExclusiveLock();
        CNntpFSDriver::DestroyThreadPool();
        CNntpFSDriver::s_pStaticLock->ExclusiveUnlock();
    }
	
	// Interfaces
	void STDMETHODCALLTYPE
	Connect( 	LPCWSTR pwszVRootPath,
				LPCSTR pszGroupPrefix,
				IUnknown *punkMetabase,
				INntpServer *pServer,
				INewsTree *pINewsTree,
				INntpDriver **pIGoodDriver,
				INntpComplete *pICompletion,
				HANDLE  hToken,
				DWORD   dwFlag );
				
	HRESULT STDMETHODCALLTYPE
	CancelConnect(){
	    // you can never turn it back to non-cancel, if
	    // it is already in cancel state
	    InterlockedCompareExchange( &m_lCancel, 1, 0 );
	    return S_OK;
	}

	static DWORD WINAPI ConnectInternal(  PVOID pvContext  );

    private:

	// Private methods
	static IUnknown *CreateDriverInstance();

	/*
    static DWORD WINAPI FailRelease( PVOID pvContext ) {
        INntpComplete *pComplete = (INntpComplete*)pvContext;
        pComplete->Release();
        return 0;
    }*/

	// Private members
	private:
		    CComPtr<IUnknown> m_pUnkMarshaler;

		    // Temporarily save the parameters, used by another thread
		    WCHAR   m_wszVRootPath[MAX_PATH+1];
		    CHAR    m_szGroupPrefix[MAX_NEWSGROUP_NAME+1];
		    IUnknown *m_punkMetabase;
		    INntpServer *m_pServer;
		    INewsTree *m_pINewsTree;
		    INntpDriver **m_ppIGoodDriver;
		    HANDLE  m_hToken;
		    DWORD   m_dwConnectFlags;
		
		
		    LONG    m_lCancel;      //1: to cancel, 0, not cancel
		    //HANDLE  m_hConnect;     // The connect event
};

//
// Class definition for CNntpFSDriverPrepare's connection work item
//
class CNntpFSDriverConnectWorkItem : public CNntpFSDriverWorkItem   //fc
{
public:
    CNntpFSDriverConnectWorkItem( PVOID pvContext ):CNntpFSDriverWorkItem( pvContext ) {};
    virtual ~CNntpFSDriverConnectWorkItem(){};

    virtual VOID Complete() {

        //
        // Call the prepare driver's static connect method
        //
        CNntpFSDriverPrepare::ConnectInternal( m_pvContext );

        delete m_pvContext;
        m_pvContext = NULL;
    }
};

//
// This class defines the cancel hint that we expose to root scan object.
//
class CNntpFSDriverCancelHint : public CCancelHint {

public:

    //
    // Constructor
    //
    CNntpFSDriverCancelHint( INntpServer *pServer )
        : m_pServer( pServer )
    {}

    virtual BOOL IShallContinue() {

        //
        // Ask the server whether we should continue
        //
        return m_pServer->ShouldContinueRebuild();
    }

private:

    //
    // Pointer to the server interface
    //
    INntpServer *m_pServer;
};

//
// Class that defines the root scan logic: what's the needs of root scan for
// the file system driver, whether we should skip the empty directories that
// has no messages in it ? ...
//
class CNntpFSDriverRootScan : public CRootScan {

public:

    CNntpFSDriverRootScan(  LPSTR           szRoot,
                            BOOL            fSkipEmpty,
                            BOOL            fNeedToDropTagFile,
                            CNntpFSDriver   *pDriver,
                            CCancelHint     *pCancelHint )
        : CRootScan( szRoot, pCancelHint ),
          m_fSkipEmpty( fSkipEmpty ),
          m_bNeedToDropTagFile( fNeedToDropTagFile ),
          m_pDriver( pDriver )
    {}

protected:

    virtual BOOL NotifyDir( LPSTR szPath );

private:

    //////////////////////////////////////////////////////////////////////////
    // Private variables
    //////////////////////////////////////////////////////////////////////////
    //
    // Should I skip the empty directories ?
    //
    BOOL m_fSkipEmpty;
    BOOL m_bNeedToDropTagFile;

    //
    // Driver context
    //
    CNntpFSDriver *m_pDriver;

    //////////////////////////////////////////////////////////////////////////
    // Private methods
    //////////////////////////////////////////////////////////////////////////
    BOOL HasPatternFile(  LPSTR szPath, LPSTR szPattern );
    BOOL HasSubDir( LPSTR szPath );
    BOOL WeShouldSkipThisDir( LPSTR szPath );
    BOOL CreateGroupInTree( LPSTR szPath, INNTPPropertyBag **ppPropBag );
    BOOL CreateGroupInVpp( INNTPPropertyBag *pPropBag );
    void IfEmptyRemoveDirectory( LPSTR szPath );
};


//
// Extern variables
//
extern CNntpFSDriverThreadPool *g_pNntpFSDriverThreadPool;
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\nntp\driver\nntpfs\src\stdafx.cpp ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

	StdAfx.cpp

Abstract:

	This module contains the implementation for the base
	ATL methods.

Author:

	Bin Lin	(binlin@microsoft.com)

Revision History:

	binlin	02/04/98	created

--*/


// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
#include <mddef.h>

HRESULT AtlAllocRegMapEx(_ATL_REGMAP_ENTRY **pparmeResult,
						 const CLSID *pclsid,
						 CComModule *pmodule,
						 LPCOLESTR pszIndex,
						 ...) {
	LPBYTE pbAdd = NULL;		// Working pointer to the next available "scratch space" in the map.
	DWORD dwCnt = 0;			// The count of entries in the map.
	LPOLESTR pszCLSID = NULL;	// The CLSID as a string.
	LPOLESTR pszTLID = NULL;	// The TLID as a string.

	if (!pparmeResult) {
		// The caller did not give us a place to return the result.
		return (E_POINTER);
	}
	*pparmeResult = NULL;	// For the first time through the loop, the result is NULL.
	// We are going to loop through twice.  The first time through, we haven't allocate the map yet, so
	// we will count all the strings, and add up their lenghts - this will give us the size of the buffer
	// we need to allocate for the map.  Then the second time through the loop, we will store all the
	// strings in the map.
	while (1) {
		if (pclsid) {
			// If we were passed a CLSID, then we want to include that in the map.
			if (!*pparmeResult) {
				// If this is the first time through, then we need to convert the CLSID to a string.
				HRESULT hrRes;

				hrRes = StringFromCLSID(*pclsid,&pszCLSID);
				if (!SUCCEEDED(hrRes)) {
					// We failed to convert the CLSID to a string.
					CoTaskMemFree(*pparmeResult);
					return (hrRes);
				}
			} else {
				// If this isn't the first time through, then we already have the CLSID as a string, so
				// we just need to put it in the map.
				(*pparmeResult)[dwCnt].szKey = L"CLSID";
				(*pparmeResult)[dwCnt].szData = (LPCOLESTR) pbAdd;
				wcscpy((LPOLESTR) (*pparmeResult)[dwCnt].szData,pszCLSID);
			}
			// Whether or not this is the first time through, we increment some stuff based on the size
			// of the CLSID string and the fact that we have a CLSID in the map.
			pbAdd += (wcslen(pszCLSID)+1) * sizeof(OLECHAR);
			dwCnt++;
			if (*pparmeResult) {
				// If this is not the first time through, make sure we clean up after ourselves.
				CoTaskMemFree(pszCLSID);
				pszCLSID = NULL;
			}
		}
		if (pmodule) {
			// If we were passed a module, then we want to include the TLID in the map.
			if (!*pparmeResult) {
				// If this is the first time through, then we need to load the type library, get its
				// TLID, and convert it to a string.
				USES_CONVERSION;
				HRESULT hrRes;
				TCHAR szModule[MAX_PATH];
				LPOLESTR pszModule;
				CComPtr<ITypeLib> pTypeLib;
				TLIBATTR *ptlaAttr;
				if (!GetModuleFileName(pmodule->GetTypeLibInstance(),
									   szModule,
									   sizeof(szModule)/sizeof(TCHAR))) {
					hrRes = HRESULT_FROM_WIN32(GetLastError());
					if (SUCCEEDED(hrRes)) {
						// GetModuleFileName() failed, but GetLastError() didn't report an error - so
						// fake it.
						hrRes = E_OUTOFMEMORY;
					}
					CoTaskMemFree(pszCLSID);
					return (hrRes);
				}
				if (pszIndex) {
					// If we were passed an index, that means that the type library desired is not the
					// first type library in the resources - so append the index to the module name.
					lstrcat(szModule,OLE2T(pszIndex));
				}
				pszModule = T2OLE(szModule);
				hrRes = LoadTypeLib(pszModule,&pTypeLib);
				if (!SUCCEEDED(hrRes)) {
					// If we couldn't load the type library from the module, let's try changing the
					// module name to a type library name (change the extension to .TLB) and try to load
					// *that*.
					LPTSTR pszExt = NULL;
					LPTSTR psz;

					for (psz=szModule;*psz;psz=CharNext(psz)) {
						if (*psz == _T('.')) {
							pszExt = psz;
						}
					}
					if (!pszExt) {
						pszExt = psz;
					}
					lstrcpy(pszExt,_T(".tlb"));
					pszModule = T2OLE(szModule);
					hrRes = LoadTypeLib(pszModule,&pTypeLib);
				}
				if (!SUCCEEDED(hrRes)) {
					// We failed to load the type library.
					CoTaskMemFree(pszCLSID);
					return (hrRes);
				}
				hrRes = pTypeLib->GetLibAttr(&ptlaAttr);
				if (!SUCCEEDED(hrRes)) {
					// We failed to get the type library attributes.
					CoTaskMemFree(pszCLSID);
					return (hrRes);
				}
				hrRes = StringFromCLSID(ptlaAttr->guid,&pszTLID);
				if (!SUCCEEDED(hrRes)) {
					// We failed to convert the TLID to a string.
					CoTaskMemFree(pszCLSID);
					return (hrRes);
				}
			} else {
				// If this isn't the first time through, then we already have the TLID as a string, so
				// we just need to put it in the map.
				(*pparmeResult)[dwCnt].szKey = L"LIBID";
				(*pparmeResult)[dwCnt].szData = (LPCOLESTR) pbAdd;
				wcscpy((LPOLESTR) (*pparmeResult)[dwCnt].szData,pszTLID);
			}
			// Whether or not this is the first time through, we increment some stuff based on the size
			// of the TLID string and the fact that we have a TLID in the map.
			pbAdd += (wcslen(pszTLID)+1) * sizeof(OLECHAR);
			dwCnt++;
			if (*pparmeResult) {
				// If this is not the first time through, make sure we clean up after ourselves.
				CoTaskMemFree(pszTLID);
				pszTLID = NULL;
			}
		}
		{	// Now we need to go through the varargs.  All of the varargs must be LPOLESTR (i.e. they
			// must be UNICODE), and they will consist of pairs - the key name followed by the data.  If
			// either member of the pair is NULL, that signals the end of the varargs.
			va_list valArgs;

			// Set the va_list to the start of the varargs.
			va_start(valArgs,pszIndex);
			while (1) {
				LPCOLESTR pszKey;
				LPCOLESTR pszData;

				// Get the first of the pair - this is the key name.
				pszKey = va_arg(valArgs,LPCOLESTR);
				if (!pszKey) {
					break;
				}
				// Get the second of the pair - this is the data.
				pszData = va_arg(valArgs,LPCOLESTR);
				if (!pszData) {
					break;
				}
				if (*pparmeResult) {
					// If this isn't the first time through, then we need to store the key name to the
					// map.
					(*pparmeResult)[dwCnt].szKey = (LPCOLESTR) pbAdd;
					wcscpy((LPOLESTR) (*pparmeResult)[dwCnt].szKey,pszKey);
				}
				// Whether or not this is the first time through, we increment some stuff based on the
				// size of the string.
				pbAdd += (wcslen(pszKey)+1) * sizeof(OLECHAR);
				if (*pparmeResult) {
					// If this isn't the first time through, then we need to store the data to the map.
					(*pparmeResult)[dwCnt].szData = (LPCOLESTR) pbAdd;
					wcscpy((LPOLESTR) (*pparmeResult)[dwCnt].szData,pszData);
				}
				// Whether or not this is the first time through, we increment some stuff based on the
				// size of the string and the fact that we have a string in the map.
				pbAdd += (wcslen(pszData)+1) * sizeof(OLECHAR);
				dwCnt++;
			}
			// Reset the va_list, for the sake of cleanliness.
			va_end(valArgs);
		}
		if (*pparmeResult) {
			// If we have allocated the map, that means that we are finishing the second time through
			// the loop - so we are done!
			break;
		}
		if (!*pparmeResult) {
			// If we havemn't allocate the map, that means that we are finishing the first time through
			// the loop - so we need to allocate the map in preparation for the second time through.
			// First we calculate the number of bytes needed for the map - this is one ATL_REGMAP_ENTRY
			// for each entry, plus one _ATL_REGMAP_ENTRY which signals the end of the map, plus enough
			// space for all of the strings to follow.
			DWORD dwBytes = (DWORD)((dwCnt + 1) * sizeof(_ATL_REGMAP_ENTRY) + (pbAdd-(LPBYTE) NULL));

			*pparmeResult = (_ATL_REGMAP_ENTRY *) CoTaskMemAlloc(dwBytes);
			if (!*pparmeResult) {
				// The memory allocation failed.
				CoTaskMemFree(pszCLSID);
				CoTaskMemFree(pszTLID);
				return (E_OUTOFMEMORY);
			}
			// The memory allocation was successful - fill the memory with zeroes in preparation for
			// loading with the values.
			memset(*pparmeResult,0,dwBytes);
			// Reset the counters to the "beginning" - so that on the second time through, they are used
			// to keep track of where each successive value gets stored in the memory block.
			pbAdd = ((LPBYTE) *pparmeResult) + (dwCnt + 1) * sizeof(_ATL_REGMAP_ENTRY);
			dwCnt = 0;
		}
	}
	return (S_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\nntp\driver\nntpfs\src\makefile.inc ===
$(O)\mailmsg.h $(O)\mailmsg_i.c : $(STAXINC)\export\mailmsg.idl
    $(MIDL) \
    $(PACKING) \
    $(INCPATH0) \
    -char unsigned \
    -ms_ext -c_ext \
    -proxy $(PASS0_SOURCEDIR)\mailmsg_p.c \
    -dlldata $(PASS0_SOURCEDIR)\dlldata.c \
    -iid $(MIDL_UUIDDIR)\mailmsg_i.c \
    -header $@ \
    -tlb $(O)\mailmsg.tlb \
    -cpp_cmd $(TARGET_CPP) \
    $(C_DEFINES) \
    $(MIDL_FLAGS) \
    $(MIDL_OPTIMIZATION) \
    $**

$(O)\nntpfs.h $(O)\nntpfs_i.c : nntpfs.idl
    $(MIDL) \
    $(PACKING) \
    $(INCPATH0) \
    -char unsigned \
    -ms_ext -c_ext \
    -proxy $(PASS0_SOURCEDIR)\nntpfs_p.c \
    -dlldata $(PASS0_SOURCEDIR)\dlldata.c \
    -iid $(MIDL_UUIDDIR)\nntpfs_i.c \
    -header $@ \
    -tlb $(O)\nntpfs.tlb \
    -cpp_cmd $(TARGET_CPP) \
    $(C_DEFINES) \
    $(MIDL_FLAGS) \
    $(MIDL_OPTIMIZATION) \
    $**
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\nntp\driver\nntpfs\src\resource.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

	Resource.h

Abstract:

	This module contains the definitions for the DirDropS
	project.

Author:

	Bin Lin	(binlin@microsoft.com)

Revision History:

	binlin	02/04/98	created

--*/


//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by SEO.rc
//
#define IDS_PROJNAME					100
#define IDR_StdAfx						101


// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           102
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\nntp\driver\nntpfs\src\fsutil.cpp ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    fsutil.cpp

Abstract:

    Static utility functions for FSDriver.

Author:

    Kangrong Yan ( KangYan )    16-March-1998

Revision History:

--*/

#include "stdafx.h"
#include "resource.h"
#include <nntpdrv.h>
#include <nntpfs.h>
#include <fsdriver.h>
#include <aclapi.h>


DWORD g_dwDebugFlags;


VOID
CNntpFSDriver::CopyUnicodeStringIntoAscii(
        IN LPSTR AsciiString,
        IN LPCWSTR UnicodeString
        )
{

    DWORD cbW = (wcslen( UnicodeString )+1) * sizeof(WCHAR);
    DWORD cbSize = WideCharToMultiByte(
                        CP_ACP,
                        0,
                        (LPCWSTR)UnicodeString,
                        -1,
                        AsciiString,
                        cbW,
                        NULL,
                        NULL
                    );

    //If this value is -1, the string is assumed to be null-terminated and the length is calculated automatically. 
    //The length will include the null-terminator. 

} // CopyUnicodeStringIntoAscii

VOID
CNntpFSDriver::CopyAsciiStringIntoUnicode(
        IN LPWSTR UnicodeString,
        IN LPCSTR AsciiString
        )
{

    DWORD cbA = strlen( AsciiString )+1;

    DWORD cbSize = MultiByteToWideChar(
        CP_ACP,         // code page
        0,              // character-type options
        AsciiString,    // address of string to map
        -1,             // number of bytes in string
        UnicodeString,  // address of wide-character buffer
        cbA        // size of buffer
        );

    // If this parameter is -1, the function processes the entire input string including the null terminator. 
    // The resulting wide character string therefore has a null terminator, and the returned length includes the null terminator. 

} // CopyAsciiStringIntoUnicode



// Recursively create dirs
BOOL
CNntpFSDriver::CreateDirRecursive(  LPSTR szDir,
                                    HANDLE  hToken ,
                                    BOOL bInherit )
{
	TraceFunctEnter( "CreateDirRecursive" );

	_ASSERT( szDir );
	_ASSERT( lstrlen( szDir ) <= MAX_PATH );

	LPSTR 	pch = szDir;
	LPSTR 	pchOld;
	DWORD	dwLen = lstrlen( szDir );
	CHAR	ch;
	BOOL	bMore = TRUE;
	HANDLE	hTemp;

    DWORD dwRes, dwDisposition;
    PSID pEveryoneSID = NULL;
    PSID pAnonymousLogonSID = NULL;
    PACL pACL = NULL;
    PSECURITY_DESCRIPTOR pSD = NULL;
    const int cExplicitAccess = 4;
    EXPLICIT_ACCESS ea[cExplicitAccess];
    SID_IDENTIFIER_AUTHORITY SIDAuthWorld = SECURITY_WORLD_SID_AUTHORITY;
    SID_IDENTIFIER_AUTHORITY SIDAuthNT = SECURITY_NT_AUTHORITY;
    SECURITY_ATTRIBUTES sa;
    SECURITY_ATTRIBUTES *psa;
    BOOL bReturn = FALSE;
    LONG lRes;


	// it should start with "\\?\"
	_ASSERT( strncmp( "\\\\?\\", szDir, 4 ) == 0 );
	if ( strncmp( "\\\\?\\", szDir, 4 ) ) {
		ErrorTrace( 0, "Invalid path" );
		SetLastError( ERROR_INVALID_PARAMETER );
		goto Cleanup;
	}

    // Create a security descriptor for the files

    // Create a well-known SID for the Everyone group.

    if(! AllocateAndInitializeSid( &SIDAuthWorld, 1,
                 SECURITY_WORLD_RID,
                 0, 0, 0, 0, 0, 0, 0,
                 &pEveryoneSID) ) 
    {
        goto Cleanup;
    }

	if (!AllocateAndInitializeSid(&SIDAuthNT, 1,
    	SECURITY_ANONYMOUS_LOGON_RID,
    	0, 0, 0, 0, 0, 0, 0,
    	&pAnonymousLogonSID)) {
		goto Cleanup;
    }

    // Initialize an EXPLICIT_ACCESS structure for an ACE.
    // The ACE will allow Everyone read access to the key.

    ZeroMemory(&ea, sizeof(ea));
	ea[0].grfAccessPermissions = WRITE_DAC | WRITE_OWNER;
	ea[0].grfAccessMode = DENY_ACCESS;
	ea[0].grfInheritance= SUB_CONTAINERS_AND_OBJECTS_INHERIT;
	ea[0].Trustee.TrusteeForm = TRUSTEE_IS_SID;
	ea[0].Trustee.TrusteeType = TRUSTEE_IS_WELL_KNOWN_GROUP;
	ea[0].Trustee.ptstrName  = (LPTSTR) pEveryoneSID;

	ea[1].grfAccessPermissions = WRITE_DAC | WRITE_OWNER;
	ea[1].grfAccessMode = DENY_ACCESS;
	ea[1].grfInheritance= SUB_CONTAINERS_AND_OBJECTS_INHERIT;
	ea[1].Trustee.TrusteeForm = TRUSTEE_IS_SID;
	ea[1].Trustee.TrusteeType = TRUSTEE_IS_USER;
	ea[1].Trustee.ptstrName  = (LPTSTR) pAnonymousLogonSID;

	ea[2].grfAccessPermissions = GENERIC_ALL;
	ea[2].grfAccessMode = SET_ACCESS;
	ea[2].grfInheritance= SUB_CONTAINERS_AND_OBJECTS_INHERIT;
	ea[2].Trustee.TrusteeForm = TRUSTEE_IS_SID;
	ea[2].Trustee.TrusteeType = TRUSTEE_IS_WELL_KNOWN_GROUP;
	ea[2].Trustee.ptstrName  = (LPTSTR) pEveryoneSID;
	
	ea[3].grfAccessPermissions = GENERIC_ALL;
	ea[3].grfAccessMode = SET_ACCESS;
	ea[3].grfInheritance= SUB_CONTAINERS_AND_OBJECTS_INHERIT;
	ea[3].Trustee.TrusteeForm = TRUSTEE_IS_SID;
	ea[3].Trustee.TrusteeType = TRUSTEE_IS_USER;
	ea[3].Trustee.ptstrName  = (LPTSTR) pAnonymousLogonSID;

    dwRes = SetEntriesInAcl(cExplicitAccess, ea, NULL, &pACL);
    if (ERROR_SUCCESS != dwRes) 
    {
        goto Cleanup;
    }

    // Initialize a security descriptor.  
 
    pSD = (PSECURITY_DESCRIPTOR) LocalAlloc(LPTR, 
                         SECURITY_DESCRIPTOR_MIN_LENGTH); 
    if (pSD == NULL) 
    {
        goto Cleanup; 
    }
 
    if (!InitializeSecurityDescriptor(pSD, SECURITY_DESCRIPTOR_REVISION)) 
    {
        goto Cleanup; 
    }
 
    // Add the ACL to the security descriptor. 
 
    if (!SetSecurityDescriptorDacl(pSD, 
        TRUE,     // fDaclPresent flag   
        pACL, 
        FALSE))   // not a default DACL 
    {
        goto Cleanup; 
    }

    // Initialize a security attributes structure.

    sa.nLength = sizeof (SECURITY_ATTRIBUTES);
    sa.lpSecurityDescriptor = pSD;
    sa.bInheritHandle = FALSE;


    psa = bInherit ? NULL : &sa;
			
    // Use the security to create the directory
    // If it's non-UNC, we'll check for drive access
    if ( !m_bUNC ) {
    	// skip this part, looking for ':'
	    _ASSERT( strlen( szDir ) >= 6 );
    	pch = szDir + 6;

	    if ( *pch == 0 || *(pch+1) == 0 ) { // a drive has been specified
										// we need to check its access
		    if ( *pch != 0 ) _ASSERT( *pch == '\\' );
    		// Check accessibility of that drive
	    	hTemp = CreateFile(	szDir,
		    					GENERIC_READ | GENERIC_WRITE,
			    				FILE_SHARE_READ | FILE_SHARE_WRITE,
				    			psa,
					    		OPEN_ALWAYS,
						    	FILE_FLAG_BACKUP_SEMANTICS,
							    INVALID_HANDLE_VALUE
        						) ;

		    if( hTemp != INVALID_HANDLE_VALUE ) {
			    CloseHandle( hTemp ) ;
    			DebugTrace( 0, "Drive specified is %s", szDir );
	    		bReturn = TRUE;
	    		goto Cleanup;
		    } else {
	    	    ErrorTrace( 0, "Invalid path" );
    	    	if ( GetLastError() == NO_ERROR )
	    		    SetLastError( ERROR_INVALID_PARAMETER );
		    	goto Cleanup;
		    }
	    }

	    // *pch must be '\'
	    _ASSERT( *pch == '\\' );
	    pch++;
	} else {    // UNC
	    pch += 8;   // skip "\\?\UNC\"
        while ( *pch != '\\' ) pch++;
	    pch++;
	}

	while ( bMore ) {
		pchOld = pch;
		while ( *pch && *pch != '\\' ) pch++;

		if ( pch != pchOld  ) {	// found a sub-dir

			ch = *pch, *pch = 0;

			// Create the dir
			if( !CreateDirectory( szDir, psa ) ) {
        		if( GetLastError() != ERROR_ALREADY_EXISTS ) {
        		    goto Cleanup;
    			}
        	}

        	*pch = ch;

        	if ( *pch == '\\' ) pch++;
        	bMore = TRUE;
	    } else {
	    	bMore = FALSE;
	    }
  	}

	bReturn = TRUE;

Cleanup:
	if (pEveryoneSID) 
		FreeSid(pEveryoneSID);
	if (pAnonymousLogonSID)
		FreeSid(pAnonymousLogonSID);
    if (pACL) 
        LocalFree(pACL);
    if (pSD) 
        LocalFree(pSD);
    
  	TraceFunctLeave();
	return bReturn;
}

// Check if the drive exists
BOOL
CNntpFSDriver::DoesDriveExist( CHAR chDrive )
{
	TraceFunctEnter( "CNntpFSDriver::DoesDriveExist" );

	chDrive = (CHAR) CharUpper( LPSTR(chDrive) );
	return ( GetLogicalDrives() & ( 1 << (chDrive - 'A')));
}

// helper function for getting string from mb
HRESULT
CNntpFSDriver::GetString(	 IMSAdminBase *pMB,
                             METADATA_HANDLE hmb,
                             DWORD dwId,
                             LPWSTR szString,
                             DWORD *pcString)
{
    METADATA_RECORD mdr;
    HRESULT hr;
    DWORD dwRequiredLen;

    mdr.dwMDAttributes = 0;
    mdr.dwMDIdentifier = dwId;
    mdr.dwMDUserType = ALL_METADATA;
    mdr.dwMDDataType = STRING_METADATA;
    mdr.dwMDDataLen = (*pcString) * sizeof(WCHAR);
    mdr.pbMDData = (BYTE *) szString;
    mdr.dwMDDataTag = 0;

    hr = pMB->GetData(hmb, L"", &mdr, &dwRequiredLen);
    if (FAILED(hr)) *pcString = dwRequiredLen;
    return hr;
}

DWORD
CNntpFSDriver::ByteSwapper(
        DWORD   dw
        ) {
/*++

Routine Description :

    Given a DWORD reorder all the bytes within the DWORD.

Arguments :

    dw - DWORD to shuffle

Return Value ;

    Shuffled DWORD

--*/

    WORD    w = LOWORD( dw ) ;
    BYTE    lwlb = LOBYTE( w ) ;
    BYTE    lwhb = HIBYTE( w ) ;

    w = HIWORD( dw ) ;
    BYTE    hwlb = LOBYTE( w ) ;
    BYTE    hwhb = HIBYTE( w ) ;

    return  MAKELONG( MAKEWORD( hwhb, hwlb ), MAKEWORD( lwhb, lwlb )  ) ;
}

DWORD
CNntpFSDriver::ArticleIdMapper( IN DWORD   dw )
/*++

Routine Description :

    Given an articleid mess with the id to get something that when
    converted to a string will build nice even B-trees on NTFS file systems.
    At the same time, the function must be easily reversible.
    In fact -

    ARTICLEID == ArticleMapper( ArticleMapper( ARTICLEID ) )

Arguments :

    articleId - the Article Id to mess with

Return Value :

    A new article id

--*/
{
    return  ByteSwapper( dw ) ;
}


HRESULT
CNntpFSDriver::MakeChildDirPath(   IN LPSTR    szPath,
                    IN LPSTR    szFileName,
                    OUT LPSTR   szOutBuffer,
                    IN DWORD    dwBufferSize )
/*++
Routine description:

    Append "szFileName" to "szPath" to make a full path.

Arguments:

    IN LPSTR    szPath  - The prefix to append
    IN LPSTR    szFileName - The suffix to append
    OUT LPSTR   szOutBuffer - The output buffer for the full path
    IN DWORD    dwBufferSize - The buffer size prepared

Return value:

    S_OK    - Success
    TYPE_E_BUFFERTOOSMALL   - The buffer is too small
--*/
{
	_ASSERT( szPath );
	_ASSERT( strlen( szPath ) <= MAX_PATH );
	_ASSERT( szFileName );
	_ASSERT( strlen( szFileName ) <= MAX_PATH );
    _ASSERT( szOutBuffer );
    _ASSERT( dwBufferSize > 0 );

    HRESULT hr = S_OK;
    LPSTR   lpstrPtr;

    if ( dwBufferSize < (DWORD)(lstrlen( szPath ) + lstrlen( szFileName ) + 2) ) {
        hr = TYPE_E_BUFFERTOOSMALL;
        goto Exit;
    }

    lstrcpy( szOutBuffer, szPath );
    lpstrPtr = szOutBuffer + lstrlen( szPath );
    if ( *( lpstrPtr - 1 )  == '\\' ) lpstrPtr--;
    *(lpstrPtr++) = '\\';

    lstrcpy( lpstrPtr, szFileName );    // trailing null should already be appended

Exit:

    return hr;
}

BOOL
CNntpFSDriver::IsChildDir( IN WIN32_FIND_DATA& FindData )
/*++
Routine description:

    Is the found data of a child dir ? ( Stolen from Jeff Richter's book )

Arguments:

    IN WIN32_FIND_DATA& FindData    - The find data of a file or directory

Return value:

    TRUE - Yes;
    FALSE - No
--*/
{
    return(
        (FindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY ) &&
        (FindData.cFileName[0] != '.') );
}


/*++
Routine description:

    Check whether a file exists or not

Arguments:

    CHAR *szFile - file to check

Return value:
    TRUE: exists
    FALSE: doesn't exists or error

--*/
BOOL CNntpFSDriver::CheckFileExists(CHAR *szFile)
{
	HANDLE hFile = CreateFile(	szFile,
		    					GENERIC_READ,
			    				FILE_SHARE_READ,
				    			NULL,
					    		OPEN_EXISTING,
						    	FILE_ATTRIBUTE_NORMAL,
							    INVALID_HANDLE_VALUE
        						) ;
	if( hFile == INVALID_HANDLE_VALUE ) 
		return FALSE;
	CloseHandle( hFile );
	return TRUE;
}



/*++
Routine description:

	set admin/localsystem full access on str
    
Arguments:

	str

Return value:

	BOOL - TRUE if successful
	
--*/

BOOL CNntpFSDriver::SetAdminACL (CHAR *str)
{
	TraceFunctEnter( "CNntpFSDriver::SetAdminACL" );
	DWORD dwRes, dwDisposition;
	PSID pLocalSystemSid = NULL, pAdminSid = NULL;
	PACL pACL = NULL;
	PSECURITY_DESCRIPTOR pSD = NULL;
	const int cMaxExplicitAccess = 2;
	EXPLICIT_ACCESS ea[cMaxExplicitAccess];
	int cExplicitAccess = 0;
	SID_IDENTIFIER_AUTHORITY SIDAuthNT = SECURITY_NT_AUTHORITY;
	LONG lRes;
	BOOL fRet = FALSE;

	if(! AllocateAndInitializeSid( &SIDAuthNT, 1,
		SECURITY_LOCAL_SYSTEM_RID,
		0, 0, 0, 0, 0, 0, 0,
		&pLocalSystemSid) )
	{
		goto Exit;
	}
	if(! AllocateAndInitializeSid( &SIDAuthNT, 2,
		SECURITY_BUILTIN_DOMAIN_RID,
		DOMAIN_ALIAS_RID_ADMINS,
		0, 0, 0, 0, 0, 0,
		&pAdminSid) )
	{
		goto Exit;
	}

	// Initialize an EXPLICIT_ACCESS structure for an ACE.

	ZeroMemory(ea, sizeof(ea));
	ea[0].grfAccessPermissions = GENERIC_ALL;
	ea[0].grfAccessMode = SET_ACCESS;
	ea[0].grfInheritance= SUB_CONTAINERS_AND_OBJECTS_INHERIT;
	ea[0].Trustee.TrusteeForm = TRUSTEE_IS_SID;
	ea[0].Trustee.TrusteeType = TRUSTEE_IS_USER;
	ea[0].Trustee.ptstrName  = (LPTSTR) pLocalSystemSid;

	ea[1].grfAccessPermissions = GENERIC_ALL;
	ea[1].grfAccessMode = SET_ACCESS;
	ea[1].grfInheritance= SUB_CONTAINERS_AND_OBJECTS_INHERIT;
	ea[1].Trustee.TrusteeForm = TRUSTEE_IS_SID;
	ea[1].Trustee.TrusteeType = TRUSTEE_IS_WELL_KNOWN_GROUP;
	ea[1].Trustee.ptstrName  = (LPTSTR) pAdminSid;

	cExplicitAccess = 2;


	// Create a new ACL that contains the new ACEs.

	dwRes = SetEntriesInAcl(cExplicitAccess, ea, NULL, &pACL);
	if (ERROR_SUCCESS != dwRes)
	{
		goto Exit;
	}

	// Initialize a security descriptor.
	pSD = (PSECURITY_DESCRIPTOR) LocalAlloc(LPTR,
                         SECURITY_DESCRIPTOR_MIN_LENGTH);
	if (pSD == NULL)
	{
		goto Exit;
	}

	if (!InitializeSecurityDescriptor(pSD, SECURITY_DESCRIPTOR_REVISION))
	{
		goto Exit;
	}

	// Add the ACL to the security descriptor.

	if (!SetSecurityDescriptorDacl(pSD,
		TRUE,     // fDaclPresent flag
		pACL,
		FALSE))   // not a default DACL
	{
		goto Exit;
	}



	fRet = SetFileSecurity (str, DACL_SECURITY_INFORMATION, pSD);

Exit:
	if (pAdminSid)
		FreeSid(pAdminSid);
	if (pLocalSystemSid)
		FreeSid(pLocalSystemSid);
	if (pACL)
		LocalFree(pACL);
	if (pSD)
		LocalFree(pSD);
	return fRet;

}


/*++
Routine description:

	create szFile in szDir, and set admin/localsystem full access
    
Arguments:

	szDir, szFile

Return value:

	HRESULT - if file is created return S_OK

--*/

HRESULT CNntpFSDriver::CreateAdminFileInDirectory(CHAR *szDir, CHAR *szFile)
{
	TraceFunctEnter( "CNntpFSDriver::CreateAdminFileInDirectory" );
	CHAR szTagFilePath[MAX_PATH];
	HRESULT hr = S_OK;
	if ( FAILED( MakeChildDirPath( szDir, szFile, szTagFilePath, sizeof(szTagFilePath) ) ) ) 
	{
		// this should not happen
		hr = TYPE_E_BUFFERTOOSMALL;
		ErrorTrace(0, "error creating file path in %s - %x", szDir, hr );
		goto Exit;
	}
	HANDLE hFile = CreateFile(	szTagFilePath,
		    					GENERIC_READ,
			    				FILE_SHARE_READ,
				    			NULL,
					    		OPEN_ALWAYS,
						    	FILE_ATTRIBUTE_NORMAL,
							    INVALID_HANDLE_VALUE
        						) ;
	if( hFile == INVALID_HANDLE_VALUE ) 
	{
		hr = HresultFromWin32TakeDefault(ERROR_ACCESS_DENIED);
		ErrorTrace(0, "error creating file %s - %x", szTagFilePath, hr );
		goto Exit;
	}

	CloseHandle( hFile );
	hFile = INVALID_HANDLE_VALUE;		

	if (!CNntpFSDriver::SetAdminACL(szTagFilePath))
		DebugTrace(0, "error setting ACL on file %s - %x", szTagFilePath, HresultFromWin32TakeDefault(ERROR_ACCESS_DENIED) );
	// return S_OK even if SetAdminACL fails. this is not fatal

Exit:
	return hr;
	
}

/*++
Routine description:

	delete szFile in szDir
    
Arguments:

	szDir, szFile

Return value:

	HRESULT - if deleted return S_OK

--*/
HRESULT CNntpFSDriver::DeleteFileInDirecotry(CHAR *szDir, CHAR *szFile)
{
	TraceFunctEnter( "CNntpFSDriver::DeleteFileInDirecotry" );
	CHAR szFilePath[MAX_PATH];
	HRESULT hr = S_OK;
	if ( FAILED( CNntpFSDriver::MakeChildDirPath( szDir, szFile, szFilePath, sizeof(szFilePath) ) ) ) 
	{
		hr = TYPE_E_BUFFERTOOSMALL;
		ErrorTrace(0, "error creating file path in %s - %x", szDir, hr );
		goto Exit;
	}
	if ( !DeleteFile( szFilePath ) ) {
		hr = HresultFromWin32TakeDefault( ERROR_PATH_NOT_FOUND );
		ErrorTrace(0, "File delete failed %s - %d", szFilePath, hr );
		goto Exit;
	}

Exit:
	return hr;
		
}



/*++
Routine description:

    If this directory is empty, remove the directory
    
Arguments:

    LPSTR szPath - The path to check

Return value:

    TRUE if directory is removed. 
    Else FALSE.

--*/
BOOL CNntpFSDriver::IfEmptyRemoveDirectory(CHAR *szDir)
{
	TraceFunctEnter( "CNntpFSDriver::IfEmptyRemoveDirectory" );
	CHAR	szFile[MAX_PATH];
	WIN32_FIND_DATA	findData;
	HANDLE	hFind = INVALID_HANDLE_VALUE;
	BOOL	bFound = FALSE;
	BOOL	bEmpty = FALSE;

	// ONLY REMOVE DIRECTORY IF IT'S COMPLETELY EMPTY
	if ( FAILED( MakeChildDirPath( szDir, "*", szFile, sizeof(szFile) ) ) ) 
		goto Exit;

	// after this point, we always go to Exit
	hFind = FindFirstFile( szFile, &findData );
	bFound = ( hFind != INVALID_HANDLE_VALUE );

	while ( bFound ) {

		// If it's not "." and "..", the directory is non-empty
		if ( strcmp( findData.cFileName, "." ) != 0 &&
			 strcmp( findData.cFileName, ".." ) != 0 )
			goto Exit;
		
		// Find next file
		bFound = FindNextFile( hFind, &findData );
	}
	// we find nothing in the directory. this is an empty directory
	bEmpty = TRUE;

Exit:
	if ( INVALID_HANDLE_VALUE != hFind ) {
		FindClose( hFind );
		hFind = INVALID_HANDLE_VALUE;
	}

	if ( !bEmpty ) return FALSE;
	if ( !RemoveDirectory( szDir ) ) {
		ErrorTrace( 0, "Removing directory failed %d", GetLastError() );
		return FALSE;
	}
	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\nntp\driver\nntpfs\src\stdafx.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

	StdAfx.h

Abstract:

	This module contains the definitions for the base
	ATL methods.

Author:

	Bin Lin     (binlin@microsoft.com)

Revision History:

	binlin   02/04/98        created

--*/


// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#ifndef _WIN32_WINNT
	#define _WIN32_WINNT 0x0400
#endif

#define THIS_MODULE "nntpfs"

#ifdef _ATL_NO_DEBUG_CRT
	#include <nt.h>
	#include <ntrtl.h>
	#include <nturtl.h>
	#include <windows.h>
    #include <randfail.h>   
    #include <xmemwrpr.h>
	#include "dbgtrace.h"
	#define _ASSERTE	_ASSERT
#endif

#include <dbgutil.h>
//#include "mailmsgprops.h"
#include <nntperr.h>
#include <mbstring.h>
#include <fsconst.h>
#include <stdlib.h>
#include <rwnew.h>
#include <nntpbag.h>
#include <flatfile.h>
#include <nntpmeta.h>
#include <cpool.h>
#include <time.h>
#include <tsunami.hxx>
#include <smartptr.h>
#include <filehc.h>
#include <syncomp.h>
#include <dirnot.h>

//#define _ATL_APARTMENT_THREADED

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>

#if defined(_ATL_SINGLE_THREADED)
	#define ATL_THREADING_MODEL_VALUE	L"Single"
#elif defined(_ATL_APARTMENT_THREADED)
	#define ATL_THREADING_MODEL_VALUE	L"Apartment"
#else
	#define ATL_THREADING_MODEL_VALUE	L"Both"
#endif


#define DECLARE_REGISTRY_RESOURCEID_EX(x,desc,progid,viprogid)			\
	static HRESULT WINAPI UpdateRegistry(BOOL bRegister) {				\
		HRESULT hrRes;													\
		_ATL_REGMAP_ENTRY *parme;										\
																		\
		hrRes = AtlAllocRegMapEx(&parme,								\
								 &GetObjectCLSID(),						\
								 &_Module,								\
								 NULL,									\
								 L"DESCRIPTION",						\
								 desc,									\
								 L"PROGID",								\
								 progid,								\
								 L"VIPROGID",							\
								 viprogid,								\
								 L"THREADINGMODEL",						\
								 ATL_THREADING_MODEL_VALUE,				\
								 NULL,									\
								 NULL);									\
		if (!SUCCEEDED(hrRes)) {										\
			return (hrRes);												\
		}																\
		hrRes = _Module.UpdateRegistryFromResource(x,bRegister,parme);	\
		CoTaskMemFree(parme);											\
		return (hrRes);													\
	}


#define DECLARE_REGISTRY_RESOURCE_EX(x,desc,progid,viprogid)				\
	static HRESULT WINAPI UpdateRegistry(BOOL bRegister) {					\
		HRESULT hrRes;														\
		_ATL_REGMAP_ENTRY *parme;											\
																			\
		hrRes = AtlAllocRegMapEx(&parme,									\
								 &GetObjectCLSID(),							\
								 &_Module,									\
								 NULL,										\
								 L"DESCRIPTION",							\
								 desc,										\
								 L"PROGID",									\
								 progid,									\
								 L"VIPROGID",								\
								 viprogid,									\
								 L"THREADINGMODEL",							\
								 ATL_THREADING_MODEL_VALUE,					\
								 NULL,										\
								 NULL);										\
		if (!SUCCEEDED(hrRes)) {											\
			return (hrRes);													\
		}																	\
		hrRes = _Module.UpdateRegistryFromResource(_T(#x),bRegister,parme);	\
		CoTaskMemFree(parme);												\
		return (hrRes);														\
	}


HRESULT AtlAllocRegMapEx(_ATL_REGMAP_ENTRY **pparmeResult,
						 const CLSID *pclsid,
						 CComModule *pmodule,
						 LPCOLESTR pszIndex,
						 ...);


template <class Base>
HRESULT AtlCreateInstanceOf(IUnknown *pUnkOuter, CComObject<Base> **pp) {
//	template <class Base>
//	HRESULT WINAPI CComObject<Base>::CreateInstance(CComObject<Base>** pp)
//	{
	    _ASSERTE(pp != NULL);
	    HRESULT hRes = E_OUTOFMEMORY;
	    CComObject<Base>* p = NULL;
	    ATLTRY(p = new CComObject<Base>())
	    if (p != NULL)
	    {
//		    p->SetVoid(NULL);					// Change this...
			p->SetVoid(pUnkOuter);				// ... to this.
	        p->InternalFinalConstructAddRef();
	        hRes = p->FinalConstruct();
	        p->InternalFinalConstructRelease();
	        if (hRes != S_OK)
	        {
	            delete p;
	            p = NULL;
	        }
	    }
	    *pp = p;
	    return hRes;
//	}
}


template <class Base>
HRESULT AtlCreateInstanceOf(IUnknown *pUnkOuter, REFIID iidDesired, LPVOID *pp) {
	HRESULT hrRes;
	CComObject<Base> *p = NULL;

	_ASSERTE(pp != NULL);
	*pp = NULL;
	hrRes = AtlCreateInstanceOf(pUnkOuter,&p);
	if (SUCCEEDED(hrRes)) {
		_ASSERTE(p != NULL);
		p->AddRef();
		hrRes = p->QueryInterface(iidDesired,pp);
		p->Release();
	}
	return (hrRes);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\nntp\driver\nntpfs\src\nntpfs.cpp ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    nntpfs.cpp

Abstract:

    This is the implementation for the file system store driver class.

Author:

    Kangrong Yan ( KangYan )    16-March-1998

Revision History:

--*/

#include "stdafx.h"
#include "resource.h"
#include "nntpdrv.h"
#include "nntpfs.h"
#include "fsdriver.h"
#include "nntpdrv_i.c"
#include "nntpfs_i.c"
#include "mailmsg_i.c"
#include "parse.h"
#include "tflist.h"
#include "watchci.h"
#include <stdio.h>


////////////////////////////////////////////////////////////////////////////
// Macros
////////////////////////////////////////////////////////////////////////////
#define MAX_FILE_SYSTEM_NAME_SIZE    ( MAX_PATH)
#define DIRNOT_RETRY_TIMEOUT            60
#define DIRNOT_INSTANCE_SIZE            1024
#define DIRNOT_MAX_INSTANCES            128     // BUGBUG: This makes very bad limit
                                                // of how many file system
                                                // vroots we can have

////////////////////////////////////////////////////////////////////////////
// Global variables
////////////////////////////////////////////////////////////////////////////
DWORD CNntpFSDriver::s_SerialDistributor = 0;
LONG CNntpFSDriver::s_cDrivers = 0;
CShareLockNH *CNntpFSDriver::s_pStaticLock = NULL;
LPCSTR g_szArticleFileExtension = ".nws";
LONG CNntpFSDriver::s_lThreadPoolRef = 0;
CNntpFSDriverThreadPool *g_pNntpFSDriverThreadPool = NULL;
BOOL    g_fBackFillLines = FALSE;   // dummy global var that is not used

static CWatchCIRoots s_TripoliInfo;

static const char g_szSlaveGroupPrefix[] = "_slavegroup";

// Max buffer size for xover
const DWORD cchMaxXover = 3400;
const CLSID CLSID_NntpFSDriver = {0xDEB58EBC,0x9CE2,0x11d1,{0x91,0x28,0x00,0xC0,0x4F,0xC3,0x0A,0x64}};

// Guid to uniquely identify the FS driver
// {E7EE82C6-7A8C-11d2-9F04-00C04F8EF2F1}
static const GUID GUID_NntpFSDriver =
	{0xe7ee82c6, 0x7a8c, 0x11d2, { 0x9f, 0x4, 0x0, 0xc0, 0x4f, 0x8e, 0xf2, 0xf1} };

//
// Function to convert LastError into hresult, taking a default value
// if the LastError was not set
//

HRESULT CNntpFSDriver::HresultFromWin32TakeDefault( DWORD  dwWin32ErrorDefault )
{
    DWORD   dwErr = GetLastError();
    return HRESULT_FROM_WIN32( (dwErr == NO_ERROR) ? dwWin32ErrorDefault : dwErr );
}

////////////////////////////////////////////////////////////////////////////
// interfaces INntpDriver implementation
////////////////////////////////////////////////////////////////////////////
//
// Static initialization for all driver instances
//
// Rule for all init, term functions:
// If init failed, init should roll back and term never gets
// called.
//
HRESULT
CNntpFSDriver::StaticInit()
{
	TraceFunctEnter( "CNntpFSDriver::StaticInit" );
	_ASSERT( CNntpFSDriver::s_cDrivers >= 0 );

	HRESULT hr = S_OK;
	DWORD	cchMacName = MAX_COMPUTERNAME_LENGTH;
	BOOL    bThrdPoolInited = FALSE;
	BOOL    bArtInited = FALSE;
	BOOL    bCacheInited = FALSE;
	BOOL    bDirNotInited = FALSE;

	s_pStaticLock->ExclusiveLock();	// I don't want two drivers'
									// init enter here at the
									// same time

	if ( InterlockedIncrement( &CNntpFSDriver::s_cDrivers ) > 1 ) {
		// we shouldn't proceed, it has already been initialized
		DebugTrace( 0, "I am not the first driver" );
		goto Exit;
	}

	//
	// The global thread pool should have already been created
	// at this point: it should always be created by the first
	// prepare driver
	//
	_ASSERT( g_pNntpFSDriverThreadPool );

	//
	// But we should still call CreateThreadPool to pair up the
	// thread pool ref count
	//
	if( !CreateThreadPool() ) {
	    _ASSERT( 0 );
	    FatalTrace( 0, "Can not create thread pool %d", GetLastError() );
	    hr = HresultFromWin32TakeDefault( ERROR_NOT_ENOUGH_MEMORY );
	    goto Exit;
	}

    bThrdPoolInited = TRUE;

    // Initialize article class
    if ( ! CArticleCore::InitClass() ) {
    	FatalTrace( 0, "Can not initialze artcore class %d", GetLastError() );
    	hr = HresultFromWin32TakeDefault( ERROR_NOT_ENOUGH_MEMORY );
		goto Exit;
	}

    bArtInited = TRUE;

	// Initialize the file handle cache
	if ( !InitializeCache() ) {
	    hr = HresultFromWin32TakeDefault( ERROR_NOT_ENOUGH_MEMORY );
        FatalTrace( 0, "Can not init file handle cache %x", hr );
        goto Exit;
    }

    bCacheInited = TRUE;

    // Initialize global stuff for dirnot
    hr = IDirectoryNotification::GlobalInitialize(  DIRNOT_RETRY_TIMEOUT,
                                                    DIRNOT_MAX_INSTANCES * 2,
                                                    DIRNOT_INSTANCE_SIZE,
                                                    NULL    );
	if (FAILED(hr)) {
		ErrorTrace( 0, "Global initialization of DirNot failed %x", hr );
		goto Exit;
	}

	bDirNotInited = TRUE;

	// Initialize the index server query object
	hr = CIndexServerQuery::GlobalInitialize();
	if (FAILED(hr)) {
		ErrorTrace( 0, "Global initialization of CIndexServerQuery failed %x", hr );
		hr = S_OK;		// Silently fail
	}

	hr = s_TripoliInfo.Initialize(L"System\\CurrentControlSet\\Control\\ContentIndex");
	if (FAILED(hr)) {
		ErrorTrace( 0, "Initialization of CWatchCIRoots failed %x", hr );
		hr = S_OK;		// Silently fail
	}

Exit:
	//
	// If init failed, we should roll back to the old state, in
	// order not to confuse the termination work
	//
	if ( FAILED( hr ) ) {
		InterlockedDecrement( &s_cDrivers );
		_ASSERT( 0 == s_cDrivers );
		if ( bThrdPoolInited ) DestroyThreadPool();
		if ( bArtInited ) CArticleCore::TermClass();
		if ( bCacheInited ) TerminateCache();
		if ( bDirNotInited ) IDirectoryNotification::GlobalShutdown();
	}

	s_pStaticLock->ExclusiveUnlock();
	TraceFunctLeave();

	return hr;
}

//
// Static termination for all driver instances
//
VOID
CNntpFSDriver::StaticTerm()
{
	TraceFunctEnter( "CNntpFSDriver::StaticTerm" );
	_ASSERT( CNntpFSDriver::s_cDrivers >= 0 );

	s_pStaticLock->ExclusiveLock();	// I don't want two drivers'
									// Term enter here at the
									// same time
	if ( InterlockedDecrement( &CNntpFSDriver::s_cDrivers ) > 0 ) {
		// we shouldn't proceed, we are not the last guy
		DebugTrace( 0, "I am not the last driver" );
		goto Exit;
	}

    // Terminate article class
    CArticleCore::TermClass();

    // Terminate the file handle cache
    TerminateCache();

    // Shutdown dirnot
    IDirectoryNotification::GlobalShutdown();

    // Terminate the query object
    CIndexServerQuery::GlobalShutdown();

    // Get rid of the tripoli info
    s_TripoliInfo.Terminate();

    //
    // We might be the person to shutdown the global thread
    // pool, since Prepare driver could go away earlier than
    // we do.  The destroy method was ref-counted.
    //
    DestroyThreadPool();

Exit:
   	s_pStaticLock->ExclusiveUnlock();
	TraceFunctLeave();
}

BOOL
CNntpFSDriver::CreateThreadPool()
/*++
Routine Description:

    Create the global thread pool.

Arguments:

    None.

Return value:

    TRUE if succeeded, FALSE otherwise
--*/
{
    TraceFunctEnter( "CNntpFSDriver::CreateThreadPool" );

    if ( InterlockedIncrement( &s_lThreadPoolRef ) == 1 ) {

        //
        // Increment the module ref count, it will be decremented when
        // we destroy the thread pool in the call back
        //
        _Module.Lock();

        g_pNntpFSDriverThreadPool = XNEW CNntpFSDriverThreadPool;
        if ( NULL == g_pNntpFSDriverThreadPool ) {
            _Module.Unlock();
            SetLastError( ERROR_OUTOFMEMORY );
            return FALSE;
        }

        if ( !g_pNntpFSDriverThreadPool->Initialize(    0, // as many as procs
                                                        POOL_MAX_THREADS,
                                                        POOL_START_THREADS ) ) {
            g_pNntpFSDriverThreadPool->Terminate( TRUE );
            XDELETE g_pNntpFSDriverThreadPool;
            g_pNntpFSDriverThreadPool = NULL;
            _Module.Unlock();
            return FALSE;
        }

        //
        // Call thread pool's beginjob here, don't know if there is
        // a better place to do this
        //
        g_pNntpFSDriverThreadPool->BeginJob( NULL );
    } else {

        _ASSERT( g_pNntpFSDriverThreadPool );
    }

    TraceFunctLeave();
    return TRUE;
}

VOID
CNntpFSDriver::DestroyThreadPool()
/*++
Routine Description:

    Destroy the global thread pool

Arguments:

    None.

Return value:

    TRUE if succeeded, FALSE otherwise
--*/
{
    TraceFunctEnter( "CNntpFSDriver::DestroyThreadPool" );

    if ( InterlockedDecrement( &s_lThreadPoolRef ) == 0 ) {

#ifdef DEADLOCK
        //
        // Wait for the thread's job to complete
        //
        _ASSERT( g_pNntpFSDriverThreadPool );
        g_pNntpFSDriverThreadPool->WaitForJob( INFINITE );

        //
        // Terminate the global thread pool
        //
        g_pNntpFSDriverThreadPool->Terminate( FALSE );
        XDELETE g_pNntpFSDriverThreadPool;
#endif
        //
        // Get all the threads out of the loop
        //
        _ASSERT( g_pNntpFSDriverThreadPool );
        g_pNntpFSDriverThreadPool->ShrinkAll();

        //
        // The thread pool will shut itself down, no
        // need to destroy it
        //
        g_pNntpFSDriverThreadPool = NULL;
    }
}

HRESULT STDMETHODCALLTYPE
CNntpFSDriver::Initialize(  IN LPCWSTR     pwszVRootPath,
							IN LPCSTR		pszGroupPrefix,
							IN IUnknown	   *punkMetabase,
                            IN INntpServer *pServer,
                            IN INewsTree   *pINewsTree,
                            IN LPVOID		pvContext,
                            OUT DWORD      *pdwNDS,
                            IN HANDLE       hToken )
/*++
Routine Description:

    All the initiliazation work for the store driver.

Arguments:

    IN LPCWSTR pwszVRootPath    - The MD vroot path of this driver
    IN IUnknown *punkLookup     - Interface pointer to lookup service
    IN IUnknown *punkNewsTree   - Interface pointer to news tree
    OUT DWORD pdwNDS            - The store driver status to be returned

Return value:

    S_OK            - Initialization succeeded.
    NNTP_E_DRIVER_ALREADY_INITIALIZED - The store driver
						has already been initialized.
--*/
{
    TraceFunctEnter( "CNntpFSDriver::Initialize" );
	_ASSERT( lstrlenW( pwszVRootPath ) <= MAX_PATH );
	_ASSERT( pINewsTree );
	_ASSERT( pServer );

	BOOL	bStaticInited = FALSE;
	VAR_PROP_RECORD vpRecord;
	DWORD           cData = 0;
	WCHAR           wszFSDir[MAX_PATH+1];
    PINIT_CONTEXT	pInitContext = (PINIT_CONTEXT)pvContext;

    HRESULT hr = S_OK;

	// Grab the usage exclusive lock, so that no one can enter
	// before we are done with initialization
	m_TermLock.ExclusiveLock();

	// Are we up already ?
	if ( DriverDown != m_Status ) {
	    DebugTrace(0, "Multiple init of store driver" );
        hr = NNTP_E_DRIVER_ALREADY_INITIALIZED;
        goto Exit;
    } else m_Status = DriverUp;	// no interlock needed

	// Do static initialization stuff
	hr = StaticInit();
	if ( FAILED( hr ) ) {
		ErrorTrace(0, "Driver static initialization failed %x", hr );
		goto Exit;	// no need to call StaticTerm
	}

	bStaticInited = TRUE;

	// Store the MB Path
	_ASSERT( pwszVRootPath );
	_ASSERT( lstrlenW( pwszVRootPath ) <= MAX_PATH );
	lstrcpynW( m_wszMBVrootPath, pwszVRootPath , sizeof(m_wszMBVrootPath)/sizeof(m_wszMBVrootPath[0]));

	hr = ReadVrootInfo( punkMetabase );
	if ( FAILED( hr ) ) {
		ErrorTrace( 0, "Read Vroot info failed %x", hr );
		goto Exit;
	}

	if ( m_bUNC ) {
	    if ( !ImpersonateLoggedOnUser( hToken ) ) {
	        hr = HresultFromWin32TakeDefault( ERROR_ACCESS_DENIED );
	        ErrorTrace( 0, "Impersonation failed %x", hr );
	        goto Exit;
	    }
	}

	// Create the dirs
	if ( !CreateDirRecursive( m_szFSDir ) ) {
    	FatalTrace(	0,
        			"Could not create directory %s  error %d",
            		m_szFSDir,
            		GetLastError());
        hr = HresultFromWin32TakeDefault( ERROR_ALREADY_EXISTS );
        if ( m_bUNC ) RevertToSelf();
	    goto Exit;
    }

    // remember the nntpserver / newstree interafce
	m_pNntpServer = pServer;
	m_pINewsTree = pINewsTree;

	// check if the vroot was upgraded
	if ( pInitContext->m_dwFlag & NNTP_CONNECT_UPGRADE ) m_fUpgrade = TRUE;

	// Create and initialize the flatfile object
	hr = InitializeVppFile();
	if ( FAILED( hr ) ) {
	    ErrorTrace( 0, "Initialize vpp file failed %x", hr );
	    if ( m_bUNC ) RevertToSelf();
	    goto Exit;
	}

	// Initialize dirnot
	// make sure m_szFSDir is null terminated before converting to Ascii
	m_szFSDir[(sizeof(m_szFSDir)/sizeof(m_szFSDir[0]))-1] = '\0';
	CopyAsciiStringIntoUnicode( wszFSDir, m_szFSDir );
	if ( *wszFSDir && *(wszFSDir+wcslen(wszFSDir)-1) == L':'  
			&& (wcslen(wszFSDir)+1+1 <= sizeof(wszFSDir)/sizeof(wszFSDir[0])))
       	wcscat( wszFSDir, L"\\" );
	m_pDirNot = new IDirectoryNotification;
	if ( NULL == m_pDirNot ) {
	    _ASSERT( 0 );
	    hr = E_OUTOFMEMORY;
	    if ( m_bUNC ) RevertToSelf();
	    ErrorTrace( 0, "Out of memory" );
	    goto Exit;
	}

	hr = m_pDirNot->Initialize( wszFSDir,   // root to watch
	                            this,       // context
	                            TRUE,       // watch sub tree
	                            FILE_NOTIFY_CHANGE_SECURITY,
	                            FILE_ACTION_MODIFIED,
	                            InvalidateGroupSec,
	                            InvalidateTreeSec,
	                            FALSE       // don't append startup entry
	                            );
	if ( FAILED( hr ) ) {
	    m_pDirNot = NULL;
	    if ( m_bUNC ) RevertToSelf();
	    ErrorTrace( 0, "Initialize dirnot failed %x", hr );
	    goto Exit;
	}

	if ( m_bUNC ) RevertToSelf();

	lstrcpyn( m_szVrootPrefix, pszGroupPrefix, sizeof(m_szVrootPrefix) );

	m_fIsSlaveGroup = (_stricmp(pszGroupPrefix, g_szSlaveGroupPrefix) == 0);

Exit:

	_ASSERT( punkMetabase );
	//punkMetabase->Release();
	// this should be released outside

	// If init failed, roll back
	if ( FAILED( hr ) && NNTP_E_DRIVER_ALREADY_INITIALIZED != hr ) {
		m_Status = DriverDown;
		if ( m_pffPropFile ) XDELETE m_pffPropFile;
		if ( m_pDirNot ) XDELETE m_pDirNot;
		if ( bStaticInited ) StaticTerm();
	}

	m_TermLock.ExclusiveUnlock();
    TraceFunctLeave();

    return hr;
}

HRESULT STDMETHODCALLTYPE
CNntpFSDriver::Terminate( OUT DWORD *pdwNDS )
/*++
Routine description:

    Store driver termination.

Arguments:

    OUT DWORD   *pdwNDS - Store driver status

Return value:

    S_OK - Succeeded
    NNTP_E_DRIVER_NOT_INITIALIZED - Driver not initialized at all
--*/
{
    TraceFunctEnter( "CNntpFSDriver::Terminate" );

    HRESULT hr = S_OK;
    LONG 	lUsages;

	// Grab termination exclusive lock
	m_TermLock.ExclusiveLock();

	// Are we up ?
	if ( m_Status != DriverUp ) {
		ErrorTrace( 0, "Trying to shutdown someone not up" );
		m_TermLock.ExclusiveUnlock();
		return NNTP_E_DRIVER_NOT_INITIALIZED;
	} else m_Status = DriverDown;

	// wait for the usage count to drop to 1
	while ( ( lUsages = InterlockedCompareExchange( &m_cUsages, 0, 0 )) != 0 ) {
		Sleep( TERM_WAIT );	// else wait
	}

	// Shutdown dirnot and delete dirnot object
    if ( m_pDirNot ) {

        //
        // Should clean the retry queue first
        //
        m_pDirNot->CleanupQueue();

        _VERIFY( SUCCEEDED( m_pDirNot->Shutdown() ) );
        delete m_pDirNot;
        m_pDirNot = NULL;
    }

   	_ASSERT( m_pNntpServer );
   	if ( m_pNntpServer ) m_pNntpServer->Release();

   	_ASSERT( m_pINewsTree );
   	if ( m_pINewsTree ) m_pINewsTree->Release();

    // Delete flatfile object
    if ( m_pffPropFile ) {
    	TerminateVppFile();
    }

    // Throw away anything that might be in the file handle cache for this vroot
    CacheRemoveFiles( m_szFSDir, TRUE );

    // static terminate stuff
    StaticTerm();

	m_TermLock.ExclusiveUnlock();
    TraceFunctLeave();

	return hr;
}

/*++
Routine description:

    Check whether a directory exists or not

Arguments:

    CHAR *szDir - path of the directory to check

Return value:
    TRUE: exists
    FALSE: doesn't exists or error

--*/
BOOL CNntpFSDriver::CheckDirectoryExists(CHAR *szDir)
{
	// special case for root: "\\?\f:"
	if ( 6 == strlen(szDir) && 0 == strncmp(szDir, "\\\\?\\", 4) ) return TRUE;
	HANDLE hFile = CreateFile(	szDir,
		    					GENERIC_READ,
			    				FILE_SHARE_READ,
				    			NULL,
					    		OPEN_EXISTING,
						    	FILE_FLAG_BACKUP_SEMANTICS,
							    INVALID_HANDLE_VALUE
        						) ;
	if( hFile == INVALID_HANDLE_VALUE ) 
		return FALSE;
	CloseHandle( hFile );
	return TRUE;
}

/*++
Routine description:

    Given an hToken and a directory path, check if the user can create a subfolder in this directory

Arguments:

    CHAR *szDir - path of the directory to check
    HANDLE hToken - token

Return value:
    TRUE: has permission to create subfolders
    FALSE: doesn't have permission to create subfolders

--*/
BOOL CNntpFSDriver::CheckCreateSubfolderPermission(CHAR *szDir, HANDLE hToken)
{
	TraceFunctEnter( "CNntpFSDriver::CheckCreateSubfolderPermission" );
	CHAR    pbSecDesc[512];
	DWORD   cbSecDesc = sizeof( pbSecDesc );
	LPSTR   lpstrSecDesc = pbSecDesc;

	DWORD dwDesiredAccess = FILE_ADD_SUBDIRECTORY;
	BYTE    psFile[256] ;
	DWORD   dwPS = sizeof( psFile ) ;
	DWORD   dwGrantedAccess = 0;

	BOOL bAllocated = FALSE;
	BOOL bAccessStatus = FALSE;    // return value

	SECURITY_INFORMATION si =
		OWNER_SECURITY_INFORMATION |
		GROUP_SECURITY_INFORMATION |
		DACL_SECURITY_INFORMATION ;

	GENERIC_MAPPING gmFile = {
		FILE_GENERIC_READ,
		FILE_GENERIC_WRITE,
		FILE_GENERIC_EXECUTE,
		FILE_ALL_ACCESS } ;

	// Get the directory's security descriptor
	if ( !GetFileSecurity(  szDir, si, lpstrSecDesc, sizeof( pbSecDesc ), &cbSecDesc ) ) 
	{
		if ( ( GetLastError() == ERROR_INSUFFICIENT_BUFFER ) && ( cbSecDesc > sizeof(pbSecDesc) ) ) 
		{
			// Allocate memory
			lpstrSecDesc = XNEW char[cbSecDesc];
			if ( !lpstrSecDesc ) 
			{
				ErrorTrace( 0, "Out of memory" );
				goto Exit;
			}
			bAllocated = TRUE;

			// Load it again
			if ( !GetFileSecurity(  szDir, si, lpstrSecDesc, cbSecDesc, &cbSecDesc ) )
			{
				ErrorTrace( 0, "Second try loading desc failed %x", GetLastError());
				goto Exit;
			}
		} else {    // fatal reason
			ErrorTrace( 0, "Get file sec desc failed %x", GetLastError() );
			goto Exit;
		}
	}

	// Being here, we should already have a security descriptor
	// for the group in lpstrSecDesc and the length is cbSecDesc

	MapGenericMask( &dwDesiredAccess, &gmFile );
	if ( !AccessCheck(  PSECURITY_DESCRIPTOR( lpstrSecDesc ),
		hToken,
		dwDesiredAccess,
		&gmFile,
		PPRIVILEGE_SET(psFile),
		&dwPS,
		&dwGrantedAccess,
		&bAccessStatus ) ) 
	{
		// If we failed because we were given a token that's not
		// impersonation token, we'll duplicate and give it a try again
		if ( GetLastError() == ERROR_NO_IMPERSONATION_TOKEN ) {
			HANDLE  hImpersonationToken = NULL;
			if ( !DuplicateToken( hToken, SecurityImpersonation, &hImpersonationToken ) ) {
				ErrorTrace( 0, "Duplicate token failed");
				goto Exit;
			} 
			else {
				if ( !AccessCheck(  PSECURITY_DESCRIPTOR( lpstrSecDesc ),
					hImpersonationToken,
					dwDesiredAccess,
					&gmFile,
					PPRIVILEGE_SET(psFile),
					&dwPS,
					&dwGrantedAccess,
					&bAccessStatus ) ) 
				{
					_VERIFY( CloseHandle( hImpersonationToken ) );
					ErrorTrace( 0, "Access checked failed with %x", GetLastError() );
					goto Exit;
				}
				_VERIFY( CloseHandle( hImpersonationToken ) );
			}
		} 
		else {
			ErrorTrace( 0, "Access checked failed with %x", HresultFromWin32TakeDefault( ERROR_ACCESS_DENIED ) );
			goto Exit;
		}
	}

    
	Exit:

	if (bAllocated) XDELETE lpstrSecDesc;
	return bAccessStatus;
}


void STDMETHODCALLTYPE
CNntpFSDriver::CreateGroup( 	IN INNTPPropertyBag *pPropBag,
                                IN HANDLE   hToken,
								IN INntpComplete *pICompletion,
								IN BOOL     fAnonymous )
/*++
Routine description:

	Create a news group.

Arguments:

	IN IUnknown *punkPropBag - IUnknown interface to the group's
								property bag
	IN HANDLE hToken - The client's access token.
	IN INntpComplete *pICompletion - Completion object's interface

Return value:

	S_OK on success, HRESULT error code otherwise
--*/
{
	TraceFunctEnter( "CNntpFSDriver::CreateGroup" );
	_ASSERT( pPropBag );
	_ASSERT( pICompletion );

	HRESULT				hr;
	CHAR				szGroupName[MAX_GROUPNAME+1];
	CHAR				szFullPath[MAX_PATH+1];
	CHAR				szFullPathCopy[MAX_PATH+1];
	CHAR				szTempPath[MAX_PATH+1];
	CHAR				szPrefix[MAX_PATH+1];
	CHAR				*pchTemp;
	DWORD				dwLen;
	VAR_PROP_RECORD		vpRecord;
	DWORD				dwOffset;
	BOOL                bImpersonated = FALSE;
	BOOL				bUsageIncreased = FALSE;
	BOOL		   bInherit = TRUE;

	// Share lock for usage count
	m_TermLock.ShareLock();
	if ( DriverUp != m_Status ) {
		ErrorTrace( 0, "Request before initialization" );
		hr = NNTP_E_DRIVER_NOT_INITIALIZED;
		m_TermLock.ShareUnlock();
		goto Exit;
	}

	// Increment the usage count
	InterlockedIncrement( &m_cUsages );
	bUsageIncreased = TRUE;
	m_TermLock.ShareUnlock();

	// Get group name
	dwLen = MAX_GROUPNAME;
	hr = pPropBag->GetBLOB(	NEWSGRP_PROP_NAME, (UCHAR*)szGroupName, &dwLen);
	if ( FAILED( hr )) {
		ErrorTrace( 0, "Failed to get group name %x", hr );
		goto Exit;
	}
	_ASSERT( dwLen > 0 );

	// Get directory path to create
	hr = GroupName2Path( szGroupName, szFullPath, sizeof(szFullPath) );
	if ( FAILED( hr ) ) {
	    ErrorTrace( 0, "insufficient buffer for path %x", hr );
	    goto Exit;
	}
	DebugTrace( 0, "The path converted is %s", szFullPath );
	// szFullPath will be modified in CreateDirRecursive, so we save a copy here
	lstrcpyn(szFullPathCopy, szFullPath, sizeof(szFullPathCopy));

	
	// check the create subfolder permission in the first existing parent group
	
	lstrcpyn(szTempPath, szFullPath, sizeof(szTempPath));
	lstrcpyn(szPrefix, m_szFSDir, sizeof(szPrefix));
	// remove the trailing '\\'
	if(szPrefix[lstrlen(szPrefix)-1]=='\\') szPrefix[lstrlen(szPrefix)-1]='\0';

	// find the first existing parent folder
	pchTemp = strrchr(szTempPath, '\\');
	_ASSERT(pchTemp);
	if (!pchTemp)
	{
      		// this should not happen because path is from GroupName2Path function
      		FatalTrace( 0, "invalid path - %s", szFullPath);
		hr = HresultFromWin32TakeDefault( ERROR_PATH_NOT_FOUND );
		goto Exit;
      	}       
	*pchTemp = '\0';

	while( FALSE == CheckDirectoryExists(szTempPath) )
	{
		pchTemp = strrchr(szTempPath, '\\');
		_ASSERT(pchTemp);
		if (!pchTemp)
		{
			// this should not happen because path is from GroupName2Path function
			FatalTrace( 0, "invalid path - %s", szFullPath);
			hr = HresultFromWin32TakeDefault( ERROR_PATH_NOT_FOUND );
			goto Exit;
		}
		*pchTemp = '\0';
		// stop and fail if m_szFSDir (szPrefix) doesn't exist; m_szFSDir is always the prefix of szFullPath
		if ( strlen(szTempPath) < strlen(szPrefix) ) 
		{
			ErrorTrace( 0, "invalid path - %s", szFullPath);
			hr = HresultFromWin32TakeDefault( ERROR_PATH_NOT_FOUND );
			goto Exit;
		}	       		
	}

	if ( FALSE == CheckCreateSubfolderPermission(szTempPath, hToken))
	{
		hr = HresultFromWin32TakeDefault( ERROR_ACCESS_DENIED);
		ErrorTrace(0, "Access denied - unable to create subfolder in %s", szTempPath);
		goto Exit;
	}

	// We will not inherit security settings if we're going to create a folder under root folder.
	if ( 6 == strlen(szTempPath) && 0 == strncmp(szTempPath, "\\\\?\\", 4) ) 
		bInherit = FALSE;
	

    hr = CreateGroupInVpp( pPropBag, dwOffset );
    if ( FAILED( hr ) ) {
        ErrorTrace( 0, "Create group into vpp file failed %x", hr );
        goto Exit;
    }

    // If I am UNC Vroot, impersonate here
    if ( m_bUNC ) {
        if ( !ImpersonateLoggedOnUser( hToken ) ) {
            hr = HresultFromWin32TakeDefault( ERROR_ACCESS_DENIED );
		    ErrorTrace( 0, "Impersonation failed %x", hr );
		    goto Exit;
		}
    }

    // Create the directory and newsgrp.tag, if it doesn't exist
    if ( !CreateDirRecursive( szFullPath, hToken, bInherit ) 
    		|| FAILED(CreateAdminFileInDirectory(szFullPathCopy, "newsgrp.tag")) ) {

	    ErrorTrace( 0, "Create dir fail %s %d", szFullPathCopy, GetLastError() );
	    hr = HresultFromWin32TakeDefault( ERROR_ALREADY_EXISTS );
        if ( m_bUNC ) RevertToSelf();

        // We need to remove the record in property file
		_ASSERT( dwOffset != 0xffffffff );

        // What do we do if we failed deletion ? still fail
        m_PropFileLock.ExclusiveLock();
        m_pffPropFile->DirtyIntegrityFlag();
		m_pffPropFile->DeleteRecord( dwOffset );
		m_pffPropFile->SetIntegrityFlag();
		m_PropFileLock.ExclusiveUnlock();

		goto Exit;
    }



    if ( m_bUNC ) RevertToSelf();


Exit:

	// Release the property bag interface
	if ( pPropBag ) {
		//pPropBag->Release();
		pICompletion->ReleaseBag( pPropBag );
		pPropBag = NULL;
	}

	pICompletion->SetResult( hr );
	pICompletion->Release();

	// request completed, decrement the usage count
	if ( bUsageIncreased )	InterlockedDecrement( &m_cUsages );

	TraceFunctLeave();
}

void STDMETHODCALLTYPE
CNntpFSDriver::RemoveGroup(	IN INNTPPropertyBag *pPropBag,
                            IN HANDLE   hToken,
							IN INntpComplete *pICompletion,
							IN BOOL     fAnonymous )
/*++
Routine description:

	Remove a news group physically from file system

Arguments:

	IN INNTPPropertyBag *pPropBag - The news group's property bag
	IN HANDLE   hToken - The client's access token
	IN INntpComplete *pICompletion - Completion object

Return value:

	S_OK On success, HRESULT error code otherwise
--*/
{
	TraceFunctEnter( "CNntpFSDriver::RemoveGroup" );
	_ASSERT( pPropBag );
	_ASSERT( pICompletion );

	CHAR	szFullPath[MAX_PATH+1];
	CHAR	szGroupName[MAX_GROUPNAME+1];
	CHAR	szFileName[MAX_PATH+1];
	CHAR	szPrefix[MAX_PATH+1];
	
	DWORD	dwLen;
	CHAR	szFindWildmat[MAX_PATH+1];
	HANDLE	hFind = INVALID_HANDLE_VALUE;
	WIN32_FIND_DATA	findData;
	BOOL	bFound;
	DWORD	dwOffset;
	HRESULT hr;

	BOOL    bImpersonated = FALSE;
	BOOL	bUsageIncreased = FALSE;

	CHAR *pchTemp=NULL;
	// Share lock for usage count
	m_TermLock.ShareLock();
	if ( DriverUp != m_Status ) {
		ErrorTrace( 0, "Request before initialization" );
		hr = NNTP_E_DRIVER_NOT_INITIALIZED;
		m_TermLock.ShareUnlock();
		goto Exit;
	}

	// Increment usage count
	InterlockedIncrement( &m_cUsages );
	bUsageIncreased = TRUE;
	m_TermLock.ShareUnlock();


	// Get group name
	dwLen = MAX_GROUPNAME;
	hr = pPropBag->GetBLOB(	NEWSGRP_PROP_NAME, (UCHAR*)szGroupName, &dwLen);
	if ( FAILED( hr )) {
		ErrorTrace( 0, "Failed to get group name %x", hr );
		goto Exit;
	}
	_ASSERT( dwLen > 0 );

	// Get directory path to remove
	hr = GroupName2Path( szGroupName, szFullPath, sizeof(szFullPath)-2 ); // for '\' and '*' below
	if ( FAILED( hr ) ) {
	    ErrorTrace( 0, "insufficient buffer for path %x", hr );
	    goto Exit;
	}

	DebugTrace( 0, "The path converted is %s", szFullPath );
	dwLen = strlen( szFullPath );
	_ASSERT( dwLen <= MAX_PATH );

	//
	// Clean up the diretory:
	// Protocol should have cleaned up all the messages under
	// the group directory.  But in case there is any junk
	// under the directory, we still do a findfirst/findnext and
	// remove those files before deleting the whole directory
	//
	strcpy( szFindWildmat, szFullPath );
	if ( *(szFindWildmat + dwLen - 1 ) != '\\' ) {
		*(szFindWildmat + dwLen) = '\\';
		*(szFindWildmat + dwLen + 1) = 0;
	}
	strcat( szFindWildmat, "*" );
	DebugTrace( 0, "Find wildmat is %s", szFindWildmat );
	_ASSERT( strlen( szFindWildmat ) <= MAX_PATH );

    // Before accessing the file system, impersonate
    if ( m_bUNC ) {
        if ( !ImpersonateLoggedOnUser( hToken ) ) {
            hr = HresultFromWin32TakeDefault( ERROR_ACCESS_DENIED );
            ErrorTrace( 0, "Impersonation failed %x", hr );
            goto Exit;
        }
        bImpersonated = TRUE;
    }

	// DELETE NEWSGRP.TAG FILE
	hr = DeleteFileInDirecotry(szFullPath, "newsgrp.tag");
	if (FAILED(hr))
	{
		ErrorTrace(0, "Tag file deletion failed in %s - %x", szFullPath, hr );
		hr = S_OK;
		// continue if we didn't delete the tag file or it doesn't exist.
	}

	// START CLEANING UP
	hFind = FindFirstFile( szFindWildmat, &findData );
	bFound = ( hFind != INVALID_HANDLE_VALUE );
	while ( bFound ) {

		if ( IsChildDir( findData ) ) {
			DebugTrace( 0, "Group directory contain sub-dir" );
			goto FindNext;
		}

		// If found "." or "..", continue finding
		if ( strcmp( findData.cFileName, "." ) == 0 ||
			 strcmp( findData.cFileName, ".." ) == 0 )
			 goto FindNext;

		hr = MakeChildDirPath(	szFullPath,
								findData.cFileName,
								szFileName,
								MAX_PATH );
		if ( FAILED( hr ) ) {
			ErrorTrace(0, "Make child dir fail %x", hr );
			goto Exit;
		}

		// Delete this file
		if ( !DeleteFile( szFileName ) ) {
			// We should continue to clean up other files
			ErrorTrace(0, "File delete failed %d", GetLastError() );
			goto FindNext;
		}

FindNext:
		// Find next file
		bFound = FindNextFile( hFind, &findData );
	}

	// Close the find handle
	FindClose( hFind );
	hFind = INVALID_HANDLE_VALUE;

	
	// remove the trailing '\\' in both szFullPath and szPrefix
	if (szFullPath[lstrlen(szFullPath)-1]=='\\') szFullPath[lstrlen(szFullPath)-1]='\0';
	lstrcpyn(szPrefix, m_szFSDir, sizeof(szPrefix));
	if(szPrefix[lstrlen(szPrefix)-1]=='\\') szPrefix[lstrlen(szPrefix)-1]='\0';	

	// remove this directory and parents if empty
	while( ( lstrlen(szPrefix) < lstrlen(szFullPath) ) && IfEmptyRemoveDirectory(szFullPath) )
	{
		pchTemp = strrchr(szFullPath, '\\');
		_ASSERT(pchTemp);
		if (!pchTemp)
		{
			// this should not happen because path is from GroupName2Path function
			ErrorTrace( 0, "invalid path - %s", szFullPath);
			break;
		}
		*pchTemp = '\0';
	}
	
	// Revert to self, if necessary
	if ( bImpersonated ) {
	    RevertToSelf();
	    bImpersonated = FALSE;
	}

	// Delete the record in flat file, should retrieve offset
	// first
	hr = pPropBag->GetDWord( NEWSGRP_PROP_FSOFFSET, &dwOffset );
	if ( FAILED( hr ) ) {
		ErrorTrace(0, "Get offset property failed %x", hr );
		goto Exit;
	}
	_ASSERT( 0xffffffff != dwOffset );
	m_PropFileLock.ExclusiveLock();

	//
	// Before vpp operation, dirty integrity
	//
	hr = m_pffPropFile->DirtyIntegrityFlag();
	if ( FAILED( hr ) ) {
	    ErrorTrace( 0, "Dirty integrity failed %x", hr );
	    m_PropFileLock.ExclusiveUnlock();
	    goto Exit;
	}

	hr = m_pffPropFile->DeleteRecord( dwOffset );
	if ( FAILED( hr ) ) {

	    //
	    // We should still set integrity flag
	    //
	    m_pffPropFile->SetIntegrityFlag();
		ErrorTrace( 0, "Delete record in flatfile failed %x" , hr );
		m_PropFileLock.ExclusiveUnlock();
		goto Exit;
	}

	//
	// After vpp operation, set integrity flag
	//
	hr = m_pffPropFile->SetIntegrityFlag();
	if ( FAILED( hr ) ) {
	    ErrorTrace( 0, "Set integrity flag failed %x", hr );
	    m_PropFileLock.ExclusiveUnlock();
	    goto Exit;
	}

	//
	// Unlock it
	//
	m_PropFileLock.ExclusiveUnlock();

	// Now reset offset, this may not be necessary.
	hr = pPropBag->PutDWord( NEWSGRP_PROP_FSOFFSET, 0xffffffff );
	if ( FAILED( hr ) ) {
		ErrorTrace( 0, "Put offset property fail %x", hr );
		goto Exit;
	}

Exit:

	if ( INVALID_HANDLE_VALUE != hFind ) {
		FindClose( hFind );
		hFind = INVALID_HANDLE_VALUE;
	}

	if ( bImpersonated ) RevertToSelf();

	if ( pPropBag ) {
		//pPropBag->Release();
		pICompletion->ReleaseBag( pPropBag );
		pPropBag = NULL;
	}

	pICompletion->SetResult( hr );
	pICompletion->Release();
	if ( bUsageIncreased ) InterlockedDecrement( &m_cUsages );

	TraceFunctLeave();
}



void STDMETHODCALLTYPE
CNntpFSDriver::SetGroupProperties( INNTPPropertyBag *pNewsGroup,
                                   DWORD   cProperties,
                                   DWORD   *rgidProperties,
                                   HANDLE   hToken,
                                   INntpComplete *pICompletion,
                                   BOOL fAnonymous )
/*++
Routine description:

    Set group properties into driver owned property file
    ( right now only helptext, prettyname, moderator can be
        set )

Arguments:

    INNTPPropertyBag *pNewsGroup - The newsgroup property bag
    DWORD cProperties - Number of properties to set
    DWORD *rgidProperties - Array of property id's to set
    HANDLE hToken - The client's access token
    INntpComplete *pICompletion - Completion object

Return value:

    None.
--*/
{
    TraceFunctEnter( "CNntpFSDriver::SetGroupProperties" );
    _ASSERT( pNewsGroup );
    _ASSERT( rgidProperties );
    _ASSERT( pICompletion );

    HRESULT hr = S_OK;
    DWORD   dwOffset;
    VAR_PROP_RECORD vpRecord;
    BOOL    bImpersonated = FALSE;
	BOOL	bUsageIncreased = FALSE;

    // Share lock for usage count
	m_TermLock.ShareLock();
	if ( DriverUp != m_Status ) {
		ErrorTrace( 0, "Request before initialization" );
		hr = NNTP_E_DRIVER_NOT_INITIALIZED;
		m_TermLock.ShareUnlock();
		goto Exit;
	}

	// Increment usage count
	InterlockedIncrement( &m_cUsages );
	bUsageIncreased = TRUE;
	m_TermLock.ShareUnlock();

    // Get offset properties
    hr = pNewsGroup->GetDWord(  NEWSGRP_PROP_FSOFFSET,
                                &dwOffset );
    if ( FAILED( hr ) ) {
        ErrorTrace( 0, "Group doesn't have offset" );
        goto Exit;
    }

    // We ignore the property list here, and we'll always set
    // all the var properties again.  Because doing do is not
    // much more expensive than writing a particular property,
    // which is different than exchange store case
    hr = Group2Record(  vpRecord, pNewsGroup );
    if ( FAILED( hr ) ) {
        ErrorTrace( 0, "Group 2 record failed %x", hr );
        m_PropFileLock.ExclusiveUnlock();
        goto Exit;
    }

    // Before accessing the file system, impersonate
    if ( m_bUNC ) {
        if ( !ImpersonateLoggedOnUser( hToken ) ) {
            hr = HresultFromWin32TakeDefault( ERROR_ACCESS_DENIED );
            ErrorTrace( 0, "Impersonation failed %x", hr );
            goto Exit;
        }
        bImpersonated = TRUE;
    }

    //
    // Before any vpp operation, dirty the integrity flag
    //
    m_PropFileLock.ExclusiveLock();
    hr = m_pffPropFile->DirtyIntegrityFlag();
    if ( FAILED( hr ) ) {
        ErrorTrace( 0, "Dirty vpp file's integrity failed %x", hr);
        m_PropFileLock.ExclusiveUnlock();
        goto Exit;
    }

    // Save the record back to the flatfile
    // Delete first and then insert
    hr = m_pffPropFile->DeleteRecord( dwOffset );
    if ( FAILED( hr ) ) {
        m_pffPropFile->SetIntegrityFlag();
        ErrorTrace(0, "Delete record failed %x", hr );
        m_PropFileLock.ExclusiveUnlock();
        goto Exit;
    }

    hr = m_pffPropFile->InsertRecord(   PBYTE(&vpRecord),
                                        RECORD_ACTUAL_LENGTH( vpRecord ),
                                        &dwOffset );
    if ( FAILED( hr ) ) {
        //m_pffPropFile->SetIntegrityFlag();
        ErrorTrace( 0, "Insert record failed %x", hr );
        m_PropFileLock.ExclusiveUnlock();
        goto Exit;
    }

    //
    // After vpp operation, set integrity flag
    //
    hr = m_pffPropFile->SetIntegrityFlag();
    if ( FAILED( hr ) ) {
        ErrorTrace( 0, "Set vpp file's integrity failed %x", hr);
        m_PropFileLock.ExclusiveUnlock();
        goto Exit;
    }

    // Set offset back into the bag
    hr = pNewsGroup->PutDWord(  NEWSGRP_PROP_FSOFFSET,
                                dwOffset );
    if ( FAILED( hr ) ) {
        ErrorTrace( 0, "Put offset into bag failed %x", hr );
        m_PropFileLock.ExclusiveUnlock();
        goto Exit;
    }

    m_PropFileLock.ExclusiveUnlock();

Exit:

    if ( bImpersonated ) RevertToSelf();

	if ( pNewsGroup ) {
		//pNewsGroup->Release();
		pICompletion->ReleaseBag( pNewsGroup );
		pNewsGroup = NULL;
	}

	pICompletion->SetResult( hr );
	pICompletion->Release();
	if ( bUsageIncreased )	InterlockedDecrement( &m_cUsages );

	TraceFunctLeave();
}

void
CNntpFSDriver::GetArticle(	IN INNTPPropertyBag *pPrimaryGroup,
                            IN INNTPPropertyBag *pCurrentGroup,
                            IN ARTICLEID    idPrimaryArt,
							IN ARTICLEID	idCurrentArt,
							IN STOREID		idStore,
							IN HANDLE       hToken,
							OUT VOID		**ppvFileHandleContext,
							IN INntpComplete	*pICompletion,
							IN BOOL         fAnonymous )
/*++
Routine description:

	Get an article from the driver

Arguments:

	IN IUnknown *punkPropBag - The property bag pointer
	IN ARTICLEID idArt - The article id to get
	IN STOREID idStore - I ignore  it
	IN HANDLE   hToken - The client's access token
	OUT HANDLE *phFile - Buffer for the opened handle
	IN INntpComplete *pICompletion - completion object
--*/
{
	TraceFunctEnter( "CNntpFSDriver::GetArticle" );
	_ASSERT( pPrimaryGroup );
	_ASSERT( ppvFileHandleContext );
	_ASSERT( pICompletion );

	HRESULT 			hr;
	DWORD				dwLen;
	CHAR				szGroupName[MAX_GROUPNAME+1];
	CHAR				szFullPath[MAX_PATH+1];
	PFIO_CONTEXT        phcFileHandleContext = NULL;
	CREATE_FILE_ARG     arg;
	BOOL                bImpersonated = FALSE;
	BOOL				bUsageIncreased = FALSE;

	arg.bUNC = m_bUNC;
	arg.hToken = hToken;

	// Share lock for usage count
	m_TermLock.ShareLock();
	if ( DriverUp != m_Status ) {
		ErrorTrace( 0, "Request before initialization" );
		hr = NNTP_E_DRIVER_NOT_INITIALIZED;
		m_TermLock.ShareUnlock();
		goto Exit;
	}

	// Increment usage count
	InterlockedIncrement( &m_cUsages );
	bUsageIncreased = TRUE;
	m_TermLock.ShareUnlock();

	// Get group name
	dwLen = MAX_GROUPNAME;
	hr = pPrimaryGroup->GetBLOB(	NEWSGRP_PROP_NAME, (UCHAR*)szGroupName, &dwLen);
	if ( FAILED( hr )) {
		//pPrimaryGroup->Release();
		ErrorTrace( 0, "Failed to get group name %x", hr );
		goto Exit;
	}
	_ASSERT( dwLen > 0 );

	// I may release the property bag now
	//pPrimaryGroup->Release(); Moved to Exit

	// I should release the current bag anyway, even if I don't
	// need to use it
	//if ( pCurrentGroup ) pCurrentGroup->Release();    Moved to Exit

	// Make up the file name based on article id
	dwLen = MAX_PATH;
	hr = ObtainFullPathOfArticleFile(	szGroupName,
										idPrimaryArt,
										szFullPath,
										dwLen );
	if ( FAILED( hr ) ) {
		ErrorTrace( 0, "Failed to obtain article full path %x", hr );
		goto Exit;
	}

	// Before accessing the file system, impersonate
    if ( m_bUNC ) {
        if ( !ImpersonateLoggedOnUser( hToken ) ) {
            hr = HresultFromWin32TakeDefault( ERROR_ACCESS_DENIED );
            ErrorTrace( 0, "Impersonation failed %x", hr );
            goto Exit;
        }
        bImpersonated = TRUE;
    }

	// Open the file for read.  If this is an article in _slavegroup, then
	// we don't bother to put it in the cache.

	if (IsSlaveGroup()) {

        HANDLE hFile = CreateFileA(
                        szFullPath,
                        GENERIC_READ,
                        FILE_SHARE_READ | FILE_SHARE_WRITE,
                        0,
                        OPEN_EXISTING,
                        FILE_ATTRIBUTE_READONLY |
                        FILE_FLAG_SEQUENTIAL_SCAN |
                        FILE_FLAG_OVERLAPPED,
                        NULL
                        ) ;
        if( hFile != INVALID_HANDLE_VALUE ) {
            phcFileHandleContext = AssociateFile(hFile);
        }

        if (hFile == INVALID_HANDLE_VALUE || phcFileHandleContext == NULL) {
            hr = HresultFromWin32TakeDefault( ERROR_FILE_NOT_FOUND );
            ErrorTrace( 0, "Failed to create file %x", hr );
            if (hFile != INVALID_HANDLE_VALUE) {
                CloseHandle(hFile);
            }
            goto Exit;
        }


    } else {
	    phcFileHandleContext = CacheCreateFile( szFullPath,
                                                CreateFileCallback,
                                                PVOID(&arg),
                                                TRUE) ;
        if ( NULL == phcFileHandleContext ) {
            hr = HresultFromWin32TakeDefault( ERROR_FILE_NOT_FOUND );
            ErrorTrace( 0, "Failed to create file from handle cache %x", hr );
            goto Exit;
        }
    }

    //
    //  Outbound case here is how to handle terminated dot:
    //  1) Exchange store driver - set the bit in m_ppfcFileContext to "No dot"
    //  2) NNTP FS driver - set the bit in m_ppfcFileContext to "Has dot"
    //  Protocol will base on this flag to decide whether to add dot, or not during
    //  TransmitFile().
    //
    SetIsFileDotTerminated( phcFileHandleContext, TRUE );

    // Set this context
    *ppvFileHandleContext = phcFileHandleContext;

Exit:

    if ( bImpersonated ) RevertToSelf();

    // Releaes bags
    if ( pPrimaryGroup ) {
        //pPrimaryGroup->Release();
        pICompletion->ReleaseBag( pPrimaryGroup );
        pPrimaryGroup = NULL;
    }

    if ( pCurrentGroup ) {
        //pCurrentGroup->Release();
        pICompletion->ReleaseBag( pCurrentGroup );
        pCurrentGroup = NULL;
    }

	pICompletion->SetResult( hr );
	pICompletion->Release();
	if ( bUsageIncreased )	InterlockedDecrement( &m_cUsages );

	TraceFunctLeave();
}

void
CNntpFSDriver::DeleteArticle(     INNTPPropertyBag *pPropBag,
                   DWORD            cArticles,
                   ARTICLEID        rgidArt[],
                   STOREID          rgidStore[],
                   HANDLE           hToken,
                   DWORD            *pdwLastSuccess,
                   INntpComplete    *pICompletion,
                   BOOL             fAnonymous )
/*++
Routine description:

	Delete an article, physically.

Arguments:

	IN INNTPPropertyBag *pGroupBag - Group's property bag
	IN ARTICLEID idArt - Article id to delete
	IN STOREID idStore - I don't care
	IN HANDLE   hToken - The client's access token
	IN INntpComplete *pICompletion - Completion object
--*/
{
	TraceFunctEnter( "CNntpFSDriver::DeleteArticle" );
	_ASSERT( pPropBag );
	_ASSERT( cArticles > 0 );
	_ASSERT( rgidArt );
	_ASSERT( pICompletion );

	HRESULT 			hr;
	DWORD               i = 0;
	BOOL				bUsageIncreased = FALSE;

	// Share lock for usage count
	m_TermLock.ShareLock();
	if ( DriverUp != m_Status  ) {
		ErrorTrace( 0, "Request before initialization" );
		hr = NNTP_E_DRIVER_NOT_INITIALIZED;
		m_TermLock.ShareUnlock();
		goto Exit;
	}

	// Increment the usage count
	InterlockedIncrement( &m_cUsages );
	bUsageIncreased = TRUE;	
	m_TermLock.ShareUnlock();

    if ( m_bUNC ) {
        if ( !ImpersonateLoggedOnUser( hToken ) ) {
            hr = HresultFromWin32TakeDefault( ERROR_ACCESS_DENIED );
            ErrorTrace( 0, "Impersonation failed %x", hr );
            goto Exit;
        }
    }

    for ( i = 0; i < cArticles; i ++ ) {
    	hr = DeleteInternal( pPropBag, rgidArt[i] );
    	if ( FAILED( hr ) ) {
    	    ErrorTrace( 0, "Deleting article %d failed", rgidArt[i] );
    	    break;
    	}
    	if ( pdwLastSuccess ) *pdwLastSuccess = i;
    }

    if ( m_bUNC ) RevertToSelf();

Exit:

	_ASSERT( pPropBag );
	if( pPropBag ) {
		//pPropBag->Release();
		pICompletion->ReleaseBag( pPropBag );
		pPropBag = NULL;
	}

	if ( i > 0 && FAILED( hr ) ) {
	    hr = NNTP_E_PARTIAL_COMPLETE;
	}

	pICompletion->SetResult( hr );
	pICompletion->Release();
	if ( bUsageIncreased )	InterlockedDecrement( &m_cUsages );

	TraceFunctLeave();

}

void
CNntpFSDriver::CommitPost(	IN IUnknown *punkMsg,
							IN STOREID	*pidStore,
							IN STOREID *pidOthers,
							IN HANDLE   hToken,
							IN INntpComplete *pICompletion,
							IN BOOL     fAnonymous )
/*++
Routine description:

	Commit the post:
		For the primary store, which AllocMessage'd, it needs
		to do nothing; for other backing stores, they need to
		copy the content file.

Arguments:

	IN IUnknown *punkMsg - Message object
	IN STOREID *pidStore, *pidOthers - I don't care
	IN HANDLE hToken - The client's access token
	IN INntpComplete *pIComplete - Completion object
--*/
{
	TraceFunctEnter( "CNntpFSDriver::CommitPost" );
	_ASSERT( punkMsg );
	_ASSERT( pICompletion );

	IMailMsgProperties *pMsg = NULL;
	HRESULT hr;
	DWORD	dwSerial;
	PFIO_CONTEXT pfioDest;
    BOOL    fIsMyMessage;
    HANDLE  hFile = INVALID_HANDLE_VALUE;
    CHAR    szFileName[MAX_PATH+1];
    DWORD   dwLinesOffset = INVALID_FILE_SIZE;
    DWORD   dwHeaderLength = INVALID_FILE_SIZE;
    BOOL    bImpersonated = FALSE;
    BOOL    fPrimary = TRUE;
	BOOL	bUsageIncreased = FALSE;

	// Share lock for usage count
	m_TermLock.ShareLock();
	if ( DriverUp != m_Status  ) {
		ErrorTrace( 0, "Request before initialization" );
		hr = NNTP_E_DRIVER_NOT_INITIALIZED;
		m_TermLock.ShareUnlock();
		goto Exit;
	}

	// Increment the usage count
	InterlockedIncrement( &m_cUsages );
	bUsageIncreased = TRUE;
	m_TermLock.ShareUnlock();

	// QI for the message object interface
	hr = punkMsg->QueryInterface( IID_IMailMsgProperties, (void**)&pMsg );
	if ( FAILED( hr ) ) {
		ErrorTrace( 0, "QI for msg obj interface failed %x", hr );
		goto Exit;
	}

	// check to see if I am the owner of the handle
    hr = GetMessageContext( pMsg, szFileName, &fIsMyMessage, &pfioDest );
    if (FAILED(hr))
    {
        DebugTrace( (DWORD_PTR)this, "GetMessageContext failed - %x\n", hr );
        goto Exit;
    }
    _ASSERT( pfioDest );
    dwLinesOffset = pfioDest->m_dwLinesOffset;
    dwHeaderLength = pfioDest->m_dwHeaderLength;

    // Before accessing the file system, impersonate
    if ( m_bUNC ) {
        if ( !ImpersonateLoggedOnUser( hToken ) ) {
            hr = HresultFromWin32TakeDefault( ERROR_ACCESS_DENIED );
            ErrorTrace( 0, "Impersonation failed %x", hr );
            goto Exit;
        }
        bImpersonated = TRUE;
    }

	if ( S_FALSE == hr || !fIsMyMessage /*dwSerial != DWORD( this )*/ ) { // copy the content

		// Alloc a file handle in the local store
		hr = AllocInternal( pMsg, &pfioDest, szFileName, FALSE, FALSE, hToken );
		if ( FAILED( hr ) ) {
			ErrorTrace( 0, "Open local file failed %x", hr );
			goto Exit;
		}

		// copy the content
		hr = pMsg->CopyContentToFileEx( pfioDest, TRUE, NULL );
		if ( FAILED( hr ) ) {
			ErrorTrace( 0, "Copy content failed %x", hr );
			ReleaseContext( pfioDest );
			goto Exit;
		}

		fPrimary = FALSE;
    }

	//
	// We should insert the fio context into file handle cache and
	// release the reference, if we are primary store, then we shouldn't
	// release the context since we might be used for copying to other
	// stores.  But if we are secondary, then we can go ahead and release
	// the FIO_CONTEXT
	//
	// Note:  We only insert the file into the cache if we're not posting
	// to _slavegroup.
	//
	if (!IsSlaveGroup()) {
	    if ( !InsertFile( szFileName, pfioDest, fPrimary ) ) {
	        ErrorTrace( 0, "Insert file context into cache failed %d", GetLastError() );
            hr = HresultFromWin32TakeDefault( ERROR_ALREADY_EXISTS );

	        // At least I should release the context
	        if ( !fPrimary ) ReleaseContext( pfioDest );
	        goto Exit;
	    }
	}

    //  Here we need to handle the Terminated Dot.  The logic is:
    //  1) Check to see if pfioContext has the Terminated Dot
    //  2) If "Has dot", NNTP FS driver does nothing, Exchange Store driver:
    //     a) Strip the dot by SetFileSize()
    //     b) Set bit in pfioContext to "No dot"
    //  3) If "No dot", Exchange Store driver does nothing, NNTP FS driver:
    //     a) Add the dot by SetFileSize().
    //     b) Set bit in pfioContext to "Has dot"
    //
    if (!GetIsFileDotTerminated(pfioDest))
    {
        //  No dot, add it
        AddTerminatedDot( pfioDest->m_hFile );

        //  Set pfioContext to "Has dot"
        SetIsFileDotTerminated( pfioDest, TRUE );
    }

    //
    // Back fill the Lines information, if necessary
    //
    if ( dwLinesOffset != INVALID_FILE_SIZE ) {

        // then we'll have to back fill it
        BackFillLinesHeader(    pfioDest->m_hFile,
                                dwHeaderLength,
                                dwLinesOffset );
    }

Exit:

    if ( bImpersonated ) RevertToSelf();

	// Release the message interface
	if ( pMsg ) {
		pMsg->Release();
		pMsg = NULL;
	}

	_ASSERT( punkMsg );
	if( punkMsg ) {
		punkMsg->Release();
		punkMsg = NULL;
	}


	pICompletion->SetResult( hr );
	pICompletion->Release();
	if ( bUsageIncreased ) InterlockedDecrement( &m_cUsages );

	TraceFunctLeave();
}

void STDMETHODCALLTYPE
CNntpFSDriver::GetXover(    IN INNTPPropertyBag *pPropBag,
                            IN ARTICLEID    idMinArticle,
                            IN ARTICLEID    idMaxArticle,
                            OUT ARTICLEID   *pidNextArticle,
                            OUT LPSTR       pcBuffer,
                            IN DWORD        cbin,
                            OUT DWORD       *pcbout,
                            IN HANDLE       hToken,
                            INntpComplete	*pICompletion,
                            IN BOOL         fAnonymous )
/*++
Routine Description:

    Get Xover information from the store driver.

Arguments:

    IN INNTPPropertyBag *pPropBag  - Interface pointer to the news group prop bag
    IN ARTICLEID idMinArticle   - The low range of article id to be retrieved from
    IN ARTICLEID idMaxArticle   - The high range of article id to be retrieved from
    OUT ARTICLEID *pidNextArticle - Buffer for actual last article id retrieved,
                                    0 if no article retrieved
    OUT LPSTR pcBuffer          - Header info retrieved
    IN DWORD cbin               - Size of pcBuffer
    IN HANDLE   hToken          - The client's access token
    OUT DWORD *pcbout             - Actual bytes written into pcBuffer

Return value:

    S_OK                    - Succeeded.
    NNTP_E_DRIVER_NOT_INITIALIZED - Driver not initialized
    S_FALSE   - The buffer provided is too small, but content still filled
--*/

{
	TraceFunctEnter( "CNntpFSDriver::GetXover" );
	_ASSERT( pPropBag );
	_ASSERT( idMinArticle <= idMaxArticle );
	_ASSERT( pidNextArticle );
	_ASSERT( cbin > 0 );
	_ASSERT( pcbout );
	_ASSERT( pICompletion );

	HRESULT	hr = S_OK;
	BOOL	bUsageIncreased = FALSE;

	// Share lock for usage count
	m_TermLock.ShareLock();
	if ( DriverUp != m_Status  ) {
		ErrorTrace( 0, "Request before initialization" );
		hr = NNTP_E_DRIVER_NOT_INITIALIZED;
		m_TermLock.ShareUnlock();
		goto Exit;
	}

	// Increment the usage count
	InterlockedIncrement( &m_cUsages );
	bUsageIncreased = TRUE;
	m_TermLock.ShareUnlock();

	hr = GetXoverInternal( 	pPropBag,
							idMinArticle,
							idMaxArticle,
							pidNextArticle,
							NULL,
							pcBuffer,
							cbin,
							pcbout,
							TRUE,	// is xover
							hToken,
							pICompletion
						);
	if ( FAILED( hr ) ) {
		ErrorTrace( 0, "GetXover failed %x", hr );
	}

Exit:

	pICompletion->SetResult( hr );
	pICompletion->Release();
	if ( bUsageIncreased )	InterlockedDecrement( &m_cUsages );

	TraceFunctLeave();

}

void STDMETHODCALLTYPE
CNntpFSDriver::GetXhdr(    IN INNTPPropertyBag *pPropBag,
                           IN ARTICLEID    idMinArticle,
                           IN ARTICLEID    idMaxArticle,
                           OUT ARTICLEID   *pidNextArticle,
                           IN LPSTR		   szHeader,
                           OUT LPSTR       pcBuffer,
                           IN DWORD        cbin,
                           OUT DWORD       *pcbout,
                           IN HANDLE        hToken,
                           INntpComplete	*pICompletion,
                           IN BOOL          fAnonymous )
/*++
Routine Description:

    Get Xover information from the store driver.

Arguments:

    IN INNTPPropertyBag *pPropBag  - Interface pointer to the news group prop bag
    IN ARTICLEID idMinArticle   - The low range of article id to be retrieved from
    IN ARTICLEID idMaxArticle   - The high range of article id to be retrieved from
    OUT ARTICLEID *pidNextArticle - Buffer for actual last article id retrieved,
                                    0 if no article retrieved
    IN szHeader					- The header key word
    OUT LPSTR pcBuffer          - Header info retrieved
    IN DWORD cbin               - Size of pcBuffer
    IN HANDLE hToken            - The client's access token
    OUT DWORD *pcbout             - Actual bytes written into pcBuffer

Return value:

    S_OK                    - Succeeded.
    NNTP_E_DRIVER_NOT_INITIALIZED - Driver not initialized
    S_FALSE   - The buffer provided is too small, but content still filled
--*/

{
	TraceFunctEnter( "CNntpFSDriver::GetXhdr" );
	_ASSERT( pPropBag );
	_ASSERT( idMinArticle <= idMaxArticle );
	_ASSERT( pidNextArticle );
	_ASSERT( cbin > 0 );
	_ASSERT( pcbout );
	_ASSERT( szHeader );
	_ASSERT( pICompletion );

	HRESULT	hr = S_OK;
	BOOL	bUsageIncreased = FALSE;
	// Share lock for usage count
	m_TermLock.ShareLock();
	if ( DriverUp != m_Status  ) {
		ErrorTrace( 0, "Request before initialization" );
		hr = NNTP_E_DRIVER_NOT_INITIALIZED;
		m_TermLock.ShareUnlock();
		goto Exit;
	}

	// Increment the usage count
	InterlockedIncrement( &m_cUsages );
	bUsageIncreased = TRUE;
	m_TermLock.ShareUnlock();

	hr = GetXoverInternal( 	pPropBag,
							idMinArticle,
							idMaxArticle,
							pidNextArticle,
							szHeader,
							pcBuffer,
							cbin,
							pcbout,
							FALSE,	// is xover
							hToken,
							pICompletion
						);
	if ( FAILED( hr ) ) {
		ErrorTrace( 0, "GetXhdr failed %x", hr );
	}

Exit:

	pICompletion->SetResult( hr );
	pICompletion->Release();
	if ( bUsageIncreased )	InterlockedDecrement( &m_cUsages );

	TraceFunctLeave();

}

HRESULT CNntpFSDriver::InitializeTagFiles(INntpComplete *pComplete)
/*++
Routine description:

	this function is called only in normal startup, and when tag files are not dropped.
	this function will loop through all newsgroups in the nntpsvc hashtable (which is from group.lst)
	drop a newsgrp.tag in these groups.

Arguments:

	INntpComplete *pComplete
    
Return value:

	HRESULT, return S_OK if success
--*/

{

	TraceFunctEnter( "CNntpFSDriver::InitializeTagFiles" );
	
	HRESULT hr = S_OK;
	CHAR szFile[MAX_PATH];
	CHAR szDir[MAX_PATH];
	INewsTreeIterator *piter = NULL;
	INNTPPropertyBag *pPropBag = NULL;
	INntpDriver *pDriver = NULL;
	CHAR    szGroupName[MAX_GROUPNAME+1];

	DWORD   dwOffset;
	DWORD   dwLen;
	
	// IF NEWSGRP.TAG EXISTS IN VROOT, REMOVE IT
	if ( FAILED( MakeChildDirPath( m_szFSDir, "newsgrp.tag", szFile, sizeof(szFile) ) ) ) 
	{
		// this should not happen
		hr = TYPE_E_BUFFERTOOSMALL;
		ErrorTrace(0, "File delete failed in %s - %x", m_szFSDir, TYPE_E_BUFFERTOOSMALL );
		goto Exit;
	}	

	if(CheckFileExists(szFile))
	{
		if (!DeleteFile(szFile))
			ErrorTrace(0,"Can't delete %s - %x", szFile, GetLastError());
		//This is not fatal
	}


	_ASSERT(m_pINewsTree);
	




	// GET THE NEWSTREE ITERATOR
	hr = m_pINewsTree->GetIterator( &piter );
	if ( FAILED( hr ) ) {
		ErrorTrace( 0, "Get news tree iterator failed %x", hr );
		goto Exit;
	}

	// Enumerate all the groups
	_ASSERT( piter );
	while( !(piter->IsEnd()) ) {

		hr = piter->Current( &pPropBag, pComplete );
		
		if ( FAILED( hr ) ) {
			ErrorTrace( 0, "Enumerate group failed %x", hr );
			goto Exit;
		}
		_ASSERT( pPropBag );

		//
		// Don't create groups that don't belong to me
		//
		dwLen = sizeof(szGroupName)-1;
		szGroupName[sizeof(szGroupName)-1]='\0';
		hr = pPropBag->GetBLOB( NEWSGRP_PROP_NAME, (PBYTE)szGroupName, &dwLen );
		if ( FAILED( hr ) ) {
		ErrorTrace( 0, "Get group name failed %x", hr );
		goto Exit;
		}
		
		_ASSERT( dwLen <= MAX_GROUPNAME && dwLen > 0);

		hr = m_pINewsTree->LookupVRoot( szGroupName, &pDriver );
		if ( FAILED( hr ) ) {
			ErrorTrace( 0, "Vroot lookup failed %x", hr );
			goto Exit;
		}

		if ( (INntpDriver*)this != pDriver ) {
			hr = S_OK;
			DebugTrace( 0, "This group doesn't belong to me" );
			goto Next;
		}

		hr = GroupName2Path( szGroupName, szDir, sizeof(szDir) );
		if ( FAILED( hr ) ) {
			ErrorTrace( 0, "insufficient buffer for path %x", hr );
			goto Exit;
		}

		hr = CreateAdminFileInDirectory(szDir, "newsgrp.tag");
		if ( FAILED( hr ) ) {
			ErrorTrace( 0, "create newsgrp.tag file in %s failed: %x", szDir, hr );
			goto Exit;
		}
			
Next:
		_ASSERT( pPropBag );
		pComplete->ReleaseBag( pPropBag );
		pPropBag = NULL;

		piter->Next();
	}

Exit:


	if ( pPropBag ) {
		pComplete->ReleaseBag( pPropBag );
		pPropBag = NULL;
	}

	if ( piter ) {
		piter->Release();
		piter = NULL;
	}
	return hr;
}


void STDMETHODCALLTYPE
CNntpFSDriver::DecorateNewsTreeObject(  IN HANDLE hToken,
                                        IN INntpComplete *pICompletion )
/*++
Routine description:

	On driver start up, it does a sanity check of newstree, against
	driver owned property file and against hash tables

Arguments:

    IN HANDLE hToken - The client's access token
	IN INntpComplete *pICompletion - The completion object

Return value:

	S_OK - Success
--*/
{
	TraceFunctEnter( "CNntpFSDriver::DecorateNewsTreeObject" );
	_ASSERT( pICompletion );

	HRESULT hr = S_OK;
	BOOL                bImpersonated = FALSE;
	BOOL				bUsageIncreased = FALSE;
	CHAR	szVRootTagFile[MAX_PATH];
	BOOL	bNeedToDropTagFile = FALSE;

	// Share lock for usage count
	m_TermLock.ShareLock();
	if ( DriverUp != m_Status  ) {
		ErrorTrace( 0, "Request before initialization" );
		hr = NNTP_E_DRIVER_NOT_INITIALIZED;
		m_TermLock.ShareUnlock();
		goto Exit;
	}



	// Increment the usage count
	InterlockedIncrement( &m_cUsages );
	bUsageIncreased = TRUE;
	m_TermLock.ShareUnlock();



	// Before accessing the file system, impersonate
    if ( m_bUNC ) {
        if ( !ImpersonateLoggedOnUser( hToken ) ) {
            hr = HresultFromWin32TakeDefault( ERROR_ACCESS_DENIED );
            ErrorTrace( 0, "Impersonation failed %x", hr );
            goto Exit;
        }
        bImpersonated = TRUE;
    }

	// CREATE THE NEWSROOT.TAG PATH TO CHECK LATER
	if ( FAILED( MakeChildDirPath( m_szFSDir, "newsroot.tag", szVRootTagFile, sizeof(szVRootTagFile) ) ) ) 
	{
		// this should not happen
		hr = TYPE_E_BUFFERTOOSMALL;
		ErrorTrace(0, "File delete failed in %s - %x", m_szFSDir, TYPE_E_BUFFERTOOSMALL );
		goto Exit;
	}	
	bNeedToDropTagFile = !CheckFileExists(szVRootTagFile);
	
    _ASSERT( m_pNntpServer );
	if ( m_pNntpServer->QueryServerMode() == NNTP_SERVER_NORMAL ) {

		// If it's upgraded, I'll create the groups into vpp file
		//
		if ( m_fUpgrade ) {
			hr = CreateGroupsInVpp( pICompletion );
			if ( FAILED( hr ) ) {
				ErrorTrace( 0, "Create groups in vpp failed %x", hr );
				goto Exit;
			}
	    	}

		// Load group offsets into
		hr = LoadGroupOffsets( pICompletion );
		if ( FAILED( hr ) ) {
			ErrorTrace( 0, "Load group offsets failed %x", hr );
			goto Exit;
		}

		if (bNeedToDropTagFile)
		{
			hr = InitializeTagFiles(pICompletion);
			if (FAILED( hr) ) {
				ErrorTrace( 0, "initialize tag files failed %x", hr);
				goto Exit;
			}

			// CREATE NEWSROOT.TAG
			hr = CreateAdminFileInDirectory(m_szFSDir, "newsroot.tag");
			if (FAILED (hr))
			{
				ErrorTrace(0, "create newsroot.tag failed -%x", hr);
				goto Exit;
			}		
		}
	} else {
		//
		// The server is in rebuild mode, we'll skip the sanity
		// check since we got into rebuild because of data inconsistency.
		// And we'll also load groups into newstree
		//
		_ASSERT( m_pNntpServer->QueryServerMode() == NNTP_SERVER_STANDARD_REBUILD ||
		m_pNntpServer->QueryServerMode() == NNTP_SERVER_CLEAN_REBUILD );


		hr = LoadGroups( pICompletion, bNeedToDropTagFile );
		if ( FAILED( hr ) ) {
			ErrorTrace( 0, "Load groups during rebuild failed %x", hr );
			goto Exit;
		}

		if (bNeedToDropTagFile)
		{
			// if we reach here, we have successfully dropped the newsroot.tag files
			// CREATE NEWSROOT.TAG
			hr = CreateAdminFileInDirectory(m_szFSDir, "newsroot.tag");
			if (FAILED (hr))
			{
				ErrorTrace(0, "create newsroot.tag failed -%x", hr);
				goto Exit;
			}	
		}
		//
		// Lets purge all our article left over in file handle cache, so
		// that if we want to parse them later, we don't hit sharing
		// violations
		//
		CacheRemoveFiles( m_szFSDir, TRUE );
	}

Exit:


	if ( bImpersonated ) RevertToSelf();

	pICompletion->SetResult( hr);
	pICompletion->Release();
	if ( bUsageIncreased )	InterlockedDecrement( &m_cUsages );

	TraceFunctLeave();
}

void STDMETHODCALLTYPE
CNntpFSDriver::CheckGroupAccess(    IN    INNTPPropertyBag *pPropBag,
                                    IN    HANDLE            hToken,
                                    IN    DWORD             dwDesiredAccess,
                                    IN    INntpComplete     *pICompletion )
/*++
Routine description:

    Check group accessibility.

Arguments:

    INNTPPropertyBag *pNewsGroup - Property bag of the news group
    HANDLE  hToken - The client access token
    DWORD   dwDesiredAccess - The client's desired access
    INntpComplete *pIcompletion - The completion object

Return value:

    None.
    In completion object: S_OK  - Access allowed
                            E_ACCESSDENIED - Access is denied
--*/
{
    TraceFunctEnter( "CNntpFSDriver::CheckGroupAccess" );

	_ASSERT( pICompletion );
	_ASSERT( pPropBag );

	HRESULT hr = S_OK;
	CHAR    pbSecDesc[512];
	DWORD   cbSecDesc = 512;
	LPSTR   lpstrSecDesc = NULL;
	BOOL    bAllocated = FALSE;
	BOOL	bUsageIncreased = FALSE;

    // Generic mapping for file system
	GENERIC_MAPPING gmFile = {
        FILE_GENERIC_READ,
        FILE_GENERIC_WRITE,
        FILE_GENERIC_EXECUTE,
        FILE_ALL_ACCESS
    } ;

    BYTE    psFile[256] ;
    DWORD   dwPS = sizeof( psFile ) ;
    DWORD   dwGrantedAccess = 0;
    BOOL    bAccessStatus = FALSE;

	// Share lock for usage count
	m_TermLock.ShareLock();
	if ( DriverUp != m_Status  ) {
		ErrorTrace( 0, "Request before initialization" );
		hr = NNTP_E_DRIVER_NOT_INITIALIZED;
		m_TermLock.ShareUnlock();
		goto Exit;
	}

	// Increment the usage count
	InterlockedIncrement( &m_cUsages );
	bUsageIncreased = TRUE;
	m_TermLock.ShareUnlock();

	// If FAT, return S_OK
	if ( m_dwFSType == FS_FAT ) {
	    hr = S_OK;
	    goto Exit;
	}

	// Check if the group has security descriptor
	lpstrSecDesc = pbSecDesc;
	hr = pPropBag->GetBLOB( NEWSGRP_PROP_SECDESC,
	                        PBYTE(lpstrSecDesc),
	                        &cbSecDesc );
	if ( FAILED( hr ) ) {

	    // If failed because of insufficient buffer, give it
	    // a retry
	    if ( TYPE_E_BUFFERTOOSMALL == hr ) {

	        // we hate "new", but this is fine since it doesn't
	        // happen quite often.  Normally 512 bytes for
	        // security descriptor would be enough
	        _ASSERT( cbSecDesc > 512 );
	        lpstrSecDesc = XNEW char[cbSecDesc];
	        if ( NULL == lpstrSecDesc ) {
	            ErrorTrace( 0, "Out of memory" );
	            hr = E_OUTOFMEMORY;
	            goto Exit;
	        }

	        bAllocated = TRUE;

	        // try to get it from property bag agin
	        hr = pPropBag->GetBLOB( NEWSGRP_PROP_SECDESC,
	                                PBYTE(lpstrSecDesc),
	                                &cbSecDesc );
	        if ( FAILED( hr ) ) {

	            // How come it failed again ?  this is fatal
	            ErrorTrace( 0, "Can not get sec descriptor from bag %x", hr );
	            goto Exit;
	        }

        } else if ( HRESULT_FROM_WIN32( ERROR_NOT_FOUND ) == hr ) {

            cbSecDesc = 512;
            hr = LoadGroupSecurityDescriptor(   pPropBag,
                                                lpstrSecDesc,
                                                &cbSecDesc,
                                                TRUE,
                                                &bAllocated );
            if ( FAILED( hr ) ) {
                ErrorTrace( 0, "Load group security desc failed %x", hr );
                goto Exit;
            }
        } else {    // fatal error

            ErrorTrace( 0, "Get security descriptor from bag failed %x", hr );
            goto Exit;

        }
    }

    // Now we interpret dwDesiredAccess into the language of
    // GENERIC_READ, GENERIC_WRITE for NTFS
    dwDesiredAccess = ( dwDesiredAccess == NNTP_ACCESS_READ ) ? GENERIC_READ :
    			   ( dwDesiredAccess == NNTP_ACCESS_POST ) ? FILE_ADD_FILE :  // same as FILE_WRITE_DATA
    			   ( dwDesiredAccess == NNTP_ACCESS_REMOVE ) ? FILE_DELETE_CHILD :
    			   ( dwDesiredAccess == NNTP_ACCESS_REMOVE_FOLDER) ? FILE_DELETE_CHILD :
    			   ( dwDesiredAccess == NNTP_ACCESS_EDIT_FOLDER ) ? FILE_WRITE_EA :
                        GENERIC_READ | GENERIC_WRITE;

    // Generic map
    MapGenericMask( &dwDesiredAccess, &gmFile );

    // Being here, we should already have a security descriptor
    // for the group in lpstrSecDesc and the length is cbSecDesc
    if ( !AccessCheck(  PSECURITY_DESCRIPTOR( lpstrSecDesc ),
                        hToken,
                        dwDesiredAccess,
                        &gmFile,
                        PPRIVILEGE_SET(psFile),
	                    &dwPS,
                        &dwGrantedAccess,
                        &bAccessStatus ) ) {
        //
        // If we failed because we were given a token that's not
        // impersonation token, we'll duplicate and give it a
        // try again
        //
        if ( GetLastError() == ERROR_NO_IMPERSONATION_TOKEN ) {

            HANDLE  hImpersonationToken = NULL;
            if ( !DuplicateToken(   hToken,
                                    SecurityImpersonation,
                                    &hImpersonationToken ) ) {
          	    hr = HresultFromWin32TakeDefault( ERROR_ACCESS_DENIED );
                ErrorTrace( 0, "Duplicate token failed %x", hr );
                goto Exit;
            } else {
                if ( !AccessCheck(  PSECURITY_DESCRIPTOR( lpstrSecDesc ),
                                    hImpersonationToken,
                                    dwDesiredAccess,
                                    &gmFile,
                                    PPRIVILEGE_SET(psFile),
	                                &dwPS,
                                    &dwGrantedAccess,
                                    &bAccessStatus ) ) {
                    hr = HresultFromWin32TakeDefault( ERROR_ACCESS_DENIED );
                    _VERIFY( CloseHandle( hImpersonationToken ) );
                    ErrorTrace( 0, "Access checked failed with %x", hr );
                    goto Exit;
                }

                _VERIFY( CloseHandle( hImpersonationToken ) );

            }
        } else {
            hr = HresultFromWin32TakeDefault( ERROR_ACCESS_DENIED );
            ErrorTrace( 0, "Access checked failed with %x", hr );
            goto Exit;
        }
    }

    hr = bAccessStatus ? S_OK : E_ACCESSDENIED;

Exit:

    // Release the property bag
    if ( pPropBag ) {
        //pPropBag->Release();
        pICompletion->ReleaseBag( pPropBag );
    }

    // If the security descriptor is dynamically allocated, free it
    if ( bAllocated ) XDELETE[] lpstrSecDesc;

	pICompletion->SetResult( hr);
	pICompletion->Release();
	if ( bUsageIncreased )	InterlockedDecrement( &m_cUsages );

	TraceFunctLeave();
}

void
CNntpFSDriver::RebuildGroup(    IN INNTPPropertyBag *pPropBag,
                                IN HANDLE           hToken,
                                IN INntpComplete     *pComplete )
/*++
Routine description:

    Enumerate all the physical articles in the group, parse out
    the headers, post them into server using INntpServer ( asking
    the server not to re-assign article id ) and then update
    newsgroup properties ( for all the cross posted groups )

Arguments:

    IN INNTPPropertyBag *pPropBag   - The property bag of the group
    IN HANDLE hToken                - Client's hToken
    IN INntpComplete *pComplete     - Completion object

Return value:

    None.
--*/
{
    TraceFunctEnter( "CNntpFSDriver::Rebuild" );
    _ASSERT( pPropBag );
    _ASSERT( pComplete );

    HRESULT         hr = S_OK;
    BOOL            f;
    INntpDriver      *pDriver = NULL;
    HANDLE          hFind = INVALID_HANDLE_VALUE;
    DWORD   dwLen = MAX_NEWSGROUP_NAME+1;
	BOOL			bUsageIncreased = FALSE;

    //
    // Share lock for usage count
    //
	m_TermLock.ShareLock();
	if ( DriverUp != m_Status  ) {
		ErrorTrace( 0, "Request before initialization" );
		hr = NNTP_E_DRIVER_NOT_INITIALIZED;
		m_TermLock.ShareUnlock();
		goto Exit;
	}

    //
	// Increment the usage count
	//
	InterlockedIncrement( &m_cUsages );
	bUsageIncreased = TRUE;
	m_TermLock.ShareUnlock();

	//
	// Make up the pattern for findfirst/findnext
	//
	CHAR    szGroupName[MAX_NEWSGROUP_NAME+1];
	CHAR    szFullPath[2 * MAX_PATH];
	CHAR    szPattern[2 * MAX_PATH];
	CHAR    szFileName[MAX_PATH+1];
	CHAR    szBadFileName[MAX_PATH+1];
	hr = pPropBag->GetBLOB( NEWSGRP_PROP_NAME,
	                                PBYTE( szGroupName ),
	                                &dwLen );
	if ( FAILED( hr ) ) {
	    ErrorTrace( 0, "Get group name failed %x", hr );
	    goto Exit;
	}
	_ASSERT( strlen( szGroupName ) <= MAX_PATH );

	//
	// Check to see if this group really belongs to me
	//
	hr = m_pINewsTree->LookupVRoot( szGroupName, &pDriver );
	if ( FAILED ( hr ) || pDriver != (INntpDriver*)this ) {
		DebugTrace(0, "I don't own this group %s", szGroupName );
		goto Exit;
	}

	hr = GroupName2Path( szGroupName, szFullPath, MAX_PATH+1 );
	if ( FAILED( hr ) ) {
	    ErrorTrace( 0, "insufficient buffer for path %x", hr );
	    goto Exit;
	}

    _ASSERT( strlen( szFullPath ) <= MAX_PATH );

    hr = MakeChildDirPath(  szFullPath,
                            "*.nws",
                            szPattern,
                            MAX_PATH );
    if ( FAILED( hr ) ) {
        ErrorTrace( 0, "makechilddirpath failed %x", hr );
        goto Exit;
    }
    _ASSERT( strlen( szPattern ) <= MAX_PATH );

    //
    // FindFirst/FindNext
    //
    WIN32_FIND_DATA FindData;

    //
    // If I am UNC Vroot, impersonate here
    //
    if ( m_bUNC ) {
        if ( !ImpersonateLoggedOnUser( hToken ) ) {
            hr = HresultFromWin32TakeDefault( ERROR_ACCESS_DENIED );
		    ErrorTrace( 0, "Impersonation failed %x", hr );
		    goto Exit;
		}
    }

    hFind = FindFirstFile( szPattern, &FindData );
    f = (INVALID_HANDLE_VALUE != hFind );
    while( f ) {

        //
        // If I am told to cancel, should not continue
        //
        if ( !m_pNntpServer->ShouldContinueRebuild() ) {
            DebugTrace( 0, "Rebuild cancelled" );
            if ( m_bUNC ) RevertToSelf();
            goto Exit;
        }

        //
        // Make a full path for the file name
        //
        hr = MakeChildDirPath(  szFullPath,
                                FindData.cFileName,
                                szFileName,
                                MAX_PATH );
        if( FAILED( hr ) ) {
            ErrorTrace( 0, "Make Childdir path failed %x", hr );
            if ( m_bUNC ) RevertToSelf();
            goto Exit;
        }

        //
        // Do all the work
        //
        hr = PostToServer(  szFileName,
                            szGroupName,
                            pComplete );
        if ( FAILED( hr ) ) {

            ErrorTrace( 0, "Post article to server failed %x", hr );
            if ( m_bUNC ) RevertToSelf();
            goto Exit;
        }

        //
        // If it's S_FALSE, we'll rename it to be *.bad
        //
        if ( S_FALSE == hr ) {
            lstrcpyn( szBadFileName, szFileName, sizeof(szBadFileName)-4);
            strcat( szBadFileName, ".bad" );
            _VERIFY( MoveFile( szFileName, szBadFileName ) );
        }

        f = FindNextFile( hFind, &FindData );
    }

    if ( m_bUNC ) RevertToSelf();

Exit:

    // Close the find handle
    if ( INVALID_HANDLE_VALUE != hFind )
        _VERIFY( FindClose( hFind ) );

    // Release the property bag
    if ( pPropBag ) {
        pComplete->ReleaseBag( pPropBag );
    }

	pComplete->SetResult( hr);
	pComplete->Release();
	if ( bUsageIncreased )	InterlockedDecrement( &m_cUsages );

	TraceFunctLeave();
}

/////////////////////////////////////////////////////////////////
// IMailMsgStoreDriver interface implementation
/////////////////////////////////////////////////////////////////
HRESULT
CNntpFSDriver::AllocMessage(	IN IMailMsgProperties *pMsg,
								IN DWORD	dwFlags,
								OUT IMailMsgPropertyStream **ppStream,
								OUT PFIO_CONTEXT *ppFIOContentFile,
								IN IMailMsgNotify *pNotify )
/*++
Routine description:

	Allocate property stream and content file for a recipient (
	with async completion ).

Arguments:

	IN IMailMsgProperties *pMsg - Specifies the message.  This may
									not be NULL ( in smtp case, it
									may be NULL ).  But we want to
									have primary group information
									at this point before opening a
									destination file handle.  By
									doing that, we even don't need to
									"MoveFile".
	IN DWORD dwFlags - Currently not used, just to make interface happy
	OUT IMailMsgPropertyStream **ppStream - not used
	OUT HANDLE *phContentFile - To return file handle opened
	IN IMailMsgNotify *pNotify - Completion object

Return value:

	S_OK - Success, the operation completed synchronously.
	MAILMSG_S_PENDING - Success, but will be completed asynchronously,
						this will never happen to the NTFS driver
--*/
{
	TraceFunctEnter( "CNntpFSDriver::AllocMessage" );
	_ASSERT( pMsg );
	_ASSERT( ppFIOContentFile );
	// I don't care about other parameters

	HRESULT hr = S_OK;
	HANDLE  hToken = NULL;
	HANDLE  hFile = INVALID_HANDLE_VALUE;
	CHAR    szFileName[MAX_PATH+1];
	BOOL    bImpersonated = FALSE;
	DWORD	dwLengthRead;
	BOOL	bUsageIncreased = FALSE;

	// Share lock for usage count
	m_TermLock.ShareLock();
	if ( DriverUp != m_Status  ) {
		ErrorTrace( 0, "Request before initialization" );
		hr = NNTP_E_DRIVER_NOT_INITIALIZED;
		m_TermLock.ShareUnlock();
		goto Exit;
	}

	// Increment the usage count
	InterlockedIncrement( &m_cUsages );
	bUsageIncreased = TRUE;
	m_TermLock.ShareUnlock();

	// Get the client token from the message object
	// BUGBUG: we'll need to have a better way to do this
	hr = pMsg->GetProperty( IMSG_POST_TOKEN,
							sizeof(hToken),
							&dwLengthRead,
							(LPBYTE)&hToken );
	_ASSERT(dwLengthRead == sizeof(hToken));

	if ( FAILED( hr ) ) {
	    ErrorTrace( 0, "Mail message doesn't have htoken" );
	    hr = E_INVALIDARG;
	    goto Exit;
	}

	// Before accessing the file system, impersonate
    if ( m_bUNC ) {
        if ( !ImpersonateLoggedOnUser( hToken ) ) {
    	    hr = HresultFromWin32TakeDefault( ERROR_ACCESS_DENIED );
                ErrorTrace( 0, "Impersonation failed %x", hr );
            goto Exit;
        }
        bImpersonated = TRUE;
    }

	hr = AllocInternal( pMsg, ppFIOContentFile, szFileName, TRUE, TRUE, hToken );
	if ( SUCCEEDED( hr ) ) {

	    _ASSERT( *ppFIOContentFile );

        /*
	    //
	    // I should stick the file name into mailmsg object, so
	    // that I can insert it into file handle cache later
	    //
	    hr = pMsg->PutProperty( IMSG_FILE_NAME, strlen( szFileName ), PBYTE(szFileName) );
	    if ( FAILED( hr ) ) {
	        ErrorTrace( 0, "Put file name into imsg failed %x", hr );
	        ReleaseContext( *ppFIOContentFile );
	        *ppFIOContentFile = NULL;
	        goto Exit;
	    }
	    */

	} else {

	    //
	    // I should also clean up the fio context, so that protocol
	    // doesn't get confused
	    //
	    *ppFIOContentFile = 0;
	}

Exit:

    if ( bImpersonated ) RevertToSelf();

	_ASSERT( pMsg );
	if ( pMsg ) {
		pMsg->Release();
	}
	if ( bUsageIncreased )	InterlockedDecrement( &m_cUsages );
	TraceFunctLeave();

	// BUGBUG: if pNotify is not NULL, we should use pNotify
	// to complete it.  But our server always pass in NULL,
	// so this is not done yet.
	return hr;
}

HRESULT
CNntpFSDriver::CloseContentFile(	IN IMailMsgProperties *pMsg,
									IN PFIO_CONTEXT pFIOContentFile )
/*++
Routine description:

	Close the content file.

Arguments:

	IN IMailMsgProperties *pMsg - Specifies the message
	IN HANDLE hContentFile - Specifies the content handle

Return value:

	S_OK - I have closed it.
	S_FALSE - it's none of my business
--*/
{
	TraceFunctEnter( "CNntpFSDriver::CloseContentFile" );
	_ASSERT( pMsg );

	HRESULT hr;
	DWORD	dwSerial;

    BOOL    fIsMyMessage = FALSE;
    PFIO_CONTEXT pfioContext = NULL;
    CHAR    szFileName[MAX_PATH+1];
    DWORD   dwFileLen = MAX_PATH;

	// Verify the driver serial number on msg object
    hr = GetMessageContext( pMsg, szFileName, &fIsMyMessage, &pfioContext );
    if (FAILED(hr))
    {
        DebugTrace( (DWORD_PTR)this, "GetMessageContext failed - %x\n", hr );
        goto Exit;
    }

    _ASSERT( pFIOContentFile == pfioContext );

	// It should not be me to close it in the following cases
	if ( NULL == pfioContext ||
			S_FALSE == hr ||	// the serial number is missing
			/*dwSerial != DWORD(this)*/
            !fIsMyMessage ) {
		DebugTrace(0, "Let somebody else close the handle" );
		hr = S_FALSE;
		goto Exit;
	}

	// We should release the context's reference
	ReleaseContext( pFIOContentFile );

    /* this is done in CommitPost now
	if ( !InsertFile( szFileName, pFIOContentFile, FALSE ) ) {
	    ErrorTrace( 0, "Insert into file handle cache failed %d", GetLastError() );

        // We should releae the context anyway
    	ReleaseContext( pFIOContentFile );
    	goto Exit;
    }*/

Exit:

	_ASSERT( pMsg );
	if ( pMsg ) {
		pMsg->Release();
		pMsg = NULL;
	}
	TraceFunctLeave();
	return hr;
}

HRESULT
CNntpFSDriver::Delete(	IMailMsgProperties *pMsg,
						IMailMsgNotify *pNotify )
/*++
Routine description:

	Delete the message given from store.

Arguments:

	IMailMsgProperties *pMsg - The message object
	IMailMsgNotify *pNotify - not used, always done synchronously

Return value:

	S_OK on success, other error code otherwise
--*/
{
	TraceFunctEnter( "CNntpFSDriver::Delete" );
	_ASSERT( pMsg );

	HRESULT hr = S_OK;
	DWORD	dwBLOBSize;
	DWORD	dwArtId;
	INNTPPropertyBag* pPropPrime;

	// Get property bag from msg object
	hr = pMsg->GetProperty(	IMSG_PRIMARY_GROUP,
							sizeof( INNTPPropertyBag* ),
							&dwBLOBSize,
							(PBYTE)&pPropPrime );
	if ( S_OK != hr ) {
		ErrorTrace( 0, "Property %d doesn't exist", IMSG_PRIMARY_GROUP );
		hr = E_INVALIDARG;
		goto Exit;
	}

	// Get article id from pMsg object
	hr = pMsg->GetDWORD(	IMSG_PRIMARY_ARTID, &dwArtId );
	if ( S_OK != hr ) {
		ErrorTrace( 0, "Property %d doesn't exist", IMSG_PRIMARY_ARTID );
		hr = E_INVALIDARG;
		goto Exit;
	}

	// Now delete it
	hr = DeleteInternal( pPropPrime, dwArtId );
	if ( FAILED( hr ) ) {
		ErrorTrace( 0, "Delete article failed %x", hr );
	}

Exit:

	TraceFunctLeave();
	return hr;
}

/////////////////////////////////////////////////////////////////
// Private methods
/////////////////////////////////////////////////////////////////
HRESULT
CNntpFSDriver::SetMessageContext(
    IMailMsgProperties* pMsg,
    char*               szFileName,
    DWORD               cbFileName,
    PFIO_CONTEXT        pfioContext
    )
/*++

Description:

    Set Message Context in mailmsg

Arguments:


Return:

    S_OK

--*/
{
    TraceFunctEnterEx( (LPARAM)this, "CNntpFSDriver::SetMessageContext()" );

    HRESULT hr = S_OK;
    BYTE    pbData[(MAX_PATH * 2) + sizeof(CLSID) + sizeof(void *)*2];
    DWORD   dwLen = 0;
    DWORD_PTR dwThisPointer = (DWORD_PTR)this;

    //  Use the standard way to putting the unique ID
    //  Just to makesure we have the unique ID, use GUID+this+newsgroup+handle
    MoveMemory(pbData, &CLSID_NntpFSDriver, sizeof(CLSID));
    MoveMemory(pbData+sizeof(CLSID), &dwThisPointer, sizeof(DWORD_PTR));
    MoveMemory(pbData+sizeof(CLSID)+sizeof(DWORD_PTR), &pfioContext, sizeof(PFIO_CONTEXT));
    MoveMemory(pbData+sizeof(CLSID)+sizeof(DWORD_PTR)+sizeof(PFIO_CONTEXT), szFileName, cbFileName);
    dwLen = sizeof(CLSID)+cbFileName+sizeof(PFIO_CONTEXT)+sizeof(DWORD_PTR);
    hr = pMsg->PutProperty( IMMPID_MPV_STORE_DRIVER_HANDLE, dwLen, pbData );
    if (FAILED(hr))
    {
        ErrorTrace((DWORD_PTR)this, "PutProperty on IMMPID_MPV_STORE_DRIVER_HANDLE failed %x\n", hr);
    }

    return hr;

} // CNntpFSDriver::SetMessageContext


HRESULT
CNntpFSDriver::GetMessageContext(
    IMailMsgProperties* pMsg,
    LPSTR               szFileName,
    BOOL *              pfIsMyMessage,
    PFIO_CONTEXT        *ppfioContext
    )
/*++

Description:

    Check this message to see if this is our message

Arguments:


Return:

    S_OK

--*/
{
    TraceFunctEnterEx( (LPARAM)this, "CNntpFSDriver::GetMessageContext()" );

    HRESULT hr = S_OK;
    BYTE    pbData[(MAX_PATH * 2) + sizeof(CLSID) + sizeof(DWORD)*2];
    DWORD   dwLen = sizeof(pbData);
    DWORD   dwLenOut = 0;
    DWORD_PTR dwThisPointer = 0;
    DWORD   dwHandle = 0;

    hr = pMsg->GetProperty( IMMPID_MPV_STORE_DRIVER_HANDLE, dwLen, &dwLenOut, pbData);
    if (FAILED(hr))
    {
        ErrorTrace((DWORD_PTR)this, "Failed on GetProperty IMMPID_MPV_STORE_DRIVER_HANDLE %x\n", hr);
        goto Exit;
    }

    //  We have this in the context info, use GUID+this+handle+newsgroup
    CopyMemory(&dwThisPointer, pbData+sizeof(CLSID), sizeof(DWORD_PTR));

    if ((DWORD_PTR)this == dwThisPointer)
        *pfIsMyMessage = TRUE;
    else
        *pfIsMyMessage = FALSE;

    //  Get the fio context
    CopyMemory(ppfioContext, pbData+sizeof(CLSID)+sizeof(DWORD_PTR), sizeof(PFIO_CONTEXT));

    //
    // Now get file name property if this is my message
    //
    if ( szFileName ) {
        dwLen = dwLenOut - sizeof(CLSID) - sizeof(DWORD_PTR) - sizeof( PFIO_CONTEXT );
        if (*pfIsMyMessage) {
        	_ASSERT( dwLen > 0 && dwLen <= MAX_PATH );
        	CopyMemory( szFileName,
                    pbData+sizeof(CLSID)+sizeof(DWORD_PTR)+sizeof(PFIO_CONTEXT),
                    dwLen );
        }
        *(szFileName + dwLen ) = 0;
    }

Exit:

    return hr;

} // CNntpFSDriver::GetMessageContext


HRESULT
CNntpFSDriver::Group2Record(	IN VAR_PROP_RECORD& vpRecord,
								IN INNTPPropertyBag *pPropBag )
/*++
Routine description:

	Convert the properties that the FS driver cares about
	from property bag into the flatfile record, in preparation
	for storing them into the flat file.  These properties
	are all variable lengthed, such as "pretty name", "description",
	etc.  FS driver doesn't care about the fixed lengthed properties,
	because all those properties can be dynamically figured out
	during a rebuild.

Arguments:

	IN VAR_PROP_RECORD& vpRecord - Destination to fill in properties;
	IN INntpPropertyBag *pPropBag - Group's property bag.

Return value:

	None.
--*/
{
	TraceFunctEnter( "CNntpFSDriver::Group2Record" );
	_ASSERT( pPropBag );

	HRESULT hr;
	DWORD	dwLen;
	SHORT	sLenAvail = MaxRecordSize;
	PBYTE	ptr;
	DWORD	dwOffset = 0;

	// Group Id
	hr = pPropBag->GetDWord(    NEWSGRP_PROP_GROUPID,
	                            &vpRecord.dwGroupId );
	if ( FAILED( hr ) ) {
	    ErrorTrace( 0, "Get Group id failed %x", hr );
	    goto Exit;
	}

	// Create time
	hr = pPropBag->GetDWord(    NEWSGRP_PROP_DATELOW,
	                            &vpRecord.ftCreateTime.dwLowDateTime );
	if ( FAILED( hr ) ) {
	    ErrorTrace( 0, "Get low date failed %x", hr);
	    goto Exit;
	}

	hr = pPropBag->GetDWord(    NEWSGRP_PROP_DATEHIGH,
	                            &vpRecord.ftCreateTime.dwHighDateTime );
	if ( FAILED( hr ) ) {
	    ErrorTrace( 0, "Get high date failed %x", hr );
	    goto Exit;
	}

	// Group name
	dwLen = sLenAvail;
	ptr = vpRecord.pData;
	hr = pPropBag->GetBLOB(		NEWSGRP_PROP_NAME,
								ptr,
								&dwLen );
	if ( FAILED( hr ) ) {	// this is fatal
		ErrorTrace( 0, "Get group name failed %x", hr );
		goto Exit;
	}

	sLenAvail -= USHORT(dwLen);
	_ASSERT( sLenAvail >= 0 );
	_ASSERT( 0 != *ptr );	// group name should exist

	// Fix up offsets
	vpRecord.iGroupNameOffset = 0;
	vpRecord.cbGroupNameLen = USHORT(dwLen);
	dwOffset = vpRecord.iGroupNameOffset + vpRecord.cbGroupNameLen;

	// Native name
	dwLen = sLenAvail;
	ptr = vpRecord.pData + dwOffset;
	hr = pPropBag->GetBLOB(		NEWSGRP_PROP_NATIVENAME,
								ptr,
								&dwLen );
	if ( FAILED( hr ) ) {
		ErrorTrace( 0, "Get group native name failed %x", hr );
		goto Exit;
	}

	sLenAvail -= USHORT(dwLen);
	_ASSERT( sLenAvail >= 0 );
	_ASSERT( 0 != *ptr );	// at least it should be the same as
							// group name
	_ASSERT( dwLen == vpRecord.cbGroupNameLen );

	// Fix up offsets
	if ( strncmp( LPCSTR(vpRecord.pData + vpRecord.iGroupNameOffset),
					LPCSTR(ptr), dwLen ) == 0 ) {	// share name
		vpRecord.iNativeNameOffset = vpRecord.iGroupNameOffset;
		vpRecord.cbNativeNameLen = vpRecord.cbGroupNameLen;
	} else {
		vpRecord.iNativeNameOffset = USHORT(dwOffset);
		vpRecord.cbNativeNameLen = vpRecord.cbGroupNameLen;
		dwOffset = vpRecord.iNativeNameOffset + vpRecord.cbNativeNameLen;
	}

	// Pretty name
	dwLen = sLenAvail;
	ptr =  vpRecord.pData + dwOffset;
	hr = pPropBag->GetBLOB(		NEWSGRP_PROP_PRETTYNAME,
								ptr,
								&dwLen );
	if ( FAILED( hr ) ) {
		ErrorTrace( 0, "Get pretty name failed %x", hr );
		goto Exit;
	}

	sLenAvail -= (USHORT)dwLen;
	_ASSERT( sLenAvail >= 0 );

	// Fix up offsets
	if ( 0 == *ptr ) {	// have no pretty name
		vpRecord.iPrettyNameOffset = OffsetNone;
		vpRecord.cbPrettyNameLen = 0;
	} else {
		vpRecord.iPrettyNameOffset = USHORT(dwOffset);
		vpRecord.cbPrettyNameLen = USHORT(dwLen);
		dwOffset = vpRecord.iPrettyNameOffset + vpRecord.cbPrettyNameLen;
	}

	// Description
	dwLen = sLenAvail;
	ptr = vpRecord.pData + dwOffset;
	hr = pPropBag->GetBLOB(	NEWSGRP_PROP_DESC,
							ptr,
							&dwLen );
	if ( FAILED( hr )  ) {
		ErrorTrace( 0, "Get description failed %x", hr );
		goto Exit;
	}

	sLenAvail -= USHORT(dwLen);
	_ASSERT( sLenAvail >= 0 );

	// Fix up offsets
	if ( 0 == *ptr ) {
		vpRecord.iDescOffset = OffsetNone;
		vpRecord.cbDescLen = 0;
	} else {
		vpRecord.iDescOffset = USHORT(dwOffset);
		vpRecord.cbDescLen = USHORT(dwLen);
		dwOffset = vpRecord.iDescOffset + vpRecord.cbDescLen;
	}

	// Moderator
	dwLen = sLenAvail;
	ptr = vpRecord.pData + dwOffset;
	hr = pPropBag->GetBLOB( NEWSGRP_PROP_MODERATOR,
							ptr,
							&dwLen );
	if ( FAILED( hr ) ) {
		ErrorTrace( 0, "Get moderator failed %x", hr );
		goto Exit;
	}

	sLenAvail -= USHORT(dwLen );
	_ASSERT( sLenAvail >= 0 );

	// Fix up offsets
	if ( 0 == *ptr ) {
		vpRecord.iModeratorOffset = OffsetNone;
		vpRecord.cbModeratorLen = 0;
	} else {
		vpRecord.iModeratorOffset = USHORT( dwOffset );
		vpRecord.cbModeratorLen = USHORT( dwLen );
		dwOffset = vpRecord.iModeratorOffset + vpRecord.cbModeratorLen;
	}

Exit:

	TraceFunctLeave();
	return hr;
}

VOID
CNntpFSDriver::Path2GroupName(  LPSTR   szGroupName,
                                LPSTR   szFullPath )
/*++
Routine description:

    Convert the path into group name.

Arguments:

    LPSTR   szGroupName - Buffer for newsgroup name ( assume >= MAX_NEWSGROUP_NAME )
    LPSTR   szFullPath  - Full path of the group directory

    The buffer size for group name should be at least MAX_NEWSGROUP_NAME+1 

Return value:

    None.
--*/
{
    TraceFunctEnter( "CNntpFSDriver::Path2GroupName" );
    _ASSERT( szGroupName );
    _ASSERT( szFullPath );

    LPSTR   lpstrStart = NULL;
    LPSTR   lpstrAppend = NULL;

    // Skip the vroot part
    _ASSERT( strlen( szFullPath ) >= strlen( m_szFSDir ) );
    lpstrStart = szFullPath + strlen( m_szFSDir );

    // If it's pointing to '\\', skip it too
    if ( *lpstrStart == '\\' ) lpstrStart++;

    // Copy the vroot prefix to desitnation buffer first
    _ASSERT( strlen( m_szVrootPrefix ) <= MAX_NEWSGROUP_NAME );
    lstrcpyn( szGroupName, m_szVrootPrefix, MAX_NEWSGROUP_NAME );

    // Append the rest part from physical path, replacing \ with .
    _ASSERT( strlen( m_szVrootPrefix ) + strlen( szFullPath ) - strlen( m_szFSDir ) < MAX_NEWSGROUP_NAME );
    lpstrAppend = szGroupName + strlen( szGroupName );
    if ( lpstrAppend > szGroupName && *lpstrStart && (lpstrAppend < szGroupName + MAX_NEWSGROUP_NAME) ) {
        //if ( *(lpstrAppend-1) == '\\' ) *(lpstrAppend-1) = '.';
        /*else*/ *(lpstrAppend++) = '.';
    }
    while( *lpstrStart  && (lpstrAppend < szGroupName + MAX_NEWSGROUP_NAME) ) {
        *(lpstrAppend++) = ( *lpstrStart == '\\' ? '.' : *lpstrStart );
        lpstrStart++;
    }

    // Append last null
    *lpstrAppend = 0;

    // Done, validate again
    _ASSERT( strlen( szGroupName ) <= MAX_NEWSGROUP_NAME );
}

HRESULT
CNntpFSDriver::GroupName2Path(	LPSTR	szGroupName,
								LPSTR	szFullPath,
								unsigned cbBuffer
								)
/*++
Routine description:

	Convert the news group name into the FS full path.

Arguments:

	LPSTR	szGroupName	- The news group name
	LPSTR	szFullPath - The FS full path ( assume buffer
							length MAX_PATH )

Return value:

	HRESULT.
--*/
{
	TraceFunctEnter( "CNntpFSDriver::GroupName2Path" );
	_ASSERT( szGroupName );
	_ASSERT( lstrlen( szGroupName ) <= MAX_GROUPNAME );
	_ASSERT( szFullPath );
	_ASSERT( lstrlen( szGroupName ) >= lstrlen( m_szVrootPrefix ) );

	LPSTR	pch, pch2;

	// Chop off group name's prefix based on our vroot prefix
	pch = szGroupName + lstrlen( m_szVrootPrefix );

	// If it's pointing to ".", skip it
	if ( '.' == *pch ) pch++;
	_ASSERT( pch - szGroupName <= lstrlen( szGroupName ) );

	// Put vroot path into return buffer first
	_ASSERT( lstrlen( m_szFSDir ) <= MAX_PATH );
	if (strlen(m_szFSDir)+1+strlen(pch)+1 > cbBuffer) return HRESULT_FROM_WIN32( ERROR_INSUFFICIENT_BUFFER );
	lstrcpy( szFullPath, m_szFSDir);

	// If there is no trailing '\\', add it
	pch2 = szFullPath + lstrlen( m_szFSDir );
	if ( pch2 == szFullPath || *(pch2-1) != '\\' ) {
		*(pch2++) = '\\';
	}

	// We should have enough space for the rest stuff
	_ASSERT( ( pch2 - szFullPath ) +
				(lstrlen( szGroupName ) - (pch - szGroupName)) <= MAX_PATH );

	// Copy the rest stuff, changing '.' to '\\'
	while ( *pch != 0 ) {
		if ( *pch == '.' ) *pch2 = '\\';
		else *pch2 = *pch;
		pch++, pch2++;
	}

	*pch2 = 0;

	_ASSERT( lstrlen( szFullPath ) <= MAX_PATH );
	TraceFunctLeave();
	return S_OK;
}

HRESULT
CNntpFSDriver::LoadGroupOffsets( INntpComplete *pComplete )
/*++
Routine description:

	Load group offset into the property file to the news tree

Arguments:

	None.

Return value:

	S_OK - Success
--*/
{
	TraceFunctEnter( "CNntpFSDriver::LoadGroupOffsets" );

	VAR_PROP_RECORD vpRec;
	DWORD			dwOffset;
	HRESULT			hr = S_OK;
	DWORD			dwSize;
	LPSTR			lpstrGroupName;
	INntpDriver 	*pDriver = NULL;
	INNTPPropertyBag *pPropBag = NULL;

	_ASSERT( m_pffPropFile );

	m_PropFileLock.ShareLock();

	//
	// check if the vpp file is in good shape
	//
	if ( !m_pffPropFile->FileInGoodShape() ) {
	    ErrorTrace( 0, "Vpp file corrupted" );
	    m_PropFileLock.ShareUnlock();
	    hr = HresultFromWin32TakeDefault( ERROR_FILE_CORRUPT );
	    return hr;
	}

	dwSize = sizeof( vpRec );
	hr = m_pffPropFile->GetFirstRecord( PBYTE(&vpRec), &dwSize, &dwOffset );
	m_PropFileLock.ShareUnlock();
	while ( S_OK == hr ) {
	    _ASSERT( RECORD_ACTUAL_LENGTH( vpRec ) < 0x10000 ); // our max record length
		_ASSERT( dwSize == RECORD_ACTUAL_LENGTH( vpRec ) );
		_ASSERT( dwOffset != 0xffffffff );
		lpstrGroupName = LPSTR(vpRec.pData + vpRec.iGroupNameOffset);
		_ASSERT( vpRec.cbGroupNameLen <= MAX_GROUPNAME );
		*(lpstrGroupName+vpRec.cbGroupNameLen) = 0;

		// check if I own this group
		hr = m_pINewsTree->LookupVRoot( lpstrGroupName, &pDriver );
		if ( FAILED ( hr ) || pDriver != (INntpDriver*)this ) {
			// skip this group
			// DebugTrace(0, "I don't own this group %s", lpstrGroupName );
			goto NextIteration;
		}

		// I own this group, i need to load offset property
		hr = m_pINewsTree->FindOrCreateGroupByName(	lpstrGroupName,
													FALSE,
													&pPropBag,
													pComplete,
													0xffffffff, // fake group id
													FALSE );    // I don't set groupid
		if ( FAILED( hr ) ) {
			DebugTrace( 0, "Can not find the group that I own %x" , hr );
			goto NextIteration;  // should fail it ?
		}

		// Set the offset
		hr = pPropBag->PutDWord( NEWSGRP_PROP_FSOFFSET, dwOffset );
		if ( FAILED( hr ) ) {
			ErrorTrace( 0, "Put offset failed %x", hr );
			goto Exit;
		}

		pComplete->ReleaseBag( pPropBag );
		pPropBag = NULL;

NextIteration:

		dwSize = sizeof( vpRec );
		m_PropFileLock.ShareLock();
		hr = m_pffPropFile->GetNextRecord( PBYTE(&vpRec), &dwSize, &dwOffset );
		m_PropFileLock.ShareUnlock();
	}

Exit:

	if ( NULL != pPropBag ) {
		pComplete->ReleaseBag( pPropBag );
		pPropBag = NULL;
	}

	TraceFunctLeave();
	return hr;
}



HRESULT
CNntpFSDriver::CreateGroupsInVpp( INntpComplete *pComplete )
/*++
Routine description:

	Enumerating the news tree and check group properties
	against hash table

Arguments:

	None.

Return value:

	S_OK	- Success
--*/
{
	TraceFunctEnter( "CNntpFSDriver::CreateGroupsInVpp" );

	HRESULT hr;
	INewsTreeIterator *piter = NULL;
	INNTPPropertyBag *pPropBag = NULL;
	DWORD   dwOffset;
	DWORD   dwLen;
	CHAR    szGroupName[MAX_GROUPNAME+1];
	INntpDriver *pDriver = NULL;

	// Get the newstree iterator
	hr = m_pINewsTree->GetIterator( &piter );
	if ( FAILED( hr ) ) {
		ErrorTrace( 0, "Get news tree iterator failed %x", hr );
		goto Exit;
	}

	// Enumerate all the groups
	_ASSERT( piter );
	while( !(piter->IsEnd()) ) {

		hr = piter->Current( &pPropBag, pComplete );
		if ( FAILED( hr ) ) {
			ErrorTrace( 0, "Enumerate group failed %x", hr );
			goto Exit;
		}
		_ASSERT( pPropBag );

		//
		// Don't create groups that don't belong to me
		//
		dwLen = MAX_GROUPNAME;
	    hr = pPropBag->GetBLOB( NEWSGRP_PROP_NAME, (PBYTE)szGroupName, &dwLen );
	    if ( FAILED( hr ) ) {
		    ErrorTrace( 0, "Get group name failed %x", hr );
		    goto Exit;
	    }
	    _ASSERT( dwLen <= MAX_GROUPNAME && dwLen > 0);

	    hr = m_pINewsTree->LookupVRoot( szGroupName, &pDriver );
	    if ( FAILED( hr ) ) {
		    ErrorTrace( 0, "Vroot lookup failed %x", hr );
		    goto Exit;
	    }

        //
	    // check if this is me ?
	    //
	    if ( (INntpDriver*)this != pDriver ) {
		    hr = S_OK;
		    DebugTrace( 0, "This group doesn't belong to me" );
		    goto Next;
	    }

		hr = CreateGroupInVpp( pPropBag, dwOffset );
		if ( FAILED( hr ) ) {
			DebugTrace( 0, "Check group property failed %x" , hr );
			goto Exit;
		}

Next:
		_ASSERT( pPropBag );
		pComplete->ReleaseBag( pPropBag );
		pPropBag = NULL;

		piter->Next();
	}

Exit:


	if ( pPropBag ) {
		pComplete->ReleaseBag( pPropBag );
		pPropBag = NULL;
	}

	if ( piter ) {
		piter->Release();
		piter = NULL;
	}

	TraceFunctLeave();
	return hr;
}

HRESULT
CNntpFSDriver::AllocInternal(	IN IMailMsgProperties *pMsg,
								OUT PFIO_CONTEXT *ppFIOContentFile,
								IN LPSTR    szFileName,
								IN BOOL	bSetSerial,
								IN BOOL fPrimaryStore,
								HANDLE  hToken )
/*++
Routine description:

	Allocate property stream and content file for a recipient (
	with async completion ).

Arguments:

	IN IMailMsgProperties *pMsg - Specifies the message.  This may
									not be NULL ( in smtp case, it
									may be NULL ).  But we want to
									have primary group information
									at this point before opening a
									destination file handle.  By
									doing that, we even don't need to
									"MoveFile".
	OUT HANDLE *phContentFile - To return file handle opened
	IN BOOL bSetSerial - Whether the serial number should be set
	HANDLE  hToken - Client access token
Return value:

	S_OK - Success, the operation completed synchronously.
	MAILMSG_S_PENDING - Success, but will be completed asynchronously,
						this will never happen to the NTFS driver
--*/
{
	TraceFunctEnter( "CNntpFSDriver::AllocInternal" );
	_ASSERT( pMsg );
	_ASSERT( ppFIOContentFile );
	// I don't care about other parameters

	HRESULT hr = S_OK;
	DWORD	dwBLOBSize;
	DWORD	dwLen;
	DWORD	dwArtId;
	INNTPPropertyBag* pPropPrime;
	CHAR	szGroupName[MAX_GROUPNAME+1];
	CHAR	szFullPath[MAX_PATH+1];
	HANDLE  hFile;

	hr = pMsg->GetProperty(	IMSG_PRIMARY_GROUP,
							sizeof( INNTPPropertyBag* ),
							&dwBLOBSize,
							(PBYTE)&pPropPrime );
	if ( S_OK != hr ) {
		ErrorTrace( 0, "Property %d doesn't exist", IMSG_PRIMARY_GROUP );
		hr = E_INVALIDARG;
		goto Exit;
	}

	// Get group name
	dwLen = MAX_GROUPNAME;
	hr = pPropPrime->GetBLOB(	NEWSGRP_PROP_NAME, (UCHAR*)szGroupName, &dwLen);
	if ( FAILED( hr )) {
		ErrorTrace( 0, "Failed to get group name %x", hr );
		goto Exit;
	}
	_ASSERT( dwLen > 0 );

	// Get article id from pMsg object
	hr = pMsg->GetDWORD(	IMSG_PRIMARY_ARTID, &dwArtId );
	if ( S_OK != hr ) {
		ErrorTrace( 0, "Property %d doesn't exist", IMSG_PRIMARY_ARTID );
		hr = E_INVALIDARG;
		goto Exit;
	}

	// Map the group name and article id to file path
	dwLen = MAX_PATH;
	hr = ObtainFullPathOfArticleFile(	szGroupName,
										dwArtId,
										szFullPath,
										dwLen );
	if ( FAILED( hr ) ) {
		ErrorTrace( 0, "Failed to obtain article full path %x", hr );
		goto Exit;
	}

	// Open the file
	hFile = INVALID_HANDLE_VALUE;
	hFile = CreateFile(	szFullPath,
						GENERIC_READ | GENERIC_WRITE,
						FILE_SHARE_READ,
						NULL,
						CREATE_NEW,
						FILE_FLAG_OVERLAPPED |
						FILE_FLAG_SEQUENTIAL_SCAN,
						NULL );

	if ( INVALID_HANDLE_VALUE == hFile ) {
		ErrorTrace( 0, "Open destination file failed %d",
					GetLastError() );
		hr = HresultFromWin32TakeDefault( ERROR_ALREADY_EXISTS );
		goto Exit;
	}

	//if ( m_bUNC && hToken ) RevertToSelf();

	//
	// Now associate the file handle with a FIO_CONTEXT and
	// insert it into file handle cache
	//
	if ( *ppFIOContentFile = AssociateFileEx( hFile,
                                              TRUE,     //  fStoreWithDots
                                              TRUE ) )  //  fStoreWithTerminatingDots
    {
        //
        // But I'd like to copy the file name out, so that somebody else
        // can do an insertfile for us
        //
        _ASSERT( strlen( szFullPath ) <= MAX_PATH );
        strcpy( szFileName, szFullPath );

    } else {    // Associate file failed

	    hr = HresultFromWin32TakeDefault( ERROR_INVALID_HANDLE );
        ErrorTrace( 0, "AssociateFile failed with %x", hr );
        _VERIFY( CloseHandle( hFile ) );
        goto Exit;
    }

    if ( fPrimaryStore ) {

    	//
	    // Stick my serial number in the message object to mark
    	// that I am the owner of the file handle, if necessary
	    //
    	if ( bSetSerial ) {
            hr = SetMessageContext( pMsg, szFullPath, strlen( szFullPath ), *ppFIOContentFile );
            if (FAILED(hr))
            {
                DebugTrace((DWORD_PTR)this, "Failed to SetMessageContext %x\n", hr);
                goto Exit;
            }
	    }
	}

	hr = S_OK;	// it could be S_FALSE, which is OK

Exit:

	TraceFunctLeave();
	return hr;
}

HRESULT
CNntpFSDriver::DeleteInternal(	IN INNTPPropertyBag *pPropBag,
								IN ARTICLEID	idArt )
/*++
Routine description:

	Delete an article, physically.

Arguments:

	IN IUnknown *punkPropBag - Group's property bag
	IN ARTICLEID idArt - Article id to delete
--*/
{
	TraceFunctEnter( "CNntpFSDriver::DeleteInternal" );
	_ASSERT( pPropBag );

	HRESULT 			hr;
	DWORD				dwLen;
	CHAR				szGroupName[MAX_GROUPNAME+1];
	CHAR				szFullPath[MAX_PATH+1];


	// Get group name
	dwLen = MAX_GROUPNAME;
	hr = pPropBag->GetBLOB(	NEWSGRP_PROP_NAME, (UCHAR*)szGroupName, &dwLen);
	if ( FAILED( hr )) {
		ErrorTrace( 0, "Failed to get group name %x", hr );
		goto Exit;
	}
	_ASSERT( dwLen > 0 );

	// Make up the file name based on article id
	dwLen = MAX_PATH;
	hr = ObtainFullPathOfArticleFile(	szGroupName,
										idArt,
										szFullPath,
										dwLen );
	if ( FAILED( hr ) ) {
		ErrorTrace( 0, "Failed to obtain article full path %x", hr );
		goto Exit;
	}

	CacheRemoveFiles( szFullPath, FALSE );

	// Delete the file
	if ( !DeleteFile( szFullPath ) ) {
		ErrorTrace( 0, "Delete file failed %d", GetLastError() );
	    hr = HresultFromWin32TakeDefault( ERROR_FILE_NOT_FOUND );
		goto Exit;
	}

Exit:

	TraceFunctLeave();
	return hr;
}

HRESULT STDMETHODCALLTYPE
CNntpFSDriver::GetXoverCacheDirectory(
			IN	INNTPPropertyBag*	pPropBag,
			OUT	CHAR*	pBuffer,
			IN	DWORD	cbIn,
			OUT	DWORD	*pcbOut,
			OUT	BOOL*	fFlatDir
			) 	{

	TraceFunctEnter( "CNntpFSDriver::GetXoverCacheDirectory" ) ;
	CHAR		szGroupName[MAX_GROUPNAME];
	DWORD	dwLen = sizeof( szGroupName ) ;
	BOOL	bUsageIncreased = FALSE;

	if( pPropBag == 0 ||
		pBuffer == 0 ||
		pcbOut == 0 )	 {
		if( pPropBag )	pPropBag->Release() ;
		return	E_INVALIDARG ;
	}

	HRESULT hr = S_OK ;
	*fFlatDir = FALSE ;
	
	// Share lock for usage count
	m_TermLock.ShareLock();
	if ( DriverUp != m_Status  ) {
		ErrorTrace( 0, "Request before initialization" );
		hr = NNTP_E_DRIVER_NOT_INITIALIZED;
		m_TermLock.ShareUnlock();
		goto Exit;
	}

	// Increment the usage count
	InterlockedIncrement( &m_cUsages );
	bUsageIncreased = TRUE;
	m_TermLock.ShareUnlock();

	hr = pPropBag->GetBLOB( NEWSGRP_PROP_NAME, (UCHAR*)szGroupName, &dwLen);
	if ( FAILED( hr ) ) {
		ErrorTrace( 0, "Get group name failed %x" , hr );
		goto Exit;
	}
	_ASSERT( dwLen > 0 );

    // Get a rough length and make sure our buffer is big enough
	*pcbOut = dwLen + strlen( m_szFSDir ) + 1 ;
	if( *pcbOut > cbIn )	{
		hr = TYPE_E_BUFFERTOOSMALL ;
		goto Exit ;	}

	hr = GroupName2Path( szGroupName,  pBuffer, cbIn ) ;
	if ( FAILED( hr ) ) {
	    hr = TYPE_E_BUFFERTOOSMALL ; 
	    ErrorTrace( 0, "insufficient buffer for path %x", hr );
	    goto Exit;
	}	

    //  Here we get the exact length and return back to caller.  No ASSERT.
    *pcbOut = strlen(pBuffer)+1;
	//_ASSERT( strlen( pBuffer )+1 == *pcbOut ) ;

	hr = S_OK ;

Exit:
	if( pPropBag )
		pPropBag->Release() ;
	if ( bUsageIncreased )	InterlockedDecrement( &m_cUsages );
	return	hr ;
}



HRESULT
CNntpFSDriver::GetXoverInternal(    IN INNTPPropertyBag *pPropBag,
		                            IN ARTICLEID    idMinArticle,
        		                    IN ARTICLEID    idMaxArticle,
                		            OUT ARTICLEID   *pidNextArticle,
                		            IN LPSTR		szHeader,
                        		    OUT LPSTR       pcBuffer,
		                            IN DWORD        cbin,
        		                    OUT DWORD       *pcbout,
        		                    IN BOOL 		bIsXOver,
        		                    HANDLE          hToken,
        		                    INntpComplete   *pComplete )
/*++
Routine Description:

    Get Xover information from the store driver.

Arguments:

    IN INNTPPropertyBag *pPropBag - Interface pointer to the news group prop bag
    IN ARTICLEID idMinArticle   - The low range of article id to be retrieved from
    IN ARTICLEID idMaxArticle   - The high range of article id to be retrieved from
    OUT ARTICLEID *pidNextArticle - Buffer for actual last article id retrieved,
                                    0 if no article retrieved
    OUT LPSTR pcBuffer          - Header info retrieved
    IN DWORD cbin               - Size of pcBuffer
    OUT DWORD *pcbout           - Actual bytes written into pcBuffer
    IN BOOL bIsXOver 			- Is it xover or xhdr ?
    HANDLE  hToken              - Client's access token

Return value:

    S_OK                    - Succeeded.
    NNTP_E_DRIVER_NOT_INITIALIZED - Driver not initialized
    S_FALSE   - The buffer provided is too small, but content still filled
--*/
{
	TraceFunctEnter( "CNntpFSDriver::GetXover" );
	_ASSERT( pPropBag );
	_ASSERT( idMinArticle <= idMaxArticle );
	_ASSERT( pidNextArticle );
	_ASSERT( cbin > 0 );
	_ASSERT( pcbout );

	DWORD 				i;
	DWORD				cbCount = 0;
	INNTPPropertyBag	*pPrimary = NULL;
	DWORD				idPrimary = 0xffffffff;
	INNTPPropertyBag    *pPrimaryNext = NULL;
	DWORD               idPrimaryNext = 0xffffffff;
	HRESULT				hr = S_OK;
	DWORD				idArt;
	DWORD				dwLen;
	DWORD				dwActualLen;
	CArticleCore		*pArticle = NULL;
	CNntpReturn     	nntpReturn;
	LPSTR				lpstrStart;
	BOOL                bImpersonated = FALSE;
	INntpDriver         *pDriver = NULL;
	BOOL                fSuccess = FALSE;

	//
    // Create allocator for storing parsed header values
    //
    const DWORD cchMaxBuffer = 8 * 1024; // this should be enough
    									 // for normal cases, if
    									 // it's not enough, CAllocator
    									 // will use "new"
    CHAR        pchBuffer[cchMaxBuffer];
    CAllocator  allocator(pchBuffer, cchMaxBuffer);

    //
    // Buffer for get xover from article object
    //
    CHAR        pchXoverBuf[cchMaxXover+1];
    CPCString   pcXOver( pchXoverBuf, cchMaxXover );

    CHAR		szGroupName[MAX_GROUPNAME];
    CHAR		szGroupName2[MAX_GROUPNAME];
    CHAR		szFullPath[MAX_PATH+1];
    LPSTR		lpstrGroupName;
    LPSTR		lpstrEntry = NULL;

    const 		cMaxNumber = 20;
    CHAR		szNumBuf[cMaxNumber+1];

    // Completion object for query hash table
    CDriverSyncComplete   scCompletion;

    BOOL        bCompletePending = FALSE;   // Are there any hash table lookup
                                            // opertions pending ?

   	// Get group name for the property bag passed in
	dwLen = MAX_GROUPNAME;
	hr = pPropBag->GetBLOB( NEWSGRP_PROP_NAME, (UCHAR*)szGroupName, &dwLen);
	if ( FAILED( hr ) ) {
		ErrorTrace( 0, "Get group name failed %x", hr);
		goto Exit;
	}
	_ASSERT( dwLen > 0 );

	// We issue a hash table look up first, to better use
	// the async completion of hash table look up
	pPrimaryNext = NULL;
	scCompletion.AddRef();    // for hash table's release
	scCompletion.AddRef();    // for my wait
	_ASSERT( scCompletion.GetRef() == 2 );
	m_pNntpServer->FindPrimaryArticle(	pPropBag,
										idMinArticle,
										&pPrimaryNext,
										&idPrimaryNext,
										TRUE,
										&scCompletion,
										pComplete );
	scCompletion.WaitForCompletion();
	// Now we should have no reference
	_ASSERT( scCompletion.GetRef() == 0 );
	hr = scCompletion.GetResult();

	// Initialize *pidNextArticle
	*pidNextArticle = idMinArticle;

	// Following operations involve file system, we need to
	// impersonate here, if necessary
	if ( m_bUNC ) {
	    if ( !ImpersonateLoggedOnUser( hToken ) ) {
	        hr = HresultFromWin32TakeDefault( ERROR_ACCESS_DENIED );
	        ErrorTrace( 0, "Impersonation failed %x", hr );
	        goto Exit;
	    }
	    bImpersonated = TRUE;
    }

	// Loop thru the article id's
	for ( i = idMinArticle ; i <= idMaxArticle; i++ ) {

	    // Save off the next to current
	    pPrimary = pPrimaryNext;
	    idPrimary = idPrimaryNext;
	    pPrimaryNext = NULL;
	    idPrimaryNext = 0xffffffff;

        // If we still have next look up, issue it now
        if ( i + 1 <= idMaxArticle ) {
    		pPrimaryNext = NULL;
	    	scCompletion.AddRef();
	    	_ASSERT( scCompletion.GetRef() == 1 );
	    	scCompletion.AddRef();
	    	_ASSERT( scCompletion.GetRef() == 2 );
	    	scCompletion.Reset();
		    m_pNntpServer->FindPrimaryArticle(	pPropBag,
			    								i + 1,
				    							&pPrimaryNext,
					    						&idPrimaryNext,
												TRUE,
						    					&scCompletion,
						    					pComplete );
		    bCompletePending = TRUE;
		}

		if ( FAILED( hr ) ) { // this is the current hr
            if ( HRESULT_FROM_WIN32( ERROR_NOT_FOUND ) == hr ||
                    HRESULT_FROM_WIN32( ERROR_FILE_NOT_FOUND ) == hr ) {
                // should proceed with other articles
                hr = S_OK;
                *pidNextArticle = i + 1;
                goto CompleteNext;
            } else {
                _ASSERT( hr != ERROR_PATH_NOT_FOUND );  // this helps find other
                                                        // error codes
			    ErrorTrace( 0, "Find primary article failed %x", hr);
			    goto Exit;
            }
		}

		_ASSERT( pPrimary );

		// if I've already got the primary, I don't need to get
		// group name, just use the one that I have
		if ( S_OK == hr ) {
			lpstrGroupName = szGroupName;
			idArt = i;
		} else {

			dwLen = MAX_GROUPNAME;
			hr = pPrimary->GetBLOB( NEWSGRP_PROP_NAME, (UCHAR*)szGroupName2, &dwLen);
			if ( FAILED( hr ) ) {
				ErrorTrace( 0, "Get group name failed %x" , hr );
				goto Exit;
			}
			_ASSERT( dwLen > 0 );

            // now the primary group will always have a copy of the article
			// This could be a group in other store ( vroot ), if so, I should use
		    // the local copy
		    _ASSERT( m_pINewsTree );
		    hr = m_pINewsTree->LookupVRoot( szGroupName2, &pDriver );
		    if ( FAILED( hr ) || NULL == pDriver || pDriver != this ) {

		        // for all these cases, I will use the local copy
		        DebugTrace( 0, "Lookup vroot %x", hr );
                lpstrGroupName = szGroupName;
                idArt = i;
            } else {
    			lpstrGroupName = szGroupName2;
	    		idArt = idPrimary;
	        }
		}

		_ASSERT( lpstrGroupName );
		_ASSERT( strlen( lpstrGroupName ) <= MAX_GROUPNAME );

		// Get the group full path
		dwLen = MAX_PATH;
		hr = ObtainFullPathOfArticleFile(	lpstrGroupName,
											idArt,
											szFullPath,
											dwLen );
		if ( FAILED( hr ) ) {
			ErrorTrace( 0, "Obtain full path failed %x" , hr);
			goto Exit;
		}
		_ASSERT( szFullPath);
		_ASSERT( strlen( szFullPath ) <= MAX_PATH );

		// Initialize the article object
		_ASSERT( NULL == pArticle );
		pArticle = new CArticleCore;
		if ( NULL == pArticle ) {
			ErrorTrace(0, "Out of memory" );
			hr = E_OUTOFMEMORY;
			goto Exit;
		}

		if ( ! pArticle->fInit( szFullPath, nntpReturn, &allocator, INVALID_HANDLE_VALUE, 0, TRUE ) ) {
			DebugTrace( 0, "Initialize article object failed %d",
						GetLastError() );

			// But I will still try to loop thru other articles
			*pidNextArticle =i + 1;
            hr = S_OK;
			goto CompleteNext;
		}

		// XOver or XHdr ?
		if ( bIsXOver ) {
            if ( pArticle->fXOver( pcXOver, nntpReturn ) ) {

                // Append xover info into out buffer
                // This is a rough esimate
                if ( cbCount + pcXOver.m_cch > cbin ) { // buffer not enough
                    hr = ( i == idMinArticle ) ?
                            HRESULT_FROM_WIN32( ERROR_INSUFFICIENT_BUFFER ):
                            S_FALSE;
                    DebugTrace(0, "Buffer too small" );
                    goto Exit;
                }

                // Set the article id before the entry
				lpstrStart = pcXOver.m_pch + cMaxNumber;
				_ASSERT( *lpstrStart == '\t' ); // this is what article obj should do
				_ltoa( i, szNumBuf,10 );
				_ASSERT( *szNumBuf );
				dwLen = strlen( szNumBuf );
				_ASSERT( dwLen <= cMaxNumber );
				lpstrStart -= dwLen;
				CopyMemory( lpstrStart, szNumBuf, dwLen );
				dwActualLen = pcXOver.m_cch - ( cMaxNumber - dwLen );
                CopyMemory( pcBuffer + cbCount, lpstrStart, dwActualLen );
                cbCount += dwActualLen;
                *pidNextArticle = i + 1;

                //
                // Clear pcXOver
                //
                pcXOver.m_pch = pchXoverBuf;
                pcXOver.m_cch = cchMaxBuffer;
            } else {

            	DebugTrace( 0, "Get XOver failed %d", GetLastError() );
            	hr = S_OK;
            	*pidNextArticle = i + 1;
            	goto CompleteNext;
            }
        } else {	// get xhdr
            //
            // get header length
            //
            _ASSERT( szHeader );
            _ASSERT( strlen( szHeader ) <= MAX_PATH );
            dwLen = 0;
            pArticle->fGetHeader( szHeader, NULL, 0, dwLen );
            if ( dwLen > 0 ) {

                //
                // Allocate buffer
                //
                lpstrEntry = NULL;
                lpstrEntry = pArticle->pAllocator()->Alloc( dwLen + 1 );
                if ( !lpstrEntry ) {
                    ErrorTrace(0, "Out of memory" );
                    hr = E_OUTOFMEMORY;
                    goto Exit;
                }
                if ( !pArticle->fGetHeader( szHeader, (UCHAR*)lpstrEntry, dwLen + 1, dwLen ) ) {
                    DebugTrace( 0, "Get Xhdr failed %x", GetLastError() );
                    hr = S_OK;
                    *pidNextArticle = i + 1;
                    goto CompleteNext;
                }

                //
                // Append this header info, including the art id
                //
                _ltoa( i, szNumBuf, 10 );
                _ASSERT( *szNumBuf );
                dwActualLen = strlen( szNumBuf );
                _ASSERT( dwActualLen <= cMaxNumber );
                if ( cbCount + dwLen + dwActualLen + 1 > cbin ) { // buffer not enough
                    hr = ( i == idMinArticle ) ?
                        HRESULT_FROM_WIN32( ERROR_INSUFFICIENT_BUFFER ) :
                        S_FALSE;
                    ErrorTrace(0, "Buffer too small" );
                    goto Exit;
                }
                CopyMemory( pcBuffer + cbCount, szNumBuf, dwActualLen );
                cbCount += dwActualLen;
                *(pcBuffer+cbCount++) = ' ';
                CopyMemory( pcBuffer + cbCount, lpstrEntry, dwLen );
                cbCount += dwLen;
                *pidNextArticle = i + 1;

                pArticle->pAllocator()->Free( lpstrEntry );
                lpstrEntry = NULL;
            } else {
                DebugTrace( 0, "Get Xhdr failed %d", GetLastError() );
                hr = S_OK;
                *pidNextArticle = i + 1;
                goto CompleteNext;
            }
        }

CompleteNext:
		// delete the article object
		if( pArticle )
		    delete pArticle;
		pArticle = NULL;

		// Releaes property bag interface
		if ( pPrimary ) {
			pComplete->ReleaseBag( pPrimary );
		}
		pPrimary = NULL;

		// Now if we have next to complete, we should complete it
		if ( i + 1 <= idMaxArticle ) {

		    // We should have said there are pending completions
		    _ASSERT( bCompletePending );
        	scCompletion.WaitForCompletion();

        	// Now we should have one reference
        	_ASSERT( scCompletion.GetRef() == 0 );
        	hr = scCompletion.GetResult();
        	bCompletePending = FALSE;
		}
	}

Exit:	// clean up

    if ( bImpersonated ) RevertToSelf();

	*pcbout = cbCount;

    if ( S_OK == hr && cbCount == 0 ) hr = S_FALSE;

    // If we have completions pending, we must have come here
    // from error path, we should wait for it to complete first
    if ( bCompletePending ) {
        scCompletion.WaitForCompletion();
        _ASSERT( scCompletion.GetRef() == 0 );
    }

	if ( lpstrEntry ) {
		_ASSERT( pArticle );
		pArticle->pAllocator()->Free( lpstrEntry );
	}
	if ( pArticle ) delete pArticle;
	if ( pPrimary ) pComplete->ReleaseBag ( pPrimary );
	if ( pPrimaryNext ) pComplete->ReleaseBag( pPrimaryNext );
	if ( pPropBag ) pComplete->ReleaseBag( pPropBag );

	TraceFunctLeave();

	return hr;
}



HRESULT
CNntpFSDriver::ObtainFullPathOfArticleFile( IN LPSTR        szNewsGroupName,
                                            IN DWORD        dwArticleId,
                                            OUT LPSTR       pchBuffer,
                                            IN OUT DWORD&   cchBuffer )
/*++
Routine description:

    Given news group name and article id, build a full path file name for
    the article based on the store driver's article naming convention.

Arguments:

    IN LPSTR    szNewsGroupName - The news group name
    IN DWORD    dwArticleId     - The article Id
    OUT LPSTR   pchBuffer       - The buffer to return the full path
    IN DWORD&   cchBuffer       - The size of buffer prepared
    OUT DWORD&  cchBuffer       - On success, the actual length of string returned
                                  On fail because of insufficient buffer, the buffer size needed
                                  On fail because of other reasons, undefined

Return value:

    S_OK                    - Succeeded
    TYPE_E_BUFFERTOOSMALL   - The prepared buffer is too small
--*/
{
    TraceFunctEnter( "CNntpFSDriver::ObtainFullPathOfArticleFile" );
    _ASSERT( szNewsGroupName );
    _ASSERT( strlen( szNewsGroupName ) <= MAX_GROUPNAME );
    _ASSERT( pchBuffer );
    _ASSERT( cchBuffer > 0 );

    DWORD   dwBufferLenNeeded;
    DWORD   dwCount = 0;
    DWORD   dwArtId;
    HRESULT hr = S_OK;

    //
    //  Is the buffer big enough ?
    //  We have three parts for the whole path:
    //  1. Vroot path ( with or without trailing "\\" );
    //  2. The relative path from the group name ( equal length of group name, excluding "\\" );
    //  3. The article file name ( at most 12 )
    //
    if ( cchBuffer <
            ( dwBufferLenNeeded = lstrlen( m_szFSDir ) + lstrlen( szNewsGroupName ) + 14 )) {
        cchBuffer = dwBufferLenNeeded;
        hr = TYPE_E_BUFFERTOOSMALL;
        goto Exit;
    }

	// Convert the group name into FS path
	hr = GroupName2Path( szNewsGroupName, pchBuffer, cchBuffer );
	if ( FAILED( hr ) ) {
	    cchBuffer =  lstrlen( m_szFSDir ) + lstrlen( szNewsGroupName ) + 14 ;
	    hr = TYPE_E_BUFFERTOOSMALL ; 
	    ErrorTrace( 0, "insufficient buffer for path %x", hr );
	    goto Exit;
	}		

    //
    // generate and catenate the file name
    //
    dwCount = strlen( pchBuffer );
    _ASSERT( dwCount > 0 );
    if ( *(pchBuffer + dwCount - 1 ) != '\\' ) {
	    *( pchBuffer + dwCount++ ) = '\\';
	}
    dwArtId = ArticleIdMapper( dwArticleId );
    _itoa( dwArtId, pchBuffer + dwCount, 16 );
    lstrcat( pchBuffer, g_szArticleFileExtension );

    cchBuffer = lstrlen( pchBuffer );
    _ASSERT( cchBuffer <= dwBufferLenNeeded );

Exit:
    TraceFunctLeave();
    return hr;
}

HRESULT
CNntpFSDriver::ReadVrootInfo( IUnknown *punkMetabase )
/*++
Routine Description:

	Read the vroot info from metabase.

Arguments:

	IUnknown *punkMetabase - Unknown interface of metabase object

Return value:

	S_OK - on success, error code otherwise
--*/
{
	TraceFunctEnter( "CNntpFSDriver::ReadVRootInfo" );
	_ASSERT( punkMetabase );

	IMSAdminBase *pMB = NULL;
	HRESULT 	hr = S_OK;
	METADATA_HANDLE hVroot;
	WCHAR	wszBuffer[MAX_PATH+1];
	CHAR    szBuffer[MAX_PATH+1];
	DWORD	dwLen;
	BOOL	bKeyOpened = FALSE;
	DWORD	dwRetry = 5;
	DWORD   err;

	// Query for the right interface to do MB operation
	hr = punkMetabase->QueryInterface( IID_IMSAdminBase, (void**)&pMB );
	if ( FAILED( hr ) ) {
		ErrorTrace( 0, "Query for MB interface failed %x", hr );
		goto Exit;
	}

	// Open the MB key
	_ASSERT( m_wszMBVrootPath );
	_ASSERT( *m_wszMBVrootPath );
	do {
		hr = pMB->OpenKey( 	METADATA_MASTER_ROOT_HANDLE,
							m_wszMBVrootPath,
							METADATA_PERMISSION_READ,
							100,
		 					&hVroot );
	}
	while ( FAILED( hr ) && --dwRetry > 0 );
	if ( FAILED( hr ) ) {
		ErrorTrace( 0, "Open MB key failed %x" , hr );
		goto Exit;
	}

	bKeyOpened = TRUE;

	// Read vroot path
	dwLen = MAX_PATH;
	hr = GetString( pMB, hVroot, MD_FS_VROOT_PATH, wszBuffer, &dwLen );
	if ( FAILED( hr ) ) {
		ErrorTrace( 0, "Vroot path not found in mb %x", hr );
		goto Exit;
	}

	// Check file system type and UNC information
	wszBuffer[sizeof(wszBuffer)/sizeof(wszBuffer[0]) -1] = L'\0';
	CopyUnicodeStringIntoAscii( szBuffer, wszBuffer );
	_ASSERT( strlen( szBuffer ) <= MAX_PATH );

	err = GetFileSystemType(    szBuffer,
	                            &m_dwFSType,
	                            &m_bUNC );
	if ( err != NO_ERROR || m_dwFSType == FS_ERROR ) {
	    hr = HresultFromWin32TakeDefault( ERROR_INVALID_PARAMETER );
	    ErrorTrace( 0, "GetFileSystemType failed %x", hr );
        goto Exit;
    }

    // Make up the vroot dir
	strcpy( m_szFSDir, "\\\\?\\" );
	if ( m_bUNC ) {
	    strcat( m_szFSDir, "UNC" );
	    if (strlen(m_szFSDir) + strlen(szBuffer + 1) + 1 > sizeof(m_szFSDir) )
	        {
	            hr = HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
	            ErrorTrace( 0, "VROOT path exceeds MAX_PATH %x", hr );
                   goto Exit;
	        }
	    strcat( m_szFSDir, szBuffer + 1 ); // strip off one '\\'
	} else { // non UNC
	    if (strlen(m_szFSDir) + strlen(szBuffer) + 1 > sizeof(m_szFSDir) )
	        {
	            hr = HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
	            ErrorTrace( 0, "VROOT path exceeds MAX_PATH %x", hr );
                   goto Exit;
	        }
	    strcat( m_szFSDir, szBuffer );
	}
    _ASSERT( strlen( m_szFSDir ) <= MAX_PATH );

	// Read vroot specific group property file path
	dwLen = MAX_PATH;
	*wszBuffer = 0;
	hr = GetString( pMB, hVroot, MD_FS_PROPERTY_PATH, wszBuffer, &dwLen );
	if ( FAILED( hr ) || *wszBuffer == 0 ) {
		DebugTrace( 0, "Group property file path not found in mb %x", hr);

		// we'll use vroot path as default
		_ASSERT( m_szFSDir );
		_ASSERT( *m_szFSDir );
		lstrcpyn( m_szPropFile, m_szFSDir, sizeof(m_szPropFile) );
	} else {
		//make sure we don't overflow
		wszBuffer[sizeof(wszBuffer)/sizeof(wszBuffer[0]) -1] = L'\0';
		CopyUnicodeStringIntoAscii( m_szPropFile, wszBuffer );
    }

    _ASSERT( *m_szPropFile );

	//
	// Append the group file name
	//
	/*if ( *(m_szPropFile+strlen(m_szPropFile)-1) == ':' ||
	     *(m_szPropFile) == '\\' && *(m_szPropFile+1) == '\\' )*/
    if(strlen(m_szPropFile)+sizeof("\\group") <= sizeof(m_szPropFile))
    {
	strcat( m_szPropFile, "\\group" );
    }
    else
    {
    	hr = HresultFromWin32TakeDefault( ERROR_INVALID_PARAMETER );
    	goto Exit;
    }

    hr = S_OK;

Exit:

	// Close the key
	if ( bKeyOpened ) {
		pMB->CloseKey( hVroot );
	}

	// Release it
	if ( pMB ) {
		pMB->Release();
		pMB = NULL;
	}

	TraceFunctLeave();
	return hr;
}

HANDLE
CNntpFSDriver::CreateFileCallback(  LPSTR   lpstrName,
                                    LPVOID  lpvData,
                                    DWORD*  pdwSize,
                                    DWORD*  pdwSizeHigh )
/*++
Routine Description:

    Function that gets called on a cache miss.

Arguments:

    LPSTR lpstrName - File name
    LPVOID lpvData  - Callback context
    DWORD* pdwSize  - To return file size

Return value:

    File handle
--*/
{
    TraceFunctEnter( "CNntpFSDriver::CreateFileCallback" );
    _ASSERT( lpstrName );
    _ASSERT( strlen( lpstrName ) <= MAX_PATH );
    _ASSERT( pdwSize );

    CREATE_FILE_ARG *arg = (CREATE_FILE_ARG*)lpvData;

    // If we are UNC vroot, we need to do impersonation
    if ( arg->bUNC ) {
        if ( !ImpersonateLoggedOnUser( arg->hToken ) ) {
            ErrorTrace( 0, "Impersonation failed %d", GetLastError() );
            return INVALID_HANDLE_VALUE;
        }
    }

    HANDLE hFile = CreateFileA(
                    lpstrName,
                    GENERIC_READ,
                    FILE_SHARE_READ,
                    0,
                    OPEN_EXISTING,
                    FILE_ATTRIBUTE_READONLY |
                    FILE_FLAG_SEQUENTIAL_SCAN |
                    FILE_FLAG_OVERLAPPED,
                    NULL
                    ) ;
    if( hFile != INVALID_HANDLE_VALUE ) {
        *pdwSize = GetFileSize( hFile, pdwSizeHigh ) ;
    }

    if ( arg->bUNC ) RevertToSelf();

    return  hFile ;
}

HRESULT
CNntpFSDriver::LoadGroupSecurityDescriptor( INNTPPropertyBag    *pPropBag,
                                            LPSTR&              lpstrSecDesc,
                                            PDWORD              pcbSecDesc,
                                            BOOL                bSetProp,
                                            PBOOL               pbAllocated )
/*++
Routine description:

    Load group's security descriptor from file system.  If bSetProp
    is true, it will also be loaded into the group's property bag

Arguments:

    INNNTPPropertyBag *pPropBag - The group's property bag
    LPSTR &lpstrSecDesc         - To receive the security descriptor
                                    It originally points to stack, only
                                    when the buffer on stack is not big
                                    enough will we allocate
    PDWORD  &pcbSecDesc         - To receive the length of security descriptor
    BOOL    bSetProp            - Whether to set it to property bag
    PBOOL   pbAllocated         - Tell caller if we have allocated buffer

Return value:

    S_OK - Success, Other HRESULT otherwise
--*/
{
    TraceFunctEnter( "CNntpFSDriver::LoadGroupSecurityDescriptor" );
    _ASSERT( pPropBag );
    _ASSERT( lpstrSecDesc );
    _ASSERT( pcbSecDesc );
    _ASSERT( pbAllocated );
    _ASSERT( *pcbSecDesc > 0 ); // original buffer size should be passed in

    CHAR    szGroupName[MAX_NEWSGROUP_NAME+1];
    DWORD   cbGroupName = MAX_NEWSGROUP_NAME+1;
    CHAR    szDirectory[MAX_PATH+1];
    HRESULT hr = S_OK;
    DWORD   dwSizeNeeded;

    SECURITY_INFORMATION	si =
				OWNER_SECURITY_INFORMATION |
				GROUP_SECURITY_INFORMATION |
				DACL_SECURITY_INFORMATION ;

    // Get the group name first
    hr = pPropBag->GetBLOB( NEWSGRP_PROP_NAME,
                            (PBYTE)szGroupName,
                            &cbGroupName );
    if ( FAILED( hr ) ) {
        ErrorTrace( 0, "Get group name failed %x", hr );
        goto Exit;
    }
    _ASSERT( *(szGroupName+cbGroupName-1) == 0 );

    // We use the group name to make up the directory path
    hr = GroupName2Path( szGroupName, szDirectory, sizeof(szDirectory) );
	if ( FAILED( hr ) ) {
	    ErrorTrace( 0, "insufficient buffer for path %x", hr );
	    goto Exit;
	}
    _ASSERT( strlen( szDirectory ) < MAX_PATH + 1 );

    *pbAllocated = FALSE;

    // Get the directory's security descriptor
    if ( !GetFileSecurity(  szDirectory,
                            si,
                            lpstrSecDesc,
                            *pcbSecDesc,
                            &dwSizeNeeded ) ) {
        if ( GetLastError() == ERROR_INSUFFICIENT_BUFFER &&
                dwSizeNeeded > *pcbSecDesc ) {

            // We allocate it
            lpstrSecDesc = XNEW char[dwSizeNeeded];
            if ( !lpstrSecDesc ) {
                ErrorTrace( 0, "Out of memory" );
                hr = E_OUTOFMEMORY;
                goto Exit;
            }

            *pbAllocated = TRUE;

            // Load it again
            if ( !GetFileSecurity(  szDirectory,
                                    si,
                                    lpstrSecDesc,
                                    dwSizeNeeded,
                                    &dwSizeNeeded ) ) {
                // This is fatal
        	    hr = HresultFromWin32TakeDefault( ERROR_ACCESS_DENIED );
                ErrorTrace( 0, "Second try loading desc failed %x", hr);
                goto Exit;
            }
        } else {    // fatal reason

    	    hr = HresultFromWin32TakeDefault( ERROR_ACCESS_DENIED );
            ErrorTrace( 0, "Get file sec desc failed %x", hr );
            goto Exit;
        }
    }

    // Being here, we already have the descriptor
    // If we are asked to set this property into property bag,
    // do it now
    if ( bSetProp ) {

        hr = pPropBag->PutBLOB( NEWSGRP_PROP_SECDESC,
                                dwSizeNeeded,
                                PBYTE(lpstrSecDesc));
        if ( FAILED( hr ) ) {
            ErrorTrace( 0, "Put security descriptor failed %x", hr );
            goto Exit;
        }
    }

    *pcbSecDesc = dwSizeNeeded;

Exit:

    TraceFunctLeave();
    return hr;
}

BOOL
CNntpFSDriver::InvalidateGroupSecInternal( LPWSTR  wszDir )
/*++
Routine description:

    Invalidate the group security descriptor, so that the next time
    CheckGroupAccess is called, we'll load the security descriptor
    again.  This function gets called as callback by DirNot when
    DirNot is sure which specific directory's security descriptor
    has been changed

Arguments:

    PVOID pvContext - Context we have given DirNot ( this pointer in this case )
    LPWSTR wszDir   - The directory whose security descriptor has been changed

Return value:

    TRUE if succeeded, FALSE otherwise
--*/
{
    TraceFunctEnter( "CNntpFSDriver::InvalidateGroupSecInternal" );
    _ASSERT( wszDir );

    CHAR szDir[MAX_PATH+1];
    CHAR szGroupName[MAX_NEWSGROUP_NAME+1];
    HRESULT hr = S_OK;
    INNTPPropertyBag *pPropBag = NULL;
    INntpDriver *pDriver;

    // Convert the directory to ascii
    if ( lstrlenW(wszDir)+1 > sizeof(szDir)/sizeof(szDir[0]) ) 
    {
    	ErrorTrace(0, "length of directory name exceeds buffer size");
    	goto Exit;
    }
    CopyUnicodeStringIntoAscii( szDir, wszDir );

    // Convert the path into newsgroup name
    Path2GroupName( szGroupName, szDir );

    //
	// Check to see if this group really belongs to me
	//
	hr = m_pINewsTree->LookupVRoot( szGroupName, &pDriver );
	if ( FAILED ( hr ) || pDriver != (INntpDriver*)this ) {
		DebugTrace(0, "I don't own this group %s", szGroupName );
		goto Exit;
	}

    // Try to locate the group in newstree
    hr = m_pINewsTree->FindOrCreateGroupByName(	szGroupName,
												FALSE,
												&pPropBag,
												NULL,
												0xffffffff, // fake group id
												FALSE       );// we don't set group id
    /* We are pretty risky here to pass in NULL as the completion
       object, since the completion object passed in else where helps
       uncover group object leaks.  We can not pass in completion
       object here because this operation is not initialiated from
       protocol.  We should make sure that we don't leak group
       object here.
    */
	if ( FAILED( hr ) ) {
		DebugTrace( 0, "Can not find the group based on path %x" , hr );
		goto Exit;
	}

	// Should return either ERROR_NOT_FOUND or S_FALSE
	_ASSERT(    HRESULT_FROM_WIN32(ERROR_NOT_FOUND ) == hr ||
	            S_FALSE == hr );

    // Now remove the security descriptor from the group object
    _ASSERT( pPropBag );
    hr = pPropBag->RemoveProperty( NEWSGRP_PROP_SECDESC );
    if ( FAILED( hr ) ) {
        ErrorTrace( 0, "Remove security descriptor failed %x", hr );
        goto Exit;
    }

Exit:

    // Release bag, if necessary
    if ( pPropBag ) pPropBag->Release();
    pPropBag = NULL;

    //
    // I want to disable retry logic in DirNot, because there is
    // no reason here for DirNot to retry. So we always return
    // TRUE but assert real failed cases.
    //
    _ASSERT( SUCCEEDED( hr ) || HRESULT_FROM_WIN32( ERROR_NOT_FOUND ) == hr );
    return TRUE;
}

HRESULT
CNntpFSDriver::InvalidateTreeSecInternal()
/*++
Routine description:

    Invalidate the security descriptors in the whole tree.  We don't
    want to keep the whole tree from being accessed for this operation
    because we think that latencies in update of security descriptor
    are fine.

Arguments:

    None.

Return value:

    S_OK if succeeded, HRESULT error code otherwise
--*/
{
    TraceFunctEnter( "CNntpFSDriver::InvalidateTreeSecInternal" );

    INewsTreeIterator *piter    = NULL;
	INNTPPropertyBag *pPropBag  = NULL;
	BOOL    bWeAreInvalidating  = FALSE;
	HRESULT hr                  = S_OK;
	CHAR    szGroupName[MAX_NEWSGROUP_NAME];
	DWORD   dwLen = MAX_NEWSGROUP_NAME;
	INntpDriver*    pDriver;

    //
    // We should tell other notifications that we are already
    // invalidating the whole tree, so invalidating the tree
    // for a second time is not necessary
    //
    if ( InterlockedExchange(&m_lInvalidating, Invalidating) == Invalidating ) {

        //
        // Somebody else is already invalidating the tree, we should
        // not do this anymore
        //
        DebugTrace( 0, "Somebody else is already invalidating the tree" );
        goto Exit;
    }

    // We should invalidate the tree
    bWeAreInvalidating = TRUE;

	// Get the newstree iterator
	hr = m_pINewsTree->GetIterator( &piter );
	if ( FAILED( hr ) ) {
		ErrorTrace( 0, "Get news tree iterator failed %x", hr );
		goto Exit;
	}

	// Enumerate all the groups
	_ASSERT( piter );
	while( !(piter->IsEnd()) ) {

		hr = piter->Current( &pPropBag, NULL );
		/*  Again, by passing the NULL as completion object here, we
		    are swearing to the protocol that we will release the
		    group object and you don't have to do check on me
		*/
		if ( FAILED( hr ) ) {
			ErrorTrace( 0, "Enumerate group failed %x", hr );
			goto Exit;
		}
		_ASSERT( pPropBag );

		//
		// Get group name to check if this group belongs to us
		//
		dwLen = MAX_NEWSGROUP_NAME;
		hr = pPropBag->GetBLOB( NEWSGRP_PROP_NAME, (PBYTE)szGroupName, &dwLen );
		if ( FAILED( hr ) ) {
		    _ASSERT( FALSE && "Should have group name" );
		    ErrorTrace( 0, "Get group name failed with %x", hr );
		    goto Exit;
		}

		//
	    // Check to see if this group really belongs to me
	    //
	    hr = m_pINewsTree->LookupVRoot( szGroupName, &pDriver );
	    if ( FAILED ( hr ) || pDriver != (INntpDriver*)this ) {
		    DebugTrace(0, "I don't own this group %s", szGroupName );

		    //
		    // but we should still continue to invalid other groups
	    } else {

		    // Remove the security descriptor from the group
		    hr = pPropBag->RemoveProperty( NEWSGRP_PROP_SECDESC );
		    if ( FAILED( hr ) && HRESULT_FROM_WIN32( ERROR_NOT_FOUND ) != hr ) {
		        ErrorTrace( 0, "Remove secruity descriptor failed %x", hr );
		        goto Exit;
		    }
		}

		_ASSERT( pPropBag );
		pPropBag->Release();
		pPropBag = NULL;

		piter->Next();
	}

Exit:


	if ( pPropBag ) {
		pPropBag->Release();
		pPropBag = NULL;
	}

	if ( piter ) {
		piter->Release();
		piter = NULL;
	}

	//
	// Now tell others that invalidating is completed, but we won't
	// disturb other invalidating process if we didn't do the invalidating
	// in the first place
	//
	if ( bWeAreInvalidating )
	    _VERIFY( Invalidating == InterlockedExchange( &m_lInvalidating, Invalidated ) );

    if ( HRESULT_FROM_WIN32( ERROR_NOT_FOUND ) == hr ) hr = S_OK;
	TraceFunctLeave();
	return hr;
}

 DWORD
CNntpFSDriver::GetFileSystemType(
    IN  LPCSTR      pszRealPath,
    OUT LPDWORD     lpdwFileSystem,
    OUT PBOOL       pbUNC
    )
/*++
    Gets file system specific information for a given path.
    It uses GetVolumeInfomration() to query the file system type
       and file system flags.
    On success the flags and file system type are returned in
       passed in pointers.

    Arguments:

        pszRealPath    pointer to buffer containing path for which
                         we are inquiring the file system details.

        lpdwFileSystem
            pointer to buffer to fill in the type of file system.

        pbUNC
            Am I UNC vroot ?

    Returns:
        NO_ERROR  on success and Win32 error code if any error.

--*/
{
    TraceFunctEnter( "CNntpFSDriver::GetFileSystemType" );

    CHAR    rgchBuf[MAX_FILE_SYSTEM_NAME_SIZE];
    CHAR    rgchRoot[MAX_FILE_SYSTEM_NAME_SIZE];
    int     i;
    DWORD   dwReturn = ERROR_PATH_NOT_FOUND;
    DWORD   len;

    if ( (pszRealPath == NULL) || (lpdwFileSystem == NULL)) {
        return ( ERROR_INVALID_PARAMETER);
    }

    ZeroMemory( rgchRoot, sizeof(rgchRoot) );
    *lpdwFileSystem = FS_ERROR;

    //
    // Copy just the root directory to rgchRoot for querying
    //
    if ( (pszRealPath[0] == '\\') &&
         (pszRealPath[1] == '\\')) {

         *lpdwFileSystem = FS_NTFS; // so that we'll always do check
         *pbUNC = TRUE;

         return NO_ERROR;


#if 0 // if UNC vroot, we always do impersonation, thus no need
      // to check if it's a fat
        PCHAR pszEnd;

        //
        // this is an UNC name. Extract just the first two components
        //
        //
        pszEnd = strchr( pszRealPath+2, '\\');

        if ( pszEnd == NULL) {

            // just the server name present

            return ( ERROR_INVALID_PARAMETER);
        }

        pszEnd = (PCHAR)_mbschr( (PUCHAR)pszEnd+1, '\\');

        len = ( ( pszEnd == NULL) ? strlen(pszRealPath)
               : ((pszEnd - pszRealPath) + 1) );

        //
        // Copy till the end of UNC Name only (exclude all other path info)
        //

        if ( len < (MAX_FILE_SYSTEM_NAME_SIZE - 1) ) {

            CopyMemory( rgchRoot, pszRealPath, len);
            rgchRoot[len] = '\0';
        } else {

            return ( ERROR_INVALID_NAME);
        }

#if 1 // DBCS enabling for share name
        if ( *CharPrev( rgchRoot, rgchRoot + len ) != '\\' ) {
#else
        if ( rgchRoot[len - 1] != '\\' ) {
#endif

            if ( len < MAX_FILE_SYSTEM_NAME_SIZE - 2 ) {
                rgchRoot[len]   = '\\';
                rgchRoot[len+1] = '\0';
            } else {

                return (ERROR_INVALID_NAME);
            }
        }
#endif
    } else {

        //
        // This is non UNC name.
        // Copy just the root directory to rgchRoot for querying
        //
        *pbUNC = FALSE;

        for( i = 0; i < 9 && pszRealPath[i] != '\0'; i++) {

            if ( (rgchRoot[i] = pszRealPath[i]) == ':') {

                break;
            }
        } // for


        if ( rgchRoot[i] != ':') {

            //
            // we could not find the root directory.
            //  return with error value
            //

            return ( ERROR_INVALID_PARAMETER);
        }

        rgchRoot[i+1] = '\\';     // terminate the drive spec with a slash
        rgchRoot[i+2] = '\0';     // terminate the drive spec with null char

    } // else

    //
    // The rgchRoot should end with a "\" (slash)
    // otherwise, the call will fail.
    //

    if (  GetVolumeInformation( rgchRoot,        // lpRootPathName
                                NULL,            // lpVolumeNameBuffer
                                0,               // len of volume name buffer
                                NULL,            // lpdwVolSerialNumber
                                NULL,            // lpdwMaxComponentLength
                                NULL,            // lpdwSystemFlags
                                rgchBuf,         // lpFileSystemNameBuff
                                sizeof(rgchBuf)
                                ) ) {



        dwReturn = NO_ERROR;

        if ( strcmp( rgchBuf, "FAT") == 0) {

            *lpdwFileSystem = FS_FAT;

        } else if ( strcmp( rgchBuf, "NTFS") == 0) {

            *lpdwFileSystem = FS_NTFS;

        } else if ( strcmp( rgchBuf, "HPFS") == 0) {

            *lpdwFileSystem = FS_HPFS;

        } else if ( strcmp( rgchBuf, "CDFS") == 0) {

            *lpdwFileSystem = FS_CDFS;

        } else if ( strcmp( rgchBuf, "OFS") == 0) {

            *lpdwFileSystem = FS_OFS;

        } else {

            *lpdwFileSystem = FS_FAT;
        }

    } else {

        dwReturn = GetLastError();

        /*IF_DEBUG( DLL_VIRTUAL_ROOTS)*/ {

            ErrorTrace( 0,
                        " GetVolumeInformation( %s) failed with error %d\n",
                        rgchRoot, dwReturn);
        }

    }

    TraceFunctLeave();
    return ( dwReturn);
} // GetFileSystemType()

HRESULT
CNntpFSDriver::InitializeVppFile()
/*++
Routine description:

    Initialzie the group property file.  We'll not only create the
    object, but also check integrity of the file.  If the integrity
    is good, we'll return success.  If the file is somehow corrupted,
    we only return success if the server is in rebuild mode.   In
    those cases, we want to make sure that the vpp file is removed.

Arguments:

    None.

Return value:

    S_OK if succeeded, other error code if failed
--*/
{
    TraceFunctEnter( "CNntpFSDriver::InitializeVppFile" );

    HRESULT hr = S_OK;
    VAR_PROP_RECORD vpRecord;
    DWORD           cData;
    CHAR            szFileName[MAX_PATH+1];

    //
    // If server is doing clean rebuild, we should not trust
    // vpp file
    //
    if ( m_pNntpServer->QueryServerMode() == NNTP_SERVER_CLEAN_REBUILD ) {
        lstrcpyn( szFileName, m_szPropFile, sizeof(szFileName)-4 );
        strcat( szFileName, ".vpp" );
        DeleteFile( szFileName );
        m_pffPropFile = NULL;
        return S_OK;
    }

    //
    // Create and initialize the flatfile object
    //
	m_pffPropFile = XNEW CFlatFile(	m_szPropFile,
									".vpp",
									NULL,
									CNntpFSDriver::OffsetUpdate );
	if ( NULL == m_pffPropFile ) {
		ErrorTrace( 0, "Create flat file object fail %d",
						GetLastError() );
	    hr = HresultFromWin32TakeDefault( ERROR_NOT_ENOUGH_MEMORY );
		return hr;
	}

    //
	// Try read one record from flatfile, to see if it will
	// cause sharing violation, and to keep the file handle open
	//
	hr = m_pffPropFile->GetFirstRecord( PBYTE(&vpRecord), &cData );
	if ( FAILED( hr ) && hr != HRESULT_FROM_WIN32( ERROR_MORE_DATA ) ) {
	    DebugTrace( 0, "Flatfile sharing violation" );
	    XDELETE m_pffPropFile;
	    m_pffPropFile = NULL;
	    return hr;
	} else hr = S_OK;

    //
    // Check to see if the vpp file is corrupted
    //
    if ( m_pffPropFile->FileInGoodShape() ) {

        //
        // Set it to be corrupted so that unless it is properly shutdown,
        // it will look corrupted to the next guy who initializes it again
        //
        /*
        hr = m_pffPropFile->DirtyIntegrityFlag();
        if ( FAILED( hr ) ) {
            ErrorTrace( 0, "Dirty integrity flag failed %x", hr );
            XDELETE m_pffPropFile;
            m_pffPropFile = NULL;
            return hr;
        }
        */

        DebugTrace( 0, "The vpp file is good" );
        TraceFunctLeave();
        return hr;
    }

    //
    // Now I am pretty sure that the vpp file is corrupted
    //
    if ( m_pNntpServer->QueryServerMode() == NNTP_SERVER_STANDARD_REBUILD
        || m_pNntpServer->QueryServerMode() == NNTP_SERVER_CLEAN_REBUILD ) {

        //
        // If the driver is being connected for rebuild purpose, we should
        // still go ahead and allow the driver to connect, but we should
        // destroy the vpp file object, so that in DecorateNewsTree, we'll
        // know that the vpp file is not credible and we'll have to do
        // root scan
        //
        XDELETE m_pffPropFile;
        m_pffPropFile = NULL;
        TraceFunctLeave();
        return S_OK;
    }

    //
    // The file is corrupted and we are not rebuilding, so we'll have to report
    // error, which will cause the driver connection to fail
    //
    TraceFunctLeave();
    return HRESULT_FROM_WIN32( ERROR_FILE_CORRUPT );
}

HRESULT
CNntpFSDriver::TerminateVppFile()
/*++
Routine description:

    Terminate the vpp file, as the last thing to do, it sets the
    integrity flag on the vpp file, so that the next guy who
    opens the vpp file will know that the file is not corrupted

Arguments:

    None.

Return value:

    HRESULT
--*/
{
    TraceFunctEnter( "CNntpFSDriver::TerminateVppFile" );

    //
    // Set the flag
    //
    /*
    HRESULT hr = m_pffPropFile->SetIntegrityFlag();
    if ( FAILED( hr ) ) {
        ErrorTrace( 0, "Failed to set the integrity flag %x", hr );
    }
    */

    //
    // This is non-fatal: it only means that next time the server is up, we
    // will think that the vpp file has been corrupted and rebuild is needed
    // So we'll go ahead and destroy the object
    //
    HRESULT hr = S_OK;
    XDELETE m_pffPropFile;
    m_pffPropFile = NULL;

    TraceFunctLeave();
    return hr;
}

HRESULT
CNntpFSDriver::CreateGroupInTree(   LPSTR szPath,
                                    INNTPPropertyBag **ppPropBag )
/*++
Routine description:

    Create the group in tree, given group name ( fs path in fact )

Arguments:

    LPSTR szPath - The file system path of the group
    INNTPPropertyBag **ppPropBag - To take group property bag
    
Return value:

    S_OK/S_FALSE if succeeded; error code otherwise
--*/
{
    TraceFunctEnter( "CNntpFSDriver::CreateGroupInTree" );
    _ASSERT( szPath );
    _ASSERT( ppPropBag );

    CHAR szGroupName[MAX_NEWSGROUP_NAME+1];
    HRESULT hr = S_OK;

    //
    // Convert the path into group name
    //
    Path2GroupName( szGroupName, szPath );
    _ASSERT( strlen( szGroupName ) <= MAX_NEWSGROUP_NAME );

    //
    // Call newstree's FindOrCreateByName
    //
    hr = m_pINewsTree->FindOrCreateGroupByName( szGroupName,    // group name
                                                TRUE ,          // create if non-exist
                                                ppPropBag,      // take back bag
                                                NULL,           // no protocolcompletion
                                                0xffffffff,     // fake group id
                                                FALSE           // we don't set group id
                                                );
    if ( FAILED( hr ) ) {
        ErrorTrace( 0, "Find or create group %s failed %x",
                    szGroupName, hr );
    } else {

        //
        // If we are adding the slave group, we'll make it special
        //
        if ( IsSlaveGroup() ) {
            (*ppPropBag)->PutBool( NEWSGRP_PROP_ISSPECIAL, TRUE );
        }
    }

    TraceFunctLeave();
    return hr;
}

HRESULT
CNntpFSDriver::CreateGroupInVpp(    INNTPPropertyBag *pPropBag,
                                    DWORD   &dwOffset)
/*++
Routine description:

    Create the group in the vpp file.  We assume the call holds the reference
    on the property bag and releases it

Arguments:

    INNTPPropertyBag *pPropBag - The group's property bag

Return value:

    HRESULT
--*/
{
    TraceFunctEnter( "CNntpFSDriver::CreateGroupInVpp" );
    _ASSERT( pPropBag );

    HRESULT         hr = S_OK;
    VAR_PROP_RECORD vpRecord;


    // Set group properties to flat file
	hr = Group2Record( vpRecord, pPropBag );
	if ( FAILED( hr ) ) {
		ErrorTrace( 0, "Group2Record fail with %x", hr );
		goto Exit;
	}

	//
	// Beofore vpp operation, dirty the integrity flag
	//
	m_PropFileLock.ExclusiveLock();
	hr = m_pffPropFile->DirtyIntegrityFlag();
	if ( FAILED( hr ) ) {
	    ErrorTrace( 0, "Dirty integrity flag failed %x", hr );
	    m_PropFileLock.ExclusiveUnlock();
	    goto Exit;
	}

	hr = m_pffPropFile->InsertRecord( 	(PBYTE)&vpRecord,
										RECORD_ACTUAL_LENGTH( vpRecord ),
										&dwOffset );
	if ( FAILED( hr ) ) {
	    //m_pffPropFile->SetIntegrityFlag();
		ErrorTrace( 0, "Insert Record fail %x", hr);
		m_PropFileLock.ExclusiveUnlock();
		goto Exit;
	}

	//
	// After the operation, set the integrity flag
	//
	hr = m_pffPropFile->SetIntegrityFlag();
	if ( FAILED( hr ) ) {
        ErrorTrace( 0, "Set integrity flag failed %x", hr );
        m_PropFileLock.ExclusiveUnlock();
        goto Exit;
    }

    //
    // Unlock it
    //
    m_PropFileLock.ExclusiveUnlock();

	//loading offset into property bag
	hr = pPropBag->PutDWord( NEWSGRP_PROP_FSOFFSET, dwOffset );
	if ( FAILED( hr ) ) {
		ErrorTrace( 0, "Loading flatfile offset failed %x", hr );
		goto Exit;
	}

Exit:

    TraceFunctLeave();
    return hr;
}

HRESULT
CNntpFSDriver::LoadGroupsFromVpp( INntpComplete *pComplete, BOOL bNeedDropTagFile )
/*++
Routine description:

    Load the groups from vpp file, including all the properties
    found from vpp file

Arguments:

    INntpComplete *pComplete - Protocol side complete object used
                                for property bag reference tracking

Return value:

    HRESULT
--*/
{
    TraceFunctEnter( "CNntpFSDriver::LoadGroupsFromVpp" );
    _ASSERT( pComplete );

    VAR_PROP_RECORD vpRec;
	DWORD			dwOffset;
	HRESULT			hr = S_OK;
	DWORD			dwSize;
	CHAR            szGroupProperty[MAX_NEWSGROUP_NAME+1];
	CHAR		szDir[MAX_PATH];
	INntpDriver 	*pDriver = NULL;
	INNTPPropertyBag *pPropBag = NULL;

	_ASSERT( m_pffPropFile );

    m_PropFileLock.ShareLock();

	//
	// check to see if the vpp is in good shape
	//
	if ( !m_pffPropFile->FileInGoodShape() ) {
	    ErrorTrace( 0, "vpp file is corrupted" );
	    hr = HRESULT_FROM_WIN32( ERROR_FILE_CORRUPT );
	    m_PropFileLock.ShareUnlock();
	    return hr;
	}

	dwSize = sizeof( vpRec );
	hr = m_pffPropFile->GetFirstRecord( PBYTE(&vpRec), &dwSize, &dwOffset );
	m_PropFileLock.ShareUnlock();
	while ( S_OK == hr ) {

	    //
	    // Check to see if I should continue this loop
	    //
	    if ( !m_pNntpServer->ShouldContinueRebuild() ) {
	        DebugTrace( 0, "Rebuild cancelled" );
	        hr = HRESULT_FROM_WIN32( ERROR_OPERATION_ABORTED );
	        goto Exit;
	    }

		_ASSERT( dwSize == RECORD_ACTUAL_LENGTH( vpRec ) );
		_ASSERT( dwOffset != 0xffffffff );
		_ASSERT( vpRec.cbGroupNameLen <= MAX_GROUPNAME );
		strncpy(    szGroupProperty,
		            LPSTR(vpRec.pData + vpRec.iGroupNameOffset),
		            min(sizeof(szGroupProperty), vpRec.cbGroupNameLen) );
		*(szGroupProperty+min(sizeof(szGroupProperty)-1, vpRec.cbGroupNameLen)) = 0;

        //
		// check if I own this group
		//
		hr = m_pINewsTree->LookupVRoot( szGroupProperty, &pDriver );
		if ( FAILED ( hr ) || pDriver != (INntpDriver*)this ) {
			// skip this group
			DebugTrace(0, "I don't own this group %s", szGroupProperty );
			goto NextIteration;
		}

		//
		// Since I own this group, I'll create this group in tree
		//
		hr = m_pINewsTree->FindOrCreateGroupByName(	szGroupProperty,
													TRUE,       // create if not exist
													&pPropBag,
													pComplete,
													vpRec.dwGroupId,
													TRUE);      // Set group id
		if ( FAILED( hr ) ) {
			ErrorTrace( 0, "Load group %s into tree failed %x" ,
			            szGroupProperty, hr );
			goto Exit;  // should fail it ?
		}

		if (bNeedDropTagFile)
		{
			hr = GroupName2Path( szGroupProperty, szDir, sizeof(szDir) );
			if ( FAILED( hr ) ) {
				ErrorTrace( 0, "insufficient buffer for path %x", hr );
				goto Exit;
			}
	
			hr = CreateAdminFileInDirectory(szDir, "newsgrp.tag");
			if ( FAILED( hr ) ) {
				ErrorTrace( 0, "create newsgrp.tag file in %s failed: %x", szDir, hr );
				goto Exit;
			}
		}
        	//
		// OK, the group has been successfully created, now set a bunch
		// of properties
		//
		// 1. Set offset
		//
		hr = pPropBag->PutDWord( NEWSGRP_PROP_FSOFFSET, dwOffset );
		if ( FAILED( hr ) ) {
			ErrorTrace( 0, "Put offset failed %x", hr );
			goto Exit;
		}

		//
		// 1.5 IsSpecial
		//
		if ( IsSlaveGroup() ) {
		    hr = pPropBag->PutBool( NEWSGRP_PROP_ISSPECIAL, TRUE );
		    if ( FAILED( hr ) ) {
		        ErrorTrace( 0, "Put is special failed %x", hr );
		        goto Exit;
		    }
		}

		//
		// 2. Native name
		//
        _ASSERT( vpRec.cbNativeNameLen <= MAX_GROUPNAME );
        if ( vpRec.iNativeNameOffset > 0 ) {
            strncpy(    szGroupProperty,
                        LPSTR(vpRec.pData + vpRec.iNativeNameOffset),
                        min(sizeof(szGroupProperty), vpRec.cbNativeNameLen ) );
            *(szGroupProperty+min(sizeof(szGroupProperty)-1, vpRec.cbNativeNameLen) )= 0;
            hr = pPropBag->PutBLOB( NEWSGRP_PROP_NATIVENAME,
                                    min((DWORD)sizeof(szGroupProperty)-1, vpRec.cbNativeNameLen),
                                    PBYTE(szGroupProperty) );
            if ( FAILED( hr ) ) {
                ErrorTrace( 0, "Put native name failed %x", hr );
                goto Exit;
            }
        }

        //
        // 3. Pretty name
        //
        _ASSERT( vpRec.cbPrettyNameLen <= MAX_GROUPNAME );
        if ( vpRec.cbPrettyNameLen > 0 ) {
            strncpy(    szGroupProperty,
                        LPSTR(vpRec.pData + vpRec.iPrettyNameOffset),
                        min(sizeof(szGroupProperty), vpRec.cbPrettyNameLen ) );
            *(szGroupProperty+min(sizeof(szGroupProperty)-1, vpRec.cbPrettyNameLen) )= 0;
            hr = pPropBag->PutBLOB( NEWSGRP_PROP_NATIVENAME,
                                    min((DWORD)sizeof(szGroupProperty)-1, vpRec.cbPrettyNameLen),
                                    PBYTE(szGroupProperty) );
            if ( FAILED( hr ) ) {
                ErrorTrace( 0, "Put pretty name failed %x", hr );
                goto Exit;
            }
        }

        //
        // 4. Description text
        //
        _ASSERT( vpRec.cbDescLen <= MAX_GROUPNAME );
        if ( vpRec.cbDescLen > 0 ) {
            strncpy(    szGroupProperty,
                        LPSTR(vpRec.pData + vpRec.iDescOffset),
                        min(sizeof(szGroupProperty), vpRec.cbDescLen ) );
            *(szGroupProperty+min(sizeof(szGroupProperty)-1, vpRec.cbDescLen) )= 0;
            hr = pPropBag->PutBLOB( NEWSGRP_PROP_DESC,
                                    min((DWORD)sizeof(szGroupProperty)-1, vpRec.cbDescLen),
                                    PBYTE(szGroupProperty) );
            if ( FAILED( hr ) ) {
                ErrorTrace( 0, "Put description text failed %x", hr);
                goto Exit;
            }
        }

        //
        // 5. Moderator
        //
        _ASSERT( vpRec.cbModeratorLen <= MAX_GROUPNAME );
        if ( vpRec.cbModeratorLen > 0 ) {
            strncpy(    szGroupProperty,
                        LPSTR(vpRec.pData + vpRec.iModeratorOffset),
                        min(sizeof(szGroupProperty), vpRec.cbModeratorLen ) );
            *(szGroupProperty+min(sizeof(szGroupProperty)-1, vpRec.cbModeratorLen) ) = 0;
            hr = pPropBag->PutBLOB( NEWSGRP_PROP_MODERATOR,
                                    min((DWORD)sizeof(szGroupProperty)-1, vpRec.cbModeratorLen),
                                    PBYTE(szGroupProperty) );
            if ( FAILED( hr ) ) {
                ErrorTrace( 0, "Put moderator failed %x", hr );
                goto Exit;
            }
        }

        //
        // 6. Create time
        //
        hr = pPropBag->PutDWord(    NEWSGRP_PROP_DATELOW,
                                    vpRec.ftCreateTime.dwLowDateTime );
        if ( FAILED( hr ) ) {
            ErrorTrace( 0, "Put low of date failed %x", hr );
            goto Exit;
        }

        hr = pPropBag->PutDWord(    NEWSGRP_PROP_DATEHIGH,
                                    vpRec.ftCreateTime.dwHighDateTime );
        if ( FAILED( hr ) ) {
            ErrorTrace( 0, "Put high of date failed %x", hr );
            goto Exit;
        }

        //
        // OK, we are done, release the property bag
        //
		pComplete->ReleaseBag( pPropBag );
		pPropBag = NULL;

NextIteration:

		dwSize = sizeof( vpRec );
		m_PropFileLock.ShareLock();
		hr = m_pffPropFile->GetNextRecord( PBYTE(&vpRec), &dwSize, &dwOffset );
		m_PropFileLock.ShareUnlock();
	}

Exit:

	if ( NULL != pPropBag ) {
		pComplete->ReleaseBag( pPropBag );
		pPropBag = NULL;
	}

	TraceFunctLeave();
	return hr;
}

HRESULT
CNntpFSDriver::LoadGroups( INntpComplete *pComplete, BOOL bNeedDropTagFile )
/*++
Routine description:

    Load the groups from store into newstree.  There are two possibilities:
    1. If vpp file is good, we'll load directly from vpp file;
    2. If vpp file is corrupted, we'll load by rootscan

Arguments:

    INntpComplete *pComplete - Protocol side complete object used for property
                                bag reference tracking

Return value:

    HRESULT
--*/
{
    TraceFunctEnter( "CNntpFSDriver::LoadGroups" );
    _ASSERT( pComplete );

    HRESULT                 hr = S_OK;
    CHAR                    szFileName[MAX_PATH+1];
    CNntpFSDriverRootScan   *pRootScan = NULL;
    CNntpFSDriverCancelHint *pCancelHint = NULL;

    if ( m_pffPropFile ) {

        //
        // vpp file is good, we'll load groups from vpp file
        //
        hr = LoadGroupsFromVpp( pComplete, bNeedDropTagFile );
        if ( FAILED( hr ) ) {
            ErrorTrace( 0, "Load groups from vpp file failed %x", hr );
            goto Exit;
        }

    } else {

        //
        // If we are doing standard rebuild, we can not tolerate the
        // corruption of vpp file
        //
        if ( m_pNntpServer->QueryServerMode() == NNTP_SERVER_STANDARD_REBUILD ) {

            ErrorTrace( 0, "Vroot rebuild failed because vpp file corruption" );
            hr = HRESULT_FROM_WIN32( ERROR_FILE_CORRUPT );
            goto Exit;
        }

        //
        // We don't have a good vpp file, we'll have to do root scan
        //
        // Before rootscan, we'll delete the vpp file and restart a
        // new vpp file, so that root scan can start adding stuff into it
        //
        lstrcpyn( szFileName, m_szPropFile,  sizeof(szFileName)-4);
        strcat( szFileName, ".vpp" );
        _ASSERT( strlen( szFileName ) <= MAX_PATH );
        DeleteFile( szFileName );

        //
        // Create the new vpp file object
        //
        m_pffPropFile = XNEW CFlatFile(	m_szPropFile,
		    							".vpp",
			    						NULL,
				    					CNntpFSDriver::OffsetUpdate );
    	if ( NULL == m_pffPropFile ) {
	    	ErrorTrace( 0, "Create flat file object fail %d",
		    				GetLastError() );
    	    hr = HresultFromWin32TakeDefault( ERROR_NOT_ENOUGH_MEMORY );
	    	goto Exit;
    	}

    	//
    	// Create the cancel hint object
    	//
    	_ASSERT( m_pNntpServer );
    	pCancelHint = XNEW CNntpFSDriverCancelHint( m_pNntpServer );
    	if ( NULL == pCancelHint ) {
    	    ErrorTrace( 0, "Create cancel hint object failed" );
    	    hr = E_OUTOFMEMORY;
    	    goto Exit;
    	}

    	//
    	// Now create the root scan object
    	//
    	pRootScan = XNEW CNntpFSDriverRootScan( m_szFSDir,
    	                                        m_pNntpServer->SkipNonLeafDirWhenRebuild(),
    	                                        bNeedDropTagFile,
    	                                        this,
    	                                        pCancelHint );
    	if ( NULL == pRootScan ) {
    	    ErrorTrace( 0, "Create root scan object failed" );
    	    hr = E_OUTOFMEMORY;
    	    goto Exit;
    	}

    	//
    	// Now start the root scan
    	if ( !pRootScan->DoScan() ) {
    	    ErrorTrace( 0, "Root scan failed %d", GetLastError() );
    	    hr = HresultFromWin32TakeDefault( ERROR_NOT_ENOUGH_MEMORY );
    	    goto Exit;
    	}
    }

Exit:

    //
    // Clean up
    //
    if ( pRootScan ) XDELETE pRootScan;
    if ( pCancelHint ) XDELETE pCancelHint;
    if ( FAILED( hr ) ) {
        m_pNntpServer->SetRebuildLastError( ERROR_FILE_CORRUPT );
    }

    TraceFunctLeave();

    return hr;
}

HRESULT
CNntpFSDriver::UpdateGroupProperties(   DWORD               cCrossPosts,
                                        INNTPPropertyBag    *rgpPropBag[],
                                        ARTICLEID           rgArticleId[] )
/*++
Routine description:

    Update groups' article counts, high/low watermarks.  The only thing
    we take care of here is high watermark, since article count and low
    watermark should have been adjusted by the protocol.

Arguments:

    DWORD               cCrossPosts     - Number of groups to update
    INNTPPropertyBag    *rgpPropBag[]   - Array of property bags
    ARTICLEID           rgArticleId[]   - Array of article ids

Return value:

    HRESULT
--*/
{
    TraceFunctEnter( "CNntpFSDriver::UpdateGroupProperties" );

    _ASSERT( cCrossPosts > 0 );
    _ASSERT( rgpPropBag );
    _ASSERT( rgArticleId );

    HRESULT hr;
    DWORD   dwHighWatermark;

    for ( DWORD i = 0; i < cCrossPosts; i++ ) {

        hr = rgpPropBag[i]->GetDWord( NEWSGRP_PROP_LASTARTICLE, &dwHighWatermark );
        if ( FAILED( hr ) ) {
            ErrorTrace( 0, "Reading group properties failed %x", hr );
            return (hr);
        }

        if ( dwHighWatermark < rgArticleId[i] )
            dwHighWatermark = rgArticleId[i];

        hr = rgpPropBag[i]->PutDWord( NEWSGRP_PROP_LASTARTICLE, dwHighWatermark );
        if ( FAILED( hr ) ) {
            ErrorTrace( 0, "Writing group properties failed %x", hr );
            return (hr);
        }

    }

    TraceFunctLeave();
    return S_OK;
}

HRESULT
CNntpFSDriver::PreparePostParams(   LPSTR               szFileName,
                                    LPSTR               szGroupName,
                                    LPSTR               szMessageId,
                                    DWORD&              dwHeaderLen,
                                    DWORD&              cCrossPosts,
                                    INNTPPropertyBag    *rgpPropBag[],
                                    ARTICLEID           rgArticleId[],
                                    INntpComplete       *pProtocolComplete )
/*++
Routine description:

    Parse out all the necessary information from the message.

Arguments:

    LPSTR   szFileName      - The file name of the message
    LPSTR   szGroupName     - The news group name
    LPSTR   szMessage       - To return message id
    DWORD   &dwHeaderLen    - To return header length
    DWORD   &cCrossPosts    - Pass in the array length limit, pass out actual length
    INNTPPropertyBag *rgpPropBag[]  - To return array of property bags
    ARTICLEID   rgArticleId[]       - To return array of article ids'
    INntpComplete *pProtocolComplete    - Protocol's completion object that helps
                                            track property bag reference count

Return value:

    S_OK - OK and results returned, S_FALSE - Article parse failed and deleted
    Otherwise, failure
--*/
{
    TraceFunctEnter( "CNntpFSDriver::PrepareParams" );
    _ASSERT( szFileName );
    _ASSERT( szGroupName );
    _ASSERT( szMessageId );
    _ASSERT( cCrossPosts > 0 );
    _ASSERT( rgpPropBag );
    _ASSERT( rgArticleId );
    _ASSERT( pProtocolComplete );

    CNntpReturn nntpReturn;

    //
    // Create allocator for storing parsed header values
    //
    const DWORD     cchMaxBuffer = 1 * 1024;
    char            pchBuffer[cchMaxBuffer];
    CAllocator      allocator(pchBuffer, cchMaxBuffer);
    HRESULT         hr = S_OK;
    HEADERS_STRINGS *pHeaders;
    DWORD           err;
    DWORD           dwLen;
    WORD            wHeaderLen;
    WORD            wHeaderOffset;
    DWORD           dwTotalLen;

    //
    // Create the article object
    //
    CArticleCore    *pArticle = new CArticleCore;
    if ( NULL == pArticle ) {
        ErrorTrace( 0, "Out of memory" );
        hr = E_OUTOFMEMORY;
        goto Exit;
    }

    //
    // Initialize the article object
    //
    if ( !pArticle->fInit( szFileName, nntpReturn, &allocator ) ) {

        //
        // If we couldn't init the article, then return S_FALSE so
        // the caller will rename the file to *.BAD and continue
        //
	    hr = S_FALSE;
        ErrorTrace( 0, "Parse failed on %s: %x", szFileName, hr );
        goto Exit;
    }

    //
    // Get the message id
    //
    if ( !pArticle->fFindOneAndOnly(    szKwMessageID,
                                        pHeaders,
                                        nntpReturn ) ) {
        if ( nntpReturn.fIs( nrcArticleMissingField ) ) {

            //
            // This is fine, we'll return S_FALSE and delete the message
            // but rebuild will continue
            //
            XDELETE pArticle;
            pArticle = NULL;
            DebugTrace( 0, "Parse message id failed on %s", szFileName );
            hr = S_FALSE;
            goto Exit;
        } else {

            //
            // It's fatal, we'll error return
            //
    	    hr = HresultFromWin32TakeDefault( ERROR_NOT_ENOUGH_MEMORY );
            ErrorTrace( 0, "Parse message id failed %s: %x", szFileName, hr );
            goto Exit;
        }
    }

    //
    // Put the message id into the buffer
    // the only caller is passing in szMessageId[2*MAX_PATH+1];
    //
    dwLen = pHeaders->pcValue.m_cch;
    _ASSERT( dwLen <= 2 * MAX_PATH );
    dwLen = min(dwLen, 2*MAX_PATH);

    CopyMemory( szMessageId, pHeaders->pcValue.m_pch, dwLen );
    *(szMessageId + dwLen ) = 0;

    //
    // Now look for xref line
    //
    if ( !pArticle->fFindOneAndOnly(    szKwXref,
                                        pHeaders,
                                        nntpReturn ) ) {
        if ( nntpReturn.fIs( nrcArticleMissingField ) ) {

            //
            // This is fine, we'll return S_FALSE and delete the message
            // but rebuild will continue
            //
            XDELETE pArticle;
            pArticle = NULL;
            DebugTrace( 0, "Parse xref line failed %s", szFileName );
            hr = S_FALSE;
            goto Exit;
        } else {

            //
            // It's fatal, we'll error return
            //
    	    hr = HresultFromWin32TakeDefault( ERROR_NOT_ENOUGH_MEMORY );
            ErrorTrace( 0, "Parse xref failed on %s: %x", szFileName, hr );
            goto Exit;
        }
    }

    //
    // Parse the xref line and get array of property bags, article ids'
    //
    hr = ParseXRef( pHeaders, szGroupName, cCrossPosts, rgpPropBag, rgArticleId, pProtocolComplete );
    if ( FAILED( hr ) ) {

        //
        // This is non fatal, we'll ask the caller to continue after deleting this
        // message
        //
        XDELETE pArticle;
        pArticle = NULL;
        DebugTrace( 0, "Parse xref line failed on %s: %x", szFileName, hr );
        hr = S_FALSE;
        goto Exit;
    }

    //
    // Get the header length
    //
    pArticle->GetOffsets( wHeaderOffset, wHeaderLen, dwTotalLen );
    dwHeaderLen = wHeaderLen;

Exit:

    //
    // If we have allocated article object, we should free it
    //
    if ( pArticle ) delete pArticle;

    TraceFunctLeave();
    return hr;
}

INNTPPropertyBag *
CNntpFSDriver::GetPropertyBag(  LPSTR   pchBegin,
                                LPSTR   pchEnd,
                                LPSTR   szGroupName,
                                BOOL&   fIsNative,
                                INntpComplete *pProtocolComplete )
/*++
Routine description:

    Given group name ( possibly native name ), find it in the newstree
    and get the property bag

Arguments:

    LPSTR   pchBegin    - Start address for the "native name"
    LPSTR   pchEnd      - End address for the "native name"
    LPSTR   szGroupName - To return all low case group name converted from this guy
    BOOL    &fIsNative  - To return if this is really a native name
    INntpComplete *pProtocolComplete - Protocol completion object that helps track
                                        group reference count

Return value:

    Pointer to the bag, if succeeded, NULL otherwise
--*/
{
    TraceFunctEnter( "CNntpFSDriver::GetPropertyBag" );
    _ASSERT( pchBegin );
    _ASSERT( pchEnd );
    _ASSERT( pchEnd >= pchBegin );
    _ASSERT( szGroupName );
    _ASSERT( pProtocolComplete );

    fIsNative = FALSE;

    // caller pass in CHAR szGroupName[MAX_NEWSGROUP_NAME];
    if ( pchEnd - pchBegin + 1 > MAX_NEWSGROUP_NAME )
    {
        ErrorTrace( 0, "newsgroup name is longer than maximum");
        return NULL;
    }
    //
    // Convert the "native name" into group name
    //
    LPSTR   pchDest = szGroupName;
    for ( LPSTR pch = pchBegin; pch < pchEnd; pch++, pchDest++ ) {
        _ASSERT( pchDest - szGroupName <= MAX_NEWSGROUP_NAME );
        *pchDest = (CHAR)tolower( *pch );
        if ( *pchDest != *pch ) fIsNative = TRUE;
    }

    //
    // Null terminate szGroupName
    //
    *pchDest = 0;

    //
    // Now try to find the group from newstree
    //
    INNTPPropertyBag *pPropBag;
    GROUPID groupid = 0xffffffff;
    HRESULT hr = m_pINewsTree->FindOrCreateGroupByName( szGroupName,
                                                        FALSE,          // don't create
                                                        &pPropBag,
                                                        pProtocolComplete,
                                                        groupid,
                                                        FALSE           // don't set groupid
                                                        );
    if ( FAILED( hr ) ) {
        ErrorTrace( 0, "Can not find the group from newstree %x", hr );
        return NULL;
    }

    //
    // We found it, now return the bag
    //
    TraceFunctLeave();
    return pPropBag;
}

HRESULT
CNntpFSDriver::ParseXRef(   HEADERS_STRINGS     *pHeaderXref,
                            LPSTR               szPrimaryName,
                            DWORD&              cCrossPosts,
                            INNTPPropertyBag    *rgpPropBag[],
                            ARTICLEID           rgArticleId[],
                            INntpComplete       *pProtocolComplete )
/*++
Routine description:

    Parse out the cross post information, get property bags for each group
    and article id's for each cross post.

Arguments:

    HEADERS_STRINGS *pHeaderXref    - The xref header
    LPSTR           szPrimaryName     - The primary group name
    DWORD           &cCrossPosts    - In: array limit, out: actual cross posts
    INNTPPropertyBag *rgpPropBag[]  - Array of property bags
    ARTICLEID       rgArticleId[]   - Array of article ids'
    INntpComplete   *pProtocolComplete  - Protocol completion object for tracking property
                                            bag ref-counts

Return value:

    HRESULT
--*/
{
    TraceFunctEnter( "CNntpFSDriver::ParseXRef" );
    _ASSERT( pHeaderXref );
    _ASSERT( szPrimaryName );
    _ASSERT( cCrossPosts > 0 );
    _ASSERT( rgpPropBag );
    _ASSERT( rgArticleId );
    _ASSERT( pProtocolComplete );

    DWORD   i = 1;
    BOOL    fPrimarySkipped = FALSE;
    CHAR    ch;
    LPSTR   lpstrXRef       = pHeaderXref->pcValue.m_pch;
    DWORD   cXRef           = pHeaderXref->pcValue.m_cch;
    LPSTR   lpstrXRefEnd    = lpstrXRef + cXRef;
    LPSTR   pchBegin        = lpstrXRef;
    LPSTR   pchEnd;
    INNTPPropertyBag *pPropBag = NULL;
    CHAR    szGroupName[MAX_NEWSGROUP_NAME];
    CHAR    szNativeName[MAX_NEWSGROUP_NAME];
    CHAR    szNumBuf[MAX_PATH];
    BOOL    fIsNative;
    HRESULT hr = S_OK;
    ARTICLEID articleid;

    //
    // Notice that we'll start from element 1, because element 0 is kept
    // for szGroupName, which is the primary group
    //
    // Also initialize the array of property bags
    ZeroMemory( rgpPropBag, sizeof( cCrossPosts * sizeof( INNTPPropertyBag *)));

    //
    // Skip the "dns.microsoft.com " part - look for first space
    //
    while ( pchBegin < lpstrXRefEnd && *pchBegin != ' ' )
        pchBegin++;

    if ( pchBegin == lpstrXRefEnd ) {

        //
        // This guy is in invalid format
        //
        hr = HRESULT_FROM_WIN32( ERROR_NOT_FOUND );
        goto Exit;
    }
    _ASSERT( *pchBegin == ' ' );

    //
    // Loop through all the newsgroups in xref line
    //
    while( pchBegin < lpstrXRefEnd && i < cCrossPosts) {

        //
        // Skip extra spaces, if any
        //
        while( pchBegin < lpstrXRefEnd &&  *pchBegin == ' ' ) pchBegin++;
        if ( pchBegin < lpstrXRefEnd ) {

            //
            // Find the ":" as the end of the newsgroup name
            //
            pchEnd = pchBegin;
            while( pchEnd < lpstrXRefEnd && *pchEnd != ':' ) pchEnd++;

            if ( pchEnd < lpstrXRefEnd ) {

                pPropBag = GetPropertyBag(  pchBegin,
                                            pchEnd,
                                            szGroupName,
                                            fIsNative,
                                            pProtocolComplete );
                if ( pPropBag ) {

                    //
                    // if it's native name, we should load it into group
                    //
                    if ( fIsNative ) {

                        CopyMemory( szNativeName, pchBegin, pchEnd-pchBegin  );
                        *(szNativeName+(pchEnd-pchBegin)) = 0;
                        hr = pPropBag->PutBLOB( NEWSGRP_PROP_NATIVENAME,
                                                (DWORD)(pchEnd-pchBegin+1),  // including 0
                                                PBYTE(szNativeName) );
                        if ( FAILED( hr ) ) {
                            ErrorTrace( 0, "Put native name failed %x", hr );
                            goto Exit;
                        }
                    }

                    //
                    // Get the article id
                    //
                    _ASSERT( *pchEnd == ':' );
                    pchEnd++;
                    pchBegin = pchEnd;
                    while( pchEnd < lpstrXRefEnd && *pchEnd != ' ' ) pchEnd++;

                    CopyMemory( szNumBuf, pchBegin, pchEnd-pchBegin );
                    *(szNumBuf+(pchEnd-pchBegin)) = 0;
                    articleid = atol( szNumBuf );

                    //
                    // Now it's time to decide where to put this propbag/article pair
                    //
                    if ( !fPrimarySkipped && strcmp( szGroupName, szPrimaryName ) == 0 ) {

                        rgpPropBag[0] = pPropBag;
                        rgArticleId[0] = articleid;
                        fPrimarySkipped = TRUE;
                    } else {

                        rgpPropBag[i] = pPropBag;
                        rgArticleId[i++] = articleid;
                    }

                    pPropBag = NULL;

                 } else {

                    //
                    // Invalid newsgroup name got
                    //
                    ErrorTrace( 0, "Invalid newsgroup name got" );
                    hr = E_OUTOFMEMORY;
                    goto Exit;
                }
            }

            //
            // Ready to find next newsgroup
            //
            pchBegin = pchEnd;
        }
    }

    //
    // If 0'th element of the array is not set, we failed
    //
    if ( rgpPropBag[0] == NULL ) {
        ErrorTrace( 0, "primary group not found in xref line" );
        hr = E_OUTOFMEMORY;
    }

Exit:

    //
    // Release pPropBag, if this guy is non-null
    //
    if ( pPropBag ) pProtocolComplete->ReleaseBag( pPropBag );

    //
    // If failed, we should release all the bags that have been allocated
    //
    if ( FAILED( hr ) ) {
        for ( DWORD j = 0; j < i; j++ )
            if ( rgpPropBag[j] ) pProtocolComplete->ReleaseBag( rgpPropBag[j] );
    }

    //
    // Set the actual length of the array
    //
    if ( SUCCEEDED( hr ) )
        cCrossPosts = i;
    else cCrossPosts = 0;

    TraceFunctLeave();
    return hr;
}

HRESULT
CNntpFSDriver::PostToServer(    LPSTR           szFileName,
                                LPSTR           szGroupName,
                                INntpComplete   *pProtocolComplete )
/*++
Routine description:

    Initialize the file with article object, parse out the necessary
    headers, post them into server, and update group properties

Arguments:

    LPSTR           szFileName          - The file name for the article
    INntpComplete   *pProtocolComplete  - Used to track property bag reference

Return value:

    HRESULT
--*/
{
    TraceFunctEnter( "CNntpFSDriver::PostToServer" );
    _ASSERT( szFileName );
    _ASSERT( pProtocolComplete );

    //
    // Prepare the post parameters from the article
    //
    HRESULT             hr = S_OK;
    CHAR                szMessageId[2*MAX_PATH+1];
    DWORD               dwHeaderLen = 0;
    DWORD               cCrossPosts = 512;      // I assume this would be enough
    INNTPPropertyBag    *rgpPropBag[512];
    ARTICLEID           rgArticleId[512];
    BOOL                fPrepareOK = FALSE;
    STOREID             storeid;
    CDriverSyncComplete scComplete;

    hr = PreparePostParams( szFileName,
                            szGroupName,
                            szMessageId,
                            dwHeaderLen,
                            cCrossPosts,
                            rgpPropBag,
                            rgArticleId,
                            pProtocolComplete );
    if ( S_OK != hr ) {
        ErrorTrace( 0, "Failed to parse post parameters %x", hr );
        goto Exit;
    }

    _ASSERT( cCrossPosts <= 512 );
    _ASSERT( cCrossPosts > 0 );
    fPrepareOK = TRUE;

    //
    // We want to make sure that this article doesn't already exist in
    // the server.  Since multiple vroots can keep same copy of the
    // article, those who won in posting the article first into xover/article
    // table will be deemed primary group/store
    //
    if( m_pNntpServer->MessageIdExist( szMessageId ) ) {

        /*
        if ( IsBadMessageIdConflict(    szMessageId,
                                        pPropBag,
                                        szGroupName,
                                        rgArticleId[0],
                                        pProtocolComplete ) ) {
            //
            // We should return return S_FALSE, so that the article
            // be bad'd
            //
            hr = S_FALSE;
            DebugTrace( 0, "A bad message id conflict" );
            goto Exit;
        } else {

            //
            // A good conflict, we should still update group properties
            //
            hr = UpdateGroupProperties( cCrossPosts,
                                        rgpPropBag,
                                        rgArticleId );
            goto Exit;
        }*/
        DebugTrace( 0, "Message already existed" );
        goto Exit;
    }

    //
    // Call the post interface to put them into hash tables
    //
    scComplete.AddRef();
    scComplete.AddRef();
    _ASSERT( scComplete.GetRef() == 2 );
    ZeroMemory( &storeid, sizeof( STOREID ) );  // I don't care about store id
    m_pNntpServer->CreatePostEntries(   szMessageId,
                                        dwHeaderLen,
                                        &storeid,
                                        (BYTE)cCrossPosts,
                                        rgpPropBag,
                                        rgArticleId,
                                        FALSE,
                                        &scComplete );
    scComplete.WaitForCompletion();
    _ASSERT( scComplete.GetRef() == 0 );
    hr = scComplete.GetResult();
    if ( FAILED( hr ) ) {

        //
        // BUGBUG: CreatePostEntries lied about the error code, it
        // always returns E_OUTOFMEMORY
        //
        ErrorTrace( 0, "Post entry to hash tables failed %x", hr );
        goto Exit;
    }

    /*
    //
    // If it has been succeeded or failed because of message already
    // existed
    //
    hr = UpdateGroupProperties( cCrossPosts,
                                rgpPropBag,
                                rgArticleId );
    if ( FAILED( hr ) ) {
        ErrorTrace( 0, "Update group properties failed %x", hr );
        goto Exit;
    }
    */

Exit:

    //
    // Release all the group bags, if necessary
    //
    if ( fPrepareOK ) {
        for ( DWORD i = 0; i < cCrossPosts; i++ ) {
            pProtocolComplete->ReleaseBag( rgpPropBag[i] );
        }
    }

    TraceFunctLeave();
    return hr;
}

#if 0
BOOL
CNntpFSDriver::IsBadMessageIdConflict(  LPSTR               szMessageId,
                                        INNTPPropertyBag    *pPropBag,
                                        LPSTR               szGroupName,
                                        ARTICLEID           articleid,
                                        INntpComplete       *pProtocolComplete )
/*++
Routine description:

    Check to see if the message id conflict that occurred during rebuild
    is bad.  It is bad if:

    1. The existing entry in article table was posted by a primary group
        that's in the same vroot as us;

        or
    2. 1 is false, but we are not one of the secondary groups of the existing
        entry
Arguments:

    LPSTR               szMessageId - The message id that's conflicted
    INNTPPropertyBag    *pPropBag   - The property bag of us ( the group )
    LPSTR               szGroupName - The newsgroup name
    ARTICLEID           articleid   - Article id of us

Return value:

    TRUE if it's a bad conflict, FALSE otherwise
--*/
{
    TraceFunctEnter( "CNntpFSDriver::IsBadMessageIdConflict" );
    _ASSERT( szMessageId );
    _ASSERT( pPropBag );
    _ASSERT( szGroupName );

    BOOL    fSame = FALSE;

    //
    // Check to see if the guy in the article table is from the same vroot
    //
    if ( !FromSameVroot( szMessageId, szGroupName, fSame ) || fSame ) {

        //
        // Either "same" or function call failed, I'll assume it's bad
        //
        DebugTrace( 0, "The guy in article table is from the same vroot" );
        TraceFunctLeave();
        return TRUE;
    }

    //
    // They are from two different vroots, check to see if they are
    // really cross posts
    //
    return !CrossPostIncludesUs(    szMessageId,
                                    pPropBag,
                                    articleid,
                                    pProtocolComplete );
}

BOOL
CNntpFSDriver::CrossPostIncludesUs(     LPSTR               szMessageId,
                                        INNTPPropertyBag   *pPropBag,
                                        ARTICLEID           articleid,
                                        INntpComplete       *pProtocolComplete )
/*++
Routine description:

    Check to see if szMessageId in article table represents a
    cross post that includes us ( pPropBag )

Arguments:

    LPSTR       szMessageId     - Message id in the article table to check against
    INNTPPropertyBag *pPropBag  - Us ( who lost the game in inserting art map entry )
    ARTICLEID   articleid       - Article id of us
    INntpComplete   *pProtocolComplete - For tracking property bag references

Return value:

    TRUE if the cross post includes us as a secondary group, FALSE otherwise
--*/
{
    TraceFunctEnter( "CNntpFSDriver::CrossPostIncludesUs" );
    _ASSERT( szMessageId );
    _ASSERT( pPropBag );

    //
    // Find the primary group from xover table
    //
    CDriverSyncComplete scComplete;
    scComplete.AddRef();
    scComplete.AddRef();
    _ASSERT( scComplete.GetRef() == 2 );
    INNTPPropertyBag    *pPrimeBag = NULL;
    ARTICLEID           articleidPrimary;
    GROUPID             groupidPrimary;
    ARTICLEID           articleidWon;
    GROUPID             groupidWon;
    STOREID             storeid;

    m_pNntpServer->FindPrimaryArticle( pPropBag,
                                       articleid,
                                       &pPrimeBag,
                                       &articleidPrimary,
                                       FALSE,      // I want global primary
                                       &scComplete,
                                       pProtocolComplete );
    scComplete.WaitForCompletion();
    _ASSERT( scComplete.GetResult() == 0 );
    HRESULT hr = scComplete.GetResult();
    if ( FAILED( hr ) ) {
        ErrorTrace( 0, "Find primary article failed with %x", hr );
        return FALSE;
    }

    //
    // Lets get the group id of that primary guy
    //
    hr = pPrimeBag->GetDWord( NEWSGRP_PROP_GROUPID, &groupidPrimary );
    if ( FAILED( hr ) ) {

        //
        // I tell a lie: saying cross post doesn't include us
        //
        ErrorTrace( 0, "Get group id failed %x", hr );
        pProtocolComplete->ReleaseBag( pPrimeBag );
        return FALSE;
    }

    //
    // It's time to release prime bag
    //
    pProtocolComplete->ReleaseBag( pPrimeBag );

    //
    // Lets find the groupid/articleid for the given messageid
    //
    if ( !m_pNntpServer->FindStoreId(   szMessageId,
                                        &groupidWon,
                                        &articleidWon,
                                        &storeid ) ) {
        ErrorTrace( 0, "Find store id failed %d", GetLastError() );
        return FALSE;
    }

    //
    // Now it's time to make comparison
    //
    return ( groupidWon == groupidPrimary && articleidWon == articleidPrimary );
}

BOOL
CNntpFSDriver::FromSameVroot(   LPSTR               szMessageId,
                                LPSTR               szGroupName,
                                BOOL&               fFromSame )
/*++
Routine description:

    Check to see if the guy in article table with the same message id
    was posted from the same vroot

Arguments:

    LPSTR               szMessageId - The message id that's conflicted
    LPSTR               szGroupName - The newsgroup name
    BOOL&               fFromSame   - To return if they are from same vroot

Return value:

    TRUE if it's from the same vroot, FALSE otherwise
--*/
{
    TraceFunctEnter( "CNntpFSDriver::FromSameVroot" );
    _ASSERT( szMessageId );

    //
    // Find out the group id of the guy in the article table
    //
    GROUPID     groupid;
    ARTICLEID   articleid;
    STOREID     storeid;
    INntpDriver *pDriver1 = NULL;
    INntpDriver *pDriver2 = NULL;
    HRESULT     hr = S_OK;

    if ( !m_pNntpServer->FindStoreId(   szMessageId,
                                         &groupid,
                                         &articleid,
                                         &storeid ) ) {
        ErrorTrace( 0, "FindStoreId failed with %d", GetLastError() );
        return FALSE;
    }

    //
    // Look up for the vroot of the guy in article table
    //
    hr = m_pINewsTree->LookupVRootEx( groupid, &pDriver1 );
    if ( FAILED( hr ) ) {
        ErrorTrace( 0, "LookupVroot failed with %x", hr );
        return FALSE;
    }

    //
    // Look up for the vroot of myself
    //
    hr = m_pINewsTree->LookupVRoot( szGroupName, &pDriver2 );
    if ( FAILED( hr ) ) {
        ErrorTrace( 0, "LookupVRoot failed with %x", hr );
        return FALSE;
    }

    //
    // Check if those two vroots are same
    //
    fFromSame = ( pDriver1 == pDriver2 );
    TraceFunctLeave();
    return TRUE;
}

#endif

void STDMETHODCALLTYPE
CNntpFSDriver::MakeSearchQuery (
	IN	CHAR *pszSearchString,
	IN	INNTPPropertyBag *pGroupBag,
	IN	BOOL bDeepQuery,
	IN	WCHAR *pwszColumns,
	IN	WCHAR *pwszSortOrder,
	IN	LCID LocaleID,
	IN	DWORD cMaxRows,
	IN	HANDLE hToken,
	IN	BOOL fAnonymous,
	IN	INntpComplete *pICompletion,
	OUT	INntpSearchResults **pINntpSearchResults,
	IN	LPVOID lpvContext) {

	WCHAR wszTripoliCatalogPath[_MAX_PATH];

#define MAX_QUERY_STRING_LEN 2000

	TraceFunctEnter("CNntpFSDriver::MakeSearchQuery");

	_ASSERT(pszSearchString);
	_ASSERT(pwszColumns);
	_ASSERT(pwszSortOrder);
	_ASSERT(pICompletion);

	CHAR szGroupName[MAX_GROUPNAME];
	CHAR *pszGroupName = NULL;
	DWORD dwLen;
	HRESULT hr;
	CNntpSearchResults *pSearch = NULL;
	const DWORD cQueryStringBuffer = MAX_QUERY_STRING_LEN;
    WCHAR *pwszQueryString = NULL;

    CNntpSearchTranslator st;

	static const WCHAR wszVPathNws[] = L" & #filename *.nws";

   	// Get group name for the property bag passed in
   	if (pGroupBag) {
		dwLen = MAX_GROUPNAME;
		hr = pGroupBag->GetBLOB( NEWSGRP_PROP_NAME, (UCHAR*)szGroupName, &dwLen);
		if ( FAILED( hr ) ) {
			ErrorTrace( 0, "Get group name failed %x", hr);
			goto Exit;
		}
		_ASSERT( dwLen > 0 );
		pszGroupName = szGroupName;
	}

	DebugTrace((DWORD_PTR)this, "pszSearchString = %s", pszSearchString);
	DebugTrace((DWORD_PTR)this, "pszCurrentGroup = %s", pszGroupName);
	DebugTrace((DWORD_PTR)this, "pwszColumns = %ws", pwszColumns);
	DebugTrace((DWORD_PTR)this, "pwszSortOrder = %ws", pwszSortOrder);

    //
    // get a buffer where we can store the Tripoli version of the search
    // command
    //

    pwszQueryString = XNEW WCHAR[cQueryStringBuffer];
	_ASSERT(pwszQueryString);
	if (pwszQueryString == NULL) {
		DebugTrace(0, "Could not allocate search string");
		hr = E_OUTOFMEMORY;
		goto Exit;
	}

    //
    // convert the query string to Tripolize
    //

    if (!st.Translate(pszSearchString,
	   		pszGroupName,
			pwszQueryString,
			cQueryStringBuffer)) {
	    hr = HresultFromWin32TakeDefault( ERROR_INVALID_PARAMETER );
		goto Exit;
	}

    //
    // append & #vpath *.nws so that we only look for news articles
    //
    if (cQueryStringBuffer - lstrlenW(pwszQueryString) < sizeof(wszVPathNws) / sizeof(wszVPathNws[0]) ) {
        DebugTrace((DWORD_PTR)this, "out of buffer space");
        hr = E_OUTOFMEMORY;
        goto Exit;
    }

    lstrcatW(pwszQueryString, wszVPathNws);

	//
    // Determine the virtual server ID from the vroot's name in the
    // metabase
    //

	DWORD dwVirtualServerID;
    if (_wcsnicmp (m_wszMBVrootPath, L"/LM/Nntpsvc/",
    	(sizeof(L"/LM/Nntpsvc/") / sizeof(WCHAR)) - 1) != 0) {
    	ErrorTrace((DWORD_PTR)this, "Could not determine virtual server ID");
    	hr = E_FAIL;
    	goto Exit;
    }

    dwVirtualServerID =
    	_wtol(&m_wszMBVrootPath[(sizeof(L"/LM/Nntpsvc/") / sizeof(WCHAR)) - 1]);

    if (dwVirtualServerID == 0) {
    	ErrorTrace((DWORD_PTR)this, "Could not determine virtual server ID");
    	hr = E_FAIL;
    	goto Exit;
    }

    //
    // start the query going
    //
    DebugTrace(0, "query string = %S", pwszQueryString);
    hr = s_TripoliInfo.GetCatalogName(dwVirtualServerID, _MAX_PATH, wszTripoliCatalogPath);
    if (hr != S_OK) {
    	DebugTrace ((DWORD_PTR)this, "Could not find path for instance %d", /*inst*/ 1);
    	hr = E_FAIL;
    	goto Exit;
    }

    DebugTrace(0, "making query against catalog %S", wszTripoliCatalogPath);

	pSearch = XNEW CNntpSearchResults(this);
	_ASSERT (pSearch != NULL);
	if (pSearch == NULL) {
		ErrorTrace((DWORD_PTR)this, "Could not allocate search results");
		hr = E_OUTOFMEMORY;
		goto Exit;
	}

	pSearch->AddRef();

	if (ImpersonateLoggedOnUser(hToken)) {
		hr = pSearch->MakeQuery(TRUE,		// Deep query
			pwszQueryString,
			NULL,							// This machine
			wszTripoliCatalogPath,
			NULL,							// Scope
			pwszColumns,					// Columns
			pwszSortOrder,					// Sort order
			LocaleID,
			cMaxRows);
		RevertToSelf();
		if (FAILED(hr)) {
			ErrorTrace((DWORD_PTR)this, "MakeQuery failed, %x", hr);
			goto Exit;
		}
	} else {
	    hr = HresultFromWin32TakeDefault( ERROR_ACCESS_DENIED );
		ErrorTrace((DWORD_PTR)this, "Impersonation failed %x", hr );
		goto Exit;
	}

	*pINntpSearchResults = (INntpSearchResults *) pSearch;

Exit:
	if (pwszQueryString)
		XDELETE pwszQueryString;

	if (FAILED(hr) && pSearch != NULL)
		pSearch->Release();

	if (pGroupBag) {
		pICompletion->ReleaseBag(pGroupBag);
		pGroupBag = NULL;
	}

	pICompletion->SetResult(hr);
	pICompletion->Release();

	TraceFunctLeave();

	return ;
}


void STDMETHODCALLTYPE
CNntpFSDriver::MakeXpatQuery (
	IN	CHAR *pszSearchString,
	IN	INNTPPropertyBag *pGroupBag,
	IN	BOOL bDeepQuery,
	IN	WCHAR *pwszColumns,
	IN	WCHAR *pwszSortOrder,
	IN	LCID LocaleID,
	IN	DWORD cMaxRows,
	IN	HANDLE hToken,
	IN	BOOL fAnonymous,
	IN	INntpComplete *pICompletion,
	OUT	INntpSearchResults **pINntpSearchResults,
	OUT	DWORD *pdwLowArticleID,
	OUT	DWORD *pdwHighArticleID,
	IN	LPVOID lpvContext
) {

	WCHAR wszTripoliCatalogPath[_MAX_PATH];

#define MAX_QUERY_STRING_LEN 2000

	TraceFunctEnter("CNntpFSDriver::MakeXpatQuery");

	_ASSERT(pszSearchString);
	_ASSERT(pwszColumns);
	_ASSERT(pwszSortOrder);
	_ASSERT(pICompletion);
	_ASSERT(pGroupBag);

	CHAR szGroupName[MAX_GROUPNAME];
	DWORD dwLen;
	HRESULT hr;
	CNntpSearchResults *pSearch = NULL;
	const DWORD cQueryStringBuffer = MAX_QUERY_STRING_LEN;
    WCHAR *pwszQueryString = NULL;

    CXpatTranslator xt;

	static const WCHAR wszVPathNws[] = L" & #filename *.nws";


   	// Get group name for the property bag passed in
	dwLen = MAX_GROUPNAME;
	hr = pGroupBag->GetBLOB( NEWSGRP_PROP_NAME, (UCHAR*)szGroupName, &dwLen);
	if ( FAILED( hr ) ) {
		ErrorTrace( 0, "Get group name failed %x", hr);
		goto Exit;
	}
	_ASSERT( dwLen > 0 );

	DebugTrace((DWORD_PTR)this, "pszSearchString = %s", pszSearchString);
	DebugTrace((DWORD_PTR)this, "pszCurrentGroup = %s", szGroupName);
	DebugTrace((DWORD_PTR)this, "pwszColumns = %ws", pwszColumns);
	DebugTrace((DWORD_PTR)this, "pwszSortOrder = %ws", pwszSortOrder);

    //
    // get a buffer where we can store the Tripoli version of the search
    // command
    //

    pwszQueryString = XNEW WCHAR[cQueryStringBuffer];
	_ASSERT(pwszQueryString);
	if (pwszQueryString == NULL) {
		DebugTrace(0, "Could not allocate search string");
		hr = E_OUTOFMEMORY;
		goto Exit;
	}

    //
    // convert the query string to Tripolize
    //

    if (!xt.Translate(pszSearchString,
	   		szGroupName,
			pwszQueryString,
			cQueryStringBuffer)) {
	    hr = HresultFromWin32TakeDefault( ERROR_INVALID_PARAMETER );
		goto Exit;
	}

	*pdwLowArticleID = xt.GetLowArticleID();
	*pdwHighArticleID = xt.GetHighArticleID();

    //
    // append & #vpath *.nws so that we only look for news articles
    //
    if (cQueryStringBuffer - lstrlenW(pwszQueryString) < sizeof(wszVPathNws) / sizeof(wszVPathNws[0]) ) {
        DebugTrace((DWORD_PTR)this, "out of buffer space");
        hr = E_OUTOFMEMORY;
        goto Exit;
    }

    lstrcatW(pwszQueryString, wszVPathNws);


	//
    // Determine the virtual server ID from the vroot's name in the
    // metabase
    //

	DWORD dwVirtualServerID;
    if (_wcsnicmp (m_wszMBVrootPath, L"/LM/Nntpsvc/",
    	(sizeof(L"/LM/Nntpsvc/") / sizeof(WCHAR)) - 1) != 0) {
    	ErrorTrace((DWORD_PTR)this, "Could not determine virtual server ID");
    	hr = E_FAIL;
    	goto Exit;
    }

    dwVirtualServerID =
    	_wtol(&m_wszMBVrootPath[(sizeof(L"/LM/Nntpsvc/") / sizeof(WCHAR)) - 1]);

    if (dwVirtualServerID == 0) {
    	ErrorTrace((DWORD_PTR)this, "Could not determine virtual server ID");
    	hr = E_FAIL;
    	goto Exit;
    }

    //
    // start the query going
    //
    DebugTrace(0, "query string = %S", pwszQueryString);
    hr = s_TripoliInfo.GetCatalogName(dwVirtualServerID, _MAX_PATH, wszTripoliCatalogPath);
    if (hr != S_OK) {
    	DebugTrace ((DWORD_PTR)this, "Could not find path for instance %d", /*inst*/ 1);
    	hr = E_FAIL;
    	goto Exit;
    }

    DebugTrace(0, "making query against catalog %S", wszTripoliCatalogPath);

	pSearch = XNEW CNntpSearchResults(this);
	_ASSERT (pSearch != NULL);
	if (pSearch == NULL) {
		ErrorTrace((DWORD_PTR)this, "Could not allocate search results");
		hr = E_OUTOFMEMORY;
		goto Exit;
	}

	pSearch->AddRef();

	if (ImpersonateLoggedOnUser(hToken)) {
		hr = pSearch->MakeQuery(TRUE,		// Deep query
			pwszQueryString,
			NULL,							// This machine
			wszTripoliCatalogPath,
			NULL,							// Scope
			pwszColumns,					// Columns
			pwszSortOrder,					// Sort order
			LocaleID,
			cMaxRows);
		RevertToSelf();
		if (FAILED(hr)) {
			ErrorTrace((DWORD_PTR)this, "MakeQuery failed, %x", hr);
			goto Exit;
		}
	} else {
	    hr = HresultFromWin32TakeDefault( ERROR_ACCESS_DENIED );
		ErrorTrace((DWORD_PTR)this, "Impersonation failed %x", hr );
		goto Exit;
	}

	*pINntpSearchResults = (INntpSearchResults *) pSearch;

Exit:
	if (pwszQueryString)
		XDELETE pwszQueryString;

	if (FAILED(hr) && pSearch != NULL)
		pSearch->Release();

	if (pGroupBag) {
		pICompletion->ReleaseBag(pGroupBag);
		pGroupBag = NULL;
	}

	pICompletion->SetResult(hr);
	pICompletion->Release();

	TraceFunctLeave();

	return ;
}

void STDMETHODCALLTYPE
CNntpFSDriver::GetDriverInfo(
	OUT	GUID *pDriverGUID,
	OUT	void **ppvDriverInfo,
	IN	LPVOID lpvContext
	) {

	// Return the GUID for this driver and an opaque pointer which
	// UsesSameSearchDatabase can use to see if two instances are
	// pointing to the same search database.

	CopyMemory(pDriverGUID, &GUID_NntpFSDriver, sizeof(GUID));
	*ppvDriverInfo = NULL;
}


BOOL STDMETHODCALLTYPE
CNntpFSDriver::UsesSameSearchDatabase (
	IN	INntpDriverSearch *pSearchDriver,
	IN	LPVOID lpvContext) {

	GUID pDriverGUID;
	void *pNotUsed;

	pSearchDriver->GetDriverInfo(&pDriverGUID, &pNotUsed, NULL);

	if (pDriverGUID == GUID_NntpFSDriver)
		return TRUE;

	return FALSE;
}


CNntpSearchResults::CNntpSearchResults(INntpDriverSearch *pDriverSearch) :
	m_cRef(0),
	m_pDriverSearch(pDriverSearch) {

	_ASSERT(pDriverSearch != NULL);

	m_pDriverSearch->AddRef();
}


CNntpSearchResults::~CNntpSearchResults() {
	m_pDriverSearch->Release();
}

void STDMETHODCALLTYPE
CNntpSearchResults::GetResults (
	IN OUT DWORD *pcResults,
	OUT	BOOL *pfMore,
	OUT	WCHAR *pGroupName[],
	OUT	DWORD *pdwArticleID,
	IN	INntpComplete *pICompletion,
	IN	HANDLE	hToken,
	IN	BOOL  fAnonymous,
	IN	LPVOID lpvContext) {

	TraceQuietEnter("CNntpSearchResults::GetResults");

	_ASSERT(pcResults);
	_ASSERT(pfMore);
	_ASSERT(pGroupName);
	_ASSERT(pdwArticleID);
	_ASSERT(pICompletion);

	HRESULT hr;
	PROPVARIANT *ppvResults[2*MAX_SEARCH_RESULTS];

	ZeroMemory (ppvResults, sizeof(ppvResults));

	if (ImpersonateLoggedOnUser(hToken)) {
		*pcResults = min (MAX_SEARCH_RESULTS, *pcResults);
		hr = GetQueryResults(pcResults, ppvResults, pfMore);
		RevertToSelf();
	} else {
		DWORD   dwErr = GetLastError();
		hr =  HRESULT_FROM_WIN32( (GetLastError() == NO_ERROR) ? ERROR_ACCESS_DENIED : dwErr );
		ErrorTrace( 0, "Impersonation failed %x", hr );
	}

	if (SUCCEEDED(hr)) {
		for (DWORD i=0; i<*pcResults; i++) {
			PROPVARIANT **pvCur = &ppvResults[i*2];

	        // Column 0 is the group name (LPWSTR) and
	        // column 1 is the article ID (UINT)
	        // If the types are wrong, skip the row
			if (pvCur[0]->vt != VT_LPWSTR || pvCur[1]->vt != VT_UI4) {
				ErrorTrace(0, "invalid col types in IDQ results -> "
					"pvCur[0]->vt = %lu pvCur[1]->vt = %lu",
					pvCur[0]->vt, pvCur[1]->vt);
				i--;
				*pcResults--;
			}

			pGroupName[i] = pvCur[0]->pwszVal;
			pdwArticleID[i] = pvCur[1]->uiVal;
		}
	}

	pICompletion->SetResult(hr);
	pICompletion->Release();

}


BOOL
CNntpFSDriver::AddTerminatedDot(
    HANDLE hFile
    )
/*++

Description:

    Add the terminated dot

Argument:

    hFile - file handle

Return Value:

    TRUE if successful, FALSE otherwise

--*/
{
    TraceFunctEnter( "CNntpFSDriver::AddTerminatedDot" );

    DWORD   ret = NO_ERROR;

    //  SetFilePointer to move the EOF file pointer
    ret = SetFilePointer( hFile,
                          5,            // move file pointer 5 chars more, CRLF.CRLF,...
                          NULL,
                          FILE_END );   // ...from EOF
    if (ret == 0xFFFFFFFF)
    {
        ret = GetLastError();
        ErrorTrace(0, "SetFilePointer() failed - %d\n", ret);
        return FALSE;
    }

    //  pickup the length of the file
    DWORD   cb = ret;

    //  Call SetEndOfFile to actually set the file pointer
    if (!SetEndOfFile( hFile ))
    {
        ret = GetLastError();
        ErrorTrace(0, "SetEndOfFile() failed - %d\n", ret);
        return FALSE;
    }

    //  Write terminating dot sequence
    static	char	szTerminator[] = "\r\n.\r\n" ;
    DWORD   cbOut = 0;
    OVERLAPPED  ovl;
    ovl.Offset = cb - 5;
    ovl.OffsetHigh = 0;
    HANDLE  hEvent = GetPerThreadEvent();
    if (hEvent == NULL)
    {
        _ASSERT( 0 );
        ErrorTrace(0, "CreateEvent() failed - %d\n", GetLastError());
        return FALSE;
    }

    ovl.hEvent = (HANDLE)(((DWORD_PTR)hEvent) | 0x1);
    if (! WriteFile( hFile, szTerminator, 5, &cbOut, &ovl ))
    {
        ret = GetLastError();
        if (ret == ERROR_IO_PENDING)
        {
            WaitForSingleObject( hEvent, INFINITE );
        }
        else
        {
            _VERIFY( ResetEvent( hEvent ) );
            ErrorTrace(0, "WriteFile() failed - %d\n", ret);
            return FALSE;
        }
    } else {    // completed synchronously

        _VERIFY( ResetEvent( hEvent ) );
    }

    return TRUE;
}

void
CNntpFSDriver::BackFillLinesHeader( HANDLE  hFile,
                                    DWORD   dwHeaderLength,
                                    DWORD   dwLinesOffset )
/*++
Routine description:

    Back fill the Lines header to the message, since this information is
    not available during posting early and munge headers

Arguments:

    HANDLE  hFile           - File to back fill into
    DWORD   dwHeaderLength  - "Lines:" is estimated "magically" by file size and dwHeaderLength
    DWORD   dwLinesOffset   - Where to fill the lines information from

Return value:

    None.
--*/
{
    TraceFunctEnter( "CNntpFSDriver::BackFillLinesHeader" );
    _ASSERT( INVALID_HANDLE_VALUE != hFile );
    _ASSERT( dwHeaderLength > 0 );
    _ASSERT( dwLinesOffset < dwHeaderLength );

    //
    // Get file size first
    //
    DWORD   dwFileSize =GetFileSize( hFile, NULL );
    _ASSERT( dwFileSize != INVALID_FILE_SIZE );
    if ( dwFileSize == INVALID_FILE_SIZE ) {
        // what can we do ? keep silent
        ErrorTrace( 0, "GetFileSize failed with %d", GetLastError());
        return;
    }

    //
    // "magically compute the line number in body"
    //
    _ASSERT( dwFileSize > dwLinesOffset );
    _ASSERT( dwFileSize >= dwHeaderLength );
    DWORD   dwLines = ( dwFileSize - dwHeaderLength ) / 40 + 1;

    //
    // convert this number into string
    //
    CHAR    szLines[MAX_PATH];
    sprintf( szLines, "%d", dwLines );

    //
    // Prepare for the overlapped structure and writefile
    //
    OVERLAPPED  ovl;
    ovl.Offset = dwLinesOffset;
    ovl.OffsetHigh = 0;
    DWORD   cbOut;
    HANDLE  hEvent = GetPerThreadEvent();
    if (hEvent == NULL)
    {
        _ASSERT( 0 );
        ErrorTrace(0, "CreateEvent() failed - %d\n", GetLastError());
        return;
    }

    ovl.hEvent = (HANDLE)(((DWORD_PTR)hEvent) | 0x1);
    if (! WriteFile( hFile, szLines, strlen(szLines), &cbOut, &ovl ))
    {
        DWORD ret = GetLastError();
        if (ret == ERROR_IO_PENDING)
        {
            WaitForSingleObject( hEvent, INFINITE );
        }
        else
        {
            _VERIFY( ResetEvent( hEvent ) );
            ErrorTrace(0, "WriteFile() failed - %d\n", ret);
            return;
        }
    } else {    // completed synchronously

        _VERIFY( ResetEvent( hEvent ) );
    }

    TraceFunctLeave();
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\nntp\idl\nntpdrv\makefile.inc ===
$(O)\nntpdrv.h : $(STAXINC)\export\nntpdrv.idl
    $(MIDL) \
    $(PACKING) \
    $(INCPATH0) \
    -char unsigned \
    -ms_ext -c_ext \
    -proxy $(PASS0_SOURCEDIR)\nntpdrv_p.c \
    -dlldata $(PASS0_SOURCEDIR)\dlldata.c \
    -iid $(MIDL_UUIDDIR)\nntpdrv_i.c \
    -header $@ \
    -tlb $(O)\nntpdrv.tlb \
    -cpp_cmd $(TARGET_CPP) \
    $(C_DEFINES) \
    $(MIDL_FLAGS) \
    $(MIDL_OPTIMIZATION) \
    $**
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\nntp\idl\nntpdrv\resource.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

	Resource.h

Abstract:

	This module contains the definitions for the
	NNTP Store Driver resources.

Author:

	Bin Lin	(binlin@microsoft.com)

Revision History:

	binlin	01/30/98	created

--*/


//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by inntpdrv.rc
//
#define IDS_PROJNAME					100


// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\nntp\idl\nntpdrv\nntpdrv.cpp ===
#include "windows.h"
#include "nntpdrv.h"

HINSTANCE g_hInst;

extern "C" {
BOOL WINAPI RPCProxyDllMain(HINSTANCE, DWORD, LPVOID);
HRESULT STDAPICALLTYPE RPCProxyDllRegisterServer();
HRESULT STDAPICALLTYPE RPCProxyDllUnregisterServer();
HRESULT STDAPICALLTYPE RPCProxyDllGetClassObject(REFCLSID, REFIID, void **);
HRESULT STDAPICALLTYPE RPCProxyDllCanUnloadNow();
}

BOOL WINAPI DllMain(
        HINSTANCE  hinstDLL,
        DWORD  fdwReason,
        LPVOID  lpvReserved)
{
    if(fdwReason == DLL_PROCESS_ATTACH)
        g_hInst = hinstDLL;
    return RPCProxyDllMain(hinstDLL, fdwReason, lpvReserved);
}

HRESULT STDAPICALLTYPE DllRegisterServer() {
	HRESULT hr;
	WCHAR wszFilename[MAX_PATH];
	wszFilename[MAX_PATH - 1] = L'\0';
	if (GetModuleFileNameW(g_hInst, wszFilename, MAX_PATH - 1) <= 0) {
		return HRESULT_FROM_WIN32(GetLastError());
	}
	ITypeLib *ptLib;
	hr = LoadTypeLib(wszFilename, &ptLib);
	if (SUCCEEDED(hr)) {
		hr = RegisterTypeLib(ptLib, wszFilename, NULL);
		if (SUCCEEDED(hr)) {
			hr = RPCProxyDllRegisterServer();
		}
		ptLib->Release();
	}

	return hr;
}

HRESULT STDAPICALLTYPE DllUnregisterServer()
{
	HRESULT hr;
	WCHAR wszFilename[MAX_PATH];

	// load the type library from our module
	wszFilename[MAX_PATH - 1] = L'\0';
	if (GetModuleFileNameW(g_hInst, wszFilename, MAX_PATH - 1) <= 0) {
		return HRESULT_FROM_WIN32(GetLastError());
	}

	ITypeLib *ptLib;
	hr = LoadTypeLib(wszFilename, &ptLib);
	if (SUCCEEDED(hr)) {
		// get the type library properties
		TLIBATTR *pTLAttributes;
		hr = ptLib->GetLibAttr(&pTLAttributes);
		if (SUCCEEDED(hr)) {
			// unregister the type library using those properties
			hr = UnRegisterTypeLib(pTLAttributes->guid, 
								   pTLAttributes->wMajorVerNum, 
								   pTLAttributes->wMinorVerNum,
								   pTLAttributes->lcid,
								   pTLAttributes->syskind);
		
			if (SUCCEEDED(hr)) {
				hr = RPCProxyDllRegisterServer();
				if (SUCCEEDED(hr)) {
					hr = RPCProxyDllUnregisterServer();
				}
			}
		}
		ptLib->Release();
	}

	return hr;
}

HRESULT STDAPICALLTYPE DllGetClassObject(REFCLSID rclsid, REFIID riid, void **ppv) {
	return RPCProxyDllGetClassObject(rclsid, riid, ppv);
}

HRESULT STDAPICALLTYPE DllCanUnloadNow() {
	return RPCProxyDllCanUnloadNow();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\nntp\isrpc\isrpc.cxx ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    isrpc.cxx

Abstract:

    Contains ISRPC class implementation.

Author:

    Murali R. Krishnan         11-Dec-1995

Environment:

    User Mode - Win32

Revision History:

--*/


/************************************************************
 *  Include Headers
 ************************************************************/

#ifndef dllexp
#define dllexp __declspec( dllexport )
#endif

//
//  System include files.
//

#ifdef __cplusplus
extern "C" {
#endif

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>
#include <winsock2.h>
#include <lm.h>

#include <stdio.h>
#include <stdarg.h>
#include <stdlib.h>
#include <string.h>
#include <tchar.h>

//#include "dbgutil.h"

//
//  Project include files.
//

//#include <inetcom.h>
//#include <inetamsg.h>
//#include <tcpproc.h>

#ifdef __cplusplus
} // extern "C"
#endif // __cplusplus

//#include <svcloc.h>
//#define SECURITY_WIN32
//#include <sspi.h>           // Security Support Provider APIs
//#include <schnlsp.h>
//#include <lonsi.hxx>
//#include "globals.hxx"
#include "isrpc.hxx"

/************************************************************
 *  Functions
 ************************************************************/


DWORD
InetinfoStartRpcServerListen(
    VOID
    )
/*++

Routine Description:

    This function starts RpcServerListen for this process. The first
    service that is calling this function will actually start the
    RpcServerListen, subsequent calls are just noted down in num count.

Arguments:

    None.

Return Value:

    None.

--*/
{

    RPC_STATUS Status = RPC_S_OK;
    Status = RpcServerListen(
                    1,                              // minimum num threads.
                    RPC_C_LISTEN_MAX_CALLS_DEFAULT, // max concurrent calls.
                    TRUE );                         // don't wait

    return( Status );
}


DWORD
InetinfoStopRpcServerListen(
    VOID
    )
/*++

Routine Description:

Arguments:

    None.

Return Value:

    None.

--*/
{
    RPC_STATUS Status = RPC_S_OK;

    Status = RpcMgmtStopServerListening(0);

    //
    // wait for all RPC threads to go away.
    //

    if( Status == RPC_S_OK) {
        Status = RpcMgmtWaitServerListen();
    }

    return( Status );
}


ISRPC::ISRPC(IN LPCTSTR  pszServiceName)
/*++

  This function constructs a new ISRPC object, initializing the
   members to proper state.
  Always the ISRPC members will use RPC_C_AUTHN_WINNT.

  Arguments:

    pszServiceName -  pointer to string containing the name of the service
    dwServiceAuthId - DWORD containing the service Authentication Identifier.

  Returns:
    A valid initialized ISRPC object on success.

--*/
:  m_dwProtocols         ( 0),
   m_fInterfaceAdded     ( FALSE),
   m_fEpRegistered       ( FALSE),
   m_fServerStarted      ( FALSE),
   m_hRpcInterface       ( NULL),
   m_pszServiceName      ( pszServiceName),
   m_pBindingVector      ( NULL)
{
    //DBG_REQUIRE( SetSecurityDescriptor() == NO_ERROR);
    SetSecurityDescriptor();

} // ISRPC::ISRPC()




ISRPC::~ISRPC(VOID)
/*++

  This function cleans up the ISRPC object and releases any dynamic memory or
  state associated with this object.

--*/
{

    CleanupData();
    Cleanup();
} // ISRPC::~ISRPC()




DWORD
ISRPC::CleanupData(VOID)
/*++

Routine Description:

    This member function cleans up the ISRPC object.

Arguments:

    None.

Return Value:

    None.

--*/
{
    DWORD rpcStatus = RPC_S_OK;
    if ( m_fServerStarted) {

        rpcStatus = StopServer( );
    }

    //DBG_ASSERT( rpcStatus == RPC_S_OK);

    rpcStatus = UnRegisterInterface();

    m_dwProtocols     = 0;
    m_hRpcInterface   = NULL;

    return (rpcStatus);
} // ISRPC::CleanupData()

RPC_STATUS RPC_ENTRY NNTPSecurityCallbackFn(
	IN RPC_IF_HANDLE InterfaceUuid,
	IN void *Context)
{

    RPC_CALL_ATTRIBUTES CallAttributes;
    RPC_STATUS Status;

    CallAttributes.Version = RPC_CALL_ATTRIBUTES_VERSION;
    CallAttributes.Flags = 0;

    Status = RpcServerInqCallAttributesW(Context, &CallAttributes);
    if (Status != RPC_S_OK) return Status;

    if ( (CallAttributes.AuthenticationService == RPC_C_AUTHN_NONE)
    	|| (CallAttributes.AuthenticationLevel < RPC_C_AUTHN_LEVEL_PKT_PRIVACY)
    	|| (CallAttributes.NullSession) )
    {
        return RPC_S_ACCESS_DENIED;
    }
    return RPC_S_OK;
}


DWORD
ISRPC::RegisterInterface( IN RPC_IF_HANDLE  hRpcInterface)
/*++

  This function registers the RPC inteface in the object.
  If there is already a valid instance present in the object,
   this function fails and returns error.
  If this is the new interface specified, the function registers the
    interface both for dynamic and static bindings.

   Should be called after calling AddProtocol() and before StartServer()

  Arguments:
    hRpcInteface - RPC inteface handle.

  Returns:
    Win32 Error Code - NO_ERROR on success.

--*/
{
    DWORD dwError = NO_ERROR;

    if ( m_dwProtocols == 0) {

        // No protocol added. Return failure.
        return ( ERROR_INVALID_PARAMETER);
    }

    if ( m_hRpcInterface != NULL) {

        dwError =  ( RPC_S_DUPLICATE_ENDPOINT);
    } else {

        //
        // since there is no duplicate, just set the new value and return.
        //

        if ( hRpcInterface == NULL) {

            dwError = ERROR_INVALID_PARAMETER;
        } else {

            m_hRpcInterface = hRpcInterface;
        }
    }


    if ( dwError == RPC_S_OK) {

        dwError = RpcServerRegisterIfEx(m_hRpcInterface,
                                      0,   // MgrUuid
                                      0,    // MgrEpv (Entry Point Vector)
                                      0,
                                      RPC_C_LISTEN_MAX_CALLS_DEFAULT,
                                      NNTPSecurityCallbackFn                                      
                                      );
        if ( dwError == RPC_S_OK ) {

            m_fInterfaceAdded = TRUE;

            //
            //  Establish the dynamic bindings if any.
            //

            if ( (m_dwProtocols & (ISRPC_OVER_TCPIP | ISRPC_OVER_SPX)) != 0) {

                dwError = RpcServerInqBindings( &m_pBindingVector);

                if ( dwError == RPC_S_OK) {

                    //DBG_ASSERT( m_pBindingVector != NULL);

                    dwError = RpcEpRegister(m_hRpcInterface,
                                            m_pBindingVector,
                                            NULL,
                                            (unsigned char *) "" );

                    if ( dwError == RPC_S_OK) {

                        m_fEpRegistered = TRUE;
                    }
                } // Ep registering
            } // dynamic bindings
        } // registration successful
    }

    return ( dwError);

} // ISRPC::RegisterInterface()



DWORD
ISRPC::UnRegisterInterface( VOID)
/*++

  This function unregisters the RPC inteface in the object.

   Should be called after after StopServer() and before cleanup.

  Arguments:
    None

  Returns:
    Win32 Error Code - NO_ERROR on success.

--*/
{
    DWORD rpcStatus = RPC_S_OK;

    if ( m_fEpRegistered) {

        //DBG_ASSERT( m_hRpcInterface != NULL && m_pBindingVector != NULL);
        rpcStatus = RpcEpUnregister(m_hRpcInterface,
                                    m_pBindingVector,
                                    NULL              // pUuidVector
                                    );
        m_fEpRegistered = FALSE;
    }

    if ( m_pBindingVector != NULL) {

        rpcStatus = RpcBindingVectorFree( &m_pBindingVector);
        m_pBindingVector = NULL;
    }

    if ( m_fInterfaceAdded != NULL) {

#if 1
        rpcStatus = RpcServerUnregisterIf(m_hRpcInterface,
                                          NULL,      // MgrUuid
                                          TRUE  // wait for calls to complete
                                          );
#endif

		m_fInterfaceAdded = FALSE;
    }

    return ( rpcStatus);
} // ISRPC::UnRegisterInterface()




DWORD
ISRPC::AddProtocol( IN DWORD Protocol)
/*++

Routine Description:

    This member function adds another protocol to the binding list.

Arguments:

    protocol - protocol binding opcode.

    fDynamic - Boolean indicating if the call should do dynamic or static
                RPC binding for the protocol specified.

Return Value:

    RPC error code.

--*/
{
    DWORD rpcStatus = RPC_S_OK;

    if ( Protocol & ISRPC_OVER_LPC ) {

        // Currently we only support static binding
        rpcStatus = BindOverLpc( FALSE);
    }

#ifndef CHICAGO

    //
    // Enable all remote bindings
    //

    if ( rpcStatus == RPC_S_OK ) {

        if ( Protocol & ISRPC_OVER_TCPIP ) {

            // Currently we only support dynamic binding
            rpcStatus = BindOverTcp( TRUE);
        }

        if ( rpcStatus == RPC_S_OK && Protocol & ISRPC_OVER_NP ) {

            // Currently we only support static binding
            rpcStatus = BindOverNamedPipe( FALSE);
        }

        if ( rpcStatus == RPC_S_OK &&  Protocol & ISRPC_OVER_SPX  ) {

            // Currently we only support dynamic binding
            rpcStatus = BindOverSpx( TRUE);
        }
    }

#else // CHICAGO
    rpcStatus = RPC_S_OK;

    if ( Protocol & ISRPC_OVER_TCPIP ) {

        // Currently we only support dynamic binding
        rpcStatus = BindOverTcp( TRUE);
    }

    if ( Protocol & ISRPC_OVER_NB ) {

        // Currently we only support dynamic binding
        // Ignore status for NB for now
        (VOID)BindOverNetBios(TRUE);
    }
#endif // CHICAGO
    return( rpcStatus );

} // ISRPC::AddProtocol()

DWORD
ISRPC::RemoveProtocol(IN DWORD Protocol)
/*++

Routine Description:

    This member function removes a protocol from the binding list.

Arguments:

    protocol - protocol binding opcode.

Return Value:

    RPC error code.

Note:
    As a side effect, this function removes the dynamic endpoing on
     TCPIP when SPX binding is removed and vice-versa.

--*/
{
    return ( ERROR_CALL_NOT_IMPLEMENTED);
} // ISRPC::RemoveProtocol()




DWORD
ISRPC::StartServer(
            VOID
            )
/*++

Routine Description:

    This member function start RPC server.

Arguments:

    None.

Return Value:

    RPC error code.

--*/
{
    DWORD rpcStatus;

    //
    // add the interface.
    //

    if ( m_hRpcInterface == NULL) {

        return (ERROR_INVALID_PARAMETER);
    }

    //
    // start rpc server.
    //

#ifndef SERVICE_AS_EXE

    rpcStatus = InetinfoStartRpcServerListen();

#else

    rpcStatus = RpcServerListen(
                                1,          // minimum num threads.
                                1,          // max concurrent calls.
                                TRUE );     // don't wait

#endif // SERVICE_AS_EXE

    if ( rpcStatus == RPC_S_OK ) {
        m_fServerStarted = TRUE;
    }
    return( rpcStatus );

} // ISRPC::StartServer()




DWORD
ISRPC::StopServer(
            VOID
            )
{
    DWORD  rpcStatus = RPC_S_OK;

    if( m_fServerStarted ) {

#ifndef SERVICE_AS_EXE

        rpcStatus = InetinfoStopRpcServerListen();
#else

        //
        // stop server listen.
        //

        rpcStatus = RpcMgmtStopServerListening(0);

        //
        // wait for all RPC threads to go away.
        //

        if( rpcStatus == RPC_S_OK) {

            rpcStatus = RpcMgmtWaitServerListen();
        }

#endif // SERVICE_AS_EXE

        m_fServerStarted = FALSE;
    }

    return ( rpcStatus);
} // ISRPC::StopServer()



DWORD
ISRPC::EnumBindingStrings(
    IN OUT LPINET_BINDINGS pBindings
    )
/*++

Routine Description:

    This member function enumurates the binding strings of the protocols
    bound to the server.

Arguments:

    pBindings : pointer to a binding strings structure. The caller
        should call FreeBindingStrings member function to free the string
        after use.

Return Value:

    Windows Error Code;

--*/
{
   DWORD dwError;
   RPC_BINDING_VECTOR * pBindingVector = NULL;
   LPINET_BIND_INFO pBindingsInfo;
   DWORD  dwCount = 0;
   DWORD i;

   //
   // query RPC for RPC_BINDING_VECTORS.
   //

   dwError =   RpcServerInqBindings( &pBindingVector );

   if( dwError != NO_ERROR ) {

       goto Cleanup;
   }

   //DBG_ASSERT( pBindingVector->Count > 0 );

   //
   // alloc memory for  INET_RPC_BINDING_STRINGS.
   //

   pBindingsInfo = (LPINET_BIND_INFO)
     LocalAlloc( GPTR, sizeof(INET_BIND_INFO) * pBindingVector->Count );

   if( pBindingsInfo == NULL ) {

       dwError = ERROR_NOT_ENOUGH_MEMORY;
       goto Cleanup;
   }

   //
   // convert binding handle to binding vectors.
   //

   pBindings->NumBindings  = 0;
   pBindings->BindingsInfo = pBindingsInfo;

   for( i = 0; i < pBindingVector->Count; i++ ) {

       LPSTR BindingString;

       BindingString = NULL;
       dwError = RpcBindingToStringBindingA(pBindingVector->BindingH[i],
                                            (LPBYTE *)&BindingString );

       if( dwError != NO_ERROR ) {
           goto Cleanup;
       }

       //
       // check to we get only our named-pipe endpoint.
       //

       if( strstr( BindingString, "ncacn_np" ) != NULL ) {

           //
           // found a named-pipe binding string.
           //

           if( strstr(BindingString,
                      m_pszServiceName ) == NULL ) {

               //
               // found a non service named-pipe entry.
               // ignore it.
               //

               RpcStringFreeA( (LPBYTE *)&BindingString );

           } else {
               pBindings->BindingsInfo[dwCount].Length =
                 (strlen(BindingString) + 1) * sizeof(CHAR);
               pBindings->BindingsInfo[dwCount].BindData = BindingString;
               dwCount++;
           }
       }

   } // for

   dwError = NO_ERROR;
   pBindings->NumBindings = dwCount;
 Cleanup:

   if( pBindingVector != NULL ) {

       DWORD LocalError;
       LocalError = RpcBindingVectorFree( &pBindingVector );
       //DBG_ASSERT( LocalError == NO_ERROR );
   }

   if( dwError != NO_ERROR ) {
       FreeBindingStrings( pBindings );
       pBindings->NumBindings = 0;
   }

   return( dwError );

} // ISRPC::EnumBindingStrings()




VOID
ISRPC::FreeBindingStrings(
     IN OUT LPINET_BINDINGS pInetBindings
    )
/*++

Routine Description:

    This member function deletes a binding vector that was returned by the
    EnumBindingStrings member function.

Arguments:

    pBindings : pointer to a binding vector.

Return Value:

    Windows Error Code;

--*/
{
    DWORD dwError;
    DWORD i;


    //
    // free binding strings.
    //

    for( i = 0; i < pInetBindings->NumBindings; i++) {
        dwError = RpcStringFreeA( ((LPBYTE *)&pInetBindings
                                 ->BindingsInfo[i].BindData ));
        //DBG_ASSERT( dwError == NO_ERROR );
    }

    pInetBindings->NumBindings = 0;

    //
    // free bindings info array.
    //

    if( pInetBindings->BindingsInfo != NULL ) {
        LocalFree( (LPWSTR)pInetBindings->BindingsInfo );
        pInetBindings->BindingsInfo = NULL;
    }

    return;

} // ISRPC::FreeBindingStrings()




DWORD
ISRPC::BindOverTcp(IN BOOL fDynamic)
{
    DWORD rpcStatus = RPC_S_OK;

    //DBG_ASSERT( (m_dwProtocols & ISRPC_OVER_TCPIP) == 0);

    if ( !fDynamic) {

        rpcStatus =  ( ERROR_CALL_NOT_IMPLEMENTED);

    } else {

        rpcStatus = ( ISRPC::DynamicBindOverTcp());
    }

    if ( rpcStatus == RPC_S_OK) {

        m_dwProtocols |= ISRPC_OVER_TCPIP;
    }

    return ( rpcStatus);
} // ISRPC::BindOverTcpIp()

#ifdef CHICAGO
DWORD
ISRPC::BindOverNetBios(IN BOOL fDynamic)
{
    DWORD rpcStatus = RPC_S_OK;

    //DBG_ASSERT( (m_dwProtocols & ISRPC_OVER_NB) == 0);

    if ( !fDynamic) {

        return ( ERROR_CALL_NOT_IMPLEMENTED);
    }

    // We will use Dynamic endpoint for the NetBios binding.

    rpcStatus =
      RpcServerUseProtseqW(
                           L"ncacn_nb_ipx",        // protocol string.
                           ISRPC_PROTSEQ_MAX_REQS, //max concurrent calls
                           &sm_sid[ACL_INDEX_ALLOW_ADMIN] );           // security

    rpcStatus =
      RpcServerUseProtseqW(
                           L"ncacn_nb_tcp",        // protocol string.
                           ISRPC_PROTSEQ_MAX_REQS, //max concurrent calls
                           &sm_sid[ACL_INDEX_ALLOW_ADMIN] );           // security

    switch (rpcStatus) {

      case RPC_S_OK:

        //
        // set the protocol bit.
        //

        m_dwProtocols |= ISRPC_OVER_NB;
        break;

      case RPC_S_DUPLICATE_ENDPOINT:

        //DBGPRINTF(( DBG_CONTEXT,
        //           "(%08x) ncacn_nb is already added for %s\n",
        //           this,
        //           m_pszServiceName));
        rpcStatus = RPC_S_OK;
        break;

      case RPC_S_PROTSEQ_NOT_SUPPORTED:
      case RPC_S_CANT_CREATE_ENDPOINT:

        //DBGPRINTF(( DBG_CONTEXT,
        //           "(%08x) ncacn_nb is not supported for %s (%ld).\n",
        //           this, m_pszServiceName, rpcStatus ));
        rpcStatus = RPC_S_OK;
        break;

      default:
        break;
    } // switch()

    //
    // if the security support provider is not enabled, do so.
    //

    if( rpcStatus == RPC_S_OK && !IsSecurityEnabled() ) {

        rpcStatus = AddSecurity();

    }
    return ( rpcStatus);
} // ISRPC::BindOverNetBios()
#endif // CHICAGO

DWORD
ISRPC::BindOverNamedPipe(IN BOOL fDynamic)
{
    DWORD rpcStatus = RPC_S_OK;

    //DBG_ASSERT( (m_dwProtocols & ISRPC_OVER_NP) == 0);


    //
    // On Named Pipe, we support only static bindings. No dynamic Binding.
    //

    if ( fDynamic) {

        return ( ERROR_CALL_NOT_IMPLEMENTED);
    }

    if( (m_dwProtocols & ISRPC_OVER_NP) == 0 ) {

        WCHAR  rgchNp[1024];

        wsprintfW( rgchNp,
#ifdef UNICODE
                  L"%ws%s"
#else
                  L"%ws%S"
#endif // UNICODE
                  ,
                  ISRPC_NAMED_PIPE_PREFIX_W,
                  m_pszServiceName);

        //
        // Establish a static Named pipe binding.
        //

        rpcStatus =
          RpcServerUseProtseqEpW(
                                 L"ncacn_np",        // protocol string.
                                 ISRPC_PROTSEQ_MAX_REQS, //max concurrent calls
                                 rgchNp,             // end point!
                                 &sm_sid[ACL_INDEX_ALLOW_ADMIN] );          // security
        switch (rpcStatus) {

          case RPC_S_OK:

            //
            // set the protocol bit.
            //
            m_dwProtocols |= ISRPC_OVER_NP;
            break;

          case RPC_S_DUPLICATE_ENDPOINT:

            //
            // Ignore the duplicate end point error
            //
            //DBGPRINTF(( DBG_CONTEXT,
            //           "(%08x) ncacn_np is already added for %s\n",
            //           this,
            //           m_pszServiceName));
            m_dwProtocols |= ISRPC_OVER_NP;
            rpcStatus = RPC_S_OK;
            break;

          case RPC_S_PROTSEQ_NOT_SUPPORTED:
          case RPC_S_CANT_CREATE_ENDPOINT:

            //DBGPRINTF(( DBG_CONTEXT,
            //           "(%08x) ncacn_np is not supported for %s (%ld).\n",
            //           this, m_pszServiceName, rpcStatus ));
            rpcStatus = RPC_S_OK;
            break;

          default:
            break;
        } // switch()
    }

    return ( rpcStatus);

} // ISRPC::BindOverNamedPipe()





DWORD
ISRPC::BindOverLpc(IN BOOL fDynamic)
{
    DWORD rpcStatus = RPC_S_OK;

    //DBG_ASSERT( (m_dwProtocols & ISRPC_OVER_LPC) == 0);


    //
    // On LPC, we support only static bindings. No dynamic Binding.
    //

    if ( fDynamic) {

        return ( ERROR_CALL_NOT_IMPLEMENTED);
    }

    if( (m_dwProtocols & ISRPC_OVER_LPC) == 0 ) {

        WCHAR  rgchLpc[1024];

        // LPC Endpoint string is:   <InterfaceName>_LPC
        wsprintfW( rgchLpc,
#ifdef UNICODE
                  L"%s_%ws"
#else
                  L"%S_%ws"
#endif // UNICODE
                  ,
                  m_pszServiceName,
                  ISRPC_LPC_NAME_SUFFIX_W);

        //
        // Establish a static Lpc binding.
        //

        rpcStatus =
          RpcServerUseProtseqEpW(
                                 L"ncalrpc",         // protocol string.
                                 ISRPC_PROTSEQ_MAX_REQS, //max concurrent calls
                                 rgchLpc,            // end point!
                                 &sm_sid[ACL_INDEX_ALLOW_ALL] );          // security
        switch (rpcStatus) {

          case RPC_S_OK:

            //
            // set the protocol bit.
            //
            m_dwProtocols |= ISRPC_OVER_LPC;
            break;

          case RPC_S_DUPLICATE_ENDPOINT:

            //
            // Ignore the duplicate end point error
            //
            //DBGPRINTF(( DBG_CONTEXT,
            //           "(%08x) ncalrpc is already added for %s\n",
            //           this,
            //           m_pszServiceName));
            m_dwProtocols |= ISRPC_OVER_LPC;
            rpcStatus = RPC_S_OK;
            break;

          case RPC_S_PROTSEQ_NOT_SUPPORTED:
          case RPC_S_CANT_CREATE_ENDPOINT:

            //DBGPRINTF(( DBG_CONTEXT,
            //           "(%08x) ncalrpc is not supported for %s (%ld).\n",
            //           this, m_pszServiceName, rpcStatus ));
            rpcStatus = RPC_S_OK;
            break;

          default:
            break;
        } // switch()
    }

    return ( rpcStatus);

} // ISRPC::BindOverLpc()




DWORD
ISRPC::BindOverSpx(IN BOOL fDynamic)
{
    DWORD rpcStatus = RPC_S_OK;

    //DBG_ASSERT( (m_dwProtocols & ISRPC_OVER_SPX) == 0);

    if ( !fDynamic) {

        rpcStatus =  ( ERROR_CALL_NOT_IMPLEMENTED);

    } else {

        rpcStatus = ISRPC::DynamicBindOverSpx();
    }

    if ( rpcStatus == RPC_S_OK) {

        m_dwProtocols |= ISRPC_OVER_SPX;
    }


    return ( rpcStatus);
} // ISRPC::BindOverSpx()


# if DBG

VOID
ISRPC::Print(VOID) const
{

} // ISRPC::Print()

# endif // DBG



/******************************
 * STATIC Member Definitions
 ******************************/

DWORD ISRPC::sm_dwProtocols = 0;

SECURITY_DESCRIPTOR ISRPC::sm_sid[2];
PACL ISRPC::sm_pACL[2];
BOOL  ISRPC::sm_fSecurityEnabled = FALSE;


DWORD
ISRPC::Initialize(VOID)
{
    sm_dwProtocols  = 0;

    return SetSecurityDescriptor();

} // ISRPC::Initialize()



DWORD
ISRPC::Cleanup(VOID)
{
    //
    // Free up the memory holding the ACL for the security descriptor
    //
    delete [] ((BYTE *) sm_pACL[0]);
    sm_pACL[0] = NULL;

    delete [] ((BYTE *) sm_pACL[1]);
    sm_pACL[1] = NULL;

    //
    // Free up the security descriptor
    //

    ZeroMemory( (PVOID) &sm_sid, sizeof(sm_sid));

    //
    // For now nothing to do. Just a place holder.
    //

    return ( NO_ERROR);

} // ISRPC::Cleanup()


DWORD
ISRPC::DynamicBindOverTcp(VOID)
/*++
  This static function (ISRPC member) establishes a dynamic endpoing
   RPC binding over TCP/IP, using a run-time library call to RPC.
  RPC run-time library allows one to create as many dynamic end points
   as one wishes. So we maintain external state and control the number
   of end points created to 1.

  Arguments:
    None

  Returns:
    RPC status - RPC_S_OK for success.

--*/
{
    DWORD rpcStatus = RPC_S_OK;

    if( (sm_dwProtocols & ISRPC_OVER_TCPIP) == 0 ) {

        //
        // Not already present. Add dynamic endpoint over TCP/IP
        //

        rpcStatus =
          RpcServerUseProtseqW(
                               L"ncacn_ip_tcp",    // protocol string.
                               ISRPC_PROTSEQ_MAX_REQS, //max concurrent calls
                               &sm_sid[ACL_INDEX_ALLOW_ADMIN] );          // security

        switch (rpcStatus) {

          case RPC_S_OK:

            //
            // set the protocol bit.
            //

            sm_dwProtocols |= ISRPC_OVER_TCPIP;
            break;

          case RPC_S_DUPLICATE_ENDPOINT:

            //DBGPRINTF(( DBG_CONTEXT,
            //           "ncacn_ip_tcp is already added.\n"));
            sm_dwProtocols |= ISRPC_OVER_TCPIP;
            rpcStatus = RPC_S_OK;
            break;

          case RPC_S_PROTSEQ_NOT_SUPPORTED:
          case RPC_S_CANT_CREATE_ENDPOINT:

            //DBGPRINTF(( DBG_CONTEXT,
            //           "ncacn_ip_tcp is not supported. Error = %ld\n",
            //           rpcStatus));

            break;

          default:
            break;
        } // switch()

        //
        // if the security support provider is not enabled, do so.
        //

        if( rpcStatus == RPC_S_OK && !IsSecurityEnabled() ) {

            rpcStatus = AddSecurity();

        }
    }
    return ( rpcStatus);

} // ISRPC::DynamicBindOverTcp()




DWORD
ISRPC::DynamicBindOverSpx(VOID)
/*++
  This static function (ISRPC member) establishes a dynamic endpoing
   RPC binding over SPX, using a run-time library call to RPC.
  RPC run-time library allows one to create as many dynamic end points
   as one wishes. So we maintain external state and control the number
   of end points created to 1.

  Arguments:
    None

  Returns:
    RPC status - RPC_S_OK for success.

--*/
{
    DWORD rpcStatus = RPC_S_OK;

    if( (sm_dwProtocols & ISRPC_OVER_SPX) == 0 ) {

        // Use dynamic end point for the server.
        rpcStatus =
          RpcServerUseProtseqW(
                               L"ncacn_spx",       // protocol string.
                               ISRPC_PROTSEQ_MAX_REQS, //max concurrent calls
                               &sm_sid[ACL_INDEX_ALLOW_ADMIN] );          // security

        switch (rpcStatus) {

          case RPC_S_OK:

            //
            // set the protocol bit.
            //
            sm_dwProtocols |= ISRPC_OVER_SPX;
            break;

          case RPC_S_DUPLICATE_ENDPOINT:

            //DBGPRINTF(( DBG_CONTEXT,
            //           "ncacn_spx is already added.\n"
            //           ));
            sm_dwProtocols |= ISRPC_OVER_SPX;
            rpcStatus = RPC_S_OK;
            break;

          case RPC_S_PROTSEQ_NOT_SUPPORTED:
          case RPC_S_CANT_CREATE_ENDPOINT:

            //DBGPRINTF(( DBG_CONTEXT,
            //           "ncacn_spx is not supported. Error (%ld).\n",
            //           rpcStatus ));
            break;

          default:
            break;
        } // switch()

        //
        // if the security support provider is not enabled, do so.
        //

        if( rpcStatus == RPC_S_OK && !IsSecurityEnabled()) {

            rpcStatus = AddSecurity();
        }
    }


    return ( rpcStatus);

} // ISRPC::DynamicBindOverSpx()





DWORD
ISRPC::SetSecurityDescriptor( VOID)
/*++

Routine Description:

    This member function builds the security descriptor used by RPC module.
    The security descriptor denies everybody the ability to change/see anything
    connected to the DACL and allows everybody to read from/write to the pipe.

Arguments:

    None.

Return Value:

    Windows error code.

--*/
{
    DWORD dwError = NO_ERROR;
    BOOL  fSuccess = FALSE;
    SID_IDENTIFIER_AUTHORITY siaWorld = SECURITY_WORLD_SID_AUTHORITY;
    SID_IDENTIFIER_AUTHORITY siaNt    = SECURITY_NT_AUTHORITY;
    PSID psidWorld = NULL;
    PSID psidAdmins = NULL;
    int sdCount;


    sm_pACL[0] = NULL;
    sm_pACL[1] = NULL;

    //
    // Create the "WORLD" sid
    //
    if ( !AllocateAndInitializeSid( &siaWorld,
                                    1,
                                    SECURITY_WORLD_RID,
                                    0,0,0,0,0,0,0,
                                    &psidWorld )
        || !AllocateAndInitializeSid( &siaNt,
                                    2,
                                    SECURITY_BUILTIN_DOMAIN_RID,
                                    DOMAIN_ALIAS_RID_ADMINS,
                                    0,0,0,0,0,0,
                                    &psidAdmins ) )
    {
        goto cleanup;
    }

    for (sdCount=0; sdCount<2; sdCount++)
    {

        BYTE *pbBuffer = NULL;
        DWORD cbAcl = 0;

        PSID pSid2Allow = (ACL_INDEX_ALLOW_ALL == sdCount)? psidWorld: psidAdmins;

        InitializeSecurityDescriptor(&sm_sid[sdCount],
                                 SECURITY_DESCRIPTOR_REVISION );
    
        //
        // Calculate the size of the ACL that will hold the the ACESS_DENIED and ACCESS_ALLOW ace
        // [ripped off from MSDN docs]
        //
       cbAcl = sizeof(ACL) +
           sizeof( ACCESS_ALLOWED_ACE ) +
           sizeof( ACCESS_DENIED_ACE )  +
           GetLengthSid(psidWorld) +
           GetLengthSid(pSid2Allow) -
           2*sizeof(DWORD) ;

        if ( ! ( pbBuffer = new BYTE[cbAcl] ) )
        {
            goto cleanup;
        }

        sm_pACL[sdCount] = (PACL) pbBuffer;

        //
        // Initialize the ACL
        //
        if ( !InitializeAcl( sm_pACL[sdCount],
                         cbAcl,
                         ACL_REVISION ) )
        {
            goto cleanup;
        }

        //
        // Add the Access Denied ACE; this has to be first in the list to make sure
        // that any attempt to muck with the DACL will be disallowed
        //
        if ( !AddAccessDeniedAce( sm_pACL[sdCount],
                              ACL_REVISION,
                              WRITE_DAC | DELETE | WRITE_OWNER,
                              psidWorld ) )
        {
            goto cleanup;
        }

        //
        // Add the Access Allowed ACE
        //
        if ( !AddAccessAllowedAce( sm_pACL[sdCount],
                               ACL_REVISION,
                               FILE_ALL_ACCESS,
                               pSid2Allow ) )
        {
            goto cleanup;
        }

        //
        // Set (no) group & owner for the security descriptor
        //
        if ( !SetSecurityDescriptorOwner( &sm_sid[sdCount],
                                      NULL,
                                      FALSE ) )
        {
            goto cleanup;
        }


        if ( !SetSecurityDescriptorGroup( &sm_sid[sdCount],
                                      NULL,
                                      FALSE ) )
        {
            goto cleanup;
        }

        if ( !( fSuccess = SetSecurityDescriptorDacl ( &sm_sid[sdCount],
                                                   TRUE,          // Dacl present
                                                   sm_pACL[sdCount],
                                                   FALSE ) ) )    // Not defaulted
        {
            goto cleanup;
        }
    }

cleanup:


    if ( psidWorld )
    {
        FreeSid( psidWorld );
    }

    if ( psidAdmins )
    {
        FreeSid( psidAdmins );
    }


    if (!fSuccess)
    {

        dwError = GetLastError();

        if ( sm_pACL[0] )
        {
            delete (BYTE*) sm_pACL[0];
            sm_pACL[0] = NULL;
        }

        if ( sm_pACL[1] )
        {
            delete (BYTE*) sm_pACL[1];
            sm_pACL[1] = NULL;

        }

        //
        // free up security discriptor memory and set it to NULL.
        //
        memset( (PVOID ) &sm_sid,  0, sizeof(sm_sid));
    }

    return( dwError );

} // ISRPC::SetSecurityDescriptor()


DWORD
ISRPC::AddSecurity(
    VOID
    )
/*++

Routine Description:

    This member function adds security support provider over RPC.

Arguments:

    None.

Return Value:

    Windows error code.

--*/
{
    DWORD rpcStatus;

    //
    // Register for authentication using WinNT.
    //

    rpcStatus = RpcServerRegisterAuthInfo(
                    (unsigned char * ) NULL, // app name to security provider
                    RPC_C_AUTHN_WINNT,       // Auth package ID.
                    NULL,                    // RPC_C_AUTHN_WINNT ==> NULL
                    NULL                     // args ptr for authn function.
                    );

    if ( rpcStatus == RPC_S_OK) {

        sm_fSecurityEnabled = TRUE;
    }


    return (rpcStatus);
} // ISRPC::AddSecurity()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\nntp\isrpc\main.cxx ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1994                **/
/**********************************************************************/

/*
    main.cxx

        Library initialization for infocomm.dll  --
           Internet Information Services Common dll.

    FILE HISTORY:
        Johnl       06-Oct-1994 Created.
*/

#ifndef dllexp
#define dllexp __declspec( dllexport )
#endif

//
//  System include files.
//

#ifdef __cplusplus
extern "C" {
#endif

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>
#include <winsock2.h>
#include <lm.h>

#include <stdio.h>
#include <stdarg.h>
#include <stdlib.h>
#include <string.h>
#include <tchar.h>

//#include "dbgutil.h"

//
//  Project include files.
//

//#include <inetcom.h>
//#include <inetamsg.h>
//#include <tcpproc.h>

#ifdef __cplusplus
} // extern "C"
#endif // __cplusplus

//#include <svcloc.h>
//#define SECURITY_WIN32
//#include <sspi.h>           // Security Support Provider APIs
//#include <schnlsp.h>
//#include <lonsi.hxx>
//#include "globals.hxx"

#include "isrpc.hxx"
#include "isrpcexp.h"

PISRPC		g_pIsrpc = NULL;
HINSTANCE	g_hDll = NULL;
PISRPC		sm_isrpc = NULL;

BOOL
InitializeServiceRpc(
				IN LPCSTR        pszServiceName,
                IN RPC_IF_HANDLE hRpcInterface
                );

BOOL
CleanupServiceRpc(
                 VOID
                 );

extern "C"
BOOL WINAPI DLLEntry( HINSTANCE hDll, DWORD dwReason, LPVOID lpvReserved )
{
    BOOL  fReturn = TRUE;

    switch ( dwReason )
    {
		case DLL_PROCESS_ATTACH:  

			g_hDll = hDll;
			break;

		case DLL_PROCESS_DETACH:
			break;

		case DLL_THREAD_ATTACH:
		case DLL_THREAD_DETACH:
		default:
			break ;
    }

    return ( fReturn);

}  // main()

BOOL
InitializeServiceRpc(
				IN LPCSTR        pszServiceName,
                IN RPC_IF_HANDLE hRpcInterface
                )
/*++
    Description:

        Initializes the rpc endpoint for the infocomm service.

    Arguments:
        pszServiceName - pointer to null-terminated string containing the name
          of the service.

        hRpcInterface - Handle for RPC interface.

    Returns:
        Win32 Error Code.

--*/
{

    DWORD dwError = NO_ERROR;
    PISRPC  pIsrpc;

    //DBG_ASSERT( pszServiceName != NULL);
    //DBG_ASSERT( sm_isrpc == NULL );

    pIsrpc = new ISRPC( pszServiceName);

    if ( pIsrpc == NULL) {
        dwError = ERROR_NOT_ENOUGH_MEMORY;
        goto exit;
    }

    //
    //  bind over Named pipe only.
    //  If needed to bind over TCP, bind with bit flag ISRPC_OVER_TCPIP on.
    //

    dwError = pIsrpc->AddProtocol( ISRPC_OVER_TCPIP
                                  | ISRPC_OVER_NP | ISRPC_OVER_LPC
                                  );

    if( (dwError == RPC_S_DUPLICATE_ENDPOINT) ||
       (dwError == RPC_S_OK)
       ) {

        dwError = pIsrpc->RegisterInterface(hRpcInterface);
    }

    if ( dwError != RPC_S_OK ) {
        goto exit;
    }

    //
    //  Start the RPC listen thread
    //
#if 0
    dwError = pIsrpc->StartServer( );
#endif

exit:

    if ( dwError != NO_ERROR ) {
        //DBGPRINTF(( DBG_CONTEXT,
        //           "Cannot start RPC Server for %s, error %lu\n",
        //           pszServiceName, dwError ));

        delete pIsrpc;
        SetLastError(dwError);
        return(FALSE);
    }

    sm_isrpc = pIsrpc;
    return(TRUE);

} // IIS_SERVICE::InitializeServiceRpc

BOOL
CleanupServiceRpc(
                       VOID
                       )
/*++
    Description:

        Cleanup the data stored and services running.
        This function should be called only after freeing all the
         services running using this DLL.
        This function is called typically when the DLL is unloaded.

    Arguments:
        pszServiceName - pointer to null-terminated string containing the name
          of the service.

        hRpcInterface - Handle for RPC interface.


    Returns:
        Win32 Error Code.

--*/
{
    DWORD dwError = NO_ERROR;

    if ( sm_isrpc == NULL ) {
        //DBGPRINTF((DBG_CONTEXT,
        //    "no isrpc object to cleanup. Returning success\n"));
        return(TRUE);
    }

#if 0
    (VOID) sm_isrpc->StopServer( );
#endif

    //dwError = sm_isrpc->CleanupData();
    dwError = sm_isrpc->UnRegisterInterface();

    if( dwError != RPC_S_OK ) {
        //DBGPRINTF(( DBG_CONTEXT,
        //           "ISRPC(%08x) Cleanup returns %lu\n", sm_isrpc, dwError ));
        //DBG_ASSERT( !"RpcServerUnregisterIf failure" );
        SetLastError( dwError);
    }

    delete sm_isrpc;
    sm_isrpc = NULL;

    return TRUE;
} // CleanupServiceRpc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\nntp\nntpapi\nntpbind.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    nntpbind.c

Abstract:

    Routines which use RPC to bind and unbind the client to the common
    internet Admin APIs.

Author:

    Madan Appiah (madana) 10-Oct-1995

Environment:

    User Mode -Win32

Revision History:

    Madan Appiah (madana) 10-Oct-1995 Created.
    Murali R. Krishnan (MuraliK)   15-Nov-1995   Remove Netp routines
    Murali R. Krishnan (MuraliK)   21-Nov-1995   Support TCP/IP binding
	Rajeev Rajan	(rajeevr)	   26-Feb-1997	 Moved from K2 tree for nntp

--*/

#define UNICODE
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windef.h>

#include <nntpsvc.h>
#include <inetinfo.h>
#include <norminfo.h>
#include "apiutil.h"



handle_t
NNTP_IMPERSONATE_HANDLE_bind(
    NNTP_IMPERSONATE_HANDLE ServerName
    )

/*++

Routine Description:

    This routine is called from the inet info admin client stubs when
    it is necessary create an RPC binding to the server end with
    impersonation level of security

Arguments:

    ServerName - A pointer to a string containing the name of the server
        to bind with.

Return Value:

    The binding handle is returned to the stub routine.  If the bind is
    unsuccessful, a NULL will be returned.

--*/
{
    handle_t BindHandle;
    RPC_STATUS RpcStatus;

    RpcStatus = RpcBindHandleForServer(&BindHandle,
                                       ServerName,
                                       NNTP_INTERFACE_NAME,
                                       PROT_SEQ_NP_OPTIONS_W
                                       );


    return BindHandle;
} // NNTP_IMPERSONATE_HANDLE_bind()



handle_t
NNTP_HANDLE_bind(
    NNTP_HANDLE ServerName
    )

/*++

Routine Description:

    This routine is called from the inet admin client stubs when
    it is necessary create an RPC binding to the server end with
    identification level of impersonation.

Arguments:

    ServerName - A pointer to a string containing the name of the server
        to bind with.

Return Value:

    The binding handle is returned to the stub routine.  If the bind is
    unsuccessful, a NULL will be returned.

--*/
{
    handle_t BindHandle;
    RPC_STATUS RpcStatus;

    RpcStatus = RpcBindHandleForServer(&BindHandle,
                                       ServerName,
                                       NNTP_INTERFACE_NAME,
                                       PROT_SEQ_NP_OPTIONS_W
                                       );

    return BindHandle;
} // NNTP_HANDLE_bind()



void
NNTP_IMPERSONATE_HANDLE_unbind(
    NNTP_IMPERSONATE_HANDLE ServerName,
    handle_t BindHandle
    )

/*++

Routine Description:

    This routine calls a common unbind routine that is shared by all services.
    This routine is called from the inet admin client stubs when it is
    necessary to unbind from the server end.

Arguments:

    ServerName - This is the name of the server from which to unbind.

    BindingHandle - This is the binding handle that is to be closed.

Return Value:

    None.

--*/
{
    UNREFERENCED_PARAMETER(ServerName);

    (VOID ) RpcBindHandleFree(&BindHandle);

    return;
} // NNTP_IMPERSONATE_HANDLE_unbind()



void
NNTP_HANDLE_unbind(
    NNTP_HANDLE ServerName,
    handle_t BindHandle
    )

/*++

Routine Description:

    This routine calls a common unbind routine that is shared by all services.
    This routine is called from the inet admin client stubs when it is
    necessary to unbind from a server.

Arguments:

    ServerName - This is the name of the server from which to unbind.

    BindingHandle - This is the binding handle that is to be closed.

Return Value:

    None.

--*/
{
    UNREFERENCED_PARAMETER(ServerName);


    (VOID ) RpcBindHandleFree(&BindHandle);

    return;
} // NNTP_IDENTITY_HANDLE_unbind()


/****************************** End Of File ******************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\nntp\nntpapi\nntpsubs.c ===
/*++

Copyright (c) 1990-1992  Microsoft Corporation

Module Name:

    nntpsubs.c

Abstract:

    Subroutines for LAN Manager APIs.

Author:

    Dan Hinsley (DanHi) 23-Mar-93

Revision History:

--*/

// These must be included first:
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#define NOMINMAX                // Avoid stdlib.h vs. windows.h warnings.
#include <windows.h>


BOOLEAN
NntpInitialize (
    IN PVOID DllHandle,
    IN ULONG Reason,
    IN LPVOID lpReserved OPTIONAL
    )
{
    UNREFERENCED_PARAMETER(DllHandle);          // avoid compiler warnings


    //
    // Handle attaching w3svc.dll to a new process.
    //

    if (Reason == DLL_PROCESS_ATTACH) {

#if 0
        //
        // Initialize RPC Bind Cache
        //

        NetpInitRpcBindCache();
#endif

    //
    // When DLL_PROCESS_DETACH and lpReserved is NULL, then a FreeLibrary
    // call is being made.  If lpReserved is Non-NULL, then ExitProcess is
    // in progress.  These cleanup routines will only be called when
    // a FreeLibrary is being called.  ExitProcess will automatically
    // clean up all process resources, handles, and pending io.
    //
    } else if ((Reason == DLL_PROCESS_DETACH) &&
               (lpReserved == NULL)) {

#if 0
        NetpCloseRpcBindCache();
#endif

    }

    return TRUE;

} // NntpInitialize
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\nntp\nntpctrs\nntpctrs.h ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1993                **/
/**********************************************************************/

/*
    nntpctrs.h

    Offset definitions for the NNTP Server's counter objects & counters.

    These offsets *must* start at 0 and be multiples of 2.  In the
    NntpOpenPerformanceData procecedure, they will be added to the
    NNTP Server's "First Counter" and "First Help" values in order to
    determine the absolute location of the counter & object names
    and corresponding help text in the registry.

    This file is used by the NNTPCTRS.DLL DLL code as well as the
    NNTPCTRS.INI definition file.  NNTPCTRS.INI is parsed by the
    LODCTR utility to load the object & counter names into the
    registry.


    FILE HISTORY:
        KeithMo     07-Jun-1993 Created.

*/


#ifndef _NNTPCTRS_H_
#define _NNTPCTRS_H_

//
// disabled tracing by default for the perfmon client code
//
#ifndef	NOTRACE
#define	NOTRACE
#endif

//
//  The "NNTP Server" object.
//

#define NNTP_COUNTER_OBJECT1                    0

//
//  The individual counters.
//

#define NNTP_BYTES_SENT_COUNTER                 2
#define NNTP_BYTES_RECEIVED_COUNTER             4
#define NNTP_BYTES_TOTAL_COUNTER                6

#define NNTP_TOTAL_CONNECTIONS_COUNTER          8
#define NNTP_TOTAL_SSL_CONNECTIONS_COUNTER      10
#define NNTP_CURRENT_CONNECTIONS_COUNTER        12
#define NNTP_MAX_CONNECTIONS_COUNTER            14

#define NNTP_CURRENT_ANONYMOUS_COUNTER          16
#define NNTP_CURRENT_NONANONYMOUS_COUNTER       18
#define NNTP_TOTAL_ANONYMOUS_COUNTER            20
#define NNTP_TOTAL_NONANONYMOUS_COUNTER         22
#define NNTP_MAX_ANONYMOUS_COUNTER              24
#define NNTP_MAX_NONANONYMOUS_COUNTER           26

#define NNTP_TOTAL_OUTBOUND_CONNECTS_COUNTER    28
#define NNTP_OUTBOUND_CONNECTS_FAILED_COUNTER   30
#define NNTP_CURRENT_OUTBOUND_CONNECTS_COUNTER  32
#define NNTP_OUTBOUND_LOGON_FAILED_COUNTER      34

#define NNTP_TOTAL_PULL_FEEDS_COUNTER           36
#define NNTP_TOTAL_PUSH_FEEDS_COUNTER           38
#define NNTP_TOTAL_PASSIVE_FEEDS_COUNTER        40

#define NNTP_ARTICLES_SENT_COUNTER              42
#define NNTP_ARTICLES_RECEIVED_COUNTER          44
#define NNTP_ARTICLES_TOTAL_COUNTER             46

#define NNTP_ARTICLES_POSTED_COUNTER            48
#define NNTP_ARTICLE_MAP_ENTRIES_COUNTER        50
#define NNTP_HISTORY_MAP_ENTRIES_COUNTER        52
#define NNTP_XOVER_ENTRIES_COUNTER              54

#define NNTP_CONTROL_MSGS_IN_COUNTER            56
#define NNTP_CONTROL_MSGS_FAILED_COUNTER        58
#define NNTP_MODERATED_POSTINGS_SENT_COUNTER    60
#define NNTP_MODERATED_POSTINGS_FAILED_COUNTER  62

#define NNTP_SESS_FLOW_CONTROL_COUNTER          64

#define NNTP_ARTICLES_EXPIRED_COUNTER           66

#define NNTP_ARTICLES_SENT_PERSEC_COUNTER       68
#define NNTP_ARTICLES_RECEIVED_PERSEC_COUNTER   70
#define NNTP_ARTICLES_POSTED_PERSEC_COUNTER     72
#define NNTP_ARTICLE_MAP_ENTRIES_PERSEC_COUNTER 74
#define NNTP_HISTORY_MAP_ENTRIES_PERSEC_COUNTER 76
#define NNTP_XOVER_ENTRIES_PERSEC_COUNTER       78
#define NNTP_ARTICLES_EXPIRED_PERSEC_COUNTER    80

//
//  The "NNTP Commands" counter object.
//

#define NNTP_COUNTER_OBJECT2                    100

//
//  The individual counters.
//

#define NNTP_CMDS_ARTICLE_COUNTER				102
#define NNTP_CMDS_PERSEC_ARTICLE_COUNTER		104
#define NNTP_CMDS_GROUP_COUNTER					106
#define NNTP_CMDS_PERSEC_GROUP_COUNTER			108
#define NNTP_CMDS_HELP_COUNTER					110
#define NNTP_CMDS_PERSEC_HELP_COUNTER			112
#define NNTP_CMDS_IHAVE_COUNTER					114
#define NNTP_CMDS_PERSEC_IHAVE_COUNTER			116
#define NNTP_CMDS_LAST_COUNTER					118
#define NNTP_CMDS_PERSEC_LAST_COUNTER			120
#define NNTP_CMDS_LIST_COUNTER					122
#define NNTP_CMDS_PERSEC_LIST_COUNTER			124
#define NNTP_CMDS_NEWGROUPS_COUNTER				126
#define NNTP_CMDS_PERSEC_NEWGROUPS_COUNTER		128
#define NNTP_CMDS_NEWNEWS_COUNTER				130
#define NNTP_CMDS_PERSEC_NEWNEWS_COUNTER		132
#define NNTP_CMDS_NEXT_COUNTER					134
#define NNTP_CMDS_PERSEC_NEXT_COUNTER			136
#define NNTP_CMDS_POST_COUNTER					138
#define NNTP_CMDS_PERSEC_POST_COUNTER			140
#define NNTP_CMDS_QUIT_COUNTER					142
#define NNTP_CMDS_PERSEC_QUIT_COUNTER			144
#define NNTP_CMDS_STAT_COUNTER					146
#define NNTP_CMDS_PERSEC_STAT_COUNTER			148
#define NNTP_LOGON_ATTEMPTS_COUNTER             150
#define NNTP_LOGON_FAILURES_COUNTER             152
#define NNTP_LOGON_ATTEMPTS_PERSEC_COUNTER      154
#define NNTP_LOGON_FAILURES_PERSEC_COUNTER      156
#define NNTP_CMDS_CHECK_COUNTER					158
#define NNTP_CMDS_TAKETHIS_COUNTER				160
#define NNTP_CMDS_MODE_COUNTER					162
#define NNTP_CMDS_SEARCH_COUNTER				164
#define NNTP_CMDS_XHDR_COUNTER					166
#define NNTP_CMDS_XOVER_COUNTER					168
#define NNTP_CMDS_XPAT_COUNTER					170
#define NNTP_CMDS_XREPLIC_COUNTER				172
#define NNTP_CMDS_PERSEC_CHECK_COUNTER			174
#define NNTP_CMDS_PERSEC_TAKETHIS_COUNTER		176
#define NNTP_CMDS_PERSEC_MODE_COUNTER			178
#define NNTP_CMDS_PERSEC_SEARCH_COUNTER			180
#define NNTP_CMDS_PERSEC_XHDR_COUNTER			182
#define NNTP_CMDS_PERSEC_XOVER_COUNTER			184
#define NNTP_CMDS_PERSEC_XPAT_COUNTER			186
#define NNTP_CMDS_PERSEC_XREPLIC_COUNTER		188

#endif  // _NNTPCTRS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\nntp\nntpapi\nntpstub.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    infostub.c

Abstract:

    Client stubs of the Internet Info Server Admin APIs.

Author:

    Madan Appiah (madana) 10-Oct-1993

Environment:

    User Mode - Win32

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <nntpsvc.h>


NET_API_STATUS
NET_API_FUNCTION
NntpGetAdminInformation(
    IN LPWSTR ServerName OPTIONAL,
    IN DWORD  InstanceId,
    OUT LPNNTP_CONFIG_INFO * pConfig
    )
/*++

Routine Description:

    This is the DLL entrypoint for NntpGetAdminInformation

Arguments:

    servername --A pointer to an ASCIIZ string containing the name of
        the remote server on which the function is to execute. A NULL
        pointer or string specifies the local machine.

    pConfig -- On return a pointer to the return information structure
        is returned in the address pointed to by pConfig

Return Value:

--*/

{
    NET_API_STATUS              apiStatus;

    *pConfig = NULL;     // Must be NULL so RPC knows to fill it in.

    RpcTryExcept

       apiStatus = NntprGetAdminInformation(
                ServerName,
				InstanceId,
                (LPI_NNTP_CONFIG_INFO*)pConfig
                );

    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
        apiStatus = RpcExceptionCode( );
    RpcEndExcept

    return(apiStatus);

} // NntpGetAdminInformation

NET_API_STATUS
NET_API_FUNCTION
NntpSetAdminInformation(
    IN LPWSTR ServerName OPTIONAL,
    IN DWORD  InstanceId,
    IN LPNNTP_CONFIG_INFO pConfig,
    OUT LPDWORD pParmError OPTIONAL
    )
/*++

Routine Description:

    This is the DLL entrypoint for NntpSetAdminInformation

Arguments:

    servername --A pointer to an ASCIIZ string containing the name of
        the remote server on which the function is to execute. A NULL
        pointer or string specifies the local machine.

    pConfig -- A pointer to the config info structure used to set
        the admin information.

    pParmError - If ERROR_INVALID_PARAMETER is returned, will point to the
        offending parameter.

Return Value:

--*/

{
    NET_API_STATUS              apiStatus;

    RpcTryExcept

       apiStatus = NntprSetAdminInformation(
                ServerName,
				InstanceId,
                (LPI_NNTP_CONFIG_INFO)pConfig,
                pParmError
                );

    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
        apiStatus = RpcExceptionCode( );
    RpcEndExcept

    return(apiStatus);

} // NntpSetAdminInformation

NET_API_STATUS
NET_API_FUNCTION
NntpQueryStatistics(
    IN  LPWSTR      servername,
    IN  DWORD       level,
    OUT LPBYTE      *bufptr
    )
/*++

Routine Description:

    This is the DLL entrypoint for NntpGetStatistics

Arguments:

    servername --A pointer to an ASCIIZ string containing the name of
        the remote server on which the function is to execute. A NULL
        pointer or string specifies the local machine.

    level --Level of information required. 100, 101 and 102 are valid
        for all platforms. 302, 402, 403, 502 are valid for the
        appropriate platform.

    bufptr --On return a pointer to the return information structure
        is returned in the address pointed to by bufptr.

Return Value:

--*/

{
    NET_API_STATUS              apiStatus;

    *bufptr = NULL;     // Must be NULL so RPC knows to fill it in.

    RpcTryExcept

       apiStatus = NntprQueryStatistics(
                                servername,
                                level,
                                (LPNNTP_STATISTICS_BLOCK_ARRAY *) bufptr
                                );

    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
        apiStatus = RpcExceptionCode( );
    RpcEndExcept

    return(apiStatus);

} // NntpQueryStatistics

NET_API_STATUS
NET_API_FUNCTION
NntpClearStatistics(
    IN LPWSTR Server OPTIONAL,
    IN DWORD  InstanceId
    )
{
    NET_API_STATUS status;

    RpcTryExcept
    {
        //
        // Try RPC (local or remote) version of API.
        //
        status = NntpClearStatistics(
						Server,
						InstanceId
						);
    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
    {
        status = RpcExceptionCode();
    }
    RpcEndExcept

    return (status);

} // NntpClearStatistics

NET_API_STATUS
NET_API_FUNCTION
NntpEnumerateFeeds (
    IN  LPWSTR ServerName,
    IN	DWORD  InstanceId,
    OUT LPDWORD EntriesRead,
    OUT LPNNTP_FEED_INFO *Buffer
    )

/*++

Routine Description:

    This is the DLL entrypoint for NntpEnumerateFeeds

Arguments:

Return Value:

--*/

{
    NET_API_STATUS apiStatus;
    NNTP_FEED_ENUM_STRUCT EnumStruct;

	ZeroMemory( &EnumStruct, sizeof( EnumStruct ) ) ;

    RpcTryExcept

        apiStatus = NntprEnumerateFeeds(
                                ServerName,
								InstanceId,
                                &EnumStruct
                                );

        *EntriesRead = EnumStruct.EntriesRead;
        *Buffer = (LPNNTP_FEED_INFO)EnumStruct.Buffer;

    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
        apiStatus = RpcExceptionCode( );
    RpcEndExcept

    return(apiStatus);

} // NntpEnumerateFeeds

NET_API_STATUS
NET_API_FUNCTION
NntpEnableFeed(
	IN	NNTP_HANDLE		ServerName,
    IN	DWORD			InstanceId,
	IN	DWORD			FeedId,
	IN	BOOL			Enable,
	IN	BOOL			Refill,
	IN	FILETIME		RefillTime
	)
{

    NET_API_STATUS apiStatus;

    RpcTryExcept

        apiStatus = NntprEnableFeed(
                                    ServerName,
									InstanceId,
                                    FeedId,
									Enable,
									Refill,
									RefillTime
                                    );

    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
        apiStatus = RpcExceptionCode( );
    RpcEndExcept

    return(apiStatus);
}

NET_API_STATUS
NET_API_FUNCTION
NntpGetFeedInformation(
    IN LPWSTR ServerName,
    IN DWORD  InstanceId,
    IN DWORD FeedId,
    OUT LPNNTP_FEED_INFO *Buffer
    )

/*++

Routine Description:

    This is the DLL entrypoint for NntpGetFeedInformation

Arguments:

Return Value:

--*/

{
    NET_API_STATUS apiStatus;
    LPI_FEED_INFO feedInfo;

    RpcTryExcept

        apiStatus = NntprGetFeedInformation(
                                    ServerName,
									InstanceId,
                                    FeedId,
                                    &feedInfo
                                    );

        *Buffer = (LPNNTP_FEED_INFO)feedInfo;

    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
        apiStatus = RpcExceptionCode( );
    RpcEndExcept

    return(apiStatus);

} // NntpGetFeedInformation

NET_API_STATUS
NET_API_FUNCTION
NntpSetFeedInformation(
    IN LPWSTR ServerName OPTIONAL,
    IN DWORD  InstanceId,
    IN LPNNTP_FEED_INFO FeedInfo,
    OUT LPDWORD ParmErr OPTIONAL
    )

/*++

Routine Description:

    This is the DLL entrypoint for NntpSetFeedInformation

Arguments:

Return Value:

--*/

{
    NET_API_STATUS apiStatus;

    RpcTryExcept

        apiStatus = NntprSetFeedInformation(
                                    ServerName,
									InstanceId,
                                    (LPI_FEED_INFO)FeedInfo,
                                    ParmErr
                                    );

    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
        apiStatus = RpcExceptionCode( );
    RpcEndExcept

    return(apiStatus);

} // NntpSetFeedInformation

NET_API_STATUS
NET_API_FUNCTION
NntpAddFeed(
    IN LPWSTR ServerName OPTIONAL,
    IN DWORD  InstanceId,
    IN LPNNTP_FEED_INFO FeedInfo,
    OUT LPDWORD ParmErr OPTIONAL,
	OUT LPDWORD pdwFeedId
    )

/*++

Routine Description:

    This is the DLL entrypoint for NntpAddFeed

Arguments:

Return Value:

--*/

{
    NET_API_STATUS apiStatus;

    RpcTryExcept

        apiStatus = NntprAddFeed(
                            ServerName,
							InstanceId,
                            (LPI_FEED_INFO)FeedInfo,
                            ParmErr,
							pdwFeedId
                            );

    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
        apiStatus = RpcExceptionCode( );
    RpcEndExcept

    return(apiStatus);

} // NntpAddFeed

NET_API_STATUS
NET_API_FUNCTION
NntpDeleteFeed(
    IN LPWSTR ServerName OPTIONAL,
    IN DWORD  InstanceId,
    IN DWORD FeedId
    )

/*++

Routine Description:

    This is the DLL entrypoint for NntpDeleteFeed

Arguments:

Return Value:

--*/

{
    NET_API_STATUS apiStatus;

    RpcTryExcept

        apiStatus = NntprDeleteFeed(
                            ServerName,
							InstanceId,
                            FeedId
                            );

    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
        apiStatus = RpcExceptionCode( );
    RpcEndExcept

    return(apiStatus);

} // NntpAddFeed

NET_API_STATUS
NET_API_FUNCTION
NntpEnumerateSessions (
    IN  LPWSTR ServerName,
    IN	DWORD  InstanceId,
    OUT LPDWORD EntriesRead,
    OUT LPNNTP_SESSION_INFO *Buffer
    )

/*++

Routine Description:

    This is the DLL entrypoint for NntpEnumerateSessions

Arguments:

Return Value:

--*/

{
    NET_API_STATUS apiStatus;
    NNTP_SESS_ENUM_STRUCT EnumStruct;

    RpcTryExcept

        apiStatus = NntprEnumerateSessions(
                                ServerName,
								InstanceId,
                                &EnumStruct
                                );

        *EntriesRead = EnumStruct.EntriesRead;
        *Buffer = (LPNNTP_SESSION_INFO)EnumStruct.Buffer;

    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
        apiStatus = RpcExceptionCode( );
    RpcEndExcept

    return(apiStatus);

} // NntpEnumerateSessions

NET_API_STATUS
NET_API_FUNCTION
NntpTerminateSession (
    IN  LPWSTR ServerName,
    IN	DWORD  InstanceId,
    IN  LPSTR UserName,
    IN  LPSTR IPAddress
    )

/*++

Routine Description:

    This is the DLL entrypoint for NntpTerminateSession

Arguments:

Return Value:

--*/

{
    NET_API_STATUS apiStatus;

    RpcTryExcept

        apiStatus = NntprTerminateSession(
                                ServerName,
								InstanceId,
                                UserName,
                                IPAddress
                                );

    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
        apiStatus = RpcExceptionCode( );
    RpcEndExcept

    return(apiStatus);

} // NntpTerminateSession



NET_API_STATUS
NET_API_FUNCTION
NntpEnumerateExpires(
	IN	NNTP_HANDLE		ServerName,
    IN	DWORD			InstanceId,
	OUT	LPDWORD			EntriesRead,
	OUT	LPNNTP_EXPIRE_INFO*	Buffer
	)
/*++

Routine Description :

	This is the DLL entrypoint for NntpEnumerateExpires

Arguments :

Return Value :


--*/
{
    NET_API_STATUS apiStatus;
    NNTP_EXPIRE_ENUM_STRUCT	EnumStruct ;

	ZeroMemory( &EnumStruct, sizeof( EnumStruct ) ) ;

    RpcTryExcept

        apiStatus = NntprEnumerateExpires(
                                ServerName,
								InstanceId,
                                &EnumStruct
                                );

        *EntriesRead = EnumStruct.EntriesRead;
        *Buffer = (LPNNTP_EXPIRE_INFO)EnumStruct.Buffer;

    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
        apiStatus = RpcExceptionCode( );
    RpcEndExcept

    return(apiStatus);


}	// NntpEnumerateExpires

NET_API_STATUS
NET_API_FUNCTION
NntpAddExpire(
	IN	NNTP_HANDLE			ServerName,
    IN	DWORD				InstanceId,
	IN	LPNNTP_EXPIRE_INFO	ExpireInfo,
	OUT	LPDWORD				ParmErr	OPTIONAL,
	OUT LPDWORD				pdwExpireId
	)
/*++

Routine Description :

	This is the DLL entrypoint for NntpAddExpire

Arguments :

Return Value :


--*/
{
	NET_API_STATUS apiStatus;

    RpcTryExcept

        apiStatus = NntprAddExpire(
                            ServerName,
							InstanceId,
                            (LPI_EXPIRE_INFO)ExpireInfo,
                            ParmErr,
							pdwExpireId
                            );

    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
        apiStatus = RpcExceptionCode( );
    RpcEndExcept

    return(apiStatus);
}	// NntpAddExpire

NET_API_STATUS
NET_API_FUNCTION
NntpDeleteExpire(
	IN	NNTP_HANDLE			ServerName,
    IN	DWORD				InstanceId,
	IN	DWORD				ExpireId
	)
/*++

Routine Description :

	This is the DLL entrypoint for NntpDeleteExpire

Arguments :

Return Value :


--*/

{
	NET_API_STATUS apiStatus;

    RpcTryExcept

        apiStatus = NntprDeleteExpire(
                            ServerName,
							InstanceId,
                            ExpireId
                            );

    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
        apiStatus = RpcExceptionCode( );
    RpcEndExcept

    return(apiStatus);
}	// NntpDeleteExpire

NET_API_STATUS
NET_API_FUNCTION
NntpGetExpireInformation(
	IN	NNTP_HANDLE			ServerName,
    IN	DWORD				InstanceId,
	IN	DWORD				ExpireId,
	OUT	LPNNTP_EXPIRE_INFO	*Buffer
	)
/*++

Routine Description :

	This is the DLL entrypoint for NntpGetExpireInformation

Arguments :

Return Value :


--*/

{

	NET_API_STATUS apiStatus;
    LPI_EXPIRE_INFO	ExpireInfo;
    NNTP_EXPIRE_ENUM_STRUCT	EnumStruct ;

	ZeroMemory( &EnumStruct, sizeof( EnumStruct ) ) ;


    RpcTryExcept

/*
        apiStatus = NntprGetExpireInformation(
                                    ServerName,
                                    ExpireId,
                                    &ExpireInfo
                                    );

        *Buffer = (LPNNTP_EXPIRE_INFO)ExpireInfo;
*/

        apiStatus = NntprGetExpireInformation(
                                ServerName,
								InstanceId,
								ExpireId,
                                &EnumStruct
                                );

        if( EnumStruct.EntriesRead > 0 ) {
			*Buffer = (LPNNTP_EXPIRE_INFO)EnumStruct.Buffer;
		}	else	{
			*Buffer = 0 ;
		}

    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
        apiStatus = RpcExceptionCode( );
    RpcEndExcept

    return(apiStatus);


}	//	NntpGetExpireInformation

NET_API_STATUS
NET_API_FUNCTION
NntpSetExpireInformation(
	IN	NNTP_HANDLE			ServerName	OPTIONAL,
    IN	DWORD				InstanceId,
	IN	LPNNTP_EXPIRE_INFO	ExpireInfo,
	OUT	LPDWORD				ParmErr	OPTIONAL
	)
/*++

Routine Description :

	This is the DLL entrypoint for NntpSetExpireInformation

Arguments :

Return Value :


--*/
{
    NET_API_STATUS apiStatus;

    RpcTryExcept

        apiStatus = NntprSetExpireInformation(
                                    ServerName,
									InstanceId,
                                    (LPI_EXPIRE_INFO)ExpireInfo,
                                    ParmErr
                                    );

    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
        apiStatus = RpcExceptionCode( );
    RpcEndExcept

    return(apiStatus);

}	// NntpSetExpireInformation


NET_API_STATUS
NET_API_FUNCTION
NntpGetNewsgroup(
	IN	NNTP_HANDLE			ServerName	OPTIONAL,
    IN	DWORD				InstanceId,
	IN OUT	LPNNTP_NEWSGROUP_INFO	*NewsgroupInfo
	)
/*++

Routine Description :

	This is the DLL entrypoint for NntpGetExpireInformation

Arguments :

Return Value :


--*/

{

	NET_API_STATUS apiStatus;

    RpcTryExcept


        apiStatus = NntprGetNewsgroup(
                                ServerName,
								InstanceId,
								(LPI_NEWSGROUP_INFO*)NewsgroupInfo
                                );

    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
        apiStatus = RpcExceptionCode( );
    RpcEndExcept

    return(apiStatus);


}	//	NntpGetNewsgroup

NET_API_STATUS
NET_API_FUNCTION
NntpSetNewsgroup(
	IN	NNTP_HANDLE				ServerName	OPTIONAL,
    IN	DWORD					InstanceId,
	IN	LPNNTP_NEWSGROUP_INFO	NewsgroupInfo
	)
/*++

Routine Description :

	This is the DLL entrypoint for NntpGetExpireInformation

Arguments :

Return Value :


--*/

{

	NET_API_STATUS apiStatus;

    RpcTryExcept


        apiStatus = NntprSetNewsgroup(
                                ServerName,
								InstanceId,
								(LPI_NEWSGROUP_INFO)NewsgroupInfo
                                );

    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
        apiStatus = RpcExceptionCode( );
    RpcEndExcept

    return(apiStatus);


}	//	NntpSetNewsgroup


NET_API_STATUS
NET_API_FUNCTION
NntpCreateNewsgroup(
	IN	NNTP_HANDLE				ServerName	OPTIONAL,
    IN	DWORD					InstanceId,
	IN	LPNNTP_NEWSGROUP_INFO	NewsgroupInfo
	)
/*++

Routine Description :

	This is the DLL entrypoint for NntpSetExpireInformation

Arguments :

Return Value :


--*/
{
    NET_API_STATUS apiStatus;

    RpcTryExcept

        apiStatus = NntprCreateNewsgroup(
                                ServerName,
								InstanceId,
								(LPI_NEWSGROUP_INFO)NewsgroupInfo
                                );

    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
        apiStatus = RpcExceptionCode( );
    RpcEndExcept

    return(apiStatus);

}	// NntpCreateNewsgroup


NET_API_STATUS
NET_API_FUNCTION
NntpDeleteNewsgroup(
	IN	NNTP_HANDLE				ServerName	OPTIONAL,
    IN DWORD					InstanceId,
	IN	LPNNTP_NEWSGROUP_INFO	NewsgroupInfo
	)
/*++

Routine Description :

	This is the DLL entrypoint for NntpSetExpireInformation

Arguments :

Return Value :


--*/
{
    NET_API_STATUS apiStatus;

    RpcTryExcept

        apiStatus = NntprDeleteNewsgroup(
                                ServerName,
								InstanceId,
								(LPI_NEWSGROUP_INFO)NewsgroupInfo
                                );



    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
        apiStatus = RpcExceptionCode( );
    RpcEndExcept

    return(apiStatus);

}	// NntpDeleteNewsgroup

NET_API_STATUS
NET_API_FUNCTION
NntpFindNewsgroup(
	IN	NNTP_HANDLE			ServerName,
    IN	DWORD				InstanceId,
	IN	NNTP_HANDLE			NewsgroupPrefix,
	IN	DWORD				MaxResults,
	OUT	LPDWORD				pdwResultsFound,
	OUT LPNNTP_FIND_LIST    *ppFindList
	)
/*++

Routine Description :

	This is the DLL entrypoint for NntpFindNewsgroup

Arguments :

Return Value :


--*/

{
	NET_API_STATUS apiStatus;

	*ppFindList = NULL;

    RpcTryExcept


        apiStatus = NntprFindNewsgroup(
                                ServerName,
								InstanceId,
								NewsgroupPrefix,
								MaxResults,
								pdwResultsFound,
								ppFindList
                                );

    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
        apiStatus = RpcExceptionCode( );
    RpcEndExcept

    return(apiStatus);

}	//	NntpFindNewsgroup

NET_API_STATUS
NET_API_FUNCTION
NntpStartRebuild(
    IN LPWSTR pszServer OPTIONAL,
    IN DWORD  InstanceId,
    IN LPNNTPBLD_INFO pBuildInfo,
    OUT LPDWORD pParmError OPTIONAL
    )
/*++

Routine Description:

    This is the DLL entrypoint for NntpStartRebuild

Arguments:

    servername --A pointer to an ASCIIZ string containing the name of
        the remote server on which the function is to execute. A NULL
        pointer or string specifies the local machine.

    pConfig -- A pointer to the config info structure used to set
        the rebuild information.

    pParmError - If ERROR_INVALID_PARAMETER is returned, will point to the
        offending parameter.

Return Value:

--*/

{
    NET_API_STATUS              apiStatus;

    RpcTryExcept

       apiStatus = NntprStartRebuild(
                pszServer,
				InstanceId,
                (LPI_NNTPBLD_INFO)pBuildInfo,
                pParmError
                );

    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
        apiStatus = RpcExceptionCode( );
    RpcEndExcept

    return(apiStatus);

} // NntpStartRebuild

NET_API_STATUS
NET_API_FUNCTION
NntpGetBuildStatus(
    IN LPWSTR ServerName OPTIONAL,
    IN DWORD  InstanceId,
	IN BOOL   fCancel,
    OUT LPDWORD pdwProgress
    )
/*++

Routine Description:

    This is the DLL entrypoint for NntpGetBuildStatus

Arguments:

    servername --A pointer to an ASCIIZ string containing the name of
        the remote server on which the function is to execute. A NULL
        pointer or string specifies the local machine.

	fCancel		-- If TRUE, cancel the rebuild
	pdwProgress -- pointer to progress number

Return Value:

--*/

{
    NET_API_STATUS              apiStatus;

    RpcTryExcept

       apiStatus = NntprGetBuildStatus(
							ServerName,
							InstanceId,
							fCancel,
							pdwProgress
							);

    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
        apiStatus = RpcExceptionCode( );
    RpcEndExcept

    return(apiStatus);

} // NntpGetBuildStatus

#if 0
NET_API_STATUS
NET_API_FUNCTION
NntpAddDropNewsgroup(
    IN LPWSTR ServerName OPTIONAL,
    IN DWORD  InstanceId,
    IN LPCSTR  szNewsgroup
    )
{
    NET_API_STATUS              apiStatus;

    RpcTryExcept

       apiStatus = NntprAddDropNewsgroup(
                ServerName,
				InstanceId,
                szNewsgroup
                );

    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
        apiStatus = RpcExceptionCode( );
    RpcEndExcept

    return(apiStatus);

}

NET_API_STATUS
NET_API_FUNCTION
NntpRemoveDropNewsgroup(
    IN LPWSTR ServerName OPTIONAL,
    IN DWORD  InstanceId,
    IN LPCSTR  szNewsgroup
    )
{
    NET_API_STATUS              apiStatus;

    RpcTryExcept

       apiStatus = NntprRemoveDropNewsgroup(
                ServerName,
				InstanceId,
                szNewsgroup
                );

    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
        apiStatus = RpcExceptionCode( );
    RpcEndExcept

    return(apiStatus);

}
#endif

NET_API_STATUS
NET_API_FUNCTION
NntpCancelMessageID(
    IN LPWSTR ServerName OPTIONAL,
    IN DWORD  InstanceId,
    IN LPCSTR  szMessageID
    )
{
    NET_API_STATUS              apiStatus;

    RpcTryExcept

       apiStatus = NntprCancelMessageID(
                ServerName,
				InstanceId,
                szMessageID
                );

    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
        apiStatus = RpcExceptionCode( );
    RpcEndExcept

    return(apiStatus);

}

NET_API_STATUS
NET_API_FUNCTION
NntpGetVRootWin32Error(
    IN LPWSTR   wszServername,
    IN DWORD    InstanceId,
    IN LPWSTR   wszVRootPath,
    OUT LPDWORD  pdwWin32Error
     )
{
    NET_API_STATUS              apiStatus;

    RpcTryExcept

       apiStatus = NntprGetVRootWin32Error(
                wszServername,
				InstanceId,
                wszVRootPath,
                pdwWin32Error
                );

    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
        apiStatus = RpcExceptionCode( );
    RpcEndExcept

    return(apiStatus);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\nntp\nntpctrs\nntpdata.c ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1993                **/
/**********************************************************************/

/*
    nntpdata.c

    Constant data structures for the NNTP Server's counter objects &
    counters.


    FILE HISTORY:
        KeithMo     07-Jun-1993 Created.

*/


#include <windows.h>
#include <winperf.h>
#include <nntpctrs.h>
#include <nntpdata.h>

static NNTP_COUNTER_BLOCK1	nntpc1;
static NNTP_COUNTER_BLOCK2	nntpc2;

//
//  Initialize the constant portitions of these data structure.
//  Certain parts (especially the name/help indices) will be
//  updated at initialization time.
//

NNTP_DATA_DEFINITION_OBJECT1 NntpDataDefinitionObject1 =
{
    {   // NntpObjectType
        sizeof(NNTP_DATA_DEFINITION_OBJECT1) + sizeof(NNTP_COUNTER_BLOCK1),
        sizeof(NNTP_DATA_DEFINITION_OBJECT1),
        sizeof(PERF_OBJECT_TYPE),
        NNTP_COUNTER_OBJECT1,
        0,
        NNTP_COUNTER_OBJECT1,
        0,
        PERF_DETAIL_ADVANCED,
        NUMBER_OF_NNTP_COUNTERS_OBJECT1,
        2,                              // Default = Bytes Total/sec
        PERF_NO_INSTANCES,
        0,
        { 0, 0 },
        { 0, 0 }
    },

    {   // NntpBytesSent
        sizeof(PERF_COUNTER_DEFINITION),
        NNTP_BYTES_SENT_COUNTER,
        0,
        NNTP_BYTES_SENT_COUNTER,
        0,
        -4,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_BULK_COUNT,
        sizeof(nntpc1.BytesSent),
        0 // assigned in open procedure
    },

    {   // NNTPBytesReceived
        sizeof(PERF_COUNTER_DEFINITION),
        NNTP_BYTES_RECEIVED_COUNTER,
        0,
        NNTP_BYTES_RECEIVED_COUNTER,
        0,
        -4,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_BULK_COUNT,
        sizeof(nntpc1.BytesReceived),
        0 // assigned in open procedure
    },

    {   // NNTPBytesTotal
        sizeof(PERF_COUNTER_DEFINITION),
        NNTP_BYTES_TOTAL_COUNTER,
        0,
        NNTP_BYTES_TOTAL_COUNTER,
        0,
        -4,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_BULK_COUNT,
        sizeof(nntpc1.BytesTotal),
        0 // assigned in open procedure
    },

    {   // NntpTotalConnections
        sizeof(PERF_COUNTER_DEFINITION),
        NNTP_TOTAL_CONNECTIONS_COUNTER,
        0,
        NNTP_TOTAL_CONNECTIONS_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(nntpc1.TotalConnections),
        0 // assigned in open procedure
    },

    {   // NntpTotalSSLConnections
        sizeof(PERF_COUNTER_DEFINITION),
        NNTP_TOTAL_SSL_CONNECTIONS_COUNTER,
        0,
        NNTP_TOTAL_SSL_CONNECTIONS_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(nntpc1.TotalSSLConnections),
        0 // assigned in open procedure
    },

    {   // NntpCurrentConnections
        sizeof(PERF_COUNTER_DEFINITION),
        NNTP_CURRENT_CONNECTIONS_COUNTER,
        0,
        NNTP_CURRENT_CONNECTIONS_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(nntpc1.CurrentConnections),
        0 // assigned in open procedure
    },

    {   // NntpMaxConnections
        sizeof(PERF_COUNTER_DEFINITION),
        NNTP_MAX_CONNECTIONS_COUNTER,
        0,
        NNTP_MAX_CONNECTIONS_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(nntpc1.MaxConnections),
        0 // assigned in open procedure
    },

    {   // NntpCurrentAnonymous
        sizeof(PERF_COUNTER_DEFINITION),
        NNTP_CURRENT_ANONYMOUS_COUNTER,
        0,
        NNTP_CURRENT_ANONYMOUS_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(nntpc1.CurrentAnonymous),
        0 // assigned in open procedure
    },

    {   // NntpCurrentNonAnonymous
        sizeof(PERF_COUNTER_DEFINITION),
        NNTP_CURRENT_NONANONYMOUS_COUNTER,
        0,
        NNTP_CURRENT_NONANONYMOUS_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(nntpc1.CurrentNonAnonymous),
        0 // assigned in open procedure
    },

    {   // NntpTotalAnonymous
        sizeof(PERF_COUNTER_DEFINITION),
        NNTP_TOTAL_ANONYMOUS_COUNTER,
        0,
        NNTP_TOTAL_ANONYMOUS_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(nntpc1.TotalAnonymous),
        0 // assigned in open procedure
    },

    {   // NntpTotalNonAnonymous
        sizeof(PERF_COUNTER_DEFINITION),
        NNTP_TOTAL_NONANONYMOUS_COUNTER,
        0,
        NNTP_TOTAL_NONANONYMOUS_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(nntpc1.TotalNonAnonymous),
        0 // assigned in open procedure
    },

    {   // NntpMaxAnonymous
        sizeof(PERF_COUNTER_DEFINITION),
        NNTP_MAX_ANONYMOUS_COUNTER,
        0,
        NNTP_MAX_ANONYMOUS_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(nntpc1.MaxAnonymous),
        0 // assigned in open procedure
    },

    {   // NntpMaxNonAnonymous
        sizeof(PERF_COUNTER_DEFINITION),
        NNTP_MAX_NONANONYMOUS_COUNTER,
        0,
        NNTP_MAX_NONANONYMOUS_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(nntpc1.MaxNonAnonymous),
        0 // assigned in open procedure
    },

    {   // NntpTotalOutboundConnects
        sizeof(PERF_COUNTER_DEFINITION),
        NNTP_TOTAL_OUTBOUND_CONNECTS_COUNTER,
        0,
        NNTP_TOTAL_OUTBOUND_CONNECTS_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(nntpc1.TotalOutboundConnects),
        0 // assigned in open procedure
    },

    {   // NntpOutboundConnectsFailed
        sizeof(PERF_COUNTER_DEFINITION),
        NNTP_OUTBOUND_CONNECTS_FAILED_COUNTER,
        0,
        NNTP_OUTBOUND_CONNECTS_FAILED_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(nntpc1.OutboundConnectsFailed),
        0 // assigned in open procedure
    },

    {   // NntpCurrentOutboundConnects
        sizeof(PERF_COUNTER_DEFINITION),
        NNTP_CURRENT_OUTBOUND_CONNECTS_COUNTER,
        0,
        NNTP_CURRENT_OUTBOUND_CONNECTS_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(nntpc1.CurrentOutboundConnects),
        0 // assigned in open procedure
    },

    {   // NntpOutboundLogonFailed
        sizeof(PERF_COUNTER_DEFINITION),
        NNTP_OUTBOUND_LOGON_FAILED_COUNTER,
        0,
        NNTP_OUTBOUND_LOGON_FAILED_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(nntpc1.OutboundLogonFailed),
        0 // assigned in open procedure
    },

    {   // NNTPPullFeeds
        sizeof(PERF_COUNTER_DEFINITION),
        NNTP_TOTAL_PULL_FEEDS_COUNTER,
        0,
        NNTP_TOTAL_PULL_FEEDS_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(nntpc1.TotalPullFeeds),
        0 // assigned in open procedure
    },

    {   // NNTPPushFeeds
        sizeof(PERF_COUNTER_DEFINITION),
        NNTP_TOTAL_PUSH_FEEDS_COUNTER,
        0,
        NNTP_TOTAL_PUSH_FEEDS_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(nntpc1.TotalPushFeeds),
        0 // assigned in open procedure
    },

    {   // NNTPPassiveFeeds
        sizeof(PERF_COUNTER_DEFINITION),
        NNTP_TOTAL_PASSIVE_FEEDS_COUNTER,
        0,
        NNTP_TOTAL_PASSIVE_FEEDS_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(nntpc1.TotalPassiveFeeds),
        0 // assigned in open procedure
    },

    {   // NntpArticlesSent
        sizeof(PERF_COUNTER_DEFINITION),
        NNTP_ARTICLES_SENT_COUNTER,
        0,
        NNTP_ARTICLES_SENT_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(nntpc1.ArticlesSent),
        0 // assigned in open procedure
    },

    {   // NntpArticlesReceived
        sizeof(PERF_COUNTER_DEFINITION),
        NNTP_ARTICLES_RECEIVED_COUNTER,
        0,
        NNTP_ARTICLES_RECEIVED_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(nntpc1.ArticlesReceived),
        0 // assigned in open procedure
    },

    {   // NntpArticlesTotal
        sizeof(PERF_COUNTER_DEFINITION),
        NNTP_ARTICLES_TOTAL_COUNTER,
        0,
        NNTP_ARTICLES_TOTAL_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(nntpc1.ArticlesTotal),
        0 // assigned in open procedure
    },

    {   // ArticlesPosted
        sizeof(PERF_COUNTER_DEFINITION),
        NNTP_ARTICLES_POSTED_COUNTER,
        0,
        NNTP_ARTICLES_POSTED_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(nntpc1.ArticlesPosted),
        0 // assigned in open procedure
    },

    {   // ArticleMapEntries
        sizeof(PERF_COUNTER_DEFINITION),
        NNTP_ARTICLE_MAP_ENTRIES_COUNTER,
        0,
        NNTP_ARTICLE_MAP_ENTRIES_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(nntpc1.ArticleMapEntries),
        0 // assigned in open procedure
    },

    {   // HistoryMapEntries
        sizeof(PERF_COUNTER_DEFINITION),
        NNTP_HISTORY_MAP_ENTRIES_COUNTER,
        0,
        NNTP_HISTORY_MAP_ENTRIES_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(nntpc1.HistoryMapEntries),
        0 // assigned in open procedure
    },

    {   // XoverEntries
        sizeof(PERF_COUNTER_DEFINITION),
        NNTP_XOVER_ENTRIES_COUNTER,
        0,
        NNTP_XOVER_ENTRIES_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(nntpc1.XoverEntries),
        0 // assigned in open procedure
    },

	{   // ControlMessagesIn
        sizeof(PERF_COUNTER_DEFINITION),
        NNTP_CONTROL_MSGS_IN_COUNTER,
        0,
        NNTP_CONTROL_MSGS_IN_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(nntpc1.ControlMessagesIn),
        0 // assigned in open procedure
    },

    {   // ControlMessagesFailed
        sizeof(PERF_COUNTER_DEFINITION),
        NNTP_CONTROL_MSGS_FAILED_COUNTER,
        0,
        NNTP_CONTROL_MSGS_FAILED_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(nntpc1.ControlMessagesFailed),
        0 // assigned in open procedure
    },

    {   // ModeratedPostingsSent
        sizeof(PERF_COUNTER_DEFINITION),
        NNTP_MODERATED_POSTINGS_SENT_COUNTER,
        0,
        NNTP_MODERATED_POSTINGS_SENT_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(nntpc1.ModeratedPostingsSent),
        0 // assigned in open procedure
    },

	{   // ModeratedPostingsFailed
        sizeof(PERF_COUNTER_DEFINITION),
        NNTP_MODERATED_POSTINGS_FAILED_COUNTER,
        0,
        NNTP_MODERATED_POSTINGS_FAILED_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(nntpc1.ModeratedPostingsFailed),
        0 // assigned in open procedure
    },

    {   // SessionsFlowControlled
        sizeof(PERF_COUNTER_DEFINITION),
        NNTP_SESS_FLOW_CONTROL_COUNTER,
        0,
        NNTP_SESS_FLOW_CONTROL_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(nntpc1.SessionsFlowControlled),
        0 // assigned in open procedure
    },

    {   // ArticlesExpired
        sizeof(PERF_COUNTER_DEFINITION),
        NNTP_ARTICLES_EXPIRED_COUNTER,
        0,
        NNTP_ARTICLES_EXPIRED_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(nntpc1.ArticlesExpired),
        0 // assigned in open procedure
    },

    {   // NntpArticlesSentPerSec
        sizeof(PERF_COUNTER_DEFINITION),
        NNTP_ARTICLES_SENT_PERSEC_COUNTER,
        0,
        NNTP_ARTICLES_SENT_PERSEC_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(nntpc1.ArticlesSentPerSec),
        0 // assigned in open procedure
    },

    {   // NntpArticlesReceivedPerSec
        sizeof(PERF_COUNTER_DEFINITION),
        NNTP_ARTICLES_RECEIVED_PERSEC_COUNTER,
        0,
        NNTP_ARTICLES_RECEIVED_PERSEC_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(nntpc1.ArticlesReceivedPerSec),
        0 // assigned in open procedure
    },

    {   // ArticlesPostedPerSec
        sizeof(PERF_COUNTER_DEFINITION),
        NNTP_ARTICLES_POSTED_PERSEC_COUNTER,
        0,
        NNTP_ARTICLES_POSTED_PERSEC_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(nntpc1.ArticlesPostedPerSec),
        0 // assigned in open procedure
    },

    {   // ArticleMapEntriesPerSec
        sizeof(PERF_COUNTER_DEFINITION),
        NNTP_ARTICLE_MAP_ENTRIES_PERSEC_COUNTER,
        0,
        NNTP_ARTICLE_MAP_ENTRIES_PERSEC_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(nntpc1.ArticleMapEntriesPerSec),
        0 // assigned in open procedure
    },

    {   // HistoryMapEntriesPerSec
        sizeof(PERF_COUNTER_DEFINITION),
        NNTP_HISTORY_MAP_ENTRIES_PERSEC_COUNTER,
        0,
        NNTP_HISTORY_MAP_ENTRIES_PERSEC_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(nntpc1.HistoryMapEntriesPerSec),
        0 // assigned in open procedure
    },

    {   // XoverEntriesPerSec
        sizeof(PERF_COUNTER_DEFINITION),
        NNTP_XOVER_ENTRIES_PERSEC_COUNTER,
        0,
        NNTP_XOVER_ENTRIES_PERSEC_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(nntpc1.XoverEntriesPerSec),
        0 // assigned in open procedure
    },

    {   // ArticlesExpiredPerSec
        sizeof(PERF_COUNTER_DEFINITION),
        NNTP_ARTICLES_EXPIRED_PERSEC_COUNTER,
        0,
        NNTP_ARTICLES_EXPIRED_PERSEC_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(nntpc1.ArticlesExpiredPerSec),
        0 // assigned in open procedure
    }
};


//
//  Initialize the constant portitions of these data structure.
//  Certain parts (especially the name/help indices) will be
//  updated at initialization time.
//

NNTP_DATA_DEFINITION_OBJECT2 NntpDataDefinitionObject2 =
{
    {   // NntpObjectType
        sizeof(NNTP_DATA_DEFINITION_OBJECT2) + sizeof(NNTP_COUNTER_BLOCK2),
        sizeof(NNTP_DATA_DEFINITION_OBJECT2),
        sizeof(PERF_OBJECT_TYPE),
        NNTP_COUNTER_OBJECT2,
        0,
        NNTP_COUNTER_OBJECT2,
        0,
        PERF_DETAIL_ADVANCED,
        NUMBER_OF_NNTP_COUNTERS_OBJECT2,
        2,                              // Default = GroupCommands
        PERF_NO_INSTANCES,
        0,
        { 0, 0 },
        { 0, 0 }
    },

    {   // ArticleCommands
        sizeof(PERF_COUNTER_DEFINITION),
        NNTP_CMDS_ARTICLE_COUNTER,
        0,
        NNTP_CMDS_ARTICLE_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(nntpc2.ArticleCmds),
        0 // assigned in open procedure
    },

    {   // ArticleCommandsPerSec
        sizeof(PERF_COUNTER_DEFINITION),
        NNTP_CMDS_PERSEC_ARTICLE_COUNTER,
        0,
        NNTP_CMDS_PERSEC_ARTICLE_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(nntpc2.ArticleCmdsPerSec),
        0 // assigned in open procedure
    },

    {   // GroupCommands
        sizeof(PERF_COUNTER_DEFINITION),
        NNTP_CMDS_GROUP_COUNTER,
        0,
        NNTP_CMDS_GROUP_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(nntpc2.GroupCmds),
        0 // assigned in open procedure
    },

    {   // GroupCommandsPerSec
        sizeof(PERF_COUNTER_DEFINITION),
        NNTP_CMDS_PERSEC_GROUP_COUNTER,
        0,
        NNTP_CMDS_PERSEC_GROUP_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(nntpc2.GroupCmdsPerSec),
        0 // assigned in open procedure
    },

    {   // HelpCommands
        sizeof(PERF_COUNTER_DEFINITION),
        NNTP_CMDS_HELP_COUNTER,
        0,
        NNTP_CMDS_HELP_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(nntpc2.HelpCmds),
        0 // assigned in open procedure
    },

    {   // HelpCommandsPerSec
        sizeof(PERF_COUNTER_DEFINITION),
        NNTP_CMDS_PERSEC_HELP_COUNTER,
        0,
        NNTP_CMDS_PERSEC_HELP_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(nntpc2.HelpCmdsPerSec),
        0 // assigned in open procedure
    },

    {   // IHaveCommands
        sizeof(PERF_COUNTER_DEFINITION),
        NNTP_CMDS_IHAVE_COUNTER,
        0,
        NNTP_CMDS_IHAVE_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(nntpc2.IHaveCmds),
        0 // assigned in open procedure
    },

    {   // IHaveCommandsPerSec
        sizeof(PERF_COUNTER_DEFINITION),
        NNTP_CMDS_PERSEC_IHAVE_COUNTER,
        0,
        NNTP_CMDS_PERSEC_IHAVE_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(nntpc2.IHaveCmdsPerSec),
        0 // assigned in open procedure
    },

    {   // LastCommands
        sizeof(PERF_COUNTER_DEFINITION),
        NNTP_CMDS_LAST_COUNTER,
        0,
        NNTP_CMDS_LAST_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(nntpc2.LastCmds),
        0 // assigned in open procedure
    },

    {   // LastCommandsPerSec
        sizeof(PERF_COUNTER_DEFINITION),
        NNTP_CMDS_PERSEC_LAST_COUNTER,
        0,
        NNTP_CMDS_PERSEC_LAST_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(nntpc2.LastCmdsPerSec),
        0 // assigned in open procedure
    },

    {   // ListCommands
        sizeof(PERF_COUNTER_DEFINITION),
        NNTP_CMDS_LIST_COUNTER,
        0,
        NNTP_CMDS_LIST_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(nntpc2.ListCmds),
        0 // assigned in open procedure
    },

    {   // ListCommandsPerSec
        sizeof(PERF_COUNTER_DEFINITION),
        NNTP_CMDS_PERSEC_LIST_COUNTER,
        0,
        NNTP_CMDS_PERSEC_LIST_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(nntpc2.ListCmdsPerSec),
        0 // assigned in open procedure
    },

    {   // NewgroupsCommands
        sizeof(PERF_COUNTER_DEFINITION),
        NNTP_CMDS_NEWGROUPS_COUNTER,
        0,
        NNTP_CMDS_NEWGROUPS_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(nntpc2.NewgroupsCmds),
        0 // assigned in open procedure
    },

    {   // NewgroupsCommandsPerSec
        sizeof(PERF_COUNTER_DEFINITION),
        NNTP_CMDS_PERSEC_NEWGROUPS_COUNTER,
        0,
        NNTP_CMDS_PERSEC_NEWGROUPS_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(nntpc2.NewgroupsCmdsPerSec),
        0 // assigned in open procedure
    },

    {   // NewnewsCommands
        sizeof(PERF_COUNTER_DEFINITION),
        NNTP_CMDS_NEWNEWS_COUNTER,
        0,
        NNTP_CMDS_NEWNEWS_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(nntpc2.NewnewsCmds),
        0 // assigned in open procedure
    },

    {   // NewnewsCommandsPerSec
        sizeof(PERF_COUNTER_DEFINITION),
        NNTP_CMDS_PERSEC_NEWNEWS_COUNTER,
        0,
        NNTP_CMDS_PERSEC_NEWNEWS_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(nntpc2.NewnewsCmdsPerSec),
        0 // assigned in open procedure
    },

    {   // NextCommands
        sizeof(PERF_COUNTER_DEFINITION),
        NNTP_CMDS_NEXT_COUNTER,
        0,
        NNTP_CMDS_NEXT_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(nntpc2.NextCmds),
        0 // assigned in open procedure
    },

    {   // NextCommandsPerSec
        sizeof(PERF_COUNTER_DEFINITION),
        NNTP_CMDS_PERSEC_NEXT_COUNTER,
        0,
        NNTP_CMDS_PERSEC_NEXT_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(nntpc2.NextCmdsPerSec),
        0 // assigned in open procedure
    },

    {   // PostCommands
        sizeof(PERF_COUNTER_DEFINITION),
        NNTP_CMDS_POST_COUNTER,
        0,
        NNTP_CMDS_POST_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(nntpc2.PostCmds),
        0 // assigned in open procedure
    },

    {   // PostCommandsPerSec
        sizeof(PERF_COUNTER_DEFINITION),
        NNTP_CMDS_PERSEC_POST_COUNTER,
        0,
        NNTP_CMDS_PERSEC_POST_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(nntpc2.PostCmdsPerSec),
        0 // assigned in open procedure
    },

    {   // QuitCommands
        sizeof(PERF_COUNTER_DEFINITION),
        NNTP_CMDS_QUIT_COUNTER,
        0,
        NNTP_CMDS_QUIT_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(nntpc2.QuitCmds),
        0 // assigned in open procedure
    },

    {   // QuitCommandsPerSec
        sizeof(PERF_COUNTER_DEFINITION),
        NNTP_CMDS_PERSEC_QUIT_COUNTER,
        0,
        NNTP_CMDS_PERSEC_QUIT_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(nntpc2.QuitCmdsPerSec),
        0 // assigned in open procedure
    },

    {   // StatCommands
        sizeof(PERF_COUNTER_DEFINITION),
        NNTP_CMDS_STAT_COUNTER,
        0,
        NNTP_CMDS_STAT_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(nntpc2.StatCmds),
        0 // assigned in open procedure
    },

    {   // StatCommandsPerSec
        sizeof(PERF_COUNTER_DEFINITION),
        NNTP_CMDS_PERSEC_STAT_COUNTER,
        0,
        NNTP_CMDS_PERSEC_STAT_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(nntpc2.StatCmdsPerSec),
        0 // assigned in open procedure
    },

    {   // NntpLogonAttempts
        sizeof(PERF_COUNTER_DEFINITION),
        NNTP_LOGON_ATTEMPTS_COUNTER,
        0,
        NNTP_LOGON_ATTEMPTS_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(nntpc2.LogonAttempts),
        0 // assigned in open procedure
    },

    {   // NntpLogonFailures
        sizeof(PERF_COUNTER_DEFINITION),
        NNTP_LOGON_FAILURES_COUNTER,
        0,
        NNTP_LOGON_FAILURES_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(nntpc2.LogonFailures),
        0 // assigned in open procedure
    },

    {   // NntpLogonAttemptsPerSec
        sizeof(PERF_COUNTER_DEFINITION),
        NNTP_LOGON_ATTEMPTS_PERSEC_COUNTER,
        0,
        NNTP_LOGON_ATTEMPTS_PERSEC_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(nntpc2.LogonAttemptsPerSec),
        0 // assigned in open procedure
    },

    {   // NntpLogonFailuresPerSec
        sizeof(PERF_COUNTER_DEFINITION),
        NNTP_LOGON_FAILURES_PERSEC_COUNTER,
        0,
        NNTP_LOGON_FAILURES_PERSEC_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(nntpc2.LogonFailuresPerSec),
        0 // assigned in open procedure
    },

    {   // CheckCommands
        sizeof(PERF_COUNTER_DEFINITION),
        NNTP_CMDS_CHECK_COUNTER,
        0,
        NNTP_CMDS_CHECK_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(nntpc2.CheckCmds),
        0 // assigned in open procedure
    },

    {   // CheckCommandsPerSec
        sizeof(PERF_COUNTER_DEFINITION),
        NNTP_CMDS_PERSEC_CHECK_COUNTER,
        0,
        NNTP_CMDS_PERSEC_CHECK_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(nntpc2.CheckCmdsPerSec),
        0 // assigned in open procedure
    },

    {   // TakethisCommands
        sizeof(PERF_COUNTER_DEFINITION),
        NNTP_CMDS_TAKETHIS_COUNTER,
        0,
        NNTP_CMDS_TAKETHIS_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(nntpc2.TakethisCmds),
        0 // assigned in open procedure
    },

    {   // TakethisCommandsPerSec
        sizeof(PERF_COUNTER_DEFINITION),
        NNTP_CMDS_PERSEC_TAKETHIS_COUNTER,
        0,
        NNTP_CMDS_PERSEC_TAKETHIS_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(nntpc2.TakethisCmdsPerSec),
        0 // assigned in open procedure
    },

    {   // ModeCommands
        sizeof(PERF_COUNTER_DEFINITION),
        NNTP_CMDS_MODE_COUNTER,
        0,
        NNTP_CMDS_MODE_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(nntpc2.ModeCmds),
        0 // assigned in open procedure
    },

    {   // ModeCommandsPerSec
        sizeof(PERF_COUNTER_DEFINITION),
        NNTP_CMDS_PERSEC_MODE_COUNTER,
        0,
        NNTP_CMDS_PERSEC_MODE_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(nntpc2.ModeCmdsPerSec),
        0 // assigned in open procedure
    },

    {   // SearchCommands
        sizeof(PERF_COUNTER_DEFINITION),
        NNTP_CMDS_SEARCH_COUNTER,
        0,
        NNTP_CMDS_SEARCH_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(nntpc2.SearchCmds),
        0 // assigned in open procedure
    },

    {   // SearchCommandsPerSec
        sizeof(PERF_COUNTER_DEFINITION),
        NNTP_CMDS_PERSEC_SEARCH_COUNTER,
        0,
        NNTP_CMDS_PERSEC_SEARCH_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(nntpc2.SearchCmdsPerSec),
        0 // assigned in open procedure
    },

    {   // XHdrCommands
        sizeof(PERF_COUNTER_DEFINITION),
        NNTP_CMDS_XHDR_COUNTER,
        0,
        NNTP_CMDS_XHDR_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(nntpc2.XHdrCmds),
        0 // assigned in open procedure
    },

    {   // XHdrCommandsPerSec
        sizeof(PERF_COUNTER_DEFINITION),
        NNTP_CMDS_PERSEC_XHDR_COUNTER,
        0,
        NNTP_CMDS_PERSEC_XHDR_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(nntpc2.XHdrCmdsPerSec),
        0 // assigned in open procedure
    },

    {   // XOverCommands
        sizeof(PERF_COUNTER_DEFINITION),
        NNTP_CMDS_XOVER_COUNTER,
        0,
        NNTP_CMDS_XOVER_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(nntpc2.XOverCmds),
        0 // assigned in open procedure
    },

    {   // XOverCommandsPerSec
        sizeof(PERF_COUNTER_DEFINITION),
        NNTP_CMDS_PERSEC_XOVER_COUNTER,
        0,
        NNTP_CMDS_PERSEC_XOVER_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(nntpc2.XOverCmdsPerSec),
        0 // assigned in open procedure
    },

    {   // XPatCommands
        sizeof(PERF_COUNTER_DEFINITION),
        NNTP_CMDS_XPAT_COUNTER,
        0,
        NNTP_CMDS_XPAT_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(nntpc2.XPatCmds),
        0 // assigned in open procedure
    },

    {   // XPatCommandsPerSec
        sizeof(PERF_COUNTER_DEFINITION),
        NNTP_CMDS_PERSEC_XPAT_COUNTER,
        0,
        NNTP_CMDS_PERSEC_XPAT_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(nntpc2.XPatCmdsPerSec),
        0 // assigned in open procedure
    },

    {   // XReplicCommands
        sizeof(PERF_COUNTER_DEFINITION),
        NNTP_CMDS_XREPLIC_COUNTER,
        0,
        NNTP_CMDS_XREPLIC_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(nntpc2.XReplicCmds),
        0 // assigned in open procedure
    },

    {   // XreplicCommandsPerSec
        sizeof(PERF_COUNTER_DEFINITION),
        NNTP_CMDS_PERSEC_XREPLIC_COUNTER,
        0,
        NNTP_CMDS_PERSEC_XREPLIC_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(nntpc2.XReplicCmdsPerSec),
        0 // assigned in open procedure
    }
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\nntp\nntpapi\rpcutil.c ===
/*++

   Copyright    (c)    1995    Microsoft Corporation

   Module  Name :

      rpcutil.c

   Abstract:

      This module defines functions that may help to replace the rpc util
        functions from rpcutil.lib

   Author:

       Murali R. Krishnan    ( MuraliK )     15-Sept-1995

   Environment:
       Win32 User Mode

   Project:

       Common Code for Internet Services

   Functions Exported:

        MIDL_user_allocate()
        MIDL_user_free()
        RpcBindHandleForServer()
        RpcBindHandleFree()

   Revision History:

        Murali R. Krishnan (MuraliK) 21-Dec-1995  Support TcpIp binding & free.
        Murali R. Krishnan (MuraliK) 20-Feb-1996  Support Lpc binding & free.

--*/


/************************************************************
 *     Include Headers
 ************************************************************/

# include <windows.h>
# include <rpc.h>

# include "apiutil.h"

# if DBG

# include <stdio.h>
# include <stdlib.h>

# define DBGPRINTF(s)       { CHAR rgchBuff[1024]; \
                              sprintf s ; \
                              OutputDebugStringA( rgchBuff); \
                            }
# define DBG_CONTEXT        ( rgchBuff)


# else // DBG


# define DBGPRINTF(s)     /* nothing */
# define DBG_CONTEXT      /* nothing */

# endif // DBG

#define ISRPC_CLIENT_OVER_TCPIP          0x00000001
#define ISRPC_CLIENT_OVER_NP             0x00000002
#define ISRPC_CLIENT_OVER_SPX            0x00000004
#define ISRPC_CLIENT_OVER_LPC            0x00000008

// # define MAX_COMPUTERNAME_LENGTH    (255)


/************************************************************
 *    Functions
 ************************************************************/


PVOID
MIDL_user_allocate(IN size_t size)
/*++

Routine Description:

    MIDL memory allocation.

Arguments:

    size : Memory size requested.

Return Value:

    Pointer to the allocated memory block.

--*/
{
    PVOID pvBlob;

    pvBlob = LocalAlloc( LPTR, size);

    return( pvBlob );

} // MIDL_user_allocate()




VOID
MIDL_user_free(IN PVOID pvBlob)
/*++

Routine Description:

    MIDL memory free .

Arguments:

    pvBlob : Pointer to a memory block that is freed.


Return Value:

    None.

--*/
{
    LocalFree( pvBlob);

    return;
}  // MIDL_user_free()




RPC_STATUS
RpcBindHandleOverNamedPipe( OUT handle_t * pBindingHandle,
                           IN LPWSTR      pwszServerName,
                           IN LPWSTR      pwszEndpoint,
                           IN LPWSTR      pwszOptions,
                           IN LPWSTR       pwszInterfaceName
                          )
/*++
  This function uses the parameters supplied and generates a named pipe
   binding handle for RPC.

  Arguments:
   pBindingHandle   pointer to location which will contain binding handle
                       on successful return
   pwszServerName   pointer to string containing the name of the server
                       to which, this function will obtain a binding.
   pwszEndpoint     pointer to string containing the Named Pipe Endpoint
   pwszOptions      pointer to string containing any additional options for
                       binding.


  Returns:
   RPC_STATUS  - RPC_S_OK  on success
   Also on success, the binding handle is stored in pBindingHandle.
   It should freed after usage, using the RpcBindingFree() function.

--*/
{
    RPC_STATUS rpcStatus;
    LPWSTR     pwszBinding = NULL;

    if ( pBindingHandle != NULL) {

        *pBindingHandle = NULL;   // init the value
    }

    //
    // Compose the binding string for named pipe binding
    //

    rpcStatus = RpcStringBindingComposeW(0,            // ObjUuid
                                         L"ncacn_np",  // prot seq: named pipe
                                         pwszServerName, // NetworkAddr
                                         pwszEndpoint, // Endpoint
                                         pwszOptions,  // Options
                                         &pwszBinding);    // StringBinding

    if ( rpcStatus == RPC_S_OK ) {

        //
        // establish the binding handle using string binding.
        //

        rpcStatus = RpcBindingFromStringBindingW(pwszBinding,
                                                 pBindingHandle );
    }

    if ( rpcStatus == RPC_S_OK) {

        //
        // set up the security information
        //

        rpcStatus =
          RpcBindingSetAuthInfoW(*pBindingHandle,
                                 pwszInterfaceName,   // pszPrincipalName
                                 RPC_C_AUTHN_LEVEL_PKT_PRIVACY,
                                 RPC_C_AUTHN_WINNT,
                                 NULL,                // AuthnIdentity
                                 0                    // AuthzSvc
                                 );
        DBGPRINTF( (DBG_CONTEXT,
                    "RpcBindingSetAuthInfo(%S(Interface=%S), %p)"
                    " return %d.\n",
                    pwszBinding,
                    pwszInterfaceName,
                    *pBindingHandle,
                    rpcStatus
                    )
                  );

    }


    //
    // Cleanup and return back.
    //

    if ( pwszBinding != NULL) {
        RpcStringFreeW(&pwszBinding);
    }

    if ( rpcStatus != RPC_S_OK) {

        if ( pBindingHandle != NULL && *pBindingHandle != NULL) {

            // RPC should have freed the binding handle.
            // We will free it now.
            RpcBindingFree(*pBindingHandle);
            *pBindingHandle = NULL;
        }
    }

    return (rpcStatus);

} // RpcBindHandleOverNamedPipe()

RPC_STATUS
RpcBindHandleOverLpc( OUT handle_t * pBindingHandle,
                      IN LPWSTR      pwszEndpoint,
                      IN LPWSTR      pwszOptions,
                      IN LPWSTR       pwszInterfaceName
                     )
/*++
  This function uses the parameters supplied and generates a lpc
   binding handle for RPC.

  Arguments:
   pBindingHandle   pointer to location which will contain binding handle
                       on successful return
   pwszEndpoint     pointer to string containing the lpc Endpoint
   pwszOptions      pointer to string containing any additional options for
                       binding.


  Returns:
   RPC_STATUS  - RPC_S_OK  on success
   Also on success, the binding handle is stored in pBindingHandle.
   It should freed after usage, using the RpcBindingFree() function.

--*/
{
    RPC_STATUS rpcStatus;
    LPWSTR     pwszBinding = NULL;

    if ( pBindingHandle != NULL) {

        *pBindingHandle = NULL;   // init the value
    }

    //
    // Compose the binding string for named pipe binding
    //

    rpcStatus = RpcStringBindingComposeW(0,            // ObjUuid
                                         L"ncalrpc",   // prot seq: lpc
                                         NULL,         // NetworkAddr
                                         pwszEndpoint, // Endpoint
                                         pwszOptions,  // Options
                                         &pwszBinding);    // StringBinding

    if ( rpcStatus == RPC_S_OK ) {

        //
        // establish the binding handle using string binding.
        //

        rpcStatus = RpcBindingFromStringBindingW(pwszBinding,
                                                 pBindingHandle );
    }

    if ( rpcStatus == RPC_S_OK) {

        //
        // set up the security information
        //

        rpcStatus =
          RpcBindingSetAuthInfoW(*pBindingHandle,
                                 pwszInterfaceName,   // pszPrincipalName
                                 RPC_C_AUTHN_LEVEL_PKT_PRIVACY,
                                 RPC_C_AUTHN_WINNT,
                                 NULL,                // AuthnIdentity
                                 0                    // AuthzSvc
                                 );
        DBGPRINTF( (DBG_CONTEXT,
                    "RpcBindingSetAuthInfo(%S(Interface=%S), %p)"
                    " return %d.\n",
                    pwszBinding,
                    pwszInterfaceName,
                    *pBindingHandle,
                    rpcStatus
                    )
                  );

    }


    //
    // Cleanup and return back.
    //

    if ( pwszBinding != NULL) {
        RpcStringFreeW(&pwszBinding);
    }

    if ( rpcStatus != RPC_S_OK) {

        if ( pBindingHandle != NULL && *pBindingHandle != NULL) {

            // RPC should have freed the binding handle.
            // We will free it now.
            RpcBindingFree(*pBindingHandle);
            *pBindingHandle = NULL;
        }
    }

    return (rpcStatus);

} // RpcBindHandleOverLpc()




#ifndef CHICAGO

//
// If changes are made to the NT version, check out the windows 95
// version located right after this routine and see if the change
// needs to be propagated there too.
//

RPC_STATUS
RpcBindHandleOverTcpIp( OUT handle_t * pBindingHandle,
                       IN LPWSTR       pwszServerName,
                       IN LPWSTR       pwszInterfaceName
                       )
/*++

    NT Version

  This function uses the parameters supplied and generates a dynamic end point
     binding handle for RPC over TCP/IP.

  Arguments:
   pBindingHandle   pointer to location which will contain binding handle
                       on successful return
   pwszServerName   pointer to string containing the name of the server
                       to which, this function will obtain a binding.
   pwszInterfaceName pointer to string containing the interface name

  Returns:
   RPC_STATUS  - RPC_S_OK  on success
   Also on success, the binding handle is stored in pBindingHandle.
   It should freed after usage, using the RpcBindingFree() function.

--*/
{
    RPC_STATUS rpcStatus;
    LPWSTR     pwszBinding = NULL;

    if ( pBindingHandle != NULL) {

        *pBindingHandle = NULL;   // init the value
    }

    //
    // Compose the binding string for named pipe binding
    //

    rpcStatus = RpcStringBindingComposeW(0,               // ObjUuid
                                         L"ncacn_ip_tcp", // tcpip seq
                                         pwszServerName,  // NetworkAddr
                                         NULL,            // Endpoint
                                         L"",             // Options
                                         &pwszBinding);   // StringBinding

    DBGPRINTF( (DBG_CONTEXT, "\nRpcStringBindingComposeW(%S, %S) return %S."
                " Error = %ld\n",
                L"ncacn_ip_tcp",
                pwszServerName,
                pwszBinding,
                rpcStatus)
              );

    if ( rpcStatus == RPC_S_OK ) {

        //
        // establish the binding handle using string binding.
        //

        rpcStatus = RpcBindingFromStringBindingW(pwszBinding,
                                                 pBindingHandle );

        DBGPRINTF( (DBG_CONTEXT,
                    "RpcBindingFromStringBindingW(%S) return %d."
                    "Binding=%p\n",
                    pwszBinding,
                    rpcStatus,
                    *pBindingHandle)
                  );
    }

    if ( rpcStatus == RPC_S_OK) {

        //
        // set up the security information
        //

        rpcStatus =
          RpcBindingSetAuthInfoW(*pBindingHandle,
                                 pwszInterfaceName,   // pszPrincipalName
                                 RPC_C_AUTHN_LEVEL_PKT_PRIVACY,
                                 RPC_C_AUTHN_WINNT,
                                 NULL,                // AuthnIdentity
                                 0                    // AuthzSvc
                                 );
        DBGPRINTF( (DBG_CONTEXT,
                    "RpcBindingSetAuthInfo(%S(Interface=%S), %p)"
                    " return %d.\n",
                    pwszBinding,
                    pwszInterfaceName,
                    *pBindingHandle,
                    rpcStatus
                    )
                  );

    }

    //
    // Cleanup and return back.
    //

    if ( pwszBinding != NULL) {

        DWORD rpcStatus1 = RpcStringFreeW(&pwszBinding);
        DBGPRINTF( (DBG_CONTEXT, "RpcStringFreeW() returns %d.",
                    rpcStatus1)
                  );

    }

    if ( rpcStatus != RPC_S_OK) {

        if ( pBindingHandle != NULL && *pBindingHandle != NULL) {

            // RPC should have freed the binding handle.
            // We will free it now.
            DWORD rpcStatus1 = RpcBindingFree(*pBindingHandle);
            DBGPRINTF( (DBG_CONTEXT, "RpcBindingFree() returns %d.\n",
                        rpcStatus1)
                      );
            *pBindingHandle = NULL;
        }
    }

    return (rpcStatus);

} // RpcBindHandleOverTcpIp()

#else // CHICAGO



RPC_STATUS
RpcBindHandleOverTcpIp( OUT handle_t * pBindingHandle,
                       IN LPWSTR       pwszServerName,
                       IN LPWSTR       pwszInterfaceName
                       )
/*++

    Windows 95 version

  This function uses the parameters supplied and generates a dynamic end point
     binding handle for RPC over TCP/IP.

  Arguments:
   pBindingHandle   pointer to location which will contain binding handle
                       on successful return
   pwszServerName   pointer to string containing the name of the server
                       to which, this function will obtain a binding.
   pwszInterfaceName pointer to string containing the interface name

  Returns:
   RPC_STATUS  - RPC_S_OK  on success
   Also on success, the binding handle is stored in pBindingHandle.
   It should freed after usage, using the RpcBindingFree() function.

--*/
{
    RPC_STATUS rpcStatus;
    LPSTR     pszBindingA = NULL;
    CHAR    szServerA[MAX_PATH];
    CHAR    szInterfaceA[MAX_PATH];
    int        cch;

    if ( pBindingHandle != NULL) {

        *pBindingHandle = NULL;   // init the value
    }

    *szServerA = '0';

    if (pwszServerName)
    cch = WideCharToMultiByte(CP_ACP,
                              0,
                              pwszServerName,
                              -1,
                              szServerA,
                              sizeof(szServerA)/sizeof(CHAR),
                              NULL,NULL
                              );

    *szInterfaceA = '0';

    if(pwszInterfaceName)
    cch = WideCharToMultiByte(CP_ACP,
                              0,
                              pwszInterfaceName,
                              -1,
                              szInterfaceA,
                              sizeof(szInterfaceA)/sizeof(CHAR),
                              NULL,NULL
                              );


    //
    // Compose the binding string for named pipe binding
    //

    rpcStatus = RpcStringBindingCompose(0,            // ObjUuid
                                         "ncacn_ip_tcp", // tcpip seq
                                         szServerA, // NetworkAddr
                                         NULL, // Endpoint
                                         NULL, //L"",  // Options
                                         &pszBindingA);    // StringBinding

    DBGPRINTF( (DBG_CONTEXT, "\nRpcStringBindingCompose(%s, %s) return %s."
                " Error = %ld\n",
                "ncacn_ip_tcp",
                szServerA,
                pszBindingA,
                rpcStatus)
              );

    if ( rpcStatus == RPC_S_OK ) {

        //
        // establish the binding handle using string binding.
        //

        rpcStatus = RpcBindingFromStringBinding(pszBindingA,
                                                 pBindingHandle );

        DBGPRINTF( (DBG_CONTEXT,
                    "RpcBindingFromStringBinding(%s) return %d."
                    "Binding=%08x\n",
                    pszBindingA,
                    rpcStatus,
                    *pBindingHandle)
                  );
    }

    if ( rpcStatus == RPC_S_OK) {

        //
        // set up the security information
        //

        rpcStatus =
          RpcBindingSetAuthInfo(*pBindingHandle,
                                 szInterfaceA,   // pszPrincipalName
                                 RPC_C_AUTHN_LEVEL_PKT_PRIVACY,
                                 RPC_C_AUTHN_WINNT,
                                 NULL,  // AuthnIdentity
                                 0      // AuthzSvc
                                 );
        DBGPRINTF( (DBG_CONTEXT,
                    "RpcBindingSetAuthInfo(%s(Interface=%s), %08x)"
                    " return %d.\n",
                    pszBindingA,
                    szInterfaceA,
                    *pBindingHandle,
                    rpcStatus
                    )
                  );

    }

    //
    // Cleanup and return back.
    //

    if ( pszBindingA != NULL) {

        DWORD rpcStatus1 = RpcStringFree(&pszBindingA);
        DBGPRINTF( (DBG_CONTEXT, "RpcStringFreeW() returns %d.",
                    rpcStatus1)
                  );

    }

    if ( rpcStatus != RPC_S_OK) {

        if ( pBindingHandle != NULL && *pBindingHandle != NULL) {

            // RPC should have freed the binding handle.
            // We will free it now.
            DWORD rpcStatus1 = RpcBindingFree(*pBindingHandle);
            DBGPRINTF( (DBG_CONTEXT, "RpcBindingFree() returns %d.\n",
                        rpcStatus1)
                      );
            *pBindingHandle = NULL;
        }
    }

    return (rpcStatus);

} // RpcBindHandleOverTcpIp()
#endif



#ifndef CHICAGO
DWORD
RpcuFindProtocolToUse( IN LPCWSTR pwszServerName)
/*++
  Given the server name this funciton determines the protocol
  to use for RPC binding.

  The transport used is determined dynamically based on following rules.

  If server name is NULL or 127.0.0.1 or same as local computer name
      then use the LPC.

  If server name starts with a leading "\\" (double slash),
      then attempt RPC binding over NamedPipe.

  If server name does not start with leading "\\",
      then attempt RPC binding over TCPIP.

  If TCPIP binding fails, then this function tries binding over NamedPipe.


  Argument:
    pwszServerName - pointer to string containing the name of the server


  Returns:
    DWORD containing the type of protocol to use.

--*/
{
    static WCHAR g_wchLocalMachineName[ MAX_COMPUTERNAME_LENGTH + 1];
    BOOL   fLeadingSlashes;
    DWORD  dwBindProtocol = ISRPC_CLIENT_OVER_NP;
    BOOL   fLocalMachine;

    if ( pwszServerName == NULL ||
         _wcsicmp( L"127.0.0.1", pwszServerName) == 0) {


        return (ISRPC_CLIENT_OVER_LPC);
    }

    if ( g_wchLocalMachineName[0] == L'\0') {

        DWORD cchComputerNameLen = MAX_COMPUTERNAME_LENGTH;

        //
        // Obtain the local computer name
        //

        if (!GetComputerNameW( g_wchLocalMachineName,
                              &cchComputerNameLen)
            ) {

            *g_wchLocalMachineName = L'\0';
        }
    }

    fLeadingSlashes = ((*pwszServerName == L'\\') &&
                       (*(pwszServerName+1) == L'\\')
                       );


    //
    // Check to see if machine name matches local computer name
    //  if so, use LPC
    //

    fLocalMachine = !_wcsicmp( g_wchLocalMachineName,
                              ((fLeadingSlashes) ?
                               (pwszServerName + 2) : pwszServerName)
                              );

    if ( fLocalMachine) {

        return (ISRPC_CLIENT_OVER_LPC);
    }

    if ( !fLeadingSlashes) {

        DWORD  nDots;
        LPCWSTR pszName;

        //
        // Check if the name has dotted decimal name.
        // If so then suggest TCP binding.
        //

        for( nDots = 0, pszName = pwszServerName;
            ((pszName = wcschr( pszName, L'.' )) != NULL);
            nDots++, pszName++)
          ;

        if ( nDots == 3) {

            //
            // if the string has 3 DOTs exactly then this string must represent
            // an IpAddress.
            //

            return(ISRPC_CLIENT_OVER_TCPIP);
        }
    }


    return ( ISRPC_CLIENT_OVER_NP);
} // RpcuFindProtocolToUse()
#endif



RPC_STATUS
RpcBindHandleForServer( OUT handle_t * pBindingHandle,
                       IN LPWSTR      pwszServerName,
                       IN LPWSTR      pwszInterfaceName,
                       IN LPWSTR      pwszOptions
                       )
/*++
  This function uses the parameters supplied and generates a binding
    handle for RPC.


  It is assumed that binding over named pipe uses static end point
      with the interface name and options as provided.

  Arguments:
   pBindingHandle   pointer to location which will contain binding handle
                       on successful return
   pwszServerName   pointer to string containing the name of the server
                       to which, this function will obtain a binding.
   pwszInterfaceName pointer to string containing the interface name
   pwszOptions      pointer to string containing any additional options for
                       binding.

  Returns:
   RPC_STATUS  - RPC_S_OK  on success
   Also on success, the binding handle is stored in pBindingHandle.
   It should freed after usage, using the RpcBindingFree() function.

--*/
{
    RPC_STATUS rpcStatus = RPC_S_SERVER_UNAVAILABLE;
    LPWSTR     pwszBinding = NULL;
    DWORD      dwBindProtocol = 0;


    if ( pBindingHandle != NULL) {

        *pBindingHandle = NULL;   // init the value
    }

#ifndef CHICAGO
    dwBindProtocol = RpcuFindProtocolToUse( pwszServerName);
#else
    dwBindProtocol = ISRPC_CLIENT_OVER_TCPIP;
#endif

    switch ( dwBindProtocol) {

      case ISRPC_CLIENT_OVER_LPC:
        {

            WCHAR  rgchLpc[1024];

            //
            // generate a LPC end point name from the interface name.
            //  the End point =   <InterfaceName>_LPC
            //

            if ( lstrlenW( pwszInterfaceName) >=
                ( sizeof(rgchLpc)/sizeof(WCHAR) - 6)) {

                SetLastError( ERROR_INVALID_PARAMETER);
                return ( ERROR_INVALID_PARAMETER);
            }

            lstrcpynW( rgchLpc, pwszInterfaceName, sizeof(rgchLpc)/sizeof(WCHAR) - 4);
            lstrcatW( rgchLpc, L"_LPC");

            //
            // Attempt binding over static LPC.
            //

            rpcStatus = RpcBindHandleOverLpc( pBindingHandle,
                                             rgchLpc,
                                             pwszOptions,
                                             pwszInterfaceName
                                             );

            DBGPRINTF(( DBG_CONTEXT,
                       " RpcBindingOverLpc(%S) returns %d."
                       " Handle = %p\n",
                       pwszServerName, rpcStatus, *pBindingHandle));

            break;
        }

      case ISRPC_CLIENT_OVER_TCPIP:

// # ifdef RPC_BIND_OVER_TCP

        //
        // Attempt binding over TCPIP using Dynamic Endpoint.
        //

        rpcStatus = RpcBindHandleOverTcpIp( pBindingHandle,
                                           pwszServerName,
                                           pwszInterfaceName);

        DBGPRINTF(( DBG_CONTEXT,
                   " RpcBindingOverTcpIp(%S) returns %d. Handle = %p\n",
                   pwszServerName, rpcStatus, *pBindingHandle));

        if ( rpcStatus == RPC_S_OK) {

            break;  // done with RPC binding over TCP
        }

        // Fall Through

// # endif // RPC_BIND_OVER_TCP

      case ISRPC_CLIENT_OVER_NP:
        {
            WCHAR  rgchNp[1024];

            //
            // generate a NamedPipe end point name from the interface name.
            //  the End point =   \PIPE\<InterfaceName>
            //

            lstrcpyW( rgchNp, L"\\PIPE\\");
            if ( lstrlenW( pwszInterfaceName) >=
                ( sizeof(rgchNp)/sizeof(WCHAR) - 10)) {

                SetLastError( ERROR_INVALID_PARAMETER);
                return ( ERROR_INVALID_PARAMETER);
            }

            lstrcatW( rgchNp, pwszInterfaceName);

            //
            // Attempt binding over static NamedPipe.
            //

            rpcStatus = RpcBindHandleOverNamedPipe( pBindingHandle,
                                                   pwszServerName,
                                                   rgchNp,
                                                   pwszOptions,
                                                   pwszInterfaceName
                                                   );

            DBGPRINTF(( DBG_CONTEXT,
                       " RpcBindingOverNamedPipe(%S) returns %d."
                       " Handle = %p\n",
                       pwszServerName, rpcStatus, *pBindingHandle));
            break;
        }

      default:
        break;

    } // switch()

    return ( rpcStatus);

} // RpcBindHandleForServer()





RPC_STATUS
RpcBindHandleFree(IN OUT handle_t * pBindingHandle)
/*++

  Description:

    This function frees up the binding handle allocated using
      RpcBindHandleForServer(). It uses RPC Binding Free routing to do this.
    This function acts just as a thunk so that the alloc/free of RPC contexts
      are consolidated within this module.

  Arguments:
    pBindingHandle  pointer to RPC binding handle that needs to be freed.


  Returns:
    RPC_STATUS - containig the RPC status. RPC_S_OK for success.

--*/
{

    return ( RpcBindingFree( pBindingHandle));

} // RpcBindHandleFree()

/************************ End of File ***********************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\nntp\nntpctrs\nntpdata.h ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1993                **/
/**********************************************************************/

/*
    nntpdata.h

    Extensible object definitions for the NNTP Server's counter
    objects & counters.


    FILE HISTORY:
        KeithMo     07-Jun-1993 Created.

*/


#ifndef _NNTPDATA_H_
#define _NNTPDATA_H_

#pragma pack(8) 

//
//  The counter structure returned.
//

typedef struct _NNTP_DATA_DEFINITION_OBJECT1
{
    PERF_OBJECT_TYPE            NntpObjectType;
    PERF_COUNTER_DEFINITION     NntpBytesSent;
    PERF_COUNTER_DEFINITION     NntpBytesReceived;
    PERF_COUNTER_DEFINITION     NntpBytesTotal;

    PERF_COUNTER_DEFINITION     NntpTotalConnections;
    PERF_COUNTER_DEFINITION     NntpTotalSSLConnections;
    PERF_COUNTER_DEFINITION     NntpCurrentConnections;
    PERF_COUNTER_DEFINITION     NntpMaxConnections;

    PERF_COUNTER_DEFINITION     NntpCurrentAnonymous;
    PERF_COUNTER_DEFINITION     NntpCurrentNonAnonymous;
    PERF_COUNTER_DEFINITION     NntpTotalAnonymous;
    PERF_COUNTER_DEFINITION     NntpTotalNonAnonymous;
    PERF_COUNTER_DEFINITION     NntpMaxAnonymous;
    PERF_COUNTER_DEFINITION     NntpMaxNonAnonymous;

    PERF_COUNTER_DEFINITION     NntpTotalOutboundConnects;
    PERF_COUNTER_DEFINITION     NntpOutboundConnectsFailed;
    PERF_COUNTER_DEFINITION     NntpCurrentOutboundConnects;
    PERF_COUNTER_DEFINITION     NntpOutboundLogonFailed;

    PERF_COUNTER_DEFINITION     NntpTotalPullFeeds;
    PERF_COUNTER_DEFINITION     NntpTotalPushFeeds;
    PERF_COUNTER_DEFINITION     NntpTotalPassiveFeeds;

    PERF_COUNTER_DEFINITION     NntpArticlesSent;
    PERF_COUNTER_DEFINITION     NntpArticlesReceived;
    PERF_COUNTER_DEFINITION     NntpArticlesTotal;

    PERF_COUNTER_DEFINITION     NntpArticlesPosted;
    PERF_COUNTER_DEFINITION     NntpArticleMapEntries;
    PERF_COUNTER_DEFINITION     NntpHistoryMapEntries;
    PERF_COUNTER_DEFINITION     NntpXoverEntries;

    PERF_COUNTER_DEFINITION     NntpControlMessagesIn;
    PERF_COUNTER_DEFINITION     NntpControlMessagesFailed;
    PERF_COUNTER_DEFINITION     NntpModeratedPostingsSent;
    PERF_COUNTER_DEFINITION     NntpModeratedPostingsFailed;

    PERF_COUNTER_DEFINITION     NntpSessionsFlowControlled;

    PERF_COUNTER_DEFINITION     NntpArticlesExpired;

    PERF_COUNTER_DEFINITION     NntpArticlesSentPerSec;
    PERF_COUNTER_DEFINITION     NntpArticlesReceivedPerSec;
    PERF_COUNTER_DEFINITION     NntpArticlesPostedPerSec;
    PERF_COUNTER_DEFINITION     NntpArticleMapEntriesPerSec;
    PERF_COUNTER_DEFINITION     NntpHistoryMapEntriesPerSec;
    PERF_COUNTER_DEFINITION     NntpXoverEntriesPerSec;
    PERF_COUNTER_DEFINITION     NntpArticlesExpiredPerSec;

} NNTP_DATA_DEFINITION_OBJECT1;

typedef struct _NNTP_DATA_DEFINITION_OBJECT2
{
    PERF_OBJECT_TYPE            NntpObjectType;
    PERF_COUNTER_DEFINITION     NntpArticleCmds;
    PERF_COUNTER_DEFINITION     NntpArticleCmdsPerSec;
    PERF_COUNTER_DEFINITION     NntpGroupCmds;
    PERF_COUNTER_DEFINITION     NntpGroupCmdsPerSec;
    PERF_COUNTER_DEFINITION     NntpHelpCmds;
    PERF_COUNTER_DEFINITION     NntpHelpCmdsPerSec;
    PERF_COUNTER_DEFINITION     NntpIHaveCmds;
    PERF_COUNTER_DEFINITION     NntpIHaveCmdsPerSec;
    PERF_COUNTER_DEFINITION     NntpLastCmds;
    PERF_COUNTER_DEFINITION     NntpLastCmdsPerSec;
    PERF_COUNTER_DEFINITION     NntpListCmds;
    PERF_COUNTER_DEFINITION     NntpListCmdsPerSec;
    PERF_COUNTER_DEFINITION     NntpNewgroupsCmds;
    PERF_COUNTER_DEFINITION     NntpNewgroupsCmdsPerSec;
    PERF_COUNTER_DEFINITION     NntpNewnewsCmds;
    PERF_COUNTER_DEFINITION     NntpNewnewsCmdsPerSec;
    PERF_COUNTER_DEFINITION     NntpNextCmds;
    PERF_COUNTER_DEFINITION     NntpNextCmdsPerSec;
    PERF_COUNTER_DEFINITION     NntpPostCmds;
    PERF_COUNTER_DEFINITION     NntpPostCmdsPerSec;
    PERF_COUNTER_DEFINITION     NntpQuitCmds;
    PERF_COUNTER_DEFINITION     NntpQuitCmdsPerSec;
    PERF_COUNTER_DEFINITION     NntpStatCmds;
    PERF_COUNTER_DEFINITION     NntpStatCmdsPerSec;

    PERF_COUNTER_DEFINITION     NntpLogonAttempts;
    PERF_COUNTER_DEFINITION     NntpLogonFailures;
    PERF_COUNTER_DEFINITION     NntpLogonAttemptsPerSec;
    PERF_COUNTER_DEFINITION     NntpLogonFailuresPerSec;

    PERF_COUNTER_DEFINITION     NntpCheckCmds;
    PERF_COUNTER_DEFINITION     NntpCheckCmdsPerSec;
    PERF_COUNTER_DEFINITION     NntpTakethisCmds;
    PERF_COUNTER_DEFINITION     NntpTakethisCmdsPerSec;
    PERF_COUNTER_DEFINITION     NntpModeCmds;
    PERF_COUNTER_DEFINITION     NntpModeCmdsPerSec;
    PERF_COUNTER_DEFINITION     NntpSearchCmds;
    PERF_COUNTER_DEFINITION     NntpSearchCmdsPerSec;
    PERF_COUNTER_DEFINITION     NntpXHdrCmds;
    PERF_COUNTER_DEFINITION     NntpXHdrCmdsPerSec;
    PERF_COUNTER_DEFINITION     NntpXOverCmds;
    PERF_COUNTER_DEFINITION     NntpXOverCmdsPerSec;
    PERF_COUNTER_DEFINITION     NntpXPatCmds;
    PERF_COUNTER_DEFINITION     NntpXPatCmdsPerSec;
    PERF_COUNTER_DEFINITION     NntpXReplicCmds;
    PERF_COUNTER_DEFINITION     NntpXReplicCmdsPerSec;
    
} NNTP_DATA_DEFINITION_OBJECT2;

typedef struct _NNTP_COUNTER_BLOCK1 {
    PERF_COUNTER_BLOCK	PerfCounterBlock;
    LONGLONG			BytesSent;
    LONGLONG			BytesReceived;
    LONGLONG			BytesTotal;

    DWORD				TotalConnections;
    DWORD				TotalSSLConnections;
    DWORD				CurrentConnections;
    DWORD				MaxConnections;

    DWORD				CurrentAnonymous;
    DWORD				CurrentNonAnonymous;
    DWORD				TotalAnonymous;
    DWORD				TotalNonAnonymous;
    DWORD				MaxAnonymous;
    DWORD				MaxNonAnonymous;

    DWORD				TotalOutboundConnects;
    DWORD				OutboundConnectsFailed;
    DWORD				CurrentOutboundConnects;
    DWORD				OutboundLogonFailed;

    DWORD				TotalPullFeeds;
    DWORD				TotalPushFeeds;
    DWORD				TotalPassiveFeeds;

    DWORD				ArticlesSent;
    DWORD				ArticlesReceived;
    DWORD				ArticlesTotal;

    DWORD				ArticlesPosted;
    DWORD				ArticleMapEntries;
    DWORD				HistoryMapEntries;
    DWORD				XoverEntries;

    DWORD				ControlMessagesIn;
    DWORD				ControlMessagesFailed;
    DWORD				ModeratedPostingsSent;
    DWORD				ModeratedPostingsFailed;

    DWORD				SessionsFlowControlled;

    DWORD				ArticlesExpired;

    DWORD				ArticlesSentPerSec;
    DWORD				ArticlesReceivedPerSec;
    DWORD				ArticlesPostedPerSec;
    DWORD				ArticleMapEntriesPerSec;
    DWORD				HistoryMapEntriesPerSec;
    DWORD				XoverEntriesPerSec;
    DWORD				ArticlesExpiredPerSec;

} NNTP_COUNTER_BLOCK1, * PNNTP_COUNTER_BLOCK1;

typedef struct _NNTP_COUNTER_BLOCK2 {
    PERF_COUNTER_BLOCK	PerfCounterBlock;
    DWORD				ArticleCmds;
    DWORD				ArticleCmdsPerSec;
    DWORD				GroupCmds;
    DWORD				GroupCmdsPerSec;
    DWORD				HelpCmds;
    DWORD				HelpCmdsPerSec;
    DWORD				IHaveCmds;
    DWORD				IHaveCmdsPerSec;
    DWORD				LastCmds;
    DWORD				LastCmdsPerSec;
    DWORD				ListCmds;
    DWORD				ListCmdsPerSec;
    DWORD				NewgroupsCmds;
    DWORD				NewgroupsCmdsPerSec;
    DWORD				NewnewsCmds;
    DWORD				NewnewsCmdsPerSec;
    DWORD				NextCmds;
    DWORD				NextCmdsPerSec;
    DWORD				PostCmds;
    DWORD				PostCmdsPerSec;
    DWORD				QuitCmds;
    DWORD				QuitCmdsPerSec;
    DWORD				StatCmds;
    DWORD				StatCmdsPerSec;

    DWORD				LogonAttempts;
    DWORD				LogonFailures;
    DWORD				LogonAttemptsPerSec;
    DWORD				LogonFailuresPerSec;

    DWORD     			CheckCmds;
    DWORD     			CheckCmdsPerSec;
    DWORD     			TakethisCmds;
    DWORD     			TakethisCmdsPerSec;
    DWORD     			ModeCmds;
    DWORD     			ModeCmdsPerSec;
    DWORD     			SearchCmds;
    DWORD     			SearchCmdsPerSec;
    DWORD     			XHdrCmds;
    DWORD     			XHdrCmdsPerSec;
    DWORD     			XOverCmds;
    DWORD     			XOverCmdsPerSec;
    DWORD     			XPatCmds;
    DWORD     			XPatCmdsPerSec;
    DWORD     			XReplicCmds;
    DWORD     			XReplicCmdsPerSec;
    DWORD			dwReservedFor8ByteAlignment;
} NNTP_COUNTER_BLOCK2, * PNNTP_COUNTER_BLOCK2;

extern  NNTP_DATA_DEFINITION_OBJECT1    NntpDataDefinitionObject1;
extern  NNTP_DATA_DEFINITION_OBJECT2    NntpDataDefinitionObject2;

#define NUMBER_OF_NNTP_COUNTERS_OBJECT1 ((sizeof(NNTP_DATA_DEFINITION_OBJECT1) -        \
										sizeof(PERF_OBJECT_TYPE)) /           \
										sizeof(PERF_COUNTER_DEFINITION))

#define NUMBER_OF_NNTP_COUNTERS_OBJECT2 ((sizeof(NNTP_DATA_DEFINITION_OBJECT2) -        \
										sizeof(PERF_OBJECT_TYPE)) /           \
										sizeof(PERF_COUNTER_DEFINITION))

//
//  Restore default packing & alignment.
//

#pragma pack()


#endif  // _NNTPDATA_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\nntp\nntpctrs\perfutil.h ===
/*++

   Copyright    (c)    1995    Microsoft Corporation

   Module  Name :

      perfutil.h

   Abstract:

      This file supports routines used to parse and create Performance Monitor
       Data structures, used by all the Internet Services product.

   Author:

       Murali R. Krishnan    ( MuraliK )    16-Nov-1995  
         From the common code for perfmon interface (Russ Blake's).

   Environment:

      User Mode

   Project:
   
       Internet Services Common Runtime code

   Revision History:

       Sophia Chung  (sophiac)  05-Nov-1996
         Added supports for mutlitple instances.

--*/

# ifndef _PERFUTIL_H_
# define _PERFUTIL_H_

//
//  Utility macro.  This is used to reserve a DWORD multiple of
//  bytes for Unicode strings embedded in the definitional data,
//  viz., object instance names.
//

#define DWORD_MULTIPLE(x) (((x+sizeof(DWORD)-1)/sizeof(DWORD))*sizeof(DWORD))
#define PVOID_MULTIPLE(x) (((x+sizeof(PVOID)-1)/sizeof(PVOID))*sizeof(PVOID))


/************************************************************
 *     Symbolic Constants
 ************************************************************/


#define QUERY_GLOBAL    1
#define QUERY_ITEMS     2
#define QUERY_FOREIGN   3
#define QUERY_COSTLY    4


/************************************************************
 *     Function Declarations
 ************************************************************/

DWORD
GetQueryType (IN LPWSTR lpwszValue);

BOOL
IsNumberInUnicodeList (IN DWORD dwNumber, IN LPWSTR lpwszUnicodeList);

VOID
MonBuildInstanceDefinition(
    OUT PERF_INSTANCE_DEFINITION *pBuffer,
    OUT PVOID *pBufferNext,
    IN DWORD ParentObjectTitleIndex,
    IN DWORD ParentObjectInstance,
    IN DWORD UniqueID,
    IN LPWSTR Name
    );

# endif // _PERFUTIL_H_

/************************ End of File ***********************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\nntp\nntpctrs\perfnntp.cxx ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1993                **/
/**********************************************************************/

/*
    perfnntp.c

    This file implements the Extensible Performance Objects for
    the NNTP Server service.


    FILE HISTORY:
        KeithMo     07-Jun-1993 Created, based on RussBl's sample code.

*/

#define INITGUID

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <winperf.h>
#include <lm.h>

#include <string.h>
#include <stdio.h>
//#include <wcstr.h>

#include <nntpctrs.h>
#include <nntps.h>
#include <nntptype.h>
#include <nntpapi.h>

extern "C" {
#include <perfutil.h>
#include <nntpdata.h>
}

#include <ole2.h>

#define APP_NAME                     (TEXT("NntpCtrs"))
#define MAX_SIZEOF_INSTANCE_NAME     128
#define TOTAL_INSTANCE_NAME          L"_Total"

#define ALIGN_ON_QWORD(x) \
     ((VOID *)(((ULONG_PTR)(x) + ((8)-1)) & ~((ULONG_PTR)(8)-1)))


//
//  Private constants.
//


//
//  Private globals.
//

DWORD   cOpens    = 0;                  // Active "opens" reference count.
BOOL    fInitOK   = FALSE;              // TRUE if DLL initialized OK.

#if DBG
#define	_ASSERT( f )	if( (f) ) ; else DebugBreak()
#else //DBG
#define	_ASSERT( f )	
#endif  // DBG

// compile time assert
#define _CASSERT(ex) { typedef char cassert_type[(ex) ? 1 : -1]; }


//
//  Private prototypes.
//
VOID
CopyStatisticsData1(
    IN NNTP_STATISTICS_0          * pNntpStats,
    OUT NNTP_COUNTER_BLOCK1		  * pCounterBlock
    );

VOID
CopyStatisticsData2(
    IN NNTP_STATISTICS_0          * pNntpStats,
    OUT NNTP_COUNTER_BLOCK2		  * pCounterBlock
    );

VOID
Update_TotalStatisticsData1(
    IN NNTP_COUNTER_BLOCK1         * pCounterBlock,
    OUT NNTP_COUNTER_BLOCK1        * pTotal
    );

VOID
Update_TotalStatisticsData2(
    IN NNTP_COUNTER_BLOCK2         * pCounterBlock,
    OUT NNTP_COUNTER_BLOCK2        * pTotal
    );

VOID
UpdateNameAndHelpIndicies(
	IN DWORD dwFirstCounter,
	IN DWORD dwFirstHelp
	);

//
//  Public prototypes.
//

PM_OPEN_PROC    OpenNntpPerformanceData;
PM_COLLECT_PROC CollectNntpPerformanceData;
PM_CLOSE_PROC   CloseNntpPerformanceData;


//
//  Public functions.
//

/*******************************************************************

    NAME:       OpenNntpPerformanceData

    SYNOPSIS:   Initializes the data structures used to communicate
                performance counters with the registry.

    ENTRY:      lpDeviceNames - Poitner to object ID of each device
                    to be opened.

    RETURNS:    DWORD - Win32 status code.

    HISTORY:
        KeithMo     07-Jun-1993 Created.

********************************************************************/
DWORD
OpenNntpPerformanceData(
        LPWSTR lpDeviceNames
        )
{
    DWORD err  = NO_ERROR;
    HKEY  hkey = NULL;
    DWORD size;
    DWORD type;
    DWORD dwFirstCounter;
    DWORD dwFirstHelp;
    //PERF_COUNTER_DEFINITION * pctr;

    //
    //  Since SCREG is multi-threaded and will call this routine in
    //  order to service remote performance queries, this library
    //  must keep track of how many times it has been opened (i.e.
    //  how many threads have accessed it). The registry routines will
    //  limit access to the initialization routine to only one thread
    //  at a time so synchronization (i.e. reentrancy) should not be
    //  a problem.
    //

    if( !fInitOK ) {

        //
        //  This is the *first* open.
        //

        //
        //  Open the NNTP Server service's Performance key.
        //

        err = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                            NNTP_PERFORMANCE_KEY,
                            0,
                            KEY_READ,
                            &hkey );

        if( err == NO_ERROR )
        {
            //
            //  Read the first counter DWORD.
            //

            size = sizeof(DWORD);

            err = RegQueryValueEx( hkey,
                                   "First Counter",
                                   NULL,
                                   &type,
                                   (LPBYTE)&dwFirstCounter,
                                   &size );
        }

        if( err == NO_ERROR )
        {
            //
            //  Read the first help DWORD.
            //

            size = sizeof(DWORD);

            err = RegQueryValueEx( hkey,
                                   "First Help",
                                   NULL,
                                   &type,
                                   (LPBYTE)&dwFirstHelp,
                                   &size );
        }

        if ( err == NO_ERROR ) {

            //
            //  Update the object & counter name & help indicies.
            //

			UpdateNameAndHelpIndicies( dwFirstCounter, dwFirstHelp );

            //
            //  Remember that we initialized OK.
            //

            fInitOK = TRUE;
        }

        //
        //  Close the registry if we managed to actually open it.
        //

        if( hkey != NULL )
        {
            RegCloseKey( hkey );
            hkey = NULL;
        }
    }

    //
    //  Bump open counter.
    //

    cOpens++;

    return NO_ERROR;

}   // OpenNntpPerformanceData

/*******************************************************************

    NAME:       CollectNntpPerformanceData

    SYNOPSIS:   Initializes the data structures used to communicate

    ENTRY:      lpValueName - The name of the value to retrieve.

                lppData - On entry contains a pointer to the buffer to
                    receive the completed PerfDataBlock & subordinate
                    structures.  On exit, points to the first bytes
                    *after* the data structures added by this routine.

                lpcbTotalBytes - On entry contains a pointer to the
                    size (in BYTEs) of the buffer referenced by lppData.
                    On exit, contains the number of BYTEs added by this
                    routine.

                lpNumObjectTypes - Receives the number of objects added
                    by this routine.

    RETURNS:    DWORD - Win32 status code.  MUST be either NO_ERROR
                    or ERROR_MORE_DATA.

    HISTORY:
        KeithMo     07-Jun-1993 Created.

********************************************************************/
DWORD CollectNntpPerformanceData(
                    LPWSTR    lpValueName,
                    LPVOID  * lppData,
                    LPDWORD   lpcbTotalBytes,
                    LPDWORD   lpNumObjectTypes
                    )
{
    PERF_INSTANCE_DEFINITION		*pPerfInstanceDefinition;
    DWORD							dwInstanceIndex = 0;
    DWORD							dwInstanceCount = 0;
    DWORD                           dwInstance = 0;
    DWORD							dwCount = 0;
    DWORD							i = 0;
    DWORD							dwQueryType;
    ULONG							cbRequired;
    //DWORD							*pdwCounter;
    //LARGE_INTEGER					*pliCounter;
    NNTP_COUNTER_BLOCK1				*pCounterBlock1;
    NNTP_COUNTER_BLOCK1				*pTotal1;
    NNTP_COUNTER_BLOCK2				*pCounterBlock2;
    NNTP_COUNTER_BLOCK2				*pTotal2;
    NNTP_DATA_DEFINITION_OBJECT1	*pNntpDataDefinitionObject1;
    NNTP_DATA_DEFINITION_OBJECT2	*pNntpDataDefinitionObject2;
    NNTP_STATISTICS_BLOCK_ARRAY     *pNntpStatisticsBlockArray = NULL;
    NNTP_STATISTICS_BLOCK           *pNntpStatisticsBlock = NULL;
    NNTP_STATISTICS_0				*pNntpStats;
    NET_API_STATUS					neterr;
    HRESULT                 		hresErr;
	DWORD							dwRetCode = NO_ERROR;
    WCHAR                           wszKeyName[MAX_PATH];

    // 8-byte alignment test -
    // the returned buffer will be 
    // NNTP_DATA_DEFINITION_OBJECT1, 
    // (PERF_INSTANCE_DEFINITION, name, NNTP_COUNTER_BLOCK1)+
    // NNTP_DATA_DEFINITION_OBJECT2, 
    // (PERF_INSTANCE_DEFINITION, name, NNTP_COUNTER_BLOCK2)+
    //
    // name will end with a 8-byte alignment
    // so if input lpp isn't 8-byte aligned, we will still return a 8-byte aligned lppData

    // Before we go, assert on size of objects
    _CASSERT(sizeof(NNTP_DATA_DEFINITION_OBJECT1) % sizeof(LONGLONG) == 0);
    _CASSERT(sizeof(PERF_INSTANCE_DEFINITION) % sizeof(LONGLONG) == 0);
    _CASSERT(sizeof(NNTP_COUNTER_BLOCK1) % sizeof(LONGLONG) == 0);
    _CASSERT(sizeof(NNTP_DATA_DEFINITION_OBJECT2) % sizeof(LONGLONG) == 0);
    _CASSERT(sizeof(NNTP_COUNTER_BLOCK2) % sizeof(LONGLONG) == 0);
    


    //
    //  No need to even try if we failed to open...
    //
    if( !fInitOK )
    {

        *lpcbTotalBytes   = 0;
        *lpNumObjectTypes = 0;

        //
        //  According to the Performance Counter design, this
        //  is a successful exit.  Go figure.
        //

        return NO_ERROR;
    }

    //
    //  Determine the query type.
    //

    dwQueryType = GetQueryType( lpValueName );

    if( dwQueryType == QUERY_FOREIGN )
    {
        //
        //  We don't do foreign queries.
        //

        *lpcbTotalBytes   = 0;
        *lpNumObjectTypes = 0;

        return NO_ERROR;
    }

    if( dwQueryType == QUERY_ITEMS )
    {
        //
        //  The registry is asking for a specific object.  Let's
        //  see if we're one of the chosen.
        //

        if( !IsNumberInUnicodeList(
                        NntpDataDefinitionObject1.NntpObjectType.ObjectNameTitleIndex,
                        lpValueName ) &&
			!IsNumberInUnicodeList(
                        NntpDataDefinitionObject2.NntpObjectType.ObjectNameTitleIndex,
                        lpValueName )
						)
        {
            *lpcbTotalBytes   = 0;
            *lpNumObjectTypes = 0;

            return NO_ERROR;
        }
    }


    //
    // query for statistics info before we check the buffer size, so we have a correct instance count 
    //

    neterr = NntpQueryStatistics(
                        NULL,
                        0,
                        (LPBYTE *)&pNntpStatisticsBlockArray );

    if( neterr != NERR_Success )
    {
        *lpcbTotalBytes   = 0;
        *lpNumObjectTypes = 0;

		dwRetCode = NO_ERROR;
		goto Exit;
    }

    // Instance count is number of instances returned, so +1 for _Total instance
    dwInstanceCount = pNntpStatisticsBlockArray->cEntries + 1;

    // Instance index is number of virtual servers returned
    dwInstanceIndex = pNntpStatisticsBlockArray->cEntries;

    
    //
    //  always return an "instance sized" buffer after the definition
    //  blocks to prevent perfmon from reading bogus data. This is strictly
    //  a hack to accomodate how PERFMON handles the "0" instance case.
    //  By doing this, perfmon won't choke when there are no instances
    //  and the counter object & counters will be displayed in the list
    //  boxes, even though no instances will be listed.
    //

    pNntpDataDefinitionObject1 = (NNTP_DATA_DEFINITION_OBJECT1 *)*lppData;

    cbRequired = sizeof(NNTP_DATA_DEFINITION_OBJECT1) +
                 (dwInstanceCount * (sizeof(PERF_INSTANCE_DEFINITION) +
                 MAX_SIZEOF_INSTANCE_NAME +
                 sizeof (NNTP_COUNTER_BLOCK1)));

    cbRequired += sizeof(NNTP_DATA_DEFINITION_OBJECT2) +
                 (dwInstanceCount * (sizeof(PERF_INSTANCE_DEFINITION) +
                 MAX_SIZEOF_INSTANCE_NAME +
                 sizeof (NNTP_COUNTER_BLOCK2)));

    // for padding in the end.
    cbRequired += 8;
    //
    //  See if there's enough space.
    //

    if( *lpcbTotalBytes < cbRequired ) {

        //
        //  Nope.
        //

        *lpcbTotalBytes   = 0;
        *lpNumObjectTypes = 0;

		dwRetCode = ERROR_MORE_DATA;
		goto Exit;
    }

    //
    //  Copy the (constant, initialized) Object Type and counter definitions
    //  to the caller's data buffer
    //

    memmove( pNntpDataDefinitionObject1,
             &NntpDataDefinitionObject1,
             sizeof(NNTP_DATA_DEFINITION_OBJECT1) );

    //
    //  Create data for return for each instance
    //

    pPerfInstanceDefinition = (PERF_INSTANCE_DEFINITION *)
                                  &pNntpDataDefinitionObject1[1];

    //
    // Set first block of Buffer for _Total
    //

    MonBuildInstanceDefinition(
        pPerfInstanceDefinition,
        (PVOID *)&pCounterBlock1,
        0,
        0,
        (DWORD)-1, // use name
        TOTAL_INSTANCE_NAME );   // pass in instance name

    pTotal1 = pCounterBlock1;
    memset( pTotal1, 0, sizeof(NNTP_COUNTER_BLOCK1 ));
    pTotal1->PerfCounterBlock.ByteLength = sizeof (NNTP_COUNTER_BLOCK1);
    pPerfInstanceDefinition =
        (PERF_INSTANCE_DEFINITION *)((LPBYTE)pCounterBlock1 +
         sizeof(NNTP_COUNTER_BLOCK1));


    //
    //  Copy the data into the perfmon buffer
    //

    for( i = 0, dwCount = 1 ; (i < dwInstanceIndex) && dwCount < dwInstanceCount;
         i++ ) {

        pNntpStatisticsBlock = &(pNntpStatisticsBlockArray->aStatsBlock[i]);
        dwInstance = pNntpStatisticsBlock->dwInstance;
        pNntpStats = &(pNntpStatisticsBlock->Stats_0);

        wszKeyName[sizeof(wszKeyName)/sizeof(WCHAR) - 1] = L'\0';
        _snwprintf(wszKeyName, sizeof(wszKeyName)/sizeof(WCHAR) - 1,
            L"%d", dwInstance);

        MonBuildInstanceDefinition(
            pPerfInstanceDefinition,
            (PVOID *)&pCounterBlock1,
            0,
            0,
            (DWORD)-1, // use name
            (LPWSTR)wszKeyName );   // pass in instance name


        //
        //  Format the NNTP Server data.
        //

        CopyStatisticsData1( pNntpStats,
                             pCounterBlock1 );

        //
        //  update _total instance counters
        //

        Update_TotalStatisticsData1( pCounterBlock1,
                                     pTotal1 );

        pPerfInstanceDefinition =
            (PERF_INSTANCE_DEFINITION *)((LPBYTE)pCounterBlock1 +
             sizeof(NNTP_COUNTER_BLOCK1));

        dwCount++;

    }

    pNntpDataDefinitionObject1->NntpObjectType.NumInstances = dwInstanceCount;
    pNntpDataDefinitionObject1->NntpObjectType.TotalByteLength =
        *lpcbTotalBytes   = (DWORD)((PBYTE)pPerfInstanceDefinition -
                                    (PBYTE)pNntpDataDefinitionObject1);

	//
	//	Fill in data for Object 2 - the "NNTP Svc Client Request" object
	//

    *lppData          = (PVOID)(pPerfInstanceDefinition);
    pNntpDataDefinitionObject2 = (NNTP_DATA_DEFINITION_OBJECT2 *)*lppData;

    //
    //  Copy the (constant, initialized) Object Type and counter definitions
    //  to the caller's data buffer
    //

    memmove( pNntpDataDefinitionObject2,
             &NntpDataDefinitionObject2,
             sizeof(NNTP_DATA_DEFINITION_OBJECT2) );

    //
    //  Create data for return for each instance
    //

    pPerfInstanceDefinition = (PERF_INSTANCE_DEFINITION *)
                                  &pNntpDataDefinitionObject2[1];

    //
    // Set first block of Buffer for _Total
    //

    MonBuildInstanceDefinition(
        pPerfInstanceDefinition,
        (PVOID *)&pCounterBlock2,
        0,
        0,
        (DWORD)-1, // use name
        TOTAL_INSTANCE_NAME );   // pass in instance name

    pTotal2 = pCounterBlock2;
    memset( pTotal2, 0, sizeof(NNTP_COUNTER_BLOCK2 ));
    pTotal2->PerfCounterBlock.ByteLength = sizeof (NNTP_COUNTER_BLOCK2);
    pPerfInstanceDefinition =
        (PERF_INSTANCE_DEFINITION *)((LPBYTE)pCounterBlock2 +
         sizeof(NNTP_COUNTER_BLOCK2));

    for( i = 0, dwCount = 1 ; (i < dwInstanceIndex) && dwCount < dwInstanceCount;
         i++ ) {

        pNntpStatisticsBlock = &(pNntpStatisticsBlockArray->aStatsBlock[i]);
        dwInstance = pNntpStatisticsBlock->dwInstance;
        pNntpStats = &(pNntpStatisticsBlock->Stats_0);

        wszKeyName[sizeof(wszKeyName)/sizeof(WCHAR) - 1] = L'\0';
        _snwprintf(wszKeyName, sizeof(wszKeyName)/sizeof(WCHAR) - 1,
            L"%d", dwInstance);

        MonBuildInstanceDefinition(
            pPerfInstanceDefinition,
            (PVOID *)&pCounterBlock2,
            0,
            0,
            (DWORD)-1, // use name
            (LPWSTR)wszKeyName );   // pass in instance name


        //
        //  Format the NNTP Server data.
        //

        CopyStatisticsData2( pNntpStats,
                             pCounterBlock2 );

        //
        //  update _total instance counters
        //

        Update_TotalStatisticsData2( pCounterBlock2,
                                     pTotal2 );

        pPerfInstanceDefinition =
            (PERF_INSTANCE_DEFINITION *)((LPBYTE)pCounterBlock2 +
             sizeof(NNTP_COUNTER_BLOCK2));

        dwCount++;

		//
		//  Free the API buffer.
		//
    }

    //
	//  Free the API buffer.
	//

	NetApiBufferFree((LPBYTE)pNntpStatisticsBlockArray);


    //
    //  Update arguments for return.
    //

    *lppData          = (PVOID)(pPerfInstanceDefinition);
    _ASSERT(*lppData == ALIGN_ON_QWORD(*lppData));
    *lpNumObjectTypes = 2;

    pNntpDataDefinitionObject2->NntpObjectType.NumInstances = dwInstanceCount;
    pNntpDataDefinitionObject2->NntpObjectType.TotalByteLength =
							(DWORD)((PBYTE)pPerfInstanceDefinition -
                            ((PBYTE)pNntpDataDefinitionObject1 + *lpcbTotalBytes));

	*lpcbTotalBytes = 	(DWORD)((PBYTE)pPerfInstanceDefinition -
                                (PBYTE)pNntpDataDefinitionObject1);

    // Should we return with lppData aligned to 8 bytes or length aligned to 8 bytes if input lppData is not 8-byte aligned?
    //
    // Make the lenght of block multiple of 8-byte.  - By JenLC
    
    *lpcbTotalBytes = (*lpcbTotalBytes+7)&(~((DWORD)7));
    *lppData = (PBYTE)pNntpDataDefinitionObject1 + *lpcbTotalBytes;

Exit:

    //
    //  Success!  Honest!!
    //

    return dwRetCode;

}   // CollectNntpPerformanceData

/*******************************************************************

    NAME:       CloseNntpPerformanceData

    SYNOPSIS:   Terminates the performance counters.

    RETURNS:    DWORD - Win32 status code.

    HISTORY:
        KeithMo     07-Jun-1993 Created.

********************************************************************/
DWORD CloseNntpPerformanceData( VOID )
{
    //
    //  No real cleanup to do here.
    //

    if ((--cOpens) == 0) {
        // Done each time the perf data is collect instead of here
        // UninitAdminBase();
	}

    return NO_ERROR;

}   // CloseNntpPerformanceData

VOID
CopyStatisticsData1(
    IN  NNTP_STATISTICS_0           * pNntpStats,
    OUT NNTP_COUNTER_BLOCK1         * pCounterBlock
    )
{
    //
    //  Format the NNTP Server data for Object1
    //

    pCounterBlock->PerfCounterBlock.ByteLength = sizeof (NNTP_COUNTER_BLOCK1);

    pCounterBlock->BytesSent        = pNntpStats->TotalBytesSent.QuadPart;
    pCounterBlock->BytesReceived    = pNntpStats->TotalBytesReceived.QuadPart;
    pCounterBlock->BytesTotal       = pNntpStats->TotalBytesSent.QuadPart + pNntpStats->TotalBytesReceived.QuadPart;

    pCounterBlock->TotalConnections = pNntpStats->TotalConnections;
    pCounterBlock->TotalSSLConnections = pNntpStats->TotalSSLConnections;
    pCounterBlock->CurrentConnections = pNntpStats->CurrentConnections;
    pCounterBlock->MaxConnections = pNntpStats->MaxConnections;
    pCounterBlock->CurrentAnonymous = pNntpStats->CurrentAnonymousUsers;
    pCounterBlock->CurrentNonAnonymous = pNntpStats->CurrentNonAnonymousUsers;
    pCounterBlock->TotalAnonymous = pNntpStats->TotalAnonymousUsers;
    pCounterBlock->TotalNonAnonymous = pNntpStats->TotalNonAnonymousUsers;
    pCounterBlock->MaxAnonymous = pNntpStats->MaxAnonymousUsers;
    pCounterBlock->MaxNonAnonymous = pNntpStats->MaxNonAnonymousUsers;
    pCounterBlock->TotalOutboundConnects = pNntpStats->TotalOutboundConnects;
    pCounterBlock->OutboundConnectsFailed = pNntpStats->OutboundConnectsFailed;
    pCounterBlock->CurrentOutboundConnects = pNntpStats->CurrentOutboundConnects;
    pCounterBlock->OutboundLogonFailed = pNntpStats->OutboundLogonFailed;
    pCounterBlock->TotalPullFeeds = pNntpStats->TotalPullFeeds;
    pCounterBlock->TotalPushFeeds = pNntpStats->TotalPushFeeds;
    pCounterBlock->TotalPassiveFeeds = pNntpStats->TotalPassiveFeeds;
    pCounterBlock->ArticlesSent = pNntpStats->ArticlesSent;
    pCounterBlock->ArticlesReceived = pNntpStats->ArticlesReceived;
    pCounterBlock->ArticlesTotal = pNntpStats->ArticlesSent + pNntpStats->ArticlesReceived;
    pCounterBlock->ArticlesPosted = pNntpStats->ArticlesPosted;
    pCounterBlock->ArticleMapEntries = pNntpStats->ArticleMapEntries;
    pCounterBlock->HistoryMapEntries = pNntpStats->HistoryMapEntries;
    pCounterBlock->XoverEntries = pNntpStats->XoverEntries;
    pCounterBlock->ControlMessagesIn = pNntpStats->ControlMessagesIn;
    pCounterBlock->ControlMessagesFailed = pNntpStats->ControlMessagesFailed;
    pCounterBlock->ModeratedPostingsSent = pNntpStats->ModeratedPostingsSent;
    pCounterBlock->ModeratedPostingsFailed = pNntpStats->ModeratedPostingsFailed;
    pCounterBlock->SessionsFlowControlled = pNntpStats->SessionsFlowControlled;
    pCounterBlock->ArticlesExpired = pNntpStats->ArticlesExpired;
    pCounterBlock->ArticlesSentPerSec = pNntpStats->ArticlesSent;
    pCounterBlock->ArticlesReceivedPerSec = pNntpStats->ArticlesReceived;
    pCounterBlock->ArticlesPostedPerSec = pNntpStats->ArticlesPosted;
    pCounterBlock->ArticleMapEntriesPerSec = pNntpStats->ArticleMapEntries;
    pCounterBlock->HistoryMapEntriesPerSec = pNntpStats->HistoryMapEntries;
    pCounterBlock->XoverEntriesPerSec = pNntpStats->XoverEntries;
    pCounterBlock->ArticlesExpiredPerSec = pNntpStats->ArticlesExpired;

}   // CopyStatisticsData

VOID
CopyStatisticsData2(
    IN  NNTP_STATISTICS_0           * pNntpStats,
    OUT NNTP_COUNTER_BLOCK2         * pCounterBlock
    )
{
    //
    //  Format the NNTP Server data for Object2
    //

    pCounterBlock->PerfCounterBlock.ByteLength = sizeof (NNTP_COUNTER_BLOCK2);

    pCounterBlock->ArticleCmds = pNntpStats->ArticleCommands;
    pCounterBlock->ArticleCmdsPerSec = pNntpStats->ArticleCommands;
    pCounterBlock->GroupCmds = pNntpStats->GroupCommands;
    pCounterBlock->GroupCmdsPerSec = pNntpStats->GroupCommands;
    pCounterBlock->HelpCmds = pNntpStats->HelpCommands;
    pCounterBlock->HelpCmdsPerSec = pNntpStats->HelpCommands;
    pCounterBlock->IHaveCmds = pNntpStats->IHaveCommands;
    pCounterBlock->IHaveCmdsPerSec = pNntpStats->IHaveCommands;
    pCounterBlock->LastCmds = pNntpStats->LastCommands;
    pCounterBlock->LastCmdsPerSec = pNntpStats->LastCommands;
    pCounterBlock->ListCmds = pNntpStats->ListCommands;
    pCounterBlock->ListCmdsPerSec = pNntpStats->ListCommands;
    pCounterBlock->NewgroupsCmds = pNntpStats->NewgroupsCommands;
    pCounterBlock->NewgroupsCmdsPerSec = pNntpStats->NewgroupsCommands;
    pCounterBlock->NewnewsCmds = pNntpStats->NewnewsCommands;
    pCounterBlock->NewnewsCmdsPerSec = pNntpStats->NewnewsCommands;
    pCounterBlock->NextCmds = pNntpStats->NextCommands;
    pCounterBlock->NextCmdsPerSec = pNntpStats->NextCommands;
    pCounterBlock->PostCmds = pNntpStats->PostCommands;
    pCounterBlock->PostCmdsPerSec = pNntpStats->PostCommands;
    pCounterBlock->QuitCmds = pNntpStats->QuitCommands;
    pCounterBlock->QuitCmdsPerSec = pNntpStats->QuitCommands;
    pCounterBlock->StatCmds = pNntpStats->StatCommands;
    pCounterBlock->StatCmdsPerSec = pNntpStats->StatCommands;
    pCounterBlock->LogonAttempts = pNntpStats->LogonAttempts;
    pCounterBlock->LogonFailures = pNntpStats->LogonFailures;
    pCounterBlock->LogonAttemptsPerSec = pNntpStats->LogonAttempts;
    pCounterBlock->LogonFailuresPerSec = pNntpStats->LogonFailures;
    pCounterBlock->CheckCmds = pNntpStats->CheckCommands;
    pCounterBlock->CheckCmdsPerSec = pNntpStats->CheckCommands;
    pCounterBlock->TakethisCmds = pNntpStats->TakethisCommands;
    pCounterBlock->TakethisCmdsPerSec = pNntpStats->TakethisCommands;
    pCounterBlock->ModeCmds = pNntpStats->ModeCommands;
    pCounterBlock->ModeCmdsPerSec = pNntpStats->ModeCommands;
    pCounterBlock->SearchCmds = pNntpStats->SearchCommands;
    pCounterBlock->SearchCmdsPerSec = pNntpStats->SearchCommands;
    pCounterBlock->XHdrCmds = pNntpStats->XHdrCommands;
    pCounterBlock->XHdrCmdsPerSec = pNntpStats->XHdrCommands;
    pCounterBlock->XOverCmds = pNntpStats->XOverCommands;
    pCounterBlock->XOverCmdsPerSec = pNntpStats->XOverCommands;
    pCounterBlock->XPatCmds = pNntpStats->XPatCommands;
    pCounterBlock->XPatCmdsPerSec = pNntpStats->XPatCommands;
    pCounterBlock->XReplicCmds = pNntpStats->XReplicCommands;
    pCounterBlock->XReplicCmdsPerSec = pNntpStats->XReplicCommands;

}   // CopyStatisticsData

VOID
Update_TotalStatisticsData1(
    IN NNTP_COUNTER_BLOCK1         * pCounterBlock,
    OUT NNTP_COUNTER_BLOCK1        * pTotal
    )
{
    //
    //  update _total instance counters for Object1
    //

    pTotal->BytesSent += pCounterBlock->BytesSent;
    pTotal->BytesReceived    += pCounterBlock->BytesReceived;
    pTotal->BytesTotal       += pCounterBlock->BytesSent + pCounterBlock->BytesReceived;

    pTotal->TotalConnections += pCounterBlock->TotalConnections;
    pTotal->TotalSSLConnections += pCounterBlock->TotalSSLConnections;
    pTotal->CurrentConnections += pCounterBlock->CurrentConnections;
    pTotal->MaxConnections += pCounterBlock->MaxConnections;
    pTotal->CurrentAnonymous += pCounterBlock->CurrentAnonymous;
    pTotal->CurrentNonAnonymous += pCounterBlock->CurrentNonAnonymous;
    pTotal->TotalAnonymous += pCounterBlock->TotalAnonymous;
    pTotal->TotalNonAnonymous += pCounterBlock->TotalNonAnonymous;
    pTotal->MaxAnonymous += pCounterBlock->MaxAnonymous;
    pTotal->MaxNonAnonymous += pCounterBlock->MaxNonAnonymous;
    pTotal->TotalOutboundConnects += pCounterBlock->TotalOutboundConnects;
    pTotal->OutboundConnectsFailed += pCounterBlock->OutboundConnectsFailed;
    pTotal->CurrentOutboundConnects += pCounterBlock->CurrentOutboundConnects;
    pTotal->OutboundLogonFailed += pCounterBlock->OutboundLogonFailed;
    pTotal->TotalPullFeeds += pCounterBlock->TotalPullFeeds;
    pTotal->TotalPushFeeds += pCounterBlock->TotalPushFeeds;
    pTotal->TotalPassiveFeeds += pCounterBlock->TotalPassiveFeeds;
    pTotal->ArticlesSent += pCounterBlock->ArticlesSent;
    pTotal->ArticlesReceived += pCounterBlock->ArticlesReceived;
    pTotal->ArticlesTotal += pCounterBlock->ArticlesTotal;
    pTotal->ArticlesPosted += pCounterBlock->ArticlesPosted;
    pTotal->ArticleMapEntries += pCounterBlock->ArticleMapEntries;
    pTotal->HistoryMapEntries += pCounterBlock->HistoryMapEntries;
    pTotal->XoverEntries += pCounterBlock->XoverEntries;
    pTotal->ControlMessagesIn += pCounterBlock->ControlMessagesIn;
    pTotal->ControlMessagesFailed += pCounterBlock->ControlMessagesFailed;
    pTotal->ModeratedPostingsSent += pCounterBlock->ModeratedPostingsSent;
    pTotal->ModeratedPostingsFailed += pCounterBlock->ModeratedPostingsFailed;
    pTotal->SessionsFlowControlled += pCounterBlock->SessionsFlowControlled;
    pTotal->ArticlesExpired += pCounterBlock->ArticlesExpired;
    pTotal->ArticlesSentPerSec += pCounterBlock->ArticlesSentPerSec;
    pTotal->ArticlesReceivedPerSec += pCounterBlock->ArticlesReceivedPerSec;
    pTotal->ArticlesPostedPerSec += pCounterBlock->ArticlesPostedPerSec;
    pTotal->ArticleMapEntriesPerSec += pCounterBlock->ArticleMapEntriesPerSec;
    pTotal->HistoryMapEntriesPerSec += pCounterBlock->HistoryMapEntriesPerSec;
    pTotal->XoverEntriesPerSec += pCounterBlock->XoverEntriesPerSec;
    pTotal->ArticlesExpiredPerSec += pCounterBlock->ArticlesExpiredPerSec;

}   // Update_TotalStatisticsData

VOID
Update_TotalStatisticsData2(
    IN NNTP_COUNTER_BLOCK2         * pCounterBlock,
    OUT NNTP_COUNTER_BLOCK2        * pTotal
    )
{
    //
    //  update _total instance counters for Object2
    //

    pTotal->ArticleCmds += pCounterBlock->ArticleCmds;
    pTotal->ArticleCmdsPerSec += pCounterBlock->ArticleCmdsPerSec;
    pTotal->GroupCmds += pCounterBlock->GroupCmds;
    pTotal->GroupCmdsPerSec += pCounterBlock->GroupCmdsPerSec;
    pTotal->HelpCmds += pCounterBlock->HelpCmds;
    pTotal->HelpCmdsPerSec += pCounterBlock->HelpCmdsPerSec;
    pTotal->IHaveCmds += pCounterBlock->IHaveCmds;
    pTotal->IHaveCmdsPerSec += pCounterBlock->IHaveCmdsPerSec;
    pTotal->LastCmds += pCounterBlock->LastCmds;
    pTotal->LastCmdsPerSec += pCounterBlock->LastCmdsPerSec;
    pTotal->ListCmds += pCounterBlock->ListCmds;
    pTotal->ListCmdsPerSec += pCounterBlock->ListCmdsPerSec;
    pTotal->NewgroupsCmds += pCounterBlock->NewgroupsCmds;
    pTotal->NewgroupsCmdsPerSec += pCounterBlock->NewgroupsCmdsPerSec;
    pTotal->NewnewsCmds += pCounterBlock->NewnewsCmds;
    pTotal->NewnewsCmdsPerSec += pCounterBlock->NewnewsCmdsPerSec;
    pTotal->NextCmds += pCounterBlock->NextCmds;
    pTotal->NextCmdsPerSec += pCounterBlock->NextCmdsPerSec;
    pTotal->PostCmds += pCounterBlock->PostCmds;
    pTotal->PostCmdsPerSec += pCounterBlock->PostCmdsPerSec;
    pTotal->QuitCmds += pCounterBlock->QuitCmds;
    pTotal->QuitCmdsPerSec += pCounterBlock->QuitCmdsPerSec;
    pTotal->StatCmds += pCounterBlock->StatCmds;
    pTotal->StatCmdsPerSec += pCounterBlock->StatCmdsPerSec;
    pTotal->LogonAttempts += pCounterBlock->LogonAttempts;
    pTotal->LogonFailures += pCounterBlock->LogonFailures;
    pTotal->LogonAttemptsPerSec += pCounterBlock->LogonAttemptsPerSec;
    pTotal->LogonFailuresPerSec += pCounterBlock->LogonFailuresPerSec;
    pTotal->CheckCmds += pCounterBlock->CheckCmds;
    pTotal->CheckCmdsPerSec += pCounterBlock->CheckCmdsPerSec;
    pTotal->TakethisCmds += pCounterBlock->TakethisCmds;
    pTotal->TakethisCmdsPerSec += pCounterBlock->TakethisCmdsPerSec;
    pTotal->ModeCmds += pCounterBlock->ModeCmds;
    pTotal->ModeCmdsPerSec += pCounterBlock->ModeCmdsPerSec;
    pTotal->SearchCmds += pCounterBlock->SearchCmds;
    pTotal->SearchCmdsPerSec += pCounterBlock->SearchCmdsPerSec;
    pTotal->XHdrCmds += pCounterBlock->XHdrCmds;
    pTotal->XHdrCmdsPerSec += pCounterBlock->XHdrCmdsPerSec;
    pTotal->XOverCmds += pCounterBlock->XOverCmds;
    pTotal->XOverCmdsPerSec += pCounterBlock->XOverCmdsPerSec;
    pTotal->XPatCmds += pCounterBlock->XPatCmds;
    pTotal->XPatCmdsPerSec += pCounterBlock->XPatCmdsPerSec;
    pTotal->XReplicCmds += pCounterBlock->XReplicCmds;
    pTotal->XReplicCmdsPerSec += pCounterBlock->XReplicCmdsPerSec;

}   // Update_TotalStatisticsData

VOID
UpdateNameAndHelpIndicies(
					IN DWORD dwFirstCounter,
					IN DWORD dwFirstHelp
					)
{
	NNTP_COUNTER_BLOCK1 nntpc1;
	NNTP_COUNTER_BLOCK2 nntpc2;

	//
    //  Update the object & counter name & help indicies for object1
    //

    NntpDataDefinitionObject1.NntpObjectType.ObjectNameTitleIndex
        += dwFirstCounter;
    NntpDataDefinitionObject1.NntpObjectType.ObjectHelpTitleIndex
        += dwFirstHelp;

    NntpDataDefinitionObject1.NntpBytesSent.CounterNameTitleIndex
        += dwFirstCounter;
    NntpDataDefinitionObject1.NntpBytesSent.CounterHelpTitleIndex
        += dwFirstHelp;
    NntpDataDefinitionObject1.NntpBytesSent.CounterOffset =
        (DWORD)((LPBYTE)&nntpc1.BytesSent - (LPBYTE)&nntpc1);

    NntpDataDefinitionObject1.NntpBytesReceived.CounterNameTitleIndex
        += dwFirstCounter;
    NntpDataDefinitionObject1.NntpBytesReceived.CounterHelpTitleIndex
        += dwFirstHelp;
    NntpDataDefinitionObject1.NntpBytesReceived.CounterOffset =
        (DWORD)((LPBYTE)&nntpc1.BytesReceived - (LPBYTE)&nntpc1);

    NntpDataDefinitionObject1.NntpBytesTotal.CounterNameTitleIndex
        += dwFirstCounter;
    NntpDataDefinitionObject1.NntpBytesTotal.CounterHelpTitleIndex
        += dwFirstHelp;
    NntpDataDefinitionObject1.NntpBytesTotal.CounterOffset =
        (DWORD)((LPBYTE)&nntpc1.BytesTotal - (LPBYTE)&nntpc1);

    NntpDataDefinitionObject1.NntpTotalConnections.CounterNameTitleIndex
        += dwFirstCounter;
    NntpDataDefinitionObject1.NntpTotalConnections.CounterHelpTitleIndex
        += dwFirstHelp;
    NntpDataDefinitionObject1.NntpTotalConnections.CounterOffset =
        (DWORD)((LPBYTE)&nntpc1.TotalConnections - (LPBYTE)&nntpc1);

    NntpDataDefinitionObject1.NntpTotalSSLConnections.CounterNameTitleIndex
        += dwFirstCounter;
    NntpDataDefinitionObject1.NntpTotalSSLConnections.CounterHelpTitleIndex
        += dwFirstHelp;
    NntpDataDefinitionObject1.NntpTotalSSLConnections.CounterOffset =
        (DWORD)((LPBYTE)&nntpc1.TotalSSLConnections - (LPBYTE)&nntpc1);

    NntpDataDefinitionObject1.NntpCurrentConnections.CounterNameTitleIndex
        += dwFirstCounter;
    NntpDataDefinitionObject1.NntpCurrentConnections.CounterHelpTitleIndex
        += dwFirstHelp;
    NntpDataDefinitionObject1.NntpCurrentConnections.CounterOffset =
        (DWORD)((LPBYTE)&nntpc1.CurrentConnections - (LPBYTE)&nntpc1);

    NntpDataDefinitionObject1.NntpMaxConnections.CounterNameTitleIndex
        += dwFirstCounter;
    NntpDataDefinitionObject1.NntpMaxConnections.CounterHelpTitleIndex
        += dwFirstHelp;
    NntpDataDefinitionObject1.NntpMaxConnections.CounterOffset =
        (DWORD)((LPBYTE)&nntpc1.MaxConnections - (LPBYTE)&nntpc1);

    NntpDataDefinitionObject1.NntpCurrentAnonymous.CounterNameTitleIndex
        += dwFirstCounter;
    NntpDataDefinitionObject1.NntpCurrentAnonymous.CounterHelpTitleIndex
        += dwFirstHelp;
    NntpDataDefinitionObject1.NntpCurrentAnonymous.CounterOffset =
        (DWORD)((LPBYTE)&nntpc1.CurrentAnonymous - (LPBYTE)&nntpc1);

    NntpDataDefinitionObject1.NntpCurrentNonAnonymous.CounterNameTitleIndex
        += dwFirstCounter;
    NntpDataDefinitionObject1.NntpCurrentNonAnonymous.CounterHelpTitleIndex
        += dwFirstHelp;
    NntpDataDefinitionObject1.NntpCurrentNonAnonymous.CounterOffset =
        (DWORD)((LPBYTE)&nntpc1.CurrentNonAnonymous - (LPBYTE)&nntpc1);

    NntpDataDefinitionObject1.NntpTotalAnonymous.CounterNameTitleIndex
        += dwFirstCounter;
    NntpDataDefinitionObject1.NntpTotalAnonymous.CounterHelpTitleIndex
        += dwFirstHelp;
    NntpDataDefinitionObject1.NntpTotalAnonymous.CounterOffset =
        (DWORD)((LPBYTE)&nntpc1.TotalAnonymous - (LPBYTE)&nntpc1);

    NntpDataDefinitionObject1.NntpTotalNonAnonymous.CounterNameTitleIndex
        += dwFirstCounter;
    NntpDataDefinitionObject1.NntpTotalNonAnonymous.CounterHelpTitleIndex
        += dwFirstHelp;
    NntpDataDefinitionObject1.NntpTotalNonAnonymous.CounterOffset =
        (DWORD)((LPBYTE)&nntpc1.TotalNonAnonymous - (LPBYTE)&nntpc1);

    NntpDataDefinitionObject1.NntpMaxAnonymous.CounterNameTitleIndex
        += dwFirstCounter;
    NntpDataDefinitionObject1.NntpMaxAnonymous.CounterHelpTitleIndex
        += dwFirstHelp;
    NntpDataDefinitionObject1.NntpMaxAnonymous.CounterOffset =
        (DWORD)((LPBYTE)&nntpc1.MaxAnonymous - (LPBYTE)&nntpc1);

    NntpDataDefinitionObject1.NntpMaxNonAnonymous.CounterNameTitleIndex
        += dwFirstCounter;
    NntpDataDefinitionObject1.NntpMaxNonAnonymous.CounterHelpTitleIndex
        += dwFirstHelp;
    NntpDataDefinitionObject1.NntpMaxNonAnonymous.CounterOffset =
        (DWORD)((LPBYTE)&nntpc1.MaxNonAnonymous - (LPBYTE)&nntpc1);

    NntpDataDefinitionObject1.NntpTotalOutboundConnects.CounterNameTitleIndex
        += dwFirstCounter;
    NntpDataDefinitionObject1.NntpTotalOutboundConnects.CounterHelpTitleIndex
        += dwFirstHelp;
    NntpDataDefinitionObject1.NntpTotalOutboundConnects.CounterOffset =
        (DWORD)((LPBYTE)&nntpc1.TotalOutboundConnects - (LPBYTE)&nntpc1);

    NntpDataDefinitionObject1.NntpOutboundConnectsFailed.CounterNameTitleIndex
        += dwFirstCounter;
    NntpDataDefinitionObject1.NntpOutboundConnectsFailed.CounterHelpTitleIndex
        += dwFirstHelp;
    NntpDataDefinitionObject1.NntpOutboundConnectsFailed.CounterOffset =
        (DWORD)((LPBYTE)&nntpc1.OutboundConnectsFailed - (LPBYTE)&nntpc1);

    NntpDataDefinitionObject1.NntpCurrentOutboundConnects.CounterNameTitleIndex
        += dwFirstCounter;
    NntpDataDefinitionObject1.NntpCurrentOutboundConnects.CounterHelpTitleIndex
        += dwFirstHelp;
    NntpDataDefinitionObject1.NntpCurrentOutboundConnects.CounterOffset =
        (DWORD)((LPBYTE)&nntpc1.CurrentOutboundConnects - (LPBYTE)&nntpc1);

    NntpDataDefinitionObject1.NntpOutboundLogonFailed.CounterNameTitleIndex
        += dwFirstCounter;
    NntpDataDefinitionObject1.NntpOutboundLogonFailed.CounterHelpTitleIndex
        += dwFirstHelp;
    NntpDataDefinitionObject1.NntpOutboundLogonFailed.CounterOffset =
        (DWORD)((LPBYTE)&nntpc1.OutboundLogonFailed - (LPBYTE)&nntpc1);

    NntpDataDefinitionObject1.NntpTotalPullFeeds.CounterNameTitleIndex
        += dwFirstCounter;
    NntpDataDefinitionObject1.NntpTotalPullFeeds.CounterHelpTitleIndex
        += dwFirstHelp;
    NntpDataDefinitionObject1.NntpTotalPullFeeds.CounterOffset =
        (DWORD)((LPBYTE)&nntpc1.TotalPullFeeds - (LPBYTE)&nntpc1);

    NntpDataDefinitionObject1.NntpTotalPushFeeds.CounterNameTitleIndex
        += dwFirstCounter;
    NntpDataDefinitionObject1.NntpTotalPushFeeds.CounterHelpTitleIndex
        += dwFirstHelp;
    NntpDataDefinitionObject1.NntpTotalPushFeeds.CounterOffset =
        (DWORD)((LPBYTE)&nntpc1.TotalPushFeeds - (LPBYTE)&nntpc1);

    NntpDataDefinitionObject1.NntpTotalPassiveFeeds.CounterNameTitleIndex
        += dwFirstCounter;
    NntpDataDefinitionObject1.NntpTotalPassiveFeeds.CounterHelpTitleIndex
        += dwFirstHelp;
    NntpDataDefinitionObject1.NntpTotalPassiveFeeds.CounterOffset =
        (DWORD)((LPBYTE)&nntpc1.TotalPassiveFeeds - (LPBYTE)&nntpc1);

    NntpDataDefinitionObject1.NntpArticlesSent.CounterNameTitleIndex
        += dwFirstCounter;
    NntpDataDefinitionObject1.NntpArticlesSent.CounterHelpTitleIndex
        += dwFirstHelp;
    NntpDataDefinitionObject1.NntpArticlesSent.CounterOffset =
        (DWORD)((LPBYTE)&nntpc1.ArticlesSent - (LPBYTE)&nntpc1);

    NntpDataDefinitionObject1.NntpArticlesReceived.CounterNameTitleIndex
        += dwFirstCounter;
    NntpDataDefinitionObject1.NntpArticlesReceived.CounterHelpTitleIndex
        += dwFirstHelp;
    NntpDataDefinitionObject1.NntpArticlesReceived.CounterOffset =
        (DWORD)((LPBYTE)&nntpc1.ArticlesReceived - (LPBYTE)&nntpc1);

    NntpDataDefinitionObject1.NntpArticlesTotal.CounterNameTitleIndex
        += dwFirstCounter;
    NntpDataDefinitionObject1.NntpArticlesTotal.CounterHelpTitleIndex
        += dwFirstHelp;
    NntpDataDefinitionObject1.NntpArticlesTotal.CounterOffset =
        (DWORD)((LPBYTE)&nntpc1.ArticlesTotal - (LPBYTE)&nntpc1);

    NntpDataDefinitionObject1.NntpArticlesPosted.CounterNameTitleIndex
        += dwFirstCounter;
    NntpDataDefinitionObject1.NntpArticlesPosted.CounterHelpTitleIndex
        += dwFirstHelp;
    NntpDataDefinitionObject1.NntpArticlesPosted.CounterOffset =
        (DWORD)((LPBYTE)&nntpc1.ArticlesPosted - (LPBYTE)&nntpc1);

    NntpDataDefinitionObject1.NntpArticleMapEntries.CounterNameTitleIndex
        += dwFirstCounter;
    NntpDataDefinitionObject1.NntpArticleMapEntries.CounterHelpTitleIndex
        += dwFirstHelp;
    NntpDataDefinitionObject1.NntpArticleMapEntries.CounterOffset =
        (DWORD)((LPBYTE)&nntpc1.ArticleMapEntries - (LPBYTE)&nntpc1);

    NntpDataDefinitionObject1.NntpHistoryMapEntries.CounterNameTitleIndex
        += dwFirstCounter;
    NntpDataDefinitionObject1.NntpHistoryMapEntries.CounterHelpTitleIndex
        += dwFirstHelp;
    NntpDataDefinitionObject1.NntpHistoryMapEntries.CounterOffset =
        (DWORD)((LPBYTE)&nntpc1.HistoryMapEntries - (LPBYTE)&nntpc1);

    NntpDataDefinitionObject1.NntpXoverEntries.CounterNameTitleIndex
        += dwFirstCounter;
    NntpDataDefinitionObject1.NntpXoverEntries.CounterHelpTitleIndex
        += dwFirstHelp;
    NntpDataDefinitionObject1.NntpXoverEntries.CounterOffset =
        (DWORD)((LPBYTE)&nntpc1.XoverEntries - (LPBYTE)&nntpc1);

    NntpDataDefinitionObject1.NntpControlMessagesIn.CounterNameTitleIndex
        += dwFirstCounter;
    NntpDataDefinitionObject1.NntpControlMessagesIn.CounterHelpTitleIndex
        += dwFirstHelp;
    NntpDataDefinitionObject1.NntpControlMessagesIn.CounterOffset =
        (DWORD)((LPBYTE)&nntpc1.ControlMessagesIn - (LPBYTE)&nntpc1);

    NntpDataDefinitionObject1.NntpControlMessagesFailed.CounterNameTitleIndex
        += dwFirstCounter;
    NntpDataDefinitionObject1.NntpControlMessagesFailed.CounterHelpTitleIndex
        += dwFirstHelp;
    NntpDataDefinitionObject1.NntpControlMessagesFailed.CounterOffset =
        (DWORD)((LPBYTE)&nntpc1.ControlMessagesFailed - (LPBYTE)&nntpc1);

    NntpDataDefinitionObject1.NntpModeratedPostingsSent.CounterNameTitleIndex
        += dwFirstCounter;
    NntpDataDefinitionObject1.NntpModeratedPostingsSent.CounterHelpTitleIndex
        += dwFirstHelp;
    NntpDataDefinitionObject1.NntpModeratedPostingsSent.CounterOffset =
        (DWORD)((LPBYTE)&nntpc1.ModeratedPostingsSent - (LPBYTE)&nntpc1);

    NntpDataDefinitionObject1.NntpModeratedPostingsFailed.CounterNameTitleIndex
        += dwFirstCounter;
    NntpDataDefinitionObject1.NntpModeratedPostingsFailed.CounterHelpTitleIndex
        += dwFirstHelp;
    NntpDataDefinitionObject1.NntpModeratedPostingsFailed.CounterOffset =
        (DWORD)((LPBYTE)&nntpc1.ModeratedPostingsFailed - (LPBYTE)&nntpc1);

    NntpDataDefinitionObject1.NntpSessionsFlowControlled.CounterNameTitleIndex
        += dwFirstCounter;
    NntpDataDefinitionObject1.NntpSessionsFlowControlled.CounterHelpTitleIndex
        += dwFirstHelp;
    NntpDataDefinitionObject1.NntpSessionsFlowControlled.CounterOffset =
        (DWORD)((LPBYTE)&nntpc1.SessionsFlowControlled - (LPBYTE)&nntpc1);

    NntpDataDefinitionObject1.NntpArticlesExpired.CounterNameTitleIndex
        += dwFirstCounter;
    NntpDataDefinitionObject1.NntpArticlesExpired.CounterHelpTitleIndex
        += dwFirstHelp;
    NntpDataDefinitionObject1.NntpArticlesExpired.CounterOffset =
        (DWORD)((LPBYTE)&nntpc1.ArticlesExpired - (LPBYTE)&nntpc1);

    NntpDataDefinitionObject1.NntpArticlesSentPerSec.CounterNameTitleIndex
        += dwFirstCounter;
    NntpDataDefinitionObject1.NntpArticlesSentPerSec.CounterHelpTitleIndex
        += dwFirstHelp;
    NntpDataDefinitionObject1.NntpArticlesSentPerSec.CounterOffset =
        (DWORD)((LPBYTE)&nntpc1.ArticlesSentPerSec - (LPBYTE)&nntpc1);

    NntpDataDefinitionObject1.NntpArticlesReceivedPerSec.CounterNameTitleIndex
        += dwFirstCounter;
    NntpDataDefinitionObject1.NntpArticlesReceivedPerSec.CounterHelpTitleIndex
        += dwFirstHelp;
    NntpDataDefinitionObject1.NntpArticlesReceivedPerSec.CounterOffset =
        (DWORD)((LPBYTE)&nntpc1.ArticlesReceivedPerSec - (LPBYTE)&nntpc1);

    NntpDataDefinitionObject1.NntpArticlesPostedPerSec.CounterNameTitleIndex
        += dwFirstCounter;
    NntpDataDefinitionObject1.NntpArticlesPostedPerSec.CounterHelpTitleIndex
        += dwFirstHelp;
    NntpDataDefinitionObject1.NntpArticlesPostedPerSec.CounterOffset =
        (DWORD)((LPBYTE)&nntpc1.ArticlesPostedPerSec - (LPBYTE)&nntpc1);

    NntpDataDefinitionObject1.NntpArticleMapEntriesPerSec.CounterNameTitleIndex
        += dwFirstCounter;
    NntpDataDefinitionObject1.NntpArticleMapEntriesPerSec.CounterHelpTitleIndex
        += dwFirstHelp;
    NntpDataDefinitionObject1.NntpArticleMapEntriesPerSec.CounterOffset =
        (DWORD)((LPBYTE)&nntpc1.ArticleMapEntriesPerSec - (LPBYTE)&nntpc1);

    NntpDataDefinitionObject1.NntpHistoryMapEntriesPerSec.CounterNameTitleIndex
        += dwFirstCounter;
    NntpDataDefinitionObject1.NntpHistoryMapEntriesPerSec.CounterHelpTitleIndex
        += dwFirstHelp;
    NntpDataDefinitionObject1.NntpHistoryMapEntriesPerSec.CounterOffset =
        (DWORD)((LPBYTE)&nntpc1.HistoryMapEntriesPerSec - (LPBYTE)&nntpc1);

    NntpDataDefinitionObject1.NntpXoverEntriesPerSec.CounterNameTitleIndex
        += dwFirstCounter;
    NntpDataDefinitionObject1.NntpXoverEntriesPerSec.CounterHelpTitleIndex
        += dwFirstHelp;
    NntpDataDefinitionObject1.NntpXoverEntriesPerSec.CounterOffset =
        (DWORD)((LPBYTE)&nntpc1.XoverEntriesPerSec - (LPBYTE)&nntpc1);

    NntpDataDefinitionObject1.NntpArticlesExpiredPerSec.CounterNameTitleIndex
        += dwFirstCounter;
    NntpDataDefinitionObject1.NntpArticlesExpiredPerSec.CounterHelpTitleIndex
        += dwFirstHelp;
    NntpDataDefinitionObject1.NntpArticlesExpiredPerSec.CounterOffset =
        (DWORD)((LPBYTE)&nntpc1.ArticlesExpiredPerSec - (LPBYTE)&nntpc1);

	//
    //  Update the object & counter name & help indicies for object2
    //

    NntpDataDefinitionObject2.NntpObjectType.ObjectNameTitleIndex
        += dwFirstCounter;
    NntpDataDefinitionObject2.NntpObjectType.ObjectHelpTitleIndex
        += dwFirstHelp;

    NntpDataDefinitionObject2.NntpArticleCmds.CounterNameTitleIndex
        += dwFirstCounter;
    NntpDataDefinitionObject2.NntpArticleCmds.CounterHelpTitleIndex
        += dwFirstHelp;
    NntpDataDefinitionObject2.NntpArticleCmds.CounterOffset =
        (DWORD)((LPBYTE)&nntpc2.ArticleCmds - (LPBYTE)&nntpc2);

    NntpDataDefinitionObject2.NntpArticleCmdsPerSec.CounterNameTitleIndex
        += dwFirstCounter;
    NntpDataDefinitionObject2.NntpArticleCmdsPerSec.CounterHelpTitleIndex
        += dwFirstHelp;
    NntpDataDefinitionObject2.NntpArticleCmdsPerSec.CounterOffset =
        (DWORD)((LPBYTE)&nntpc2.ArticleCmdsPerSec - (LPBYTE)&nntpc2);

    NntpDataDefinitionObject2.NntpGroupCmds.CounterNameTitleIndex
        += dwFirstCounter;
    NntpDataDefinitionObject2.NntpGroupCmds.CounterHelpTitleIndex
        += dwFirstHelp;
    NntpDataDefinitionObject2.NntpGroupCmds.CounterOffset =
        (DWORD)((LPBYTE)&nntpc2.GroupCmds - (LPBYTE)&nntpc2);

    NntpDataDefinitionObject2.NntpGroupCmdsPerSec.CounterNameTitleIndex
        += dwFirstCounter;
    NntpDataDefinitionObject2.NntpGroupCmdsPerSec.CounterHelpTitleIndex
        += dwFirstHelp;
    NntpDataDefinitionObject2.NntpGroupCmdsPerSec.CounterOffset =
        (DWORD)((LPBYTE)&nntpc2.GroupCmdsPerSec - (LPBYTE)&nntpc2);

    NntpDataDefinitionObject2.NntpHelpCmds.CounterNameTitleIndex
        += dwFirstCounter;
    NntpDataDefinitionObject2.NntpHelpCmds.CounterHelpTitleIndex
        += dwFirstHelp;
    NntpDataDefinitionObject2.NntpHelpCmds.CounterOffset =
        (DWORD)((LPBYTE)&nntpc2.HelpCmds - (LPBYTE)&nntpc2);

    NntpDataDefinitionObject2.NntpHelpCmdsPerSec.CounterNameTitleIndex
        += dwFirstCounter;
    NntpDataDefinitionObject2.NntpHelpCmdsPerSec.CounterHelpTitleIndex
        += dwFirstHelp;
    NntpDataDefinitionObject2.NntpHelpCmdsPerSec.CounterOffset =
        (DWORD)((LPBYTE)&nntpc2.HelpCmdsPerSec - (LPBYTE)&nntpc2);

    NntpDataDefinitionObject2.NntpIHaveCmds.CounterNameTitleIndex
        += dwFirstCounter;
    NntpDataDefinitionObject2.NntpIHaveCmds.CounterHelpTitleIndex
        += dwFirstHelp;
    NntpDataDefinitionObject2.NntpIHaveCmds.CounterOffset =
        (DWORD)((LPBYTE)&nntpc2.IHaveCmds - (LPBYTE)&nntpc2);

    NntpDataDefinitionObject2.NntpIHaveCmdsPerSec.CounterNameTitleIndex
        += dwFirstCounter;
    NntpDataDefinitionObject2.NntpIHaveCmdsPerSec.CounterHelpTitleIndex
        += dwFirstHelp;
    NntpDataDefinitionObject2.NntpIHaveCmdsPerSec.CounterOffset =
        (DWORD)((LPBYTE)&nntpc2.IHaveCmdsPerSec - (LPBYTE)&nntpc2);

    NntpDataDefinitionObject2.NntpLastCmds.CounterNameTitleIndex
        += dwFirstCounter;
    NntpDataDefinitionObject2.NntpLastCmds.CounterHelpTitleIndex
        += dwFirstHelp;
    NntpDataDefinitionObject2.NntpLastCmds.CounterOffset =
        (DWORD)((LPBYTE)&nntpc2.LastCmds - (LPBYTE)&nntpc2);

    NntpDataDefinitionObject2.NntpLastCmdsPerSec.CounterNameTitleIndex
        += dwFirstCounter;
    NntpDataDefinitionObject2.NntpLastCmdsPerSec.CounterHelpTitleIndex
        += dwFirstHelp;
    NntpDataDefinitionObject2.NntpLastCmdsPerSec.CounterOffset =
        (DWORD)((LPBYTE)&nntpc2.LastCmdsPerSec - (LPBYTE)&nntpc2);

    NntpDataDefinitionObject2.NntpListCmds.CounterNameTitleIndex
        += dwFirstCounter;
    NntpDataDefinitionObject2.NntpListCmds.CounterHelpTitleIndex
        += dwFirstHelp;
    NntpDataDefinitionObject2.NntpListCmds.CounterOffset =
        (DWORD)((LPBYTE)&nntpc2.ListCmds - (LPBYTE)&nntpc2);

    NntpDataDefinitionObject2.NntpListCmdsPerSec.CounterNameTitleIndex
        += dwFirstCounter;
    NntpDataDefinitionObject2.NntpListCmdsPerSec.CounterHelpTitleIndex
        += dwFirstHelp;
    NntpDataDefinitionObject2.NntpListCmdsPerSec.CounterOffset =
        (DWORD)((LPBYTE)&nntpc2.ListCmdsPerSec - (LPBYTE)&nntpc2);

    NntpDataDefinitionObject2.NntpNewgroupsCmds.CounterNameTitleIndex
        += dwFirstCounter;
    NntpDataDefinitionObject2.NntpNewgroupsCmds.CounterHelpTitleIndex
        += dwFirstHelp;
    NntpDataDefinitionObject2.NntpNewgroupsCmds.CounterOffset =
        (DWORD)((LPBYTE)&nntpc2.NewgroupsCmds - (LPBYTE)&nntpc2);

    NntpDataDefinitionObject2.NntpNewgroupsCmdsPerSec.CounterNameTitleIndex
        += dwFirstCounter;
    NntpDataDefinitionObject2.NntpNewgroupsCmdsPerSec.CounterHelpTitleIndex
        += dwFirstHelp;
    NntpDataDefinitionObject2.NntpNewgroupsCmdsPerSec.CounterOffset =
        (DWORD)((LPBYTE)&nntpc2.NewgroupsCmdsPerSec - (LPBYTE)&nntpc2);

    NntpDataDefinitionObject2.NntpNewnewsCmds.CounterNameTitleIndex
        += dwFirstCounter;
    NntpDataDefinitionObject2.NntpNewnewsCmds.CounterHelpTitleIndex
        += dwFirstHelp;
    NntpDataDefinitionObject2.NntpNewnewsCmds.CounterOffset =
        (DWORD)((LPBYTE)&nntpc2.NewnewsCmds - (LPBYTE)&nntpc2);

    NntpDataDefinitionObject2.NntpNewnewsCmdsPerSec.CounterNameTitleIndex
        += dwFirstCounter;
    NntpDataDefinitionObject2.NntpNewnewsCmdsPerSec.CounterHelpTitleIndex
        += dwFirstHelp;
    NntpDataDefinitionObject2.NntpNewnewsCmdsPerSec.CounterOffset =
        (DWORD)((LPBYTE)&nntpc2.NewnewsCmdsPerSec - (LPBYTE)&nntpc2);

    NntpDataDefinitionObject2.NntpNextCmds.CounterNameTitleIndex
        += dwFirstCounter;
    NntpDataDefinitionObject2.NntpNextCmds.CounterHelpTitleIndex
        += dwFirstHelp;
    NntpDataDefinitionObject2.NntpNextCmds.CounterOffset =
        (DWORD)((LPBYTE)&nntpc2.NextCmds - (LPBYTE)&nntpc2);

    NntpDataDefinitionObject2.NntpNextCmdsPerSec.CounterNameTitleIndex
        += dwFirstCounter;
    NntpDataDefinitionObject2.NntpNextCmdsPerSec.CounterHelpTitleIndex
        += dwFirstHelp;
    NntpDataDefinitionObject2.NntpNextCmdsPerSec.CounterOffset =
        (DWORD)((LPBYTE)&nntpc2.NextCmdsPerSec - (LPBYTE)&nntpc2);

    NntpDataDefinitionObject2.NntpPostCmds.CounterNameTitleIndex
        += dwFirstCounter;
    NntpDataDefinitionObject2.NntpPostCmds.CounterHelpTitleIndex
        += dwFirstHelp;
    NntpDataDefinitionObject2.NntpPostCmds.CounterOffset =
        (DWORD)((LPBYTE)&nntpc2.PostCmds - (LPBYTE)&nntpc2);

    NntpDataDefinitionObject2.NntpPostCmdsPerSec.CounterNameTitleIndex
        += dwFirstCounter;
    NntpDataDefinitionObject2.NntpPostCmdsPerSec.CounterHelpTitleIndex
        += dwFirstHelp;
    NntpDataDefinitionObject2.NntpPostCmdsPerSec.CounterOffset =
        (DWORD)((LPBYTE)&nntpc2.PostCmdsPerSec - (LPBYTE)&nntpc2);

    NntpDataDefinitionObject2.NntpQuitCmds.CounterNameTitleIndex
        += dwFirstCounter;
    NntpDataDefinitionObject2.NntpQuitCmds.CounterHelpTitleIndex
        += dwFirstHelp;
    NntpDataDefinitionObject2.NntpQuitCmds.CounterOffset =
        (DWORD)((LPBYTE)&nntpc2.QuitCmds - (LPBYTE)&nntpc2);

    NntpDataDefinitionObject2.NntpQuitCmdsPerSec.CounterNameTitleIndex
        += dwFirstCounter;
    NntpDataDefinitionObject2.NntpQuitCmdsPerSec.CounterHelpTitleIndex
        += dwFirstHelp;
    NntpDataDefinitionObject2.NntpQuitCmdsPerSec.CounterOffset =
        (DWORD)((LPBYTE)&nntpc2.QuitCmdsPerSec - (LPBYTE)&nntpc2);

    NntpDataDefinitionObject2.NntpStatCmds.CounterNameTitleIndex
        += dwFirstCounter;
    NntpDataDefinitionObject2.NntpStatCmds.CounterHelpTitleIndex
        += dwFirstHelp;
    NntpDataDefinitionObject2.NntpStatCmds.CounterOffset =
        (DWORD)((LPBYTE)&nntpc2.StatCmds - (LPBYTE)&nntpc2);

    NntpDataDefinitionObject2.NntpStatCmdsPerSec.CounterNameTitleIndex
        += dwFirstCounter;
    NntpDataDefinitionObject2.NntpStatCmdsPerSec.CounterHelpTitleIndex
        += dwFirstHelp;
    NntpDataDefinitionObject2.NntpStatCmdsPerSec.CounterOffset =
        (DWORD)((LPBYTE)&nntpc2.StatCmdsPerSec - (LPBYTE)&nntpc2);

    NntpDataDefinitionObject2.NntpLogonAttempts.CounterNameTitleIndex
        += dwFirstCounter;
    NntpDataDefinitionObject2.NntpLogonAttempts.CounterHelpTitleIndex
        += dwFirstHelp;
    NntpDataDefinitionObject2.NntpLogonAttempts.CounterOffset =
        (DWORD)((LPBYTE)&nntpc2.LogonAttempts - (LPBYTE)&nntpc2);

    NntpDataDefinitionObject2.NntpLogonFailures.CounterNameTitleIndex
        += dwFirstCounter;
    NntpDataDefinitionObject2.NntpLogonFailures.CounterHelpTitleIndex
        += dwFirstHelp;
    NntpDataDefinitionObject2.NntpLogonFailures.CounterOffset =
        (DWORD)((LPBYTE)&nntpc2.LogonFailures - (LPBYTE)&nntpc2);

    NntpDataDefinitionObject2.NntpLogonAttemptsPerSec.CounterNameTitleIndex
        += dwFirstCounter;
    NntpDataDefinitionObject2.NntpLogonAttemptsPerSec.CounterHelpTitleIndex
        += dwFirstHelp;
    NntpDataDefinitionObject2.NntpLogonAttemptsPerSec.CounterOffset =
        (DWORD)((LPBYTE)&nntpc2.LogonAttemptsPerSec - (LPBYTE)&nntpc2);

    NntpDataDefinitionObject2.NntpLogonFailuresPerSec.CounterNameTitleIndex
        += dwFirstCounter;
    NntpDataDefinitionObject2.NntpLogonFailuresPerSec.CounterHelpTitleIndex
        += dwFirstHelp;
    NntpDataDefinitionObject2.NntpLogonFailuresPerSec.CounterOffset =
        (DWORD)((LPBYTE)&nntpc2.LogonFailuresPerSec - (LPBYTE)&nntpc2);

    NntpDataDefinitionObject2.NntpCheckCmds.CounterNameTitleIndex
        += dwFirstCounter;
    NntpDataDefinitionObject2.NntpCheckCmds.CounterHelpTitleIndex
        += dwFirstHelp;
    NntpDataDefinitionObject2.NntpCheckCmds.CounterOffset =
        (DWORD)((LPBYTE)&nntpc2.CheckCmds - (LPBYTE)&nntpc2);

    NntpDataDefinitionObject2.NntpCheckCmdsPerSec.CounterNameTitleIndex
        += dwFirstCounter;
    NntpDataDefinitionObject2.NntpCheckCmdsPerSec.CounterHelpTitleIndex
        += dwFirstHelp;
    NntpDataDefinitionObject2.NntpCheckCmdsPerSec.CounterOffset =
        (DWORD)((LPBYTE)&nntpc2.CheckCmdsPerSec - (LPBYTE)&nntpc2);

    NntpDataDefinitionObject2.NntpTakethisCmds.CounterNameTitleIndex
        += dwFirstCounter;
    NntpDataDefinitionObject2.NntpTakethisCmds.CounterHelpTitleIndex
        += dwFirstHelp;
    NntpDataDefinitionObject2.NntpTakethisCmds.CounterOffset =
        (DWORD)((LPBYTE)&nntpc2.TakethisCmds - (LPBYTE)&nntpc2);

    NntpDataDefinitionObject2.NntpTakethisCmdsPerSec.CounterNameTitleIndex
        += dwFirstCounter;
    NntpDataDefinitionObject2.NntpTakethisCmdsPerSec.CounterHelpTitleIndex
        += dwFirstHelp;
    NntpDataDefinitionObject2.NntpTakethisCmdsPerSec.CounterOffset =
        (DWORD)((LPBYTE)&nntpc2.TakethisCmdsPerSec - (LPBYTE)&nntpc2);

    NntpDataDefinitionObject2.NntpModeCmds.CounterNameTitleIndex
        += dwFirstCounter;
    NntpDataDefinitionObject2.NntpModeCmds.CounterHelpTitleIndex
        += dwFirstHelp;
    NntpDataDefinitionObject2.NntpModeCmds.CounterOffset =
        (DWORD)((LPBYTE)&nntpc2.ModeCmds - (LPBYTE)&nntpc2);

    NntpDataDefinitionObject2.NntpModeCmdsPerSec.CounterNameTitleIndex
        += dwFirstCounter;
    NntpDataDefinitionObject2.NntpModeCmdsPerSec.CounterHelpTitleIndex
        += dwFirstHelp;
    NntpDataDefinitionObject2.NntpModeCmdsPerSec.CounterOffset =
        (DWORD)((LPBYTE)&nntpc2.ModeCmdsPerSec - (LPBYTE)&nntpc2);

    NntpDataDefinitionObject2.NntpSearchCmds.CounterNameTitleIndex
        += dwFirstCounter;
    NntpDataDefinitionObject2.NntpSearchCmds.CounterHelpTitleIndex
        += dwFirstHelp;
    NntpDataDefinitionObject2.NntpSearchCmds.CounterOffset =
        (DWORD)((LPBYTE)&nntpc2.SearchCmds - (LPBYTE)&nntpc2);

    NntpDataDefinitionObject2.NntpSearchCmdsPerSec.CounterNameTitleIndex
        += dwFirstCounter;
    NntpDataDefinitionObject2.NntpSearchCmdsPerSec.CounterHelpTitleIndex
        += dwFirstHelp;
    NntpDataDefinitionObject2.NntpSearchCmdsPerSec.CounterOffset =
        (DWORD)((LPBYTE)&nntpc2.SearchCmdsPerSec - (LPBYTE)&nntpc2);

    NntpDataDefinitionObject2.NntpXHdrCmds.CounterNameTitleIndex
        += dwFirstCounter;
    NntpDataDefinitionObject2.NntpXHdrCmds.CounterHelpTitleIndex
        += dwFirstHelp;
    NntpDataDefinitionObject2.NntpXHdrCmds.CounterOffset =
        (DWORD)((LPBYTE)&nntpc2.XHdrCmds - (LPBYTE)&nntpc2);

    NntpDataDefinitionObject2.NntpXHdrCmdsPerSec.CounterNameTitleIndex
        += dwFirstCounter;
    NntpDataDefinitionObject2.NntpXHdrCmdsPerSec.CounterHelpTitleIndex
        += dwFirstHelp;
    NntpDataDefinitionObject2.NntpXHdrCmdsPerSec.CounterOffset =
        (DWORD)((LPBYTE)&nntpc2.XHdrCmdsPerSec - (LPBYTE)&nntpc2);

    NntpDataDefinitionObject2.NntpXOverCmds.CounterNameTitleIndex
        += dwFirstCounter;
    NntpDataDefinitionObject2.NntpXOverCmds.CounterHelpTitleIndex
        += dwFirstHelp;
    NntpDataDefinitionObject2.NntpXOverCmds.CounterOffset =
        (DWORD)((LPBYTE)&nntpc2.XOverCmds - (LPBYTE)&nntpc2);

    NntpDataDefinitionObject2.NntpXOverCmdsPerSec.CounterNameTitleIndex
        += dwFirstCounter;
    NntpDataDefinitionObject2.NntpXOverCmdsPerSec.CounterHelpTitleIndex
        += dwFirstHelp;
    NntpDataDefinitionObject2.NntpXOverCmdsPerSec.CounterOffset =
        (DWORD)((LPBYTE)&nntpc2.XOverCmdsPerSec - (LPBYTE)&nntpc2);

    NntpDataDefinitionObject2.NntpXPatCmds.CounterNameTitleIndex
        += dwFirstCounter;
    NntpDataDefinitionObject2.NntpXPatCmds.CounterHelpTitleIndex
        += dwFirstHelp;
    NntpDataDefinitionObject2.NntpXPatCmds.CounterOffset =
        (DWORD)((LPBYTE)&nntpc2.XPatCmds - (LPBYTE)&nntpc2);

    NntpDataDefinitionObject2.NntpXPatCmdsPerSec.CounterNameTitleIndex
        += dwFirstCounter;
    NntpDataDefinitionObject2.NntpXPatCmdsPerSec.CounterHelpTitleIndex
        += dwFirstHelp;
    NntpDataDefinitionObject2.NntpXPatCmdsPerSec.CounterOffset =
        (DWORD)((LPBYTE)&nntpc2.XPatCmdsPerSec - (LPBYTE)&nntpc2);

    NntpDataDefinitionObject2.NntpXReplicCmds.CounterNameTitleIndex
        += dwFirstCounter;
    NntpDataDefinitionObject2.NntpXReplicCmds.CounterHelpTitleIndex
        += dwFirstHelp;
    NntpDataDefinitionObject2.NntpXReplicCmds.CounterOffset =
        (DWORD)((LPBYTE)&nntpc2.XReplicCmds - (LPBYTE)&nntpc2);

    NntpDataDefinitionObject2.NntpXReplicCmdsPerSec.CounterNameTitleIndex
        += dwFirstCounter;
    NntpDataDefinitionObject2.NntpXReplicCmdsPerSec.CounterHelpTitleIndex
        += dwFirstHelp;
    NntpDataDefinitionObject2.NntpXReplicCmdsPerSec.CounterOffset =
        (DWORD)((LPBYTE)&nntpc2.XReplicCmdsPerSec - (LPBYTE)&nntpc2);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\nntp\nntpctrs\perfutil.c ===
/*++

   Copyright    (c)    1995    Microsoft Corporation

   Module  Name :

      perfutil.c

   Abstract:

      This file implements the utility routines used for all perfmon 
       interface dlls in the internet services group.

   Author:

       Murali R. Krishnan    ( MuraliK )     16-Nov-1995  
          Pulled from  perfmon interface common code.

   Environment:
       User Mode
       
   Project:

       Internet Servies Common Runtime functions

   Functions Exported:

        DWORD GetQueryType();
        BOOL  IsNumberInUnicodeList();
        VOID  MonBuildInstanceDefinition();

   Revision History:

       Sophia Chung (sophiac)  05-Nov-1996
          Added routine to support multiple instances

--*/


/************************************************************
 *     Include Headers
 ************************************************************/

#include <windows.h>
#include <string.h>

#include <winperf.h>
#include <perfutil.h>


/************************************************************
 *     Global Data Definitions
 ************************************************************/

WCHAR GLOBAL_STRING[] = L"Global";
WCHAR FOREIGN_STRING[] = L"Foreign";
WCHAR COSTLY_STRING[] = L"Costly";

// test for delimiter, end of line and non-digit characters
// used by IsNumberInUnicodeList routine
//
#define DIGIT       1
#define DELIMITER   2
#define INVALID     3

#define EvalThisChar(c,d) ( \
     (c == d) ? DELIMITER : \
     (c == 0) ? DELIMITER : \
     (c < (WCHAR)'0') ? INVALID : \
     (c > (WCHAR)'9') ? INVALID : \
     DIGIT)

#define ALIGN_ON_QWORD(x) \
     ((VOID *)(((ULONG_PTR)(x) + ((8)-1)) & ~((ULONG_PTR)(8)-1)))


/************************************************************
 *    Functions 
 ************************************************************/



DWORD
GetQueryType (
    IN LPWSTR lpValue
)
/*++

GetQueryType

    returns the type of query described in the lpValue string so that
    the appropriate processing method may be used

Arguments

    IN lpValue
        string passed to PerfRegQuery Value for processing

Return Value

    QUERY_GLOBAL
        if lpValue == 0 (null pointer)
           lpValue == pointer to Null string
           lpValue == pointer to "Global" string

    QUERY_FOREIGN
        if lpValue == pointer to "Foriegn" string

    QUERY_COSTLY
        if lpValue == pointer to "Costly" string

    otherwise:

    QUERY_ITEMS

--*/
{
    WCHAR   *pwcArgChar, *pwcTypeChar;
    BOOL    bFound;

    if (lpValue == 0) {
        return QUERY_GLOBAL;
    } else if (*lpValue == 0) {
        return QUERY_GLOBAL;
    }

    // check for "Global" request

    pwcArgChar = lpValue;
    pwcTypeChar = GLOBAL_STRING;
    bFound = TRUE;  // assume found until contradicted

    // check to the length of the shortest string

    while ((*pwcArgChar != 0) && (*pwcTypeChar != 0)) {
        if (*pwcArgChar++ != *pwcTypeChar++) {
            bFound = FALSE; // no match
            break;          // bail out now
        }
    }

    if (bFound) return QUERY_GLOBAL;

    // check for "Foreign" request

    pwcArgChar = lpValue;
    pwcTypeChar = FOREIGN_STRING;
    bFound = TRUE;  // assume found until contradicted

    // check to the length of the shortest string

    while ((*pwcArgChar != 0) && (*pwcTypeChar != 0)) {
        if (*pwcArgChar++ != *pwcTypeChar++) {
            bFound = FALSE; // no match
            break;          // bail out now
        }
    }

    if (bFound) return QUERY_FOREIGN;

    // check for "Costly" request

    pwcArgChar = lpValue;
    pwcTypeChar = COSTLY_STRING;
    bFound = TRUE;  // assume found until contradicted

    // check to the length of the shortest string

    while ((*pwcArgChar != 0) && (*pwcTypeChar != 0)) {
        if (*pwcArgChar++ != *pwcTypeChar++) {
            bFound = FALSE; // no match
            break;          // bail out now
        }
    }

    if (bFound) return QUERY_COSTLY;

    // if not Global and not Foreign and not Costly,
    // then it must be an item list

    return QUERY_ITEMS;

}



BOOL
IsNumberInUnicodeList (
    IN DWORD   dwNumber,
    IN LPWSTR  lpwszUnicodeList
)
/*++

IsNumberInUnicodeList

Arguments:

    IN dwNumber
        DWORD number to find in list

    IN lpwszUnicodeList
        Null terminated, Space delimited list of decimal numbers

Return Value:

    TRUE:
            dwNumber was found in the list of unicode number strings

    FALSE:
            dwNumber was not found in the list.

--*/
{
    DWORD   dwThisNumber;
    WCHAR   *pwcThisChar;
    BOOL    bValidNumber;
    BOOL    bNewItem;
    WCHAR   wcDelimiter;    // could be an argument to be more flexible

    if (lpwszUnicodeList == 0) return FALSE;    // null pointer, # not founde

    pwcThisChar = lpwszUnicodeList;
    dwThisNumber = 0;
    wcDelimiter = (WCHAR)' ';
    bValidNumber = FALSE;
    bNewItem = TRUE;

    while (TRUE) {
        switch (EvalThisChar (*pwcThisChar, wcDelimiter)) {
            case DIGIT:
                // if this is the first digit after a delimiter, then
                // set flags to start computing the new number
                if (bNewItem) {
                    bNewItem = FALSE;
                    bValidNumber = TRUE;
                }
                if (bValidNumber) {
                    dwThisNumber *= 10;
                    dwThisNumber += (*pwcThisChar - (WCHAR)'0');
                }
                break;

            case DELIMITER:
                // a delimter is either the delimiter character or the
                // end of the string ('\0') if when the delimiter has been
                // reached a valid number was found, then compare it to the
                // number from the argument list. if this is the end of the
                // string and no match was found, then return.
                //
                if (bValidNumber) {
                    if (dwThisNumber == dwNumber) return TRUE;
                    bValidNumber = FALSE;
                }
                if (*pwcThisChar == 0) {
                    return FALSE;
                } else {
                    bNewItem = TRUE;
                    dwThisNumber = 0;
                }
                break;

            case INVALID:
                // if an invalid character was encountered, ignore all
                // characters up to the next delimiter and then start fresh.
                // the invalid number is not compared.
                bValidNumber = FALSE;
                break;

            default:
                break;

        }
        pwcThisChar++;
    }

}   // IsNumberInUnicodeList



VOID
MonBuildInstanceDefinition(
    OUT PERF_INSTANCE_DEFINITION *pBuffer,
    OUT PVOID *pBufferNext,
    IN DWORD ParentObjectTitleIndex,
    IN DWORD ParentObjectInstance,
    IN DWORD UniqueID,
    IN LPWSTR Name
    )
/*++

MonBuildInstanceDefinition  

    Build an instance of an object

Arguments:

    OUT pBuffer         -   pointer to buffer where instance is to
                            be constructed

    OUT pBufferNext     -   pointer to a pointer which will contain
                                next available location, DWORD aligned

    IN  ParentObjectTitleIndex
                        -   Title Index of parent object type; 0 if
                            no parent object

    IN  ParentObjectInstance
                        -   Index into instances of parent object
                            type, starting at 0, for this instances
                            parent object instance

    IN  UniqueID        -   a unique identifier which should be used
                            instead of the Name for identifying
                            this instance

    IN  Name            -   Name of this instance

Return Value:

    None.

--*/
{
    DWORD NameLength;
    LPWSTR pName;
    //
    //  Include trailing null in name size
    //

    NameLength = (lstrlenW(Name) + 1) * sizeof(WCHAR);

    pBuffer->ByteLength = sizeof(PERF_INSTANCE_DEFINITION) +
                          DWORD_MULTIPLE(NameLength);

    pBuffer->ParentObjectTitleIndex = ParentObjectTitleIndex;
    pBuffer->ParentObjectInstance = ParentObjectInstance;
    pBuffer->UniqueID = UniqueID;
    pBuffer->NameOffset = sizeof(PERF_INSTANCE_DEFINITION);
    pBuffer->NameLength = NameLength;

    // copy name to name buffer
    pName = (LPWSTR)&pBuffer[1];
    RtlMoveMemory(pName,Name,NameLength);

#if 0
    // allign on 8 byte boundary for new NT5 requirement
    pBuffer->ByteLength = QWORD_MULTIPLE(pBuffer->ByteLength);
    // update "next byte" pointer
    *pBufferNext = (PVOID) ((PCHAR) pBuffer + pBuffer->ByteLength);
#endif

    // update "next byte" pointer
    *pBufferNext = (PVOID) ((PCHAR) pBuffer + pBuffer->ByteLength);

    // round up to put next buffer on a QUADWORD boundry
    *pBufferNext = ALIGN_ON_QWORD (*pBufferNext);
    // adjust length value to match new length
    pBuffer->ByteLength = (ULONG)((ULONG_PTR)*pBufferNext - (ULONG_PTR)pBuffer);

    return;
}



/************************ End of File ***********************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\nntp\server\article\src\datetime.cxx ===
/*++

   Copyright    (c)    1994    Microsoft Corporation

   Module  Name :

      datetime.cxx

   Abstract:

      This module exports common functions for date and time fields,
      Expanding into strings and manipulation.

   Author:

           Murali R. Krishnan    ( MuraliK )    3-Jan-1995

   Project:

      Internet Services Common DLL

   Functions Exported:

      SystemTimeToGMT()
      NtLargeIntegerTimeToSystemTime()

   Revision History:

      MuraliK    23-Feb-1996      Added IslFormatDate()

--*/


/************************************************************
 *     Include Headers
 ************************************************************/

#include	<stdlib.h>
#include "stdinc.h"

#ifndef DBG_ASSERT
#define	DBG_ASSERT( f )		_ASSERT( f )
#endif

/************************************************************
 *   Data
 ************************************************************/
static  TCHAR * s_rgchDays[] =  {
    TEXT("Sun"),
    TEXT("Mon"),
    TEXT("Tue"),
    TEXT("Wed"),
    TEXT("Thu"),
    TEXT("Fri"),
    TEXT("Sat") };

static TCHAR * s_rgchMonths[] = {
    TEXT("Jan"),
    TEXT("Feb"),
    TEXT("Mar"),
    TEXT("Apr"),
    TEXT("May"),
    TEXT("Jun"),
    TEXT("Jul"),
    TEXT("Aug"),
    TEXT("Sep"),
    TEXT("Oct"),
    TEXT("Nov"),
    TEXT("Dec") };

/************************************************************
 *    Functions
 ************************************************************/

int
make_month(
    TCHAR * s
    )
{
    int i;

    for (i=0; i<12; i++)
        if (!_strnicmp(s_rgchMonths[i], s, 3))
            return i + 1;
    return 0;
}


BOOL
SystemTimeToGMT(
    IN  const SYSTEMTIME & st,
    OUT CHAR *             pszBuff,
    IN  DWORD              cbBuff
    )
/*++
  Converts the given system time to string representation
  containing GMT Formatted String.

  Arguments:
      st         System time that needs to be converted.
      pstr       pointer to string which will contain the GMT time on
                  successful return.
      cbBuff     size of pszBuff in bytes

  Returns:
     TRUE on success.  FALSE on failure.

  History:
     MuraliK        3-Jan-1995
--*/
{
    DBG_ASSERT( pszBuff != NULL);

    if ( cbBuff < 40 ) {
        SetLastError( ERROR_INSUFFICIENT_BUFFER );
        return FALSE;
    }

    //
    //  Formats a string like: "Thu, 14 Jul 1994 15:26:05 GMT"
    //

    ::wsprintf( pszBuff,
                TEXT( "%s, %02d %s %04d %02d:%02d:%02d GMT"),
                s_rgchDays[st.wDayOfWeek],
                st.wDay,
                s_rgchMonths[st.wMonth - 1],
                st.wYear,
                st.wHour,
                st.wMinute,
                st.wSecond);

    return ( TRUE);

} // SystemTimeToGMT()

BOOL
NtLargeIntegerTimeToLocalSystemTime(
    IN const LARGE_INTEGER * pliTime,
    OUT SYSTEMTIME * pst)
/*++
  Converts the time returned by NTIO apis ( which is a LARGE_INTEGER) into
  Win32 SystemTime in Local Time zone.

  Arguments:
    pliTime        pointer to large integer containing the time in NT format.
    pst            pointer to SYSTEMTIME structure which contains the time
                         fields on successful conversion.

  Returns:
    TRUE on success and FALSE on failure.

  History:

    MuraliK            27-Apr-1995

  Limitations:
     This is an NT specific function !! Reason is: Win32 uses FILETIME
      structure for times. However LARGE_INTEGER and FILETIME both use
      similar structure with one difference that is one has a LONG while
      other has a ULONG.
--*/
{
    FILETIME  ftLocal;

    if ( pliTime == NULL || pst == NULL) {

        SetLastError( ERROR_INVALID_PARAMETER);
        return ( FALSE);
    }

    //
    //  Convert the given large integer to local file time and
    //  then convert that to SYSTEMTIME.
    //   structure, containing the time details.
    //  I dont like this cast ( assumes too much about time structures)
    //   but again suitable methods are not available.
    //
    return (FileTimeToLocalFileTime((FILETIME *) pliTime,
                                     &ftLocal) &&
            FileTimeToSystemTime(&ftLocal, pst)
            );

} // NtLargeIntegerTimeToLocalSystemTime()

BOOL
SystemTimeToGMTEx(
    IN  const SYSTEMTIME & st,
    OUT CHAR *      pszBuff,
    IN  DWORD       cbBuff,
    IN  DWORD       csecOffset
    )
/*++
  Converts the given system time to string representation
  containing GMT Formatted String.

  Arguments:
      st         System time that needs to be converted.
      pstr       pointer to string which will contain the GMT time on
                  successful return.
      cbBuff     size of pszBuff in bytes
      csecOffset The number of seconds to offset the specified system time

  Returns:
     TRUE on success.  FALSE on failure.

  History:
     MuraliK        3-Jan-1995
--*/
{
    SYSTEMTIME    sttmp;
    DWORD         dwSeconds = 0;
    ULARGE_INTEGER liTime;
    FILETIME    ft;

    DBG_ASSERT( pszBuff != NULL);

    //
    //  If an offset is specified, calculate that now
    //

    if (!SystemTimeToFileTime( &st, &ft )) {
        return(FALSE);
    }

    liTime.HighPart = ft.dwHighDateTime;
    liTime.LowPart = ft.dwLowDateTime;

    //
    //  Nt Large integer times are stored in 100ns increments, so convert the
    //  second offset to 100ns increments then add it
    //

    liTime.QuadPart += ((ULONGLONG) csecOffset) * (ULONGLONG) 10000000;

    ft.dwHighDateTime = liTime.HighPart;
    ft.dwLowDateTime = liTime.LowPart;

    FileTimeToSystemTime( &ft, &sttmp );

    return SystemTimeToGMT( sttmp,
                            pszBuff,
                            cbBuff );
} // SystemTimeToGMTEx

BOOL
NtLargeIntegerTimeToSystemTime(
    IN const LARGE_INTEGER & liTime,
    OUT SYSTEMTIME * pst)
/*++
  Converts the time returned by NTIO apis ( which is a LARGE_INTEGER) into
  Win32 SystemTime in GMT

  Arguments:
    liTime             large integer containing the time in NT format.
    pst                pointer to SYSTEMTIME structure which contains the time
                         fields on successful conversion.

  Returns:
    TRUE on success and FALSE on failure.

  History:

    MuraliK            3-Jan-1995

  Limitations:
     This is an NT specific function !! Reason is: Win32 uses FILETIME
      structure for times. However LARGE_INTEGER and FILETIME both use
      similar structure with one difference that is one has a LONG while
      other has a ULONG. Will that make a difference ? God knows.
       Or substitute whatever you want for God...
--*/
{
    FILETIME ft;

    if ( pst == NULL) {

        SetLastError( ERROR_INVALID_PARAMETER);
        return ( FALSE);
    }

    //
    // convert li to filetime
    //

    ft.dwLowDateTime = liTime.LowPart;
    ft.dwHighDateTime = liTime.HighPart;

    //
    // convert to system time
    //

    if (!FileTimeToSystemTime(&ft,pst)) {
        return(FALSE);
    }

    return ( TRUE);

} // NtLargeIntegerTimeToSystemTime()

BOOL
NtSystemTimeToLargeInteger(
    IN  const SYSTEMTIME * pst,
    OUT LARGE_INTEGER *    pli
    )
{

    FILETIME ft;

    //
    // Convert to file time
    //

    if ( !SystemTimeToFileTime( pst, &ft ) ) {
        return(FALSE);
    }

    //
    // Convert file time to large integer
    //

    pli->LowPart = ft.dwLowDateTime;
    pli->HighPart = ft.dwHighDateTime;

    return(TRUE);
}

BOOL
StringTimeToFileTime(
    IN  const TCHAR * pszTime,
    OUT LARGE_INTEGER * pliTime
    )
/*++

  Converts a string representation of a GMT time (three different
  varieties) to an NT representation of a file time.

  We handle the following variations:

    Sun, 06 Nov 1994 08:49:37 GMT   (RFC 822 updated by RFC 1123)
    Sunday, 06-Nov-94 08:49:37 GMT  (RFC 850)
    Sun Nov  6 08:49:37 1994        (ANSI C's asctime() format

  Arguments:
    pszTime             String representation of time field
    pliTime             large integer containing the time in NT format.

  Returns:
    TRUE on success and FALSE on failure.

  History:

    Johnl       24-Jan-1995     Modified from WWW library

--*/
{

    TCHAR * s;
    SYSTEMTIME    st;

    if (!pszTime) {
        SetLastError( ERROR_INVALID_PARAMETER );
        return FALSE;
    }

    st.wMilliseconds = 0;

    if ((s = strchr(pszTime, ','))) {    /* Thursday, 10-Jun-93 01:29:59 GMT */
        s++;                /* or: Thu, 10 Jan 1993 01:29:59 GMT */
        while (*s && *s==' ') s++;
        if (strchr(s,'-')) {        /* First format */

            if ((int)strlen(s) < 18) {
                SetLastError( ERROR_INVALID_PARAMETER );
                return FALSE;
            }
            st.wDay = (WORD)atoi(s);
            st.wMonth = (WORD)make_month(s+3);
            st.wYear = (WORD)atoi(s+7);
            st.wHour = (WORD)atoi(s+10);
            st.wMinute = (WORD)atoi(s+13);
            st.wSecond = (WORD)atoi(s+16);
        } else {                /* Second format */

            if ((int)strlen(s) < 20) {
                SetLastError( ERROR_INVALID_PARAMETER );
                return FALSE;
            }
            st.wDay = (WORD)atoi(s);
            st.wMonth = (WORD)make_month(s+3);
            st.wYear = (WORD)atoi(s+7);
            st.wHour = (WORD)atoi(s+12);
            st.wMinute = (WORD)atoi(s+15);
            st.wSecond = (WORD)atoi(s+18);

        }
    } else {    /* Try the other format:  Wed Jun  9 01:29:59 1993 GMT */

        s = (TCHAR *) pszTime;
        while (*s && *s==' ') s++;

        if ((int)strlen(s) < 24) {
            SetLastError( ERROR_INVALID_PARAMETER );
            return FALSE;
        }

        st.wDay = (WORD)atoi(s+8);
        st.wMonth = (WORD)make_month(s+4);
        st.wYear = (WORD)atoi(s+22);
        st.wHour = (WORD)atoi(s+11);
        st.wMinute = (WORD)atoi(s+14);
        st.wSecond = (WORD)atoi(s+17);
    }

    //
    //  Adjust for dates with only two digits
    //

    if ( st.wYear < 1000 ) {
        if ( st.wYear < 50 ) {
            st.wYear += 2000;
        } else {
            st.wYear += 1900;
        }
    }

    if ( !NtSystemTimeToLargeInteger( &st,pliTime )) {
        SetLastError( ERROR_INVALID_PARAMETER );
        return FALSE;
    }
    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\nntp\server\article\src\frmstore.cpp ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    fromclnt.cpp

Abstract:

	Contains InFeed, Article, and Fields code specific to FromStore Infeeds

	As the name suggests, these for for processing articles that come from
	clients. The idea is to be very strict in what is allowed from the client.
	If an article doesn't match spec, it is either fixed or rejected.


Author:

    Carl Kadie (CarlK)     05-Dec-1995

Revision History:

--*/

#ifdef  _NO_TEMPLATES_
#define DEFINE_CGROUPLST_FUNCTIONS
#endif

#include "stdinc.h"
//#include <artcore.h>
//#include    <stdlib.h>

#define FROMSTOREART_SIGNATURE  (DWORD) 'ArtC'

//
// CPool is used to allocate memory while processing an article.
//

CPool  CFromStoreArticle::g_ArticlePool(FROMSTOREART_SIGNATURE);

//
//  Largest possible CFromStoreArticle derived object
//
#define MAX_ARTICLE_SIZE    sizeof( CFromStoreArticle )

//
// An upperbound on the number of article objects that can
// exist at any time.
//
const   unsigned    cbMAX_ARTICLE_SIZE = MAX_ARTICLE_SIZE ;

void*
CFromStoreArticle::operator      new(    size_t  size )
{
        _ASSERT( size <= cbMAX_ARTICLE_SIZE ) ;
        return  g_ArticlePool.Alloc() ;
}

void
CFromStoreArticle::operator      delete( void*   pv )
{
        g_ArticlePool.Free( pv ) ;
}

BOOL
CFromStoreArticle::InitClass(
					void
					)
/*++

Routine Description:

    Preallocates memory for CArticle objects

Arguments:

    None.

Return Value:

    TRUE, if successful. FALSE, otherwise.

--*/
{
	return	g_ArticlePool.ReserveMemory( MAX_ARTICLES, cbMAX_ARTICLE_SIZE ) ;
}


BOOL
CFromStoreArticle::TermClass(
					void
					)
/*++

Routine Description:

    Called when objects are freed.

Arguments:

    None.

Return Value:

    TRUE

--*/
{

	_ASSERT( g_ArticlePool.GetAllocCount() == 0 ) ;

	BOOL b;

	b =	g_ArticlePool.ReleaseMemory() ;
    //delete g_ArticlePool;
    return b;

}


BOOL
CFromStoreArticle::fValidate(
							//CPCString& pcHub,
							//const char * szCommand,
							//CInFeed*	pInFeed,
							CNntpReturn & nntpReturn
							)
/*++

Routine Description:

	Validates an article from a client. Does not change the article
	except to fix (if necessary) the capitalization of some header keywords.

Arguments:

	szCommand - The arguments (if any) used to post/xreplic/etc this article.
	nntpReturn - The return value for this function call


Return Value:

	TRUE, if successful. FALSE, otherwise.

--*/
{

	//
	// Check article state
	//

	_ASSERT(asPreParsed == m_articleState);

    //
    // Check required and optional fields
    //

	CField * rgPFields [] = {
            &m_fieldControl,
			&m_fieldSubject,
			&m_fieldNewsgroups,
			&m_fieldDistribution,
			&m_fieldFrom,
			&m_fieldDate,
			&m_fieldFollowupTo,
			&m_fieldReplyTo,
			&m_fieldApproved,
			&m_fieldSender,
			&m_fieldOrganization,
			&m_fieldSummary,
			&m_fieldReferences,
			&m_fieldLines,
			&m_fieldKeyword,
			&m_fieldExpires,
			&m_fieldPath,
			//&m_fieldNNTPPostingHost,  // forget about NNTP Posting Host for now...
			&m_fieldMessageID	// must be last - as we may not want to parse it !
				};
	DWORD cFields = sizeof(rgPFields)/sizeof(CField *);

    // By default, we honor Message-Id
    cFields;

	if (!fFindAndParseList((CField * *) rgPFields, cFields, nntpReturn))
	{
    	return (nntpReturn.fFalse());
        //return FALSE;
    }

	CPCString	pcDate = m_fieldDate.pcGet() ;
	if( pcDate.m_pch != 0 ) {

		if( !AgeCheck( pcDate ) ) {
			nntpReturn.fSet( nrcArticleDateTooOld ) ;
			return	FALSE ;
		}
	}


	//
	// Confirm (and fix, if necessary) the capitalization of the fields
	//

	if (!fConfirmCapsList((CField * *) rgPFields, cFields, nntpReturn))
		return nntpReturn.fFalse();
        //return FALSE;
//
	//!!!CLIENT LATER Not doing anything with control messages
	//

	/* !!!CLIENT LATER
	Body
	SHOULD limit signatures -- !!!LATER
	Early  difficulties in inferring return addresses from article headers led to "signatures": short closing texts,  automatically  added  to  the end of articles by posting agents, identifying the poster and giving his network addresses etc.  If  a  poster

 or posting agent does append a signature to an article, the signature SHOULD be preceded with  a  delimiter line  containing  (only)  two hyphens (ASCII 45) followed by one blank (ASCII  32).   Posting  agents  SHOULD  limit  the length  of  signatures

 since  verbose  excess bordering on abuse is common if no restraint is imposed;  4  lines  is  a common limit.

	Whole Article
	No NULL character allowed
	Header and body lines MAY contain any ASCII characters other than CR (ASCII 13), LF (ASCII 10), and NUL (ASCII 0).
	NO char > oct 127 allowed (unless co-operating)
	Articles  MUST  not  contain  any octet with value exceeding 127, i.e. any octet that is not an ASCII character.
	Limit to 60K -- LATER
	Posters SHOULD limit  posted  articles  to  at  most  60,000 octets,  including  headers  and EOL representations, unless the articles are being posted only within a cooperating sub-net which is known to be capable of handling larger articles gracefully.


  Posting agents presented with a  large  article SHOULD warn the poster and request confirmation.
	*/

	return nntpReturn.fSetOK();
}


BOOL
CFromStoreArticle::fMungeHeaders(
							 CPCString& pcHub,
							 CPCString& pcDNS,
							 //CNAMEREFLIST & grouplist,
							 DWORD remoteIpAddress,
							 CNntpReturn & nntpReturn
			  )

/*++

Routine Description:

	Modify the headers of the article.

Arguments:

	grouplist - A list: for each newsgroup its name, and the article number in that group.
	nntpReturn - The return value for this function call


Return Value:

	TRUE, if successful. FALSE, otherwise.

--*/
{
	//
	// clear the return code object
	//

	nntpReturn.fSetClear();

	/* !!!CLIENT LATER
	Must validate encodings see From parsing
	Posting agents MUST ensure that any material  resembling  an  encoded  word (complete  with  all delimiters), in a context where encoded words may appear, really is an encoded word.

	*/

	if (!(
  			   m_fieldMessageID.fSet(*this, pcDNS, nntpReturn)
  			&& m_fieldNewsgroups.fSet(*this, nntpReturn)
  			&& m_fieldDistribution.fSet(*this, nntpReturn)
  			&& m_fieldDate.fSet(*this, nntpReturn)
  			&& m_fieldLines.fSet(*this, nntpReturn)
  			&& m_fieldOrganization.fSet(*this, nntpReturn)
  			&& m_fieldPath.fSet(*this, pcHub, nntpReturn)
			/*&& m_fieldXref.fSet(pcHub, grouplist, *this, m_fieldNewsgroups, nntpReturn)*/
			&& m_fieldNNTPPostingHost.fSet(*this, remoteIpAddress, nntpReturn)
			/* && m_fieldXAuthLoginName.fSet(*this, nntpReturn) */
			&& fDeleteEmptyHeader(nntpReturn)
			&& fSaveHeader(nntpReturn)
		))
		return nntpReturn.fFalse();

	return nntpReturn.fSetOK();
}



BOOL
CFromStoreArticle::fCheckBodyLength(
				 CNntpReturn & nntpReturn
				 )
/*++

Routine Description:

	Checks if the length of the body is within bounds.

Arguments:

	nntpReturn - The return value for this function call


Return Value:

	TRUE, if successful. FALSE, otherwise.

--*/
{

	//
	//!!!CLIENT NEXT need to add a real body length check here
	//

	return nntpReturn.fSetOK();
}



BOOL
CFromStoreNewsgroupsField::fSet(
				   				 CFromStoreArticle & article,
								 CNntpReturn & nntpReturn
								 )
/*++

Routine Description:


	Rewrites the Newsgroups line, fixing some problems such as
	extra whitespace and duplicates.


Arguments:

	article - The article being processed.
	nntpReturn - The return value for this function call


Return Value:

	TRUE, if successful. FALSE, otherwise.

--*/
{

	//
	// clear the return code object
	//

	nntpReturn.fSetClear();

	//
	// Check article state
	//

	_ASSERT(fsParsed == m_fieldState);//real

	CPCString pcLine;


	//
	// max size needed is the size of the old line
	//

	const DWORD cchMaxNewsgroups =
			(m_pHeaderString->pcLine).m_cch
			+ 2 // for the newline
			+ 1; // for a terminating null


	//
	// Allocate memory for line within a PCString.
	//

	pcLine.m_pch  = article.pAllocator()->Alloc(cchMaxNewsgroups);
	if (!pcLine.m_pch)
		return nntpReturn.fSet(nrcMemAllocationFailed, __FILE__, __LINE__);

	//
	// Start with "Newsgroups: "
	//

	pcLine << szKwNewsgroups << (char) ' ';

	//
	// Loop through the newsgroups
	//

	_ASSERT(0 < cGet());//real
	char const * szNewsgroup = multiSzGet();
	do
	{

	//
	// Start with newsgroup name, then add comma
	//

		pcLine << szNewsgroup << (char) ',';

		//
		// go to first char after next null
		//

		while ('\0' != szNewsgroup[0])
			szNewsgroup++;
		szNewsgroup++;
	} while ('\0' != szNewsgroup[0]);

	//
	// Remove the last ","
	//

	pcLine.vSkipEnd(1);

	pcLine	<< "\r\n";
	pcLine.vMakeSz(); // terminate the string

	//
	// confirm that we allocated enough memory
	//

	_ASSERT(cchMaxNewsgroups-1 >= pcLine.m_cch);//real

	if (!(
  		article.fRemoveAny(szKwNewsgroups, nntpReturn)
		&& article.fAdd(pcLine.sz(), pcLine.pchMax(), nntpReturn)
		))
	{
		//
		// If anything went wrong, free the memory.
		//

		article.pAllocator()->Free(pcLine.m_pch);
		return nntpReturn.fFalse();
	}

	return nntpReturn.fSetOK();
}


BOOL
CFromStoreDistributionField::fSet(
				   				 CFromStoreArticle & article,
								 CNntpReturn & nntpReturn
								 )
/*++

Routine Description:


	Rewrites the Distribution line, fixing some problems such as
	extra whitespace and duplicates.


Arguments:

	article - The article being processed.
	nntpReturn - The return value for this function call


Return Value:

	TRUE, if successful. FALSE, otherwise.

--*/
{

	//
	// clear the return code object
	//

	nntpReturn.fSetClear();

	//
	// If it was not found exists, then just return
	//

	if (fsNotFound == m_fieldState)
		return nntpReturn.fSetOK();


	//
	// Otherwise, fix up what was found.
	//

	//
	// Check article state
	//

	_ASSERT(fsParsed == m_fieldState);//real

	CPCString pcLine;


	//
	// max size needed is the size of the old line
	//

	const DWORD cchMaxDistribution =
			(m_pHeaderString->pcLine).m_cch
			+ 2 // for the newline
			+ 1; // for a terminating null


	//
	// Allocate memory for line within a PCString.
	//

	pcLine.m_pch  = article.pAllocator()->Alloc(cchMaxDistribution);
	if (!pcLine.m_pch)
		return nntpReturn.fSet(nrcMemAllocationFailed, __FILE__, __LINE__);

	//
	// Start with "Distribution: "
	//

	pcLine << szKwDistribution << (char) ' ';

	//
	// Loop through the Distribution
	//

	_ASSERT(0 <= (int)cGet());//real
	char const * szDistributrionValue = multiSzGet();
	do
	{

	//
	// Start with distribution value and add comma
	//

		pcLine << szDistributrionValue << (char) ',';

		//
		// go to first char after next null
		//

		while ('\0' != szDistributrionValue[0])
			szDistributrionValue++;
		szDistributrionValue++;
	} while ('\0' != szDistributrionValue[0]);

	//
	// Remove the last ","
	//

	pcLine.vSkipEnd(1);

	pcLine	<< "\r\n";
	pcLine.vMakeSz(); // terminate the string

	//
	// confirm that we allocated enough memory
	//

	_ASSERT(cchMaxDistribution-1 >= pcLine.m_cch);//real

	if (!(
  		article.fRemoveAny(szKwDistribution, nntpReturn)
		&& article.fAdd(pcLine.sz(), pcLine.pchMax(), nntpReturn)
		))
	{
		//
		// If anything went wrong, free the memory.
		//

		article.pAllocator()->Free(pcLine.m_pch);
		return nntpReturn.fFalse();
	}

	return nntpReturn.fSetOK();
}



BOOL
CFromStoreDateField::fSet(
				   				 CFromStoreArticle & article,
								 CNntpReturn & nntpReturn
								 )
/*++

Routine Description:


	If the date field is missing, adds it.


Arguments:

	article - The article being processed.
	nntpReturn - The return value for this function call


Return Value:

	TRUE, if successful. FALSE, otherwise.

--*/
{

	//
	// clear the return code object
	//

	nntpReturn.fSetClear();

	//
	// Check article state
	//
	//
	// If it already exists, then just return
	//

	if (fsParsed == m_fieldState)
		return nntpReturn.fSetOK();


	//
	// Otherwise, add it.
	//

	_ASSERT(fsNotFound == m_fieldState);//real
	CPCString pcLine;

	//
	// max size needed is
	//

	const DWORD cchMaxDate =
			STRLEN(szKwDate)	// for the Date keyword
			+ 1					// space following the keyword
			+ cMaxArpaDate		// bound on the data string
			+ 2 // for the newline
			+ 1; // for a terminating null

	//
	// Allocate memory for line within a PCString.
	//

	pcLine.m_pch  = article.pAllocator()->Alloc(cchMaxDate);
	if (!pcLine.m_pch)
		return nntpReturn.fSet(nrcMemAllocationFailed, __FILE__, __LINE__);

	char szDateBuf[cMaxArpaDate];

	//
	// Start with "Date: ", then add the date and the newline
	//

	pcLine << szKwDate << (char) ' ' << (GetArpaDate(szDateBuf)) << "\r\n";
	pcLine.vMakeSz(); // terminate the string

	//
	// confirm that we allocated enough memory
	//

	_ASSERT(cchMaxDate-1 >= pcLine.m_cch);//real

	if (!article.fAdd(pcLine.sz(), pcLine.pchMax(), nntpReturn))
	{
		//
		// If anything went wrong, free the memory.
		//

		article.pAllocator()->Free(pcLine.m_pch);
		nntpReturn.fFalse();
	}


	return nntpReturn.fSetOK();
}

/*
Organization: Optional  But if not and default is given, create
The Organization header content is a short phrase  identify-ing the posters organization:
Organization-content = nonblank-text
This header is typically supplied by the posting agent.  The Organization content SHOULD  mention  geographical  location (e.g.  city  and  country)  when  it is not obvious from the organization?s name.  policy.  Posting agents SHOULD permit the poster t


o override a local default Organization header.
*/

BOOL
CFromStoreOrganizationField::fSet(
   				   				 CFromStoreArticle & article,
								 CNntpReturn & nntpReturn
								 )
/*++

Routine Description:


	Optional, But if not given my user and default is given, create


Arguments:

	country -


Return Value:

	TRUE, if successful. FALSE, otherwise.

--*/
{

//
//!!!CLIENT NEXT - add this code
//

	return nntpReturn.fSetOK();
}

//
//!!!constize
//

/*
Restricted Syntax
The  From header contains the electronic address, and possibly the full name, of the articles author:
From-content  = address [ space "(" paren-phrase ")" ]
/  [ plain-phrase space ] "<" address ">"
paren-phrase  = 1*( paren-char / space / encoded-word )
paren-char    = <ASCII printable character except ()<>\>
plain-phrase  = plain-word *( space plain-word )
plain-word    = unquoted-word / quoted-word / encoded-word
unquoted-word = 1*unquoted-char
unquoted-char = <ASCII printable character except !()<>@,;:\".[]>
               quoted-word   = quote 1*( quoted-char / space ) quote
               quote         = <" (ASCII 34)>
               quoted-char   = <ASCII printable character except "()<>\>
               address       = local-part "@" domain
               local-part    = unquoted-word *( "." unquoted-word )
               domain        = unquoted-word *( "." unquoted-word )

(Encoded words are described in section 4.5.)  The full name is  distinguished  from  the  electronic  address  either by enclosing the former in parentheses (making  it  resemble  a MAIL  comment, after the address) or by enclosing the latter in angle br


ackets.  The second form is  preferred.   In  the first  form, encoded words inside the full name MUST be composed  entirely  of  <paren-char>s.   In  the  second  form, encoded  words  inside the full name may not contain characters other than letters (o

f either case),  digits,  and  the characters "!", "*", "+", "-", "/", "=", and "_".  The local part is case-sensitive (except that all case counterparts of "postmaster"  are  deemed  equivalent),  the domain is case-insensitive, and all other parts of  t


he  From  content  are comments  which  MUST  be  ignored  by news software (except insofar as reading agents may wish to display  them  to  the reader).   Posters  and  posting  agents MUST restrict them-selves to this subset of the MAIL From syntax; rel


ayers  MAY accept  a  broader subset, but see the discussion in section 9.1.
Avoid "!" and "@" in full names
Posters  and  posting agents SHOULD avoid use of the characters "!" and "@" in full names, as they may trigger unwanted header rewriting by old, simple-minded news software.
"." and "," must be quoted
NOTE: Also, the characters "." and ",", not infrequently found in names (e.g., "John  W.  Campbell, Jr."), are NOT, repeat NOT, allowed in an unquoted word.  A From header like the following  MUST  not be written without the quotation marks:
                    From:	"John W. Campbell, Jr." <editor@analog.com>

*/
/*
 Three permissible forms documented in RFC 1036 should be supported.  Full names within this header line can only contain printable ASCII (0x20 to 0x7E) except "(", ")", "<", ">".  The following characters are inadvisable: ",", ":", "@", "!", "/", "=", ";


".  Test cases include non-printable characters, empty header line (can?t be empty), missing/duplicate "@" address delimiter, multiple address, name lists (not supported), missing address, invalid address, inadvisable characters in name, etc.
 */

BOOL
CFromStoreXAuthLoginNameField::fSet(
				 				 CFromStoreArticle & article,
								 CNntpReturn & nntpReturn
								 )
/*++

Routine Description:


	replace with our value


Arguments:

	article - The article being processed.
	nntpReturn - The return value for this function call


Return Value:

	TRUE, if successful. FALSE, otherwise.

--*/
{
	//
	// clear the return code object
	//

	nntpReturn.fSetClear();

	//
	// Check article state
	//

	_ASSERT(fsInitialized == m_fieldState);//real
	CPCString pcLine;


	//
	// max size needed is
	//

	const DWORD cchMaxXAuthLoginName =
			STRLEN(szKwXAuthLoginName)	// for the XAuthLoginName keyword
			+ 1					// space following the keyword
			//+ cMaxLoginName		// bound on the data string
            + MAX_PATH		// bound on the data string
			+ 2 // for the newline
			+ 1; // for a terminating null

	//
	// Allocate memory for line within a PCString.
	//

	pcLine.m_pch  = article.pAllocator()->Alloc(cchMaxXAuthLoginName);
	if (!pcLine.m_pch)
		return nntpReturn.fSet(nrcMemAllocationFailed, __FILE__, __LINE__);

	//
	// Start with "XAuthLoginName: "
	//

	wsprintf(pcLine.m_pch, "%s ", szKwXAuthLoginName);
	pcLine.m_cch = STRLEN(szKwXAuthLoginName)	+ 1;

	//
	// Add the data value and newline
	//

	pcLine << (article.m_szLoginName) << "\r\n";
	pcLine.vMakeSz(); // Terminate the string

	//
	// confirm that we allocated enough memory
	//

	_ASSERT(cchMaxXAuthLoginName-1 >= pcLine.m_cch);//real

	if (!(
  		article.fRemoveAny(szKwXAuthLoginName, nntpReturn)
		&& article.fAdd(pcLine.sz(), pcLine.pchMax(), nntpReturn)
		))
	{
		//
		// If anything went wrong, free the memory.
		//

		article.m_pAllocator->Free(pcLine.m_pch);

		return nntpReturn.fFalse();
	}


	return nntpReturn.fSetOK();
}






//
//!!!CLIENT NEXT: In Newsgroups: parse need to check for illegal groups like "control" and "poster"
//

/*
Followup-To: Optional
Email address is not allowed. Like newsgroups line or "poster" (capitalization?)
NOTE: The way to request that followups be  mailed to  a specific address other than that in the From line is  to  supply  "Followup-To: poster"  and  a Reply-To header.  Putting a mailing address in the Followup-To  line  is  incorrect;  posting  agent

should reject or rewrite such headers.
*/
/*
Reply-To: Optional
Must be a valid email address
*/

/*

//
///!!!CLIENT NEXT should Hubname be lower case?
///!!!CLIENT NEXT should Hubname be the domain name (for message id?)
//

/*
Message-ID: Replace any with own
How to create a messageid
5.3. Message-ID
The  Message-ID  header contains the articles message ID, a unique identifier  distinguishing  the  article  from  every other article:
Message-ID-content  = message-id
message-id          = "<" local-part "@" domain ">"
As  with  From addresses, a message IDs local part is case-sensitive and its domain is case-insensitive.  The  "<"  and ">"  are  parts  of the message ID, not peculiarities of the Message-ID header.
NOTE: News message IDs are a restricted subset  of MAIL message IDs.  In particular, no existing news software copes properly with MAIL quoting  conventions  within  the local part, so they are forbid-den.  This is unfortunate, particularly for  X.400 gat

es on gatewaying in section 10.
The domain in the message ID SHOULD  be  the  full  Internet domain name of the posting agent?s host.  Use of the ".uucp" pseudo-domain (for hosts registered in the UUCP maps) or the ".bitnet"  pseudo-domain  (for Bitnet hosts) is permissible, but SHOUL

be avoided.
Posters and posting agents MUST generate the local part of a
message ID using an algorithm which obeys the specified syn-
tax (words separated by ".",  with  certain  characters  not
permitted)  (see  section  5.2  for  details),  and will not repeat itself (ever).  The  algorithm  SHOULD  not  generate message  IDs which differ only in case of letters.  Note the specification in section 6.5 of a recommended convention for indicatin

 subject  changes.  Otherwise the algorithm is up to the implementor.
NOTE: The crucial use of message IDs is to distinguish  circulating  articles  from  each other and from articles circulated recently.  They are  also potentially  useful  as  permanent  indexing keys, hence the requirement for permanent  uniqueness...  b


ut   indexers  cannot  absolutely  rely  on  this because the earlier RFCs  urged  it  but  did  not demand  it.  All major implementations have always generated  permanently-unique   message   IDs   by design,  but  in  some  cases this is sensitive to p


roper administration,  and  duplicates  may  have occurred by accident.
NOTE:  The most popular method of generating local parts is to use the date and time, plus  some  way of distinguishing between simultaneous postings on the same host (e.g. a process number), and  encode them  in a suitably-restricted alphabet.  An olde

but now  less-popular  alternative  is  to  use  a sequence  number,  incremented  each time the host generates a new message ID; this is workable,  but requires  careful  design  to  cope  properly with simultaneous  posting  attempts,  and  is  not  a

robust  in  the presence of crashes and other malfunctions.
NOTE: Some buggy news software  considers  message
IDs  completely case-insensitive, hence the advice
to  avoid  relying  on  case  distinctions.    The
restrictions  placed  on  the  "alphabet" of local
parts and domains in section 5.2 have  the  useful side effect of making it unnecessary to parse message IDs in complex ways to break them into  case-sensitive and case-insensitive portions.

*/
BOOL
CFromStoreMessageIDField::fSet(
				 				 CFromStoreArticle  & article,
								 CPCString & pcHub,
								 CNntpReturn & nntpReturn
								 )
/*++

Routine Description:


	Replaces any messageid field, with a newly created one.


  Form: <1993Jun27.0645330123.1778.343@localmachinename>

Arguments:

	article - The article being processed.
	pcHub - The name of the hub the current machine is part of.
	nntpReturn - The return value for this function call


Return Value:

	TRUE, if successful. FALSE, otherwise.

--*/
{

	//
	// clear the return code object
	//

	nntpReturn.fSetClear();

	//
	// Check article state
	//

	if( m_fieldState == fsParsed ) {
		return	nntpReturn.fSetOK() ;
	}

	CPCString pcLine;


	//
	// max size needed is
	//

#if 0
	const DWORD cchMaxMessageID =
			STRLEN(szKwMessageID)	// for the MessageID keyword
			+ 1					// space following the keyword
			+ 5					// <..@>
			+ cMaxMessageIDDate // The message id date
			+ 20				// Two dwords
			+ pcHub.m_cch		// the hub name
			+ 2 // for the newline
			+ 1; // for a terminating null
#endif

	const DWORD cchMaxMessageID =
			STRLEN(szKwMessageID)	// for the MessageID keyword
			+ 1					// space following the keyword
			+ 4					// <..@>
			+ cMaxMessageIDDate // The message id date
			+ 10				// One dword
			+ pcHub.m_cch		// the hub name
			+ 2 // for the newline
			+ 1; // for a terminating null

	//
	// The message-id created (without the newlines) must be less than the max
	//

	_ASSERT(cchMaxMessageID - 2 < MAX_MSGID_LEN);

	//
	// Allocate memory for line within a PCString.
	//

	pcLine.m_pch  = article.pAllocator()->Alloc(cchMaxMessageID);
	if (!pcLine.m_pch)
		return nntpReturn.fSet(nrcMemAllocationFailed, __FILE__, __LINE__);

	//
	// Start with "MessageID: <"
	//

	wsprintf(pcLine.m_pch, "%s <", szKwMessageID);
	pcLine.m_cch = STRLEN(szKwMessageID)	+ 2;

	char szMessageIDBuf[cMaxMessageIDDate];

	CArticleRef artRef = article.articleRef();

	pcLine
			//
			// Add the local part
			//
			<< (GetMessageIDDate( artRef.m_groupId, artRef.m_articleId, szMessageIDBuf))
			<< (char) '.'
			//<< (GetCurrentProcessId())
			//<< '.'
			<< (const DWORD) (GetCurrentThreadId())
			//
			// Add '@' and domain and '>' and newline
			//
			<< (char) '@'
			<< pcHub ///!!!CLIENT NEXT I need the local machine rather than the hub
			<< ">\r\n";
	pcLine.vMakeSz(); // terminate the string

	//
	// confirm that we allocated enough memory
	//

	//_ASSERT(cchMaxMessageID-1-STRLEN(szKwMessageID)-1 >= pcLine.m_cch);//real
	_ASSERT(cchMaxMessageID >= pcLine.m_cch+1);//real

	if (!(
  		article.fRemoveAny(szKwMessageID, nntpReturn)//!!!CLIENT NEXT -- this really only needs to be called of state is parsed
		&& article.fAdd(pcLine.sz(), pcLine.pchMax(), nntpReturn)
		))
	{
		article.pAllocator()->Free(pcLine.m_pch);
		return nntpReturn.fFalse();
	}


	//
	//Also save the value (without newlines but with room for a terminating
	//a '\0') in m_szMessageID
	//

	DWORD cchMessageID = pcLine.m_cch - 2 - STRLEN(szKwMessageID) - 1;
	strncpy(m_szMessageID, pcLine.m_pch + STRLEN(szKwMessageID)	+ 1, cchMessageID);
	m_szMessageID[cchMessageID] ='\0';
	_ASSERT('<' == m_szMessageID[0] && '>' == m_szMessageID[cchMessageID-1]);


	return nntpReturn.fSetOK();
}


BOOL
CFromStorePathField::fSet(
						   CFromStoreArticle & article,
						   CPCString & pcHub,
						   CNntpReturn & nntpReturn
						   )
/*++

Routine Description:


	Replaces any existing Path header with a newly created one that
	contains only the name of the hub.


Arguments:

	article - The article being processed.
	pcHub - The name of the hub the current machine is part of.
	nntpReturn - The return value for this function call


Return Value:

	TRUE, if successful. FALSE, otherwise.

--*/
{
	//
	// clear the return code object
	//

	nntpReturn.fSetClear();

	//
	// Check article state
	//

	_ASSERT(fsInitialized != m_fieldState);//real

	CPCString pcLine;


	//
	// max size needed is
	//

	DWORD	cbOldPath = 0 ;
	if( m_pHeaderString && m_pHeaderString->pcValue.m_pch ) {
		cbOldPath = m_pHeaderString->pcValue.m_cch + 1 ;	//include 1 for extra '!'
	}

	const DWORD cchMaxPath =
			STRLEN(szKwPath)	// for the Path keyword
			+ 1					// space following the keyword
			+ pcHub.m_cch		// the hub name
			+ 2 // for the newline
			+ cbOldPath // in case there already is a path header !
			+ 1; // for a terminating null

	//
	// Allocate memory for line within a PCString.
	//

	pcLine.m_pch  = article.pAllocator()->Alloc(cchMaxPath);
	if (!pcLine.m_pch)
		return nntpReturn.fSet(nrcMemAllocationFailed, __FILE__, __LINE__);

	//
	// Start with "Path: <hubname>"
	//

	pcLine << szKwPath << (char) ' ' << pcHub ;		//	<< "\r\n";

	if( m_pHeaderString && m_pHeaderString->pcValue.m_pch ) {
		_ASSERT( m_pHeaderString->pcValue.m_cch != 0 ) ;
		pcLine << "!" << (m_pHeaderString->pcValue) ;
	}

	pcLine << "\r\n" ;

	pcLine.vMakeSz();

	//
	// confirm that we allocated enough memory
	//

	_ASSERT(cchMaxPath-1 == pcLine.m_cch);//real

	if (!(
  		article.fRemoveAny(szKwPath, nntpReturn)//!!!CLIENT NEXT -- this really only needs to be called of state is parsed
		&& article.fAdd(pcLine.sz(), pcLine.pchMax(), nntpReturn)
		))
	{
		//
		// If anything went wrong, free the memory.
		//

		article.pAllocator()->Free(pcLine.m_pch);

		return nntpReturn.fFalse();
	}

	return nntpReturn.fSetOK();
}


BOOL
CFromStoreNNTPPostingHostField::fSet(
									  CFromStoreArticle & article,
									  DWORD remoteIpAddress,
									  CNntpReturn & nntpReturn
									  )
/*++

Routine Description:

	Behavior is governed by global set by a reg key.
	In any case, this removes any old NNTPPostingHost headers.

	If global is set, a new NNTP-Posting-Host header is added
	else no new header is added. default behavior is to NOT add
	this header.

Arguments:

	article - The article being processed.
	remoteIpAddress - client IP address
	nntpReturn - The return value for this function call



Return Value:

	TRUE, if successful. FALSE, otherwise.

--*/
{
	//
	// clear the return code object
	//

	nntpReturn.fSetClear();
	return nntpReturn.fSetOK();
}


BOOL
CFromStoreDistributionField::fParse(
									 CArticleCore & article,
									 CNntpReturn & nntpReturn
									 )
/*++

Routine Description:

  Parses the Distribution field. Here is the grammer from Son of 1036:

               Newsgroups-content  = newsgroup-name *( ng-delim newsgroup-name )
               newsgroup-name      = plain-component *( "." component )
               component           = plain-component / encoded-word
               plain-component     = component-start *13component-rest
               component-start     = lowercase / digit
               lowercase           = <letter a-z>
               component-rest      = component-start / "+" / "-" / "_"
               ng-delim            = ","


Arguments:

	nntpReturn - The return value for this function call


Return Value:

	TRUE, if successful. FALSE, otherwise.

--*/
{
	//
	// clear the return code object
	//

	nntpReturn.fSetClear();

	//
	// Check article state
	//

	_ASSERT(fsFound == m_fieldState);//real

	_ASSERT(m_pHeaderString); //real


	//
	// Record the allocator
	//

	m_pAllocator = article.pAllocator();

	if (!fParseSplit(TRUE, m_multiSzDistribution, m_cDistribution, " \t\r\n,",
			article, nntpReturn))
		return FALSE;

	//
	//Check for duplicates
	//

	DWORD cOldCount = m_cDistribution;
	if (!fMultiSzRemoveDupI(m_multiSzDistribution, m_cDistribution, m_pAllocator))
		nntpReturn.fSet(nrcMemAllocationFailed, __FILE__, __LINE__);

	if( m_cDistribution == 0 ) {
		return	nntpReturn.fSetOK() ;
	}

	//
	// check for illegal characters and substrings in Distribution name
	//

	char const * szDistribution = m_multiSzDistribution;
	do
	{
		if ('\0' == szDistribution[0]
			|| !fTestAComponent(szDistribution)
			)
		return nntpReturn.fSet(nrcArticleFieldIllegalComponent, szDistribution, szKeyword());

		//
		// go to first char after next null
		//

		while ('\0' != szDistribution[0])
			szDistribution++;
		szDistribution++;
	} while ('\0' != szDistribution[0]);

	return nntpReturn.fSetOK();
}

BOOL
CFromStoreLinesField::fParse(
						 CArticleCore & article,
						 CNntpReturn & nntpReturn
						 )
/*++

Routine Description:

	Parses the Lines field.

Arguments:

	nntpReturn - The return value for this function call


Return Value:

	TRUE, if successful. FALSE, otherwise.

--*/
{
	//
	// clear the return code object
	//

	nntpReturn.fSetClear();

	//
	// Check article state
	//

	_ASSERT(fsFound == m_fieldState);//real

	_ASSERT(m_pHeaderString); //real

	if (!fParseSimple(TRUE, m_pc, nntpReturn))
		return nntpReturn.fFalse();

	char * pchMax = m_pc.pchMax();
	for (char * pch = m_pc.m_pch; pch < pchMax; pch++)
	{
		if (!(UCHAR)isdigit(*pch))
			return nntpReturn.fSet(nrcArticleFieldBadChar, (BYTE) *pch, szKeyword());
	}

	return nntpReturn.fSetOK();
}

BOOL
CFromStoreReferencesField::fParse(
								   CArticleCore & article,
								   CNntpReturn & nntpReturn
								   )
/*++

Routine Description:

	Parses the References field.

Arguments:

	nntpReturn - The return value for this function call


Return Value:

	TRUE, if successful. FALSE, otherwise.

--*/
{
	//
	// clear the return code object
	//

	nntpReturn.fSetClear();

	//
	// Check article state
	//

	_ASSERT(fsFound == m_fieldState);//real

	_ASSERT(m_pHeaderString); //real


	//
	// Record the allocator
	//

	m_pAllocator = article.pAllocator();

	if (!fParseSplit(FALSE, m_multiSzReferences, m_cReferences, szWSNLChars,
			article, nntpReturn))
		return nntpReturn.fFalse();

	//
	// check for illegal characters and substrings in References name
	//

	char const * szReferences = m_multiSzReferences;
	do
	{
		if (!fTestAMessageID(szReferences, nntpReturn))
			return nntpReturn.fFalse();

		//
		// go to first char after next null
		//

		while ('\0' != szReferences[0])
			szReferences++;
		szReferences++;
	} while ('\0' != szReferences[0]);

	return nntpReturn.fSetOK();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\nntp\server\article\src\artcore.cpp ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    artcore.cpp

Abstract:

    This module contains definition for the CArticleCore base class.

	This class provides basic, general tools to parse and edit a
	Netnews articles.

	The basic idea is to map the files containing the articles and
	then to record the location of parts of the articles with CPCStrings.
	A CPCString is just a pointer (usually into the mapped file) and a length.

Author:

    Carl Kadie (CarlK)     06-Oct-1995

Revision History:

--*/

#ifdef	_NO_TEMPLATES_
#define	DEFINE_CGROUPLST_FUNCTIONS
#endif

#include "stdinc.h"
#include <artcore.h>
#include    <stdlib.h>

//
// externs
//
extern BOOL    g_fBackFillLines;

//
// CPool is used to allocate memory while processing an article.
//

CPool*  CArticleCore::g_pArticlePool;

const	unsigned	cbMAX_ARTCORE_SIZE = MAX_ARTCORE_SIZE ;

//
// Some function prototypes
//

// Does most of the work of testing a newsgroup name for legal values.
BOOL fTestComponentsInternal(
			 const char * szNewsgroups,
			 CPCString & pcNewsgroups
			);


BOOL
AgeCheck(	CPCString	pcDate ) {

	//
	//	This function will be used to determine whether an article is
	//	to old for the server to take.  In case of error return TRUE
	//	so that we take the article anyways !
	//

	extern	BOOL
		StringTimeToFileTime(
			IN  const TCHAR * pszTime,
			OUT LARGE_INTEGER * pliTime
			) ;

	extern	BOOL
		ConvertAsciiTime( char*	pszTime,	FILETIME&	filetime ) ;


	char	szDate[512] ;

	if( pcDate.m_cch > sizeof( szDate )-1 ) {
		return	TRUE ;
	}
	
	CopyMemory( szDate, pcDate.m_pch, pcDate.m_cch ) ;
	//
	//	Null terminate
	//
	szDate[pcDate.m_cch] = '\0' ;

	LARGE_INTEGER	liTime ;
	FILETIME		filetime ;

	if( ConvertAsciiTime( szDate, filetime ) ) {

		liTime.LowPart = filetime.dwLowDateTime ;
		liTime.HighPart = filetime.dwHighDateTime ;

	}	else	if( !StringTimeToFileTime( szDate, &liTime ) ) {

		//
		//	Could not convert the time so accept the article !!
		//

		return	TRUE ;

	}


	FILETIME	filetimeNow ;

	GetSystemTimeAsFileTime( &filetimeNow ) ;

	LARGE_INTEGER	liTimeNow ;
	liTimeNow.LowPart = filetimeNow.dwLowDateTime ;
	liTimeNow.HighPart = filetimeNow.dwHighDateTime ;

	if( liTime.QuadPart > liTimeNow.QuadPart )	{
		return	TRUE ;
	}	else	{

		LARGE_INTEGER	liDiff ;
		liDiff.QuadPart = liTimeNow.QuadPart - liTime.QuadPart ;		

		LARGE_INTEGER	liExpire ;
		liExpire.QuadPart = ArticleTimeLimitSeconds  ;
		liExpire.QuadPart += (24 * 60 * 60 * 2) ;	// fudge by 2 days !
		liExpire.QuadPart *= 10 * 1000 * 1000 ;		// convert seconds to 100th of Nanoseconds.

		if( liDiff.QuadPart > liExpire.QuadPart )
			return	FALSE ;
	}
	
	return	TRUE ;
}


BOOL
CArticleCore::InitClass(
					void
					)
/*++

Routine Description:

    Preallocates memory for CArticle objects

Arguments:

    None.

Return Value:

    TRUE, if successful. FALSE, otherwise.

--*/
{
    g_pArticlePool = new CPool( ARTCORE_SIGNATURE );
    if (g_pArticlePool == NULL)
    	return FALSE;

	return	g_pArticlePool->ReserveMemory( MAX_ARTICLES, cbMAX_ARTCORE_SIZE ) ;	
}


BOOL
CArticleCore::TermClass(
					void
					)
/*++

Routine Description:

    Called when objects are freed.

Arguments:

    None.

Return Value:

    TRUE

--*/
{

	_ASSERT( g_pArticlePool->GetAllocCount() == 0 ) ;

	BOOL b;
	
	b =	g_pArticlePool->ReleaseMemory() ;
    delete g_pArticlePool;
    return b;

}


CArticleCore::CArticleCore(
                void
                ):
/*++

Routine Description:

    Class Constructor. Does nothing except initial member variables.

Arguments:

    None.

Return Value:

    TRUE

--*/
	m_hFile(INVALID_HANDLE_VALUE),
	//m_pOpenFile( 0 ),
	//m_pInstance( NULL ),
	m_cHeaders(0),
	m_articleState(asUninitialized),
	m_pHeaderBuffer( 0 ),
	m_pMapFile( 0 ),
	m_CacheCreateFile( TRUE )
{
   m_szFilename = 0 ;
   numArticle++;

} // CArticleCore

	
	
CArticleCore::~CArticleCore(
                    void
                    )
/*++

Routine Description:

    Class destructor

Arguments:

    None.

Return Value:

    None

--*/
{

    //
    // Be sure the file is closed
    //

	if( m_pHeaderBuffer ) {
							
		m_pAllocator->Free(m_pHeaderBuffer);
		m_pHeaderBuffer = 0 ;

	}

	if (m_pMapFile)
	{
		XDELETE	m_pMapFile ;//!!!mem
		m_pMapFile = NULL ;
	}

	//
	// If file handle is open and it's not in the cache, close it
	//

	if( m_hFile != INVALID_HANDLE_VALUE &&
	    !m_CacheCreateFile.m_pFIOContext )
	{
		BOOL	fSuccess = ArtCloseHandle(
												m_hFile
												//m_pOpenFile
												) ;

		_ASSERT( fSuccess ) ;
	}

	//
	//!!!COMMENT May want to make this a function so that
	// m_pMapFile can be make private.

    numArticle--;

}



void
CArticleCore::vClose(
					 void
					 )
/*++

Routine Description:

    Close the file mapping and handle (if any)  of the article's file.

Arguments:

    None

Return Value:

    None

--*/
{

	//
	// We shouldn't be calling this unless it is open
	//

	if (m_pMapFile)
	{
		XDELETE	m_pMapFile ;//!!!MEM
		m_pMapFile = NULL ;
	}

	//
	// If file handle is open, close it
	//

	if( m_hFile != INVALID_HANDLE_VALUE )
	{
		// bugbug ... clean up this debug code some time

		BOOL	fSuccess = ArtCloseHandle(
												m_hFile
												//m_pOpenFile
												) ;
		DWORD	dw = GetLastError() ;
		_ASSERT( fSuccess ) ;

#ifdef	DEBUG
		_ASSERT( ValidateFileBytes( m_szFilename ) );
#endif

	}

}


void
CArticleCore::vCloseIfOpen (
					 void
					 )
/*++

Routine Description:

    If the mapping and handle are open,
	close them.

Arguments:

    None

Return Value:

    None

--*/
{

	//
	// We shouldn't be calling this unless it is open
	//

	// The mapping and the handle should agree.
	//_ASSERT((INVALID_HANDLE_VALUE == m_hFile) == (NULL == m_pMapFile));

	if(m_pMapFile)
		vClose();


}

void
CArticleCore::vFlush(	
				void	
				)
/*++

Routine Description :

	This function ensures that all of our file mapping bytes are written to
	the harddisk.

Arguments :

	None.

Return Value :

	None.

--*/
{

	if(	m_pMapFile ) {

		DWORD	cb = 0 ;
		LPVOID	lpv = m_pMapFile->pvAddress(	&cb	) ;
		if( lpv != 0 ) {
			BOOL	fSuccess = FlushViewOfFile(	lpv, cb ) ;
			_ASSERT( fSuccess ) ;
			_ASSERT( memcmp( ((BYTE*)lpv)+cb-5, "\r\n.\r\n", 5 ) == 0 ) ;
		}
	}
}

BOOL
CArticleCore::fInit(
				char*	pchHead,
				DWORD	cbHead,
				DWORD	cbArticle,
				DWORD	cbBufferTotal,
				CAllocator*	pAllocator,
				//PNNTP_SERVER_INSTANCE pInstance,
				CNntpReturn&	nntpReturn
				)	{

	m_articleState = asInitialized ;
	//m_pInstance = pInstance ;

	m_szFilename = 0 ;
	m_hFile = INVALID_HANDLE_VALUE ;
	//m_pOpenFile = 0 ;
	m_pAllocator = pAllocator ;
	m_pcGap.m_cch = 0 ;

	m_pMapFile = 0 ;

	m_pcFile.m_pch = pchHead ;
	m_pcFile.m_cch = cbBufferTotal ;
	m_pcGap.m_pch = m_pcFile.m_pch ;

	m_pcArticle.m_pch = m_pcFile.m_pch ;
	m_pcArticle.m_cch = cbArticle ;

	m_pcHeader.m_pch = pchHead ;
	m_pcHeader.m_cch = cbHead ;

	m_ibBodyOffset = cbHead - 2 ;

	_ASSERT( strncmp( m_pcArticle.m_pch + m_ibBodyOffset, "\r\n", 2 ) == 0 ) ;

	if( !fPreParse(nntpReturn))
		return	FALSE;

	return	TRUE ;
}


BOOL
CArticleCore::fInit(
				char*	pchHead,
				DWORD	cbHead,
				DWORD	cbArticle,
				DWORD	cbBufferTotal,
				HANDLE	hFile,
				LPSTR	lpstrFileName,
				DWORD	ibHeadOffset,
				CAllocator*	pAllocator,
				//PNNTP_SERVER_INSTANCE pInstance,
				CNntpReturn&	nntpReturn
				)	{

	m_articleState = asInitialized ;
	//m_pInstance = pInstance ;
	
	m_szFilename = lpstrFileName ;
	m_hFile = hFile ;
	//m_pOpenFile = 0 ;
	m_pAllocator = pAllocator ;
	m_pcGap.m_cch = ibHeadOffset ;

	m_pMapFile = 0 ;

	m_pcFile.m_pch = 0 ;
	m_pcFile.m_cch = cbArticle + ibHeadOffset ;
	m_pcGap.m_pch = 0 ;

	m_pcArticle.m_pch = pchHead ;
	m_pcArticle.m_cch = cbArticle ;

	m_pcHeader.m_pch = pchHead ;
	m_pcHeader.m_cch = cbHead ;

	m_ibBodyOffset = cbHead - 2 + ibHeadOffset ;

	//
	//	Verify our arguments !!!
	//
	
#ifdef	DEBUG

	BY_HANDLE_FILE_INFORMATION	fileinfo ;
	if( !GetFileInformationByHandle( hFile, &fileinfo ) ) {

		_ASSERT( 1==0 ) ;

	}	else	{

		_ASSERT( fileinfo.nFileSizeLow == ibHeadOffset + cbArticle ) ;

		CMapFile	map( hFile, FALSE, FALSE, 0 ) ;

		if( !map.fGood() ) {

			//_ASSERT( 1==0 ) ;

		}	else	{
			DWORD	cb ;
			char*	pch = (char*)map.pvAddress( &cb ) ;

			_ASSERT( cb == ibHeadOffset + cbArticle ) ;
			_ASSERT( strncmp( pch + ibHeadOffset + cbHead - 4, "\r\n\r\n", 4 ) == 0 ) ;
			_ASSERT( strncmp( pch + ibHeadOffset + cbArticle - 5, "\r\n.\r\n", 5 ) == 0 ) ;
			_ASSERT( strncmp( pch + m_ibBodyOffset, "\r\n", 2 ) == 0 ) ;
		}
	}
#endif

	if( !fPreParse(nntpReturn))
		return	FALSE;

	_ASSERT( cbHead-2 == m_pcHeader.m_cch ) ;

	return	TRUE ;
}

BOOL
CArticleCore::fInit(
			  const char * szFilename,
  			  CNntpReturn & nntpReturn,
  			  CAllocator * pAllocator,
			  HANDLE hFile,
			  DWORD	cBytesGapSize,
			  BOOL fCacheCreate
	  )

/*++

Routine Description:

    Initialize from a file handle - used on incoming files

Arguments:

	szFilename - The name of the file containing the article
	nntpReturn - The return value for this function call
	hFile - A file handle to an Netnews article
	cBytesGapSize - The number of bytes in the file before the article starts
	pAllocator	- the object that handle memory allocations while article processing.

Return Value:

    TRUE, if and only if process succeeded.

--*/
{
    //
    // Determine if we want mapfile to do cache create
    //
    CCreateFile *pCreateFile = fCacheCreate ? &m_CacheCreateFile : NULL;

	//
	// clear the return code object
	//

	nntpReturn.fSetClear();

	//
	// Set article state
	//

	//_ASSERT(asUninitialized == m_articleState);
	m_articleState = asInitialized;
	//m_pInstance = pInstance ;

    //
    // Set membership variables
    //

	m_szFilename = (char*)szFilename ;
	m_hFile = hFile;
	//m_pOpenFile = pOpenFile ;
	m_pcGap.m_cch = cBytesGapSize;
	m_pAllocator = pAllocator;



#ifdef	DEBUG
				_ASSERT( ValidateFileBytes( (char *) szFilename, FALSE ) );
#endif

	//
    // Map the file.
    //

	m_pMapFile = XNEW CMapFile(m_szFilename, m_hFile, fReadWrite(),0, pCreateFile);//!!!MEM now

	if (!m_pMapFile || !m_pMapFile->fGood())
	{
		if (m_pMapFile)	{
			XDELETE m_pMapFile;//!!!mem
			m_pMapFile = 0 ;
		}
		return nntpReturn.fSet(nrcArticleMappingFailed, m_szFilename, GetLastError());
	}
	

	//
	// Set the file, gap, and article PC (pointer/count) strings.
	//

	m_pcFile.m_pch = (char *) m_pMapFile->pvAddress( &(m_pcFile.m_cch) );
	m_pcGap.m_pch = m_pcFile.m_pch; //length set in init

	//
	// If the length of the gap size is not known, determine it from the file itself
	//

	if (cchUnknownGapSize == m_pcGap.m_cch)
	{
		vGapRead();
	}

	m_pcArticle.m_pch = m_pcFile.m_pch + m_pcGap.m_cch;
	m_pcArticle.fSetCch(m_pcFile.pchMax());	
	
	//
	// Preparse the file (meaning find where the header, body, and fields are.)
	//
	

	if (!fPreParse(nntpReturn))
		return nntpReturn.fFalse();

	m_ibBodyOffset = (DWORD)(m_pcBody.m_pch - m_pcFile.m_pch) ;

	return nntpReturn.fSetOK();
}



BOOL
CArticleCore::fPreParse(
					CNntpReturn & nntpReturn
					)
/*++

Routine Description:

    Find where the header, body, and fields are.
	Results for the fields is an array of structure in which
	each structure points to the parts of each field.

Arguments:

	nntpReturn - The return value for this function call
	pchMax -

Return Value:

    TRUE, if and only if process succeeded.

--*/
{

	//
	// clear the return code object
	//

	nntpReturn.fSetClear();


	//
	// Set the article's state
	//

	_ASSERT(asInitialized == m_articleState); //real
	m_articleState = asPreParsed;


	//
	// Create a pointer to the first address past the end of the article
	//

	char * pchMax = m_pcArticle.pchMax();

	//
	//	Some versions of fInit() our able to setup m_pcHeader based on IO buffers
	//	which captured the head of the article - make sure we remain within these if
	//	this is setup !
	//

	if( m_pcHeader.m_pch != 0 &&
		m_pcHeader.m_cch != 0 ) {

		_ASSERT( m_pcHeader.m_pch == m_pcArticle.m_pch ) ;

		pchMax = m_pcHeader.pchMax() ;
	}

	//
	// (re)initialize the list of header strings
	//

	m_cHeaders = 0;

	//
	// record where the header starts
	//

	m_pcHeader.m_pch = m_pcArticle.m_pch;
	m_pcHeader.m_cch = 0 ;

	//
	// Loop while there is data and the next field
	// doesn't start with a new line.
	//

	char * pchCurrent = m_pcArticle.m_pch;
	while( pchCurrent < pchMax && !fNewLine(pchCurrent[0]))
	{
		if (!fAddInternal(pchCurrent, pchMax, TRUE, nntpReturn))
			return nntpReturn.fFalse();
	}

	//
	// _ASSERT that the length of the header (as measured with the running total)
	// is correct.
	//
	_ASSERT((signed)  m_pcHeader.m_cch == (pchCurrent - m_pcHeader.m_pch));

	//
	// Check that there is at least one header line
	//

	if (0 == m_cHeaders)
		return nntpReturn.fSet(nrcArticleMissingHeader);

	//
	// Record the body's start and length
	//

	m_pcBody.m_pch = pchCurrent;
	m_pcBody.fSetCch(m_pcArticle.pchMax());


	//
	// Check that the body is not too long.
	//

	if (!fCheckBodyLength(nntpReturn))
		return nntpReturn.fFalse();

	return nntpReturn.fSetOK();
}

BOOL
CArticleCore::fGetHeader(
				LPSTR	szHeader,
				BYTE*	lpb,
				DWORD	cbSize,
				DWORD&	cbOut ) {

	cbOut = 0 ;

	HEADERS_STRINGS * phsMax = m_rgHeaders + m_cHeaders;
	HEADERS_STRINGS * phs;

	DWORD cbHeaderLen = lstrlen( szHeader );
	for (phs = m_rgHeaders;
			phs < phsMax;
			phs++)
	{
		//if ((phs->pcKeyword).fEqualIgnoringCase(szHeader))

		//if( _strnicmp( phs->pcKeyword.m_pch, szHeader, phs->pcKeyword.m_cch - 1 ) == 0 )
		if( (!phs->fRemoved) && (phs->pcKeyword.m_cch >= cbHeaderLen) &&  _strnicmp( phs->pcKeyword.m_pch, szHeader,  cbHeaderLen ) == 0 )
		{
			cbOut = (phs->pcValue).m_cch + 2 ;
			if( cbOut < cbSize ) {
				CopyMemory( lpb, (phs->pcValue).m_pch, cbOut-2) ;
				lpb[cbOut-2] = '\r' ;
				lpb[cbOut-1] = '\n' ;
				return	TRUE ;
			}	else	{
				SetLastError( ERROR_INSUFFICIENT_BUFFER ) ;
				return	FALSE ;
			}
		}

	}
	SetLastError( ERROR_INVALID_NAME ) ;
	return	FALSE ;
}				



BOOL
CArticleCore::fRemoveAny(
				  const char * szKeyword,
				  CNntpReturn & nntpReturn
				  )
/*++

Routine Description:

  Removes every occurance of a type of header (e.g. every "XRef:" header).

Arguments:

	szKeyword - The keyword to remove.
	nntpReturn - The return value for this function call

Return Value:

    TRUE, if and only if process succeeded.

--*/
{

	//
	// clear the return code object
	//

	nntpReturn.fSetClear();


	//
	// Set the article's state
	//

	_ASSERT(asPreParsed == m_articleState
			|| asModified == m_articleState);//real
	m_articleState = asModified;

	//
	// Loop though the array of header information
	// removing matches.
	//

	HEADERS_STRINGS * phsMax = m_rgHeaders + m_cHeaders;
	HEADERS_STRINGS * phs;

	for (phs = m_rgHeaders;
			phs < phsMax;
			phs++)
	{
		if ((phs->pcKeyword).fEqualIgnoringCase(szKeyword))
		{
			_ASSERT(TRUE == phs->fInFile); //real
			vRemoveLine(phs);
		}

	}

	
	return nntpReturn.fSetOK();
	
}

void
CArticleCore::vRemoveLine(
					  HEADERS_STRINGS * phs
					  )
/*++

Routine Description:

  Removes an item from the array of header info.

Arguments:

	phs - a pointer to an item in the array

Return Value:

    None

--*/
{
	if (!phs->fRemoved)
	{
		//
		// Make the item as removed
		//

		phs->fRemoved = TRUE;

		//
		// Adjust the size of the article and header.
		//

		m_pcArticle.m_pch = NULL;
		m_pcArticle.m_cch -= phs->pcLine.m_cch;
		m_pcHeader.m_pch = NULL;
		m_pcHeader.m_cch -= phs->pcLine.m_cch;
	}
}

BOOL
CArticleCore::fAdd(
			   char * pchCurrent,
			   const char * pchMax,
			   CNntpReturn & nntpReturn
			   )
/*++

Routine Description:

  Adds text to the header.

Arguments:

	pchCurrent - A pointer to a dynamically-allocated string buffer
	pchMax	- A pointer to one past the end of that string
	nntpReturn - The return value for this function call

Return Value:

    TRUE, if and only if process succeeded.

--*/
{
	//
	// clear the return code object
	//

	nntpReturn.fSetClear();


	//
	// Just like fAddInternal except that pchCurrent is call-by-value
	//

	return fAddInternal(pchCurrent, pchMax, FALSE, nntpReturn);
}


BOOL
CArticleCore::fAddInternal(
			   char * & pchCurrent,
			   const char * pchMax,
			   BOOL fInFile,
			   CNntpReturn & nntpReturn
			   )
/*++

Routine Description:

  Adds text to the header.

Arguments:

	pchCurrent - A pointer to a string buffer
	pchMax	- A pointer to one past the end of that string
	fInFile - True, if and only the string buffer is in a mapped file
	nntpReturn - The return value for this function call

Return Value:

    TRUE, if and only if process succeeded.

--*/
{
    TraceFunctEnter("CArticleCore::fAddInternal");

	//
	// clear the return code object
	//

	nntpReturn.fSetClear();

	//
	// Set the article's state
	//

	if (fInFile)
	{
		_ASSERT((asPreParsed == m_articleState)
			|| asModified == m_articleState);//real
	} else {
		_ASSERT((asPreParsed == m_articleState)
			|| asModified == m_articleState);//real
		m_articleState = asModified;
	}

	//
	// Check that there is a slot available in the header array.
	//

	if (uMaxFields <= m_cHeaders)
	{
		return nntpReturn.fSet(nrcArticleTooManyFields, m_cHeaders);
	}

	//
	// Create a pointer to the next slot in the header array
	//

	HEADERS_STRINGS * phs = &m_rgHeaders[m_cHeaders];

	//
	// Record whether the string buffer is dynamic or in a mapped file.
	//

	phs->fInFile = fInFile;

	//
	// Set that this field as not been removed
	//

	phs->fRemoved = FALSE;

	//
	// Record where the keyword and line start
	//

	phs->pcKeyword.m_pch = pchCurrent;
	phs->pcLine.m_pch = pchCurrent;
	
	//
	// Look for ":" and record it
	//

	for (;
			(pchCurrent < pchMax) && !fCharInSet(pchCurrent[0], ": \t\n\0");
			pchCurrent++)
			{};

	//
	// we should not be at the end and the character should be a ":"
	//

	if(!((pchCurrent < pchMax) && ':' == pchCurrent[0]))
	{
		nntpReturn.fSet(nrcArticleIncompleteHeader);
		ErrorTrace((DWORD_PTR) this, "%d, %s", nntpReturn.m_nrc, nntpReturn.szReturn());
		return nntpReturn.fFalse();
	}
	
	//
	// move current to the character following the ":"
	//

	pchCurrent++;
	phs->pcKeyword.m_cch = (DWORD)(pchCurrent - phs->pcKeyword.m_pch);

    // Avoid this check for INN-compatibility
	char chBad;
	if (!phs->pcKeyword.fCheckTextOrSpace(chBad))
		return nntpReturn.fSet(nrcArticleBadChar,  (BYTE) chBad, "header");

	//
	// Check for end-of-file and illegal an illegal character
	//

	if (pchCurrent >= pchMax)
		nntpReturn.fSet(nrcArticleIncompleteHeader);

	if (!fCheckFieldFollowCharacter(*pchCurrent))
	{
		const DWORD cMaxBuf = 50;
		char szKeyword[cMaxBuf];
		(phs->pcKeyword).vCopyToSz(szKeyword, cMaxBuf);
		nntpReturn.fSet(nrcArticleBadFieldFollowChar, szKeyword);
		ErrorTrace((DWORD_PTR) this, "%d, %s", nntpReturn.m_nrc, nntpReturn.szReturn());
		return nntpReturn.fFalse();
	}


	//
	// Look for end of white space
	//

	for (; (pchCurrent < pchMax) && fWhitespaceNull(pchCurrent[0]); pchCurrent++);

	phs->pcValue.m_pch = pchCurrent;


	//
	// Find the end of this item - it may be several lines long.
	//

	for(; pchCurrent < pchMax && '\0' != pchCurrent[0]; pchCurrent++ )
	{
		if( pchCurrent[0] == '\n' )
		{
			//
			// Continues if next char is white space (unless this is the end of the header)
			//

			if(pchCurrent+1 >= pchMax || !fWhitespaceNull(pchCurrent[1]))
			{
				//
				//   Hit the end,  so get out now.
				//

				pchCurrent++;		// Include the \n too.
				break;
			}
		}
	}

	//
	// The line to add should end in a \n
	//

	if((phs->pcLine.m_pch >= pchCurrent) || ('\n' != *(pchCurrent-1)))
	{
		const DWORD cMaxBuf = 50;
		char szLine[cMaxBuf];
		(phs->pcLine).vCopyToSz(szLine, cMaxBuf);
		nntpReturn.fSet(nrcArticleAddLineBadEnding, szLine);
		ErrorTrace((DWORD_PTR) this, "%d, %s", nntpReturn.m_nrc, nntpReturn.szReturn());
		return nntpReturn.fFalse();
	}

		
	//
	// Line string includes end of line.
	//

	phs->pcLine.fSetCch(pchCurrent);

	//
	// Value string does not include end of line, so trim it.
	//

	phs->pcValue.fSetCch(pchCurrent);
	phs->pcValue.dwTrimEnd(szNLChars);

	//
	// Adjust the size of the header
	//

	m_pcHeader.m_cch += phs->pcLine.m_cch;

	//
	// Adjust the size of the article
	//

	if (!fInFile)
	{
		m_pcArticle.m_cch += phs->pcLine.m_cch;
		m_pcArticle.m_pch = NULL;
		m_pcHeader.m_pch = NULL;

	}

	//
	// Increment the count in the array of headers.
	//

	m_cHeaders++;

    TraceFunctLeave();

	return nntpReturn.fSetOK();

}




BOOL
CArticleCore::fFindOneAndOnly(
			  const char * szKeyword,
			  HEADERS_STRINGS * & pHeaderString,
			  CNntpReturn & nntpReturn
						  )
/*++

Routine Description:

  Finds the one and only occurance of a field in the headers.
  If there is more than one, it returns an error.

Arguments:

	szKeyword - The keyword to remove.
	pHeaderString - a pointer to the field's keyword, value, and line.
	nntpReturn - The return value for this function call

Return Value:

    TRUE, if and only if process succeeded.

--*/
{

	//
	// clear the return code object
	//

	nntpReturn.fSetClear();


	//
	// Set the article's state
	//
	_ASSERT((asPreParsed == m_articleState)||(asSaved == m_articleState));//real


	//
	// Loop through the array of header data.
	//

	HEADERS_STRINGS * phsMax = m_rgHeaders + m_cHeaders;
	HEADERS_STRINGS * phsTemp;
	pHeaderString = NULL;

	for (phsTemp = m_rgHeaders;
			phsTemp < phsMax;
			phsTemp++)
	{
		if ((phsTemp->pcKeyword).fEqualIgnoringCase(szKeyword)
			&& !phsTemp->fRemoved)
		{
			if (pHeaderString)
			{
				nntpReturn.fSetEx(nrcArticleTooManyFieldOccurances, szKeyword);
				return FALSE;
			} else {
				pHeaderString = phsTemp;
			}
		}

	}

	if (!pHeaderString)
		return nntpReturn.fSetEx(nrcArticleMissingField, szKeyword);
	
	return nntpReturn.fSetOK();
	
}


BOOL
CArticleCore::fDeleteEmptyHeader(
					  CNntpReturn & nntpReturn
						  )
/*++

Routine Description:

  Removes every valueless field from the headers.

Arguments:

	nntpReturn - The return value for this function call

Return Value:

    TRUE, if and only if process succeeded.

--*/
{

	//
	// clear the return code object
	//

	nntpReturn.fSetClear();


	//
	// Set the article's state
	//

	_ASSERT((asPreParsed == m_articleState) || (asModified == m_articleState));//real



	//
	// Loop through the array of header data.
	//

	HEADERS_STRINGS * phsMax = m_rgHeaders + m_cHeaders;
	HEADERS_STRINGS * phs;

	
	for (phs = m_rgHeaders;
			phs < phsMax;
			phs++)
	{

		//
		//!!!CLIENT LATER -- should we assert if the line is not infile?
		//
		
		//
		// If the line has not already been remove and its value has zero length
		// then remove it.
		//

		if (0 == phs->pcValue.m_cch)
			vRemoveLine(phs);
	}
	
	return nntpReturn.fSetOK();
	
}

BOOL
CArticleCore::fGetBody(
		CMapFile * & pMapFile,
        char * & pchMappedFile,
		DWORD & dwLength
		)
/*++

Routine Description:

	Returns the body of the article.
	If article is cached, return pointers to the i/o buffers else
	map the file containing the article

Arguments:

	pMapFile - Returns the pointer to the mapped file (if mapping is needed)
	******** NOTE: It is the responsibility of the caller to delete this **********

	pchMappedFile - Returns the pointer to the article's body
	dwLength - Returns the length of the body.

Return Value:

	TRUE, if successful. FALSE, otherwise.

--*/
{
	// hopefully we dont have to map the article !
	pMapFile = NULL;

	if( fIsArticleCached() ) {

		if( m_pHeaderBuffer ) {

			// Skip over the new line
			pchMappedFile = (m_pcBody.m_pch + 2);
			dwLength = m_pcBody.m_cch - 2;

		}	else	{

			// Skip over the new line
			_ASSERT( m_ibBodyOffset );
			pchMappedFile = (m_pcArticle.m_pch + m_ibBodyOffset + 2);
			dwLength = m_pcArticle.m_cch - m_ibBodyOffset - 2;
		}
		
	}	else	{

		//
		//	article is not cached - check to see if it is already mapped
		//  if not - map it
		//

		if( m_pMapFile ) {

			pchMappedFile = (m_pcBody.m_pch + 2);
			dwLength = m_pcBody.m_cch - 2;

		} else {

			HANDLE hFile = INVALID_HANDLE_VALUE;
			DWORD  Offset = 0;
			DWORD  Length = 0;

			BOOL fWhole = fWholeArticle(hFile, Offset, Length);
			_ASSERT( fWhole );

			// deleted by caller !!!
			pMapFile = XNEW CMapFile( hFile, FALSE, FALSE, 0 ) ;

			if( !pMapFile || !pMapFile->fGood() ) {

				// error - failed to map file !
				pchMappedFile = NULL;
				dwLength = 0;
				if( pMapFile ) {
					XDELETE pMapFile;
					pMapFile = NULL;
				}
				return FALSE;

			}	else	{
				DWORD	cb ;
				char*	pch = (char*)pMapFile->pvAddress( &cb ) ;

				// Skip over the new line
				_ASSERT( m_ibBodyOffset );
				pchMappedFile = (pch + m_ibBodyOffset + 2);
				dwLength = cb - m_ibBodyOffset - 2;
			}
		}
	}

	// Assert that the body starts with a new line.
	_ASSERT(memcmp( pchMappedFile-2, "\r\n", 2 ) == 0 );

	return TRUE;
}

BOOL
CArticleCore::fSaveHeader(
					  CNntpReturn & nntpReturn,
					  PDWORD        pdwLinesOffset
						  )
/*++

Routine Description:

  Saves changes to the current header back to disk.

Arguments:

	nntpReturn - The return value for this function call

Return Value:

    TRUE, if and only if process succeeded.

--*/
{

	//
	// clear the return code object
	//

	nntpReturn.fSetClear();


	//
	// Set the article's state
	//

	_ASSERT(asModified == m_articleState);//real
	m_articleState = asSaved;



	//
	// _ASSERT that the header and the article have some content
	//

	_ASSERT(!m_pcHeader.m_pch && m_pcHeader.m_cch > 0
		   && !m_pcArticle.m_pch && m_pcArticle.m_cch > 0); //real

	if( fIsArticleCached() ) {

		fSaveCachedHeaderInternal( nntpReturn, pdwLinesOffset ) ;

	}	else	{

		//
		// Declare some objects
		//

		CPCString pcHeaderBuf;
		CPCString pcNewBody;

		fSaveHeaderInternal(pcHeaderBuf, pcNewBody, nntpReturn, pdwLinesOffset );

					
		m_pAllocator->Free(pcHeaderBuf.m_pch);

	}

	return nntpReturn.fIsOK();
	
}

BOOL
CArticleCore::fCommitHeader(	CNntpReturn&	nntpReturn )	{
/*++

Routine Description :

	The user is not going to call fSaveHeader(), however the article
	may have been created with an initial gap.
	This function will ensure the gap image is correct.

Arguments :

	nntpReturn - return error code if necessary !

Return Value :

	TRUE if successfull, false otherwise.

--*/

	if( !fIsArticleCached() ) {

		if( m_pcGap.m_cch != 0 ) {
			if( m_pMapFile == 0 ) {

				m_pMapFile = XNEW CMapFile(m_szFilename, m_hFile, TRUE, 0 );

				if (!m_pMapFile || !m_pMapFile->fGood())
					return nntpReturn.fSet(nrcArticleMappingFailed, m_szFilename, GetLastError());

				m_pcFile.m_pch = (char *) m_pMapFile->pvAddress( &(m_pcFile.m_cch) );

				m_pcGap.m_pch = m_pcFile.m_pch ;

			}
			vGapFill() ;
		}
	}

	return	TRUE ;
}

BOOL
CArticleCore::fSaveCachedHeaderInternal(
							CNntpReturn&	nntpReturn,
							PDWORD          pdwLinesOffset
							) {
/*++

Routine Description :

	Assuming that the entire article is sitting in a memory buffer
	somewhere, we want to try to modify the memory buffer to contain
	the correct header contents.

Arguments :


--*/

	//_ASSERT( m_hFile == INVALID_HANDLE_VALUE ) ;
	//_ASSERT( m_pBuffer != 0 ) ;
	//_ASSERT( m_cbBuffer >= m_pcArticle.m_cch ) ;


	CPCString	pcHeaderBuf ;
	CPCString	pcBodyBuf ;

	if( !fBuildNewHeader( pcHeaderBuf, nntpReturn, pdwLinesOffset ) )
		return	nntpReturn.fIsOK() ;

	if( m_pcArticle.m_cch <= m_pcFile.m_cch )	{

		if( m_pcBody.m_pch < (m_pcFile.m_pch + m_pcHeader.m_cch) ) {
			//
			//	Need to move the body around !
			//

			pcBodyBuf.m_pch = m_pcFile.m_pch + m_pcHeader.m_cch ;
			pcBodyBuf.m_cch = m_pcBody.m_cch ;

			pcBodyBuf.vMove( m_pcBody ) ;
			
			m_pcArticle.fSetPch( pcBodyBuf.pchMax() ) ;
			m_pcHeader.m_pch = m_pcArticle.m_pch ;
			m_pcBody = pcBodyBuf ;

		}	else	{

			m_pcArticle.fSetPch( m_pcBody.pchMax() ) ;
			m_pcHeader.m_pch = m_pcArticle.m_pch ;

		}
		m_pcGap.m_pch = 0 ;
		m_pcGap.m_cch = 0 ;

		m_pcHeader.vCopy( pcHeaderBuf ) ;


		//
		//	We have moved all the headers around - the pointers
		//	in the m_rgHeaders array refer to the dynamically allocated
		//	memory which starts at pcHeaderBuf.m_pch
		//	We want to do some math on each pointer to move it to
		//	the correct offset from m_pcHeader.m_pch
		//	
		//	So the math should be
		//
		//	m_pcHeader.m_pch Now points to first character of the header
		//	pcHeaderBuf.m_pch Points to first character of the regenerated header
		//	phs->XXXX->m_pch Originally points to first character in regen'd header
		//		should finally point to offset within m_pcHeader.m_pch buffer
		//
		//	(NEW)phs->XXXX->m_pch = (phs->XXXX->m_pch - pcHeaderBuf.m_pch) + m_pchHeader.m_pch ;
		//
		//	Note also that
		//

		for (HEADERS_STRINGS* phs = m_rgHeaders, 	*phsMax = m_rgHeaders + m_cHeaders;
			phs < phsMax;
			phs++)
		{
			phs->fInFile = TRUE;

			char * pchBufLine = phs->pcLine.m_pch;
			char * pchFileLine = m_pcHeader.m_pch +
				(pchBufLine - pcHeaderBuf.m_pch);

			//
			// Adjust all the line's pointers
			//

			phs->pcLine.m_pch =  pchFileLine;
			phs->pcKeyword.m_pch = pchFileLine;
			phs->pcValue.m_pch = pchFileLine +
				(phs->pcValue.m_pch - pchBufLine);
		}

		m_pAllocator->Free(pcHeaderBuf.m_pch);

		//
		// compress the items in the array
		//

		vCompressArray();
		
		if (0 == m_cHeaders)
			return nntpReturn.fSet(nrcArticleMissingHeader);



	}	else	{
		//
		//	Buffer is too small to hold resulting article !!
		//

		m_pHeaderBuffer = pcHeaderBuf.m_pch ;
		
		m_pcHeader.m_pch = m_pHeaderBuffer ;

	}


	return	nntpReturn.fSetOK() ;
}

BOOL
CArticleCore::fBuildNewHeader(	CPCString&		pcHeaderBuf,
							    CNntpReturn&	nntpReturn,
							    PDWORD          pdwLinesOffset )	{

    TraceFunctEnter("CArticleCore::fSaveHeaderInternal");

	//
	// Create a pointer to the array of header info and a pointer to the
	// first entry beyond the array of header info
	//

	HEADERS_STRINGS * phsMax = m_rgHeaders + m_cHeaders;
	HEADERS_STRINGS * phs;

	//
	// Create a buffer for the new header
	//


	pcHeaderBuf.m_pch = m_pAllocator->Alloc(m_pcHeader.m_cch);

	if (!pcHeaderBuf.m_pch)
		return nntpReturn.fSet(nrcMemAllocationFailed, __FILE__, __LINE__);

	//
	// The new header buffer starts out with zero content
	//

	pcHeaderBuf.fSetCch(pcHeaderBuf.m_pch);

	//
	// Loop though the array of header information
	//

	for (phs = m_rgHeaders;
			phs < phsMax;
			phs++)
	{
		//
		// Point to the start of the current line
		//

		char * pchOldLine = phs->pcLine.m_pch;

		//
		// If the current line has not be removed, copy it to the new buffer
		//

		if (!phs->fRemoved)
		{
			//
			// Point to where the current line will be copied to
			//

			char * pchNewLine = pcHeaderBuf.pchMax();

			//
			// _ASSERT that there is enough space in the buffer to do the
			// copy. There should be, because we should have allocated exactly
			// the right amount of space.
			//

			_ASSERT(pcHeaderBuf.m_pch + m_pcHeader.m_cch
						>= pcHeaderBuf.pchMax()+phs->pcLine.m_cch);//real

			//
			// Before copying the line to the new buffer, we'll check if it's 
			// Lines line, if it is, we'll record the offset into which to
			// back fill the actual line information.
			//
			if ( pdwLinesOffset && strncmp( phs->pcKeyword.m_pch, szKwLines, strlen(szKwLines) ) == 0 ) {
                *pdwLinesOffset =   pcHeaderBuf.m_cch +
                                    strlen( szKwLines ) +
                                    1;  // plus one space
            }

			//
			// Copy the line to the new buffer
			//

			pcHeaderBuf << (phs->pcLine);

			//
			// Adjust all the line's pointers
			//

			phs->pcLine.m_pch =  pchNewLine;
			phs->pcKeyword.m_pch = pchNewLine;
			phs->pcValue.m_pch += (pchNewLine - pchOldLine);
		}

		//
		// If the memory was allocated dynamically, free it.
		//
		if (!phs->fInFile)
			m_pAllocator->Free(pchOldLine);


	}
	
	//
	// double check that everything copy copied to the buffer
	//
	_ASSERT(pcHeaderBuf.m_cch == m_pcHeader.m_cch); //real



	return	nntpReturn.fSetOK() ;

}

BOOL
CArticleCore::fSaveHeaderInternal(
							    CPCString & pcHeaderBuf,
							    CPCString & pcNewBody,
				  			    CNntpReturn & nntpReturn,
				  			    PDWORD      pdwLinesOffset
							)
/*++

Routine Description:

  Does most of the work of saving changes to the current header back to disk.

Arguments:

	nntpReturn - The return value for this function call

Return Value:

    TRUE, if and only if process succeeded.

--*/
{
    TraceFunctEnter("CArticleCore::fSaveHeaderInternal");

	//
	// Create a pointer to the array of header info and a pointer to the
	// first entry beyond the array of header info
	//

	HEADERS_STRINGS * phsMax = m_rgHeaders + m_cHeaders;
	HEADERS_STRINGS * phs;

	//
	// Create a buffer for the new header
	//


	if( !fBuildNewHeader( pcHeaderBuf, nntpReturn, pdwLinesOffset ) )
		return	nntpReturn.fIsOK() ;


	//
	// Now there are two cases 1. There is enough room in the
	// file for the new header or 2. there is not.
	//

	//
	// Case 1. There is enough room
	//
	if (m_pcArticle.m_cch <= m_pcFile.m_cch)
	{
		//
		// Update article/header/gap
		// (body and file stay the same).
		//


		if( m_pMapFile == 0 ) {

			m_pMapFile = XNEW CMapFile(m_szFilename, m_hFile, TRUE, 0 );

			if (!m_pMapFile || !m_pMapFile->fGood())
				return nntpReturn.fSet(nrcArticleMappingFailed, m_szFilename, GetLastError());

			m_pcFile.m_pch = (char *) m_pMapFile->pvAddress( &(m_pcFile.m_cch) );

			m_pcGap.m_pch = m_pcFile.m_pch ;

		}

		_ASSERT(m_pcArticle.m_cch == pcHeaderBuf.m_cch + m_pcBody.m_cch); //real
		m_pcArticle.fSetPch(m_pcFile.pchMax());
		m_pcHeader.m_pch = m_pcArticle.m_pch;
		m_pcGap.fSetCch(m_pcArticle.m_pch);



		//
		//Fill in the gap
		//

		vGapFill();

	} else {
		//
		// Case 2. There is not enough room, so close and reopen the file bigger
		//

		//
		// Double check that we know the article, header and body sizes
		// are consistent.
		//

		_ASSERT(m_pcArticle.m_cch == pcHeaderBuf.m_cch + m_pcBody.m_cch); //real


		//
		// Need to create a new file
		//

		//
		// Find offset of body from start of file
		//

		DWORD dwBodyOffset = m_ibBodyOffset ; //m_pcBody.m_pch - m_pcFile.m_pch;
		
		//
		//!!!CLIENT NOW - This  does not need to close the handle.
		// It could just close the mapping and then
		// reopen the mapping bigger.
		//

		//
		// Close and reopen the file and mapping
		//

		if( m_pMapFile )
			vClose();
		

		//!!!MEM now
		m_pMapFile = XNEW CMapFile(m_szFilename, m_hFile, TRUE, m_pcArticle.m_cch - m_pcFile.m_cch);


		if (!m_pMapFile || !m_pMapFile->fGood())
			return nntpReturn.fSet(nrcArticleMappingFailed, m_szFilename, GetLastError());

		//
		// Point to the start of the new file
		//

		m_pcFile.m_pch = (char *) m_pMapFile->pvAddress( &(m_pcFile.m_cch) );

		//
		// Point to the start of the body in the new mapping
		//

		m_pcBody.m_pch = m_pcFile.m_pch + dwBodyOffset;

		//
		// Set gap to new mapping, size 0
		//

		m_pcGap.m_pch = m_pcFile.m_pch;
		m_pcGap.m_cch = 0;

		//
		// Set article to new mapping
		//

		m_pcArticle.m_pch = m_pcFile.m_pch + m_pcGap.m_cch;
		_ASSERT(m_pcArticle.pchMax() == m_pcFile.pchMax());	//real

		//
		// Set header to new mapping
		//

		m_pcHeader.m_pch = m_pcArticle.m_pch;
		
		//
		// Shift the body down
		//

		pcNewBody.m_pch = m_pcArticle.m_pch + m_pcHeader.m_cch;
		pcNewBody.fSetCch(m_pcArticle.pchMax());

		ErrorTrace((DWORD_PTR) this, "About to move the body %d bytes", pcNewBody.m_pch - m_pcBody.m_pch);

        //
        //  src+len and dst+len should be within the file mapping
        //
        ASSERT( m_pcBody.m_pch+m_pcBody.m_cch <= m_pcFile.m_pch+m_pcFile.m_cch );
        ASSERT( pcNewBody.m_pch+m_pcBody.m_cch <= m_pcFile.m_pch+m_pcFile.m_cch );
		pcNewBody.vMove(m_pcBody);
		m_pcBody = pcNewBody;
#if DEBUG
		_ASSERT(memcmp( m_pcFile.pchMax()-5, "\r\n.\r\n", 5 ) == 0 );
		_ASSERT(memcmp( m_pcArticle.pchMax()-5, "\r\n.\r\n", 5 ) == 0 );
		_ASSERT(memcmp( m_pcBody.pchMax()-5, "\r\n.\r\n", 5 ) == 0 );
#endif
	}

	//
	// Fill in the new header
	//

	m_pcHeader.vCopy(pcHeaderBuf);
	
	//
	// adjust the field's start pointers
	//

	//
	//!!!CLIENT LATER there may be an off-by-one error here
	//!!! this hasn't been test well because new mapping keeps coming
	// up with the same address as the old mapping
	//

	for (phs = m_rgHeaders;
		phs < phsMax;
		phs++)
	{
		phs->fInFile = TRUE;

		char * pchBufLine = phs->pcLine.m_pch;
		char * pchFileLine = m_pcHeader.m_pch +
			(pchBufLine - pcHeaderBuf.m_pch);

		//
		// Adjust all the line's pointers
		//

		phs->pcLine.m_pch =  pchFileLine;
		phs->pcKeyword.m_pch = pchFileLine;
		phs->pcValue.m_pch = pchFileLine +
			(phs->pcValue.m_pch - pchBufLine);
	}

	//
	// compress the items in the array
	//

	vCompressArray();
	
	if (0 == m_cHeaders)
		return nntpReturn.fSet(nrcArticleMissingHeader);

	return nntpReturn.fSetOK();
}

void
CArticleCore::vCompressArray(
						 void
						  )
/*++

Routine Description:

  Removes empty entries from the array of header items.

Arguments:

	None

Return Value:

    None

--*/
{

	//
	// Loop though the array
	//

	HEADERS_STRINGS * phsMax = m_rgHeaders + m_cHeaders;
	HEADERS_STRINGS * phsBefore;
	HEADERS_STRINGS * phsAfter = m_rgHeaders;;

	for (phsBefore = m_rgHeaders;
			phsBefore < phsMax;
			phsBefore++)
	{
		if (phsBefore->fRemoved)
		{
			//
			// only InFile fields may be deleted
			//
			_ASSERT(phsBefore->fInFile);//real
			m_cHeaders--;
		} else {

			//
			// If deleted items have been skipped over, then copy
			// items down.
			//

			if (phsBefore != phsAfter)
				CopyMemory(phsAfter, phsBefore, sizeof(HEADERS_STRINGS));
			phsAfter++;
		}
	}
}

void
CArticleCore::vGapFill(
		 void
		 )
/*++

Routine Description:

	Fills the gap in the file.
	
	The rule is	a gap is any whitespace before non-whitespace
	except if a gap starts with a TAB then it can contain
	a number that tells the size of the gap.

Arguments:

	None

Return Value:

    None

--*/
{
	switch (m_pcGap.m_cch)
	{
		case 0:

			//
			// do nothing
			//

			break;
		case 1:
			m_pcGap.m_pch[0] = ' ';
			break;
		case 2:
			m_pcGap.m_pch[0] = ' ';
			m_pcGap.m_pch[1] = ' ';
			break;
		case 3:
			lstrcpy(m_pcGap.m_pch, "   ");
			break;
		default:

			//
			// Fill the gap with  " nnnn      " where
			// nnnn is the size of the gap, expressed in as few
			// decimal digits as possible.
			//

			int iFilled = wsprintf(m_pcGap.m_pch, "\t%-lu ", m_pcGap.m_cch);
			FillMemory(m_pcGap.m_pch + iFilled, m_pcGap.m_cch - iFilled, (BYTE) ' ');
	}
	
};

void
CArticleCore::vGapRead(
		 void
		 )
/*++

Routine Description:

	Reads the gap in the file.
	
	If there is a gap, it start with ' ' or '\x0d'

Arguments:

	None

Return Value:

    None

--*/
{
	_ASSERT(m_pcGap.m_pch == m_pcFile.m_pch); //real

	//
	//If the file is empty or starts with something besides ' '
	// then the gap must have zero length
	//

	if (0 == m_pcFile.m_cch || !isspace((UCHAR)m_pcGap.m_pch[0]))
	{
		m_pcGap.m_cch = 0;
		return;
	}

#if 0
	if ('\t' == m_pcGap.m_pch[0])
	{
		if (1 == sscanf(m_pcGap.m_pch, " %u ", &m_pcGap.m_cch))
		{
			return;
		}
	}
#endif

	//
	// the gap ends with the whitespace ends
	//

	char * pcGapMax = m_pcGap.m_pch;
	char * pcFileMax = m_pcFile.pchMax();
	while (pcGapMax <= pcFileMax && isspace((UCHAR)pcGapMax[0]))
		pcGapMax++;

	if( '\t' == m_pcGap.m_pch[0]) {
		char	szBuff[9] ;
		ZeroMemory( szBuff, sizeof( szBuff ) ) ;
		CopyMemory( szBuff, pcGapMax, min( sizeof(szBuff)-1, pcFileMax - pcGapMax ) ) ;
		for( int i=0; i<sizeof(szBuff); i++ ) {
			if( !isdigit( (UCHAR)szBuff[i] ) )			
				break ;		
		}
		szBuff[i] = '\0' ;
		m_pcGap.m_cch = atoi( szBuff ) ;
		return ;
	}

	m_pcGap.fSetCch(pcGapMax);
	return;
}


BOOL
CField::fParseSimple(
						BOOL fEmptyOK,
						CPCString & pc,
						CNntpReturn & nntpReturn
						)
/*++

Routine Description:

	 Finds everything in the value part of a header line
	 expect trims staring and ending white space.


Arguments:

	fEmptyOK - True, if and only, if empty values are OK
	pc - The PCString to return
	nntpReturn - The return value for this function call


Return Value:

	TRUE, if successful. FALSE, otherwise.

--*/
{
	//
	// clear the return code object
	//

	nntpReturn.fSetClear();


	//
	// Set article state
	//
	_ASSERT(fsFound == m_fieldState);//real
	_ASSERT(m_pHeaderString); //real


	m_fieldState = fsParsed;
	
	pc = m_pHeaderString->pcValue;

	pc.dwTrimStart(szWSNLChars);
	pc.dwTrimEnd(szWSNLChars);

	if (!fEmptyOK && 0 == pc.m_cch )
		return nntpReturn.fSetEx(nrcArticleFieldMissingValue, szKeyword());

	return nntpReturn.fSetOK();
}


BOOL
CField::fParseSplit(
						BOOL fEmptyOK,
						char * & multisz,
						DWORD & c,
						char const * szDelimSet,
						CArticleCore & article,
						CNntpReturn & nntpReturn
						)
/*++

Routine Description:

	Splits the value part of a header into a list.

Arguments:

	fEmptyOK - True, if and only, if empty values are OK
	multisz - The list returned
	c - The size of the list returned
	szDelimSet - A set of delimiters
	nntpReturn - The return value for this function call


Return Value:

	TRUE, if successful. FALSE, otherwise.

--*/
{
	//
	// clear the return code object
	//

	nntpReturn.fSetClear();


	//
	// Set article state
	//

	_ASSERT(fsFound == m_fieldState);//real
	_ASSERT(m_pHeaderString); //real
	m_fieldState = fsParsed;
	
	CPCString * ppcValue = & (m_pHeaderString->pcValue);

	multisz = article.pAllocator()->Alloc((ppcValue->m_cch)+2);

	if (multisz == NULL)
		return nntpReturn.fSet(nrcMemAllocationFailed, __FILE__, __LINE__);

	ppcValue->vSplitLine(szDelimSet, multisz, c);

	if (!fEmptyOK && 0 == c)
		return nntpReturn.fSetEx(nrcArticleFieldZeroValues, szKeyword());

	return nntpReturn.fSetOK();
}


BOOL
CMessageIDField::fParse(
					    CArticleCore & article,
						CNntpReturn & nntpReturn
						)
/*++

Routine Description:

	Parses MessageID headers.

Arguments:

	nntpReturn - The return value for this function call


Return Value:

	TRUE, if successful. FALSE, otherwise.

--*/
{
	//
	// clear the return code object
	//

	extern	BOOL
	FValidateMessageId(	LPSTR	lpstrMessageId ) ;


	nntpReturn.fSetClear();


	//
	// Set article state
	//

	_ASSERT(fsFound == m_fieldState);//real
	_ASSERT(m_pHeaderString); //real
	CPCString pcMessageID;

	if (!fParseSimple(FALSE, pcMessageID, nntpReturn))
		return FALSE;

	if (MAX_MSGID_LEN-1 <= pcMessageID.m_cch)
		return nntpReturn.fSet(nrcArticleFieldMessIdTooLong, pcMessageID.m_cch, MAX_MSGID_LEN-1);


	if (!(
		'<' == pcMessageID.m_pch[0]
		&&	'>' == pcMessageID.m_pch[pcMessageID.m_cch - 1]
		))
		return nntpReturn.fSet(nrcArticleFieldMessIdNeedsBrack);

	//
	// See if '>' anywhere other than as the last character
	//
#if 0
	char * pchLast = pcMessageID.pchMax() -1;
	for (char * pch = pcMessageID.m_pch + 1; pch < pchLast; pch++)
	{
		if ('>' == *pch)
			return nntpReturn.fSet(nrcArticleFieldMessIdNeedsBrack);
	}
#endif

	pcMessageID.vCopyToSz(m_szMessageID);

	if( !FValidateMessageId( m_szMessageID ) ) {
		nntpReturn.fSet(nrcArticleBadMessageID, m_szMessageID, szKwMessageID  ) ;
		ZeroMemory( &m_szMessageID[0], sizeof( m_szMessageID ) ) ;
        return  FALSE ;
	}

	return nntpReturn.fSetOK();	
}


					
const char *
CNewsgroupsField::multiSzGet(
						void
						)
/*++

Routine Description:

	Returns the list of newsgroups in the Newsgroups field as a
	multisz.

Arguments:

	None.

Return Value:

	The list of Newsgroups.

--*/
{
	_ASSERT(fsParsed == m_fieldState);//real
	return m_multiSzNewsgroups;
}


DWORD
CNewsgroupsField::cGet(
						void
						)
/*++

Routine Description:

	Returns the number of newsgroups in the Newsgroups field as a
	multisz.

Arguments:

	None.

Return Value:

	The number of newsgroups.

--*/
{
	_ASSERT(fsParsed == m_fieldState);//real
	return m_cNewsgroups;
}

const char *
CDistributionField::multiSzGet(
						void
						)
/*++

Routine Description:

	Returns the list of Distribution in the Distribution field as a
	multisz.

Arguments:

	None.

Return Value:

	The list of Distribution.

--*/
{
	_ASSERT(fsParsed == m_fieldState);//real
	return m_multiSzDistribution;
}



DWORD
CDistributionField::cGet(
						void
						)
/*++

Routine Description:

	Returns the number of Distribution in the Distribution field as a
	multisz.

Arguments:

	None.

Return Value:

	The number of Distribution.

--*/
{
	_ASSERT(fsParsed == m_fieldState);//real
	return m_cDistribution;
}


const char *
CPathField::multiSzGet(
						void
						)
/*++

Routine Description:

	Returns the list of path items in the Path field as a
	multisz.

Arguments:

	None.

Return Value:

	The list of path items.

--*/
{
	
	const char * multiszPath = m_multiSzPath;
	if (multiszPath)
		return multiszPath;
	else
		return "\0\0";
}


BOOL
CPathField::fSet(
 				 CPCString & pcHub,
				 CArticleCore & article,
				 CNntpReturn & nntpReturn
				 )
/*++

Routine Description:

	Replaces any old Path headers (if any) with a new one.	

Arguments:

	pcHub - The name of the hub the current machine is part of.
	article - The article being processed.
	nntpReturn - The return value for this function call


Return Value:

	TRUE, if successful. FALSE, otherwise.

--*/
{
	//
	// clear the return code object
	//

	nntpReturn.fSetClear();


	//
	// Set article state
	//

	_ASSERT(fsParsed == m_fieldState);//real
	CPCString pcLine;


	//
	// Record the allocator
	//

	m_pAllocator = article.pAllocator();

	//
	// max size needed is
	//

	const DWORD cchMaxPath =
			STRLEN(szKwPath)	// for the Path keyword
			+ 1					// space following the keyword
			+ pcHub.m_cch		// the hub name
			+ 1					// the "!"
			+ (m_pHeaderString->pcValue).m_cch

								//
								// length of the old value.
								//

			+ 2 // for the newline
			+ 1; // for a terminating null

	//
	// Allocate memory for line within a PCString.
	//

	pcLine.m_pch  = article.pAllocator()->Alloc(cchMaxPath);
	if (!pcLine.m_pch)
		return nntpReturn.fSet(nrcMemAllocationFailed, __FILE__, __LINE__);

	//
	// Start with "Path: <hubname>!"
	//

	wsprintf(pcLine.m_pch, "%s %s!", szKwPath, pcHub.sz());
	pcLine.m_cch = STRLEN(szKwPath)	+ 1	+ pcHub.m_cch + 1;

	//
	// Add the old path value and string terminators
	//

	pcLine << (m_pHeaderString->pcValue) << "\r\n";
	pcLine.vMakeSz(); // add string terminator

	//
	// confirm that we allocated enough memory
	//

	_ASSERT(cchMaxPath-1 == pcLine.m_cch);//real


	if (!(
  		article.fRemoveAny(szKwPath, nntpReturn)
		&& article.fAdd(pcLine.sz(), pcLine.m_pch+cchMaxPath, nntpReturn)
		))
	{
		article.pAllocator() -> Free(pcLine.m_pch);
		return nntpReturn.fFalse();
	}
	
	return nntpReturn.fIsOK();
}



BOOL
CPathField::fCheck(
 				 CPCString & pcHub,
				 CNntpReturn & nntpReturn
				 )
/*++

Routine Description:

	Tells if the current hub name appears in the path (but
	the last position doesn't count. See RFC1036).

	This is used for finding cycles.


Arguments:

	pcHub - The name of the hub the current machine is part of.
	nntpReturn - The return value for this function call


Return Value:

	TRUE, if successful. FALSE, otherwise.

--*/
{
	//
	// clear the return code object
	//

	nntpReturn.fSetClear();


	//
	// Set article state
	//

	_ASSERT(fsParsed == m_fieldState);//real
	_ASSERT(!m_fChecked);
	m_fChecked = TRUE;

	char const * sz = multiSzGet();
	DWORD	dwCount = cGet();
	do
	{
		if ((0 == lstrcmp(sz, pcHub.sz()))
				&& (dwCount >=1))
			return nntpReturn.fSet(nrcPathLoop, pcHub.sz());

		dwCount--;

		//
		// go to first char after next null
		//

		while ('\0' != sz[0])
			sz++;
		sz++;
	} while ('\0' != sz[0]);

	return nntpReturn.fSetOK();
}
	
BOOL
CControlField::fParse(
			 CArticleCore & article,
			 CNntpReturn & nntpReturn
			 )
/*++

Routine Description:

	Parses the control field.

Arguments:

	nntpReturn - The return value for this function call


Return Value:

	TRUE, if successful. FALSE, otherwise.

--*/
{
	//
	// clear the return code object
	//

	nntpReturn.fSetClear();

	//
	// Check article state
	//

	_ASSERT(fsFound == m_fieldState);//real
	_ASSERT(m_pHeaderString); //real

	if (!fParseSimple(FALSE, m_pc, nntpReturn))
		return nntpReturn.fFalse();

    BOOL fValidMsg = FALSE;
    for(DWORD i=0; i<MAX_CONTROL_MESSAGES; i++)
    {
        DWORD cbMsgLen = lstrlen(rgchControlMessageTbl [i]);

        // The control message keyword len is greater than the value in the control header
        if(m_pc.m_cch < cbMsgLen)
            continue;

        char * pch = m_pc.m_pch;
        if(!_strnicmp(pch, rgchControlMessageTbl[i], cbMsgLen))
        {
            // check for exact match
            if(!isspace((UCHAR)*(pch+cbMsgLen)))
                continue;

            // matched control message keyword - note the type
            m_cmCommand = (CONTROL_MESSAGE_TYPE)i;
            fValidMsg = TRUE;
            break;
        }
    }

    if(!fValidMsg)
        return nntpReturn.fSet(nrcIllegalControlMessage);

	return nntpReturn.fSetOK();
}
	
BOOL
CXrefField::fSet(
				 CPCString & pcHub,
				 CNAMEREFLIST & namereflist,
				 CArticleCore & article,
				 CNewsgroupsField & fieldNewsgroups,
				 CNntpReturn & nntpReturn
				 )
/*++

Routine Description:

	Replaces any old Xref headers with a new one.

  The form of an Xref line is something like:
		Xref: <hubname> alt.politics.libertarian:48170 talk.politics.misc:188851


Arguments:

	pcHub - The name of the hub the current machine is part of.
	namereflist - a list of the newsgroups names and article numbers
	article - The article being processed.
	fieldNewsgroups - The Newsgroups field for this article.
	nntpReturn - The return value for this function call

Return Value:

	TRUE, if successful. FALSE, otherwise.
*/
{

	//
	// clear the return code object
	//

	nntpReturn.fSetClear();


	//
	// Set article state
	//
	// We don't expect this field to be found or parsed, because
	// we don't care about old values, if any.
	//

	_ASSERT(fsInitialized == m_fieldState);//real
	CPCString pcLine;


	//
	// The number of our newsgroups to post to.
	//

	const DWORD cgroups = namereflist.GetCount();


#if 0   // we want XREF in all articles, not just crossposted ones
	if( cgroups == 1 ) {

		if (!article.fRemoveAny(szKwXref, nntpReturn))
			nntpReturn.fFalse();

	}	else	{
#endif

		//
		// max size needed is
		//

		const DWORD cchMaxXref =
				STRLEN(szKwXref)	// for the Xref keyword
				+ 1					// space following the keyword
				+ pcHub.m_cch		// the hub name
				+ ((fieldNewsgroups.m_pHeaderString)->pcValue).m_cch
				+ 16				// max size of any of the control.* groups
				+ (cgroups *		// for each newsgroup
					(10				// space for any DWORD
					+ 2))			// space for the ":" and leading space

				//
				// length of the old value.
				//

				+ 2 // for the newline
				+ 1; // for a terminating null

		//
		// Allocate memory for line within a PCString.
		//

		pcLine.m_pch  = article.pAllocator() -> Alloc(cchMaxXref);
		if (!pcLine.m_pch)
			return nntpReturn.fSet(nrcMemAllocationFailed, __FILE__, __LINE__);

		//
		// Start with "Xref: <hubname>"
		//

		wsprintf(pcLine.m_pch, "%s %s", szKwXref, pcHub.sz());
		pcLine.m_cch = STRLEN(szKwXref)	+ 1	+ pcHub.m_cch;

		//
		// For each newsgroup ...
		//

		POSITION	pos = namereflist.GetHeadPosition() ;
		while( pos  )
		{
			NAME_AND_ARTREF * pNameAndRef = namereflist.GetNext( pos ) ;

			//
			// Add " <newsgroupname>:<articlenumber>"
			//

			pcLine << (const CHAR)' ' << (pNameAndRef->pcName)
	               << (const CHAR)':' << ((pNameAndRef->artref).m_articleId);
		}

		//
		// Add newline and string terminators.
		//

		pcLine << "\r\n";
		pcLine.vMakeSz(); // add string terminator

		 //
		 // confirm that we allocated enough memory
		 //

		_ASSERT(cchMaxXref >= pcLine.m_cch);//real

		//
		// Remove the old Xref line and add the new one.
		//

		if (!(
  				article.fRemoveAny(szKwXref, nntpReturn)
				&& article.fAdd(pcLine.sz(), pcLine.pchMax(), nntpReturn)
				))
		{
			article.pAllocator() -> Free(pcLine.m_pch);	
			return nntpReturn.fFalse();
		}

#if 0 // XREF in all articles, not just cross posted ones
	}
#endif

	return nntpReturn.fIsOK();
}


		
BOOL
CXrefField::fSet(
				 CArticleCore & article,
				 CNntpReturn & nntpReturn
				 )
/*++

Routine Description:

	 Just remove the old fields, if any.


Arguments:

	article - The article being processed.
	nntpReturn - The return value for this function call


Return Value:

	TRUE, if successful. FALSE, otherwise.

--*/
{
	_ASSERT(fsInitialized == m_fieldState);//real
	CPCString pcLine;
	nntpReturn.fSetClear(); // clear the return object

	if (!article.fRemoveAny(szKwXref, nntpReturn))
		nntpReturn.fFalse();

	return nntpReturn.fIsOK();
}


BOOL
CField::fFind(
			  CArticleCore & article,
			  CNntpReturn & nntpReturn
			)
/*++

Routine Description:

	Finds the location of a field (based on keyword) in the article.
	Returns an error if there is more than one occurance of the field.

Arguments:

	article - The article being processed.
	nntpReturn - The return value for this function call


Return Value:

	TRUE, if successful. FALSE, otherwise.

--*/
{
	
	//
	// clear the return code object
	//

	nntpReturn.fSetClear();


	//
	// Set article state
	//
	_ASSERT(fsInitialized == m_fieldState); //real
	m_fieldState = fsFound;

	//
	// Mark as not set
	//

	return article.fFindOneAndOnly(szKeyword(), m_pHeaderString, nntpReturn);
}


BOOL
CField::fFindOneOrNone(
			  CArticleCore & article,
			  CNntpReturn & nntpReturn
			)
/*++

Routine Description:

	Finds the location of a field (based on keyword) in the article.
	Returns an error if there is more than one occurance of the field.
	Does not return an error if the field does not exist at all.



Arguments:

	article - The article being processed.
	nntpReturn - The return value for this function call


Return Value:

	TRUE, if successful. FALSE, otherwise.

--*/
{
	//
	// clear the return code object
	//

	nntpReturn.fSetClear();

	//
	// Set article state
	//

	_ASSERT(fsInitialized == m_fieldState); //real

	if (!article.fFindOneAndOnly(szKeyword(), m_pHeaderString, nntpReturn))

		//
		//If the field is missing that is OK
		//

		if (nntpReturn.fIs(nrcArticleMissingField))
		{
			m_fieldState = fsNotFound;
			return nntpReturn.fSetOK();
		} else {
			return nntpReturn.fFalse(); // return with error from FindOneAndOnly
		}

	m_fieldState = fsFound;
	return nntpReturn.fIsOK();

}

BOOL
CField::fFindNone(
			  CArticleCore & article,
			  CNntpReturn & nntpReturn
			)
/*++

Routine Description:

	Finds the location of a field (based on keyword) in the article.
	Returns an error if there is one occurance of the field.
	Does not return an error if the field does not exist at all.

Arguments:

	article - The article being processed.
	nntpReturn - The return value for this function call


Return Value:

	TRUE, if successful. FALSE, otherwise.

--*/
{
	//
	// clear the return code object
	//

	nntpReturn.fSetClear();

	//
	// Set article state
	//

	_ASSERT(fsInitialized == m_fieldState); //real

	if (!article.fFindOneAndOnly(szKeyword(), m_pHeaderString, nntpReturn))
    {
		//
		//If the field is missing that is OK
		//
		if (nntpReturn.fIs(nrcArticleMissingField))
		{
			m_fieldState = fsNotFound;
			return nntpReturn.fSetOK();
		}

    } else {
        nntpReturn.fSet(nrcSystemHeaderPresent, szKeyword());
    }

	return nntpReturn.fFalse();
}

BOOL
CNewsgroupsField::fParse(
						 CArticleCore & article,
						 CNntpReturn & nntpReturn
						 )
/*++

Routine Description:

	Parse the Newsgroups field by creating a list and removing duplicates.

Arguments:

	nntpReturn - The return value for this function call


Return Value:

	TRUE, if successful. FALSE, otherwise.

--*/
{
	//
	// clear the return code object
	//

	nntpReturn.fSetClear();

	//
	// Record the allocator
	//

	m_pAllocator = article.pAllocator();

	//
	// Check article state
	//

	_ASSERT(fsFound == m_fieldState);//real

	_ASSERT(m_pHeaderString); //real

	if (!fParseSplit(FALSE, m_multiSzNewsgroups, m_cNewsgroups, " \t\r\n,",
				article, nntpReturn))
		return nntpReturn.fFalse();

	//
	//Remove duplicates
	//

	if (!fMultiSzRemoveDupI(m_multiSzNewsgroups, m_cNewsgroups, article.pAllocator()))
		nntpReturn.fSet(nrcMemAllocationFailed, __FILE__, __LINE__);

	
	//
	// check for illegal characters and substrings in newsgroup name
	//

	char const * szNewsgroup = m_multiSzNewsgroups;
	DWORD i = 0;
	do
	{
		if ('\0' == szNewsgroup[0]
			|| strpbrk(szNewsgroup,":")
			|| '.' == szNewsgroup[0]
			|| strstr(szNewsgroup,"..")
			)
		return nntpReturn.fSet(nrcArticleFieldIllegalNewsgroup, szNewsgroup, szKeyword());

		//
		// go to first char after next null
		//

		while ('\0' != szNewsgroup[0])
			szNewsgroup++;
		szNewsgroup++;
	} while ('\0' != szNewsgroup[0]);

	return nntpReturn.fSetOK();
}


BOOL
CDistributionField::fParse(
						 CArticleCore & article,
						 CNntpReturn & nntpReturn
						 )
/*++

Routine Description:

	Parse the Distribution field by creating a list and removing duplicates.

Arguments:

	nntpReturn - The return value for this function call


Return Value:

	TRUE, if successful. FALSE, otherwise.

--*/
{
	//
	// clear the return code object
	//

	nntpReturn.fSetClear();

	//
	// Record the allocator
	//

	m_pAllocator = article.pAllocator();

	//
	// Check article state
	//

	_ASSERT(fsFound == m_fieldState);//real

	_ASSERT(m_pHeaderString); //real

	if (!fParseSplit(FALSE, m_multiSzDistribution, m_cDistribution, " \t\r\n,",
				article, nntpReturn))
		return nntpReturn.fFalse();

	//
	//Remove duplicates
	//

	if (!fMultiSzRemoveDupI(m_multiSzDistribution, m_cDistribution, article.pAllocator()))
		nntpReturn.fSet(nrcMemAllocationFailed, __FILE__, __LINE__);

	
	//
	// Don't really need to check for illegal characters, because
	// we should be able to tolerate them.
	//

	return nntpReturn.fSetOK();
}


BOOL
CArticleCore::fHead(
			  HANDLE & hFile,
			  DWORD & dwOffset,
			  DWORD & dwLength
			  )
/*++

Routine Description:

	Returns the header of the article.

Arguments:

	hFile - Returns a handle to the file
	dwOffset - Returns the offset to the article's header
	dwLength - Returns the length of the header.


Return Value:

	TRUE, if successful. FALSE, otherwise.

--*/
{
	_ASSERT(INVALID_HANDLE_VALUE != m_hFile);
	hFile = m_hFile;
	dwOffset = (DWORD)(m_pcHeader.m_pch - m_pcFile.m_pch);
	dwLength = m_pcHeader.m_cch;
	return TRUE;
}


BOOL
CArticleCore::fBody(
			  HANDLE & hFile,
			  DWORD & dwOffset,
			  DWORD & dwLength
			  )
/*++

Routine Description:

	Returns the body of the article.

Arguments:

	hFile - Returns a handle to the file
	dwOffset - Returns the offset to the article's body
	dwLength - Returns the length of the body.

Return Value:

	TRUE, if successful. FALSE, otherwise.

--*/
{
	_ASSERT(INVALID_HANDLE_VALUE != m_hFile);
	hFile = m_hFile;

	// Assert that the body start with a new line.
	_ASSERT(memcmp( m_pcBody.m_pch, "\r\n", 2 ) == 0 );

	//
	// Skip over the new line
	//

	dwOffset = (DWORD)((m_pcBody.m_pch + 2) - m_pcFile.m_pch);

	dwLength = m_pcBody.m_cch - 2;

	return TRUE;
}

BOOL
CArticleCore::fBody(
        char * & pchMappedFile,
		DWORD & dwLength
		)
/*++

Routine Description:

	Returns the body of the article.

Arguments:

	pchMappedFile - Returns the pointer to the article's body
	dwLength - Returns the length of the body.

Return Value:

	TRUE, if successful. FALSE, otherwise.

--*/
{
	// Assert that the body start with a new line.
	_ASSERT(memcmp( m_pcBody.m_pch, "\r\n", 2 ) == 0 );

	//
	// Skip over the new line
	//
	pchMappedFile = (m_pcBody.m_pch + 2);
	dwLength = m_pcBody.m_cch - 2;

	return TRUE;
}


BOOL
CArticleCore::fWholeArticle(
			  HANDLE & hFile,
			  DWORD & dwOffset,
			  DWORD & dwLength
			  )
/*++

Routine Description:

	Returns the whole article of the article.

Arguments:

	hFile - Returns a handle to the file
	dwOffset - Returns the offset to the start of the whole article
	dwLength - Returns the length of the whole article.


Return Value:

	TRUE, if successful. FALSE, otherwise.

--*/
{
	_ASSERT(INVALID_HANDLE_VALUE != m_hFile);
	hFile = m_hFile;
	dwOffset = m_pcGap.m_cch; //m_pcArticle.m_pch - m_pcFile.m_pch;
	dwLength = m_pcArticle.m_cch;
	return TRUE;
}


BOOL
CArticleCore::fFindAndParseList(
				  CField * * rgPFields,
				  DWORD cFields,
				  CNntpReturn & nntpReturn
				  )
/*++

Routine Description:

	Given a list of fields, find the location of the
	field and parses it.

Arguments:

	rgPFields - A list of fields
	cFields - The number of fields in the list.
	nntpReturn - The return value for this function call


Return Value:

	TRUE, if successful. FALSE, otherwise.

--*/
{
	//
	// clear the return code object
	//

	nntpReturn.fSetClear();

	for (DWORD dwFields = 0; dwFields < cFields; dwFields++)
	{
		CField * pField = rgPFields[dwFields];

		//
		// If the find or the parse fails, return a new error message based on the
		// message from fFindAndParse
		//

		if (!pField->fFindAndParse(*this, nntpReturn))
			return nntpReturn.fFalse();
	}

	return nntpReturn.fSetOK();
}

BOOL
CField::fFindAndParse(
						CArticleCore & article,
						CNntpReturn & nntpReturn
						)
/*++

Routine Description:

	Find the location of this field in the article and parse it.

Arguments:

	article - The article being processed.
	nntpReturn - The return value for this function call


Return Value:

	TRUE, if successful. FALSE, otherwise.

--*/
{
	//
	// clear the return code object
	//

	nntpReturn.fSetClear();

	//
	// Check that it is found if it is required.
	//

	if (!fFind(article, nntpReturn))
		return nntpReturn.fFalse();
	
	//
	// If it is optional, just return
	//

	if (m_fieldState == fsNotFound)
		return nntpReturn.fSetOK();

	//
	// Otherwise, parse it
	//

	return fParse(article, nntpReturn);
};


BOOL
CArticleCore::fConfirmCapsList(
				  CField * * rgPFields,
				  DWORD cFields,
				  CNntpReturn & nntpReturn
				  )
/*++

Routine Description:

	Given a list of fields, confirms and
	fixes (if necessary) the capitalization
	of the keywords.

Arguments:

	rgPFields - A list of fields
	cFields - The number of fields in the list.
	nntpReturn - The return value for this function call


Return Value:

	TRUE, if successful. FALSE, otherwise.

--*/
{
	//
	// clear the return code object
	//

	nntpReturn.fSetClear();

	//
	// Loop through each field
	//

	for (DWORD dwFields = 0; dwFields < cFields; dwFields++)
	{
		CField * pField = rgPFields[dwFields];

		if (!pField->fConfirmCaps(nntpReturn))
			return nntpReturn.fFalse();
	}

	return nntpReturn.fSetOK();
}

BOOL
CField::fConfirmCaps(
						CNntpReturn & nntpReturn
						)
/*++

Routine Description:

	confirms and fixes (if necessary) the capitalization
	of the keywords.

Arguments:

	article - The article being processed.
	nntpReturn - The return value for this function call


Return Value:

	TRUE, if successful. FALSE, otherwise.

--*/
{
	//
	// clear the return code object
	//

	nntpReturn.fSetClear();

	//
	// If it is optional, just return
	//

	if (m_fieldState == fsNotFound)
		return nntpReturn.fSetOK();

	//
	// _ASSERT that it was found
	//

	_ASSERT(m_fieldState == fsParsed);

	//
	// Fix the capitalization
	//

	(m_pHeaderString->pcKeyword).vReplace(szKeyword());

	return nntpReturn.fSetOK();
}

#define	HOUR( h )	((h)*60)

typedef	enum	DaylightSavingsModes	{
	tZONE,		/* No daylight savings stuff */
	tDAYZONE,	/* Daylight savings zone */
}	;

typedef	struct	tsnTimezones	{

	LPSTR	lpstrName ;
	int		type ;
	long	offset ;

}	TIMEZONE ;

//	This table taken from INN's parsedate.y
/* Timezone table. */
static TIMEZONE	TimezoneTable[] = {
    { "gmt",	tZONE,     HOUR( 0) },	/* Greenwich Mean */
    { "ut",	tZONE,     HOUR( 0) },	/* Universal */
    { "utc",	tZONE,     HOUR( 0) },	/* Universal Coordinated */
    { "cut",	tZONE,     HOUR( 0) },	/* Coordinated Universal */
    { "z",	tZONE,     HOUR( 0) },	/* Greenwich Mean */
    { "wet",	tZONE,     HOUR( 0) },	/* Western European */
    { "bst",	tDAYZONE,  HOUR( 0) },	/* British Summer */
    { "nst",	tZONE,     HOUR(3)+30 }, /* Newfoundland Standard */
    { "ndt",	tDAYZONE,  HOUR(3)+30 }, /* Newfoundland Daylight */
    { "ast",	tZONE,     HOUR( 4) },	/* Atlantic Standard */
    { "adt",	tDAYZONE,  HOUR( 4) },	/* Atlantic Daylight */
    { "est",	tZONE,     HOUR( 5) },	/* Eastern Standard */
    { "edt",	tDAYZONE,  HOUR( 5) },	/* Eastern Daylight */
    { "cst",	tZONE,     HOUR( 6) },	/* Central Standard */
    { "cdt",	tDAYZONE,  HOUR( 6) },	/* Central Daylight */
    { "mst",	tZONE,     HOUR( 7) },	/* Mountain Standard */
    { "mdt",	tDAYZONE,  HOUR( 7) },	/* Mountain Daylight */
    { "pst",	tZONE,     HOUR( 8) },	/* Pacific Standard */
    { "pdt",	tDAYZONE,  HOUR( 8) },	/* Pacific Daylight */
    { "yst",	tZONE,     HOUR( 9) },	/* Yukon Standard */
    { "ydt",	tDAYZONE,  HOUR( 9) },	/* Yukon Daylight */
    { "akst",	tZONE,     HOUR( 9) },	/* Alaska Standard */
    { "akdt",	tDAYZONE,  HOUR( 9) },	/* Alaska Daylight */
    { "hst",	tZONE,     HOUR(10) },	/* Hawaii Standard */
    { "hast",	tZONE,     HOUR(10) },	/* Hawaii-Aleutian Standard */
    { "hadt",	tDAYZONE,  HOUR(10) },	/* Hawaii-Aleutian Daylight */
    { "ces",	tDAYZONE,  -HOUR(1) },	/* Central European Summer */
    { "cest",	tDAYZONE,  -HOUR(1) },	/* Central European Summer */
    { "mez",	tZONE,     -HOUR(1) },	/* Middle European */
    { "mezt",	tDAYZONE,  -HOUR(1) },	/* Middle European Summer */
    { "cet",	tZONE,     -HOUR(1) },	/* Central European */
    { "met",	tZONE,     -HOUR(1) },	/* Middle European */
    { "eet",	tZONE,     -HOUR(2) },	/* Eastern Europe */
    { "msk",	tZONE,     -HOUR(3) },	/* Moscow Winter */
    { "msd",	tDAYZONE,  -HOUR(3) },	/* Moscow Summer */
    { "wast",	tZONE,     -HOUR(8) },	/* West Australian Standard */
    { "wadt",	tDAYZONE,  -HOUR(8) },	/* West Australian Daylight */
    { "hkt",	tZONE,     -HOUR(8) },	/* Hong Kong */
    { "cct",	tZONE,     -HOUR(8) },	/* China Coast */
    { "jst",	tZONE,     -HOUR(9) },	/* Japan Standard */
    { "kst",	tZONE,     -HOUR(9) },	/* Korean Standard */
    { "kdt",	tZONE,     -HOUR(9) },	/* Korean Daylight */
    { "cast",	tZONE,     -(HOUR(9)+30) }, /* Central Australian Standard */
    { "cadt",	tDAYZONE,  -(HOUR(9)+30) }, /* Central Australian Daylight */
    { "east",	tZONE,     -HOUR(10) },	/* Eastern Australian Standard */
    { "eadt",	tDAYZONE,  -HOUR(10) },	/* Eastern Australian Daylight */
    { "nzst",	tZONE,     -HOUR(12) },	/* New Zealand Standard */
    { "nzdt",	tDAYZONE,  -HOUR(12) },	/* New Zealand Daylight */

};


BOOL
CField::fStrictDateParse(
					   CPCString & pcDate,
					   BOOL fEmptyOK,
						 CNntpReturn & nntpReturn
						 )
/*++

Routine Description:

	Strictly parse a date-style field.

	Here is the grammer:

               Date-content  = [ weekday "," space ] date space time
               weekday       = "Mon" / "Tue" / "Wed" / "Thu"
                             / "Fri" / "Sat" / "Sun"
               date          = day space month space year
               day           = 1*2digit
               month         = "Jan" / "Feb" / "Mar" / "Apr" / "May" / "Jun"
                             / "Jul" / "Aug" / "Sep" / "Oct" / "Nov" / "Dec"
               year          = 4digit / 2digit
               time          = hh ":" mm [ ":" ss ] space timezone
               timezone      = "UT" / "GMT"
                             / ( "+" / "-" ) hh mm [ space "(" zone-name ")" ]
               hh            = 2digit
               mm            = 2digit
               ss            = 2digit
               zone-name     = 1*( <ASCII printable character except ()\> / space )

Arguments:

	pcDate - The string to parse
	fEmptyOK - True, if and only, if empty values are OK
	nntpReturn - The return value for this function call


Return Value:

	TRUE, if successful. FALSE, otherwise.

--*/
{
	//
	// clear the return code object
	//

	nntpReturn.fSetClear();

	if (!fParseSimple(fEmptyOK, pcDate, nntpReturn))
		return nntpReturn.fFalse();

	if (fEmptyOK && (0 == pcDate.m_cch)) //!!!isn't there a pc.fEmpty()?
		return nntpReturn.fSetOK();

	CPCString pc = pcDate;

	if (0 == pc.m_cch)
		return nntpReturn.fSet(nrcArticleFieldDateIllegalValue);
		
	//
	// If it start with an alpha, parse weekday
	//

	if (isalpha((UCHAR)pc.m_pch[0]))
	{
		const int cchMax = 4;
		const int iDaysInAWeek = 7;

		if (cchMax > pc.m_cch)
			return nntpReturn.fSet(nrcArticleFieldDateIllegalValue, szKeyword());

		char * rgszWeekDays[] = {"Mon,", "Tue,", "Wed,", "Thu,", "Fri,", "Sat,", "Sun,"};

		int i;
		for (i = 0; i < iDaysInAWeek; i++)
			if (0== _strnicmp(rgszWeekDays[i], pc.m_pch, cchMax))
				break;
		if (iDaysInAWeek == i)
			return nntpReturn.fSet(nrcArticleFieldDateIllegalValue, szKeyword());
		pc.vSkipStart(cchMax);

		//
		// must be a 'space' of some type after the day of the week.
		//

		if (0 == pc.dwTrimStart(szWSNLChars))
			return nntpReturn.fSet(nrcArticleFieldDateIllegalValue, szKeyword());

	}
	
	if (0 ==  pc.m_cch)
		return nntpReturn.fSet(nrcArticleFieldDateIllegalValue, szKeyword());

	//
	// Check for a day-of-the-month with length 1 or 2
	//

	char	*pchDayOfMonth = pc.m_pch ;
	DWORD dwDayLength = pc.dwTrimStart("0123456789");
	if ((0 == pc.m_cch) || (0 == dwDayLength) || (2 < dwDayLength))
			return nntpReturn.fSet(nrcArticleFieldDateIllegalValue, szKeyword());

	//
	// must be a 'space' of some type after the day and that must not be the end
	//

	if ((0 == pc.dwTrimStart(szWSNLChars)) || (0 ==  pc.m_cch))
		return nntpReturn.fSet(nrcArticleFieldDateIllegalValue, szKeyword());

	const int cchMax = 3;
	const int iMonthsInAYear = 12;

	char * rgszYearMonths[] = {"Jan", "Feb", "Mar", "Apr", "May", "Jun",
							"Jul", "Aug", "Sep", "Oct", "Nov", "Dec"};
	int i;
	for (i = 0; i < iMonthsInAYear; i++)
		if (0== _strnicmp(rgszYearMonths[i], pc.m_pch, cchMax))
			break;
	if (iMonthsInAYear == i)
		return nntpReturn.fSet(nrcArticleFieldDateIllegalValue, szKeyword());
	pc.vSkipStart(cchMax);

	int	DayOfMonth = atoi( pchDayOfMonth ) ;
	int	rgdwDaysOfMonth[] = { 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 } ;
	if( DayOfMonth > rgdwDaysOfMonth[i] ) {
		return nntpReturn.fSet(nrcArticleFieldDateIllegalValue, szKeyword());
	}
	

	//
	// must be a 'space' of some type after the month
	//

	if ((0 == pc.dwTrimStart(szWSNLChars)) || (0 ==  pc.m_cch))
		return nntpReturn.fSet(nrcArticleFieldDateIllegalValue, szKeyword());

	//
	// must have a 4 digit year
	//

	DWORD	cDigits = pc.dwTrimStart("0123456789") ;
	if ((4 != cDigits && 2 != cDigits) || (0 ==  pc.m_cch))//!!contize
		return nntpReturn.fSet(nrcArticleFieldDate4DigitYear, szKeyword());
	
	//
	// must be a 'space' of some type after the year
	//

	if ((0 == pc.dwTrimStart(szWSNLChars)) || (0 ==  pc.m_cch))
		return nntpReturn.fSet(nrcArticleFieldDateIllegalValue, szKeyword());

    //
    // finally parse   time  = hh ":" mm [ ":" ss ] space timezone
    //

	//
	// hh:mm
	//

	if ((2 != pc.dwTrimStart("0123456789"))
			|| (0 ==  pc.m_cch)
			|| (1 != pc.dwTrimStart(":"))
			|| (0 ==  pc.m_cch)
			|| (2 != pc.dwTrimStart("0123456789"))
			|| (0 ==  pc.m_cch)
		)
		return nntpReturn.fSet(nrcArticleFieldDateIllegalValue, szKeyword());

	//
	// Parse optional second
	//

	if (':' == pc.m_pch[0])
	{
		pc.vSkipStart(1); // skip ':'
		if ((0 ==  pc.m_cch)
			|| (2 != pc.dwTrimStart("0123456789"))//!!constize
			|| (0 ==  pc.m_cch)
			)
			return nntpReturn.fSet(nrcArticleFieldDateIllegalValue, szKeyword());
	}

	//
	// must be a 'space' of some type before the year
	//

	if ((0 == pc.dwTrimStart(szWSNLChars)) || (0 ==  pc.m_cch))
		return nntpReturn.fSet(nrcArticleFieldDateIllegalValue, szKeyword());


#if 0
	/*               timezone      = "UT" / "GMT"
                             / ( "+" / "-" ) hh mm [ space "(" zone-name ")" ]
	 */
	const char * szUT = "UT";
	const char * szGMT = "GMT";
	if ((STRLEN(szUT) <= pc.m_cch) && (0==strncmp(szUT, pc.m_pch, STRLEN(szUT))))
	{
		pc.vSkipStart(STRLEN(szUT));
	} else if ((STRLEN(szGMT) <= pc.m_cch) && (0==strncmp(szGMT, pc.m_pch, STRLEN(szUT))))
	{
		pc.vSkipStart(STRLEN(szGMT));
	} else
#endif

	BOOL	fGoodTimeZone = FALSE ;
	long	tzOffset = 0 ;
	for( i=0; i < sizeof( TimezoneTable ) / sizeof( TimezoneTable[0] ); i++ ) {

		if( (DWORD)lstrlen( TimezoneTable[i].lpstrName ) >= pc.m_cch ) {
			if( _strnicmp( pc.m_pch, TimezoneTable[i].lpstrName, pc.m_cch ) == 0 ) {
				fGoodTimeZone = TRUE ;
				tzOffset = TimezoneTable[i].offset ;
				pc.vSkipStart( lstrlen( TimezoneTable[i].lpstrName ) ) ;
				break ;
			}
		}
	}
	if( !fGoodTimeZone ) { //( "+" / "-" ) hh mm [ space "(" zone-name ")" ]
		if ((0 ==  pc.m_cch)
			|| (2 <= pc.dwTrimStart("+-"))
			|| (0 ==  pc.m_cch)
			|| (4 != pc.dwTrimStart("0123456789"))//!!constize
			)
			return nntpReturn.fSet(nrcArticleFieldDateIllegalValue, szKeyword());
		if (0 < pc.m_cch) // must have optional timezone comment
		{

			//
			// Look for " (.*)$"
			//

			if ((0 == pc.dwTrimStart(szWSNLChars))
				|| (0 ==  pc.m_cch)
				|| (1 != pc.dwTrimStart("("))
				|| (1 >=  pc.m_cch)
				|| (')' != (pc.m_pch[pc.m_cch-1]))
				)
			return nntpReturn.fSet(nrcArticleFieldDateIllegalValue, szKeyword());

			for( DWORD i=0; i<pc.m_cch-1; i++ ) {
				if( fCharInSet( pc.m_pch[i], "()\\/>" ) ) {
					return nntpReturn.fSet(nrcArticleFieldDateIllegalValue, szKeyword());
				}
			}


			pc.m_pch = pc.pchMax()-1;
			pc.m_cch = 0;
		}
	}

	//
	// That should be everything
	//

	if (0 !=  pc.m_cch)
		return nntpReturn.fSet(nrcArticleFieldDateIllegalValue, szKeyword());

	return nntpReturn.fSetOK();
}

#define MAX_TIMEUNITS 9

/*
 *   relative date time units
 */

static  char  *rgchTimeUnits[ MAX_TIMEUNITS ] =
{
	"year", "month", "week", "day", "hour", "minute",
	"min", "second", "sec",
};

enum
{
	ExpectNumber,
	ExpectTimeUnit
};

BOOL
CField::fRelativeDateParse(
					   CPCString & pcDate,
						BOOL fEmptyOK,
						CNntpReturn & nntpReturn
						 )
/*++

Routine Description:

	parse a relative date field eg: 5 years 3 months 24 days

	Here is the grammar:

			   Date-content  = token | token {space}+ Date-content
			   token         = number {space}+ time-unit
			   number        = digit | digit number
			   digit		 = 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9
			   time-unit     = "year" / "month" / "week" / "day" / "hour"
							 / "minute" / "min" / "second" / "sec"
							   (plural allowed, any capitalization allowed)

Arguments:

	pcDate - The string to parse
	fEmptyOK - True, if and only, if empty values are OK
	nntpReturn - The return value for this function call


Return Value:

	TRUE, if Date value is a relative date FALSE, otherwise.

--*/
{
	BOOL  fValid = FALSE;
	BOOL  fDone  = FALSE;

	//
	// clear the return code object
	//
	nntpReturn.fSetClear();

	// get the value to parse
	pcDate = m_pHeaderString->pcValue;

	pcDate.dwTrimStart(szWSNLChars);
	pcDate.dwTrimEnd(szWSNLChars);

	if (fEmptyOK && (0 == pcDate.m_cch)) //!!!isn't there a pc.fEmpty()?
		return nntpReturn.fSetOK();

	// make a copy, so original date value is preserved
	CPCString pc = pcDate;

	if (0 == pc.m_cch)
		return nntpReturn.fSet(nrcArticleFieldDateIllegalValue);
		
	DWORD dwNumSize = 0;
	CPCString pcWord;
	DWORD dwState = ExpectNumber;

	// parse the string
	while(pc.m_cch)
	{
		// state toggles between ExpectNumber and ExpectTimeUnit
		switch(dwState)
		{
			case ExpectNumber:

				// skip the number
				dwNumSize = pc.dwTrimStart("0123456789");
				if(0 == dwNumSize)
				{
					// expected number, got junk
					fValid = FALSE;
					fDone  = TRUE;
					break;
				}

				// skipped number, now expect time-unit
				dwState = ExpectTimeUnit;

				break;

			case ExpectTimeUnit:

				// skip word; check if word is a valid time-unit
				pc.vGetWord(pcWord);
				if(	(0 == pcWord.m_cch) ||
					(!pcWord.fExistsInSet(rgchTimeUnits, MAX_TIMEUNITS))
					)
				{
					// expected time-unit, got junk
					fValid = FALSE;
					fDone = TRUE;
					break;
				}

				// seen at least one <number> space <time-unit> sequence
				// now expect a number
				fValid = TRUE;
				dwState = ExpectNumber;

				break;

			default:

				fValid = FALSE;
				fDone  = TRUE;
		};

		// syntax error detected - bail out
		if(fDone) break;

		// skip whitespace between tokens
		pc.dwTrimStart(szWSChars);
	}

	if(fValid)
		return nntpReturn.fSetOK();
	else
		return nntpReturn.fSet(nrcArticleFieldDateIllegalValue, szKeyword());
}


BOOL
CField::fStrictFromParse(
					   CPCString & pcFrom,
					   BOOL fEmptyOK,
						 CNntpReturn & nntpReturn
						 )
/*++

Routine Description:

	Stickly parse a from-style (address-style) field.

  The grammer is:

               From-content  = address [ space "(" paren-phrase ")" ]
                             /  [ plain-phrase space ] "<" address ">"
               paren-phrase  = 1*( paren-char / space / encoded-word )
               paren-char    = <ASCII printable character except ()<>\>
               plain-phrase  = plain-word *( space plain-word )
               plain-word    = unquoted-word / quoted-word / encoded-word
               unquoted-word = 1*unquoted-char
               unquoted-char = <ASCII printable character except !()<>@,;:\".[]>
               quoted-word   = quote 1*( quoted-char / space ) quote
               quote         = <" (ASCII 34)>
               quoted-char   = <ASCII printable character except "()<>\>
               address       = local-part "@" domain
			                     OR JUST local-part
               local-part    = unquoted-word *( "." unquoted-word )
               domain        = unquoted-word *( "." unquoted-word )

Arguments:

	pcFrom - The string to parse
	fEmptyOK - True, if and only, if empty values are OK
	nntpReturn - The return value for this function call


Return Value:

	TRUE, if successful. FALSE, otherwise.

--*/
{
	//
	// clear the return code object
	//

	nntpReturn.fSetClear();

	if (!fParseSimple(fEmptyOK, pcFrom, nntpReturn))
		return nntpReturn.fFalse();

	if (fEmptyOK && (0==pcFrom.m_cch))
		return nntpReturn.fSetOK();

	CPCParse pcFrom2(pcFrom.m_pch, pcFrom.m_cch);

	if (!pcFrom2.fFromContent())
		return nntpReturn.fSet(nrcArticleFieldAddressBad, szKeyword());

	return nntpReturn.fSetOK();
}


BOOL
fTestAComponent(
				const char * szComponent
				)
/*++

Routine Description:

	Test components of a newsgroup name (e.g. "alt" "ms-windows", etc.)
	for illegal values.

	!!!CLIENT LATER might be nice of errors were more specific

Arguments:

	szComponent - The newsgroup component to test.


Return Value:

	TRUE, if successful. FALSE, otherwise.

--*/
{
	const char szSpecial[] = "+-_";

	//
	// If it is empty or starts with one of the special characters,
	// or is the wild card value ("all"), return FALSE
	//

	if ('\0' == szComponent[0]
		|| fCharInSet(szComponent[0], szSpecial)
		|| 0 == lstrcmp("all", szComponent))
		return FALSE;

	//
	// Look at each character (including the first one)
	//

	for (int i = 0; ; i++)
	{


		//
		// If the character is not a..z, 0..9, + - _ return FALSE
		//

		char ch = szComponent[i];
		if ('\0' == ch) break;
		if ((!(ch >= '0' && ch <= '9')) && (!(ch >= 'a' && ch <= 'z')) && 
			(!(ch >= 'A' && ch <= 'Z')) && (!fCharInSet(ch, szSpecial)))
			return FALSE;
	}

	return TRUE;

}


BOOL
fTestANewsgroupComponent(
				const char * szComponent
				)
/*++

Routine Description:

	Test components of a newsgroup name (e.g. "alt" "ms-windows", etc.)
	for illegal values.

	NOTE: We deviate from the RFC to be more INN compatible - we allow
	newsgroups to begin with '+-_'

	!!!CLIENT LATER might be nice of errors were more specific

Arguments:

	szComponent - The newsgroup component to test.


Return Value:

	TRUE, if successful. FALSE, otherwise.

--*/
{
	const char szSpecial[] = "+-_";

	//
	// If it is empty or starts with one of the special characters,
	// or is the wild card value ("all"), return FALSE
	//

	if ('\0' == szComponent[0]
		|| 0 == lstrcmp("all", szComponent))
		return FALSE;

	//
	// Look at each character (including the first one)
	//

	for (int i = 0; ; i++)
	{

		//
		// If the character is not a..z, 0..9, + - _ return FALSE
		//

		char ch = szComponent[i];
		if ('\0' == ch) break;
		if ((!(ch >= '0' && ch <= '9')) && (!(ch >= 'a' && ch <= 'z')) && 
			(!(ch >= 'A' && ch <= 'Z')) && (!fCharInSet(ch, szSpecial)))
			return FALSE;
	}

	return TRUE;

}


BOOL
fTestComponents(
				 const char * szNewsgroups
				)
/*++

Routine Description:

	Test a newsgroup name (e.g. "alt.barney") for illegal values.


Arguments:

	szNewsgroups - The newsgroup name to test.


Return Value:

	TRUE, if successful. FALSE, otherwise.

--*/
{
	CPCString pcNewsgroups((char *)szNewsgroups);
	BOOL fOK = FALSE;
	CNntpReturn nntpReturn;

	if (pcNewsgroups.m_cch-1 > MAX_PATH)
		return FALSE;

	//
	// Split the newsgroup up into its components
	// No matter what, delete the multisz
	//

	fOK = fTestComponentsInternal(szNewsgroups, pcNewsgroups);

	return fOK;
}


BOOL
fTestComponentsInternal(
				 const char * szNewsgroups,
				 CPCString & pcNewsgroups
				)
/*++

Routine Description:

	Does most of the work of testing
	a newsgroup name (e.g. "alt.barney") for illegal values.


Arguments:

	szNewsgroups - The newsgroup name to test.


Return Value:

	TRUE, if successful. FALSE, otherwise.

--*/
{
	DWORD count;
	char multiSz[MAX_PATH + 2];

	//
	// Reject newsgroup names that start or end with "."
	//
	
	if (0 == pcNewsgroups.m_cch
		|| '.' == pcNewsgroups.m_pch[0]
		|| '.' == pcNewsgroups.m_pch[pcNewsgroups.m_cch -1]
		)
		return FALSE;


	// Split the newsgroup name
	pcNewsgroups.vSplitLine(".", multiSz, count);
	if (0 == count)
		return FALSE;

	//
	// Loop through the components
	//

	char const * szComponent = multiSz;
	do
	{
		if (!fTestANewsgroupComponent(szComponent))
			return FALSE;

		//
		// go to first char after next null
		//

		while ('\0' != szComponent[0])
			szComponent++;
		szComponent++;
	} while ('\0' != szComponent[0]);

	return TRUE;

}
	
BOOL
CField::fStrictNewsgroupsParse(
					   BOOL fEmptyOK,
					   char * & multiSzNewsgroups,
					   DWORD & cNewsgroups,
					   CArticleCore & article,
						CNntpReturn & nntpReturn
						 )
/*++

Routine Description:

	Stictly parse a value of the Newsgroups field.

	 Not as strict as it used to be because things like dups and uppers case are
	 now fixed.


Arguments:

	fEmptyOK - True, if and only, if empty values are OK
	multiSzNewsgroups - A list of newsgroups in multsz form.
	cNewsgroups - The number of newsgroups.
	nntpReturn - The return value for this function call

Return Value:

	TRUE, if successful. FALSE, otherwise.

--*/
{
	//
	// clear the return code object
	//

	nntpReturn.fSetClear();


	if (!fParseSplit(fEmptyOK, multiSzNewsgroups, cNewsgroups, " \t\r\n,",
			article, nntpReturn))//!!const
		return nntpReturn.fFalse();

	if (fEmptyOK && 0==cNewsgroups)
		return nntpReturn.fSetOK();

	if (!fMultiSzRemoveDupI(multiSzNewsgroups, cNewsgroups, article.pAllocator()))
		nntpReturn.fSet(nrcMemAllocationFailed, __FILE__, __LINE__);

	//
	// check for illegal characters and substrings in newsgroup name
	//

	char const * szNewsgroup = multiSzNewsgroups;
	do
	{
		if (('\0' == szNewsgroup[0])
			|| !fTestComponents(szNewsgroup)
			)
			return nntpReturn.fSet(nrcArticleFieldIllegalNewsgroup, szNewsgroup, szKeyword());

		//
		// go to first char after next null
		//

		while ('\0' != szNewsgroup[0])
			szNewsgroup++;
		szNewsgroup++;
	} while ('\0' != szNewsgroup[0]);

	return nntpReturn.fSetOK();
}


BOOL
CField::fTestAMessageID(
				 const char * szMessageID,
				 CNntpReturn & nntpReturn
				 )
/*++

Routine Description:

	Check if a message id is of legal form.

Arguments:

	szMessageID - The message id to check.
	nntpReturn - The return value for this function call


Return Value:

	TRUE, if successful. FALSE, otherwise.

--*/
{
	CPCString pcMessageID((char *) szMessageID);

	if (!(
		'<' == pcMessageID.m_pch[0]
		&&	'>' == pcMessageID.m_pch[pcMessageID.m_cch - 1]
		))
		return nntpReturn.fSet(nrcArticleBadMessageID, szMessageID, szKeyword());

	return nntpReturn.fSetOK();
}

BOOL
CArticleCore::fXOver(
				  CPCString & pcBuffer,
				  CNntpReturn & nntpReturn
				  )
/*++

Routine Description:

	Returns XOver information (except for the initial artid)

	format of the Xover data is:

	artid|subject|From|date|messageId|References|bytecount|linecount|Xref:

	where | is \t and linecount and References may be empty.
		Check if a message id is of legal form.

Arguments:

	pcBuffer - A buffer in to which the Xover information should be placed.
	nntpReturn - The return value for this function call


Return Value:

	TRUE, if successful. FALSE, otherwise.

--*/
{
	//
	// clear the return code object
	//

	nntpReturn.fSetClear();


	//
	// Set article state
	//

	_ASSERT((asPreParsed == m_articleState)||(asSaved == m_articleState));//real

	char szDwBuf[12]; // enougth room for any DWORD
	_itoa(m_pcFile.m_cch, szDwBuf, 10);

	char	szNumberBuff[20] ;
	FillMemory( szNumberBuff, sizeof( szNumberBuff ), ' ' ) ;
	CPCString	pcMaxNumber( szNumberBuff, sizeof( szNumberBuff ) ) ;

	CPCString pcXover(pcBuffer.m_pch, 0);
	if (!(
		pcXover.fAppendCheck(pcMaxNumber, pcBuffer.m_cch )
		&& fXOverAppend(pcXover, pcBuffer.m_cch, szKwSubject, TRUE, FALSE, nntpReturn)
		&& fXOverAppend(pcXover, pcBuffer.m_cch, szKwFrom, TRUE, FALSE, nntpReturn)
		&& fXOverAppend(pcXover, pcBuffer.m_cch, szKwDate, TRUE, FALSE, nntpReturn)
		&& fXOverAppend(pcXover, pcBuffer.m_cch, szKwMessageID, TRUE, FALSE, nntpReturn)
		&& fXOverAppendReferences(pcXover, pcBuffer.m_cch, nntpReturn)
		&& fXOverAppendStr(pcXover, pcBuffer.m_cch, szDwBuf, nntpReturn)
		&& fXOverAppend(pcXover, pcBuffer.m_cch, szKwLines, FALSE, FALSE, nntpReturn)
		&& fXOverAppend(pcXover, pcBuffer.m_cch, szKwXref, FALSE, TRUE, nntpReturn)
		))
		return nntpReturn.fFalse();

	//
	// Append a newline
	//
	CPCString	pcNewline( "\r\n", 2 ) ;

	if (!pcXover.fAppendCheck(pcNewline, pcBuffer.m_cch))
		return nntpReturn.fFalse();

	//
	// Record the length of the string in the original buffer
	//

	pcBuffer.m_cch = pcXover.m_cch;

	return nntpReturn.fSetOK();

}

BOOL
CArticleCore::fXOverAppend(
					   CPCString & pc,
					   DWORD cchLast,
					   const char * szKeyword,
			   		   BOOL fRequired,
					   BOOL fIncludeKeyword,
					   CNntpReturn & nntpReturn
				 )
/*++

Routine Description:

	Appends new information to the Xover return buffer. It is very careful
	to return an error is the buffer is not big enough.

Arguments:

	pc - The XOver string so far
	cchLast - The size of the buffer
	szKeyword - The keyword for this data
	fRequired - True, if it there must be data for this keyword
	fIncludeKeyword - True, if the keyword should be included with the XOver return string.
	nntpReturn - The return value for this function call


Return Value:

	TRUE, if successful. FALSE, otherwise.

--*/
{
	//
	// clear the return code object
	//

	nntpReturn.fSetClear();

	HEADERS_STRINGS * pHeaderString;


	//
	// Find the keyword (if not found, is it required?)
	//

	if (!fFindOneAndOnly(szKeyword, pHeaderString, nntpReturn))
	{
		if (nntpReturn.fIs(nrcArticleMissingField) && fRequired)
		{
			return nntpReturn.fFalse();
		} else {
			if (fIncludeKeyword)
			{
				return nntpReturn.fSetOK();
			} else {
				if (!pc.fAppendCheck('\t', cchLast))
					return nntpReturn.fSet(nrcArticleXoverTooBig);
				else
					return nntpReturn.fSetOK();
			}
		}
	}

	//
	// Append Tab
	//

	if (!pc.fAppendCheck('\t', cchLast))
		return nntpReturn.fSet(nrcArticleXoverTooBig);

	//
	// Append Keyword if appropriate
	//

	if (fIncludeKeyword)
	{
		if (!(
			pc.fAppendCheck(pHeaderString->pcKeyword, cchLast)
			&& pc.fAppendCheck(' ', cchLast)
			))
			return nntpReturn.fSet(nrcArticleXoverTooBig);
	}

	CPCString pcNew(pc.pchMax(), (pHeaderString->pcValue).m_cch);

	//
	// Append value
	//

	if (!pc.fAppendCheck(pHeaderString->pcValue, cchLast))
		return nntpReturn.fSet(nrcArticleXoverTooBig);

	//
	// Translate any newline characters or tab to blank
	//

	pcNew.vTr("\n\r\t", ' ');

	return nntpReturn.fSetOK();
}


BOOL
CArticleCore::fXOverAppendReferences(
					   CPCString & pc,
					   DWORD cchLast,
					   CNntpReturn & nntpReturn
				 )
/*++

Routine Description:

	Appends references information to the Xover return buffer.
	It is very careful to return an error is the buffer is not big enough.
	It will shorten the References list if it is too long.

Arguments:

	pc - The XOver string so far
	cchLast - The size of the buffer
	nntpReturn - The return value for this function call


Return Value:

	TRUE, if successful. FALSE, otherwise.

--*/
{
	//
	// clear the return code object
	//

	nntpReturn.fSetClear();

	HEADERS_STRINGS * pHeaderString;

   const char * szKeyword = szKwReferences;

	//
	// Find the keyword (if not found, it is not required)
	//

	if (!fFindOneAndOnly(szKeyword, pHeaderString, nntpReturn))
	{
		if (!pc.fAppendCheck('\t', cchLast))
			return nntpReturn.fSet(nrcArticleXoverTooBig);
		else
			return nntpReturn.fSetOK();
	}

	//
	// Append Tab
	//

	if (!pc.fAppendCheck('\t', cchLast))
		return nntpReturn.fSet(nrcArticleXoverTooBig);


	CPCString pcNew(pc.pchMax(), (pHeaderString->pcValue).m_cch);

	//
	// Append value
	//

	if (pHeaderString->pcValue.m_cch <= MAX_REFERENCES_FIELD)
	{
		if (!pc.fAppendCheck(pHeaderString->pcValue, cchLast))
			return nntpReturn.fSet(nrcArticleXoverTooBig);
	} else {
		// Shorten the References line
		CPCString pcRefList = pHeaderString->pcValue;

		char rgchBuf[MAX_REFERENCES_FIELD];
		CPCString pcNewValue(rgchBuf, 0);

		CPCString pcFirst;

		static	char	sz3spaces[] = "   " ;
		CPCString	pc3spaces( sz3spaces, sizeof( sz3spaces ) ) ;

		// Copy the first references and append 3 spaces as son of 1036
		// recommends
		pcRefList.vGetToken(szWSNLChars, pcFirst);
		if (!(
				pcNewValue.fAppendCheck(pcFirst, MAX_REFERENCES_FIELD)
				&& pcNewValue.fAppendCheck(pc3spaces, MAX_REFERENCES_FIELD)
				))
			return nntpReturn.fSet(nrcArticleXoverTooBig);

		// Skip over the rest of the refs, until the list is short enough
		CPCString pcJunk;
		while (pcRefList.m_cch > (MAX_REFERENCES_FIELD - pcNewValue.m_cch))
			pcRefList.vGetToken(szWSNLChars, pcJunk);

		// pcRefList might have zero length, that's OK
		if (!pcNewValue.fAppendCheck(pcRefList, MAX_REFERENCES_FIELD))
			return nntpReturn.fSet(nrcArticleXoverTooBig);
		
		// Now pcNewValue has the shortened References in it, so copy it
		// to the Xover line

		if (!pc.fAppendCheck(pcNewValue, cchLast))
			return nntpReturn.fSet(nrcArticleXoverTooBig);


	}

	//
	// Translate any newline characters or tab to blank
	//

	pcNew.vTr("\n\r\t", ' ');

	return nntpReturn.fSetOK();
}

BOOL
CArticleCore::fXOverAppendStr(
						  CPCString & pc,
						  DWORD cchLast,
						  char * const sz,
						CNntpReturn & nntpReturn
						 )
/*++

Routine Description:

	Adds Xover information to the XOver return string.

Arguments:

	pc - The Xover return string.
	cchLast - The size of the buffer.
	sz - The information to add.
	nntpReturn - The return value for this function call


Return Value:

	TRUE, if successful. FALSE, otherwise.

--*/
{
	//
	// clear the return code object
	//

	nntpReturn.fSetClear(); // clear the return object

	//
	// Append Tab
	//

	if (!pc.fAppendCheck('\t', cchLast))
		return nntpReturn.fSet(nrcArticleXoverTooBig);

	//
	// Append the string
	//

	CPCString pcAdd(sz);
	if (!pc.fAppendCheck(pcAdd, cchLast))
		return nntpReturn.fSet(nrcArticleXoverTooBig);
	
	return nntpReturn.fSetOK();
}


BOOL
CLinesField::fSet(
				 CArticleCore & article,
				 CNntpReturn & nntpReturn
				 )
/*++

Routine Description:


	If the Line field is missing, adds it.


Arguments:

	article - The article being processed.
	nntpReturn - The return value for this function call


Return Value:

	TRUE, if successful. FALSE, otherwise.

--*/
{
	
	//
	// clear the return code object
	//

	nntpReturn.fSetClear();

	//
	// Check article state
	//
	//
	// If it already exists, then just return
	//

	if (fsParsed == m_fieldState)
		return nntpReturn.fSetOK();

	//
	// If we are asked not to back fill, we don't bother
	// to add the line to the header
	//
	if ( !g_fBackFillLines )
	    return nntpReturn.fSetOK();

	//
	// Otherwise, add it.
	//

	_ASSERT(fsNotFound == m_fieldState);//real
	CPCString pcLine;

	//
	// max size needed is
	//

	const DWORD cchMaxLine =
			STRLEN(szKwLines)	// for the Line keyword
			+ 1					// space following the keyword
			+ 10				// bound on the data string
			+ 2 // for the newline
			+ 1; // for a terminating null

	//
	// Allocate memory for line within a PCString.
	//

	pcLine.m_pch  = article.pAllocator()->Alloc(cchMaxLine);
	if (!pcLine.m_pch)
		return nntpReturn.fSet(nrcMemAllocationFailed, __FILE__, __LINE__);

	//
	// Start with "Line: ", then add an approximation of the number of Line
	// in the body and the newline
	// 
	// KangYan: start with "Lines: ", then add 10 spaces to be back filled
	//

	pcLine << szKwLines << (const CHAR)' ' << (const DWORD)1 << "         \r\n";
	pcLine.vMakeSz(); // terminate the string

	//
	// confirm that we allocated enough memory
	//

	_ASSERT(cchMaxLine-1 >= pcLine.m_cch);//real

	if (!article.fAdd(pcLine.sz(), pcLine.pchMax(), nntpReturn))
	{
		//
		// If anything went wrong, free the memory.
		//

		article.pAllocator()->Free(pcLine.m_pch);
		nntpReturn.fFalse();
	}


	return nntpReturn.fSetOK();
}


BOOL CArticleCore::fGetStream(IStream **ppStream) {
	if (fIsArticleCached()) {
		CStreamMem *pStream = XNEW CStreamMem(m_pcArticle.m_pch,
											 m_pcArticle.m_cch);
		*ppStream = pStream;
	} else {
		BOOL fMappedAlready = (m_pMapFile != NULL);

		// map the article if it isn't already mapped
		if (!fMappedAlready) {
			m_pMapFile = XNEW CMapFile( m_hFile, FALSE, FALSE, 0 );
			if (m_pMapFile == NULL || !m_pMapFile->fGood()) {
				if (m_pMapFile) {
				    XDELETE m_pMapFile;
					m_pMapFile = NULL;
				}
				return FALSE;
			}
		}

		// get the pointer to the article and its size
		DWORD cb;
		char *pch = (char*)m_pMapFile->pvAddress(&cb);

		// build a stream from that
		CStreamMem *pStream = XNEW CStreamMem(pch, cb);
		*ppStream = pStream;
	}

	return (*ppStream != NULL);
}

//
// this function makes it safe to use the fGetHeader() function after
// the article has been closed with vClose().
//
BOOL CArticleCore::fMakeGetHeaderSafeAfterClose(CNntpReturn &nntpReturn) {
	//
	// fGetHeader is always safe after a vClose() if the article is cached,
	// because vClose is a NO-OP for cached articles, and the memory backing
	// the cached article is valid for the lifetime of the CArticleCore
	//
	if (fIsArticleCached()) return TRUE;

	//
	// if the article isn't cached then m_pHeaderBuffer should be NULL
	//
	_ASSERT(m_pHeaderBuffer == NULL);

	//
	// fBuildNewHeader copies the headers to pcHeaderBuf and rewrites
	// the pointers in m_pcHeaders to point to values inside pcHeaderBuf.
	//
	CPCString	pcHeaderBuf ;
	if (!fBuildNewHeader(pcHeaderBuf, nntpReturn)) {
		return nntpReturn.fIsOK();
	}

	//
	// set m_pHeaderBuffer and m_pcHeader to point to the newly created buffer
	//
	// CArticleCore::~CArticleCore will clean up m_pHeaderBuffer if it is set
	//
	m_pHeaderBuffer = pcHeaderBuf.m_pch;
	m_pcHeader.m_pch = m_pHeaderBuffer;
	_ASSERT(m_pcHeader.m_cch == pcHeaderBuf.m_cch);

	return TRUE;
}

BOOL
CArticleCore::ArtCloseHandle(
                HANDLE& hFile
                //LPTS_OPEN_FILE_INFO&    pOpenFile
                )   {
/*++

Routine Description :

    Wrap the call to TsCloseHandle() so we don't have knowledge of
    g_pTsvcInfo everywhere
    We will set the callers handle and pOpenFile to
    INVALID_HANDLE_VALUE and NULL

Arguments :

    hFile - IN/OUT - file handle of file
    pOpenFile - IN/OUT gibraltar caching stuff

Return Value :

    TRUE if successfull, FALSE otherwise

--*/

    BOOL    fSuccess = FALSE ;

    /*if( pOpenFile == 0 ) {*/

        if( hFile != INVALID_HANDLE_VALUE ) {

            fSuccess = CloseHandle( hFile ) ;
            _ASSERT( fSuccess ) ;
            hFile = INVALID_HANDLE_VALUE ;

        }/*
    }   else    {

        fSuccess = ::TsCloseHandle( GetTsvcCache(),
                                    pOpenFile ) ;
        pOpenFile = 0 ;
        hFile = INVALID_HANDLE_VALUE ;

        _ASSERT( fSuccess ) ;

    }*/
    return  fSuccess ;
}

CCacheCreateFile::~CCacheCreateFile()
{
    if ( m_pFIOContext ) ReleaseContext( m_pFIOContext );
    m_pFIOContext = NULL;
}

HANDLE
CCacheCreateFile::CacheCreateCallback(  LPSTR   szFileName,
                                        LPVOID  pv,
                                        PDWORD  pdwSize,
                                        PDWORD  pdwSizeHigh )
/*++
Routine Description:

    Function that gets called on a cache miss.

Arguments:

    LPSTR szFileName - File name
    LPVOID lpvData  - Callback context
    DWORD* pdwSize  - To return file size

Return value:

    File handle
--*/
{
    TraceFunctEnter( "CCacheCreateFile::CreateFileCallback" );
    _ASSERT( szFileName );
    _ASSERT( strlen( szFileName ) <= MAX_PATH );
    _ASSERT( pdwSize );

    HANDLE hFile = CreateFileA(
                    szFileName,
                    GENERIC_READ,
                    FILE_SHARE_READ,
                    0,
                    OPEN_EXISTING,
                    FILE_FLAG_SEQUENTIAL_SCAN |
                    FILE_ATTRIBUTE_READONLY |
                    FILE_FLAG_OVERLAPPED,
                    NULL
                    ) ;
    if( hFile != INVALID_HANDLE_VALUE ) {
        *pdwSize = GetFileSize( hFile, pdwSizeHigh ) ;
    }

    return  hFile ;
}

HANDLE
CCacheCreateFile::CreateFileHandle( LPCSTR szFileName )
/*++
Routine description:

    Create the file for map file.

Arguments:

    LPSTR   szFileName  - The file name to open

Return value:

    File handle
--*/
{
    TraceFunctEnter( "CCacheCreateFile::CreateFileHandle" );
    _ASSERT( szFileName );

    m_pFIOContext = CacheCreateFile(    (LPSTR)szFileName,
                                        CacheCreateCallback,
                                        NULL,
                                        TRUE );
    if ( m_pFIOContext == NULL ) return INVALID_HANDLE_VALUE;
    else return m_pFIOContext->m_hFile;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\nntp\server\article\src\artutil.cpp ===
#include "stdinc.h"

BOOL
ValidateFileBytes(  LPSTR   lpstrFile, BOOL fFileMustExist ) {

#if 0

    //
    //  Check that the file is OK.
    //

    HANDLE  hFile = CreateFile( lpstrFile, GENERIC_READ, FILE_SHARE_READ | FILE_SHARE_WRITE,
                        0, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, INVALID_HANDLE_VALUE ) ;

    if( hFile == INVALID_HANDLE_VALUE ) {
        DWORD   dw = GetLastError() ;
        return  !fFileMustExist ;
    }   else    {

        char    szBuff[5] ;
        DWORD   cbJunk = 0 ;
        ZeroMemory( szBuff, sizeof( szBuff ) ) ;

        SetFilePointer( hFile, -5, 0, FILE_END ) ;
        if( ReadFile( hFile, szBuff, 5, &cbJunk, 0 ) )  {
            if( memcmp( szBuff, "\r\n.\r\n", 5 ) == 0 ) {
                _VERIFY( CloseHandle( hFile ) );
                return  TRUE ;
            }
        }
        _VERIFY( CloseHandle( hFile ) );
    }
    return  FALSE ;
#else
    return  TRUE ;
#endif
}

BOOL
ValidateFileBytes(	HANDLE	hFileIn )		{

	HANDLE	hProcess = GetCurrentProcess() ;
	HANDLE	hFile = INVALID_HANDLE_VALUE ;
	if( !DuplicateHandle( hProcess, hFileIn, hProcess, &hFile, 0, FALSE, DUPLICATE_SAME_ACCESS ) ) {
		DWORD	dw = GetLastError() ;
		return	FALSE ;
	}	else	{
		char	szBuff[5] ;
		DWORD	cbJunk = 0 ;
		ZeroMemory( szBuff, sizeof( szBuff ) ) ;

		SetFilePointer( hFile, -5, 0, FILE_END ) ;
		if( ReadFile( hFile, szBuff, 5, &cbJunk, 0 ) )	{
			if( memcmp( szBuff, "\r\n.\r\n", 5 ) == 0 ) {
				_VERIFY( CloseHandle( hFile ) );
				return	TRUE ;
			}
		}
		DWORD	dw = GetLastError() ;
		_VERIFY( CloseHandle( hFile ) );
	}
	return	FALSE ;
}


BOOL
fMultiSzRemoveDupI(char * multiSz, DWORD & c, CAllocator * pAllocator)
{
    char * * rgsz;
    char * multiSzOut = NULL; // this is only used if necessary
    DWORD k = 0;
    BOOL    fOK = FALSE; // assume the worst
    DWORD   cb = 0 ;


    rgsz = (CHARPTR *) pAllocator->Alloc(sizeof(CHARPTR) * c);
    if (!rgsz)
        return FALSE;

    char * sz = multiSz;

    for (DWORD i = 0; i < c; i++)
    {
        _ASSERT('\0' != sz[0]); // real

        cb = lstrlen( sz ) ;

        // Look for match
        BOOL fMatch = FALSE; // assume
        for (DWORD j = 0; j < k; j++)
        {
            if (0 == _stricmp(sz, rgsz[j]))
            {
                fMatch = TRUE;
                break;
            }
        }

        // Handle match
        if (fMatch)
        {
            // If they are equal and we are not yet
            // using multiSzOut, the start it at 'sz'
            if (!multiSzOut)
                multiSzOut = sz;
        }
        else
        {
            // If the are not equal and we are using multiSzOut
            // then copy sz into multiSzOut;
            if (multiSzOut)
            {
                rgsz[k++] = multiSzOut;
                vStrCopyInc(sz, multiSzOut);
                *multiSzOut++ = '\0'; // add terminating null
            }
            else
            {
                rgsz[k++] = sz;
            }
        }

	    // go to first char after next null
	    //while ('\0' != sz[0])
	    //  sz++;
	    //sz++;
	    sz += cb + 1 ;
    }


    fOK = TRUE;

    pAllocator->Free((char *)rgsz);

    c = k;
    if (multiSzOut)
        multiSzOut[0] = '\0';
    return fOK;
}

///!!!
// Copies the NULL, too
void
vStrCopyInc(char * szIn, char * & szOut)
{
    while (*szIn)
        *szOut++ = *szIn++;
}

BOOL
FValidateMessageId( LPSTR   lpstrMessageId ) {
/*++

Routine Description :

    Check that the string is a legal looking message id.
    Should contain 1 @ sign and at least one none '>' character
    after that '@' sign.

Arguments :

    lpstrMessageId - Message ID to be validated.

Returns

    TRUE if it appears to be legal
    FALSE   otherwise

--*/

    int cb = lstrlen( lpstrMessageId );

    if( lpstrMessageId[0] != '<' || lpstrMessageId[cb-1] != '>' ) {
        return  FALSE ;
    }

    if( lpstrMessageId[1] == '@' )
        return  FALSE ;

    int cAtSigns = 0 ;
    for( int i=1; i<cb-2; i++ ) {
        if( lpstrMessageId[i] == '@' ) {
            cAtSigns++ ;
        }   else if( lpstrMessageId[i] == '<' || lpstrMessageId[i] == '>' ) {
            return  FALSE ;
        }   else if( isspace( (UCHAR)lpstrMessageId[i] ) ) {
            return  FALSE ;
        }
    }
    if( lpstrMessageId[i] == '<' || lpstrMessageId[i] == '>' || cAtSigns != 1 ) {
        return  FALSE ;
    }
    return  TRUE ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\nntp\server\article\src\nntpmacr.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    nntpmacr.h

Abstract:

    This module contains macross for the NNTP server.

Author:

    Johnson Apacible (JohnsonA)     26-Sept-1995

Revision History:

--*/

#ifndef _NNTPMACR_
#define _NNTPMACR_


#define ALLOCATE_HEAP( nBytes ) LocalAlloc( 0, nBytes )
#define FREE_HEAP( _heap )      LocalFree( (PVOID)(_heap) )

//
// try/finally macros
//

#define START_TRY               __try {
#define END_TRY                 }
#define TRY_EXCEPT              } __except(EXCEPTION_EXECUTE_HANDLER) {
#define START_FINALLY           } __finally {

//
// tracing
//

#define INIT_TRACE              InitAsyncTrace( )
#define TERM_TRACE              TermAsyncTrace( )
#define ENTER( _x_ )            TraceFunctEnter( _x_ );
#define LEAVE                   TraceFunctLeave( );

//
// Convert FILETIME TO LIs
//

#define LI_FROM_FILETIME( _pLi, _pFt ) {               \
            (_pLi)->LowPart = (_pFt)->dwLowDateTime;   \
            (_pLi)->HighPart = (_pFt)->dwHighDateTime; \
            }

#define FILETIME_FROM_LI( _pFt, _pLi ) {               \
            (_pFt)->dwLowDateTime = (_pLi)->LowPart;   \
            (_pFt)->dwHighDateTime = (_pLi)->HighPart; \
            }

//
// CRITICAL SECTIONS
//

#define INIT_LOCK( _l )     InitializeCriticalSection( _l )
#define ACQUIRE_LOCK( _l )  EnterCriticalSection( _l )
#define RELEASE_LOCK( _l )  LeaveCriticalSection( _l )
#define DELETE_LOCK( _l )   DeleteCriticalSection( _l )

//
// LockStatistics
//

#define LockStatistics( pInst )						ACQUIRE_LOCK( &pInst->m_StatLock );
#define UnlockStatistics( pInst )					RELEASE_LOCK( &pInst->m_StatLock );
#define IncrementStat( pInst, _x )					((pInst->m_NntpStats). ## _x)++;
#define DecrementStat( pInst, _x )					((pInst->m_NntpStats). ## _x)--;
#define InterlockedIncrementStat( pInst, _x )		InterlockedIncrement((LPLONG)&((pInst->m_NntpStats). ## _x));
#define InterlockedDecrementStat( pInst, _x )		InterlockedDecrement((LPLONG)&((pInst->m_NntpStats). ## _x));
#define InterlockedExchangeAddStat( pInst, _x, _y )	InterlockedExchangeAdd( (PLONG)&((pInst->m_NntpStats). ## _x), (LONG)(_y) )
#define AddByteStat( pInst, _x, _y ) \
        if( (ULONG)InterlockedExchangeAdd( (PLONG)&(((pInst->m_NntpStats). ## _x).LowPart), (LONG)(_y)) \
			> ( ULONG_MAX - (ULONG)(_y) ) ) InterlockedIncrement( (LPLONG)&(((pInst->m_NntpStats). ## _x).HighPart) );

//
// debug constants\macros
//

#define  NNTP_DEBUG_REGISTRY        0x00000004
#define  NNTP_DEBUG_EXPIRE          0x00000008
#define  NNTP_DEBUG_LOCKS           0x00000010
#define  NNTP_DEBUG_ARTMAP          0x00000020
#define  NNTP_DEBUG_HISTORY         0x00000040
#define  NNTP_DEBUG_HEAP            0x00000080
#define  NNTP_DEBUG_HASH            0x00000100
#define  NNTP_DEBUG_SECURITY        0x00000200
#define  NNTP_DEBUG_FEEDMGR         0x00000400
#define  NNTP_DEBUG_FEEDBLOCK       0x00000800

extern DWORD DebugLevel;
#define DO_DEBUG( flag ) \
    if ( DebugLevel & (NNTP_DEBUG_ ## flag) )

//
// on debug build define all inline functions as regular functions.
// copied from msndef.h
//

#if DBG
#define INLINE
#else
#define INLINE      inline
#endif

//
// from extcmk2.h
//

#define fCharInSet(ch, set) (NULL !=strchr(set, ch))
#define STRLEN(sz) (sizeof(sz)-1)
#define	fWhitespace(ch) fCharInSet(ch, szWSChars)
#define	fWhitespaceNull(ch) fCharInSet(ch, szWSNullChars)
#define	fWhitespaceNewLine(ch) fCharInSet(ch, szWSNLChars)
#define	fNewLine(ch) ( ( ch != '\0' ) && fCharInSet(ch, szNLChars) )

#ifndef	Assert
#define Assert _ASSERT
#endif

//
//	Virtual Server scoping macros
//
#define XOVER_TABLE(   pTree )		((pTree->GetVirtualServer())->XoverTable())
#define ARTICLE_TABLE( pTree )		((pTree->GetVirtualServer())->ArticleTable())
#define HISTORY_TABLE( pTree )		((pTree->GetVirtualServer())->HistoryTable())
#define XOVER_CACHE( pTree )		((pTree->GetVirtualServer())->XoverCache())
#define EXPIRE_OBJECT( pTree )		((pTree->GetVirtualServer())->ExpireObject())
#define INST( pS )					((pS->m_context).m_pInstance)

//
//	Delete macros
//
#define DELETE_CHK( ptr )	if( ptr ) { delete ptr ; ptr = NULL ; }

#endif // _NNTPMACR_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\nntp\server\article\src\globals.cpp ===
#include "stdinc.h"

#define DEF_EXPIRE_INTERVAL (3 * SEC_PER_WEEK)
DWORD numField = 0;
DWORD numPCString = 0;
DWORD numDateField = 0;
DWORD numFromPeerArt = 0;
DWORD ArticleTimeLimitSeconds = DEF_EXPIRE_INTERVAL + SEC_PER_WEEK;
DWORD numArticle = 0;
DWORD numPCParse = 0;
DWORD numMapFile = 0;

DEBUG_PRINTS *g_pDebug;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\nntp\server\article\src\mapfile.cpp ===
/* ------------------------------------------------------------------------
  mapfile.cpp
     (was bbmpfile.cpp)
  	A wrapper function to perform the cook book type operations required
  	to map a file into memory.  Maps the whole file, and nothing but the
  	file, so help me God.  Returns a pointer to void;  NULL on error.
  	An error also results in an entry in the event log, unless the error
  	is "file not found" during CreateFile().

  Copyright (C)  1994, 1995  Microsoft Corporation.
  All Rights Reserved.

  Author
  	Lindsay Harris	- lindsayh

   ------------------------------------------------------------------------ */

//#ifndef	UNIT_TEST
//#include "tigris.hxx"
//#else
//#include	<windows.h>
//#include	"mapfile.h"

//#ifndef	_ASSERT
//#define	_ASSERT( f )	if( (f) ) ; else DebugBreak()
//#endif
//#endif

#include "stdinc.h"

/* ------------------------------------------------------------------------
  CMapFile::CMapFile
  	Constructor for unicode mapping.

  Author
  	Lindsay Harris	- lindsayh

  History
	16:11 on Mon 10 Apr 1995    -by-    Lindsay Harris   [lindsayh]
  	First version, to support tracking of objects in exception handling.

   ------------------------------------------------------------------------ */

CMapFile::CMapFile( const WCHAR *pwchFileName, BOOL fWriteEnable, BOOL fTrack )
{

    HANDLE   hFile;				// Ditto.

	// Set default values corresponding to no mapping happened.
    //
	m_pv = NULL;
	m_cb = 0;
	m_fFlags = 0;			// Until later.
#ifndef	UNIT_TEST
    numMapFile++;
#endif

    hFile = CreateFileW( pwchFileName,
                 fWriteEnable ? (GENERIC_READ | GENERIC_WRITE) : GENERIC_READ,
                 FILE_SHARE_READ, NULL, OPEN_EXISTING,
				 FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN, NULL );

    if ( INVALID_HANDLE_VALUE == hFile )
    {
    	//  Only legitimate reason for coming here is non-existent file.
        //
    	if (  GetLastError() != ERROR_FILE_NOT_FOUND
           && GetLastError() != ERROR_PATH_NOT_FOUND )
    	{
			// Error case
            //
			m_pv = NULL;
    	}
        return;				// Default values are failure.
    }
    lstrcpynW( m_rgwchFileName, pwchFileName, MAX_PATH );

	MapFromHandle( hFile, fWriteEnable, 0 );

	BOOL	fClose = CloseHandle( hFile );
	_ASSERT( fClose ) ;

	return;
}


/* ------------------------------------------------------------------------
  CMapFile::CMapFile
  	Constructor for ascii file name version.

  Author
  	Lindsay Harris	- lindsayh

  History:
	16:13 on Mon 10 Apr 1995    -by-    Lindsay Harris   [lindsayh]
  	First version to handle tracking of objects for exception handling.

   ------------------------------------------------------------------------ */

CMapFile::CMapFile( const char *pchFileName, BOOL fWriteEnable, BOOL fTrack, DWORD cbIncrease )
{
    HANDLE   hFile;				// Ditto.

	//    Set default values corresponding to no mapping happened.
	m_pv = NULL;
	m_cb = 0;
	m_fFlags = 0;				// None set yet.
#ifndef	UNIT_TEST
    numMapFile++;
#endif

    hFile = CreateFile( pchFileName,
                 fWriteEnable ? (GENERIC_READ | GENERIC_WRITE) : GENERIC_READ,
                 FILE_SHARE_READ, NULL, OPEN_EXISTING,
				 FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN, NULL );

    if ( INVALID_HANDLE_VALUE == hFile )
    {
    	//  Only legitimate reason for coming here is non-existent file.
        //
    	if (  GetLastError() != ERROR_FILE_NOT_FOUND
		   && GetLastError() != ERROR_PATH_NOT_FOUND )
    	{
			// Error case
            //
			m_pv = NULL;
    	}
        return;
    }

    MultiByteToWideChar( CP_ACP, MB_PRECOMPOSED, pchFileName, -1,
												 m_rgwchFileName, MAX_PATH );

	MapFromHandle( hFile, fWriteEnable, cbIncrease );

	BOOL	fClose = CloseHandle( hFile );
	_ASSERT( fClose ) ;

	return;
}


/* ------------------------------------------------------------------------
  CMapFile::CMapFile.
  	Constructor for ascii file name version.

  Note: Creates file handle if necessary. Does not close file handle.

  Author
  	Lindsay Harris	- lindsayh


  History:
	16:13 on Mon 10 Apr 1995    -by-    Lindsay Harris   [lindsayh]
  	First version to handle tracking of objects for exception handling.

   ------------------------------------------------------------------------ */

CMapFile::CMapFile( const char *pchFileName, HANDLE & hFile, BOOL fWriteEnable, DWORD cbIncrease, CCreateFile *pCreateFile )
{
	// Set default values corresponding to no mapping happened.
    //
	m_pv = NULL;
	m_cb = 0;
	m_fFlags = 0;				// None set yet.
#ifndef	UNIT_TEST
    numMapFile++;
#endif

	if ( INVALID_HANDLE_VALUE == hFile )
	{

	    //
	    // If we are given an interface to create file, we'll use it,
	    // otherwise use the default mechanism to create it
	    //
	    if ( pCreateFile ) {
	        hFile = pCreateFile->CreateFileHandle( pchFileName );
	    } else {
		    hFile = CreateFile( pchFileName,
			            		fWriteEnable ? (GENERIC_READ | GENERIC_WRITE) : GENERIC_READ,
					            FILE_SHARE_READ, NULL, OPEN_EXISTING,
					            FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN, NULL );
		}

		if ( INVALID_HANDLE_VALUE == hFile )
		{
			//  Only legitimate reason for coming here is non-existent file.
            //
			if (  GetLastError() != ERROR_FILE_NOT_FOUND
               && GetLastError() != ERROR_PATH_NOT_FOUND )
			{
				// Error case
                //
				m_pv = NULL;
			}
			return;
		}
	}

    MultiByteToWideChar( CP_ACP, MB_PRECOMPOSED, pchFileName, -1,
												 m_rgwchFileName, MAX_PATH );

	MapFromHandle( hFile, fWriteEnable, cbIncrease );

	return;
}

/* ------------------------------------------------------------------------
  CMapFile::CMapFile
  	Constructor when a file handle is available rather than a name.
	Note that it does not closes the handle

  Author
  	Lindsay Harris	- lindsayh

  History
	16:14 on Mon 10 Apr 1995    -by-    Lindsay Harris   [lindsayh]
  	First version to allow object tracking.  Based on CarlK's function.

   ------------------------------------------------------------------------ */

CMapFile::CMapFile( HANDLE hFile, BOOL fWriteEnable, BOOL fTrack, DWORD cbIncrease, BOOL fZero )
{
	m_pv = NULL;
	m_cb = 0;				// Set defaults.
	m_fFlags = 0;			// None set yet.
#ifndef	UNIT_TEST
    numMapFile++;
#endif
	wcsncpy( m_rgwchFileName, L"<name unavailable - from handle>", MAX_PATH );

	MapFromHandle( hFile, fWriteEnable, cbIncrease, fZero );

	return;
}


/* ------------------------------------------------------------------------
  CMapFile::~CMapFile
  	Destructor.  Two purposes, being to unmap the file, and optionally
  	remove it from the track data.

  Author
  	Lindsay Harris	- lindsayh

  History
	16:22 on Mon 10 Apr 1995    -by-    Lindsay Harris   [lindsayh]
  	Numero Uno.

   ------------------------------------------------------------------------ */

CMapFile::~CMapFile( void )
{
    //
	// Unmap the file, if we succeeded in mapping it first!
	//
#ifndef	UNIT_TEST
    numMapFile--;
#endif

	if ( !(m_fFlags & MF_RELINQUISH) )
	{
		//   We're still controlling this file, so stick with it.
        //
		if ( m_pv )
		{
			UnmapViewOfFile( m_pv );
		}
	}
	return;
}



/* ------------------------------------------------------------------------
  CMapFile::MapFromHandle
  	Does the real work of mapping.  Given a handle to the file, go through
  	the motions of mapping, and recording what happens.  Reports errors
  	as needed.  Also adjusts file size if requested.

  Author
  	Lindsay Harris	- lindsayh
  	Carl Kadie		- carlk

  History
	16:30 on Mon 10 Apr 1995    -by-    Lindsay Harris   [lindsayh]
  	First version, based on older code with CarlK enhancements.

   ------------------------------------------------------------------------ */

void
CMapFile::MapFromHandle( HANDLE hFile, BOOL fWriteEnable, DWORD cbIncrease, BOOL fZero )
{

	if ( !fWriteEnable && cbIncrease != 0 )
		return;				// This is non-sensical.

	m_cb = GetFileSize( hFile, NULL );

	DWORD	cbNewSize = 0;

	//
	// Determine if the file is to grow.  Only pass a non-zero size
	// to the system if the size is growing - it's probably faster, and
	// the most likely common case.
	//
	if ( cbIncrease )
	{
		cbNewSize = m_cb += cbIncrease;
	}
	else
	{
		if ( m_cb == 0 )
			return;				// Nothing there.
	}

#if 1
    if ( cbIncrease )
    {
        _ASSERT(fWriteEnable);

        //
        // Make sure the file is the correct size.
        //
        DWORD fpos;
        BOOL  fSetEnd;
        if ( (DWORD)-1 == ( fpos = SetFilePointer( hFile, cbNewSize, NULL, FILE_BEGIN ))
           || !(fSetEnd = SetEndOfFile( hFile ))
           )
        {
            //
            // Error case
            //
            m_pv = NULL;
            return;
        }
    }
#endif

    //
    // Create the mapping object.
    //
	HANDLE hFileMap;				// Intermediate step.

    hFileMap = CreateFileMapping( hFile, NULL,
                                 fWriteEnable ? PAGE_READWRITE : PAGE_READONLY,
                                 0, cbNewSize, NULL );

    if ( !hFileMap )
    {
		// Error case
        //
		m_pv = NULL;
        return;
    }

    //
    // Get the pointer mapped to the desired file.
    //
    m_pv = MapViewOfFile( hFileMap,
                                 fWriteEnable ? FILE_MAP_WRITE : FILE_MAP_READ,
                                 0, 0, 0 );

	if ( !m_pv )
	{
        // Error case
        //
		m_pv = NULL;
		m_cb = 0;			// Also set to zero, just in case.

	}

	if( fZero && cbIncrease )
	{
		// zero out the part grown
		DWORD cbOldSize = cbNewSize - cbIncrease;
		ZeroMemory( (LPVOID)((LPBYTE)m_pv + cbOldSize), cbNewSize - cbOldSize );
	}

    //
    // Now that we have our pointer, we can close the mapping object.
    //
    BOOL fClose = CloseHandle( hFileMap );
	_ASSERT( fClose );


    return;

}




/* -------------------------------------------------------------------------
  pvMapFile
  	Map a file into memory and return the base address, NULL on failure.

  Author
  	Lindsay Harris	- lindsayh

  History
	14:21 on Mon 20 Feb 1995    -by-    Lindsay Harris   [lindsayh]
  	Amended to use unicode file name.

	10:18 on Tue 29 Nov 1994    -by-    Lindsay Harris   [lindsayh]
  	Made a separately compiled module.

	10:55 on Mon 10 Oct 1994    -by-    Lindsay Harris   [lindsayh]
  	Added FILE_FLAG_SEQUENTIAL_SCAN to speed up directory reading.

	17:38 on Wed 06 Jul 1994    -by-    Lindsay Harris   [lindsayh]
    Make write enable code functional; clean up some old ideas.

    15:35 on Wed 06 Apr 1994    -by-    Lindsay Harris   [lindsayh]
  	Adding this comment, written some time back.

   ------------------------------------------------------------------------- */

void *
pvMapFile( DWORD  *pdwSize, const  WCHAR  *pwchFileName, BOOL bWriteEnable )
{
	//
	// Cook book formula.
	//
    VOID    *pvRet;				// Returned to caller
    HANDLE   hFileMap;			// Used during operations, closed before return
    HANDLE   hFile;				// Ditto.


    hFile = CreateFileW( pwchFileName,
                 bWriteEnable ? (GENERIC_READ | GENERIC_WRITE) : GENERIC_READ,
                 FILE_SHARE_READ, NULL, OPEN_EXISTING,
				 FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN, NULL );

    if ( INVALID_HANDLE_VALUE == hFile )
    {
    	//  Only legitimate reason for coming here is non-existent file.
        //
    	if (  GetLastError() != ERROR_FILE_NOT_FOUND
           && GetLastError() != ERROR_PATH_NOT_FOUND )
    	{
		    // Error case
    	}
        return NULL;
    }

    //
    // If the caller wants to know the size (usually does) then get it now.
    //
    if ( pdwSize )
		*pdwSize = GetFileSize( hFile, NULL );


    //
    // Create the mapping object.
    //
    hFileMap = CreateFileMapping( hFile, NULL,
                                 bWriteEnable ? PAGE_READWRITE : PAGE_READONLY,
                                 0, 0, NULL );

    if ( !hFileMap )
    {
		// Error case
        //
        BOOL fClose = CloseHandle( hFile );           // No handle leaks.
		_ASSERT( fClose ) ;

        return NULL;
    }

    //
    // Get the pointer mapped to the desired file.
    //
    pvRet = MapViewOfFile( hFileMap,
                                 bWriteEnable ? FILE_MAP_WRITE : FILE_MAP_READ,
                                 0, 0, 0 );

	if ( !pvRet )
	{
		// Error case
        //
	}

    //
    // Now that we have our pointer, we can close the file and the
    // mapping object.
    //
    BOOL fClose = CloseHandle( hFileMap );
	_ASSERT( fClose || hFileMap == 0 ) ;
	fClose = CloseHandle( hFile );
	_ASSERT( fClose || hFile == INVALID_HANDLE_VALUE ) ;

    return pvRet;
}

/* -------------------------------------------------------------------------
  pvMapFile
  	Map a file into memory and return the base address, NULL on failure.

  Author
  	Lindsay Harris	- lindsayh

  History
	10:18 on Tue 29 Nov 1994    -by-    Lindsay Harris   [lindsayh]
  	Made a separately compiled module.

	10:55 on Mon 10 Oct 1994    -by-    Lindsay Harris   [lindsayh]
  	Added FILE_FLAG_SEQUENTIAL_SCAN to speed up directory reading.

	17:38 on Wed 06 Jul 1994    -by-    Lindsay Harris   [lindsayh]
    Make write enable code functional; clean up some old ideas.

    15:35 on Wed 06 Apr 1994    -by-    Lindsay Harris   [lindsayh]
  	Adding this comment, written some time back.

   ------------------------------------------------------------------------- */

void *
pvMapFile( DWORD  *pdwSize, const  char  *pchFileName, BOOL bWriteEnable )
{
	//
	// Cook book formula.
	//

    VOID    *pvRet;				/* Returned to caller */
    HANDLE   hFileMap;			// Used during operations, closed before return
    HANDLE   hFile;				// Ditto.


    hFile = CreateFile( pchFileName,
                 bWriteEnable ? (GENERIC_READ | GENERIC_WRITE) : GENERIC_READ,
                 FILE_SHARE_READ, NULL, OPEN_EXISTING,
				 FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN, NULL );

    if ( INVALID_HANDLE_VALUE == hFile )
    {
    	//  Only legitimate reason for coming here is non-existent file.
        //
    	if (  GetLastError() != ERROR_FILE_NOT_FOUND
           && GetLastError() != ERROR_PATH_NOT_FOUND )
    	{
			// Error case
            //
		}
        return NULL;
    }

    //
    // If the caller wants to know the size (usually does) then get it now.
    //
    if ( pdwSize )
		*pdwSize = GetFileSize( hFile, NULL );


    //
    // Create the mapping object.
    //
    hFileMap = CreateFileMapping( hFile, NULL,
                                 bWriteEnable ? PAGE_READWRITE : PAGE_READONLY,
                                 0, 0, NULL );

    if ( !hFileMap )
    {
		// Error case
        //
        BOOL fClose = CloseHandle( hFile );           // No handle leaks.
		_ASSERT( fClose ) ;

        return NULL;
    }

    //
    // Get the pointer mapped to the desired file.
    //
    pvRet = MapViewOfFile( hFileMap,
                                 bWriteEnable ? FILE_MAP_WRITE : FILE_MAP_READ,
                                 0, 0, 0 );

	if ( !pvRet )
	{
		// Error case
        //
	}

    //
    // Now that we have our pointer, we can close the file and the
    // mapping object.
    //
    BOOL fClose = CloseHandle( hFileMap );
	_ASSERT( fClose || hFileMap == 0 ) ;
	fClose = CloseHandle( hFile );
	_ASSERT( fClose || hFile == INVALID_HANDLE_VALUE ) ;

    return  pvRet;

}



/* -------------------------------------------------------------------------
  pvFromHandle
  	Creates a mapped file from an file handle. Does not close that handle.

  History

  	21 Dec 1994 	-by-	Carl Kadie		 [carlk]
	Based on pvMapFile code by Lindsay Harris   [lindsayh]

   ------------------------------------------------------------------------- */

void *
pvFromHandle( HANDLE hFile,
              BOOL bWriteEnable,        // If the file is to be writeable
              DWORD  * pdwSizeFinal,    // If not Null, returns the final size of the file
              DWORD dwSizeIncrease )    // Use 0 if the size is not to increase
{
	DWORD dwSize;
    VOID    *pvRet;				/* Returned to caller */
    HANDLE   hFileMap;


	dwSize = GetFileSize( hFile, NULL ) + dwSizeIncrease;
    if ( pdwSizeFinal )
	{
		*pdwSizeFinal = dwSize;
	}

	// If the ultimate size of the file is 0, then return NULL. The
	// calling program may decide that this is OK.
    //
	if ( !dwSize)
	{
		return NULL;
	}

#if 1
    if ( dwSizeIncrease )
    {
        _ASSERT(bWriteEnable);

        //
        // Make sure the file is the correct size.
        //
        DWORD fpos;
        BOOL  fSetEnd;
        if ( (DWORD)-1 == (fpos = SetFilePointer( hFile, dwSize, NULL, FILE_BEGIN ))
           || !(fSetEnd = SetEndOfFile( hFile ))
           )
        {
            //
            // Error case
            //
            BOOL fClose = CloseHandle( hFile );           // No handle leaks.
            return NULL;
        }
    }
#endif

    //
    // Create the mapping object.
    //
    hFileMap = CreateFileMapping( hFile, NULL,
                                 bWriteEnable ? PAGE_READWRITE : PAGE_READONLY,
                                 0, dwSize, NULL );

    if ( !hFileMap )
    {
		// Error case
        //
        BOOL fClose = CloseHandle( hFile );           // No handle leaks.
        return NULL;
    }

    //
    // Get the pointer mapped to the desired file.
    //
    pvRet = MapViewOfFile( hFileMap,
                                 bWriteEnable ? FILE_MAP_WRITE : FILE_MAP_READ,
                                 0, 0, 0 );

	if ( !pvRet )
	{
		//  Log the error,  but continue, which returns the error.
        //
#if 0
		char	rgchErr[ MAX_PATH + 32 ];
		wsprintf( rgchErr, "MapViewOfFile" );
		LogErrorEvent( MSG_GEN_FAIL, rgchErr, "pvFromHandle" );
#endif
	}

    //
    // Now that we have our pointer, we can close the file and the
    // mapping object.
    //

    BOOL fClose = CloseHandle( hFileMap );
	_ASSERT( fClose ) ;

	return pvRet;
}

/* -------------------------------------------------------------------------
  pvMapFile
  	Map a file into memory and return the base address, NULL on failure.
	Also, allows the file to be grown.

  History

  	11:08 on Tue 18 Oct 1994	-by-	Carl Kadie		 [carlk]
	Generalize pvMapFile to add support for adding to the file

	10:55 on Mon 10 Oct 1994    -by-    Lindsay Harris   [lindsayh]
  	Added FILE_FLAG_SEQUENTIAL_SCAN to speed up directory reading.

	17:38 on Wed 06 Jul 1994    -by-    Lindsay Harris   [lindsayh]
    Make write enable code functional; clean up some old ideas.

    15:35 on Wed 06 Apr 1994    -by-    Lindsay Harris   [lindsayh]
  	Adding this comment, written some time back.

   ------------------------------------------------------------------------- */

void *
pvMapFile(	const char  * pchFileName,		// The name of the file
			BOOL bWriteEnable,		// If the file is to be writeable
 			DWORD  * pdwSizeFinal, // If not Null, returns the final size of the file
			DWORD dwSizeIncrease )     // Use 0 if the size is not to increase
{
	//
	// Cook book formula.
	//
    HANDLE   hFile;
    VOID    *pvRet;				/* Returned to caller */

	// If the file is to grow, it only makes sense to open it read/write.
    //
	if (0 != dwSizeIncrease && !bWriteEnable)
	{
		return NULL;
	}

    hFile = CreateFile( pchFileName,
                 bWriteEnable ? (GENERIC_READ | GENERIC_WRITE) : GENERIC_READ,
                 FILE_SHARE_READ, NULL, OPEN_ALWAYS,  //changed from open_existing
				 FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN, NULL );

    if ( INVALID_HANDLE_VALUE == hFile )
    {
        return  NULL;
    }

    //
    // If the caller wants to know the size (usually does) then get it now.
    //
	pvRet = pvFromHandle(hFile, bWriteEnable, pdwSizeFinal, dwSizeIncrease);

	BOOL fClose = CloseHandle( hFile );
	_ASSERT( fClose ) ;

    return  pvRet;
}

#ifdef DEBUG
//
//	CMapFileEx: version with guard pages to be used only in DEBUG builds
//	to catch other threads writing into our memory !
//

/* ------------------------------------------------------------------------
  CMapFileEx::CMapFileEx
  	Constructor when a file handle is available rather than a name.
	Note that it does not closes the handle

  Author
  	Lindsay Harris	- lindsayh

  History
	16:14 on Mon 10 Apr 1995    -by-    Lindsay Harris   [lindsayh]
  	First version to allow object tracking.  Based on CarlK's function.

   ------------------------------------------------------------------------ */

CMapFileEx::CMapFileEx( HANDLE hFile, BOOL fWriteEnable, BOOL fTrack, DWORD cbIncrease )
{
	m_pv = NULL;
	m_cb = 0;				// Set defaults.
	m_fFlags = 0;			// None set yet.
	m_hFile = INVALID_HANDLE_VALUE;
	m_pvFrontGuard = NULL;
	m_cbFrontGuardSize = 0;
	m_pvRearGuard = NULL;
	m_cbRearGuardSize = 0;
	InitializeCriticalSection(&m_csProtectMap);

	wcsncpy( m_rgwchFileName, L"<name unavailable - from handle>", MAX_PATH );

	MapFromHandle( hFile, fWriteEnable, cbIncrease );

	m_hFile = hFile;

	return;
}


/* ------------------------------------------------------------------------
  CMapFileEx::~CMapFileEx
  	Destructor.  Two purposes, being to unmap the file, and optionally
  	remove it from the track data.

  Author
  	Lindsay Harris	- lindsayh

  History
	16:22 on Mon 10 Apr 1995    -by-    Lindsay Harris   [lindsayh]
  	Numero Uno.

   ------------------------------------------------------------------------ */

CMapFileEx::~CMapFileEx( void )
{
    //
	// Unmap the file, if we succeeded in mapping it first!
	//

	//   Lock
	EnterCriticalSection(&m_csProtectMap);

	if ( !(m_fFlags & MF_RELINQUISH) )
	{
		//   We're still controlling this file, so stick with it.
        //
		if ( m_pvFrontGuard )
		{
			_ASSERT( m_pvFrontGuard && m_pv && m_pvRearGuard );
			_ASSERT( m_cbFrontGuardSize && m_cb && m_cbRearGuardSize );

			// get rid of guard pages
			DWORD dwOldProtect = PAGE_READONLY | PAGE_GUARD;
			if(!VirtualProtect(
						(LPVOID)m_pvFrontGuard,
						m_cbFrontGuardSize,
						PAGE_READWRITE,
						&dwOldProtect
						))
			{
				_ASSERT( 1==0 );
				goto CMapFileEx_Exit ;
			}

			if(!VirtualProtect(
						(LPVOID)m_pv,
						m_cb,
						PAGE_READWRITE,
						&dwOldProtect
						))
			{
				_ASSERT( 1==0 );
				goto CMapFileEx_Exit ;
			}

			if(!VirtualProtect(
						(LPVOID)m_pvRearGuard,
						m_cbRearGuardSize,
						PAGE_READWRITE,
						&dwOldProtect
						))
			{
				_ASSERT( 1== 0 );
				goto CMapFileEx_Exit ;
			}

			MoveMemory( m_pvFrontGuard, m_pv, m_cb );

			FlushViewOfFile( m_pvFrontGuard, m_cb ) ;

			UnmapViewOfFile( (LPVOID)m_pvFrontGuard );

			if( INVALID_HANDLE_VALUE != m_hFile )
			{
				if( SetFilePointer( m_hFile, m_cb, NULL, FILE_BEGIN ) == m_cb )
				{
					SetEndOfFile( m_hFile ) ;
				}
			}

			m_pvFrontGuard = m_pvRearGuard = m_pv = NULL ;
			m_cbFrontGuardSize = m_cb = m_cbRearGuardSize = 0;
		}
	}

CMapFileEx_Exit:

	LeaveCriticalSection(&m_csProtectMap);

	DeleteCriticalSection(&m_csProtectMap);

	return;
}



/* ------------------------------------------------------------------------
  CMapFileEx::MapFromHandle
  	Does the real work of mapping.  Given a handle to the file, go through
  	the motions of mapping, and recording what happens.  Reports errors
  	as needed.  Also adjusts file size if requested.

  Author
  	Lindsay Harris	- lindsayh
  	Carl Kadie		- carlk

  History
	16:30 on Mon 10 Apr 1995    -by-    Lindsay Harris   [lindsayh]
  	First version, based on older code with CarlK enhancements.

   ------------------------------------------------------------------------ */

void
CMapFileEx::MapFromHandle( HANDLE hFile, BOOL fWriteEnable, DWORD cbIncrease )
{
	BOOL fErr = FALSE;

	if ( !fWriteEnable && cbIncrease != 0 )
		return;				// This is non-sensical.

	m_cb = GetFileSize( hFile, NULL );

	DWORD	cbNewSize = 0;
	DWORD	cbOldSize = 0;

	//
	// Determine if the file is to grow.  Only pass a non-zero size
	// to the system if the size is growing - it's probably faster, and
	// the most likely common case.
	//
	if ( cbIncrease )
	{
		cbNewSize = m_cb += cbIncrease;
	}
	else
	{
		if ( m_cb == 0 )
			return;				// Nothing there.

		// In the guard page version we always grow the file by 2*GuardPageSize !
		cbNewSize = m_cb;
	}

	//
	// Add guard page logic
	//
	SYSTEM_INFO si;
	GetSystemInfo(&si);
	DWORD dwPageSize = si.dwPageSize ;
	DWORD dwGuardPageSize = si.dwAllocationGranularity;

	// GuardPageSize should be > cbNewSize
	while( cbNewSize > dwGuardPageSize )
	{
		dwGuardPageSize += si.dwAllocationGranularity;
	}

	// cbNewSize should be a multiple of dwPageSize, to ensure rear guard page is properly aligned
	_ASSERT( (cbNewSize % dwPageSize) == 0 ) ;

	DWORD cbAllocSize = (2 * (dwGuardPageSize)) + cbNewSize;
	DWORD dwOldProtect = PAGE_READWRITE ;
	DWORD dwError;

	//
	//	Grow the file to match the size of memory mapping
	//

    if ( cbIncrease || cbAllocSize )
    {
        _ASSERT(fWriteEnable);

        //
        // Make sure the file is the correct size.
        //
        DWORD fpos;
        BOOL  fSetEnd;
        if ( (DWORD)-1 == ( fpos = SetFilePointer( hFile, cbAllocSize, NULL, FILE_BEGIN ))
           || !(fSetEnd = SetEndOfFile( hFile ))
           )
        {
            //
            // Error case
            //
            m_pv = NULL;
            return;
        }
    }

    //
    // Create the mapping object.
    //
	HANDLE hFileMap;				// Intermediate step.

    hFileMap = CreateFileMapping(
							hFile,
							NULL,
                            fWriteEnable ? PAGE_READWRITE : PAGE_READONLY,
                            0,
							cbAllocSize,	// NOTE: this is greater than cbNewSize by 2*GuardPageSize
							NULL
							);

    if ( !hFileMap )
    {
		// Error case
        //
		m_pv = NULL;
		m_cb = 0;
        return;
    }

    //
    // Get the pointer mapped to the desired file.
    //
    m_pvFrontGuard = (LPBYTE)MapViewOfFile(
									hFileMap,
									fWriteEnable ? FILE_MAP_WRITE : FILE_MAP_READ,
									0, 0, 0
									);

	if ( !m_pvFrontGuard )
	{
		//
        // Error case
        //
		fErr = TRUE;
		goto MapFromHandle_Exit;
	}

	// zero out the part grown
	cbOldSize = cbNewSize - cbIncrease;
	ZeroMemory( m_pvFrontGuard + cbOldSize, cbAllocSize - cbOldSize );

	// front guard page of size (64KB)
	m_cbFrontGuardSize = dwGuardPageSize ;

	// actual memory-mapping
	m_pv = m_pvFrontGuard + m_cbFrontGuardSize ;
	MoveMemory( m_pv, m_pvFrontGuard, cbNewSize );

	// rear guard page of size (64KB)
	m_pvRearGuard  = m_pv + cbNewSize ;
	m_cbRearGuardSize = m_cbFrontGuardSize ;

	// zero out the front and rear guard pages
	ZeroMemory( m_pvFrontGuard, m_cbFrontGuardSize );
	ZeroMemory( m_pvRearGuard,  m_cbRearGuardSize );

	// make front page a guard page
	if(!VirtualProtect(
				(LPVOID)m_pvFrontGuard,
				m_cbFrontGuardSize,
				PAGE_READONLY | PAGE_GUARD,
				&dwOldProtect
				))
	{
		Cleanup();
		fErr = TRUE;
		goto MapFromHandle_Exit ;
	}

	// make mapping read-only; users of CMapFileEx will need to use the
	// UnprotectMapping() / ProtectMapping() calls to write to this mapping.
	if(!VirtualProtect(
				(LPVOID)m_pv,
				cbNewSize,
				PAGE_READONLY,
				&dwOldProtect
				))
	{
		Cleanup();
		fErr = TRUE;
		goto MapFromHandle_Exit ;
	}

	// make rear page a guard page
	if(!VirtualProtect(
				(LPVOID)m_pvRearGuard,
				m_cbRearGuardSize,
				PAGE_READONLY | PAGE_GUARD,
				&dwOldProtect
				))
	{
		Cleanup();
		fErr = TRUE;
		goto MapFromHandle_Exit ;
	}


MapFromHandle_Exit:

	dwError = GetLastError();

    //
    // Now that we have our pointer, we can close the mapping object.
    //
    BOOL fClose = CloseHandle( hFileMap );
	_ASSERT( fClose );

	// reset all member vars in error cases
	if( fErr )
	{
		m_pvFrontGuard = m_pvRearGuard = m_pv = NULL;
		m_cbFrontGuardSize = m_cbRearGuardSize = m_cb = 0;
		m_hFile = INVALID_HANDLE_VALUE;
	}

    return;
}

/* ------------------------------------------------------------------------
  CMapFileEx::UnprotectMapping

	Change mapping from READONLY to READWRITE when a write is necessary
	**** NOTE: Calls to UnprotectMapping() and ProtectMapping() should be matched ***
	eg:
		{
			UnprotectMapping();

			//
			//	 code to write to the mapping
			//

			ProtectMapping();
		}

	Returns TRUE on success, FALSE on failure
	Lock is held only if returns TRUE

   ------------------------------------------------------------------------ */

BOOL
CMapFileEx::UnprotectMapping()
{
	DWORD dwOldProtect = PAGE_READONLY;

	// *** This is released in ProtectMapping() ***
	EnterCriticalSection(&m_csProtectMap);

	// enable writes
	if(!VirtualProtect(
				(LPVOID)m_pv,
				m_cb,
				PAGE_READWRITE,
				&dwOldProtect
				))
	{
		LeaveCriticalSection(&m_csProtectMap);
		return FALSE;
	}

	return TRUE;
}

/* ------------------------------------------------------------------------
  CMapFileEx::UnprotectMapping

	This is called to revert the mapping protection back to READONLY
	**** The thread calling this function should have the protect lock *****

	Returns TRUE on success, FALSE on failure
	Lock is released in either case

   ------------------------------------------------------------------------ */

BOOL
CMapFileEx::ProtectMapping()
{
	DWORD dwOldProtect = PAGE_READWRITE;
	BOOL  fRet = TRUE;

	// disable writes
	if(!VirtualProtect(
				(LPVOID)m_pv,
				m_cb,
				PAGE_READONLY,
				&dwOldProtect
				))
	{
		fRet = FALSE ;
	}

	LeaveCriticalSection(&m_csProtectMap);
	return fRet;
}

/* ------------------------------------------------------------------------
  CMapFileEx::Cleanup
  	Called when MapFromHandle fails - Does the necessary VirtualProtects
	to revert guard pages back and unmap view of file.

  Author
  	Lindsay Harris	- lindsayh

  History
	16:22 on Mon 10 Apr 1995    -by-    Lindsay Harris   [lindsayh]
  	Numero Uno.

   ------------------------------------------------------------------------ */

void
CMapFileEx::Cleanup( void )
{
	_ASSERT( m_pvFrontGuard && m_pv && m_pvRearGuard );
	_ASSERT( m_cbFrontGuardSize && m_cb && m_cbRearGuardSize );

	//
	// get rid of guard pages - make everything PAGE_READWRITE !
	//
	DWORD dwOldProtect = PAGE_READONLY | PAGE_GUARD;
	VirtualProtect( (LPVOID)m_pvFrontGuard, m_cbFrontGuardSize, PAGE_READWRITE, &dwOldProtect);
	VirtualProtect( (LPVOID)m_pv, m_cb, PAGE_READWRITE, &dwOldProtect);
	VirtualProtect( (LPVOID)m_pvRearGuard, m_cbRearGuardSize, PAGE_READWRITE, &dwOldProtect);

	// move data back
	MoveMemory( m_pvFrontGuard, m_pv, m_cb );

	// flush and unmap !
	FlushViewOfFile( m_pvFrontGuard, m_cb ) ;
	UnmapViewOfFile( (LPVOID)m_pvFrontGuard );

	if( INVALID_HANDLE_VALUE != m_hFile )
	{
		if( SetFilePointer( m_hFile, m_cb, NULL, FILE_BEGIN ) == m_cb )
		{
			SetEndOfFile( m_hFile ) ;
		}
	}

	m_pvFrontGuard = m_pvRearGuard = m_pv = NULL ;
	m_cbFrontGuardSize = m_cb = m_cbRearGuardSize = 0;

	return;
}

#endif // DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\nntp\server\article\src\nntpret.cpp ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    nntpret.cpp

Abstract:

    This module implements an object from returning return codes
	and objects.

Author:

    Carl Kadie (CarlK)     16-Oct-1995

Revision History:

--*/

//#include "tigris.hxx"
#include  <stdlib.h>
#include "stdinc.h"
#include <stdio.h>

BOOL
ResultCode(
		   char*	szCode,
		   NRC&	nrcOut
		   )
/*++

Routine Description:

	Turns a return code expressed as a string of ascii numerals into
	a number.

Arguments:

	szCode - The return code string.
	nrcOut - The return code as a number.


Return Value:

	TRUE, if successful. FALSE, otherwise.

--*/
{
	nrcOut = nrcNotSet ;

	if( isdigit( (UCHAR)szCode[0] ) &&
		isdigit( (UCHAR)szCode[1] ) &&
		isdigit( (UCHAR)szCode[2] ) &&
		szCode[3] == '\0' )	{
		nrcOut = (NRC)atoi( szCode ) ;
		return	TRUE ;
	}
	return	FALSE ;
}


BOOL
CNntpReturn::fSetOK(
	   void
	   )
/*++

Routine Description:

	Efficently sets the return code object to be "OK".


Arguments:

	None.

Return Value:

	Always TRUE

--*/
{
  m_nrc = nrcOK;
  m_sz = szOK;
  return TRUE;
}


BOOL
CNntpReturn::fSetClear(
	   void
	   )
/*++

Routine Description:

	Efficently sets the return code object to be undefined.


Arguments:

	None.

Return Value:

	Always TRUE

--*/
{
  m_nrc = nrcNotSet;
  m_sz = szNotSet;
  return TRUE;
}


BOOL
CNntpReturn::fSet(
				  NRC nrc,
				  ...
				  )
/*++

Routine Description:

	Sets the return code object.

	 Returns TRUE if the the nrc is nrcOK, otherwise returns
	 false. The idea is that this return value can be returned by
	 the calling function.


Arguments:

	nrc - The numeric return code.
	... -  Arguments to the error message


Return Value:

	TRUE, if nrc is nrcOK. FALSE, otherwise.

--*/
{

	if (nrcOK == nrc)
		return fSetOK();

	char const * szFormat;
	BOOL fHasFormatCodes;
	m_nrc = nrc;

	vSzFormat(szFormat, fHasFormatCodes);

	va_list arglist;

    va_start(arglist, nrc);

	//
	// there is a short circuit here for the common case... if there are
	// no formatting codes in the return string then we don't need to
	// run it through _vsnprintf, so we'll skip that.
	//
	if (fHasFormatCodes) {
		_vsnprintf(m_szBuf, maxCchNntpLine, szFormat, arglist);
		m_szBuf[maxCchNntpLine-1] = '\0';
		m_sz = m_szBuf;
	} else {
		m_sz = szFormat;
	}

    va_end(arglist);

	return FALSE;
}

//
// this is just like fSet, except for we defer the call into _vsnprintf.
// this version is only designed to be used with format strings which have
// one %s item in them, and which can guarantee that the argument is
// a static literal.
//
BOOL
CNntpReturn::fSetEx(NRC nrc,
					char const *szArg)
{
	if (nrcOK == nrc)
		return fSetOK();

#ifdef DEBUG
	if (!IsDebuggerPresent()) {
		// make sure that we can't write to the memory... static literals should
		// be read only
		//
		// we only do this if the debugger isn't attached so that it doesn't
		// cause the debugger to stop in every call to IsBadWritePtr.
		_ASSERT(IsBadWritePtr((void *) szArg, 1));
	}

	// make sure that its not on the stack
	DWORD blah;
	DWORD_PTR addrBlah = (DWORD_PTR) &blah, addrArg = (DWORD_PTR) szArg;

	// make sure that szArg isn't within +/- 4k of the stack variable blah
	_ASSERT(addrArg < (addrBlah - 4096) || addrArg > (addrBlah + 4096));
#endif

	m_nrc = nrc;
	m_szArg = szArg;
	m_sz = NULL;
	return FALSE;
}

const char *
CNntpReturn::szReturn() {
	if (m_sz == NULL) {
		// we are in lazy evaluation mode...we need to fill in m_sz now
		_ASSERT(m_szArg != NULL);
		char const * szFormat;
		BOOL fHasFormatCodes;

		vSzFormat(szFormat, fHasFormatCodes);
		_ASSERT(fHasFormatCodes);

		_snprintf(m_szBuf, maxCchNntpLine, szFormat, (char *) m_szArg);
		m_szBuf[maxCchNntpLine-1] = '\0';
		m_sz = m_szBuf;
	}
	return m_sz;
}

void
CNntpReturn::vSzFormat(
					   char const * & szFormat,
					   BOOL &fHasFormatCodes
					   )
/*++

Routine Description:

	Returns the string used to format the message.

Arguments:

	szFormat - the string returned.


Return Value:

	None.

--*/
{
	fHasFormatCodes = FALSE;
	switch (m_nrc)
	{
		case nrcServerReady :
			szFormat = "Good Enough" ;
			break ;
		case nrcServerReadyNoPosts :
			szFormat = "Posting Not Allowed" ;
			break ;
		case nrcSlaveStatusNoted :
			szFormat = "Unsupported" ;
			break ;
		case nrcModeStreamSupported :
			szFormat = "Mode Stream Supported" ;
			break ;
		case nrcXoverFollows :
			szFormat = "data follows \r\n." ;
			break ;
		case nrcNewnewsFollows :
			szFormat = "Newnews follows" ;
			break ;
        case nrcSNotAccepting :
            szFormat = "Not Accepting Articles " ;
            break ;
		case	nrcNoSuchGroup :
			szFormat = "no such newsgroup" ;
			break ;
		case	nrcNoGroupSelected :
			szFormat = "no Newsgroup has been selected" ;
			break ;
		case	nrcNoCurArticle :
			szFormat = "no current article has been selected" ;
			break ;
		case	nrcNoNextArticle :
			szFormat = "no next article" ;
			break ;
		case	nrcSTransferredOK:
			szFormat = "article successfully transferred";
			break ;
		case	nrcNoPrevArticle :
			szFormat = "no prev article" ;
			break ;
		case	nrcNoArticleNumber :
			szFormat = "no such article number in group" ;
			break ;
		case	nrcNoSuchArticle :
			szFormat = "no such article found" ;
			break ;
		case	nrcNotWanted :
			szFormat = "article not wanted" ;
			break ;
		case	nrcArticleTransferredOK :
			szFormat = "Article Transferred OK";
			break;
		case	nrcArticlePostedOK :
			szFormat = "Article Posted OK";
			break;
		case nrcOK:
			szFormat = szOK;
			break;
		case nrcPostFailed:
			szFormat = "(%d) Article Rejected -- %s";
			fHasFormatCodes = TRUE;
			break;
		case nrcNoMatchesFound:
			szFormat = "No Matches Found";
			break;
		case nrcErrorPerformingSearch:
			szFormat = "Error Performing Search";
			break;
		case nrcPostModeratedFailed:
			szFormat = "Failed to mail Article to %s";
			fHasFormatCodes = TRUE;
			break;
		case nrcLogonRequired:
			szFormat = "Logon Required" ;
			break;
        case nrcNoListgroupSelected:
            szFormat = "No group specified" ;
            break ;
		case nrcTransferFailedTryAgain:
			szFormat = "(%d) Transfer Failed - Try Again -- %s";
			fHasFormatCodes = TRUE;
			break;
		case nrcTransferFailedGiveUp:
			szFormat = "(%d) Transfer Failed - Do Not Try Again -- %s";
			fHasFormatCodes = TRUE;
			break;
		case nrcSAlreadyHaveIt :
			szFormat = "%s" ;
			fHasFormatCodes = TRUE;
			break ;
		case nrcSArticleRejected :
			szFormat = "(%d) Transfer Failed - Do Not Try Again -- %s";
			fHasFormatCodes = TRUE;
			break ;
		case nrcPostingNotAllowed :
			szFormat = "No Posting" ;
			break ;
		case	nrcNotRecognized :
			szFormat = "Command Not Recognized" ;
			break ;
		case	nrcSyntaxError :
			szFormat = "Syntax Error in Command" ;
			break ;
		case	nrcNoAccess :
			szFormat = "Access Denied."	;
			break ;
		case	nrcServerFault :
			szFormat = "Server Failure." ;
			break ;
		case nrcArticleIncompleteHeader:
			szFormat = "Header is incomplete";
			break;
		case nrcArticleMissingHeader:
			szFormat = "Header is missing";
			break;
		case nrcArticleTooManyFieldOccurances:
			szFormat = "Multiple '%s' fields";
			fHasFormatCodes = TRUE;
			break;
		case nrcArticleMissingField:
			szFormat = "Missing '%s' field";
			fHasFormatCodes = TRUE;
			break;
		case nrcArticleBadField:
			szFormat = "Bad '%s' field";
			fHasFormatCodes = TRUE;
			break;
		case nrcArticleFieldZeroValues:
			szFormat = "The '%s' field requires one or more values";
			fHasFormatCodes = TRUE;
			break;
		case nrcArticleFieldMessIdNeedsBrack:
			szFormat = "The message id must start with '<' and end with '>'";
			break;
		case nrcArticleFieldMissingValue:
			szFormat = "The '%s' field is empty";
			fHasFormatCodes = TRUE;
			break;
		case nrcArticleFieldIllegalNewsgroup:
			szFormat = "Illegal newsgroup '%s' in '%s' field";
			fHasFormatCodes = TRUE;
			break;
		case nrcArticleTooManyFields:
			szFormat = "Too many fields in article header (limit is %d)";
			fHasFormatCodes = TRUE;
			break;
		case nrcMemAllocationFailed:
#ifdef DEBUG
			szFormat = "Memory Allocation Failed (File %s, Line %d)";
			fHasFormatCodes = TRUE;
#else
			szFormat = "Memory Allocation Failed";
			fHasFormatCodes = FALSE;
#endif
			break;
		case nrcArticleFieldMessIdTooLong:
			szFormat = "Message ID had length %d. The longest supported is %d";
			fHasFormatCodes = TRUE;
			break;
		case nrcErrorReadingReg:
			szFormat = "Can't read registry value '%s' from key '%s'";
			fHasFormatCodes = TRUE;
			break;
		case nrcArticleDupMessID:
			szFormat = "Duplicate Message-ID %s (GLE=%d)";
			fHasFormatCodes = TRUE;
			break;
		case nrcArticleMappingFailed:
			szFormat = "Mapping of file %s failed. LastError is %d";
			fHasFormatCodes = TRUE;
			break;
		case nrcArticleAddLineBadEnding:
			szFormat = "Line should end with newline character (%s)";
			fHasFormatCodes = TRUE;
			break;
		case nrcPathLoop:
			szFormat = "This hub (%s) found in path.";
			fHasFormatCodes = TRUE;
			break;
		case nrcArticleInitFailed:
			szFormat = "Initialization of article failed.";
			break;
		case nrcNewsgroupInsertFailed:
			szFormat = "Insertion into group %s of article %s failed.";
			fHasFormatCodes = TRUE;
			break;
		case nrcNewsgroupAddRefToFailed:
			szFormat = "Adding xref to group %s for article %s failed.";
			fHasFormatCodes = TRUE;
			break;
		case nrcHashSetArtNumSetFailed:
			szFormat = "Can't set IDs to %d/%d for article %s in Article Table. (GLE=%d)";
			fHasFormatCodes = TRUE;
			break;
		case nrcHashSetXrefFailed:
			szFormat = "Can't add xrefs to article %s in Article Table. (GLE=%d)";
			fHasFormatCodes = TRUE;
			break;
		case nrcOpenFile:
			szFormat = "Can't open file %s. (GLE=%d)";
			fHasFormatCodes = TRUE;
			break;
		case nrcArticleBadFieldFollowChar:
			szFormat = "Keyword '%s' is not followed by a space";
			fHasFormatCodes = TRUE;
			break;
		case nrcArticleBadChar:
			szFormat = "A bad character (%d) was found in the %s";
			fHasFormatCodes = TRUE;
			break;
		case nrcDuplicateComponents:
			szFormat = "Duplicate components found in field '%s'";
			fHasFormatCodes = TRUE;
			break;
		case nrcArticleFieldIllegalComponent:
			szFormat = "Illegal component '%s' in field '%s'";
			fHasFormatCodes = TRUE;
			break;
		case nrcArticleBadMessageID:
			szFormat = "Ill-formed message id '%s' in field '%s'";
			fHasFormatCodes = TRUE;
			break;
		case nrcArticleFieldBadChar:
			szFormat = "A bad character (%d) was found in the %s field";
			fHasFormatCodes = TRUE;
			break;
		case nrcArticleFieldDateIllegalValue:
			szFormat = "Date in '%s' field has illegal value";
			fHasFormatCodes = TRUE;
			break;
		case nrcArticleFieldDate4DigitYear:
			szFormat = "Date in '%s' field must contain 4-digit year";
			fHasFormatCodes = TRUE;
			break;
		case nrcArticleFieldAddressBad:
			szFormat = "Address in '%s' field has an illegal value";
			fHasFormatCodes = TRUE;
			break;
		case nrcArticleXoverTooBig:
			szFormat = "Too much Xover data";
			break;
		case nrcCreateNovEntryFailed:
			szFormat = "Xover insertion (group %d, article %d, GLE=%d)";
			fHasFormatCodes = TRUE;
			break;
		case nrcArticleXrefBadHub:
			szFormat = "Hub from Master in Xref ('%s') does not match local hub ('%s')";
			fHasFormatCodes = TRUE;
			break;
		case nrcArticleNoSuchGroups:
			szFormat = "No such groups";
			break;
		case nrcHashSetFailed:
			szFormat = "Can't add article %s to %s Table. (GLE=%d)";
			fHasFormatCodes = TRUE;
			break;
		case nrcArticleTableCantDel		:
			szFormat = "Can't delete message id %s from the Article Table. (GLE=%d)";
			fHasFormatCodes = TRUE;
			break;
		case nrcArticleTableError		:
			szFormat = "Error trying to find entry for %s in Article Table. (GLE=%d)";
			fHasFormatCodes = TRUE;
			break;
		case nrcArticleTableDup		:
			szFormat = "Unexpected duplicate entry %s in Article Table. (GLE=%d)";
			fHasFormatCodes = TRUE;
			break;
		case nrcCantAddToQueue		:
			szFormat = "Error trying to add article reference to outgoing feed";
			break;
		case nrcSlaveGroupMissing	:
			szFormat = "The special group for sending articles to the Master is missing";
			break;
		case nrcInconsistentMasterIds :
			szFormat = "The xreplic command line does not match the group ids in the articles Xref line";
			break ;
		case nrcInconsistentXref :
			szFormat = "The groups in the xreplic command line do not match the groups in the articles Xref line";
			break ;
		case nrcArticleDateTooOld :
			szFormat = "The Date in the date header is too old";
			break ;
		case nrcArticleTooLarge :
			szFormat = "The article is too large" ;
			break ;
		case nrcIllegalControlMessage :
			szFormat = "Illegal control message" ;
			break ;
		case nrcNotYetImplemented :
			szFormat = "Not Yet Implemented" ;
			break ;
		case nrcControlNewsgroupMissing :
			szFormat = "Control.* newsgroup is missing" ;
			break ;
		case nrcBadNewsgroupNameLen :
			szFormat = "Newsgroup name too long or zero" ;
			break ;
		case nrcNewsgroupDescriptionTooLong :
			szFormat = "Newsgroup description too long" ;
			break ;
		case nrcCreateNewsgroupFailed :
			szFormat = "Create Newsgroup failed" ;
			break ;
		case nrcGetGroupFailed :
			szFormat = "Get group failed" ;
			break ;
		case nrcControlMessagesNotAllowed :
			szFormat = "Control messages are not allowed by this server" ;
			break ;
		case nrcServerEventCancelledPost :
			szFormat = "A server event filter cancelled the posting" ;
			break ;

		case nrcLoggedOn :
			szFormat = "Packages Follow \r\n%s." ;
			fHasFormatCodes = TRUE;
			break ;
		case nrcSystemHeaderPresent:
			szFormat = "The '%s' header is a system header - client posts should not have it";
			fHasFormatCodes = TRUE;
			break;

		case nrcHeaderTooLarge:
			szFormat = "The header is too large";
			break;

		default:
			szFormat = "<no text for error code>";
			break;

	}

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\nntp\server\article\src\nntpcons.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    nntpcons.h

Abstract:

    This module contains global constants for the NNTP server.

Author:

    Johnson Apacible (JohnsonA)     26-Sept-1995

Revision History:

--*/

#ifndef _NNTPCONS_
#define _NNTPCONS_

//
// manifest constants
//

#define     KB                          1024
#define     MEG                         (KB * KB)
#define     MAX_NNTP_LINE               512
//
// convert to seconds
//

#define     SEC_PER_MIN                 (60)
#define     SEC_PER_HOUR                (60* SEC_PER_MIN)
#define     SEC_PER_DAY                 (24* SEC_PER_HOUR)
#define     SEC_PER_WEEK                (7 * SEC_PER_DAY)

//
// Port numbers
//

#define     NNTP_PORT                   119
#define     NNTP_SSL_PORT               563

//
// Id values
//

#define     GROUPID_INVALID             0xffffffff
#define     GROUPID_DELETED             0xfffffffe

#define     ARTICLEID_INVALID           0xffffffff

//
// Secret data name
//

#define NNTP_SSL_CERT_SECRET    L"NNTP_CERTIFICATE"
#define NNTP_SSL_PKEY_SECRET    L"NNTP_PRIVATE_KEY"
#define NNTP_SSL_PWD_SECRET     L"NNTP_SSL_PASSWORD"

//
// Default pull date/time
//

#define DEF_PULL_TIME           "000000"

//
// Maximum xover reference
//

#define MAX_REFERENCES_FIELD             512

//
//	Newsgroup constants
//
//
const	DWORD	MAX_DESCRIPTIVE_TEXT = 512 ;
const	DWORD	MAX_MODERATOR_NAME = 512 ;
const	DWORD	MAX_VOLUMES = 1;
const	DWORD	MAX_NEWSGROUP_NAME = 512 ;
const	DWORD	MAX_PRETTYNAME_TEXT = 72 ;

#endif // _NNTPCONS_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\nntp\server\article\src\nntpstr.cpp ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    nntpstr.cpp

Abstract:

    This module contains definition all string definitions

Author:

    Johnson Apacible (JohnsonA)     25-Sept-1995

Revision History:

--*/

//#include "tigris.hxx"
#include "stdinc.h"

//
// from extcmk2.h
//

const char szWSChars[] = " \t";
const char szWSNullChars[] = " \t\0";
const char szNLChars[] = "\n\r";
const char szWSNLChars[] = " \t\n\r";
const char StrNewLine[] = "\r\n";
const char StrTermLine[] = ".\r\n";

//
// Misc
//

LPSTR StrUnknownUser = "Anonymous";

//
// registry stuff
//

LPSTR StrParmKey = "System\\CurrentControlSet\\Services\\NNTPSvc\\Parameters";
LPSTR StrFeedKey = "System\\CurrentControlSet\\Services\\NNTPSvc\\Parameters\\Feeds";
LPSTR StrExpireKey = "System\\CurrentControlSet\\Services\\NNTPSvc\\Parameters\\Expires";
LPSTR StrVirtualRootsKey = "System\\CurrentControlSet\\Services\\NNTPSvc\\Parameters\\Virtual Roots";
LPSTR StrExpireNewsgroups = "Newsgroups" ;
LPSTR StrExpirePolicy = "ExpirePolicy" ;
LPSTR StrTreeRoot = "TreeRoot";
LPSTR StrRejectGenome = "RejectGenomeGroups";
LPSTR StrServerName = "ServerName";
LPSTR StrNntpHubName = "HubName";
LPSTR StrFeedType = "FeedType";
LPSTR StrFeedInterval = "FeedInterval";
LPSTR StrFeedDistribution = "Distribution";
LPSTR StrFeedNewsgroups = "Newsgroups";
LPSTR StrFeedAutoCreate = "CreateAutomatically";
LPSTR StrFeedAllowControl = "AllowControlMessages";
LPSTR StrFeedOutgoingPort = "OutgoingPort";
LPSTR StrFeedPairId = "FeedPairId";
LPSTR StrFeedIsMaster = "IsNntpMaster";
LPSTR StrFeedStartHigh = "FeedStartTimeHigh";
LPSTR StrFeedStartLow = "FeedStartTimeLow";
LPSTR StrFeedNextPullLow = "NextPullTimeLow";
LPSTR StrFeedNextPullHigh = "NextPullTimeHigh";
LPSTR StrPeerGapSize = "PeerGapSize";
LPSTR StrPeerTempDir = "PeerTempDirectory";
LPSTR StrFeedTempDir = "FeedTempDirectory" ;
LPSTR StrFeedUucpName = "UucpName" ;
LPSTR StrFeedMaxConnectAttempts = "MaxConnectionAttempts" ;
LPSTR StrFeedConcurrentSessions = "ConcurrentSessions" ;
LPSTR StrFeedSecurityType = "SecurityType" ;
LPSTR StrFeedAuthType = "AuthenticationType" ;
LPSTR StrFeedAuthAccount = "AuthinfoAccount" ;
LPSTR StrFeedAuthPassword = "AuthinfoPassword" ;
LPSTR StrListFileName = "ListFile";
LPSTR StrQueueFile = "QueueFile";
LPSTR StrExpireHorizon = "ExpireHorizon";
LPSTR StrExpireSpace   = "ExpireSpace";
LPSTR StrCleanBoot = "CleanBoot";
LPSTR StrSocketRecvSize = "SocketRecvBufferSize" ;
LPSTR StrSocketSendSize = "SocketSendBufferSize" ;
LPSTR StrBuffer = "BufferedWrites" ;
LPSTR StrCommandLogMask = "CommandLogMask" ;
LPSTR StrActiveFile = "Active.txt" ;
LPSTR StrDescriptiveFile = "groups.txt" ;
LPSTR StrGroupList = "group.lst" ;
LPSTR StrModeratorFile = "nntpfile\\moderatr.txt" ;
LPSTR StrFeedDisabled = "Disabled" ;
LPSTR StrAFilePath = "ArticleTableFile" ;
LPSTR StrHFilePath = "HistoryTableFile" ;
LPSTR StrXFilePath = "XoverTableFile" ;
LPSTR StrModeratorPath = "ModeratorFile" ;
LPSTR StrHistoryExpiration = "HistoryExpiration" ;
LPSTR StrArticleTimeLimit = "ArticleTimeLimit" ;
LPSTR StrAllowClientPosts = "AllowClientPosts" ;
LPSTR StrAllowFeedPosts = "AllowFeedPosts" ;
LPSTR StrAllowControlMessages = "AllowControlMessages" ;
LPSTR StrServerSoftLimit = "ServerPostingSoftLimit" ;
LPSTR StrServerHardLimit = "ServerPostingHardLimit" ;
LPSTR StrFeedSoftLimit = "FeedPostSoftLimit" ;
LPSTR StrFeedHardLimit = "FeedPostHardLimit" ;
LPSTR StrServerOrg = "ServerOrganization" ;
LPSTR StrSmallBufferSize = "SmallBufferSize" ;
LPSTR StrMediumBufferSize = "MediumBufferSize" ;
LPSTR StrLargeBufferSize = "LargeBufferSize" ;
LPSTR StrNewsCrawlerTime = "NewsCrawlerTime" ;
LPSTR StrNewsVrootUpdateRate = "NewsVrootUpdateRate" ;
LPSTR StrHonorClientMessageIDs = "HonorClientMessageIDs" ;
LPSTR StrHonorClientDateHeader = "HonorClientDateHeader" ;
LPSTR StrDisableNewnews = "DisableNewnews" ;
LPSTR StrGenerateErrFiles = "GenerateErrFiles" ;
LPSTR StrXoverPageEntry = "NumXoverPageEntry" ;
LPSTR StrArticlePageEntry = "NumArticlePageEntry" ;
LPSTR StrHistoryPageEntry = "NumHistoryPageEntry" ;
LPSTR StrShutdownLatency = "ShutdownLatency" ;
LPSTR StrStartupLatency = "StartupLatency" ;
LPSTR StrHonorApprovedHeader = "HonorApprovedHeader" ;
LPSTR StrMailFromHeader = "MailFromHeader" ;
LPSTR StrEnableNntpPostingHost = "EnableNntpPostingHost" ;
LPSTR StrNumExpireThreads = "NumExpireThreads" ;
LPSTR StrNumSpecialCaseExpireThreads = "NumSpecialCaseExpireThreads" ;
LPSTR StrSpecialExpireArtCount = "SpecialExpireArtCount" ;
LPSTR StrSpecialExpireGroup = "SpecialExpireGroup" ;
LPSTR StrNewsTreeFileScanRate = "NewsTreeFileScanRate" ;
LPSTR StrPageCacheSize = "PageCacheSize" ;
LPSTR StrFileHandleCacheSize = "FileHandleCacheSize" ;
LPSTR StrXixHandlesPerTable = "XixHandlesPerTable" ;
LPSTR StrHashTableNoBuffering = "HashTableNoBuffering" ;
LPSTR StrPostBackFillLines = "PostBackFillLines";


LPWSTR StrSmtpAddressW = L"SmtpAddress" ;
LPWSTR StrUucpNameW = L"ServerUucpName" ;
LPSTR  StrUucpNameA = "ServerUucpName" ;
LPWSTR StrDefaultModeratorW = L"DefaultModerator" ;
LPWSTR StrAuthPackagesW = L"NTAuthenticationProviders" ;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\nntp\server\article\src\stdinc.h ===
#ifndef	_STDINC_H_
#define	_STDINC_H_

//
// disables a browser info warning that breaks the build
//
#pragma warning (disable:4786)

//
// disables redundant warning about / in // comments
//
#pragma warning (disable:4010)

#ifdef __cplusplus
extern "C" {
#endif

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <randfail.h>

#ifdef __cplusplus
};
#endif

#include <malloc.h>

#include <objidl.h>
#include <nntps.h>
#include <xmemwrpr.h>
#include <nntptype.h>
#include <nntpapi.h>
#include <tigdflts.h>
#include <smartptr.h>
#include <cpool.h>
#include <tsunami.hxx>
#include <stdio.h>
#include <cstream.h>
#include <time.h>
//#include <tsvcinfo.hxx>
//#include <tcpproc.h>
#include "dbgtrace.h"
//#include "resource.h"

#include "tigtypes.h"
#include "fsconst.h"

#ifdef PROFILING
#include "icapexp.h"
#endif

typedef char *LPMULTISZ;

#include <filehc.h>
#include <artcore.h>
#include <frmstore.h>

#pragma hdrstop

#endif	// _STDINC_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\nntp\server\article\src\tigmem.cpp ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    tigmem.cpp

Abstract:

    This module contains definition for the CAllocator base class.
	That class can be used to allocator memory from a fixed buffer
	before resorting to "new".

Author:

    Carl Kadie (CarlK)     12-Jan-1995

Revision History:

--*/

//#ifndef	UNIT_TEST
//#include "tigris.hxx"
//#else
//#include	<windows.h>
//#include	"tigmem.h"
#include "stdinc.h"


//#ifndef	_ASSERT
//#define	_ASSERT( f )	if( (f) ) ; else DebugBreak()
//#endif
//#ifndef	TraceFunctEnter( sz )
//#define	TraceFunctEnter( sz )
//#endif
//#ifndef	ErrorTrace
//#define ErrorTrace  1 ? (void)0 : PreAsyncTrace
//#endif
//__inline int PreAsyncTrace( LPARAM lParam, LPCSTR szFormat, ... )
//{
//        return( 1);
//}
//
//#endif


char *
CAllocator::Alloc(
	  size_t size
	  )
{
	char * pv;

	//
	// Align the request on SIZE_T boundry
	//

 	if (0 != size%(sizeof(SIZE_T)))
		size += (sizeof(SIZE_T)) - (size%(sizeof(SIZE_T)));

	if( size <= (m_cchMaxPrivateBytes - m_ichLastAlloc) )
	{
		pv = m_pchPrivateBytes + m_ichLastAlloc;
		_ASSERT(0 == (((DWORD_PTR)pv)%(sizeof(SIZE_T)))); //should be SIZE_T aligned.
		m_ichLastAlloc += size;
		m_cNumberOfAllocs ++;
		return (char *) (pv);
	} else {
		m_cNumberOfAllocs ++;
		return PCHAR(PvAlloc(size));
	}
};


void
CAllocator::Free(
	 char *pv
	 )
{
	if (!pv)
		return;

	_ASSERT(0 != m_cNumberOfAllocs);

	if ( pv >= m_pchPrivateBytes &&
		pv < (m_pchPrivateBytes + m_cchMaxPrivateBytes))
	{
		m_cNumberOfAllocs --;
	} else {
		m_cNumberOfAllocs --;
		FreePv( pv );
	}

};

CAllocator::~CAllocator(void)
{
	TraceFunctEnter("CAllocator::~CAllocator");
	if (0 != m_cNumberOfAllocs)
	{
		ErrorTrace((DWORD_PTR) this, "CAllocator has %d allocations outstanding", m_cNumberOfAllocs);
		_ASSERT(FALSE);
	}
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\nntp\server\article\src\pcparse.cpp ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    pcprase.cpp

Abstract:

    This module implements an object for parsing FROM values.
	It works by creating a function for each grammer rule.
	When called the function will "eat up" any characters that
	parse and return TRUE. If no characters parse, then none
	will be eaten up and the return will be FALSE.

Author:

    Carl Kadie (CarlK)     11-Dec-1995

Revision History:

--*/

//#include "tigris.hxx"
#include "stdinc.h"

BOOL
CPCParse::fParenChar(
								void
				 )
/*++

Routine Description:

	Parse a "("

Arguments:

	None.

Return Value:

	TRUE, if successful. FALSE, otherwise.    

--*/
{
	if ((0<m_cch) && fParenCharTest(m_pch[0]))
	{
		m_pch++;
		m_cch--;
		return TRUE;
	}

	return FALSE;
}

BOOL
CPCParse::fIsChar(
				 char ch
				 )
/*++

Routine Description:

	Look at next char to see if it matches ch.

Arguments:

	ch - The character to look for.


Return Value:

	TRUE, if successful. FALSE, otherwise.    

--*/
{
	if ((0<m_cch) && (ch == m_pch[0]))
	{
		return TRUE;
	}

	return FALSE;
}


BOOL
CPCParse::fParseSingleChar(
				 char ch
				 )
/*++

Routine Description:

	Parse a single character.

Arguments:

	ch - The character to look for.


Return Value:

	TRUE, if successful. FALSE, otherwise.    

--*/
{
	if ((0<m_cch) && (ch == m_pch[0]))
	{
		m_pch++;
		m_cch--;
		return TRUE;
	}

	return FALSE;
}


BOOL
CPCParse::fAtLeast1QuotedChar(
								   void
		  )
/*++

Routine Description:

	Parse one or more occurances of a "QuotedChar"

Arguments:

	None.

Return Value:

	TRUE, if successful. FALSE, otherwise.    

--*/
{

	//
	// Is it even long enough?
	//

	DWORD dwN = 1;
	if (m_cch < dwN)
		return FALSE;

	//
	// Are their N occuraces?
	//

	DWORD dw;
	for (dw = 0; dw < dwN; dw++)
	{
 		if (!fQuotedCharTest(m_pch[dw]))
			return FALSE;
	}
	vSkipStart(dw);

	//
	// Process any additional occuracies
	//

	while ((0<m_cch) && fQuotedCharTest(m_pch[0]))
	{
		m_pch++;
		m_cch--;
	}


	return TRUE;
}

BOOL
CPCParse::fAtLeast1UnquotedChar(
								   void
		  )
/*++

Routine Description:

	Parse one or more occurances of a "UnquotedChar"

Arguments:

	None.

Return Value:

	TRUE, if successful. FALSE, otherwise.    

--*/
{

	//
	// Is it even long enough?
	//

	DWORD dwN = 1;
	if (m_cch < dwN)
		return FALSE;

	//
	// Are their N occuraces?
	//

	DWORD dw;
	for (dw = 0; dw < dwN; dw++)
	{
 		if (!fUnquotedCharTest(m_pch[dw]))
			return FALSE;
	}
	vSkipStart(dw);

	//
	// Process any additional occuracies
	//

	while ((0<m_cch) && fUnquotedCharTest(m_pch[0]))
	{
		m_pch++;
		m_cch--;
	}


	return TRUE;
}


BOOL
CPCParse::fAtLeast1UnquotedDotChar(
								   void
								   )
/*++

Routine Description:

	Parse one or more occurances of a "UnquotedChar" - allows Dots to be present

Arguments:

	None.

Return Value:

	TRUE, if successful. FALSE, otherwise.    

--*/
{

	//
	// Is it even long enough?
	//

	DWORD dwN = 1;
	if (m_cch < dwN)
		return FALSE;

	//
	// Are their N occuraces?
	//

	DWORD dw;
	for (dw = 0; dw < dwN; dw++)
	{
 		if (!fUnquotedDotCharTest(m_pch[dw]))
			return FALSE;
	}
	vSkipStart(dw);

	//
	// Process any additional occuracies
	//

	while ((0<m_cch) && fUnquotedDotCharTest(m_pch[0]))
	{
		m_pch++;
		m_cch--;
	}


	return TRUE;
}

BOOL
CPCParse::fAtLeast1Space(
					   void
		  )
/*++

Routine Description:

	Parse one or more occurances of a "Space"

Arguments:

	None.

Return Value:

	TRUE, if successful. FALSE, otherwise.    

--*/
{

	//
	// Is it even long enough?
	//

	DWORD dwN = 1;
	if (m_cch < dwN)
		return FALSE;

	//
	// Are their N occuraces?
	//

	DWORD dw;
	for (dw = 0; dw < dwN; dw++)
	{
 		if (!fSpaceTest(m_pch[dw]))
			return FALSE;
	}
	vSkipStart(dw);

	//
	// Process any additional occuracies
		// Process any additional occuracies
		//

	while ((0<m_cch) && fSpaceTest(m_pch[0]))
	{
		m_pch++;
		m_cch--;
	}

	return TRUE;
}


BOOL
CPCParse::fAtLeast1QuotedCharOrSpace(
					   void
		  )
/*++

Routine Description:

	Parse one or more occurances of a "QuotedChar" or Space

Arguments:

	None.

Return Value:

	TRUE, if successful. FALSE, otherwise.    

--*/
{

	//
	// Is it even long enough?
	//

	DWORD dwN = 1;
	if (m_cch < dwN)
		return FALSE;

	//
	// Are their N occuraces?
	//

	DWORD dw;
	for (dw = 0; dw < dwN; dw++)
	{
 		if (!fQuotedCharOrSpaceTest(m_pch[dw]))
			return FALSE;
	}
	vSkipStart(dw);

	//
	// Process any additional occuracies
		// Process any additional occuracies
		//

	while ((0<m_cch) /*&& fParenCharTest(m_pch[0]*/ && *m_pch != '\"' )
	{
		m_pch++;
		m_cch--;
	}

	return TRUE;
}

BOOL
CPCParse::fAtLeast1ParenChar(
					   void
		  )
/*++

Routine Description:

	Parse at least one "ParenChar"

Arguments:

	None.

Return Value:

	TRUE, if successful. FALSE, otherwise.    

--*/
{

	//
	// Is it even long enough?
	//

	DWORD dwN = 1;
	if (m_cch < dwN)
		return FALSE;

	//
	// Are their N occuraces?
	//

	DWORD dw;
	for (dw = 0; dw < dwN; dw++)
	{
 		if (!fParenCharTest(m_pch[dw]))
			return FALSE;
	}
	vSkipStart(dw);

	//
	// Process any additional occuracies
		// Process any additional occuracies
		//

	while ((0<m_cch) && fParenCharTest(m_pch[0]))
	{
		m_pch++;
		m_cch--;
	}

	return TRUE;
}

BOOL
CPCParse::fAtLeast1CodeChar(
					   void
		  )
/*++

Routine Description:

	Parse at least one "CodeChar"

Arguments:

	None.

Return Value:

	TRUE, if successful. FALSE, otherwise.    

--*/
{

	//
	// Is it even long enough?
	//

	DWORD dwN = 1;
	if (m_cch < dwN)
		return FALSE;

	//
	// Are their N occuraces?
	//

	DWORD dw;
	for (dw = 0; dw < dwN; dw++)
	{
 		if (!fCodeCharTest(m_pch[dw]))
			return FALSE;
	}
	vSkipStart(dw);

	//
	// Process any additional occuracies
		// Process any additional occuracies
		//

	while ((0<m_cch) && fCodeCharTest(m_pch[0]))
	{
		m_pch++;
		m_cch--;
	}

	return TRUE;
}

BOOL
CPCParse::fAtLeast1TagChar(
					   void
		  )
/*++

Routine Description:

	Parse at least one "TagChar"

Arguments:

	None.

Return Value:

	TRUE, if successful. FALSE, otherwise.    

--*/
{

	//
	// Is it even long enough?
	//

	DWORD dwN = 1;
	if (m_cch < dwN)
		return FALSE;

	//
	// Are their N occuraces?
	//

	DWORD dw;
	for (dw = 0; dw < dwN; dw++)
	{
 		if (!fTagCharTest(m_pch[dw]))
			return FALSE;
	}
	vSkipStart(dw);

	//
	// Process any additional occuracies
		// Process any additional occuracies
		//

	while ((0<m_cch) && fTagCharTest(m_pch[0]))
	{
		m_pch++;
		m_cch--;
	}

	return TRUE;
}


BOOL
CPCParse::fQuotedWord(
			void
			)
/*++

Routine Description:


	 quoted-word   = quote 1*( quoted-char / space ) quote


Arguments:

	None.

Return Value:

	TRUE, if successful. FALSE, otherwise.    

--*/
{
	CPCParse pcOld = *this;
	if (fParseSingleChar('\"') //!!!constize
		&& fAtLeast1QuotedCharOrSpace()
		&& fParseSingleChar('\"')
		)
		return TRUE;

	*this = pcOld;
	return FALSE;
}

BOOL
CPCParse::fLocalPart(
			void
			)
/*++

Routine Description:

	 local-part    = unquoted-word *( "." unquoted-word )


Arguments:

	None.

Return Value:

	TRUE, if successful. FALSE, otherwise.    

--*/
{
	if (!fUnquotedWord())
		return FALSE;

	CPCParse pcOld = *this;

	while(fParseSingleChar('.') && fUnquotedWord())
		pcOld = *this;

	*this = pcOld;
	return TRUE;
}



BOOL
CPCParse::fStrictAddress(
			void
			)
/*++

Routine Description:


	address       = local-part "@" domain

  !!!X LATER - do we want a flag that tells if just local-part is acceptable?

Arguments:

	None.

Return Value:

	TRUE, if successful. FALSE, otherwise.    

--*/
{
	CPCParse pcOld = *this;

	if (!fLocalPart())
		return FALSE;

	if (!fParseSingleChar('@'))
		return FALSE;

	if (fDomain())
		return TRUE;

	*this = pcOld;
	return FALSE;
}

BOOL
CPCParse::fAddress(
			void
			)
/*++

Routine Description:


	address       = local-part "@" domain or JUST local-part

  !!!X LATER - do we want a flag that tells if just local-part is acceptable?

Arguments:

	None.

Return Value:

	TRUE, if successful. FALSE, otherwise.    

--*/
{
	CPCParse pcOld = *this;

	if (!fLocalPart())
		return FALSE;

	if (!fParseSingleChar('@'))
		return TRUE;

	if (fDomain())
		return TRUE;

	*this = pcOld;
	return FALSE;
}

BOOL
CPCParse::fPlainPhrase(
			void
			)
/*++

Routine Description:

	 plain-phrase  = plain-word *( space plain-word )


Arguments:

	None.

Return Value:

	TRUE, if successful. FALSE, otherwise.    

--*/
{
	if (!fPlainWord())
		return FALSE;

	CPCParse pcOld = *this;

	while(fSpace() && fPlainWord())
		pcOld = *this;

	*this = pcOld;
	return TRUE;
}


BOOL
CPCParse::fParenPhrase(
			 void
			 )
/*++

Routine Description:

    paren-phrase  = 1*( paren-char / space / encoded-word )


Arguments:

	None.

Return Value:

	TRUE, if successful. FALSE, otherwise.    

--*/
{
	if (!(
		   fParenChar()
		|| fSpace()
		|| fEncodedWord()
        )) {

        //
        // special case () to fix rfc-non-compliance by TIN
        //
		return fIsChar(')');
    }

	CPCParse pcOld = *this;

	while(fParenChar()|| fSpace() || fEncodedWord())
		pcOld = *this;

	*this = pcOld;
	return TRUE;
}


BOOL
CPCParse::fFromContent(
			 void
			 )
/*++

Routine Description:

	  From-content  = address [ space "(" paren-phrase ")" ]
	         /  [ plain-phrase space ] "<" address ">"


Arguments:

	None.

Return Value:

	TRUE, if successful. FALSE, otherwise.    

--*/
{
	CPCParse pcOld = *this;
	BOOL fOK = FALSE; // Assume the worst

    // try style 1
	if (fStrictAddress())
	{
        // address is ok
        fOK = TRUE;

        // now check for optional [ space "(" paren-phrase ")" ]
		if (fSpace())
		{
			if (!(
				fParseSingleChar('(') 
				&& fParenPhrase()
				&& fParseSingleChar(')')
				))
			{
				fOK = FALSE;
			}	
			else	
			{
				fOK = TRUE ;
			}
		}
	}

	// If it didn't parse that way, try style 2
	if (!fOK)
	{
		*this = pcOld;

		if (fPlainPhrase() && !fSpace())
		{
            fOK = FALSE;
        } else if (!(fParseSingleChar('<') 
			        && fAddress()
			        && fParseSingleChar('>')
			        ))
		{
            fOK = FALSE;
        } else {
            fOK = TRUE ;
        }
	}

    // style 1 and 2 both failed
    if( !fOK )
    {
        *this = pcOld;
        if( fAddress() ) {
            fOK = TRUE;
        }
    }

	//
	// There should be no characters left
	//

	if (0 != m_cch)
		{
			*this = pcOld;
			return FALSE;
		}

	return TRUE;
}


BOOL
CPCParse::fEncodedWord(
			 void
			 )
/*++

Routine Description:

	  encoded-word  = "=?" charset "?" encoding "?" codes "?="


Arguments:

	None.

Return Value:

	TRUE, if successful. FALSE, otherwise.    

--*/
{
		CPCParse pcOld = *this;
		if (
			 fParseSingleChar('=')
			&& fParseSingleChar('?')
			&& fCharset()
			&& fParseSingleChar('?')
			&& fEncoding()
			&& fParseSingleChar('?')
			&& fCodes()
			&& fParseSingleChar('?')
			&& fParseSingleChar('=')
			)
			return TRUE;

		*this = pcOld;
		return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\nntp\server\article\src\pcstring.cpp ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    pcstring.cpp

Abstract:

    This module implements an abstract data type called
	"Pointer/Counter Strings". Each object is just
	a pair: a pointer to char and a count of how many
	characters are in the string.

Author:

    Carl Kadie (CarlK)     10-Oct-1995

Revision History:

--*/

//#include "tigris.hxx"
#include "stdinc.h"

char *
CPCString::pchMax(
				  void
				  )
/*++

Routine Description:

	Returns a pointer to one past the last legal character.

Arguments:

	None.

Return Value:

	A pointer to one past the last legal character.

--*/
{
	return m_pch + m_cch;
}

BOOL
CPCString::fEqualIgnoringCase(
							  const char * sz
							  )
/*++

Routine Description:

	Tests if sz is equal to the current sting.

		\\!!! What if the sz is longer?? Should test that, too.

Arguments:

	sz - The string to compare with the current string.


Return Value:

	TRUE, if eqaul. FALSE, otherwise.

--*/
{
	return m_cch && (0 == _strnicmp(sz, m_pch, m_cch));
}

BOOL
CPCString::fExistsInSet(char ** rgsz, DWORD dwNumStrings)
/*++

Routine Description:

	Tests if the current string exists in the set of strings rgsz


Arguments:

	rgsz			-  The set of strings
	dwNumStrings	-  number of strings in rgsz


Return Value:

	TRUE, if exists. FALSE, otherwise.

--*/
{
	BOOL fExists = FALSE;

	// iterate over set of strings
	for(DWORD i=0; i<dwNumStrings; i++)
	{
		// If this string equals current string in set
		if(0 == _strnicmp(rgsz[i], m_pch, strlen(rgsz[i])))
		{
			fExists = TRUE;
			break;
		}
	}

	return fExists;
}

BOOL
CPCString::fSetCch(
				   const char * pchMax
				   )
/*++

Routine Description:

	Sets the string's length based a pointer to one beyond
		its last legal character.

Arguments:

	pchMax - One beyond the legal legal character of this string.


Return Value:

	TRUE, if successful. FALSE, otherwise.

--*/
{
	if (NULL == m_pch || pchMax < m_pch)
		return FALSE;

	m_cch = (DWORD)(pchMax - m_pch);
	return TRUE;

};

BOOL
CPCString::fSetPch(
				   char * pchMax
				   )
/*++

Routine Description:

	Sets the string's start based a pointer to one beyond
		its last legal character (and its length).

Arguments:

	pchMax - One beyond the legal legal character of this string.


Return Value:

	TRUE, if successful. FALSE, otherwise.

--*/
{
	if (NULL == pchMax)
		return FALSE;

	m_pch = pchMax - m_cch;
	return TRUE;

};

DWORD
CPCString::dwTrimEnd(
					 const char * szSet
					 )
/*++

Routine Description:

	Trims characters in the set from the end of the string.

Arguments:

	szSet - the set of characters to trim.


Return Value:

	Number of characters trimed.

--*/
{
	DWORD dw = m_cch;
	while(m_cch > 0 && fCharInSet(m_pch[m_cch-1], szSet))
		m_cch--;

		return dw-m_cch;
}

DWORD
CPCString::dwTrimStart(
					   const char * szSet
					   )
/*++

Routine Description:

	Trims characters in the set from the beginning of the string.

Arguments:

	szSet - the set of characters to trim.


Return Value:

	Number of characters trimed.

--*/
{
	DWORD dw = m_cch;
	while(m_cch > 0 && fCharInSet(m_pch[0], szSet))
	{
		m_pch++;
		m_cch--;
	}

	return dw-m_cch;
}

	
void
CPCString::vSplitLine(
		  const char *	szDelimSet,
		  char *	multiszBuf,
		  DWORD	&	dwCount	
		  )
/*++

Routine Description:

	Splits the string on the delimiters.

	It is not stict about repeated delimiters or whitespace
	It returns TRUE even if count is 0..
	The caller must allocate space for multisz. It
	 can be up to two bytes longer that the original string


Arguments:

	szDelimSet - The set of delimiter characters.
	multiszBuf - The buffer to write the results to
	dwCount - The number of items in the list.


Return Value:

	None.

--*/
{

	//
	// Create a pointer into the output buffer
	//

	char * multisz = multiszBuf;

	//
	// Create a pointer into the input
	//

	char * pch = m_pch;

	//
	// Create a pointer to the one past the end of the input buffer
	//

	const char * pchMax1 = pchMax();

	dwCount = 0;

	//
	// skip over any leading delimiters
	//

	while (pch < pchMax1 && fCharInSet(pch[0], szDelimSet))
		pch++;

	if (pch >= pchMax1)
	{
		multisz[0] = '\0';
		multisz[1] = '\0';

	} else {
		do
		{

			//
			// copy until delimiter
			//

			while (pch < pchMax1 && !fCharInSet(pch[0], szDelimSet))
				*multisz++ = *pch++;

			//
			// terminate the string
			//

			*multisz++ = '\0';
			dwCount++;

			//
			// skip any delimiters
			//

			while (pch < pchMax1 && fCharInSet(pch[0], szDelimSet))
				pch++;

		} while (pch < pchMax1);

		//
		// terminate the multistring
		//

		*multisz++ = '\0';
	}

	return;
}


CPCString&
CPCString::operator <<(
				   const CPCString & pcNew
				   )
/*++

Routine Description:

	Append a second PCString to the current one.

Arguments:

	pcNew - the PCString to append.


Return Value:

	The current PCString after the append.

--*/
{
	CopyMemory(pchMax(), pcNew.m_pch, pcNew.m_cch); //!!!check for error
	fSetCch(pchMax() + pcNew.m_cch);
	return *this;
}

CPCString&
CPCString::operator <<(
				  const char * szNew
				  )
/*++

Routine Description:

	Append a sz string to the current PCString.

Arguments:

	szNew - the sz string to append.


Return Value:

	The current PCString after the append.

--*/
{
	while (*szNew)
		m_pch[m_cch++] = *(szNew++);

	return *this;
}

CPCString&
CPCString::operator <<(
				  const char cNew
				  )
/*++

Routine Description:

	Append a character to the current PCString.

Arguments:

	cNew - the character to append


Return Value:

	The current PCString after the append.

--*/
{
	m_pch[m_cch++] = cNew;
	return *this;
}
CPCString&
CPCString::operator <<(
				  const DWORD dwNew
				  )
/*++

Routine Description:

	Append a number to the current PCString.

Arguments:

	dwNew - the number to append


Return Value:

	The current PCString after the append.

--*/
{
	int iLen = wsprintf(m_pch+m_cch, "%lu", dwNew);
	_ASSERT(iLen>0);
	m_cch += iLen;
	return *this;
}

void
CPCString::vCopy(
				   CPCString & pcNew
				   )
/*++

Routine Description:

	Copy from a second PCString to this one.

Arguments:

	pcNew - the PCString to copy from


Return Value:

	None.

--*/
{
	CopyMemory(m_pch, pcNew.m_pch, pcNew.m_cch);
	m_cch = pcNew.m_cch;
}

void
CPCString::vMove(
				   CPCString & pcNew
				   )
/*++

Routine Description:

	"Move" (safe copy) from a second PCString to this one.

Arguments:

	pcNew - the PCString to copy from


Return Value:

	None.

--*/
{
	MoveMemory(m_pch, pcNew.m_pch, pcNew.m_cch);
	m_cch = pcNew.m_cch;
}


void
CPCString::vCopyToSz(
					 char * sz
				   )
/*++

Routine Description:

	Copy to an sz.

Arguments:

	sz - The sz to copy to.


Return Value:

	None.

--*/
{
	strncpy(sz, m_pch, m_cch);
	sz[m_cch] = '\0';
}

void
CPCString::vCopyToSz(
					 char * sz,
					 DWORD cchMax
				   )
/*++

Routine Description:

	Copy to an sz.

Arguments:

	sz - The sz string to copy to.
	cchMax - The maximum number of characters to copy.
	        (The last character will always be a \0.)


Return Value:

	None.

--*/
{
	DWORD cchLast = min(cchMax - 1, m_cch);
	strncpy(sz, m_pch, cchLast);
	sz[cchLast] = '\0';
}


void
CPCString::vMakeSz(
				   void
				   )
/*++

Routine Description:

	Adds a '\0' one chacter past the end of the string.

Arguments:

	None.

Return Value:

	None.

--*/
{
	m_pch[m_cch] = '\0';
}


char *
CPCString::sz(
				void
				)
/*++

Routine Description:

	Returns the current PCstring as an sz string.

	 Only to be used in the special case in which you
	 now that the string is null termianted.


Arguments:

	None.

Return Value:

	The sz string.

--*/
{
	_ASSERT('\0' == m_pch[m_cch]); //real
	return m_pch;
}


BOOL
CPCString::fCheckTextOrSpace(
						char & chBad
						)
/*++

Routine Description:

	 Returns TRUE if contains only 7-bit characters (and no nulls)


Arguments:

	chBad - the character that was bad.


Return Value:

	TRUE, if successful. FALSE, otherwise.

--*/
{
	char * pchMax = m_pch + m_cch; //!!!should me pchMax();
	for (char * pch = m_pch; pch < pchMax; pch++)
	{
		if (('\0'==*pch) || !__isascii((UCHAR)*pch))
		{
			chBad = *pch;
			return FALSE;
		}
	}

	return TRUE;
}

BOOL
CPCString::fAppendCheck(
			 const CPCString & pcNew,
			 DWORD cchLast
			 )
/*++

Routine Description:

	Appends pcNew to the current PCString,
	but only if it the result is not too long.

Arguments:

	pcNew - the PCString to append to this string.
	cchLast - The greatest allowed length of the result.


Return Value:

	TRUE, if successful. FALSE, otherwise.

--*/
{
	if(m_cch+pcNew.m_cch > cchLast)
		return FALSE;
	
	(*this)<<pcNew;
	return TRUE;
}

BOOL
CPCString::fAppendCheck(
			 char ch,
			 DWORD cchLast
			 )
/*++

Routine Description:

	Appends a character to the current PCString,
	but only if it the result is not too long.

Arguments:

	ch - the character to append to this string.
	cchLast - The greatest allowed length of the result.


Return Value:

	TRUE, if successful. FALSE, otherwise.

--*/
{
	if(m_cch+1 > cchLast)
		return FALSE;
	
	(*this)<<ch;
	return TRUE;
}


void
CPCString::vTr(
	const char * szFrom,
	char chTo
	)
/*++

Routine Description:

	 Translate any character in a set to some other character.

Arguments:

	szFrom - The set of characters to translate from
	chTo - The character to translate to


Return Value:

	None.

--*/
{
	const char * pchMax1 = pchMax();
	for (char * pch = m_pch; pch < pchMax1; pch++)
	{
		if (fCharInSet(*pch, szFrom))
			*pch = chTo;
	}
}


void
CPCString::vGetToken(
		  const char *	szDelimSet,
		  CPCString & pcToken
	)
/*++

Routine Description:

	Get a token from the current string. As a side-effect
	remove the token and any delimiters from the string.

Arguments:

	szDelimSet - The set of delimiter characters.
	pcToken - The token


Return Value:

	None.

--*/
{
	pcToken.m_pch = m_pch;

	while(m_cch > 0 && !fCharInSet(m_pch[0], szDelimSet))
	{
		m_pch++;
		m_cch--;
	}

	pcToken.fSetCch(m_pch);

	dwTrimStart(szDelimSet);

}

void
CPCString::vGetWord(
		  CPCString & pcWord
	)
/*++

Routine Description:

	Get a word from the current string. As a side-effect
	remove the word from the string. NOTE: this string
	should be trimmed of whitespace before calling this
	function.

Arguments:

	pcWord - The word


Return Value:

	None.

--*/
{
	pcWord.m_pch = m_pch;

	while(m_cch > 0 && isalpha((UCHAR)m_pch[0]))
	{
		m_pch++;
		m_cch--;
	}

	pcWord.fSetCch(m_pch);
}

DWORD
CPCString::dwCountChar(
			char ch
			)
/*++

Routine Description:

	Counts the number of times a specified character
	appears in the string.

Arguments:

	ch - the character of interest.


Return Value:

	The number of times it occurs.

--*/
{
	DWORD dw = 0;

	const char * pchMax1 = pchMax();
	for (char * pch = m_pch; pch < pchMax1; pch++)
	{
		if (*pch == ch)
			dw++;
	}

	return dw;
}


void
CPCString::vReplace(
				   const char * sz
				   )
/*++

Routine Description:

	Replaces the current string with a sz string of
	exactly the same length.

Arguments:

	sz - the sz string


Return Value:

	None.

--*/
{
	_ASSERT('\0' == sz[m_cch]);

	CopyMemory(m_pch, sz, m_cch);
}

void
CPCString::vSkipLine(void)
/*++

Routine Description:

	Skip a CRLF terminated line

Arguments:


Return Value:

	void

--*/
{
    while( (*m_pch) != '\n')
    {
        m_pch++;
        m_cch--;
        _ASSERT(m_cch);
    }

    m_pch++;
    m_cch--;

	return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\nntp\server\cbuffer\gcache.cpp ===
//#ifdef	UNIT_TEST
//#include	<windows.h>
//#include	"gcache.h"
//#else
#include	"stdinc.h"
//#endif

#ifndef	_ASSERT
#define	_ASSERT( f )	if( (f) ) ; else DebugBreak()
#endif

DWORD	CClassAllocator::cbJunk	= 0 ;
DWORD	CCache::cbJunk = 0 ;

CCache::CCache(	void**	ppv,	DWORD	size	)	:
	m_pCache( ppv ), m_clpv( size ) {
	ZeroMemory( ppv, m_clpv * sizeof( void * ) ) ;
}

CCache::~CCache( ) {
	for( DWORD	i=0; i<m_clpv; i++ ) {
		_ASSERT( m_pCache[i] == 0 ) ;
	}
}

void*	
CCache::InternalFree(	void*	lpv ) {
	for(	DWORD	i=0;	i<m_clpv && lpv != 0 ; i++ ) {
		lpv = (void*)InterlockedExchangePointer( &m_pCache[i], lpv ) ;
	}
	return	lpv ;
}

void*
CCache::InternalAlloc()	{
	LPVOID	lpv	 = 0 ;
	for( DWORD	i=0; i<m_clpv && lpv == 0; i++ ) {
		lpv = (void*)InterlockedExchangePointer( &m_pCache[i], NULL ) ;
	}
	return	lpv ;
}

void
CCache::Free(	void*	lpv,	CClassAllocator*	pAllocator ) {

#ifdef	DEBUG
	_ASSERT( pAllocator->RangeCheck( lpv ) ) ;
	pAllocator->Erase( lpv ) ;
#endif

	lpv = InternalFree( lpv ) ;

	if( lpv != 0 ) {
#ifdef	DEBUG
		_ASSERT( pAllocator->EraseCheck( lpv ) ) ;
#endif
		pAllocator->Release( lpv ) ;
	}
}

void*
CCache::Alloc(	DWORD	size,	CClassAllocator*	pAllocator, DWORD &cbOut )	{

	void*	lpv = InternalAlloc() ;

#ifdef	DEBUG
	_ASSERT( pAllocator->SizeCheck( size ) ) ;
	if( lpv != 0 ) {
		_ASSERT(	pAllocator->EraseCheck( lpv ) ) ;
	}
#endif

	if( lpv == 0 ) {
		lpv = pAllocator->Allocate(	size, cbOut ) ;
	}
	return	lpv ;
}

void*
CCache::Empty(	)	{
	return	InternalAlloc() ;
}

void
CCache::Empty( CClassAllocator*	pAllocator ) {

	LPVOID	lpv = 0 ;
	for( DWORD i=0; i<m_clpv; i++ ) {
		lpv = (void*)InterlockedExchangePointer( &m_pCache[i], NULL ) ;
		if( lpv != 0 ) {
			pAllocator->Release( lpv ) ;
		}
	}
}

CClassAllocator::CClassAllocator()	{
}

CClassAllocator::~CClassAllocator()	{
}


#ifdef	DEBUG
void
CClassAllocator::Erase(	LPVOID	lpv ) {

}

BOOL
CClassAllocator::EraseCheck( LPVOID	lpv )	{

	return	TRUE ;
}

BOOL
CClassAllocator::RangeCheck(	LPVOID	lpv )	{
	return	TRUE ;
}

BOOL
CClassAllocator::SizeCheck(	DWORD	cb )	{
	return	TRUE ;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\nntp\server\cbuffer\stdinc.cpp ===
#include "stdinc.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\nntp\server\cbuffer\cbuffer.cpp ===
/*++

	packet.cpp

	This file contains the code which implements the CPacket derived classes.
	A CPacket derived object describes the most basic IO operation that is performed.


--*/




#include	"stdinc.h"

#ifdef	CIO_DEBUG
#include	<stdlib.h>		// For Rand() function
#endif

#ifdef	_NO_TEMPLATES_

DECLARE_ORDEREDLISTFUNC( CPacket ) 

#endif


//
//	Module globals 
//
CPool	CBufferAllocator::rgPool[ MAX_BUFFER_SIZES ] ;//!!!How do you give this a signature?
DWORD	CBufferAllocator::rgPoolSizes[ MAX_BUFFER_SIZES ] ;
CBufferAllocator	CBuffer::gAllocator ;
CBufferAllocator*	CSmallBufferCache::BufferAllocator = 0 ;
CBufferAllocator*	CMediumBufferCache::BufferAllocator = 0 ;
CSmallBufferCache*	CBuffer::gpDefaultSmallCache = 0 ;
CMediumBufferCache*	CBuffer::gpDefaultMediumCache = 0  ;

//
//  Control what size buffers the server uses
//
DWORD   cbLargeBufferSize = 33 * 1024 ;
DWORD   cbMediumBufferSize = 4 * 1024 ;
DWORD   cbSmallBufferSize =  512 ;

BOOL
CBufferAllocator::InitClass( ) {
/*++

Routine Description : 

	This function initializes the CBufferAllocator class which handles all 
	memory management of CBuffer objects.
	We will use three different CPools to produce CBuffers of different sizes.

Arguments : 

	None.

Return Value : 

	TRUE if successfull false otherwise !

--*/

	rgPoolSizes[0] = cbSmallBufferSize ;
	rgPoolSizes[1] = cbMediumBufferSize ;
	rgPoolSizes[2] = cbLargeBufferSize ;

	for( int i=0; i< sizeof( rgPoolSizes ) / sizeof( rgPoolSizes[0] ); i++ ) {
		if( !rgPool[i].ReserveMemory(	MAX_BUFFERS / ((i+1)*(i+1)), rgPoolSizes[i] ) ) break ;
	} 		
	
	if( i != sizeof( rgPoolSizes ) / sizeof( rgPoolSizes[0] ) ) {
		for( i--; i!=0; i-- ) {
			rgPool[i].ReleaseMemory() ;
		}
		return	FALSE ;
	}
	return	TRUE ;
}

BOOL
CBufferAllocator::TermClass()	{
/*++

Routine Description : 

	Clean up all the CPool objects we use to manage CBuffer memory

Arguments : 

	None.

Return Value ;

	TRUE if successfull FALSE otherwise.

--*/

	BOOL	fSuccess = TRUE ;
	for( int i=0; i< sizeof( rgPoolSizes ) / sizeof( rgPoolSizes[0] ); i++ ) {
		_ASSERT( rgPool[i].GetAllocCount() == 0 ) ;
		fSuccess &= rgPool[i].ReleaseMemory() ;
	} 		
	return	fSuccess ;
}

LPVOID	
CBufferAllocator::Allocate(	
					DWORD	cb,	
					DWORD&	cbOut 
					) {
/*++

Routine description : 

	Allocate the memory required for a CBuffer object from the CPool which 
	will provide a large enough block of memory.
	We will use a portion of the allocated memory to hold a pointer back to 
	the particular CPool from which this memory was allocated

Arguments : 

	cb -	Number of bytes required
	cbOut -	Number of bytes allocated for the CBuffer

Return Value : 

	Pointer to the allocated block of memory - NULL on failure

--*/

	//cb += sizeof( CBuffer ) ;
	cb += sizeof( CPool* ) ; 

	//_ASSERT(	size == sizeof( CBuffer ) ) ;

	cbOut = 0 ;
	for( int i=0; i<sizeof(rgPoolSizes)/sizeof(rgPoolSizes[0]); i++ ) {
		if( cb < rgPoolSizes[i] ) {
			cbOut = rgPoolSizes[i] - sizeof( CPool * ) ;
			void *pv = rgPool[i].Alloc() ;
			if( pv == 0 ) {
				return	0 ;
			}
			((CPool **)pv)[0] = &rgPool[i] ;
			return	(void *)&(((CPool **)pv)[1]) ;
		}
	}
	_ASSERT( 1==0 ) ;
	return	0 ;
}

void
CBufferAllocator::Release(	
					void*	pv 
					)	{
/*++

Routine description : 

	Release memory that was used for a CBuffer object back to its CPool
	examine the DWORD before the allocated memory to figure out which CPool
	to release this too.

Arguments : 

	pv - the memory being released

Return Value : 

	None.

--*/
	CPool**	pPool = (CPool**)pv ;
	pPool[-1]->Free( (void*)&(pPool[-1]) ) ;
}

#ifdef	DEBUG

//
//	Debug functions - the following functions all do various forms of validation
//	to ensure that memory is being properly manipulated
//

int	
CBufferAllocator::GetPoolIndex(	
						void*	lpv 
						)	{
/*++

Routine Description : 

	figure out which pool this block of memory was allocated out of.

Agruments : 

	lpv - pointer to a block of memory allocated by CBufferAllocator
		when it was allocated we stuck a pointer to the CPool we used 
		ahead of the pointer

Return Value : 

	index of the pool used to allocate the buffer

--*/
	CPool**	pPool = (CPool**)lpv ;
	CPool*	pool = pPool[-1] ;

	for( int i=0; i < sizeof(rgPoolSizes)/sizeof(rgPoolSizes[0]); i++ ) {
		if( pool == &rgPool[i] ) {
			return	i ;
		}
	}
	return	-1 ;
}

void
CBufferAllocator::Erase(	
						void*	lpv 
						) {
/*++

Routine Description : 

	Fill a block of released memory so it is easy to spot during debug.

Arguments : 

	lpv - released memory

Returns : 

	Nothing

--*/

	int	i = GetPoolIndex( lpv ) ;
	_ASSERT( i >= 0 ) ;

	DWORD	cb = rgPoolSizes[i] - sizeof( CPool*) ;
	FillMemory( (BYTE*)lpv, cb, 0xCC ) ;
}

BOOL
CBufferAllocator::EraseCheck(	
						void*	lpv 
						)	{
/*++

Routine Description : 

	Verify that a block of memory has been erased using CBufferAllocator::Erase()

Arguments : 

	lpv - released memory

Returns : 

	TRUE if correctly erased
	FALSE otherwise

--*/
	int	i = GetPoolIndex( lpv ) ;
	_ASSERT( i>=0 ) ;
	
	DWORD	cb = rgPoolSizes[i] - sizeof( CPool* ) ;
	
	for( DWORD	j=sizeof(CPool*); j < cb; j++ ) {
		if(	((BYTE*)lpv)[j] != 0xCC ) 
			return	FALSE ;
	}
	return	TRUE ;
}

BOOL
CBufferAllocator::RangeCheck(	
						void*	lpv 
						)	{
/*++

Routine Description : 

	Check that a block of memory is actually something that 
	we would allocate.  Unfortunately, this is hard to do 
	with the current CPool interface.

Arguments : 

	lpv - block of memory

Return Value : 

	Always TRUE

--*/
	//
	//	Need to modify CPool so we can examine the address range into which objects fall !
	//	
	return	TRUE ;
}

BOOL
CBufferAllocator::SizeCheck(	
						DWORD	cb 
						)	{
/*++

Routine Description : 
	
	Check that we are trying to allocate a size which is legal 
	for this allocater.

Arguments : 

	cb - the requested size

Return Value : 

	TRUE if legit, FALSE otherwise.

--*/
	return	(cb + sizeof( CPool* )) < rgPoolSizes[2] ;
}
#endif	// DEBUG


BOOL	CBuffer::gTerminate = FALSE ;

BOOL
CBuffer::InitClass()	{
/*++

Routine Description : 

	This class initializes the CBufferClass.

Arguemtns : 

	None.

Return Value : 

	TRUE if successfull.

--*/
	gTerminate = FALSE ;
	if( CBufferAllocator::InitClass() )	{
		CSmallBufferCache::InitClass( &gAllocator ) ;
		CMediumBufferCache::InitClass( &gAllocator ) ;

		gpDefaultSmallCache = XNEW	CSmallBufferCache() ;
		gpDefaultMediumCache = XNEW	CMediumBufferCache() ;
		if( gpDefaultSmallCache == 0 ||
			gpDefaultMediumCache == 0 ) {

			if( gpDefaultMediumCache != 0 ) {
				XDELETE	gpDefaultMediumCache ;
				gpDefaultMediumCache = 0 ;
			}
			if( gpDefaultSmallCache != 0 ) {
				XDELETE	gpDefaultSmallCache ;
				gpDefaultSmallCache = 0 ;
			}
			CBufferAllocator::TermClass() ;
			return	gTerminate ;

		}	else	{
			gTerminate = TRUE ;
		}
	}
	return	gTerminate ;
}

BOOL
CBuffer::TermClass()	{
/*++

Routine Description : 

	Terminate the CBuffer class - release everything ever allocated 
	through this class.

Arguments : 

	None.

Return Value : 
	
	TRUE if successfull.

--*/

	if( gpDefaultMediumCache != 0 ) {
		XDELETE	gpDefaultMediumCache ;
		gpDefaultMediumCache = 0 ;
	}
	if( gpDefaultSmallCache != 0 ) {
		XDELETE	gpDefaultSmallCache ;
		gpDefaultSmallCache = 0 ;
	}

	if( !gTerminate ) {
		return	TRUE ;
	}	else	{
		return	CBufferAllocator::TermClass() ;
	}
}

void*
CBuffer::operator	new(	
					size_t	size,	
					DWORD	cb,	
					DWORD	&cbOut,	
					CSmallBufferCache*	pCache,
					CMediumBufferCache*	pMediumCache
					) {
/*++

Routine Description : 

	Allocate a buffer of a specified size, if possible from a Cache.

Arguments : 

	size - size being requested - this will be the size of CBuffer itself as
		generated by the compiler.  not so usefull as we intend m_rgbBuff to 
		be variable sized.
	cb -	Caller provided size - this indicates how big we want the buffer
		to be and tells us we need to allocate a block big support a 
		m_rgbBuff of that size
	cbOut - Out parameter - get the exact sizeof m_rgbBuff that can be 
		accommodated
	pCache - Cache from which to allocate small buffers
	pMediumCache - Cache from which to allocate medium sized buffers

Return Value : 

	pointer to allocated block (NULL on failure).		

--*/

	//
	//	Validate args - default args for pCache and pMediumCache
	//	should ensure these are never NULL
	//
	_ASSERT( pCache != 0 ) ;
	_ASSERT( pMediumCache != 0 ) ;

	cb += sizeof( CBuffer ) ;
	_ASSERT( size == sizeof( CBuffer ) ) ;

	void*	pv = 0 ;
	
	if( cb <= CBufferAllocator::rgPoolSizes[0] )	{
		pv = pCache->Alloc( cb, cbOut ) ;
	}	else if( cb <= CBufferAllocator::rgPoolSizes[1] ) {
		pv = pMediumCache->Alloc( cb, cbOut ) ;
	}	else	{
		pv = gAllocator.Allocate( cb, cbOut ) ;
	}
		
	if( pv != 0 ) {
		cbOut -= sizeof( CBuffer ) ;
	}
	_ASSERT( cbOut >= (cb - sizeof(CBuffer)) )  ;

	return	pv ;
}

void
CBuffer::operator	delete(	
						void*	pv 
						) {
/*++

Routine Description : 

	Release a block of memory allocated to hold a CBuffer object to 
	some place.

Arguments : 

	pv - block of memory being released.

Return Value : 

	none.

--*/

	CPool** pPool = (CPool**)pv ;

	if( pPool[-1] == &CBufferAllocator::rgPool[0] ) 
		gpDefaultSmallCache->Free( pv ) ;
	else if (pPool[-1] == &CBufferAllocator::rgPool[1] )
		gpDefaultMediumCache->Free( pv ) ;
	else
		gAllocator.Release( pv ) ;
}

void
CBuffer::Destroy(	
			CBuffer*	pbuffer,	
			CSmallBufferCache*	pCache 
			) {
	if( pCache == 0 ) {
		delete	pbuffer ;
	}	else	{
		pCache->Free( (void*)pbuffer ) ;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\nntp\server\article\src\timeconv.cpp ===
/* --------------------------------------------------------------------------
	timeconv.cpp
		Functions to perform various time conversion operations.

	Copyright (C) 1994, Microsoft Corporation.
	All rights reserved.

	Author:
		Lindsay Harris - lindsayh

   -------------------------------------------------------------------------- */

//#include "tigris.hxx"
#include "stdinc.h"
#include <stdlib.h>

/*
 *   A handcrafted time zone string to GMT offsets table.  This is not
 *  a very good way to handle this.
 */

static  struct
{
	int		iTZOffset;		// Arithmetic offset from GMT, in seconds.
	char    rgchTZName[ 4 ];	// String representation of time zone.
} _TZ_NAME[] =
{
	{ 0, 		{ 'G', 'M', 'T', '\0' } },
	{ 0, 		{ 'U', 'T', 'C', '\0' } },
	{ 0, 		{ 'U', 'T', '\0', '\0' } },
	{ -14400,	{ 'E', 'D', 'T', '\0' } },
	{ -18000,	{ 'E', 'S', 'T', '\0' } },
	{ -18000,	{ 'C', 'D', 'T', '\0' } },
	{ -21600,	{ 'C', 'S', 'T', '\0' } },
	{ -21600,	{ 'M', 'D', 'T', '\0' } },
	{ -25200,	{ 'M', 'S', 'T', '\0' } },
	{ -25200,	{ 'P', 'D', 'T', '\0' } },
	{ -28800,	{ 'P', 'S', 'T', '\0' } },
	{  43200,	{ 'N', 'Z', 'S', '\0' } },	// NZ standard time.
	{  46800,	{ 'N', 'Z', 'D', '\0' } },
};

#define	NUM_TZ	(sizeof( _TZ_NAME ) / sizeof( _TZ_NAME[ 0 ] ))

// The date Jan 1, 1970 00:00:00 in type FILETIME
#define	ft1970high 27111902
#define	ft1970low 3577643008

static FILETIME ft1970 = {ft1970low, ft1970high};


// The number of FILETIME units (100's of nanoseconds) in a time_t unit (seconds)
#define dFiletimePerDTime_t 10000000

#define BUNCH_FACTOR	  6
#define MESSAGE_ID_SPAN	  64

char MsgIdSet[MESSAGE_ID_SPAN] = {
    'A','B','C','D','E','F','G','H','I','J','K','L','M',
    'N','O','P','Q','R','S','T','U','V','W','X','Y','Z',
    'a','b','c','d','e','f','g','h','i','j','k','l','m',
    'n','o','p','q','r','s','t','u','v','w','x','y','z',
    '0','1','2','3','4','5','6','7','8','9','#','$'
};

/*
 *   English language month table.
 */

static  char  *rgchMonth[ 12 ] =
{
	"Jan", "Feb", "Mar", "Apr", "May", "Jun",
	"Jul", "Aug", "Sep", "Oct", "Nov", "Dec",
};

/*
 *   English language weekday table.
 */

static  char  *rgchDayOfWeek[ 7 ] =
{
	"Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat",
};

/* --------------------------------------------------------------------------
   dwConvertAsciiTime
   	Convert a usenet (unix) style date string into a MOS time value.  There
   	seem to be some variations on this format.  Time returned is GMT/UNC.


   Author:
   	Lindsay Harris - lindsayh

   History:
    13:49 on Thu 31 Mar 1994    -by-    Lindsay Harris   [lindsayh]
   	First version.

   -------------------------------------------------------------------------- */
BOOL
ConvertAsciiTime( char *pchInput, FILETIME	&filetime )
{
	DWORD  dwRet;			// Return value,  0 on error.

	int	   iTZOffset = 0;		// Time zone offset, if it can be decided.

	SYSTEMTIME  tm;			// Result is built in here.


	char  *pchTemp;

	dwRet = 0;

	GetSystemTime(&tm);

	// if less then 2 char long, skip everything and use system time (so we won't read invalid data)
	if( (strlen(pchInput) > 2) && (pchTemp = strchr( pchInput+2, ':' ) ) )
	{
		/*
		 *  Found a colon, which separates hours and minutes.  Probably valid.
		 *  The other part of the test is if the preceeding character is a
		 *  digit which is also preceeded by either a digit or a space char.
		 *  That is,  we have either <digit><digit>: or <space><digit>:
		 */
		// if it's not <space><digit>:<digit><digit> or <digit><digit>:<digit><digit>, skip everything and use system time
		if( isdigit( (UCHAR)*(pchTemp - 1) ) &&
			(isdigit( (UCHAR)*(pchTemp - 2) ) || *(pchTemp - 2) == ' ') &&
			isdigit( (UCHAR)*(pchTemp + 1) ) &&
			isdigit( (UCHAR)*(pchTemp + 2) )
			)
		{
			tm.wHour = (WORD)atoi( pchTemp - 2 );
			tm.wMinute = (WORD)atoi( pchTemp + 1 );

			pchTemp += 3;		// Skip to char after minutes digit.

			if( *pchTemp == ':' )
			{
				tm.wSecond = (WORD)atoi( pchTemp + 1 );
				tm.wMilliseconds = 0;

				pchTemp += 3;			// Skip :ss to first byte past end.
			}
			else
			{
				tm.wSecond = 0;
				tm.wMilliseconds = 0;
			}

			//  Time zone information - much guess work here!
			while( *pchTemp && *pchTemp == ' ' )
					++pchTemp;

			/*
			 *   Sometimes there is a time zone offset encoded.  This starts
			 *  with either a + or - sign or a digit,  having 4 digits in all.
			 *  Otherwise,  presume it is some sort of time zone string,
			 *  of 3 letters and totally ambiguous as to where it is unless
			 *  it happens to be GMT.
			 */

			if( *pchTemp == '-' || *pchTemp == '+' || isdigit( (UCHAR)*pchTemp ) )
			{
				//  Appears to be numeric value.
				int   iSign;

				iSign = *pchTemp == '-' ? -60 : 60;

				if( !isdigit( (UCHAR)*pchTemp ) )
					++pchTemp;				// Skip the sign.

				// if incorrect formatted, skip the timezone adjustment.
				if( isdigit( (UCHAR)*pchTemp ) && isdigit( (UCHAR)*(pchTemp+1) ) &&
					isdigit( (UCHAR)*(pchTemp+2) ) && isdigit( (UCHAR)*(pchTemp+3) ) )
				{
					iTZOffset = (*pchTemp - '0') * 10 + *(pchTemp + 1) - '0';
					pchTemp += 2;
					iTZOffset *= 60;		// Into minutes.
	
					iTZOffset += (*pchTemp - '0') * 10 + *(pchTemp + 1) - '0';

					iTZOffset *= iSign;		// Into seconds.
				}

			}
			else
			{
				int  iIndex;

				iTZOffset = 0;			// Default to GMT if nothing found.
				for( iIndex = 0; iIndex < NUM_TZ; ++iIndex )
				{
					if( !strncmp( pchTemp, _TZ_NAME[ iIndex ].rgchTZName, 3 ) )
					{
						iTZOffset = _TZ_NAME[ iIndex ].iTZOffset;
						break;
					}
				}
			}

			/*
			 *   Now try for the date.  The format is day of month, three
			 *  letter abbreviation of month, then year, as either 2 or 4
			 *  digits.  This is at the start of the string, possibly
			 *  preceeded by a 3 letter day of week with following comma.
			 */

			pchTemp = pchInput;

			// skip over any leading blanks
			while( *pchTemp && *pchTemp == ' ' )
					++pchTemp;

			// make sure we don't pass the end of string
			if( (strlen(pchTemp) > 5) && (*(pchTemp + 3) == ',' ) )
				pchTemp += 5;			// Skip over day + comma + space.

			if( (*pchTemp == ' ' || isdigit( (UCHAR)*pchTemp )) &&
				(*(pchTemp + 1) == ' ' || isdigit( (UCHAR)*(pchTemp + 1) )) )
			{
				//  Looks good, so turn into day of month.

				int   iIndex;


				tm.wDay = 0;
				if( isdigit( (UCHAR)*pchTemp ) )
					tm.wDay = *pchTemp - '0';

				++pchTemp;

				if( isdigit( (UCHAR)*pchTemp ) )
					tm.wDay = tm.wDay * 10 + *pchTemp++ - '0';

				pchTemp++;		// Skip the space before name of month.

				// make sure we have month and a space after it
				if (strlen(pchTemp) >= 4)
				{
					for( iIndex = 0; iIndex < 12; ++iIndex )
					{
						if( strncmp( pchTemp, rgchMonth[ iIndex ], 3 ) == 0 )
						{
							tm.wMonth = iIndex + 1;
							break;
						}
					}
					pchTemp += 4;
					iIndex = atoi( pchTemp );
					if( iIndex < 50 ) {
						iIndex += 2000;
				    	} else if (iIndex < 100) {
				       	iIndex += 1900;
				    	}

					tm.wYear = (WORD)iIndex;
				}

			}

		}

	}

	return	SystemTimeToFileTime( &tm, &filetime ) ;
}



/* -----------------------------------------------------------------------
  GetArpaDate
  	Returns a pointer to static memory containing the current date in
  	Internet/ARPA standard format.

  Author
 	Lindsay Harris	- lindasyh

  History
	13:49 on Wed 20 Apr 1994    -by-    Lindsay Harris   [lindsayh]
  	First version.
	Imported to Tigris. Added passed-in buffer, changed year to 4-digit format

   ----------------------------------------------------------------------- */


char  *
GetArpaDate( char achReturn[ cMaxArpaDate ] )
{

	char    chSign;							// Sign to print.

	DWORD   dwResult;

	int		iBias;							// Offset relative to GMT.

	TIME_ZONE_INFORMATION	tzi;			// Local time zone data.

	SYSTEMTIME	stUTC;						// The current time in UTC/GMT



	dwResult = GetTimeZoneInformation( &tzi );
	GetLocalTime( &stUTC );

	//  Calculate the time zone offset.
	iBias = tzi.Bias;
	if( dwResult == TIME_ZONE_ID_DAYLIGHT )
		iBias += tzi.DaylightBias;

	/*
	 *   We always want to print the sign for the time zone offset, so
	 *  we decide what it is now and remember that when converting.
	 *  The convention is that west of the 0 degree meridian has a
	 *  negative offset - i.e. add the offset to GMT to get local time.
	 */

	if( iBias > 0 )
	{
		chSign = '-';		// Yes, I do mean negative.
	}
	else
	{
		iBias = -iBias;
		chSign = '+';
	}

	/*
	 *    No major trickery here.  We have all the data, so simply
	 *  format it according to the rules on how to do this.
	 */

	_snprintf( achReturn, cMaxArpaDate , "%s, %02d %s %04d %02d:%02d:%02d %c%02d%02d",
			rgchDayOfWeek[stUTC.wDayOfWeek], stUTC.wDay, rgchMonth[ stUTC.wMonth - 1 ],
			stUTC.wYear,
			stUTC.wHour, stUTC.wMinute, stUTC.wSecond, chSign,
			(iBias / 60) % 100, iBias % 60 );

	return achReturn;
}

/* -----------------------------------------------------------------------
  GetMessageIDDate

   ----------------------------------------------------------------------- */


char  *
GetMessageIDDate( DWORD GroupId, DWORD ArticleId, char achReturn[ cMaxMessageIDDate ] )
{
	SYSTEMTIME	stUTC;						// The current time in UTC/GMT
	FILETIME    ftUTC;
	DWORD NumSextets = (sizeof(MsgIdSet) / BUNCH_FACTOR)+1;
	LARGE_INTEGER liMask;
	LARGE_INTEGER liSextet;
	LARGE_INTEGER * pliDate;

#if 0
	GetSystemTime( &stUTC );

	/*
	 *    No major trickery here.  We have all the data, so simply
	 *  format it according to the rules on how to do this.
	 */

	wsprintf( achReturn, "%d%s%d.%02d%02d%02d%04d",
			stUTC.wYear,
			rgchMonth[ stUTC.wMonth - 1 ],
			stUTC.wDay,
			stUTC.wHour,
			stUTC.wMinute,
			stUTC.wSecond,
			stUTC.wMilliseconds);
#endif

	// If articles are created sufficiently close, use the sum of grp and art id to create a difference
	// NOTE: Only 24 bits are taken so that the difference is within 1.6 secs
	DWORD dwGrpArtSuffix = GroupId + ArticleId;
	dwGrpArtSuffix &= 0x00ffffff;

	GetSystemTime( &stUTC );
	SystemTimeToFileTime( &stUTC, &ftUTC );

	liMask.QuadPart = 0x3F;		// Mask to get sextets
	pliDate = (LARGE_INTEGER *) (void *) & ftUTC;

	// add a 24-bit offset that is a function of the group id and article id
	pliDate->QuadPart += dwGrpArtSuffix;

	// For each sextet in the date, lookup a char in the lookup array
	for(DWORD i=0; i<NumSextets; i++)
	{
		liSextet.QuadPart = ( pliDate->QuadPart ) & liMask.QuadPart;
		liSextet.QuadPart >>= i*BUNCH_FACTOR;
		liMask.QuadPart <<= BUNCH_FACTOR;

		_ASSERT( 0 <= liSextet.QuadPart && liSextet.QuadPart <= MESSAGE_ID_SPAN-1 );

		achReturn [i] = MsgIdSet [liSextet.QuadPart];
	}

	achReturn [i] = '\0';

	return achReturn;
}

/* -----------------------------------------------------------------------
  SystemTimeToTime_T
  	Coverts SYSTEMTIME to time_t.

  	Returns 0 if date is before 1970 or -1 if far, far into the future.


  Author
  	Carl Kadie - carlk

  History
	Thu, 15 Dec 1994   -by-    Carl Kadie [carlk]
  	First version.

   ----------------------------------------------------------------------- */

time_t
SystemTimeToTime_T(SYSTEMTIME & st)
{
	FILETIME ft;

	// Convert from SYSTEMTIME to FILETIME
	SystemTimeToFileTime(&st, &ft);

	// If date is before 1970, return 0
	if (filetimeGreaterThan(ft1970, ft))
	{
		return 0;
	} else {
		// Convert from FILETIME to time_t
		ft = filetimeSubtract(ft, ft1970);
		return dTime_tFromDFiletime(ft);
	}
}

/* -----------------------------------------------------------------------
  dTime_tFromDFiletime
	Converts changes in filetimes (dFiletime) to changes in time_ts (dTime_t)

	Do not use to change absolute FILETIME's to absolute time_t's

	Returns -1 if the dFiletime overflows the dTime_t

  Author
  	Carl Kadie - carlk

  History
  	24 March 1995 - by - Carl Kadie [carlk]

   ----------------------------------------------------------------------- */

time_t
dTime_tFromDFiletime(const FILETIME & ft)
{
	_ASSERT(sizeof(LARGE_INTEGER) == sizeof(FILETIME));
	_ASSERT(sizeof(LARGE_INTEGER) == (2 * sizeof(time_t)));

	LARGE_INTEGER * pli = (LARGE_INTEGER *)(void *) &ft;
	LARGE_INTEGER liHold;

	liHold.QuadPart = pli->QuadPart / dFiletimePerDTime_t;

	if (0 == liHold.HighPart)
		return (time_t) liHold.LowPart;
	else
		return (time_t) -1;
}

/* -----------------------------------------------------------------------
  filetimeSubtract
	Subtract two filetimes (or subtract a filetime by a dFiletime)

  Author
  	Carl Kadie - carlk

  History
  	24 March 1995 - by - Carl Kadie [carlk]

   ----------------------------------------------------------------------- */

FILETIME
filetimeSubtract(const FILETIME & ft1, const FILETIME & ft2)
{
	LARGE_INTEGER li;

	LARGE_INTEGER * pli1 = (LARGE_INTEGER *) (void *) & ft1;
	LARGE_INTEGER * pli2 = (LARGE_INTEGER *) (void *) & ft2;

	_ASSERT(0 <= pli1->HighPart && 0 <= pli2->HighPart); //LargeInteger is signed, FILETIME is not

	li.QuadPart = pli1->QuadPart - pli2->QuadPart;

	return *((FILETIME *)(void *)(&li));
}


/* -----------------------------------------------------------------------
  filetimeGreaterThan
	Compare two filetimes

  Author
  	Carl Kadie - carlk

  History
  	24 March 1995 - by - Carl Kadie [carlk]

   ----------------------------------------------------------------------- */

BOOL
filetimeGreaterThan(const FILETIME & ft1, const FILETIME & ft2)
{
    return ((ft1.dwHighDateTime == ft2.dwHighDateTime) && (ft1.dwLowDateTime > ft2.dwLowDateTime)) ||
    		(ft1.dwHighDateTime > ft2.dwHighDateTime);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\nntp\server\cbuffer\stdinc.h ===
#ifndef	_STDINC_H_
#define	_STDINC_H_

//
// disables a browser info warning that breaks the build
//
#pragma warning (disable:4786)

//
// disables redundant warning about / in // comments
//
#pragma warning (disable:4010)

#ifdef __cplusplus
extern "C" {
#endif

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <randfail.h>

#ifdef __cplusplus
};
#endif

#include <smartptr.h>
#include <cpool.h>
#include <xmemwrpr.h>
#include <nntpcons.h>
#include "gcache.h"
#include "cbuffer.h"

#pragma hdrstop

#endif	// _STDINC_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\nntp\server\dirnot\src\cretryq.cxx ===
/*++

   Copyright    (c)    1994    Microsoft Corporation

   Module  Name :

        cretryq.cxx

   Abstract:
		Implements the generic retry queue

   Author:

           Rohan Phillips    ( Rohanp )    18-JAN-1996

   Project:

          SMTP Server DLL

   Functions Exported:


   Revision History:


--*/

/************************************************************
 *     Include Headers
 ************************************************************/

#include "cretryq.hxx"
//#include "timemath.h"

// Calculate timeout in milliseconds from timeout in seconds.
#define TimeToWait(Timeout)   (((Timeout) == INFINITE) ? INFINITE : \
                                (Timeout) * 1000)

CRetryQ::CRetryQ(void) {
	TraceFunctEnterEx((LPARAM)this, "CRetryQ::CRetryQ");

	m_hTimeoutEvent = NULL;
	m_hThreadHandle = NULL;
	m_cEntries = 0;
	m_cTimeOut = INFINITE;
	m_fLongSleep = TRUE;
	m_pLastEntry = NULL;

	//init list and crit sect
	InitializeListHead(&m_leQueueHead);
   	InitializeCriticalSection( &m_csQueue);

	TraceFunctLeaveEx((LPARAM)this);
}

CRetryQ::~CRetryQ() {
	TraceFunctEnterEx((LPARAM)this, "CRetryQ::~CRetryQ");

	DeleteCriticalSection (&m_csQueue);

	TraceFunctLeaveEx((LPARAM)this);
}

void CRetryQ::InsertIntoQueue(CRetryQueueEntry *pEntry) {
	TraceFunctEnterEx((LPARAM)this, "CRetryQ::InsertIntoQueue");

    _ASSERT(pEntry != NULL);

	if (pEntry == NULL) {
		TraceFunctLeaveEx((LPARAM)this);
		return;
	}

#if 0
	// BUGBUG
	if(QuerySmtpInstance()->IsShuttingDown())
	{
		delete MailQEntry;
		TraceFunctLeaveEx((LPARAM)this);
		return;
	}
#endif

	LockList();

	// Insert into the list of entrys to retry/NDR.
	InsertTailList(&m_leQueueHead, pEntry->QueryListEntry());

	// wake up the timeout thread if its been sleeping too long
    if (m_fLongSleep) SetEvent(m_hTimeoutEvent);

	m_cEntries++;

	UnLockList();

	TraceFunctLeaveEx((LPARAM)this);
}

void CRetryQ::RemoveFromQueue(CRetryQueueEntry *pEntry) {
	TraceFunctEnterEx((LPARAM)this, "CRetryQ::RemoveFromQueue");

    _ASSERT(pEntry != NULL);

	if(pEntry == NULL) {
		TraceFunctLeaveEx((LPARAM)this);
		return;
	}

	LockList();

    // Remove from list of connections
    RemoveEntryList(pEntry->QueryListEntry());

    // Decrement count of entries
    m_cEntries--;

	UnLockList();

	TraceFunctLeaveEx((LPARAM)this);
}

void CRetryQ::FlushQueue(void) {
	PLIST_ENTRY pEntry;
	CRetryQueueEntry *pQEntry;

	TraceFunctEnterEx((LPARAM) this, "void CRetryQ::FlushQueue(void)");

    // delete all entries from the list
    while(!IsListEmpty(&m_leQueueHead)) {
		pEntry = RemoveHeadList(&m_leQueueHead);
		pQEntry = CONTAINING_RECORD(pEntry, CRetryQueueEntry, m_le);
		delete pQEntry;
		m_cEntries--;
    }

    TraceFunctLeaveEx((LPARAM) this);
}

void CRetryQ::CleanQueue(void *pvContext) {
	CRetryQueueEntry *pQEntry;

	TraceFunctEnterEx((LPARAM) this, "void CRetryQ::CleanQueue(void *pvContext)");

	LockList();

    PLIST_ENTRY pEntry = m_leQueueHead.Flink;
    while(pEntry != &m_leQueueHead) {
		PLIST_ENTRY pNext = pEntry->Flink;

		pQEntry = CONTAINING_RECORD(pEntry, CRetryQueueEntry, m_le);
		if (pQEntry->MatchesContext(pvContext)) {
			RemoveEntryList(pEntry);
			delete pQEntry;
			m_cEntries--;
		}

		pEntry = pNext;
    }

	UnLockList();

    TraceFunctLeaveEx((LPARAM) this);
}

BOOL CRetryQ::InitializeQueue(DWORD cTimeOut) {
	TraceFunctEnterEx((LPARAM)this, "CRetryQ::InitializeQueue");

	m_cTimeOut = cTimeOut;
	m_fShutdown = FALSE;

	// create the event the thread waits on
	m_hTimeoutEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
	if (!m_hTimeoutEvent) {
		ErrorTrace((LPARAM) NULL, "CreateEvent failed (err=%d)", GetLastError());
		TraceFunctLeaveEx((LPARAM)this);
		return(FALSE);
	}

  	// create the thread that processes things out of the
  	// the queue
  	DWORD ThreadId;
	m_hThreadHandle = CreateThread(NULL, 0, CRetryQ::RetryQueueThread, 
		this, 0, &ThreadId);
  	if (m_hThreadHandle == NULL) {
		ErrorTrace((LPARAM) NULL, "CreateThread failed (err=%d)", GetLastError());
		CloseHandle(m_hTimeoutEvent);
		m_hTimeoutEvent = NULL;
		TraceFunctLeaveEx((LPARAM)this);
	    return FALSE;  		
  	}
   	
	TraceFunctLeaveEx((LPARAM)this);
   	return(TRUE);
}

BOOL CRetryQ::ShutdownQueue(PFN_SHUTDOWN_FN pfnShutdown) {

	DWORD ec;
	TraceFunctEnterEx((LPARAM)this, "CRetryQ::ShutdownQueue");

	// signal that we are shutting down
	m_fShutdown = TRUE;

	// set the event to shutdown the retry thread
	SetEvent(m_hTimeoutEvent);

	for( int i=1; i<=120; i++)
	{
		// wait to get notice that its shutdown
		ec = WaitForSingleObject(m_hThreadHandle, 1000);
		if( pfnShutdown ) {
			(*pfnShutdown)();
		}

		if( WAIT_OBJECT_0 == ec ) break;
	}
	
	if (ec != WAIT_OBJECT_0) {
		ErrorTrace(0, "retry thread hasn't shutdown yet, waiting some more");
		_ASSERT(FALSE);
		ec = WaitForSingleObject(m_hThreadHandle, INFINITE);
		_ASSERT(ec == WAIT_OBJECT_0);
	}

	// remove all items from the queue
	FlushQueue();

	// close handles
	CloseHandle(m_hTimeoutEvent);
	CloseHandle(m_hThreadHandle);

	TraceFunctLeaveEx((LPARAM) this);

	return TRUE;
}

void CRetryQ::ProcessQueue(void) {
	TraceFunctEnterEx((LPARAM)this, "CRetryQ::ProcessQueue");

	PLIST_ENTRY     pEntry = NULL;
	PLIST_ENTRY     pEntryNext = NULL;
	PLIST_ENTRY     pEntryTail = NULL;
	CRetryQueueEntry *pContext = NULL;
	DWORD			NumProcessed = 0;

	// grab the crit sect
	LockList();

	// setup the pointers
	pEntry = m_leQueueHead.Flink,
	m_pLastEntry = m_leQueueHead.Blink;

    // unlock the list
	UnLockList();

	for(; pEntry != &m_leQueueHead; pEntry = pEntryNext) {
		// save the guy in front, in case this guy gets
		// removed from the queue.
		pEntryNext = pEntry->Flink;
		// get the pointer to the full entry class
		pContext = CONTAINING_RECORD(pEntry, CRetryQueueEntry, m_le);

		// process the entry.  if its successful then remove it from the queue
		if (pContext->ProcessEntry()) {
			RemoveFromQueue(pContext);
			delete pContext;
		}

		// If we have just processed the guy who was in the tail
		// of the initial list (there could be more guys added
		// at this point). We exit out of the loop to prevent
		// infinite looping
		if (pEntry == m_pLastEntry) {
			break;
		}

		// during shutdown we need to bail
		if (m_fShutdown) {
			break;
		}
	}
	
	TraceFunctLeaveEx((LPARAM)this);
}

DWORD WINAPI CRetryQ::RetryQueueThread(void *ThisPtr) {
    DWORD        cTimeout = INFINITE; // In seconds
	CRetryQ      *ThisQ = (CRetryQ *) ThisPtr;

	TraceFunctEnterEx((LPARAM) ThisPtr, "RetryQueueThread(LPDWORD param)");

    for(;;) {
        DWORD dwErr = WaitForSingleObject(ThisQ->GetTimeoutEvent(), 
			TimeToWait(cTimeout));

        switch (dwErr) {
            //  Somebody wants us to wake up and do something
	        case WAIT_OBJECT_0:
				// kill the thread if we're shutting down
				if (ThisQ->m_fShutdown) return 0;

				ThisQ->LockList();
				ThisQ->ClearLongSleep();
				ThisQ->UnLockList();

				cTimeout = ThisQ->GetRetryTimeout();

				DebugTrace((LPARAM) ThisQ,
					"Retry thread setting timeout value to %d", cTimeout);

				continue;

	        //
	        //  When there is work to do, we wakeup every x seconds to look at
	        //  the list.  That's what we need to do now.
	        //
	        case WAIT_TIMEOUT:
				// kill the thread if we're shutting down
				if (ThisQ->m_fShutdown) return 0;

				DebugTrace((LPARAM)ThisQ,
					"Retry thread timed out....scanning retry list");
	
	            // We are at a Timeout Interval. Examine and timeout requests.
	            ThisQ->LockList();  // Prevents adding/removing items
	
	            //
	            //  If the list is empty, then turn off timeout processing
	            //  We actually wait for one complete RetryMinute before
	            //   entering the sleep mode.
	            //
	            if (ThisQ->IsQEmpty()) {
	                // We ought to enter long sleep mode.
					ThisQ->SetLongSleep();
	                ThisQ->UnLockList();
	
	                cTimeout = INFINITE;
					DebugTrace(
						(LPARAM)ThisQ, "Retry thread setting timeout value to INFINITE because list is empty");
	                continue;
	            }

				ThisQ->UnLockList();

				//process each item in the queue
				ThisQ->ProcessQueue();

				continue;

	        //
	        //  Somebody must have closed the event, time to leave
	        //
	        default:
				DebugTrace((LPARAM)ThisQ,"Retry thread hit default case error = %d", GetLastError());
				TraceFunctLeaveEx((LPARAM) ThisQ);
	            return 0;
        } // switch
    } 

	_ASSERT(FALSE);
	TraceFunctLeaveEx((LPARAM) ThisQ);
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\nntp\server\dirnot\src\dirnot.cpp ===
#include "dirnot.h"
#include <randfail.h>
#include <dbgtrace.h>
#include <stdio.h>
#include "cretryq.hxx"

CPool*  CDirNotBuffer::g_pDirNotPool = NULL;
CRetryQ *IDirectoryNotification::g_pRetryQ;
PFN_SHUTDOWN_FN IDirectoryNotification::m_pfnShutdown = NULL;

//
// one of these is passed into the retry q for each file that can't be 
// opened
//
class CDirNotRetryEntry : public CRetryQueueEntry {
	public:
		virtual BOOL ProcessEntry(void);
		virtual BOOL MatchesContext(void *pvContext) { return pvContext == m_pDirNot; }
		CDirNotRetryEntry(PVOID pvContext, WCHAR *szPathname, 
			IDirectoryNotification *pDirNot);

	private:
		WCHAR m_szPathname[MAX_PATH + 1];
		IDirectoryNotification *m_pDirNot;
		PVOID m_pvContext;
};

CDirNotRetryEntry::CDirNotRetryEntry(PVOID pvContext,
									 WCHAR *szPathname, 
								     IDirectoryNotification *pDirNot) 
{
	TraceFunctEnter("CDirNotRetryEntry::CDirNotRetryEntry");
	
	_ASSERT(lstrlen(szPathname) <= MAX_PATH);
	lstrcpy(m_szPathname, szPathname);
	_ASSERT(pDirNot != NULL);
	m_pDirNot = pDirNot;
	m_pvContext = pvContext;
	
	TraceFunctLeave();
}

BOOL CDirNotRetryEntry::ProcessEntry(void) {
	TraceFunctEnter("CDirNotRetryEntry::ProcessEntry");

	BOOL f;
	_ASSERT(m_pDirNot != NULL);

	// if the directory notification has been shutdown then we are done
	// here
	if (m_pDirNot->IsShutdown()) {
		TraceFunctLeave();
		return(TRUE);
	}

	f = m_pDirNot->CallCompletionFn(m_pvContext, m_szPathname);
	TraceFunctLeave();
	return f;
}

//
// one of these is stuck onto the retry queue during startup to find 
// files in that pickup 
//
class CDirNotStartupEntry : public CRetryQueueEntry {
	public:
		virtual BOOL ProcessEntry(void);
		virtual BOOL MatchesContext(void *pvContext) { return pvContext == m_pDirNot; }
		CDirNotStartupEntry(IDirectoryNotification *pDirNot);

	private:
		IDirectoryNotification *m_pDirNot;
};

CDirNotStartupEntry::CDirNotStartupEntry(IDirectoryNotification *pDirNot) {
	_ASSERT(pDirNot != NULL);
	m_pDirNot = pDirNot;
}

BOOL CDirNotStartupEntry::ProcessEntry(void) {
	TraceFunctEnter("CDirNotStartupEntry::ProcessEntry");

	_ASSERT(m_pDirNot != NULL);

	// if the directory notification has been shutdown then we are done
	// here
	if (m_pDirNot->IsShutdown()) return TRUE;

	HRESULT hr = m_pDirNot->CallSecondCompletionFn( m_pDirNot );
	if (FAILED(hr)) {
		ErrorTrace(0, "DoFindFile() failed with 0x%x", hr);
	}
	TraceFunctLeave();
	return TRUE;
}

IDirectoryNotification::IDirectoryNotification() {
	m_pAtqContext = NULL;
}

IDirectoryNotification::~IDirectoryNotification() {
	_ASSERT(m_pAtqContext == NULL);
}

HRESULT IDirectoryNotification::GlobalInitialize(DWORD cRetryTimeout, 
												 DWORD cMaxInstances, 
												 DWORD cInstanceSize,
												 PFN_SHUTDOWN_FN pfnShutdown) {
	TraceFunctEnter("IDirectoryNotification::GlobalInitialize");

	// set shutdown fn ptr
	m_pfnShutdown = pfnShutdown;

	// Allocate the cpool object
	CDirNotBuffer::g_pDirNotPool = new CPool( DIRNOT_BUFFER_SIGNATURE );
	if ( NULL == CDirNotBuffer::g_pDirNotPool ) {
	    TraceFunctLeave();
	    return E_OUTOFMEMORY;
	}
	
	// reserve memory for our cpool
	if (!CDirNotBuffer::g_pDirNotPool->ReserveMemory(cMaxInstances, cInstanceSize)) {
		return HRESULT_FROM_WIN32(GetLastError());
	} 

	// create the retry Q
	g_pRetryQ = XNEW CRetryQ;
	if (g_pRetryQ == NULL || !(g_pRetryQ->InitializeQueue(cRetryTimeout))) {
		DWORD ec = GetLastError();
		if (g_pRetryQ != NULL) XDELETE g_pRetryQ;
		ErrorTrace(0, "CRetryQ::InitializeQueue(%lu) failed with %lu", 
			cRetryTimeout, ec);
		CDirNotBuffer::g_pDirNotPool->ReleaseMemory();
		TraceFunctLeave();
		return HRESULT_FROM_WIN32(ec);
	}

	TraceFunctLeave();
	return S_OK;
}

HRESULT IDirectoryNotification::GlobalShutdown(void) {
	TraceFunctEnter("IDirectoryNotification::GlobalShutdown");

	// shutdown the retry Q
	if (!g_pRetryQ->ShutdownQueue( m_pfnShutdown )) {
		ErrorTrace(0, "g_pRetryQ->Shutdown failed with %lu", GetLastError());
		TraceFunctLeave();
		return HRESULT_FROM_WIN32(GetLastError());
	}
	XDELETE g_pRetryQ;
	g_pRetryQ = NULL;

	// release our cpool memory
	if (!CDirNotBuffer::g_pDirNotPool->ReleaseMemory()) {
		return HRESULT_FROM_WIN32(GetLastError());
	} 
	_ASSERT(CDirNotBuffer::g_pDirNotPool->GetAllocCount() == 0);

	if ( CDirNotBuffer::g_pDirNotPool ) delete CDirNotBuffer::g_pDirNotPool;
	CDirNotBuffer::g_pDirNotPool = NULL;

	TraceFunctLeave();
	return S_OK;
}

void IDirectoryNotification::CleanupQueue(void) {
	if (g_pRetryQ) g_pRetryQ->CleanQueue(this);
}

HRESULT IDirectoryNotification::Initialize(WCHAR *pszDirectory, 
										   PVOID pContext,
										   BOOL bWatchSubTree,
										   DWORD dwNotifyFilter,
										   DWORD dwChangeAction,
										   PDIRNOT_COMPLETE_FN pfnComplete,
										   PDIRNOT_SECOND_COMPLETE_FN pfnSecondComplete,
										   BOOL bAppendStartEntry ) 
{
	TraceFunctEnter("IDirectoryNotification::Initialize");
	
	_ASSERT(m_pAtqContext == NULL);

	m_pContext = pContext;
	m_pfnComplete = pfnComplete;
	m_pfnSecondComplete = pfnSecondComplete;
	m_cPathname = lstrlen(pszDirectory);
	m_fShutdown = FALSE;
	m_cPendingIo = 0;
	m_bWatchSubTree = bWatchSubTree;
	m_dwNotifyFilter = dwNotifyFilter;
	m_dwChangeAction = dwChangeAction;

	// get the path to the directory
	if (m_cPathname > MAX_PATH) {
		ErrorTrace(0, "pathname %S is too long", pszDirectory);
		TraceFunctLeave();
		return E_INVALIDARG;
	}
	lstrcpy(m_szPathname, pszDirectory);

	// open the directory
	m_hDir = CreateFile(m_szPathname, FILE_LIST_DIRECTORY, 
						FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
						NULL, OPEN_EXISTING, 
						FILE_FLAG_BACKUP_SEMANTICS | FILE_FLAG_OVERLAPPED,
						NULL);

	if (m_hDir == INVALID_HANDLE_VALUE) {
		ErrorTrace(0, "CreateFile(pszDirectory = %S) failed, ec = %lu", 
			pszDirectory, GetLastError());
		TraceFunctLeave();
		return HRESULT_FROM_WIN32(GetLastError());
	}

	// add the handle to ATQ
	if (!AtqAddAsyncHandle(&m_pAtqContext, NULL, this, 
						   IDirectoryNotification::DirNotCompletion,
						   INFINITE, m_hDir))
	{
		DWORD ec = GetLastError();
		ErrorTrace(0, "AtqAddAsyncHandle failed, ec = %lu", ec);
		CloseHandle(m_hDir);
		m_hDir = INVALID_HANDLE_VALUE;
		m_pAtqContext = NULL;
		TraceFunctLeave();
		return HRESULT_FROM_WIN32(ec);
	}

	// add an entry to the queue to process all of the existing files
	if ( bAppendStartEntry ) {
    	CDirNotStartupEntry *pEntry = XNEW CDirNotStartupEntry(this);
	    if (pEntry == NULL) {
		    ErrorTrace(0, "new pEntry failed", GetLastError());
    		AtqCloseFileHandle(m_pAtqContext);
	    	AtqFreeContext(m_pAtqContext, FALSE);
		    m_pAtqContext = NULL;
    		return E_OUTOFMEMORY;
	    }
    	g_pRetryQ->InsertIntoQueue(pEntry);
    }

	// this is set when its safe to do a shutdown
	m_heNoOutstandingIOs = CreateEvent(NULL, FALSE, FALSE, NULL);
	if (m_heNoOutstandingIOs == NULL) {
		ErrorTrace(0, "m_heOutstandingIOs = CreateEvent() failed, ec = %lu",
			GetLastError());
		AtqCloseFileHandle(m_pAtqContext);
		AtqFreeContext(m_pAtqContext, FALSE);
		m_pAtqContext = NULL;
		return HRESULT_FROM_WIN32(GetLastError());
	}

	// start the directory notification process
	HRESULT hr = PostDirNotification();
	if (FAILED(hr)) {
		ErrorTrace(0, "PostDirNotification() failed with 0x%08x", hr);
		AtqCloseFileHandle(m_pAtqContext);
		m_hDir = INVALID_HANDLE_VALUE;
		AtqFreeContext(m_pAtqContext, FALSE);
		m_pAtqContext = NULL;
	}

	TraceFunctLeave();
	return hr;
}

HRESULT IDirectoryNotification::Shutdown() {
	TraceFunctEnter("IDirectoryNotification::Shutdown");

	_ASSERT(m_pAtqContext != NULL);
	if (m_pAtqContext == NULL) return E_UNEXPECTED;

	m_fShutdown = TRUE;

	// close the handle to the directory. this will cause all of our 
	// outstanding IOs to complete.  when the last one cleans up it sets
	// the event m_heNoOutstandingIOs
	DebugTrace(0, "closing dirnot handle, all dirnot ATQ requests should complete");
	AtqCloseFileHandle(m_pAtqContext);

	// wait for all of the events to complete.  if they timeout then just
	// keep shutting down
	DWORD dw;
	do {
		dw = WaitForSingleObject(m_heNoOutstandingIOs, 500);
		switch (dw) {
			case WAIT_TIMEOUT:
				// give a stop hint
				if ( m_pfnShutdown ) m_pfnShutdown();
				break;
			case WAIT_OBJECT_0:
				// we're done
				break;
			default:
				// this case shouldn't happen
				ErrorTrace(0, "m_heNoOutstandingIOs was never set... GLE = %lu", GetLastError());
				_ASSERT(FALSE);
		}
	} while (dw == WAIT_TIMEOUT);
	CloseHandle(m_heNoOutstandingIOs);
	m_heNoOutstandingIOs = NULL;

	// this is done here to make sure that we don't finish the shutdown
	// phase while a thread might be in DoFindFile.  Once we've passed
	// through this lock all threads in DoFindFile will be aware of 
	// the m_fShutdown flag and won't make any more posts.
	m_rwShutdown.ExclusiveLock();

	// kill the ATQ context
	AtqFreeContext(m_pAtqContext, FALSE);
	m_pAtqContext = NULL;

	m_rwShutdown.ExclusiveUnlock();

	TraceFunctLeave();
	return S_OK;
}

HRESULT IDirectoryNotification::PostDirNotification() {
	TraceFunctEnter("IDirectoryNotification::PostDirNotification");

	_ASSERT(m_pAtqContext != NULL);
	if (m_pAtqContext == NULL) return E_POINTER;

	// don't pend an IO during shutdown
	if (m_fShutdown) return S_OK;

	CDirNotBuffer *pBuffer = new CDirNotBuffer(this);
	if (pBuffer == NULL) {
		TraceFunctLeave();
		return E_OUTOFMEMORY;
	}

	IncPendingIoCount();

	if (!AtqReadDirChanges(m_pAtqContext, pBuffer->GetData(), 
						   pBuffer->GetMaxDataSize(), m_bWatchSubTree, 
						   m_dwNotifyFilter, 
						   &pBuffer->m_Overlapped.Overlapped))
	{
		DWORD ec = GetLastError();
		ErrorTrace(0, "AtqReadDirChanges failed with %lu", ec);
		delete pBuffer;
		DecPendingIoCount();
		TraceFunctLeave();
		return HRESULT_FROM_WIN32(GetLastError());
	}

	return S_OK;
}

VOID IDirectoryNotification::DirNotCompletion(PVOID pvContext, 
											  DWORD cWritten,
									 		  DWORD dwCompletionStatus, 
									 		  OVERLAPPED *lpOverlapped)
{
	TraceFunctEnter("IDirectoryNotification::DirNotCompletion");

	_DIRNOT_OVERLAPPED *pDirNotOverlapped = (_DIRNOT_OVERLAPPED *) lpOverlapped;
	CDirNotBuffer *pBuffer = pDirNotOverlapped->pBuffer;
	IDirectoryNotification *pDirNot = pBuffer->GetParent();

	_ASSERT(pDirNot == (IDirectoryNotification *) pvContext);
	_ASSERT(pDirNot->m_pAtqContext != NULL);

 	if (pDirNot->m_fShutdown) {
		// we want to clean up as quickly as possible during shutdown
		DebugTrace(0, "in shutdown mode, not posting a new dirnot");
	} else if (dwCompletionStatus != NO_ERROR) {
		// we received an error
		ErrorTrace(0, "received error %lu", GetLastError());
	} else if (cWritten > 0) {
		// the directory notification contains filename information

		// repost the directory notification
		_VERIFY((pDirNot->PostDirNotification() == S_OK) || pDirNot->m_fShutdown);

		PFILE_NOTIFY_INFORMATION pInfo = 
			(PFILE_NOTIFY_INFORMATION) pBuffer->GetData();
		while (1) {
			DebugTrace(0, "processing notification");

			// we only care about files added to this directory
			if (pInfo->Action == pDirNot->m_dwChangeAction ) {
				WCHAR szFilename[MAX_PATH + 1];

				lstrcpy(szFilename, pDirNot->m_szPathname);
				memcpy(&szFilename[pDirNot->m_cPathname], 
					pInfo->FileName, pInfo->FileNameLength);
				szFilename[pDirNot->m_cPathname+(pInfo->FileNameLength/2)]=0;
				DebugTrace(0, "file name %S was detected", szFilename);

				//
				// call the user's completion function.  if it fails then
				// insert their entry into the retry so that it can be 
				// called later
				//
				if (!pDirNot->CallCompletionFn(pDirNot->m_pContext, 
											   szFilename))
				{											  
					CDirNotRetryEntry *pEntry = 
						 XNEW CDirNotRetryEntry(pDirNot->m_pContext, szFilename,
							                  pDirNot);
					pDirNot->g_pRetryQ->InsertIntoQueue(pEntry);
				}
			}

			if (pInfo->NextEntryOffset == 0) {
				DebugTrace(0, "no more entries in this notification");
				break;
			}

			pInfo = (PFILE_NOTIFY_INFORMATION) 
				((PCHAR) pInfo + pInfo->NextEntryOffset);
		}
	} else {
	    // no bytes were written, search for files using FindFirstFile
		// BUGBUG - handle failure
		_VERIFY(pDirNot->CallSecondCompletionFn( pDirNot ) == S_OK);
		// now post a new dir change event
		// BUGBUG - handle failure
		_VERIFY((pDirNot->PostDirNotification() == S_OK) || pDirNot->m_fShutdown);
	}

	// delete the buffer that was used for this notification
    delete pBuffer;

	// we decrement only after we've incremented in the above if, so that
	// we only get to 0 pending IOs during shutdown.
	pDirNot->DecPendingIoCount();

	TraceFunctLeave();
}

//
// get a listing of files in the directory.  we can enter this state if there
// were so many new files that they couldn't fit into the buffer passed into
// AtqReadDirChanges
// 
HRESULT IDirectoryNotification::DoFindFile( IDirectoryNotification *pDirNot ) {
	WCHAR szFilename[MAX_PATH + 1];
	HANDLE hFindFile = INVALID_HANDLE_VALUE;
	WIN32_FIND_DATA find;

	TraceFunctEnter("IDirectoryNotification::DoFindFile");

	_ASSERT( pDirNot );

	pDirNot->m_rwShutdown.ShareLock();

	if (pDirNot->m_fShutdown) {
		pDirNot->m_rwShutdown.ShareUnlock();
		TraceFunctLeave();
		return S_OK;
	}

	_ASSERT(pDirNot->m_pAtqContext != NULL);
	if (pDirNot->m_pAtqContext == NULL) {
		pDirNot->m_rwShutdown.ShareUnlock();
		TraceFunctLeave();
		return E_FAIL;
	}

	_ASSERT(pDirNot->m_hDir != INVALID_HANDLE_VALUE);

	// make up the file spec we want to find
	lstrcpy(szFilename, pDirNot->m_szPathname);
	lstrcat(szFilename, TEXT("*"));

	DebugTrace(0, "FindFirstFile on %S", szFilename);

	hFindFile = FindFirstFile(szFilename, &find);
	if (hFindFile == INVALID_HANDLE_VALUE) {
		DWORD ec = GetLastError();
		ErrorTrace(0, "FindFirstFile failed, ec = %lu", ec);
		pDirNot->m_rwShutdown.ShareUnlock();
		TraceFunctLeave();
		return HRESULT_FROM_WIN32(ec);
	}

	do {
		// ignore subdirectories
		if (!(find.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)) {
			// get the full name of the file to return it to the completion
			// function
			lstrcpy(szFilename, pDirNot->m_szPathname);
			lstrcat(szFilename, find.cFileName);

			DebugTrace(0, "file name %S was detected", szFilename);
			pDirNot->m_pfnComplete(pDirNot->m_pContext, szFilename);
		}
	} while (!pDirNot->m_fShutdown && FindNextFile(hFindFile, &find)); 

	// close handle
	FindClose(hFindFile);

	pDirNot->m_rwShutdown.ShareUnlock();
	TraceFunctLeave();
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\nntp\server\newstree\src\grpiter.cpp ===
//
//	grpiter.cpp
//
//	This file contains the implementation of the CGroupIteratorCore class.
//
//


#include	"stdinc.h"
#include	"wildmat.h"

BOOL MatchGroup(LPMULTISZ multiszPatterns, LPSTR lpstrGroup);

CGroupIteratorCore::CGroupIteratorCore( 
						CNewsTreeCore*  pTree,
						CGRPCOREPTR		&pFirst
						) : 
/*++

Routine Description : 

	This builds an iterator that will enumerate all newsgoups
	without doing any wildmat pattern matching.
	We will do secure newsgroup checking however.

Arguments : 

	pFirst - First newsgroup in the list
		Caller must be holding a reference to this so that 
		there is no chance of the newsgroup being destroyed
		untill we can set up our reference 
		(done through a smart pointer)

	fIncludeSecureGroups - 
		if TRUE then include secure newsgroups in iteration.

	CSecurityCtx* pClientLogon - client security context

	BOOL	IsClientSecure	- is client connection secure

Return Value : 

	None.
	
--*/
	m_pTree( pTree ),
	m_multiszPatterns( 0 ),
	m_pCurrentGroup( pFirst ), 
	m_fIncludeSpecial( FALSE ),
	m_cRef(1) 
{

	//
	//	Make sure we start on a valid newsgroup !
	//
	if (pFirst && (pFirst->IsSpecial() || (pFirst->IsDeleted()))) Next();

	if( m_pCurrentGroup ) {
		m_fPastEnd = m_fPastBegin = FALSE ;
	}	else	{
		m_fPastEnd = m_fPastBegin = TRUE ;
	}
}

CGroupIteratorCore::CGroupIteratorCore( 
								CNewsTreeCore*  pTree,
								LPMULTISZ	lpstr,	
								CGRPCOREPTR&	pFirst,
								BOOL		fSpecialGroups
								) :
/*++

Routine Description : 

	Create an interator that will do wildmat pattern matching.

Arguments : 

	lpstr - wildmat patterns
	pFirst - first newsgroup 
	fIncludeSecureGroups - if TRUE include secure SSL only newsgroups
	fSpecialGroups - if TRUE include reserved groups

Return Value : 

	None.

--*/
	m_pTree( pTree ),
	m_multiszPatterns( lpstr ), 
	m_pCurrentGroup( pFirst ), 
	m_fPastEnd( TRUE ),
	m_fIncludeSpecial( fSpecialGroups ),
	m_cRef(1)
{

	//
	//	Check whether the first group is legal
	//
	if (pFirst != 0 && 
	    ((pFirst->IsSpecial() && !m_fIncludeSpecial) ||
		 (pFirst->IsDeleted()) ||
		 (!MatchGroup( m_multiszPatterns, pFirst->GetName())))) 
	{
		Next() ;
	}

	if( m_pCurrentGroup != 0 ) {
		m_fPastEnd = m_fPastBegin = FALSE ;
	}	else	{
		m_fPastEnd = m_fPastBegin = TRUE ;
	}
}

CGroupIteratorCore::~CGroupIteratorCore() {
}

BOOL
CGroupIteratorCore::IsBegin()	{

	BOOL	fRtn = FALSE ;
	if( m_pCurrentGroup == 0 ) 
		fRtn = m_fPastBegin ;
	return	fRtn ;
}

BOOL
CGroupIteratorCore::IsEnd()	{

	BOOL	fRtn = FALSE ;
	if( m_pCurrentGroup == 0 ) 
		fRtn = m_fPastEnd ;
	return	fRtn ;
}

/*++
	
	MatchGroup - 
		
	All negation strings (starting with '!')  must precede other strings.

--*/
BOOL
MatchGroup(	LPMULTISZ	multiszPatterns,	LPSTR lpstrGroup ) {

	Assert( multiszPatterns != 0 ) ;
	
    if( multiszPatterns == 0 ) {
        return  TRUE ;
    }

	LPSTR	lpstrPattern = multiszPatterns ;

	while( *lpstrPattern != '\0' )	{
		if( *lpstrPattern == '!' ) {
			_strlwr( lpstrPattern+1 );
			if( HrMatchWildmat( lpstrGroup, lpstrPattern+1 ) == ERROR_SUCCESS ) {
				return	FALSE ;
			}
		}	else	{
			_strlwr( lpstrPattern );
			if( HrMatchWildmat( lpstrGroup, lpstrPattern ) == ERROR_SUCCESS ) {
				return	TRUE ;
			}
		}
		lpstrPattern += lstrlen( lpstrPattern ) + 1 ;
	}
	return	FALSE ;
};

void
CGroupIteratorCore::NextInternal()	{
/*++

Routine description : 

	This function advances the iterators current group pointer 
	to the next valid newsgroup.

	NOTE: this is called by the constructor to spin past newsgroups with the same prefix
	that are not visible.

Arguments : 

	None.

Return Value : 

	None.

--*/

	CNewsGroupCore*	pTemp  = 0 ;
	LPSTR lpRootGroup = NULL;
	DWORD RootGroupSize = 0;

	_ASSERT( m_pCurrentGroup );

	m_pTree->m_LockTables.ShareLock() ;

	pTemp = m_pCurrentGroup ;
	lpRootGroup = pTemp->GetName();
	RootGroupSize = lstrlen( lpRootGroup );

	// spin past groups with the same prefix
	do {
			pTemp = pTemp->m_pNext ;
	} while( (pTemp && (strstr( pTemp->GetName(), lpRootGroup ) == pTemp->GetName()) && (*(pTemp->GetName()+RootGroupSize) == '.') ) || 
				(pTemp && pTemp->IsDeleted()) );

	// either we are past the end or the current group does not have lpRootGroup as the prefix
	_ASSERT( (pTemp == NULL) ||
				(strstr( pTemp->GetName(), lpRootGroup ) != pTemp->GetName()) ||
				(*(pTemp->GetName()+RootGroupSize) != '.') );

	//
	//	Use a reference counting smart pointer to close windows where the 
	//	newsgroup is destroyed after our call to ShareUnlock().
	//
	CGRPCOREPTR	pPtrTemp = pTemp ;
	_ASSERT( !pPtrTemp || !pPtrTemp->IsDeleted() );

	m_pTree->m_LockTables.ShareUnlock() ;

	//
	//	This could implicity call the destructor for the newsgroup we 
	//	were pointing at - which tries to unlink the newsgroup after 
	//	grabbing the m_LockTables lock exclusively - which is why this
	//	code is outside of the call to ShareLock().
	//
	m_pCurrentGroup = pPtrTemp ;

	if( m_pCurrentGroup != 0 ) {
		m_fPastEnd = m_fPastBegin = FALSE ;
	}	else	{
		m_fPastEnd = TRUE ;
	}
}

void
CGroupIteratorCore::Next()	{
/*++

Routine description : 

	This function advances the iterators current group pointer 
	to the next valid newsgroup.

Arguments : 

	None.

Return Value : 

	None.

--*/

	CNewsGroupCore*	pTemp  = 0 ;

	m_pTree->m_LockTables.ShareLock() ;

	pTemp = m_pCurrentGroup->m_pNext ;

	if( !m_fIncludeSpecial || m_multiszPatterns) {
		while (pTemp != 0 && 
			   ((!m_fIncludeSpecial && pTemp->IsSpecial()) ||
				(pTemp->IsDeleted()) ||
				(m_multiszPatterns && !MatchGroup( m_multiszPatterns, pTemp->GetName())))) 
		{
			pTemp = pTemp->m_pNext ;
		}

		_ASSERT( pTemp == 0 ||
				((!m_fIncludeSpecial && !pTemp->IsSpecial()) ||
				 (m_fIncludeSpecial)) ) ;
	}

	//
	//	Use a reference counting smart pointer to close windows where the 
	//	newsgroup is destroyed after our call to ShareUnlock().
	//
	CGRPCOREPTR	pPtrTemp = pTemp ;
	_ASSERT( !pPtrTemp || !pPtrTemp->IsDeleted() );

	m_pTree->m_LockTables.ShareUnlock() ;

	//
	//	This could implicity call the destructor for the newsgroup we 
	//	were pointing at - which tries to unlink the newsgroup after 
	//	grabbing the m_LockTables lock exclusively - which is why this
	//	code is outside of the call to ShareLock().
	//
	m_pCurrentGroup = pPtrTemp ;

	if( m_pCurrentGroup != 0 ) {
		m_fPastEnd = m_fPastBegin = FALSE ;
	}	else	{
		m_fPastEnd = TRUE ;
	}
}

void
CGroupIteratorCore::Prev()	{
/*++

Routine Description : 

	Find the previous element in the list.

Arguments : 

	None.

Return Value : 

	None.

--*/

	CNewsGroupCore*	pTemp = 0 ;

#if 0
	if( !m_multiszPatterns )	{
#endif
	
	m_pTree->m_LockTables.ShareLock() ;

	pTemp = m_pCurrentGroup->m_pPrev ;

	if( !m_fIncludeSpecial || m_multiszPatterns) {

		while (pTemp != 0 && 
			   ((!m_fIncludeSpecial && pTemp->IsSpecial()) ||
				(pTemp->IsDeleted()) ||
				(m_multiszPatterns && !MatchGroup( m_multiszPatterns, pTemp->GetName())))) 
		{
			pTemp = pTemp->m_pPrev ;
		}

		_ASSERT( pTemp == 0 ||
				((!m_fIncludeSpecial && !pTemp->IsSpecial()) ||
				 (m_fIncludeSpecial)) ) ;
	}

	//
	//	Use a reference counting smart pointer to close windows where the 
	//	newsgroup is destroyed after our call to ShareUnlock().
	//
	CGRPCOREPTR	pPtrTemp = pTemp ;
	_ASSERT( !pPtrTemp || !pPtrTemp->IsDeleted() );

	m_pTree->m_LockTables.ShareUnlock() ;
	//
	//	This could implicity call the destructor for the newsgroup we 
	//	were pointing at - which tries to unlink the newsgroup after 
	//	grabbing the m_LockTables lock exclusively - which is why this
	//	code is outside of the call to ShareLock().
	//
	m_pCurrentGroup = pPtrTemp ;

	if( m_pCurrentGroup != 0 ) {
		m_fPastEnd = m_fPastBegin = FALSE ;
	}	else	{
		m_fPastBegin = TRUE ;
	}
}

HRESULT CGroupIteratorCore::Current(INNTPPropertyBag **ppGroup, INntpComplete *pProtocolComplete ) {
	_ASSERT(ppGroup != NULL);
	if (ppGroup == NULL) return E_INVALIDARG;

	CGRPCOREPTR pGroup = Current();
	if (pGroup == NULL) return HRESULT_FROM_WIN32(ERROR_NOT_FOUND);

	*ppGroup = pGroup->GetPropertyBag();
#ifdef DEBUG
	if ( pProtocolComplete ) ((CNntpComplete*)pProtocolComplete)->BumpGroupCounter();
#endif
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\nntp\server\hash\src\nntphash.cpp ===
/*++

  NNTPHASH.CPP

  This file implements the classes defined in nntphash.h


--*/

#include	<windows.h>
#include	<dbgtrace.h>
#include    <wtypes.h>
#include    <xmemwrpr.h>
#include	"hashmap.h"
#include	"nntpdrv.h"
#include	"nntphash.h"


CCACHEPTR	g_pSharedCache ;

CStoreId CMsgArtMap::g_storeidDefault;
CStoreId CXoverMap::g_storeidDefault;


BOOL
InitializeNNTPHashLibrary(DWORD dwCacheSize )	{

	g_pSharedCache = new	CPageCache() ;	
	if( g_pSharedCache == 0 ) {
		return	FALSE ;
	}
	
    DWORD cPageEntry = 0 ;
    if( dwCacheSize ) {
        //
        //  Given the cache size, calculate the number of pages
        //
	    DWORD	block = dwCacheSize / 4096 ;

	    //
	    //	Now we want that to be divisible evenly by 32
	    //
	    cPageEntry = block & (~(32-1)) ;
    }

	if( !g_pSharedCache->Initialize(cPageEntry) ) {
		g_pSharedCache = 0 ;
		return	FALSE ;
	}

	if( !CHistoryImp::Init() ) {
		g_pSharedCache = 0 ;
		return	FALSE ;
	}
	return	TRUE ;
}

BOOL
TermNNTPHashLibrary()	{

	g_pSharedCache = 0 ;

	return	CHistoryImp::Term() ;

}


HASH_VALUE
INNHash(    LPBYTE  Key,
            DWORD   Length ) {

    return  CHashMap::CRCHash(  Key, Length ) ;

}

DWORD
GetArticleEntrySize( DWORD MsgIdLen )
{
	int cStoreId = 256;		// should have this be an argument, but its only
							// used by rebuild for now - BUGBUG

	return ((FIELD_OFFSET(ART_MAP_ENTRY, rgbStoreId) + 256 + MsgIdLen + 3) & ~3);
}

DWORD GetXoverEntrySize( DWORD VarLen )
{
	return ((sizeof(XOVER_MAP_ENTRY) -1 + (VarLen) + 3) & ~3);
}


CArticleData::CArticleData(WORD	HeaderOffset, WORD HeaderLength,
						   GROUPID PrimaryGroup, ARTICLEID ArticleNo,
						   CStoreId &storeid)	
{
	ZeroMemory( &m_articleData, sizeof( m_articleData ) ) ;
	m_articleData.HeaderOffset = HeaderOffset ;
	m_articleData.HeaderLength =  HeaderLength ;
	m_articleData.PrimaryGroupId = PrimaryGroup ;
	m_articleData.ArticleId = ArticleNo ;
	memcpy(m_articleData.rgbStoreId, storeid.pbStoreId, storeid.cLen);
	m_articleData.cStoreId = storeid.cLen;
}

//
//	Save the key into the hash table
//
LPBYTE CArticleData::Serialize(LPBYTE pbPtr) const {
	BYTE Flags;
	Flags = ARTFLAG_FLAGS_EXIST;

	DWORD cEntrySize = FIELD_OFFSET(ART_MAP_ENTRY, MsgIdLen);
	if (m_articleData.cStoreId > 0) Flags |= ARTFLAG_STOREID;

	memcpy(pbPtr, &m_articleData, cEntrySize);
	*pbPtr = Flags;

	WORD cbMsgLen = *((WORD *) (pbPtr + FIELD_OFFSET(ART_MAP_ENTRY, MsgIdLen)));
	DWORD cStoreIdSize = 0;
	if (m_articleData.cStoreId > 0) {
		DWORD iStoreIdOffset = FIELD_OFFSET(ART_MAP_ENTRY, MsgId) + cbMsgLen;
		cStoreIdSize = sizeof(m_articleData.cStoreId) + m_articleData.cStoreId;

		memcpy(pbPtr + iStoreIdOffset, &(m_articleData.cStoreId), cStoreIdSize);
	}

	return pbPtr + cEntrySize + sizeof(m_articleData.MsgIdLen) + cbMsgLen + cStoreIdSize;
}

//
//	Restore the key from the hash table
//
LPBYTE CArticleData::Restore(LPBYTE pbPtr, DWORD& cbOut) {
	// set these to their defaults since they may not be read
	m_articleData.Flags = 0;
	m_articleData.cStoreId = 0;

	// read the flags byte
	m_articleData.Flags = *pbPtr;

	// compute
	DWORD iEntryOffset = sizeof(m_articleData.Flags);
	DWORD cEntrySize = FIELD_OFFSET(ART_MAP_ENTRY, MsgIdLen);

	// see if there is a flags byte.
	if (!(m_articleData.Flags & ARTFLAG_FLAGS_EXIST)) {
		return RestoreMCIS( pbPtr, cbOut );
	}

	// copy the header length and offset fields
	memcpy(((BYTE *) (&m_articleData)) + 1, pbPtr + iEntryOffset, cEntrySize);

	// there is a store id for us to read
	DWORD cStoreIdData = 0;
	if (m_articleData.Flags & ARTFLAG_STOREID) {
		WORD cbMsgLen = *((WORD *) (pbPtr + FIELD_OFFSET(ART_MAP_ENTRY, MsgIdLen)));
		DWORD iStoreIdOffset = FIELD_OFFSET(ART_MAP_ENTRY, MsgId) + cbMsgLen;
		m_articleData.cStoreId = pbPtr[iStoreIdOffset];
		memcpy(&(m_articleData.rgbStoreId), pbPtr + iStoreIdOffset + 1, m_articleData.cStoreId);
		cStoreIdData = 1 + m_articleData.cStoreId;
	} else {
		m_articleData.cStoreId = 0;
	}

	return pbPtr + iEntryOffset + cEntrySize + cStoreIdData +
			sizeof(m_articleData.MsgIdLen) + m_articleData.MsgIdLen;
}

//
// Restore the key from an MCIS entry
//
LPBYTE CArticleData::RestoreMCIS(LPBYTE pbPtr, DWORD& cbOut ) {

    _ASSERT( pbPtr );
    PMCIS_ART_MAP_ENTRY pMap = PMCIS_ART_MAP_ENTRY( pbPtr );
    DWORD iEntryOffset = 0;
	DWORD cEntrySize = FIELD_OFFSET(ART_MAP_ENTRY, MsgIdLen) - sizeof(m_articleData.Flags);

    //
    // MCIS entries don't have flags
    //

    m_articleData.Flags = 0;

    //
    // MCIS entries don't have store id's
    //

    m_articleData.cStoreId = 0;

    //
    // Copy other members
    //

    m_articleData.HeaderOffset = pMap->HeaderOffset;
    m_articleData.HeaderLength = pMap->HeaderLength;
    m_articleData.PrimaryGroupId = pMap->PrimaryGroupId;
    m_articleData.ArticleId = pMap->ArticleId;
    m_articleData.MsgIdLen = pMap->MsgIdLen;

    return pbPtr + iEntryOffset + cEntrySize + sizeof( m_articleData.MsgIdLen )
                + m_articleData.MsgIdLen;
}

//
//	Return the size of the key
//
DWORD CArticleData::Size() const {
	return sizeof(m_articleData)
		   - sizeof(m_articleData.MsgId) 		// in the key
		   - sizeof(m_articleData.rgbStoreId)	// real size added below
		   + m_articleData.cStoreId;
}

//
//	Verify that the message-id looks legitimate !
//
BOOL CArticleData::Verify(LPBYTE pbContainer, LPBYTE pbPtr, DWORD cb) const {
	return	TRUE;
}

template< class	Key, class OldKey >
DWORD
CMessageIDKey<Key, OldKey>::Hash()	const	{
/*++

Routine Description :

	This function computes the hash value of a Message ID key

Arguments :

	None

Return Value :

	32 bit hash value

--*/

	_ASSERT( m_lpbMessageID != 0 ) ;
	_ASSERT( m_cbMessageID != 0 ) ;

	return	CHashMap::CRCHash( (const BYTE *)m_lpbMessageID, m_cbMessageID ) ;
}

template< class	Key, class OldKey >
BOOL
CMessageIDKey<Key, OldKey>::CompareKeys(	LPBYTE	pbPtr )	const	{
/*++

Routine Description :

	This function compares a key stored within ourselves to
	one that has been serialized into the hash table !

Arguments :

	Pointer to the start of the block of serialized data

Return Value :

	TRUE if the keys match !

--*/


	_ASSERT( m_lpbMessageID != 0 ) ;
	_ASSERT( m_cbMessageID != 0 ) ;
	_ASSERT( pbPtr != 0 ) ;

	Key*	pKey    = (Key*)pbPtr ;
	OldKey* pOldKey = NULL;
	DWORD   dwKeyLen    = 0;
	PVOID   pvKeyPos    = NULL;

	//
	// If we don't match the version, then we'll be degraded to
	// using older version
	//

	if ( !pKey->VersionMatch() ) {
	    pOldKey = (OldKey*)pbPtr;
	    pvKeyPos = pOldKey->KeyPosition();
	    dwKeyLen = pOldKey->KeyLength();
	} else {
	    pvKeyPos = pKey->KeyPosition();
	    dwKeyLen = pKey->KeyLength();
	}

	if( dwKeyLen == m_cbMessageID ) {

		return	memcmp( pvKeyPos, m_lpbMessageID, m_cbMessageID ) == 0 ;

	}
	return	FALSE ;
}

template< class	Key, class OldKey >
LPBYTE
CMessageIDKey<Key, OldKey >::EntryData(	LPBYTE	pbPtr,
							DWORD&	cbKeyOut )	const	{
/*++

Routine Description :

	This function returns a pointer to where the data is
	serialized.  We always return the pointer we were passed
	as we have funky serialization semantics that places
	the key not before the data but somewhere in the middle
	or end.

Arguments :

	pbPtr - Start of serialized hash entyr
	cbKeyOut - returns the size of the key

Return Value :

	Pointer to where the data resides - same as pbPtr

--*/


	_ASSERT( pbPtr != 0 ) ;
	
	Key*	pKey = (Key*)pbPtr ;
	cbKeyOut = pKey->KeyLength() ;

	return	pbPtr ;
}

template< class	Key, class OldKey >
LPBYTE
CMessageIDKey<Key, OldKey>::Serialize(	LPBYTE	pbPtr )	const	{
/*++

Routine Description :

	This function saves a key into the hash table.
	We use functions off of the template type 'Key' to
	determine where we should stick the message id

Arguments :

	pbPtr - Start od where we should serialize to

Return Value :

	same as pbPtr

--*/

	_ASSERT( m_lpbMessageID != 0 ) ;
	_ASSERT(	m_cbMessageID != 0 ) ;
	_ASSERT( pbPtr != 0 ) ;

    //
    // We should always save as new version, so never
    // use the OldKey here
    //
    
	Key*	pKey = (Key*)pbPtr ;

	pKey->KeyLength() = m_cbMessageID ;

	CopyMemory( pKey->KeyPosition(),
				m_lpbMessageID,
				m_cbMessageID ) ;
	return	pbPtr ;
}	

template< class	Key, class OldKey >
LPBYTE
CMessageIDKey<Key, OldKey>::Restore(	LPBYTE	pbPtr, DWORD	&cbOut )		{
/*++

Routine Description :

	This function is called to recover a key from where
	it was Serialize()'d .

Arguments :

	pbPtr - Start of the block of serialized data

Return Value :

	pbPtr if successfull, NULL otherwise

--*/

	_ASSERT( m_lpbMessageID != 0 ) ;
	_ASSERT( m_cbMessageID != 0 ) ;

	Key*	pKey    = (Key*)pbPtr ;
	OldKey* pOldKey = NULL;
	WORD    wKeyLen    = 0;
	PVOID   pvKeyPos    = NULL;

	//
	// If the version mismatches, I should use the OldKey
	//

	if ( !pKey->VersionMatch() ) {
        pOldKey = (OldKey*)pbPtr;
        wKeyLen = pOldKey->KeyLength();
        pvKeyPos = pOldKey->KeyPosition();
    } else {
        wKeyLen = pKey->KeyLength();
        pvKeyPos = pKey->KeyPosition();
    }

	if( wKeyLen <= m_cbMessageID ) {
		CopyMemory( m_lpbMessageID, pvKeyPos, wKeyLen ) ;
		m_cbMessageID = wKeyLen ;
		return	pbPtr ;
	}
	return	0 ;
}

template< class	Key, class OldKey >
DWORD
CMessageIDKey<Key, OldKey>::Size()	const	{
/*++

Routine Description :

	This function retruns the size of the key - which is just
	the number of bytes makeing up the message id.
	The bytes use to hold the serialized length are accounted
	for by the

Arguments :

	None

Return Value :

	32 bit hash value

--*/

	_ASSERT( m_lpbMessageID != 0 ) ;
	_ASSERT( m_cbMessageID != 0 ) ;

	return	m_cbMessageID ;
}

template< class	Key, class OldKey >
BOOL
CMessageIDKey< Key, OldKey >::Verify(	BYTE*	pbContainer, BYTE*	pbData, DWORD	cb )	const	{

	return	TRUE ;

}



typedef	CMessageIDKey< ART_MAP_ENTRY, MCIS_ART_MAP_ENTRY >	ARTICLE_KEY ;
typedef	CMessageIDKey< HISTORY_MAP_ENTRY, HISTORY_MAP_ENTRY >	HISTORY_KEY ;


CMsgArtMap*
CMsgArtMap::CreateMsgArtMap(StoreType st)	{
/*++

Routine Description :

	This function returns a pointer to an object which implements the
	CMsgArtMap interface.

Arguments :

	None

Return Value :

	If successfull a pointer to an object, otherwise NULL.

--*/

	return	new	CMsgArtMapImp() ;
}

CHistory*
CHistory::CreateCHistory(StoreType st)	{
/*++

Routine Description :

	This function returns a pointer to an object which implements the
	CHistory interface.

Arguments :

	None

Return Value :

	If successfull a pointer to an object, otherwise NULL.

--*/


	return	new	CHistoryImp() ;
}

CMsgArtMap::~CMsgArtMap() {
}


CMsgArtMapImp::CMsgArtMapImp()	{
/*++

Routine Description :

	This function constructs an implementation of the CMsgArtMap
	interface - not much for us to do most work happens in base classes.

Arguments :

	None

Return Value :

	None.

--*/
}

CMsgArtMapImp::~CMsgArtMapImp() {
/*++

Routine Description :

	Destroy ourselves - all work done in base classes !

Arguments :

	None

Return Value :

	None

--*/
}


BOOL
CMsgArtMapImp::DeleteMapEntry(	
		LPCSTR	MessageID
		)	{
/*++

Routine Description :

	Remove a Message ID from the hash table !

Arguments :

	MessageID - pointer to the message id to delete

Return Value :

	TRUE if successfully removed !

--*/

	ARTICLE_KEY	key( const_cast<LPSTR>(MessageID), (WORD)lstrlen( MessageID ) ) ;

	return	CHashMap::DeleteMapEntry(	&key ) ;
}

BOOL
CMsgArtMapImp::GetEntryArticleId(
		LPCSTR	MessageID,
		WORD&	HeaderOffset,
		WORD&	HeaderLength,
		ARTICLEID&	ArticleId,
		GROUPID&	GroupId,
		CStoreId	&storeid
		)	{
/*++

Routine Description :

	Get all the information we hold regarding a particular
	Message-ID

Arguments :

	MessageID - message ID to insert
	HeaderOffset - return val gets the offset to the start of
		the Header portion of the article within the file
	HeaderLength - Length of the RFC 822 article header
	ArticleId - the Article Id
	GroupId - the Group Id of the primary article

Return Value :

	TRUE if successfull

--*/

	ARTICLE_KEY	key( (LPSTR)MessageID, (WORD)lstrlen( MessageID ) ) ;

	CArticleData	data ;

	if( LookupMapEntry(	&key,
						&data ) )	{

		HeaderOffset = data.m_articleData.HeaderOffset ;
		HeaderLength = data.m_articleData.HeaderLength ;
		ArticleId = data.m_articleData.ArticleId ;
		GroupId = data.m_articleData.PrimaryGroupId ;
		storeid.cLen = data.m_articleData.cStoreId;
		_ASSERT(storeid.pbStoreId != NULL);
		memcpy(storeid.pbStoreId, data.m_articleData.rgbStoreId, storeid.cLen);
		return	TRUE ;
	}
	return	FALSE ;
}

BOOL
CMsgArtMapImp::Initialize(			
		LPSTR	lpstrArticleFile,
		HASH_FAILURE_PFN	pfn,
		BOOL	fNoBuffering
		)	{
/*++

Routine Description :

	This function initializes the hash table

Arguments :

	lpstrArticleFile - the file in which the hash table is located
	cNumPageEntry - number of PageEntry objects we should use
	pfn - function call back for when things go south

Return Value :

	TRUE if successfull

--*/

	return	CHashMap::Initialize(	lpstrArticleFile,
                                    ART_HEAD_SIGNATURE,
                                    0,
									1,
									g_pSharedCache,
									HASH_VFLAG_PAGE_BASIC_CHECKS,
									pfn,
									0,
									fNoBuffering
									) ;
}

BOOL
CMsgArtMapImp::InsertMapEntry(
		LPCSTR		MessageID,
		WORD		HeaderOffset,
		WORD		HeaderLength,
		GROUPID		PrimaryGroup,
		ARTICLEID	ArticleId,
		CStoreId	&storeid
		)	{
/*++

Routine Description :

	Insert a Message ID and all its associated data

Arguments :

	MessageID - the message id to insert into the table
	HeaderOffset - Offset to the RFC 822 header within its file
	HeaderLength - Length of RFC 822 header
	PrimaryGroup - The id of the group where the article will reside
	ArticleId - the id wihtin the primary group

Return Value :

	TRUE if successfull

--*/

	ARTICLE_KEY	key(	(LPSTR)MessageID, (WORD)lstrlen( MessageID ) ) ;
	CArticleData	data(	HeaderOffset,
							HeaderLength,
							PrimaryGroup,
							ArticleId ,
							storeid
							) ;

	return	CHashMap::InsertMapEntry(
							&key,
							&data,
							TRUE    // Only mark page dirty, don't flush to disk to save WriteFile
							) ;
}

BOOL
CMsgArtMapImp::SetArticleNumber(
		LPCSTR		MessageID,
		WORD		HeaderOffset,
		WORD		HeaderLength,
		GROUPID		PrimaryGroup,
		ARTICLEID	ArticleId,
		CStoreId	&storeid
		)	{
/*++

Routine Description :

	Modify the data associated with a Message ID

Arguments :

	MessageID - the message id to insert into the table
	HeaderOffset - Offset to the RFC 822 header within its file
	HeaderLength - Length of RFC 822 header
	PrimaryGroup - The id of the group where the article will reside
	ArticleId - the id wihtin the primary group

Return Value :

	TRUE if successfull

--*/
	ARTICLE_KEY	key(	(LPSTR)MessageID, (WORD)lstrlen( MessageID ) ) ;
	CArticleData	data(	HeaderOffset,
							HeaderLength,
							PrimaryGroup,
							ArticleId ,
							storeid
							) ;

	return	CHashMap::InsertOrUpdateMapEntry(
							&key,
							&data,
							TRUE
							) ;
}

BOOL
CMsgArtMapImp::SearchMapEntry(
		LPCSTR	MessageID
		)	{
/*++

Routine Description :

	Determine if the MessageID exists in the table

Arguments :

	MessageID - the Message ID to look for

Return Value :

	TRUE if it is found - FALSE and SetLastError() == ERROR_FILE_NOT_FOUND
		if not present in hash table

--*/

	ARTICLE_KEY	key(	const_cast<LPSTR>(MessageID), (WORD)lstrlen( MessageID ) ) ;

	return	CHashMap::Contains(	&key	) ;
}

void
CMsgArtMapImp::Shutdown(
		BOOL	fLocksHeld
		)	{
/*++

Routine Description :

	Terminate the hash table

Arguments :

	None

Return Value :

	None

--*/

	CHashMap::Shutdown( fLocksHeld ) ;

}

DWORD
CMsgArtMapImp::GetEntryCount()	{
/*++

Routine Description :

	Return the number of entries in the hash table

Arguments :

	None

Return Value :

	Number of Message ID's in the table

--*/

	return	CHashMap::GetEntryCount() ;

}

BOOL
CMsgArtMapImp::IsActive() {
/*++

Routine Description :

	Returns TRUE if hash table operational

Arguments :

	None

Return Value :

	TRUE if everything is hunky-dory

--*/

	return	CHashMap::IsActive() ;

}

CHistory::~CHistory()	{
}

BOOL
CHistoryImp::DeleteMapEntry(	
		LPSTR	MessageID
		)	{
/*++

Routine Description :

	Remove a Message ID from the hash table !

Arguments :

	MessageID - pointer to the message id to delete

Return Value :

	TRUE if successfully removed !

--*/

	HISTORY_KEY	key( MessageID, (WORD)lstrlen( MessageID ) ) ;

	return	CHashMap::DeleteMapEntry(	&key ) ;
}

BOOL
CHistoryImp::Initialize(			
		LPSTR	lpstrArticleFile,
		BOOL	fCreateExpirationThread,
		HASH_FAILURE_PFN	pfn,
		DWORD	ExpireTimeInSec,
		DWORD	MaxEntriesToCrawl,
		BOOL	fNoBuffering
		)	{
/*++

Routine Description :

	This function initializes the hash table

Arguments :

	lpstrArticleFile - the file in which the hash table is located
	cNumPageEntry - number of PageEntry objects we should use
	pfn - function call back for when things go south

Return Value :

	TRUE if successfull

--*/

	_ASSERT( ExpireTimeInSec != 0 ) ;
	_ASSERT( MaxEntriesToCrawl != 0 ) ;


	BOOL	fSuccess = CHashMap::Initialize(	lpstrArticleFile,
                                    HIST_HEAD_SIGNATURE,
                                    0,
									8,		// Fraction is set to 8 - we use only 1/8th of the pages
											//	available in the cache !
									g_pSharedCache,
									HASH_VFLAG_PAGE_BASIC_CHECKS,
									pfn,
									0,
									fNoBuffering
									) ;

	if( fSuccess )	{
		m_fExpire = fCreateExpirationThread ;

		m_expireTimeInSec = ExpireTimeInSec ;
		m_maxEntriesToCrawl = MaxEntriesToCrawl ;

	}

	return	fSuccess ;
}

DWORD
CHistoryImp::ExpireTimeInSec()	{


	return	m_expireTimeInSec ;
}

BOOL
CHistoryImp::InsertMapEntry(
		LPCSTR	MessageID,
		PFILETIME	BaseTime
		)	{
/*++

Routine Description :

	Insert a Message ID and all its associated data

Arguments :

	MessageID - the message id to insert into the table
	HeaderOffset - Offset to the RFC 822 header within its file
	HeaderLength - Length of RFC 822 header
	PrimaryGroup - The id of the group where the article will reside
	ArticleId - the id wihtin the primary group

Return Value :

	TRUE if successfull

--*/

	HISTORY_KEY	key(	(LPSTR)MessageID, (WORD)lstrlen( MessageID ) ) ;
	CHistoryData	data(	*((PULARGE_INTEGER)BaseTime) ) ;

	return	CHashMap::InsertMapEntry(
							&key,
							&data
							) ;
}

BOOL
CHistoryImp::SearchMapEntry(
		LPCSTR	MessageID
		)	{
/*++

Routine Description :

	Determine if the MessageID exists in the table

Arguments :

	MessageID - the Message ID to look for

Return Value :

	TRUE if it is found - FALSE and SetLastError() == ERROR_FILE_NOT_FOUND
		if not present in hash table

--*/

	HISTORY_KEY	key(	const_cast<LPSTR>(MessageID), (WORD)lstrlen( MessageID ) ) ;

	return	CHashMap::Contains(	&key	) ;
}

void
CHistoryImp::Shutdown(
		BOOL	fLocksHeld
		)	{
/*++

Routine Description :

	Terminate the hash table

Arguments :

	None

Return Value :

	None

--*/

	EnterCriticalSection( &g_listcrit ) ;

	if( m_pNext != 0 ) 
		m_pNext->m_pPrev = m_pPrev ;
	if( m_pPrev != 0 ) 
		m_pPrev->m_pNext = m_pNext ;
	m_pPrev = 0 ;
	m_pNext = 0 ;
		
	LeaveCriticalSection( &g_listcrit ) ;

	CHashMap::Shutdown( fLocksHeld ) ;

}

DWORD
CHistoryImp::GetEntryCount()	{
/*++

Routine Description :

	Return the number of entries in the hash table

Arguments :

	None

Return Value :

	Number of Message ID's in the table

--*/

	return	CHashMap::GetEntryCount() ;

}

BOOL
CHistoryImp::IsActive() {
/*++

Routine Description :

	Returns TRUE if hash table operational

Arguments :

	None

Return Value :

	TRUE if everything is hunky-dory

--*/

	return	CHashMap::IsActive() ;

}


HANDLE	CHistoryImp::g_hCrawler = 0 ;
DWORD	CHistoryImp::g_crawlerSleepTimeInSec = 30 ;
HANDLE	CHistoryImp::g_hTermination = 0 ;
CRITICAL_SECTION	CHistoryImp::g_listcrit ;
CHistoryList		CHistoryImp::g_listhead ;

BOOL
CHistoryImp::Init( ) {
/*++

Routine Description :

	Initialize globals

Arguments :

	None

Return Value :

	TRUE if everything is hunky-dory

--*/

	_ASSERT( g_hCrawler == 0 ) ;
	_ASSERT( g_hTermination == 0 ) ;
	_ASSERT( g_listhead.m_pNext = &g_listhead ) ;

	InitializeCriticalSection( &g_listcrit ) ;

	return	TRUE ;
}

BOOL
CHistoryImp::Term( ) {
/*++

Routine Description :

	Terminate globals

Arguments :

	None

Return Value :

	TRUE if everything is hunky-dory

--*/

	_ASSERT( g_hCrawler == 0 ) ;
	_ASSERT( g_hTermination == 0 ) ;
	_ASSERT( g_listhead.m_pNext = &g_listhead ) ;

	DeleteCriticalSection( &g_listcrit ) ;

	return	TRUE ;
}

CHistoryImp::CHistoryImp()	:
	m_expireTimeInSec( 0 ),
	m_maxEntriesToCrawl( 0 ),
	m_fExpire( FALSE ),
	m_fContextInitialized( FALSE ) {
/*++

Routine Description :

	Initialize a CHistoryImp object - we put ourselves into a
	doubly linked list of history hash tables so that a background
	thread can do expiration !

Arguments :

	None

Return Value :

	None

--*/

	EnterCriticalSection( &g_listcrit ) ;

	m_pNext = g_listhead.m_pNext ;
	m_pPrev = &g_listhead ;
	g_listhead.m_pNext = this ;
	m_pNext->m_pPrev = this ;
	
	LeaveCriticalSection( &g_listcrit ) ;

}	

CHistoryImp::~CHistoryImp()	{
/*++

Routine Description :

	Destroy a CHistoryImp object - remove it from the list
	of objects needing expiration processing !

Arguments :

	None

Return Value :

	None

--*/

	EnterCriticalSection( &g_listcrit ) ;

	if( m_pNext != 0 ) 
		m_pNext->m_pPrev = m_pPrev ;
	if( m_pPrev != 0 ) 
		m_pPrev->m_pNext = m_pNext ;
	m_pPrev = 0 ;
	m_pNext = 0 ;

	LeaveCriticalSection( &g_listcrit ) ;
}

BOOL
CHistory::StartExpirationThreads(	DWORD	CrawlerSleepTime ) {

	return	CHistoryImp::StartExpirationThreads( CrawlerSleepTime ) ;

}

BOOL
CHistory::TermExpirationThreads()	{

	return	CHistoryImp::TermExpirationThreads() ;

}

BOOL
CHistoryImp::StartExpirationThreads(	DWORD	CrawlerSleepTime	 ) {
/*++

Routine Description :

	Initialize globals

Arguments :

	None

Return Value :

	TRUE if everything is hunky-dory

--*/

	_ASSERT( g_hCrawler == 0 ) ;
	_ASSERT( g_hTermination == 0 ) ;

    //
    // Create termination event
    //
    g_hTermination = CreateEvent( NULL, TRUE, FALSE, NULL );
    if ( g_hTermination == NULL )    {
		return	FALSE ;
    }

    //
    // Create crawler thread
    //
	DWORD	threadId ;

	g_hCrawler = CreateThread(
						NULL,               // attributes
						0,                  // stack size
						CHistoryImp::CrawlerThread,      // thread start
						0,        // param
						0,                  // creation params
						&threadId
						);

	if ( g_hCrawler == NULL )	{
		return	FALSE ;
	}

	return	TRUE ;
}

BOOL
CHistoryImp::TermExpirationThreads( ) {
/*++

Routine Description :

	Terminate globals

Arguments :

	None

Return Value :

	TRUE if everything is hunky-dory

--*/

#if 0
    //  this is all bogus!  It's doing something exactly
    //  like CHistoryImp::Term()!!!
    //  must be having too much beer :):)
	_ASSERT( g_hCrawler == 0 ) ;
	_ASSERT( g_hTermination == 0 ) ;
	_ASSERT( g_listhead.m_pNext = &g_listhead ) ;

	DeleteCriticalSection( &g_listcrit ) ;
#endif

    //
    //  We need to signal the History expiration thread
    //  for termination, if it's created in the first place
    //
    if (g_hCrawler != 0) {
        
        //
        //  This event should be initialized by StartExpirationThreads()
        //  Assert if not, go figure in dbg bld.
        //
        _ASSERT( g_hTermination != 0 );

        if (g_hTermination) {
            
            //
            //  signal the Crawler thread to die.
            //
            SetEvent( g_hTermination );

            //
            // Wait for the crawler to die
            //
            (VOID)WaitForSingleObject( g_hCrawler, INFINITE );

            _VERIFY(CloseHandle(g_hCrawler));
            g_hCrawler = 0;
        }
    }

    //
    //  destroy the event
    //
    if (g_hTermination != 0) {
        
        _VERIFY(CloseHandle(g_hTermination));
        g_hTermination = 0;
    }

	return	TRUE ;
}



DWORD
WINAPI
CHistoryImp::CrawlerThread(
        LPVOID Context
        )
/*++

Routine Description:

    This is the thread which walks history tables expiring articles !

Arguments:

    Context - unused.

Return Value:

    Bogus

--*/
{

    DWORD status;
    DWORD timeout = g_crawlerSleepTimeInSec * 1000;

    //
    // Loop until the termination event is signalled
    //

    while (TRUE) {

        status = WaitForSingleObject(
                            g_hTermination,
                            timeout
                            );

        if (status == WAIT_TIMEOUT) {

            //
            // expire articles
            //

			EnterCriticalSection( &g_listcrit ) ;

			for( CHistoryList*	p = g_listhead.m_pNext;
					p != &g_listhead;
					p = p->m_pNext ) {
				
				p->Expire() ;

			}

			LeaveCriticalSection( &g_listcrit ) ;

		} else if (status == WAIT_OBJECT_0) {

			break;
		} else {
			_ASSERT(FALSE);
			break;
		}
    }
    return 1;

} // CrawlerThread

    //
    // Additional work that needs to be done by the derived class
    // for an entry during a delete
    //
VOID
CHistoryImp::I_DoAuxDeleteEntry(
            IN PMAP_PAGE MapPage,
            IN DWORD EntryOffset
            ) {


	//
	//	When we delete an entry we need to figure out what
	//	the new low is !
	//

	PENTRYHEADER entry = (PENTRYHEADER)GET_ENTRY(MapPage, EntryOffset) ;

	HISTORY_MAP_ENTRY	*pHistory = (PHISTORY_MAP_ENTRY)&entry->Data[0] ;
	ULARGE_INTEGER*	oldestTime = (PULARGE_INTEGER)(&MapPage->Reserved1) ;
	if( pHistory->BaseTime.QuadPart <= oldestTime->QuadPart ||
		oldestTime->HighPart == 0xFFFFFFFF ) {

_ASSERT( oldestTime->QuadPart == pHistory->BaseTime.QuadPart || oldestTime->HighPart == 0xFFFFFFFF ) ;

		oldestTime->HighPart = 0xFFFFFFFF ;

		for( int i=0, entriesScanned=0;
			i < MAX_LEAF_ENTRIES && entriesScanned < MapPage->ActualCount;
			i++ ) {


			SHORT	curEntryOffset = MapPage->Offset[i] ;
			if( curEntryOffset > 0 ) {

				entriesScanned ++ ;

				if( DWORD(curEntryOffset) != EntryOffset ) {

					entry = (PENTRYHEADER)GET_ENTRY(MapPage, curEntryOffset) ;
					pHistory = (PHISTORY_MAP_ENTRY)&entry->Data[0] ;

					if( pHistory->BaseTime.QuadPart < oldestTime->QuadPart )	{

						oldestTime->QuadPart = pHistory->BaseTime.QuadPart ;

					}
				}
			}
		}
	}
#ifdef	_DEBUG
	//
	//	Check that the minimum exists in the page !
	//
	BOOL	fFound = FALSE ;
	int	entriesScanned = 0 ;
	for( int i=0; 
			i < MAX_LEAF_ENTRIES ;
			i++ ) {
		SHORT	curEntryOffset = MapPage->Offset[i] ;
		if( curEntryOffset > 0 ) {

			entriesScanned ++ ;

			if( DWORD(curEntryOffset) != EntryOffset ) {

				entry = (PENTRYHEADER)GET_ENTRY(MapPage, curEntryOffset) ;
				pHistory = (PHISTORY_MAP_ENTRY)&entry->Data[0] ;

				if( pHistory->BaseTime.QuadPart < oldestTime->QuadPart )	{

					_ASSERT( oldestTime->HighPart == 0xFFFFFFFF ) ;

				}	else if( pHistory->BaseTime.QuadPart == oldestTime->QuadPart ) {
					fFound = TRUE ;
				}
			}
		}
	}
	_ASSERT( entriesScanned == MapPage->ActualCount || entriesScanned == MapPage->EntryCount ) ;
	_ASSERT( fFound || oldestTime->HighPart == 0xFFFFFFFF || MapPage->ActualCount == 0  ) ;
#endif
}

VOID
CHistoryImp::I_DoAuxInsertEntry(
            IN PMAP_PAGE MapPage,
            IN DWORD EntryOffset
            ) {

	//
	//	When we delete an entry we need to figure out what
	//	the new low is !
	//

	PENTRYHEADER entry = (PENTRYHEADER)GET_ENTRY(MapPage, EntryOffset) ;

	HISTORY_MAP_ENTRY	*pHistory = (PHISTORY_MAP_ENTRY)&entry->Data[0] ;

	ULARGE_INTEGER*	oldestTime = (PULARGE_INTEGER)(&MapPage->Reserved1) ;
	if( MapPage->ActualCount == 1 ||
		pHistory->BaseTime.QuadPart <= oldestTime->QuadPart ) {

		BOOL	fAccurate = oldestTime->HighPart != 0xFFFFFFFF ;
		oldestTime->QuadPart = pHistory->BaseTime.QuadPart ;

		if( !fAccurate ) {
			for( int i=0, entriesScanned=0; 
				i < MAX_LEAF_ENTRIES && entriesScanned < MapPage->ActualCount;
				i++ ) {
				SHORT	curEntryOffset = MapPage->Offset[i] ;
				if( curEntryOffset > 0 ) {
					entriesScanned ++ ;

					entry = (PENTRYHEADER)GET_ENTRY(MapPage, curEntryOffset) ;
					pHistory = (PHISTORY_MAP_ENTRY)&entry->Data[0] ;
					if( pHistory->BaseTime.QuadPart < oldestTime->QuadPart )	{

						oldestTime->QuadPart = pHistory->BaseTime.QuadPart ;

					}
				}
			}
		}
	}

#ifdef	_DEBUG
	//
	//	Check that the minimum exists in the page !
	//
	BOOL	fFound = FALSE ;
	int	entriesScanned = 0 ;
	for( int i=0; 
			i < MAX_LEAF_ENTRIES ;
			i++ ) {
		SHORT	curEntryOffset = MapPage->Offset[i] ;
		if( curEntryOffset > 0 ) {

			entriesScanned ++ ;

			if( DWORD(curEntryOffset) != EntryOffset ) {

				entry = (PENTRYHEADER)GET_ENTRY(MapPage, curEntryOffset) ;
				pHistory = (PHISTORY_MAP_ENTRY)&entry->Data[0] ;

				if( pHistory->BaseTime.QuadPart < oldestTime->QuadPart )	{

					_ASSERT( FALSE ) ;

				}	else if( pHistory->BaseTime.QuadPart == oldestTime->QuadPart ) {
					fFound = TRUE ;
				}
			}
		}
	}
	_ASSERT( entriesScanned == MapPage->ActualCount || entriesScanned == MapPage->EntryCount ) ;
	_ASSERT( fFound || (MapPage->ActualCount == 1 || MapPage->ActualCount == 0)) ;
#endif


}



//
// Additional work that needs to be done by the derived class
// for an entry during a page split
//
VOID
CHistoryImp::I_DoAuxPageSplit(
            IN PMAP_PAGE OldPage,
            IN PMAP_PAGE NewPage,
            IN PVOID NewEntry
            ) {


	//
	//	In the history table the reserved words keep the smallest
	//	time stamp of any the entries - whatever we put in the new
	//	page during a split the smallest entry will still be
	//	the same !
	//
//	CopyMemory( &NewPage->Reserved1, &OldPage->Reserved1, 
//			sizeof( NewPage->Reserved1 ) * 4 ) ;


	PENTRYHEADER entry = (PENTRYHEADER)NewEntry ;
	HISTORY_MAP_ENTRY	*pHistory = (PHISTORY_MAP_ENTRY)&entry->Data[0] ;

	ULARGE_INTEGER*	oldestTime = (PULARGE_INTEGER)(&NewPage->Reserved1) ;
	if( NewPage->EntryCount == 1 ||
		pHistory->BaseTime.QuadPart <= oldestTime->QuadPart ) {

		oldestTime->QuadPart = pHistory->BaseTime.QuadPart ;
			
	}

#ifdef	_DEBUG
	//
	//	Check that the minimum exists in the page !
	//
	DWORD	EntryOffset = (LPBYTE)NewEntry - (LPBYTE)GET_ENTRY(NewPage,0);
	BOOL	fFound = FALSE ;
	int	entriesScanned = 0 ;
	for( int i=0; 
			i < MAX_LEAF_ENTRIES ;
			i++ ) {
		SHORT	curEntryOffset = NewPage->Offset[i] ;
		if( curEntryOffset > 0 ) {

			entriesScanned ++ ;

			if( DWORD(curEntryOffset) != EntryOffset ) {

				entry = (PENTRYHEADER)GET_ENTRY(NewPage, curEntryOffset) ;
				pHistory = (PHISTORY_MAP_ENTRY)&entry->Data[0] ;

				if( pHistory->BaseTime.QuadPart < oldestTime->QuadPart )	{

					_ASSERT( FALSE ) ;

				}	else if( pHistory->BaseTime.QuadPart == oldestTime->QuadPart ) {
					fFound = TRUE ;
				}
			}
		}
	}
	_ASSERT( entriesScanned == NewPage->ActualCount || entriesScanned == NewPage->EntryCount ) ;
	_ASSERT( fFound || (NewPage->ActualCount == 1 || NewPage->ActualCount == 0)) ;
#endif


}




class	CExpireEnum	:	public	IEnumInterface	{
public :

	DWORD			m_cEntries ;
	ULARGE_INTEGER	m_expireTime ;
	ULARGE_INTEGER	m_oldestTime ;

	CExpireEnum(	ULARGE_INTEGER	expireTime )	:
		m_cEntries( 0 ),
		m_expireTime( expireTime ) {
	}

	BOOL
	ExaminePage(	PMAP_PAGE	page )	{
		ULARGE_INTEGER	*oldestTime = (PULARGE_INTEGER)(&page->Reserved1) ;

		if( (oldestTime->HighPart != 0xFFFFFFFF) &&
			(oldestTime->QuadPart != 0 &&
			oldestTime->QuadPart > m_expireTime.QuadPart) ) {

			m_cEntries += page->ActualCount ;
			
			return	FALSE ;
		}
		return	TRUE ;
	}	

	BOOL
	ExamineEntry(	PMAP_PAGE	page,	LPBYTE	pbPtr )	{

		HISTORY_MAP_ENTRY*	pHistory = (PHISTORY_MAP_ENTRY)pbPtr ;

		if( pHistory->BaseTime.QuadPart < m_oldestTime.QuadPart ) {
			m_oldestTime = pHistory->BaseTime ;
		}

		m_cEntries ++ ;
		if( pHistory->BaseTime.QuadPart > m_expireTime.QuadPart )	{
			return	FALSE ;
		}
		return	TRUE ;
	}
} ;


#define LI_FROM_FILETIME( _pLi, _pFt ) {               \
            (_pLi)->LowPart = (_pFt)->dwLowDateTime;   \
            (_pLi)->HighPart = (_pFt)->dwHighDateTime; \
            }



void
CHistoryImp::Expire()	{
/*++

Routine Description:

    Do the grunt work of expiring stuff out of the history table

Arguments:

    None

Return Value:

    None

--*/



    DWORD status;
    DWORD currentPage = 1;
    ULARGE_INTEGER expireTime;
    ULARGE_INTEGER expireInterval;
    FILETIME fTime;
    DWORD entriesToCrawl;
	DWORD	entries = GetEntryCount() ;

	if( m_fExpire ) {

		if ( entries == 0 ) {
			return ;
		}

		//
		// How many pages to crawl?
		//

		entriesToCrawl = entries >> FRACTION_TO_CRAWL_SHFT;
		if ( entriesToCrawl > (100*m_maxEntriesToCrawl) ) {
			entriesToCrawl = (100*m_maxEntriesToCrawl) ;
		}	else if( entriesToCrawl == 0 ) {
			entriesToCrawl = 100 ;
		}


		expireInterval.QuadPart = m_expireTimeInSec;
		expireInterval.QuadPart *= (ULONGLONG)10 * 1000 * 1000;

		//
		// Compute expiration time
		//

		GetSystemTimeAsFileTime( &fTime );

		LI_FROM_FILETIME( &expireTime, &fTime );
		expireTime.QuadPart -= expireInterval.QuadPart;

		CExpireEnum	enumerator( expireTime) ;

		while( enumerator.m_cEntries <entriesToCrawl	) {

			
			char	szBuff[512] ;
			HISTORY_KEY	key(	szBuff, sizeof( szBuff )  ) ;
			ULARGE_INTEGER	ul ;
			ul.QuadPart = 0 ;
			CHistoryData	data( ul ) ;
			DWORD	cbKey ;
			DWORD	cbData ;
			WORD	words[4] ;
			PULARGE_INTEGER	oldestTime = (PULARGE_INTEGER)&words ; ;

			BOOL	fGetEntry = FALSE ;


			if( !m_fContextInitialized ) {
		
				fGetEntry = CHashMap::GetFirstMapEntry(
											&key,
											cbKey,
											&data,
											cbData,
											&m_ExpireContext,
											&enumerator
											) ;
				m_fContextInitialized = TRUE ;

			}	else	{

				fGetEntry = CHashMap::GetNextMapEntry(
											&key,
											cbKey,
											&data,
											cbData,
											&m_ExpireContext,
											&enumerator
											) ;

			}

			if( !fGetEntry )	{
				
				if( GetLastError() == ERROR_NO_MORE_ITEMS  ) {
					m_fContextInitialized = FALSE ;
				}
				
				break ;

			}	else	{

				//
				//	The enumerator we used already gauranteed that the
				//	entry we are eaxmining is ready to be expired !
				//

				CHashMap::DeleteMapEntry(	&key, TRUE ) ;

			}
		}
	}
}

#if 0

BOOL
CHistory::I_ExpireEntriesInPage(
                    IN DWORD CurrentPage,
                    IN PULARGE_INTEGER ExpireTime
                    )
/*++

Routine Description:

    This routine expires articles in a given page

Arguments:

	HLock - Handle to lock used to hold the page we are examining.
		Need to provide this to FlushPage()
    CurrentPage - Page to expire entries
    ExpireTime - Time to expire

Return Value:

    TRUE - Page processed for expiration.
    FALSE - Cannot get page pointer, means that hash table is inactive.

--*/
{
    PMAP_PAGE mapPage;
    HPAGELOCK hLock;
    DWORD oldCount;
    PULARGE_INTEGER oldestTime;
    DWORD i, entriesScanned;

    ENTER("ExpireEntriesInPage")

    //
    // Get the map pointer
    //

    mapPage = (PMAP_PAGE)GetAndLockPageByNumberNoDirLock(CurrentPage,hLock);
    if ( mapPage == NULL ) {
        LEAVE
        return FALSE;
    }

    //
    // See if there are pages to delete here.  If 0, then
    // we have no entries.
    //

    oldestTime = (PULARGE_INTEGER)&mapPage->Reserved1;

    if ( (oldCount = mapPage->ActualCount) > 0 ) {

        _ASSERT(oldestTime->QuadPart != 0);

        if ( ExpireTime->QuadPart < oldestTime->QuadPart ) {
            DO_DEBUG(HISTORY) {
                DebugTrace(0,"Page %d. Oldest is not old enough\n",CurrentPage);
            }
            goto exit;
        }

    } else {

        DO_DEBUG(HISTORY) {
            DebugTrace(0,"Page %d. No entries for this page\n",CurrentPage);
        }
        goto exit;
    }

    //
    // Look at all entries and see if we can expire any
    //

    oldestTime->LowPart = 0xffffffff;
    oldestTime->HighPart = 0xffffffff;

    for ( i = 0, entriesScanned = 0;
          entriesScanned < oldCount ;
          i++ ) {

        SHORT entryOffset;

        //
        // Get the offset
        //

        entryOffset = mapPage->ArtOffset[i];

        if ( entryOffset > 0 ) {

            PHISTORY_MAP_ENTRY entry;
            entry = (PHISTORY_MAP_ENTRY)GET_ENTRY(mapPage,entryOffset);

            //
            // Expire this entry ?
            //

            entriesScanned++;
            if ( ExpireTime->QuadPart >= entry->BaseTime.QuadPart ) {

                DebugTrace(0,"Expiring page %d entry %d msgId %s\n",
                        CurrentPage, i, entry->MsgId );

                //
                // Set the delete bit.
                //

                mapPage->ArtOffset[i] |= OFFSET_FLAG_DELETED;
                mapPage->ActualCount--;

                //
                // Link this into a chain
                //

                LinkDeletedEntry( mapPage, entryOffset );

            } else {

                //
                // See if this can be the oldest time
                //

                if ( oldestTime->QuadPart > entry->BaseTime.QuadPart ) {
                    oldestTime->QuadPart = entry->BaseTime.QuadPart;
                }
            }
        }
    }

    //
    // set the new
    //

    if ( mapPage->ActualCount == 0 ) {
        oldestTime->QuadPart = 0;
    }

    //
    // Flush
    //

    FlushPage( hLock, mapPage );

    //
    // See if the page needs to be compacted
    //

    if ( mapPage->FragmentedBytes > FRAG_THRESHOLD ) {
        CompactPage(hLock, mapPage);
    }

exit:
    ReleasePageShared(mapPage, hLock);
    LEAVE
    return TRUE;

} // ExpireEntriesInPage
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\nntp\server\hash\src\nntphash.h ===
/*++

  NNTPHASH.H

  Defines the internal types used to implement the NNTP Hash tables !


--*/

#ifndef	_NNTPHASH_H_
#define	_NNTPHASH_H_

#include	"tigtypes.h"
#include	"nntpdrv.h"
#include	"ihash.h"


extern	CCACHEPTR	g_pSharedCache ;

//
// type declarations
//

typedef DWORD HASH_VALUE;
typedef DWORD GROUPID, *PGROUPID;
typedef DWORD ARTICLEID, *PARTICLEID;

#define	INVALID_ARTICLEID	((ARTICLEID)(~0))
const GROUPID NullGroupId = (GROUPID) -1;


//
// manifest constants for hash stuff
//

#define     MAX_MSGID_LEN               255

#define     MAX_XPOST_GROUPS            255

//
// MASK and SIGNATURES
//

#define     DELETE_SIGNATURE            0xCCCC
#define     OFFSET_FLAG_DELETED         0x8000
#define     OFFSET_VALUE_MASK           0x7fff
#define     DEF_HEAD_SIGNATURE          0xdefa1234
#define     CACHE_INFO_SIGNATURE        0xbeef0205
#define     GROUP_LINK_MASK             0x80000000

//
// history map stuff (should be reg settable)
//

#define     DEF_EXPIRE_INTERVAL         (3 * SEC_PER_WEEK) // 1 week
#define     DEF_CRAWLER_WAKEUP_TIME     (30)               // 30 secs
#define     MIN_MAXPAGES_TO_CRAWL       (4)

//
//
// what fraction of total pages to crawl.  1/128 means
// we could cover all the pages in 2 hours.  This is
// expressed in terms of shifts.  7 right shift is 128
//

#define     FRACTION_TO_CRAWL_SHFT      7

//
// Indicates that the space used for this entry has been reclaimed
//

#define     ENTRY_DEL_RECLAIMED         ((WORD)0xffff)

//
// Get pointer given the offset and base
//

#define     GET_ENTRY( _base, _offset ) \
                ((PCHAR)(_base) + (_offset))

//
// See if we need to update the stats in the header page
//

#define     UPDATE_HEADER_STATS( ) { \
            if ( (m_nInsertions + m_nDeletions) >= STAT_FLUSH_THRESHOLD ) { \
                FlushHeaderStats( ); \
            } \
}

//
// Disable auto alignments
//

#ifndef _WIN64		// bugbug
			// Let these get packed by the compiler on WIN64 - this is NOT
			// a good long-term solution because it will make this take up
			// too much space on disk.  We should either reorder the struct
			// for win64 or come up with a way to pack/unpack the data on
			// the way to disk.
#pragma pack(1)
#endif



//
// Page header flags
//

#define PAGE_FLAG_SPLIT_IN_PROGRESS     (WORD)0x0001


//
//
//
// This is the structure of each entry in the leaf pages of the
// MsgId to ArticleID mapping table
//

// flags for article entries
// if the high bit is set then there is a flags word.  otherwise there is

// no flags word and it shouldn't be read
#define		ARTFLAG_FLAGS_EXIST			0x80

// if this is set then there is a storeid
#define 	ARTFLAG_STOREID				0x01

// reserved to say that more flags exist in the future
#define		ARTFLAG_RESERVED			0x40

typedef struct _ART_MAP_ENTRY {
	//
	// if the header offset's high bit is set then these flags are read
	//
	BYTE		Flags;

	//
	//	Offsets into article file - where does the head start ?
	//
	WORD		HeaderOffset ;

	//
	//	Size of the header !
	//
	WORD		HeaderLength ;

    //
    // The primary group of article (where it's actually stored)
    //
    GROUPID     PrimaryGroupId;

    //
    // Article Number in primary group
    //
    ARTICLEID   ArticleId;

    //
    // Length of the message ID (excluding null terminator)
    //
    WORD        MsgIdLen;

    //
    // the message ID goes here when the data is serialized
    //
    CHAR		MsgId[1];

	//
	// the primary store identifier.
	//
	BYTE		cStoreId;
	BYTE		rgbStoreId[256];

	//
	//	Return reference to where the MsgIdLen is stored.
	//
	WORD&		KeyLength()
	{
        return MsgIdLen;
	}

	//
	//	Return pointer to where the MsgId is serialized
	//
	CHAR*		KeyPosition()
	{
        return &MsgId[0];
    }

    //
    // To see if the first byte is the flag, if it's
    // the flag, then we match, otherwise we don't
    //
    BOOL        VersionMatch()
    {
        return ( (Flags & ARTFLAG_FLAGS_EXIST) != 0 );
    }

} ART_MAP_ENTRY, * PART_MAP_ENTRY;

typedef struct MCIS_ART_MAP_ENTRY {

	//
	//	Offsets into article file - where does the head start ?
	//
	WORD		HeaderOffset ;

	//
	//	Size of the header !
	//
	WORD		HeaderLength ;

	//
    // Length of the message ID (excluding null terminator)
    //
    WORD        MsgIdLen;

    //
    // The primary group of article (where it's actually stored)
    //
    GROUPID     PrimaryGroupId;

    //
    // Article Number in primary group
    //
    ARTICLEID   ArticleId;

    //
    // the message ID goes here when the data is serialized
    //
    CHAR		MsgId[1];

	//
	//	Return reference to where the MsgIdLen is stored.
	//
	WORD&		KeyLength()
	{
	        return MsgIdLen;
    }

	//
	//	Return pointer to where the MsgId is serialized
	//
	CHAR*		KeyPosition()
	{
        return &MsgId[0];
	}

	//
	// Check to see if the version matches
	//

	BOOL        VersionMatch()
	{
	    return ( ((*PBYTE(this)) & ARTFLAG_FLAGS_EXIST) == 0 );
	}

} MCIS_ART_MAP_ENTRY, * PMCIS_ART_MAP_ENTRY;

//
//
//
// This is the structure of each entry in the leaf pages of the hash table.
//

typedef struct _HISTORY_MAP_ENTRY {
    //
    // Length of the message ID (excluding null terminator)
    //

    WORD        MsgIdLen;

    //
    // Base file time of the entry.  Used for expiring entry.
    //

    ULARGE_INTEGER  BaseTime;

    //
    // Start of message ID string (null terminated)
    //

    CHAR        MsgId[1];

	//
	//	Return reference to where the MsgIdLen is stored.
	//
	WORD&		KeyLength()	{	return	MsgIdLen ;	}

	//
	//	Return pointer to where the MsgId is serialized
	//
	CHAR*		KeyPosition()	{	return	&MsgId[0] ;	}

	//
	//  We'll always say version match since we don't have backward
	//  compatibility problem
	//

	BOOL        VersionMatch() { return TRUE; }

} HISTORY_MAP_ENTRY, *PHISTORY_MAP_ENTRY;

//
//
//
// This is the structure of each entry in the leaf pages of the hash table.
//

typedef struct _XOVER_MAP_ENTRY {
    //
    // Length of the message ID (excluding null terminator)
    //

    WORD        KeyLen;

    //
    // Time inserted
    //

    FILETIME    FileTime;

	//
	//	Offsets into article file - where does the head start ?
	//
	WORD		HeaderOffset ;

	//
	//	Size of the header !
	//
	WORD		HeaderLength ;

    //
    // Length of xover data
    //

    WORD        XoverDataLen;

    //
    // Additional info about this entry
    //

    BYTE        Flags;

    //
    // Number of xpostings
    //

    BYTE        NumberOfXPostings;

    //
    // Start of variable data
    //

    CHAR        Data[1];

    //
    // Start of xposting list
    //
    //GROUP_ENTRY   XPostings;

    //
    // Start of key (null terminated)
    //
    //
    //CHAR        Key[1];

    //
    // Start of xover data (null terminated)
    //
    //CHAR        XoverData[1];

	WORD&		KeyLength()	{	return	KeyLen ;	}

	CHAR*		KeyPosition(	)	{

		return	Data + NumberOfXPostings*sizeof(GROUP_ENTRY) ;

	}

	BYTE*		XPostingsPosition()	{
		return	(BYTE*)&Data[0] ;
	}

	BYTE*		MessageIDPosition()	{
		return	(BYTE*)(Data + NumberOfXPostings*sizeof(GROUP_ENTRY) + KeyLen) ;
	}

	DWORD		TotalSize()	{
		return	sizeof( _XOVER_MAP_ENTRY ) - 1 + NumberOfXPostings * sizeof( GROUP_ENTRY ) + XoverDataLen + KeyLen ;
	}


} XOVER_MAP_ENTRY, *PXOVER_MAP_ENTRY;


//
// XOVER FLAGS
//

#define XOVER_MAP_PRIMARY       ((BYTE)0x01)
#define	XOVER_IS_NEW			((BYTE)0x02)
#define XOVER_CONTAINS_STOREID	((BYTE)0x04)

//
//
//
// This is the version 2 structure for XOVER_MAP_ENTRY -
//	this structure is used in all released versions
//	of NNTP after K2 Beta3.
//
//	For back compatability - the Flags field must be
//	at the sameoffset as the Flags field in the
//	original XOVER_MAP_ENTRY !
//

typedef struct _XOVER_ENTRY {
	//
	//	This is the GROUPID and ARTICLEID used to look this
	//	entry up in the xover hash table !
	//
	GROUP_ENTRY	Key ;

    //
    // Time inserted
    //
    FILETIME    FileTime;

	//
	//	NOTE
	//
    //
    // Additional info about this entry
    //
    BYTE        Flags;

    //
    // Number of xpostings
    //
    BYTE        NumberOfXPostings;

    //
    // Length of the message ID (excluding null terminator)
    //
    WORD        XoverDataLen;

	//
	//	Offsets into article file - where does the head start ?
	//
	WORD		HeaderOffset ;

	//
	//	Size of the header !
	//
	WORD		HeaderLength ;


    //
    // Start of variable data
    //

    CHAR        Data[1];

    //
    // Start of xposting list
    //
    //GROUP_ENTRY   XPostings;

    //
    // Start of key (null terminated)
    //
    //
    //CHAR        MessageId[1];

	//
	// array of store ids (count is cStoreIds)
	// BYTE		cStoreIds;
	// BYTE		*rgcCrossposts;
	// STOREID	*rgStoreIds;
	//

	BYTE*		XPostingsPosition()	{
		return	(BYTE*)&Data[0] ;
	}

	GROUP_ENTRY*	PrimaryEntry()	{
		_ASSERT( NumberOfXPostings == 1 ) ;
		return	(GROUP_ENTRY*)XPostingsPosition() ;
	}

	BYTE*		MessageIDPosition()	{
		return	(BYTE*)(Data + NumberOfXPostings*sizeof(GROUP_ENTRY)) ;
	}

	BYTE *StoreIdPosition() {
		return MessageIDPosition() + XoverDataLen;
	}

	DWORD		TotalSize()	{
		return	sizeof( _XOVER_ENTRY ) - 1 + NumberOfXPostings * sizeof( GROUP_ENTRY ) + XoverDataLen ;
	}

	BOOL		IsXoverEntry()	{
		return	Flags & XOVER_IS_NEW ;
	}

} XOVER_ENTRY, *PXOVER_ENTRY;


#ifndef _WIN64
#pragma pack()
#endif

#include	"hashmap.h"


template<	class	Key, class OldKey >
class	CMessageIDKey	:	public	IKeyInterface	{
private :

	//
	//	Pointer to a message-id contained within angle brackets '<msg@id>'
	//
	LPSTR	m_lpbMessageID ;

	//
	//	Length of the message-id !
	//
	WORD	m_cbMessageID ;

public :

	//
	//	This constructor is used when we have a key we wish to
	//	serialize !
	//
	CMessageIDKey(	LPSTR	lpbMessageID,
					WORD	cbMessageID
					)	:
		m_lpbMessageID( lpbMessageID ),
		m_cbMessageID( cbMessageID )	{
	}

	//
	//	The public interface required by CHashMap follows
	//

	//
	//	Compute the Hash value of the Key we are holding !
	//
	DWORD	Hash()	const ;

	//
	//	Compare a serialized Message-Id to one that we are holding
	//
	BOOL	CompareKeys(	LPBYTE	pbPtr )	const ;

	//
	//	Determine where the serialized data begins !
	//
	LPBYTE	EntryData(	LPBYTE	pbPtr,
						DWORD&	cbKeyOut
						)	const ;


	//
	//	Save the key into the hash table
	//
	LPBYTE	Serialize(	LPBYTE	pbPtr ) const	;

	//
	//	Restore the key from the hash table
	//
	LPBYTE	Restore(	LPBYTE	pbPtr,
						DWORD&	cbOut
						)	;

	//
	//	Return the size of the key
	//
	DWORD	Size( )	const ;

	//
	//	Verify that the message-id looks legitimate !
	//
	BOOL	Verify( LPBYTE	pbContainer,
					LPBYTE	pbPtr,
					DWORD	cb
					) const ;

} ;


class	CXoverKey : public	IKeyInterface	{
private :

	typedef	XOVER_MAP_ENTRY	Key;

	GROUPID		m_groupid ;
	ARTICLEID	m_articleid ;
	Key*		m_pData ;

	BYTE		m_rgbSerialize[ 40 ] ;
	DWORD		m_cb ;

	CHAR*		SerializeOffset( BYTE *	pb )	const	{
		_ASSERT( m_pData != 0 ) ;
		return	(CHAR*)(m_pData->KeyPosition() - ((CHAR*)m_pData) + (CHAR*)pb) ;
	}

public :

	CXoverKey() ;

	//
	//	This constructor is used when we have a key we wish to
	//	serialize !
	//
	CXoverKey(	GROUPID	groupId,
				ARTICLEID	articleId,
				XOVER_MAP_ENTRY*	data
					)	:
		m_groupid( groupId ),
		m_articleid( articleId ),
		m_pData( data ),
		m_cb( 0 )	{

		m_cb = wsprintf( (char*)m_rgbSerialize, "%lu!%lu", m_groupid, m_articleid);
		m_cb++;
	}

	//
	//	The public interface required by CHashMap follows
	//

	//
	//	Compute the Hash value of the Key we are holding !
	//
	DWORD	Hash()	const ;

	//
	//	Compare a serialized Message-Id to one that we are holding
	//
	BOOL	CompareKeys(	LPBYTE	pbPtr )	const ;

	//
	//	Determine where the serialized data begins !
	//
	LPBYTE	EntryData(	LPBYTE	pbPtr,
						DWORD&	cbKeyOut
						)	const ;


	//
	//	Save the key into the hash table
	//
	LPBYTE	Serialize(	LPBYTE	pbPtr ) const	;

	//
	//	Restore the key from the hash table
	//
	LPBYTE	Restore(	LPBYTE	pbPtr,
						DWORD&	cbOut
						)	;

	//
	//	Return the size of the key
	//
	DWORD	Size( )	const ;

	//
	//	Verify that the message-id looks legitimate !
	//
	BOOL	Verify( LPBYTE	pbContainer,
					LPBYTE	pbPtr,
					DWORD	cb
					) const ;

	//
	//	Placement operator new - let us construct this thing in place !
	//
	void*
	operator	new(	size_t	size,
						LPBYTE	lpb
						) {
		return	lpb ;
	}

} ;

class	CXoverKeyNew :	public	IKeyInterface	{

	BYTE			m_rgbBackLevel[ (sizeof( CXoverKey ) + 16) ] ;

	CXoverKey*		m_pBackLevelKey ;

	class	CXoverKey*
	GetBackLevel()	const	{
		if( m_pBackLevelKey == 0 ) {
			(CXoverKey*)m_pBackLevelKey =
				new( (LPBYTE)m_rgbBackLevel )	CXoverKey(	m_key.GroupId,
															m_key.ArticleId,
															0
															) ;
		}
		return	m_pBackLevelKey ;
	}

public :

	//
	//	Public expose this for people who are using this object
	//	to extract info from the hash tables (i.e. GetNextNovEntry())
	//
	GROUP_ENTRY		m_key ;

	CXoverKeyNew() :
		m_pBackLevelKey( 0 )	{
		m_key.GroupId = INVALID_GROUPID ;
		m_key.ArticleId = INVALID_ARTICLEID ;
	}

	CXoverKeyNew(	GROUPID		group,
					ARTICLEID	article,
					LPVOID		lpvBogus
					)	:
		m_pBackLevelKey( 0 ) {
		m_key.GroupId = group ;
		m_key.ArticleId = article ;
	}

	//
	//	Compute the Hash Value of the key we are holding
	//
	DWORD
	Hash()	const ;

	//
	//	Compare our key to one serialized in the file !
	//
	BOOL
	CompareKeys(	LPBYTE	pbPtr	)	const	{
		PXOVER_ENTRY	px = (PXOVER_ENTRY)pbPtr ;
		if( px->IsXoverEntry() ) {
			return	memcmp( pbPtr, &m_key, sizeof( m_key ) ) == 0 ;
		}
		return	GetBackLevel()->CompareKeys( pbPtr ) ;
	}

	//
	//	Determine where the serialized data begins !
	//
	LPBYTE
	EntryData(	LPBYTE	pbPtr,
				DWORD&	cbKeyOut
				)	const	{
		PXOVER_ENTRY	px = (PXOVER_ENTRY)pbPtr ;
		if( px->IsXoverEntry() )	{
			cbKeyOut = sizeof( m_key ) ;
			return	pbPtr ;
		}
		LPBYTE	lpbReturn = GetBackLevel()->EntryData( pbPtr, cbKeyOut ) ;
		_ASSERT( lpbReturn == pbPtr ) ;
		return	lpbReturn ;
	}

	//
	//	Save the key into the hash table !
	//
	LPBYTE
	Serialize( LPBYTE	pbPtr )		const	{
		PGROUP_ENTRY	pgroup = (PGROUP_ENTRY)pbPtr ;
		*pgroup = m_key ;
		return	pbPtr ;
	}

	//
	//	Restore the key into the hash table !
	//
	LPBYTE
	Restore(	LPBYTE	pbPtr,
				DWORD&	cbOut
				)	{
		PXOVER_ENTRY	px = (PXOVER_ENTRY)pbPtr ;
		if( px->IsXoverEntry() ) {
			m_key = px->Key ;
			cbOut = sizeof( m_key ) ;
			return	pbPtr ;
		}
		return	GetBackLevel()->Restore( pbPtr, cbOut ) ;
	}

	//
	//	Return the size of the key !
	//
	DWORD
	Size()	const	{
		return	sizeof( m_key ) ;
	}

	//
	//	Verify that everything looks legit !
	//
	BOOL
	Verify(	LPBYTE	pbContainer,
			LPBYTE	pbPtr,
			DWORD	cb
			)	const	{
		return	TRUE ;
	}
} ;

class	CXoverData : public	ISerialize	{
/*++

This class deals with XOVER entries in the hash tables as they were formatted in
MCIS 2.0, K2 and NT5 Beta 2.  This class should no longer be used to save
XOVER entries into the hash tables, but only to extract the back level entries
that may remain after upgrade scenarios.

--*/
public :

	XOVER_MAP_ENTRY		m_data ;

	DWORD				m_cGroups ;
	GROUP_ENTRY*		m_pGroups ;

	DWORD				m_cbMessageId ;
	LPSTR				m_pchMessageId ;

	CHAR				m_rgbPrimaryBuff[40] ;
	DWORD				m_cb ;
	BOOL				m_fSufficientBuffer ;

	GROUPID				m_PrimaryGroup ;
	ARTICLEID			m_PrimaryArticle ;
	IExtractObject*		m_pExtractor ;

	//
	//	How do we report failures to Unserialize a buffer -
	//	if this is TRUE then if we cannot hold all the serialized data
	//	that we are getting through a Restore operation, we return
	//	NULL from our Restore() API, otherwise we return a NON-NULL
	//	value, which lets hashmap think we succeeded, but capture
	//	in our internal state data to let us figure out how to retry
	//	and grow buffers to successfully restore the whole item.
	//
	//	We need to distinguish this case when we are doing enumerations !
	//
	BOOL			m_fFailRestore ;


	CXoverData() :
		m_cGroups( 0 ),
		m_pGroups( 0 ),
		m_cbMessageId( 0 ),
		m_pchMessageId( 0 ),
		m_cb( 0 ),
		m_fSufficientBuffer( FALSE ),
		m_pExtractor( 0 )	{

		m_rgbPrimaryBuff[0] = '\0' ;
		ZeroMemory( &m_data, sizeof( m_data ) ) ;
	}


	CXoverData(
			FILETIME		FileTime,
			WORD			HeaderOffset,
			WORD			HeaderLength,
			BYTE			NumberOfXPostings = 0,
			GROUP_ENTRY*	pXPosts = 0,
			DWORD			cbMessageId = 0,
			LPSTR			lpstrMessageId = 0
			) :
		m_cGroups( NumberOfXPostings ),
		m_pGroups( pXPosts ),
		m_cbMessageId( cbMessageId ),
		m_pchMessageId( lpstrMessageId ),
		m_cb( 0 ),
		m_fSufficientBuffer( FALSE ),
		m_pExtractor( 0 )	{

		m_rgbPrimaryBuff[0] = '\0' ;

		m_data.FileTime = FileTime ;
		m_data.HeaderOffset = HeaderOffset ;
		m_data.HeaderLength = HeaderLength ;
		m_data.Flags = XOVER_MAP_PRIMARY ;
		m_data.NumberOfXPostings = NumberOfXPostings ;
		m_data.XoverDataLen = (WORD)cbMessageId ;

	}

	CXoverData(
			FILETIME		FileTime,
			WORD			HeaderOffset,
			WORD			HeaderLength,
			GROUPID			PrimaryGroup,
			ARTICLEID		PrimaryArticle
			)	:
		m_fSufficientBuffer( FALSE ),
		m_pGroups( 0 ),
		m_cGroups( 0 ),
		m_pExtractor( 0 )	{

		m_data.FileTime = FileTime ;
		m_data.HeaderOffset = HeaderOffset ;
		m_data.HeaderLength = HeaderLength ;
		m_data.Flags = 0 ;
		m_data.NumberOfXPostings = 0 ;
		m_data.XoverDataLen = 0 ;

		m_cb = wsprintf( (char*)m_rgbPrimaryBuff, "%lu!%lu", PrimaryGroup, PrimaryArticle ) ;
		m_cb++ ;

		m_data.XoverDataLen = WORD(m_cb) ;
		m_pchMessageId = m_rgbPrimaryBuff ;
		m_cbMessageId = m_cb ;
	}

	//
	//	Save the data into the XOVER hash table !
	//
	LPBYTE
	Serialize(	LPBYTE	pbPtr )	const ;

	//
	//	Restore selected portions of the entry !
	//
	LPBYTE
	Restore(	LPBYTE	pbPtr,
				DWORD&	cbOut	) ;

	//
	//	Return the size required !
	//
	DWORD
	Size()	const ;

	BOOL
	Verify(	LPBYTE	pbContainer,
			LPBYTE	pbPtr,
			DWORD	cb )	const	{

		return	TRUE ;
	}

	//
	//	Placement operator new - let us construct this thing in place !
	//
	void*
	operator	new(	size_t	size,
						LPBYTE	lpb
						) {
		return	lpb ;
	}



} ;

//
//	This class is for reading existing and new format Xover entries !
//
class	CXoverDataNew:	public	ISerialize	{
/*++

This class deals with XOVER entries in the hash tables as they exist in
NT5 Beta3 and NT5 RTM releases.

--*/

	BYTE			m_rgbBackLevel[ (sizeof( CXoverData ) + 16) ] ;

	class	CXoverData*	m_pBackLevelData ;

	class	CXoverData*
	GetBackLevel()	const	{
		if( m_pBackLevelData == 0 ) {
			(CXoverData*)m_pBackLevelData =
				new( (LPBYTE)m_rgbBackLevel )	CXoverData(	) ;
		}
		return	m_pBackLevelData ;
	}

public :

	//
	//	This field gets a copy of the entire fixed portion of the entry !
	//
	XOVER_ENTRY		m_data ;

	//
	//	Fields that get the primary group info !
	//
	GROUPID			m_PrimaryGroup ;
	ARTICLEID		m_PrimaryArticle ;

	//
	//	Points to a buffer to receive the internet Message Id
	//
	LPSTR			m_pchMessageId ;
	DWORD			m_cbMessageId ;

	//
	//	Points to a buffer to get the Cross Posted Information !
	//
	DWORD			m_cGroups ;
	GROUP_ENTRY*	m_pGroups ;

	//
	//	How do we report failures to Unserialize a buffer -
	//	if this is TRUE then if we cannot hold all the serialized data
	//	that we are getting through a Restore operation, we return
	//	NULL from our Restore() API, otherwise we return a NON-NULL
	//	value, which lets hashmap think we succeeded, but capture
	//	in our internal state data to let us figure out how to retry
	//	and grow buffers to successfully restore the whole item.
	//
	//	We need to distinguish this case when we are doing enumerations !
	//
	BOOL			m_fFailRestore ;

	//
	//	Was there enough room to recover all the data we wanted !
	//
	BOOL			m_fSufficientBuffer ;

	//
	//	Variable the recovers the size of the extract Message Id !
	//
	DWORD			m_cb ;

	//
	//	Object which massages results during extraction of XOVER entries !
	//
	IExtractObject*		m_pExtractor ;

	//
	// storeid information
	//
	// length of m_pStoreIds.  in restore only this number of entries will
	// be restored into m_pStoreIds.
	DWORD			m_cStoreIds;
	// array of store ids
	CStoreId		*m_pStoreIds;
	// array of count of crossposts per store id
	BYTE			*m_pcCrossposts;
	// number of store ids in the entry
	DWORD			m_cEntryStoreIds;

	//
	//
	//
	//
	CXoverDataNew(
			LPSTR	lpbMessageId,
			DWORD	cbMessageId,
			GROUP_ENTRY*	pGroups,
			DWORD	cGroups,
			IExtractObject*	pExtractor = 0,
			DWORD	cStoreIds = 0,
			CStoreId *pStoreIds = NULL,
			BYTE	*pcCrossposts = NULL
			)	:
		m_fFailRestore( FALSE ),
		m_pBackLevelData( 0 ),
		m_PrimaryGroup( INVALID_GROUPID ),
		m_PrimaryArticle( INVALID_ARTICLEID ),
		m_pchMessageId( lpbMessageId ),
		m_cbMessageId( cbMessageId ),
		m_pGroups( pGroups ),
		m_cGroups( cGroups ),
		m_fSufficientBuffer( FALSE ),
		m_cb( 0 ),
		m_pExtractor( pExtractor )	,
		m_cStoreIds(cStoreIds),
		m_pStoreIds(pStoreIds),
		m_pcCrossposts(pcCrossposts)
	{
	}


	CXoverDataNew(
			FILETIME		FileTime,
			WORD			HeaderOffset,
			WORD			HeaderLength,
			BYTE			NumberOfXPostings = 0,
			GROUP_ENTRY*	pXPosts = 0,
			DWORD			cbMessageId = 0,
			LPSTR			lpstrMessageId = 0  ,
			DWORD			cStoreIds = 0,
			CStoreId		*pStoreIds = NULL,
			BYTE			*pcCrossposts = NULL
			) :
		m_fFailRestore( FALSE ),
		m_pBackLevelData( 0 ),
		m_PrimaryGroup( INVALID_GROUPID ),
		m_PrimaryArticle( INVALID_ARTICLEID ),
		m_cGroups( NumberOfXPostings ),
		m_pGroups( pXPosts ),
		m_cbMessageId( cbMessageId ),
		m_pchMessageId( lpstrMessageId ),
		m_fSufficientBuffer( FALSE ),
		m_cb( 0 ),
		m_pExtractor( 0 ),
		m_cStoreIds(cStoreIds),
		m_pStoreIds(pStoreIds),
		m_pcCrossposts(pcCrossposts)
	{

		m_data.FileTime = FileTime ;
		m_data.HeaderOffset = HeaderOffset ;
		m_data.HeaderLength = HeaderLength ;
		m_data.Flags = XOVER_MAP_PRIMARY | XOVER_IS_NEW ;
		m_data.NumberOfXPostings = NumberOfXPostings ;
		m_data.XoverDataLen = (WORD)cbMessageId ;
		if (m_cStoreIds > 0) m_data.Flags |= XOVER_CONTAINS_STOREID;

		_ASSERT( m_data.XoverDataLen == m_cbMessageId ) ;

	}

	CXoverDataNew(
			FILETIME		FileTime,
			WORD			HeaderOffset,
			WORD			HeaderLength,
			GROUPID			PrimaryGroup,
			ARTICLEID		PrimaryArticle
			)	:
		m_fFailRestore( FALSE ),
		m_pBackLevelData( 0 ),
		m_PrimaryGroup( PrimaryGroup ),
		m_PrimaryArticle( PrimaryArticle ),
		m_pGroups( 0 ),
		m_cGroups( 0 ),
		m_cbMessageId( 0 ),
		m_pchMessageId( 0 ),
		m_fSufficientBuffer( FALSE ),
		m_cb( 0 ),
		m_pExtractor( 0 ),
		m_cStoreIds(0),
		m_pStoreIds(NULL),
		m_pcCrossposts(NULL)
	{

		m_data.FileTime = FileTime ;
		m_data.HeaderOffset = HeaderOffset ;
		m_data.HeaderLength = HeaderLength ;
		m_data.Flags = XOVER_IS_NEW  ;
		m_data.NumberOfXPostings = 1 ;
		m_data.XoverDataLen = 0 ;

	}


	//
	//	This constructor is used when we are building a
	//	CXoverDataNew object which we will use to retrieve
	//	Xover Data !
	//
	CXoverDataNew()	:
		m_pBackLevelData( 0 ),
		m_PrimaryGroup( INVALID_GROUPID ),
		m_PrimaryArticle( INVALID_ARTICLEID ),
		m_pGroups( 0 ),
		m_cGroups( 0 ),
		m_pchMessageId( 0 ),
		m_cbMessageId( 0 ),
		m_fSufficientBuffer( FALSE ),
		m_fFailRestore(FALSE),
		m_cb( 0 ),
		m_pExtractor( 0 ),
		m_cStoreIds(0),
		m_pStoreIds(NULL),
		m_pcCrossposts(NULL)
	{
	}

	//
	//	Save the data into the XOVER hash table -
	//	this should not be called this class is for extraction ONLY !
	//
	LPBYTE
	Serialize(	LPBYTE	pbPtr )	const ;


	//
	//	Restore selected portions of the entry !
	//
	LPBYTE
	Restore(	LPBYTE	pbPtr,
				DWORD&	cbOut	) ;

	//
	//	Return the size required - should not be
	//	called - this class supports Restore() only !
	//
	DWORD
	Size()	const ;


	//
	//	Verify that the entry looks good !
	//
	BOOL
	Verify(	LPBYTE	pbContainer,
			LPBYTE	pbPtr,
			DWORD	cb )	const	{

		return	TRUE ;
	}

	void CheckStoreIds(void);

} ;




class	CArticleData	:	public	ISerialize	{
public :
	ART_MAP_ENTRY	m_articleData;

	CArticleData() {
		ZeroMemory( &m_articleData, sizeof( m_articleData ) ) ;
	}

	CArticleData(
			WORD		HeaderOffset,
			WORD		HeaderLength,
			GROUPID		PrimaryGroup,
			ARTICLEID	ArticleNo,
			CStoreId	&storeid
			);

	//
	//	Save the key into the hash table
	//
	LPBYTE Serialize(LPBYTE pbPtr) const;

	//
	//	Restore the key from the hash table
	//
	LPBYTE Restore(LPBYTE pbPtr, DWORD& cbOut);

	//
	//	Return the size of the key
	//
	DWORD Size() const;

	//
	//	Verify that the message-id looks legitimate !
	//
	BOOL Verify(LPBYTE pbContainer, LPBYTE pbPtr, DWORD cb) const;

private:

    //
    // Restoring an MCIS entry
    //

    LPBYTE RestoreMCIS(LPBYTE pbPtr, DWORD& cbOut );
};


class	CHistoryData	:	public	ISerialize	{
public :

	HISTORY_MAP_ENTRY	m_historyData ;

	CHistoryData(
			ULARGE_INTEGER	BaseTime
			)	{

		m_historyData.BaseTime = BaseTime ;
	}


	//
	//	Save the key into the hash table
	//
	LPBYTE	Serialize(	LPBYTE	pbPtr ) const	{

		HISTORY_MAP_ENTRY*	pSerialize = (HISTORY_MAP_ENTRY*)pbPtr ;

		pSerialize->BaseTime = m_historyData.BaseTime ;

		return	(BYTE*)pSerialize->KeyPosition() + pSerialize->KeyLength() ;

	}

	//
	//	Restore the key from the hash table
	//
	LPBYTE	Restore(	LPBYTE	pbPtr,
						DWORD&	cbOut
						)	{
		cbOut = sizeof( m_historyData ) ;
		CopyMemory(	&m_historyData, pbPtr, cbOut ) ;
		return	pbPtr + cbOut ;
	}

	//
	//	Return the size of the key
	//
	DWORD	Size( )	const	{
		return	sizeof( m_historyData ) - sizeof( m_historyData.MsgId ) ;
	}

	//
	//	Verify that the message-id looks legitimate !
	//
	BOOL	Verify( LPBYTE	pbContainer,
					LPBYTE	pbPtr,
					DWORD	cb
					) const		{
		return	TRUE ;
	}
} ;


class	CMsgArtMapImp : public	CMsgArtMap,	private	CHashMap	{
public :

	CMsgArtMapImp() ;

	//
	//	Destroy a CMsgArtMap object
	//
	~CMsgArtMapImp() ;

	BOOL
	DeleteMapEntry(
			LPCSTR	MessageID
			) ;

	//
	//	Delete a an entry in the hash table using the MessageID key
	//
	BOOL
	GetEntryArticleId(
			LPCSTR	MessageID,
			WORD&	HeaderOffset,
			WORD&	HeaderLength,
			ARTICLEID&	ArticleId,
			GROUPID&	GroupId,
			CStoreId	&storeid
			) ;

	//
	//	Get all the info we have on a Message ID
	//
	BOOL
	Initialize(
			LPSTR	lpstrArticleFile,
			HASH_FAILURE_PFN	pfn,
			BOOL	fNoBuffering = FALSE
			) ;

	//
	//	Insert an entry into the hash table
	//
	BOOL
	InsertMapEntry(
			LPCSTR		MessageID,
			WORD		HeaderOffset,
			WORD		HeaderLength,
			GROUPID		PrimaryGroup,
			ARTICLEID	ArticleID,
			CStoreId	&storeid
			) ;

	//
	//	Modify an existing entry in the hash ttable
	//
	BOOL
	SetArticleNumber(
			LPCSTR		MessageID,
			WORD		HeaderOffset,
			WORD		HeaderLength,
			GROUPID		Group,
			ARTICLEID	ArticleId,
			CStoreId	&storeid = g_storeidDefault
			);

	//
	//	Check to see if a MessageID is present in the system !
	//
	BOOL
	SearchMapEntry(
			LPCSTR	MessageID
			) ;

	//
	//	Terminate everything
	//
	void
	Shutdown(
			BOOL	fLocksHeld
			) ;

	//
	//	return the number of entries in the hash table
	//
	DWORD
	GetEntryCount() ;

	//
	//	This creates an object conforming to this interface !
	//
	BOOL
	IsActive() ;

} ;

class	CHistoryList	{
public :
	CHistoryList*	m_pNext ;
	CHistoryList*	m_pPrev ;
	CHistoryList()	:
		m_pNext( 0 ), m_pPrev( 0 ) {    m_pNext = this ; m_pPrev = this ; }

	virtual	void
	Expire() {}

} ;

class	CHistoryImp	:	public	CHistory,
						public	CHistoryList,
						private	CHashMap	{
private :

	//
	//	Handle of the thread which expires entries
	//
	static	HANDLE	g_hCrawler ;

	//
	//	Amount of time the crawler thread should sleep between iterations
	//
	static	DWORD	g_crawlerSleepTimeInSec ;

	//
	//	Handle used to stop crawler thread
	//
	static	HANDLE	g_hTermination ;

	//
	//	Critical section which protects doubly linked list
	//	of History Hash Tables
	//
	static	CRITICAL_SECTION	g_listcrit ;

	//
	//	Head of the doubly linked list of history hash tables !
	//
	static	CHistoryList	g_listhead ;

	//
	//	The thread which crawls over history tables doing stuff !
	//
	static	DWORD	WINAPI
	CrawlerThread(	LPVOID	) ;

	//
	//	How long entries last in seconds !
	//
	DWORD	m_expireTimeInSec ;

	//
	//	Number of pages to crawl with each iteration
	//
	DWORD	m_maxEntriesToCrawl ;

	//
	//	if TRUE then we should be expiring entries in this table !
	//
	BOOL	m_fExpire ;

	//
	//	The context we use to walk through expiring stuff !
	//
	CHashWalkContext	m_ExpireContext ;

	//
	//	This bool is used to determine if the m_ExpireContext has been initializsed !
	//
	BOOL	m_fContextInitialized ;

	//
	//	function which expires entries from the history table !
	//
	void
	Expire() ;

    //
    // Additional work that needs to be done by the derived class
    // for an entry during a delete
    //
    VOID I_DoAuxInsertEntry(
                    IN PMAP_PAGE MapPage,
                    IN DWORD EntryOffset
                    ) ;

    //
    // Additional work that needs to be done by the derived class
    // for an entry during a delete
    //
    VOID I_DoAuxDeleteEntry(
                    IN PMAP_PAGE MapPage,
                    IN DWORD EntryOffset
                    ) ;

    //
    // Additional work that needs to be done by the derived class
    // for an entry during a page split
    //
    VOID I_DoAuxPageSplit(
                    IN PMAP_PAGE OldPage,
                    IN PMAP_PAGE NewPage,
                    IN PVOID NewEntry
                    ) ;




public:

	//
	//	This function initializes all of our globals !
	//
	static	BOOL
	Init() ;

	//
	//	This function terminates all of our globals !
	//
	static	BOOL
	Term() ;

	//
	//	This function creates the threads which expire
	//	entries out of all the history tables which may
	//	be created !
	//
	static	BOOL
	StartExpirationThreads(	DWORD	CrawlerSleepTime) ;

	//
	//	This function terminates the threads which expire
	//	entries out of all the history tables which may be
	//	created.
	//
	static	BOOL
	TermExpirationThreads() ;

	//
	//	Construct one of our objects
	//
	CHistoryImp() ;

	//
	//	Destroy the History table
	//
	virtual	~CHistoryImp() ;

	//
	//	amount of time entries last in the history table
	//
	virtual	DWORD
	ExpireTimeInSec() ;


	//
	//	Delete a MessageID from this table
	//
	virtual	BOOL
	DeleteMapEntry(
			LPSTR	MessageID
			) ;

	//
	//	Initialize the Hash table
	//
	virtual	BOOL
	Initialize(
			LPSTR	lpstrArticleFile,
			BOOL	fCreateExpirationThread,
			HASH_FAILURE_PFN	pfn,
			DWORD	ExpireTimeInSec,
			DWORD	MaxEntriesToCrawl,
			BOOL	fNoBuffering = FALSE
			) ;

	//
	//	Insert an entry into the hash table
	//
	virtual	BOOL
	InsertMapEntry(
			LPCSTR	MessageID,
			PFILETIME	BaseTime
			) ;

	//
	//	Check for the presence of a Message ID in the history table
	//
	virtual	BOOL
	SearchMapEntry(
			LPCSTR	MessageID
			) ;

	//
	//	Shutdown the hash table
	//
	virtual	void
	Shutdown(
			BOOL	fLocksHeld
			) ;

	//
	//	Return the number of entries in the hash table
	//
	virtual	DWORD
	GetEntryCount() ;

	//
	//	Is the hash table initialized and functional ?
	//
	virtual	BOOL
	IsActive() ;
} ;


class	CXoverMapIteratorImp : public	CXoverMapIterator	{
private :
	//
	//	No copying allowed !
	//
	CXoverMapIteratorImp( CXoverMapIteratorImp& ) ;
	CXoverMapIteratorImp&	operator=( CXoverMapIteratorImp ) ;

protected :
	//
	//	CXoverMapImp is our friend, and does all of our
	//	creation etc... !
	//
	friend class	CXoverMapImp ;
	//
	//	This keeps track of our location in the base table !
	//
	CHashWalkContext	m_IteratorContext ;

	//
	//	All member's protected, since you can only use us indirectly
	//	through GetFirstNovEntry, GetNextNovEntry()
	//
	CXoverMapIteratorImp()	{}

}  ;


//
//	Specify the interface used to access data in the XOVER hash table
//
//
class	CXoverMapImp : public	CXoverMap, private	CHashMap	{
public :

	//
	//	Destructor is virtual because most work done in a derived class
	//
	~CXoverMapImp() ;

	//
	//	Create an entry for the primary article
	//
	virtual	BOOL
	CreatePrimaryNovEntry(
			GROUPID		GroupId,
			ARTICLEID	ArticleId,
			WORD		HeaderOffset,
			WORD		HeaderLength,
			PFILETIME	FileTime,
			LPCSTR		szMessageId,
			DWORD		cbMessageId,
			DWORD		cEntries,
			GROUP_ENTRY	*pEntries,
			DWORD		cStoreIds,
			CStoreId	*pStoreIds,
			BYTE		*pcCrossposts
			) ;


	//
	//	Create a Cross Posting entry that references the
	//	specified primary entry !
	//
	virtual	BOOL
	CreateXPostNovEntry(
			GROUPID		GroupId,
			ARTICLEID	ArticleId,
			WORD		HeaderOffset,
			WORD		HeaderLength,
			PFILETIME	FileTime,
			GROUPID		PrimaryGroupId,
			ARTICLEID	PrimaryArticleId
			) ;

	//
	//	Delete an entry from the hash table!
	//
	virtual	BOOL
	DeleteNovEntry(
			GROUPID		GroupId,
			ARTICLEID	ArticleId
			) ;

	//
	//	Get all the information stored about an entry
	//
	virtual	BOOL
	ExtractNovEntryInfo(
			GROUPID		GroupId,
			ARTICLEID	ArticleId,
			BOOL		&fPrimary,
			WORD		&HeaderOffset,
			WORD		&HeaderLength,
			PFILETIME	FileTime,
			DWORD		&DataLen,
			PCHAR		MessageId,
			DWORD 		&cStoreEntries,
			CStoreId	*pStoreIds,
			BYTE		*pcCrossposts,
			IExtractObject*	pExtract = 0
			) ;

	//
	//	Get the primary article and the message-id if necessary
	//
	virtual	BOOL
	GetPrimaryArticle(
			GROUPID		GroupId,
			ARTICLEID	ArticleId,
			GROUPID&	GroupIdPrimary,
			ARTICLEID&	ArticleIdPrimary,
			DWORD		cbBuffer,
			PCHAR		MessageId,
			DWORD&		DataLen,
			WORD&		HeaderOffset,
			WORD&		HeaderLength,
			CStoreId	&storeid
			) ;

	//
	//	Check to see whether the specified entry exists -
	//	don't care about its contents !
	//
	virtual	BOOL
	Contains(
			GROUPID		GroupId,
			ARTICLEID	ArticleId
			) ;

	//
	//	Get all the cross-posting information related to an article !
	//
	virtual	BOOL
	GetArticleXPosts(
			GROUPID		GroupId,
			ARTICLEID	AritlceId,
			BOOL		PrimaryOnly,
			PGROUP_ENTRY	GroupList,
			DWORD		&GroupListSize,
			DWORD		&NumberOfGroups,
			PBYTE		rgcCrossposts = NULL
			) ;

	//
	//	Initialize the hash table
	//
	virtual	BOOL
	Initialize(
			LPSTR		lpstrXoverFile,
			HASH_FAILURE_PFN	pfnHint,
			BOOL	fNoBuffering = FALSE
			) ;

	virtual	BOOL
	SearchNovEntry(
			GROUPID		GroupId,
			ARTICLEID	ArticleId,
			PCHAR		XoverData,
			PDWORD		DataLen,
            BOOL        fDeleteOrphans = FALSE
			) ;

	//
	//	Signal the hash table to shutdown
	//
	virtual	void
	Shutdown( ) ;

	//
	//	Return the number of entries in the hash table !
	//
	virtual	DWORD
	GetEntryCount() ;

	//
	//	Returns TRUE if the hash table is successfully
	//	initialized and ready to do interesting stuff !!!
	//
	virtual	BOOL
	IsActive() ;

	BOOL
	GetFirstNovEntry(
				OUT	CXoverMapIterator*	&pIterator,
				OUT	GROUPID&	GroupId,
				OUT ARTICLEID&	ArticleId,
				OUT	BOOL&		fIsPrimary,
				IN	DWORD		cbBuffer,
				OUT	PCHAR	MessageId,
				OUT	CStoreId&	storeid,
				IN	DWORD		cGroupBuffer,
				OUT	GROUP_ENTRY*	pGroupList,
				OUT	DWORD&		cGroups
				) ;


	BOOL
	GetNextNovEntry(
				OUT	CXoverMapIterator*	pIterator,
				OUT	GROUPID&	GroupId,
				OUT ARTICLEID&	ArticleId,
				OUT	BOOL&		fIsPrimary,
				IN	DWORD		cbBuffer,
				OUT	PCHAR	MessageId,
				OUT	CStoreId&	storeid,
				IN	DWORD		cGroupBuffer,
				OUT	GROUP_ENTRY*	pGroupList,
				OUT	DWORD&		cGroups
				) ;


} ;




#endif	// _NNTPHASH_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\nntp\server\hash\src\xhash.cpp ===
/*++

	XHASH.CPP

	This file implements all of the code specific to
	the XOVER hash table used by NNTP.


--*/



#include	<windows.h>
#include	<stdlib.h>
#include    <xmemwrpr.h>
#include	<dbgtrace.h>
#include	"hashmap.h"
#include	"nntphash.h"



WORD
MyRand(
    IN DWORD& seed,
	IN DWORD	val
    )
{
    DWORD next = seed;
    next = (seed*val) * 1103515245 + 12345;   // magic!!
	seed = next ;
    return (WORD)((next/65536) % 32768);
}

HASH_VALUE
IDHash(
    IN DWORD Key1,
    IN DWORD Key2
    )
/*++

Routine Description:

    Used to find the hash value given 2 numbers. (Used for articleid + groupId)

Arguments:

    Key1 - first key to hash.  MS bit mapped to LSb of hash value
    Key2 - second key to hash.  LS bit mapped to MS bit of hash value.

Return Value:

    Hash value

--*/
{
    HASH_VALUE val;

    DWORD	val1 = 0x80000000, val2 = 0x80000000;

    //
    // Do Key1 first
    //

	DWORD	lowBits = Key2 & 0xf ;

	DWORD	TempKey2 = Key2 & (~0xf) ;
	DWORD	seed1 = (Key2 << (Key1 & 0x7)) - Key1 ;

	Key1 = (0x80000000 - ((67+Key1)*(19+Key1)*(7+Key1)+12345)) ^ (((3+Key1)*(5+Key1)+12345) << ((Key1&0xf)+8)) ;
	TempKey2 = (0x80000000 - ((67+TempKey2)*(19+TempKey2)*(7+TempKey2)*(1+TempKey2)+12345)) ^ ((TempKey2+12345) << (((TempKey2>>4)&0x7)+8)) ;
	
	val1 -=	(MyRand( seed1, Key1 ) << (Key1 & 0xf)) ;
	val1 += MyRand( seed1, Key1 ) << (((TempKey2 >> 4) & 0x3)+4) ;
	val1 ^=	MyRand( seed1, Key1 ) << 17 ;

	DWORD	seed2 = val1 - TempKey2 ;

	val2 -= MyRand( seed2, TempKey2 >> 1 ) << (((Key1 << 3)^Key1) &0xf) ;
	val2 =  (val2 + MyRand( seed2, TempKey2 )) << (13 ^ Key1) ;
	val2 ^= MyRand( seed2, TempKey2 ) << 15 ;

	
	//DWORD	val = val1 + val2 ;

	val = (val1 + val2 + 67) * (val1 - val2 + 19) * (val1 % (val2 + 67)) ;

	val += (MyRand( seed2, lowBits ) >> 3) ;

    return(val);

} // IDHash



DWORD	
ExtractGroupInfo(	LPSTR	data,
					GROUPID	&groupid,
					ARTICLEID	&articleid ) {

	char*	p = 0 ;
	p=strtok(data, "!");

	if ( p == NULL ) {
		_ASSERT(FALSE);
		return ERROR_INTERNAL_ERROR;
	}

	groupid	= atoi(p);
	p+=(strlen(p)+1);
	articleid  = atoi(p);

	return	0 ;
}


CXoverKey::CXoverKey() :
	m_groupid( INVALID_GROUPID ),
	m_articleid( INVALID_ARTICLEID ),
	m_cb( 0 )	{

}

DWORD
CXoverKey::Hash()	const	{
/*++

Routine Description :

	This function computes the hash value of a Message ID key

Arguments :

	None

Return Value :

	32 bit hash value

--*/

	return	IDHash( m_groupid, m_articleid ) ;
}


BOOL
CXoverKey::CompareKeys(	LPBYTE	pbPtr )	const	{
/*++

Routine Description :

	This function compares a key stored within ourselves to
	one that has been serialized into the hash table !

Arguments :

	Pointer to the start of the block of serialized data

Return Value :

	TRUE if the keys match !

--*/


	Key*	pKey = (XOVER_MAP_ENTRY*)pbPtr ;

	if( pKey->KeyLength() == m_cb	&&
        (lstrcmp(pKey->KeyPosition(), (const char*)&m_rgbSerialize[0]) == 0) ) {
        return TRUE;
    }

    return FALSE;
}


LPBYTE
CXoverKey::EntryData(	LPBYTE	pbPtr,
							DWORD&	cbKeyOut )	const	{
/*++

Routine Description :

	This function returns a pointer to where the data is
	serialized.  We always return the pointer we were passed
	as we have funky serialization semantics that places
	the key not before the data but somewhere in the middle
	or end.

Arguments :

	pbPtr - Start of serialized hash entyr
	cbKeyOut - returns the size of the key

Return Value :

	Pointer to where the data resides - same as pbPtr

--*/


	_ASSERT( pbPtr != 0 ) ;
	
	Key*	pKey = (Key*)pbPtr ;
	cbKeyOut = pKey->KeyLength() ;

	return	pbPtr ;
}


LPBYTE
CXoverKey::Serialize(	LPBYTE	pbPtr )	const	{
/*++

Routine Description :

	This function saves a key into the hash table.
	We use functions off of the template type 'Key' to
	determine where we should stick the message id

Arguments :

	pbPtr - Start od where we should serialize to

Return Value :

	same as pbPtr

--*/

	_ASSERT( m_pData != 0  ) ;
	_ASSERT( pbPtr != 0 ) ;

	Key*	pKey = (Key*)pbPtr ;

	pKey->KeyLength() = WORD(m_cb) ;

	CopyMemory( SerializeOffset(pbPtr),
				m_rgbSerialize,
				m_cb ) ;
	return	pbPtr ;
}	


LPBYTE
CXoverKey::Restore(	LPBYTE	pbPtr, DWORD	&cbOut )		{
/*++

Routine Description :

	This function is called to recover a key from where
	it was Serialize()'d .

Arguments :

	pbPtr - Start of the block of serialized data

Return Value :

	pbPtr if successfull, NULL otherwise

--*/

	Key*	pKey = (Key*)pbPtr ;

	if( pKey->KeyLength() <= sizeof( m_rgbSerialize ) ) {
		CopyMemory( m_rgbSerialize, pKey->KeyPosition(), pKey->KeyLength() ) ;
		m_cb = pKey->KeyLength() ;
		return	pbPtr ;
	}
	return	0 ;
}


DWORD
CXoverKey::Size()	const	{
/*++

Routine Description :

	This function retruns the size of the key - which is just
	the number of bytes makeing up the message id.
	The bytes use to hold the serialized length are accounted
	for by the

Arguments :

	None

Return Value :

	32 bit hash value

--*/

	return	m_cb ;
}


BOOL
CXoverKey::Verify(	BYTE*	pbContainer, BYTE*	pbData, DWORD	cb )	const	{

	return	TRUE ;

}



LPBYTE	
CXoverData::Serialize(	LPBYTE	pbPtr )	const	{
/*++

Routine Description :

	This function saves XOVER data into a location in the XOVER file.
	Size() is called before we are to make sure there is sufficient
	room - we must use exactly Size() bytes !

Arguments :

	pbPtr - the location to save our data !

Return Value :

	Pointer to the first byte following the serialized data !

--*/

	XOVER_MAP_ENTRY*	pEntry = (XOVER_MAP_ENTRY*)pbPtr ;

	//
	//	Save the static header portions !
	//
	//
	pEntry->FileTime = m_data.FileTime ;
	pEntry->HeaderOffset = m_data.HeaderOffset ;
	pEntry->HeaderLength = m_data.HeaderLength ;
	pEntry->Flags = m_data.Flags ;
	pEntry->NumberOfXPostings = m_data.NumberOfXPostings ;

	//
	//	If we are primary then we have cross post info to save !
	//
	if( m_data.Flags & XOVER_MAP_PRIMARY ) {

		if( m_pGroups ) {
			CopyMemory( pEntry->XPostingsPosition(), m_pGroups,
				sizeof( m_pGroups[0] ) * m_cGroups ) ;
		}
	}	else	{
		_ASSERT(m_pGroups == 0 ) ;
		_ASSERT(m_cGroups == 0 ) ;
	}

	//
	//	If we are not primary this points at a buffer containing
	//	the primart Group and ArticleId formatted correctly - otherwise
	//	it really does contain the primary Message Id !
	//
	if( m_pchMessageId ) {
		pEntry->XoverDataLen = (WORD)m_cbMessageId ;
		CopyMemory( pEntry->MessageIDPosition(),
			m_pchMessageId, m_cbMessageId ) ;
	}
	return	pEntry->MessageIDPosition() + m_cbMessageId ;
}

LPBYTE
CXoverData::Restore(	LPBYTE	pbPtr,
						DWORD&	cbOut	
						)	{
/*++

Routine Description :

	This function copies the data out of a serialized XOVER
	entry into internal buffers.
	If there is not enough memory to hold the variable length
	objects we will succeed this call and mark a
	member variable (m_fSufficientBuffer) as FALSE.

Arguments :

	pbPtr - Buffer to restore from

	cbOut -		returns the number of bytes to hold this data

Return Value :

	Pointer to following byte if successfull - FALSE otherwise !

--*/

	CopyMemory( &m_data, pbPtr, sizeof( m_data ) - 1 ) ;

	XOVER_MAP_ENTRY*	pEntry = (XOVER_MAP_ENTRY*) pbPtr ;

	cbOut = Size() ;

	m_fSufficientBuffer = TRUE ;

	if( m_pGroups ) {
		if( m_cGroups >= m_data.NumberOfXPostings ) {
			m_cGroups = m_data.NumberOfXPostings ;
			CopyMemory( m_pGroups, pEntry->XPostingsPosition(),
				m_cGroups * sizeof( m_pGroups[0] ) ) ;

		}	else	{
		
			//
			//	Do not fail - assume caller checks
			//	our structures to determine failures !
			//
			m_fSufficientBuffer = FALSE ;
		}

	}

	if( m_data.Flags & XOVER_MAP_PRIMARY ) {
		if( m_pchMessageId ) {
			if( m_cbMessageId >= m_data.XoverDataLen ) {

				m_cbMessageId = 0 ;
	
				if( !m_pExtractor ||
					m_pExtractor->DoExtract(	m_PrimaryGroup,
									m_PrimaryArticle,
									(GROUP_ENTRY*)pEntry->XPostingsPosition(),
									pEntry->NumberOfXPostings ) ) {

					m_cbMessageId = m_data.XoverDataLen ;
					CopyMemory( m_pchMessageId, pEntry->MessageIDPosition(),
						m_cbMessageId ) ;

				}
			}	else	{

				m_fSufficientBuffer = FALSE ;			

			}
		}
	}	else	{

		if( m_data.XoverDataLen > 40 ) {
			SetLastError( ERROR_INTERNAL_ERROR ) ;
		}	else	{
			m_cb = m_data.XoverDataLen ;
			CopyMemory( m_rgbPrimaryBuff, pEntry->MessageIDPosition(),
					m_cb ) ;

		}
	}
	return	pbPtr + pEntry->TotalSize() ;
}

DWORD	
CXoverData::Size()	const	{

	DWORD	cbSize = sizeof( XOVER_MAP_ENTRY ) -1 ;
	if( m_pGroups ) {
		cbSize += m_data.NumberOfXPostings * sizeof( GROUP_ENTRY ) ;
	}
	if( m_pchMessageId ) {
		cbSize += m_data.XoverDataLen ;
	}
	return	cbSize ;
}


DWORD
CXoverKeyNew::Hash()	const	{
/*++

Routine Description :

	This function computes the hash value of a Message ID key

Arguments :

	None

Return Value :

	32 bit hash value

--*/

	return	IDHash( m_key.GroupId, m_key.ArticleId ) ;
}



LPBYTE
CXoverDataNew::Restore(	LPBYTE	pbPtr,
								DWORD&	cbOut
								) {
	PXOVER_ENTRY	pEntry = (PXOVER_ENTRY)pbPtr ;
	DWORD cbStoreId = 0;

	if( pEntry->IsXoverEntry() ) {

		CopyMemory( &m_data, pbPtr, sizeof( m_data ) - 1 ) ;

		cbOut = Size() ;

		m_fSufficientBuffer = TRUE ;

		if( m_pGroups ) {
			if( m_cGroups >= m_data.NumberOfXPostings ) {
				m_cGroups = m_data.NumberOfXPostings ;
				CopyMemory( m_pGroups, pEntry->XPostingsPosition(),
					m_cGroups * sizeof( m_pGroups[0] ) ) ;

			}	else	{
			
				if( m_fFailRestore )	{
					return	0 ;
				}
				//
				//	Do not fail - assume caller checks
				//	our structures to determine failures !
				//
				m_fSufficientBuffer = FALSE ;
			}

		}

		if( m_data.Flags & XOVER_MAP_PRIMARY ) {
			m_PrimaryGroup = pEntry->Key.GroupId;
			m_PrimaryArticle = pEntry->Key.ArticleId;
		}	else	{
			GROUP_ENTRY*	p = pEntry->PrimaryEntry() ;
			m_PrimaryGroup = p->GroupId;
			m_PrimaryArticle = p->ArticleId;
		}

		if( m_data.Flags & XOVER_MAP_PRIMARY ) {
			if( m_pchMessageId ) {
				if( m_cbMessageId >= m_data.XoverDataLen ) {

					m_cbMessageId = 0 ;
		
					if( !m_pExtractor ||
						m_pExtractor->DoExtract(	m_PrimaryGroup,
										m_PrimaryArticle,
										(GROUP_ENTRY*)pEntry->XPostingsPosition(),
										pEntry->NumberOfXPostings ) ) {

						m_cbMessageId = m_data.XoverDataLen ;
						CopyMemory( m_pchMessageId, pEntry->MessageIDPosition(),
							m_cbMessageId ) ;

					}
				}	else	{

					if( m_fFailRestore )
						return	0 ;

					m_fSufficientBuffer = FALSE ;			

				}
			}

			if (m_data.Flags & XOVER_CONTAINS_STOREID) {
				BYTE *p = pEntry->StoreIdPosition();

				// get the count of store ids
				m_cEntryStoreIds = *p; p++;
				DWORD c = min(m_cStoreIds, m_cEntryStoreIds);
				if (c < m_cStoreIds) m_cStoreIds = c;

				// copy the crosspost count array
				if (m_pcCrossposts) CopyMemory(m_pcCrossposts, p, m_cEntryStoreIds);
				p += m_cEntryStoreIds;

				// copy the store id array
				for (DWORD i = 0; i < c; i++) {
					m_pStoreIds[i].cLen = *p; p++;
					CopyMemory(m_pStoreIds[i].pbStoreId, p, m_pStoreIds[i].cLen); p += m_pStoreIds[i].cLen;
				}
				cbStoreId = (DWORD)(p - pEntry->StoreIdPosition());
			} else {
				m_cEntryStoreIds = 0;
			}
		}
#if 0
			else	{

			if( m_data.XoverDataLen > 40 ) {
				SetLastError( ERROR_INTERNAL_ERROR ) ;
			}	else	{
				m_cb = m_data.XoverDataLen ;
				CopyMemory( m_rgbPrimaryBuff, pEntry->MessageIDPosition(),
						m_cb ) ;

			}
		}
#endif
		return	pbPtr + pEntry->TotalSize() + cbStoreId;
		
	}	else	{

		CXoverData*	pXover = GetBackLevel() ;

		pXover->m_pchMessageId = m_pchMessageId ;
		pXover->m_cbMessageId = m_cbMessageId ;
		pXover->m_pExtractor = m_pExtractor ;
		pXover->m_PrimaryGroup = m_PrimaryGroup ;
		pXover->m_PrimaryArticle = m_PrimaryArticle ;
		pXover->m_cGroups = m_cGroups ;
		pXover->m_pGroups = m_pGroups ;
		pXover->m_cb = m_cb ;

		LPBYTE	lpb = pXover->Restore( pbPtr, cbOut ) ;

		m_data.FileTime = pXover->m_data.FileTime ;
		m_data.Flags = pXover->m_data.Flags ;
		m_data.NumberOfXPostings = pXover->m_data.NumberOfXPostings ;
		m_data.XoverDataLen = pXover->m_data.XoverDataLen ;
		m_data.HeaderOffset = pXover->m_data.HeaderOffset ;
		m_data.HeaderLength = pXover->m_data.HeaderLength ;

		m_fSufficientBuffer = pXover->m_fSufficientBuffer ;
		m_pGroups = pXover->m_pGroups ;
		m_cGroups = pXover->m_cGroups ;
		m_pchMessageId = pXover->m_pchMessageId ;
		m_cbMessageId = pXover->m_cbMessageId ;
		m_cb = pXover->m_cb ;
		m_cEntryStoreIds = 0;
		
				
		if( !(m_data.Flags & XOVER_MAP_PRIMARY) ) {
			ExtractGroupInfo( pXover->m_rgbPrimaryBuff, m_PrimaryGroup, m_PrimaryArticle ) ;

		}
		return	lpb ;
	}
	return 0 ;
}


LPBYTE	
CXoverDataNew::Serialize(	LPBYTE	pbPtr )	const	{
/*++

Routine Description :

	This function saves XOVER data into a location in the XOVER file.
	Size() is called before we are to make sure there is sufficient
	room - we must use exactly Size() bytes !

Arguments :

	pbPtr - the location to save our data !

Return Value :

	Pointer to the first byte following the serialized data !

--*/

	XOVER_ENTRY*	pEntry = (XOVER_ENTRY*)pbPtr ;

	//
	//	Save the static header portions !
	//
	//
	pEntry->FileTime = m_data.FileTime ;
	pEntry->Flags = m_data.Flags ;
	pEntry->NumberOfXPostings = m_data.NumberOfXPostings ;
	pEntry->XoverDataLen = m_data.XoverDataLen ;
	pEntry->HeaderOffset = m_data.HeaderOffset ;
	pEntry->HeaderLength = m_data.HeaderLength ;

	_ASSERT( pEntry->IsXoverEntry() ) ;

	//
	//	If we are primary then we have cross post info to save !
	//
	if( m_data.Flags & XOVER_MAP_PRIMARY ) {

		if( m_pGroups ) {
			CopyMemory( pEntry->XPostingsPosition(), m_pGroups,
				sizeof( m_pGroups[0] ) * m_cGroups ) ;
		}	else	{
			_ASSERT( pEntry->NumberOfXPostings == 0 ) ;
		}
	}	else	{

		_ASSERT( pEntry->NumberOfXPostings == 1 ) ;

		GROUP_ENTRY*	pGroup = pEntry->PrimaryEntry() ;
		pGroup->GroupId = m_PrimaryGroup ;
		pGroup->ArticleId = m_PrimaryArticle ;


		_ASSERT(m_pGroups == 0 ) ;
		_ASSERT(m_cGroups == 0 ) ;
	}

	//
	//	If we are not primary this points at a buffer containing
	//	the primart Group and ArticleId formatted correctly - otherwise
	//	it really does contain the primary Message Id !
	//
	if( m_pchMessageId ) {
		pEntry->XoverDataLen = (WORD)m_cbMessageId ;
		CopyMemory( pEntry->MessageIDPosition(),
			m_pchMessageId, m_cbMessageId ) ;
	}

	DWORD cbStoreId = 0;
	// this data has a count of store Ids followed by each store id.  Each
	// store id contains a length byte followed by data bytes.
	if ((m_data.Flags & XOVER_MAP_PRIMARY) && m_cStoreIds > 0) {
		_ASSERT(m_data.Flags & XOVER_CONTAINS_STOREID);
		BYTE *p = pEntry->StoreIdPosition();
		// store the length of this array
		*p = (BYTE) m_cStoreIds; p++;
		// store the crosspost count array
		CopyMemory(p, m_pcCrossposts, m_cStoreIds); p += m_cStoreIds;
		for (DWORD i = 0; i < m_cStoreIds; i++) {
			*p = m_pStoreIds[i].cLen; p++;

			CopyMemory(p, m_pStoreIds[i].pbStoreId, m_pStoreIds[i].cLen);
			p += m_pStoreIds[i].cLen;
		}
		cbStoreId = (DWORD)(p - pEntry->StoreIdPosition());
	}

	return	pEntry->MessageIDPosition() + m_cbMessageId + cbStoreId;
}


DWORD	
CXoverDataNew::Size()	const	{
	DWORD	cbSize = sizeof( XOVER_ENTRY ) -1 ;

	if( m_pGroups ) {
		cbSize += m_data.NumberOfXPostings * sizeof( GROUP_ENTRY ) ;
	}
	if( m_pchMessageId ) {
		cbSize += m_data.XoverDataLen ;
	}	
	if ((m_data.Flags & XOVER_MAP_PRIMARY) && m_cStoreIds > 0) {
		cbSize += sizeof(BYTE);			// storeid count
		cbSize += m_cStoreIds;			// crosspost count array
		for (DWORD i = 0; i < m_cStoreIds; i++) {
			cbSize += sizeof(BYTE);		// storeid length
			cbSize += m_pStoreIds[i].cLen;
		}
	}
	return	cbSize ;
}


CXoverMap*
CXoverMap::CreateXoverMap(StoreType st)	{

	return	new	CXoverMapImp() ;

}

CXoverMap::~CXoverMap()	{
}


BOOL
CXoverMapImp::CreatePrimaryNovEntry(
		GROUPID		GroupId,
		ARTICLEID	ArticleId,
		WORD		HeaderOffset,
		WORD		HeaderLength,
		PFILETIME	FileTime,
		LPCSTR		szMessageId,
		DWORD		cbMessageId,
		DWORD		cEntries,
		GROUP_ENTRY	*pEntries,
		DWORD		cStoreIds,
		CStoreId	*pStoreIds,
		BYTE		*pcCrossposts
		)	{
/*++

Routine Description :

	Create an entry in the XOVER table for a Primary Entry.
	The Primary entry contains cross posting info and the Message
	Id of the new element.

Arguments :

	GroupId - Primary Grouop ID
	ArticleId	- Primary Article Id
	HeaderOffset - Offset to the RFC 822 header
	HeaderLength - Length of the RFC 822 Header
	FileTime - Time the article arrived
	szMessageId - The Message Id of the article
	cbMessageId - length of the Message Id
	cEntries - Number of GROUP_ENTRY objects to be serialized
	pEntries - Pointer to the GROUP_ENTRY objects to be saved in the entry
	
Return Value :

	TRUE if successfull !

--*/

	_ASSERT( cEntries <= 255 ) ;

	CXoverDataNew	data(		*FileTime,
							HeaderOffset,
							HeaderLength,
							BYTE(cEntries),
							pEntries,
							cbMessageId,
							(LPSTR)szMessageId,
							BYTE(cStoreIds),
							pStoreIds,
							pcCrossposts
							) ;
	CXoverKeyNew	key( GroupId, ArticleId, &data.m_data ) ;

	return	CHashMap::InsertMapEntry(	&key,
										&data ) ;	
	
}

BOOL
CXoverMapImp::CreateXPostNovEntry(
		GROUPID		GroupId,
		ARTICLEID	ArticleId,
		WORD		HeaderOffset,
		WORD		HeaderLength,
		PFILETIME	FileTime,
		GROUPID		PrimaryGroupId,
		ARTICLEID	PrimaryArticleId
		)	{
/*++

Routine Description :

	Create an entry for a cross posted article.
	
Arguments :

	GroupId - The Group the cross posted article resides in
	ArticleId - The Id of the article in the cross posting group
	HeaderOffset - Offset to the RFC 822 Header within the article
	HeaderLength - Length of the RFC 822 header within the article
	FileTime - Time the article arrived on the systyem
	PrimaryGroupId - The Group of the primary article
	PrimaryArticleId - The Id of the Primary Article within the Primary Group

Return Value :

	TRUE if successfull.

--*/

	CXoverDataNew	data(	*FileTime,
						HeaderOffset,
						HeaderLength,
						PrimaryGroupId,
						PrimaryArticleId
						) ;

	CXoverKeyNew	key( GroupId, ArticleId, &data.m_data ) ;

	return	CHashMap::InsertMapEntry(	&key,
										&data ) ;

}

BOOL
CXoverMapImp::DeleteNovEntry(
		GROUPID		GroupId,
		ARTICLEID	ArticleId
		)	{
/*++

Routine Description :

	Removes an entry from the hash table

Arguments :

	GroupId - Id of the group for which we wish to remove the entry
	ArticleId - Id of the article within the group

Return Value :

	TRUE if successfull !

--*/

	CXoverKeyNew	key( GroupId, ArticleId, 0 ) ;

	return	CHashMap::DeleteMapEntry(	&key ) ;
}

BOOL
CXoverMapImp::ExtractNovEntryInfo(
		GROUPID		GroupId,
		ARTICLEID	ArticleId,
		BOOL		&fPrimary,
		WORD		&HeaderOffset,
		WORD		&HeaderLength,
		PFILETIME	FileTime,
		DWORD		&DataLen,
		PCHAR		MessageId,
		DWORD		&cStoreIds,
		CStoreId	*pStoreIds,
		BYTE		*pcCrossposts,
		IExtractObject*	pExtract
		)	{
/*++

Routine Description :

	Extract selected information about the specified article -
	if the article is not a primary article but a cross posting
	we will find the primary article and get info there  !

Arguments :

	GroupId - NewsGroup in which the article we want info about resides
	ArticleId - Id of the article within GroupId
	fPrimary - Returns whether the article is the primary Article
	HeaderOffset - returns the offset to the RFC 822 header within the article
	HeaderLength - returns the length of the RFC 822 header
	FileTime - returns the time the article was added to the system
	DataLen - IN/OUT parameter - comes in with the size of the MessageId buffer,
		returns the number of bytes placed in buffer
	MessageId - Buffer to hold the message Id
	pExtract -

Return Value :

	TRUE if successfull, FALSE otherwise !

--*/

	CXoverKeyNew	key(	GroupId,	ArticleId, 0 ) ;
	CXoverDataNew	data ;

	data.m_pchMessageId = MessageId ;
	data.m_cbMessageId = DataLen ;
	data.m_pExtractor = pExtract ;
	data.m_PrimaryGroup = GroupId ;
	data.m_PrimaryArticle = ArticleId ;
	data.m_cStoreIds = cStoreIds;
	data.m_pStoreIds = pStoreIds;
	data.m_pcCrossposts = pcCrossposts;

	char	*pchPrimary = data.m_pchMessageId ;
	BOOL	fSuccess = FALSE ;

	if(	fSuccess = CHashMap::LookupMapEntry(	&key,
												&data ) )	{

		if( !(data.m_data.Flags & XOVER_MAP_PRIMARY) )	{

			fPrimary = FALSE ;

			//
			//	Assume that we need to reread these !
			//
			data.m_pchMessageId = MessageId ;
			data.m_cbMessageId = DataLen ;

#if 0
			ExtractGroupInfo(	&data.m_rgbPrimaryBuff[0],
								GroupId,
								ArticleId ) ;

			data.m_PrimaryGroup = GroupId ;
			data.m_PrimaryArticle = ArticleId ;
#else
			GroupId = data.m_PrimaryGroup ;
			ArticleId = data.m_PrimaryArticle ;
			_ASSERT( GroupId != INVALID_GROUPID ) ;
			_ASSERT( ArticleId != INVALID_ARTICLEID ) ;
#endif

			CXoverKeyNew	key2(	GroupId, ArticleId, 0 ) ;
			
			fSuccess = CHashMap::LookupMapEntry(	&key2,
													&data ) ;


		}	else	{

			fPrimary = TRUE ;

		}
	}	

	// report the number of ids in the entry
	cStoreIds = data.m_cEntryStoreIds;

	if( fSuccess ) {

		if( !(data.m_data.Flags & XOVER_MAP_PRIMARY) ) {
			SetLastError( ERROR_INTERNAL_ERROR ) ;
			return	FALSE ;
		}

		HeaderOffset = data.m_data.HeaderOffset ;
		HeaderLength = data.m_data.HeaderLength ;
		*FileTime = data.m_data.FileTime ;

		DataLen = data.m_data.XoverDataLen ;

		if( !data.m_fSufficientBuffer ) {
			SetLastError( ERROR_INSUFFICIENT_BUFFER ) ;
		}	else	{
			DataLen = data.m_cbMessageId ;
		}

		return	data.m_fSufficientBuffer ;
	}
	return	FALSE ;
}


//
//	Get the primary article and the message-id if necessary
//
BOOL
CXoverMapImp::GetPrimaryArticle(	
		GROUPID		GroupId,
		ARTICLEID	ArticleId,
		GROUPID&	GroupIdPrimary,
		ARTICLEID&	ArticleIdPrimary,
		DWORD		cbBuffer,
		PCHAR		MessageId,
		DWORD&		DataLen,
		WORD&		HeaderOffset,
		WORD&		HeaderLength,
		CStoreId	&storeid
		)	{

	_ASSERT( GroupId != INVALID_GROUPID ) ;
	_ASSERT( ArticleId != INVALID_ARTICLEID ) ;
	
	GroupIdPrimary = INVALID_GROUPID ;
	ArticleIdPrimary = INVALID_ARTICLEID ;

	CXoverKeyNew	key(	GroupId,	ArticleId, 0 ) ;
	CXoverDataNew	data ;

	data.m_pchMessageId = MessageId ;
	data.m_cbMessageId = DataLen ;
	data.m_PrimaryGroup = GroupId ;
	data.m_PrimaryArticle = ArticleId ;
	data.m_cStoreIds = 1;
	data.m_pStoreIds = &storeid;

	char	*pchPrimary = data.m_pchMessageId ;
	BOOL	fSuccess = FALSE ;

	if(	fSuccess = CHashMap::LookupMapEntry(	&key,
												&data ) )	{

		if( !(data.m_data.Flags & XOVER_MAP_PRIMARY) )	{

#if 0
			ExtractGroupInfo(	&data.m_rgbPrimaryBuff[0],
								GroupId,
								ArticleId ) ;

			data.m_PrimaryGroup = GroupId ;
			data.m_PrimaryArticle = ArticleId ;
#else
			GroupId = data.m_PrimaryGroup ;
			ArticleId = data.m_PrimaryArticle ;
			_ASSERT( GroupId != INVALID_GROUPID ) ;
			_ASSERT( ArticleId != INVALID_ARTICLEID ) ;
#endif

			CXoverKeyNew	key2(	GroupId, ArticleId, 0 ) ;
			
			//
			//	Assume that we need to reread these !
			//
			data.m_pchMessageId = MessageId ;
			data.m_cbMessageId = DataLen ;

			fSuccess = CHashMap::LookupMapEntry(	&key2,
													&data ) ;


		}	

		GroupIdPrimary = GroupId ;
		ArticleIdPrimary = ArticleId ;

	}	

	if( fSuccess ) {

		HeaderOffset = data.m_data.HeaderOffset ;
		HeaderLength = data.m_data.HeaderLength ;

		if( !(data.m_data.Flags & XOVER_MAP_PRIMARY) ) {
			GroupIdPrimary = INVALID_GROUPID ;
			ArticleIdPrimary = INVALID_ARTICLEID ;
			SetLastError( ERROR_INTERNAL_ERROR ) ;
			return	FALSE ;
		}

		if( MessageId )	{
			DataLen = data.m_data.XoverDataLen ;

			if( !data.m_fSufficientBuffer) {
				SetLastError( ERROR_INSUFFICIENT_BUFFER ) ;
				return	FALSE ;
			}	else	{
				DataLen = data.m_cbMessageId ;
			}
		}

		return	TRUE ;
	}
	return	FALSE ;




}


//
//	Check to see whether the specified entry exists -
//	don't care about its contents !
//
BOOL
CXoverMapImp::Contains(	
		GROUPID		GroupId,
		ARTICLEID	ArticleId
		)	{

	CXoverKeyNew	key(	GroupId,	ArticleId, 0 ) ;

	return	CHashMap::Contains( &key ) ;
}

//
//	Get all the cross-posting information related to an article !
//
BOOL
CXoverMapImp::GetArticleXPosts(
		GROUPID		GroupId,
		ARTICLEID	ArticleId,
		BOOL		PrimaryOnly,
		PGROUP_ENTRY	GroupList,
		DWORD		&GroupListSize,
		DWORD		&NumberOfGroups,
		PBYTE		rgcCrossposts
		)	{


	CXoverKeyNew	key(	GroupId,	ArticleId, 0 ) ;
	CXoverDataNew	data ;

	DWORD	WorkingSize = GroupListSize ;
	PGROUP_ENTRY	WorkingEntry = GroupList ;
	DWORD cStoreCrossposts;

	if( WorkingSize < sizeof( GROUP_ENTRY ) ) {
		WorkingEntry = 0 ;
		WorkingSize = 0 ;
	}

	if( WorkingSize != 0 && !PrimaryOnly ) {
		data.m_cGroups = (WorkingSize / sizeof( GROUP_ENTRY )) - 1 ;
		if( data.m_cGroups != 0 ) {
			data.m_pGroups = WorkingEntry+1 ;
		}	
	}

	data.m_pcCrossposts = rgcCrossposts;

	BOOL	fSuccess = FALSE ;

	if(	fSuccess = CHashMap::LookupMapEntry(	&key,
												&data ) )	{


		if( (data.m_data.Flags & XOVER_MAP_PRIMARY) )	{

			if( WorkingEntry != 0 ) {
				WorkingEntry->GroupId = GroupId ;
				WorkingEntry->ArticleId = ArticleId ;
			}

		}	else	{

#if 0
			//
			//	Assume that we need to reread these !
			//
			ExtractGroupInfo(	&data.m_rgbPrimaryBuff[0],
								GroupId,
								ArticleId ) ;
#else
			GroupId = data.m_PrimaryGroup ;
			ArticleId = data.m_PrimaryArticle ;
#endif

			if( WorkingEntry != 0 ) {
				WorkingEntry->GroupId = GroupId ;
				WorkingEntry->ArticleId = ArticleId ;
			}

		}

		if( PrimaryOnly ) {

			//
			//	If we only want the primary we're all set !!
			//
			GroupListSize = sizeof( GROUP_ENTRY ) ;
			NumberOfGroups = 1 ;

			if( WorkingEntry == 0 ) {
				SetLastError( ERROR_INSUFFICIENT_BUFFER ) ;
				return	FALSE ;
			}

			//
			//	We're all done then !
			//
			return	TRUE ;

		}	

		if( !(data.m_data.Flags & XOVER_MAP_PRIMARY) ) {
	
			CXoverKeyNew	key2(	GroupId, ArticleId, 0 ) ;

			if( WorkingSize != 0 && !PrimaryOnly ) {
				data.m_cGroups = (WorkingSize / sizeof( GROUP_ENTRY )) - 1 ;
				if( data.m_cGroups != 0 ) {
					data.m_pGroups = WorkingEntry+1 ;
				}	
			}


			fSuccess = CHashMap::LookupMapEntry(	&key2,
													&data ) ;
		}
	}	

	if( fSuccess ) {

		NumberOfGroups = 1 + data.m_data.NumberOfXPostings ;
		GroupListSize = NumberOfGroups * sizeof( GROUP_ENTRY ) ;

		if( !data.m_fSufficientBuffer )
			SetLastError( ERROR_INSUFFICIENT_BUFFER ) ;

		return	data.m_fSufficientBuffer ;
	}
	return	FALSE ;
}

//
//	Initialize the hash table
//
BOOL
CXoverMapImp::Initialize(	
		LPSTR		lpstrXoverFile,
		HASH_FAILURE_PFN	pfnHint,
		BOOL	fNoBuffering
		)	{

	return	CHashMap::Initialize(
							lpstrXoverFile,
                            XOVER_HEAD_SIGNATURE,
                            0,
							1,
							g_pSharedCache,
							HASH_VFLAG_PAGE_BASIC_CHECKS,
							pfnHint,
							0,
							fNoBuffering
							) ;
}

BOOL
CXoverMapImp::SearchNovEntry(
		GROUPID		GroupId,
		ARTICLEID	ArticleId,
		PCHAR		XoverData,
		PDWORD		DataLen,
        BOOL        fDeleteOrphans
		)	{

	CXoverKeyNew	key( GroupId, ArticleId, 0 ) ;
	CXoverDataNew	data ;

    DWORD   Length = 0 ;
    if( DataLen != 0 )
        Length = *DataLen ;

    if( Length != 0 ) {
    	data.m_pchMessageId = XoverData ;
        data.m_cbMessageId = Length ;
    }

	BOOL	fSuccess = FALSE ;

	if(	fSuccess = CHashMap::LookupMapEntry(	&key,
												&data ) )	{

		if( !(data.m_data.Flags & XOVER_MAP_PRIMARY) )	{

			//
			//	Assume that we need to reread these !
			//
            if( Length != 0 ) {
    	        data.m_pchMessageId = XoverData ;
                data.m_cbMessageId = Length ;
            }

#if 0
			ExtractGroupInfo(	&data.m_rgbPrimaryBuff[0],
								GroupId,
								ArticleId ) ;
#else
			GroupId = data.m_PrimaryGroup ;
			ArticleId = data.m_PrimaryArticle ;
#endif

    		CXoverKeyNew	key2(	GroupId, ArticleId, 0 ) ;
            fSuccess = CHashMap::LookupMapEntry(	fDeleteOrphans ? &key2 : &key,
													&data ) ;
            if( !fSuccess && fDeleteOrphans ) {
        		CHashMap::DeleteMapEntry(	&key ) ;
                SetLastError( ERROR_FILE_NOT_FOUND );
                return FALSE;
            }
		}	
	}

	if( fSuccess ) {

        if( DataLen != 0 )
    		*DataLen = data.m_data.XoverDataLen ;

		if( !data.m_fSufficientBuffer )
			SetLastError( ERROR_INSUFFICIENT_BUFFER ) ;

		return	data.m_fSufficientBuffer ;
	}
	return	FALSE ;
}

void
CXoverMapImp::Shutdown(

		)	{
/*++

Routine Description :

	Terminate the hash table

Arguments :

	None

Return Value :

	None

--*/

	CHashMap::Shutdown( FALSE ) ;

}

DWORD
CXoverMapImp::GetEntryCount()	{
/*++

Routine Description :

	Return the number of entries in the hash table

Arguments :

	None

Return Value :

	Number of Message ID's in the table

--*/

	return	CHashMap::GetEntryCount() ;

}

BOOL
CXoverMapImp::IsActive() {
/*++

Routine Description :

	Returns TRUE if hash table operational

Arguments :

	None

Return Value :

	TRUE if everything is hunky-dory

--*/

	return	CHashMap::IsActive() ;

}

CXoverMapImp::~CXoverMapImp()	{
}

BOOL
CXoverMapImp::GetFirstNovEntry(
				OUT	CXoverMapIterator*	&pIterator,
				OUT	GROUPID&	GroupId,
				OUT ARTICLEID&	ArticleId,
				OUT	BOOL&		fIsPrimary,
				IN	DWORD		cbBuffer,
				OUT	PCHAR	MessageId,
				OUT	CStoreId&	storeid,
				IN	DWORD		cGroupBuffer,
				OUT	GROUP_ENTRY*	pGroupList,
				OUT	DWORD&		cGroups
				)	{
	//
	//	Validate our arguments !
	//
	_ASSERT( pIterator == 0 ) ;
	_ASSERT( (MessageId == 0 && cbBuffer == 0) || (MessageId != 0 && cbBuffer != 0) ) ;
	_ASSERT( (cGroupBuffer == 0 && pGroupList ==0) || (cGroupBuffer != 0 && pGroupList != 0) ) ;

	GroupId = INVALID_GROUPID ;
	ArticleId = INVALID_ARTICLEID ;
	cGroups = 0 ;

	BOOL	fSuccess = FALSE ;
	

	CXoverMapIteratorImp*	pImp = new	CXoverMapIteratorImp() ;

	if( pImp ) {
		//
		//	This is the object we use to get the key of the XOVER entry !
		//
		CXoverKeyNew	key ;

		//
		//	This is the object we give to the basic hash table to get the
		//	Data portion of the XOVER entry !
		//
		CXoverDataNew	data ;
		data.m_fFailRestore = TRUE ;
		
		//
		//	Setup the data object so that it extracts the fields the caller requested !
		//
		//	If the user provides space for more than one GROUP_ENTRY object, arrange
		//	space so that we have room to stick the primary as the first entry !
		//
		if( cGroupBuffer > 1 ) {
			data.m_cGroups = cGroupBuffer - 1 ;
			data.m_pGroups = pGroupList + 1 ;
		}

		//
		//	Setup to extract the Message-ID if requested !
		//
		data.m_pchMessageId = MessageId ;
		data.m_cbMessageId = cbBuffer ;

		DWORD	cbKeyRequired= 0 ;
		DWORD	cbEntryRequired = 0 ;

		fSuccess = GetFirstMapEntry(	
											&key,
											cbKeyRequired,
											&data,
											cbEntryRequired,
											&pImp->m_IteratorContext,
											0
											) ;

		//
		//	Now - this should have extracted the data we want !
		//

		if( !fSuccess ) {
			if( GetLastError() == ERROR_INSUFFICIENT_BUFFER ) {
				//
				//	If the error is that the user did not provide enough memory to get the
				//	first item in the hash table, then we will return them the iterator
				//	even though we return FALSE as well !
				//	
				pIterator = pImp ;

			}	else	{
				//
				//	Don't give out a useless Iterator, destroy it !
				//
				delete	pImp ;
				_ASSERT( pIterator == 0 ) ;
			}
		}	else	{

			//
			//	Give out the iterator that can be used to continue walking the tree !
			//
			pIterator = pImp ;

			//
			//	Do the basic items
			//
			GroupId = key.m_key.GroupId ;
			ArticleId = key.m_key.ArticleId ;

			fIsPrimary = (GroupId == data.m_PrimaryGroup) && (ArticleId == data.m_PrimaryArticle) ;

			//
			//	Is this the primary entry ? if so fix up the GROUP_ENTRY structure !
			//
			if( cGroupBuffer >= 1 ) {
				pGroupList[0].GroupId = data.m_PrimaryGroup ;
				pGroupList[0].ArticleId = data.m_PrimaryArticle ;
			}		
		}
	}
	return	fSuccess ;
}

BOOL
CXoverMapImp::GetNextNovEntry(		
				IN	CXoverMapIterator*	pIterator,
				OUT	GROUPID&	GroupId,
				OUT ARTICLEID&	ArticleId,
				OUT	BOOL&		fIsPrimary,
				IN	DWORD		cbBuffer,
				OUT	PCHAR	MessageId,
				OUT	CStoreId&	storeid,
				IN	DWORD		cGroupBuffer,
				OUT	GROUP_ENTRY*	pGroupList,
				OUT	DWORD&		cGroups
				)	{	

	//
	//	Do some argument validation !
	//
	_ASSERT( pIterator != 0 ) ;
	_ASSERT( (MessageId == 0 && cbBuffer == 0) || (MessageId != 0 && cbBuffer != 0) ) ;
	_ASSERT( (cGroupBuffer == 0 && pGroupList ==0) || (cGroupBuffer != 0 && pGroupList != 0) ) ;
	_ASSERT( cGroups == 0 ) ;

	//
	//	Downcast to the actual implementation of the iterator !
	//
	CXoverMapIteratorImp	*pImp = (CXoverMapIteratorImp*)pIterator ;

	//
	//	Set all out parameters to illegal stuff !
	//
	GroupId = INVALID_GROUPID ;
	ArticleId = INVALID_ARTICLEID ;
	cGroups = 0 ;
	
	//
	//	This is the object we use to get the key of the XOVER entry !
	//
	CXoverKeyNew	key ;

	//
	//	This is the object we give to the basic hash table to get the
	//	Data portion of the XOVER entry !
	//
	CXoverDataNew	data ;
	data.m_fFailRestore = TRUE ;
	
	//
	//	Setup the data object so that it extracts the fields the caller requested !
	//
	//	If the user provides space for more than one GROUP_ENTRY object, arrange
	//	space so that we have room to stick the primary as the first entry !
	//
	if( cGroupBuffer > 1 ) {
		data.m_cGroups = cGroupBuffer - 1 ;
		data.m_pGroups = pGroupList + 1 ;
	}

	//
	//	Setup to extract the Message-ID if requested !
	//
	data.m_pchMessageId = MessageId ;
	data.m_cbMessageId = cbBuffer ;

	DWORD	cbKeyRequired= 0 ;
	DWORD	cbEntryRequired = 0 ;

	BOOL	fSuccess = GetNextMapEntry(	&key,
										cbKeyRequired,
										&data,
										cbEntryRequired,
										&pImp->m_IteratorContext,
										0
										) ;

	//
	//	Now - this should have extracted the data we want !
	//

	if( fSuccess ) {
		//
		//	Is this the primary entry ? if so fix up the GROUP_ENTRY structure !
		//
		//
		//	Do the basic items
		//
		GroupId = key.m_key.GroupId ;
		ArticleId = key.m_key.ArticleId ;

		fIsPrimary = (GroupId == data.m_PrimaryGroup) && (ArticleId == data.m_PrimaryArticle) ;

		//
		//	Is this the primary entry ? if so fix up the GROUP_ENTRY structure !
		//
		if( cGroupBuffer >= 1 ) {
			pGroupList[0].GroupId = data.m_PrimaryGroup ;
			pGroupList[0].ArticleId = data.m_PrimaryArticle ;
		}		
	}
	return	fSuccess ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\nntp\server\newstree\src\group.cpp ===
#include    "stdinc.h"

CShareLockNH    CNewsGroupCore::m_rglock[GROUP_LOCK_ARRAY_SIZE];

CNewsGroupCore::~CNewsGroupCore() {
	TraceQuietEnter("CNewsGroupCore::~CNewsGroupCore");
	
	_ASSERT(m_dwSignature == CNEWSGROUPCORE_SIGNATURE);

	m_pNewsTree->m_LockTables.ExclusiveLock();

    // remove ourselves from the list of newsgroups
    if (this->m_pPrev != NULL) {
        this->m_pPrev->m_pNext = m_pNext;
    } else if (m_pNewsTree->m_pFirst == this) {
        m_pNewsTree->m_pFirst = this->m_pNext;
    }
    if (this->m_pNext != NULL) {
        this->m_pNext->m_pPrev = m_pPrev;
    } else if (m_pNewsTree->m_pLast == this) {
	    m_pNewsTree->m_pLast = this->m_pPrev;
    }
    m_pPrev = m_pNext = NULL;

	m_pNewsTree->m_LockTables.ExclusiveUnlock();

    // clean up allocated memory
    if (m_pszGroupName != NULL) {
        XDELETE m_pszGroupName;
        m_pszGroupName = NULL;
    }
    if (m_pszNativeName != NULL) {
        XDELETE m_pszNativeName;
        m_pszNativeName = NULL;
    }
	if (m_pszHelpText != NULL) {
		XDELETE m_pszHelpText;
		m_pszHelpText = NULL;
		m_cchHelpText = 0;
	}
	if (m_pszPrettyName != NULL) {
		XDELETE m_pszPrettyName;
		m_pszPrettyName = NULL;
		m_cchPrettyName = 0;
	}
	if (m_pszModerator != NULL) {
		XDELETE m_pszModerator;
		m_pszModerator = NULL;
		m_cchModerator = 0;
	}

	if (m_pVRoot != NULL) {
		m_pVRoot->Release();
		m_pVRoot = NULL;
	}

	//ZeroMemory(this, sizeof(CNewsGroupCore));
	this->m_dwSignature = CNEWSGROUPCORE_SIGNATURE_DEL;
}

void CNewsGroupCore::SaveFixedProperties() {
	INNTPPropertyBag *pBag = GetPropertyBag();
	m_pNewsTree->SaveGroup(pBag);
	pBag->Release();
}

BOOL CNewsGroupCore::SetPrettyName(LPCSTR szPrettyName, int cch) {
	ExclusiveLock();
	if (cch == -1) cch = (szPrettyName == NULL) ? 0 : strlen(szPrettyName);
	BOOL f = FALSE;
	if (m_pszPrettyName != NULL) {
		XDELETE[] m_pszPrettyName;
		m_pszPrettyName = NULL;
		m_cchPrettyName = 0;
	}
	if (cch > 0) {
		m_pszPrettyName = XNEW char[(cch * sizeof(char)) + 1];
		if (m_pszPrettyName != NULL) {
			strcpy(m_pszPrettyName, szPrettyName);
			m_cchPrettyName = cch ;
			f = TRUE;
		} else {
			SetLastError(ERROR_NOT_ENOUGH_MEMORY);
		}
	} else {
		f = TRUE;
	}
	m_fVarPropChanged = TRUE;
	ExclusiveUnlock();
	return f;						
}

BOOL CNewsGroupCore::SetNativeName(LPCSTR szNativeName, int cch) {

    //
    // Validate if native name differs only in case with group name
    //
    if ( (DWORD)cch != m_cchGroupName ||
            _strnicmp( szNativeName, m_pszGroupName, cch ) ) {
        SetLastError( ERROR_INVALID_PARAMETER );
        return FALSE;
    }

	ExclusiveLock();
	if (cch == -1) cch = (szNativeName == NULL) ? 0 : strlen(szNativeName);
	BOOL f = FALSE;
	if (m_pszNativeName != NULL) {

	    if ( m_pszNativeName != m_pszGroupName ) {
    		XDELETE[] m_pszNativeName;
        }

	    m_pszNativeName = NULL;
		
	}
	if (cch > 0) {
		m_pszNativeName = XNEW char[(cch * sizeof(char)) + 1];
		if (m_pszNativeName != NULL) {
			strcpy(m_pszNativeName, szNativeName);
			f = TRUE;
		} else {
			SetLastError(ERROR_NOT_ENOUGH_MEMORY);
		}
	} else {
		f = TRUE;
	}
	m_fVarPropChanged = TRUE;
	ExclusiveUnlock();
	return f;						
}

BOOL CNewsGroupCore::SetModerator(LPCSTR szModerator, int cch) {
	ExclusiveLock();
	if (cch == -1) cch = (szModerator == NULL) ? 0 : strlen(szModerator);
	BOOL f = FALSE;
	if (m_pszModerator != NULL) {
		XDELETE[] m_pszModerator;
		m_pszModerator = NULL;
		m_cchModerator = 0;
	}
	if (cch > 0) {
		m_pszModerator = XNEW char[(cch * sizeof(char)) + 1];
		if (m_pszModerator != NULL) {
			strcpy(m_pszModerator, szModerator);
			m_cchModerator = cch ;
			f = TRUE;
		} else {
			SetLastError(ERROR_NOT_ENOUGH_MEMORY);
		}
	} else {
		f = TRUE;
	}
	ExclusiveUnlock();
	m_fVarPropChanged = TRUE;
	return f;						
}

BOOL CNewsGroupCore::SetHelpText(LPCSTR szHelpText, int cch) {
	ExclusiveLock();
	if (cch == -1) cch = (szHelpText == NULL) ? 0 : strlen(szHelpText);
	BOOL f = FALSE;
	if (m_pszHelpText != NULL) {
		XDELETE[] m_pszHelpText;
		m_pszHelpText = NULL;
		m_cchHelpText = 0;
	}
	if (cch > 0) {
		m_pszHelpText = XNEW char[(cch * sizeof(char)) + 1];
		if (m_pszHelpText != NULL) {
			strcpy(m_pszHelpText, szHelpText);
			m_cchHelpText = cch ;
			f = TRUE;
		} else {
			SetLastError(ERROR_NOT_ENOUGH_MEMORY);
		}
	} else {
		f = TRUE;
	}
	ExclusiveUnlock();
	m_fVarPropChanged = TRUE;
	return f;				
}

void
CNewsGroupCore::InsertArticleId(	
					ARTICLEID	artid
					)		{
/*++

Routine Description :

	Record the presence of an article id in our newsgroup.	
	This is called on slaves when a master sticks articles into
	a newsgroup, as well as during rebuilds initiated by nntpbld.exe

Arguments :

	artid - the article in our newsgroup

Return Value :

	None.

--*/
    //
    // If i am delete, do nothing
    //
    if ( IsDeleted() ) return;

    //
    // Lock myself first
    //
    ExclusiveLock();

    //
    // If I am deleted, do nothing
    //
    if ( m_fDeleted ) {
        ExclusiveUnlock();
        return;
    }

    //
    // Adjust high watermark
    //
    m_iHighWatermark = max( m_iHighWatermark, artid );

    //
    // Unlock it
    //
    ExclusiveUnlock();
}

ARTICLEID
CNewsGroupCore::AllocateArticleId(	)	{
/*++

Routine Description :

	Get an ID to be used for a newly posted article.
	We just bump a counter for this id.

Arguments :

	None.

Return Value

	The article id for the new article.	

--*/
    ExclusiveLock();
	ARTICLEID artid = ++m_iHighWatermark;
	ExclusiveUnlock();
	return	artid ;
}

CNewsGroupCore::AddReferenceTo(
                    ARTICLEID,
                    CArticleRef&    artref
                    ) {
/*++

Routine description :

    This function is used for cross posted articles which
    are physically stored in another newsgroup - we bump
    the number of articles in this group.

Arguments :

    We don't use our arguments anymore -
    place holders in case we ever want to create disk links

Return Value :

    TRUE if successfull - always succeed.

--*/
    if (IsDeleted()) return FALSE;

    return TRUE;
}

BOOL CNewsGroupCore::SetDriverStringProperty(   DWORD   cProperties,
                                                DWORD   rgidProperties[] )
{
    TraceFunctEnter( "CNewsGroupCore::SetDriverStringProperty" );

    HANDLE  heDone = NULL;
    HRESULT hr = S_OK;
    CNntpSyncComplete scComplete;
    INNTPPropertyBag *pPropBag = NULL;

    // get vroot
    CNNTPVRoot *pVRoot = GetVRoot();
    if ( pVRoot == NULL ) {
        ErrorTrace( 0, "Vroot doesn't exist" );
        hr = E_OUTOFMEMORY;
        goto Exit;
    }

    // Set Vroot to completion object
    scComplete.SetVRoot( pVRoot );

    // Get the property bag
    pPropBag = GetPropertyBag();
    if ( NULL == pPropBag ) {
        ErrorTrace( 0, "Get group property bag failed" );
        hr = E_UNEXPECTED;
        goto Exit;
    }

    pVRoot->SetGroup(   pPropBag, cProperties, rgidProperties, &scComplete );

    _ASSERT( scComplete.IsGood() );
    hr = scComplete.WaitForCompletion();
    if ( FAILED( hr ) ) {
        ErrorTrace( 0, "SetGroup failed with %x", hr );
    }

    // Here the property bag should have been released by
    // the driver
    pPropBag = NULL;

Exit:

    if ( pVRoot ) pVRoot->Release();
    if ( pPropBag ) pPropBag->Release();

    if ( FAILED( hr ) ) SetLastError( HRESULT_FROM_WIN32( hr ) );

    TraceFunctLeave();
    return SUCCEEDED( hr );
}

BOOL
CNewsGroupCore::IsGroupAccessible(  HANDLE hClientToken,
                                    DWORD   dwAccessDesired )
/*++
Routine description:

    Wrapper of the vroot call "CheckGroupAccess".  This function
    is called by CNewsGroup's IsGroupAccessibleInternal.

Arguments:

    HANDLE hClientToken - The client's access token to check against
    DWORD  dwAccessDesired - The desired access rights to check

Return value:

    TRUE - Access allowed
    FALSE - Access denied
--*/
{
    TraceFunctEnter( "CNewsGroupCore::IsGroupAccessible" );

    HRESULT hr = S_OK;
    CNntpSyncComplete scComplete;
    INNTPPropertyBag *pPropBag = NULL;

    //
    // If he wanted to post but we only have read permission, we'll
    // fail it
    //
    if ( (dwAccessDesired & NNTP_ACCESS_POST) && ( IsReadOnly() || !IsAllowPost() )) {
        SetLastError( ERROR_ACCESS_DENIED );
        return FALSE;
    }

    // get vroot
    CNNTPVRoot *pVRoot = GetVRoot();
    if ( pVRoot == NULL ) {
        ErrorTrace( 0, "Vroot doesn't exist" );
        hr = E_OUTOFMEMORY;
        goto Exit;
    }

    // if it's UNC Vroot and the vroot has impersonation
    // token, return true
    if ( pVRoot->GetLogonInfo() == CNNTPVRoot::VROOT_LOGON_UNC &&
         pVRoot->GetImpersonationToken() ) {
        DebugTrace( 0, "Has personation token" );
        goto Exit;
    }

    //
    // Set vroot to the completion object
    //
    scComplete.SetVRoot( pVRoot );

    // Get the property bag
    pPropBag = GetPropertyBag();
    if ( NULL == pPropBag ) {
        ErrorTrace( 0, "Get group property bag failed" );
        hr = E_UNEXPECTED;
        goto Exit;
    }

    pVRoot->CheckGroupAccess(   pPropBag,
                                hClientToken,
                                dwAccessDesired,
                                &scComplete );

    //
    // Wait for completion
    //
    _ASSERT( scComplete.IsGood() );
    hr = scComplete.WaitForCompletion();

    // Here the property bag should have been released by
    // the driver
    pPropBag = NULL;

Exit:

    if ( pVRoot ) pVRoot->Release();
    if ( pPropBag ) pPropBag->Release();

    if ( FAILED( hr ) ) SetLastError( hr );

    TraceFunctLeave();
    return SUCCEEDED( hr );
}

BOOL
CNewsGroupCore::RebuildGroup(  HANDLE hClientToken )
/*++
Routine description:

    Rebuild this group in store.

Arguments:

    HANDLE hClientToken - The client's access token to check against

Return value:

    TRUE - Succeeded  FALSE otherwise
--*/
{
    TraceFunctEnter( "CNewsGroupCore::Rebuild" );

    HRESULT hr = S_OK;
    CNntpSyncComplete scComplete;
    INNTPPropertyBag *pPropBag = NULL;

    // get vroot
    CNNTPVRoot *pVRoot = GetVRoot();
    if ( pVRoot == NULL ) {
        ErrorTrace( 0, "Vroot doesn't exist" );
        hr = E_OUTOFMEMORY;
        goto Exit;
    }

    //
    // Set vroot to the completion object
    //
    scComplete.SetVRoot( pVRoot );

    // Get the property bag
    pPropBag = GetPropertyBag();
    if ( NULL == pPropBag ) {
        ErrorTrace( 0, "Get group property bag failed" );
        hr = E_UNEXPECTED;
        goto Exit;
    }

    pVRoot->RebuildGroup(   pPropBag,
                            hClientToken,
                            &scComplete );

    //
    // Wait for completion
    //
    _ASSERT( scComplete.IsGood() );
    hr = scComplete.WaitForCompletion();

    // Here the property bag should have been released by
    // the driver
    pPropBag = NULL;

Exit:

    if ( pVRoot ) pVRoot->Release();
    if ( pPropBag ) pPropBag->Release();

    if ( FAILED( hr ) ) SetLastError( hr );

    TraceFunctLeave();
    return SUCCEEDED( hr );
}

BOOL
CNewsGroupCore::ShouldCacheXover()
/*++
Routine description:

    Check if I should insert entry into xix cache for this group.

Arguments:

    None.

Return value:

    TRUE if the group doesn't have per-item sec-desc and the
    cache hit counter is greater than threshold; FALSE otherwise
--*/
{
    CGrabShareLock lock(this);

    //
    // First check cache hit count, if it's below threshold,
    // we'll return FALSE immediately
    //
    if ( m_dwCacheHit < CACHE_HIT_THRESHOLD ) return FALSE;

    //
    // If it's greater than the CACHE_HIT_THRESHOLD, we'll
    // still check if the group has per-item sec-desc
    //

    //
    // If it's file system driver, we'll always return TRUE if
    // it has been referenced for enough times, since it doesn't
    // have per item sec-desc
    //
    CNNTPVRoot *pVRoot = GetVRootWithoutLock();
    if ( NULL == pVRoot ) {
        // No vroot ?  a bad group ?  no cache
        return FALSE;
    }

    if ( pVRoot->GetLogonInfo() != CNNTPVRoot::VROOT_LOGON_EX ) {
        pVRoot->Release();
        return TRUE;
    }

    pVRoot->Release();

    //
    // For exchange vroots, we'll check sec-desc
    //
    INNTPPropertyBag *pPropBag = GetPropertyBag();
    _ASSERT( pPropBag );    // should never be NULL;
    BYTE pbBuffer[512];
    DWORD dwLen = 512;
    BOOL  f;
    HRESULT hr = pPropBag->GetBLOB( NEWSGRP_PROP_SECDESC, pbBuffer, &dwLen );
    pPropBag->Release();

    f = ( HRESULT_FROM_WIN32( ERROR_NOT_FOUND ) != hr );

    return f;
}

BOOL
CNewsGroupCore::ComputeXoverCacheDir(	char*	szPath,
										BOOL&	fFlatDir,
										BOOL	fLocksHeld
										) 	{
/*++

Routine Description :

	Figure out where the .XIX files should be saved and return whether
	they are flat within the direectory !

Arguments :

	szPath - gets the target directory !

Return Value :

	TRUE if .xix files are flat in the directory - FALSE otherwise !

--*/

	BOOL	fReturn = FALSE ;

	if( !fLocksHeld ) 	{
		ShareLock() ;
	}
	DWORD	cbOut ;

	CNNTPVRoot*	pVRoot = GetVRootWithoutLock() ;
	if( pVRoot != 0 ) {
		fReturn =
			pVRoot->GetXoverCacheDir(	
									this,
									szPath,
									MAX_PATH*2,
									&cbOut,
									&fFlatDir
									) ;
		pVRoot->Release() ;
		if( !fReturn || cbOut == 0 ) 	{
			CNntpServerInstanceWrapperEx*	pInst = m_pNewsTree->m_pInstWrapper ;
			PCHAR	szTemp = pInst->PeerTempDirectory() ;
			if( strlen( szTemp ) < MAX_PATH*2 ) 	{
				strcpy( szPath, szTemp ) ;
				fFlatDir = TRUE ;
				fReturn = TRUE ;
			}
		}
	}

	if( !fLocksHeld ) 	{
		ShareUnlock() ;
	}

	return	fReturn ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\nntp\server\newstree\src\nntpbag.cpp ===
// NNTPPropertyBag.cpp : Implementation of CNNTPPropertyBag
#include "stdinc.h"


/////////////////////////////////////////////////////////////////////////////
// CNNTPPropertyBag - Interface methods

HRESULT CNNTPPropertyBag::Validate()
/*++
Routine description:

    Current logic: a property bag could be empty, but it must be associated
    with a newsgroup.  Otherwise, ie. the news group pointer is not initialized,
    Get/Set operations can not be done on this property bag.  Because right now
    it's only relaying properties and doesn't have its own storage.

Arguments:

    None.

Return value:

    None.
--*/
{
    _ASSERT( m_pParentGroup );
    m_PropBag.Validate();
    return S_OK;
}

ULONG _stdcall CNNTPPropertyBag::Release() {
	_ASSERT(m_pcRef != NULL);
	
	// see if we need to save changes back
	if (m_fPropChanges) {
	    m_fPropChanges = FALSE;
	    m_pParentGroup->SaveFixedProperties();
	}
	
	// our parent group should always have at least one reference
	if ( InterlockedDecrement( m_pcRef ) == 0 ) {
	    _ASSERT( 0 );
	}
	
	return *(m_pcRef);
}

STDMETHODIMP CNNTPPropertyBag::PutBLOB(IN DWORD dwID, IN DWORD cbValue, IN PBYTE pbValue)
/*++
Routine description:

    Put property by blob.

Arguments:

    IN DWORD dwID   -   The property ID
    IN DWORD cbValue-   The length, in bytes of blob
    IN PBYTE pbValue-   The pointer to the blob

Return value:

    S_OK            - Success
    S_FALSE			- OK, but property doesn't previously exist
    E_FAIL          - Failed.
    E_INVALIDARG    - Arguments invalid ( possibly prop id not supported )
    E_OUTOFMEMORY   - Memory allocation fail
    CO_E_NOT_SUPPORTED- The operation not supported ( eg. some properties are read only )
--*/
{
    _ASSERT( cbValue > 0 );
    _ASSERT( pbValue );

    //
    // Validate if the bag has been initialized
    //
    Validate();

    if ( DRIVER_OWNED( dwID ) ) 
    	return m_PropBag.PutBLOB( dwID, pbValue, cbValue );
    
    switch( dwID ) {

		case NEWSGRP_PROP_PRETTYNAME:
		    _ASSERT( cbValue == 0 || *(pbValue + cbValue - 1) == 0 );
			if ( !m_pParentGroup->SetPrettyName( LPCSTR(pbValue), cbValue ) ) 
				return HRESULT_FROM_WIN32( GetLastError() );
			break;

		case NEWSGRP_PROP_DESC:
		    _ASSERT( cbValue == 0 || *(pbValue + cbValue - 1 ) == 0 );
			if ( !m_pParentGroup->SetHelpText( LPCSTR(pbValue), cbValue ) )
				return HRESULT_FROM_WIN32( GetLastError() );
			break;

		case NEWSGRP_PROP_MODERATOR:
		    _ASSERT( cbValue == 0 || *(pbValue + cbValue - 1 ) == 0 );
			if ( !m_pParentGroup->SetModerator( LPCSTR(pbValue), cbValue ) )
				return HRESULT_FROM_WIN32( GetLastError() );
			break;

	    case NEWSGRP_PROP_NATIVENAME:
	        _ASSERT( cbValue == 0 || *(pbValue + cbValue - 1 ) == 0 );
	        if ( !m_pParentGroup->SetNativeName( LPCSTR(pbValue), cbValue) )
	            return HRESULT_FROM_WIN32( GetLastError() );
	        break;

        default:
            return E_INVALIDARG;
    }

	return S_OK;
}

STDMETHODIMP CNNTPPropertyBag::GetBLOB(IN DWORD dwID, OUT PBYTE pbValue, OUT PDWORD pcbValue)
/*++
Routine description:

    Get property by blob.

Arguments:

    IN DWORD dwID       - Propert ID to get
    OUT PBYTE pbValue   - Buffer to contain value to be returned
    IN PDWORD pcbValue  - Buffer length
    OUT PDWORD pcbValue - Buffer length needed, or property size returned

Return value

    S_OK            - Success
    E_FAIL          - Fail
    HRESULT_FROM_WIN32( ERROR_NOT_FOUND )- Invalid arguments ( possibly property id not supported )
    TYPE_E_BUFFERTOOSMALL - Buffer too small, please check actual buffer size needed
                            in pcbValue
--*/
{
    _ASSERT( pbValue );
    _ASSERT( pcbValue );

    DWORD   dwSizeNeeded;
    LPCSTR	lpstrSource;
    HRESULT	hr;
    DWORD	dwLen = *pcbValue;

    //
    // Validate if the bag has been initiated
    //
    Validate();

    if ( DRIVER_OWNED( dwID ) ) {
    	hr = m_PropBag.GetBLOB( dwID, pbValue, &dwLen );
    	_ASSERT( dwLen <= *pcbValue );
    	*pcbValue = dwLen;
    	return hr;
    }
    	
    switch( dwID ) {
    
        case NEWSGRP_PROP_NATIVENAME:	// must have property
            _ASSERT( m_pParentGroup->m_pszGroupName );
            dwSizeNeeded =  m_pParentGroup->GetGroupNameLen() * sizeof( CHAR );
            if ( *pcbValue < dwSizeNeeded ) {
                *pcbValue = dwSizeNeeded;
                return TYPE_E_BUFFERTOOSMALL;
            }
            CopyMemory( pbValue, m_pParentGroup->GetNativeName(), dwSizeNeeded );
            *pcbValue = dwSizeNeeded;  
            break;
            
        case NEWSGRP_PROP_NAME:		// must have property
            dwSizeNeeded = ( m_pParentGroup->GetGroupNameLen() ) * sizeof( CHAR );
            if ( *pcbValue < dwSizeNeeded ) {
                *pcbValue = dwSizeNeeded;
                return TYPE_E_BUFFERTOOSMALL;
            }
            CopyMemory( pbValue, m_pParentGroup->GetGroupName(), dwSizeNeeded );
            *pcbValue = dwSizeNeeded ;  
            break;

        case NEWSGRP_PROP_PRETTYNAME:	// optional
        	if ( lpstrSource = m_pParentGroup->GetPrettyName( &dwSizeNeeded ) ) {
        		if ( *pcbValue < dwSizeNeeded ) { 
        			*pcbValue = dwSizeNeeded;
        			return TYPE_E_BUFFERTOOSMALL;
        		}
        		CopyMemory( pbValue, lpstrSource, dwSizeNeeded );
        		*pcbValue = dwSizeNeeded;
        	} else { // property doesn't exist
        		*pcbValue = 1;
        		*pbValue = 0;
        	}
        	break;

        case NEWSGRP_PROP_DESC:	// optional
        	if ( lpstrSource = m_pParentGroup->GetHelpText( &dwSizeNeeded ) ) {
        		if ( *pcbValue < dwSizeNeeded  ) { 
        			*pcbValue = dwSizeNeeded;
        			return TYPE_E_BUFFERTOOSMALL;
        		}
        		CopyMemory( pbValue, lpstrSource, dwSizeNeeded );
        		*pcbValue = dwSizeNeeded;
        	} else { // property doesn't exist
        		*pcbValue = 1;
        		*pbValue = 0;
        	}
        	break;

        case NEWSGRP_PROP_MODERATOR:	// optional
        	if ( lpstrSource = m_pParentGroup->GetModerator( &dwSizeNeeded ) ) {
        		if ( *pcbValue < dwSizeNeeded ) { 
        			*pcbValue = dwSizeNeeded;
        			return TYPE_E_BUFFERTOOSMALL;
        		}
        		CopyMemory( pbValue, lpstrSource, dwSizeNeeded );
        		*pcbValue = dwSizeNeeded;
        	} else { // property doesn't exist
        		*pcbValue = 1;
        		*pbValue = 0;
        	}
        	break;
        	
        default:
            return HRESULT_FROM_WIN32( ERROR_NOT_FOUND );
    }        
            
    return S_OK;
}        

STDMETHODIMP CNNTPPropertyBag::PutDWord(IN DWORD dwID, IN DWORD dwValue)
/*++
Routine description:

    Put a dword property

Arguments:

    IN DWORD dwID       - The property id
    IN DWORD dwValue    - The value to be put

Return value:

    S_OK    - Success
    E_FAIL  - Fail
    E_INVALIDARG - Invalid arguments ( possibly the property not supported )
    CO_E_NOT_SUPPORTED - Operation not supported ( eg. property readonly )
--*/ 
{
	FILETIME ftBuffer;

    //
    // Validate if the property bag has been initiated
    //
    Validate();

    if ( DRIVER_OWNED( dwID ) ) 
    	return m_PropBag.PutDWord( dwID, dwValue );
    	
    switch( dwID ) {
    
        case NEWSGRP_PROP_LASTARTICLE:
            m_pParentGroup->SetHighWatermark( dwValue );
			m_fPropChanges = TRUE;
            break;

        case NEWSGRP_PROP_FIRSTARTICLE:
            m_pParentGroup->SetLowWatermark( dwValue );
			m_fPropChanges = TRUE;
            break;

        case NEWSGRP_PROP_ARTICLECOUNT:
            m_pParentGroup->SetMessageCount( dwValue );
			m_fPropChanges = TRUE;
            break;

		case NEWSGRP_PROP_DATEHIGH:
			ftBuffer = m_pParentGroup->GetCreateDate();
			ftBuffer.dwHighDateTime = dwValue;
			m_pParentGroup->SetCreateDate( ftBuffer );
			m_fPropChanges = TRUE;
			break;

		case NEWSGRP_PROP_DATELOW:
			ftBuffer = m_pParentGroup->GetCreateDate();
			ftBuffer.dwLowDateTime = dwValue;
			m_pParentGroup->SetCreateDate( ftBuffer );
			m_fPropChanges = TRUE;
			break;

        default:
            return E_INVALIDARG;
    }

    return S_OK;
} 

STDMETHODIMP CNNTPPropertyBag::GetDWord(IN DWORD dwID, OUT PDWORD pdwValue)
/*++
Routine description:

    Get dword properties

Arguments:

    IN DWORD dwID   - The property ID.
    OUT PDWORD pdwValue - Buffer for the property value to be returned

Return value:

    S_OK    - Success
    E_FAIL  - Fail
    HRESULT_FROM_WIN32( ERROR_NOT_FOUND ) - Invalid arguments ( possibly property not supported )
-*/
{
    _ASSERT( pdwValue );
	FILETIME	ftBuffer;

	Validate();
	if ( DRIVER_OWNED( dwID ) )
		return m_PropBag.GetDWord( dwID, pdwValue );
		
    switch( dwID ) {
    
        case NEWSGRP_PROP_GROUPID:
            *pdwValue = m_pParentGroup->GetGroupId();
            break;

        case NEWSGRP_PROP_LASTARTICLE:
            *pdwValue = m_pParentGroup->GetHighWatermark();
            break;

        case NEWSGRP_PROP_FIRSTARTICLE:
            *pdwValue = m_pParentGroup->GetLowWatermark();
            break;

        case NEWSGRP_PROP_ARTICLECOUNT:
            *pdwValue = m_pParentGroup->GetMessageCount();
            break;

		case NEWSGRP_PROP_NAMELEN:
			*pdwValue = m_pParentGroup->GetGroupNameLen();
			break;

		case NEWSGRP_PROP_DATELOW:
			ftBuffer = m_pParentGroup->GetCreateDate();
			*pdwValue = ftBuffer.dwLowDateTime;
			break;

		case NEWSGRP_PROP_DATEHIGH:
			ftBuffer = m_pParentGroup->GetCreateDate();
			*pdwValue = ftBuffer.dwHighDateTime;
			break;

		default:
            return HRESULT_FROM_WIN32( ERROR_NOT_FOUND );
    }

    return S_OK;
}
        
STDMETHODIMP CNNTPPropertyBag::PutInterface(DWORD dwID, IUnknown * punkValue)
{
	// TODO: Add your implementation code here

	return E_NOTIMPL;
}

STDMETHODIMP CNNTPPropertyBag::GetInterface(DWORD dwID, IUnknown * * ppunkValue)
{
	// TODO: Add your implementation code here

	return E_NOTIMPL;
}

STDMETHODIMP CNNTPPropertyBag::PutBool( IN DWORD dwID, IN BOOL fValue )
/*++
Routine description:

    Put a boolean property

Arguments:

    IN DWORD dwID - The property id.
    IN BOOL  fValue- The boolean value to be put

Return value:

    S_OK    - Success
    E_FAIL  - Fail
    E_INVALIDARG - Invalid argument ( possibly the proerty not supported )
--*/
{
    //
    // Validate if the bag has been initiated
    //
    Validate();

    if ( DRIVER_OWNED( dwID ) ) 
    	return m_PropBag.PutBool( dwID, fValue );
    	
    switch( dwID ) {

        case NEWSGRP_PROP_READONLY:
            m_pParentGroup->SetReadOnly( fValue );
			m_fPropChanges = TRUE;
            break;

		case NEWSGRP_PROP_ISSPECIAL:
			m_pParentGroup->SetSpecial( fValue );
			m_fPropChanges = TRUE;
			break;

        default:
            return E_INVALIDARG;
    }

    return S_OK;
}

STDMETHODIMP CNNTPPropertyBag::GetBool( IN DWORD dwID, OUT PBOOL pfValue )
/*++
Routine description:

    Get a boolean property

Arguments:

    IN DWORD dwID   - The property id
    OUT PBOOL pfValue   - Buffer for boolean value returned

Return value:

    S_OK    - Success
    E_FAIL  - Fail
    HRESULT_FROM_WIN32( ERROR_NOT_FOUND )- Invalid argument ( possibly the property not supported )
--*/
{
    _ASSERT( pfValue );

    //
    // Validate if the bag has been initiated
    //
    Validate();

    if ( DRIVER_OWNED( dwID ) )
    	return m_PropBag.GetBool( dwID, pfValue );
    	
    switch( dwID ) {
        
        case NEWSGRP_PROP_READONLY:
            *pfValue = m_pParentGroup->IsReadOnly();
            break;

		case NEWSGRP_PROP_ISSPECIAL:
			*pfValue = m_pParentGroup->IsSpecial();
			break;

        default:
            return HRESULT_FROM_WIN32( ERROR_NOT_FOUND );
    }

    return S_OK;
}
         
STDMETHODIMP CNNTPPropertyBag::RemoveProperty(DWORD dwID)
{
	_ASSERT( DRIVER_OWNED( dwID ) );
	
	return m_PropBag.RemoveProperty( dwID );
}

/////////////////////////////////////////////////////////////////////
// CNNTPPropertyBag - Priate methods
CNNTPPropertyBag::STRING_COMP_RESULTS
CNNTPPropertyBag::ComplexStringCompare( 	IN LPCSTR sz1, 
											IN LPCSTR sz2, 
											IN DWORD dwLen )
/*++
Routine Description:

	Compare two given strings.

Arguments:

	IN LPCSTR sz1 - The first string to be compared
	IN LPCSTR sz2 - The second string to be compared
	IN DWORD dwLen - The length to compare

Return value:

	0 - String exactly the same
	1 - String not exactly the same but only varies in case
	2 - Otherwise
--*/
{
	_ASSERT( sz1 );
	_ASSERT( sz2 );
	_ASSERT( dwLen > 0 );

	LPCSTR	lpstr1 = sz1; 
	LPCSTR	lpstr2 = sz2;
	BOOL	fCaseDifferent = FALSE;

	while ( dwLen > 0 && *lpstr1 && *lpstr2 && 
			tolower(*lpstr1) == tolower(*lpstr2) ) {
		if ( *lpstr1 != *lpstr2 ) fCaseDifferent = TRUE;
		lpstr1++, lpstr2++, dwLen--;
	}

	if ( dwLen > 0 )
		return CNNTPPropertyBag::DIFFER;	// big difference between two strings
	_ASSERT( dwLen == 0 );
	if ( fCaseDifferent ) return CNNTPPropertyBag::DIFFER_IN_CASE;
	else return CNNTPPropertyBag::SAME;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\nntp\server\newstree\src\makefile.inc ===
$(O)\mailmsg.h : $(STAXINC)\export\mailmsg.idl
    $(MIDL) \
    $(PACKING) \
    $(INCPATH0) \
    -char unsigned \
    -ms_ext -c_ext \
    -proxy $(PASS0_SOURCEDIR)\mailmsg_p.c \
    -dlldata $(PASS0_SOURCEDIR)\dlldata.c \
    -iid $(MIDL_UUIDDIR)\mailmsg_i.c \
    -header $@ \
    -tlb $(O)\mailmsg.tlb \
    -cpp_cmd $(TARGET_CPP) \
    $(C_DEFINES) \
    $(MIDL_FLAGS) \
    $(MIDL_OPTIMIZATION) \
    $**

$(O)\nntpmsg.h: ..\..\server\nntpmsg.mc
    mc -v -r $(O) -h $(O) $**
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\nntp\server\newstree\src\newstree.cpp ===
/*++

        newstree.cpp

        This file contains the code implementing the CNewsTreeCore object.
        There can only be one CNewsTreeCore object per Tigris server.
        Each CNewsTreeCore object is responsible for helping callers
        search and find arbitrary newsgroups.

        To support this, the CNewsTreeCore object maintains two HASH Tables -
        One hash table for searching for newsgroups by name, another
        to search by GROUP ID.
        Additionally, we maintain a linked list of (alphabetical) of all
        the newsgroups.  And finally, we maintain a thread which is used
        to periodically save newsgroup information and handle expiration.


--*/

#define         DEFINE_FHASH_FUNCTIONS
#include    "stdinc.h"
#include <time.h>
#include "nntpmsg.h"

//
// Out latest groupvar.lst version
//
#define GROUPVAR_VER    1

//template      class   TFHash< CGrpLpstr, LPSTR > ;
//template      class   TFHash< CGrpGroupId,    GROUPID > ;

char    szSlaveGroup[]  = "_slavegroup._slavegroup" ;
#define VROOT_CHANGE_LATENCY 10000

// External functions
DWORD   ScanDigits(     char*   pchBegin,       DWORD   cb );
DWORD   Scan(   char*   pchBegin,       DWORD   cb );
void    StartHintFunction( void );
void    StopHintFunction( void );
BOOL    fTestComponents( const char * szNewsgroups      );
VOID    NntpLogEvent(
    IN DWORD  idMessage,              // id for log message
    IN WORD   cSubStrings,            // count of substrings
    IN const CHAR * apszSubStrings[], // substrings in the message
    IN DWORD  errCode                 // error code if any
    );

VOID
NntpLogEventEx(
    IN DWORD  idMessage,               // id for log message
    IN WORD   cSubStrings,             // count of substrings
    IN const  CHAR * apszSubStrings[], // substrings in the message
    IN DWORD  errCode,                 // error code if any
        IN DWORD  dwInstanceId                     // virtual server instance id
    );

DWORD
Scan(   char*   pchBegin,       DWORD   cb ) {
        //
        //      This is a utility used when reading a newsgroup
        //      info. from disk.
        //

        for( DWORD      i=0; i < cb; i++ ) {
                if( pchBegin[i] == ' ' || pchBegin[i] == '\n' ) {
                        return i+1 ;
                }
        }
        return  0 ;
}

DWORD
ScanDigits(     char*   pchBegin,       DWORD   cb ) {
        //
        //      This is a utility used when reading a newsgroup
        //      info. from disk.
        //

        for( DWORD      i=0; i < cb; i++ ) {
                if( pchBegin[i] == ' ' || pchBegin[i] == '\n' || pchBegin[i] == '\r' ) {
                        return i+1 ;
                }
                if( !isdigit( (UCHAR)pchBegin[i] ) && pchBegin[i] != '-' )     {
                        return  0 ;
                }
        }
        return  0 ;
}

DWORD
ComputeHash( LPSTR      lpstrIn ) {
        //
        //      Compute a hash value for the newsgroup name
        //

        return  CRCHash( (BYTE*)lpstrIn, strlen( lpstrIn ) + 1 ) ;
}

DWORD   ComputeGroupIdHash(     GROUPID grpid )         {
        //
        //      Compute a hash value for the newsgroup id
        //

        return  grpid ;
}

//
//      static term for CNewsTreeCore objects
//
void
CNewsTreeCore::TermTree()       {
/*++

Routine Description :

        save's the tree and releases our references on the newsgroup objects.

Arguments :

        None.

Return Value :

        TRUE if successfull.


--*/
        if (m_pFixedPropsFile && m_pVarPropsFile) {

                if (!SaveTree()) {
                        // log event??
                } else {
                    m_pVarPropsFile->Compact();
                }
                m_pFixedPropsFile->Term();
                XDELETE m_pFixedPropsFile;
                m_pFixedPropsFile = NULL;
                XDELETE m_pVarPropsFile;
                m_pVarPropsFile = NULL;
        }

        m_LockTables.ExclusiveLock();

        // empty our two hash tables, and remove our references on all of the
        // newsgroups
        m_HashNames.Empty();
        m_HashGroupId.Empty();

        CNewsGroupCore *p = m_pFirst;
        while (p && p->IsDeleted()) p = p->m_pNext;
        if (p) p->AddRef();
        m_LockTables.ExclusiveUnlock() ;

        while (p != NULL) {
                m_LockTables.ExclusiveLock();
                CNewsGroupCore *pThis = p;
                p = p->m_pNext;
                while (p && p->IsDeleted()) p = p->m_pNext;
                if ( p ) p->AddRef();
                pThis->MarkDeleted();
                m_LockTables.ExclusiveUnlock();
                pThis->Release();
                pThis->Release();
        }


        m_pVRTable->EnumerateVRoots(NULL, CNewsTreeCore::DropDriverCallback);
}

BOOL
CNewsTreeCore::StopTree()       {
/*++

Routine Description :

        This function signals all of the background threads we create that
        it is time to stop and shuts them down.

Arguments :

        None.

Return Value :
        TRUE if Successfull.

--*/

    m_LockTables.ExclusiveLock();
        m_fStoppingTree = TRUE;
        m_LockTables.ExclusiveUnlock();

        return TRUE;
}

BOOL
CNewsTreeCore::InitNewsgroupGlobals(DWORD cNumLocks)    {
/*++

Routine Description :

        Set up all the newsgroup class globals - this is two critical sections
        used for allocating article id's

Arguments :

        None.

Return Value :

        None.

--*/

        //
        //      The only thing we have are critical sections for allocating
        //      article-id's.
        //

        InitializeCriticalSection( & m_critIdAllocator ) ;
        //InitializeCriticalSection( & m_critLowAllocator ) ;

        m_NumberOfLocks = cNumLocks ;

        m_LockPathInfo = XNEW CShareLockNH[m_NumberOfLocks] ;

        if( m_LockPathInfo != 0 )
                return  TRUE ;
        else
                return  FALSE ;
}

void
CNewsTreeCore::TermNewsgroupGlobals()   {
/*++

Routine Description :

        Release and destroy all class global object.s

Arguments :

        None.

Return Value

        TRUE if successfull (always succeed).

--*/

        //
        //      Done with our critical section !
        //

        if( m_LockPathInfo != 0 )       {
                XDELETE[]       m_LockPathInfo ;
                m_LockPathInfo = 0 ;
        }

        DeleteCriticalSection( &m_critIdAllocator ) ;
        //DeleteCriticalSection( &m_critLowAllocator ) ;
}

void
CNewsTreeCore::RenameGroupFile()        {
/*++

Routine Description :

        This function just renames the file containing all the group info.
        We are called during recover boot when we think the newsgroup file
        may be corrupt or whatever, and we wish to save the old version
        before we create a new one.

Arguments :

        None.

Return Value :

        None.

--*/




}


CNewsTreeCore::CNewsTreeCore(INntpServer *pServerObject) :
        m_pFirst( 0 ),
        m_pLast( 0 ),
        m_cGroups( 0 ),
        m_idStartSpecial( FIRST_RESERVED_GROUPID ),
        m_idLastSpecial( LAST_RESERVED_GROUPID ),
        m_idSpecialHigh( FIRST_RESERVED_GROUPID ),
        m_idSlaveGroup( INVALID_ARTICLEID ),
        m_idStart( FIRST_GROUPID ),
        m_fStoppingTree( FALSE ),
        m_idHigh( FIRST_GROUPID ),
        m_pVRTable(NULL),
        m_pFixedPropsFile(NULL),
        m_pVarPropsFile(NULL),
        m_pServerObject(pServerObject),
        m_fVRTableInit(FALSE),
        m_pInstWrapper( NULL )
{
        m_inewstree.Init(this);
        // keep a reference for ourselves
        m_inewstree.AddRef();
}

CNewsTreeCore::~CNewsTreeCore() {
        TraceFunctEnter( "CNewsTreeCore::~CNewsTreeCore" ) ;
        TermNewsgroupGlobals();
        TraceFunctLeave();
}

BOOL
CNewsTreeCore::Init(
                        CNNTPVRootTable *pVRTable,
                        CNntpServerInstanceWrapperEx *pInstWrapper,
                        BOOL& fFatal,
                        DWORD cNumLocks,
                        BOOL fRejectGenomeGroups
                        ) {
/*++

Routine Description :

        Initialize the news tree.
        We need to setup the hash tables, check that the root virtual root is intact
        and then during regular server start up we would load a list of newsgroups from
        a file.

Arguments :


Return Value :

        TRUE if successfull.

--*/
        //
        //      This function will initialize the newstree object
        //      and read the group.lst file if it can.
        //

        TraceFunctEnter( "CNewsTreeCore::Init" ) ;

        fFatal = FALSE;
        m_fStoppingTree = FALSE;
        m_fRejectGenomeGroups = fRejectGenomeGroups;
        m_pVRTable = pVRTable;

        BOOL    fRtn = TRUE ;

        //
        // Set the instance wrapper
        //
        m_pInstWrapper = pInstWrapper;

        //
        //      Init objects global to newsgroup scope
        //
        if( !InitNewsgroupGlobals(cNumLocks) ) {
                fFatal = TRUE ;
                return FALSE ;
        }

        m_LockTables.ExclusiveLock() ;

        fRtn &= m_HashNames.Init( &CNewsGroupCore::m_pNextByName,
                                                          10000,
                                                          5000,
                                                          ComputeHash,
                                                          2,
                                                          &CNewsGroupCore::GetKey,
                                                          &CNewsGroupCore::MatchKey);
        fRtn &= m_HashGroupId.Init( &CNewsGroupCore::m_pNextById,
                                                                10000,
                                                                5000,
                                                                ComputeGroupIdHash,
                                                                2,
                                                                &CNewsGroupCore::GetKeyId,
                                                                &CNewsGroupCore::MatchKeyId) ;
        m_cDeltas = 0 ;         // OpenTree can call CNewsTreeCore::Dirty() while doing error checking -
                                                // so initialize it now !

        m_LockTables.ExclusiveUnlock() ;

        if( !fRtn ) {
                fFatal = TRUE ;
                return  FALSE ;
        }

        return  fRtn ;
}

BOOL
CNewsTreeCore::LoadTreeEnumCallback(DATA_BLOCK &block, void *pContext, DWORD dwOffset, BOOL bInOrder ) {
        TraceQuietEnter("CNewsTreeCore::LoadTreeEnumCallback");

        static DWORD dwHintCounter=0;
        static time_t tNextHint=0;

        // Update our hints roughly every five seconds.  We only check the
        // time every 10 groups or so..
        if( dwHintCounter++ % 10 == 0 ) {
                time_t now = time(NULL);
                if (now > tNextHint) {
                        StartHintFunction();
                        tNextHint = now + 5;
                }
        }

        CNewsTreeCore *pThis = (CNewsTreeCore *) pContext;
        INNTPPropertyBag *pPropBag;
        HRESULT hr = S_OK;

        CGRPCOREPTR pNewGroup;

        //DebugTrace((DWORD_PTR) pThis, "loading group %s/%i", block.szGroupName,
        //      block.dwGroupId);

        if (!pThis->CreateGroupInternal(block.szGroupName,
                                                                        block.szGroupName,
                                                                        block.dwGroupId,
                                                                        FALSE,
                                                                        NULL,
                                                                        block.bSpecial,
                                                                        &pNewGroup,
                                                                        FALSE,
                                                                        TRUE,
                                    FALSE,
                                    bInOrder ))
        {
                TraceFunctLeave();
                return FALSE;
        }

        _ASSERT(pNewGroup != NULL);

        pNewGroup->SetHighWatermark(block.dwHighWaterMark);
        pNewGroup->SetLowWatermark(block.dwLowWaterMark);
        pNewGroup->SetMessageCount(block.dwArtCount);
        pNewGroup->SetReadOnly(block.bReadOnly);
        pNewGroup->SetCreateDate(block.ftCreateDate);
        pNewGroup->SetExpireLow( block.dwLowWaterMark ? block.dwLowWaterMark-1 : 0 );

        // Load the grouplist offset, we have to ask the property bag to do so
        pPropBag = pNewGroup->GetPropertyBag();
        _ASSERT( pPropBag );    // should not be zero in any case
        hr = pPropBag->PutDWord( NEWSGRP_PROP_FIXOFFSET, dwOffset );
        if ( FAILED( hr ) ) {
            ErrorTrace( 0, "Loading fix offset failed %x", hr );
            pPropBag->Release();
            TraceFunctLeave();
            return FALSE;
        }

    pPropBag->Release();

    //
        // Set read only to be the value we want to set last, since at this point
        // we are ready to be posted to, if readonly is false
        //
        pNewGroup->SetAllowPost( TRUE );

        //
        // Set the group to be expireable, since at this moment we are ready
        //
        pNewGroup->SetAllowExpire( TRUE );

        return TRUE;
}

//
// the format of these records is:
// <groupid><helptext>0<moderator>0<prettyname>0
//

void
CNewsTreeCore::FlatFileOffsetCallback(void *pTree,
                                                                          BYTE *pData,
                                                                          DWORD cData,
                                                                          DWORD iNewOffset)
{
        CNewsTreeCore *pThis = (CNewsTreeCore *) pTree;

        _ASSERT(cData >= 4);
        DWORD iGroupId = *((DWORD *) pData);

        CNewsGroupCore *pGroup = pThis->m_HashGroupId.SearchKey(iGroupId);
        _ASSERT(pGroup);
        if (pGroup) {
                pGroup->SetVarOffset(iNewOffset);
        }
}

//
// load a flatfile record and save the properties into the group object
//
// assumes that the hashtable lock is held in R or W mode.
//
HRESULT
CNewsTreeCore::ParseFFRecord(BYTE *pData,
                                                         DWORD cData,
                                                         DWORD iNewOffset,
                                                         DWORD dwVersion )
{
        DWORD iGroupId = *((DWORD *) pData);

        char *pszHelpText = (char *) (pData + 4);
        int cchHelpText = strlen(pszHelpText);
        char *pszModerator = pszHelpText + cchHelpText + 1;
        int cchModerator = strlen(pszModerator);
        char *pszPrettyName = pszModerator + cchModerator + 1;
        int cchPrettyName = strlen(pszPrettyName);
        DWORD dwCacheHit = 0;   // Default to be no hit

        //
        // If version >= 1, we need to pick up property "dwCacheHit"
        //
        if ( dwVersion >= 1 ) {
            PBYTE pb = PBYTE(pszPrettyName + cchPrettyName + 1);
            CopyMemory( &dwCacheHit, pb, sizeof( DWORD ) );
        }

        CNewsGroupCore *pGroup = m_HashGroupId.SearchKey(iGroupId);
        if (pGroup) {
                if (cchHelpText) pGroup->SetHelpText(pszHelpText, cchHelpText+1);
                if (cchModerator) pGroup->SetModerator(pszModerator, cchModerator+1);
                if (cchPrettyName) pGroup->SetPrettyName(pszPrettyName, cchPrettyName+1);
                pGroup->SetVarOffset(iNewOffset);
                pGroup->SetCacheHit( dwCacheHit );

                //
            // Whenever the version is old, we'll mark that the group's var property
            // has been changed, so that we'll force the record to be re-written into
            // flatfile, with a most current version number
            //
            if ( dwVersion < GROUPVAR_VER ) {
                pGroup->ChangedVarProps();
            }
        } else {
                return E_FAIL;
        }

        return S_OK;
}

//
// save the variable length properties into a flatfile record.  since the
// max length of these properties is 512 bytes each, and there are 3 of
// them we shouldn't be able to overflow a flatfile record.
//
// caller is passing in BYTE pData[MAX_RECORD_SIZE];
HRESULT 
CNewsTreeCore::BuildFFRecord(CNewsGroupCore *pGroup,
                                                         BYTE *pData,
                                                         DWORD *pcData)
{
	 TraceFunctEnter("CNewsTreeCore::BuildFFRecord");
        *pcData = 0;
        const char *psz;
        DWORD cch;
        DWORD dwCacheHit;

        pGroup->SavedVarProps();

        _ASSERT(MAX_RECORD_SIZE > 512 + 512 + 512 + 4);

        // save the group id
        DWORD dwGroupId = pGroup->GetGroupId();
        memcpy(pData + *pcData, &dwGroupId, sizeof(DWORD)); *pcData += 4;

        // save the help text (including the trailing 0);
        psz = pGroup->GetHelpText(&cch);
        if (cch == 0) {
                pData[*pcData] = 0; (*pcData)++;
        } 
        else if (*pcData + cch > MAX_RECORD_SIZE ) {
        	// don't save it if invalid.
        	ErrorTrace(0,"data to copy is greater than buffer size");
        	*pcData = 0;
        	goto Exit;
        }
        else {
                memcpy(pData + *pcData, psz, cch ); *pcData += cch ;
        }
        _ASSERT(*pcData < MAX_RECORD_SIZE);

        // save the moderator (including the trailing 0);
        psz = pGroup->GetModerator(&cch);
        if (cch == 0) {
                pData[*pcData] = 0; (*pcData)++;
        } 
        else if (*pcData + cch > MAX_RECORD_SIZE ) {
        	// don't save it if invalid.
        	ErrorTrace(0,"data to copy is greater than buffer size");
        	*pcData = 0;
        	goto Exit;
        }
        else {
                memcpy(pData + *pcData, psz, cch ); *pcData += cch ;
        }
        _ASSERT(*pcData < MAX_RECORD_SIZE);

        // save the help text (including the trailing 0);
        psz = pGroup->GetPrettyName(&cch);
        if (cch == 0) {
                pData[*pcData] = 0; (*pcData)++;
        } 
        else if (*pcData + cch > MAX_RECORD_SIZE ) {
        	// don't save it if invalid.
        	ErrorTrace(0,"data to copy is greater than buffer size");        	
        	*pcData = 0;
        	goto Exit;
        }
        else {
                memcpy(pData + *pcData, psz, cch ); *pcData += cch ;
        }
        _ASSERT(*pcData < MAX_RECORD_SIZE);

        // Save the cache hit count
        dwCacheHit = pGroup->GetCacheHit();
        if ( *pcData + sizeof(DWORD) > MAX_RECORD_SIZE)
        {
        	// don't save it if invalid.
        	ErrorTrace(0,"data to copy is greater than buffer size");        	
        	*pcData = 0;
        	goto Exit;        	
        }
    	 memcpy( pData + *pcData, &dwCacheHit, sizeof( DWORD ) );
        *pcData += sizeof( DWORD );

        // if the record contains no useful data then we don't need to save it.
        if (*pcData == sizeof(DWORD) + 3 * sizeof(char)) *pcData = 0;
Exit:
       TraceFunctLeave();	
       return S_OK;
        
}

BOOL
CNewsTreeCore::LoadTree(char *pszFixedPropsFilename,
                                                char *pszVarPropsFilename,
                                                BOOL&   fUpgrade,
                                                DWORD   dwInstanceId,
                                                BOOL    fVerify )
{
        TraceFunctEnter("CNewsTreeCore::LoadTree");
        CHAR    szOldListFile[MAX_PATH+1];
        BOOL    bFatal = FALSE;

        //
        // Initialize upgrade to be false
        //
        fUpgrade = FALSE;

        _ASSERT(pszFixedPropsFilename != NULL);
        _ASSERT(pszVarPropsFilename != NULL);

        m_pFixedPropsFile = XNEW CFixPropPersist(pszFixedPropsFilename);

        if (m_pFixedPropsFile == NULL) {
                SetLastError(ERROR_NOT_ENOUGH_MEMORY);
                return FALSE;
        }

        m_pVarPropsFile = XNEW CFlatFile(pszVarPropsFilename,
                                                                        "",
                                                                        this,
                                                                        FlatFileOffsetCallback,
                                                                        (DWORD) 'VprG');
        if (m_pVarPropsFile == NULL) {
                XDELETE m_pFixedPropsFile;
                m_pFixedPropsFile = NULL;
                SetLastError(ERROR_NOT_ENOUGH_MEMORY);
                TraceFunctLeave();
                return FALSE;
        }

        m_LockTables.ExclusiveLock() ;

        if (!m_pFixedPropsFile->Init(TRUE, this, &m_idHigh, CNewsTreeCore::LoadTreeEnumCallback)) {

            // If it's a old version group.lst, we'll try the old way to parse it
            if ( GetLastError() == ERROR_OLD_WIN_VERSION ) {

            // Delete the fix prop object and move the old group.lst
            lstrcpyn( szOldListFile, pszFixedPropsFilename, sizeof(szOldListFile) - 4 );
            strcat( szOldListFile, ".bak" );
            DeleteFile( szOldListFile );
            if ( !MoveFile( pszFixedPropsFilename, szOldListFile ) ) {
                XDELETE m_pFixedPropsFile;
                m_pFixedPropsFile = NULL;
                XDELETE m_pVarPropsFile;
                m_pVarPropsFile = NULL;
                m_LockTables.ExclusiveUnlock();
                TraceFunctLeave();
                return FALSE;
            }

            // Init the fix prop file again: this time since the file doesn't exist,
            // a new file will be created
            if ( !m_pFixedPropsFile->Init(TRUE, this, NULL, CNewsTreeCore::LoadTreeEnumCallback)) {
                XDELETE m_pFixedPropsFile;
                m_pFixedPropsFile = NULL;
                XDELETE m_pVarPropsFile;
                m_pVarPropsFile = NULL;
                m_LockTables.ExclusiveUnlock();
                TraceFunctLeave();
                return FALSE;
            }

                if ( !OpenTree( szOldListFile, dwInstanceId, fVerify, bFatal, FALSE ) || bFatal ) {

                    // No one can recognize this file, bail
                    m_pFixedPropsFile->Term();
                        XDELETE m_pFixedPropsFile;
                        m_pFixedPropsFile = NULL;
                        XDELETE m_pVarPropsFile;
                        m_pVarPropsFile = NULL;

                        // we restore the group.lst file
                        DeleteFile( pszFixedPropsFilename );
                        _VERIFY( MoveFile( szOldListFile, pszFixedPropsFilename ) );

                        m_LockTables.ExclusiveUnlock();
                        TraceFunctLeave();
                        return FALSE;
            }

            // Set upgrade to be true
            fUpgrade = TRUE;

            // OK, we may delete the old bak file
            _VERIFY( DeleteFile( szOldListFile ) );

        } else {

            // fatal error, we should fail
                XDELETE m_pFixedPropsFile;
                m_pFixedPropsFile = NULL;
            XDELETE m_pVarPropsFile;
                    m_pVarPropsFile = NULL;
                m_LockTables.ExclusiveUnlock();
                    TraceFunctLeave();
                return FALSE;
        }
        }

        BYTE pData[MAX_RECORD_SIZE];
        DWORD cData = MAX_RECORD_SIZE;
        DWORD iOffset;
        DWORD dwVersion;
        DWORD dwHintCounter = 0;
        time_t tNextHint = 0;

        //
    // Enumerate all the records in flatfile
        //
        HRESULT hr = m_pVarPropsFile->GetFirstRecord(pData, &cData, &iOffset, &dwVersion );
        while (hr == S_OK) {
                // Update our hints roughly every five seconds.  We only check the
                // time every 10 groups or so..
                if( dwHintCounter++ % 10 == 0 ) {
                        time_t now = time(NULL);
                        if (now > tNextHint) {
                                StartHintFunction();
                                tNextHint = now + 5;
                        }
            }

                hr = ParseFFRecord(pData, cData, iOffset, dwVersion );
                if (SUCCEEDED(hr)) {
                    cData = MAX_RECORD_SIZE;
                    hr = m_pVarPropsFile->GetNextRecord(pData, &cData, &iOffset, &dwVersion );
                }
        }

        if (FAILED(hr)) {
                m_pFixedPropsFile->Term();
                XDELETE m_pFixedPropsFile;
                m_pFixedPropsFile = NULL;
                XDELETE m_pVarPropsFile;
                m_pVarPropsFile = NULL;
                ErrorTrace((DWORD_PTR) this, "enum varprops file failed with %x", hr);
                m_LockTables.ExclusiveUnlock();
                TraceFunctLeave();
                return FALSE;
        }

        m_LockTables.ExclusiveUnlock() ;

        TraceFunctLeave();
        return TRUE;
}

BOOL
CNewsTreeCore::SaveGroup(INNTPPropertyBag *pGroup) {
        _ASSERT(pGroup != NULL);
        return m_pFixedPropsFile->SetGroup(pGroup, ALL_FIX_PROPERTIES);
}

BOOL
CNewsTreeCore::SaveTree( BOOL fTerminate ) {
        m_LockTables.ExclusiveLock();

        BYTE pData[MAX_RECORD_SIZE];
        DWORD cData;
        INNTPPropertyBag *pPropBag;
        BOOL    bInited = TRUE;
        BOOL    bToSave = TRUE;
        DWORD dwHintCounter=0;
        time_t tNextHint=0;
        DWORD lastError = NO_ERROR;

    _ASSERT( m_pFixedPropsFile );
        if ( !m_pFixedPropsFile->SaveTreeInit() ) {
            lastError = GetLastError();
            // In rtl, this is non-fatal, we just don't
            // use the backup ordered list file
            bToSave = bInited = FALSE;
        }

        CNewsGroupCore *p = m_pFirst;
        while (p != NULL) {
                // Update our hints roughly every five seconds.  We only check the
                // time every 10 groups or so..
                if( dwHintCounter++ % 10 == 0 ) {
                        time_t now = time(NULL);
                        if (now > tNextHint) {
                                StopHintFunction();
                                tNextHint = now + 5;
                        }
                }

                if (!(p->IsDeleted())) {

                    //
                    // Before I save all the properties, i need to make everybody
                    // know that we are dieing and we don't want anybody to post
                    // or expire
                    //
                    p->SetAllowExpire( FALSE );
                    p->SetAllowPost( FALSE );

                        //
                        // BUGBUG - event logs if any of these operations fail
                        //
                        if (p->DidVarPropsChange() || p->ShouldCacheXover() ) {
                                if (p->GetVarOffset() != 0) {
                                        m_pVarPropsFile->DeleteRecord(p->GetVarOffset());
                                }
                                if (!(p->IsDeleted())) {
                                        BuildFFRecord(p, pData, &cData);
                                        if (cData > 0) m_pVarPropsFile->InsertRecord(   pData,
                                                                                        cData,
                                                                                        NULL,
                                                                                        GROUPVAR_VER );
                                }
                        }

                        // Save it to the ordered backup file
                        if ( bToSave ) {
                        pPropBag = p->GetPropertyBag();
                        _ASSERT( pPropBag );    // this shouldn't fail
                        if ( !m_pFixedPropsFile->SaveGroup( pPropBag ) ) {
                            // This is still fine in rtl
                            lastError = GetLastError();
                            bToSave = FALSE;
                        }
                pPropBag->Release();
            }

            //
            // If we are not terminateing, we should allow post and expire again
            //
            if ( !fTerminate ) {
                p->SetAllowExpire( TRUE );
                p->SetAllowPost( TRUE );
            }

                }
                p = p->m_pNext;
        }

        // Close the savetree process in fixprop stuff, telling it
        // whether we want to void it
        if ( bInited ) {
            _VERIFY( m_pFixedPropsFile->SaveTreeClose( bToSave ) );
        }

        if (!bToSave) {
                // An error occurred while trying to save.
                NntpLogEventEx(NNTP_SAVETREE_FAILED,
                        0, (const CHAR **)NULL,
                        lastError,
                        m_pInstWrapper->GetInstanceId()) ;
        }

        m_LockTables.ExclusiveUnlock();

        return TRUE;
}

BOOL
CNewsTreeCore::CreateSpecialGroups()    {
/*++

Routine Description :

        This function creates newsgroups which have 'reserved' names which
        we use in a special fashion for master slave etc...

Arguments :

        None.

Return Value :

        TRUE if Successfull
        FALSE otherwise.

--*/

        CNewsGroupCore *pGroup;

        char*   sz = (char*)szSlaveGroup ;

    m_LockTables.ExclusiveLock();

    //
    // If the tree has already been stopped, return false
    //
    if ( m_fStoppingTree ) {
        m_LockTables.ExclusiveUnlock();
        return FALSE;
    }

        if( (pGroup = m_HashNames.SearchKey(sz)) )      {
                m_idSlaveGroup = pGroup->GetGroupId() ;
        }       else    {
                if( !CreateGroupInternal(   sz,
                                            NULL,           //no native name
                                            m_idSlaveGroup,
                                            FALSE,          //not anonymous
                                            NULL,           //system token
                                            TRUE            //is special group
                                        )) {
                    m_LockTables.ExclusiveUnlock();
                        return  FALSE ;
                }
        }

        //
        // Slave group should be non-read only, since we set group to be read only
        // before we append the group to list, we'll now set it back
        //
        pGroup = m_HashNames.SearchKey(sz);
        if ( pGroup ) {
            pGroup->SetAllowPost( TRUE );
            pGroup->SetAllowExpire( TRUE );
        }

        m_LockTables.ExclusiveUnlock();
        return  TRUE ;
}

void
CNewsTreeCore::Dirty() {
/*++

Routine Description :

        This function marks a counter which lets our background thread know that
        the newstree has been changed and should be saved to a file again.

Arguments :

        None.

Return Value :

        None.

--*/
        //
        //      Mark the newstree as dirty so that the background thread will save our info.
        //

        InterlockedIncrement( &m_cDeltas ) ;

}

void
CNewsTreeCore::ReportGroupId(
                                        GROUPID groupid
                                        ) {
/*++

Routine Description :

        This function is used during boot up to report the group id's that are read
        from the file where we saved all the newsgroups.  We want to figure out what
        the next 'legal' group id would be that we can use.

Arguments ;

        groupid - the Group ID that was found in the file

Return Value :

        None.

--*/


        //
        //      This function is used during bootup when we read groupid's from disk.
        //      We use it to maintain a high water mark of groupid's so that the next
        //      group that is created gets a unique id.
        //
        if(     groupid >= m_idStartSpecial && groupid <= m_idLastSpecial ) {
                if( groupid > m_idSpecialHigh ) {
                        m_idSpecialHigh = groupid ;
                }
        }       else    {
                if( groupid >= m_idHigh ) {
                        m_idHigh = groupid + 1;
                }
        }
}

BOOL
CNewsTreeCore::OpenTree(
                LPSTR   szGroupListFile,
                DWORD   dwInstanceId,
                                BOOL    fRandomVerifies,
                                BOOL&   fFatalError,
                                BOOL    fIgnoreChecksum                         )       {
/*++

Routine Description :

        This function reads in the file which contains all of the group information.


Arguments :

        fRandomVerifies -       If TRUE then the server should check some fraction of
                the groups within the file against the harddisk. (Ensure directory exists etc...)

        fFatailError -  OUT parameter which the function can use to indicate that an
                extremely bad error occurred reading the file and the server should not boot
                in its normal mode.

        fIgnoreChecksum - If TRUE then we should not check the checksum in the file
                against the contents.

Return Value :

        TRUE if successfull FALSE otherwise.

--*/

        //
        //      This function restorces the newstree from its saved file.
        //

        DWORD   dwHintCounter = 0 ;
        DWORD   cVerifyCounter = 1 ;
        BOOL    fVerify = FALSE ;
        fFatalError = FALSE ;
        CHAR    szGroupName[MAX_NEWSGROUP_NAME+1];
        CHAR    szNativeName[MAX_NEWSGROUP_NAME+1];
        DWORD   dwLowWatermark;
        DWORD   dwHighWatermark;
        DWORD   dwArticleCount;
        DWORD   dwGroupId;
        BOOL    bReadOnly = FALSE;
        FILETIME    ftCreateDate;
        BOOL    bSpecial = FALSE;
        BOOL    bHasNativeName;
        LPSTR   lpstrNativeName;
        INNTPPropertyBag *pPropBag;

        TraceFunctEnter("CNewsTreeCore::OpenTree");

        CMapFile        map( szGroupListFile,  FALSE, 0 ) ;

        // missing group.lst file is not fatal
        if( !map.fGood() ) {
                return FALSE;
        }

        //
        //      Verify checksum on group.lst file - bail if incorrect !
        //

        DWORD   cb ;
        char*   pchBegin = (char*)map.pvAddress( &cb ) ;

        if( !fIgnoreChecksum ) {

                DWORD   UNALIGNED*      pdwCheckSum = (DWORD UNALIGNED *)(pchBegin + cb - 4);

                if( *pdwCheckSum != INNHash( (BYTE*)pchBegin, cb-4 ) ) {
                        PCHAR   args[2] ;
                        CHAR    szId[20];
                        _itoa( dwInstanceId, szId, 10 );
                        args[0] = szId;
                        args[1] = szGroupListFile ;


                        NntpLogEvent(   NNTP_GROUPLST_CHKSUM_BAD,
                                                        2,
                                                        (const char **)args,
                                                        0
                                                        ) ;
                        return  FALSE ;
                }
        }
        cb -= 4 ;

        // calculate random verification skip number
        // 91 is heuristically the avg length in bytes of a newsgroup entry in group.lst
        // Always verify approx 10 groups independent of the size of the newstree
        DWORD cGroups = (cb+4)/91;
        DWORD cQ = cGroups / 10;
        DWORD cR = cGroups % 10;
        DWORD cSkipFactor = cR >= 25 ? cQ+1 : cQ;
        if(!cSkipFactor) ++cSkipFactor; // min should be 1

        _ASSERT(cSkipFactor);

        // read in the DWORD on the first line - this is the minimum m_idHigh we should use
        // if this DWORD is not present - m_idHigh = max of all group ids + 1
        DWORD cbIdHigh, idHigh;
        if( (cbIdHigh = ScanDigits( pchBegin, cb )) != 0 )
        {
                idHigh = atoi( pchBegin ) ;
                ReportGroupId( idHigh-1 ) ;
                DebugTrace((DWORD_PTR)this, "idHigh = %d", idHigh );
                pchBegin += cbIdHigh ;
                cb -= cbIdHigh ;
        }

        //
        //      ok, now read group.lst line by line and add the groups to the newstree
        //
        while( cb != 0 ) {

                if( fRandomVerifies && (cVerifyCounter ++ % cSkipFactor == 0 ) && (cVerifyCounter<15) ) {
                        fVerify = TRUE ;
                }       else    {
                        fVerify = FALSE ;
                }

        // Read the fix prop stuff
                DWORD   cbUsed = 0 ;
                BOOL    fInit = ParseGroupParam(    pchBegin,
                                                    cb,
                                                    cbUsed,
                                                    szGroupName,
                                                    szNativeName,
                                                    dwGroupId,
                                                    bSpecial,
                                                    dwHighWatermark,
                                                    dwLowWatermark,
                                                    dwArticleCount,
                                                    bReadOnly,
                                                    bHasNativeName,
                                                    ftCreateDate ) ;
                if( cbUsed == 0 ) {

                        // Fatal Error - blow out of here
                        PCHAR   args[2] ;
                        CHAR    szId[20];
                        _itoa(dwInstanceId, szId, 10 );
                        args[0] = szId;
                        args[1] = szGroupListFile;
                        NntpLogEvent(
                                                NNTP_GROUPLIST_CORRUPT,
                                                2,
                                                (const char **)args,
                                                0
                                                ) ;

                        goto OpenTree_ErrExit;
                }       else    {
                        if( fInit ) {
                            CGRPCOREPTR pGroup;

                            // Now create the group
                            _ASSERT( strlen( szGroupName ) <= MAX_NEWSGROUP_NAME );
                            _ASSERT( strlen( szNativeName ) <= MAX_NEWSGROUP_NAME );
                            _ASSERT( dwHighWatermark >= dwLowWatermark ||
                                        dwLowWatermark - dwHighWatermark == 1 );
                            lpstrNativeName = bHasNativeName ? szNativeName : NULL;
                            if ( !CreateGroupInternal(  szGroupName,
                                                        lpstrNativeName,
                                                        dwGroupId,
                                                        FALSE,
                                                        NULL,
                                                        bSpecial,
                                                        &pGroup,
                                                        FALSE,
                                                        TRUE,
                                                        TRUE ) ) {
                                        goto OpenTree_ErrExit;
                                } else {

                                    // keep setting other properties
                                    _ASSERT( pGroup );
                                    pGroup->SetHighWatermark( dwHighWatermark );
                                    pGroup->SetLowWatermark( dwLowWatermark );
                                    pGroup->SetMessageCount( dwArticleCount );
                    pGroup->SetReadOnly( bReadOnly );
                                    pGroup->SetCreateDate( ftCreateDate );
                                    pGroup->SetExpireLow( dwLowWatermark ? dwLowWatermark-1 : 0 );

                                    //
                                    // The last thing to set is read only, so that we can
                                    // allow posting, expire to work on this group since we
                                    // have setup all the properties already
                                    //
                                    pGroup->SetAllowPost( TRUE );

                                    //
                                    // Also say the group can be expired
                                    //
                                    pGroup->SetAllowExpire( TRUE );

                                    // Add this group object to the fix prop file
                                pPropBag = pGroup->GetPropertyBag();
                                if ( !m_pFixedPropsFile->AddGroup( pPropBag ) ) {
                                    ErrorTrace( 0, "Add group failed %d", GetLastError() );

                                    // this is fatal, since coming here, the fix prop file
                                    // should be brand new
                                    goto OpenTree_ErrExit;
                                }

                                // Since fixprop doesn't know releasing prop bags ...
                                pPropBag->Release();
                                pPropBag = NULL;
                                }
                        }       else    {
                                //
                                // How should we handle an error
                                if( fVerify /*|| m_pInstance->RecoverBoot()*/ ) {
                                        goto OpenTree_ErrExit;
                                }
                        }
                }
                pchBegin += cbUsed ;
                cb -= cbUsed ;

                if( dwHintCounter++ % 200 == 0 ) {

                        StartHintFunction() ;
                }
        }

        return  TRUE ;

OpenTree_ErrExit:

        fFatalError = TRUE;
        return  FALSE ;
}

BOOL
CNewsTreeCore::ParseGroupParam(
                                char    *pchBegin,
                                DWORD   cb,
                                DWORD   &cbOut,
                                LPSTR   szGroupName,
                                LPSTR   szNativeName,
                                DWORD&   dwGroupId,
                                BOOL&    bSpecial,
                                DWORD&   dwHighWatermark,
                                DWORD&   dwLowWatermark,
                                DWORD&   dwArticleCount,
                                BOOL&    bReadOnly,
                                BOOL&    bHasNativeName,
                                FILETIME&    ftCreateDate
                                ){
/*++

Routine description :

        Read an newsgroup data from the saved format.

Arguments :

        pchBegin - buffer containing article data
        cb - Number of bytes to the end of the buffer
        &cbOut - Out parameter, number of bytes read to
                make up one CNewsgroup object
        fVerify - if TRUE check physical articles for consistency

Return Value :

        TRUE if successfull
        FALSE otherwise.

--*/
        //
        //      This function is the partner of SaveToBuffer -
        //      It will parse newsgroup data that has been written with
        //      SaveToBuffer.  We are intentionally unforgiving, extra
        //      spaces, missing args etc.... will cause us to return
        //      cbOut as 0.  This should be used by the caller to
        //      entirely bail processing of the newsgroup data file.
        //
        //      Additionally, our BOOL return value is used to indicate
        //      whether a successfully parsed newsgroup appears to be intact.
        //      If directories don't exist etc... we will return FALSE and
        //      cbOut NON ZERO.  The caller should use this to delete the
        //      newsgroup from its tables.
        //

        //
        //      cbOut should be the number of bytes we consumed -
        //      we will only return non 0 if we successfully read every field from the file !
        //
        cbOut = 0 ;
        BOOL    fReturn = TRUE ;

        TraceFunctEnter( "CNewsGroupCore::Init( char*, DWORD, DWORD )" ) ;

        BOOL    fDoCheck = FALSE ;      // Should we check article integrity - if newsgroups move !

        DWORD   cbScan = 0 ;
        DWORD   cbRead = 0 ;
        DWORD   cbGroupName = 0 ;

        // scan group name
        if( (cbScan = Scan( pchBegin+cbRead, cb-cbRead )) == 0 || cbScan > MAX_NEWSGROUP_NAME+1) {
                return  FALSE ;
        }       else    {
                CopyMemory( szGroupName, pchBegin, cbScan ) ;
                szGroupName[cbScan-1] = '\0' ;
                DebugTrace((DWORD_PTR) this, "Scanned group name -=%s=", szGroupName ) ;
        }

        cbRead += cbScan ;

    // scan vroot path - discarded
        if( (cbScan = Scan( pchBegin+cbRead, cb-cbRead )) == 0 ) {
                return  FALSE ;
        }

        cbRead+=cbScan ;

    // scan low watermark
        if( (cbScan = ScanDigits( pchBegin + cbRead, cb-cbRead )) == 0 ) {
                return  FALSE ;
        }       else    {

                dwLowWatermark = atol( pchBegin + cbRead ) ;

#if 0
                if( m_artLow != 0 )
                        m_artXoverExpireLow = m_artLow - 1 ;
                else
                        m_artXoverExpireLow = 0 ;
#endif


        }

        cbRead += cbScan ;

        // scan high watermark
        if( (cbScan = ScanDigits( pchBegin + cbRead, cb-cbRead )) == 0 )        {
                return  FALSE ;
        }       else    {

                dwHighWatermark = atol( pchBegin + cbRead ) ;

        // I don't know why mcis group.lst file saved the high
        // watermark one higher than the real
        if ( dwHighWatermark > 0 ) dwHighWatermark--;

        }

        cbRead += cbScan ;

    // scan message count
        if( (cbScan = ScanDigits( pchBegin + cbRead, cb-cbRead )) == 0 )        {
                return  FALSE ;
        }       else    {

                dwArticleCount = atol( pchBegin + cbRead ) ;

        }

        cbRead += cbScan ;

    // scan group id
        if( (cbScan = ScanDigits( pchBegin + cbRead, cb-cbRead )) == 0 )        {
                return  FALSE ;
        }       else    {

                dwGroupId = atol( pchBegin + cbRead ) ;
        }

        DebugTrace((DWORD_PTR) this, "Scanned m_artLow %d m_artHigh %d m_cArticle %d m_groupid %x",
                        dwLowWatermark, dwHighWatermark, dwArticleCount, dwGroupId ) ;

        cbRead += cbScan ;

    // scan time stamp
        if( (cbScan = ScanDigits( pchBegin + cbRead, cb-cbRead )) == 0 )        {
                return  FALSE ;
        }       else    {

                ftCreateDate.dwLowDateTime = atoi( pchBegin + cbRead ) ;

        }

        cbRead += cbScan ;

        if( (cbScan = ScanDigits( pchBegin + cbRead, cb-cbRead )) == 0 )        {
                return  FALSE ;
        }       else    {

                ftCreateDate.dwHighDateTime = atoi( pchBegin + cbRead ) ;

        }

        cbRead += cbScan ;

    // scan read only bit
        if( (cbScan = ScanDigits( pchBegin + cbRead, cb-cbRead )) == 0 )        {
                bReadOnly = FALSE ;             // default if we dont find this flag !
        }       else    {

                bReadOnly = atoi( pchBegin + cbRead ) ;

        }

        cbRead += cbScan ;

        if( *(pchBegin+cbRead-1) == '\n' ) {
                cbRead--;
        }

    // scan native name
        if( (cbScan = Scan( pchBegin+cbRead, cb-cbRead )) <= 1 || cbScan > MAX_NEWSGROUP_NAME+1 ) {
                // did not find native group name, NULL it to save space !!
                bHasNativeName = FALSE;
        }       else    {
                CopyMemory( szNativeName, pchBegin+cbRead, cbScan ) ;
                szNativeName[cbScan-1] = '\0' ;
                DebugTrace((DWORD_PTR) this, "Scanned native group name -=%s=", szNativeName ) ;
        bHasNativeName = TRUE;
        }

        cbRead += cbScan ;

        if( pchBegin[cbRead-1] != '\n' && pchBegin[cbRead-1] != '\r' ) {
                return FALSE ;
        }
        while( cbRead < cb && (pchBegin[cbRead] == '\n' || pchBegin[cbRead] == '\r') ) {
                cbRead ++ ;
        }

        //
        //      Return to the caller the number of bytes consumed
        //      We may still fail - but with this info the caller can continue reading the file !
        //
        cbOut = cbRead ;

        _ASSERT( cbOut >= cbRead ) ;

        //
        //      If we've reached this point, then we've successfully read the entry in the group.lst
        //      file.  Now we will do some validity checking !
        //

	return	fReturn ;
}

void
CNewsTreeCore::AppendList(      CNewsGroupCore* pGroup )        {
        //
        //      This function appends a newsgroup to the list of newsgroups.
        //      The real work horse is InsertList, however this function lets
        //      us speed up insertion when we are fairly confident the newgroup
        //      being added as at the end.
        //      (ie. when we save newsgroups to a file, we save them alphabetically.
        //      so this is a good function for this use.)
        //

        _ASSERT( pGroup != 0 ) ;

        if( m_pFirst == 0 ) {
                Assert( m_pLast == 0 ) ;
                m_pFirst = pGroup ;
                m_pLast = pGroup ;
        }       else    {

                CNewsCompareName        comp( pGroup ) ;

                if( comp.IsMatch( m_pLast ) < 0 ) {
                        m_pLast->m_pNext = pGroup ;
                        pGroup->m_pPrev = m_pLast ;
                        m_pLast = pGroup ;
                }       else    {
                        InsertList( pGroup, 0 ) ;
                }
        }
}

void
CNewsTreeCore::InsertList( CNewsGroupCore   *pGroup,    CNewsGroupCore  *pParent ) {
        //
        //      Insert a newsgroup into the tree.
        //      The parent newsgroup is provided (optionally may be 0), as it can be used
        //      to speed inserts since we know the child will follow
        //      in lexicographic order shortly after the parent.
        //

        _ASSERT( pGroup != 0 ) ;

        CNewsCompareName    comp( pGroup ) ;

        if( m_pFirst == 0 ) {
                Assert( m_pLast == 0 ) ;
                m_pFirst = pGroup ;
                m_pLast = pGroup ;
        }   else    {
                Assert( m_pLast != 0 ) ;

                CNewsGroupCore  *p = m_pFirst ;
                if( pParent && comp.IsMatch( pParent ) < 0 )
                        p = pParent ;

                int i ;
                while( (p && (i = comp.IsMatch( p )) < 0) || (p && p->IsDeleted()) ) {
                        p = p->m_pNext ;
                }

                if( p && i == 0 ) {
                        // Assert( p == pGroup ) ;
                        // duplicate found - p should not be deleted else we would have skipped it
                        _ASSERT( !p->IsDeleted() );

                }   else    {
                        if( p ) {

                                _ASSERT( !p->IsDeleted() );
                                pGroup->m_pPrev = p->m_pPrev ;
                                pGroup->m_pNext = p ;
                                if( p->m_pPrev )
                                        p->m_pPrev->m_pNext = pGroup ;
                                p->m_pPrev = pGroup ;
                        }   else {
                                m_pLast->m_pNext = pGroup ;
                                pGroup->m_pPrev = m_pLast ;
                                m_pLast = pGroup ;
                        }

                        if( p == m_pFirst ) {
                                _ASSERT( pGroup != 0 ) ;
                                m_pFirst = pGroup ;
                        }
                }
        }
}

//
// !! This function should NOT be used. Newsgroup objects should unlink themselves
// in their destructors.
void
CNewsTreeCore::RemoveList(  CNewsGroupCore  *pGroup ) {
        //
        //      Remove a newsgroup from the doubly linked list !
        //

        m_cDeltas ++ ;

        if( pGroup->m_pPrev != 0 ) {
                pGroup->m_pPrev->m_pNext = pGroup->m_pNext ;
        }   else    {
                _ASSERT( pGroup->m_pNext != 0 || m_pLast == pGroup ) ;
                m_pFirst = pGroup->m_pNext ;
        }

        if( pGroup->m_pNext != 0 ) {
                pGroup->m_pNext->m_pPrev = pGroup->m_pPrev ;
        }   else    {
                m_pLast = pGroup->m_pPrev ;
                _ASSERT( pGroup->m_pPrev != 0 || m_pFirst == pGroup ) ;
        }

        pGroup->m_pPrev = 0;
        pGroup->m_pNext = 0;
}

BOOL
CNewsTreeCore::Insert( CNewsGroupCore   *pGroup,   CNewsGroupCore  *pParent ) {
        //
        //      Insert a newsgroup into all hash tables and linked lists !
        //      Parent newsgroup provided to help optimize inserts into linked lists
        //

        m_cDeltas++ ;

        if( !m_HashNames.InsertDataHash( pGroup->GetGroupNameHash(), *pGroup ) ) {
                return FALSE;
        }

        if( !m_HashGroupId.InsertData( *pGroup ) ) {
                m_HashNames.DeleteData( pGroup->GetName() );
                return FALSE;
        }

        InsertList( pGroup, pParent ) ;
//      pGroup->AddRef();
        m_cGroups ++ ;

        return TRUE;
}

BOOL
CNewsTreeCore::InsertEx( CNewsGroupCore   *pGroup ) {
        //
        //      Insert a newsgroup into m_HashNames hash table and linked lists !
        //      Parent newsgroup provided to help optimize inserts into linked lists
        //

        m_cDeltas++ ;

        if( !m_HashNames.InsertData( *pGroup ) ) {
                return FALSE;
        }

        InsertList( pGroup, 0 ) ;
//      pGroup->AddRef();
        m_cGroups ++ ;

        return TRUE;
}

BOOL
CNewsTreeCore::HashGroupId( CNewsGroupCore   *pGroup ) {
        //
        //      Insert a newsgroup into m_HashGroupId hash table
        //
        m_LockTables.ExclusiveLock() ;

        if( !m_HashGroupId.InsertData( *pGroup ) ) {
                m_HashNames.DeleteData( pGroup->GetName() );
                pGroup->MarkDeleted();
                m_LockTables.ExclusiveUnlock() ;
                return FALSE;
        }
        m_LockTables.ExclusiveUnlock() ;

        return TRUE;
}

BOOL
CNewsTreeCore::Append(  CNewsGroupCore  *pGroup ) {
        //
        //      Append a newsgroup - newsgroup should fall on end of list
        //      or there will be a performance price to finds its proper location !
        //

        m_cDeltas ++ ;

        if( !m_HashNames.InsertData( *pGroup ) ) {
                return FALSE;
        }

        if( !m_HashGroupId.InsertData( *pGroup ) ) {
                m_HashNames.DeleteData( pGroup->GetName() );
                return FALSE;
        }

        AppendList( pGroup ) ;
//      pGroup->AddRef();
        m_cGroups ++ ;

        return TRUE;
}

CGRPCOREPTRHASREF
CNewsTreeCore::GetGroup(
                                const   char*   lpstrGroupName,
                                int cb
                                ) {
/*++

Routine Description :

        Find a newsgroup based on a name.  We may desctuctively
        use the callers buffer, so we will convert the string
        to lower case in place before doing the search.

Arguments :

        lpstrGroupName - Name of the group to find
        cb - number of bytes in the name

Return Value :

        Pointer to Newsgroup, NULL if not found.

--*/

        _ASSERT( lpstrGroupName != NULL ) ;

        TraceQuietEnter(        "CNewsTreeCore::GetGroup" ) ;

        CGRPCOREPTR     pGroup = 0 ;
        if (m_fStoppingTree) return (CNewsGroupCore *)pGroup;

        _strlwr( (char*)lpstrGroupName ) ;

        m_LockTables.ShareLock() ;

        if (m_fStoppingTree) {
                m_LockTables.ShareUnlock();
                return (CNewsGroupCore *)pGroup;
        }

        char*   szTemp = (char*)lpstrGroupName ;

        pGroup = m_HashNames.SearchKey(szTemp);
        m_LockTables.ShareUnlock() ;
        return  (CNewsGroupCore *)pGroup ;
}


CGRPCOREPTRHASREF
CNewsTreeCore::GetGroupPreserveBuffer(
                                                const   char*   lpstrGroup,
                                                int     cb
                                                )       {
/*++

Routine Description :

        This function will find a group based on its name.
        For some reason the caller has the group in a buffer it doesn't want
        modified, so we must not touch the original bytes.
        Since we must do all our searches in lower case, we will copy
        the buffer and lower case it locally.

Arguments :

        lpstrGroup - The group to find - must be NULL terminated.
        cb      - The length of the group's name

Return Value :

        Smart pointer to the newsgroup, NULL smart pointer if not found.

--*/

        TraceFunctEnter(        "CNewsTreeCore::GetGroup" ) ;

        _ASSERT( lpstrGroup != 0 ) ;
        _ASSERT( cb != 0 ) ;
        _ASSERT( lpstrGroup[cb-1] == '\0' ) ;

        CGRPCOREPTR     pGroup = 0 ;
        char    szGroupBuff[512] ;
        if( cb < sizeof( szGroupBuff ) ) {
                CopyMemory(     szGroupBuff, lpstrGroup, cb ) ;
                _strlwr( szGroupBuff ) ;

                DebugTrace((DWORD_PTR) this, "grabbing shared lock -" ) ;
                m_LockTables.ShareLock() ;

                char    *szTemp = szGroupBuff ;

                pGroup = m_HashNames.SearchKey(szTemp);

                DebugTrace((DWORD_PTR) this, "releasing lock" ) ;
                m_LockTables.ShareUnlock() ;
        }
        return  (CNewsGroupCore *)pGroup ;
}

CGRPCOREPTRHASREF
CNewsTreeCore::GetGroupById(
                                GROUPID groupid,
                                BOOL    fFirm
                                ) {
/*++

Routine Description :

        Find a newsgroup based on groupid.

Arguments :

        groupid of the group we want to find.

Return Value :

        Poniter to newsgroup, NULL if not found.

--*/

        TraceFunctEnter( "CNewsTreeCore::GetGroup" ) ;

        CGRPCOREPTR     pGroup = 0 ;
        if (!fFirm && m_fStoppingTree) return (CNewsGroupCore *)pGroup;

        DebugTrace((DWORD_PTR) this, "grabbing shared lock" ) ;

        m_LockTables.ShareLock() ;


        if (!fFirm && m_fStoppingTree) {
                m_LockTables.ShareUnlock();
                return (CNewsGroupCore *)pGroup;
        }

        // we need to check if m_HashGroupId is valid
        // if it's called from nntpex, shutdown process might have already emptied the hash.
        if (!m_HashGroupId.IsValid(FALSE) ) {
                m_LockTables.ShareUnlock();
                return (CNewsGroupCore *)pGroup;
        }


        pGroup = m_HashGroupId.SearchKey(groupid);
        DebugTrace((DWORD_PTR) this, "release lock" ) ;
        m_LockTables.ShareUnlock() ;
        return  (CNewsGroupCore *)pGroup ;
}

CGRPCOREPTRHASREF
CNewsTreeCore::GetParent(
                        IN  char*  lpGroupName,
                        IN  DWORD  cbGroup,
                        OUT DWORD& cbConsumed
                           ) {
/*++

Routine Description :

        Find the parent of a newsgroup.

Arguments :

        char* lpGroupName -  name of newsgroup whose parent we want to find
                                                 (should be NULL terminated)
        DWORD cbGroup - length of szGroupName
        DWORD cbConsumed - bytes consumed by this function

Return Value :

        Pointer to parent Newsgroup, NULL if not found.

--*/

        _ASSERT( lpGroupName != NULL ) ;
        _ASSERT( *(lpGroupName + cbGroup) == '\0' );
        _ASSERT( cbConsumed == 0 );

        TraceFunctEnter( "CNewsTreeCore::GetParent" ) ;

        CGRPCOREPTR pGroup = 0;

        char* pch = lpGroupName+cbGroup-1;

        do
        {
                while( pch != lpGroupName )
                {
                        if( *pch == '.' )
                                break;
                        pch--;
                        cbConsumed++;
                }

                if( pch != lpGroupName )
                {
                        _ASSERT( DWORD(pch-lpGroupName) <= (cbGroup-1) );
                        *pch-- = '\0';
                        cbConsumed++;

                        pGroup = GetGroup( lpGroupName, cbGroup - cbConsumed ) ;
                }
                else
                        break;

        } while( !pGroup );

        // return the parent group; if this is NULL the whole buffer should be consumed
        _ASSERT( pGroup || (cbConsumed == cbGroup-1) );

        return (CNewsGroupCore *)pGroup;
}

BOOL
CNewsTreeCore::Remove(
                                CNewsGroupCore      *pGroup ,
                                BOOL fHaveExLock

                                ) {
/*++

Routine Description :

        Remove all references to the newsgroup from the newstree.
        The newsgroup may continue to exist if there is anybody holding
        onto a smart pointer to it.

--*/

        TraceFunctEnter( "CNewsTreeCore::Remove" ) ;

        DebugTrace((DWORD_PTR) this, "Getting Exclusive Lock " ) ;

        HRESULT hr = S_OK;

        if (!fHaveExLock) m_LockTables.ExclusiveLock() ;

    //  fix bug 80453 - avoid double-release in Remove() if two threads come in at the
    //  same time!
    if (pGroup->IsDeleted())
    {
        if (!fHaveExLock) m_LockTables.ExclusiveUnlock();
        return FALSE;
    }

        // Remove this group from all hash tables and lists
        // This makes the group inaccessible
        LPSTR lpstrGroup = pGroup->GetName();
        GROUPID grpId = pGroup->GetGroupId();

        _VERIFY(m_HashNames.DeleteData(lpstrGroup) == pGroup);
        _VERIFY(m_HashGroupId.DeleteData(grpId) == pGroup);

        m_cGroups -- ;

        // !! Do not explicitly remove a newsgroup object from the list
        // This is done in the newsgroup object destructor
        // RemoveList( pGroup );

        // mark as deleted so newsgroup iterators skip over this one
        pGroup->MarkDeleted();

        DebugTrace((DWORD_PTR) this, "releasing lock" ) ;

        if (!fHaveExLock) m_LockTables.ExclusiveUnlock() ;

        pGroup->Release();

    return TRUE;
}

void
CNewsTreeCore::RemoveEx(
                                CNewsGroupCore   *pGroup
                                ) {
/*++

Routine Description :

        Remove all references to the newsgroup from the newstree.
        This is called only by Standard rebuild to mark newsgroups deleted.
        The newsgroup may continue to exist if there is anybody holding
        onto a smart pointer to it.

--*/

        TraceFunctEnter( "CNewsTreeCore::RemoveEx" ) ;

        DebugTrace((DWORD_PTR) this, "Getting Exclusive Lock " ) ;

        m_LockTables.ExclusiveLock() ;

        // Remove this group from all hash tables and lists
        // This makes the group inaccessible
        LPSTR lpstrGroup = pGroup->GetName();

        m_HashNames.DeleteData( lpstrGroup ) ;

        pGroup->Release();
        m_cGroups -- ;

        // !! Do not explicitly remove a newsgroup object from the list
        // This is done in the newsgroup object destructor
        // RemoveList( pGroup );

        // mark as deleted so newsgroup iterators skip over this one
        pGroup->MarkDeleted();

        DebugTrace((DWORD_PTR) this, "releasing lock" ) ;

        m_LockTables.ExclusiveUnlock() ;
}

GROUPID
CNewsTreeCore::GetSlaveGroupid()        {
        return  m_idSlaveGroup ;
}

BOOL
CNewsTreeCore::RemoveGroupFromTreeOnly( CNewsGroupCore *pGroup )
/*++
Routine description:

    Remove the group from newstree only

Arguments:

    CNewsGroupCore *pGroup - The newsgroup to be removed

Return value:

    TRUE if succeeded, FALSE otherwise
--*/
{
        TraceFunctEnter("CNewsTreeCore::RemoveGroup");

        if (m_fStoppingTree) return FALSE;
        if (pGroup->IsDeleted()) return FALSE;

        // remove group from internal hash tables and lists
        if (!Remove(pGroup)) return FALSE;

        // remove the group from the fix props file
        INNTPPropertyBag *pBag = pGroup->GetPropertyBag();
        m_pFixedPropsFile->RemoveGroup(pBag);
        pBag->Release();

    // also remove it from the var props file
    if (pGroup->GetVarOffset() != 0) {
        m_pVarPropsFile->DeleteRecord(pGroup->GetVarOffset());
    }

    TraceFunctLeave();
    return TRUE;
}

//
// unlink a group from the group list.  this doesn't physically remove a
// group from a store, RemoveDriverGroup should be used for that.
//
BOOL
CNewsTreeCore::RemoveGroup( CNewsGroupCore *pGroup )
{
        TraceFunctEnter("CNewsTreeCore::RemoveGroup");

        if (m_fStoppingTree) return FALSE;
        if (pGroup->IsDeleted()) return FALSE;

        // remove group from internal hash tables and lists
        if (!Remove(pGroup)) return FALSE;

        // remove the group from the fix props file
        INNTPPropertyBag *pBag = pGroup->GetPropertyBag();
        m_pFixedPropsFile->RemoveGroup(pBag);
        pBag->Release();

    // also remove it from the var props file
    if (pGroup->GetVarOffset() != 0) {
        m_pVarPropsFile->DeleteRecord(pGroup->GetVarOffset());
    }

    //
    // Put the group into rmgroup queue
    //
    if(!m_pInstWrapper->EnqueueRmgroup( pGroup ) )  {
        ErrorTrace( 0, "Could not enqueue newsgroup %s", pGroup->GetName());
        return FALSE;
    }

    TraceFunctLeave();
        return TRUE;
}

//
// physically remove a group from a store.  This doesn't remove a group from
// the tree, use RemoveGroup for that.
//
BOOL CNewsTreeCore::RemoveDriverGroup(  CNewsGroupCore *pGroup ) {
        TraceFunctEnter("CNewsTreeCore::RemoveDriverGroup");

        CNNTPVRoot *pVRoot = pGroup->GetVRoot();
        if (pVRoot == NULL) return TRUE;

        // create a completion object
        INNTPPropertyBag *pBag = pGroup->GetPropertyBag();
        HRESULT hr = S_OK;
        CNntpSyncComplete scComplete;

        //
        // Set vroot to the completion object
        //
        scComplete.SetVRoot( pVRoot );

        // start the remove operation
        pVRoot->RemoveGroup(pBag, &scComplete );

        // wait for it to complete
        _ASSERT( scComplete.IsGood() );
        hr = scComplete.WaitForCompletion();

        pVRoot->Release();

        // check out status and return it
        if (FAILED(hr)) SetLastError(hr);
        TraceFunctLeave();
        return SUCCEEDED(hr);
}

HRESULT
CNewsTreeCore::FindOrCreateGroup(
                                                LPSTR           lpstrGroupName,
                                                BOOL            fIsAllLowerCase,
                                                BOOL            fCreateIfNotExist,
                                                BOOL            fCreateInStore,
                                                CGRPCOREPTR     *ppGroup,
                                                HANDLE      hToken,
                                                BOOL        fAnonymous,
                                                GROUPID     groupid,
                                                BOOL        fSetGroupId )
{
/*++

Routine Description :

        This function can do a lookup for a group or create a group all in
        one operation.

Arguments :

        lpstrGroupName - Name of the newsgroup
        fIsAllLowerCase - If TRUE the newsgroup name is already lower case,
                if FALSE we will make our own lower case copy of the newsgroup
                name.
        fCreateIfNotExist - create the group if its not found?
        ppGroup - recieves the group pointer

Return Value :

        TRUE if successfull.
        FALSE otherwise.

--*/

        HRESULT hr = S_OK;
        char    szBuff[512] ;
        LPSTR   lpstrNativeGroupName = NULL ;

        TraceQuietEnter("CNewsTreeCore::CreateGroup");

        if( !fIsAllLowerCase ) {

                int     cb = 0 ;
                lpstrNativeGroupName = lpstrGroupName;
                if( (cb = lstrlen( lpstrGroupName )+1) < sizeof( szBuff ) )             {

                        CopyMemory( szBuff, lpstrGroupName, cb ) ;
                        _strlwr( szBuff ) ;
                        lpstrGroupName = szBuff ;
                }

                //
                //      Optimize - if the native group name is all lower case, store
                //      only one of 'em.
                //

                if( strcmp( lpstrGroupName, lpstrNativeGroupName ) == 0 ) {
                        lpstrNativeGroupName = NULL ;
                }
        }

        m_LockTables.ShareLock() ;

        if (m_fStoppingTree) {
                m_LockTables.ShareUnlock();
                return E_UNEXPECTED;
        }

        CGRPCOREPTR pOldGroup = m_HashNames.SearchKey(lpstrGroupName);
        if( pOldGroup == NULL)  {
                if (!fCreateIfNotExist) {
                        m_LockTables.ShareUnlock() ;
                        return HRESULT_FROM_WIN32(ERROR_NOT_FOUND);
                }

                // since there is a timing window here we need to redo our
                // check to see if the group exists
                m_LockTables.ShareUnlock() ;
                m_LockTables.ExclusiveLock() ;

                //
                // check stopping tree again
                //
                if ( m_fStoppingTree ) {
                    m_LockTables.ExclusiveUnlock();
                    return E_UNEXPECTED;
                }
                pOldGroup = m_HashNames.SearchKey(lpstrGroupName);
                if (pOldGroup != NULL) {
                        m_LockTables.ExclusiveUnlock() ;
                        pOldGroup->SetDecorateVisitedFlag(TRUE);
                        DebugTrace((DWORD_PTR) this, "set visited %s", pOldGroup->GetName());
                        if (ppGroup != NULL) *ppGroup = pOldGroup;
                        hr = S_FALSE;
                } else {
                        CGRPCOREPTR     pNewGroup = NULL;

                        BOOL fRtn = CreateGroupInternal(
                                                                lpstrGroupName,
                                                                lpstrNativeGroupName,
                                                                groupid,
                                                                fAnonymous,
                                                                hToken,
                                                                FALSE,
                                                                &pNewGroup,
                                                                TRUE,
                                                                fSetGroupId,
                                                                fCreateInStore
                                                                ) ;

                        m_LockTables.ExclusiveUnlock() ;

                        // bail if CreateGroupInternal fails !
                        if(!fRtn) {
                                hr = HRESULT_FROM_WIN32(GetLastError());
                                if (SUCCEEDED(hr)) hr = E_FAIL;
                                return hr;
                        } else {
                                //
                                // Before appending this guy onto newstree, we should reset its watermark
                                // if there is an old group lying around
                                //
                m_pInstWrapper->AdjustWatermarkIfNec( pNewGroup );

                //
                // Set the group to be postable
                //
                pNewGroup->SetAllowPost( TRUE );

                //
                // Set the group to be expireable
                //
                pNewGroup->SetAllowExpire( TRUE );

                                pNewGroup->SetDecorateVisitedFlag(TRUE);
                                DebugTrace((DWORD_PTR) this, "set visited %s", pNewGroup->GetName());
                        }

                        if (ppGroup != NULL) *ppGroup = pNewGroup;
                }
        }       else    {
                m_LockTables.ShareUnlock() ;
                pOldGroup->SetDecorateVisitedFlag(TRUE);
                //DebugTrace((DWORD_PTR) this, "set visited %s", pOldGroup->GetName());
                if (ppGroup != NULL) *ppGroup = pOldGroup;
                hr = S_FALSE;
        }
        return hr;
}

static  char    szCreateFileString[] = "\\\\?\\" ;

BOOL
CNewsTreeCore::CreateGroupInternal(     LPSTR           lpstrGroupName,
                                                                LPSTR           lpstrNativeGroupName,
                                                                GROUPID&        groupid,
                                                                BOOL        fAnonymous,
                                                                HANDLE      hToken,
                                                                BOOL            fSpecial,
                                                                CGRPCOREPTR     *ppGroup,
                                                                BOOL            fAddToGroupFiles,
                                                                BOOL            fSetGroupId,
                                                                BOOL            fCreateInStore,
                                                                BOOL        fAppend )
{
        /*++

        Routine Description :

                This function exists to create newsgroups.
                We will create all the necessary directories etc...
                Caller must have exclusive lock to newstree held.

        Arguments :

                lpstrGroupName - The name of the newsgroup that we want to create !
                lpstrNativeGroupName - The native (case-preserved) name of the newsgroup
                fSpecial - If TRUE the caller wants to build a special internal newsgroup
                        not to be seen by clients - we can suppress our usual validity checking !
                ppGroup - recieves the group object that was created

        Return Value :

                TRUE    if Created Successfully, FALSE otherwise

--*/

        TraceQuietEnter( "CNewsTreeCore::CreateGroup" ) ;

        BOOL    fRtn = TRUE ;
        CNntpSyncComplete scComplete;

        if( !fSpecial ) {

                if( lpstrGroupName == 0 ) {
                        SetLastError( ERROR_INVALID_NAME );
                        return  FALSE ;
                }

                //
                // Reject weird Genome groups like alt.024.-.-.0
                // -johnson
                //

                if ( m_fRejectGenomeGroups &&
                         (*lpstrGroupName == 'a') &&
                         (lstrlen(lpstrGroupName) > 4) ) {

                        if ( *(lpstrGroupName+4) == '0') {
                                SetLastError( ERROR_INVALID_NAME );
                                return(FALSE);
                        }
                }

                //
                //      Group names may not contain a slash
                //
                if( strchr( lpstrGroupName, '\\' ) != 0 ) {
                        SetLastError( ERROR_INVALID_NAME );
                        return  FALSE ;
                }

                //
                //  Group names may not contain ".."
                //
                if ( strstr( lpstrGroupName, ".." ) != 0 ) {
                    SetLastError( ERROR_INVALID_NAME );
                    return FALSE;
                }

                if( !fTestComponents( lpstrGroupName ) ) {
                        SetLastError( ERROR_INVALID_NAME );
                        return  FALSE ;
                }

        }       else    {

                if( m_idSpecialHigh == m_idLastSpecial ) {
                        SetLastError( ERROR_INVALID_NAME );
                        return  FALSE ;
                }

        }

        DWORD   dw = 0 ;
        BOOL    fFound = FALSE ;

        // DebugTrace( (DWORD_PTR)this, "Did not find group %s", lpstrGroupName ) ;

        CGRPCOREPTR     pParent = 0 ;
        //LPSTR lpstrRootDir = NntpTreeRoot;

        //
        //      Make sure the newsgroup is not already present !
        //
        if( m_HashNames.SearchKey( lpstrGroupName) == NULL ) {

                CNewsGroupCore* pNews = AllocateGroup();

                if (pNews != 0) {
                        NNTPVROOTPTR pVRoot = NULL;
                        HRESULT hr;

                        if (m_fVRTableInit) {
                                hr = m_pVRTable->FindVRoot(lpstrGroupName, &pVRoot);
                        } else {
                                hr = S_OK;
                        }

                        if (SUCCEEDED(hr)) {
                                if (!fSetGroupId) {
                                        if( !fSpecial ) {
                                                groupid = m_idHigh++ ;
                                        }       else    {
                                                groupid = m_idSpecialHigh ++ ;
                                        }
                                } else {
                                        CNewsGroupCore *pGroup = m_HashGroupId.SearchKey(groupid);
                                        _ASSERT(pGroup == NULL);
                                        if (pGroup != NULL) {
                                                m_LockTables.ExclusiveUnlock();
                                                pNews->Release();
                                                m_LockTables.ExclusiveLock();
                                                SetLastError(ERROR_ALREADY_EXISTS);
                                                return FALSE;
                                        }

                                        if (fSpecial && groupid >= m_idSpecialHigh)
                                                m_idSpecialHigh = groupid + 1;
                                        if (!fSpecial && groupid >= m_idHigh)
                                                m_idHigh = groupid + 1;

                                }

                                if (!pNews->Init( lpstrGroupName,
                                                                lpstrNativeGroupName,
                                                                groupid,
                                                                pVRoot,
                                                                fSpecial
                                                                )) {
                                        // Init calls SetLastError
                                        TraceFunctLeave();
                                        return FALSE;
                                }

                                INNTPPropertyBag *pBag = pNews->GetPropertyBag();
                                if (fCreateInStore && fAddToGroupFiles && pVRoot && pVRoot->IsDriver()) {
                                        // call into the driver to create the group.  because the
                                        // driver may take a long time we let go of our lock.  this
                                        // means that we need to check that the group hasn't already
                                        // been created by another thread when we get the lock back.
                                        m_LockTables.ExclusiveUnlock();

                                        //
                                        // Set vroot to the completion object
                                        //
                                        scComplete.SetVRoot( pVRoot );

                                        // add a reference for creategroup
                                        pBag->AddRef();
                                        pVRoot->CreateGroup(    pBag,
                                                                &scComplete,
                                                                hToken,
                                                                fAnonymous );
                                        _ASSERT( scComplete.IsGood() );
                                        hr = scComplete.WaitForCompletion();

                                        m_LockTables.ExclusiveLock();

                                        //
                                        // re-check m_fStoppingTree
                                        //
                                        if ( m_fStoppingTree ) {
                                            DebugTrace( 0, "Tree stopping, group creation aborted" );
                                            pBag->Release();
                                            m_LockTables.ExclusiveUnlock();
                                            pNews->Release();
                                            m_LockTables.ExclusiveLock();
                                            SetLastError( ERROR_OPERATION_ABORTED );
                                            TraceFunctLeave();
                                            return FALSE;
                                        }

                                        // check to see if the create group failed or if the group was
                                        // created by someone else
                                        BOOL fExists = ((m_HashGroupId.SearchKey(groupid) != NULL) ||
                                                                (m_HashNames.SearchKey(lpstrGroupName) != NULL));
                                        if (FAILED(hr) || fExists) {
                                                ErrorTrace((DWORD_PTR) this, "driver->CreateGroup failed with 0x%x", hr);
                                                pBag->Release();
                                                m_LockTables.ExclusiveUnlock();
                                                pNews->Release();
                                                m_LockTables.ExclusiveLock();
                                                SetLastError((fExists) ? ERROR_ALREADY_EXISTS : hr);
                                                TraceFunctLeave();
                                                return FALSE;
                                        }
                                }

                                //
                                // Set the group to be read only, so that even though it's inserted
                                // into the list, it's still non-postable.  This is because we'll
                                // double check with rmgroup queue and adjust watermarks before allowing
                                // any posting into this group.  We cannot do check here, because
                                // the check may cause the old group to be destroyed.  The destroy of
                                // old group needs to hold a table lock.  However we are already in
                                // table lock.
                                //
                                pNews->SetAllowPost( FALSE );
                                pNews->SetAllowExpire( FALSE );

                                // insert in the newstree as usual
                                if ( fAppend )
                                        fRtn = Append( pNews );
                                else {
                                        // Find the parent newsgroup as a hint where to start looking for
                                        // the insertion point.
                                        CHAR szParentGroupName[MAX_NEWSGROUP_NAME+1];
                                        lstrcpyn(szParentGroupName, lpstrGroupName, MAX_NEWSGROUP_NAME);
                                        LPSTR pszLastDot;
                                        while ((pszLastDot=strrchr(szParentGroupName, '.'))) {
                                                *pszLastDot = NULL;
                                                pParent = m_HashNames.SearchKey(szParentGroupName);
                                                if (pParent)
                                                        break;
                                        }
                                        fRtn = Insert( pNews, (CNewsGroupCore*)pParent );
                                }
                                if ( fRtn ) {

                                        if (fAddToGroupFiles) {
                                                // add the group to the group file
                                                _ASSERT(m_pFixedPropsFile);
                                                if (m_pFixedPropsFile->AddGroup(pBag)) {
                                                        pBag->Release();
                                                if (ppGroup) *ppGroup = pNews;
                                                        return TRUE ;
                                                }
                        pNews->AddRef();
                                                Remove(pNews, TRUE);
                                        } else {
                                                pBag->Release();
                                        if (ppGroup) *ppGroup = pNews;
                                                return TRUE;
                                        }
                                }
                                pBag->Release();
                        }       else    {
                                //_ASSERT(FALSE);
                        }
                }       else    {
                        _ASSERT(FALSE);
                }

                if( pNews != 0 ) {
                        m_LockTables.ExclusiveUnlock();
                        pNews->Release();
                        m_LockTables.ExclusiveLock();
                }

        }

        SetLastError(ERROR_ALREADY_EXISTS);
        return  FALSE ;
}

CNewsCompareId::CNewsCompareId( GROUPID id ) :
        m_id( id ) {}

CNewsCompareId::IsMatch( CNewsGroupCore  *pGroup ) {
    return  pGroup->GetGroupId() - m_id ;
}

DWORD
CNewsCompareId::ComputeHash( ) {
    return  CNewsGroupCore::ComputeIdHash( m_id ) ;
}

CNewsCompareName::CNewsCompareName( LPSTR lpstr ) :
        m_lpstr( lpstr ) { }

CNewsCompareName::CNewsCompareName( CNewsGroupCore *p ) :
        m_lpstr( p->GetGroupName() ) {}

CNewsCompareName::IsMatch( CNewsGroupCore    *pGroup ) {
    return  lstrcmp( pGroup->GetGroupName(), m_lpstr ) ;
}

DWORD
CNewsCompareName::ComputeHash( ) {
    return  CNewsGroupCore::ComputeNameHash( m_lpstr ) ;
}


CGroupIteratorCore*
CNewsTreeCore::ActiveGroups(BOOL    fReverse) {
/*++

Routine Description :

        Build an iterator that can be used to walk all of the
        client visible newsgroups.

Arguments :

        fIncludeSecureGroups -
                IF TRUE then the iterator we return will visit the
                SSL only newsgroups.

Return Value :

        An iterator, NULL if an error occurs

--*/

        m_LockTables.ShareLock() ;
        CGRPCOREPTR     pStart;
    if( !fReverse ) {
                CNewsGroupCore *p = m_pFirst;
                while (p && p->IsDeleted()) p = p->m_pNext;
                pStart = p;
    } else {
                CNewsGroupCore *p = m_pLast;
                while (p && p->IsDeleted()) p = p->m_pPrev;
                pStart = p;
    }
        m_LockTables.ShareUnlock() ;

        CGroupIteratorCore*     pReturn = XNEW CGroupIteratorCore(this, pStart) ;
        return  pReturn ;
}

CGroupIteratorCore*
CNewsTreeCore::GetIterator(LPMULTISZ lpstrPattern, BOOL fIncludeSpecialGroups) {
/*++

Routine Description :

        Build an iterator that  will list newsgroups meeting
        all of the specified requirements.

Arguments :

        lpstrPattern - wildmat patterns the newsgroup must match
        fIncludeSecureGroups - if TRUE then include secure (SSL only) newsgroups
        fIncludeSpecialGroups - if TRUE then include reserved newsgroups

Return Value :

        An iterator, NULL on error

--*/

        CGRPCOREPTR pFirst;

        m_LockTables.ShareLock() ;
        CNewsGroupCore *p = m_pFirst;
        while (p != NULL && p->IsDeleted()) p = p->m_pNext;
        pFirst = p;
        m_LockTables.ShareUnlock() ;

        CGroupIteratorCore*     pIterator = XNEW CGroupIteratorCore(
                                                                                                this,
                                                                                                lpstrPattern,
                                                                                                pFirst,
                                                                                                fIncludeSpecialGroups
                                                                                                ) ;

    return  pIterator ;
}

//
// find the vroot which owns a group name
//
HRESULT CNewsTreeCore::LookupVRoot(char *pszGroup, INntpDriver **ppDriver) {
        NNTPVROOTPTR pVRoot;

        if (m_fVRTableInit) {
                HRESULT hr = m_pVRTable->FindVRoot(pszGroup, &pVRoot);
                if (FAILED(hr)) return hr;
        } else {
                return E_UNEXPECTED;
        }

        *ppDriver = pVRoot->GetDriver();

        return S_OK;
}

//
// given a group ID find the matching group
//
// parameters:
//   dwGroupID - the group ID
//
//
HRESULT CINewsTree::FindGroupByID(DWORD dwGroupID,
                                                                  INNTPPropertyBag **ppNewsgroupProps,
                                                                  INntpComplete *pProtocolComplete )
{
        _ASSERT(this != NULL);
        _ASSERT(ppNewsgroupProps != NULL);

        return E_NOTIMPL;
}

//
// given a group name find the matching group.  if the group doesn't
// exist and fCreateIfNotExist is set then a new group will be created.
// the new group won't be available until CommitGroup() is called.
// if the group is Release'd before CommitGroup was called then it
// won't be added.
//
HRESULT CINewsTree::FindOrCreateGroupByName(LPSTR pszGroupName,
                                                                                BOOL fCreateIfNotExist,
                                                                                INNTPPropertyBag **ppNewsgroupProps,
                                                                                INntpComplete *pProtocolComplete,
                                                                                GROUPID groupid,
                                                                                BOOL fSetGroupId )
{
        CGRPCOREPTR pGroup;
        HRESULT hr;

        _ASSERT(pszGroupName != NULL);
        _ASSERT(this != NULL);
        _ASSERT(ppNewsgroupProps != NULL);

        hr = m_pParentTree->FindOrCreateGroup(  pszGroupName,
                                                FALSE,
                                                fCreateIfNotExist,
                                                FALSE,
                                                &pGroup,
                                                NULL,
                                                FALSE,
                                                groupid,
                                                fSetGroupId );

        if (SUCCEEDED(hr)) {
                *ppNewsgroupProps = pGroup->GetPropertyBag();
#ifdef DEBUG
                if ( pProtocolComplete ) ((CNntpComplete *)pProtocolComplete)->BumpGroupCounter();
#endif
        } else {
                *ppNewsgroupProps = NULL;
        }

        return hr;
}

//
// add a new group to the newstree
//
HRESULT CINewsTree::CommitGroup(INNTPPropertyBag *pNewsgroupProps) {
        _ASSERT(pNewsgroupProps != NULL);
        _ASSERT(this != NULL);

        return S_OK;
}

//
// remove an entry
//
HRESULT CINewsTree::RemoveGroupByID(DWORD dwGroupID) {
        _ASSERT(this != NULL);

        return E_NOTIMPL;
}

HRESULT CINewsTree::RemoveGroupByName(LPSTR pszGroupName, LPVOID lpContext) {
        _ASSERT(pszGroupName != NULL);
        _ASSERT(this != NULL);

        CGRPCOREPTR pGroup;
        HRESULT hr;

    //  First, get the CGRPCOREPTR
        hr = m_pParentTree->FindOrCreateGroup(  pszGroupName,
                                                FALSE,
                                                FALSE,  // fCreateIfNotExist,
                                                FALSE,  // fCreateinStore
                                                &pGroup,
                                                NULL,
                                                FALSE );

        if (SUCCEEDED(hr)) {
                //  Found the group, delete it from Newstree only
        if (!m_pParentTree->RemoveGroupFromTreeOnly(pGroup))
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
        }
        }

    return hr;
}

//
// enumerate across the list of keys.
//
HRESULT CINewsTree::GetIterator(INewsTreeIterator **ppIterator) {
        _ASSERT(this != NULL);
        _ASSERT(ppIterator != NULL);
        if (ppIterator == NULL) return E_INVALIDARG;

        *ppIterator = m_pParentTree->ActiveGroups();
        if (*ppIterator == NULL) return E_OUTOFMEMORY;

        return S_OK;
}

HRESULT CINewsTree::GetNntpServer(INntpServer **ppNntpServer) {
        _ASSERT(ppNntpServer != NULL);
        _ASSERT(this != NULL);
        if (ppNntpServer == NULL) return E_INVALIDARG;

        *ppNntpServer = m_pParentTree->GetNntpServer();
        return S_OK;
}

HRESULT CINewsTree::LookupVRoot(char *pszGroup, INntpDriver **ppDriver) {
        _ASSERT(this != NULL);
        _ASSERT(ppDriver != NULL);

        return m_pParentTree->LookupVRoot(pszGroup, ppDriver);
}

//
// this callback is called for each vroot in the vroot table.  it calls
// the drop driver method
//
// parameters:
//   pEnumContext - ignored
//   pVRoot - the pointer to the vroot object.
//
void CNewsTreeCore::DropDriverCallback(void *pEnumContext,
                                                                           CVRoot *pVRoot)
{
        ((CNNTPVRoot *) pVRoot)->DropDriver();
}

//
// a vroot rescan took place.  enumerate through all of the groups and
// update their vroot pointers
//
void CNewsTreeCore::VRootRescanCallback(void *pContext) {
        TraceQuietEnter("CNewsTreeCore::VRootRescanCallback");

        CNewsTreeCore *pThis = ((CINewsTree *) pContext)->GetTree();

        pThis->m_LockTables.ShareLock() ;
        pThis->m_fVRTableInit = TRUE;
        CNewsGroupCore *p = pThis->m_pFirst;
        while (p) {
                NNTPVROOTPTR pVRoot;
                HRESULT hr = pThis->m_pVRTable->FindVRoot(p->GetName(), &pVRoot);
                if (FAILED(hr)) pVRoot = NULL;
                p->UpdateVRoot(pVRoot);
                //DebugTrace((DWORD_PTR) pThis, "group %s has vroot 0x%x",
                //      p->GetName(), pVRoot);

            p = p->m_pNext;
        }
        pThis->m_LockTables.ShareUnlock() ;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\nntp\server\newstree\src\stdinc.h ===
#ifndef	_STDINC_H_
#define	_STDINC_H_

//
// disables a browser info warning that breaks the build
//
#pragma warning (disable:4786)

//
// disables redundant warning about / in // comments
//
#pragma warning (disable:4010)

#ifdef __cplusplus
extern "C" {
#endif

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>

#ifdef __cplusplus
};
#endif

#include <xmemwrpr.h>
#include <malloc.h>
#include <mbstring.h>
#include <nntptype.h>
#include <nntps.h>
#include <nntpapi.h>
#include <tigdflts.h>
#include <nntpmeta.h>
#include <nntpcons.h>
#include <nntputil.h>

#include "dbgtrace.h"
//#include "resource.h"

#include "tigtypes.h"
#include "fsconst.h"
#include "crchash.h"

#ifdef PROFILING
#include "icapexp.h"
#endif

typedef char *LPMULTISZ;

#include <instwpex.h>
#include "nntpvr.h"
#include "group.h"
#include "nwstree.h"
#include "nntpbag.h"
#include "nntperr.h"
#include "mapfile.h"
#include "ihash.h"
#include "drvid.h"

#pragma hdrstop

#endif	// _STDINC_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\nntp\server\nntpdbg\nntpdbgp.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    ntsdextp.h

Abstract:

    Common header file for NTSDEXTS component source files.

Author:

    Steve Wood (stevewo) 21-Feb-1995

Revision History:

--*/

#if 0
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>
#include <winsock.h>
#include <ntsdexts.h>
#include <stdio.h>
#include <string.h>
#include <wchar.h>
#endif

#define move(dst, src)\
__try {\
    ReadMemory((LPVOID) (src), &(dst), sizeof(dst), NULL);\
} __except (EXCEPTION_EXECUTE_HANDLER) {\
    return;\
}
#define moveBlock(dst, src, size)\
__try {\
    ReadMemory((LPVOID) (src), &(dst), (size), NULL);\
} __except (EXCEPTION_EXECUTE_HANDLER) {\
    return;\
}

#ifdef __cplusplus
#define CPPMOD extern "C"
#else
#define CPPMOD
#endif

#define DECLARE_API(s)                          \
    CPPMOD VOID                                 \
    s(                                          \
        HANDLE hCurrentProcess,                 \
        HANDLE hCurrentThread,                  \
        DWORD dwCurrentPc,                      \
        PNTSD_EXTENSION_APIS lpExtensionApis,   \
        LPSTR lpArgumentString                  \
     )

#define INIT_API() {                            \
    ExtensionApis = *lpExtensionApis;           \
    ExtensionCurrentProcess = hCurrentProcess;  \
    }

#define dprintf                 (ExtensionApis.lpOutputRoutine)
#define GetExpression           (ExtensionApis.lpGetExpressionRoutine)
#define GetSymbol               (ExtensionApis.lpGetSymbolRoutine)
#define Disassm                 (ExtensionApis.lpDisasmRoutine)
#define CheckControlC           (ExtensionApis.lpCheckControlCRoutine)
#define ReadMemory(a,b,c,d)     ReadProcessMemory( ExtensionCurrentProcess, (LPCVOID)(a), (b), (c), (d) )
#define WriteMemory(a,b,c,d)    WriteProcessMemory( ExtensionCurrentProcess, (LPVOID)(a), (LPVOID)(b), (c), (d) )


#ifndef DbgAlloc
#define DbgAlloc( n ) HeapAlloc( GetProcessHeap(), 0, (n) )
#endif
#ifndef DbgFree
#define DbgFree( p ) HeapFree( GetProcessHeap(), 0, (p) )
#define DbgFreeEx( p ) if( (p) ) DbgFree( (p) )
#endif

extern NTSD_EXTENSION_APIS ExtensionApis;
extern HANDLE ExtensionCurrentProcess;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\nntp\server\nntpdbg\dbgnntp.cxx ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    inetdbg.c

Abstract:

    This function contains the default ntsd debugger extensions

Author:

    Mark Lucovsky (markl) 09-Apr-1991

Revision History:

--*/

#ifdef DBG
#undef DBG
#endif

#define dllexp
#define CALL_STACK_BUF_SIZE 1024

//
// To obtain the private & protected members of C++ class,
// let me fake the "private" keyword
//
# define private    public
# define protected    public

#define INCL_INETSRV_INCS
#include <tigris.hxx>
#include "smtpcli.h"

#include  <ntsdexts.h>
#include "nntpdbgp.h"

extern "C" {
#if 0
void __cdecl main( void )
{
   ;
}
#endif
}

//
// Globals that we have to have because we included others' headers
//

CShareLockNH    CNewsGroupCore::m_rglock[GROUP_LOCK_ARRAY_SIZE];

//DECLARE_DEBUG_PRINTS_OBJECT( );

NTSD_EXTENSION_APIS ExtensionApis;
HANDLE ExtensionCurrentProcess;

// globals
char g_szBuffer [1024];	// temp buffer for misc stuff

VOID
PrintUsage(
    VOID
    );

VOID
PrintSystemTime(
	FILETIME* pftTime
	);

VOID
PrintString(
	LPSTR lp1,
	LPSTR lp2
	);

VOID
DbgPrintInstance(
	NNTP_SERVER_INSTANCE* pInstance
	);

VOID
DbgPrintNewstree(
	CNewsTree* ptree,
	DWORD nGroups
	);

CNewsGroup*
DbgPrintNewsgroup(
    CNewsGroup * pSrcGroup
    );

CNNTPVRoot*
DbgPrintVRoot(
    CNNTPVRoot *pDestGroup
    );

VOID
DbgPrintVRootList(
	CNNTPVRoot* pFirstVRoot,
	DWORD nVRoots
	);

VOID
DbgPrintDebugVRootList(
	CNNTPVRoot* pFirstVRoot,
	DWORD nVRoots
	);

void
DbgPrintVRootTable(
    CNNTPVRootTable * pVRTable
    );

VOID
DbgDumpPool(
	CSmtpClientPool* pSCPool
	);

VOID
DbgDumpFeedBlock(
	PFEED_BLOCK feedBlock
	);

VOID
DbgDumpFeedList(
	CFeedList* pSrcFeedList,
	CFeedList* pDstFeedList
	);

VOID
DbgDumpCPool(CPool* pCPool, DWORD dwSignature, LPCSTR symbol);

VOID
SkipArgument( LPSTR* ppArg )
{
    // skip the arg and the spaces after
    while( *(*ppArg) != ' ' ) (*ppArg)++;
    while( *(*ppArg) == ' ' ) (*ppArg)++;
}

//
//  Here and elsewhere we use "nntpsvc" prefix in GetExpression() calls.
//

#define DEBUG_PREFIX    "&nntpsvc!"

#define DumpDword( symbol )                                     \
        {                                                       \
            DWORD dw = GetExpression( DEBUG_PREFIX symbol );    \
            DWORD dwValue = 0;                                  \
                                                                \
            if ( dw )                                           \
            {                                                   \
                if ( ReadMemory( (LPVOID) dw,                   \
                                 &dwValue,                      \
                                 sizeof(dwValue),               \
                                 NULL ))                        \
                {                                               \
                    dprintf( "\t" symbol "   = %8d (0x%8lx)\n", \
                             dwValue,                           \
                             dwValue );                         \
                }                                               \
            }                                                   \
        }

#define DumpCPool( symbol, signature )                          \
        {                                                       \
           DbgDumpCPool((CPool*)GetExpression(DEBUG_PREFIX symbol), signature, symbol );    \
        }


//
// util functions
//
VOID
CopyUnicodeStringIntoAscii(
            IN LPSTR AsciiString,
            IN LPWSTR UnicodeString
                 )
{
    while ( (*AsciiString++ = (CHAR)*UnicodeString++) != '\0');

} // CopyUnicodeStringIntoAscii

DECLARE_API( help )
{
    INIT_API();

    PrintUsage();
}

DECLARE_API( cpool )
{
	CPool* pCPool;

	INIT_API();

    while (*lpArgumentString == ' ')
        lpArgumentString++;

    if ( !*lpArgumentString )
    {
        PrintUsage();
        return;
    }

    //
    //  Get the address of the instance
    //
	pCPool = (CPool*)GetExpression( lpArgumentString );
	
    if ( !pCPool )
    {
        dprintf( "nntpdbg: Unable to evaluate \"%s\"\n", lpArgumentString );
        return;
    }

	DbgDumpCPool(pCPool, 0, NULL);
}

DECLARE_API( cpools )
{
    INIT_API();

    //
    //  Dump Nntpsvc cpools
    //

    dprintf("Nntpsvc Cpools:\n");

    DumpCPool("CArticle__gArticlePool",ARTICLE_SIGNATURE);
    DumpCPool("CCIOAllocator__IOPool",CIO_SIGNATURE) ;
    DumpCPool("CFeed__gFeedPool",FEED_SIGNATURE) ;
    DumpCPool("CChannel__gChannelPool",CHANNEL_SIGNATURE) ;
    DumpCPool("CSessionSocket__gSocketAllocator",SESSION_SOCKET_SIGNATURE) ;
    DumpCPool("CSessionState__gStatePool",SESSION_STATE_SIGNATURE) ;
    DumpCPool("CXoverIndex__gCacheAllocator",1) ;
    DumpCPool("CXoverIndex__gXoverIndexAllocator",1) ;
}

DECLARE_API( instance )

/*++

Routine Description:

    This function is called as an NTSD extension to format and dump
    an object attributes structure.

Arguments:

    hCurrentProcess - Supplies a handle to the current process (at the
        time the extension was called).

    hCurrentThread - Supplies a handle to the current thread (at the
        time the extension was called).

    CurrentPc - Supplies the current pc at the time the extension is
        called.

    lpExtensionApis - Supplies the address of the functions callable
        by this extension.

    lpArgumentString - Supplies the asciiz string that describes the
        ansi string to be dumped.

Return Value:

    None.

--*/

{
	NNTP_SERVER_INSTANCE	  *pSrcInst, *pDstInst;
	DWORD		  cbInst = sizeof(NNTP_SERVER_INSTANCE);

    INIT_API();

    while (*lpArgumentString == ' ')
        lpArgumentString++;

    if ( !*lpArgumentString )
    {
        PrintUsage();
        return;
    }

    //
    //  Get the address of the instance
    //
	pSrcInst = (NNTP_SERVER_INSTANCE*)GetExpression( lpArgumentString );
	
    if ( !pSrcInst )
    {
        dprintf( "nntpdbg: Unable to evaluate \"%s\"\n", lpArgumentString );
        return;
    }

	dprintf("Instance object is 0x%p\n", pSrcInst);

	//	
	//	Allocate memory in our address space so we can read data from the debuggee's address space
	//
	pDstInst = (NNTP_SERVER_INSTANCE*) DbgAlloc( cbInst );

	if( !pDstInst )
	{
        dprintf( "nntpdbg: Unable to allocate memory \n");
        return;
	}

	if( !ReadMemory( pSrcInst, pDstInst, cbInst, NULL ) )
	{
		dprintf("Could not get data at 0x%x\n", pSrcInst);
		DbgFree( pDstInst );
		return;
	}

	//
	//	Dump the the server instance
	//
	
	DbgPrintInstance( pDstInst );
	DbgFree( pDstInst );
}

DECLARE_API( newstree )

/*++

Routine Description:

    This function is called as an NTSD extension to format and dump
    an object attributes structure.

Arguments:

    hCurrentProcess - Supplies a handle to the current process (at the
        time the extension was called).

    hCurrentThread - Supplies a handle to the current thread (at the
        time the extension was called).

    CurrentPc - Supplies the current pc at the time the extension is
        called.

    lpExtensionApis - Supplies the address of the functions callable
        by this extension.

    lpArgumentString - Supplies the asciiz string that describes the
        ansi string to be dumped.

Return Value:

    None.

--*/

{
	CNewsTree	  *pSrcTree, *pDstTree;
	DWORD		  cbTree = sizeof(CNewsTree);
	DWORD		  nGroups = 0;

    INIT_API();

    while (*lpArgumentString == ' ')
        lpArgumentString++;

    if ( !*lpArgumentString )
    {
        PrintUsage();
        return;
    }

    //
    //  Get the address of the global newstree pointer
    //
	pSrcTree = (CNewsTree*)GetExpression( lpArgumentString );
	
    if ( !pSrcTree )
    {
        dprintf( "nntpdbg: Unable to evaluate \"%s\"\n", lpArgumentString );
        return;
    }

	// same as doing pSrcTree = *ppSrcTree !!
	dprintf("Newstree object is 0x%p\n", pSrcTree);

    SkipArgument( &lpArgumentString );
    nGroups = atoi( lpArgumentString );
    
	//	
	//	Allocate memory in our address space so we can read data from the debuggee's address space
	//
	pDstTree = (CNewsTree*) DbgAlloc( cbTree );

	if( !pDstTree )
	{
        dprintf( "nntpdbg: Unable to allocate memory \n");
        return;
	}

	if( !ReadMemory( pSrcTree, pDstTree, cbTree, NULL ) )
	{
		dprintf("Could not get data at 0x%x\n", pSrcTree);
		DbgFree( pDstTree );
		return;
	}

	//
	//	Dump the newstree
	//
	DbgPrintNewstree( pDstTree, nGroups );
	DbgFree( pDstTree );
}

DECLARE_API( vrootlist )

/*++

Routine Description:

    This function is called as an NTSD extension to format and dump
    an object attributes structure.

Arguments:

    hCurrentProcess - Supplies a handle to the current process (at the
        time the extension was called).

    hCurrentThread - Supplies a handle to the current thread (at the
        time the extension was called).

    CurrentPc - Supplies the current pc at the time the extension is
        called.

    lpExtensionApis - Supplies the address of the functions callable
        by this extension.

    lpArgumentString - Supplies the asciiz string that describes the
        ansi string to be dumped.

Return Value:

    None.

--*/

{
    CNNTPVRoot    *pFirstVRoot;
	DWORD		  nVRoots = 0;

    INIT_API();

    while (*lpArgumentString == ' ')
        lpArgumentString++;

    if ( !*lpArgumentString )
    {
        PrintUsage();
        return;
    }

    //
    //  Get the address of the first vroot
    //
    
	pFirstVRoot = (CNNTPVRoot*)GetExpression( lpArgumentString );
    if ( !pFirstVRoot )
    {
        dprintf( "nntpdbg: Unable to evaluate \"%s\"\n", lpArgumentString );
        return;
    }

    SkipArgument( &lpArgumentString );
    nVRoots = atoi( lpArgumentString );
    
	//
	//	Dump the list
	//
	DbgPrintVRootList( pFirstVRoot, nVRoots );
}


DECLARE_API( newsgroup )

/*++

Routine Description:

    This function is called as an NTSD extension to format and dump
    an object attributes structure.

Arguments:

    hCurrentProcess - Supplies a handle to the current process (at the
        time the extension was called).

    hCurrentThread - Supplies a handle to the current thread (at the
        time the extension was called).

    CurrentPc - Supplies the current pc at the time the extension is
        called.

    lpExtensionApis - Supplies the address of the functions callable
        by this extension.

    lpArgumentString - Supplies the asciiz string that describes the
        ansi string to be dumped.

Return Value:

    None.

--*/

{
	CNewsGroup*   pSrcGroup;

    INIT_API();

    while (*lpArgumentString == ' ')
        lpArgumentString++;

    if ( !*lpArgumentString )
    {
        PrintUsage();
        return;
    }

    //
    //  Treat the argument as the address of a CNewsGroup struct
    //	NOTE: pSrcGroup is an address in the debuggee's address space !
	//

    pSrcGroup = (CNewsGroup*)GetExpression( lpArgumentString );

    if ( !pSrcGroup )
    {
        dprintf( "nntpdbg: Unable to evaluate \"%s\"\n", lpArgumentString );
        return;
    }

	//
	//	Dump the CNewsGroup object
	//
	DbgPrintNewsgroup( pSrcGroup );
}

DECLARE_API( vroot )

/*++

Routine Description:

    This function is called as an NTSD extension to format and dump
    an object attributes structure.

Arguments:

    hCurrentProcess - Supplies a handle to the current process (at the
        time the extension was called).

    hCurrentThread - Supplies a handle to the current thread (at the
        time the extension was called).

    CurrentPc - Supplies the current pc at the time the extension is
        called.

    lpExtensionApis - Supplies the address of the functions callable
        by this extension.

    lpArgumentString - Supplies the asciiz string that describes the
        ansi string to be dumped.

Return Value:

    None.

--*/

{
	CNNTPVRoot*   pVroot = NULL;

    INIT_API();

    while (*lpArgumentString == ' ')
        lpArgumentString++;

    if ( !*lpArgumentString )
    {
        PrintUsage();
        return;
    }

    //
    //  Treat the argument as the address of a CNNTPVRoot struct
    //	NOTE: pVroot is an address in the debuggee's address space !
	//

    pVroot = (CNNTPVRoot*)GetExpression( lpArgumentString );

    if ( !pVroot )
    {
        dprintf( "nntpdbg: Unable to evaluate \"%s\"\n", lpArgumentString );
        return;
    }

	//
	//	Dump the CNNTPVRoot object
	//
	DbgPrintVRoot( pVroot );
}

DECLARE_API( vrtable )

/*++

Routine Description:

    This function is called as an NTSD extension to format and dump
    an object attributes structure.

Arguments:

    hCurrentProcess - Supplies a handle to the current process (at the
        time the extension was called).

    hCurrentThread - Supplies a handle to the current thread (at the
        time the extension was called).

    CurrentPc - Supplies the current pc at the time the extension is
        called.

    lpExtensionApis - Supplies the address of the functions callable
        by this extension.

    lpArgumentString - Supplies the asciiz string that describes the
        ansi string to be dumped.

Return Value:

    None.

--*/

{
	CNNTPVRootTable*   pVRTable = NULL;

    INIT_API();

    while (*lpArgumentString == ' ')
        lpArgumentString++;

    if ( !*lpArgumentString )
    {
        PrintUsage();
        return;
    }

    //
    //  Treat the argument as the address of a CNNTPVRootTable struct
    //	NOTE: pVRTable is an address in the debuggee's address space !
	//

    pVRTable = (CNNTPVRootTable*)GetExpression( lpArgumentString );

    if ( !pVRTable )
    {
        dprintf( "nntpdbg: Unable to evaluate \"%s\"\n", lpArgumentString );
        return;
    }

	//
	//	Dump the CNNTPVRootTable object
	//
	DbgPrintVRootTable( pVRTable );
}

DECLARE_API( sockets )

/*++

Routine Description:

    This function is called as an NTSD extension to format and dump
    an object attributes structure.

Arguments:

    hCurrentProcess - Supplies a handle to the current process (at the
        time the extension was called).

    hCurrentThread - Supplies a handle to the current thread (at the
        time the extension was called).

    CurrentPc - Supplies the current pc at the time the extension is
        called.

    lpExtensionApis - Supplies the address of the functions callable
        by this extension.

    lpArgumentString - Supplies the asciiz string that describes the
        ansi string to be dumped.

Return Value:

    None.

--*/

{
	CSessionSocket	  *pSrcSocket, *pDstSocket;
	DWORD		  cbSocket = sizeof(CSessionSocket);

    INIT_API();

    while (*lpArgumentString == ' ')
        lpArgumentString++;

    if ( !*lpArgumentString )
    {
        PrintUsage();
        return;
    }

    //
    //  Get the address of the socket obj
    //
	pSrcSocket = (CSessionSocket*)GetExpression( lpArgumentString );
	
    if ( !pSrcSocket )
    {
        dprintf( "nntpdbg: Unable to evaluate \"%s\"\n", lpArgumentString );
        return;
    }

	dprintf("Socket object is 0x%p\n", pSrcSocket);

	//	
	//	Allocate memory in our address space so we can read data from the debuggee's address space
	//
	pDstSocket = (CSessionSocket*) DbgAlloc( cbSocket );

	if( !pDstSocket )
	{
        dprintf( "nntpdbg: Unable to allocate memory \n");
        return;
	}

	if( !ReadMemory( pSrcSocket, pDstSocket, cbSocket, NULL ) )
	{
		dprintf("Could not get data at 0x%x\n", pSrcSocket);
		DbgFree( pDstSocket );
		return;
	}

	//
	//	Dump the socket obj
	//

	dprintf(" ========== socket object =========== \n");

    dprintf(" Prev = 0x%p Next = 0x%p \n", pDstSocket->m_pPrev, pDstSocket->m_pPrev);
    dprintf(" Sink = 0x%p \n", pDstSocket->m_pSink );
    dprintf(" Port = 0x%08lx \n", pDstSocket->m_nntpPort );
    dprintf(" ClientContext = 0x%p \n", pDstSocket->m_context );
    
	dprintf(" ========== socket object =========== \n");
	
	DbgFree( pDstSocket );
}

DECLARE_API( smtp )

/*++

Routine Description:

    This function is called as an NTSD extension to format and dump
    an object attributes structure.

Arguments:

    hCurrentProcess - Supplies a handle to the current process (at the
        time the extension was called).

    hCurrentThread - Supplies a handle to the current thread (at the
        time the extension was called).

    CurrentPc - Supplies the current pc at the time the extension is
        called.

    lpExtensionApis - Supplies the address of the functions callable
        by this extension.

    lpArgumentString - Supplies the asciiz string that describes the
        ansi string to be dumped.

Return Value:

    None.

--*/

{
	CSmtpClientPool		*pSrcSCPool, *pDstSCPool;
	DWORD				cbSCPool = sizeof(CSmtpClientPool);

    INIT_API();

    //
    //  Get the address of the global newstree pointer
    //
	pSrcSCPool = (CSmtpClientPool*)GetExpression( DEBUG_PREFIX "g_SCPool" );
	
    if ( !pSrcSCPool )
    {
        dprintf( "nntpdbg: Unable to evaluate \"%s\"\n", DEBUG_PREFIX "g_SCPool" );
        return;
    }

	//	
	//	Allocate memory in our address space so we can read data from the debuggee's address space
	//
	pDstSCPool = (CSmtpClientPool*) DbgAlloc( cbSCPool );

	if( !pDstSCPool )
	{
        dprintf( "nntpdbg: Unable to allocate memory \n");
        return;
	}

	if( !ReadMemory( pSrcSCPool, pDstSCPool, cbSCPool, NULL ) )
	{
		dprintf("Could not get data at 0x%x\n", pSrcSCPool);
		DbgFree( pDstSCPool );
		return;
	}

    //
    //  Dump the smtp conx cache
    //
	DbgDumpPool( pDstSCPool );
	DbgFree( pDstSCPool );
}

DECLARE_API( feedlist )

/*++

Routine Description:

    This function is called as an NTSD extension to format and dump
    an object attributes structure.

Arguments:

    hCurrentProcess - Supplies a handle to the current process (at the
        time the extension was called).

    hCurrentThread - Supplies a handle to the current thread (at the
        time the extension was called).

    CurrentPc - Supplies the current pc at the time the extension is
        called.

    lpExtensionApis - Supplies the address of the functions callable
        by this extension.

    lpArgumentString - Supplies the asciiz string that describes the
        ansi string to be dumped.

Return Value:

    None.

--*/

{
	CFeedList*	  pSrcFeedList;
	CFeedList*	  pDstFeedList;
	DWORD		  cbFeedList = sizeof(CFeedList);

    INIT_API();

    while (*lpArgumentString == ' ')
        lpArgumentString++;

    if ( !*lpArgumentString )
    {
        PrintUsage();
        return;
    }

	//
	//	Get the ActiveFeeds global
	//
	pSrcFeedList = (CFeedList*)GetExpression( lpArgumentString );
	
    if ( !pSrcFeedList )
    {
        dprintf( "nntpdbg: Unable to evaluate \"%s\"\n", lpArgumentString );
        return;
    }

	pDstFeedList = (CFeedList*)DbgAlloc( cbFeedList );
	if( !pDstFeedList )
	{
		dprintf("nntpdbg: Unable to allocate memory\n");
		return;
	}

    //
    //  Dump the feedblock list
    //
	if( !ReadMemory( pSrcFeedList, pDstFeedList, cbFeedList, NULL ) )
	{
		dprintf("nntpdbg: Unable to read memory at 0x%p\n", pSrcFeedList );
		DbgFree( pDstFeedList );
		return;
	}

	DbgDumpFeedList( pSrcFeedList, pDstFeedList );
	DbgFree( pDstFeedList );
}

DECLARE_API( feed )

/*++

Routine Description:

    This function is called as an NTSD extension to format and dump
    an object attributes structure.

Arguments:

    hCurrentProcess - Supplies a handle to the current process (at the
        time the extension was called).

    hCurrentThread - Supplies a handle to the current thread (at the
        time the extension was called).

    CurrentPc - Supplies the current pc at the time the extension is
        called.

    lpExtensionApis - Supplies the address of the functions callable
        by this extension.

    lpArgumentString - Supplies the asciiz string that describes the
        ansi string to be dumped.

Return Value:

    None.

--*/

{
	PFEED_BLOCK	  feedBlock;

    INIT_API();

    while (*lpArgumentString == ' ')
        lpArgumentString++;

    if ( !*lpArgumentString )
    {
        PrintUsage();
        return;
    }

    //
    //  Treat the argument as the address of a FEED_BLOCK
    //

    feedBlock = (PFEED_BLOCK)GetExpression( lpArgumentString );

    if ( !feedBlock )
    {
        dprintf( "nntpdbg: Unable to evaluate \"%s\"\n", lpArgumentString );
        return;
    }

    DbgDumpFeedBlock( feedBlock );
}

DECLARE_API( rf )

/*++

Routine Description:

    This function is called as an NTSD extension to format and dump
    an object attributes structure.

Arguments:

    hCurrentProcess - Supplies a handle to the current process (at the
        time the extension was called).

    hCurrentThread - Supplies a handle to the current thread (at the
        time the extension was called).

    CurrentPc - Supplies the current pc at the time the extension is
        called.

    lpExtensionApis - Supplies the address of the functions callable
        by this extension.

    lpArgumentString - Supplies the asciiz string that describes the
        ansi string to be dumped.

Return Value:

    None.

--*/

{
    INIT_API();

    PLONG   pcCallStack = NULL;
    LONG    cCallStack = 0;
    PVOID   pvCallStack = NULL;
    CHAR**  ppchCallStack = NULL;
    CHAR**  ppchReal = NULL;
    LPVOID  lpvCallStack = NULL;
    LPVOID  lpvBuffer = NULL;

    //
    //  Get the number of buffers
    //
	pcCallStack = (PLONG)GetExpression( "exstrace!g_iCallStack" );
    if ( !pcCallStack )
    {
        dprintf( "nntpdbg: Unable to evaluate \"exstrace!g_cCallStack\"\n" );
        return;
    }

    if ( !ReadMemory( pcCallStack, &cCallStack, sizeof(LONG), NULL ) ) {
        dprintf( "nntpdbg: Could not read g_cCallStack\n" );
        return;
    }

    //
    // Get pointer to buffer
    //
    pvCallStack = (CHAR**)GetExpression( "exstrace!g_ppchCallStack" );
    if ( !pvCallStack ) 
    {
        dprintf( "nntpdbg: Unable to evaluate \"exstrace!g_ppchCallStack\"\n" );
        return;
    }

    if ( !ReadMemory( pvCallStack, &ppchCallStack, sizeof(CHAR**), NULL ) ) {
        dprintf( "nntpdbg: Could not read g_ppchCallStack\n" );
        return;
    }

    lpvCallStack = DbgAlloc( sizeof(CHAR*) * cCallStack );
    if ( !lpvCallStack ) {
        dprintf( "nntpdbg: Unable to allocate memory\n" );
        return;
    }

    if ( !ReadMemory( ppchCallStack, lpvCallStack, sizeof(CHAR*)*cCallStack, NULL ) ) {
        dprintf( "nntpdbg: Could not get data at 0x%x\n", ppchCallStack );
        DbgFree( lpvCallStack );
        return;
    } else 
        ppchReal = (CHAR**)lpvCallStack;

    lpvBuffer = DbgAlloc( CALL_STACK_BUF_SIZE );
    if ( !lpvBuffer ) {
        DbgFree( lpvCallStack );
        dprintf( "nntpdbg: Unable to allocate memory\n" );
        return;
    }
    
    for ( LONG i = 0; i < cCallStack; i++ ) {
        if( ppchReal[i] ) {
            if ( !ReadMemory( ppchReal[i], lpvBuffer, CALL_STACK_BUF_SIZE, NULL ) ) {
                dprintf( "nntpdbg: Could not get data at 0x%x\n", ppchReal[i] );
                DbgFree( lpvCallStack );
                DbgFree( lpvBuffer );
                return;
            }
            *(PBYTE(lpvBuffer)+CALL_STACK_BUF_SIZE-1) = 0;
            dprintf("%s\n", (PCHAR)lpvBuffer );
        }
    }

    DbgFree( lpvBuffer );
	DbgFree( lpvCallStack );
}

VOID
PrintUsage(
    VOID
    )
{
    dprintf("\n\nMicrosoft Internet News Server debugging extension, Version 2.0\n\n");

    dprintf("!vroot <address>       - Dump nntp virtual root\n");
    dprintf("!vrtable <address>     - Dump nntp virtual root table\n");
    dprintf("!vrootlist <address> <n> - Dump the first <n> vroots in the table\n");
    dprintf("!cpool <address>       - Dump CPool at <address>\n");
    dprintf("!cpools                - Dump nntpsvc cpools\n");
    dprintf("!instance <address>    - Dump instance at <address> \n");
    dprintf("!newstree <address> <n>- Dump first <n> newsgroups in newstree at <address> \n");
    dprintf("!newsgroup <address>   - Dump newsgroup at <address> \n");
    dprintf("!sockets <address>     - Dump socket at <address> \n");
    dprintf("!smtp                  - Dump smtp conx cache \n");
    dprintf("!feedlist <address>    - Dump active feedblock list at <address> \n");
    dprintf("!feed <address>        - Dump feedblock at <address> \n");
    dprintf("!rf                    - Dump all randfail call stacks \n" );
    dprintf("!help                  - Usage \n\n");
}

VOID
DbgPrintInstance(
	NNTP_SERVER_INSTANCE* pInst
	)
/*++

Routine Description:
	
	Dump the first n newsgroup objects in the newstree.
	NOTE: Assumed that the pointer passed is in OUR address space

--*/
{
	dprintf("\n\n======== Begin Instance dump =========\n");

    if ( NNTP_SERVER_INSTANCE_SIGNATURE == pInst->m_signature ) {
    
        switch( pInst->m_dwServerState ) {
            case MD_SERVER_STATE_STARTED:
                dprintf("Server state is started\n");
                break;
            case MD_SERVER_STATE_STARTING:
                dprintf("Server state is starting\n");
                break;
            case MD_SERVER_STATE_STOPPING:
                dprintf("Server state is stopping\n" );
                break;
            case MD_SERVER_STATE_STOPPED:
                dprintf("Server state is stopped\n" );
                break;
            case MD_SERVER_STATE_PAUSING:
                dprintf("Server state is pausing\n" );
                break;
            case MD_SERVER_STATE_PAUSED:
                dprintf("Server state is paused\n" );
                break;
            case MD_SERVER_STATE_CONTINUING:
                dprintf("Server state is continuing\n" );
                break;
        }

        dprintf("Server has %d references\n", pInst->m_reference );
        dprintf("Instance id is %d\n", pInst->QueryInstanceId() );
        dprintf("Default port is %d\n", pInst->m_sDefaultPort );
        pInst->m_fAddedToServerInstanceList ?
            dprintf("Added to server instance list\n" ) :
            dprintf("NOT added to server instance list\n" );
        dprintf("It has %d connections now\n", pInst->m_dwCurrentConnections );
        dprintf("Owning service is 0x%p\n", pInst->m_Service );
        dprintf("Previous instance 0x%p\n", 
                CONTAINING_RECORD(  pInst->m_InstanceListEntry.Flink,
                                    IIS_SERVER_INSTANCE,
                                    m_InstanceListEntry ) );
        dprintf("Next instance 0x%p\n", 
                CONTAINING_RECORD(  pInst->m_InstanceListEntry.Blink,
                                    IIS_SERVER_INSTANCE,
                                    m_InstanceListEntry ) );
        pInst->m_ServiceStartCalled ?
            dprintf("Start method called\n") :
            dprintf("Start method NOT called\n" );
            
        dprintf("Article table pointer 0x%p\n", pInst->m_pArticleTable );
        dprintf("History table pointer 0x%p\n", pInst->m_pHistoryTable );
        dprintf("Xover table pointer 0x%p\n", pInst->m_pXoverTable );
        dprintf("Xover cache is 0x%p\n", pInst->m_pXCache );
        dprintf("Expire object is 0x%p\n", pInst->m_pExpireObject );
        dprintf("VRoot table is 0x%p\n", pInst->m_pVRootTable );
        dprintf("Dirnot object is 0x%p\n", pInst->m_pDirNot );
        dprintf("Server object is 0x%p\n", pInst->m_pNntpServerObject );
        dprintf("Wrapper( for posting lib) is 0x%p\n", pInst->m_pInstanceWrapper );
        dprintf("Wrapper( for newstree lib) is 0x%p\n", pInst->m_pInstanceWrapperEx );
        dprintf("SEO router 0x%p\n", pInst->m_pSEORouter );
        dprintf("Newstree is 0x%p\n", pInst->m_pTree );
        
        pInst->m_fAllowClientPosts ?
                dprintf("Server allows client posts\n") :
                dprintf("Server doesn't allow client posts\n" );
        pInst->m_fAllowFeedPosts ?
                dprintf("Server allows feed posts\n" ) :
                dprintf("Server doesn't allow feed posts\n" );
        pInst->m_fAllowControlMessages ?
                dprintf("Server allows control messages\n" ) :
                dprintf("Server doesn't allow control messages\n" );
        pInst->m_fNewnewsAllowed ?
                dprintf("Newnews allowed\n" ) :
                dprintf("Newnews not allowed\n" );
                
        dprintf("Client post hard limit %d\n", pInst->m_cbHardLimit );
        dprintf("Client post soft limit %d\n", pInst->m_cbSoftLimit );
        dprintf("Feed hard limit %d\n", pInst->m_cbFeedHardLimit );
        dprintf("Feed soft limit %d\n", pInst->m_cbFeedSoftLimit );
        dprintf("SSL access params 0x%08lx\n", pInst->m_dwSslAccessPerms );
        dprintf("SSLInfo object 0x%p\n", pInst->m_pSSLInfo );
        dprintf("Rebuild object 0x%p\n", pInst->m_pRebuild );
        dprintf("Last rebuild error %d\n", pInst->m_dwLastRebuildError );
        dprintf("Socket list 0x%p\n", pInst->m_pInUseList );
        dprintf("Active feed list 0x%p\n", pInst->m_pActiveFeeds );
        dprintf("Passive feed list 0x%p\n", pInst->m_pPassiveFeeds );
        
    } else {
        
        dprintf("Instance signature bad\n" );
    }
    
	dprintf("\n\n======== End Instance dump =========\n\n");
}

VOID
DbgPrintNewstree(
	CNewsTree* ptree,
	DWORD nGroups
	)
/*++

Routine Description:
	
	Dump the first n newsgroup objects in the newstree.
	NOTE: Assumed that the pointer passed is in OUR address space

--*/
{
	CNewsGroup* pGroup;

   	dprintf("\n\n======== Newstree members =========\n");

	dprintf(" Owning instance is 0x%p\n", ptree->m_pInstance );
	dprintf(" StartSpecial is %d\n", ptree->m_idStartSpecial );
	dprintf(" LastSpecial is %d\n", ptree->m_idLastSpecial );
	dprintf(" idSlaveGroup is %d\n", ptree->m_idSlaveGroup );
	dprintf(" idSpecialHigh is %d\n", ptree->m_idSpecialHigh );
	dprintf(" idStart is %d\n", ptree->m_idStart );
	dprintf(" idHigh is %d\n", ptree->m_idHigh );
    dprintf(" First group is 0x%p\n", ptree->m_pFirst );
    dprintf(" Last group is 0x%p\n", ptree->m_pLast );
    dprintf(" Num groups is %d\n", ptree->m_cGroups );
    dprintf(" VRoot table is 0x%p\n", ptree->m_pVRTable );
    ptree->m_fStoppingTree ?    dprintf( " Tree is being stopped\n" ) :
                                dprintf( " Tree is not being stopped\n" );
    dprintf(" Group.lst object is 0x%p\n", ptree->m_pFixedPropsFile );
    dprintf(" Groupvar.lst object is 0x%p\n", ptree->m_pVarPropsFile );
    dprintf(" Server object is 0x%p\n", ptree->m_pServerObject );
    ptree->m_fVRTableInit ? dprintf(" Vroot table initialized\n" ) :
                            dprintf(" Vroot table NOT initialized\n" );
    

    if( nGroups ) 
    {
    	dprintf("\n\n======== Begin Newstree dump =========\n");
    
	    for( pGroup = (CNewsGroup*)ptree->m_pFirst; pGroup && nGroups--; )
    	{
	    	pGroup = DbgPrintNewsgroup( pGroup );
	    }

    	dprintf("\n\n======== End Newstree dump =========\n\n");
	}
}

VOID
DbgPrintVRootList(
	CNNTPVRoot* pFirstVRoot,
	DWORD nVRoots
	)
/*++

Routine Description:
	
	Dump the first n newsgroup objects in the newstree.
	NOTE: Assumed that the pointer passed is in OUR address space

--*/
{
	CNNTPVRoot* pVRoot;

    if( nVRoots ) 
    {
    	dprintf("\n\n======== Begin virtual root list dump =========\n");
    
	    for( pVRoot = pFirstVRoot; pVRoot && nVRoots--; )
    	{
	    	pVRoot = DbgPrintVRoot( pVRoot );
	    }

    	dprintf("\n\n======== End virtual root list dump =========\n\n");
	}
}

VOID
PrintSystemTime(
	FILETIME* pftTime
	)
{
	SYSTEMTIME st;
	FileTimeToSystemTime( pftTime, &st );

	dprintf(" %04d::%02d::%02d::::%02d::%02d::%02d\n", st.wYear, st.wMonth, st.wDay, st.wHour, st.wMinute, st.wSecond);
}

VOID
PrintString(
	LPSTR lp1,
	LPSTR lp2
	)
{
	move( g_szBuffer, lp2 );
	dprintf( lp1, g_szBuffer );
}

CNewsGroup*
DbgPrintNewsgroup(
    CNewsGroup * pSrcGroup
    )
/*++

Routine Description:
	
	Dump the newsgroup object at pGroup.
	NOTE: Assumed that the pointer passed in is in the debuggee's address space
	      ie. we need to allocate memory and copy the data over into our address space !

Arguments:

Returns:

	The next newsgroup pointer

--*/
{
	CNewsGroup  *pGroup, *pDstGroup;
	char	    szNewsGroup [MAX_NEWSGROUP_NAME];
	DWORD       cbGroupName;
	LPCSTR	    lpstrGroup; 
	DWORD	    cbPath, cbNewsGroup;
	CNewsGroup* pGroupRet   = NULL;
	BOOL        fActive     = TRUE;         
	SYSTEMTIME  sysTime;

	//	
	//	Allocate memory in our address space so we can read data from the debuggee's address space
	//
	
	cbNewsGroup = sizeof(CNewsGroup);
	pDstGroup = (CNewsGroup*) DbgAlloc( cbNewsGroup );

	if( !pDstGroup )
	{
        dprintf( "nntpdbg: Unable to allocate memory \n");
        return NULL;
	}

	if( !ReadMemory( pSrcGroup, pDstGroup, cbNewsGroup, NULL ) )
	{
		dprintf("Could not get data at 0x%x\n", pSrcGroup);
		goto DbgPrintNewsgroup_Exit;
	}

	// Now, we can use pGroup to access the members of the CNewsGroup object
	pGroup = pDstGroup;

	//
	//	Dump the newsgroup object
	//
	
	dprintf("\n\n======== Begin Newsgroup object =========\n\n");

	//
	// Check to see if group object is deallocated
	//

	fActive = ( pGroup->m_dwSignature == CNEWSGROUPCORE_SIGNATURE );

	if ( fActive ) {

        //
        // dump newsgroup name
        //
	
        lpstrGroup = pGroup->m_pszGroupName;
        cbGroupName = pGroup->m_cchGroupName; // it should have already included '\0'
        if( ReadMemory( lpstrGroup, szNewsGroup, cbGroupName, NULL) ) {
	        dprintf("Newsgroup name is %s\n", szNewsGroup );
        }

        //
        // Dump native name
        //

        lpstrGroup = pGroup->m_pszNativeName;
        if ( lpstrGroup && ReadMemory( lpstrGroup, szNewsGroup, cbGroupName, NULL ) ) {
            dprintf("Pretty name is %s\n", szNewsGroup );
        } else {
            dprintf("No native name\n" );
        }

        //
        // Dump pretty name
        //

        lpstrGroup = pGroup->m_pszPrettyName;
        cbGroupName = pGroup->m_cchPrettyName;
        if ( lpstrGroup && ReadMemory( lpstrGroup, szNewsGroup, cbGroupName, NULL ) ) {
	        dprintf("Pretty name is %s\n", szNewsGroup );
	    } else {
	        dprintf("No pretty name\n" );
        }

        //
        // Dump help text
        //

        lpstrGroup = pGroup->m_pszHelpText;
        cbGroupName = pGroup->m_cchHelpText;
        if ( lpstrGroup && ReadMemory( lpstrGroup, szNewsGroup, cbGroupName, NULL ) ) {
            dprintf("Help text is %s\n", szNewsGroup );
        } else {
            dprintf("No help text\n" );
        }

        //
        // Dump moderator
        //

        lpstrGroup = pGroup->m_pszModerator;
        cbGroupName = pGroup->m_cchModerator;
        if ( lpstrGroup && ReadMemory( lpstrGroup, szNewsGroup, cbGroupName, NULL ) ) {
            dprintf("Moderator is %s\n", szNewsGroup );
        } else {
            dprintf("No moderator\n" );
        }

        //
	    // dump group privates
	    //
	    
	    dprintf("Ref count is %d\n", pGroup->m_cRefs );
	    dprintf("Parent tree is 0x%p\n", pGroup->m_pNewsTree );
	    dprintf("Parent vroot is 0x%p\n", pGroup->m_pVRoot );
	    dprintf("Low watermark is %d\n", pGroup->m_iLowWatermark);
	    dprintf("High watermark is %d\n", pGroup->m_iHighWatermark);
	    dprintf("Article estimate is %d\n", pGroup->m_cMessages );
	    dprintf("Group id is %d\n", pGroup->m_dwGroupId );
	    pGroup->m_fReadOnly ? dprintf("Group is read only\n" ) : dprintf("Group is not read only\n" );
	    pGroup->m_fDeleted ? dprintf("Group is marked deleted\n") : dprintf("Group is NOT marked deleted\n");
	    FileTimeToSystemTime( &(pGroup->m_ftCreateDate), &sysTime );
        dprintf("Group create time: %d/%d/%d - %d:%d:%d\n",
                sysTime.wMonth,
                sysTime.wDay,
                sysTime.wYear,
                sysTime.wHour,
                sysTime.wMinute,
                sysTime.wSecond );
        dprintf("Cache hit is %d\n", pGroup->m_dwCacheHit );
        pGroup->m_fAllowExpire ? dprintf( "Expire allowed\n" ) : dprintf( "Expire not allowed\n" );
        pGroup->m_fAllowPost ? dprintf( "Post allowed\n" ) : dprintf( "Expire not allowed\n" );
        pGroup->m_fDecorateVisited ? dprintf( "Decorate visited\n" ) : dprintf( "Decorate non-visited\n" );
        dprintf("m_artXoverExpireLow is %d\n", pGroup->m_artXoverExpireLow);
	    dprintf("Prev group is 0x%p\n", pGroup->m_pPrev);
	    dprintf("Next group is 0x%p\n", pGroup->m_pNext);
	    pGroupRet = (CNewsGroup*)pGroup->m_pNext;
	} else {

	    dprintf( "Newsgroup signature is bad\n" );
	}

	dprintf("\n======== End Newsgroup object =========\n");

DbgPrintNewsgroup_Exit:

	DbgFreeEx( pDstGroup );

	return pGroupRet;
}

CNNTPVRoot*
DbgPrintVRoot(
    CNNTPVRoot * pVRoot
    )
/*++

Routine Description:
	
	Dump the vroot object at pVRoot
	NOTE: Assumed that the pointer passed in is in the debuggee's address space
	      ie. we need to allocate memory and copy the data over into our address space !

Arguments:

Returns:

	The next newsgroup pointer

--*/
{
    CNNTPVRoot  *pDestVRoot, *pMyVRoot;
	DWORD       cbVRoot;
	CNNTPVRoot* pVRootRet   = NULL;
	BOOL        fActive     = FALSE;

	//	
	//	Allocate memory in our address space so we can read data from the debuggee's address space
	//
	
	cbVRoot = sizeof(CNNTPVRoot);
	pDestVRoot = (CNNTPVRoot*) DbgAlloc( cbVRoot );

	if( !pDestVRoot )
	{
        dprintf( "nntpdbg: Unable to allocate memory \n");
        return NULL;
	}

	if( !ReadMemory( pVRoot, pDestVRoot, cbVRoot, NULL ) )
	{
		dprintf("Could not get data at 0x%x\n", pVRoot );
		goto DbgPrintVRoot_Exit;
	}

	// Now, we can use pMyVRoot to access the members of the CNNTPVRoot object
	pMyVRoot = pDestVRoot;

	//
	//	Dump the vroot object
	//
	
	dprintf("\n\n======== Begin virtual root object =========\n\n");

	//
	// Check to see if group object is deallocated
	//

	fActive = ( pMyVRoot->m_dwSig == VROOT_GOOD_SIG );

	if ( fActive ) {

	    //
	    // Dump reference
        //

        dprintf("Reference count is %d\n", pMyVRoot->m_cRefs );
        dprintf("Next vroot is 0x%p\n", pMyVRoot->m_pNext );
        pVRootRet = (CNNTPVRoot*)pMyVRoot->m_pNext;
        dprintf("Prev vroot is 0x%p\n", pMyVRoot->m_pPrev );
        pMyVRoot->m_fInit ? dprintf("Vroot is initialized\n") :
                            dprintf("Vroot is NOT initialized\n" );
        dprintf("Vroot name is %s\n", pMyVRoot->m_szVRootName );
        dprintf("Owning vroot table is 0x%p\n", pMyVRoot->m_pVRootTable );
        pMyVRoot->m_fUpgrade ?  dprintf("This is an upgraded vroot\n" ) :
                                dprintf("This is not an upgraded vroot\n" );
        pMyVRoot->m_fIsIndexed ?  dprintf("Content indexed\n" ) :
                                dprintf("Not content indexed\n" );
        dprintf("Access bitmask is 0x%08lx\n", pMyVRoot->m_dwAccess );
        dprintf("SSL access bitmask 0x%08lx\n", pMyVRoot->m_dwSSL );
        dprintf("Metabase object 0x%p\n", pMyVRoot->m_pMB );
        dprintf("Directory path %s\n", pMyVRoot->m_szDirectory );
        dprintf("Prepare driver 0x%p\n", pMyVRoot->m_pDriverPrepare );
        dprintf("Good driver 0x%p\n", pMyVRoot->m_pDriver );
        switch( pMyVRoot->m_eLogonInfo ) {
            case CNNTPVRoot::VROOT_LOGON_DEFAULT:
                dprintf("This is a file system vroot\n");
                break;
            case CNNTPVRoot::VROOT_LOGON_UNC:
                dprintf("This is a UNC vroot\n" );
                break;
            case CNNTPVRoot::VROOT_LOGON_EX:
                dprintf("This is an exchange vroot\n" );
                break;
        }
        switch( pMyVRoot->m_eState ) {
            case CNNTPVRoot::VROOT_STATE_UNINIT:
                dprintf("Vroot not inited\n" );
                break;
            case CNNTPVRoot::VROOT_STATE_CONNECTING:
                dprintf("Vroot is connecting\n" );
                break;
            case CNNTPVRoot::VROOT_STATE_CONNECTED:
                dprintf("Vroot is connected\n" );
                break;
        }
        dprintf("VRoot Win32 Error %d\n",  pMyVRoot->m_dwWin32Error );
        dprintf("Impersonation token ( for UNC ): %d\n", pMyVRoot->m_hImpersonation );
        pMyVRoot->m_bExpire ?   dprintf("Vroot handles expire himself\n") :
                                dprintf("Protocol should help him expire\n" );
        pMyVRoot->m_lDecCompleted == 0 ?
            dprintf("Decorate newstree in progress\n") :
            dprintf("Decorate newstree completed\n" );
#ifdef DEBUG
        dprintf("Next vroot in debug list 0x%p\n",
                CONTAINING_RECORD(  pMyVRoot->m_DebugList.Flink,
                                    CVRoot,
                                    m_DebugList ) );
#endif
    } else {

        dprintf("Vroot signature bad\n" );
    }
                                
	dprintf("\n======== End virtual root object =========\n");

DbgPrintVRoot_Exit:

	DbgFreeEx( pDestVRoot );

	return pVRootRet;
}

void
DbgPrintVRootTable(
    CNNTPVRootTable * pVRTable
    )
/*++

Routine Description:
	
	Dump the vroot table object at pVRTable
	NOTE: Assumed that the pointer passed in is in the debuggee's address space
	      ie. we need to allocate memory and copy the data over into our address space !

Arguments:

Returns:

	The next newsgroup pointer

--*/
{
    CNNTPVRootTable  *pDestVRTable, *pMyVRTable;
	DWORD       cbVRTable;
	CHAR        szVRootPath[MAX_VROOT_PATH];

	//	
	//	Allocate memory in our address space so we can read data from the debuggee's address space
	//
	
	cbVRTable = sizeof(CNNTPVRootTable);
	pDestVRTable = (CNNTPVRootTable*) DbgAlloc( cbVRTable );

	if( !pDestVRTable )
	{
        dprintf( "nntpdbg: Unable to allocate memory \n");
        return ;
	}

	if( !ReadMemory( pVRTable, pDestVRTable, cbVRTable, NULL ) )
	{
		dprintf("Could not get data at 0x%x\n", pVRTable );
		goto DbgPrintVRootTable_Exit;
	}

	// Now, we can use pMyVRTable to access the members of the CNNTPVRoot object
	pMyVRTable = pDestVRTable;

	//
	//	Dump the vroot object
	//
	
	dprintf("\n\n======== Begin virtual root table object =========\n\n");

#ifdef DEBUG

    if ( IsListEmpty( &pMyVRTable->impl.m_DebugListHead ) ) {
        dprintf("Debug list is empty\n");
    } else {
        dprintf("First vroot in debug list 0x%p\n", 
                CONTAINING_RECORD(  pMyVRTable->impl.m_DebugListHead.Flink,
                                    CVRoot,
                                    m_DebugList ) );
    }
#endif

    CopyUnicodeStringIntoAscii( szVRootPath, pMyVRTable->impl.m_wszRootPath );
    dprintf("VRoot path is %s\n", szVRootPath );
    pMyVRTable->impl.m_fInit ? dprintf("We have been initialized\n") :
                          dprintf("We are not initialized\n" );
    pMyVRTable->impl.m_fShuttingDown ?   dprintf("We are shutting down\n") :
                                    dprintf("We are not shutting down\n" );
    if ( pMyVRTable->impl.m_listVRoots.IsEmpty() ) {
        dprintf("Table is empty\n" );
    } else {
        dprintf("The first vroot on table is 0x%p\n", 
                pMyVRTable->impl.m_listVRoots.m_pHead );
    }
    dprintf("Owning instance wrapper 0x%p\n", pMyVRTable->m_pInstWrapper );

                                
	dprintf("\n======== End virtual root table object =========\n");

DbgPrintVRootTable_Exit:

	DbgFreeEx( pDestVRTable );
}

VOID
DbgDumpPool(
	CSmtpClientPool* pSCPool
	)
/*++

Routine Description:
	
	Dump the smtp cached conx
	NOTE: Assumed that the pointer passed is in OUR address space

--*/
{
	DWORD cSlots = pSCPool->m_cSlots;
	DWORD i;
	BOOL* rgAvailList = NULL;
	CSmtpClient** rgppSCList = NULL;

	dprintf("\n======== Begin CSmtpClientPool dump =========\n\n");

	dprintf("Number of slots is %d\n", cSlots);

	DWORD cbAvailList = sizeof(BOOL)*cSlots;
	DWORD cbSCList = sizeof(CSmtpClient*)*cSlots;

	rgAvailList = (BOOL*)DbgAlloc( cbAvailList );
	if( !rgAvailList || !ReadMemory( pSCPool->m_rgAvailList, rgAvailList, cbAvailList, NULL) )
	{
		dprintf("Failed to allocate or read memory\n");
		goto DbgDumpPool_Exit;
	}

	rgppSCList  = (CSmtpClient**)DbgAlloc( cbSCList );
	if( !rgppSCList || !ReadMemory( pSCPool->m_rgpSCList, rgppSCList, cbSCList, NULL) )
	{
		dprintf("Failed to allocate or read memory\n");
		goto DbgDumpPool_Exit;
	}

	// Dump the conx object pointers and avail status
	for(i=0; i<cSlots; i++)
	{
		dprintf("Smtp conx object %d is 0x%p\n", i+1, rgppSCList [i]);
		dprintf("Avail status is %d\n", rgAvailList [i]);
	}

	dprintf("\n======== End   CSmtpClientPool dump =========\n");

DbgDumpPool_Exit:

	DbgFreeEx( rgAvailList );
	DbgFreeEx( rgppSCList );
}

VOID
DbgDumpFeedBlock(
	PFEED_BLOCK feedBlock
	)
/*++

Routine Description:
	
	Dump the feedBlock passed in; validate signature
	NOTE: Assumed that the pointer passed in is in the debuggee's address space
	      ie. we need to allocate memory and copy the data over into our address space !

Arguments:

Returns:

--*/
{
	FEED_BLOCK	feed;

	// read memory from debuggee's address space
	move( feed, feedBlock );

	// validate signature
	if( FEED_BLOCK_SIGN != feed.Signature )
	{
		dprintf("Invalid Feed block signature Expected: 0x%08lx Got: 0x%08lx \n", FEED_BLOCK_SIGN, feed.Signature );
		return;
	}

	// ok, dump the feed block
	dprintf("============ Begin feed block dump =============== \n");

    dprintf("Number of feeds done so far is %d\n", feed.NumberOfFeeds);
	dprintf("Number of failed connection attempts for Push feeds is %d\n", feed.cFailedAttempts);
    dprintf("The last newsgroup spec Pulled is %d\n", feed.LastNewsgroupPulled);
    dprintf("Resolved IP address is %d\n", feed.IPAddress);
    dprintf("feedblock ListEntry Flink is 0x%p\n", feed.ListEntry.Flink);
    dprintf("feedblock ListEntry Blink is 0x%p\n", feed.ListEntry.Blink);
	dprintf("feed is in progress ? %d\n", feed.FeedsInProgress);
    dprintf("Count of references to this block is %d\n", feed.ReferenceCount);
    dprintf("Current State of this block is %d\n", feed.State);
	dprintf("Should we delete this block when the references reach 0 ? %d\n", feed.MarkedForDelete);
	dprintf("Pointer to a FEED_BLOCK that we are replaced by is 0x%p\n", feed.ReplacedBy);
	dprintf("Pointer to a FEED_BLOCK we replace is 0x%p\n", feed.Replaces);
    dprintf("Type of this feed (push/pull/passive) is %d\n", feed.FeedType);

    //dprintf("Name of reg key this feed info is stored under 0x%p\n", feed.KeyName);

	dprintf("The Queue used to record outgoing articles for this ACTIVE outgoing feed is 0x%p\n", feed.pFeedQueue);
    dprintf("Unique id for this feed block is %d\n", feed.FeedId);
    dprintf("Should we autocreate directories?  %d\n", feed.AutoCreate);
    dprintf("Minutes between feeds is %d\n", feed.FeedIntervalMinutes);

    dprintf("Pull Request Time is");
	PrintSystemTime( &feed.PullRequestTime );

	FILETIME ft;

    dprintf("Start Time is");
	FILETIME_FROM_LI( &ft, &feed.StartTime );
	PrintSystemTime( &ft );

    dprintf("Next Active Time is");
	FILETIME_FROM_LI( &ft, &feed.NextActiveTime);
	PrintSystemTime( &ft );

	PrintString("Name of the feed server is %s\n", feed.ServerName);
	dprintf("Newsgroups to pull is 0x%p\n", feed.Newsgroups);
	dprintf("Distributions is 0x%p\n", feed.Distribution);

	dprintf("Flag indicating whether the feed is currently 'enabled' is %d\n", feed.fEnabled);

	//PrintString("The name to be used in Path processing is %s\n", feed.UucpName);
	PrintString("The directory where we are to store our temp files is %s\n", feed.FeedTempDirectory);

	dprintf("Maximum number of consecutive failed connect attempts before\n");
	dprintf("we disable the feed is %d\n", feed.MaxConnectAttempts);
	dprintf("Number of sessions to create for outbound feeds is %d\n", feed.ConcurrentSessions);
	dprintf("Type of security to have is %d\n", feed.SessionSecurityType);
	dprintf("Authentication security is %d\n", feed.AuthenticationSecurity);

	PrintString("User Account for clear text logons is %s\n", feed.NntpAccount);
	PrintString("User Password for clear text logons is %s\n", feed.NntpPassword);

	dprintf("Allow control messages on this feed ? %d\n", feed.fAllowControlMessages);

	dprintf("============ End    feed block dump =============== \n");
}

VOID
DbgDumpFeedList(
	CFeedList* pSrcFeedList,
	CFeedList* pDstFeedList
	)
/*--
	Arguments:

		pSrcFeedList	-	pointer in debuggee's address space
		pDstFeedList	-	pointer in OUR address space

--*/
{
	LIST_ENTRY  Entry;
	PLIST_ENTRY listEntry;
	PLIST_ENTRY	SrclistEntry =	(pDstFeedList->m_ListHead).Flink ;
	listEntry = SrclistEntry;

	DWORD offset = (DWORD)((DWORD_PTR)&((CFeedList*)0)->m_ListHead);
	PLIST_ENTRY listEnd = (PLIST_ENTRY)((LPBYTE)pSrcFeedList+offset);

	//dprintf("offset is %d listEnd is 0x%p\n", offset, listEnd);
	
	while( listEntry != listEnd ) {

		PFEED_BLOCK	feedBlock = CONTAINING_RECORD(	listEntry, 
													FEED_BLOCK,
													ListEntry );

		DbgDumpFeedBlock( feedBlock );

		SrclistEntry = listEntry;
		move( Entry, SrclistEntry );

		listEntry = Entry.Flink ;
	}
}

VOID
DbgDumpCPool(CPool* pCPool, DWORD dwSignature, LPCSTR szSymbol)
{

    CPool* pPool = (CPool*)DbgAlloc( sizeof(CPool));

    if ( pCPool && pPool )
    {
        if ( ReadMemory( (LPVOID) pCPool,
                         pPool,
                         sizeof(CPool),
                         NULL ))
        {
            dprintf( "%s at 0x%8lx, signature is 0x%.8x\n",
            	(szSymbol?szSymbol:"CPool"),
            	pCPool, pPool->m_dwSignature);

            if( dwSignature != 0 && dwSignature != pPool->m_dwSignature ) {
                dprintf(" *** signature mismatch\n" );
            }

            dprintf(" m_cMaxInstances = %d\n", pPool->m_cMaxInstances );
            dprintf(" m_cInstanceSize = %d\n", pPool->m_cInstanceSize );
            dprintf(" m_cNumberCommitted = %d\n", pPool->m_cNumberCommitted );
            dprintf(" m_cNumberInUse = %d\n", pPool->m_cNumberInUse );
            dprintf(" m_cNumberAvail = %d\n", pPool->m_cNumberAvail );
            dprintf(" m_cFragmentInstances = %d\n", pPool->m_cFragmentInstances );
            dprintf(" m_cFragments = %d\n", pPool->m_cFragments );
            dprintf(" Fragments:\n");
            for(int i=0; i<MAX_CPOOL_FRAGMENTS; i++) {
	    	    dprintf("  %p%s", pPool->m_pFragments[i], ((i+1)%4)==0?"\n":"" );
	    	}
			dprintf("=========================\n");
        }
        DbgFree( (PVOID)pPool );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\nntp\server\nntpdbg\makefile.inc ===
$(O)\nntpdrv.h $(O)\nntpdrv_i.c : $(STAXINC)\export\nntpdrv.idl
    $(MIDL) \
    $(PACKING) \
    $(INCPATH0) \
    -char unsigned \
    -ms_ext -c_ext \
    -proxy $(PASS0_SOURCEDIR)\nntpdrv_p.c \
    -dlldata $(PASS0_SOURCEDIR)\dlldata.c \
    -iid $(MIDL_UUIDDIR)\nntpdrv_i.c \
    -header $@ \
    -tlb $(O)\nntpdrv.tlb \
    -cpp_cmd $(TARGET_CPP) \
    $(C_DEFINES) \
    $(MIDL_FLAGS) \
    $(MIDL_OPTIMIZATION) \
    $**

$(O)\nntpsvc.h $(O)\nntpsvc_s.c : $(STAXNNTP)\nntpsvc.idl
    $(MIDL) \
    $(PACKING) \
    $(INCPATH0) \
    -char unsigned \
    -ms_ext -c_ext \
    -oldnames \
    -client none \
    -sstub $(O)\nntpsvc_s.c \
    -header $@ \
    -tlb $(O)\nntpsvc.tlb \
    -cpp_cmd $(TARGET_CPP) \
    $(C_DEFINES) \
    $(MIDL_FLAGS) \
    $(MIDL_OPTIMIZATION) \
    $**

$(O)\seo.h $(O)\seo_i.c : $(STAXINC)\export\seo.idl
    $(MIDL) \
    $(PACKING) \
    $(INCPATH0) \
    -char unsigned \
    -ms_ext -c_ext \
    -proxy $(PASS0_SOURCEDIR)\seo_p.c \
    -dlldata $(PASS0_SOURCEDIR)\dlldata.c \
    -iid $(MIDL_UUIDDIR)\seo_i.c \
    -header $@ \
    -tlb $(O)\seo.tlb \
    -cpp_cmd $(TARGET_CPP) \
    $(C_DEFINES) \
    $(MIDL_FLAGS) \
    $(MIDL_OPTIMIZATION) \
    $**

$(O)\nntpfilt.h $(O)\nntpfilt_i.c : $(STAXNNTP)\core\include\nntpfilt.idl
    $(MIDL) \
    $(PACKING) \
    $(INCPATH0) \
    -char unsigned \
    -ms_ext -c_ext \
    -proxy $(PASS0_SOURCEDIR)\nntpfilt_p.c \
    -dlldata $(PASS0_SOURCEDIR)\dlldata.c \
    -iid $(MIDL_UUIDDIR)\nntpfilt_i.c \
    -header $@ \
    -tlb $(O)\nntpfilt.tlb \
    -cpp_cmd $(TARGET_CPP) \
    $(C_DEFINES) \
    $(MIDL_FLAGS) \
    $(MIDL_OPTIMIZATION) \
    $**

$(O)\mailmsg.h $(O)\mailmsg_i.c : $(STAXINC)\export\mailmsg.idl
    $(MIDL) \
    $(PACKING) \
    $(INCPATH0) \
    -char unsigned \
    -ms_ext -c_ext \
    -proxy $(PASS0_SOURCEDIR)\mailmsg_p.c \
    -dlldata $(PASS0_SOURCEDIR)\dlldata.c \
    -iid $(MIDL_UUIDDIR)\mailmsg_i.c \
    -header $@ \
    -tlb $(O)\mailmsg.tlb \
    -cpp_cmd $(TARGET_CPP) \
    $(C_DEFINES) \
    $(MIDL_FLAGS) \
    $(MIDL_OPTIMIZATION) \
    $**

$(O)\nntpmsg.h $(O)\nntpmsg.rc $(O)\msg00001.bin: ..\server\nntpmsg.mc ..\..\..\..\inc\inetamsg.mc
    copy /a ..\..\..\..\inc\inetamsg.mc + /a ..\server\nntpmsg.mc $(O)\tmp.mc
    mc -v -r $(O) -h $(O) $(O)\tmp.mc
    copy $(O)\tmp.h $(O)\nntpmsg.h
    del $(O)\tmp.h
    copy $(O)\tmp.rc $(O)\nntpmsg.rc
    del  $(O)\tmp.rc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\nntp\server\post\src\article.cpp ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    article.cpp

Abstract:

    This module contains definition for the CArticle base class.

	This class provides basic, general tools to parse and edit a
	Netnews articles.

	The basic idea is to map the files containing the articles and
	then to record the location of parts of the articles with CPCStrings.
	A CPCString is just a pointer (usually into the mapped file) and a length.

Author:

    Carl Kadie (CarlK)     06-Oct-1995

Revision History:

--*/

#ifdef	_NO_TEMPLATES_
#define	DEFINE_CGROUPLST_FUNCTIONS
#endif

#include    <stdlib.h>
#include	"stdinc.h"
//#include "smtpdll.h"

//
// Some function prototypes
//

BOOL
CArticle::InitClass(
					void
					)
/*++

Routine Description:

    Preallocates memory for CArticle objects

Arguments:

    None.

Return Value:

    TRUE, if successful. FALSE, otherwise.

--*/
{
	return	gArticlePool.ReserveMemory( MAX_ARTICLES, cbMAX_ARTICLE_SIZE ) ;	
}


BOOL
CArticle::TermClass(
					void
					)
/*++

Routine Description:

    Called when objects are freed.

Arguments:

    None.

Return Value:

    TRUE

--*/
{

	_ASSERT( gArticlePool.GetAllocCount() == 0 ) ;
	return	gArticlePool.ReleaseMemory() ;

}


CArticle::CArticle(
                void
                ):
/*++

Routine Description:

    Class Constructor. Does nothing except initial member variables.

Arguments:

    None.

Return Value:

    TRUE

--*/m_pInstance( NULL )/*
	m_hFile(INVALID_HANDLE_VALUE),
	m_pOpenFile( 0 ),
	m_pInstance( NULL ),
	m_cHeaders(0),
	m_articleState(asUninitialized),
	m_pHeaderBuffer( 0 ),
	m_pMapFile( 0 )*/
{
   m_szFilename = 0 ;
   numArticle++;

} // CArticle

	
	
CArticle::~CArticle(
                    void
                    )
/*++

Routine Description:

    Class destructor

Arguments:

    None.

Return Value:

    None

--*/
{
	//
	// If file handle is open, close it, make sure 
	// if we have done this, our base class's destructor
	// doesn't do it 
	//

	if( m_hFile != INVALID_HANDLE_VALUE )
	{
		BOOL	fSuccess = ArtCloseHandle( 
												m_hFile
												) ;
        _ASSERT( fSuccess ) ;
        m_hFile = INVALID_HANDLE_VALUE;
	}
}

extern       MAIL_FROM_SWITCH        mfMailFromHeader;

BOOL	
CArticle::fMailArticle(
			LPSTR	lpModerator
			//class	CSecurityCtx*	pSecurity,
			//BOOL	fIsSecure	
			)	{
/*++

Routine Description : 

	Pass the article to a mail provider.
	The CArticle object may reside only in memory, or we may have
	a file containing the article available.

Arguments : 

	pSecurity - The client's security context
	fIsSecure - TRUE if the client is using a secure (SSL?) session

Return Value : 

	TRUE if successfull !

--*/

    char  szSmtpAddress [MAX_PATH+1];
    DWORD cbAddressSize = MAX_PATH;
	LPSTR lpFrom = NULL;
	DWORD cbLen = 0;
	BOOL  fRet = TRUE;

    m_pInstance->GetSmtpAddress(szSmtpAddress, &cbAddressSize);
	LPSTR lpTempDirectory = m_pInstance->PeerTempDirectory();

	// construct mail message from header if required
	if( mfMailFromHeader == mfAdmin )
	{
		lpFrom = m_pInstance->QueryAdminEmail();
		cbLen  = m_pInstance->QueryAdminEmailLen()-1;	// len includes terminating null
	} else if( mfMailFromHeader == mfArticle ) {
		fGetHeader((char*)szKwFrom,(LPBYTE)lpFrom, 0, cbLen);
		if( cbLen ) {
			lpFrom = pAllocator()->Alloc(cbLen+1);
			if(lpFrom == NULL || !fGetHeader((char*)szKwFrom,(LPBYTE)lpFrom, cbLen+1, cbLen)) {
				pAllocator()->Free(lpFrom);
				lpFrom = NULL;
				cbLen = 0;
			} else {
				//
				//	TODO: Need to call into Keith's smtpaddr lib to clean up this header
				//	Some SMTP server's would have a problem with quotes in the from: hdr
				//
				cbLen -= 2;
			}
		}
	}

	_ASSERT( (lpFrom && cbLen) || (!lpFrom && !cbLen) );

	if( fIsArticleCached() ) {

		// NOTE: fPostArticleEx takes both file and memory info for an article
		// If the file info is valid, memory is not and vice versa
		if( m_pHeaderBuffer ) {

			fRet =	fPostArticleEx(	INVALID_HANDLE_VALUE,	// file handle
									NULL,					// filename
									0,						// file offset
									0,						// article length in file
									m_pcHeader.m_pch,		// header
									m_pcHeader.m_cch,		// header size
									m_pcBody.m_pch,			// body
									m_pcBody.m_cch,			// body size
									lpModerator,			// moderator
									szSmtpAddress,			// SMTP server
									cbAddressSize,			// sizeof server
									lpTempDirectory,		// temp dir
									lpFrom,					// mail envelope from hdr
									cbLen					// from hdr len
									//pSecurity,
									//fIsSecure
									) ;
		}	else	{

			fRet =	fPostArticleEx(	INVALID_HANDLE_VALUE,	// file handle
									NULL,					// filename
									0,						// file offset
									0,						// article length in file
									m_pcArticle.m_pch,		// article
									m_pcArticle.m_cch,		// article size
									0,						// body
									0,						// body size
									lpModerator,			// moderator
									szSmtpAddress,			// SMTP server
									cbAddressSize,			// sizeof server
									lpTempDirectory,		// temp dir
									lpFrom,					// mail envelope from hdr
									cbLen					// from hdr len
									//pSecurity,
									//fIsSecure
									) ;
		}
		
	}	else	{

		HANDLE hFile = INVALID_HANDLE_VALUE;
		DWORD  dwOffset = 0;
		DWORD  dwLength = 0;

		BOOL fWhole = fWholeArticle(hFile, dwOffset, dwLength);
		_ASSERT( fWhole );

		fRet =	fPostArticleEx(	hFile,				// file handle
								m_szFilename,		// filename
								dwOffset,			// file offset
								dwLength,			// article length in file
								0,					// header - not valid
								0,					// size - not valid
								0,					// body - not valid
								0,					// body size - not valid
								lpModerator,		// moderator
								szSmtpAddress,		// SMTP server
								cbAddressSize,		// sizeof server
								lpTempDirectory,	// temp dir
								lpFrom,				// mail envelope from hdr
								cbLen				// from hdr len
								//pSecurity,
								//fIsSecure
								) ;
	}

	// Free from header if allocated
	if( lpFrom && (mfMailFromHeader == mfArticle) ) {
		pAllocator()->Free(lpFrom);
		lpFrom = NULL;
	}

	return	fRet ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\nntp\server\post\src\fromclnt.cpp ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    fromclnt.cpp

Abstract:

	Contains InFeed, Article, and Fields code specific to FromClient Infeeds

	As the name suggests, these for for processing articles that come from
	clients. The idea is to be very strict in what is allowed from the client.
	If an article doesn't match spec, it is either fixed or rejected.


Author:

    Carl Kadie (CarlK)     05-Dec-1995

Revision History:

--*/


#include "stdinc.h"

BOOL
CFromClientArticle::fValidate(
							CPCString& pcHub,
							const char * szCommand,
							CInFeed*	pInFeed,
							CNntpReturn & nntpReturn
							)
/*++

Routine Description:

	Validates an article from a client. Does not change the article
	except to fix (if necessary) the capitalization of some header keywords.

Arguments:

	szCommand - The arguments (if any) used to post/xreplic/etc this article.
	nntpReturn - The return value for this function call


Return Value:

	TRUE, if successful. FALSE, otherwise.

--*/
{

	//
	// Check article state
	//

	_ASSERT(asPreParsed == m_articleState);

    //
    // Check required and optional fields
    //

	CField * rgPFields [] = {
            &m_fieldControl,
			&m_fieldSubject,
			&m_fieldNewsgroups,
			&m_fieldDistribution,
			&m_fieldFrom,
			&m_fieldDate,
			&m_fieldFollowupTo,
			&m_fieldReplyTo,
			&m_fieldApproved,
			&m_fieldSender,
			&m_fieldOrganization,
			&m_fieldSummary,
			&m_fieldReferences,
			&m_fieldLines,
			&m_fieldKeyword,
			&m_fieldExpires,
			&m_fieldPath,
            &m_fieldNNTPPostingHost,
			&m_fieldMessageID	// must be last - as we may not want to parse it !
				};
	DWORD cFields = sizeof(rgPFields)/sizeof(CField *);

	if( !gHonorClientMessageIDs ) {
		cFields -- ;
	}

	if (!fFindAndParseList((CField * *) rgPFields, cFields, nntpReturn))
		return nntpReturn.fFalse();

	CPCString	pcDate = m_fieldDate.pcGet() ;
	if( pcDate.m_pch != 0 ) {

		if( !AgeCheck( pcDate ) ) {
			nntpReturn.fSet( nrcArticleDateTooOld ) ;
			return	FALSE ;
		}
	}

	LPSTR	lpstrMessageId = m_fieldMessageID.szGet() ;
	if( lpstrMessageId != 0 && *lpstrMessageId != '\0' ) {
		if (m_pInstance->ArticleTable()->SearchMapEntry(lpstrMessageId)
			|| m_pInstance->HistoryTable()->SearchMapEntry(lpstrMessageId))
		{
			nntpReturn.fSet(nrcArticleDupMessID, lpstrMessageId, GetLastError());
			return nntpReturn.fFalse();
		}
	}


	//
	// Confirm (and fix, if necessary) the capitalization of the fields
	//

	if (!fConfirmCapsList((CField * *) rgPFields, cFields, nntpReturn))
		return nntpReturn.fFalse();
//
	//!!!CLIENT LATER Not doing anything with control messages
	//

	/* !!!CLIENT LATER
	Body
	SHOULD limit signatures -- !!!LATER
	Early  difficulties in inferring return addresses from article headers led to "signatures": short closing texts,  automatically  added  to  the end of articles by posting agents, identifying the poster and giving his network addresses etc.  If  a  poster

 or posting agent does append a signature to an article, the signature SHOULD be preceded with  a  delimiter line  containing  (only)  two hyphens (ASCII 45) followed by one blank (ASCII  32).   Posting  agents  SHOULD  limit  the length  of  signatures

 since  verbose  excess bordering on abuse is common if no restraint is imposed;  4  lines  is  a common limit.

	Whole Article
	No NULL character allowed
	Header and body lines MAY contain any ASCII characters other than CR (ASCII 13), LF (ASCII 10), and NUL (ASCII 0).
	NO char > oct 127 allowed (unless co-operating)
	Articles  MUST  not  contain  any octet with value exceeding 127, i.e. any octet that is not an ASCII character.
	Limit to 60K -- LATER
	Posters SHOULD limit  posted  articles  to  at  most  60,000 octets,  including  headers  and EOL representations, unless the articles are being posted only within a cooperating sub-net which is known to be capable of handling larger articles gracefully.


  Posting agents presented with a  large  article SHOULD warn the poster and request confirmation.
	*/

	return nntpReturn.fSetOK();
}


BOOL
CFromClientArticle::fMungeHeaders(
							 CPCString& pcHub,
							 CPCString& pcDNS,
							 CNAMEREFLIST & grouplist,
							 DWORD remoteIpAddress,
							 CNntpReturn & nntpReturn,
							 PDWORD     pdwLinesOffset
			  )

/*++

Routine Description:

	Modify the headers of the article.

Arguments:

	grouplist - A list: for each newsgroup its name, and the article number in that group.
	nntpReturn - The return value for this function call


Return Value:

	TRUE, if successful. FALSE, otherwise.

--*/
{
	//
	// clear the return code object
	//

	nntpReturn.fSetClear();

	/* !!!CLIENT LATER
	Must validate encodings see From parsing
	Posting agents MUST ensure that any material  resembling  an  encoded  word (complete  with  all delimiters), in a context where encoded words may appear, really is an encoded word.

	*/

	if (!(
  			   m_fieldMessageID.fSet(*this, pcDNS, nntpReturn)
  			&& m_fieldNewsgroups.fSet(*this, nntpReturn)
  			&& m_fieldDistribution.fSet(*this, nntpReturn)
  			&& m_fieldDate.fSet(*this, nntpReturn)
  			&& m_fieldLines.fSet(*this, nntpReturn)
  			&& m_fieldOrganization.fSet(*this, nntpReturn)
  			&& m_fieldPath.fSet(*this, pcHub, nntpReturn)
			&& m_fieldXref.fSet(pcHub, grouplist, *this, m_fieldNewsgroups, nntpReturn)
			&& m_fieldNNTPPostingHost.fSet(*this, remoteIpAddress, nntpReturn)
			/* && m_fieldXAuthLoginName.fSet(*this, nntpReturn) */
			&& fDeleteEmptyHeader(nntpReturn)
			&& fSaveHeader(nntpReturn, pdwLinesOffset)
		))
		return nntpReturn.fFalse();

    //
    // if we don't need to back fill, set pdwLinesOffset to INVALID_FILE_SIZE,
    // so that the caller will know that this message doesn't need back fill of lines
    //
    if ( pdwLinesOffset && !m_fieldLines.fNeedBackFill() )
        *pdwLinesOffset = INVALID_FILE_SIZE;

	return nntpReturn.fSetOK();
}

BOOL
CFromClientArticle::fCheckBodyLength(
				 CNntpReturn & nntpReturn
				 )
/*++

Routine Description:

	Checks if the length of the body is within bounds.

Arguments:

	nntpReturn - The return value for this function call


Return Value:

	TRUE, if successful. FALSE, otherwise.

--*/
{

	//
	//!!!CLIENT NEXT need to add a real body length check here
	//

	return nntpReturn.fSetOK();
}



BOOL
CFromClientNewsgroupsField::fSet(
				   				 CFromClientArticle & article,
								 CNntpReturn & nntpReturn
								 )
/*++

Routine Description:


	Rewrites the Newsgroups line, fixing some problems such as
	extra whitespace and duplicates.


Arguments:

	article - The article being processed.
	nntpReturn - The return value for this function call


Return Value:

	TRUE, if successful. FALSE, otherwise.

--*/
{

	//
	// clear the return code object
	//

	nntpReturn.fSetClear();

	//
	// Check article state
	//

	_ASSERT(fsParsed == m_fieldState);//real

	CPCString pcLine;


	//
	// max size needed is the size of the old line
	//

	const DWORD cchMaxNewsgroups =
			(m_pHeaderString->pcLine).m_cch
			+ 2 // for the newline
			+ 1; // for a terminating null


	//
	// Allocate memory for line within a PCString.
	//

	pcLine.m_pch  = article.pAllocator()->Alloc(cchMaxNewsgroups);
	if (!pcLine.m_pch)
		return nntpReturn.fSet(nrcMemAllocationFailed, __FILE__, __LINE__);

	//
	// Start with "Newsgroups: "
	//

	pcLine << szKwNewsgroups << (char) ' ';

	//
	// Loop through the newsgroups
	//

	_ASSERT(0 < cGet());//real
	char const * szNewsgroup = multiSzGet();
	do
	{

	//
	// Start with newsgroup name, then add comma
	//

//		pcLine << szDownCase((char *)szNewsgroup, szNewsgroupBuf) << (char) ',';
		pcLine << szNewsgroup << (char) ',';

		//
		// go to first char after next null
		//

		while ('\0' != szNewsgroup[0])
			szNewsgroup++;
		szNewsgroup++;
	} while ('\0' != szNewsgroup[0]);

	//
	// Remove the last ","
	//

	pcLine.vSkipEnd(1);

	pcLine	<< "\r\n";
	pcLine.vMakeSz(); // terminate the string

	//
	// confirm that we allocated enough memory
	//

	_ASSERT(cchMaxNewsgroups-1 >= pcLine.m_cch);//real

	if (!(
  		article.fRemoveAny(szKwNewsgroups, nntpReturn)
		&& article.fAdd(pcLine.sz(), pcLine.pchMax(), nntpReturn)
		))
	{
		//
		// If anything went wrong, free the memory.
		//

		article.pAllocator()->Free(pcLine.m_pch);
		return nntpReturn.fFalse();
	}

	return nntpReturn.fSetOK();
}


BOOL
CFromClientDistributionField::fSet(
				   				 CFromClientArticle & article,
								 CNntpReturn & nntpReturn
								 )
/*++

Routine Description:


	Rewrites the Distribution line, fixing some problems such as
	extra whitespace and duplicates.


Arguments:

	article - The article being processed.
	nntpReturn - The return value for this function call


Return Value:

	TRUE, if successful. FALSE, otherwise.

--*/
{

	//
	// clear the return code object
	//

	nntpReturn.fSetClear();

	//
	// If it was not found exists, then just return
	//

	if (fsNotFound == m_fieldState)
		return nntpReturn.fSetOK();


	//
	// Otherwise, fix up what was found.
	//

	//
	// Check article state
	//

	_ASSERT(fsParsed == m_fieldState);//real

	CPCString pcLine;


	//
	// max size needed is the size of the old line
	//

	const DWORD cchMaxDistribution =
			(m_pHeaderString->pcLine).m_cch
			+ 2 // for the newline
			+ 1; // for a terminating null


	//
	// Allocate memory for line within a PCString.
	//

	pcLine.m_pch  = article.pAllocator()->Alloc(cchMaxDistribution);
	if (!pcLine.m_pch)
		return nntpReturn.fSet(nrcMemAllocationFailed, __FILE__, __LINE__);

	//
	// Start with "Distribution: "
	//

	pcLine << szKwDistribution << (char) ' ';

	//
	// Loop through the Distribution
	//

	_ASSERT(0 <= (int)cGet());//real
	char const * szDistributrionValue = multiSzGet();
	do
	{

	//
	// Start with distribution value and add comma
	//

//		pcLine << szDownCase((char *)szDistributrionValue, szDistributrionValueBuf) << ',';
		pcLine << szDistributrionValue << (char) ',';

		//
		// go to first char after next null
		//

		while ('\0' != szDistributrionValue[0])
			szDistributrionValue++;
		szDistributrionValue++;
	} while ('\0' != szDistributrionValue[0]);

	//
	// Remove the last ","
	//

	pcLine.vSkipEnd(1);

	pcLine	<< "\r\n";
	pcLine.vMakeSz(); // terminate the string

	//
	// confirm that we allocated enough memory
	//

	_ASSERT(cchMaxDistribution-1 >= pcLine.m_cch);//real

	if (!(
  		article.fRemoveAny(szKwDistribution, nntpReturn)
		&& article.fAdd(pcLine.sz(), pcLine.pchMax(), nntpReturn)
		))
	{
		//
		// If anything went wrong, free the memory.
		//

		article.pAllocator()->Free(pcLine.m_pch);
		return nntpReturn.fFalse();
	}

	return nntpReturn.fSetOK();
}



BOOL
CFromClientDateField::fSet(
				   				 CFromClientArticle & article,
								 CNntpReturn & nntpReturn
								 )
/*++

Routine Description:


	If the date field is missing, adds it.


Arguments:

	article - The article being processed.
	nntpReturn - The return value for this function call


Return Value:

	TRUE, if successful. FALSE, otherwise.

--*/
{

	//
	// clear the return code object
	//

	nntpReturn.fSetClear();

	//
	// Check article state
	//
	//
	// If it already exists, then just return
	//

	if (fsParsed == m_fieldState && gHonorClientDateHeader)
		return nntpReturn.fSetOK();


	//
	// Otherwise, add it.
	//

	_ASSERT(fsNotFound == m_fieldState || !gHonorClientDateHeader);//real
	CPCString pcLine;

	//
	// max size needed is
	//

	const DWORD cchMaxDate =
			STRLEN(szKwDate)	// for the Date keyword
			+ 1					// space following the keyword
			+ cMaxArpaDate		// bound on the data string
			+ 2 // for the newline
			+ 1; // for a terminating null

	//
	// Allocate memory for line within a PCString.
	//

	pcLine.m_pch  = article.pAllocator()->Alloc(cchMaxDate);
	if (!pcLine.m_pch)
		return nntpReturn.fSet(nrcMemAllocationFailed, __FILE__, __LINE__);

	char szDateBuf[cMaxArpaDate];

	//
	// Start with "Date: ", then add the date and the newline
	//

	pcLine << szKwDate << (char) ' ' << (GetArpaDate(szDateBuf)) << "\r\n";
	pcLine.vMakeSz(); // terminate the string

	//
	// confirm that we allocated enough memory
	//

	_ASSERT(cchMaxDate-1 >= pcLine.m_cch);//real

	if (!(
		article.fRemoveAny(szKwDate, nntpReturn)
		&& article.fAdd(pcLine.sz(), pcLine.pchMax(), nntpReturn)
		))
	{
		//
		// If anything went wrong, free the memory.
		//

		article.pAllocator()->Free(pcLine.m_pch);
		return nntpReturn.fFalse();
	}

	return nntpReturn.fSetOK();
}

/*
Organization: Optional  But if not and default is given, create
The Organization header content is a short phrase  identify-ing the posters organization:
Organization-content = nonblank-text
This header is typically supplied by the posting agent.  The Organization content SHOULD  mention  geographical  location (e.g.  city  and  country)  when  it is not obvious from the organization?s name.  policy.  Posting agents SHOULD permit the poster t


o override a local default Organization header.
*/

BOOL
CFromClientOrganizationField::fSet(
   				   				 CFromClientArticle & article,
								 CNntpReturn & nntpReturn
								 )
/*++

Routine Description:


	Optional, But if not given my user and default is given, create


Arguments:

	country -


Return Value:

	TRUE, if successful. FALSE, otherwise.

--*/
{

//
//!!!CLIENT NEXT - add this code
//

	return nntpReturn.fSetOK();
}

//
//!!!constize
//

/*
Restricted Syntax
The  From header contains the electronic address, and possibly the full name, of the articles author:
From-content  = address [ space "(" paren-phrase ")" ]
/  [ plain-phrase space ] "<" address ">"
paren-phrase  = 1*( paren-char / space / encoded-word )
paren-char    = <ASCII printable character except ()<>\>
plain-phrase  = plain-word *( space plain-word )
plain-word    = unquoted-word / quoted-word / encoded-word
unquoted-word = 1*unquoted-char
unquoted-char = <ASCII printable character except !()<>@,;:\".[]>
               quoted-word   = quote 1*( quoted-char / space ) quote
               quote         = <" (ASCII 34)>
               quoted-char   = <ASCII printable character except "()<>\>
               address       = local-part "@" domain
               local-part    = unquoted-word *( "." unquoted-word )
               domain        = unquoted-word *( "." unquoted-word )

(Encoded words are described in section 4.5.)  The full name is  distinguished  from  the  electronic  address  either by enclosing the former in parentheses (making  it  resemble  a MAIL  comment, after the address) or by enclosing the latter in angle br


ackets.  The second form is  preferred.   In  the first  form, encoded words inside the full name MUST be composed  entirely  of  <paren-char>s.   In  the  second  form, encoded  words  inside the full name may not contain characters other than letters (o

f either case),  digits,  and  the characters "!", "*", "+", "-", "/", "=", and "_".  The local part is case-sensitive (except that all case counterparts of "postmaster"  are  deemed  equivalent),  the domain is case-insensitive, and all other parts of  t


he  From  content  are comments  which  MUST  be  ignored  by news software (except insofar as reading agents may wish to display  them  to  the reader).   Posters  and  posting  agents MUST restrict them-selves to this subset of the MAIL From syntax; rel


ayers  MAY accept  a  broader subset, but see the discussion in section 9.1.
Avoid "!" and "@" in full names
Posters  and  posting agents SHOULD avoid use of the characters "!" and "@" in full names, as they may trigger unwanted header rewriting by old, simple-minded news software.
"." and "," must be quoted
NOTE: Also, the characters "." and ",", not infrequently found in names (e.g., "John  W.  Campbell, Jr."), are NOT, repeat NOT, allowed in an unquoted word.  A From header like the following  MUST  not be written without the quotation marks:
                    From:	"John W. Campbell, Jr." <editor@analog.com>

*/
/*
 Three permissible forms documented in RFC 1036 should be supported.  Full names within this header line can only contain printable ASCII (0x20 to 0x7E) except "(", ")", "<", ">".  The following characters are inadvisable: ",", ":", "@", "!", "/", "=", ";


".  Test cases include non-printable characters, empty header line (can?t be empty), missing/duplicate "@" address delimiter, multiple address, name lists (not supported), missing address, invalid address, inadvisable characters in name, etc.
 */

BOOL
CFromClientXAuthLoginNameField::fSet(
				 				 CFromClientArticle & article,
								 CNntpReturn & nntpReturn
								 )
/*++

Routine Description:


	replace with our value


Arguments:

	article - The article being processed.
	nntpReturn - The return value for this function call


Return Value:

	TRUE, if successful. FALSE, otherwise.

--*/
{
	//
	// clear the return code object
	//

	nntpReturn.fSetClear();

	//
	// Check article state
	//

	_ASSERT(fsInitialized == m_fieldState);//real
	CPCString pcLine;


	//
	// max size needed is
	//

	const DWORD cchMaxXAuthLoginName =
			STRLEN(szKwXAuthLoginName)	// for the XAuthLoginName keyword
			+ 1					// space following the keyword
			+ cMaxLoginName		// bound on the data string
			+ 2 // for the newline
			+ 1; // for a terminating null

	//
	// Allocate memory for line within a PCString.
	//

	pcLine.m_pch  = article.pAllocator()->Alloc(cchMaxXAuthLoginName);
	if (!pcLine.m_pch)
		return nntpReturn.fSet(nrcMemAllocationFailed, __FILE__, __LINE__);

	//
	// Start with "XAuthLoginName: "
	//

	wsprintf(pcLine.m_pch, "%s ", szKwXAuthLoginName);
	pcLine.m_cch = STRLEN(szKwXAuthLoginName)	+ 1;

	//
	// Add the data value and newline
	//

	pcLine << (article.m_szLoginName) << "\r\n";
	pcLine.vMakeSz(); // Terminate the string

	//
	// confirm that we allocated enough memory
	//

	_ASSERT(cchMaxXAuthLoginName-1 >= pcLine.m_cch);//real

	if (!(
  		article.fRemoveAny(szKwXAuthLoginName, nntpReturn)
		&& article.fAdd(pcLine.sz(), pcLine.pchMax(), nntpReturn)
		))
	{
		//
		// If anything went wrong, free the memory.
		//

		article.m_pAllocator->Free(pcLine.m_pch);

		return nntpReturn.fFalse();
	}


	return nntpReturn.fSetOK();
}






//
//!!!CLIENT NEXT: In Newsgroups: parse need to check for illegal groups like "control" and "poster"
//

/*
Followup-To: Optional
Email address is not allowed. Like newsgroups line or "poster" (capitalization?)
NOTE: The way to request that followups be  mailed to  a specific address other than that in the From line is  to  supply  "Followup-To: poster"  and  a Reply-To header.  Putting a mailing address in the Followup-To  line  is  incorrect;  posting  agent

should reject or rewrite such headers.
*/
/*
Reply-To: Optional
Must be a valid email address
*/

/*

//
///!!!CLIENT NEXT should Hubname be lower case?
///!!!CLIENT NEXT should Hubname be the domain name (for message id?)
//

/*
Message-ID: Replace any with own
How to create a messageid
5.3. Message-ID
The  Message-ID  header contains the articles message ID, a unique identifier  distinguishing  the  article  from  every other article:
Message-ID-content  = message-id
message-id          = "<" local-part "@" domain ">"
As  with  From addresses, a message IDs local part is case-sensitive and its domain is case-insensitive.  The  "<"  and ">"  are  parts  of the message ID, not peculiarities of the Message-ID header.
NOTE: News message IDs are a restricted subset  of MAIL message IDs.  In particular, no existing news software copes properly with MAIL quoting  conventions  within  the local part, so they are forbid-den.  This is unfortunate, particularly for  X.400 gat

es on gatewaying in section 10.
The domain in the message ID SHOULD  be  the  full  Internet domain name of the posting agent?s host.  Use of the ".uucp" pseudo-domain (for hosts registered in the UUCP maps) or the ".bitnet"  pseudo-domain  (for Bitnet hosts) is permissible, but SHOUL

be avoided.
Posters and posting agents MUST generate the local part of a
message ID using an algorithm which obeys the specified syn-
tax (words separated by ".",  with  certain  characters  not
permitted)  (see  section  5.2  for  details),  and will not repeat itself (ever).  The  algorithm  SHOULD  not  generate message  IDs which differ only in case of letters.  Note the specification in section 6.5 of a recommended convention for indicatin

 subject  changes.  Otherwise the algorithm is up to the implementor.
NOTE: The crucial use of message IDs is to distinguish  circulating  articles  from  each other and from articles circulated recently.  They are  also potentially  useful  as  permanent  indexing keys, hence the requirement for permanent  uniqueness...  b


ut   indexers  cannot  absolutely  rely  on  this because the earlier RFCs  urged  it  but  did  not demand  it.  All major implementations have always generated  permanently-unique   message   IDs   by design,  but  in  some  cases this is sensitive to p


roper administration,  and  duplicates  may  have occurred by accident.
NOTE:  The most popular method of generating local parts is to use the date and time, plus  some  way of distinguishing between simultaneous postings on the same host (e.g. a process number), and  encode them  in a suitably-restricted alphabet.  An olde

but now  less-popular  alternative  is  to  use  a sequence  number,  incremented  each time the host generates a new message ID; this is workable,  but requires  careful  design  to  cope  properly with simultaneous  posting  attempts,  and  is  not  a

robust  in  the presence of crashes and other malfunctions.
NOTE: Some buggy news software  considers  message
IDs  completely case-insensitive, hence the advice
to  avoid  relying  on  case  distinctions.    The
restrictions  placed  on  the  "alphabet" of local
parts and domains in section 5.2 have  the  useful side effect of making it unnecessary to parse message IDs in complex ways to break them into  case-sensitive and case-insensitive portions.

*/
BOOL
CFromClientMessageIDField::fSet(
				 				 CFromClientArticle  & article,
								 CPCString & pcHub,
								 CNntpReturn & nntpReturn
								 )
/*++

Routine Description:


	Replaces any messageid field, with a newly created one.


  Form: <1993Jun27.0645330123.1778.343@localmachinename>

Arguments:

	article - The article being processed.
	pcHub - The name of the hub the current machine is part of.
	nntpReturn - The return value for this function call


Return Value:

	TRUE, if successful. FALSE, otherwise.

--*/
{

	//
	// clear the return code object
	//

	nntpReturn.fSetClear();

	//
	// Check article state
	//

	if( m_fieldState == fsParsed ) {
		return	nntpReturn.fSetOK() ;
	}

	CPCString pcLine;


	//
	// max size needed is
	//

	const DWORD cchMaxMessageID =
			STRLEN(szKwMessageID)	// for the MessageID keyword
			+ 1					// space following the keyword
			+ 4					// <..@>
			+ cMaxMessageIDDate // The message id date
			+ 10				// One dword
			+ pcHub.m_cch		// the hub name
			+ 2 // for the newline
			+ 1; // for a terminating null

	//
	// The message-id created (without the newlines) must be less than the max
	//

	_ASSERT(cchMaxMessageID - 2 < MAX_MSGID_LEN);

	//
	// Allocate memory for line within a PCString.
	//

	pcLine.m_pch  = article.pAllocator()->Alloc(cchMaxMessageID);
	if (!pcLine.m_pch)
		return nntpReturn.fSet(nrcMemAllocationFailed, __FILE__, __LINE__);

	//
	// Start with "MessageID: <"
	//

	wsprintf(pcLine.m_pch, "%s <", szKwMessageID);
	pcLine.m_cch = STRLEN(szKwMessageID)	+ 2;

	char szMessageIDBuf[cMaxMessageIDDate];

	CArticleRef artRef = article.articleRef();

	pcLine
			//
			// Add the local part
			//
			<< (GetMessageIDDate( artRef.m_groupId, artRef.m_articleId, szMessageIDBuf))
			<< (char) '.'
			<< (const DWORD) (GetCurrentThreadId())
			//
			// Add '@' and domain and '>' and newline
			//
			<< (char) '@'
			<< pcHub ///!!!CLIENT NEXT I need the local machine rather than the hub
			<< ">\r\n";
	pcLine.vMakeSz(); // terminate the string

	//
	// confirm that we allocated enough memory
	//

	//_ASSERT(cchMaxMessageID-1-STRLEN(szKwMessageID)-1 >= pcLine.m_cch);//real
	_ASSERT(cchMaxMessageID >= pcLine.m_cch+1);//real

	if (!(
  		article.fRemoveAny(szKwMessageID, nntpReturn)//!!!CLIENT NEXT -- this really only needs to be called of state is parsed
		&& article.fAdd(pcLine.sz(), pcLine.pchMax(), nntpReturn)
		))
	{
		article.pAllocator()->Free(pcLine.m_pch);
		return nntpReturn.fFalse();
	}


	//
	//Also save the value (without newlines but with room for a terminating
	//a '\0') in m_szMessageID
	//

	DWORD cchMessageID = pcLine.m_cch - 2 - STRLEN(szKwMessageID) - 1;
	strncpy(m_szMessageID, pcLine.m_pch + STRLEN(szKwMessageID)	+ 1, cchMessageID);
	m_szMessageID[cchMessageID] ='\0';
	_ASSERT('<' == m_szMessageID[0] && '>' == m_szMessageID[cchMessageID-1]);


	return nntpReturn.fSetOK();
}


BOOL
CFromClientPathField::fSet(
						   CFromClientArticle & article,
						   CPCString & pcHub,
						   CNntpReturn & nntpReturn
						   )
/*++

Routine Description:


	Replaces any existing Path header with a newly created one that
	contains only the name of the hub.


Arguments:

	article - The article being processed.
	pcHub - The name of the hub the current machine is part of.
	nntpReturn - The return value for this function call


Return Value:

	TRUE, if successful. FALSE, otherwise.

--*/
{
	//
	// clear the return code object
	//

	nntpReturn.fSetClear();

	//
	// Check article state
	//

	_ASSERT(fsInitialized != m_fieldState);//real

	CPCString pcLine;


	//
	// max size needed is
	//

	DWORD	cbOldPath = 0 ;
	if( m_pHeaderString && m_pHeaderString->pcValue.m_pch ) {
		cbOldPath = m_pHeaderString->pcValue.m_cch + 1 ;	//include 1 for extra '!'
	}

	const DWORD cchMaxPath =
			STRLEN(szKwPath)	// for the Path keyword
			+ 1					// space following the keyword
			+ pcHub.m_cch		// the hub name
			+ 2 // for the newline
			+ cbOldPath // in case there already is a path header !
			+ 1; // for a terminating null

	//
	// Allocate memory for line within a PCString.
	//

	pcLine.m_pch  = article.pAllocator()->Alloc(cchMaxPath);
	if (!pcLine.m_pch)
		return nntpReturn.fSet(nrcMemAllocationFailed, __FILE__, __LINE__);

	//
	// Start with "Path: <hubname>"
	//

	pcLine << szKwPath << (char) ' ' << pcHub ;		//	<< "\r\n";

	if( m_pHeaderString && m_pHeaderString->pcValue.m_pch ) {
		_ASSERT( m_pHeaderString->pcValue.m_cch != 0 ) ;
		pcLine << "!" << (m_pHeaderString->pcValue) ;
	}

	pcLine << "\r\n" ;

	pcLine.vMakeSz();

	//
	// confirm that we allocated enough memory
	//

	_ASSERT(cchMaxPath-1 == pcLine.m_cch);//real

	if (!(
  		article.fRemoveAny(szKwPath, nntpReturn)//!!!CLIENT NEXT -- this really only needs to be called of state is parsed
		&& article.fAdd(pcLine.sz(), pcLine.pchMax(), nntpReturn)
		))
	{
		//
		// If anything went wrong, free the memory.
		//

		article.pAllocator()->Free(pcLine.m_pch);

		return nntpReturn.fFalse();
	}

	return nntpReturn.fSetOK();
}


BOOL
CFromClientNNTPPostingHostField::fSet(
									  CFromClientArticle & article,
									  DWORD remoteIpAddress,
									  CNntpReturn & nntpReturn
									  )
/*++

Routine Description:

	Behavior is governed by global set by a reg key.
	In any case, this removes any old NNTPPostingHost headers.

	If global is set, a new NNTP-Posting-Host header is added
	else no new header is added. default behavior is to NOT add
	this header.

Arguments:

	article - The article being processed.
	remoteIpAddress - client IP address
	nntpReturn - The return value for this function call



Return Value:

	TRUE, if successful. FALSE, otherwise.

--*/
{
	//
	// clear the return code object
	//

	nntpReturn.fSetClear();

	//
	// Check article state - article validation should have rejected this
    // post if this header was present.
	//

	_ASSERT(fsNotFound == m_fieldState);//real

	//
	//	generate header only if reg key is set
	//	if an error occurs, revert to default behavior
	//
	while ( gEnableNntpPostingHost ) {

		IN_ADDR remoteAddr;
		char szIpAddress [16];
		DWORD cbIpAddr = 0;
		struct hostent* pRemoteHost = NULL;
		DWORD cbRemoteHost = 0;

        // Convert IP to dotted decimal format
        _ASSERT( sizeof(remoteAddr) == sizeof(remoteIpAddress) );
        CopyMemory( (LPVOID)&remoteAddr, (LPVOID)&remoteIpAddress, sizeof(remoteIpAddress) );
	    DWORD dwError = InetNtoa( remoteAddr, szIpAddress);
		_ASSERT( dwError == NO_ERROR);  // since we had given sufficient buffer
		cbIpAddr = lstrlen( szIpAddress );

		//
		// Do a reverse DNS lookup on client IP
		//

		pRemoteHost = gethostbyaddr( (const char FAR*) &remoteIpAddress, sizeof( remoteIpAddress), PF_INET );
		if( pRemoteHost != NULL ) {
			cbRemoteHost = lstrlen( pRemoteHost->h_name ) + 1;
		}

		// calculate length of header
		DWORD cchMaxHost =
				STRLEN(szKwNNTPPostingHost)	// for the NNTPPostingHost keyword
				+ 1							// space following the keyword
				+ cbRemoteHost				// the reverse DNS name followed by space
//				+ 2							// enclosing []
				+ cbIpAddr					// dotted-decimal IP address
				+ 2							// for the newline
				+ 1;						// for a terminating null

		CPCString pcLine;

		//
		// Allocate memory for line within a PCString.
		//

		pcLine.m_pch  = article.pAllocator()->Alloc( cchMaxHost );
		if (!pcLine.m_pch)
			break;

		//
		// NNTP-Posting-Host: <reverse DNS lookup name> <[dotted-decimal IP address]\r\n
		//
		pcLine << szKwNNTPPostingHost << (char) ' ';
		if( pRemoteHost != NULL ) {
			pcLine << pRemoteHost->h_name << (char) ' ';
		}

		pcLine << szIpAddress << "\r\n";
		pcLine.vMakeSz();

		//
		// confirm that we allocated enough memory
		//
		_ASSERT(cchMaxHost-1 == pcLine.m_cch);

		if (!(
  			article.fRemoveAny(szKwNNTPPostingHost, nntpReturn)
			&& article.fAdd(pcLine.sz(), pcLine.pchMax(), nntpReturn)
			))
		{
			//
			// If anything went wrong, free the memory.
			//

			article.pAllocator()->Free(pcLine.m_pch);

			return nntpReturn.fFalse();
		}

		return nntpReturn.fSetOK();
	}

	//
	//	Default behavior - remove NNTP-Posting-Host header if present
	//
	return article.fRemoveAny(szKwNNTPPostingHost, nntpReturn);

}


BOOL
CFromClientDistributionField::fParse(
									 CArticleCore & article,
									 CNntpReturn & nntpReturn
									 )
/*++

Routine Description:

  Parses the Distribution field. Here is the grammer from Son of 1036:

               Newsgroups-content  = newsgroup-name *( ng-delim newsgroup-name )
               newsgroup-name      = plain-component *( "." component )
               component           = plain-component / encoded-word
               plain-component     = component-start *13component-rest
               component-start     = lowercase / digit
               lowercase           = <letter a-z>
               component-rest      = component-start / "+" / "-" / "_"
               ng-delim            = ","


Arguments:

	nntpReturn - The return value for this function call


Return Value:

	TRUE, if successful. FALSE, otherwise.

--*/
{
	//
	// clear the return code object
	//

	nntpReturn.fSetClear();

	//
	// Check article state
	//

	_ASSERT(fsFound == m_fieldState);//real

	_ASSERT(m_pHeaderString); //real


	//
	// Record the allocator
	//

	m_pAllocator = article.pAllocator();

	if (!fParseSplit(TRUE, m_multiSzDistribution, m_cDistribution, " \t\r\n,",
			article, nntpReturn))
		return FALSE;

	//
	//Check for duplicates
	//

	DWORD cOldCount = m_cDistribution;
	if (!fMultiSzRemoveDupI(m_multiSzDistribution, m_cDistribution, m_pAllocator))
		nntpReturn.fSet(nrcMemAllocationFailed, __FILE__, __LINE__);

	if( m_cDistribution == 0 ) {
		return	nntpReturn.fSetOK() ;
	}

	//
	// check for illegal characters and substrings in Distribution name
	//

	char const * szDistribution = m_multiSzDistribution;
	do
	{
		if ('\0' == szDistribution[0]
			|| !fTestAComponent(szDistribution)
			)
		return nntpReturn.fSet(nrcArticleFieldIllegalComponent, szDistribution, szKeyword());

		//
		// go to first char after next null
		//

		while ('\0' != szDistribution[0])
			szDistribution++;
		szDistribution++;
	} while ('\0' != szDistribution[0]);

	return nntpReturn.fSetOK();
}

BOOL
CFromClientLinesField::fParse(
						 CArticleCore & article,
						 CNntpReturn & nntpReturn
						 )
/*++

Routine Description:

	Parses the Lines field.

Arguments:

	nntpReturn - The return value for this function call


Return Value:

	TRUE, if successful. FALSE, otherwise.

--*/
{
	//
	// clear the return code object
	//

	nntpReturn.fSetClear();

	//
	// Check article state
	//

	_ASSERT(fsFound == m_fieldState);//real

	_ASSERT(m_pHeaderString); //real

	if (!fParseSimple(TRUE, m_pc, nntpReturn))
		return nntpReturn.fFalse();

	char * pchMax = m_pc.pchMax();
	for (char * pch = m_pc.m_pch; pch < pchMax; pch++)
	{
		if (!isdigit((UCHAR)*pch))
			return nntpReturn.fSet(nrcArticleFieldBadChar, (BYTE) *pch, szKeyword());
	}

	return nntpReturn.fSetOK();
}

BOOL
CFromClientReferencesField::fParse(
								   CArticleCore & article,
								   CNntpReturn & nntpReturn
								   )
/*++

Routine Description:

	Parses the References field.

Arguments:

	nntpReturn - The return value for this function call


Return Value:

	TRUE, if successful. FALSE, otherwise.

--*/
{
	//
	// clear the return code object
	//

	nntpReturn.fSetClear();

	//
	// Check article state
	//

	_ASSERT(fsFound == m_fieldState);//real

	_ASSERT(m_pHeaderString); //real


	//
	// Record the allocator
	//

	m_pAllocator = article.pAllocator();

	if (!fParseSplit(FALSE, m_multiSzReferences, m_cReferences, szWSNLChars,
			article, nntpReturn))
		return nntpReturn.fFalse();

	//
	// check for illegal characters and substrings in References name
	//

	char const * szReferences = m_multiSzReferences;
	do
	{
		if (!fTestAMessageID(szReferences, nntpReturn))
			return nntpReturn.fFalse();

		//
		// go to first char after next null
		//

		while ('\0' != szReferences[0])
			szReferences++;
		szReferences++;
	} while ('\0' != szReferences[0]);

	return nntpReturn.fSetOK();
}

BOOL
CFromClientFeed::fRecordMessageIDIfNecc(
										CNntpServerInstanceWrapper * pInstance,
										const char * szMessageID,
										CNntpReturn & nntpReturn
										)
/*++

Routine Description:

	Records the MessageID of an article in article table.

Arguments:

	pInstance - virtual server instance
	szMessageID - the message id to record
	nntpReturn - The return value for this function call


Return Value:

	TRUE, if successful. FALSE, otherwise.

--*/
{
	//
	// clear the return code object
	//

	nntpReturn.fSetClear();

	//
	// Now, insert the article
	//

	if (!(pInstance->ArticleTable())->InsertMapEntry(szMessageID))
		return nntpReturn.fSet(nrcArticleDupMessID, szMessageID, GetLastError());

	return nntpReturn.fSetOK();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\nntp\server\newstree\src\nntpvr.cpp ===
#include "stdinc.h"

#include "nntpdrv_i.c"

#define DEFAULT_DRIVER_PROGID L"NNTP.FSPrepare"
#define NO_DRIVER_PROGID L"TestNT.NoDriver"
#define EX_DRIVER_PROGID L"NNTP.ExDriverPrepare"

extern char szSlaveGroup[];

CNntpComplete::CNntpComplete(CNNTPVRoot *pVRoot) {
#ifdef DEBUG
    m_cGroups = 0;
#endif
	m_cRef = 1;
	m_hr = E_FAIL;
	m_pVRoot = pVRoot;
	if (m_pVRoot) m_pVRoot->AddRef();
}

HRESULT CNntpComplete::GetResult() {
	return m_hr;
}

void CNntpComplete::SetResult(HRESULT hr) {
	m_hr = hr;
}

void CNntpComplete::SetVRoot(CNNTPVRoot *pVRoot) {
	if( pVRoot != m_pVRoot ) 	{
		CNNTPVRoot*	pTemp ;
		pTemp = m_pVRoot ;
		m_pVRoot = pVRoot ;
		if( m_pVRoot )
			m_pVRoot->AddRef() ;
		if( pTemp )
			pTemp->Release() ;
	}
}

ULONG CNntpComplete::AddRef() {
   	long	l = InterlockedIncrement(&m_cRef);
	_ASSERT( l >= 0 ) ;
	return	l ;
}

void CNntpComplete::Destroy() {
	XDELETE this;
}

ULONG CNntpComplete::Release() {
#ifdef DEBUG
    _ASSERT( m_cGroups == 0 );
#endif
	LONG i = InterlockedDecrement(&m_cRef);
	_ASSERT( i >= 0 ) ;
  	if (i == 0) Destroy();
	return i;
}

HRESULT CNntpComplete::QueryInterface(const IID &iid, VOID **ppv) {
	if ( iid == IID_IUnknown ) {
		*ppv = static_cast<IUnknown*>(this);
	} else if ( iid == IID_INntpComplete ) {
		*ppv = static_cast<INntpComplete*>(this);
	} else {
		*ppv = NULL;
		return E_NOINTERFACE;
	}
    reinterpret_cast<IUnknown*>(*ppv)->AddRef();
    return S_OK;
}

CNNTPVRoot *CNntpComplete::GetVRoot() {
	return m_pVRoot;
}

CNntpComplete::~CNntpComplete() {
	if (m_pVRoot) {
		// this ASSERT is hit if nothing ever calls SetResult() because
		// E_FAIL is the default value for m_hr.
		_ASSERT((GetResult() != E_FAIL) || (m_cRef!=0));

		// update the vroot state if the store went down
		m_pVRoot->UpdateState(GetResult());
	
		// release the vroot
		m_pVRoot->Release();
		m_pVRoot = NULL;
	}
}

void
CNntpComplete::Reset()	{
/*++

Routine Description :

	This function restores the completion object to the same state
	it would be after construction, so that it can be re-issued to
	a Store driver.

Arguments :

	None.

Return Value :

	None.

--*/
#ifdef DEBUG
    m_cGroups = 0;
#endif

	_ASSERT( m_cRef == 0 ) ;
	_ASSERT( m_hr != E_FAIL ) ;
	m_cRef = 1 ;
	m_hr = E_FAIL ;

	//
	//	We leave the VRoot pointer alone - assume client
	//	 is going to use the same VRoot.  NOTE :
	//	m_pVroot should be NONNULL since we've already gone
	//	through one opeartion !
	//
	//_ASSERT( m_pVRoot != 0 ) ;

}

CNNTPVRoot::CNNTPVRoot() {
	m_cchDirectory = 0;
	*m_szDirectory = 0;
	m_pDriver = NULL;
	m_pDriverPrepare = NULL;
#ifdef DEBUG
	m_pDriverBackup = NULL;
#endif
	m_hImpersonation = NULL;
	m_clsidDriverPrepare = GUID_NULL;
	m_eState = VROOT_STATE_UNINIT;
	m_pMB = NULL;
	m_bExpire = FALSE;
    m_eLogonInfo = VROOT_LOGON_DEFAULT;
    m_lDecCompleted = 1;
    m_fUpgrade = FALSE;
    m_dwWin32Error = NOERROR;
}

CNNTPVRoot::~CNNTPVRoot() {
	DropDriver();
	if ( m_hImpersonation ) CloseHandle( m_hImpersonation );
	if ( m_pMB ) m_pMB->Release();
}

void CNNTPVRoot::DropDriver() {
	INntpDriver *pDriver;
	INntpDriverPrepare *pDriverPrepare;
	
	m_lock.ExclusiveLock();
	Verify();
	pDriverPrepare = m_pDriverPrepare;
	m_pDriverPrepare = NULL;
	pDriver = m_pDriver;
	m_pDriver = NULL;
#ifdef DEBUG
	m_pDriverBackup = NULL;
#endif
	m_eState = VROOT_STATE_UNINIT;
	m_lock.ExclusiveUnlock();
	SetVRootErrorCode(ERROR_PIPE_NOT_CONNECTED);	

	if (pDriverPrepare) pDriverPrepare->Release();
	if (pDriver) pDriver->Release();
}

#ifdef DEBUG
//
// do a bunch of asserts which verify that our member variables are valid.
//
// this should only be called while a lock is held (shared or exclusive)
//
void CNNTPVRoot::Verify(void) {
	_ASSERT(m_pDriverBackup == m_pDriver);
	switch (m_eState) {
		case VROOT_STATE_UNINIT:
			_ASSERT(m_pDriver == NULL);
			_ASSERT(m_pDriverPrepare == NULL);
			break;
		case VROOT_STATE_CONNECTING:
			// the driver may be NULL if the store driver is halfway through
			// connecting
			//
			// _ASSERT(m_pDriver == NULL);
			_ASSERT(m_pDriverPrepare != NULL);
			break;
		case VROOT_STATE_CONNECTED:
			_ASSERT(m_pDriver != NULL);
			_ASSERT(m_pDriverPrepare == NULL);
			break;
		default:
			_ASSERT(m_eState == VROOT_STATE_UNINIT ||
					m_eState == VROOT_STATE_CONNECTING ||
					m_eState == VROOT_STATE_CONNECTED);
			break;
	}
}
#endif

BOOL CNNTPVRoot::CrackUserAndDomain(
    CHAR *   pszDomainAndUser,
    CHAR * * ppszUser,
    CHAR * * ppszDomain
    )
/*++

Routine Description:

    Given a user name potentially in the form domain\user, zero terminates
    the domain name and returns pointers to the domain name and the user name

Arguments:

    pszDomainAndUser - Pointer to user name or domain and user name
    ppszUser - Receives pointer to user portion of name
    ppszDomain - Receives pointer to domain portion of name

Return Value:

    TRUE if successful, FALSE otherwise (call GetLastError)

--*/
{
    static CHAR szDefaultDomain[MAX_COMPUTERNAME_LENGTH+1];

    //
    //  Crack the name into domain/user components.
    //

    *ppszDomain = pszDomainAndUser;
    *ppszUser   = (PCHAR)_mbspbrk( (PUCHAR)pszDomainAndUser, (PUCHAR)"/\\" );

    if( *ppszUser == NULL )
    {
        //
        //  No domain name specified, just the username so we assume the
        //  user is on the local machine
        //

        if ( !*szDefaultDomain )
        {
            _ASSERT( pfnGetDefaultDomainName );
            if ( !pfnGetDefaultDomainName( szDefaultDomain,
                                        sizeof(szDefaultDomain)))
            {
                return FALSE;
            }
        }

        *ppszDomain = szDefaultDomain;
        *ppszUser   = pszDomainAndUser;
    }
    else
    {
        //
        //  Both domain & user specified, skip delimiter.
        //

        **ppszUser = L'\0';
        (*ppszUser)++;

        if( ( **ppszUser == L'\0' ) ||
            ( **ppszUser == L'\\' ) ||
            ( **ppszUser == L'/' ) )
        {
            //
            //  Name is of one of the following (invalid) forms:
            //
            //      "domain\"
            //      "domain\\..."
            //      "domain/..."
            //

            SetLastError( ERROR_INVALID_PARAMETER );
            return FALSE;
        }
    }

    return TRUE;
}

//
// Logon on the user, return the impersonation token
//
HANDLE CNNTPVRoot::LogonUser(   LPSTR  szAccountName,
                                LPSTR  szPassWord )
{
    TraceFunctEnter( "CNNTPVRoot::LogonUser" );
    _ASSERT( szAccountName );
    _ASSERT( szPassWord );

    CHAR       szDomainAndUser[DNLEN+UNLEN+2];
    CHAR   *   szUserOnly;
    CHAR   *   szDomain;
    HANDLE      hToken = NULL;
    BOOL        fReturn;

    //
    //  Validate parameters & state.
    //
    _ASSERT( *szAccountName != 0 );
    _ASSERT( strlen( szAccountName ) < sizeof( szDomainAndUser ) );
    _ASSERT( strlen( szPassWord ) <= PWLEN );

    //
    //  Save a copy of the domain\user so we can squirrel around
    //  with it a bit.
    //

    lstrcpyn( szDomainAndUser, szAccountName, sizeof(szDomainAndUser) );

    //
    //  Crack the name into domain/user components.
    //  Then try and logon as the specified user.
    //

    fReturn = ( CrackUserAndDomain( szDomainAndUser,
                                   &szUserOnly,
                                   &szDomain ) &&
               ::LogonUserA(szUserOnly,
                          szDomain,
                          szPassWord,
                          LOGON32_LOGON_INTERACTIVE, //LOGON32_LOGON_NETWORK,
                          LOGON32_PROVIDER_DEFAULT,
                          &hToken )
               );

    if ( !fReturn) {

        //
        //  Logon user failed.
        //

        ErrorTrace( 0, " CrachUserAndDomain/LogonUser (%s) failed Error=%d\n",
                       szAccountName, GetLastError());

        hToken = NULL;
    } else {
        HANDLE hImpersonation = NULL;

        // we need to obtain the impersonation token, the primary token cannot
        // be used for a lot of purposes :(
        if (!DuplicateTokenEx( hToken,      // hSourceToken
                               TOKEN_ALL_ACCESS,
                               NULL,
                               SecurityImpersonation,  // Obtain impersonation
                               TokenImpersonation,
                               &hImpersonation)  // hDestinationToken
            ) {

            DebugTrace( 0, "Creating ImpersonationToken failed. Error = %d\n",
                        GetLastError()
                        );

            // cleanup and exit.
            hImpersonation = NULL;

            // Fall through for cleanup
        }

        //
        // close original token. If Duplicate was successful,
        //  we should have ref in the hImpersonation.
        // Send the impersonation token to the client.
        //
        CloseHandle( hToken);
        hToken = hImpersonation;
    }

    //
    //  Success!
    //

    return hToken;

} // LogonUser()

//
// reads the following parameters:
//
// MD_VR_PATH -> m_szDirectory
// MD_VR_DRIVER_PROGID -> m_clsidDriverPrepare
//
// calls StartConnecting()
//
HRESULT CNNTPVRoot::ReadParameters(IMSAdminBase *pMB, METADATA_HANDLE hmb) {
	TraceFunctEnter("CNNTPVRoot::ReadParameters");

	_ASSERT(m_pMB == NULL);
	m_pMB = pMB;
	m_pMB->AddRef();

	HRESULT hr = CIISVRoot::ReadParameters(m_pMB, hmb);

	if (FAILED(hr)) return hr;

	_ASSERT(m_eState == VROOT_STATE_UNINIT);
	Verify();

	WCHAR wszDirectory[MAX_PATH];
	DWORD cch = MAX_PATH;
	if (FAILED(GetString(m_pMB, hmb, MD_VR_PATH, wszDirectory, &cch))) {
		hr = HRESULT_FROM_WIN32(ERROR_NOT_FOUND);
		TraceFunctLeave();
		DebugTrace((DWORD_PTR) this, "GetString failed with %x", hr);
		return hr;
	}
	//length must include null terminator
	if (WideCharToMultiByte(CP_ACP, 0,
							wszDirectory, cch+1,
							m_szDirectory, MAX_PATH,
							NULL, NULL) == 0)
	{
		hr = HRESULT_FROM_WIN32(GetLastError());
		DebugTrace((DWORD_PTR) this, "WideCharToMultiByte failed with %x", hr);
		TraceFunctLeave();
		return hr;
	}
	m_cchDirectory = lstrlen(m_szDirectory);

	// get the progid for the driver that we want to use.  if it isn't
	// specified then we'll use the CLSID for the exchange store driver.
	// there is a "special" progid called "TestNT.NoDriver" that disables
	// the drivers.
	WCHAR wszProgId[MAX_PATH];
	cch = MAX_PATH;
	if (FAILED(GetString(m_pMB, hmb, MD_VR_DRIVER_PROGID, wszProgId, &cch))) {
		lstrcpyW(wszProgId, DEFAULT_DRIVER_PROGID);
	}

	// Initialize the logon info to default value
	m_eLogonInfo = VROOT_LOGON_DEFAULT;

	if (lstrcmpW(wszProgId, NO_DRIVER_PROGID) != 0) {

	    // If it's FS Driver, we check whether it's UNC and whether we need
	    // to use vroot level logon credential
	    if (    _wcsicmp( wszProgId, DEFAULT_DRIVER_PROGID ) == 0 &&
    	        *m_szDirectory == '\\' && *(m_szDirectory+1) == '\\' ) {   // UNC
    	    DWORD dwUseAccount = 0;
            hr = GetDWord( m_pMB, hmb, MD_VR_USE_ACCOUNT, &dwUseAccount );
            if ( FAILED( hr ) || dwUseAccount == 1 ) m_eLogonInfo = VROOT_LOGON_UNC;
        } else if ( _wcsicmp( wszProgId, EX_DRIVER_PROGID ) == 0 ) {
            // Exchange vroot
            m_eLogonInfo = VROOT_LOGON_EX;
        }

        // For UNC , we'll need the vroot logon token, do logon
        if ( m_eLogonInfo == VROOT_LOGON_UNC  ) {

            WCHAR   wszAccountName[MAX_PATH+1];
            CHAR    szAccountName[MAX_PATH+1];
            WCHAR   wszPassword[MAX_PATH+1];
            CHAR    szPassword[MAX_PATH+1];
            DWORD   cchAccountName = MAX_PATH;
            DWORD   cchPassword = MAX_PATH;

            if ( SUCCEEDED( hr = GetString(  m_pMB,
                                        hmb,
                                        MD_VR_USERNAME,
                                        wszAccountName,
                                        &cchAccountName ) )
                  && SUCCEEDED( hr = GetString(  m_pMB,
                                            hmb,
                                            MD_VR_PASSWORD,
                                            wszPassword,
                                            &cchPassword ) )) {
                CopyUnicodeStringIntoAscii( szAccountName, wszAccountName );
                CopyUnicodeStringIntoAscii( szPassword, wszPassword );
                m_hImpersonation = LogonUser(   szAccountName,
                                                    szPassword );
                if ( NULL == m_hImpersonation ) {
                    hr = HRESULT_FROM_WIN32( GetLastError() );
                    ErrorTrace( 0, "Logon using vroot account failed %x", hr );
                    TraceFunctLeave();
                    return hr;
                }
            } else {

                // Logon credential missing in vroot configuration, this is also fatal
                ErrorTrace( 0, "Logon credential missing in vroot configuration" );
                TraceFunctLeave();
                return hr;
            }

            _ASSERT( NULL != m_hImpersonation );
        }
	
		// get a CLSID for the driver
		hr = CLSIDFromProgID(wszProgId, &m_clsidDriverPrepare);
		if (FAILED(hr)) {
			// BUGBUG - log an event about an invalid progid being supplied
			DebugTrace((DWORD_PTR) this, "CLSIDFromProgID failed with %x", hr);
			TraceFunctLeave();
			return hr;
		}

		m_lock.ExclusiveLock();
		hr = StartConnecting();
		m_lock.ExclusiveUnlock();
	} else {
		hr = S_OK;
	}

    // Read the expire configuration, does the vroot handle expire itself ?
	DWORD   dwExpire;
	if ( SUCCEEDED( GetDWord( m_pMB, hmb, MD_VR_DO_EXPIRE, &dwExpire ) ) ) {
	    m_bExpire = ( dwExpire == 0 ) ? FALSE : TRUE;
	} else m_bExpire = FALSE;
	
	DebugTrace((DWORD_PTR) this, "success");
	return hr;
}

void
CNNTPVRoot::DispatchDropVRoot(
    )
/*++

Description:

    This function handles orphan VRoot during VRootRescan/VRootDelete
    We need to drop PrepareDriver, if exists.
    Can't drop good driver because it's gaurantee to complete operations,
    plus dropping good driver may result in unexpected AV!!!

Arguments:

    NONE

Return Values:

    NONE
--*/
{
	INntpDriverPrepare *pDriverPrepare;
	
	m_lock.ExclusiveLock();
	Verify();
	pDriverPrepare = m_pDriverPrepare;
	m_pDriverPrepare = NULL;
	m_lock.ExclusiveUnlock();

	if (pDriverPrepare) pDriverPrepare->Release();
}

HRESULT CNNTPVRoot::MapGroupToPath(const char *pszGroup,
								   char *pszPath,
								   DWORD cchPath,
								   PDWORD pcchDirRoot,
								   PDWORD pcchVRoot)
{
	DWORD cchVRoot;
	const char *pszVRoot = GetVRootName(&cchVRoot);

	if (_snprintf(pszPath, cchPath, "%s%s%s",
				  m_szDirectory,
				  (pszGroup[cchVRoot] == '.') ? "" : "\\",
				  &(pszGroup[cchVRoot])) < 0)
	{
		return E_INVALIDARG;
	}
	pszPath[cchPath-1]='\0';

	for (char *p = &pszPath[lstrlen(m_szDirectory)]; *p != 0; p++) {
		if (*p == '.') *p = '\\';
	}

	if (pcchDirRoot != NULL) *pcchDirRoot = m_cchDirectory;
	if (pcchVRoot != NULL) *pcchVRoot = cchVRoot;

	return S_OK;
}

//
// Set the key MD_WIN32_ERROR on the virtual root
//
void CNNTPVRoot::SetVRootErrorCode(DWORD dwErrorCode) {
	METADATA_HANDLE hmb;
	HRESULT hr;

//
//	BUG 74747 : this will cause MB deadlocks !!
//	Contact RajeevR for details.
//
#if 0	
	hr = m_pMB->OpenKey(METADATA_MASTER_ROOT_HANDLE,
				   		m_wszConfigPath,
				   		METADATA_PERMISSION_WRITE,
				   		100,
				   		&hmb);

	if (SUCCEEDED(hr)) {
		METADATA_RECORD mdr = {
			MD_WIN32_ERROR,
			0,
			ALL_METADATA,
			DWORD_METADATA,
			sizeof(DWORD),
			(BYTE *) &dwErrorCode,
			0
		};

		hr = m_pMB->SetData(hmb, L"", &mdr);
		// we don't do anything if this fails

		hr = m_pMB->CloseKey(hmb);
		_ASSERT(SUCCEEDED(hr));
	}
#endif
    //
    // Set it through instance wrapper
    //
    /*
    CHAR    szVRootPath[METADATA_MAX_NAME_LEN+1];
    _ASSERT( m_pVRootTable );
    _ASSERT( ((CNNTPVRootTable*)m_pVRootTable)->GetInstWrapper() );
    CopyUnicodeStringIntoAscii( szVRootPath, m_wszConfigPath);
    ((CNNTPVRootTable*)m_pVRootTable)->GetInstWrapper()->SetWin32Error( szVRootPath, dwErrorCode );
    */

    //
    // OK, now we have the rpc to get win32 error, we set it to
    // a internal member variable
    //
    m_dwWin32Error = dwErrorCode;
}

//
// move us from VROOT_STATE_UNINIT to VROOT_STATE_CONNECTING.
//
// returns: S_OK if state was changed properly, or an error otherwise.
//
// locking: assumes the exclusive lock is held
//
HRESULT CNNTPVRoot::StartConnecting() {
        INntpDriverPrepare *pPrepareDriver = NULL;
	TraceFunctEnter("CNNTPVRoot::StartConnecting");
	HANDLE  hToken = m_hImpersonation ? m_hImpersonation :
	                    g_hProcessImpersonationToken;

	Verify();

	//
	// Set the vroot error code to say that we are connecting
	//
	SetVRootErrorCode(ERROR_PIPE_NOT_CONNECTED);

	_ASSERT(m_eState != VROOT_STATE_CONNECTED);
	if (m_eState != VROOT_STATE_UNINIT) return E_UNEXPECTED;

	HRESULT hr;

	// this can happen if the special "no driver" progid was used.  This
	// should only be used in unit test situations.
	if (m_clsidDriverPrepare == GUID_NULL) { return E_INVALIDARG; }

	// create the driver
	hr = CoCreateInstance(m_clsidDriverPrepare,
						  NULL,
						  CLSCTX_INPROC_SERVER,
						  (REFIID) IID_INntpDriverPrepare,
						  (void **) &m_pDriverPrepare);
	if (FAILED(hr)) {
		DebugTrace((DWORD_PTR) this, "CoCreateInstance failed with %x", hr);
		TraceFunctLeave();
		return hr;
	}
	_ASSERT(m_pDriverPrepare != NULL);

	// create a new completion object
	CNNTPVRoot::CPrepareComplete *pComplete = XNEW CNNTPVRoot::CPrepareComplete(this);
	if (pComplete == NULL) {
		DebugTrace((DWORD_PTR) this, "new CPrepareComplete failed");
		m_pDriverPrepare->Release();
		m_pDriverPrepare = NULL;
		TraceFunctLeave();
		return E_OUTOFMEMORY;
	}

	m_eState = VROOT_STATE_CONNECTING;

        //
        // We can not call into driver while holding a lock, so we are releasing
        // the lock.  But before releasing the lock, we'll save off the prepare
        // driver to stack, add ref to it, since m_pPrepareDriver could be dropped
        // to NULL by DropDriver while we are outside the lock
        //
    pPrepareDriver = m_pDriverPrepare;
    pPrepareDriver->AddRef();
	m_lock.ExclusiveUnlock();

	// get a pointer to the server object
	INntpServer *pNntpServer;
	hr = GetContext()->GetNntpServer(&pNntpServer);
	if (FAILED(hr)) {
		// this should never happen
		_ASSERT(FALSE);
		DebugTrace((DWORD_PTR) this, "GetNntpServer failed with 0x%x", hr);
		pPrepareDriver->Release();
		pPrepareDriver->Release();
		pPrepareDriver = NULL;
		TraceFunctLeave();
		return hr;
	}

	// add a reference to the metabase on the drivers behalf
	m_pMB->AddRef();
	pNntpServer->AddRef();
	GetContext()->AddRef();

	// Prepare the flag to tell driver whether we are right after upgrade
	DWORD   dwFlag = 0;
	if ( m_fUpgrade ) dwFlag |= NNTP_CONNECT_UPGRADE;

	// start the driver initialization process
	_ASSERT( pPrepareDriver );
	pPrepareDriver->Connect(GetConfigPath(),
							  GetVRootName(),
							  m_pMB,
							  pNntpServer,
							  GetContext(),
							  &(pComplete->m_pDriver),
							  pComplete,
							  hToken,
							  dwFlag );

	//
	// We should make sure that driver has added a ref to prepare driver
	// before returning on this thread, so that DropDriver doesn't
	// destroy the prepare driver while it's still being accessed by
	// the connect thread
	//
	pPrepareDriver->Release();

	m_lock.ExclusiveLock();

	Verify();

	TraceFunctLeave();
	return hr;
}

//
// this is called before a driver operation to verify that we are in the
// connected state.  it returns FALSE otherwise.  if we are in the
// UNINIT state then this will try to get us into the connecting state
//
// locking: assumes the share lock is held
//
BOOL CNNTPVRoot::CheckState() {
	Verify();

	switch (m_eState) {
		case VROOT_STATE_CONNECTING:
			return FALSE;
			break;
		case VROOT_STATE_CONNECTED:
			return TRUE;
			break;
		default:
			_ASSERT(m_eState == VROOT_STATE_UNINIT);
			//
			// here we make an attempt to connect.  this requires
			// switching to an exclusive lock, starting the connection
			// process, then switching back to the shared
			// lock and seeing what state we are in.
			//
			if (!m_lock.SharedToExclusive()) {
				// if we couldn't migrate the lock (because others held the
				// shared lock at the same time) then release our lock and
				// explicitly grab the exclusive lock.
				m_lock.ShareUnlock();
				m_lock.ExclusiveLock();
			}
			if (m_eState == VROOT_STATE_UNINIT) StartConnecting();
			m_lock.ExclusiveToShared();
			// if we are now connected then return TRUE, otherwise return
			// FALSE
			return (m_eState == VROOT_STATE_CONNECTED);
			break;
	}
}

//
// check to see if the HRESULT is due to a driver going down.  if
// so drop our connection to the driver and update our state
//
// locking: assumes no lock is held
//
void CNNTPVRoot::UpdateState(HRESULT hr) {
	if (hr == NNTP_E_REMOTE_STORE_DOWN) {
		m_lock.ExclusiveLock();

		//
		// we can't assume our state here because multiple threads could
		// enter UpdateState() with the same error code at the same time.
		//
		if (m_eState == VROOT_STATE_CONNECTED) {
			// if we are connected then we should have a driver interface but
			// no prepare interface
			_ASSERT(m_pDriver != NULL);
			_ASSERT(m_pDriverPrepare == NULL);
			m_pDriver->Release();
			m_pDriver = NULL;
#ifdef DEBUG
			m_pDriverBackup = NULL;
#endif
			m_eState = VROOT_STATE_UNINIT;

			StartConnecting();
		}

		m_lock.ExclusiveUnlock();
	}
}

/////////////////////////////////////////////////////////////////////////
// WRAPPERS FOR DRIVER OPERATIONS                                      //
/////////////////////////////////////////////////////////////////////////

void CNNTPVRoot::DecorateNewsTreeObject(CNntpComplete *pCompletion) {
	TraceFunctEnter("CNNTPVRoot::DecorateNewsTreeObject");
	
	INntpDriver *pDriver;
	HANDLE      hToken;

	DebugTrace((DWORD_PTR) this, "in DecorateNewsTreeObject wrapper");

	// If we have UNC Vroot configuration, we'll use
	// the vroot level token, otherwise use the process token, because
	// the decorate newstree operation is done in system context
	_ASSERT( g_hProcessImpersonationToken );

	if ( m_eLogonInfo == VROOT_LOGON_EX ) hToken = NULL;    // use system
	else if ( m_hImpersonation ) hToken = m_hImpersonation;
	else hToken = g_hProcessImpersonationToken;
	
	pCompletion->SetVRoot(this);
	if ((pDriver = GetDriver( pCompletion ))) {
		pDriver->DecorateNewsTreeObject(hToken, pCompletion);
		pDriver->Release();
	} else {
	    pCompletion->SetResult(E_UNEXPECTED);
	    pCompletion->Release();
	}

	Verify();
	TraceFunctLeave();
}

void CNNTPVRoot::CreateGroup(   INNTPPropertyBag *pGroup,
                                CNntpComplete *pCompletion,
                                HANDLE      hToken,
                                BOOL fAnonymous ) {
	TraceFunctEnter("CNNTPVRoot::CreateGroup");
	
	INntpDriver *pDriver;

	DebugTrace((DWORD_PTR) this, "in CreateGroup wrapper");

	if ( m_hImpersonation && VROOT_LOGON_UNC == m_eLogonInfo )
        hToken = m_hImpersonation;
	else {
        if( !hToken ) {
            if (  VROOT_LOGON_EX == m_eLogonInfo ) hToken = NULL;   // use system
            else hToken = g_hProcessImpersonationToken;
        }
    }
	
	pCompletion->SetVRoot(this);

    pCompletion->BumpGroupCounter();
	if ((pDriver = GetDriver( pCompletion ))) {
		pDriver->CreateGroup(pGroup, hToken, pCompletion, fAnonymous );
		pDriver->Release();
	} else {
		if (pGroup) pCompletion->ReleaseBag( pGroup );
		pCompletion->SetResult(E_UNEXPECTED);
	    pCompletion->Release();
	}

	Verify();
	TraceFunctLeave();
}

void CNNTPVRoot::RemoveGroup(   INNTPPropertyBag *pGroup,
                                CNntpComplete *pCompletion ) {
	TraceFunctEnter("CNNTPVRoot::RemoveGroup");
	
	INntpDriver *pDriver;
	HANDLE  hToken;

	DebugTrace((DWORD_PTR) this, "in RemoveGroup wrapper");

    if ( m_hImpersonation && VROOT_LOGON_UNC == m_eLogonInfo )
        hToken = m_hImpersonation;
    else {
        if ( VROOT_LOGON_EX == m_eLogonInfo ) hToken = NULL;    //use system
        else hToken = g_hProcessImpersonationToken;
    }
	
	pCompletion->SetVRoot(this);
	pCompletion->BumpGroupCounter();
	if ((pDriver = GetDriver( pCompletion ))) {
		pDriver->RemoveGroup(pGroup, hToken, pCompletion, FALSE );
		pDriver->Release();
	} else {
		if (pGroup) pCompletion->ReleaseBag( pGroup );
		pCompletion->SetResult(E_UNEXPECTED);
	    pCompletion->Release();
	}

	Verify();
	TraceFunctLeave();
}

void CNNTPVRoot::SetGroup(  INNTPPropertyBag    *pGroup,
                            DWORD       cProperties,
                            DWORD       idProperties[],
                            CNntpComplete *pCompletion )
{
	TraceFunctEnter("CNNTPVRoot::SetGroup");
	
	_ASSERT( pGroup );
    _ASSERT( pCompletion );

	DebugTrace((DWORD_PTR) this, "in SetGroup wrapper");

    INntpDriver *pDriver;
    HANDLE  hToken;

    // There is no control set group, so we'll use either process
    // or store's administrator token here.
    if ( m_hImpersonation && VROOT_LOGON_UNC == m_eLogonInfo )
        hToken = m_hImpersonation;
    else {
        if ( VROOT_LOGON_EX == m_eLogonInfo ) hToken = NULL;    // use system
        else hToken = g_hProcessImpersonationToken;
    }

    pCompletion->SetVRoot( this );
    pCompletion->BumpGroupCounter();
    if ( (pDriver = GetDriver( pCompletion ))) {
        pDriver->SetGroupProperties(    pGroup,
                                        cProperties,
                                        idProperties,
                                        hToken,
                                        pCompletion,
                                        FALSE );
        pDriver->Release();
	} else {
		if (pGroup) pCompletion->ReleaseBag( pGroup );
		pCompletion->SetResult(E_UNEXPECTED);
	    pCompletion->Release();
    }

	Verify();
	TraceFunctLeave();
}

void
CNNTPVRoot::GetArticle(		CNewsGroupCore  *pPrimaryGroup,
							CNewsGroupCore  *pCurrentGroup,
							ARTICLEID       idPrimary,
							ARTICLEID       idCurrent,
							STOREID         storeid,
							FIO_CONTEXT     **ppfioContext,
							HANDLE          hImpersonate,
							CNntpComplete   *pComplete,
                            BOOL            fAnonymous )
{
	TraceFunctEnter("CNNTPVRoot::GetArticle");

	
	//
	//	The primary Group cannot be NULL - although the secondary one may !
	//
	_ASSERT( pPrimaryGroup != 0 ) ;

	DebugTrace((DWORD_PTR) this, "in GetArticle wrapper");

	if ( m_hImpersonation && VROOT_LOGON_UNC == m_eLogonInfo )
        hImpersonate = m_hImpersonation;
	else {
        if( !hImpersonate ) {
            if (  VROOT_LOGON_EX == m_eLogonInfo ) hImpersonate = NULL;
            else hImpersonate = g_hProcessImpersonationToken;
        }
    }
	
	INntpDriver *pDriver;
	pComplete->SetVRoot(this);
	if ((pDriver = GetDriver( pComplete ))) {
		INNTPPropertyBag *pPrimaryBag = pPrimaryGroup->GetPropertyBag();
		pComplete->BumpGroupCounter();
		INNTPPropertyBag *pCurrentBag = 0 ;
		if( pCurrentGroup ) {
			pCurrentBag = pCurrentGroup->GetPropertyBag();
			pComplete->BumpGroupCounter();
	    }
		pDriver->GetArticle(pPrimaryBag,
							pCurrentBag,
							idPrimary,
							idCurrent,
							storeid,
							hImpersonate,
							(void **) ppfioContext,
							pComplete,
                            fAnonymous );
		pDriver->Release();
	} else {
	    pComplete->SetResult(E_UNEXPECTED);
	    pComplete->Release();
	}

	Verify();
	TraceFunctLeave();
}

void	
CNNTPVRoot::GetXover(	IN	CNewsGroupCore	*pGroup,
						IN	ARTICLEID		idMinArticle,
						IN	ARTICLEID		idMaxArticle,
						OUT	ARTICLEID		*pidLastArticle,
						OUT	char*			pBuffer,
						IN	DWORD			cbIn,
						OUT	DWORD*			pcbOut,
						IN	HANDLE			hToken,
						IN	CNntpComplete*	pComplete,
                        IN  BOOL            fAnonymous
						) 	{
/*++	



Routine Description :

	This function wraps access to the storage driver for retrieving
	XOVER information.   We take a generic completion object and set
	it up to capture Driver error codes etc... that we would want to
	cause us to reset our VROOOTs etc....

Arguments :

	pGroup	The Group that we are getting XOVER data for
	idMinArticle	The smallest article number that we want INCLUDED in the
		XOVER result set !
	idMaxArticle	The smallest article number that we want EXCLUDED from the
		XOVER data set, all smaller article numbers should be INCLUDED
	pidLastArticle	



--*/
	TraceFunctEnter("CNNTPVRoot::GetXover");

	//
	//	The primary Group cannot be NULL - although the secondary one may !
	//
	_ASSERT( pGroup != 0 ) ;
	_ASSERT( idMinArticle != INVALID_ARTICLEID ) ;
	_ASSERT( idMaxArticle != INVALID_ARTICLEID ) ;
	_ASSERT( pidLastArticle != 0 ) ;
	_ASSERT( pBuffer != 0 ) ;
	_ASSERT( cbIn != 0 ) ;
	_ASSERT( pcbOut != 0 ) ;
	_ASSERT( pComplete != 0 ) ;

	DebugTrace(0, "in GetXover wrapper");

	if ( m_hImpersonation && VROOT_LOGON_UNC == m_eLogonInfo )
        hToken = m_hImpersonation;
	else {
        if( !hToken ) {
            if (  VROOT_LOGON_EX == m_eLogonInfo ) hToken = NULL;
            else hToken = g_hProcessImpersonationToken;
        }
    }

	INntpDriver *pDriver;
	pComplete->SetVRoot(this);
	if ((pDriver = GetDriver( pComplete ))) {
		INNTPPropertyBag *pBag = pGroup->GetPropertyBag();
		pComplete->BumpGroupCounter();
		pDriver->GetXover(	pBag,
							idMinArticle,
							idMaxArticle,
							pidLastArticle,
							pBuffer,
							cbIn,
							pcbOut,
							hToken,
							pComplete,
							fAnonymous
							) ;
		pDriver->Release();
	} else {
	    pComplete->SetResult(E_UNEXPECTED);
	    pComplete->Release();
	}

	Verify();
	TraceFunctLeave();
}


		//
		//	Wrap calls to the drivers to get the path for XOVER caching !
		//
BOOL	
CNNTPVRoot::GetXoverCacheDir(	
					IN	CNewsGroupCore*	pGroup,
					OUT	char*	pBuffer,
					IN	DWORD	cbIn,
					OUT	DWORD*	pcbOut,
					OUT	BOOL*	pfFlatDir
					) 	{

	_ASSERT( pGroup != 0 ) ;
	_ASSERT( pBuffer != 0 ) ;
	_ASSERT( pcbOut != 0 ) ;
	_ASSERT( pfFlatDir != 0 ) ;

	INntpDriver *pDriver;
	HRESULT hr  ;
	if ((pDriver = GetDriverHR( &hr ))) {
		INNTPPropertyBag *pBag = pGroup->GetPropertyBag();
		hr = pDriver->GetXoverCacheDirectory(	
							pBag,
							pBuffer,
							cbIn,
							pcbOut,
							pfFlatDir
							) ;
		pDriver->Release();
		if( SUCCEEDED(hr ) ) {
			return	TRUE ;
		}
	}
	return	FALSE ;
}



void	
CNNTPVRoot::GetXhdr(	IN	CNewsGroupCore	*pGroup,
						IN	ARTICLEID		idMinArticle,
						IN	ARTICLEID		idMaxArticle,
						OUT	ARTICLEID		*pidLastArticle,
						LPSTR               szHeader,
						OUT	char*			pBuffer,
						IN	DWORD			cbIn,
						OUT	DWORD*			pcbOut,
						IN	HANDLE			hToken,
						IN	CNntpComplete*	pComplete,
                        IN  BOOL            fAnonymous
						) 	{
/*++	



Routine Description :

	This function wraps access to the storage driver for retrieving
	XHDR information.   We take a generic completion object and set
	it up to capture Driver error codes etc... that we would want to
	cause us to reset our VROOOTs etc....

Arguments :

	pGroup	The Group that we are getting XOVER data for
	idMinArticle	The smallest article number that we want INCLUDED in the
		XOVER result set !
	idMaxArticle	The smallest article number that we want EXCLUDED from the
		XOVER data set, all smaller article numbers should be INCLUDED
	pidLastArticle	



--*/
	TraceFunctEnter("CNNTPVRoot::GetXover");

	//
	//	The primary Group cannot be NULL - although the secondary one may !
	//
	_ASSERT( pGroup != 0 ) ;
	_ASSERT( idMinArticle != INVALID_ARTICLEID ) ;
	_ASSERT( idMaxArticle != INVALID_ARTICLEID ) ;
	_ASSERT( pidLastArticle != 0 ) ;
	_ASSERT( szHeader );
	_ASSERT( pBuffer != 0 ) ;
	_ASSERT( cbIn != 0 ) ;
	_ASSERT( pcbOut != 0 ) ;
	_ASSERT( pComplete != 0 ) ;

	DebugTrace(0, "in GetXover wrapper");

	if ( m_hImpersonation && VROOT_LOGON_UNC == m_eLogonInfo )
        hToken = m_hImpersonation;
	else {
        if( !hToken ) {
            if (  VROOT_LOGON_EX == m_eLogonInfo ) hToken = NULL;
            else hToken = g_hProcessImpersonationToken;
        }
    }

	INntpDriver *pDriver;
	pComplete->SetVRoot(this);
	if ((pDriver = GetDriver( pComplete ))) {
		INNTPPropertyBag *pBag = pGroup->GetPropertyBag();
		pComplete->BumpGroupCounter();
		pDriver->GetXhdr(	pBag,
							idMinArticle,
							idMaxArticle,
							pidLastArticle,
							szHeader,
							pBuffer,
							cbIn,
							pcbOut,
							hToken,
							pComplete,
							fAnonymous
							) ;
		pDriver->Release();
	} else {
	    pComplete->SetResult(E_UNEXPECTED);
	    pComplete->Release();
	}

	Verify();
	TraceFunctLeave();
}

void CNNTPVRoot::CommitPost(IUnknown					*punkMessage,
			    		    STOREID						*pStoreId,
						    STOREID						*rgOtherStoreIds,
						    HANDLE                      hClientToken,
						    CNntpComplete				*pComplete,
                            BOOL                        fAnonymous )
{
	TraceFunctEnter("CNNTPVRoot::CommitPost");
	
	INntpDriver *pDriver;
	HANDLE      hImpersonate;

	DebugTrace((DWORD_PTR) this, "in CommitPost wrapper");

	if ( m_hImpersonation && VROOT_LOGON_UNC == m_eLogonInfo )
        hClientToken = m_hImpersonation;
	else {
        if( !hClientToken ) {
            if (  VROOT_LOGON_EX == m_eLogonInfo ) hClientToken = NULL;
            else hClientToken = g_hProcessImpersonationToken;
        }
    }
	
	pComplete->SetVRoot(this);
	if ((pDriver = GetDriver( pComplete ))) {
		pDriver->CommitPost(punkMessage,
		                    pStoreId,
		                    rgOtherStoreIds,
		                    hClientToken ,
		                    pComplete,
		                    fAnonymous );
		pDriver->Release();
	} else {
		if (punkMessage) punkMessage->Release();
		pComplete->SetResult(E_UNEXPECTED);
	    pComplete->Release();
	}

	Verify();
	TraceFunctLeave();
}

void CNNTPVRoot::CheckGroupAccess(  INNTPPropertyBag    *pPropBag,
                                    HANDLE              hClientToken,
                                    DWORD               dwAccessDesired,
                                    CNntpComplete       *pComplete )
{
	TraceFunctEnter("CNNTPVRoot::CheckGroupAccess");
	
	INntpDriver *pDriver;
    pComplete->SetVRoot(this);
    pComplete->BumpGroupCounter();

	// BUGBUG - the MMC doesn't set MD_ACCESS_READ in the metabase, so
	// we assume that read always works.
	DWORD dwGenericMask = GENERIC_READ;
	if (GetAccessMask() & MD_ACCESS_READ) dwGenericMask |= GENERIC_READ;
	if (GetAccessMask() & MD_ACCESS_WRITE) dwGenericMask |= GENERIC_WRITE;

    //
    // If we have specified post, create, remove access types but
    // metabase says that it doesn't have write access, then we
    // will fail it
    //
	if ( ((dwGenericMask & GENERIC_WRITE) == 0) && (dwAccessDesired != NNTP_ACCESS_READ) ) {
		pComplete->SetResult(E_ACCESSDENIED);
		if ( pPropBag ) pComplete->ReleaseBag( pPropBag );
		pComplete->Release();
	} else {
	
	    if ( m_hImpersonation && VROOT_LOGON_UNC == m_eLogonInfo )
            hClientToken = m_hImpersonation;
        else {
            if ( NULL == hClientToken ) {
	            if ( VROOT_LOGON_EX == m_eLogonInfo ) hClientToken = NULL;
	            else  hClientToken = g_hProcessImpersonationToken;
	        }
	    }
	
	    if ((pDriver = GetDriver( pComplete ))) {
	        pDriver->CheckGroupAccess(  pPropBag,
	                                    hClientToken,
	                                    dwAccessDesired,
	                                    pComplete );
	        pDriver->Release();
		} else {
			if (pPropBag) pComplete->ReleaseBag( pPropBag );
			pComplete->SetResult(E_UNEXPECTED);
			pComplete->Release();
	    }
	}

	Verify();
	TraceFunctLeave();
}

void CNNTPVRoot::DeleteArticle( INNTPPropertyBag    *pPropBag,
                                DWORD               cArticles,
                                ARTICLEID           rgidArt[],
                                STOREID             rgidStore[],
                                HANDLE              hClientToken,
                                PDWORD              piFailed,
                                CNntpComplete       *pComplete,
                                BOOL                fAnonymous )
{
	TraceFunctEnter("CNNTPVRoot::DeleteArticle");
	
	DebugTrace((DWORD_PTR) this, "in DeleteArticle wrapper");

	if ( m_hImpersonation && VROOT_LOGON_UNC == m_eLogonInfo )
        hClientToken = m_hImpersonation;
	else {
        if( !hClientToken ) {
            if (  VROOT_LOGON_EX == m_eLogonInfo ) hClientToken = NULL;
            else hClientToken = g_hProcessImpersonationToken;
        }
    }

	INntpDriver *pDriver;
    pComplete->SetVRoot(this);
    pComplete->BumpGroupCounter();
    if ( (pDriver = GetDriver( pComplete ))) {
        pDriver->DeleteArticle( pPropBag,
                                cArticles,
                                rgidArt,
                                rgidStore,
                                hClientToken,
                                piFailed,
                                pComplete,
                                fAnonymous );
        pDriver->Release();
	} else {
		if (pPropBag) pComplete->ReleaseBag( pPropBag );
		pComplete->SetResult(E_UNEXPECTED);
	    pComplete->Release();
    }

	Verify();
	TraceFunctLeave();
}

void CNNTPVRoot::RebuildGroup(  INNTPPropertyBag *pPropBag,
                                HANDLE          hClientToken,
                                CNntpComplete   *pComplete )
{
    TraceFunctEnter( "CNNTPVRoot::RebuildGroup" );

    DebugTrace( 0, "in Rebuild group wrapper" );

    if ( m_hImpersonation && VROOT_LOGON_UNC == m_eLogonInfo )
        hClientToken = m_hImpersonation;
    else {
        if ( !hClientToken ) {
            if ( VROOT_LOGON_EX == m_eLogonInfo ) hClientToken = NULL;
            else hClientToken = g_hProcessImpersonationToken;
        }
    }

    INntpDriver *pDriver;
    pComplete->SetVRoot(this);
    pComplete->BumpGroupCounter();
    if ( (pDriver = GetDriver( pComplete ) ) ) {
        pDriver->RebuildGroup(  pPropBag,
                                hClientToken,
                                pComplete );
        pDriver->Release();
    } else {
        if ( pPropBag ) pComplete->ReleaseBag( pPropBag );
        pComplete->SetResult(E_UNEXPECTED);
        pComplete->Release();
    }

    Verify();
    TraceFunctLeave();
}

/////////////////////////////////////////////////////////////////////////
// COMPLETION OBJECTS                                                  //
/////////////////////////////////////////////////////////////////////////

//
// this method is called when the IPrepareDriver::Connect call completes
//
CNNTPVRoot::CPrepareComplete::~CPrepareComplete() {
	TraceFunctEnter("CPrepareComplete");
	
	// temp driver pointers.  if they aren't NULL then a operation will occur
	// after releasing the lock:
	// pDriver - Release()
	// pDriverPrepare - Release()
	// pDriverDecorate - DecorateNewstree(pComplete)
	INntpDriver *pDriver = NULL, *pDriverDecorate = NULL;
	INntpDriverPrepare *pDriverPrepare = NULL;

	// the completion object that we will use with decorate
    CNNTPVRoot::CDecorateComplete *pComplete;
    HANDLE      hToken = NULL;

    GetVRoot()->m_lock.ExclusiveLock();

	DWORD ecVRoot = ERROR_SUCCESS;

	// copy the driver pointer from the completion object to the vroot
	GetVRoot()->m_pDriver = m_pDriver;

#ifdef DEBUG
	GetVRoot()->m_pDriverBackup = GetVRoot()->m_pDriver;
#endif

	// see if the call succeeded
    if (SUCCEEDED(GetResult())) {
		// yes, then update our vroot state and start the decorate newstree
		// process going
        pComplete = XNEW CNNTPVRoot::CDecorateComplete(GetVRoot());
        if (pComplete == NULL) {
			// not enough memory to build a completion object, so tear down
			// the connect
            GetVRoot()->m_eState = VROOT_STATE_UNINIT;
			pDriver = GetVRoot()->m_pDriver;
		    GetVRoot()->m_pDriver = NULL;
#ifdef DEBUG
			GetVRoot()->m_pDriverBackup = NULL;
#endif
			ecVRoot = ERROR_NOT_ENOUGH_MEMORY;
        } else {
			// mark each of the groups in the vroot as not having been
			// visited
			CNewsTreeCore *pTree = ((CINewsTree *) GetVRoot()->GetContext())->GetTree();

			pTree->m_LockTables.ShareLock();

			CNewsGroupCore *p = pTree->m_pFirst;
			while (p) {
				//DebugTrace((DWORD_PTR) this, "reset visited %s", p->GetName());
				// if this group belongs to this vroot then mark its visited
				// flag as FALSE
				CNNTPVRoot *pVRoot = p->GetVRoot();
				if (pVRoot == GetVRoot()) p->SetDecorateVisitedFlag(FALSE);
				if (pVRoot) pVRoot->Release();

			    p = p->m_pNext;
			}        	

			pTree->m_LockTables.ShareUnlock();

			// call DecorateNewstree
			GetVRoot()->SetDecStarted();
			GetVRoot()->m_eState = VROOT_STATE_CONNECTED;
			pDriverDecorate = GetVRoot()->m_pDriver;
			pDriverDecorate->AddRef();
        }
    } else {
		// the call didn't succeed
        GetVRoot()->m_eState = VROOT_STATE_UNINIT;
		HRESULT hr = GetResult();
		ecVRoot = (HRESULT_FACILITY(hr) == FACILITY_NT_BIT) ?
				   HRESULT_CODE(hr) :
				   hr;
    }

    // drop our reference to the prepare interface
	pDriverPrepare = GetVRoot()->m_pDriverPrepare;
	GetVRoot()->m_pDriverPrepare = NULL;
    GetVRoot()->m_lock.ExclusiveUnlock();

	// set the vroot error code
	GetVRoot()->SetVRootErrorCode(ecVRoot);	

 	if (pDriverPrepare) pDriverPrepare->Release();
	// we should never be releasing the driver and decorating it.
	_ASSERT(!(pDriver && pDriverDecorate));
	if (pDriver) pDriver->Release();
	if (pDriverDecorate) {

	    if ( GetVRoot()->m_hImpersonation && VROOT_LOGON_UNC == GetVRoot()->m_eLogonInfo )
            hToken = GetVRoot()->m_hImpersonation;
        else {
            if ( VROOT_LOGON_EX == GetVRoot()->m_eLogonInfo ) hToken = NULL;
            else hToken = g_hProcessImpersonationToken;
        }

		pDriverDecorate->DecorateNewsTreeObject(hToken, pComplete);
		pDriverDecorate->Release();
	}
}

void CNNTPVRoot::CDecorateComplete::CreateControlGroups(INntpDriver *pDriver) {
	char szNewsgroup [3][MAX_NEWSGROUP_NAME];
	BOOL fRet = TRUE;

	TraceFunctEnter("CNNTPVRoot::CPrepareComplete::CreateControlGroups");
	
	lstrcpy(szNewsgroup[0], "control.newgroup");
	lstrcpy(szNewsgroup[1], "control.rmgroup");
	lstrcpy(szNewsgroup[2], "control.cancel");

	CINewsTree *pINewsTree = (CINewsTree *) m_pVRoot->GetContext();
	CNewsTreeCore *pTree = pINewsTree->GetTree();
	CGRPCOREPTR	pGroup;
	HRESULT hr;

    for (int i=0; i<3; i++) {
		INntpDriver *pGroupDriver;

		// check to see if this vroot owns the group.  if not then we
		// shouldn't create it
		hr = pINewsTree->LookupVRoot(szNewsgroup[i], &pGroupDriver);
		if (FAILED(hr)) fRet = FALSE;
		if (FAILED(hr) || pDriver != pGroupDriver) continue;

		// try and create the group.  if it doesn't exist it will be
		// created, or if it does exist then we'll just get a pointer to it
    	BOOL f = pTree->CreateGroup(szNewsgroup[i], TRUE, NULL, FALSE );
		if (!f) {
       	    ErrorTrace(0,"Failed to create newsgroup %s, ec = %i",
				szNewsgroup[i], GetLastError());
       	    fRet = FALSE ;
		}
    }

	if (!fRet) {
		// BUGBUG - log error
	}
}

void CNNTPVRoot::CDecorateComplete::CreateSpecialGroups(INntpDriver *pDriver) {
    TraceFunctEnter( "CNNTPVRoot::CDecorateComplete::CreateSpecialGroups" );

    CINewsTree *pINewsTree = (CINewsTree *)m_pVRoot->GetContext();
    CNewsTreeCore *pTree = pINewsTree->GetTree();
    CGRPCOREPTR pGroup;
    HRESULT hr;

    //
    // Make sure that the group belongs to us
    //
    INntpDriver *pGroupDriver;
    hr = pINewsTree->LookupVRoot( szSlaveGroup, &pGroupDriver );
    if ( FAILED( hr ) ) {
        ErrorTrace( 0, "Lookup vroot for slave group failed %x", hr );
        return;
    }

    if ( pDriver != pGroupDriver ) {
        // It's none of our business
        DebugTrace( 0, "I shouldn't create special group" );
        return;
    }

    //
    // I should create it
    //
    pTree->CreateSpecialGroups();
    TraceFunctLeave();
}

//
// this method is called when the INntpDriver::DecorateNewstree call completes
//
CNNTPVRoot::CDecorateComplete::~CDecorateComplete() {
	TraceFunctEnter("CDecorateComplete");

	HRESULT hr = GetResult();

    GetVRoot()->m_lock.ShareLock();

    //
	// if the vroot state still isn't CONNECTED then this vroot has gone
	// down and we shouldn't do anything
	//
	if (GetVRoot()->m_eState == VROOT_STATE_CONNECTED) {

	    // visit each of the groups in the tree that point to this vroot and
	    // see if they were visited
	    CNewsTreeCore *pTree = ((CINewsTree *) GetVRoot()->GetContext())->GetTree();

	    pTree->m_LockTables.ShareLock();
	    CNewsGroupCore *p = pTree->m_pFirst;
	    while( p && p->IsDeleted() ) p = p->m_pNext;
	    if (p) p->AddRef();
	    pTree->m_LockTables.ShareUnlock();

	    while (p && !(pTree->m_fStoppingTree)) {
		    //DebugTrace((DWORD_PTR) this, "check visited %s, flag = %i",
			//    p->GetName(), p->GetDecorateVisitedFlag());
		    // if this group belongs to this vroot then see if it has been
		    // visited.  if not then delete it
		    CNNTPVRoot *pVRoot = p->GetVRoot();
		    //DebugTrace((DWORD_PTR) this, "vroot 0x%x, group vroot 0x%x",
			//    GetVRoot(), pVRoot);
		    if (pVRoot == GetVRoot() &&         // I am in charge of this vroot
		        (!(p->GetDecorateVisitedFlag()) // The group hasn't been visited
		        || FAILED( hr ) )  ) {          // or we failed in decorate newstree
			    DebugTrace((DWORD_PTR) this, "remove unvisited %s", p->GetName());
			    pTree->RemoveGroupFromTreeOnly(p);
		    }
		    if (pVRoot) pVRoot->Release();

		    pTree->m_LockTables.ShareLock();

            CNewsGroupCore *pOld = p;

		    do {
	            p = p->m_pNext;
	        } while ( p && p->IsDeleted() );
		
		    if (p) p->AddRef();
		    pTree->m_LockTables.ShareUnlock();

		    pOld->Release();
	    }        	
	    if (p) p->Release();

	    // Release hte share lock here before calling into driver
	    GetVRoot()->m_lock.ShareUnlock();

	    //
	    // We should check if decorate newstree succeeded, if failed, we should
	    // release the driver
	    //
        if ( SUCCEEDED( GetResult() ) ) {

            //
	        // Create control groups and special groups
	        //
	        INntpDriver *pDriver = GetVRoot()->GetDriver( NULL );
	        if ( pDriver ) {
	            CreateControlGroups( pDriver );
	            CreateSpecialGroups( pDriver );
	            pDriver->Release();
	        }
	    } else {

	        GetVRoot()->m_lock.ExclusiveLock();

            INntpDriver *pDriver = GetVRoot()->m_pDriver;
            INntpDriverPrepare *pPrepare = GetVRoot()->m_pDriverPrepare;
            GetVRoot()->m_pDriver = NULL;
#ifdef DEBUG
            GetVRoot()->m_pDriverBackup = NULL;
#endif
            GetVRoot()->m_pDriverPrepare = NULL;
            GetVRoot()->m_eState = VROOT_STATE_UNINIT;

            GetVRoot()->m_lock.ExclusiveUnlock();

            GetVRoot()->SetVRootErrorCode( GetResult() );
            if ( pDriver ) pDriver->Release();
            if ( pPrepare ) pPrepare->Release();
        }

    } else {
   	    GetVRoot()->m_lock.ShareUnlock();
    }

    //
    // Set decorate complete flag, this is just for rebuild purpose
    //
    GetVRoot()->SetDecCompleted();
}

void
CNNTPVRootTable::BlockEnumerateCallback(    PVOID   pvContext,
                                            CVRoot  *pVRoot )
/*++
Routine description:

    Check if the vroot is in stable state, if it is, return true
    through context, otherwise false through context

Arguments:

    PVOID   pvContext   - context ( for return value )
    CVRoot  *pVRoot     - VRoot

Return value:

    None.
--*/
{
    TraceFunctEnter( "CNNTPVRootTable::BlockEnumerateCallback" );
    _ASSERT( pvContext );
    _ASSERT( pVRoot );

    //
    // We know that it's safe to cast it back
    //
    CNNTPVRoot *pNntpVRoot = (CNNTPVRoot*)pVRoot;

    *((BOOL*)pvContext) = *((BOOL*)pvContext) && pNntpVRoot->InStableState();
}

void
CNNTPVRootTable::DecCompleteEnumCallback(   PVOID   pvContext,
                                            CVRoot  *pVRoot )
/*++
Routine description:

    Check if the vroot is finished with decorate newstree

Arguments:

    PVOID pvContext     - context ( for return value )
    CVRoot  *pVRoot     - VRoot

Return value:

    None.
--*/
{
    TraceFunctEnter( "CNNTPVRootTable::DecCompleteEnumCallback" );
    _ASSERT( pvContext );
    _ASSERT( pVRoot );

    //
    // We know that it's safe to cast it back
    //
    CNNTPVRoot *pNntpVRoot = (CNNTPVRoot*)pVRoot;

    *((BOOL*)pvContext) = *((BOOL*)pvContext) && pNntpVRoot->DecCompleted();
}

BOOL
CNNTPVRootTable::BlockUntilStable( DWORD dwWaitMSeconds )
/*++
Routine description:

    This function enumerates all the vroots, waits for all of them to reach
    stable state - either CONNECTED or UNINITED.

    The function should not be called during normal server startup.  IT's
    called in rebuild.

Arguments:

    DWORD dwWaitSeconds - How many seconds to wait as the polling interval

Return value:

    TRUE if succeeded, FALSE otherwise
--*/
{
    TraceFunctEnter( "CNNTPVRootTable::BlockUntilStable" );
    _ASSERT( dwWaitMSeconds > 0 );

    BOOL    fStable = FALSE;
    HRESULT hr      = S_OK;
    DWORD   dwTimeOutRetries = 10 * 60; // 600 sec, 10 minutes
    DWORD   cRetries = 0;

    //
    // We should wait for all the vroot connection to fail or succeed,
    // if any vroot is hung during connection, we'll time out and fail
    // the rebuild
    //
    while( cRetries++ < dwTimeOutRetries && SUCCEEDED( hr ) && !fStable ) {
        fStable = TRUE;
        hr = EnumerateVRoots( &fStable, BlockEnumerateCallback );
        if ( SUCCEEDED( hr ) && !fStable ) {
            Sleep( dwWaitMSeconds );
        }
    }

    //
    // If we have been timed out, we should return error
    //
    if ( !fStable || FAILED( hr ) ) {
        DebugTrace( 0, "We are timed out waiting for vroot connection" );
        SetLastError( WAIT_TIMEOUT );
        return FALSE;
    }

    //
    // Now we should really block until decoratenewstree to complete
    //
    fStable = FALSE;
    while( SUCCEEDED( hr ) && !fStable ) {
        fStable = TRUE;
        hr = EnumerateVRoots( &fStable, DecCompleteEnumCallback );
        if ( SUCCEEDED( hr ) && !fStable ) {
            Sleep( dwWaitMSeconds );
        }
    }

    return SUCCEEDED( hr );
}

void
CNNTPVRootTable::CheckEnumerateCallback(    PVOID   pvContext,
                                            CVRoot  *pVRoot )
/*++
Routine description:

    Call back function for:
    Check to see if every configured vroot has been successfully connected.

Arguments:

    PVOID   pvContext   - context ( for return value )
    CVRoot  *pVRoot     - VRoot

Return value:

    None.
--*/
{
    TraceFunctEnter( "CNNTPVRootTable::CheckEnumerateCallback" );
    _ASSERT( pvContext );
    _ASSERT( pVRoot );

    //
    // We know that it's safe to cast it back
    //
    CNNTPVRoot *pNntpVRoot = (CNNTPVRoot*)pVRoot;

    *((BOOL*)pvContext) = *((BOOL*)pvContext ) && pNntpVRoot->IsConnected();
}

BOOL
CNNTPVRootTable::AllConnected()
/*++
Routine description;

    This function enumerates all the vroots to see if all of them are
    connected.  The function may be called during rebuild, when the
    rebuild requires to rebuild all the vroots.  It should be called
    after calling BlockUntilStable - when the vroot connection reaches
    stability

Arguments:

    None.

Return value:

    TRUE if every vroot is connected, FALSE otherwise
--*/
{
    TraceFunctEnter( "CNNTPVRootTable::CheckConnections" );

    BOOL    fConnected  = TRUE;
    HRESULT hr          = S_OK;

    hr = EnumerateVRoots( &fConnected, CheckEnumerateCallback );

    return SUCCEEDED( hr ) && fConnected;
}

DWORD
CNNTPVRootTable::GetVRootWin32Error(    LPWSTR  wszVRootPath,
                                        PDWORD  pdwWin32Error )
/*++
Routine description:

    Get the vroot connection status error code

Arguments:

    LPWSTR  wszVRootPath -  The vroot to get connection status from
    PDWORD  pdwWin32Error - To return the win32 error code

Return value:

    NOERROR if succeeded, WIN32 error code otherwise
--*/
{
    TraceFunctEnter( "CNNTPVRootTable::GetVRootWin32Error" );
    _ASSERT( wszVRootPath );
    _ASSERT( pdwWin32Error );

    CHAR    szGroupName[MAX_NEWSGROUP_NAME+1];
    DWORD   dw = NOERROR;

    //
    // Convert the vrpath to ascii
    //
    CopyUnicodeStringIntoAscii( szGroupName, wszVRootPath );

    //
    // Make it look like a news group so that we can do vrtable lookup
    //
    LPSTR   lpstr = szGroupName;
    while( *lpstr ) {
        if ( *lpstr == '/' ) *lpstr = '.';
        *lpstr = (CHAR)tolower( *lpstr );
        lpstr++;
    };

    //
    // Now search for the vroot and get its connection status
    //
    NNTPVROOTPTR pVRoot = NULL;
    HRESULT hr = FindVRoot( szGroupName, &pVRoot );
    if ( pVRoot ) {
        dw = pVRoot->GetVRootWin32Error( pdwWin32Error );
    } else {

        // vroot was not ever configured
        *pdwWin32Error = ERROR_NOT_FOUND;
    }

    TraceFunctLeave();
    return dw;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\nntp\server\post\src\frommstr.cpp ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    fromclnt.cpp

Abstract:

	Contains InFeed, Article, and Fields code specific to FromMaster Infeeds


Author:

    Carl Kadie (CarlK)     12-Dec-1995

Revision History:

--*/

#include "stdinc.h"
#include    <stdlib.h>


BOOL
CFromMasterArticle::fValidate(
							CPCString& pcHub,
							const char * szCommand,
							CInFeed*		pInFeed,
							CNntpReturn & nntpReturn
							)
/*++

Routine Description:

	Validates an article from a master. Does not change the article.

Arguments:

	szCommand - The arguments (if any) used to post/xreplic/etc this article.
	nntpReturn - The return value for this function call


Return Value:

	TRUE, if successful. FALSE, otherwise.

--*/
{
	nntpReturn.fSetClear(); // clear the return object

	//
	// Check the message id
	//

	if (!m_fieldMessageID.fFindAndParse(*this, nntpReturn))
			return nntpReturn.fFalse();

	//
	//!!!FROMMASTER LATER do multiple masters
	//

	if (m_pInstance->ArticleTable()->SearchMapEntry(m_fieldMessageID.szGet())
		|| m_pInstance->HistoryTable()->SearchMapEntry(m_fieldMessageID.szGet()))
	{
		nntpReturn.fSet(nrcArticleDupMessID, m_fieldMessageID.szGet(), GetLastError());
		return nntpReturn.fFalse();
	}
	

	//
	// From here on, we want to add an entry to the history table
	// even if the article was rejected.
	//


	//
	// Create a list of the fields of interest
	//


	//
	//	NOTE ! Because we will ignore errors caused by bad XREF lines,
	//	we must make sure it is parsed last, otherwise we may miss errors
	//	that occur in parsing the other header lines !
	//
	CField * rgPFields [] = {
            &m_fieldControl,
			&m_fieldPath,
			&m_fieldXref
				};

	DWORD cFields = sizeof(rgPFields)/sizeof(CField *);

	m_cNewsgroups = 0 ;
	LPCSTR	lpstr = szCommand ;
	while( lpstr && *lpstr != '\0' ) {
		lpstr += lstrlen( lpstr ) + 1 ;
		m_cNewsgroups ++ ;
	}

	//
	// Assume the best
	//

	nntpReturn.fSetOK();

	//
	// Even if fFindParseList or fCheckCommandLine fail,
	// save the message id

	CNntpReturn	nntpReturnParse ;

	if (fFindAndParseList((CField * *)rgPFields, cFields, nntpReturnParse))	{
		if( !fCheckCommandLine(szCommand, nntpReturn)	)	{
#ifdef BUGBUG
			if( nntpReturn.m_nrc == nrcInconsistentMasterIds ) {
				pInFeed->LogFeedEvent( NNTP_MASTER_BADARTICLEID, (char*)szMessageID(), m_pInstance->QueryInstanceId() ) ;
			}	else	if(	nntpReturn.m_nrc == nrcInconsistentXref ) {
				pInFeed->LogFeedEvent( NNTP_MASTER_BAD_XREFLINE, (char*)szMessageID(), m_pInstance->QueryInstanceId() ) ;
			}
#endif
		}
	}

	//
	// Now, insert the article, even if fFindAndParseList or fCheckCommandLine
	// failed.
	//

	if (!m_pInstance->ArticleTable()->InsertMapEntry(m_fieldMessageID.szGet()))
		return nntpReturn.fFalse();


	return nntpReturn.fIsOK();
}


BOOL
CFromMasterArticle::fMungeHeaders(
							 CPCString& pcHub,
							 CPCString& pcDNS,
							 CNAMEREFLIST & grouplist,
							 DWORD remoteIpAddress,
							 CNntpReturn & nntpReturn,
							 PDWORD pdwLinesOffset
			  )
/*++

Routine Description:

	Modify the headers of the article.

Arguments:

	grouplist - A list: for each newsgroup its name, and the article number in that group.
	nntpReturn - The return value for this function call


Return Value:

	TRUE, if successful. FALSE, otherwise.

--*/
{
	nntpReturn.fSetClear(); // clear the return object

	//
	// We don't want caller to back fill lines line in any case here
	//
	if ( pdwLinesOffset ) *pdwLinesOffset = INVALID_FILE_SIZE;
	
	if( !fCommitHeader( nntpReturn ) )
		return	FALSE ;
	return nntpReturn.fSetOK();
}

BOOL
CFromMasterXrefField::fParse(
							 CArticleCore & article,
							 CNntpReturn & nntpReturn
				 )
 /*++

Routine Description:

  Parses the XRef field.


Arguments:

	nntpReturn - The return value for this function call


Return Value:

	TRUE, if successful. FALSE, otherwise.

--*/
{
	nntpReturn.fSetClear(); // clear the return object
	
	CPCString pcValue = m_pHeaderString->pcValue;
	CPCString pcHubFromParse;

	pcValue.vGetToken(szWSNLChars, pcHubFromParse);

#if 0
	CPCString pcHub(NntpHubName, HubNameSize);
	if (pcHub != pcHubFromParse)
	{
		char szHubFromParse[MAX_PATH];
		pcHubFromParse.vCopyToSz(szHubFromParse, MAX_PATH);
		return nntpReturn.fSet(nrcArticleXrefBadHub, NntpHubName, szHubFromParse);
	}
#endif

	if( !pcHubFromParse.fEqualIgnoringCase((((CArticle&)article).m_pInstance)->NntpHubName()) ) {
		char szHubFromParse[MAX_PATH];
		pcHubFromParse.vCopyToSz(szHubFromParse, MAX_PATH);
		return nntpReturn.fSet(nrcArticleXrefBadHub, (((CArticle&)article).m_pInstance)->NntpHubName(), szHubFromParse);
	}

	//
	// Count the number of ':''s so we know the number of slots needed
	//

	DWORD dwXrefCount = pcValue.dwCountChar(':');
	if (!m_namereflist.fInit(dwXrefCount, article.pAllocator()))
	{
		return nntpReturn.fSet(nrcMemAllocationFailed, __FILE__, __LINE__);
	}

	while (0 < pcValue.m_cch)
	{
		CPCString pcName;
		CPCString pcArticleID;

		pcValue.vGetToken(":", pcName);
		pcValue.vGetToken(szWSNLChars, pcArticleID);

		if ((0 == pcName.m_cch) || (0 == pcArticleID.m_cch))
			return nntpReturn.fSet(nrcArticleBadField, szKeyword());

		NAME_AND_ARTREF Nameref;

		//
		// Convert string to number. Don't need to terminate with a '\0' any
		// nondigit will do.
		//

		(Nameref.artref).m_articleId = (ARTICLEID)atoi(pcArticleID.m_pch);
		Nameref.pcName = pcName;
		m_namereflist.AddTail(Nameref);

		pcValue.dwTrimStart(szWSNLChars) ;
	}

	return nntpReturn.fSetOK();
}


BOOL
CFromMasterArticle::fCheckCommandLine(
									  char const * szCommand,
									  CNntpReturn & nntpReturn
									  )
/*++

Routine Description:


	 Check that the Command line is consistent with the article
		 Currently, just return OK


Arguments:

	szCommand -
	nntpReturn - The return value for this function call


Return Value:

	TRUE, if successful. FALSE, otherwise.

--*/
{
	nntpReturn.fSetClear(); // clear the return object
	//!!!FROMMASTER LATER check against xref data.
/* Here is some code that might be useful when checking consistancy.  */
	//
	// Of the form: "ggg:nnn\0[,ggg:nnn\0...]\0"
	//

	CNAMEREFLIST*	pNameRefList = m_fieldXref.pNamereflistGet() ;

	DWORD   iMatch = 0 ;
	int		i = 0 ;

	POSITION	posInOrder = pNameRefList->GetHeadPosition() ;

	if( pNameRefList != 0 ) {
		char const * sz = szCommand;
		do
		{

			CPCString pcItem((char *)szCommand);
			CPCString pcGroupID;
			CPCString pcArticleID;

			//
			// First get a ggg
			//

			pcItem.vGetToken(":", pcGroupID);

			//
			// Second, get a nnn
			//
			pcItem.vGetToken(szWSNLChars, pcArticleID);
			

			//GROUPID	groupId ;
			ARTICLEID	artId = 0 ; //atoi(  ) ;

			//
			//!!!FROMMASTER LATER check against xref data.
			//
			POSITION	pos = 0 ;
			NAME_AND_ARTREF*	pNameRef = 0 ;
			if( posInOrder != 0 ) {
				pNameRef = pNameRefList->GetNext( posInOrder ) ;
				if( pNameRef->pcName.fEqualIgnoringCase( szCommand ) ) {
					iMatch++ ;
					if( pNameRef->artref.m_articleId != (ARTICLEID)atoi( pcArticleID.sz() ) ) {
						return	nntpReturn.fSet( nrcInconsistentMasterIds ) ;
					}
					goto	KEEP_LOOPING ;
				}	
			}			

			pos = pNameRefList->GetHeadPosition() ;
			pNameRef = pNameRefList->GetNext( pos ) ;
			for( i=pNameRefList->GetCount(); i>0; i--, pNameRef = pNameRefList->GetNext( pos ) ) {
				if( pNameRef->pcName.fEqualIgnoringCase( szCommand ) ) {
					iMatch ++ ;
					if( pNameRef->artref.m_articleId != (ARTICLEID)atoi( pcArticleID.sz() ) )	{					
						return	nntpReturn.fSet( nrcInconsistentMasterIds ) ;
					}
					break ;
				}
			}

			//
			// go to first char after next null
			//

KEEP_LOOPING :
			while ('\0' != szCommand[0])
				szCommand++;
			szCommand++;
		} while ('\0' != szCommand[0]);
	}

	if( iMatch == m_cNewsgroups )
		return nntpReturn.fSetOK();
	else
		return	nntpReturn.fSet( nrcInconsistentXref ) ;
}



BOOL
CFromMasterFeed::fCreateGroupLists(
							CNewsTreeCore * pNewstree,
							CARTPTR & pArticle,
							CNEWSGROUPLIST & grouplist,
							CNAMEREFLIST * pNamereflist,
							LPMULTISZ	multiszCommandLine,
                            CPCString& pcHub,
							CNntpReturn & nntpReturn
							)
/*++

Routine Description:

	For each newsgroup, find the article id for this new article
	in that newsgroup. Uses the data in XRef to do this.


  !!!FROMMASTER this should be replaced to different


Arguments:

	pNewstree - Newstree for this virtual server instance
	pArticle - Pointer to the being processed.
	grouplist - A list of group objects, one for each newsgroup
	namereflist - A list: each item has the name of the newsgroup and groupid and
	               article id
	nntpReturn - The return value for this function call


Return Value:

	TRUE, if successful. FALSE, otherwise.

--*/
{
	nntpReturn.fSetClear();

#if 0
	pNamereflist = pArticle->pNamereflistGet();

	POSITION	pos = pNamereflist->GetHeadPosition() ;
	while( pos  )
	{
		NAME_AND_ARTREF * pNameref = pNamereflist->Get(pos);
		char szName[MAX_PATH];
		(pNameref->pcName).vCopyToSz(szName, MAX_PATH);
		CGRPPTR	pGroup = pNewstree->GetGroup(szName, (pNameref->pcName).m_cch);
		if (pGroup)
		{
			/*!!! laterm ilestone
			CSecurity * pSecurity = pGroup->GetSecurity( ) ;
			if (pSecurity->Restricted(m_socket))
			{
				grouplist.RemoveAll();
				break;
			}
			*/
			(pNameref->artref).m_groupId = pGroup->GetGroupId();
			grouplist.AddTail(pGroup);
		}
		(pNameref->pcName).vInsert(pGroup->GetName());
		pNamereflist->GetNext(pos);
	}
#endif

	if( 0==multiszCommandLine ) {
		nntpReturn.fSet( nrcSyntaxError ) ;
		return	FALSE ;
	}

	POSITION	pos = pNamereflist->GetHeadPosition() ;

	LPSTR	lpstrArg = multiszCommandLine ;
	while( lpstrArg != 0 && *lpstrArg != '\0' ) {
		
		LPSTR	lpstrColon = strchr( lpstrArg, ':' ) ;
		if( lpstrColon == 0 ) {
			

		}	else	{
			*lpstrColon = '\0' ;
			_strlwr( lpstrArg ) ;
			CGRPCOREPTR	pGroup = pNewstree->GetGroup( lpstrArg, (int)(lpstrColon-lpstrArg) ) ;
			*lpstrColon++ = ':' ;
			if( pGroup ) {
				
				LPSTR	lpstrCheckDigits = lpstrColon ;
				while( *lpstrCheckDigits ) {
					if( !isdigit( (UCHAR)*lpstrCheckDigits ++ ) ) 	{
						nntpReturn.fSet( nrcSyntaxError ) ;
						return	FALSE ;
					}
				}	

				CPostGroupPtr pPostGroupPtr(pGroup);

				grouplist.AddTail( pPostGroupPtr ) ;
				
				NAME_AND_ARTREF		NameRef ;

				//
				// Only I from master care about the compare key, which
				// is the pointer to the vroot, because incoming xref
				// line from master has no knowledge of our vroots, and
				// they might not be ordered by vroots.  Just as we will sorted
				// grouplist based on vroots, we'll also sort nameref list
				// based on vroot.  So we are setting the compare key here
				//
				NameRef.artref.m_compareKey = pGroup->GetVRootWithoutRef();
				NameRef.artref.m_groupId = pGroup->GetGroupId() ;
				NameRef.pcName.vInsert(pGroup->GetName()) ;
				NameRef.artref.m_articleId = (ARTICLEID)atoi( lpstrColon ) ;

				pGroup->InsertArticleId( NameRef.artref.m_articleId ) ;

				pNamereflist->AddTail(NameRef ) ;

			}
		}
		lpstrArg += lstrlen( lpstrArg ) + 1 ;
	}

	return nntpReturn.fSetOK();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\nntp\server\post\src\nntpsupp.cpp ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    nntpsupp.cpp

Abstract:

    This module contains support routines for the Tigris server

Author:

    Johnson Apacible (JohnsonA)     18-Sept-1995

Revision History:

--*/

#include "stdinc.h"

DWORD
NntpGetTime(
    VOID
    )
{
    NTSTATUS      ntStatus;
    LARGE_INTEGER timeSystem;
    DWORD         cSecondsSince1970 = 0;

    ntStatus = NtQuerySystemTime( &timeSystem );
    if( NT_SUCCESS(ntStatus) ) {
        RtlTimeToSecondsSince1970( &timeSystem, (PULONG)&cSecondsSince1970 );
    }

    return cSecondsSince1970;

} // NntpGetTime

BOOL
IsIPInList(
    IN PDWORD IPList,
    IN DWORD IPAddress
    )
/*++

Routine Description:

    Check whether a given IP is in a given list

Arguments:

    IPList - The list where the IP address is to checked against.
    IPAddress - The ip address to be checked.

Return Value:

    TRUE, if the IPAddress is in to IPList
    FALSE, otherwise.

--*/
{

    DWORD i = 0;

    //
    // If the list is empty, then there's no master.
    //

    if ( IPList == NULL ) {
        return(FALSE);
    }

    //
    // ok, search the list for it
    //

    while ( IPList[i] != INADDR_NONE ) {

        if ( IPList[i] == IPAddress ) {
            return(TRUE);
        }
        ++i;
    }

    //
    // Not found. ergo, not a master
    //

    return(FALSE);

} // IsIPInList


DWORD
multiszLength(
			  char const * multisz
			  )
 /*
   returns the length of the multisz
   INCLUDING all nulls
 */
{
	char * pch;
	for (pch = (char *) multisz;
		!(pch[0] == '\0' && pch[1] == '\0');
		pch++)
	{};

	return (DWORD)(pch + 2 - multisz);

}

const char *
multiszCopy(
			char const * multiszTo,
			const char * multiszFrom,
			DWORD dwCount
			)
{
	const char * sz = multiszFrom;
	char * mzTo = (char *) multiszTo;
	do
	{
		// go to first char after next null
		while ((DWORD)(sz-multiszFrom) < dwCount && '\0' != sz[0])
			*mzTo++ = *sz++;
		if ((DWORD)(sz-multiszFrom) < dwCount )
			*mzTo++ = *sz++;
	} while ((DWORD)(sz-multiszFrom) < dwCount && '\0' != sz[0]);
	if( (DWORD)(sz-multiszFrom) < dwCount ) {
		*mzTo++ = '\0' ;
	}

    return multiszTo;
}

// no longer does lower-case - we preserve the newsgroup case
char *
szDownCase(
		   char * sz,
		   char * szBuf
		   )
{
	char * oldSzBuf = szBuf;
	for (;*sz; sz++)
		*(szBuf++) = (*sz); // tolower(*sz);
	*szBuf = '\0';
	return oldSzBuf;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\nntp\server\post\src\makefile.inc ===
$(O)\seo.h $(O)\seo_i.c : $(STAXINC)\export\seo.idl
    $(MIDL) \
    $(PACKING) \
    $(INCPATH0) \
    -char unsigned \
    -ms_ext -c_ext \
    -proxy $(PASS0_SOURCEDIR)\seo_p.c \
    -dlldata $(PASS0_SOURCEDIR)\dlldata.c \
    -iid $(MIDL_UUIDDIR)\seo_i.c \
    -header $@ \
    -tlb $(O)\seo.tlb \
    -cpp_cmd $(TARGET_CPP) \
    $(C_DEFINES) \
    $(MIDL_FLAGS) \
    $(MIDL_OPTIMIZATION) \
    $**

$(O)\nntpfilt.h $(O)\nntpfilt_i.c : $(STAXNNTP)\core\include\nntpfilt.idl
    $(MIDL) \
    $(PACKING) \
    $(INCPATH0) \
    -char unsigned \
    -ms_ext -c_ext \
    -proxy $(PASS0_SOURCEDIR)\nntpfilt_p.c \
    -dlldata $(PASS0_SOURCEDIR)\dlldata.c \
    -iid $(MIDL_UUIDDIR)\nntpfilt_i.c \
    -header $@ \
    -tlb $(O)\nntpfilt.tlb \
    -cpp_cmd $(TARGET_CPP) \
    $(C_DEFINES) \
    $(MIDL_FLAGS) \
    $(MIDL_OPTIMIZATION) \
    $**

$(O)\cdo.h $(O)\cdo_i.c : $(STAXINC)\cdo.idl
    $(MIDL) \
    $(PACKING) \
    $(INCPATH0) \
    -char unsigned \
    -ms_ext -c_ext \
    -proxy $(PASS0_SOURCEDIR)\cdo_p.c \
    -dlldata $(PASS0_SOURCEDIR)\dlldata.c \
    -iid $(MIDL_UUIDDIR)\cdo_i.c \
    -header $@ \
    -tlb $(O)\cdo.tlb \
    -cpp_cmd $(TARGET_CPP) \
    $(C_DEFINES) \
    $(MIDL_FLAGS) \
    $(MIDL_OPTIMIZATION) \
    $**

$(O)\mailmsg.h $(O)\mailmsg_i.c : $(STAXINC)\export\mailmsg.idl
    $(MIDL) \
    $(PACKING) \
    $(INCPATH0) \
    -char unsigned \
    -ms_ext -c_ext \
    -proxy $(PASS0_SOURCEDIR)\mailmsg_p.c \
    -dlldata $(PASS0_SOURCEDIR)\dlldata.c \
    -iid $(MIDL_UUIDDIR)\mailmsg_i.c \
    -header $@ \
    -tlb $(O)\mailmsg.tlb \
    -cpp_cmd $(TARGET_CPP) \
    $(C_DEFINES) \
    $(MIDL_FLAGS) \
    $(MIDL_OPTIMIZATION) \
    $**

$(O)\mailmsgi.h $(O)\mailmsgi_i.c : $(STAXINC)\export\mailmsgi.idl
    $(MIDL) \
    $(PACKING) \
    $(INCPATH0) \
    -char unsigned \
    -ms_ext -c_ext \
    -proxy $(PASS0_SOURCEDIR)\mailmsgi_p.c \
    -dlldata $(PASS0_SOURCEDIR)\dlldata.c \
    -iid $(MIDL_UUIDDIR)\mailmsgi_i.c \
    -header $@ \
    -tlb $(O)\mailmsgi.tlb \
    -cpp_cmd $(TARGET_CPP) \
    $(C_DEFINES) \
    $(MIDL_FLAGS) \
    $(MIDL_OPTIMIZATION) \
    $**

$(O)\nntpmsg.h: ..\..\server\nntpmsg.mc
    mc -v -r $(O) -h $(O) $**
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\nntp\server\post\src\infeed.cpp ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    infeed.cpp

Abstract:

    This module contains definition for the CInFeed base class

Author:

    Carl Kadie (CarlK)     01-Oct-1995

Revision History:

--*/

#include "stdinc.h"
//#include "smtpdll.h"
#include "drvid.h"

//
///!!! is this the best place for this???
//

const time_t INVALID_TIME = (time_t) -1;

//
// The largest allowed xover line.
//

const DWORD cchXOverMax = 3400;

//
// Max warnings to log on moderated post failures
//
#define MAX_EVENTLOG_WARNINGS	9

//
//If some of these look very simple, make them inline!!!!
//

//const   unsigned    cbMAX_FEED_SIZE = MAX_FEED_SIZE ;

HANDLE GetNtAnonymousToken() {
    TraceFunctEnter("GetNtAnonymousToken");

    HANDLE  hToken = NULL;

    //  Impersonate Anonymous token on this thread
    if (!ImpersonateAnonymousToken(GetCurrentThread()))
    {
        DWORD   dw = GetLastError();
        ErrorTrace(0, "ImpersonateAnonymousToken() failed %x", dw);
        return NULL;
    }

    //  Get current thread token
    if (!OpenThreadToken(GetCurrentThread(), TOKEN_QUERY | TOKEN_DUPLICATE | TOKEN_IMPERSONATE, TRUE, &hToken))
    {
        ErrorTrace(0, "OpenThreadToken() failed %x", GetLastError());
        // fall through to RevertToSelf
    }

    //  Revert to self
    RevertToSelf();

    return hToken;

}

void SelectToken(
	CSecurityCtx *pSecurityCtx,
	CEncryptCtx *pEncryptCtx,
	HANDLE *phToken)
{

	//
	// Set the token.  Note that it might be overwritten below, but we want to
	// have a default value in case it isn't.
	//

	if ( pEncryptCtx && pEncryptCtx->QueryCertificateToken() )
		*phToken = pEncryptCtx->QueryCertificateToken();
	else if ( pSecurityCtx && pSecurityCtx->QueryImpersonationToken() ) {
		*phToken = pSecurityCtx->QueryImpersonationToken();
	} else
		*phToken = NULL;

}

void
SaveGroupList(	char*	pchGroups,
				DWORD	cbGroups,
				CNEWSGROUPLIST&	grouplist ) {

	_ASSERT( pchGroups != 0 ) ;
	_ASSERT( cbGroups > 0 ) ;

	DWORD	ib = 0 ;

	POSITION	pos = grouplist.GetHeadPosition() ;
	if( grouplist.IsEmpty() ) {
		pchGroups[0] = '\0' ;
	}	else	{
		while( pos ) {
			CPostGroupPtr *pPostGroupPtr = grouplist.GetNext(pos);
			CGRPCOREPTR group = pPostGroupPtr->m_pGroup;

			LPSTR	lpstr = group->GetName() ;
			DWORD	cb = lstrlen( lpstr ) ;

			if( (ib + cb + 1) < cbGroups ) {
				CopyMemory( pchGroups+ib, lpstr, cb ) ;
			}	else	{
				pchGroups[ib-1] = '\0' ;
				return	 ;
			}
			ib+=cb ;
			pchGroups[ib++] = ' ' ;
		}
		pchGroups[ib-1] = '\0' ;
	}
}


void
CInFeed::LogFeedEvent(	DWORD	messageId,	LPSTR	lpstrMessageId, DWORD dwInstanceId )	{
#ifdef BUGBUG

	PCHAR	rgArgs[3] ;
	CHAR    szId[20];

	_itoa( dwInstanceId, szId, 10 );
	rgArgs[0] = szId ;
	rgArgs[1] = ServerNameFromCompletionContext( m_feedCompletionContext ) ;
	rgArgs[2] = lpstrMessageId ;

	if( rgArgs[1] == 0 ) {
		rgArgs[1] = "<UNKNOWN>" ;
	}

	if( m_cEventsLogged < 100 ) {

		NntpLogEvent(
				messageId,
				3,
				(const CHAR **)rgArgs,
				0 ) ;


	}	else	if(	m_cEventsLogged == 100 ) {

		//
		//	Log the too many logs this session message !
		//

		NntpLogEvent(
				NNTP_EVENT_TOO_MANY_FEED_LOGS,
				3,
				(const CHAR **)rgArgs,
				0 ) ;

	}
	m_cEventsLogged ++ ;
#endif

}

//
//	K2_TOD: should make this a member of NNTP_SERVER_INSTANCE ?
//

BOOL
gFeedManfPost(
			  CNntpServerInstanceWrapper * pInstance,
			  CNEWSGROUPLIST& newsgroups,
			  CNAMEREFLIST& namerefgroups,
			  class	CSecurityCtx*	pSecurity,
			  BOOL	fIsSecure,
			  CArticle* pArticle,
			  CStoreId *rgStoreIds,
			  BYTE *rgcCrossposts,
			  DWORD cStoreIds,
			  const CPCString & pcXOver,
			  CNntpReturn & nntpReturn,
			  DWORD dwFeedId,
			  char *pszMessageId,
			  WORD HeaderLength
			  )
/*++

Routine Description:

	Puts an article in the news tree.

	!!! this should be made part of feedman eventually


Arguments:

	pInstance - virtual server instance for this post
	newsgroups - a list of newsgroup objects to post to.
	namerefgroups - a list of the names, groupid and article ids of the article
	pArticle - a pointer to the article being processed
	pcXOver - the XOver data from this article.
	nntpReturn - The return value for this function call


Return Value:

	TRUE, if successful. FALSE, otherwise.

--*/
{
    TraceQuietEnter("gFeedManfPost");

	_ASSERT(newsgroups.GetCount() == namerefgroups.GetCount()); //real
	_ASSERT(1 <= newsgroups.GetCount()); //real
	nntpReturn.fSetClear(); // clear the return object

	//
	// Get the article's messageid
	//

	const char *szMessageID;
	if (pszMessageId) {
		_ASSERT(pArticle == NULL);
		szMessageID = pszMessageId;
	} else {
		_ASSERT(pArticle);
		szMessageID = pArticle->szMessageID();
	}
	DWORD	cbMessageID = lstrlen( szMessageID ) ;

	//
	// Loop through all the newsgroups, but get the 1st newsgroup first
	// because it is a special case.
	//

	POSITION	pos1 = newsgroups.GetHeadPosition() ;
	POSITION	pos2 = namerefgroups.GetHeadPosition() ;

	CPostGroupPtr *pPostGroupPtr = newsgroups.GetNext(pos1);
	CGRPCOREPTR pGroup = pPostGroupPtr->m_pGroup;
	NAME_AND_ARTREF * pNameRef = namerefgroups.GetNext( pos2 ) ;
	CArticleRef * pArtrefFirst = &(pNameRef->artref);

    //
    // If the length of the header is zero, see if we have it in pArticle.
    //
	WORD	HeaderOffset = 0 ;
	if (HeaderLength == 0 && pArticle) {
		DWORD	ArticleSize = 0 ;
		pArticle->GetOffsets(	HeaderOffset,
								HeaderLength,
								ArticleSize ) ;
	}

	//
	// Record the location of this article in the hash table
	//

	if (!(pInstance->ArticleTable())->SetArticleNumber(
                szMessageID,
				HeaderOffset,
				HeaderLength,
                pArtrefFirst->m_groupId,
                pArtrefFirst->m_articleId,
				rgStoreIds[0]
                )) {

        //
        //  If this fails, we end up with orphaned NWS files in the
        //  newsgroup. So, delete the file we just inserted...
        //

		if ( pGroup->DeletePhysicalArticle( pArtrefFirst->m_articleId ) )
		{
			DebugTrace(0,"Group %s ArticleId %d - SetArticleNumber failed - phy article deleted", pGroup->GetName(), pArtrefFirst->m_articleId);
		}
		else
		{
			ErrorTrace(0,"Could not delete phy article: GroupId %s ArticleId %d", pGroup->GetName(), pArtrefFirst->m_articleId);
		}

		return nntpReturn.fSet(nrcHashSetArtNumSetFailed,
                pArtrefFirst->m_groupId,
                pArtrefFirst->m_articleId,
                szMessageID,
				GetLastError());
    }

	FILETIME	FileTime ;
	GetSystemTimeAsFileTime( &FileTime ) ;

	//
	// Record the articles Xover information
	//
    DWORD       cXPosts = namerefgroups.GetCount() - 1 ;
    GROUP_ENTRY *pGroups = 0 ;
    if( cXPosts > 0 ) {
		if (pArticle) {
	        pGroups =  (GROUP_ENTRY*)pArticle->pAllocator()->Alloc( cXPosts * sizeof(GROUP_ENTRY) ) ;
		} else {
			pGroups = XNEW GROUP_ENTRY[cXPosts];
		}
	}
    if( pGroups ) {

    	POSITION	pos3 = namerefgroups.GetHeadPosition() ;
        NAME_AND_ARTREF *pNameRefTemp = namerefgroups.GetNext( pos3 ) ;
        for( DWORD i=0; i<cXPosts; i++ ) {

            pNameRefTemp = namerefgroups.GetNext(pos3) ;
            pGroups[i].GroupId = pNameRefTemp->artref.m_groupId ;
            pGroups[i].ArticleId = pNameRefTemp->artref.m_articleId ;

        }


    }

    BOOL    fCreateSuccess =  (pInstance->XoverTable())->CreatePrimaryNovEntry(
                        pArtrefFirst->m_groupId,
			            pArtrefFirst->m_articleId,
						HeaderOffset,
						HeaderLength,
						&FileTime,
						szMessageID, /*pcXOver.m_pch,*/
						cbMessageID, /*pcXOver.m_cch,*/
                        cXPosts,
                        pGroups,
						cStoreIds,
						rgStoreIds,
						rgcCrossposts
                        ) ;

    DWORD gle = NO_ERROR;

    if (!fCreateSuccess)
        gle = GetLastError();

    if( pGroups ) {
		if (pArticle) {
	        pArticle->pAllocator()->Free( (char*)pGroups ) ;
		} else {
			XDELETE[] pGroups;
		}
    }

    if( !fCreateSuccess )   {

		// If CreateNovEntry Fails, the GLE should not be 0
		//_ASSERT(0 != GetLastError());
        SetLastError(gle);
        ErrorTrace(0, "CreatePrimaryNovEntry failed, %x", GetLastError());

		return nntpReturn.fSet(
                    nrcCreateNovEntryFailed,
                    pArtrefFirst->m_groupId,
                    pArtrefFirst->m_articleId,
			    	GetLastError()
                    );
	}

    //
    // Insert primary article succeeded, we'll bump article count
	//
	pGroup->BumpArticleCount( pArtrefFirst->m_articleId );

	//
	// If there no newsgroups, then we are done.
	//

	DWORD cLastRest = namerefgroups.GetCount();
	if (1 == cLastRest)	{

		return nntpReturn.fSetOK();
	}

	//
	// there must be some more newsgroups.
	// Allocate some space for them
	//

	GROUPID * rgGroupID = //!!~MEM(GROUPID *) (pArticle->pAllocator())->Alloc(sizeof(GROUPID) * cLastRest);
						XNEW GROUPID[cLastRest];
	if (!rgGroupID)
		return nntpReturn.fSet(nrcMemAllocationFailed, __FILE__, __LINE__);


	gFeedManfPostInternal(pInstance, newsgroups, namerefgroups, pcXOver,
				pos1, pos2, &pGroup, pNameRef, pArtrefFirst,
				szMessageID, rgGroupID,
				HeaderOffset, HeaderLength, FileTime, nntpReturn
				);

	//
	// No matter what, dellocate that memory
	//

    gle = GetLastError();
	//!!!MEM (pArticle->pAllocator())->Free((char *)rgGroupID);
	XDELETE[]rgGroupID;
    SetLastError(gle);

	return nntpReturn.fIsOK();
}

//
//	K2_TOD: should make this a member of NNTP_SERVER_INSTANCE ?
//

BOOL
gFeedManfPostInternal(
			  CNntpServerInstanceWrapper * pInstance,
			  CNEWSGROUPLIST& newsgroups,
			  CNAMEREFLIST& namerefgroups,
			  const CPCString & pcXOver,
			  POSITION & pos1,
			  POSITION & pos2,
			  CGRPCOREPTR * ppGroup,
			  NAME_AND_ARTREF * pNameRef,
			  CArticleRef * pArtrefFirst,
			  const char * szMessageID,
			  GROUPID * rgGroupID,
			  WORD	HeaderOffset,
			  WORD	HeaderLength,
			  FILETIME FileTime,
  			  CNntpReturn & nntpReturn
			  )
/*++

Routine Description:

	Does most of the work of puting an article in the news tree.

	!!! this should be made part of feedman eventually


Arguments:

	pInstance - virtual server instance
	newsgroups - a list of newsgroup objects to post to.
	namerefgroups - a list of the names, groupid and article ids of the article
	pArticle - a pointer to the article being processed
	pcXOver - the XOver data from this article.
	ppGroup - a pointer to the group pointer
	pNameRef - a pointer to the name, group id, and article id
	pArtrefFirst - a pointer groupid/articleid of the first group
	szMessageID - the article's message id
	rgGroupID - an array of group id's
	FileTime - the current time in FILETIME format.
	nntpReturn - The return value for this function call


Return Value:

	TRUE, if successful. FALSE, otherwise.

--*/
{

    TraceQuietEnter("gFeedManfPostInternal");

	DWORD cRest = 0;
    BOOL  fSuccess = TRUE;
	while( pos1) {

		_ASSERT(pos2);
		CPostGroupPtr *pPostGroupPtr = newsgroups.GetNext(pos1);
		ppGroup = &(pPostGroupPtr->m_pGroup);
		pNameRef = namerefgroups.GetNext( pos2 ) ;
		if (!(* ppGroup)->AddReferenceTo((pNameRef->artref).m_articleId, *pArtrefFirst))
		{
			char szName[MAX_PATH];
			(pNameRef->pcName).vCopyToSz(szName, MAX_PATH);

            //  Set failure codes and continue processing -
            //  Error paths will cleanup this article.
			nntpReturn.fSet(nrcNewsgroupAddRefToFailed,	szName, szMessageID);
            fSuccess = FALSE;
		}

		//
		// append this groupid to a list
		//

		rgGroupID[cRest++] = (pNameRef->artref).m_groupId;
	}

    //
    // Bail if we encountered an error while adding refs to logical groups
    //
    if( !fSuccess ) {
        _ASSERT( !nntpReturn.fIsOK() );
        ErrorTrace(0, "AddRef failed for %s", szMessageID);
        return FALSE ;
    }

	//
	// Record the articles Xover information for the remaining newsgroups
	//

	pos2 = namerefgroups.GetHeadPosition() ;
	namerefgroups.GetNext( pos2 ) ;

	//
	// Get the newstree object, to get group by id
	//
	CNewsTreeCore *pTree = pInstance->GetTree();
	_ASSERT( pTree );

	while( pos2) {
		pNameRef = namerefgroups.GetNext( pos2 ) ;
		CArticleRef * pArtref = &(pNameRef->artref);

		//
		// If the group has already been deleted, don't bother to create nov
		// entry for him
		//
		CGRPCOREPTR pGroup = pTree->GetGroupById( pArtref->m_groupId, TRUE );
		if ( pGroup ) {
		    if (!(pInstance->XoverTable())->CreateXPostNovEntry(pArtref->m_groupId,
			    				pArtref->m_articleId,
				    			HeaderOffset,
					    		HeaderLength,
						    	&FileTime,
                                pArtrefFirst->m_groupId,
                                pArtrefFirst->m_articleId
                                )) {
                ErrorTrace(0, "CreateXPostNovEntry failed %x", GetLastError());
		    	return nntpReturn.fSet(nrcCreateNovEntryFailed,
			    		pArtref->m_groupId,
				    	pArtref->m_articleId,
					    GetLastError());
		    } else {

		        //
		        // Insert succeeded, we'll bump the article count for this group
		        //
		        pGroup->BumpArticleCount( pArtref->m_articleId );
		    }
		}
	}



	//
	// Everything is OK, so set return code
	//

	return nntpReturn.fSetOK();
}




char *
CInFeed::szTempDirectory( void )

/*++

Routine Description:

	Returns the name of the temp directory in which incomming articles
	should be placed.

Arguments:

	None.

Return Value:

	The name of the temp directory.

--*/
{
	return m_szTempDirectory;
} //!!!make inline


DWORD
CInFeed::cInitialBytesGapSize(
					 void
					 )
/*++

Routine Description:

	Returns the size of the gap in the files of incomming articles.


Arguments:

	None.

Return Value:

	The gap size.

--*/
{
	return m_cInitialBytesGapSize;
}


BOOL CInFeed::MailMsgAddAsyncHandle(PATQ_CONTEXT      *ppatqContext,
                                    PVOID             pEndpointObject,
                                    PVOID             pClientContext,
                                    ATQ_COMPLETION    pfnCompletion,
                                    DWORD             cTimeout,
                                    HANDLE            hAsyncIO)
{
	_ASSERT(ppatqContext != NULL);
	_ASSERT(hAsyncIO != INVALID_HANDLE_VALUE);
	if (ppatqContext == NULL || hAsyncIO == INVALID_HANDLE_VALUE) {
		SetLastError(ERROR_INVALID_PARAMETER);
		return FALSE;
	}
	*ppatqContext = (PATQ_CONTEXT) AssociateFile(hAsyncIO);
	return (*ppatqContext != NULL);
}

void CInFeed::MailMsgFreeContext(PATQ_CONTEXT     pAtqContext,
                                 BOOL             fReuseContext)
{
	ReleaseContext((FIO_CONTEXT *) pAtqContext);
}

CPostContext::CPostComplete::CPostComplete(CInFeed *pInFeed,
										   CPostContext *pContext,
										   INntpComplete *pPostCompletion,
										   BOOL fAnonymous,
										   DWORD &dwSecondary,
										   CNntpReturn &nntpReturn)
  : m_pInFeed(pInFeed),
	m_pContext(pContext),
	m_pPostCompletion(pPostCompletion),
	m_fAnonymous(fAnonymous),
	m_dwSecondary(dwSecondary),
	m_nntpReturn(nntpReturn),
	CNntpComplete()
{
    m_fWriteMapEntries = TRUE;
}

void CPostContext::CPostComplete::Destroy() {
	HRESULT hr = GetResult();

	//
	// see if we are either done or have hit in an error.  in both cases
	// we need to go through WriteMapEntries to properly set the NNTP
	// error code
	//

        //  make sure we have Read Acess to the m_pArticle pointer.
        _ASSERT( IsBadReadPtr( (void *) (m_pContext->m_pArticle), sizeof(m_pContext->m_pArticle) ) == 0 );
        _ASSERT( m_pContext->m_pArticle != NULL );
	if (FAILED(hr) || m_pContext->m_cStoreIds == m_pContext->m_cStores) {
	    INntpComplete *pPostCompletion = m_pPostCompletion;

            pPostCompletion->SetResult( hr );
            if ( SUCCEEDED( hr ) && m_fWriteMapEntries ) {
    		BOOL f = m_pInFeed->WriteMapEntries(hr,
                                                    m_pContext,
                                                    m_dwSecondary,
                                                    m_nntpReturn
                                                    );
		pPostCompletion->SetResult( f ? S_OK : E_ABORT );
            } else if ( FAILED( hr )  )  {
                //  fix 600 return code when async post fail in the Store
                CNntpReturn ret;
                ret.fSet(nrcNewsgroupInsertFailed, NULL, NULL);
                m_nntpReturn.fSet(nrcPostFailed, ret.m_nrc, ret.szReturn());
            }

            //
            // Whether we succeeded or not, we'll release the post context
            //
            _ASSERT( m_pContext );
            m_pContext->Release();
            pPostCompletion->Release();
	} else {
            // in this case there are more stores to post to.
            _ASSERT(m_pContext->m_cStoreIds < m_pContext->m_cStores);

            CNntpComplete::Reset();
            m_pVRoot->Release();
            m_pVRoot = NULL;

            //
            // Passing in NULL is fine, since sfromcl guy should never come here
            //
            m_pInFeed->CommitPostToStores(m_pContext, NULL);
	}
}

BOOL
CInFeed::PostEarly(
		CNntpServerInstanceWrapper			*pInstance,
		CSecurityCtx                        *pSecurityCtx,
		CEncryptCtx                         *pEncryptCtx,
		BOOL								fAnonymous,
		const LPMULTISZ						szCommandLine,
		CBUFPTR								&pbufHeaders,
		DWORD								iHeadersOffset,
		DWORD								cbHeaders,
		DWORD								*piHeadersOutOffset,
		DWORD								*pcbHeadersOut,
		PFIO_CONTEXT						*ppFIOContext,
		void								**ppvContext,
		DWORD								&dwSecondary,
		DWORD								dwRemoteIP,
		CNntpReturn							&nntpReturn,
		char                                *pszNewsgroups,
		DWORD                               cbNewsgroups,
		BOOL								fStandardPath,
		BOOL								fPostToStore)
{
	TraceFunctEnter("CInFeed::PostEarly");

	CNntpReturn ret2;
	CPostContext *pContext = NULL;
	HRESULT hr;

	_ASSERT(pInstance);
	_ASSERT(pbufHeaders);
	_ASSERT(cbHeaders > 0);
	*ppFIOContext = NULL;

	pInstance->BumpCounterArticlesReceived();

	// create our context pointer and article object
	pContext = XNEW CPostContext(this,
								0,
								pInstance,
								pSecurityCtx,
								pEncryptCtx,
								fAnonymous,
								pbufHeaders,
								cbHeaders,
								fStandardPath,
								dwSecondary,
								nntpReturn);
	if (pContext) pContext->m_pArticle = pArticleCreate();
	if (pContext == NULL || pContext->m_pArticle == NULL) {
		if (pContext) {
			pContext->Release();
			pContext = NULL;
		}
		pbufHeaders = NULL;
		ret2.fSet(nrcMemAllocationFailed, __FILE__, __LINE__);
		_ASSERT(*ppFIOContext == NULL);
		return	nntpReturn.fSet(nrcArticleRejected(fStandardPath),
								ret2.m_nrc, ret2.szReturn());
	}


    //
    // Create the mail message using instance's class factory
    //
    hr = pInstance->CreateMailMsgObject( &pContext->m_pMsg );
    /*
	hr = CoCreateInstance((REFCLSID) clsidIMsg,
		                       NULL,
		                       CLSCTX_INPROC_SERVER,
		                       (REFIID) IID_IMailMsgProperties,
		                       (void**)&pContext->m_pMsg );
    */
	if (FAILED(hr)) {
		pContext->m_pArticle->vClose();
		pContext->Release();
		ret2.fSet(nrcMemAllocationFailed, __FILE__, __LINE__);
		pbufHeaders = NULL;
		_ASSERT(*ppFIOContext == NULL);
		return	nntpReturn.fSet(nrcArticleRejected(fStandardPath),
								ret2.m_nrc, ret2.szReturn());
	}

	if (!pContext->m_pArticle->fInit(pbufHeaders->m_rgBuff + iHeadersOffset,
									 cbHeaders,
									 cbHeaders,
									 cbHeaders,
									 &(pContext->m_allocator),
									 pInstance,
									 ret2))
	{
		dwSecondary = ret2.m_nrc;
		pContext->Release();
		pbufHeaders = NULL;
		_ASSERT(*ppFIOContext == NULL);
		return nntpReturn.fSet(nrcArticleRejected(fStandardPath),
							   ret2.m_nrc, ret2.szReturn());
	}

	if (!fPostInternal(pInstance,
					   szCommandLine,
					   pSecurityCtx,
					   pEncryptCtx,
					   pContext->m_fAnonymous,
					   pContext->m_pArticle,
					   pContext->m_grouplist,
					   pContext->m_namereflist,
					   pContext->m_pMsg,
					   pContext->m_allocator,
					   pContext->m_multiszPath,
					   pszNewsgroups,
					   cbNewsgroups,
					   dwRemoteIP,						// XXX: REMOTE IP ADDR
					   ret2,
					   ppFIOContext,
					   &(pContext->m_fBound),
					   &(pContext->m_dwOperations),
					   &(pContext->m_fPostToMod),
					   pContext->m_szModerator ))
	{
		//
		// Moves the message id (if any) to the history table.
		// Unless the message id was a duplicate, or due to HashSetFailed.
        // But we also want to move mid if HashSetFailed is due to moving
        // into history table, which is returned by CANCEL or expiration.
		//
		const char *szMessageID = pContext->m_pArticle->szMessageID();

		if (szMessageID[0] != 0 &&
			!ret2.fIs(nrcArticleDupMessID) &&
		    ((!ret2.fIs(nrcHashSetFailed)) ? TRUE : (NULL != strstr(ret2.szReturn(), "History"))))
		{
 			fMoveMessageIDIfNecc(pInstance, szMessageID, nntpReturn, NULL, FALSE);
		}

		dwSecondary = ret2.m_nrc;
		pContext->Release();
		pbufHeaders = NULL;
		_ASSERT(*ppFIOContext == NULL);
		return nntpReturn.fSet(nrcArticleRejected(fStandardPath),
							   ret2.m_nrc, ret2.szReturn());
	}

	pContext->m_pFIOContext = *ppFIOContext;


	*piHeadersOutOffset = iHeadersOffset;

	//
	//	Figure out whether the headers were left in our IO buffer, if so then we
	//	don't need to do much !
	//
	if (pContext->m_pArticle->FHeadersInIOBuff(pbufHeaders->m_rgBuff,
											   pbufHeaders->m_cbTotal))
	{
		*pcbHeadersOut = pContext->m_pArticle->GetHeaderPosition(pbufHeaders->m_rgBuff,
																 pbufHeaders->m_cbTotal,
																 *piHeadersOutOffset);
		_ASSERT(*piHeadersOutOffset >= iHeadersOffset);
	}	else	{
		// see if the headers will fit into the buffer
		*pcbHeadersOut = pContext->m_pArticle->GetHeaderLength( );

		if (*pcbHeadersOut > (pbufHeaders->m_cbTotal - iHeadersOffset)) {
			*piHeadersOutOffset = 0 ;
			// there isn't enough space.  Lets allocate a larger buffer
			DWORD cbOut = 0;
			pbufHeaders = new (*pcbHeadersOut,
			  				   cbOut,
							   CBuffer::gpDefaultSmallCache,
							   CBuffer::gpDefaultMediumCache)
							   CBuffer (cbOut);
			if (pbufHeaders == NULL ||
				pbufHeaders->m_cbTotal < *pcbHeadersOut)
			{
				PostCancel(pContext, dwSecondary, nntpReturn);
				pContext->m_pFIOContext = *ppFIOContext = NULL;
				ret2.fSet(nrcMemAllocationFailed, __FILE__, __LINE__);
				pbufHeaders = NULL;
				return nntpReturn.fSet(nrcArticleRejected(fStandardPath),
								   	   ret2.m_nrc, ret2.szReturn());
			}
		}

		// copy the headers out of the article back into the buffer
		pContext->m_pArticle->CopyHeaders(pbufHeaders->m_rgBuff + *piHeadersOutOffset);
	}

	nntpReturn.fSetOK();

	*ppvContext = pContext;

	return TRUE;
}

BOOL
CInFeed::ShouldBeSentToModerator(   CNntpServerInstanceWrapper *pInstance,
                                    CPostContext *pContext )
/*++
Routine description:

    Check to see if we were to be posted to a moderated group

Argument:

    CNntpServerInstanceWrapper *pInstance   - The server instance wrapper
    CPostContext *pContext                  - The post context

Return value:

    TRUE if we were to be posted to a moderated group, FALSE otherwise
--*/
{
    TraceFunctEnter( "CInFeed::ShouldBeSentToModerator" );
    _ASSERT( pInstance );
    _ASSERT( pContext );
#ifdef DEBUG
    if ( pContext->m_fPostToMod ) {
        POSITION	pos = pContext->m_grouplist.GetHeadPosition();
        _ASSERT( pos );
		CPostGroupPtr *pPostGroupPtr = pContext->m_grouplist.GetNext(pos);
		CGRPCOREPTR pGroup1 = pPostGroupPtr->m_pGroup;
		_ASSERT( pGroup1 );
		CNewsTreeCore *pTree = pInstance->GetTree();
		_ASSERT( pTree );
        CGRPCOREPTR pGroup2 = pTree->GetGroupById( pTree->GetSlaveGroupid() );
        _ASSERT( pGroup2 );
        _ASSERT( pGroup1 == pGroup2 );
    }
#endif
    return pContext->m_fPostToMod;
}

BOOL
CInFeed::SendToModerator(   CNntpServerInstanceWrapper *pInstance,
                            CPostContext *pContext )
/*++
Routine description:

    Send the article to the moderator

Arguments:

    CNntpServerInstanceWrapper  *pInstance  - Server instance wrapper
    CPostContext                *pContext   - Post context

Return value:

    TRUE if succeeded, FALSE otherwise
--*/
{
    TraceFunctEnter( "CInFeed::SendToModerator" );
    _ASSERT( pInstance );
    _ASSERT( pContext );

    //
    // Get the group object from post context
    //
    POSITION    pos = pContext->m_grouplist.GetHeadPosition();
    _ASSERT( pos );
    CPostGroupPtr *pPostGroupPtr = pContext->m_grouplist.GetNext(pos);
    _ASSERT( pPostGroupPtr );
    CGRPCOREPTR pGroup = pPostGroupPtr->m_pGroup;
    _ASSERT( pGroup );

    //
    // Get the article id ( posted to the special group )
    //
	pos = pContext->m_namereflist.GetHeadPosition() ;
	_ASSERT( pos );
	NAME_AND_ARTREF *pNameref = pContext->m_namereflist.GetNext(pos);
	_ASSERT( pNameref );
	if (pNameref == NULL) {
	    return FALSE;
	}
	ARTICLEID artid = pNameref->artref.m_articleId;
	_ASSERT( artid > 0 );

	return pInstance->MailArticle( pGroup, artid, pContext->m_szModerator );
}

void
CInFeed::ApplyModerator( CPostContext   *pContext,
                         CNntpReturn    &nntpReturn )
/*++
Routine description:

    Apply moderator - send the message to moderator

Arguments:

    CPostContext    *pCotnext   - Posting context
    CNntpReturn     &nntpReturn - nntp return

Return value:

    None.
--*/
{
    //
	// We should check for moderator first, if it's a message that needs
	// to be sent to moderator, we should do it here without going any
	// farther
	//
	if ( ShouldBeSentToModerator( pContext->m_pInstance, pContext ) ) {
	    if ( !SendToModerator( pContext->m_pInstance, pContext ) ) {
	        nntpReturn.fSet(nrcPostModeratedFailed, pContext->m_szModerator);
	    } else {
	        nntpReturn.fSetOK();
	    }
	} else nntpReturn.fSetOK();
}

//
// this is called by the protocol when a message is received
//
BOOL
CInFeed::PostCommit(
        CNntpServerInstanceWrapper          *pInstance,
		void								*pvContext,
		HANDLE                              hToken,
		DWORD								&dwSecondary,
		CNntpReturn							&nntpReturn,
		BOOL								fAnonymous,
		INntpComplete*      				pCompletion
		)
{
	CPostContext *pContext = (CPostContext *) pvContext;
	HRESULT hr;
	BOOL    bSyncPost = FALSE;  // this will be taken out when async post is done

    //
    // This is not to be posted to the moderated group, we can go ahead
    //
	hr = TriggerServerEvent(pContext->m_pInstance->GetEventRouter(),
					   		CATID_NNTP_ON_POST,
					   		pContext->m_pArticle,
					   		&(pContext->m_grouplist),
					   		m_dwFeedId,
					   		pContext->m_pMsg);

	if (SUCCEEDED(hr)) {
		//DWORD dwOperations;

		hr = pContext->m_pMsg->GetDWORD(IMSG_NNTP_PROCESSING, &(pContext->m_dwOperations));
		if (SUCCEEDED(hr)) {
			// check to see if they wanted to cancel the post
			if ((pContext->m_dwOperations & NNTP_PROCESS_POST) != NNTP_PROCESS_POST) {
				PostCancel(pvContext, dwSecondary, nntpReturn);
				return	FALSE ;
			}
		}
	}

	pContext->m_hToken = hToken;

	// create a completion object which we'll block on
	pContext->m_completion.m_pPostCompletion = pCompletion ;
	CNntpSyncComplete postcompletion;
	if (pContext->m_completion.m_pPostCompletion == NULL) {
		pContext->m_completion.m_pPostCompletion = &postcompletion;
		bSyncPost = TRUE;
	}

	// figure out how many stores we are dealing with
	DWORD cStores = 0;
	POSITION posGrouplist = pContext->m_grouplist.GetHeadPosition();
	CNNTPVRoot *pThisVRoot = NULL;
	while (posGrouplist != NULL) {
		CPostGroupPtr *pPostGroupPtr = pContext->m_grouplist.GetNext(posGrouplist);
		if (pPostGroupPtr->m_pVRoot != pThisVRoot) {
			pThisVRoot = pPostGroupPtr->m_pVRoot;
			cStores++;
		}
	}

	// let each of the stores save the post.  if this fails then it will
	// back out from all stores that it properly committed to
	pContext->m_cStores = cStores;
	pContext->m_cStoreIds = 0;
	pContext->m_posGrouplist = pContext->m_grouplist.GetHeadPosition();
	pContext->m_pPostGroupPtr = pContext->m_grouplist.GetNext(pContext->m_posGrouplist);
	pContext->m_posNamereflist = pContext->m_namereflist.GetHeadPosition();
	pContext->m_pNameref = pContext->m_namereflist.GetNext(pContext->m_posNamereflist);
	pContext->m_rgStoreIds = (CStoreId *) pContext->m_allocator.Alloc(sizeof(CStoreId) * cStores);
	pContext->m_rgcCrossposts = (BYTE *) pContext->m_allocator.Alloc(sizeof(BYTE) * cStores);
	CommitPostToStores(pContext, pInstance);

	if ( bSyncPost ) {
	    _ASSERT( postcompletion.IsGood() );
	    //
	    // Since this is a Sync event, we'll increase the number of runnable
	    // threads in the Atq pool.
	    //
	    AtqSetInfo(AtqIncMaxPoolThreads, NULL);
		HRESULT hr = postcompletion.WaitForCompletion();
	    AtqSetInfo(AtqDecMaxPoolThreads, NULL);
	}

	return TRUE;
}

BOOL CInFeed::WriteMapEntries(
		HRESULT 							hr,
		CPostContext						*pContext,
		DWORD								&dwSecondary,
		CNntpReturn							&nntpReturn)
{
	CNntpReturn ret2;

	if (SUCCEEDED(hr)) {

		pContext->m_pInstance->BumpCounterArticlesPosted();

		TriggerServerEvent(pContext->m_pInstance->GetEventRouter(),
				   		   CATID_NNTP_ON_POST_FINAL,
				   		   pContext->m_pArticle,
				   		   &(pContext->m_grouplist),
				   		   m_dwFeedId,
				   		   pContext->m_pMsg);

		char szXOver[cchXOverMax];
		CPCString pcXOver(szXOver, cchXOverMax);
		if (pContext->m_pArticle->fXOver(pcXOver, ret2)) {
			if (gFeedManfPost(pContext->m_pInstance,
						  	  pContext->m_grouplist,
						  	  pContext->m_namereflist,
						  	  pContext->m_pSecurityContext,
						  	  !(pContext->m_fAnonymous),
						  	  pContext->m_pArticle,
							  pContext->m_rgStoreIds,
							  pContext->m_rgcCrossposts,
							  pContext->m_cStoreIds,
						  	  pcXOver,
						  	  ret2,
						  	  m_dwFeedId))
			{
				if (pContext->m_pInstance->AddArticleToPushFeeds(
											pContext->m_grouplist,
											pContext->m_pArticle->articleRef(),
											pContext->m_multiszPath,
											ret2))
				{
					ret2.fSetOK();
				}
			}
		}

        //  Only execute control message if Server Event doesn't disable it.
        if (pContext->m_dwOperations & NNTP_PROCESS_CONTROL)
        {
            if (!fApplyControlMessageCommit(pContext->m_pArticle, pContext->m_pSecurityContext, pContext->m_pEncryptContext, pContext->m_fAnonymous, pContext->m_grouplist, &(pContext->m_namereflist), ret2))
            {
			    if( !nntpReturn.fIsOK() )
			    {
				    // bump perfmon counter
				    pContext->m_pArticle->m_pInstance->BumpCounterControlMessagesFailed();
			    }
            }
        }

        if ( pContext->m_dwOperations & NNTP_PROCESS_MODERATOR ) {
                //
                // Send article to moderator if necessary
                //
                pContext->CleanupMailMsgObject();
                ApplyModerator( pContext, ret2 );
        }

        if (!(ret2.fIsOK())) {
			// GUBGUB - back out post
		}
	} else {
		// GUBGUB - unroll succeeded postings?

		ret2.fSet(nrcNewsgroupInsertFailed, NULL, NULL);
	}

	// update nntpReturn as necessary
	dwSecondary = ret2.m_nrc;
	if (ret2.fIsOK()) {
		nntpReturn.fSet(nrcArticleAccepted(pContext->m_fStandardPath));
	} else {

		//
		// Moves the message id (if any) to the history table.
		// Unless the message id was a duplicate, or due to HashSetFailed.
        // But we also want to move mid if HashSetFailed is due to moving
        // into history table, which is returned by CANCEL or expiration.
		//
		const char *szMessageID = pContext->m_pArticle->szMessageID();

		if ('\0' != szMessageID[0] &&
			!ret2.fIs(nrcArticleDupMessID) &&
		    ((!ret2.fIs(nrcHashSetFailed)) ?
				TRUE : (NULL != strstr(ret2.szReturn(), "History"))))
		{
 			fMoveMessageIDIfNecc(pContext->m_pInstance, szMessageID, nntpReturn, pContext->m_hToken, pContext->m_fAnonymous );
		}

		nntpReturn.fSet(nrcArticleRejected(pContext->m_fStandardPath),
			ret2.m_nrc, ret2.szReturn());
	}

	return ret2.fIsOK();
}


//
// this is called by the protocol if a message was cancelled.  we will
// close the message file handle and get rid of the IMailMsgProperties
//
BOOL
CInFeed::PostCancel(
		void								*pvContext,
		DWORD								&dwSecondary,
		CNntpReturn							&nntpReturn)
{
	CPostContext *pContext = (CPostContext *) pvContext;

	CPostGroupPtr *pPostGroupPtr = pContext->m_grouplist.GetHead();
	if (pPostGroupPtr == NULL) {
	    return FALSE;
	}
	IMailMsgStoreDriver *pDriver = pPostGroupPtr->GetStoreDriver();
	HRESULT hr;
	CNntpReturn ret2;

	ret2.fSet(nrcServerEventCancelledPost);

	// we need to release our usage of the file handle
	if (pContext->m_pMsg && pContext->m_fBound) {
		IMailMsgQueueMgmt *pQueueMgmt;
		HRESULT hr;
		hr = pContext->m_pMsg->QueryInterface(IID_IMailMsgQueueMgmt,
									          (void **)&pQueueMgmt);
		if (SUCCEEDED(hr)) {

            //
            // Before we ask mail message to delete it, we'll close
            // the handle forcefully, no one should think this handle
            // is open from now on
            //
            CloseNonCachedFile( pContext->m_pFIOContext );
            pQueueMgmt->Delete(NULL);
			pContext->m_fBound = FALSE;
            pContext->m_pMsg = NULL;
            pQueueMgmt->Release();
		}
	}

	// tell the driver to delete the message
	if ( pContext->m_pMsg ) {
	    pContext->m_pMsg->AddRef();
	    hr = pDriver->Delete(pContext->m_pMsg, NULL);
	    _ASSERT(SUCCEEDED(hr));		// not much that we can do if this failed
	}

	// release our reference on the driver
	pDriver->Release();

	// remove the entry from the article hash table, if it was made
	const char *szMessageID = pContext->m_pArticle->szMessageID();
	if (*szMessageID != 0) {
		pContext->m_pInstance->ArticleTable()->DeleteMapEntry(szMessageID);
	}

	dwSecondary = ret2.m_nrc;
	nntpReturn.fSet(nrcArticleRejected(pContext->m_fStandardPath),
		ret2.m_nrc, ret2.szReturn());

	// delete all other state
	pContext->Release();

	return TRUE;
}

BOOL CInFeed::PostPickup(CNntpServerInstanceWrapper	*pInstance,
						 CSecurityCtx               *pSecurityCtx,
						 CEncryptCtx                *pEncryptCtx,
						 BOOL						fAnonymous,
						 HANDLE						hArticle,
						 DWORD						&dwSecondary,
						 CNntpReturn				&nntpreturn,
						 BOOL						fPostToStore)
{
	TraceFunctEnter("CInFeed::PostPickup");

	_ASSERT(pInstance != NULL);

	//
	// memory map the file
	//
	CMapFile map(hArticle, TRUE, FALSE, 0);
	if (!map.fGood()) {
		// the memory map failed, put it on the retry queue
		TraceFunctLeave();
		return FALSE;
	}
	DWORD cMapBuffer;
	char *pMapBuffer = (char *) map.pvAddress(&cMapBuffer);
	BOOL fSuccess = TRUE;

	//
	// a valid buffer needs to be at least 9 bytes long (to contain
	// \r\n\r\n\r\n.\r\n and pass the next two tests.  we aren't
	// assuming anything about what headers need to be here, we'll
	// let fPost handle that).
	//
	CNntpReturn nr;

	if (cMapBuffer >= 9) {
		//
		// make sure the article ends with \r\n.\r\n.  we scan for it, and
		// when we find it we set pDot to point at it.
		//
		char *pDot = pMapBuffer + (cMapBuffer - 5);
		while (fSuccess && memcmp(pDot, "\r\n.\r\n", 5) != 0) {
			pDot--;
			if (pDot == pMapBuffer) fSuccess = FALSE;
		}

		if (fSuccess) {
			//
			// find the end of the headers
			//
			char *pEndBuffer = pMapBuffer + (cMapBuffer - 1);
			char *pBodyStart = pMapBuffer;
			while (fSuccess && memcmp(pBodyStart, "\r\n\r\n", 4) != 0) {
				pBodyStart++;
				if (pBodyStart >= pEndBuffer - 4) fSuccess = FALSE;
			}

			_ASSERT(pBodyStart > pMapBuffer);
			_ASSERT(pDot < pEndBuffer);
			_ASSERT(pBodyStart < pEndBuffer);

			// this can happen if there is junk after the \r\n.\r\n that includes
			// a \r\n\r\n
			if (pBodyStart >= pDot) fSuccess = FALSE;

			if (fSuccess) {
				// pBodyStart points to the \r\n\r\n now, point it at the real
				// body
				pBodyStart += 4;
				DWORD cbHead = (DWORD)(pBodyStart - pMapBuffer);
				DWORD cbArticle = (DWORD)((pDot + 5) - pMapBuffer);
				DWORD cbTotal;
				CBUFPTR pbufHeaders = new (cbHead, cbTotal) CBuffer(cbTotal);
				void *pvContext;
				PFIO_CONTEXT pFIOContext;
				DWORD iHeadersOutOffset, cbHeadersOut;

				if (pbufHeaders != NULL && pbufHeaders->m_cbTotal >= cbHead) {
					memcpy(pbufHeaders->m_rgBuff, pMapBuffer, cbHead);

					//
					// pass it into the feed's post method
					//
					fSuccess = PostEarly(pInstance,
										 pSecurityCtx,
										 pEncryptCtx,
										 fAnonymous,
										 "post",
										 pbufHeaders,
										 0,
										 cbHead,
										 &iHeadersOutOffset,
										 &cbHeadersOut,
										 &pFIOContext,
										 &pvContext,
										 dwSecondary,
										 ntohl(INADDR_LOOPBACK),	// Pickup directory, IPaddr=127.0.0.1 for localhost
										 nr,
										 NULL,
										 0);
					if (fSuccess) {
						OVERLAPPED ol;
						HANDLE hEvent = CreateEvent(NULL, TRUE, TRUE, NULL);
						DWORD dwDidWrite;
						DWORD i;

						for (i = 0; (i < 2) && fSuccess; i++) {
							BYTE *pSource;
							DWORD cSource;
							DWORD iOffset;

							switch (i) {
								case 0:
									pSource = (BYTE *) pbufHeaders->m_rgBuff + iHeadersOutOffset;
									cSource = cbHeadersOut - iHeadersOutOffset;
									iOffset = 0;
									break;
								case 1:
									pSource = (BYTE *) pBodyStart;
									cSource = cbArticle - cbHead;
									iOffset = cbHeadersOut - iHeadersOutOffset;
									break;
								default:
									_ASSERT(FALSE);
							}

							ol.Internal = 0;
							ol.InternalHigh = 0;
							ol.Offset = iOffset;
							ol.OffsetHigh = 0;
							ol.hEvent = (HANDLE) (((DWORD_PTR) hEvent) | 0x00000001);

							// copy the headers into the FIO context
							fSuccess = WriteFile(pFIOContext->m_hFile,
												 pSource,
												 cSource,
												 &dwDidWrite,
												 &ol);
							if (!fSuccess) {
								if (GetLastError() == ERROR_IO_PENDING) {
									fSuccess = TRUE;
									WaitForSingleObject(hEvent, INFINITE);

									_VERIFY(GetOverlappedResult(pFIOContext->m_hFile,
															    &ol,
															    &dwDidWrite,
															    FALSE));
								} else {
									nr.fSet(nrcServerFault);
								}
							}
							_ASSERT(!fSuccess || (dwDidWrite == cSource));
						}

						if (fSuccess) {
							// commit it
							fSuccess = PostCommit(pInstance,
							                      pvContext,
												  NULL,
												  dwSecondary,
												  nr,
												  fAnonymous);
							if (fSuccess)
							{
								nr.fSetOK();
							}
						}
					}
				} else {
					nr.fSet(nrcServerFault);
				}
			} else {
				// we couldn't find the \r\n\r\n between the headers and body
				nr.fSet(nrcArticleIncompleteHeader);
			}
		} else {
			// the buffer didn't contain the trailing .
			nr.fSet(nrcArticleIncompleteHeader);
		}
	} else {
		// the buffer was too short to contain the trailing .
		nr.fSet(nrcArticleIncompleteHeader);
	}

	UnmapViewOfFile(pMapBuffer);
	map.Relinquish();

	if (!nr.fIsOK()) {
		return nr.fSet(nrcArticleRejected(TRUE), nr.m_nrc, nr.szReturn());
	} else {
		return nr.fIsOK();
	}
}

/*++

Routine Description:

	Add a feed newsgroup multisz into m_multiszAcceptGroups
	We should first allocate memory for it, and then copy it.
	When we copy, we should keep the negated newsgroup in the beginning.

Arguments:

	LPSTR multiszAcceptGroups: the multisz to insert

Return Value:

	TRUE if successfully inserted.
	FALSE if not. Only return FALSE when memory is low. We won't touch the existing m_multiszAcceptGroups in this case.

--*/
BOOL CInFeed::AddMultiszAcceptGroups(LPSTR multiszAcceptGroups)
{

	// Assuming the negated string are in the front of input multisz


	if (!m_multiszAcceptGroups) 
	{
		// we allocate the exact size. when we are called again we'll re-allocate.
		m_multiszAcceptGroups = XNEW CHAR[multiszLength(multiszAcceptGroups)];
		if (!m_multiszAcceptGroups) return FALSE;
		CopyMemory(m_multiszAcceptGroups, multiszAcceptGroups, multiszLength(multiszAcceptGroups));
	}
	else
	{

		// We will keep negated string in the front in the result multisz
		LPSTR pchNew = NULL;
		pchNew = XNEW CHAR[multiszLength(m_multiszAcceptGroups)+multiszLength(multiszAcceptGroups)-1];
		if (!pchNew) return FALSE;
		LPSTR pchTarget, pch1, pch2;
		int len = 0;
		pch1 = m_multiszAcceptGroups; 
		pch2 = multiszAcceptGroups;
		pchTarget = pchNew;

		// first negated newsgroup in both multisz
		while ('!' == *pch1 ) 
		{
			lstrcpy(pchTarget, pch1);
			len = lstrlen(pchTarget)+1;
			// advance to next string or terminator
			pch1 += len;
			// advance to next char to write
			pchTarget += len;
		}
		while ( '!' == *pch2 )
		{
			lstrcpy(pchTarget, pch2);
			len = lstrlen(pchTarget)+1;
			pch2 += len;
			pchTarget += len;
		}
		// then copy the rest
		while ( '\0' != *pch1  )
		{
			lstrcpy(pchTarget, pch1);
			len = lstrlen(pchTarget)+1;
			pch1 += len;
			pchTarget += len;
		}
		while ( '\0' != *pch2 )
		{
			lstrcpy(pchTarget, pch2);
			len = lstrlen(pchTarget)+1;
			pch2 += len;
			pchTarget += len;
		}
		//multisz terminator
		pchTarget = '\0';
		
		_ASSERT(multiszLength(pchNew) < multiszLength(m_multiszAcceptGroups)+multiszLength(multiszAcceptGroups));

		XDELETE m_multiszAcceptGroups;
		m_multiszAcceptGroups = pchNew;
	}
	return TRUE;
}

static int __cdecl comparegroups(const void *pvGroup1, const void *pvGroup2) {
	CPostGroupPtr *pGroupPtr1 = (CPostGroupPtr *) pvGroup1;
	CPostGroupPtr *pGroupPtr2 = (CPostGroupPtr *) pvGroup2;

	// GUBGUB - read vroot priorities
	if (pGroupPtr1->m_pVRoot < pGroupPtr2->m_pVRoot) {
		return -1;
	} else if (pGroupPtr1->m_pVRoot == pGroupPtr2->m_pVRoot) {
		return 0;
	} else {
		return 1;
	}
}


/*++

Routine Description:

	Compare the input multiszNewsgroups against m_multiszAcceptGroups.
	We loop through the Newsgroups header (in multiszNewsgroups)
	return TRUE if any of the newsgroup in multiszNewsgroups can be accepted.
	return FALSE if all of the newsgroups in multiszNewsgroups is not accepted.

Arguments:

	LPSTR multiszNewsgroups : the newsgroups header in multisz

Return Value:

	return TRUE if any of the newsgroup in multiszNewsgroups can be accepted.
	return FALSE if all of the newsgroups in multiszNewsgroups is not accepted.

--*/
BOOL
CInFeed::CheckAcceptGroups (const char *multiszNewsgroups)
{

	BOOL bAccept = FALSE;
	LPSTR pchNewsgroup = (LPSTR) multiszNewsgroups;

	// we stop when we reach the end or we decide to accept
	while ( ( '\0' != *pchNewsgroup ) && ( FALSE == bAccept) )
	{
		bAccept = MatchGroup(m_multiszAcceptGroups, pchNewsgroup);
		pchNewsgroup += ( lstrlen(pchNewsgroup)+1 );
	}
	return bAccept;
}

BOOL
CInFeed::fPostInternal (
						CNntpServerInstanceWrapper *  pInstance,
						const LPMULTISZ	szCommandLine, //the Post, Xreplic, IHave, etc. command line
						CSecurityCtx    *pSecurityCtx,
						CEncryptCtx     *pEncryptCtx,
						BOOL            fAnonymous,
						CARTPTR	        &pArticle,
						CNEWSGROUPLIST  &grouplist,
						CNAMEREFLIST    &namereflist,
						IMailMsgProperties *pMsg,
						CAllocator      &allocator,
						char *          &multiszPath,
						char*		    pchGroups,
						DWORD		    cbGroups,
						DWORD		    remoteIpAddress,
						CNntpReturn     &nntpReturn,
						PFIO_CONTEXT    *ppFIOContext,
						BOOL            *pfBoundToStore,
						DWORD           *pdwOperations,
						BOOL            *fPostToMod,
						LPSTR           szModerator
						)
/*++

Routine Description:


	 Does most of the processing for an incoming article.


Arguments:

	szCommandLine -  the Post, Xreplic, IHave, etc. command line
	pArticle - a pointer to the article being processed
	pGrouplist - pointer to a list of newsgroup objects to post to.
	pNamerefgroups - pointer to a list of the names, groupid and article ids of the article
	nntpReturn - The return value for this function call

Return Value:

	TRUE, if successful. FALSE, otherwise.

--*/
{
 	TraceFunctEnter( "CInFeed::fPostInternal" );

 	HANDLE hToken = NULL;

	nntpReturn.fSetClear(); // clear the return object

	//
	//	Get the newstree, hash tables etc for this virtual server instance
	//
	CNewsTreeCore*  pNewstree = pInstance->GetTree() ;
	CPCString pcHub(pInstance->NntpHubName(), pInstance->HubNameSize());
	CPCString pcDNS(pInstance->NntpDNSName(), pInstance->NntpDNSNameSize()) ;

	//
	// Validate the article
	//

	if (!pArticle->fValidate(pcHub, szCommandLine, this, nntpReturn))
		return nntpReturn.fFalse();

	//
	// Find the list of newsgroups to post to
	//

	DWORD cNewsgroups = pArticle->cNewsgroups();
	if (!grouplist.fInit(cNewsgroups, pArticle->pAllocator()))
		return nntpReturn.fSet(nrcMemAllocationFailed, __FILE__, __LINE__);

	if (!namereflist.fInit(cNewsgroups, pArticle->pAllocator()))
		return nntpReturn.fSet(nrcMemAllocationFailed, __FILE__, __LINE__);

	//
	// Remember the path it is posted to
	//

	DWORD dwLength = multiszLength(pArticle->multiszPath());
	multiszPath = (pArticle->pAllocator())->Alloc(dwLength);
	if (!multiszPath)
		return nntpReturn.fSet(nrcMemAllocationFailed, __FILE__, __LINE__);
	multiszCopy(multiszPath, pArticle->multiszPath(), dwLength);


	// do CheckAcceptGroups for accept feeds from peer/slave.
	if ( m_fAcceptFeedFromSlavePeer && !CheckAcceptGroups( pArticle->multiszNewsgroups() ) )
		return nntpReturn.fSet( nrcNoAccess );
	//
	//!!!FROMMASTER this should be replaced to different
	//calls for different feeds. By default grouplist will be
	//created from multiszNewsgroups, but in the case of a frommaster
	//feed it will be created from the xref information (or command sz)
	// Likewise 	CNAMEREFLIST namereflist(cNewsgroups);
	//

	if (!fCreateGroupLists(pNewstree, pArticle, grouplist, &namereflist, szCommandLine, pcHub, nntpReturn))
		return nntpReturn.fFalse();

	//
	// pass through the server events interface.  this can change the grouplist
	// if it likes.
	//
	//DWORD dwOperations = 0xffffffff;
	HRESULT hr;

	hr = pMsg->PutDWORD(IMSG_NNTP_PROCESSING, *pdwOperations);
	if (SUCCEEDED(hr)) {
		hr = TriggerServerEvent(pInstance->GetEventRouter(),
								CATID_NNTP_ON_POST_EARLY,
								pArticle,
								&grouplist,
								m_dwFeedId,
								pMsg);
		if (SUCCEEDED(hr)) {
			hr = pMsg->GetDWORD(IMSG_NNTP_PROCESSING, pdwOperations);
		}
	}


	// if the server event doesn't want us to post then don't
	if ((*pdwOperations & NNTP_PROCESS_POST) != NNTP_PROCESS_POST)
		return nntpReturn.fSet(nrcServerEventCancelledPost);

	//
	// Check if article is going to be posted to any newsgroups.
	//

	if (grouplist.IsEmpty())
	{
        // If this is a newgroup control message and we are processing control
		// messages it is ok to have an empty grouplist at this stage
        CONTROL_MESSAGE_TYPE cmControlMessage = pArticle->cmGetControlMessage();

        if(!((cmNewgroup == cmControlMessage) &&
		     (*pdwOperations & NNTP_PROCESS_CONTROL)))
        {
		    BOOL fOK = nntpReturn.fSet(nrcNoGroups());

			//ErrorTrace((long) this, "Article (%s) to be posted to no newsgroups", szFilename);

		    //
		    // If it is OK to post to no newsgroups, then just delete the file
		    //
		    if (fOK)
		    {
			    pArticle->vClose();

				if( !pArticle->fIsArticleCached() )
				{
					// delete only if we create a temp file for this article
					if( !DeleteFile( pArticle->szFilename() ) )
					{
						DWORD	dw = GetLastError() ;
						ErrorTrace( 0, "Delete File of %s failed cause of %d",
							        pArticle->szFilename(), dw ) ;
						_ASSERT( FALSE ) ;
					}
				}
		    }

		    return fOK;
        }
	};

	if (*pdwOperations & NNTP_PROCESS_MODERATOR) {
	    //
	    //  moderated newsgroup check (check Approved: header for moderator)
		//	NOTE: FROMMASTER does nothing here ! The slave relies on the master for this check !!
	    //
		if (!fModeratedCheck(   pInstance,
		                        pArticle,
		                        grouplist,
		                        gHonorApprovedHeaders,
		                        nntpReturn,
		                        szModerator))
	    {
	        //
	        // Return FALSE means this article is not accepted, but probably should
	        // be mailed to moderator.  We'll check nntpReturn, if it's still OK,
	        // we'll go ahead and ask the posting path to get the whole article, then
	        // we'll send the article to moderator in CommitPost phase.  If nntpReturn
	        // says it's not OK, then we'll fail the post
	        //
	        if (!nntpReturn.fIsOK() ) return FALSE;
	        else {
	            *fPostToMod = TRUE;
	            (*pdwOperations) &= ~(NNTP_PROCESS_CONTROL);
	        }
	    }
	}

	//
	//	Now do security check
	//
	if( pSecurityCtx || pEncryptCtx ) {
		if( !fSecurityCheck( pSecurityCtx, pEncryptCtx, grouplist, nntpReturn ) )
			return	nntpReturn.fFalse() ;
	}

	if ( *pdwOperations & NNTP_PROCESS_CONTROL) {
	    //
	    //  check for control messages and apply if necessary
	    //  NOTE: If this is a control message, grouplist and namereflist will be
	    //  changed to the appropriate control.* group. This ensures that the article
	    //  appears ONLY in the control.* groups and not the groups in the Newsgroups header
	    //
		if (!fApplyControlMessageEarly(pArticle, pSecurityCtx, pEncryptCtx, fAnonymous, grouplist, &namereflist, nntpReturn))
	    {
	        // Return TRUE if control message was applied successfully, FALSE otherwise
			return nntpReturn.fIsOK();
	    }
	}

    //
    // Sort the groups based on vroots
    //
    grouplist.Sort( comparegroups );

    //
    // Should also sort the nameref list into same order as grouplst.  This
    // is no-op for from-client.
    //
    SortNameRefList( namereflist );

    //
    //  at this point we have the final grouplist (possibly adjusted by fApplyControlMessageEarly)
    //  so, now create the namereflist. This ensures that the article id high watermark is not
    //  bumped unnecessarily.
    //  NOTE: FROMMASTER should do nothing here
    //
	if (!fCreateNamerefLists(pArticle, grouplist, &namereflist, nntpReturn))
		return nntpReturn.fFalse();

	//
	// Set the artref of the article
	//

	NAME_AND_ARTREF * pNameRef = namereflist.GetHead();
	_ASSERT(pNameRef); // real
	pArticle->vSetArticleRef(pNameRef->artref);

  	//
  	// Looks OK so munge the headers
    // add xref and path
    //
    DWORD   dwLinesOffset = INVALID_FILE_SIZE;
    DWORD   dwHeaderLength = INVALID_FILE_SIZE;
	if (!pArticle->fMungeHeaders(   pcHub,
	                                pcDNS,
	                                namereflist,
	                                remoteIpAddress,
	                                nntpReturn,
	                                &dwLinesOffset ))
		return nntpReturn.fFalse();

    //
    // Set the new header length
    //
    dwHeaderLength = pArticle->GetHeaderLength();

    //
	// See if the header too big
	//
	if (dwHeaderLength >= cbLargeBufferSize-128) {	// Room for cpool overhead, just in case
		return	nntpReturn.fSet(nrcHeaderTooLarge);
	}

	if( pchGroups != 0 )
		SaveGroupList(	pchGroups,	cbGroups, grouplist ) ;

	//
	//If necessary, record the message id
	//

	if (!fRecordMessageIDIfNecc(pInstance, pArticle->szMessageID(), nntpReturn))
		return nntpReturn.fFalse();


	//
	// Create the xover info
	//

	char szXOver[cchXOverMax];
	CPCString pcXOver(szXOver, cchXOverMax);
	if (!pArticle->fXOver(pcXOver, nntpReturn))
		return nntpReturn.fFalse();

	//
	// get the article object to copy all of its headers into a place that
	// is safe for reading after the vClose operation below
	//
	if (!pArticle->fMakeGetHeaderSafeAfterClose(nntpReturn))
		return nntpReturn.fFalse();

	//
	// Move the article to a local place, and then queues it up on any outfeeds
	//
	pArticle->vFlush() ;
	pArticle->vClose();

	class	CSecurityCtx*	pSecurity = 0 ;
	BOOL	fIsSecure = FALSE ;

	//
	// at this point we are ready to go.  talk to the first driver and
	// get a file handle that we can write to.
	//
	CPostGroupPtr *pPostGroupPtr = grouplist.GetHead();
	IMailMsgStoreDriver *pStoreDriver = pPostGroupPtr->GetStoreDriver();
	if (pStoreDriver == NULL)
			return nntpReturn.fSet(nrcNewsgroupInsertFailed,
				pPostGroupPtr->m_pGroup->GetGroupName(), pArticle->szMessageID());

	if ( pPostGroupPtr->m_pVRoot->GetImpersonationHandle() )
	    hToken = pPostGroupPtr->m_pVRoot->GetImpersonationHandle();
	else {
		if (pEncryptCtx == NULL && pSecurityCtx == NULL) {
			hToken = NULL;
		} else if (pEncryptCtx->QueryCertificateToken()) {
	        hToken = pEncryptCtx->QueryCertificateToken();
	    } else {
			hToken = pSecurityCtx->QueryImpersonationToken();
		}
	}

 	hr = FillInMailMsg(pMsg, pPostGroupPtr->m_pVRoot, &grouplist, &namereflist, hToken, szModerator );
	if (SUCCEEDED(hr)) {
		pMsg->AddRef();
		HANDLE hFile;
		IMailMsgPropertyStream *pStream = NULL;
		hr = pStoreDriver->AllocMessage(pMsg, 0, &pStream, ppFIOContext, NULL);
		if (SUCCEEDED(hr) && pStream == NULL) {
			pStream = XNEW CDummyMailMsgPropertyStream();
			if (pStream == NULL) hr = E_OUTOFMEMORY;
		}
		if (SUCCEEDED(hr)) {

		    //
		    // Set Lines header back fill offset to fiocontext
		    //
		    (*ppFIOContext)->m_dwLinesOffset = dwLinesOffset;
		    (*ppFIOContext)->m_dwHeaderLength = dwHeaderLength;

			// bind the handle to the mailmsg object
			IMailMsgBind *pBind = NULL;
			hr = pMsg->QueryInterface(__uuidof(IMailMsgBind), (void **) &pBind);
			if (SUCCEEDED(hr)) {
				hr = pBind->BindToStore(pStream,
				 					    pStoreDriver,
									    (*ppFIOContext));
				if (SUCCEEDED(hr)) *pfBoundToStore = TRUE;
			}
			if (pBind) pBind->Release();
			pBind = NULL;
		}
		if( pStream != NULL )
			pStream->Release() ;
	}
	if (pStoreDriver) pStoreDriver->Release();
	pStoreDriver = NULL;

	if (FAILED(hr))
		return nntpReturn.fSet(nrcNewsgroupInsertFailed,
			pPostGroupPtr->m_pGroup->GetGroupName(), pArticle->szMessageID());

	TraceFunctLeave();
	return nntpReturn.fSetOK();

}

//
// fill in the required fields in the IMailMsg object
//
// arguments:
// pMsg - the mail msg which we are filling in
// pVRoot - the vroot which will be receiving this mailmsg.
// pGrouplist - the posting path's grouplist
// pNamereflist - the posting path's nameref list
//
HRESULT CInFeed::FillInMailMsg(IMailMsgProperties *pMsg,
							   CNNTPVRoot *pVRoot,
							   CNEWSGROUPLIST *pGrouplist,
							   CNAMEREFLIST *pNamereflist,
							   HANDLE       hToken,
                               char*        pszApprovedHeader )
{
	TraceFunctEnter("CInFeed::FillInMailMsg");

	DWORD i=0;
	DWORD rgArticleIds[MAX_NNTPHASH_CROSSPOSTS];
	INNTPPropertyBag *rgpGroupBags[MAX_NNTPHASH_CROSSPOSTS];
	POSITION posGrouplist = pGrouplist->GetHeadPosition();
	POSITION posNamereflist = pNamereflist->GetHeadPosition();
	HRESULT hr;

	if (pNamereflist == NULL) {
	    return E_UNEXPECTED;
	}

	// these sizes need to be the same!
	_ASSERT(pGrouplist->GetCount() == pNamereflist->GetCount());

	while (posGrouplist != NULL) {
		// look at this group.  if it is one of the ones for this driver
		// then add it to the list, otherwise keep looking
		CPostGroupPtr *pPostGroupPtr = pGrouplist->GetNext(posGrouplist);
		if (pPostGroupPtr->m_pVRoot != pVRoot) {
			// if we haven't found any groups for this vroot then we
			// need to keep looking.  otherwise we are done.
			if (i == 0) continue;
			else break;
		}

		// build up the entries needed in the property bag
		NAME_AND_ARTREF *pNameref = pNamereflist->GetNext(posNamereflist);
		rgpGroupBags[i] = pPostGroupPtr->m_pGroup->GetPropertyBag();
		// we don't need to keep this reference because we have a reference
		// counted one already in the CPostGroupPtr.
		rgpGroupBags[i]->Release();
		rgArticleIds[i] = pNameref->artref.m_articleId;

		DebugTrace((DWORD_PTR) this,
				   "group %s, article %i",
				   pPostGroupPtr->m_pGroup->GetGroupName(),
				   pNameref->artref.m_articleId);
		i++;
		_ASSERT(i <= MAX_NNTPHASH_CROSSPOSTS);
		if (i > MAX_NNTPHASH_CROSSPOSTS) break;
	}

	hr = FillMailMsg(pMsg, rgArticleIds, rgpGroupBags, i, hToken, pszApprovedHeader );
	if (FAILED(hr)) return hr;

	TraceFunctLeave();
	return S_OK;
}

//
// fill in the required fields in the IMailMsg object
//
// arguments:
// pMsg - the mail msg which we are filling in
// pArticle - the article object for this message
// pGrouplist - the posting path's grouplist
//
HRESULT FillInMailMsgForSEO(IMailMsgProperties *pMsg,
							CArticle *pArticle,
							CNEWSGROUPLIST *pGrouplist)
{
	TraceFunctEnter("CInFeed::FillInMailMsgForSEO");

	HRESULT hr;

	// save all of the properties into the property bag
	hr = pMsg->PutProperty(IMSG_HEADERS,
						   pArticle->GetShortHeaderLength(),
						   (BYTE*) pArticle->GetHeaderPointer());

	if (SUCCEEDED(hr)) {
		char szNewsgroups[4096] = "";

		DWORD c = 0, iGroupList, cGroupList = pGrouplist->GetCount();
		POSITION posGroupList = pGrouplist->GetHeadPosition();
		for (iGroupList = 0;
			 iGroupList < cGroupList;
			 iGroupList++, pGrouplist->GetNext(posGroupList))
		{
			CPostGroupPtr *pPostGroupPtr = pGrouplist->Get(posGroupList);
			CGRPCOREPTR pNewsgroup = pPostGroupPtr->m_pGroup;
			_ASSERT(pNewsgroup != NULL);
			DWORD l = strlen(pNewsgroup->GetName());
			if (l + c + 1 + 1 < sizeof(szNewsgroups)) {	// length + total len + comma + null
				if (iGroupList > 0) {
					lstrcatA(szNewsgroups, ",");
					c++;
				}
				lstrcatA(szNewsgroups, pNewsgroup->GetName());
				c += l;
			} else {
				// BUGBUG - shouldn't use a fixed size buffer
				_ASSERT(FALSE);
			}
		}

		hr = pMsg->PutStringA(IMSG_NEWSGROUP_LIST, szNewsgroups);
	}

	TraceFunctLeave();
	return hr;
}

//
// fill in the properties that a driver looks for in an IMailMsgPropertyBag
//
HRESULT CInFeed::FillMailMsg(IMailMsgProperties *pMsg,
							 DWORD *rgArticleIds,
							 INNTPPropertyBag **rgpGroupBags,
							 DWORD cCrossposts,
							 HANDLE hToken,
                             char*  pszApprovedHeader )
{
	_ASSERT(cCrossposts != 0);
	_ASSERT(cCrossposts <= 256);

	HRESULT hr;

	// save all of the properties into the property bag
	hr = pMsg->PutProperty(IMSG_PRIMARY_GROUP,
						   sizeof(INNTPPropertyBag *),
						   (BYTE*) rgpGroupBags);

	if (SUCCEEDED(hr)) {
		hr = pMsg->PutProperty(IMSG_SECONDARY_GROUPS,
						  	   sizeof(INNTPPropertyBag *) * cCrossposts,
						  	   (BYTE*) rgpGroupBags);
	}

	if (SUCCEEDED(hr)) {
		hr = pMsg->PutProperty(IMSG_PRIMARY_ARTID,
						  	   sizeof(DWORD),
						  	   (BYTE*) rgArticleIds);
	}

	if (SUCCEEDED(hr)) {
		hr = pMsg->PutProperty(IMSG_SECONDARY_ARTNUM,
						  	   sizeof(DWORD) * cCrossposts,
						  	   (BYTE*) rgArticleIds);
	}

	if ( SUCCEEDED(hr) ) {
	    hr = pMsg->PutProperty( IMSG_POST_TOKEN,
                                sizeof( hToken ),
                                (PBYTE)&hToken );
	}

	if (SUCCEEDED(hr)) {
		hr = pMsg->PutStringA(IMMPID_NMP_NNTP_APPROVED_HEADER,
						  	  pszApprovedHeader);
	}

	return hr;
}

//
// Copy the article into each of the stores
//
void CInFeed::CommitPostToStores(CPostContext *pContext, CNntpServerInstanceWrapper *pInstance ) {
	TraceFunctEnter("CInFeed::CommitPostToStores");

	DWORD cCrossposts = 0;
	DWORD rgArticleIds[MAX_NNTPHASH_CROSSPOSTS];
	INNTPPropertyBag *rgpGroupBags[MAX_NNTPHASH_CROSSPOSTS];
	CNEWSGROUPLIST *pGrouplist = &(pContext->m_grouplist);
	CNAMEREFLIST *pNamereflist = &(pContext->m_namereflist);
	CStoreId *rgStoreIds = pContext->m_rgStoreIds;
	BYTE *rgcCrossposts = pContext->m_rgcCrossposts;
	HRESULT hr;
	CNNTPVRoot *pThisVRoot = pContext->m_pPostGroupPtr->m_pVRoot;

	// these sizes need to be the same!
	_ASSERT(pGrouplist->GetCount() == pNamereflist->GetCount());

	rgcCrossposts[pContext->m_cStoreIds] = 0;

	//
	// loop at each group that belongs to this vroot
	//
	while (pContext->m_pPostGroupPtr != NULL &&
		   pContext->m_pPostGroupPtr->m_pVRoot == pThisVRoot)
	{
		if (rgcCrossposts[pContext->m_cStoreIds] < MAX_NNTPHASH_CROSSPOSTS) {
			rgpGroupBags[cCrossposts] = pContext->m_pPostGroupPtr->m_pGroup->GetPropertyBag();
			rgArticleIds[cCrossposts] = pContext->m_pNameref->artref.m_articleId;

			// we don't need to keep this reference because we have a reference
			// counted one already in the CPostGroupPtr.
			rgpGroupBags[cCrossposts]->Release();

			rgcCrossposts[pContext->m_cStoreIds]++;
			cCrossposts++;
		} else {
			_ASSERT(cCrossposts < MAX_NNTPHASH_CROSSPOSTS);
		}

		pContext->m_pPostGroupPtr = pGrouplist->GetNext(pContext->m_posGrouplist);
		pContext->m_pNameref = pNamereflist->GetNext(pContext->m_posNamereflist);
	}

	// we should have found at least one group
	_ASSERT(rgcCrossposts[pContext->m_cStoreIds] != 0);

	// build the mail msg for this group
	hr = FillMailMsg(pContext->m_pMsg,
					 rgArticleIds,
					 rgpGroupBags,
					 rgcCrossposts[pContext->m_cStoreIds],
					 pContext->m_hToken,
                     pContext->m_szModerator);

	if (FAILED(hr)) {
		pContext->m_completion.SetResult(hr);
		pContext->m_completion.Release();
		TraceFunctLeave();
		return;
	} else {
		pContext->m_pMsg->AddRef();
		// add a reference for the driver's CommitPost
		pContext->m_completion.AddRef();
		// tell the driver to commit the message
		pThisVRoot->CommitPost(pContext->m_pMsg,
						       &(rgStoreIds[pContext->m_cStoreIds]),
						       NULL,
						       pContext->m_hToken,
						       &(pContext->m_completion),
							   pContext->m_fAnonymous);
		// say that we saw this store id.
		(pContext->m_cStoreIds)++;
		// release our reference
		pContext->m_completion.Release();
	}

	TraceFunctLeave();
}

BOOL
CInFeed::fCreateNamerefLists(
			CARTPTR & pArticle,
			CNEWSGROUPLIST & grouplist,
			CNAMEREFLIST * pNamereflist,
			CNntpReturn & nntpReturn
		    )
/*++

Routine Description:

  Create the namereflist from the grouplist

  !!!FROMMASTER this should be replaced to different


Arguments:

	grouplist - a list of newsgroup objects to post to.
	namereflist - a list of the names, groupid and article ids of the article
	nntpReturn - The return value for this function call


Return Value:

	TRUE, if successful. FALSE, otherwise.

--*/
{
 	TraceFunctEnter( "CInFeed::fCreateNamerefLists" );

	nntpReturn.fSetClear();

	//
	// Check if article is going to be posted to any newsgroups.
	//

	if (grouplist.IsEmpty())
		return nntpReturn.fFalse();

	if( pNamereflist != 0 ) {
		//
		// Allocate article numbers and create the Name/Ref list.
		// !!! for sfromcl could replace real newsgruops with newsgroup 1 right here

		POSITION	pos = grouplist.GetHeadPosition() ;
		while( pos  )
		{
			CPostGroupPtr *pPostGroupPtr = grouplist.GetNext(pos);
			CGRPCOREPTR *ppGroup = &(pPostGroupPtr->m_pGroup);
			NAME_AND_ARTREF Nameref;
			(Nameref.artref).m_groupId = (* ppGroup)->GetGroupId();
			(Nameref.artref).m_articleId = (* ppGroup)->AllocateArticleId();
			(Nameref.pcName).vInsert((* ppGroup)->GetNativeName());
			pNamereflist->AddTail(Nameref);
		}
	}

	return nntpReturn.fSetOK();
}

DWORD
CInFeed::CalculateXoverAvail(
						   CARTPTR & pArticle,
                           CPCString& pcHub
						   )
/*++

Routine Description:

	From the article object and other constants, figure out
    the amount of space available for xover data.

Arguments:

	pArticle - a pointer to the article being processed

Return Value:

	Number of bytes available for more xover data

--*/
{
 	TraceFunctEnter( "CInFeed::CalculateXoverAvail" );

    //
    //  Calculate available space for xover info.
    //  At this point, we can figure out all the xover fields except Xref.
    //

	const DWORD cchMaxDate =
			STRLEN(szKwDate)	    // for the Date keyword
			+ 1					    // space following the keyword
			+ cMaxArpaDate		    // bound on the data string
			+ 2                     // for the newline
			+ 1;                    // for a terminating null

	const DWORD cchMaxMessageID =
			STRLEN(szKwMessageID)	// for the MessageID keyword
			+ 1					    // space following the keyword
			+ 4					    // <..@>
			+ cMaxMessageIDDate     // The message id date
			+ 10				    // One dword
			+ pcHub.m_cch		    // the hub name
			+ 2                     // for the newline
			+ 1;                    // for a terminating null

    DWORD cbFrom = 0, cbSubject = 0, cbRefs = 0;
    pArticle->fGetHeader((char*)szKwFrom,NULL, 0, cbFrom);
    pArticle->fGetHeader((char*)szKwSubject,NULL, 0, cbSubject);
    _ASSERT( cbFrom && cbSubject );
    pArticle->fGetHeader((char*)szKwReferences,NULL, 0, cbRefs);

    DWORD cbXover =
            11                      // article id + tab
            + cbSubject  + 1        // length of subject field + tab
            + cbFrom     + 1        // length of from field + tab
            + cchMaxDate + 1        // length of date field + tab
            + cchMaxMessageID + 1   // length of message-id field + tab
            + 10 + 1                // article size + tab
            + cbRefs + 1            // References field + tab
            + 10 + 1                // Lines field + tab
            + STRLEN(szKwXref)+2    // XRef + : + space
            + pcHub.m_cch + 1;      // Hub name + space

    return max(cchXOverMax - cbXover, 0);
}

BOOL
CInFeed::fCreateGroupLists(
						   CNewsTreeCore* pNewstree,
						   CARTPTR & pArticle,
						   CNEWSGROUPLIST & grouplist,
						   CNAMEREFLIST * pNamereflist,
						   LPMULTISZ	multiszCommandLine,
                           CPCString& pcHub,
						   CNntpReturn & nntpReturn
						   )
/*++

Routine Description:

	From the names of the newsgroups, gets the group objects,
	groupid's and articleid and returns them as lists.

  !!!FROMMASTER this should be replaced to different


Arguments:

	pNewstree - newstree for this virtual server instance
	pArticle - a pointer to the article being processed
	grouplist - a list of newsgroup objects to post to.
	namerefgroups - a list of the names, groupid and article ids of the article
	nntpReturn - The return value for this function call


Return Value:

	TRUE, if successful. FALSE, otherwise.

--*/
{
 	TraceFunctEnter( "CInFeed::fCreateGroupLists" );

	nntpReturn.fSetClear();

    //
    //  Calculate available space for xover info. We will use this to
    //  truncate the grouplist, if the newsgroups header is too big.
    //
    DWORD cbXoverAvail = CalculateXoverAvail( pArticle, pcHub );

	const char * multiszNewsgroups = pArticle->multiszNewsgroups();
	DWORD cNewsgroups = pArticle->cNewsgroups();

	char const * sz = multiszNewsgroups;
	do
	{
		//!!! DISTR needs something like this
        DWORD cbLen = lstrlen(sz);
		CGRPCOREPTR	pGroup = pNewstree->GetGroupPreserveBuffer( sz, cbLen+1 );//!!!does GetGroup really need the length?
		if (pGroup && (cbXoverAvail > cbLen+10+2) )
		{
			CPostGroupPtr PostGroupPtr(pGroup);
			//
			// If it is already in the tree ...
			//
			/* Security algorithm

				  // Start with a list, L, of newsgroup names from the "Newsgroups:" line.

				  // Remove thoese we don't carry and duplicates.
				  L' = L union Carry

				  If now empty, toHistory with messageid, return

				  // Check if passes wildmat test
				  if not [exists l in L' such that W(l)]
						delete message id

				  //Check if passes security
				  if not [for all l in L', S(l)]
						delete message id

				  Post to L'


			*/
			grouplist.AddTail(PostGroupPtr);
            cbXoverAvail -= (cbLen+10+2);
            _ASSERT( cbXoverAvail > 0 );

        } else if(pGroup == NULL) {

			//
			// If the group does not exist ...
			//
        } else {
            //
            //  Newsgroups: header is too big, truncate the grouplist
            //
            break;
        }

		//
		// go to first char after next null
		//

		while ('\0' != sz[0])
			sz++;
		sz++;
	} while ('\0' != sz[0]);

	return nntpReturn.fSetOK();
}

BOOL
CInFeed::SetLoginName(
					  char * szLoginName
					  )
/*++

Routine Description:

	Sets the LoginName of the user (only used by clients)

Arguments:

	szLoginName - the login name of the client giving us articles


Return Value:

	TRUE, if successful. FALSE, otherwise.

--*/
{
	strncpy(m_szLoginName, szLoginName, cMaxLoginName);
	m_szLoginName[cMaxLoginName-1] = '\0';

	return TRUE;
}


BOOL CInFeed::fInit(
			PVOID feedCompletionContext,
			const char * szTempDirectory,
			const char * multiszNewnewsPattern,
			DWORD cInitialBytesGapSize,
			BOOL fCreateAutomatically,
			BOOL fDoSecurityChecks,
			BOOL fAllowControlMessages,
			DWORD dwFeedId,
			BOOL fAcceptFeedFromSlavePeer
			)
/*++

Routine Description:

	Initalizes the InFeed

Arguments:

	sockaddr - the socket address articles are coming in on
	feedCompletionContext - what to call when done
	szTempDirectory - where to put articles pending processing
	multiszNewnewsPattern - what pattern of articles to accept
	cInitialBytesGapSize - what gap to leave in the file before the article
	fCreateAutomatically - make feed's groups our groups?


Return Value:

	TRUE, if successful. FALSE, otherwise.

--*/
{
    _ASSERT(ifsUninitialized == m_feedState);
    m_feedState = ifsInitialized;

	m_feedCompletionContext = feedCompletionContext;
	m_szTempDirectory = (char *) szTempDirectory;
	m_multiszNewnewsPattern = (char *) multiszNewnewsPattern;
	m_cInitialBytesGapSize = cInitialBytesGapSize;
	m_fCreateAutomatically = fCreateAutomatically;
	m_fDoSecurityChecks = fDoSecurityChecks ;
	m_fAllowControlMessages = fAllowControlMessages ;
	m_dwFeedId = dwFeedId;
	m_fAcceptFeedFromSlavePeer = fAcceptFeedFromSlavePeer;

	return TRUE;
};

BOOL
CInFeed::fMoveMessageIDIfNecc(
						CNntpServerInstanceWrapper *	pInstance,
						const char *			szMessageID,
						CNntpReturn &			nntpReturn,
						HANDLE                  hToken,
						BOOL					fAnonymous
						)
/*++

Routine Description:

	If the message id is in the article table, moves it to the
	history table.

Arguments:

	pInstance - virtual server instance
	szMessageID - the message id to move
	nntpReturn - The return value for this function call


Return Value:

	TRUE, if successful or unneeded. FALSE, otherwise.

--*/
{
 	TraceFunctEnter( "CInFeed::fMoveMessageIDIfNecc" );

	//
	// clear the return code object
	//

	nntpReturn.fSetOK();

    //
	// Confirm that the article is not in the table
	//

	WORD	HeaderOffset ;
	WORD	HeaderLength ;
	ARTICLEID ArticleNo;
    GROUPID GroupId;
	CStoreId storeid;

	//
	// Look for the article. It is OK if there is none.
	//

	if (!(pInstance->ArticleTable())->GetEntryArticleId(
											szMessageID,
											HeaderOffset,
											HeaderLength,
											ArticleNo,
											GroupId,
											storeid))
	{
		if (ERROR_FILE_NOT_FOUND == GetLastError())
		{
			return nntpReturn.fSetOK();
		} else {
			return nntpReturn.fSet(nrcArticleTableError, szMessageID, GetLastError());
		}
	}

    //
    // If <GroupId, ArticleNo> is valid, we should simulate a cancel on
    // this message-id to cleanup entries in our hash tables.
    // Else, just zap the message-id in the article map table.
    //

    if( ArticleNo != INVALID_ARTICLEID && GroupId != INVALID_ARTICLEID )
    {
        //
		// Call gExpireArticle to cancel this article
		//

		if (  pInstance->ExpireArticle( GroupId, ArticleNo, &storeid, nntpReturn, hToken, TRUE, fAnonymous ) /*
			   || pInstance->DeletePhysicalArticle( GroupId, ArticleNo, &storeid, hToken, fAnonymous)*/
		)
		{
			DebugTrace((LPARAM)this,"Article cancelled: GroupId %d ArticleId %d", GroupId, ArticleNo);
		}
		else
		{
			ErrorTrace((LPARAM)this, "Could not cancel article: GroupId %d ArticleId %d", GroupId, ArticleNo);
		}
    } else
    {
    	//
	    // Try to delete it from the article table, even if adding to history
    	// table failed.
	    //

        _ASSERT( ArticleNo == INVALID_ARTICLEID && GroupId == INVALID_ARTICLEID );
    	if (!(pInstance->ArticleTable())->DeleteMapEntry(szMessageID))
    		return nntpReturn.fSet(nrcArticleTableCantDel, szMessageID, GetLastError());
    }

	// Use "fIsOK" rather than "fSetOK" because HistoryInsert might have failed
	return nntpReturn.fIsOK();

	TraceFunctLeave();
}


BOOL
CInFeed::fModeratedCheck(
            CNntpServerInstanceWrapper *pInstance,
            CARTPTR & pArticle,
			CNEWSGROUPLIST & grouplist,
            BOOL fCheckApproved,
			CNntpReturn & nntpReturn,
			LPSTR   szModerator
			)
/*++

Routine Description:

    Check for moderated newsgroups. If none of the groups in grouplist are moderated,
    accept the article. Else, we'll reset the grouplist to be the special group, so
    that the posting path can stream the article into the group temporarily and
    CommitPost can mail it out to the moderator.

Arguments:

	pArticle - a pointer to the article being processed
	grouplist - a list of newsgroup objects to post to.
    fCheckApproved - If TRUE, validate contents of Approved header
	nntpReturn - The return value for this function call


Return Value:

	TRUE, if article is to be accepted, FALSE if article is not accepted

--*/
{
 	TraceFunctEnter( "CInFeed::fModeratedCheck" );

	nntpReturn.fSetClear();

	if( !fModeratorChecks() ) {
		return	nntpReturn.fSetOK() ;
	}

    BOOL fAtLeastOneModerated = FALSE;
    DWORD cbModeratorLen = 0;

    POSITION	pos = grouplist.GetHeadPosition();
	while( pos  )
	{
		CPostGroupPtr *pPostGroupPtr = grouplist.GetNext(pos);
		CGRPCOREPTR *ppGroup = &(pPostGroupPtr->m_pGroup);
		const char *pszModerator = (*ppGroup)->GetModerator(&cbModeratorLen);
        if(cbModeratorLen && *pszModerator)
        {
			_ASSERT(pszModerator != NULL);
			if (pszModerator) strncpy(szModerator, pszModerator, MAX_MODERATOR_NAME);
            // found first moderated newsgroup in list
            fAtLeastOneModerated = TRUE;
            _ASSERT(cbModeratorLen < MAX_MODERATOR_NAME);
            szModerator [min(cbModeratorLen, MAX_MODERATOR_NAME-1)] = '\0';    // null-terminate the moderator string
            break;
        }
	}

    // Mail the article to the moderator of the first moderated newsgroup
    if(fAtLeastOneModerated)
    {
        //
        // Check for Approved header
        //
        char* lpApproved = NULL;
        DWORD cbLen = 0;
        pArticle->fGetHeader((char*)szKwApproved,(LPBYTE)lpApproved, 0, cbLen);

        if(cbLen)
        {
            // validate Approved header only if required
            if(fCheckApproved)
            {
                // Approved header is present - check moderator access
                lpApproved = (pArticle->pAllocator())->Alloc(cbLen+1);
                if(lpApproved == NULL || !pArticle->fGetHeader((char*)szKwApproved,(LPBYTE)lpApproved, cbLen+1, cbLen))
                {
                    ErrorTrace((LPARAM)this,"CArticle::fGetheader failed LastError is %d", GetLastError());
                    (pArticle->pAllocator())->Free(lpApproved);
                    return nntpReturn.fSet(nrcServerFault);
                }

                // adjust for \r\n at the end of lpApproved
                cbLen -= 2;
                lpApproved [cbLen] = '\0';

                // If len does not match - reject
                if(cbLen + 1 != cbModeratorLen) // cbModerator includes terminating null
                {
                    (pArticle->pAllocator())->Free(lpApproved);
                    nntpReturn.fSet(nrcNoAccess);
                    return FALSE;
                }

                // Approved email does not match - reject
                if(_strnicmp(lpApproved, szModerator, cbModeratorLen))
                {
                    (pArticle->pAllocator())->Free(lpApproved);
                    nntpReturn.fSet(nrcNoAccess);
                    return FALSE;
                }

                (pArticle->pAllocator())->Free(lpApproved);
                DebugTrace((LPARAM)this,"Approved header matched: moderator is %s",szModerator);
            }
        }
        else
        {
            //
            // We should modify the grouplist so that the article is streamed
            // into the special group before sent out
            //

            //
            // Lets remove all the group's in group.lst
            //
            pos = grouplist.GetHeadPosition();
	        while( pos  ) {
		        CPostGroupPtr *pPostGroupPtr = grouplist.GetNext(pos);
		        pPostGroupPtr->Cleanup();
            }
            grouplist.RemoveAll();

            //
            // OK, now push the special group into grouplist
            //
            CNewsTreeCore *pTree = pInstance->GetTree();
            _ASSERT( pTree );

            CGRPCOREPTR pGroup = pTree->GetGroupById(pTree->GetSlaveGroupid());
            _ASSERT( pGroup );
            if ( !pGroup ) {
                ErrorTrace( 0, "Can not find the special group" );
                nntpReturn.fSet( nrcPostModeratedFailed, szModerator );
                return FALSE;
            }

            CPostGroupPtr PostGroupPtr(pGroup);
            grouplist.AddTail( PostGroupPtr );

#if GUBGUB
			// num moderated postings we attempt to deliver to an Smtp server
			pArticle->m_pInstance->BumpCounterModeratedPostingsSent();

            // Approved header absent - mail article to moderator
            if(!pArticle->fMailArticle( szModerator ))
            {
                // handle error - mail server could be down
                ErrorTrace( (LPARAM)this,"Error mailing article to moderator");
                nntpReturn.fSet(nrcPostModeratedFailed, szModerator);

				// log a warning for moderated posting failures; If number of warnings exceeds a limit
				// log a final error and then stop logging.
				DWORD NumWarnings;
				if( (NumWarnings = InterlockedExchangeAddStat( (pArticle->m_pInstance), ModeratedPostingsFailed, 1 )) <= MAX_EVENTLOG_WARNINGS )
				{
					if(NumWarnings < MAX_EVENTLOG_WARNINGS)
					{
						PCHAR args [2];
						CHAR  szId[20];
						_itoa( (pArticle->m_pInstance)->QueryInstanceId(), szId, 10 );
						args [0] = szId;
						args [1] = szModerator;

						NntpLogEvent(
								NNTP_EVENT_WARNING_SMTP_FAILURE,
								2,
								(const CHAR **)args,
								0 ) ;
					}
					else
					{
						PCHAR args   [3];
						char  szTemp [10];
						CHAR  szId[20];
						_itoa( (pArticle->m_pInstance)->QueryInstanceId(), szId, 10 );
						args [0] = szId;

						args [1] = szModerator;
						wsprintf( szTemp, "%d", MAX_EVENTLOG_WARNINGS+1 );
						args [2] = szTemp;

						NntpLogEvent(
								NNTP_EVENT_ERROR_SMTP_FAILURE,
								3,
								(const CHAR **)args,
								0 ) ;
					}
				}
                return FALSE;
            }
#endif

            // return 240 OK but dont accept the article
			nntpReturn.fSetOK();
            return FALSE;
        }
    }

    TraceFunctLeave();
    return nntpReturn.fSetOK();
}

BOOL
CInFeed::fSecurityCheck(
		CSecurityCtx    *pSecurityCtx,
		CEncryptCtx     *pEncryptCtx,
		CNEWSGROUPLIST&	grouplist,
		CNntpReturn&	nntpReturn
		)	{
/*++

Routine Description :

	Check that the caller has access to each of the newsgroups
	in the list.

Arguments :

	pcontext - Users context, has all we need to do impersonates etc...
	grouplist - list of newsgroups the user is posting to
	nntpReturn - result

Return Value :

	TRUE if the post can succeed, FALSE otherwise

--*/

	BOOL	fRtn = TRUE;

	HANDLE  hToken = NULL;

    POSITION	pos = grouplist.GetHeadPosition();
    POSITION	pos_current;
	while( pos && fRtn )
	{
		// remember the current position since GetNext will increase it
		pos_current = pos;
		CPostGroupPtr *pPostGroupPtr = grouplist.GetNext(pos);
		CGRPCOREPTR *ppGroup = &(pPostGroupPtr->m_pGroup);

		SelectToken(pSecurityCtx, pEncryptCtx, &hToken);

		// if the news group is not accessible remove it from the internal group list
		if (!(* ppGroup)->IsGroupAccessible(
						hToken,
						NNTP_ACCESS_POST
						) )
		{
			grouplist.Remove(pos_current);
		}

       }
	if (grouplist.IsEmpty())
		fRtn = FALSE;

	if( !fRtn )
		return	nntpReturn.fSet( nrcNoAccess ) ;
	else
		return	nntpReturn.fSetOK() ;
}

BOOL
CInFeed::fApplyControlMessageEarly(
        CARTPTR & pArticle,
		CSecurityCtx *pSecurityCtx,
		CEncryptCtx *pEncryptCtx,
		BOOL fAnonymous,
	    CNEWSGROUPLIST & grouplist,
		CNAMEREFLIST * pNamereflist,
		CNntpReturn & nntpReturn
		)
/*++

Routine Description:

    Given an article with the Control: header, applies the control message.
    Derived classes that dont need to apply control messages, should override
    this to do nothing.

    This function is called during PostEarly.  It only does early Control Message
    apply sanity check, but won't commit the action until CommitPost later in the
    posting path.
    fApplyControlMessageCommit() & fApplyControlMessageEarly() are splined-off from
    fApplyControlMessage().

Arguments:

	pArticle - a pointer to the article being processed
    grouplist - reference to the list of newsgroups
    pNamereflist - pointer to the corresponding nameref list
	nntpReturn - The return value for this function call


Return Value:

	TRUE, if this is not a control message or control message is applied successfully
    FALSE, if this is a control message and could not be applied

--*/
{
	TraceFunctEnter("CInFeed::fApplyControlMessageEarly");

    BOOL fRet = TRUE;
	char* lpApproved = NULL;
    char* lpControl = NULL;
	DWORD cbLen = 0;

	nntpReturn.fSetOK();

    //
    // Check for Control: header
    //
    pArticle->fGetHeader((char*)szKwControl, (LPBYTE)lpControl, 0, cbLen);

    // If cbLen is non-zero, this is a control message
    if(cbLen)
    {
		// get a hold of the appropriate newstree object !
		CNewsTreeCore* pNewstree = pArticle->m_pInstance->GetTree();

        // set grouplist and pNamereflist to the control.* group
        // This overrides the Newsgroups header, since control messages
        // should not actually appear in those groups. They appear only
        // in the control.* groups
        // FROMMASTER: do nothing - accept whatever the master sends
        if(!fAdjustGrouplist( pNewstree, pArticle, grouplist, pNamereflist, nntpReturn))
        {
            ErrorTrace((LPARAM)this,"Adjust grouplist failed");
            fRet = nntpReturn.fFalse();
			goto fApplyControlMessageEarly_Exit;
        }

        //
        //  moderated newsgroup check (Ignore contents of Approved: header)
		//	NOTE: FROMMASTER does nothing here - relies on master to have done this check !!
        //
        /* I don't see any need to check for this here
	    if (!fModeratedCheck(pArticle, grouplist, FALSE, nntpReturn))
        {
            // Newsgroup is moderated - dont fall through
            fRet = FALSE;
			goto fApplyControlMessageEarly_Exit;
        }*/

	    //
	    //	Now do security check
	    //
	    if( pSecurityCtx || pEncryptCtx )
        {
		    if( !fSecurityCheck( pSecurityCtx, pEncryptCtx, grouplist, nntpReturn ) )
            {
			    fRet = nntpReturn.fFalse();
				goto fApplyControlMessageEarly_Exit;
            }
	    }

		// Approved check: this checks existence of Approved header for non-moderated newsgroups
        CONTROL_MESSAGE_TYPE cmControlMessage = pArticle->cmGetControlMessage();
		if( (cmControlMessage == cmNewgroup) || (cmControlMessage == cmRmgroup) )
		{
			// newgroup, rmgroup control message MUST have an Approved header
			pArticle->fGetHeader((char*)szKwApproved,(LPBYTE)lpApproved, 0, cbLen);
			if( cbLen == 0 )
			{
				nntpReturn.fSet(nrcNoAccess);
                fRet = FALSE;
				goto fApplyControlMessageEarly_Exit;
			}
		}

    }   // end if(cbLen)

fApplyControlMessageEarly_Exit:

	// cleanup !
	if( lpControl ) {
		// free the control header value if required
		(pArticle->pAllocator())->Free(lpControl);
		lpControl = NULL;
	}

    TraceFunctLeave();
    return fRet;
}

BOOL
CInFeed::fApplyControlMessageCommit(
        CARTPTR & pArticle,
		CSecurityCtx *pSecurityCtx,
		CEncryptCtx *pEncryptCtx,
		BOOL fAnonymous,
	    CNEWSGROUPLIST & grouplist,
		CNAMEREFLIST * pNamereflist,
		CNntpReturn & nntpReturn
		)
/*++

Routine Description:

    Given an article with the Control: header, applies the control message.
    Derived classes that dont need to apply control messages, should override
    this to do nothing.

    Commit the actual Control Message action

Arguments:

	pArticle - a pointer to the article being processed
    grouplist - reference to the list of newsgroups
    pNamereflist - pointer to the corresponding nameref list
	nntpReturn - The return value for this function call


Return Value:

	TRUE, if this is not a control message or control message is applied successfully
    FALSE, if this is a control message and could not be applied

--*/
{
	TraceFunctEnter("CInFeed::fApplyControlMessageCommit");

    BOOL fRet = TRUE;
	char* lpApproved = NULL;
    char* lpControl = NULL;
	CMapFile* pMapFile = NULL;
	DWORD cbLen = 0;

	nntpReturn.fSetOK();

    //
    // Check for Control: header
    //
    pArticle->fGetHeader((char*)szKwControl, (LPBYTE)lpControl, 0, cbLen);

    // If cbLen is non-zero, this is a control message
    if(cbLen)
    {
		// get a hold of the appropriate newstree object !
		CNewsTreeCore* pNewstree = pArticle->m_pInstance->GetTree();

		// bump perfmon counter
		pArticle->m_pInstance->BumpCounterControlMessagesIn();

        // First check to see if control messages are allowed for this feed
	    if(!fAllowControlMessages(pArticle->m_pInstance))
        {
            // if control messages are disabled, dont apply them and return 240 OK
            // NOTE: in either case, the message will appear on the control.* group and get sent on feeds
            DebugTrace((LPARAM)this,"control message disabled: not applied");
		    pArticle->m_pInstance->BumpCounterControlMessagesFailed();
            fRet = nntpReturn.fSetOK();
		    goto fApplyControlMessageCommit_Exit;
        }

        // get the control header value
        lpControl = (pArticle->pAllocator())->Alloc(cbLen+1);
        if(lpControl == NULL || !pArticle->fGetHeader((char*)szKwControl,(LPBYTE)lpControl, cbLen+1, cbLen))
        {
            ErrorTrace((LPARAM)this,"CArticle::fGetheader failed LastError is %d", GetLastError());
            fRet = nntpReturn.fSet(nrcServerFault);
			goto fApplyControlMessageCommit_Exit;
        }

        CPCString pcValue(lpControl, cbLen);

        // trim leading and trailing whitespace and \r\n
	    pcValue.dwTrimStart(szWSNLChars);
	    pcValue.dwTrimEnd(szWSNLChars);

        // get the control message type
        CONTROL_MESSAGE_TYPE cmControlMessage = pArticle->cmGetControlMessage();
        DWORD cbMsgLen = (DWORD)lstrlen(rgchControlMessageTbl[cmControlMessage]);

        // skip to the arguments of the control message
        pcValue.vSkipStart(cbMsgLen);
        pcValue.dwTrimStart(szWSNLChars);
        pcValue.vMakeSz();

        // at least one argument
        if(!pcValue.m_cch)
        {
            fRet = nntpReturn.fSet(nrcArticleFieldMissingValue, rgchControlMessageTbl[cmControlMessage]);
			goto fApplyControlMessageCommit_Exit;
        }

		//
        // get article body - if non-null pMapFile is returned, we need to delete it !
		//
        char* lpBody = NULL;
        DWORD cbBodySize = 0;

#ifdef GUBGUB
        if( !pArticle->fGetBody(pMapFile, lpBody, cbBodySize) )
		{
            ErrorTrace((LPARAM)this,"CArticle::fGetBody failed LastError is %d", GetLastError());
            fRet = nntpReturn.fSet(nrcServerFault);
			goto fApplyControlMessage_Exit;
		}

		_ASSERT( lpBody && cbBodySize );
#endif
        CPCString pcBody(lpBody, cbBodySize);

        // assume not implemented
        nntpReturn.fSet(nrcNotYetImplemented);

        // now we have a control command and at least one argument
        switch(cmControlMessage)
        {
            case cmCancel:

                fRet = fApplyCancelArticle( (pArticle->m_pInstance), pSecurityCtx, pEncryptCtx, fAnonymous, pcValue, nntpReturn);
                break;

            case cmNewgroup:

                fRet = fApplyNewgroup( (pArticle->m_pInstance), pSecurityCtx, pEncryptCtx, fAnonymous, pcValue, pcBody, nntpReturn);
                break;

            case cmRmgroup:

				fRet = fApplyRmgroup( (pArticle->m_pInstance), pSecurityCtx, pEncryptCtx, pcValue, nntpReturn);
                break;

            case cmIhave:

                break;

            case cmSendme:

                break;

            case cmSendsys:

                break;

            case cmVersion:

                break;

            case cmWhogets:

                break;

            case cmCheckgroups:

                break;

            default:

                nntpReturn.fSet(nrcIllegalControlMessage);
                fRet = FALSE;
                break;
        }   // end switch

    }   // end if(cbLen)

fApplyControlMessageCommit_Exit:

	// cleanup !
	if( lpControl ) {
		// free the control header value if required
		(pArticle->pAllocator())->Free(lpControl);
		lpControl = NULL;
	}

	if( pMapFile ) {
		XDELETE pMapFile;
		pMapFile = NULL;
	}

    TraceFunctLeave();
    return fRet;
}

BOOL
CInFeed::fAdjustGrouplist(
		CNewsTreeCore* pNewstree,
        CARTPTR & pArticle,
	    CNEWSGROUPLIST & grouplist,
		CNAMEREFLIST * pNamereflist,
		CNntpReturn & nntpReturn
		)
/*++

Routine Description:

    Modifies grouplist and pNamereflist to include "control.*" newsgroups instead
    of the newsgroups in the Newsgroups: header.

Arguments:

	pNewstree - a pointer to the newstree object for this feed
	pArticle - a pointer to the article being processed
    grouplist - reference to the list of newsgroups
    pNamereflist - pointer to the corresponding nameref list
	nntpReturn - The return value for this function call


Return Value:

    TRUE if the grouplist is adjusted successfully, FALSE otherwise

--*/
{
    BOOL fRet = TRUE;
    TraceFunctEnter("CInFeed::fAdjustGrouplist");

    char* lpGroups = NULL;

    CONTROL_MESSAGE_TYPE cmControlMessage = pArticle->cmGetControlMessage();
    DWORD cbMsgLen = (DWORD)lstrlen(rgchControlMessageTbl[cmControlMessage]);

    // control messages should be posted to control.* groups
    lpGroups = (pArticle->pAllocator())->Alloc(cbMsgLen+8+1);
    if (lpGroups == NULL) {
    	nntpReturn.fSet(nrcMemAllocationFailed, __FILE__, __LINE__);
        return FALSE;
    }

    lstrcpy(lpGroups, "control.");  // 8 chars
    lstrcat(lpGroups, rgchControlMessageTbl[cmControlMessage]);

    if (!grouplist.fInit(1, pArticle->pAllocator()))
    {
	    nntpReturn.fSet(nrcMemAllocationFailed, __FILE__, __LINE__);
        (pArticle->pAllocator())->Free(lpGroups);
        return FALSE;
    }

	if (!pNamereflist->fInit(1, pArticle->pAllocator()))
    {
	    nntpReturn.fSet(nrcMemAllocationFailed, __FILE__, __LINE__);
        (pArticle->pAllocator())->Free(lpGroups);
        return FALSE;
    }

	CGRPCOREPTR	pGroup = pNewstree->GetGroup( lpGroups, lstrlen(lpGroups)+1);
	if (pGroup)
	{
	    //
		// If it is already in the tree ...
		//
		grouplist.AddTail(CPostGroupPtr(pGroup));
	}

	//
	// Check if article is going to be posted to any newsgroups.
	//
	if (grouplist.IsEmpty())
    {
	    nntpReturn.fSet(nrcControlNewsgroupMissing);
        (pArticle->pAllocator())->Free(lpGroups);
        return FALSE;
    }

    (pArticle->pAllocator())->Free(lpGroups);
    return fRet;
}

BOOL
CInFeed::fApplyCancelArticleInternal(
			CNntpServerInstanceWrapper * pInstance,
			CSecurityCtx *pSecurityCtx,
			CEncryptCtx *pEncryptCtx,
			BOOL fAnonymous,
            CPCString & pcValue,
			BOOL fApply,
			CNntpReturn & nntpReturn
			)
/*++

Routine Description:

	If the message id is in the article table, move it to the
	history table - else add it to the history table

    TODO: From header check - the From header in the control message
    should match the From header in the target article.

	!!! SlaveFromClient is different - just does ACL checks

Arguments:

	pcontext - client logon context (for ACL checks only)
	pcValue - the message id to cancel
	fApply - if TRUE, apply the control message else do ACL checks only
	nntpReturn - The return value for this function call


Return Value:

	TRUE, if successful or unneeded. FALSE, otherwise.

--*/
{
 	TraceFunctEnter( "CInFeed::fApplyCancelArticle" );

 	HANDLE hToken = NULL;

	//
	// clear the return code object
	//

	nntpReturn.fSetOK();

    //
    // validate argument
    //
    _ASSERT(pcValue.m_cch);
    const char* szMessageID = (const char*)pcValue.m_pch;
    char chStart = szMessageID [0];
    char chEnd   = szMessageID [pcValue.m_cch-1];
    if(chStart != '<' || chEnd != '>')
    {
        return nntpReturn.fSet(nrcArticleBadMessageID, szMessageID, szKwControl);
    }

	WORD	HeaderOffset ;
	WORD	HeaderLength ;
	ARTICLEID ArticleNo;
    GROUPID GroupId;

	//
	// Look for the article in the article table.
    // If there is none, insert in the history table
	//

	CStoreId storeid;
	if (!(pInstance->ArticleTable())->GetEntryArticleId(
										szMessageID,
										HeaderOffset,
										HeaderLength,
										ArticleNo,
										GroupId,
										storeid))
	{
		if (ERROR_FILE_NOT_FOUND != GetLastError())
		{
			return nntpReturn.fSet(nrcArticleTableError, szMessageID, GetLastError());
		}
        else
        {
			// do not apply for SlaveFromClientFeeds
			if( fApply )
			{
				//
				// Put it in the history table. If there is an error, record it but
				// continue so that the entry can be removed from the ArticleTable
				// !!! SlaveFromClient should not execute this.
				//

				FILETIME	FileTime ;
				GetSystemTimeAsFileTime( &FileTime ) ;
				nntpReturn.fSetOK(); // assume the best

				if (!(pInstance->HistoryTable())->InsertMapEntry(szMessageID, &FileTime))
				{
					// If it already exists in the history table, we are ok
					if(ERROR_ALREADY_EXISTS != GetLastError())
						nntpReturn.fSet(nrcHashSetFailed, szMessageID, "History", GetLastError());
				}
			}
        }
	}
    else
    {
        //
        // Article found in the article table - check From header
		// NOTE: rfc suggests we can avoid this check.
        //

		//
		// 3rd level ACL check: client context should have access to cancel an article
		//
		CNewsTreeCore*	ptree = pInstance->GetTree() ;
		CGRPCOREPTR	pGroup = ptree->GetGroupById( GroupId ) ;
		if( pGroup != 0 )
		{

			SelectToken(pSecurityCtx, pEncryptCtx, &hToken);

			if( !pGroup->IsGroupAccessible(
												hToken,
												NNTP_ACCESS_REMOVE
												) )
			{
				DebugTrace((LPARAM)this, "Group %s Cancel article: Access denied", pGroup->GetName());
				return nntpReturn.fSet( nrcNoAccess ) ;
			}
		}

		// do not apply for SlaveFromClientFeeds
		if( fApply && pGroup )
		{
		    // We should have hToken got here

			//
			// Call gExpireArticle to cancel this article
			// !!! SlaveFromClient should not execute this.
			//
			if (  pInstance->ExpireArticle( GroupId, ArticleNo, &storeid, nntpReturn, hToken, TRUE, fAnonymous ) /*
				   || pInstance->DeletePhysicalArticle( GroupId, ArticleNo, &storeid, hToken, fAnonymous )*/
			)
			{
				DebugTrace((LPARAM)this,"Article cancelled: GroupId %d ArticleId %d", GroupId, ArticleNo);
			}
			else
			{
				ErrorTrace((LPARAM)this, "Could not cancel article: GroupId %d ArticleId %d", GroupId, ArticleNo);
				return nntpReturn.fIsOK();
			}
		}
    }


	TraceFunctLeave();

	// Use "fIsOK" rather than "fSetOK" because HistoryInsert might have failed
	return nntpReturn.fIsOK();
}

BOOL
CInFeed::fApplyNewgroupInternal(
			CNntpServerInstanceWrapper * pInstance,
			CSecurityCtx *pSecurityCtx,
			CEncryptCtx *pEncryptCtx,
			BOOL fAnonymous,
            CPCString & pcValue,
            CPCString & pcBody,
			BOOL fApply,
			CNntpReturn & nntpReturn
			)
/*++

Routine Description:

    Add a new newsgroup in response to a control message. Follows son-of-RFC1036 spec.

    NOTE: A newgroup control message should be posted to the control.newgroup group.
    Only the moderator of this group can send this message. A newgroup control message
    without the proper Approved header will be rejected.

    TODO: The code to add a newsgroup has been lifted from svcgroup.cpp. This code
    should be probably be made a member of CNewsTree and called by the RPC stub as well
    as this function.

    TODO: Allow change of moderation status ?

    This function will never get called from SlaveFromClient

Arguments:

    pcontext - client logon context (for ACL checks only)
	pcValue - argument to the newgroup command
    pcBody - body of the article
	fApply - if TRUE, apply the control message else do ACL checks only
	     fApply is always TRUE. SlaveFromClient no longer process control message
	nntpReturn - The return value for this function call

Return Value:

	TRUE, if successful or unneeded. FALSE, otherwise.

--*/
{
 	TraceFunctEnter( "CInFeed::fApplyNewgroup" );

	//
	// clear the return code object
	//
	nntpReturn.fSetOK();

    char	szNewsgroup[MAX_NEWSGROUP_NAME+1] ;
    char	szNewsgroupTemp[MAX_NEWSGROUP_NAME+1] ;
    char	szParentGroup[MAX_NEWSGROUP_NAME+1] ;
	char	szDescription[MAX_DESCRIPTIVE_TEXT+1] ;
	char	szModerator[MAX_MODERATOR_NAME+1] ;
	DWORD   cbNewsgroup = 0;
	DWORD   cbParentGroup = 0;
    DWORD   cbDescription = 0;
	DWORD	cbModerator = 0;
    BOOL    fModerated = FALSE;
	char*   pch = NULL;
	HANDLE  hToken;

	szNewsgroup[0] = '\0' ;
	szDescription[0] = '\0' ;
	szModerator[0] = '\0';

    //
    // get the newsgroup name
    //
    CPCString pcNewsgroup;
    pcValue.vGetToken(" ", pcNewsgroup);
    cbNewsgroup = pcNewsgroup.m_cch;

    // validate newsgroup name length
    if(cbNewsgroup == 0 || cbNewsgroup >= MAX_NEWSGROUP_NAME)
        return nntpReturn.fSet(nrcBadNewsgroupNameLen);

    // make a copy of the newsgroup name
    pcNewsgroup.vCopyToSz(szNewsgroup);

	//
	// check for "moderated" / "unmoderated" qualifier
	// if "moderated", get the default moderator
	// default moderator is hiphenated-newsgroup@default
	//
	CPCString pcModeration;
	pcValue.vGetToken("\r\n", pcModeration);

	if( pcModeration.fEqualIgnoringCase("moderated") )
	{
		fModerated = TRUE;
		cbModerator = MAX_MODERATOR_NAME;
		if( pInstance->GetDefaultModerator( szNewsgroup, szModerator, &cbModerator ) ) {
			_ASSERT( !cbModerator || (cbModerator == (DWORD)lstrlen( szModerator )+1) );
		} else {
			ErrorTrace((LPARAM)this,"Error %d GetDefaultModerator", GetLastError());
			cbModerator = 0;
		}
	}

    //
    // get the newsgroup description and moderator (if provided)
    //
    CPCString pcDescription;

#ifdef GUBGUB
    _ASSERT(pcBody.m_cch);

    //
    //  search for the descriptor-tag in the body
    //
    do
    {
        pcBody.vGetToken("\r\n", pcDescription);    // skip this line

        // check if line is descriptor-tag
        if(pcDescription.fEqualIgnoringCase(lpNewgroupDescriptorTag))
        {
            // Newsgroup description is present
            pcBody.dwTrimStart(szWSNLChars);        // skip whitespace and \r\n
            pcBody.vGetToken(" \t", pcDescription); // skip the newsgroup name
            pcBody.dwTrimStart(szWSChars);          // skip whitespace after the newsgroup name
            pcBody.vGetToken("\r\n", pcDescription);// this is the description
            cbDescription = pcDescription.m_cch;

            // validate newsgroup description length
            cbDescription = min( cbDescription, MAX_DESCRIPTIVE_TEXT );
			pcDescription.m_cch = cbDescription;

            // make a copy of the newsgroup description
            pcDescription.vCopyToSz(szDescription);

            break;
        }
		else if( fModerated &&
					!_strnicmp( pcDescription.m_pch, lpModeratorTag, sizeof(lpModeratorTag)-1 ) )
		{
			// Newsgroup is moderated and moderator name is present
			pcDescription.vGetToken("\r\n", pcModeration);
			pcModeration.vSkipStart( sizeof(lpModeratorTag)-1 );
			pcModeration.dwTrimStart(szWSChars);
			pcModeration.dwTrimEnd(szWSNLChars);
			cbModerator = pcModeration.m_cch;

            // validate moderator length
            cbModerator = min( cbModerator, MAX_MODERATOR_NAME );
			pcModeration.m_cch = cbModerator;

			// make a copy of the moderator
			pcModeration.vCopyToSz(szModerator);
		}

    } while(pcBody.m_cch);
#endif


	// get global newstree object
	CNewsTreeCore*	ptree = pInstance->GetTree();
	SelectToken(pSecurityCtx, pEncryptCtx, &hToken);
	//
	// If the group does not exist - ACL check the parent
    // If the group exists already - ACL check the group
	//
	lstrcpy( szNewsgroupTemp, szNewsgroup );
    CGRPCOREPTR	pGroup = ptree->GetGroup( szNewsgroupTemp, lstrlen( szNewsgroupTemp ) ) ;

	if( pGroup != 0 )
	{



		// group exists - do an ACL check on the newsgroup
		if( !pGroup->IsGroupAccessible(
								hToken,
								NNTP_ACCESS_EDIT_FOLDER
								) )
		{
			DebugTrace((LPARAM)this, "Group %s newgroup: Access denied", pGroup->GetName());
			return nntpReturn.fSet( nrcNoAccess ) ;
		}
	}

       // We no longer need to check access on parent newsgroups. The CreateGroup call will do access check in driver.

	// do not apply for SlaveFromClientFeeds
	if( !fApply ) {
		return nntpReturn.fIsOK();
	}

	//
	//	All ACL checks completed - apply the newgroup control message
       //	we have all the info - create/modify the group
	//  !!! SlaveFromClient should not execute this.
	//

	// create the group !!!
	if( pGroup == 0 )
	{
		if( !ptree->CreateGroup( szNewsgroup, FALSE, hToken, fAnonymous ) )
		{
			// Failed to create group
			ErrorTrace((LPARAM)this, "Group %s newgroup: create group failed", szNewsgroup );
			return nntpReturn.fSet(nrcCreateNewsgroupFailed);
		}

		pGroup = ptree->GetGroup( szNewsgroup, lstrlen( szNewsgroup ) ) ;
	}

    //
    // Only when we have a good group pointer do we do the following, notice that
    // group pointer could be null in case the group is deleted right away after
    // the creation
    //
    if ( pGroup ) {
	    // Moderator info ? rfc does not provide a way to set this
	    // workaround rfc by using a "default moderator"
	    if( fModerated ) pGroup->SetModerator(szModerator);

	    // set Description info
	    if( szDescription[0] != '\0' ) pGroup->SetHelpText(szDescription);

	    PCHAR	args[2] ;
	    CHAR    szId[20];
	    _itoa( pInstance->QueryInstanceId(), szId, 10 );
	    args[0] = szId ;
	    args[1] = pGroup->GetNativeName() ;

	    NntpLogEvent(
			    NNTP_EVENT_NEWGROUP_CMSG_APPLIED,
			    2,
			    (const CHAR **)args,
			    0 ) ;

    }

	return nntpReturn.fIsOK();
}

BOOL
CInFeed::fApplyRmgroupInternal(
			CNntpServerInstanceWrapper * pInstance,
			CSecurityCtx *pSecurityCtx,
			CEncryptCtx *pEncryptCtx,
            CPCString & pcValue,
			BOOL	fApply,
			CNntpReturn & nntpReturn
			)
/*++

Routine Description:

    Remove a newsgroup in response to a control message. Follows son-of-RFC1036 spec.

    NOTE: A rmgroup control message should be posted to the control.rmgroup group.
    Only the moderator of this group can send this message. A rmgroup control message
    without the proper Approved header will be rejected.

	!!! SlaveFromClient is different - just does ACL checks

Arguments:

	pcontext - client logon context (for ACL checking)
	pcValue - argument to the newgroup command
	fApply - if TRUE, apply the control message else do ACL checks only
	nntpReturn - The return value for this function call

Return Value:

	TRUE, if successful or unneeded. FALSE, otherwise.

--*/
{
 	TraceFunctEnter( "CInFeed::fApplyRmgroup" );
 	HANDLE  hToken;

	//
	// clear the return code object
	//
	nntpReturn.fSetOK();

    char	szNewsgroup[MAX_NEWSGROUP_NAME] ;

    DWORD   cbNewsgroup = 0;
	szNewsgroup[0] = '\0' ;

    //
    // get the newsgroup name
    //
    CPCString pcNewsgroup;
    pcValue.vGetToken(" ", pcNewsgroup);
    cbNewsgroup = pcNewsgroup.m_cch;

    // validate newsgroup name length
    if(cbNewsgroup == 0 || cbNewsgroup >= MAX_NEWSGROUP_NAME)
        return nntpReturn.fSet(nrcBadNewsgroupNameLen);

    // make a copy of the newsgroup name
    pcNewsgroup.vCopyToSz(szNewsgroup);

    //
    // Now we have all the info - remove the group
    //
	CNewsTreeCore*	ptree = pInstance->GetTree() ;

	CGRPCOREPTR	pGroup = ptree->GetGroup( szNewsgroup, cbNewsgroup) ;
	if( pGroup == 0 )
    {
	    nntpReturn.fSet(nrcGetGroupFailed);
	}
	else
    {
		//
		//	3rd level ACL check: check client access to rmgroup argument
		//

		SelectToken(pSecurityCtx, pEncryptCtx, &hToken);

		if( !pGroup->IsGroupAccessible(
										hToken,
										NNTP_ACCESS_REMOVE_FOLDER
										) )

		{
			DebugTrace((LPARAM)this, "Group %s rmgroup: Access denied", pGroup->GetName());
			nntpReturn.fSet( nrcNoAccess ) ;
		}
		else
		{
			if( fApply )
			{
				// ACL check succeeded - apply rmgroup
				// !!! SlaveFromClient should not execute this.
				if( !ptree->RemoveGroup( pGroup ) )
					nntpReturn.fSet(nrcServerFault);

				PCHAR	args[2] ;
				CHAR    szId[20];
				_itoa( pInstance->QueryInstanceId(), szId, 10 );
				args[0] = szId ;
				args[1] = pGroup->GetNativeName() ;

				NntpLogEvent(
					NNTP_EVENT_RMGROUP_CMSG_APPLIED,
					2,
					(const CHAR **)args,
					0 ) ;

			}
		}
	}

	return nntpReturn.fIsOK();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\nntp\server\post\src\seodisp.cpp ===
#include "stdinc.h"
#include "wildmat.h"

#define INITGUID
#include "initguid.h"

DEFINE_GUID(NNTP_SOURCE_TYPE_GUID, 
0xc028fd82, 0xf943, 0x11d0, 0x85, 0xbd, 0x0, 0xc0, 0x4f, 0xb9, 0x60, 0xea);
DEFINE_GUID(CATID_NNTP_ON_POST_EARLY, 
0xc028fd86, 0xf943, 0x11d0, 0x85, 0xbd, 0x0, 0xc0, 0x4f, 0xb9, 0x60, 0xea);
DEFINE_GUID(CATID_NNTP_ON_POST, 
0xc028fd83, 0xf943, 0x11d0, 0x85, 0xbd, 0x0, 0xc0, 0x4f, 0xb9, 0x60, 0xea);
DEFINE_GUID(CATID_NNTP_ON_POST_FINAL, 
0xc028fd85, 0xf943, 0x11d0, 0x85, 0xbd, 0x0, 0xc0, 0x4f, 0xb9, 0x60, 0xea);
DEFINE_GUID(CLSID_CNNTPDispatcher, 
0xc028fd84, 0xf943, 0x11d0, 0x85, 0xbd, 0x0, 0xc0, 0x4f, 0xb9, 0x60, 0xea);

DEFINE_GUID(GUID_NNTPSVC, 
0x8e3ecb8c, 0xe9a, 0x11d1, 0x85, 0xd1, 0x0, 0xc0, 0x4f, 0xb9, 0x60, 0xea);

// {0xCD000080,0x8B95,0x11D1,{0x82,0xDB,0x00,0xC0,0x4F,0xB1,0x62,0x5D}}
DEFINE_GUID(IID_IConstructIMessageFromIMailMsg, 0xCD000080,0x8B95,0x11D1,0x82,
0xDB,0x00,0xC0,0x4F,0xB1,0x62,0x5D);

DWORD ComputeDropHash( const  LPCSTR&	lpstrIn);

CNNTPDispatcher::CNNTPParams::CNNTPParams() : m_iidEvent(GUID_NULL) {
	m_szRule = NULL;
	m_pCDOMessage = NULL;
}

void CNNTPDispatcher::CNNTPParams::Init(IID iidEvent,
										CArticle *pArticle,
										CNEWSGROUPLIST *pGrouplist,
										DWORD dwFeedId,
										IMailMsgProperties *pMailMsg)
{ 
	m_pArticle = pArticle;
	m_pGrouplist = pGrouplist;
	m_dwFeedId = dwFeedId;
	m_pMailMsg = pMailMsg;
	m_iidEvent = iidEvent;
}

CNNTPDispatcher::CNNTPParams::~CNNTPParams() { 
	if (m_szRule != NULL) {
		XDELETE m_szRule;
		m_szRule = NULL;
	}
	if (m_pCDOMessage != NULL) {
		m_pCDOMessage->Release();
		m_pCDOMessage = NULL;
	}
}

//
// initialize a new binding.  we cache information from the binding database
// here
//
HRESULT CNNTPDispatcher::CNNTPBinding::Init(IEventBinding *piBinding) {
	HRESULT hr;
	CComPtr<IEventPropertyBag> piEventProperties;

	// get the parent initialized
	hr = CBinding::Init(piBinding);
	if (FAILED(hr)) return hr;

	// get the binding database 
	hr = m_piBinding->get_SourceProperties(&piEventProperties);
	if (FAILED(hr)) return hr;

	// get the rule from the binding database
	hr = piEventProperties->Item(&CComVariant("Rule"), &m_vRule);
	if (FAILED(hr)) return hr;

	if (m_vRule.vt == VT_BSTR) m_cRule = lstrlenW(m_vRule.bstrVal) + 1;

	// get the newsgroup list from the binding database
	CComVariant vNewsgroupList;
	hr = piEventProperties->Item(&CComVariant("NewsgroupList"), 
								 &vNewsgroupList);
	if (FAILED(hr)) return hr;
	// go through each of the groups in the newsgroup list and add them 
	// to the groupset
	m_groupset.Init(ComputeDropHash);
	if (vNewsgroupList.vt == VT_BSTR) {
		//
		// copy the list to an ascii string and go through it, adding
		// each group to the groupset.
		//
		DWORD cNewsgroupList = lstrlenW(vNewsgroupList.bstrVal);
		char *pszGrouplist = XNEW char[cNewsgroupList + 1];
		if (pszGrouplist == NULL) return E_OUTOFMEMORY;
		if (WideCharToMultiByte(CP_ACP, 0, vNewsgroupList.bstrVal, 
							    -1, pszGrouplist, cNewsgroupList + 1, NULL,
								NULL) <= 0)
		{
			XDELETE[] pszGrouplist;
			return HRESULT_FROM_WIN32(GetLastError());
		}

		char *pszGroup = pszGrouplist, *pszComma;
		do {
			pszComma = strchr(pszGroup, ',');
			if (pszComma != NULL) *pszComma = 0;
			if (!m_groupset.AddGroup(pszGroup)) {
				XDELETE[] pszGrouplist;
				return E_OUTOFMEMORY;
			}
			pszGroup = pszComma + 1;
		} while (pszComma != NULL);

		XDELETE[] pszGrouplist;
		
		m_fGroupset = TRUE;
	} else {
		m_fGroupset = FALSE;
	}

	return S_OK;
}

//
// check the rule to see if we should call the child object
//
// returns:
//	S_OK - handle this event
// 	S_FALSE - skip this event
// 	<else> - error
//
HRESULT CNNTPDispatcher::CNNTPParams::CheckRule(CBinding &bBinding) {
	CNNTPBinding *pbNNTPBinding = (CNNTPBinding *) &bBinding;
	HRESULT hr;

	// do the header patterns rule check
	m_szRule = 0;
	hr = HeaderPatternsRule(pbNNTPBinding);
	// if this check passed and there is a valid groupset, then also
	// check against the groupset.
	if (hr == S_OK && pbNNTPBinding->m_fGroupset) {
		hr = GroupListRule(pbNNTPBinding);
	}

	return hr;
}

//
// check to see if any of the groups that this message is being posted
// to are in the grouplist hash table
//
HRESULT CNNTPDispatcher::CNNTPParams::GroupListRule(CNNTPBinding *pbNNTPBinding) {
	DWORD iGroupList, cGroupList = m_pGrouplist->GetCount();
	POSITION posGroupList = m_pGrouplist->GetHeadPosition();
	for (iGroupList = 0; 
		 iGroupList < cGroupList; 
		 iGroupList++, m_pGrouplist->GetNext(posGroupList)) 
	{
		CPostGroupPtr *pPostGroupPtr = m_pGrouplist->Get(posGroupList);
		CGRPCOREPTR pNewsgroup = pPostGroupPtr->m_pGroup;
		_ASSERT(pNewsgroup != NULL);
		LPSTR pszNewsgroup = pNewsgroup->GetNativeName();

		if (pbNNTPBinding->m_groupset.IsGroupMember(pszNewsgroup)) return S_OK;
	}

	return S_FALSE;
}

HRESULT CNNTPDispatcher::CNNTPParams::NewsgroupPatternsRule(CNNTPBinding *pbNNTPBinding, 
														    char *pszNewsgroupPatterns) 
{
	DWORD cRule = MAX_RULE_LENGTH;
	HRESULT hr;

	hr = S_FALSE;
	// try each comma delimited group in the newsgroup patterns
	// list
	char *pszNewsgroupPattern = pszNewsgroupPatterns;
	while (pszNewsgroupPattern != NULL && *pszNewsgroupPattern != 0) {
		// find the next comma in the string and turn it into a 0
		// if it exists
		char *pszComma = strchr(pszNewsgroupPatterns, ',');
		if (pszComma != NULL) *pszComma = 0;

		DWORD iGroupList, cGroupList = m_pGrouplist->GetCount();
		POSITION posGroupList = m_pGrouplist->GetHeadPosition();
		for (iGroupList = 0; 
			 iGroupList < cGroupList; 
			 iGroupList++, m_pGrouplist->GetNext(posGroupList)) 
		{
			CPostGroupPtr *pPostGroupPtr = m_pGrouplist->Get(posGroupList);
			CGRPCOREPTR pNewsgroup = pPostGroupPtr->m_pGroup;
			_ASSERT(pNewsgroup != NULL);
			LPSTR pszNewsgroup = pNewsgroup->GetNativeName();

			DWORD ec = HrMatchWildmat(pszNewsgroup, pszNewsgroupPattern);
			switch (ec) {
				case ERROR_SUCCESS: 
					return S_OK; 
					break;
				case ERROR_FILE_NOT_FOUND: 
					_ASSERT(hr == S_FALSE);
					break;
				default: 
					return HRESULT_FROM_WIN32(ec); 
					break;
			}			
		}

		// the next pattern is the one past the end of the comma
		pszNewsgroupPattern = (pszComma == NULL) ? NULL : pszComma + 1;
	}

	return hr;
}

HRESULT CNNTPDispatcher::CNNTPParams::FeedIDRule(CNNTPBinding *pbNNTPBinding, 
											     char *pszFeedIDs) 
{
	HRESULT hr = S_FALSE;

	// try each comma delimited group in the newsgroup patterns
	// list
	char *pszFeedID = pszFeedIDs;
	while (pszFeedID != NULL && *pszFeedID != 0) {
		// find the next comma in the string and turn it into a 0
		// if it exists
		char *pszComma = strchr(pszFeedIDs, ',');
		if (pszComma != NULL) *pszComma = 0;
		
		// convert the text FeedID into an integer and compare it against
		// the current FeedID
		DWORD dwFeedID = (DWORD) atol(pszFeedID);
		if (m_dwFeedId == dwFeedID) {
			// we found a match, so the rule passes
			return S_OK;
		}

		// the next pattern is the one past the end of the comma
		pszFeedID = (pszComma == NULL) ? NULL : pszComma + 1;
	}

	return hr;
}

//
// rule syntax:
// <header1>=<pattern1-1>,<pattern1-2>;<header2>=<pattern2-1>
//
// if there isn't a pattern specified for a header then the existence of the
// header will trigger the rule.  
// 
// :Newsgroup is a special header which refers to the envelope newsgroup
// information.
//
// any match in the rule causes the filter to be triggered.
//
// example:
// control=rmgroup,newgroup;:newsgroups=comp.*
//
// this will trigger the filter on rmgroup and newgroup postings in the 
// comp.* heirarchy
//
HRESULT CNNTPDispatcher::CNNTPParams::HeaderPatternsRule(CNNTPBinding *pbNNTPBinding) {
	HRESULT hr;
	BOOL fCaseSensitive = FALSE;

	if ( ( pbNNTPBinding->m_vRule.vt != VT_BSTR ) || (pbNNTPBinding->m_cRule == 0 ) ) {
		// this rule isn't in the metabase, so we pass it
		return S_OK;
	} else {
		hr = S_OK;

		// copy the rule into an ascii string
		m_szRule = XNEW char[pbNNTPBinding->m_cRule];
		if (m_szRule == NULL) return E_OUTOFMEMORY;
		if (WideCharToMultiByte(CP_ACP, 0, pbNNTPBinding->m_vRule.bstrVal, 
							    -1, m_szRule, pbNNTPBinding->m_cRule, NULL, NULL) <= 0)
		{
			return HRESULT_FROM_WIN32(GetLastError());
		}

		// try each semi-colon delimited rule in the header patterns list
		char *pszHeader = m_szRule;
		while (pszHeader != NULL && *pszHeader != 0) {
			// find the next semicolon in the string and turn it into a 0
			// if it exists
			char *pszSemiColon = strchr(pszHeader, ';');
			if (pszSemiColon != NULL) *pszSemiColon = 0;

			// set pszContents to point to the text which must be matched
			// in the header.  if pszContents == NULL then just having
			// the header exist is good enough.
			char *pszPatterns = strchr(pszHeader, '=');
			if (pszPatterns == NULL) {
				// this is a directive, honor it
				if (lstrcmpi(pszHeader, "case-sensitive") == 0) {
					fCaseSensitive = TRUE;
				} else if (lstrcmpi(pszHeader, "case-insensitive") == 0) {
					fCaseSensitive = FALSE;
				} else {
					return E_INVALIDARG;
				}
			} else {
				// they are doing a header comparison
				
				// check to see if the right side of the = is blank
				if (pszPatterns[1] == 0) {
					pszPatterns = NULL;
				} else {
					*pszPatterns = 0;
					(pszPatterns++);
				}

				if (lstrcmpi(pszHeader, ":newsgroups") == 0) {
					// call into the newsgroup rule engine to handle this
					hr = NewsgroupPatternsRule(pbNNTPBinding, pszPatterns);
					// if we got back S_FALSE or an error then return that
					if (hr != S_OK) return hr;
				} else if (lstrcmpi(pszHeader, ":feedid") == 0) {
					// call into the feedid rule engine to handle this
					hr = FeedIDRule(pbNNTPBinding, pszPatterns);
					// if we got back S_FALSE or an error then return that
					if (hr != S_OK) return hr;
				} else {
					// we now have the header that we are looking for in 
					// pszHeader and the list of patterns that we are interested 
					// in pszPatterns.  Make the lookup into the header
					// data structure
					char szHeaderData[4096];
					DWORD cHeaderData;
					BOOL f = m_pArticle->fGetHeader(pszHeader, 
													(BYTE *) szHeaderData, 
										   		    4096, cHeaderData);
					if (!f) {
						switch (GetLastError()) {
							case ERROR_INSUFFICIENT_BUFFER:
								// BUGBUG - should handle this better.  for now we
								// just assume that the header doesn't match
								return S_FALSE;
								break;
							case ERROR_INVALID_NAME:
								// header wasn't found
								return S_FALSE;
								break;
							default:
								_ASSERT(FALSE);
								return(HRESULT_FROM_WIN32(GetLastError()));
								break;
						}
					} else {
						// convert the trailing \r\n to 0
						szHeaderData[cHeaderData - 2] = 0;
						// if there is no pszContents then just having the header
						// is good enough.
						if (pszPatterns == NULL) return S_OK;

						// if they don't care about case then lowercase the
						// string
						if (!fCaseSensitive) _strlwr(szHeaderData);
		
						// assume that we won't find a match.  once we do
						// find a match then we are okay and we'll stop looking
						// for further matches
						hr = S_FALSE;
						do {
							char *pszComma = strchr(pszPatterns, ',');
							if (pszComma != NULL) *pszComma = 0;

							// if they don't care about case then lowercase the
							// string
							if (!fCaseSensitive) _strlwr(pszPatterns);
		
							// check to see if it passes the pattern that we have
							switch (HrMatchWildmat(szHeaderData, pszPatterns)) {
								case ERROR_SUCCESS: 
									hr = S_OK;
									break;
								case ERROR_FILE_NOT_FOUND: 
									break;
								default: 
									hr = HRESULT_FROM_WIN32(hr); 
									break;
							}
	
							// the next pattern is past the comma
							pszPatterns = (pszComma == NULL) ? NULL : pszComma + 1;
						} while (pszPatterns != NULL && hr == S_FALSE);
						// if we didn't find a match or if there was an error
						// then bail
						if (hr != S_OK) return hr;
					}
				}
			}

			// if we get here then everything should have matched so far
			_ASSERT(hr == S_OK);

			// the next pattern is the one past the end of the semicolon
			pszHeader = (pszSemiColon == NULL) ? NULL : pszSemiColon + 1;
		}
	} 

	return hr;
}

//
// call the child object
//
HRESULT CNNTPDispatcher::CNNTPParams::CallObject(CBinding &bBinding,
												 IUnknown *punkObject) 
{
	HRESULT hr = S_OK;
	INNTPFilter *pFilter;

	hr = FillInMailMsgForSEO(m_pMailMsg, m_pArticle, m_pGrouplist);
	if (SUCCEEDED(hr)) {
		hr = punkObject->QueryInterface(IID_INNTPFilter, (void **) &pFilter);
		if (SUCCEEDED(hr)) {
			hr = pFilter->OnPost(m_pMailMsg);
			pFilter->Release();
		} else if (hr == E_NOINTERFACE) {
			hr = CallCdoObject(punkObject);
		}
	}

	return hr;
}

//
// Call a CDO child object
//
HRESULT CNNTPDispatcher::CNNTPParams::CallCdoObject(IUnknown *punkObject) {
	HRESULT hr = S_OK;
	void *pFilter;
	CdoEventStatus eStatus = cdoRunNextSink;
	IID iidInterface;
	CdoEventType eEventType;
	
	if (m_iidEvent == CATID_NNTP_ON_POST_EARLY) {
		iidInterface = IID_INNTPOnPostEarly;
		eEventType = cdoNNTPOnPostEarly;
	} else if (m_iidEvent == CATID_NNTP_ON_POST_FINAL) {
		iidInterface = IID_INNTPOnPostFinal;
		eEventType = cdoNNTPOnPostFinal;
	} else {
		iidInterface = IID_INNTPOnPost;
		eEventType = cdoNNTPOnPost;
		_ASSERT(m_iidEvent == CATID_NNTP_ON_POST);
	}

	// QI for the CDO interface
	hr = punkObject->QueryInterface(iidInterface, &pFilter);

	if (SUCCEEDED(hr)) {
		// see if we need to create a CDO message object
		if (m_pCDOMessage == NULL) {
			hr = CoCreateInstance(CLSID_Message,
								  NULL,
								  CLSCTX_INPROC_SERVER,
								  IID_IMessage,
								  (void **) &m_pCDOMessage);
			if (SUCCEEDED(hr)) {
				IConstructIMessageFromIMailMsg *pConstruct;
				hr = m_pCDOMessage->QueryInterface(
						IID_IConstructIMessageFromIMailMsg,
						(void **) &pConstruct);
				if (SUCCEEDED(hr)) {
					hr = pConstruct->Construct(eEventType, m_pMailMsg);
					pConstruct->Release();
				}
				if (FAILED(hr)) {
					m_pCDOMessage->Release();
					m_pCDOMessage = NULL;
				}
			}
		}

		// call the CDO interface
		switch (eEventType) {
			case cdoNNTPOnPostEarly:
				hr = ((INNTPOnPostEarly *) pFilter)->OnPostEarly(m_pCDOMessage, &eStatus);
				((INNTPOnPostEarly *) pFilter)->Release();
				break;
			case cdoNNTPOnPost:
				hr = ((INNTPOnPost *) pFilter)->OnPost(m_pCDOMessage, &eStatus);
				((INNTPOnPost *) pFilter)->Release();
				break;
			case cdoNNTPOnPostFinal:
				hr = ((INNTPOnPostFinal *) pFilter)->OnPostFinal(m_pCDOMessage, &eStatus);
				((INNTPOnPostFinal *) pFilter)->Release();
				break;
			default:
				_ASSERT(FALSE);
				hr = E_UNEXPECTED;
				break;
		}
	}

	if (eStatus == cdoSkipRemainingSinks) hr = S_FALSE;

	return hr;
}

HRESULT STDMETHODCALLTYPE CNNTPDispatcher::OnPost(REFIID iidEvent,
												  void *pArticle,
												  void *pGrouplist,
												  DWORD dwFeedId,
												  void *pMailMsg)
{
	// create the params object, and pass it into the dispatcher
	CNNTPParams NNTPParams;
	
	NNTPParams.Init(iidEvent,
					(CArticle *) pArticle,
					(CNEWSGROUPLIST *) pGrouplist, 
					dwFeedId,
					(IMailMsgProperties *) pMailMsg);

	return Dispatcher(iidEvent, &NNTPParams);
}

//
// trigger an nntp server event
//
// arguments:
//    [in] pRouter - the router object returned by MakeServerEventsRouter
//    [in] iidEvent - the GUID for the event
//    [in] pArticle - the article 
//    [in] pGrouplist - the newsgroup list
//	  [in] dwOperations - bitmask of operations that filter doesn't want
//						  server to do.
// returns:
//    S_OK - success
//    <else> - error
//
HRESULT TriggerServerEvent(IEventRouter *pRouter,
						   IID iidEvent,
						   CArticle *pArticle,
						   CNEWSGROUPLIST *pGrouplist,
						   DWORD dwFeedId,
						   IMailMsgProperties *pMailMsg) 
{
	CNNTPDispatcherClassFactory cf;
	CComPtr<INNTPDispatcher> pEventDispatcher;
	HRESULT hr;
	DWORD htokSecurity;

	if (pRouter == NULL) return E_POINTER;

	hr = pRouter->GetDispatcherByClassFactory(CLSID_CNNTPDispatcher,
										 	  &cf,
										 	  iidEvent,
										 	  IID_INNTPDispatcher,
										 	  (IUnknown **) &pEventDispatcher);
	if (FAILED(hr)) return hr;

	hr = pEventDispatcher->OnPost(iidEvent, 
								  pArticle, 
								  pGrouplist, 
								  dwFeedId, 
								  pMailMsg);
	return hr;
}

DWORD ComputeDropHash(const  LPCSTR& lpstrIn) {
	//
	//	Compute a hash value for the newsgroup name
	//
	return	INNHash( (BYTE*)lpstrIn, lstrlen( lpstrIn ) ) ;
}

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
#include "nntpdisp_i.c"
#include "nntpfilt_i.c"
#include "cdo_i.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\nntp\server\post\src\seodisp.h ===
#ifndef __SEODISP_H__
#define __SEODISP_H__
#define _ATL_NO_DEBUG_CRT
#define _WINDLL
//#include "stdafx.h"
#define _ASSERTE _ASSERT
#include "atlbase.h"
extern CComModule _Module;
#include "atlcom.h"
#undef _WINDLL
#include "seolib.h"
#include "seo.h"
#include "nntpdisp.h"
#include "nntpfilt.h"
#include "ddroplst.h"
#include "cdo.h"

#define MAX_RULE_LENGTH 4096

class CNNTPDispatcher :
		public CEventBaseDispatcher,
		public CComObjectRoot,
		public INNTPDispatcher
{
	public:
		DECLARE_PROTECT_FINAL_CONSTRUCT();
	
#if 0
		DECLARE_REGISTRY_RESOURCEID_EX(IDR_StdAfx,
									   L"NNTPDispatcher.Class",
									   L"NNTP.Dispatcher.1",
									   L"NNTP.Dispatcher");
#endif
	
		DECLARE_GET_CONTROLLING_UNKNOWN();

		DECLARE_NOT_AGGREGATABLE(CNNTPDispatcher);
	
		BEGIN_COM_MAP(CNNTPDispatcher)
			COM_INTERFACE_ENTRY(IEventDispatcher)
			COM_INTERFACE_ENTRY(INNTPDispatcher)
			COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_pUnkMarshaler.p)
		END_COM_MAP()

		// this code gets called during initialization
		HRESULT FinalConstruct() {
			HRESULT hr;
			// we need to do this to signal that we are free threaded
			hr = CoCreateFreeThreadedMarshaler(GetControllingUnknown(), &m_pUnkMarshaler.p);
			// if SUCCEEDED(hr) then hr must be S_OK
			_ASSERT((!SUCCEEDED(hr)) || hr == S_OK);
			// if SUCCEEDED(hr) return S_OK else return hr;
			return (SUCCEEDED(hr)) ? S_OK : hr;
		}

		// this has the global destructor code in it
		void FinalRelease() {}

		class CNNTPBinding : public CEventBaseDispatcher::CBinding {
			public:
				virtual HRESULT Init(IEventBinding *piBinding);
			public:
				CComVariant m_vRule;
				DWORD m_cRule;
				CDDropGroupSet m_groupset;
				BOOL m_fGroupset;
		};

		virtual HRESULT AllocBinding(REFGUID rguidEventType,
									 IEventBinding *piBinding,
									 CBinding **ppNewBinding)
		{
			if (ppNewBinding) *ppNewBinding = NULL;
			if (!piBinding || !ppNewBinding) return E_POINTER;
			*ppNewBinding = new CNNTPBinding;
			if (*ppNewBinding == NULL) return E_OUTOFMEMORY;
			return S_OK;
		}

		class CNNTPParams : public CEventBaseDispatcher::CParams {
			public:
				CNNTPParams();
				void Init(IID iidEvent,
						  CArticle *pArticle,
						  CNEWSGROUPLIST *pGrouplist,
						  DWORD dwFeedId,
						  IMailMsgProperties *pMailMsg);
				~CNNTPParams();
				virtual HRESULT CheckRule(CBinding &bBinding);
				virtual HRESULT CallObject(CBinding &bBinding, IUnknown *punkObject);
				virtual HRESULT CallCdoObject(IUnknown *punkObject);
			private:
				HRESULT HeaderPatternsRule(CNNTPBinding *pbNNTPBinding);
				HRESULT GroupListRule(CNNTPBinding *pbNNTPBinding);
				HRESULT NewsgroupPatternsRule(CNNTPBinding *pbNNTPBinding,
											  char *pszNewsgroupPatterns);
				HRESULT FeedIDRule(CNNTPBinding *pbNNTPBinding,
								   char *pszFeedIDs);
			public:
				CArticle *m_pArticle;
				CNEWSGROUPLIST *m_pGrouplist;
				DWORD m_dwFeedId;
				IMailMsgProperties *m_pMailMsg;
				IMessage *m_pCDOMessage;
				IID m_iidEvent;

				// our local copy of the rule
				char *m_szRule;
		};

		HRESULT STDMETHODCALLTYPE OnPost(REFIID iidEvent,
										 void *pArticle,
										 void *pGrouplist,
										 DWORD dwFeedId,
										 void *pMailMsg);

	private:
		CComPtr<IUnknown> m_pUnkMarshaler;
};

class CNNTPDispatcherClassFactory : public IClassFactory {
	HRESULT STDMETHODCALLTYPE QueryInterface(REFIID riid, void * * ppvObj) {
		_ASSERT(FALSE);
		return E_NOTIMPL;
	}
	unsigned long  STDMETHODCALLTYPE AddRef () { _ASSERT(FALSE); return 0; }
	unsigned long  STDMETHODCALLTYPE Release () { _ASSERT(FALSE); return 0; }

	// *** IClassFactory methods ***
	HRESULT STDMETHODCALLTYPE CreateInstance (LPUNKNOWN pUnkOuter, REFIID riid,  void * * ppvObj) {
		return CComObject<CNNTPDispatcher>::_CreatorClass::CreateInstance(pUnkOuter, riid, ppvObj);
	}
	HRESULT STDMETHODCALLTYPE LockServer (int fLock) {
		_ASSERT(FALSE);
		return E_NOTIMPL;
	}
};
	

HRESULT TriggerServerEvent(IEventRouter *pRouter,
						   IID iidEvent,
						   CArticle *pArticle,
						   CNEWSGROUPLIST *pGrouplist,
						   DWORD dwFeedId,
						   IMailMsgProperties *pMailMsg);

HRESULT FillInMailMsgForSEO(IMailMsgProperties *pMsg,
							CArticle *pArticle,
					  		CNEWSGROUPLIST *pGrouplist);


DEFINE_GUID(GUID_NNTPSVC,
0x8e3ecb8c, 0xe9a, 0x11d1, 0x85, 0xd1, 0x0, 0xc0, 0x4f, 0xb9, 0x60, 0xea);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\nntp\server\post\src\stdinc.h ===
#ifndef	_STDINC_H_
#define	_STDINC_H_

//
// disables a browser info warning that breaks the build
//
#pragma warning (disable:4786)

//
// disables redundant warning about / in // comments
//
#pragma warning (disable:4010)

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <winsock2.h>

#include <xmemwrpr.h>
#include <malloc.h>
#include <imd.h>

#include <rpc.h>
#define SECURITY_WIN32
#include <wincrypt.h>
#include <sspi.h>
#include <spseal.h>
#include <ntlmsp.h>
        //#include <sslsp.h>
#include <buffer.hxx>

#include <pudebug.h>
#include <iistypes.hxx>
#include <simssl2.h>
#include <tssec.hxx>
#include <simauth2.h>
#include <nntptype.h>
#include <nntps.h>
#include <nntpapi.h>
#include <tigdflts.h>
#include <tsunami.hxx>
#include <nntpmeta.h>
#include <time.h>
#include <smartptr.h>
#include <fcache.h>
#include <tcpproc.h>
#include <nntpcons.h>

#include "dbgtrace.h"
//#include "resource.h"

#include "tigtypes.h"
#include "fsconst.h"
#include "crchash.h"

#ifdef PROFILING
#include "icapexp.h"
#endif

typedef char *LPMULTISZ;

#include <instwpex.h>
#include "nntpvr.h"
#include "group.h"
#include "nwstree.h"
#include "nntpbag.h"
#include "nntperr.h"
#include <ihash.h>
#include <atq.h>

#include "cbuffer.h"
#include "cfeed.h"
#include "infeed.h"
#include "fromclnt.h"
#include "frompeer.h"
#include "frommstr.h"
#include "sfromcl.h"
#include "nntputil.h"
#include "seo.h"
#include "cstream.h"
#include "mailmsg.h"
#include "mailmsgi.h"
#include "seodisp.h"
#include <randfail.h>
#include <nntpdrv.h>
#include "smtpdll.h"
#include "nntpmsg.h"
#include "cdoconstimsg.h"

VOID
NntpLogEvent(
    IN DWORD  idMessage,              // id for log message
    IN WORD   cSubStrings,            // count of substrings
    IN const CHAR * apszSubStrings[], // substrings in the message
    IN DWORD  errCode                 // error code if any
    );

#pragma hdrstop

#endif	// _STDINC_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\nntp\server\post\src\sfromcl.cpp ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    sfromcl.cpp

Abstract:

	Contains InFeed, Article, and Fields code specific to SlaveFromClient Infeeds


Author:

    Carl Kadie (CarlK)     12-Dec-1995

Revision History:

--*/


#include "stdinc.h"


BOOL
CSlaveFromClientArticle::fMungeHeaders(
							 CPCString& pcHub,
							 CPCString& pcDNS,
							 CNAMEREFLIST & grouplist,
							 DWORD remoteIpAddress,
							 CNntpReturn & nntpReturn,
							 PDWORD pdwLinesOffset
			  )
/*++

Routine Description:

	 Just like FromClientArticle's fMungeHeaders only doesn't create a xref,
		 just removes it


Arguments:

	grouplist - a list of the newsgroups the article is posted to.
	nntpReturn - The return value for this function call


Return Value:

	TRUE, if successful. FALSE, otherwise.    

--*/
{
	nntpReturn.fSetClear(); // clear the return object

	if (!(
  			   m_fieldMessageID.fSet(*this, pcDNS, nntpReturn)
  			&& m_fieldNewsgroups.fSet(*this, nntpReturn)
  			&& m_fieldDistribution.fSet(*this, nntpReturn)
  			&& m_fieldDate.fSet(*this, nntpReturn)
  			&& m_fieldOrganization.fSet(*this, nntpReturn)
			/* && m_fieldLines.fSet(*this, nntpReturn) */
  			&& m_fieldPath.fSet(*this, pcHub, nntpReturn)
			&& m_fieldNNTPPostingHost.fSet(*this, remoteIpAddress, nntpReturn)
			/* && m_fieldXAuthLoginName.fSet(*this, nntpReturn) */
			/* && m_fieldXref.fSet(*this, nntpReturn) */
			&& fDeleteEmptyHeader(nntpReturn)
			&& fSaveHeader(nntpReturn)
		))
		return nntpReturn.fFalse();

	//
	// We didn't seem to care about Lines field, tell the caller not to back 
	// fill
	//
	if ( pdwLinesOffset ) *pdwLinesOffset = INVALID_FILE_SIZE;

	return nntpReturn.fSetOK();
}

BOOL
CSlaveFromClientFeed::fPostInternal (
									 CNntpServerInstanceWrapper * pInstance,
									 const LPMULTISZ	szCommandLine, //the Post, Xreplic, IHave, etc. command line
									 CSecurityCtx   *pSecurityCtx,
									 CEncryptCtx *pEncryptCtx,
									 BOOL fAnonymous,
									 CARTPTR	& pArticle,
                                     CNEWSGROUPLIST &grouplist,
                                     CNAMEREFLIST &namereflist,
                                     IMailMsgProperties *pMsg,
									 CAllocator & allocator,
									 char*		& multiszPath,
									 char*		pchGroups,
									 DWORD		cbGroups,
									 DWORD		remoteIpAddress,
									 CNntpReturn & nntpReturn,
                                     PFIO_CONTEXT *ppFIOContext,
                                     BOOL *pfBoundToStore,
                                     DWORD *pdwOperations,
                                     BOOL *pfPostToMod,
                                     LPSTR  szModerator
						)
/*++

Routine Description:


	 Does most of the processing for an incoming article.


Arguments:

	hFile - The handle of the file.
	szFilename - The name of the file.
	szCommandLine -  the Post, Xreplic, IHave, etc. command line
	pArticle - a pointer to the article being processed
	pGrouplist - pointer to a list of newsgroup objects to post to.
	pNamerefgroups - pointer to a list of the names, groupid and article ids of the article
	nntpReturn - The return value for this function call


Return Value:

	TRUE, if successful. FALSE, otherwise.    

--*/
{
 	TraceFunctEnter( "CSlaveFromClientFeed::fPostInternal" );

    HRESULT hr      = S_OK;
    HANDLE  hToken  = NULL;

	nntpReturn.fSetClear(); // clear the return object

	CNewsTreeCore*  pNewstree = pInstance->GetTree() ;
	CPCString pcHub(pInstance->NntpHubName(), pInstance->HubNameSize());
	CPCString pcDNS(pInstance->NntpDNSName(), pInstance->NntpDNSNameSize()) ;

	//
	// Validate the article
	//

	if (!pArticle->fValidate(pcHub, szCommandLine, this, nntpReturn))
		return nntpReturn.fFalse();
	
	//
	// Find the list of newsgroups the poster wants to post to.
	//

	DWORD cNewsgroups = pArticle->cNewsgroups();
	if (!grouplist.fInit(cNewsgroups, pArticle->pAllocator()))
		return nntpReturn.fSet(nrcMemAllocationFailed, __FILE__, __LINE__);

	if (!namereflist.fInit(cNewsgroups, pArticle->pAllocator()))
		return nntpReturn.fSet(nrcMemAllocationFailed, __FILE__, __LINE__);

	if (!fCreateGroupLists(pNewstree, pArticle, grouplist, (CNAMEREFLIST*)NULL, szCommandLine, pcHub, nntpReturn))
		return nntpReturn.fFalse();

	//
	//	Set up the namereflist object to refer to the slave posting group !
	//

	CGRPCOREPTR pGroup = pNewstree->GetGroupById(pNewstree->GetSlaveGroupid());//!!!!!pNewstree->GetSlaveGroupid()
	if (!pGroup)
	{
		_ASSERT(FALSE);
		return nntpReturn.fSet(nrcSlaveGroupMissing);
	}


	// Alocate the article id
    ARTICLEID   articleId ;

	articleId = pGroup->AllocateArticleId();

	NAME_AND_ARTREF	Nameref ;
	(Nameref.artref).m_groupId = pGroup->GetGroupId() ;
	(Nameref.artref).m_articleId = articleId ;
	(Nameref.pcName).vInsert( pGroup->GetName() ) ;
	namereflist.AddTail( Nameref ) ;

	if( grouplist.IsEmpty() ) 
	{
        // If this is a newgroup control message it is ok to have an empty grouplist at this stage
        CONTROL_MESSAGE_TYPE cmControlMessage = pArticle->cmGetControlMessage();

        if(cmNewgroup != cmControlMessage)
        {
			BOOL	fOk = nntpReturn.fSet(nrcNoGroups()) ;

			if( !fOk ) {
				return	fOk ;
			}
		}
	}

    //
    //  moderated newsgroup check (check Approved: header for moderator)
    //
	if (!fModeratedCheck(   pInstance,
	                        pArticle, 
	                        grouplist, 
	                        gHonorApprovedHeaders, 
	                        nntpReturn,
	                        szModerator ))
    {
        //
        // If FALSE is returned, we'll still check nntpReturn, if nntpReturn is
        // OK, it means the group is moderated and we should mail the message
        // to moderator;  otherwise it's a real failed case
        //
        if ( !nntpReturn.fIsOK() ) return FALSE;
        else {
            *pfPostToMod = TRUE;
        }
    }

	//
	//	Now do security check
	//
	if( pSecurityCtx || pEncryptCtx ) {
		if( !fSecurityCheck( pSecurityCtx, pEncryptCtx, grouplist, nntpReturn ) ) 
			return	nntpReturn.fFalse() ;
	}
    
    // Should not apply control message at all at this point, we should apply
    // control message when the post comes back from master

	//
  	// Looks OK so munge the headers
    // remove xref and add path
    //

	if (!pArticle->fMungeHeaders(pcHub, pcDNS, namereflist, remoteIpAddress, nntpReturn))
		return nntpReturn.fFalse();

	if( pchGroups != 0 ) 
		SaveGroupList(	pchGroups,	cbGroups, grouplist ) ;

	//
	// Move the article to a local place, and then queues it up on any outfeeds
	//

	pArticle->vFlush() ;
	pArticle->vClose();

    //
    // at this point we are ready to go, talk to the first driver and 
    // get a file handle that we can write to
    //
    CNNTPVRoot *pVRoot = pGroup->GetVRoot();
    _ASSERT( pVRoot );
    IMailMsgStoreDriver *pStoreDriver = pVRoot->GetStoreDriver();
    if ( NULL == pStoreDriver ) {
        pVRoot->Release();
        return nntpReturn.fSet( nrcNewsgroupInsertFailed, pGroup->GetGroupName(), pArticle->szMessageID() );
    }

    //
    // Get the right hToken: the post should have permission to post
    // to the slave group
    //
    if ( pVRoot->GetImpersonationHandle() )
        hToken = pVRoot->GetImpersonationHandle();
    else {
        if ( NULL == pEncryptCtx && pSecurityCtx == NULL )
            hToken = NULL;
        else if ( pEncryptCtx->QueryCertificateToken() ) {
            hToken = pEncryptCtx->QueryCertificateToken();
        } else {
            hToken = pSecurityCtx->QueryImpersonationToken();
        }
    }

    //
    // Fill up properties into mailmsg: we know that slave group is going to 
    // be file system only, so passing in group pointer and article id would be
    // enough
    //
    hr = FillInMailMsg(pMsg, pGroup, articleId, hToken, szModerator ); 
    if ( SUCCEEDED( hr ) ) {
        pMsg->AddRef();
        HANDLE hFile;
        IMailMsgPropertyStream *pStream = NULL;
        hr = pStoreDriver->AllocMessage( pMsg, 0, &pStream, ppFIOContext, NULL );
        if ( SUCCEEDED( hr ) && pStream == NULL ) {
            pStream = XNEW CDummyMailMsgPropertyStream;
            if ( NULL == pStream ) hr = E_OUTOFMEMORY;
        }
        if ( SUCCEEDED( hr ) ) {

            //
            // Bind the handle to the mailmsg object
            //
            IMailMsgBind *pBind = NULL;
            hr = pMsg->QueryInterface(__uuidof(IMailMsgBind), (void **) &pBind);
            if ( SUCCEEDED( hr ) ) {
                hr = pBind->BindToStore(    pStream,
                                            pStoreDriver,
                                            *ppFIOContext );
                if ( SUCCEEDED( hr ) ) *pfBoundToStore = TRUE;
            }
            if ( pBind ) pBind->Release();
            pBind = NULL;
        }
    }
    
    if ( pStoreDriver ) pStoreDriver->Release();
    pStoreDriver = NULL;
    if ( pVRoot ) pVRoot->Release();
    pVRoot = NULL;

    if ( FAILED( hr ) ) return nntpReturn.fSet( nrcNewsgroupInsertFailed, NULL, NULL ); 

    //
    // Now ready to put it into push feed queue
    //
    /* not until we have committed the post
	CArticleRef	articleRef( pGroup->GetGroupId(), articleId ) ;
	if( !pInstance->AddArticleToPushFeeds( grouplist, articleRef, multiszPath, nntpReturn ) )
		return	nntpReturn.fFalse() ;
    */

	TraceFunctLeave();
	return nntpReturn.fSetOK();
}

HRESULT CSlaveFromClientFeed::FillInMailMsg(IMailMsgProperties *pMsg, 
							                CNewsGroupCore *pGroup, 
							                ARTICLEID   articleId,
							                HANDLE       hToken,
                                            char*       pszApprovedHeader )
/*++
Routine description:

    Fill in properties into mailmsg object so that driver can get those
    properties on AllocMessage

Arguments:

    IMailMsgProperties *pMsg    - The message object
    CNNTPVRoot *pVRoot          - Pointer to the vroot
    CNewsGroupCore *pGroup      - The group to alloc the message from
    ARTICLEID   articleId       - The article id for this article
    HANDLE      hToken          - Client hToken

Return value:

    HRESULT
--*/
{
	TraceFunctEnter("CSlaveFromClientFeed::FillInMailMsg");
	
	DWORD i=0;
	DWORD rgArticleIds[1];
	INNTPPropertyBag *rgpGroupBags[1];
	HRESULT hr;

    //
	// build up the entries needed in the property bag
	//
	rgpGroupBags[0] = pGroup->GetPropertyBag();

	//
	// we don't need to keep this reference because we have a reference
	// counted one already in the pGroup and we know that AllocMessage
	// is synchronous
	//.  
	rgpGroupBags[0]->Release();
	rgArticleIds[0] = articleId;
	
	DebugTrace( 0, 
				"group %s, article %i", 
				pGroup->GetGroupName(),
				articleId);

	hr = FillMailMsg(pMsg, rgArticleIds, rgpGroupBags, 1, hToken, pszApprovedHeader );
	if (FAILED(hr)) return hr;

	TraceFunctLeave();
	return S_OK;
}

void CSlaveFromClientFeed::CommitPostToStores(  CPostContext *pContext, 
                                                CNntpServerInstanceWrapper *pInstance)
/*++
Routine description:

    Since we know that sfromclient type of post will be only posted to
    slave group in file system.  We pretty much don't need to do anything
    here except to put the article into feed queue

Arguments:

    CPostContext *pContext  - Post context

Return value:

    None.
--*/
{
	TraceFunctEnter("CSlaveFromclientFeed::CommitPostToStores");
	_ASSERT( pContext );
	_ASSERT( pInstance );

	CNntpReturn ret;

	//
	// If it's posted to a moderated group, we'll try to apply
	// the moderator stuff by sending out the article
	//
	if ( pContext->m_fPostToMod ) {

	    pContext->CleanupMailMsgObject();
	    ApplyModerator( pContext, ret );

	    if ( ret.fIsOK() ) 
	        pContext->m_completion.m_nntpReturn.fSet( nrcArticleAccepted(pContext->m_fStandardPath) );
	    else
	        pContext->m_completion.m_nntpReturn.fSet( nrcArticleRejected(pContext->m_fStandardPath) );
	} else {

    	//
	    // We try real hard to get the slave group id and article id from namereflist
    	// remember ?  we added the slave group ref info to tail of namereflist
	    //
    	POSITION posNamereflist = pContext->m_namereflist.GetHeadPosition();
	    NAME_AND_ARTREF *pnameref;
    	DWORD       err;

	    while( posNamereflist ) {
	        pnameref = pContext->m_namereflist.GetNext( posNamereflist );
        }

        //
        // There must be one art ref in there
        //
        _ASSERT( pnameref );

	    //
    	// Put it onto push feed queue
	    //
    	if( !pInstance->AddArticleToPushFeeds(  pContext->m_grouplist, 
	                                            pnameref->artref, 
	                                            pContext->m_multiszPath, 
	                                            ret ) ) {
    	    err = GetLastError();
	        if ( NO_ERROR == err ) err = ERROR_NOT_ENOUGH_MEMORY;
	        pContext->m_completion.SetResult( HRESULT_FROM_WIN32( err ) );
    	    pContext->m_completion.m_nntpReturn.fSet( nrcArticleRejected( pContext->m_fStandardPath),
	                                                ret.m_nrc, 
	                                                ret.szReturn() );
    	} else {
	        pContext->m_completion.SetResult( S_OK );
	        pContext->m_completion.m_nntpReturn.fSet( nrcArticleAccepted( pContext->m_fStandardPath));
    	}
    }

	//
	// Before we release the completion object, we should tell the destroy guy 
	// that 1. we are the only group to be committed and hence we are done; 2.
	// set the flag telling it not to insert us into map entries
	//
	pContext->m_completion.m_fWriteMapEntries = FALSE;
	pContext->m_cStoreIds = pContext->m_cStores;

	//
	// Now release the completion object
	//
	pContext->m_completion.Release();

	TraceFunctLeave();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\nntp\server\post\src\frompeer.cpp ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    fromclnt.cpp

Abstract:

	Contains InFeed, Article, and Fields code specific to Peer Infeeds


Author:

    Carl Kadie (CarlK)     12-Dec-1995

Revision History:

--*/


#include "stdinc.h"


BOOL
CFromPeerArticle::fValidate(
						CPCString& pcHub,
						const char * szCommand,
						CInFeed*	pInFeed,
				  		CNntpReturn & nntpReturn
						)
/*++

Routine Description:

	Validates an article from a peer. Does not change the article.

Arguments:

	szCommand - The arguments (if any) used to post/xreplic/etc this article.
	nntpReturn - The return value for this function call


Return Value:

	TRUE, if successful. FALSE, otherwise.    

--*/
{
	nntpReturn.fSetClear(); // clear the return object

	/* Son of 1036 says:
          An article MUST have one, and only one, of each of the  fol-
          lowing headers: Date, From, Message-ID, Subject, Newsgroups,
          Path.
		  */

	//
	// Check the message id first
	//

	if (!m_fieldMessageID.fFindAndParse(*this, nntpReturn))
			return nntpReturn.fFalse();

	if (m_pInstance->ArticleTable()->SearchMapEntry(m_fieldMessageID.szGet())
		|| m_pInstance->HistoryTable()->SearchMapEntry(m_fieldMessageID.szGet()))
	{
		nntpReturn.fSet(nrcArticleDupMessID, m_fieldMessageID.szGet(), GetLastError());
		return nntpReturn.fFalse();
	}
	
	//
	// From here on, we want to add an entry to the history table
	// even if the article was rejected.
	//

	//
	// Create a list of the fields of interest
	//

	CField * rgPFields [] = {
            &m_fieldControl,
			&m_fieldDate,
			&m_fieldLines,
			&m_fieldFrom,
			&m_fieldSubject,
			&m_fieldNewsgroups,
			&m_fieldDistribution,
			&m_fieldPath
				};

	DWORD cFields = sizeof(rgPFields)/sizeof(CField *);

	nntpReturn.fSetOK(); // assume the best

	if (fFindAndParseList((CField * *)rgPFields, cFields, nntpReturn))
	{
		//
		// check that this hub does not appear as a relayer in the path
		//
		m_fieldPath.fCheck(pcHub, nntpReturn);
	}

	CPCString	pcDate = m_fieldDate.pcGet() ;
	if( pcDate.m_pch != 0 ) {
	
		if( !AgeCheck( pcDate ) ) {
			nntpReturn.fSet( nrcArticleDateTooOld ) ;

			//
			//	Most errors we should store the message-id in the hash tables
			//	so that they can make into the history table later.  But if we 
			//	did that in this case, then by sending us article with old dates
			//	we could be forced to overflow our History Table.  We know that 
			//	we will reject the article if it comes around again - so why bother ?
			//

			return	FALSE ;
		}
	}

	//
	// Even if parsing and the path check failed, insert the article's
	// message id in the article table.
	//

	if (!m_pInstance->ArticleTable()->InsertMapEntry(m_fieldMessageID.szGet(), NULL))
		return nntpReturn.fSet(nrcHashSetFailed, m_fieldMessageID.szGet(), "Article",
				GetLastError() );

	// nntpReturn.fIsOK could be true or false depending on how find/parse and path
	// check went.
	//

	return nntpReturn.fIsOK();
}


BOOL
CFromPeerArticle::fMungeHeaders(
							 CPCString& pcHub,
							 CPCString& pcDNS,
							 CNAMEREFLIST & grouplist,
							 DWORD remoteIpAddress,
							 CNntpReturn & nntpReturn,
							 PDWORD     pdwLinesOffset
			  )
/*++

Routine Description:


	 Modify the headers.


Arguments:

	grouplist - a list of newsgroups to post to (name, groupid, article id)
	nntpReturn - The return value for this function call


Return Value:

	TRUE, if successful. FALSE, otherwise.    

--*/
{
	nntpReturn.fSetClear(); // clear the return object

	if (!(
  			m_fieldPath.fSet(pcHub, *this, nntpReturn)
			&& m_fieldLines.fSet(*this, nntpReturn)
			&& m_fieldXref.fSet(pcHub, grouplist, *this, m_fieldNewsgroups, nntpReturn)
			&& fSaveHeader(nntpReturn)
		))
		return nntpReturn.fFalse();

	//
	// If we the lines line was already there, we'll tell the caller not
	// to back fill the lines information
	//
	if ( pdwLinesOffset && !m_fieldLines.fNeedBackFill() )
	    *pdwLinesOffset = INVALID_FILE_SIZE;

	return nntpReturn.fSetOK();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\nntp\server\seo\ddrop\filter.h ===
#ifndef __FILTER_H__
#define __FILTER_H__

#include "nntpfilt.h"

class ATL_NO_VTABLE CNNTPDirectoryDrop : 
	public INNTPFilter,
	public IPersistPropertyBag,
	public CComObjectRoot,
	public CComCoClass<CNNTPDirectoryDrop, &CLSID_CNNTPDirectoryDrop>
{
	public:
		HRESULT FinalConstruct();
		void FinalRelease();

	DECLARE_PROTECT_FINAL_CONSTRUCT();

	DECLARE_REGISTRY_RESOURCEID_EX(IDR_StdAfx,
								   L"NNTP DirectoryDrop Class",
								   L"NNTP.DirectoryDrop.1",
								   L"NNTP.DirectoryDrop");

	DECLARE_GET_CONTROLLING_UNKNOWN();

	BEGIN_COM_MAP(CNNTPDirectoryDrop)
		COM_INTERFACE_ENTRY(INNTPFilter)
		COM_INTERFACE_ENTRY(IPersistPropertyBag)
		COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_pUnkMarshaler.p)
	END_COM_MAP()

	// INNTPFilter
	public:
		HRESULT STDMETHODCALLTYPE OnPost(IMailMsgProperties *pMessage);
	// IPersistPropertyBag
	public:
		HRESULT STDMETHODCALLTYPE GetClassID(CLSID *pCLSID) {
			if (!pCLSID) return (E_POINTER);
			*pCLSID = CLSID_CNNTPDirectoryDrop;
			return (S_OK);
		}

		HRESULT STDMETHODCALLTYPE InitNew() {
			return (S_OK);
		}

		HRESULT STDMETHODCALLTYPE Load(IPropertyBag *pProps, 
									   IErrorLog *pErrorLog) 
		{
			HRESULT hrRes;
			CComVariant varValue;

			if (!pProps) return (E_POINTER);
			hrRes = pProps->Read(L"Drop Directory",&varValue,pErrorLog);
			if (SUCCEEDED(hrRes)) {
				hrRes = varValue.ChangeType(VT_BSTR);
				if (SUCCEEDED(hrRes)) {
					if (lstrlenW(varValue.bstrVal) < MAX_PATH) {
						lstrcpyW(m_wszDropDirectory, varValue.bstrVal);
					}
				}
			}
			return (S_OK);
		}

		HRESULT STDMETHODCALLTYPE Save(IPropertyBag *pProps, 
									   BOOL fClearDirty, 
									   BOOL fSaveAllProperties) 
		{
			return (S_OK);
		}
	private:
		CComPtr<IUnknown> m_pUnkMarshaler;
		WCHAR m_wszDropDirectory[MAX_PATH];
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\nntp\server\search\src\parsxpat.cpp ===
#include "pch.cxx"
#include "parse.h"

//
// the types of search key operands
//
typedef enum {
	eAString,					// an astring type
	eNumber,					// a numeric type
	eDate,						// a date
	eSearchKey,					// a nested search key
	eDateDay,					// a date where we need to use =
	eNone 						// no operand
} SKEY_OPERAND_TYPE;

#define XPAT_SPACE " \t"					// whitespace characters
#define XPAT_MESSAGE_ID_CHAR '@'			// all message IDs have this
#define XPAT_MESSAGE_ID_PREFIX '<'			// prefix's message IDs
#define XPAT_MESSAGE_ID_SUFFIX '>'			// prefix's message IDs
#define XPAT_RANGE_OPERATOR_CHAR '-'		// used to denote article ID range

BOOL CXpatTranslator::Translate(char *pszStatement, char *pszNewsGrp,
									  WCHAR *pwszOutput, DWORD cOutput) {
	TraceFunctEnter("CXpatTranslator::Translate");

	char **ppszStatement = &pszStatement;
	WCHAR **ppwszOutput = &pwszOutput;
	DWORD *pcOutput = &cOutput;

	m_iLowArticleID = 0;
	m_iHighArticleID = ARTICLEID_INFINITE;

	//
	// if they don't have a newsgroup selected then XPAT doesn't work
	//
	if (pszNewsGrp == NULL) retEC(ERROR_SEARCH_P_NO_GROUP, FALSE);

	// 
	// list the newsgroup for tripoli
	//
	if (!WriteOutput(IS_NEWSGROUP_EQ, ppwszOutput, pcOutput)) ret(FALSE);
	if (!WriteOutput(pszNewsGrp, ppwszOutput, pcOutput)) ret(FALSE);

	//
	// get the header that they want to search
	//
	if (!SkipChars(ppszStatement, XPAT_SPACE)) 
		retEC(ERROR_SEARCH_P_SYNTAX_ERROR, FALSE);
	char *pszHeader = GetCharsTill(ppszStatement, XPAT_SPACE, FALSE);
	if (pszHeader == NULL) retEC(ERROR_SEARCH_P_SYNTAX_ERROR, FALSE);

	// 
	// figure out the Tripoli word for this header
	//
	SKEY_INFO *pSkinfo = GetSearchKeyInfo(pszHeader, m_cHeaders, m_rgHeaders);
	if (pSkinfo == NULL) retEC(ERROR_SEARCH_P_UNSUPPORTED_KEY, FALSE);
	char *pszPropertyName;
	if (pSkinfo->eOperandType == eDate || pSkinfo->eOperandType == eDateDay)
		pszPropertyName = pSkinfo->pszPropertyName;
	else
		pszPropertyName = pSkinfo->pszRegexName;
	//
	// get the message ID or article ID
	//
	if (!SkipChars(ppszStatement, XPAT_SPACE)) 
		retEC(ERROR_SEARCH_P_SYNTAX_ERROR, FALSE);
	char *pszID = GetCharsTill(ppszStatement, XPAT_SPACE, FALSE);
	if (pszID == NULL) retEC(ERROR_SEARCH_P_SYNTAX_ERROR, FALSE);

	//
	// its a message ID if it contains an @ sign, otherwise its an article ID
	//
	if (strchr(pszID, XPAT_MESSAGE_ID_CHAR) != NULL &&
	    *pszID == XPAT_MESSAGE_ID_PREFIX &&
		pszID[strlen(pszID) - 1] == XPAT_MESSAGE_ID_SUFFIX) 
	{
		//
		// message ID
		//
		if (!WriteOutput(IS_AND, ppwszOutput, pcOutput)) ret(FALSE);
		if (!WriteOutput(IS_MESSAGE_ID_EQ IS_QUOTE, ppwszOutput, pcOutput)) ret(FALSE);
		if (!WriteOutput(pszID, ppwszOutput, pcOutput)) ret(FALSE);
		if (!WriteOutput(IS_QUOTE, ppwszOutput, pcOutput)) ret(FALSE);
	} else {
		//
		// article ID range
		//
		// possibilities here:
		// x-y
		// x-
		// x
		// -
		// -y
		//
		char *pszDash = strchr(pszID, XPAT_RANGE_OPERATOR_CHAR);
		char *pszFirstArticleID = pszID;
		char *pszSecondArticleID = NULL;
		char szOne[] = "1";
		if (pszDash != NULL) {
			*pszDash = 0;
			pszSecondArticleID = pszDash + 1;
			if (*pszSecondArticleID != 0 && !IsNumber(pszSecondArticleID))
				retEC(ERROR_SEARCH_P_SYNTAX_ERROR, FALSE);
		}
		// this will be true in the "-" and "-y" cases
		if (pszDash == pszFirstArticleID) pszFirstArticleID = szOne;
		if (!IsNumber(pszFirstArticleID)) 
			retEC(ERROR_SEARCH_P_SYNTAX_ERROR, FALSE);

//
// we don't want to use @NewsArticleID to restrict the searchs for XPAT.
// when the article is cross-posted the @NewsArticleID property isn't
// necessarily the article ID for this article in this newsgroup, so 
// restricting it could cause articles that are in the desired set not
// to get returned by tripoli.
//
// the xpat code does its own independent checking of the article ID's
// using the high and low article IDs that we return to it.
//
#if 0
		if (!WriteOutput(IS_AND, ppwszOutput, pcOutput)) ret(FALSE);
		// write to output
		if (pszSecondArticleID == NULL) {
			// just one article (passed in #)
			if (!WriteOutput(IS_ARTICLE_ID_EQ, ppwszOutput, pcOutput)) ret(FALSE);
			if (!WriteOutput(pszFirstArticleID, ppwszOutput, pcOutput)) ret(FALSE);
		} else if (*pszSecondArticleID == 0) {
			// article to max article (passed in #-)
			if (!WriteOutput(IS_ARTICLE_ID_GE, ppwszOutput, pcOutput)) ret(FALSE);
			if (!WriteOutput(pszFirstArticleID, ppwszOutput, pcOutput)) ret(FALSE);
		} else {
			// article to article (passed in #-#)
			if (!WriteOutput(IS_ARTICLE_ID_GE, ppwszOutput, pcOutput)) ret(FALSE);
			if (!WriteOutput(pszFirstArticleID, ppwszOutput, pcOutput)) ret(FALSE);
			if (!WriteOutput(IS_AND, ppwszOutput, pcOutput)) ret(FALSE);
			if (!WriteOutput(IS_ARTICLE_ID_LE, ppwszOutput, pcOutput)) ret(FALSE);
			if (!WriteOutput(pszSecondArticleID, ppwszOutput, pcOutput)) ret(FALSE);
		}
#endif

		m_iLowArticleID = atoi(pszFirstArticleID);
		if (pszSecondArticleID == NULL) {
			m_iHighArticleID = m_iLowArticleID;
		} else if (*pszSecondArticleID == 0) {
			m_iHighArticleID = ARTICLEID_INFINITE;
		} else {
			if (!IsNumber(pszFirstArticleID)) 
				retEC(ERROR_SEARCH_P_SYNTAX_ERROR, FALSE);
			m_iHighArticleID = atoi(pszSecondArticleID);
		}
	}

	//
	// take each pattern in turn and add it to the Tripoli string
	//
	BOOL fFirstPattern = TRUE;
	if (!WriteOutput(IS_AND IS_OPEN_PAREN, ppwszOutput, pcOutput)) ret(FALSE);
	do {
		if (!SkipChars(ppszStatement, XPAT_SPACE, !fFirstPattern)) 
			retEC(ERROR_SEARCH_P_SYNTAX_ERROR, TRUE);

		if (**ppszStatement != 0) {
			// if this isn't the first pattern then we need to OR it with 
			// the others
			if (!fFirstPattern) {
				if (!WriteOutput(IS_OR, ppwszOutput, pcOutput)) ret(FALSE);
			}
			if (!WriteOutput(pszPropertyName, ppwszOutput, pcOutput)) ret(FALSE);

			// If it's a date string, run it through the date translator.  Otherwise
			// copy the string with the translation mentioned below.
			switch (pSkinfo->eOperandType) {
			case eDate:
				if (!TranslateDate(ppszStatement, ppwszOutput, pcOutput))
					retEC(ERROR_SEARCH_P_SYNTAX_ERROR, FALSE);
				break;
			case eDateDay:
				if (!TranslateDateDay(pszPropertyName, ppszStatement, ppwszOutput, pcOutput))
					retEC(ERROR_SEARCH_P_SYNTAX_ERROR, FALSE);
				break;
			default:
				// we need to do the equiv of
				// if (!WriteOutput(pszPattern, ppwszOutput, pcOutput)) ret(FALSE);
				// but at the same time convert [ to |[.
				char *pszPattern = GetCharsTill(ppszStatement, XPAT_SPACE, TRUE);
				if (pszPattern == NULL) retEC(ERROR_SEARCH_P_SYNTAX_ERROR, TRUE);

				DWORD iPattern, iOutput;
				for (iPattern = 0, iOutput = 0; pszPattern[iPattern] != 0; iPattern++, iOutput++) {
					if (iOutput > *pcOutput) retEC(ERROR_MORE_DATA, FALSE);
					if (pszPattern[iPattern] == L'[') {
						(*ppwszOutput)[iOutput] = L'|'; iOutput++;
						(*ppwszOutput)[iOutput] = L'[';
					} else {
						(*ppwszOutput)[iOutput] = (char) pszPattern[iPattern];
					}
				}
				*pcOutput -= iOutput;
				*ppwszOutput += iOutput;
			}
		}

		fFirstPattern = FALSE;
	} while (**ppszStatement != 0);

	if (!WriteOutput(IS_CLOSE_PAREN, ppwszOutput, pcOutput)) ret(FALSE);

	**ppwszOutput = 0;

	ret(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\nntp\server\search\src\pch.cxx ===
//+-------------------------------------------------------------------------
//
//  Copyright (C) Microsoft Corporation, 1992 - 1996
//
//  File:       pch.cxx
//
//  Contents:   Pre-compiled header
//
//--------------------------------------------------------------------------


#define __QUERY__

#include <stdio.h>
#include <stdlib.h>
#include <windows.h>
#include <dbgtrace.h>
#include "parse.h"

// return and TraceFunctLeave() at once, even returning a Win32 error code if
// necessary
#define ret(__rc__) { 													\
	TraceFunctLeave(); 													\
	return(__rc__);														\
}

#define retEC(__ec__, __rc__) {											\
	SetLastError(__ec__); 												\
	DebugTrace(0, "error return (ec = 0x%x, %lu)\n", __ec__, __ec__); 	\
	TraceFunctLeave(); 													\
	return(__rc__); 													\
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\nntp\server\seo\ddrop\dllmain.cpp ===
#include "stdafx.h"
#include "resource.h"

#include "initguid.h"

#include "seo.h"
#include "SEO_i.c"
#include "nntpfilt.h"
#include "ddrop.h"
#include "ddrop_i.c"
#include "nntpfilt_i.c"
#include "filter.h"

CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
	OBJECT_ENTRY(CLSID_CNNTPDirectoryDrop, CNNTPDirectoryDrop)
END_OBJECT_MAP()


/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/) {

	if (dwReason == DLL_PROCESS_ATTACH) {
		_Module.Init(ObjectMap,hInstance);
		DisableThreadLibraryCalls(hInstance);
	}
	else if (dwReason == DLL_PROCESS_DETACH) {
		_Module.Term();
	}
	return (TRUE);    // ok
}


/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void) {
	HRESULT hRes = (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
	return (hRes);
}


/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv) {
	HRESULT hRes = _Module.GetClassObject(rclsid,riid,ppv);
	return (hRes);
}


/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void) {
	// registers object, typelib and all interfaces in typelib
	HRESULT hRes = _Module.RegisterServer();
	return (hRes);
}


/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void) {
	_Module.UnregisterServer();
	return (S_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\nntp\server\seo\ddrop\makefile.inc ===
$(O)\ddrop.h $(O)\ddrop_i.c : ddrop.idl
    $(MIDL) \
    $(PACKING) \
    $(INCPATH0) \
    -char unsigned \
    -ms_ext -c_ext \
    -proxy $(PASS0_SOURCEDIR)\ddrop_p.c \
    -dlldata $(PASS0_SOURCEDIR)\dlldata.c \
    -iid $(MIDL_UUIDDIR)\ddrop_i.c \
    -header $@ \
    -tlb $(O)\ddrop.tlb \
    -cpp_cmd $(TARGET_CPP) \
    $(C_DEFINES) \
    $(MIDL_FLAGS) \
    $(MIDL_OPTIMIZATION) \
    $**

$(O)\seo.h $(O)\seo_i.c : $(STAXINC)\export\seo.idl
    $(MIDL) \
    $(PACKING) \
    $(INCPATH0) \
    -char unsigned \
    -ms_ext -c_ext \
    -proxy $(PASS0_SOURCEDIR)\seo_p.c \
    -dlldata $(PASS0_SOURCEDIR)\dlldata.c \
    -iid $(MIDL_UUIDDIR)\seo_i.c \
    -header $@ \
    -tlb $(O)\seo.tlb \
    -cpp_cmd $(TARGET_CPP) \
    $(C_DEFINES) \
    $(MIDL_FLAGS) \
    $(MIDL_OPTIMIZATION) \
    $**

$(O)\nntpfilt.h $(O)\nntpfilt_i.c : $(STAXNNTP)\core\include\nntpfilt.idl
    $(MIDL) \
    $(PACKING) \
    $(INCPATH0) \
    -char unsigned \
    -ms_ext -c_ext \
    -proxy $(PASS0_SOURCEDIR)\nntpfilt_p.c \
    -dlldata $(PASS0_SOURCEDIR)\dlldata.c \
    -iid $(MIDL_UUIDDIR)\nntpfilt_i.c \
    -header $@ \
    -tlb $(O)\nntpfilt.tlb \
    -cpp_cmd $(TARGET_CPP) \
    $(C_DEFINES) \
    $(MIDL_FLAGS) \
    $(MIDL_OPTIMIZATION) \
    $**

$(O)\mailmsg.h $(O)\mailmsg_i.c : $(STAXINC)\export\mailmsg.idl
    $(MIDL) \
    $(PACKING) \
    $(INCPATH0) \
    -char unsigned \
    -ms_ext -c_ext \
    -proxy $(PASS0_SOURCEDIR)\mailmsg_p.c \
    -dlldata $(PASS0_SOURCEDIR)\dlldata.c \
    -iid $(MIDL_UUIDDIR)\mailmsg_i.c \
    -header $@ \
    -tlb $(O)\mailmsg.tlb \
    -cpp_cmd $(TARGET_CPP) \
    $(C_DEFINES) \
    $(MIDL_FLAGS) \
    $(MIDL_OPTIMIZATION) \
    $**

$(O)\mailmsgi.h $(O)\mailmsgi_i.c : $(STAXINC)\export\mailmsgi.idl
    $(MIDL) \
    $(PACKING) \
    $(INCPATH0) \
    -char unsigned \
    -ms_ext -c_ext \
    -proxy $(PASS0_SOURCEDIR)\mailmsgi_p.c \
    -dlldata $(PASS0_SOURCEDIR)\dlldata.c \
    -iid $(MIDL_UUIDDIR)\mailmsgi_i.c \
    -header $@ \
    -tlb $(O)\mailmsgi.tlb \
    -cpp_cmd $(TARGET_CPP) \
    $(C_DEFINES) \
    $(MIDL_FLAGS) \
    $(MIDL_OPTIMIZATION) \
    $**
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\nntp\server\search\src\parse.cpp ===
#define INITGUID
#define DEFINE_STRCONST
#include <pch.cxx>
#include <ole2.h>
#include <exchmole.h>

//
// information needed to convert months from IMAP format to IS format
//
typedef const struct MONTH_INFO_st {
	char	*pszIMAPName;				// the IMAP name of the date
	char	*pszISName;					// the IS name for the date
} MONTH_INFO;

//
// the types of search key operands
//
typedef enum {
	eAString,					// an astring type
	eNumber,					// a numeric type
	eDate,						// a date
	eSearchKey,					// a nested search key
	eDateDay,					// a date where we need to use =
	eNone 						// no operand
} SKEY_OPERAND_TYPE;

//
// this is the table of valid search keys as defined in the SEARCH proposal.
// it contains all "simple" search keys.  special cases are noted with
// comments and are handled specially in TranslateSearchKey().
//
// these need to be kept in alphabetical order to allow us to use a
// binary search.
//
SKEY_INFO CNntpSearchTranslator::m_rgSearchKeys[] = {
	// ( is a special case
	{ "ALL",		"@NewsArticleID > 0",NULL,	eNone, 		FALSE	},
	{ "BEFORE",		"@Write < ",		NULL,	eDate,		FALSE	},
	{ "BODY",		"@Contents ",		NULL,	eAString,	FALSE	},
	// CHARSET is a special case
	{ "FROM",		"@NewsFrom ",		NULL,	eAString,	FALSE	},
	// HEADER is a special case
	// IN is a special case
	{ "LARGER",		"@Size > ",			NULL,	eNumber,	FALSE	},
//	{ "NEWSGROUP",	"#NewsGroups ",		NULL,	eAString,	TRUE	},
	{ "NOT",		"NOT ",				NULL,	eSearchKey,	FALSE	},
	{ "ON",			"@Write ",			NULL,	eDateDay,	FALSE	},
	// OR is a special case
	{ "SENTBEFORE",	"@NewsDate < ",		NULL,	eDate,		FALSE	},
	{ "SENTON",		"@NewsDate ",		NULL,	eDateDay,	FALSE	},
	{ "SENTSINCE",	"@NewsDate > ",		NULL,	eDate,		FALSE	},
	{ "SINCE",		"@Write > ",		NULL,	eDate,		FALSE	},
	{ "SMALLER",	"@Size < ",			NULL,	eNumber,	FALSE	},
	{ "SUBJECT",	"@NewsSubject ",	NULL,	eAString,	FALSE	},
	{ "TEXT",		"@All ",			NULL,	eAString,	FALSE	},
	// UID is a special case
	{ NULL, 		NULL,				NULL,	eSearchKey,	FALSE	}
};

// size of the table minus the NULL
#define NUM_SEARCH_KEYS (sizeof(m_rgSearchKeys) / sizeof(SKEY_INFO)) - 1

//
// this is the table of valid HEADER fields supported by NNTP.
//
// these need to be kept in alphabetical order to allow us to use a
// binary search.
//
SKEY_INFO CQueryLanguageTranslator::m_rgHeaders[] = {
	// this is just used to report that we support the :Text search header
	{ ":Body",		"@Contents ",	"@All ",		eAString,	FALSE	},
	{ ":Date",		"@Write ",		"@Write ",		eDateDay,	FALSE	},
	{ ":Text",		"@All ",		"@Contents ",	eAString,	FALSE	},
	{ "Date",		"@NewsDate ",	"#NewsDate ",	eDateDay,	FALSE	},
	{ "From",		"@NewsFrom ",	"#NewsFrom ",	eAString,	FALSE	},
	{ "Message-ID",	"@NewsMsgID ",	"#NewsMsgID ",	eAString,	FALSE	},
//	{ "Newsgroup",	"@NewsGroup ",	"#NewsGroup ",	eAString,	TRUE	},
	{ "Newsgroups",	"@NewsGroups ",	"#NewsGroups ",	eAString,	TRUE	},
	{ "Subject",	"@NewsSubject ","#NewsSubject ",eAString,	FALSE	},
	{ NULL, 		NULL,			NULL,			eSearchKey,	FALSE	}
};

// the number of headers (not counting the NULL) in the above list
const DWORD CQueryLanguageTranslator::m_cHeaders =
	(sizeof(CQueryLanguageTranslator::m_rgHeaders) / sizeof(SKEY_INFO)) - 1;

//
// IMAP queries keep the date in word form, Tripoli likes the date to be in
// numeric form.  we use this table to convert
//
MONTH_INFO CQueryLanguageTranslator::m_rgMonthTable[] = {
	{ "Jan", "1"  }, 	{ "Feb", "2"  }, 	{ "Mar", "3"  },
	{ "Apr", "4"  }, 	{ "May", "5"  }, 	{ "Jun", "6"  },
	{ "Jul", "7"  }, 	{ "Aug", "8"  }, 	{ "Sep", "9"  },
	{ "Oct", "10" }, 	{ "Nov", "11" }, 	{ "Dec", "12" },
	{ NULL,  NULL }
};

//
// IMAP/Search spec's words and special characters (except those defined
// in the above tables)
//
#define IMAP_OR "OR"
#define IMAP_ALL "ALL"
#define IMAP_SPACE " \t"
#define IMAP_OPEN_PAREN "("
#define IMAP_OPEN_PAREN_CHAR '('
#define IMAP_CLOSE_PAREN ")"
#define IMAP_CLOSE_PAREN_CHAR ')'
#define IMAP_QUOTE "\""
#define IMAP_QUOTE_CHAR '"'
#define IMAP_DATE_SEPERATOR "-"
#define IMAP_ATOM_SPECIALS "()* \"\\"
#define IMAP_SET_RANGE_SEPARATOR '-'
#define IMAP_SET_SEPARATORS IMAP_SPACE "-" IMAP_CLOSE_PAREN
#define IMAP_IN "in"
#define IMAP_COMMA ","

#define MIN_MIME2_STRING 9

BOOL CNntpSearchTranslator::Translate(char *pszStatement, char *pszNewsGrp,
									  WCHAR *pwszOutput, DWORD cOutput) {
	TraceFunctEnter("CNntpSearchTranslator::Translate");

	m_pszNewsgroup = pszNewsGrp;
	m_fSpecifiedNewsgroup = FALSE;
	m_fAndWithLast = FALSE;

	BOOL rc = TRUE;
	char *pSearchKey, *p, chEnd;

	// check to see if we have IN parameter
	p = pszStatement;
	pSearchKey = GetCharsTill(&p, IMAP_SPACE, TRUE, &chEnd);
	if (pSearchKey != NULL && _stricmp(IMAP_IN, pSearchKey) == 0) {
		pszStatement = p;
		rc = TranslateIN(&pszStatement, &pwszOutput, &cOutput) &&
			 SkipChars(&pszStatement, IMAP_SPACE, TRUE);
	} else {
		if (chEnd != 0) p[-1] = chEnd;
	}


	// translate each search key and AND them together
	while (rc && *pszStatement != 0) {
		if (m_fAndWithLast) WriteOutput(IS_AND, &pwszOutput, &cOutput);
		else m_fAndWithLast = TRUE;
		rc = TranslateSearchKey(&pszStatement, &pwszOutput, &cOutput) &&
			 SkipChars(&pszStatement, IMAP_SPACE, TRUE);
	};

	if (rc && !m_fSpecifiedNewsgroup) {
		if (m_fAndWithLast) WriteOutput(IS_AND, &pwszOutput, &cOutput);

		if (m_pszNewsgroup == NULL) retEC(ERROR_SEARCH_P_NO_GROUP, FALSE);
		rc = WriteOutput(IS_NEWSGROUP IS_SPACE IS_QUOTE, &pwszOutput, &cOutput) &&
			 WriteOutput(m_pszNewsgroup, &pwszOutput, &cOutput) &&
			 WriteOutput(IS_QUOTE, &pwszOutput, &cOutput);
	}

	*pwszOutput = 0;

	ret(rc);
}

BOOL CNntpSearchTranslator::TranslateSearchKey(char **ppszStatement, WCHAR **ppwszOutput, DWORD *pcOutput) {
	TraceFunctEnter("CNntpSearchTranslator::TranslateSearchKey");

	if (!SkipChars(ppszStatement, IMAP_SPACE IMAP_CLOSE_PAREN)) ret(FALSE);
	BOOL fParen = FALSE;
	BOOL rc;
	char *pszSearchKey = NULL, chEnd = NULL;
	if (**ppszStatement == IMAP_OPEN_PAREN_CHAR) {
		fParen = TRUE;
	} else {
		pszSearchKey = GetCharsTill(ppszStatement,
			IMAP_SPACE IMAP_CLOSE_PAREN, TRUE, &chEnd);
		if (pszSearchKey == NULL) ret(FALSE);
	}

	//
	// check for special cases
	//
	if (fParen == TRUE) {
		rc = TranslateAndList(ppszStatement, ppwszOutput, pcOutput);
	} else if (_stricmp(pszSearchKey, IMAP_OR) == 0) {
		rc = TranslateOR(ppszStatement, ppwszOutput, pcOutput);
	} else {
		//
		// if there were no special cases then look for this key in the
		// search key info list and do a translation
		//
		SKEY_INFO *skinfo = GetSearchKeyInfo(pszSearchKey,
			NUM_SEARCH_KEYS, m_rgSearchKeys);
		if (skinfo == NULL) {
			if (GetLastError() == ERROR_SEARCH_P_UNSUPPORTED_KEY)
				SetLastError(ERROR_SEARCH_P_SYNTAX_ERROR);
			ret(FALSE);
		}

		if (skinfo->fSpecifiedNewsgroup) m_fSpecifiedNewsgroup = TRUE;

		if (!WriteOutput(skinfo->pszPropertyName, ppwszOutput, pcOutput))
			ret(FALSE);

		switch (skinfo->eOperandType) {
			case eAString: 	rc = TranslateAString(ppszStatement, ppwszOutput, pcOutput);
							break;
			case eNumber: 	rc = TranslateNumber(ppszStatement, ppwszOutput, pcOutput);
							break;
			case eDate: 	rc = TranslateDate(ppszStatement, ppwszOutput, pcOutput);
							break;
			case eDateDay: 	rc = TranslateDateDay(skinfo->pszPropertyName, ppszStatement, ppwszOutput, pcOutput);
							break;
			case eSearchKey:rc = TranslateSearchKey(ppszStatement, ppwszOutput, pcOutput);
							break;
			case eNone:		rc = TRUE;
							break;
			default:		_ASSERT(FALSE);
							SetLastError(ERROR_SEARCH_P_INTERNAL);
							rc = FALSE;
							break;
		}
	}

	if (chEnd == IMAP_CLOSE_PAREN_CHAR) {
		(*ppszStatement)--;
		**ppszStatement = chEnd;
	}

	ret(rc);
}

//
// convert alt.*,comp.* into (@NewsGroups "alt.*" | @Newsgroups "comp.*")
//
BOOL CNntpSearchTranslator::TranslateIN(char **ppszStatement, WCHAR **ppwszOutput,
								    DWORD *pcOutput)
{
	TraceFunctEnter("CNntpSearchTranslator::TranslateIN");


	char chEnd;
	char *pszWildmat;
	BOOL fFirstNG = TRUE;

	do {
		pszWildmat = GetCharsTill(ppszStatement, IMAP_COMMA IMAP_SPACE,
								  TRUE, &chEnd);

		// If the search pattern is "*", don't bother adding it to the
		// query string we're building.  (Tripoli doesn't like it and
		// it doesn't add any value to the query.)
		if (strcmp(pszWildmat, "*") != 0) {
			if (!fFirstNG) {
				if (!WriteOutput(IS_OR, ppwszOutput, pcOutput)) ret(FALSE);
			} else {
				if (!WriteOutput(IS_OPEN_PAREN, ppwszOutput, pcOutput)) ret(FALSE);
				fFirstNG = FALSE;
			}
			if (pszWildmat == NULL) retEC(ERROR_SEARCH_P_SYNTAX_ERROR, FALSE);
			if (*pszWildmat == 0) retEC(ERROR_SEARCH_P_SYNTAX_ERROR, FALSE);
//			if (!WriteOutput(IS_NEWSGROUP_WILDMAT IS_SPACE IS_QUOTE, ppwszOutput, pcOutput)) ret(FALSE);
			if (!WriteOutput(IS_NEWSGROUP IS_SPACE IS_QUOTE, ppwszOutput, pcOutput)) ret(FALSE);
			if (!WriteOutput(pszWildmat, ppwszOutput, pcOutput)) ret(FALSE);
			if (!WriteOutput(IS_QUOTE, ppwszOutput, pcOutput)) ret(FALSE);
		}
	} while (chEnd == ',');

	if (!fFirstNG) {
		if (!WriteOutput(IS_CLOSE_PAREN, ppwszOutput, pcOutput)) ret(FALSE);
		m_fAndWithLast = TRUE;
	}

	m_fSpecifiedNewsgroup = TRUE;

	ret(TRUE);
}

//
// convert <searchkey> <searchkey> into (<searchkey> OR <searchkey>)
// (TranslateSearchKey() eats the OR)
//
BOOL CNntpSearchTranslator::TranslateOR(char **ppszStatement, WCHAR **ppwszOutput,
								    DWORD *pcOutput)
{
	TraceFunctEnter("CNntpSearchTranslator::TranslateOR");

	if (!WriteOutput(IS_OPEN_PAREN, ppwszOutput, pcOutput)) ret(FALSE);
	if (!TranslateSearchKey(ppszStatement, ppwszOutput, pcOutput)) ret(FALSE);
	if (!WriteOutput(" " IS_OR " ", ppwszOutput, pcOutput)) ret(FALSE);
	if (!TranslateSearchKey(ppszStatement, ppwszOutput, pcOutput)) ret(FALSE);
	if (!WriteOutput(IS_CLOSE_PAREN, ppwszOutput, pcOutput)) ret(FALSE);

	ret(TRUE);

	TraceFunctLeave();
}

//
// convert (<searchkey> ... <searchkey>)
// into (<searchkey> AND ... AND <searchkey>)
//
BOOL CNntpSearchTranslator::TranslateAndList(char **ppszStatement,
									     WCHAR **ppwszOutput, DWORD *pcOutput)
{
	TraceFunctEnter("CNntpSearchTranslator::TranslateAndList");

	BOOL rc, fFirstRun = TRUE;

	// skip paren
	(*ppszStatement)++;
	if (!WriteOutput(IS_OPEN_PAREN, ppwszOutput, pcOutput)) ret(FALSE);
	do {
		if (!fFirstRun) WriteOutput(IS_AND, ppwszOutput, pcOutput);
		else fFirstRun = FALSE;
		rc = TranslateSearchKey(ppszStatement, ppwszOutput, pcOutput) &&
			 SkipChars(ppszStatement, IMAP_SPACE);
	} while (rc && **ppszStatement != IMAP_CLOSE_PAREN_CHAR);
	if (!WriteOutput(IS_CLOSE_PAREN, ppwszOutput, pcOutput)) ret(FALSE);
	// skip paren
	(*ppszStatement)++;

	ret(rc);
}

//
// convert astring types (in the search spec) into the proper strings for
// the tripoli search engine.
//
// BUGBUG - doesn't support MIME or Literal's yet
//
BOOL CQueryLanguageTranslator::TranslateAString(char **ppszStatement, WCHAR **ppwszOutput,
										 DWORD *pcOutput)
{
	TraceFunctEnter("CQueryLanguageTranslator::TranslateAString");

	if (!SkipChars(ppszStatement, IMAP_SPACE)) ret(FALSE);

	char *pszString, chEndChar;

	// check for a quoted string.  if we find one then we copy to the output
	// until the end quote, otherwise its an atom (one character)
	if (**ppszStatement == IMAP_QUOTE_CHAR) {
		(*ppszStatement)++;
		pszString = GetCharsTill(ppszStatement, IMAP_QUOTE, FALSE, &chEndChar);
	} else {
		// the string ends with an atom special character
		pszString = GetCharsTill(ppszStatement, IMAP_ATOM_SPECIALS, TRUE,
								 &chEndChar);
	}

	// make sure we found an close quote
	if (pszString == NULL) retEC(ERROR_SEARCH_P_SYNTAX_ERROR, FALSE);

	if (!WriteOutput(IS_QUOTE, ppwszOutput, pcOutput)) ret(FALSE);

	// check to see if its a mime-2 string
	DWORD cString = lstrlen(pszString);
	if (cString > MIN_MIME2_STRING &&
		pszString[0] == '=' &&
		pszString[1] == '?' &&
		pszString[cString - 2] == '?' &&
		pszString[cString - 1] == '=')
	{
		if (!WriteOutputM2(pszString, ppwszOutput, pcOutput)) ret(FALSE);
	} else {
		if (!WriteOutput(pszString, ppwszOutput, pcOutput)) ret(FALSE);
	}

	if (!WriteOutput(IS_QUOTE IS_WILDMAT, ppwszOutput, pcOutput)) ret(FALSE);

	if (chEndChar == IMAP_CLOSE_PAREN_CHAR) {
		(*ppszStatement)--;
		(**ppszStatement) = chEndChar;
	}

	ret(TRUE);
}

BOOL CQueryLanguageTranslator::TranslateNumber(char **ppszStatement, WCHAR **ppwszOutput,
										 DWORD *pcOutput)
{
	TraceFunctEnter("CQueryLanguageTranslator::TranslateNumber");

	if (!SkipChars(ppszStatement, IMAP_SPACE)) ret(FALSE);

	char *pszNumber, chEnd;

	pszNumber = GetCharsTill(ppszStatement, IMAP_SPACE IMAP_CLOSE_PAREN,
		TRUE, &chEnd);
	if (pszNumber == NULL) ret(FALSE);
	if (!IsNumber(pszNumber)) ret(FALSE);

	if (!WriteOutput(pszNumber, ppwszOutput, pcOutput)) ret(FALSE);

	// fix the statement to have the closing paren if we ran over it...
	if (chEnd == IMAP_CLOSE_PAREN_CHAR) {
		(*ppszStatement)--;
		**ppszStatement = chEnd;
	}

	ret(TRUE);
}

//
// translate 18-feb-1974 to 1974/2/18
//
BOOL CQueryLanguageTranslator::TranslateDate(char **ppszStatement, WCHAR **ppwszOutput,
										 DWORD *pcOutput)
{
	TraceFunctEnter("CQueryLanguageTranslator::TranslateDate");

	ret(TranslateDateDay(NULL, ppszStatement, ppwszOutput, pcOutput));
}

//
// translate 18-feb-1974 to ">= 1974/2/18 and pszField <= 1974/2/18 23:59:59"
//
// if pszField is NULL then it will do the following translation:
// translate 18-feb-1974 to "1974/2/18"
//
BOOL CQueryLanguageTranslator::TranslateDateDay(char *pszField,
											 char **ppszStatement,
											 WCHAR **ppwszOutput,
										 	 DWORD *pcOutput)
{
	TraceFunctEnter("CQueryLanguageTranslator::TranslateDateDay");

	if (pszField != NULL) {
		// put out the >=
		if (!WriteOutput(IS_OPERATOR_GE, ppwszOutput, pcOutput)) ret(FALSE);
	}

	// skip whitespace
	if (!SkipChars(ppszStatement, IMAP_SPACE)) ret(FALSE);

	BOOL fQuoted = (**ppszStatement == IMAP_QUOTE_CHAR);

	// skip the open quote if there is one
	if (fQuoted) (*ppszStatement)++;

	// read the day #
	char *pszDayOfMonth = GetCharsTill(ppszStatement, "-", FALSE);
	if (pszDayOfMonth == NULL) ret(FALSE);
	// make sure its valid.
	// must be 1 or 2 chars.  each char must be a number
	if (*pszDayOfMonth == 0 ||
		strlen(pszDayOfMonth) > 2 ||
	    !isdigit((UCHAR)pszDayOfMonth[0]) ||
	    (pszDayOfMonth[1] != 0 && !isdigit((UCHAR)pszDayOfMonth[1])))
	{
		retEC(ERROR_SEARCH_P_SYNTAX_ERROR, FALSE);
	}

	// read the month
	char *pszMonth = GetCharsTill(ppszStatement, "-", FALSE);
	// make sure its valid.
	// must be 3 chars long
	if (pszMonth == 0 || strlen(pszMonth) != 3) retEC(ERROR_SEARCH_P_SYNTAX_ERROR, FALSE);

	// find the IS name for the month
	char *pszISMonth = NULL;
	int i;
	for (i = 0; m_rgMonthTable[i].pszIMAPName != NULL; i++) {
		if (_stricmp(m_rgMonthTable[i].pszIMAPName, pszMonth) == NULL) {
			pszISMonth = m_rgMonthTable[i].pszISName;
			break;
		}
	}
	if (pszISMonth == NULL) retEC(ERROR_SEARCH_P_SYNTAX_ERROR, FALSE);

	// read the year
	char chEnd, *pszYear = GetCharsTill(ppszStatement,
		IMAP_SPACE IMAP_CLOSE_PAREN IMAP_QUOTE, TRUE, &chEnd);
	// make sure its valid.
	// must be 4 chars long, each must be a number
	if (strlen(pszYear) != 4 ||
		!isdigit((UCHAR)pszYear[0]) ||
		!isdigit((UCHAR)pszYear[1]) ||
		!isdigit((UCHAR)pszYear[2]) ||
		!isdigit((UCHAR)pszYear[3]))
	{
		retEC(ERROR_SEARCH_P_SYNTAX_ERROR, FALSE);
	}

	char pszDate[256];

	_snprintf(pszDate, 256, "%s/%s/%s", pszYear, pszISMonth, pszDayOfMonth);
	// BUGBUG - check for overflow
	if (!WriteOutput(pszDate, ppwszOutput, pcOutput)) ret(FALSE);

	if (pszField != NULL) {
		_snprintf(pszDate, 256, " & %s<= %s/%s/%s 23:59:59 ", pszField,
			pszYear, pszISMonth, pszDayOfMonth);
		if (!WriteOutput(pszDate, ppwszOutput, pcOutput)) ret(FALSE);
	}

	// if there was an open quote then skip until the close quote
	if (fQuoted && chEnd != IMAP_QUOTE_CHAR) {
		if (!SkipChars(ppszStatement, IMAP_SPACE, FALSE)) ret(FALSE);
		if (**ppszStatement != IMAP_QUOTE_CHAR) ret(FALSE);
	}

	if (chEnd == IMAP_CLOSE_PAREN_CHAR) {
		(*ppszStatement)--;
		**ppszStatement = chEnd;
	}

	ret(TRUE);
}
BOOL CQueryLanguageTranslator::WriteOutput(char *pszText, WCHAR **ppwszOutput,
									DWORD *pcOutput)
{
	TraceFunctEnter("CQueryLanguageTranslator::WriteOutput");

	DWORD iText, iOutput;

	// copy, converting ASCII to Unicode
	for (iText = 0, iOutput = 0; pszText[iText] != 0; iText++, iOutput++) {
		if (iOutput > *pcOutput) retEC(ERROR_MORE_DATA, FALSE);
		(*ppwszOutput)[iOutput] = (char) pszText[iText];
	}
	*pcOutput -= iOutput;
	*ppwszOutput += iOutput;

	ret(TRUE);
}

BOOL CQueryLanguageTranslator::WriteOutputM2(char *pszText,
											 WCHAR **ppwszOutput,
									  		 DWORD *pcOutput)
{
	TraceFunctEnter("CQueryLanguageTranslator::WriteOutputM2");

	IMimeInternational *pMI;
	HRESULT hr;

	// BUGBUG - don't coinit/couninit just for this function
	CoInitialize(NULL);

	hr = CoCreateInstance(CLSID_IMimeInternational,
						  NULL,
						  CLSCTX_INPROC_SERVER,
						  IID_IMimeInternational,
						  (void **) &pMI);
	if (FAILED(hr)) {
		DebugTrace(0, "CoCreateInstance failed with 0x%x\n", hr);
		SetLastError(HRESULT_CODE(hr));
		ret(FALSE);
	}

	PROPVARIANT pvDest;
	RFC1522INFO rfc1522info;
	pvDest.vt = VT_LPWSTR;
	rfc1522info.fRfc1522Allowed = TRUE;

	// convert the Mime-2 string to Unicode.  it will be written into
	// pvDest
	hr = pMI->DecodeHeader(NULL, pszText, &pvDest, &rfc1522info);
	if (FAILED(hr)) {
		DebugTrace(0, "DecodeHeader() failed with 0x%x\n", hr);
		SetLastError(HRESULT_CODE(hr));
		ret(FALSE);
	}

	// this shouldn't get changed
	_ASSERT(pvDest.vt == VT_LPWSTR);
	// we should only be passing in rfc1522 strings
	_ASSERT(rfc1522info.fRfc1522Used);

	if (!WriteOutput("\"", ppwszOutput, pcOutput)) ret(FALSE);

	// make sure pvDest will fit into ppwszOutput and copy it over
	DWORD cDest = lstrlenW(pvDest.pwszVal);
	if (cDest > *pcOutput) {
		ErrorTrace(0, "pcOutput (%lu) < cDest (%lu)", *pcOutput, cDest);
		SetLastError(ERROR_OUTOFMEMORY);
		ret(FALSE);
	}

	lstrcpyW(*ppwszOutput , pvDest.pwszVal);
	*pcOutput -= cDest;
	*ppwszOutput += cDest;

	if (!WriteOutput("\"", ppwszOutput, pcOutput)) ret(FALSE);

	pMI->Release();
	CoUninitialize();

	ret(TRUE);
}

BOOL CQueryLanguageTranslator::SkipChars(char **ppszStatement, char *pszSkipList,
								  BOOL fEndOfStringOkay)
{
	TraceFunctEnter("CQueryLanguageTranslator::SkipChars");

	char *p = *ppszStatement;

	// loop until we find a character that isn't in the skiplist
	while (*p != 0 && strchr(pszSkipList, *p) != NULL) p++;
	if (*p == 0 && !fEndOfStringOkay)
		retEC(ERROR_SEARCH_P_SYNTAX_ERROR, FALSE);
	*ppszStatement = p;
	ret(TRUE);
}

char *CQueryLanguageTranslator::GetCharsTill(char **ppszStatement, char *pszEndList,
									  BOOL fEndOfStringOkay, char *pchEndChar)
{
	TraceFunctEnter("CQueryLanguageTranslator::GetCharsTill");

	char *front = *ppszStatement;
	int i;

	// loop until we find a character that is in the end list
	for (i = 0; front[i] != 0 && strchr(pszEndList, front[i]) == NULL; i++);
	if (front[i] == 0 && !fEndOfStringOkay)
		retEC(ERROR_SEARCH_P_SYNTAX_ERROR, FALSE);

	if (pchEndChar != NULL) *pchEndChar = front[i];

	if (front[i] != 0) {
		front[i] = 0;
		*ppszStatement += (i + 1);
	} else {
		*ppszStatement += i;
	}

	ret(front);
}

//
// given a search key's name, find information about it
//
SKEY_INFO *CQueryLanguageTranslator::GetSearchKeyInfo(char *pszSearchKey,
											   DWORD cSKInfo,
											   SKEY_INFO *pSKInfo)
{
	TraceFunctEnter("CQueryLanguageTranslator::GetSearchKeyInfo");

	int lo = 0, hi = cSKInfo - 1;

	// do a binary search to find the proper searchkey (this requires that
	// the searchkey table is kept sorted)
	do {
		int mid = (lo + hi) / 2;
		int order = _stricmp(pSKInfo[mid].pszSearchKey, pszSearchKey);
		if (order == 0) {
			ret(pSKInfo + mid);
		} else if (order > 0) {
			hi = mid - 1;
		} else {
			lo = mid + 1;
		}
	} while (lo <= hi);
	SetLastError(ERROR_SEARCH_P_UNSUPPORTED_KEY);
	ret(NULL);
}

//
// verify that this string is a valid IMAP number
//
BOOL CQueryLanguageTranslator::IsNumber(char *pszString) {
	TraceFunctEnter("CQueryLanguageTranslator::IsNumber");

	int i, l = strlen(pszString);

	for (i = 0; i < l; i++) {
		if (!isdigit((UCHAR)pszString[i])) {
			SetLastError(ERROR_SEARCH_P_SYNTAX_ERROR);
			ret(FALSE);
		}
	}

	ret(TRUE);
}

char *GetSearchHeader(DWORD iIndex) {
	if (iIndex > CQueryLanguageTranslator::m_cHeaders) return NULL;

	return CQueryLanguageTranslator::m_rgHeaders[iIndex].pszSearchKey;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\nntp\server\seo\ddrop\ddrop.cpp ===
#include "stdafx.h"
#include "resource.h"
#include "seo.h"
#include "nntpfilt.h"
#include "ddrop.h"
#include "filter.h"
#include <stdio.h>
#include "mailmsgprops.h"

HRESULT CNNTPDirectoryDrop::FinalConstruct() {
	*m_wszDropDirectory = 0;
	return (CoCreateFreeThreadedMarshaler(GetControllingUnknown(),
										  &m_pUnkMarshaler.p));
}

void CNNTPDirectoryDrop::FinalRelease() {
	m_pUnkMarshaler.Release();
}

BOOL
AddTerminatedDot(
    HANDLE hFile
    )
/*++

Description:

    Add the terminated dot

Argument:

    hFile - file handle

Return Value:

    TRUE if successful, FALSE otherwise

--*/
{
    TraceFunctEnter( "CNntpFSDriver::AddTerminatedDot" );

    DWORD   ret = NO_ERROR;

    //  SetFilePointer to move the EOF file pointer
    ret = SetFilePointer( hFile,
                          5,            // move file pointer 5 chars more, CRLF.CRLF,...
                          NULL,
                          FILE_END );   // ...from EOF
    if (ret == 0xFFFFFFFF)
    {
        ret = GetLastError();
        ErrorTrace(0, "SetFilePointer() failed - %d\n", ret);
        return FALSE;
    }

    //  pickup the length of the file
    DWORD   cb = ret;

    //  Call SetEndOfFile to actually set the file pointer
    if (!SetEndOfFile( hFile ))
    {
        ret = GetLastError();
        ErrorTrace(0, "SetEndOfFile() failed - %d\n", ret);
        return FALSE;
    }

    //  Write terminating dot sequence
    static	char	szTerminator[] = "\r\n.\r\n" ;
    DWORD   cbOut = 0;
    OVERLAPPED  ovl;
    ovl.Offset = cb - 5;
    ovl.OffsetHigh = 0;
    HANDLE  hEvent = CreateEvent( NULL, TRUE, FALSE, NULL );
    if (hEvent == NULL)
    {
        ErrorTrace(0, "CreateEvent() failed - %d\n", GetLastError());
        return FALSE;
    }

    ovl.hEvent = (HANDLE)(((DWORD_PTR)hEvent) | 0x1);
    if (! WriteFile( hFile, szTerminator, 5, &cbOut, &ovl ))
    {
        ret = GetLastError();
        if (ret == ERROR_IO_PENDING)
        {
            WaitForSingleObject( hEvent, INFINITE );
        }
        else
        {
            ErrorTrace(0, "WriteFile() failed - %d\n", ret);
            _VERIFY( CloseHandle(hEvent) );
            return FALSE;
        }
    }

    if (hEvent != 0) {
        _VERIFY( CloseHandle(hEvent) );
    }

    return TRUE;
}

//
// this is our filter function.
//
HRESULT STDMETHODCALLTYPE CNNTPDirectoryDrop::OnPost(IMailMsgProperties *pMsg) {
	HRESULT hr;

#if 0
	// if this code is enabled then the post will be cancelled
	pMsg->PutDWORD(IMMPID_NMP_NNTP_PROCESSING, 0x0);
#endif
	
	_ASSERT(pMsg != NULL);
	if (pMsg == NULL) return E_INVALIDARG;

	HANDLE hFile;
	WCHAR szDestFilename[MAX_PATH];

	if (*m_wszDropDirectory == 0) {
		return E_INVALIDARG;
	}

	// get a temp filename to write to
	// we use GetTickCount() to generate the base of the filename.  This is
	// to increase the number of temporary file names available (by default
	// GetTempFileName() only generated 65k of them, which fills up quickly
	// if nothing is picking up the dropped articles).
	WCHAR wszPrefix[12];

	wsprintfW(wszPrefix, L"d%02x", GetTickCount() & 0xff);
	wszPrefix[3] = 0;
	if (GetTempFileNameW(m_wszDropDirectory, wszPrefix, 0, szDestFilename) == 0) {
		return HRESULT_FROM_WIN32(GetLastError());
	}

	// open the destination file
	hFile = CreateFileW(szDestFilename, GENERIC_READ | GENERIC_WRITE, 
		0, NULL, OPEN_EXISTING, 
		FILE_FLAG_OVERLAPPED | FILE_FLAG_SEQUENTIAL_SCAN, NULL);
	if (hFile == INVALID_HANDLE_VALUE) {
		DeleteFileW(szDestFilename);
		return HRESULT_FROM_WIN32(GetLastError());
	}

	PFIO_CONTEXT pFIOContext = AssociateFileEx( hFile,   
	                                            TRUE,   // fStoreWithDots
	                                            TRUE    // fStoreWithTerminatingDots
	                                           );
	if (pFIOContext == NULL) {
		CloseHandle(hFile);
		DeleteFileW(szDestFilename);
		return HRESULT_FROM_WIN32(GetLastError());
	}

	// copy from the source stream to the destination file
	hr = pMsg->CopyContentToFileEx( pFIOContext, 
	                                TRUE,
	                                NULL);

	//
	// Handle the trailing dot
	//
	if ( !GetIsFileDotTerminated( pFIOContext ) ) {

	    // No dot, add it
	    AddTerminatedDot( pFIOContext->m_hFile );

	    // Set pFIOContext to has dot
	    SetIsFileDotTerminated( pFIOContext, TRUE );
	}

#if 0
	//
	// if this code is enabled then more properties will be dropped into the
	// file
	//
	SetFilePointer(hFile, 0, 0, FILE_END);

	BYTE buf[4096];
	DWORD c, dw;
	strcpy((char *) buf, "\r\n-------------\r\nheaders = "); c = strlen((char *)buf);
	WriteFile(hFile, buf, c, &dw, NULL);
	pMsg->GetProperty(IMMPID_NMP_HEADERS, 4096, &c, buf);
	WriteFile(hFile, buf, c, &dw, NULL);
	strcpy((char *) buf, "\r\n------------\r\nnewsgroups = "); c = strlen((char *)buf);
	WriteFile(hFile, buf, c, &dw, NULL);
	pMsg->GetProperty(IMMPID_NMP_NEWSGROUP_LIST, 4096, &c, buf);
	WriteFile(hFile, buf, c, &dw, NULL);
	strcpy((char *) buf, "\r\n------------\r\n"); c = strlen((char *)buf);
	WriteFile(hFile, buf, c, &dw, NULL);
#endif

	// cleanup
	ReleaseContext(pFIOContext);

	if (!FAILED(hr)) hr = S_OK;

	return (hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\nntp\server\seo\ddrop\resource.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

	Resource.h

Abstract:

	This module contains the definitions for the DirDropS
	project.

Author:

	Don Dumitru	(dondu@microsoft.com)

Revision History:

	dondu	03/17/96	created

--*/


//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by SEO.rc
//
#define IDS_PROJNAME					100
#define IDR_StdAfx						101


// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           102
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\nntp\server\seo\ddrop\stdafx.cpp ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

	StdAfx.cpp

Abstract:

	This module contains the implementation for the base
	ATL methods.

Author:

	Don Dumitru	(dondu@microsoft.com)

Revision History:

	dondu	12/04/96	created

--*/


// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>


HRESULT AtlAllocRegMapEx(_ATL_REGMAP_ENTRY **pparmeResult,
						 const CLSID *pclsid,
						 CComModule *pmodule,
						 LPCOLESTR pszIndex,
						 ...) {
	LPBYTE pbAdd = NULL;		// Working pointer to the next available "scratch space" in the map.
	DWORD dwCnt = 0;			// The count of entries in the map.
	LPOLESTR pszCLSID = NULL;	// The CLSID as a string.
	LPOLESTR pszTLID = NULL;	// The TLID as a string.

	if (!pparmeResult) {
		// The caller did not give us a place to return the result.
		return (E_POINTER);
	}
	*pparmeResult = NULL;	// For the first time through the loop, the result is NULL.
	// We are going to loop through twice.  The first time through, we haven't allocate the map yet, so
	// we will count all the strings, and add up their lenghts - this will give us the size of the buffer
	// we need to allocate for the map.  Then the second time through the loop, we will store all the
	// strings in the map.
	while (1) {
		if (pclsid) {
			// If we were passed a CLSID, then we want to include that in the map.
			if (!*pparmeResult) {
				// If this is the first time through, then we need to convert the CLSID to a string.
				HRESULT hrRes;

				hrRes = StringFromCLSID(*pclsid,&pszCLSID);
				if (!SUCCEEDED(hrRes)) {
					// We failed to convert the CLSID to a string.
					CoTaskMemFree(*pparmeResult);
					return (hrRes);
				}
			} else {
				// If this isn't the first time through, then we already have the CLSID as a string, so
				// we just need to put it in the map.
				(*pparmeResult)[dwCnt].szKey = L"CLSID";
				(*pparmeResult)[dwCnt].szData = (LPCOLESTR) pbAdd;
				wcscpy((LPOLESTR) (*pparmeResult)[dwCnt].szData,pszCLSID);
			}
			// Whether or not this is the first time through, we increment some stuff based on the size
			// of the CLSID string and the fact that we have a CLSID in the map.
			pbAdd += (wcslen(pszCLSID)+1) * sizeof(OLECHAR);
			dwCnt++;
			if (*pparmeResult) {
				// If this is not the first time through, make sure we clean up after ourselves.
				CoTaskMemFree(pszCLSID);
				pszCLSID = NULL;
			}
		}
		if (pmodule) {
			// If we were passed a module, then we want to include the TLID in the map.
			if (!*pparmeResult) {
				// If this is the first time through, then we need to load the type library, get its
				// TLID, and convert it to a string.
				USES_CONVERSION;
				HRESULT hrRes;
				TCHAR szModule[MAX_PATH];
				LPOLESTR pszModule;
				CComPtr<ITypeLib> pTypeLib;
				TLIBATTR *ptlaAttr;
				if (!GetModuleFileName(pmodule->GetTypeLibInstance(),
									   szModule,
									   sizeof(szModule)/sizeof(TCHAR))) {
					hrRes = HRESULT_FROM_WIN32(GetLastError());
					if (SUCCEEDED(hrRes)) {
						// GetModuleFileName() failed, but GetLastError() didn't report an error - so
						// fake it.
						hrRes = E_OUTOFMEMORY;
					}
					CoTaskMemFree(pszCLSID);
					return (hrRes);
				}
				if (pszIndex) {
					// If we were passed an index, that means that the type library desired is not the
					// first type library in the resources - so append the index to the module name.
					lstrcat(szModule,OLE2T(pszIndex));
				}
				pszModule = T2OLE(szModule);
				hrRes = LoadTypeLib(pszModule,&pTypeLib);
				if (!SUCCEEDED(hrRes)) {
					// If we couldn't load the type library from the module, let's try changing the
					// module name to a type library name (change the extension to .TLB) and try to load
					// *that*.
					LPTSTR pszExt = NULL;
					LPTSTR psz;

					for (psz=szModule;*psz;psz=CharNext(psz)) {
						if (*psz == _T('.')) {
							pszExt = psz;
						}
					}
					if (!pszExt) {
						pszExt = psz;
					}
					lstrcpy(pszExt,_T(".tlb"));
					pszModule = T2OLE(szModule);
					hrRes = LoadTypeLib(pszModule,&pTypeLib);
				}
				if (!SUCCEEDED(hrRes)) {
					// We failed to load the type library.
					CoTaskMemFree(pszCLSID);
					return (hrRes);
				}
				hrRes = pTypeLib->GetLibAttr(&ptlaAttr);
				if (!SUCCEEDED(hrRes)) {
					// We failed to get the type library attributes.
					CoTaskMemFree(pszCLSID);
					return (hrRes);
				}
				hrRes = StringFromCLSID(ptlaAttr->guid,&pszTLID);
				if (!SUCCEEDED(hrRes)) {
					// We failed to convert the TLID to a string.
					CoTaskMemFree(pszCLSID);
					return (hrRes);
				}
			} else {
				// If this isn't the first time through, then we already have the TLID as a string, so
				// we just need to put it in the map.
				(*pparmeResult)[dwCnt].szKey = L"LIBID";
				(*pparmeResult)[dwCnt].szData = (LPCOLESTR) pbAdd;
				wcscpy((LPOLESTR) (*pparmeResult)[dwCnt].szData,pszTLID);
			}
			// Whether or not this is the first time through, we increment some stuff based on the size
			// of the TLID string and the fact that we have a TLID in the map.
			pbAdd += (wcslen(pszTLID)+1) * sizeof(OLECHAR);
			dwCnt++;
			if (*pparmeResult) {
				// If this is not the first time through, make sure we clean up after ourselves.
				CoTaskMemFree(pszTLID);
				pszTLID = NULL;
			}
		}
		{	// Now we need to go through the varargs.  All of the varargs must be LPOLESTR (i.e. they
			// must be UNICODE), and they will consist of pairs - the key name followed by the data.  If
			// either member of the pair is NULL, that signals the end of the varargs.
			va_list valArgs;

			// Set the va_list to the start of the varargs.
			va_start(valArgs,pszIndex);
			while (1) {
				LPCOLESTR pszKey;
				LPCOLESTR pszData;

				// Get the first of the pair - this is the key name.
				pszKey = va_arg(valArgs,LPCOLESTR);
				if (!pszKey) {
					break;
				}
				// Get the second of the pair - this is the data.
				pszData = va_arg(valArgs,LPCOLESTR);
				if (!pszData) {
					break;
				}
				if (*pparmeResult) {
					// If this isn't the first time through, then we need to store the key name to the
					// map.
					(*pparmeResult)[dwCnt].szKey = (LPCOLESTR) pbAdd;
					wcscpy((LPOLESTR) (*pparmeResult)[dwCnt].szKey,pszKey);
				}
				// Whether or not this is the first time through, we increment some stuff based on the
				// size of the string.
				pbAdd += (wcslen(pszKey)+1) * sizeof(OLECHAR);
				if (*pparmeResult) {
					// If this isn't the first time through, then we need to store the data to the map.
					(*pparmeResult)[dwCnt].szData = (LPCOLESTR) pbAdd;
					wcscpy((LPOLESTR) (*pparmeResult)[dwCnt].szData,pszData);
				}
				// Whether or not this is the first time through, we increment some stuff based on the
				// size of the string and the fact that we have a string in the map.
				pbAdd += (wcslen(pszData)+1) * sizeof(OLECHAR);
				dwCnt++;
			}
			// Reset the va_list, for the sake of cleanliness.
			va_end(valArgs);
		}
		if (*pparmeResult) {
			// If we have allocated the map, that means that we are finishing the second time through
			// the loop - so we are done!
			break;
		}
		if (!*pparmeResult) {
			// If we havemn't allocate the map, that means that we are finishing the first time through
			// the loop - so we need to allocate the map in preparation for the second time through.
			// First we calculate the number of bytes needed for the map - this is one ATL_REGMAP_ENTRY
			// for each entry, plus one _ATL_REGMAP_ENTRY which signals the end of the map, plus enough
			// space for all of the strings to follow.
			DWORD dwBytes = (DWORD)((dwCnt + 1) * sizeof(_ATL_REGMAP_ENTRY) + (pbAdd-(LPBYTE) NULL));

			*pparmeResult = (_ATL_REGMAP_ENTRY *) CoTaskMemAlloc(dwBytes);
			if (!*pparmeResult) {
				// The memory allocation failed.
				CoTaskMemFree(pszCLSID);
				CoTaskMemFree(pszTLID);
				return (E_OUTOFMEMORY);
			}
			// The memory allocation was successful - fill the memory with zeroes in preparation for
			// loading with the values.
			memset(*pparmeResult,0,dwBytes);
			// Reset the counters to the "beginning" - so that on the second time through, they are used
			// to keep track of where each successive value gets stored in the memory block.
			pbAdd = ((LPBYTE) *pparmeResult) + (dwCnt + 1) * sizeof(_ATL_REGMAP_ENTRY);
			dwCnt = 0;
		}
	}
	return (S_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\nntp\server\seo\ddrop\stdafx.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

	StdAfx.h

Abstract:

	This module contains the definitions for the base
	ATL methods.

Author:

	Don Dumitru     (dondu@microsoft.com)

Revision History:

	dondu   12/04/96        created

--*/


// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#ifndef _WIN32_WINNT
	#define _WIN32_WINNT 0x0400
#endif


#ifdef _ATL_NO_DEBUG_CRT
	#include <nt.h>
	#include <ntrtl.h>
	#include <nturtl.h>
	#include <windows.h>
	#include "dbgtrace.h"
	#define _ASSERTE	_ASSERT
#endif


//#define _ATL_APARTMENT_THREADED

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>


#if defined(_ATL_SINGLE_THREADED)
	#define ATL_THREADING_MODEL_VALUE	L"Single"
#elif defined(_ATL_APARTMENT_THREADED)
	#define ATL_THREADING_MODEL_VALUE	L"Apartment"
#else
	#define ATL_THREADING_MODEL_VALUE	L"Both"
#endif


#define DECLARE_REGISTRY_RESOURCEID_EX(x,desc,progid,viprogid)			\
	static HRESULT WINAPI UpdateRegistry(BOOL bRegister) {				\
		HRESULT hrRes;													\
		_ATL_REGMAP_ENTRY *parme;										\
																		\
		hrRes = AtlAllocRegMapEx(&parme,								\
								 &GetObjectCLSID(),						\
								 &_Module,								\
								 NULL,									\
								 L"DESCRIPTION",						\
								 desc,									\
								 L"PROGID",								\
								 progid,								\
								 L"VIPROGID",							\
								 viprogid,								\
								 L"THREADINGMODEL",						\
								 ATL_THREADING_MODEL_VALUE,				\
								 NULL,									\
								 NULL);									\
		if (!SUCCEEDED(hrRes)) {										\
			return (hrRes);												\
		}																\
		hrRes = _Module.UpdateRegistryFromResource(x,bRegister,parme);	\
		CoTaskMemFree(parme);											\
		return (hrRes);													\
	}


#define DECLARE_REGISTRY_RESOURCE_EX(x,desc,progid,viprogid)				\
	static HRESULT WINAPI UpdateRegistry(BOOL bRegister) {					\
		HRESULT hrRes;														\
		_ATL_REGMAP_ENTRY *parme;											\
																			\
		hrRes = AtlAllocRegMapEx(&parme,									\
								 &GetObjectCLSID(),							\
								 &_Module,									\
								 NULL,										\
								 L"DESCRIPTION",							\
								 desc,										\
								 L"PROGID",									\
								 progid,									\
								 L"VIPROGID",								\
								 viprogid,									\
								 L"THREADINGMODEL",							\
								 ATL_THREADING_MODEL_VALUE,					\
								 NULL,										\
								 NULL);										\
		if (!SUCCEEDED(hrRes)) {											\
			return (hrRes);													\
		}																	\
		hrRes = _Module.UpdateRegistryFromResource(_T(#x),bRegister,parme);	\
		CoTaskMemFree(parme);												\
		return (hrRes);														\
	}


HRESULT AtlAllocRegMapEx(_ATL_REGMAP_ENTRY **pparmeResult,
						 const CLSID *pclsid,
						 CComModule *pmodule,
						 LPCOLESTR pszIndex,
						 ...);


template <class Base>
HRESULT AtlCreateInstanceOf(IUnknown *pUnkOuter, CComObject<Base> **pp) {
//	template <class Base>
//	HRESULT WINAPI CComObject<Base>::CreateInstance(CComObject<Base>** pp)
//	{
	    _ASSERTE(pp != NULL);
	    HRESULT hRes = E_OUTOFMEMORY;
	    CComObject<Base>* p = NULL;
	    ATLTRY(p = new CComObject<Base>())
	    if (p != NULL)
	    {
//		    p->SetVoid(NULL);					// Change this...
			p->SetVoid(pUnkOuter);				// ... to this.
	        p->InternalFinalConstructAddRef();
	        hRes = p->FinalConstruct();
	        p->InternalFinalConstructRelease();
	        if (hRes != S_OK)
	        {
	            delete p;
	            p = NULL;
	        }
	    }
	    *pp = p;
	    return hRes;
//	}
}


template <class Base>
HRESULT AtlCreateInstanceOf(IUnknown *pUnkOuter, REFIID iidDesired, LPVOID *pp) {
	HRESULT hrRes;
	CComObject<Base> *p = NULL;

	_ASSERTE(pp != NULL);
	*pp = NULL;
	hrRes = AtlCreateInstanceOf(pUnkOuter,&p);
	if (SUCCEEDED(hrRes)) {
		_ASSERTE(p != NULL);
		p->AddRef();
		hrRes = p->QueryInterface(iidDesired,pp);
		p->Release();
	}
	return (hrRes);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\nntp\server\server\addon.h ===
#ifndef	_ADDON_H_
#define	_ADDON_H_

class	CAddon	{
//
//	This class manages files which contains data with the following format : 
//
//	Name<TAB or SPACE>String with Spaces<CRLF>
//
//	Examples of such files are active.txt files and descript.txt files.
//	In these files the 'Name' is the newsgroup name, and the following
//	character contains strings which CNewsGroup objects will reference.
//	(For instance - descript.txt the extra text is the descriptive string provided
//	in response to the list newsgroups command.
//
//	This base class handles memory mapping the file, and handles insert, 
//	deletion and compaction of the data file.  Insertions are appended to the
//	end, there is no attempt to order the data.  Deletions will just overwrite
//	portions of the file with NULL's.  When we compact, we shift all the data
//	around.
//
//	The function LookupFunction() should be overridden by derived classes
//	so as we parse the file they can learn where the content is.
//	The ReadData() and FinishReadData() must be used before any pointer
//	which points into the memory mapping is used, this ensures that 
//	there are not synchronization problems as we compact or grow the file.
//

protected : 

	//	
	//	Handle to the source file 
	//
	HANDLE		m_hFile ;

	//
	//	Memory mapping of the data file !
	//
	CMapFile*	m_pMapFile ;

	//
	//	Number of bytes of the file In use - that contain original or appended data.
	//
	DWORD		m_cbInuse ;

	//
	//	Number of bytes that we have overwritten with NULLs due to deletions
	//
	DWORD		m_cbDeleted ;

	//
	//	Number of bytes at the end of the file available for 'stuff'
	//
	DWORD		m_cbAvailable ;

	//
	//	Reader/Writer lock for accessing the data.
	//
	CShareLockNH	m_Access ;

	//
	//	This function is called for each string in the file - the derived class
	//	should determine whether this string is still needed !
	//	Each line of our data file contains a string followed by a space followed by 
	//	a bunch of text (which may contain spaces).  
	//	The first string will typically be a newsgroup name.  The derived class
	//	should lookup the newsgroup, and set its member pointers to point into our 
	//	data area.  we will notify the derived class if we have to move the data 
	//	around so that the newsgroup pointers can be adjusted.
	//
	virtual		BOOL	LookupFunction( 
							LPSTR	lpstrString, 
							DWORD	cbString, 
							LPSTR	lpstrData, 
							DWORD	cbData,
							LPVOID	lpv ) = 0 ;

	//
	//	This lets the derived class know that all of the data strings are moving around - 
	//	it should delete all of its pointers into our data when this called.
	//	After this is called we will start calling LookupFunction() with the new positions.
	//	This kind of thing happens when we need to grow and shrink our memory mapping.
	//
	virtual		void	ResetAddons() = 0 ;

	//
	//	This function will remove the NULL's that we leave in the data file as we 
	//	remove entries
	//
	void		CompactImage() ;

	//
	//	This function will parse the file and call LookupFunction for each 
	//	entry as we come across it.
	//
	BOOL		ScanImage() ;

public : 

	//
	//	Constructor - set us in an empty state
	//
	CAddon(	) ;

	//
	//	lpstrAddonFile - A file containing newsgroup names followed by space followed by data.
	//	We will get a memory mapping and parse the file, and calll LookupFunction as we 
	//	separate out the distinct newsgroups.
	//	During init we will call LookupFunction with the lpvContext set to NULL.
	//
	BOOL	Init(	
				LPSTR	lpstrAddonFile,	
				BOOL	fCompact = TRUE, 
				DWORD cbGrow = 0
				) ;
	
	//
	//	Add a newsgroup and data to the data file.
	//	We may have to muck with the memory mapping, which may result in a call
	//	to ResetAddons().
	//	Once we have completed appending the line, we will call LookupFunction for the newly 
	//	added line, and pass lpvContext through.
	//
	BOOL	AppendLine( 
					LPSTR	lpstrName,	
					DWORD	cbName,	
					LPSTR	lpstrText,	
					DWORD	cbText, 
					LPVOID lpvContext 
					) ;

	//
	//	Remove a line from the file.  We will fill the line in with NULLs.
	//	When we are close'd we will compact the file removing the NULL's, or we may do 
	//	this during an AppendLine() if we figure we'll recover enough space to make it worth while.
	//
	BOOL	DeleteLine(	
					LPSTR	lpstrName
					) ;

	//
	//	Close all of our memory mappings etc...
	//
	BOOL	Close(	
					BOOL	fCompact,
					LPSTR	lpstrAddonFile
					) ;

	//
	//	Anybody who has stored a pointer as a result of a call to LookupFunction should call 
	//	ReadData() before using that pointer.
	//	This will synchronize all the things that may happen during Append's etc...
	//	(Basically this grabs a Reader/Writer Lock)
	//
	void	ReadData() ;

	//
	//	To be paired with ReadData() - releases locks.
	//
	void	FinishReadData() ;

	//
	//
	//
	void	ExclusiveData() ;

	void	UnlockExclusiveData() ;

} ; 

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\nntp\server\server\artsupp.cpp ===
#include <tigris.hxx>

//
// CPool is used to allocate memory while processing an article.
//

CPool   CArticle::gArticlePool(ARTICLE_SIGNATURE);

//
//  Largest possible CArticle derived object
//
#define MAX_ARTICLE_SIZE    max(    sizeof( CArticle ), \
                            max(    sizeof( CFromPeerArticle ), \
                            max(    sizeof( CFromClientArticle ),   \
                            max(    sizeof( CFromMasterArticle ),   \
                                    sizeof( CToClientArticle )  \
                             ) ) ) )

//
// An upperbound on the number of article objects that can
// exist at any time.
//
const   unsigned    cbMAX_ARTICLE_SIZE = MAX_ARTICLE_SIZE ;

void*	
CArticle::operator	new(	size_t	size )
{
	_ASSERT( size <= cbMAX_ARTICLE_SIZE ) ;
	return	gArticlePool.Alloc() ;
}

void
CArticle::operator	delete( void*	pv )
{
	gArticlePool.Free( pv ) ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\nntp\server\server\adminmb.cxx ===
#include "tigris.hxx"

#define INITGUID
#include "initguid.h"

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>

#include <ole2.h>
#include "iadmw.h"

//
//  We need a ptr to the IMSAdminBase interface because IMDCOM does not
//  do access checks !
//

IMSAdminBaseW * g_pAdminBase = NULL;

//
//  Following are helper functions for getting to IMSAdminBaseW
//

HRESULT
InitAdminBase()
{
    HRESULT hRes = S_OK;

    hRes = CoInitializeEx(NULL, COINIT_MULTITHREADED);

    if ( hRes == CO_E_ALREADYINITIALIZED || SUCCEEDED(hRes) ) {
        hRes = CoCreateInstance(
                   CLSID_MSAdminBase_W,
                   NULL,
                   CLSCTX_SERVER,
                   IID_IMSAdminBase_W,
                   (void**) &g_pAdminBase
                   );
    }

    return hRes;
}

VOID
UninitAdminBase()
{
    if (g_pAdminBase != NULL) {
        g_pAdminBase->Release();
        CoUninitialize();
        g_pAdminBase = NULL;
    }
}

HRESULT
OpenAdminBaseKey(
    IN  LPCWSTR lpPath,
    IN  DWORD   Access,
    OUT METADATA_HANDLE *phHandle
    )
{
    HRESULT hRes = S_OK;
    METADATA_HANDLE RootHandle;

    if (g_pAdminBase == NULL) {
        //
        // Don't have a Metadata interface
        //
        return S_FALSE;
    }

    hRes = g_pAdminBase->OpenKey(
                METADATA_MASTER_ROOT_HANDLE,
                lpPath,
                Access,
                100,
                &RootHandle
                );

    if (SUCCEEDED(hRes)) {
        *phHandle = RootHandle;
    }

    return(hRes);
}

VOID
CloseAdminBaseKey(
    IN METADATA_HANDLE hHandle
    )
{
    if( g_pAdminBase ) {
        g_pAdminBase->CloseKey(hHandle);
    }
}

BOOL
AccessCheck( 
    IN METADATA_HANDLE hHandle,
    IN DWORD Access
    )
{
    DWORD i=0;
    WCHAR wszKeyName [METADATA_MAX_NAME_LEN+1];
    HRESULT hr;

    TraceFunctEnter("AccessCheck");

    if( g_pAdminBase ) {

        //
        //  Success in enumerating a key implies access !
        //

        hr = g_pAdminBase->EnumKeys(
                            hHandle,
                            L"",
                            wszKeyName,
                            i);

        if( SUCCEEDED(hr) ) {
            DebugTrace(0,"Access Check found key %S", wszKeyName);
            return TRUE;
        } else {
            DebugTrace(0,"Access Check failed : %x", hr);
        }
    } 
    
    return FALSE;
}

BOOL 
OperatorAccessCheck( 
                  LPCSTR lpMBPath, 
                  DWORD Access 
                  )
/*++

Routine Description : 

    Check operator access against given MB path

Arguments : 
	
    lpMBPath    -   MB path to check access against
    Access      -   Access mask

Return Value : 

	If TRUE, operator has access else not.

--*/
{
    DWORD       err;
    BOOL        fRet = FALSE;
    WCHAR       wszPath [METADATA_MAX_NAME_LEN+1];
    LPWSTR      lpwstrPath = wszPath;
    METADATA_HANDLE hMeta;
    HRESULT     hr;

    TraceFunctEnter("OperatorAccessCheck");

    if (strlen(lpMBPath) > METADATA_MAX_NAME_LEN) 
    {
        ErrorTrace(0,"Invalid metabase path %s", lpMBPath);
        return FALSE;
    }

    //
    //  Impersonate the RPC client.
    //

    err = (DWORD)RpcImpersonateClient( NULL );

    if( err != NO_ERROR )
    {
        ErrorTrace(0,"cannot impersonate rpc client error %lu", err );

    } else {

        //
        //  Successfully impersonated RPC client -
        //  Validate access to MB by opening the metabase key
        //

        while ( (*lpwstrPath++ = (WCHAR)*lpMBPath++) != (WCHAR)'\0');

        // open the key with read permission because we only do enumerate
        hr = OpenAdminBaseKey( (LPCWSTR)wszPath, METADATA_PERMISSION_READ, &hMeta );
        if ( FAILED(hr) ) 
	    {
		    ErrorTrace(0,"Error opening %S : %x",wszPath,hr);
        } else {
            fRet = AccessCheck( hMeta, Access );
            CloseAdminBaseKey(  hMeta );
        }

        //
        //  Revert to our former self.
        //

        _VERIFY( !RpcRevertToSelf() );
    }

    return fRet;

}   // OperatorAccessCheck
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\nntp\server\server\cfeed.cpp ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    cfeed.cpp

Abstract:

    This module contains definition for the CFeed base class

Author:

    Carl Kadie (CarlK)     01-Oct-1995

Revision History:

--*/

#include "tigris.hxx"

//
//If some of these look very simple, make them inline!!!!
//

CPool	CFeed::gFeedPool(FEED_SIGNATURE) ;


//
//  Largest possible CInFeed derived object
//
#define MAX_FEED_SIZE   max(    sizeof( CFeed ),    \
                            max(    sizeof( COutFeed ), \
                            max(    sizeof( CInFeed ),  \
                            max(    sizeof( CFromPeerFeed ),    \
                            max(    sizeof( CFromMasterFeed ),  \
                                    sizeof( CFromClientFeed )   \
                             ) ) ) ) )

const   unsigned    cbMAX_FEED_SIZE = MAX_FEED_SIZE ;

BOOL	
CFeed::InitClass()	
/*++

Routine Description:

    Preallocates CPOOL memory for articles

Arguments:

    None.

Return Value:

    TRUE, if successful. FALSE, otherwise.

--*/
{

	return	gFeedPool.ReserveMemory(	MAX_FEEDS, cbMAX_FEED_SIZE ) ;

}


BOOL
CFeed::TermClass(
				   void
				   )
/*++

Routine Description:

	Called when done with CPOOL.

Arguments:

	None.

Return Value:

	TRUE, if successful. FALSE, otherwise.

--*/
{

	_ASSERT( gFeedPool.GetAllocCount() == 0 ) ;

	return	gFeedPool.ReleaseMemory() ;

}

void
CFeed::LogFeedEvent(	DWORD	messageId,	LPSTR	lpstrMessageId, DWORD dwInstanceId )	{

	return ;

}	

void*	CFeed::operator	new(	size_t	size )
{
	Assert( size <= MAX_FEED_SIZE ) ;
	return	gFeedPool.Alloc() ;
}

void	CFeed::operator	delete(	void*	pv )
{
	gFeedPool.Free( pv ) ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\nntp\server\server\boot.cpp ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    main.cpp

Abstract:

    This module contains the main function for the chkhash program.

Author:

    Johnson Apacible (JohnsonA)     25-Sept-1995

Revision History:

--*/

#include "tigris.hxx"
#include "chkhash.h"
#include "nntpbld.h"

/*
BOOL
RenameHashFile(
    PHTABLE			ourTable,
	CBootOptions*	pOptions
    );

BOOL
VerifyTable(
    PHTABLE			ourTable,
	CBootOptions*	pOptions
    );
*/

/*

BOOL
DeletePatternFiles(
	CBootOptions*	pOptions,
	LPSTR			lpstrPath,
	LPSTR			lpstrPattern
	);

BOOL
DeleteServerFiles( 
				PNNTP_SERVER_INSTANCE pInstance,
				CBootOptions*		 pOptions,
				MB&					 mb
				);

BOOL
BuildCandidateFile(
			PNNTP_SERVER_INSTANCE 	pInstance,
			IIS_VROOT_TABLE*	 	pTable,	
			LPSTR				 	szFile,
			BOOL					fRejectEmpties,
			DWORD					ReuseIndexFiles,
			LPDWORD 				pdwTotalFiles,
			LPDWORD 				pdwCancelState,
			LPSTR   				szErrString
			);
*/

//
//	WorkCompletion() routine for rebuilding an instance 
//	Steps to rebuild:
//	-	Cleanup tables etc
//	-	Build tree from active file or vroot scan as the case maybe
//	-	Start() the instance
//	-	Rebuild hash tables using group iterator
//	-	Stop() the instance
//	-	signal instance rebuild done (also signal progress)
//

VOID
CRebuildThread::WorkCompletion( PVOID pvRebuildContext ) 
{
    TraceFunctEnter("CRebuildThread::WorkCompletion");

/*
	BOOL	fError = FALSE;
	BOOL	DoClean = FALSE;
	LPSTR	lpstrGroupFile = NULL ;
	DWORD	dwTotalFiles = 0;
	DWORD   cSecs = 0;
	char	szTempPath[MAX_PATH*2] ;
	char	szTempFile[MAX_PATH*2] ;
	char    szErrString[MAX_PATH];
	CBootOptions*	pOptions = NULL ;
	CNewsTree* pTree = NULL ;
	MB      mb( (IMDCOM*) g_pInetSvc->QueryMDObject() );
*/

    //
    // Get the instance pointer
    //
    _ASSERT( pvRebuildContext );
	PNNTP_SERVER_INSTANCE pInstance = (PNNTP_SERVER_INSTANCE) pvRebuildContext ;
	_ASSERT( pInstance->QueryServerState() == MD_SERVER_STATE_STOPPED );
	_ASSERT( g_pInetSvc->QueryCurrentServiceState() == SERVICE_RUNNING );

	//
	// Now we call instance's rebuild method - rebuild
	//
	pInstance->Rebuild();

    //
    //  Set last rebuild error
    //

    /*
    if (!pInstance->m_dwLastRebuildError)
        pInstance->m_dwLastRebuildError = GetLastError();
    */
    
    //
    // Done, dereference the instance
    //
    pInstance->Dereference();
	
#if 0
	pOptions = pInstance->m_BootOptions ;
	pInstance->m_dwProgress = 0 ;
	pInstance->m_dwLastRebuildError = 0 ;
	DoClean = pOptions->DoClean ;
    lstrcpy( szErrString, "" );
    
	//
	//	Scan the virtual roots to build a candidate group list file if necessary
	//
	if( DoClean && !pOptions->IsActiveFile ) {

		if( pOptions->szGroupFile[0] == '\0' ) {

			if( GetTempPath( sizeof( szTempPath ), szTempPath ) == 0 ) {
				pOptions->ReportPrint( "Can't get temp path - error %d\n", GetLastError() ) ;
				goto exit;
			}

			if( GetTempFileName( szTempPath, "nntp", 0, szTempFile ) == 0 ) {
				pOptions->ReportPrint( "Can't create temp file - error %d\n", GetLastError() ) ;
				goto exit;
			}
			lstrcpy( pOptions->szGroupFile, szTempFile ) ;
		}

		lpstrGroupFile = pOptions->szGroupFile ;
		if( !BuildCandidateFile(	pInstance,
									pInstance->QueryVrootTable(),
									lpstrGroupFile, 
									pOptions->OmitNonleafDirs, 
									pOptions->ReuseIndexFiles,
									&dwTotalFiles,
									&(pOptions->m_dwCancelState),
									szErrString ) )	
		{
			// error building candidate file
			pOptions->ReportPrint("Failed to build candidates file: Error %d ErrorString %s\n", GetLastError(), szErrString);
			goto exit ;
		}

		DebugTrace(0,"Found %d files in first pass scan", dwTotalFiles );

	} else {
		lpstrGroupFile = pOptions->szGroupFile ;
	}

    //
    //  if standard rebuild, then handle it differently
    //
    
    if ( pOptions->ReuseIndexFiles == NNTPBLD_DEGREE_STANDARD )
    {
        //
        // Patially boot XOVER and ARTICLE hash table
        // Also construct most of the server structures
        //
        if (!pInstance->StartHashTables())
        {
            fError = TRUE;
            ErrorTrace(0,"Error booting hash tables");
            pInstance->StopHashTables();
            goto exit;
        }

        //
	    //	Do the rebuild
	    //

	    pTree = pInstance->GetTree() ;
	    _ASSERT( pTree );
	    _ASSERT( lpstrGroupFile );

        if( pTree->BuildTreeEx( lpstrGroupFile ) )	{

            pOptions->ReportPrint("Rebuilding group.lst file...\n");

            pOptions->m_hShutdownEvent = QueryShutdownEvent();
    	    pOptions->m_dwTotalFiles = dwTotalFiles;
            pOptions->m_cGroups = (DWORD) pTree->GetGroupCount();

            if ( RebuildGroupList( pInstance ) ) 
    	    {
                pOptions->ReportPrint("Done.\n");
            } else {
                fError = TRUE;
                pOptions->ReportPrint("Failed.\n");

            }
        } else {
		    fError = TRUE;
		    pOptions->ReportPrint( "NNTPBLD aborting due to error building news tree\n" ) ;

            //
            //  rebuild cancelled internally !
            //
        
		    pOptions->m_dwCancelState = NNTPBLD_CMD_CANCEL_PENDING ;
        }

	    //
	    //	If we aborted due to a cancel, simply log error,
        //  and delete the temparory file, if any.
	    //
        if (pOptions->m_dwCancelState == NNTPBLD_CMD_CANCEL_PENDING) {

    	    pInstance->m_BootOptions->m_dwCancelState = NNTPBLD_CMD_CANCEL ;
            DeleteFile( (LPCTSTR) pInstance->QueryGroupListFile() );
            DebugTrace(0,"Instance %d: Rebuild cancelled", pInstance->QueryInstanceId());
		    fError = TRUE;
            
	    }

        //
        // Shutdown hash tables no matter what
        //

        pInstance->StopHashTables();

        if (!fError && !pInstance->m_dwLastRebuildError)
        {

	        //
            // Copy the group.lst.tmp into group.lst, delete group.lst.tmp if success.
            // On StartHashTables() we swapped the name, so the logic is reversed here!!!
            //
  