aLevel <= iBestKashidaLevel)
                    {
                        iBestKashidaLevel = iKashidaLevel;
                        Assert(iPropL > 0);
                        iBestPr = iPropL - 1;
                    }
                }
                else
                {
                    rgExpType[iPropL] = exptNone;
                }
            }
            break;

        }

        iPropL++;
    }

    // add/set any remaining priority.
    if(fKashida && iBestPr >= 0 && flKashidaPct)
    {
        rgExpType[iBestPr] = exptAddInkContinuous;
        rgexpinfo[iBestPr].prior = 1;
        rgexpinfo[iBestPr].duMax = lsexpinfInfinity;
        rgexpinfo[iBestPr].fCanBeUsedForResidual = FALSE;
        rgexpinfo[iBestPr].u.AddInkContinuous.duMin = iKashidaWidth;
    }
    
Cleanup:

    return lserr;
}

//-----------------------------------------------------------------------------
//
//  Function:   GetGlyphExpansionInkInfo (member, LS callback)
//
//  Synopsis:   Unimplemented LineServices callback
//
//  Returns:    lserrNone
//
//-----------------------------------------------------------------------------

LSERR WINAPI
CLineServices::GetGlyphExpansionInkInfo(
    PLSRUN plsrun,              // IN
    LSDEVICE lsDeviceID,        // IN
    GINDEX gindex,              // IN
    GPROP gprop,                // IN
    LSTFLOW kTFlow,             // IN
    DWORD cAddInkDiscrete,      // IN
    long* rgDu)                 // OUT
{
    LSTRACE(GetGlyphExpansionInkInfo);
    LSNOTIMPL(GetGlyphExpansionInkInfo);
    return lserrNone;
}

//-----------------------------------------------------------------------------
//
//  Function:   FTruncateBefore (member, LS callback)
//
//  Synopsis:   Unimplemented LineServices callback
//
//  Returns:    lserrNone
//
//-----------------------------------------------------------------------------

LSERR WINAPI
CLineServices::FTruncateBefore(
    PLSRUN plsrunCur,       // IN
    LSCP cpCur,             // IN
    WCHAR wchCur,           // IN
    long durCur,            // IN
    PLSRUN plsrunPrev,      // IN
    LSCP cpPrev,            // IN
    WCHAR wchPrev,          // IN
    long durPrev,           // IN
    long durCut,            // IN
    BOOL* pfTruncateBefore) // OUT
{
    LSTRACE(FTruncateBefore);
    // FUTURE (mikejoch) Need to adjust cp values if we ever implement this.
    LSNOTIMPL(FTruncateBefore);
    return lserrNone;
}

//-----------------------------------------------------------------------------
//
//  Function:   FHangingPunct (member, LS callback)
//
//  Synopsis:   Unimplemented LineServices callback
//
//  Returns:    lserrNone
//
//-----------------------------------------------------------------------------

LSERR WINAPI
CLineServices::FHangingPunct(
    PLSRUN plsrun,
    MWCLS mwcls,
    WCHAR wch,
    BOOL* pfHangingPunct)
{
    LSTRACE(FHangingPunct);

    *pfHangingPunct = FALSE;

    return lserrNone;
}

//-----------------------------------------------------------------------------
//
//  Function:   GetSnapGrid (member, LS callback)
//
//  Synopsis:   Unimplemented LineServices callback
//
//  Returns:    lserrNone
//
//-----------------------------------------------------------------------------

LSERR WINAPI
CLineServices::GetSnapGrid(
    WCHAR* rgwch,           // IN
    PLSRUN* rgplsrun,       // IN
    LSCP* rgcp,             // IN
    DWORD cwch,             // IN
    BOOL* rgfSnap,          // OUT
    DWORD* pwGridNumber)    // OUT
{
    LSTRACE(GetSnapGrid);

    // This callback function shouldn't be called. We manage grid snapping ourselves.
    *pwGridNumber = 0;

    return lserrNone;
}

//-----------------------------------------------------------------------------
//
//  Function:   FCancelHangingPunct (member, LS callback)
//
//  Synopsis:   Unimplemented LineServices callback
//
//  Returns:    lserrNone
//
//-----------------------------------------------------------------------------

LSERR WINAPI
CLineServices::FCancelHangingPunct(
    LSCP cpLim,                // IN
    LSCP cpLastAdjustable,      // IN
    WCHAR wch,                  // IN
    MWCLS mwcls,                // IN
    BOOL* pfCancelHangingPunct) // OUT
{
    LSTRACE(FCancelHangingPunct);
    // FUTURE (mikejoch) Need to adjust cp values if we ever implement this.
    LSNOTIMPL(FCancelHangingPunct);
    return lserrNone;
}

//-----------------------------------------------------------------------------
//
//  Function:   ModifyCompAtLastChar (member, LS callback)
//
//  Synopsis:   Unimplemented LineServices callback
//
//  Returns:    lserrNone
//
//-----------------------------------------------------------------------------

LSERR WINAPI
CLineServices::ModifyCompAtLastChar(
    LSCP cpLim,             // IN
    LSCP cpLastAdjustable,  // IN
    WCHAR wchLast,          // IN
    MWCLS mwcls,            // IN
    long durCompLastRight,  // IN
    long durCompLastLeft,   // IN
    long* pdurChangeComp)   // OUT
{
    LSTRACE(ModifyCompAtLastChar);
    // FUTURE (mikejoch) Need to adjust cp values if we ever implement this.
    LSNOTIMPL(ModifyCompAtLastChar);
    return lserrNone;
}

//-----------------------------------------------------------------------------
//
//  Function:   EnumText (member, LS callback)
//
//  Synopsis:   Enumeration function, currently unimplemented
//
//  Returns:    lserrNone
//
//-----------------------------------------------------------------------------

LSERR WINAPI
CLineServices::EnumText(
    PLSRUN plsrun,           // IN
    LSCP cpFirst,            // IN
    LSDCP dcp,               // IN
    LPCWSTR rgwch,           // IN
    DWORD cwch,              // IN
    LSTFLOW lstflow,         // IN
    BOOL fReverseOrder,      // IN
    BOOL fGeometryProvided,  // IN
    const POINT* pptStart,   // IN
    PCHEIGHTS pheightsPres,  // IN
    long dupRun,             // IN
    BOOL fCharWidthProvided, // IN
    long* rgdup)             // IN
{
    LSTRACE(EnumText);

    return lserrNone;
}

//-----------------------------------------------------------------------------
//
//  Function:   EnumTab (member, LS callback)
//
//  Synopsis:   Enumeration function, currently unimplemented
//
//  Returns:    lserrNone
//
//-----------------------------------------------------------------------------

LSERR WINAPI
CLineServices::EnumTab(
    PLSRUN plsrun,          // IN
    LSCP cpFirst,           // IN
    WCHAR * rgwch,          // IN                   
    WCHAR wchTabLeader,     // IN
    LSTFLOW lstflow,        // IN
    BOOL fReversedOrder,    // IN
    BOOL fGeometryProvided, // IN
    const POINT* pptStart,  // IN
    PCHEIGHTS pheightsPres, // IN
    long dupRun)
{
    LSTRACE(EnumTab);

    return lserrNone;
}

//-----------------------------------------------------------------------------
//
//  Function:   EnumPen (member, LS callback)
//
//  Synopsis:   Enumeration function, currently unimplemented
//
//  Returns:    lserrNone
//
//-----------------------------------------------------------------------------

LSERR WINAPI
CLineServices::EnumPen(
    BOOL fBorder,           // IN
    LSTFLOW lstflow,        // IN
    BOOL fReverseOrder,     // IN
    BOOL fGeometryProvided, // IN
    const POINT* pptStart,  // IN
    long dup,               // IN
    long dvp)               // IN
{
    LSTRACE(EnumPen);

    return lserrNone;
}

//-----------------------------------------------------------------------------
//
//  Function:   GetObjectHandlerInfo (member, LS callback)
//
//  Synopsis:   Returns an object handler for the client-side functionality
//              of objects which are handled primarily by LineServices.
//
//  Returns:    lserrNone
//
//-----------------------------------------------------------------------------

LSERR WINAPI
CLineServices::GetObjectHandlerInfo(
    DWORD idObj,        // IN
    void* pObjectInfo)  // OUT
{
    LSTRACE(GetObjectHandlerInfo);

    switch (idObj)
    {
        case LSOBJID_RUBY:
#if !defined(UNIX) && !defined(_MAC)
            Assert( sizeof(RUBYINIT) == sizeof(::RUBYINIT) );
            *(RUBYINIT *)pObjectInfo = s_rubyinit;
#else
            int iSize = InitRubyinit();
            Assert( sizeof(RUBYINIT) == sizeof(::RUBYINIT) + iSize );
            *(::RUBYINIT *)pObjectInfo = s_unix_rubyinit;
#endif
            break;

        case LSOBJID_TATENAKAYOKO:
#if !defined(UNIX) && !defined(_MAC)
            Assert( sizeof(TATENAKAYOKOINIT) == sizeof(::TATENAKAYOKOINIT) );
            *(TATENAKAYOKOINIT *)pObjectInfo = s_tatenakayokoinit;
#else
            iSize = InitTatenakayokoinit();
            Assert( sizeof(TATENAKAYOKOINIT) == sizeof(::TATENAKAYOKOINIT) + iSize);
            *(::TATENAKAYOKOINIT *)pObjectInfo = s_unix_tatenakayokoinit;
#endif
            break;

        case LSOBJID_HIH:
#if !defined(UNIX) && !defined(_MAC)
            Assert( sizeof(HIHINIT) == sizeof(::HIHINIT) );
            *(HIHINIT *)pObjectInfo = s_hihinit;
#else
            iSize = InitHihinit();
            Assert( sizeof(HIHINIT) == sizeof(::HIHINIT) + iSize);
            *(::HIHINIT *)pObjectInfo = s_unix_hihinit;
#endif
            break;

        case LSOBJID_WARICHU:
#if !defined(UNIX) && !defined(_MAC)
            Assert( sizeof(WARICHUINIT) == sizeof(::WARICHUINIT) );
            *(WARICHUINIT *)pObjectInfo = s_warichuinit;
#else
            iSize = InitWarichuinit();
            Assert( sizeof(WARICHUINIT) == sizeof(::WARICHUINIT) + iSize);
            *(::WARICHUINIT *)pObjectInfo = s_unix_warichuinit;
#endif
            break;

        case LSOBJID_REVERSE:
#if !defined(UNIX) && !defined(_MAC)
            Assert( sizeof(REVERSEINIT) == sizeof(::REVERSEINIT) );
            *(REVERSEINIT *)pObjectInfo = s_reverseinit;
#else
            iSize = InitReverseinit();
            Assert( sizeof(REVERSEINIT) == sizeof(::REVERSEINIT) + iSize);
            *(::REVERSEINIT *)pObjectInfo = s_unix_reverseinit;
#endif
            break;

        default:
            AssertSz(0,"Unknown LS object ID.");
            break;
    }

    return lserrNone;
}

//-----------------------------------------------------------------------------
//
//  Function:   AssertFailed (member, LS callback)
//
//  Synopsis:   Assert callback for LineServices
//
//  Returns:    Nothing.
//
//-----------------------------------------------------------------------------

void WINAPI
CLineServices::AssertFailed(
    char* szMessage,
    char* szFile,
    int   iLine)
{
    LSTRACE(AssertFailed);

#if DBG==1
    if (IsTagEnabled(tagLSAsserts))
    {
        DbgExAssertImpl( szFile, iLine, szMessage );
    }
#endif
}

//-----------------------------------------------------------------------------
//
//  Function:   ChunkifyTextRun
//
//  Synopsis:   Break up a text run if necessary.
//
//  Returns:    lserr.
//
//-----------------------------------------------------------------------------

LSERR
CLineServices::ChunkifyTextRun(COneRun *por, COneRun **pporOut)
{
    LONG    cchRun;
    LPCWSTR pwchRun;
    BOOL    fHasInclEOLWhite = por->_pPF->HasInclEOLWhite(por->_fInnerPF);
    const   DWORD cpCurr = por->Cp();
    LSERR   lserr = lserrNone;
    
    *pporOut = por;
    
    //
    // 0) If current run has character grid, in some cases we need to open/close
    //    LS installed object (LSOBJID_LAYOUTGRID).
    //    A special object should be created in following circumstances:
    //    * 'layout-grid-type' is 'fixed' and run has 'cursive' characters.
    //    * 'layout-grid-type' is 'strict' and run has 'cursive'/'half-width' characters
    //
    if (por->GetCF()->HasCharGrid(por->_fInnerCF))
    {
        if (!IsFrozen())
        {
            if (    por->GetPF()->GetLayoutGridType(por->_fInnerPF) == styleLayoutGridTypeFixed
                ||  por->GetPF()->GetLayoutGridType(por->_fInnerPF) == styleLayoutGridTypeStrict)
            {
                // Look backward for a run which is either:
                // * normal text run.
                // * synthetic run of type SYNTHTYPE_LAYOUTGRID
                // * synthetic run of type SYNTHTYPE_ENDLAYOUTGRID
                COneRun * porGridCompare = por->_pPrev ? por->_pPrev : _listCurrent._pTail;
                while (     porGridCompare
                        &&  !(porGridCompare->_ptp->IsText() &&  porGridCompare->IsNormalRun())
                        &&  porGridCompare->_synthType != SYNTHTYPE_LAYOUTGRID
                        &&  porGridCompare->_synthType != SYNTHTYPE_ENDLAYOUTGRID)
                {
                    porGridCompare = porGridCompare->_pPrev;
                }
                if (porGridCompare && porGridCompare->_synthType == SYNTHTYPE_ENDLAYOUTGRID)
                    porGridCompare = NULL;

                if (por->IsOneCharPerGridCell())
                {
                    if (    porGridCompare 
                        &&  porGridCompare->IsNormalRun()
                        &&  porGridCompare->GetCF()->HasCharGrid(porGridCompare->_fInnerCF)
                        &&  !porGridCompare->IsOneCharPerGridCell())
                    {
                        // Need to tell LS that we are closing artificially opened
                        // layout grid object.
                        Assert(_cLayoutGridObjArtificial > 0);  // Can't close without opening
                        --_cLayoutGridObjArtificial;
                        lserr = AppendILSControlChar(por, SYNTHTYPE_ENDLAYOUTGRID, pporOut);
                        Assert(lserr != lserrNone || (*pporOut)->_synthType != SYNTHTYPE_NONE);
                        goto Cleanup;
                    }
                }
                else
                {
                    if (    !porGridCompare 
                        ||  (   porGridCompare->IsNormalRun()
                            &&  (   !porGridCompare->GetCF()->HasCharGrid(porGridCompare->_fInnerCF)
                                ||  porGridCompare->IsOneCharPerGridCell())))
                    {
                        // Need to tell LS that we are opening artificial layout grid object.
                        Assert(_cLayoutGridObjArtificial == 0); // We are allowed to have only one
                        ++_cLayoutGridObjArtificial;
                        lserr = AppendILSControlChar(por, SYNTHTYPE_LAYOUTGRID, pporOut);
                        Assert(lserr != lserrNone || (*pporOut)->_synthType != SYNTHTYPE_NONE);
                        goto Cleanup;
                    }
                }
            }
        }
    }
    else if (_cLayoutGridObjArtificial > 0)
    {
        // Look backward for a run which is either:
        // * normal text run.
        // * synthetic run of type SYNTHTYPE_LAYOUTGRID
        // * synthetic run of type SYNTHTYPE_ENDLAYOUTGRID
        COneRun * porGridCompare = por->_pPrev ? por->_pPrev : _listCurrent._pTail;
        while (     porGridCompare
                &&  !(porGridCompare->_ptp->IsText() &&  porGridCompare->IsNormalRun())
                &&  porGridCompare->_synthType != SYNTHTYPE_LAYOUTGRID
                &&  porGridCompare->_synthType != SYNTHTYPE_ENDLAYOUTGRID)
        {
            porGridCompare = porGridCompare->_pPrev;
        }
        if (porGridCompare && porGridCompare->_synthType == SYNTHTYPE_ENDLAYOUTGRID)
        {
            Assert(_cLayoutGridObjArtificial == 0);
            porGridCompare = NULL;
        }

        if (    porGridCompare 
            &&  porGridCompare->IsNormalRun()
            &&  porGridCompare->GetCF()->HasCharGrid(porGridCompare->_fInnerCF)
            &&  !porGridCompare->IsOneCharPerGridCell())
        {
            // Need to tell LS that we are closing artificially opened
            // layout grid object.
            Assert(_cLayoutGridObjArtificial > 0);  // Can't close without opening
            --_cLayoutGridObjArtificial;
            lserr = AppendILSControlChar(por, SYNTHTYPE_ENDLAYOUTGRID, pporOut);
            Assert(lserr != lserrNone || (*pporOut)->_synthType != SYNTHTYPE_NONE);
            goto Cleanup;
        }
    }

    //
    // 1) If there is a whitespace at the beginning of line, we
    //    do not want to show the whitespace (0 width -- the right
    //    way to do it is to say that the run is hidden).
    //
    if (IsFirstNonWhiteOnLine(cpCurr))
    {
        const TCHAR * pwchRun = por->_pchBase;
        DWORD cp = cpCurr;
        cchRun  = por->_lscch;

        if (!fHasInclEOLWhite)
        {
            while (cchRun)
            {
                const TCHAR ch = *pwchRun++;

                if (!IsWhite(ch))
                    break;

                // Note a whitespace at BOL
                WhiteAtBOL(cp, 1);
                //_lineFlags.AddLineFlag(cp, FLAG_HAS_NOBLAST);
                cp++;

                // Goto next character
                cchRun--;
            }
        }


        //
        // Did we find any whitespaces at BOL? If we did, then
        // create a chunk with those whitespace and mark them
        // as hidden.
        //
        if (cchRun != por->_lscch)
        {
            por->_lscch -= cchRun;
            por->_fHidden = TRUE;
            goto Cleanup;
        }
    }

    //
    // 2. Fold whitespace after an aligned or abspos'd site if there
    //    was a whitespace *before* the aligned site. The way we do this
    //    folding is by saying that the present space is hidden.
    //
    {
        const TCHAR chFirst = *por->_pchBase;
        if (!fHasInclEOLWhite)
        {
            if ( !_fIsEditable
                   )
            {
                if (   IsWhite(chFirst)
                    && NeedToEatThisSpace(por)
                   )
                {
                    _lineFlags.AddLineFlag(cpCurr, FLAG_HAS_NOBLAST);
                    por->_lscch = 1;
                    por->_fHidden = TRUE;
                    goto Cleanup;
                }
            }

            if (IsFirstNonWhiteOnLine(cpCurr))
            {
                //
                // 3. Note any \n\r's
                //
                if (chFirst == TEXT('\r') || chFirst == TEXT('\n'))
                {
                    WhiteAtBOL(cpCurr, 1);
                    _lineFlags.AddLineFlag(cpCurr, FLAG_HAS_NOBLAST);
                }
            }
        }
    }
    
    if (_fScanForCR)
    {
        cchRun = por->_lscch;
        pwchRun = por->_pchBase;

        if (WCH_CR == *pwchRun)
        {
            // If all we have on the line are sites, then we do not want the \r to
            // contribute to height of the line and hence we set _fNoTextMetrics to TRUE.
            if (LineHasOnlySites(por->Cp()))
                por->_fNoTextMetrics = TRUE;
            
            lserr = TerminateLine(por, TL_ADDNONE, pporOut);
            if (lserr != lserrNone)
                goto Cleanup;
            if (*pporOut == NULL)
            {
                //
                // All lines ending in a carriage return have the BR flag set on them.
                //
                _lineFlags.AddLineFlag(cpCurr, FLAG_HAS_A_BR);
                por->FillSynthData(SYNTHTYPE_LINEBREAK);
                *pporOut = por;
            }
            goto Cleanup;
        }
        // if we came here after a single site in _fScanForCR mode, it means that we
        // have some text after the single site and hence it should be on the next
        // line. Hence terminate the line here. (If it were followed by a \r, then
        // it would have fallen in the above case which would have consumed that \r)
        else if (_fSingleSite)
        {
            lserr = TerminateLine(por, TL_ADDEOS, pporOut);
            goto Cleanup;
        }
        else
        {
            LONG cch = 0;
            while (cch != cchRun)
            {
                if (WCH_CR == *pwchRun)
                    break;
                cch++;
                pwchRun++;
            }
            por->_lscch = cch;
        }
    }

    Assert(por->_ptp && por->_ptp->IsText() && por->_sid == DWORD(por->_ptp->Sid()));

    if (   _pBidiLine != NULL
        || sidAsciiLatin != por->_sid
        || g_iNumShape != NUMSHAPE_NONE
        || _li._fLookaheadForGlyphing)
    {
        BOOL fGlyph = FALSE;
        BOOL fForceGlyphing = FALSE;
        BOOL fNeedBidiLine = (_pBidiLine != NULL);
        BOOL fRTL = FALSE;
        DWORD uLangDigits = LANG_NEUTRAL;
        WCHAR chNext = WCH_NULL;

        //
        // 4. Note any glyphable etc chars
        //
        cchRun = por->_lscch;
        pwchRun = por->_pchBase;
        while (cchRun-- && !(fGlyph && fNeedBidiLine))
        {
            const TCHAR ch = *pwchRun++;

            fGlyph |= IsGlyphableChar(ch);
            fNeedBidiLine |= IsRTLChar(ch);
        }

        //
        // 5. Break run based on the text direction.
        //
        if (fNeedBidiLine && _pBidiLine == NULL)
        {
            _pBidiLine = new CBidiLine(_treeInfo, _cpStart, _li._fRTLLn, _pli);
        }
        if (_pBidiLine != NULL)
        {
            por->_lscch = _pBidiLine->GetRunCchRemaining(por->Cp(), por->_lscch);
            // FUTURE (mikejoch) We are handling symmetric swapping by forced
            // glyphing of RTL runs. We may be able to do this faster by
            // swapping symmetric characters in CLSRenderer::TextOut().
            fRTL = fForceGlyphing = _pBidiLine->GetLevel(por->Cp()) & 1;
        }

        //
        // 6. Break run based on the digits.
        //
        if (g_iNumShape != NUMSHAPE_NONE)
        {
            cchRun = por->_lscch;
            pwchRun = por->_pchBase;
            while (cchRun && !InRange(*pwchRun, ',', '9'))
            {
                pwchRun++;
                cchRun--;
            }
            if (cchRun)
            {
                if (g_iNumShape == NUMSHAPE_NATIVE)
                {
                    uLangDigits = g_uLangNationalDigits;
                    fGlyph = TRUE;
                }
                else
                {
                    COneRun * porContext;

                    Assert(g_iNumShape == NUMSHAPE_CONTEXT && InRange(*pwchRun, ',', '9'));

                    // Scan back for first strong text.
                    cchRun = pwchRun - por->_pchBase;
                    pwchRun--;
                    while (cchRun != 0 && (!IsStrongClass(DirClassFromCh(*pwchRun)) || InRange(*pwchRun, WCH_LRM, WCH_RLM)))
                    {
                        cchRun--;
                        pwchRun--;
                    }
                    porContext = _listCurrent._pTail;
                    if (porContext == por)
                    {
                        porContext = porContext->_pPrev;
                    }
                    while (cchRun == 0 && porContext != NULL)
                    {
                        if (porContext->IsNormalRun() && porContext->_pchBase != NULL)
                        {
                            cchRun = porContext->_lscch;
                            pwchRun = porContext->_pchBase + cchRun - 1;
                            while (cchRun != 0 && (!IsStrongClass(DirClassFromCh(*pwchRun)) || InRange(*pwchRun, WCH_LRM, WCH_RLM)))
                            {
                                cchRun--;
                                pwchRun--;
                            }
                        }

                        if (cchRun == 0)
                        {
                            porContext = porContext->_pPrev;
                        }
                    }

                    if (cchRun > 0 && porContext != NULL)
                    {
                        CComplexRun * pcr;
                        const SCRIPT_PROPERTIES *psp = NULL;

                        pcr = porContext->GetComplexRun();
                        if (pcr != NULL)
                        {
                            psp = GetScriptProperties(pcr->GetAnalysis()->eScript);

                            uLangDigits = psp->langid;
                            fGlyph = TRUE;
                        }
                    }
                    else if (   _li._fRTLLn 
                             && IsInArabicBlock(PRIMARYLANGID(g_lcidLocalUserDefault)))
                    {
                        uLangDigits = PRIMARYLANGID(g_lcidLocalUserDefault);
                        fGlyph = TRUE;
                    }
                }
            }
        }

        //
        // 7. Check if we should have glyphed the prior run (for combining
        //    Latin diacritics; esp. Vietnamese)
        //
        if (_lsMode == LSMODE_MEASURER && !_li._fLookaheadForGlyphing)
        {
            if (fGlyph && IsCombiningMark(*(por->_pchBase)))
            {
                // We want to break the shaping if the formats are not similar
                COneRun * porPrev = _listCurrent._pTail;

                while (porPrev != NULL && !porPrev->IsNormalRun())
                {
                    porPrev = porPrev->_pPrev;
                }

                if (porPrev != NULL && !porPrev->_lsCharProps.fGlyphBased)
                {
                    const CCharFormat *pCF1 = por->GetCF();
                    const CCharFormat *pCF2 = porPrev->GetCF();

                    Assert(pCF1 != NULL && pCF2 != NULL);
                    _li._fLookaheadForGlyphing = pCF1->CompareForLikeFormat(pCF2);
                    _fNeedRecreateLine = TRUE;
                }
            }
        }
        else if (_li._fLookaheadForGlyphing)
        {
            Assert (por->_lscch >= 1);

            CTxtPtr txtptr(_pMarkup, por->Cp() + por->_lscch - 1);

            // N.B. (mikejoch) This is an extremely non-kosher lookup to do
            // here. It is quite possible that chNext will be from an
            // entirely different site. If that happens, though, it will
            // only cause the unnecessary glyphing of this run, which
            // doesn't actually affect the visual appearence.
            while ((chNext = txtptr.NextChar()) == WCH_NODE);
            if (IsCombiningMark(chNext))
            {
                // Good chance this run needs to be glyphed with the next one.
                // Turn glyphing on.
                fGlyph = fForceGlyphing = TRUE;
            }
        }

        //
        // 8. Break run based on the script.
        //
        if (fGlyph || fRTL)
        {
            CComplexRun * pcr = por->GetNewComplexRun();

            if (pcr == NULL)
                return lserrOutOfMemory;

            pcr->ComputeAnalysis(_pFlowLayout, fRTL, fForceGlyphing, chNext,
                                 _chPassword, por, _listCurrent._pTail, 
                                 uLangDigits, _pBidiLine);

            // Something on the line needs glyphing.
            if (por->_lsCharProps.fGlyphBased)
            {
                _fGlyphOnLine = TRUE;

                //
                // In case of glyphing set sid to sidDefault.
                // Keep sid informatio only for:
                // * surrogates
                // * sidHan - we need to UnUnify it and keep this information for fontlinking
                // 
                if (   uLangDigits != LANG_NEUTRAL
                    || (   por->_sid != sidHan 
                        && por->_sid != sidThai
                        && por->_sid != sidHangul
#ifndef NO_UTF16
                        && por->_sid != sidSurrogateA 
                        && por->_sid != sidSurrogateB
#endif
                       )
                   )
                {
                    por->_sid = ScriptIDFromLangID(uLangDigits);
                }
            }
        }
    }

    Assert(sidAmbiguous < sidCurrency);
    if (por->_sid >= sidAmbiguous) 
    {
        //
        // (Bug 44817) (grzegorz) Built-in printer fonts sometimes do not contain
        // EURO sign. So, in case of priniting currency signs font's out precision
        // is changed to force downloading software fonts instead of using printer 
        // built-in fonts.
        //
        if (    por->_sid == sidCurrency
            &&  _pci->_pMarkup->IsPrintMedia())
        {
            CCharFormat * pCFNew = por->GetOtherCloneCF();
            pCFNew->_fOutPrecision = 1;
            pCFNew->_bCrcFont = pCFNew->ComputeFontCrc();

            // Do not blast this line
            _lineFlags.AddLineFlag(por->Cp(), FLAG_HAS_NOBLAST);
        }

        if (por->_sid == sidAmbiguous)
        {
            //
            // (Bug 85263) (grzegorz) If we have SOFT HYPHEN character we don't want to 
            // blast a line. In case of blasting we render this character, that is wrong.
            //
            cchRun = por->_lscch;
            pwchRun = por->_pchBase;

            LONG cch = 0;
            while (cch != cchRun)
            {
                if (WCH_NONREQHYPHEN == *pwchRun)
                    break;
                cch++;
                pwchRun++;
            }
            if (cch != cchRun)
            {
                // Don't blast this line
                _lineFlags.AddLineFlag(por->Cp(), FLAG_HAS_NOBLAST);
            }

            COneRun * porPrev = _listCurrent._pTail;
            while (porPrev != NULL && (!porPrev->IsNormalRun() || porPrev == por))
            {
                porPrev = porPrev->_pPrev;
            }

            // Disambiguate ScriptId
            por->_sid = fl().DisambiguateScript(_pMarkup->GetFamilyCodePage(), 
                por->GetCF()->_lcid, porPrev ? porPrev->_sid : sidDefault, por->_pchBase, &por->_lscch);

            _lineFlags.AddLineFlag(por->Cp(), FLAG_HAS_NOBLAST);
        }
    }

    // Ununify sidHan script
    if (por->_sid == sidHan)
    {
        CCcs ccs;
        GetCcs(&ccs, por, _pci->_hdc, _pci, FALSE);
        const CBaseCcs * pBaseCcs = ccs.GetBaseCcs();
        const UINT uiFamilyCodePage = _pMarkup->GetFamilyCodePage();

        SCRIPT_IDS sidsFace = 0;
        if (pBaseCcs)
            sidsFace = fc().EnsureScriptIDsForFont(_pci->_hdc, pBaseCcs, FC_SIDS_USEMLANG);
        por->_sid = fl().UnunifyHanScript(uiFamilyCodePage, 
                por->GetCF()->_lcid, sidsFace, por->_pchBase, &por->_lscch);

        // We want Han chars to linebreak with Wide (W) rules.
        por->_brkopt |= fCscWide;

        _lineFlags.AddLineFlag(por->Cp(), FLAG_HAS_NOBLAST);
    }
    
    // Do not blast lines with layout grid.
    if (por->GetCF()->HasLayoutGrid(por->_fInnerCF))
    {
        _lineFlags.AddLineFlag(por->Cp(), FLAG_HAS_NOBLAST);

        // Vertical align lines with line layout grid
        if (por->GetCF()->HasLineGrid(por->_fInnerCF))
            _lineFlags.AddLineFlag(por->Cp(), FLAG_HAS_VALIGN);
    }

    // Do not blast lines with non default vertical-align attribute.
    if (por->GetCF()->_fNeedsVerticalAlign)
    {
        BOOL fNeedsVAlign = FALSE;
        if (por->GetFF()->HasCSSVerticalAlign() || por->GetCF()->HasVerticalLayoutFlow())
        {
            fNeedsVAlign = (styleVerticalAlignBaseline != por->GetFF()->GetVerticalAlign(por->GetCF()->HasVerticalLayoutFlow()));
        }
        else
        {
            CTreeNode * pNodeParent = por->Branch()->Parent();
            while (pNodeParent)
            {
                const CCharFormat  * pCF = pNodeParent->GetCharFormat();
                const CFancyFormat * pFF = pNodeParent->GetFancyFormat();
                if (pFF->HasCSSVerticalAlign() || pCF->HasVerticalLayoutFlow())
                {
                    fNeedsVAlign = (styleVerticalAlignBaseline != pFF->GetVerticalAlign(pCF->HasVerticalLayoutFlow()));
                    break;
                }
                pNodeParent = pNodeParent->Parent();
            }
        }
        if (fNeedsVAlign)
            _lineFlags.AddLineFlag(por->Cp(), FLAG_HAS_NOBLAST | FLAG_HAS_VALIGN);
    }

Cleanup:
    return lserr;
}

//-----------------------------------------------------------------------------
//
//  Function:   NeedToEatThisSpace
//
//  Synopsis:   Decide if the current space needs to be eaten. We eat any space
//              after a abspos or aligned site *IF* that site was preceeded by
//              a space too.
//
//  Returns:    lserr.
//
//-----------------------------------------------------------------------------

BOOL
CLineServices::NeedToEatThisSpace(COneRun *porIn)
{
    BOOL fMightFold = FALSE;
    BOOL fFold      = FALSE;
    CElement   *pElementLayout;
    CTreeNode  *pNode;
    COneRun    *por;

    por = FindOneRun(porIn->_lscpBase);
    if (   por == NULL
        && porIn->_lscpBase >= _listCurrent._pTail->_lscpBase
       )
        por = _listCurrent._pTail;

    //
    // TODO: (SujalP, track bug 112335): We will not fold across hidden stuff... need to fix this...
    //
    while(por)
    {
        if (por->_fCharsForNestedLayout)
        {
            Assert(por->_fCharsForNestedElement);
            pNode = por->Branch();
            Assert(pNode->ShouldHaveLayout(LC_TO_FC(_pci->GetLayoutContext())));
            pElementLayout = pNode->GetUpdatedLayout( _pci->GetLayoutContext() )->ElementOwner();
            if (!pElementLayout->IsInlinedElement(LC_TO_FC(_pci->GetLayoutContext())))
                fMightFold = TRUE;
            else
                break;
        }
        else
            break;
        por = por->_pPrev;
    }

    if (fMightFold)
    {
        if (!por)
        {
            fFold = TRUE;
        }
        else if (!por->_fCharsForNestedElement)
        {
            Assert(por->_pchBase);
            TCHAR ch = por->_pchBase[por->_lscch-1];
            if (   ch == _T(' ')
                || ch == _T('\t')
               )
            {
                fFold = TRUE;
            }
        }
    }

    return fFold;
}

//-----------------------------------------------------------------------------
//
//  Function:   ChunkifyObjectRun
//
//  Synopsis:   Breakup a object run if necessary.
//
//  Returns:    lserr.
//
//-----------------------------------------------------------------------------

void
CLineServices::ChunkifyObjectRun(COneRun *por, COneRun **pporOut)
{
    CElement        *pElementLayout;
    CLayout         *pLayout;
    CTreeNode       *pNode;
    BOOL             fInlinedElement;
    BOOL             fIsAbsolute = FALSE;
    LONG             cp     = por->Cp();
    COneRun         *porOut = por;

    Assert(por->_lsCharProps.idObj == LSOBJID_EMBEDDED);
    pNode = por->Branch();
    Assert(pNode);
    pLayout = pNode->GetUpdatedLayout( _pci->GetLayoutContext() );
    Assert(pLayout);
    pElementLayout = pLayout->ElementOwner();
    Assert(pElementLayout);
    fInlinedElement = pElementLayout->IsInlinedElement(LC_TO_FC(_pci->GetLayoutContext()));

   _pMeasurer->_fHasNestedLayouts = TRUE;
   
    //
    // Setup all the various flags and counts
    //
    if (fInlinedElement)
    {
        _lineFlags.AddLineFlag(cp, FLAG_HAS_INLINEDSITES);
    }
    else
    {
        fIsAbsolute = pNode->IsAbsolute((stylePosition)por->GetFF()->_bPositionType);

        if (!fIsAbsolute)
        {
            _lineCounts.AddLineCount(cp, LC_ALIGNEDSITES, por->_lscch);
        }
        else
        {
            //
            // This is the only opportunity for us to measure abspos'd sites
            //
            if (_lsMode == LSMODE_MEASURER)
            {
                _lineCounts.AddLineCount(cp, LC_ABSOLUTESITES, por->_lscch);
                pLayout->SetXProposed(0);
                pLayout->SetYProposed(0);
            }
        }
    }
    _lineFlags.AddLineFlag(cp, FLAG_HAS_EMBED_OR_WBR);

    if (por->_fCharsForNestedRunOwner)
    {
        _lineFlags.AddLineFlag(cp, FLAG_HAS_NESTED_RO);
        _pMeasurer->_pRunOwner = pLayout;
    }

    if (IsOwnLineSite(por))
    {
        _fSingleSite = TRUE;

        // In edit mode, if we are showing editing glyphs for the ownline site
        // then the only thing on the line will not be the the layout, we will also
        // have the editing glyph on that line. Hence we say that its not a single
        // site line in that case. The other option would have been to give the
        // glyph a line of its own but thats not possible since where will I get
        // a character for it? Done to fix IE5.5 bug 101569.
        if (   _fIsEditable
            && por->_ptp->ShowTreePos()
           )
            _li._fSingleSite = FALSE;
        else
            _li._fSingleSite = TRUE;
        _li._fHasEOP = TRUE;
    }

    if (!fInlinedElement)
    {
        // Since we are not showing this run, lets just anti-synth it!
        por->MakeRunAntiSynthetic();

        // And remember that these chars are white at BOL
        if (IsFirstNonWhiteOnLine(cp))
        {
            AlignedAtBOL(cp, por->_lscch);
        }
    }

    // Do not blast lines with layout grid.
    if (por->GetCF()->HasLayoutGrid(por->_fInnerCF))
    {
        _lineFlags.AddLineFlag(por->Cp(), FLAG_HAS_NOBLAST);

        // Vertical align lines with line layout grid
        if (por->GetCF()->HasLineGrid(por->_fInnerCF))
            _lineFlags.AddLineFlag(por->Cp(), FLAG_HAS_VALIGN);
    }

    // Do not blast lines with non default vertical-align attribute.
    if (por->GetCF()->_fNeedsVerticalAlign)
    {
        BOOL fNeedsVAlign = FALSE;
        if (por->GetFF()->HasCSSVerticalAlign() || por->GetCF()->HasVerticalLayoutFlow())
        {
            fNeedsVAlign = (styleVerticalAlignBaseline != por->GetFF()->GetVerticalAlign(por->GetCF()->HasVerticalLayoutFlow()));
        }
        else
        {
            CTreeNode * pNodeParent = por->Branch()->Parent();
            while (pNodeParent)
            {
                const CCharFormat  * pCF = pNodeParent->GetCharFormat();
                const CFancyFormat * pFF = pNodeParent->GetFancyFormat();
                if (pFF->HasCSSVerticalAlign() || pCF->HasVerticalLayoutFlow())
                {
                    fNeedsVAlign = (styleVerticalAlignBaseline != pFF->GetVerticalAlign(pCF->HasVerticalLayoutFlow()));
                    break;
                }
                pNodeParent = pNodeParent->Parent();
            }
        }
        if (fNeedsVAlign)
            _lineFlags.AddLineFlag(por->Cp(), FLAG_HAS_NOBLAST | FLAG_HAS_VALIGN);
    }

    SetRenderingHighlights(por);

    *pporOut = porOut;
}

//+==============================================================================
//
//  Method: GetRenderingHighlights
//
//  Synopsis: Get the type of highlights between these two cp's by going through
//            the array of CRenderStyle
//
//  A 'CRenderStyle' denotes a "non-content-based" way of changing the rendering
// of something. 
//
//-------------------------------------------------------------------------------

HRESULT
CLineServices::GetRenderingHighlights( 
                    int cpLineMin, 
                    int cpLineMax, 
                    CPtrAry<CRenderStyle*> *papHighlight )
{
    int i;
    HighlightSegment* pHighlight;
    CLSRenderer *pRenderer = GetRenderer();

    if( !papHighlight )
        RRETURN(E_INVALIDARG);
    Assert( pRenderer && pRenderer->HasSelection() );

    Assert( papHighlight->Size() == 0 );
    
    for (i = pRenderer->_aryHighlight.Size(), pHighlight = pRenderer->_aryHighlight;
        i > 0 ;
        i --, pHighlight++)
    {
        if ( (  pHighlight->_cpStart <= cpLineMin ) && ( pHighlight->_cpEnd >= cpLineMax) )
        {
            if( papHighlight->Size() > 0 ) 
            {
                for( int j = 0; j < papHighlight->Size(); j++ )
                {                    
                    if( ((*papHighlight)[j])->GetAArenderingPriority() < 
                        pHighlight->_pRenderStyle->GetAArenderingPriority() )
                    {
                        papHighlight->Insert(j, pHighlight->_pRenderStyle);
                        break;
                    }
                }
                if( j == papHighlight->Size() )
                {
                    papHighlight->Append( pHighlight->_pRenderStyle );
                }
            }
            else
            {
                papHighlight->Append( pHighlight->_pRenderStyle );
            }
        }
    }

    RRETURN( S_OK );
}

//+====================================================================================
//
// Method: SetRenderingHighlightsCore
//
// Synopsis: Set any 'markup' on this COneRun
//
// NOTE:   marka - currently the only type of Markup is Selection. We see if the given
//         run is selected, and if so we mark-it.
//
//         This used to be called ChunkfiyForSelection. However, under due to the new selection
//         model's use of TreePos's the Run is automagically chunkified for us
//
//------------------------------------------------------------------------------------
void
CLineServices::SetRenderingHighlightsCore(COneRun  *por)
{
    CLSRenderer * pRenderer = GetRenderer();
    Assert(pRenderer && pRenderer->HasSelection());

    CPtrAry<CRenderStyle *> apRenderStyle(Mt(CLineServices_SetRenHighlightScore_apRender_pv));
    int cpMin = por->Cp();
    int cpMax = min(long(pRenderer->_cpSelMax), por->Cp() + por->_lscch);
    if (cpMin < cpMax)
    {
        // If we are not rendering we should do nothing
        Assert(_lsMode == LSMODE_RENDERER);

        // We will not show selection if it is hidden.
        Assert(!por->_fHidden);
        
        GetRenderingHighlights( cpMin, cpMax, &apRenderStyle );

        if ( apRenderStyle.Size() )
        {
            por->Selected(pRenderer, _pFlowLayout, &apRenderStyle);
        }
    }
}

//-----------------------------------------------------------------------------
//
//  Function:   TransformTextRun
//
//  Synopsis:   Do any necessary text transformations.
//
//  Returns:    lserr.
//
//-----------------------------------------------------------------------------

LSERR
CLineServices::TransformTextRun(COneRun *por)
{
    LSERR lserr = lserrNone;
    const CCharFormat* pCF = por->GetCF();
    TCHAR chPrev = WCH_NULL;

    Assert(pCF->IsTextTransformNeeded());

    _lineFlags.AddLineFlag(por->Cp(), FLAG_HAS_NOBLAST);

    if (pCF->_bTextTransform == styleTextTransformCapitalize)
    {
        COneRun *porTemp = FindOneRun(por->_lscpBase - 1);

        // If no run found on this line before this run, then its the first
        // character on this line, and hence needs to be captilaized. This is
        // done implicitly by initializing chPrev to WCH_NULL.
        while (porTemp)
        {
            // If it is anti-synth, then its not shown at all or
            // is not in the flow, hence we ignore it for the purposes
            // of transformations. If it is synthetic then we will need
            // to look at runs before the synthetic to determine the
            // prev character. Hence, we only need to investigate normal runs
            if (porTemp->IsNormalRun())
            {
                // If the previous run had a nested layout, then we will ignore it.
                // The rule says that if there is a layout in the middle of a word
                // then the character after the layout is *NOT* capitalized. If the
                // layout is at the beginning of the word then the character needs
                // to be capitalized. In essence, we completely ignore layouts when
                // deciding whether a char should be capitalized, i.e. if we had
                // the combination:
                // <charX><layout><charY>, then capitalization of <charY> depends
                // only on what <charX> -- ignoring the fact that there is a layout
                // (It does not matter if the layout is hidden, aligned, abspos'd
                // or relatively positioned).
                if (   !porTemp->_fCharsForNestedLayout
                    && porTemp->_synthType == SYNTHTYPE_NONE
                   )
                {
                    Assert(porTemp->_ptp->IsText());
                    chPrev = porTemp->_pchBase[porTemp->_lscch - 1];
                    break;
                }
            }
            porTemp = porTemp->_pPrev;
        }
    }

    if (pCF->_fSmallCaps)
    {
        por->ConvertToSmallCaps(chPrev);
        pCF = por->GetCF(); // _pCF can be cloned inside ConvertToSmallCaps()
    }

    por->_pchBase = (TCHAR *)TransformText(por->_cstrRunChars, por->_pchBase, por->_lscch,
                                           pCF->_bTextTransform, chPrev);
    if (por->_pchBase == NULL)
        lserr = lserrOutOfMemory;

    return lserr;
}

//-----------------------------------------------------------------------------
//
//  Function:   CheckForPassword
//
//  Synopsis:   If text transformation is necessary for the run, then do it here.
//
//  Returns:    lserr.
//
//-----------------------------------------------------------------------------

LSERR
CLineServices::CheckForPassword(COneRun  *por)
{
    static TCHAR zwnbsp = WCH_ZWNBSP;

    LSERR lserr = lserrNone;
    CStr strPassword;
    TCHAR * pchPassword;
    HRESULT hr;
    
    Assert(_chPassword);

    for (LONG i = 0; i < por->_lscch; i++)
    {
        pchPassword = (   (IsZeroWidthChar(por->_pchBase[i]) && !IsCombiningMark(por->_pchBase[i])) 
                       || IsLowSurrogateChar(por->_pchBase[i]))
                      ? &zwnbsp : &_chPassword;
        hr = strPassword.Append(pchPassword, 1);
        if (hr != S_OK)
        {
            lserr = lserrOutOfMemory;
            goto Cleanup;
        }
    }
    por->_pchBase = por->SetString(strPassword);
    if (por->_pchBase == NULL)
        lserr = lserrOutOfMemory;
    
Cleanup:
    return lserr;
}

//-----------------------------------------------------------------------------
//
//  Function:   AdjustForNavBRBug (member)
//
//  Synopsis:   Navigator will break between a space and a BR character at
//              the end of a line if the BR character, when it's width is
//              treated like that of a space character, will cause line to
//              overflow. Necessary for compat.
//
//  Returns:    LSERR
//
//-----------------------------------------------------------------------------

LSERR
CLineServices::AdjustCpLimForNavBRBug(
    LONG xWrapWidth,        // IN
    LSLINFO *plslinfo )     // IN/OUT
{
    LSERR lserr = lserrNone;

    // Do not support this NAV bug in vertical layout.
    if (_pFlowLayout->ElementOwner()->HasVerticalLayoutFlow())
        goto Cleanup;
        
    // check 1: (a) We must not be in a PRE and (b) the line
    // must have at least three chars.
    if (   !_pPFFirst->HasPre(_fInnerPFFirst)
        && _cpLim - plslinfo->cpFirstVis >= 3)
    {
        COneRun *por = FindOneRun(_lscpLim - 1);
        if (!por)
            goto Cleanup;

        // check 2: Line must have ended in a BR
        if (   por->_ptp->IsEndNode()
            && por->Branch()->Tag() == ETAG_BR
           )
        {
            // check 3: The BR char must be preceeded by a space char.

            // Go to the begin BR
            por = por->_pPrev;
            if (!(   por
                  && por->IsAntiSyntheticRun()
                  && por->_ptp->IsBeginNode()
                  && por->Branch()->Tag() == ETAG_BR)
               )
                goto Cleanup;

            // Now go one more beyond that to check for the space
            do
            {
                por = por->_pPrev;
            }
            while (por && por->IsAntiSyntheticRun() && !por->_fCharsForNestedLayout);
            if (!por)
                goto Cleanup;

            // NOTE (SujalP + CThrash): This will not work if the space was
            // in, say, a reverse object. But then this *is* a NAV bug. If
            // somebody complains vehemently, then we will fix it...
            if (   por->IsNormalRun()
                && por->_ptp->IsText()
                && WCH_SPACE == por->_pchBase[por->_lscch - 1]
               )
            {
                if (_fMinMaxPass)
                    ((CDisplay *)_pMeasurer->_pdp)->SetNavHackPossible();

                // check 4: must have overflowed, because the width of a BR
                // character is included in _xWidth
                if (!_fMinMaxPass && _li._xWidth > xWrapWidth)
                {
                    // check 5:  The BR alone cannot be overflowing.  We must
                    // have at least one pixel more to break before the BR.

                    HRESULT hr;
                    LSTEXTCELL lsTextCell;

                    hr = THR( QueryLineCpPpoint( _lscpLim, FALSE, NULL, &lsTextCell ) );

                    if (   S_OK == hr
                        && (_li._xWidth - lsTextCell.dupCell) > xWrapWidth)
                    {
                        // Break between the space and the BR.  Yuck! Also 2
                        // here because one for open BR and one for close BR
                        _cpLim -= 2;

                        // The char for open BR was antisynth'd in the lscp
                        // space, so just reduce by one char for the close BR.
                        _lscpLim--;
                    }
                }
            }
        }
    }

Cleanup:
    return lserr;
}

//-----------------------------------------------------------------------------
//
//  Function:   AdjustForRelElementAtEnd (member)
//
//  Synopsis: In our quest to put as much on the line as possible we will end up
//      putting the begin splay for a relatively positioned element on this
//      line(the first character in this element will be on the next line)
//      This is not really acceptable for positioning purposes and hence
//      we detect that this happened and chop off the relative element
//      begin splay (and any chars anti-synth'd after it) so that they will
//      go to the next line. (Look at bug 54162).
//
//  Returns:    Nothing
//
//-----------------------------------------------------------------------------
VOID
CLineServices::AdjustForRelElementAtEnd()
{
    //
    // By looking for _lscpLim - 1, we find the last but-one-run. After
    // this run, there will possibly be antisynthetic runs (all at the same
    // lscp -- but different cp's -- as the last char of this run) which
    // have ended up on this line. It is these set of antisynthetic runs
    // that we have to investigate to find any ones which begin a relatively
    // positioned element. If we do find one, we will stop and modify cpLim
    // so as to not include the begin splay and any antisynth's after it.
    //
    COneRun *por = FindOneRun(_lscpLim - 1);

    Assert(por);

    //
    // Go to the start of the antisynth chunk (if any).
    //
    por = por->_pNext;

    //
    // Walk while we have antisynth runs
    //
    while (   por
           && por->IsAntiSyntheticRun()
           && _lscpLim == por->_lscpBase
          )
    {
        //
        // If it begins a relatively positioned element, then we want to
        // stop and modify the cpLim
        //
        if (   por->_ptp->IsBeginElementScope()
            && por->GetCF()->IsRelative(por->_fInnerCF))
        {
            _cpLim = por->Cp();
            break;
        }
        Assert(por->_lscch == 1);
        por = por->_pNext;
    }
}

//-----------------------------------------------------------------------------
//
//  Function:   ComputeWhiteInfo (member)
//
//  Synopsis:   A post pass for the CMeasurer to compute whitespace
//              information (_cchWhite and _xWhite) on the associated
//              CLineFull object (_li).
//
//  Returns:    LSERR
//
//-----------------------------------------------------------------------------

HRESULT
CLineServices::ComputeWhiteInfo(LSLINFO *plslinfo, LONG *pxMinLineWidth, DWORD dwlf,
                                LONG durWithTrailing, LONG durWithoutTrailing)
{
    HRESULT hr = S_OK;
    BOOL  fInclEOLWhite = _pPFFirst->HasInclEOLWhite(_fInnerPFFirst);
    CMarginInfo *pMarginInfo = (CMarginInfo*)_pMarginInfo;

    // Note that cpLim is no longer an LSCP.  It's been converted by the
    // caller.

    const LONG cpLim = _cpLim;
    CTxtPtr txtptr( _pMarkup, cpLim );
    const TCHAR chBreak = txtptr.GetPrevChar();

    LONG  lscpLim = _lscpLim - 1;
    COneRun *porLast = FindOneRun(lscpLim);

    WHEN_DBG(LONG cchWhiteTest=0);


    Assert( _cpLim == _cpStart + _li._cch );

    //
    // Compute all the flags for the line
    //
    Assert(dwlf == _lineFlags.GetLineFlags(cpLim));
    if (dwlf)
    {
        _li._fHasEmbedOrWbr       = (dwlf & FLAG_HAS_EMBED_OR_WBR) ? TRUE : FALSE;
        _li._fHasNestedRunOwner   = (dwlf & FLAG_HAS_NESTED_RO)    ? TRUE : FALSE;
        _li._fHasBackground       = (dwlf & FLAG_HAS_BACKGROUND)   ? TRUE : FALSE;
        _li._fHasNBSPs            = (dwlf & FLAG_HAS_NBSP)         ? TRUE : FALSE;
        _fHasRelative             = (dwlf & FLAG_HAS_RELATIVE)     ? TRUE : FALSE;
        _fFoundLineHeight         = (dwlf & FLAG_HAS_LINEHEIGHT)   ? TRUE : FALSE;
        pMarginInfo->_fClearLeft |= (dwlf & FLAG_HAS_CLEARLEFT)    ? TRUE : FALSE;
        pMarginInfo->_fClearRight|= (dwlf & FLAG_HAS_CLEARRIGHT)   ? TRUE : FALSE;
        _fHasMBP                  = (dwlf & FLAG_HAS_MBP)          ? TRUE : FALSE;
        _fHasVerticalAlign        = (dwlf & FLAG_HAS_VALIGN)       ? TRUE : FALSE;
        _li._fHasBreak            = (dwlf & FLAG_HAS_A_BR)         ? TRUE : FALSE;
        _fHasInlinedSites         = (dwlf & FLAG_HAS_INLINEDSITES) ? TRUE : FALSE;
        _li._fHasInlineBgOrBorder = (dwlf & FLAG_HAS_INLINE_BG_OR_BORDER) ? TRUE : FALSE;
        _fLineWithHeight         |= (dwlf & FLAG_HAS_NODUMMYLINE)  ? TRUE : FALSE;
   }
    else
    {
        _li._fHasEmbedOrWbr       = FALSE;
        _li._fHasNestedRunOwner   = FALSE;
        _li._fHasBackground       = FALSE;
        _li._fHasNBSPs            = FALSE;
        _fHasRelative             = FALSE;
        _fFoundLineHeight         = FALSE;
      //pMarginInfo->_fClearLeft |= FALSE;
      //pMarginInfo->_fClearRight|= FALSE;
        _fHasMBP                  = FALSE;
        _fHasVerticalAlign        = FALSE;
        _li._fHasBreak            = FALSE;
        _fHasInlinedSites         = FALSE;
        _li._fHasInlineBgOrBorder = FALSE;
      //_fLineWithHeight         |= FALSE;
    }
    
    // Lines containing \r's also need to be marked _fHasBreak
    if (   !_li._fHasBreak
        && _fExpectCRLF
        && plslinfo->endr == endrEndPara
       )
    {
        _li._fHasBreak = TRUE;
    }
    
    _pFlowLayout->_fContainsRelative |= _fHasRelative;

    // If all we have is whitespaces till here then mark it as a dummy line
    if (IsDummyLine(cpLim))
    {
        const LONG cchHidden = _lineCounts.GetLineCount(cpLim, LC_HIDDEN);
        const LONG cch = (_cpLim - _cpStart) - cchHidden;

        _li._fDummyLine = TRUE;
        _li._fForceNewLine = FALSE;

        // If this line was a dummy line because all it contained was hidden
        // characters, then we need to mark the entire line as hidden.  Also
        // if the paragraph contains nothing (except a blockbreak), we also
        // need the hide the line.  Note that LI's are an exception to this
        // rule -- even if all we have on the line is a blockbreak, we don't
        // want to hide it if it's an LI. (LI's are excluded in the dummy
        // line check).
        if ( cchHidden
             && (   cch == 0
                 || _li._fFirstInPara
                )
           )
        {
            _li._fHidden = TRUE;
            _li._yBeforeSpace = 0;
        }
    }

    //
    // Also find out all the relevant counts
    //
    _cAbsoluteSites = _lineCounts.GetLineCount(cpLim, LC_ABSOLUTESITES);
    _cAlignedSites  = _lineCounts.GetLineCount(cpLim, LC_ALIGNEDSITES);
    _li._fHasAbsoluteElt = !!_cAbsoluteSites;
    _li._fHasAligned     = !!_cAlignedSites;

    //
    // And the relevant values
    //
    if (_fFoundLineHeight)
    {
        _lMaxLineHeight = max(plslinfo->dvpMultiLineHeight,
                              _lineCounts.GetMaxLineValue(cpLim, LC_LINEHEIGHT));
    }
    
    //
    // Consume trailing WCH_NOSCOPE/WCH_BLOCKBREAK characters.
    //

    _li._cchWhite = 0;
    _li._xWhite = 0;

    if (   porLast
        && porLast->_ptp->IsNode()
        && porLast->Branch()->Tag() != ETAG_BR
       )
    {
        // NOTE (cthrash) We're potentially tacking on characters but are
        // not included their widths.  These character can/will have widths in
        // edit mode.  The problem is, LS never measured them, so we'd have
        // to measure them separately.

        CTxtPtr txtptrT( txtptr );
        long dcch;

        // If we have a site that lives on it's own line, we may have stopped
        // fetching characters prematurely.  Specifically, we may have left
        // some space characters behind.

        while (TEXT(' ') == txtptrT.GetChar())
        {
            if (!txtptrT.AdvanceCp(1))
                break;
        }
        dcch = txtptrT.GetCp() - txtptr.GetCp();

        _li._cchWhite += (SHORT)dcch;
        _li._cch += dcch;
    }

    WHEN_DBG(cchWhiteTest = _li._cchWhite);

    //
    // Compute _cchWhite and _xWhite of line
    //
    if (!fInclEOLWhite)
    {
        BOOL  fDone = FALSE;
        TCHAR ch;
        COneRun *por = porLast;
        LONG index = por ? lscpLim - por->_lscpBase : 0;
        WHEN_DBG (CTxtPtr txtptrTest(txtptr));

        while (por && !fDone)
        {
            if (por->_fCharsForNestedLayout)
            {
                fDone = TRUE;
                break;
            }

            if (por->IsNormalRun())
            {
                for(LONG i = index; i >= 0; i--)
                {
                    ch = por->_pchBase[i];
                    if (   IsWhite(ch)
                        // If its a no scope char and we are not showing it then
                        // we treat it like a whitespace.
                       )
                    {
                        _li._cchWhite++;
                        txtptr.AdvanceCp(-1);
                    }
                    else
                    {
                        fDone = TRUE;
                        break;
                    }
                }
            }
            por = por->_pPrev;
            index = por ? por->_lscch - 1 : 0;
        }

#if DBG==1            
        {
            long durWithTrailingDbg, durWithoutTrailingDbg;
            LSERR lserr = GetLineWidth( &durWithTrailingDbg,
                                        &durWithoutTrailingDbg );
            Assert(lserr || durWithTrailingDbg == durWithTrailing);
            Assert(lserr || durWithoutTrailingDbg == durWithoutTrailing);
        }
#endif

        _li._xWhite  = durWithTrailing - durWithoutTrailing;
        _li._xWidth -= _li._xWhite;
        
        if ( porLast && chBreak == WCH_NODE && !_fScanForCR )
        {
            CTreePos *ptp = porLast->_ptp;

            if (   ptp->IsEndElementScope()
                && ptp->Branch()->Tag() == ETAG_BR
               )
            {
                LONG cp = CPFromLSCP( plslinfo->cpFirstVis );
                _li._fEatMargin = LONG(txtptr.GetCp()) == cp + 1;
            }
        }
    }
    else if (_fScanForCR)
    {
        HRESULT hr;
        LSTEXTCELL  lsTextCell;
        CTxtPtr tp(_pMarkup, cpLim);
        TCHAR ch = tp.GetChar();
        TCHAR chPrev = tp.GetPrevChar();
        BOOL fDecWidth = FALSE;
        LONG cpJunk;
        
        if (   chPrev == _T('\n')
            || chPrev == _T('\r')
           )
        {
            fDecWidth = TRUE;
        }
        else if (ch == WCH_NODE)
        {
            CTreePos *ptpLast = _pMarkup->TreePosAtCp(cpLim - 1, &cpJunk);

            if (   ptpLast->IsEndNode()
                && (   ptpLast->Branch()->Tag() == ETAG_BR
                    || IsPreLikeNode(ptpLast->Branch())
                   )
               )
            {
                fDecWidth = TRUE;
            }
        }

        if (fDecWidth)
        {
            // The width returned by LS includes the \n, which we don't want
            // included in CLine::_xWidth.
            hr = THR( QueryLineCpPpoint( _lscpLim - 1, FALSE, NULL, &lsTextCell ) );
            if (!hr)
            {
                _li._xWidth -= lsTextCell.dupCell; // note _xWhite is unchanged
                if (pxMinLineWidth)
                    *pxMinLineWidth -= lsTextCell.dupCell;
            }
        }
    }
    else
    {
        _li._cchWhite = plslinfo->cpFirstVis - _cpStart;
    }

    //
    // If the white at the end of the line meets the white at the beginning
    // of a line, then we need to shift the BOL white to the EOL white.
    //

    if (_cWhiteAtBOL + _li._cchWhite >= _li._cch)
    {
        _li._cchWhite = _li._cch;
    }

    //
    // Find out if the last char on the line has any overhang, and if so set it on
    // the line.
    //
    if (_fHasOverhang)
    {
        CTreeNode *pNode = _pFlowLayout->GetFirstBranch();
        const CFancyFormat * pFF = pNode->GetFancyFormat(LC_TO_FC(LayoutContext()));
        const CCharFormat  * pCF = pNode->GetCharFormat(LC_TO_FC(LayoutContext()));
        BOOL fVerticalLayoutFlow = pCF->HasVerticalLayoutFlow();
        BOOL fWritingModeUsed = pCF->_fWritingModeUsed;
        styleOverflow so = pFF->GetLogicalOverflowX(fVerticalLayoutFlow, fWritingModeUsed);

        if (   so == styleOverflowHidden
            || so == styleOverflowNotSet
           )
        {
            COneRun *por = porLast;

            while (por)
            {
                if (por->_ptp->IsText())
                {
                    _li._xLineOverhang = por->_xOverhang;
                    if (pxMinLineWidth)
                        *pxMinLineWidth += por->_xOverhang;
                    break;
                }
                else if(por->_fCharsForNestedLayout)
                    break;
                // Continue for synth and antisynth runs
                por = por->_pPrev;
            }
        }
    }
    
    // Fold the S_FALSE case in -- don't propagate.
    hr = SUCCEEDED(hr) ? S_OK : hr;
    if (hr)
        goto Cleanup;

    DecideIfLineCanBeBlastedToScreen(_cpStart + _li._cch - _li._cchWhite, dwlf);

Cleanup:
    RRETURN(hr);
}

//-----------------------------------------------------------------------------
//
//  Function:   DecideIfLineCanBeBlastedToScreen
//
//  Synopsis:   Decides if it is possible for a line to be blasted to screen
//              in a single shot.
//
//  Params:     The last cp in the line
//
//  Returns:    Nothing
//
//-----------------------------------------------------------------------------
void
CLineServices::DecideIfLineCanBeBlastedToScreen(LONG cpEndLine, DWORD dwlf)
{
    // By default you cannot blast a line to the screen
    _li._fCanBlastToScreen = FALSE;

#if DBG==1
    if (IsTagEnabled(tagLSNoBlast))
        goto Cleanup;
#endif

    //
    // 0) If we have eaten a space char or have fontlinking, we cannot blast
    //    line to screen
    //
    if (dwlf & FLAG_HAS_NOBLAST)
        goto Cleanup;

    //
    // 1) No justification
    //
    if (_pPFFirst->GetBlockAlign(_fInnerPFFirst) == htmlBlockAlignJustify)
        goto Cleanup;

    //
    // 2) Only simple LTR
    //
    if (_pBidiLine != NULL || _li.IsRTLLine() || _pFlowLayout->IsRTLFlowLayout())
        goto Cleanup;

    //
    // 3) Cannot handle passwords for blasting.
    //
    if (_chPassword)
        goto Cleanup;

    //
    // 4) If there is a glyph on the line then do not blast.
    //
    if (_fGlyphOnLine)
        goto Cleanup;

    //
    // 5) There's IME highlighting, so we can't blast,
    //    or funny callback for getruncharwidths
    //
    if (_fSpecialNoBlast)
        goto Cleanup;

    //
    // None of the restrictions apply, lets blast this to the screen!
    //
    _li._fCanBlastToScreen = TRUE;

Cleanup:
    return;
}

LONG
CLineServices::RememberLineHeight(LONG cp, const CCharFormat *pCF, const CBaseCcs *pBaseCcs)
{
    long lAdjLineHeight;
    
    AssertSz(pCF->_cuvLineHeight.GetUnitType() != CUnitValue::UNIT_PERCENT,
             "Percent units should have been converted to points in ApplyInnerOuterFormats!");
    
    // If there's no height set, get out quick.
    if (pCF->_cuvLineHeight.IsNull())
    {
        lAdjLineHeight = pBaseCcs->_yHeight;
    }

    // Apply the CSS Attribute LINE_HEIGHT
    else
    {
        const CUnitValue *pcuvUseThis = &pCF->_cuvLineHeight;
        long lFontHeight = 1;
        
        if (pcuvUseThis->GetUnitType() == CUnitValue::UNIT_FLOAT)
        {
            CUnitValue cuv;
            cuv = pCF->_cuvLineHeight;
            cuv.ScaleTo ( CUnitValue::UNIT_EM );
            pcuvUseThis = &cuv;
            lFontHeight = pCF->GetHeightInTwips( _pFlowLayout->Doc() );
        }

        lAdjLineHeight = pcuvUseThis->YGetPixelValue(_pci, 0, lFontHeight );
        NoteLineHeight(cp, lAdjLineHeight);
    }

    if (pCF->HasLineGrid(TRUE))
    {
        _lineFlags.AddLineFlag(cp, FLAG_HAS_NOBLAST);
        lAdjLineHeight = GetClosestGridMultiple(GetLineGridSize(), lAdjLineHeight);
        NoteLineHeight(cp, lAdjLineHeight);
    }

    return lAdjLineHeight;
}

//-------------------------------------------------------------------------
//
//  Member:     VerticalAlignObjectsFast
//
//  Synopsis:   Process all vertically aligned objects and adjust the line
//              height.
//              Fast version - not used in case of CSS:vertical-align.
//
//-------------------------------------------------------------------------
#pragma warning(disable:4189) // local variable initialized but not used 
#pragma warning(disable:4701)
void
CLineServices::VerticalAlignObjectsFast(CLSMeasurer& lsme, long xLineShift)
{
    const LONG  cchPreChars = lsme._fMeasureFromTheStart ? 0 : lsme._cchPreChars;
    CTreePos  * ptpStart;
    LONG        cch;
    LONG        cchAdvanceStart;
    LONG        cchAdvance;
    LONG        cchNewAdvance;
    BOOL        fDisplayNone = FALSE;
    BOOL        fFastProcessing;
    COneRun   * porHead;
    COneRun   * por;
    VAOFINFO    vaoi;
        
    // Initialize the constants in the VAOINFO structure
    vaoi._pElementFL  = _pFlowLayout->ElementOwner();
    vaoi._pFL         = _pFlowLayout;
    vaoi._xLineShift  = xLineShift;
    
    // Now initialize the loop specific vars
    vaoi._fMeasuring   = TRUE;
    vaoi._fPositioning = FALSE;
    vaoi._yTxtAscent   = _li._yHeight - _li._yDescent;
    vaoi._yTxtDescent  = _li._yDescent;
    vaoi._yDescent     = _li._yDescent;
    vaoi._yAscent      = vaoi._yTxtAscent;
    vaoi._yAbsHeight   = 0;
    vaoi._atAbs        = htmlControlAlignNotSet;
    vaoi._xWidthSoFar  = 0;
    vaoi._yMaxHeight   = LONG_MIN;
    
    // Setup so that we can use the one run list as soon as we are
    // done with the prechars.
    por = _listCurrent._pHead;
    while (   por
           && por->IsSyntheticRun()
          )
        por = por->_pNext;
    porHead = por;

    // Based on the prechars and blast status decide if we can do fast processing or not
    // and setup the vars appropriately
    if (cchPreChars == 0 && _li._fCanBlastToScreen)
    {
        ptpStart = porHead->_ptp;
        cchAdvanceStart = porHead->_lscch;
    }
    else
    {
        LONG ich;
        ptpStart = _pMarkup->TreePosAtCp(lsme.GetCp() - _li._cch - cchPreChars, &ich, TRUE);
        Assert(ptpStart);
        cchAdvanceStart = min(long(_li._cch + cchPreChars), ptpStart->GetCch() - ich);
    }

    // first pass we measure the line's baseline and height
    // second pass we set the rcProposed of the site relative to the line.
    while (vaoi._fMeasuring || vaoi._fPositioning)
    {
        por = porHead;
        fFastProcessing = cchPreChars == 0 && _li._fCanBlastToScreen;
        
        cch = _li._cch + cchPreChars;
        vaoi._ptp = ptpStart;
        lsme.Advance(-cch, vaoi._ptp);
        cchAdvance = cchAdvanceStart;
        vaoi._pCF = NULL;

        while(cch)
        {
            vaoi._cp = lsme.GetCp();
            if (fFastProcessing)
            {
                Assert(vaoi._ptp == por->_ptp);
                if (por->_fCharsForNestedLayout)
                {
                    vaoi._pNode = vaoi._ptp->Branch();
                    vaoi._pLayout = vaoi._pNode->GetUpdatedLayout( _pci->GetLayoutContext() );
                    vaoi._lscp = por->_lscpBase;
                    vaoi._por = por;
                    Assert(vaoi._pLayout);
                }
                else
                {
                    vaoi._pNode = por->Branch();
                    vaoi._pLayout = NULL;
                }
            }
            else
            {
                if(vaoi._ptp && vaoi._ptp->IsBeginElementScope())
                {
                    vaoi._pNode = vaoi._ptp->Branch();
                    vaoi._pLayout = (   vaoi._pElementFL != vaoi._pNode->Element()
                                     && vaoi._pNode->ShouldHaveLayout(LC_TO_FC(_pci->GetLayoutContext()))
                                    ) 
                                    ? vaoi._pNode->GetUpdatedLayout( _pci->GetLayoutContext() )
                                    : NULL;
                    vaoi._lscp = -1;
                    vaoi._por = NULL;
                }
                else if(vaoi._ptp)
                {
                    vaoi._pNode = vaoi._ptp->GetBranch();
                    vaoi._pLayout = NULL;
                }
		else
		{
                    vaoi._pNode = NULL;
		    vaoi._pLayout = NULL;
		    break;
		}
            }
            
            vaoi._pElementLayout = vaoi._pLayout ? vaoi._pNode->Element() : NULL;
            vaoi._pCF = vaoi._pNode->GetCharFormat( LC_TO_FC(_pci->GetLayoutContext()));
            fDisplayNone = vaoi._pCF->IsDisplayNone();

            // If we are transisitioning from a normal chunk to relative or
            // relative to normal chunk, add a new chunk to the line. Relative
            // elements can end in the prechar's so look for transition in
            // prechar's too.
            if(vaoi._fMeasuring && _fHasRelative && !fDisplayNone
                && (    vaoi._ptp->IsBeginElementScope()
                    ||  vaoi._ptp->IsText()
                    ||  (   vaoi._ptp->IsEndElementScope()
                            &&  cch > (_li._cch - (lsme._fMeasureFromTheStart ? lsme._cchPreChars : 0)))
                   )
              )
            {
                TestForTransitionToOrFromRelativeChunk(
                    lsme.GetCp(),
                    vaoi._pCF->IsRelative(SameScope(vaoi._pNode, vaoi._pElementFL)),
                    FALSE /*fForceChunk*/,
                    lsme.CurrBranch(),
                    vaoi._pElementLayout);
            }

            // If the current branch is a site and not the current CTxtSite
            if (vaoi._pLayout)
            {
                if (!fDisplayNone )
                {
                    VerticalAlignOneObjectFast(lsme, &vaoi);
                }

                Assert(vaoi._pElementLayout);
                
                //  setup cchAdvance to skip the current layout
                cchAdvance = lsme.GetNestedElementCch(vaoi._pElementLayout, &vaoi._ptp);
                Assert(vaoi._ptp);
            }
            else if (vaoi._pCF->HasLineGrid(FALSE))
            {
                vaoi._yMaxHeight = max(vaoi._yMaxHeight, GetClosestGridMultiple(GetLineGridSize(), _li._yHeight));
            }

            cch -= cchAdvance;
            if (cch != 0)
            {
                if (fFastProcessing)
                {
                    vaoi._xWidthSoFar += por->_xWidth;
                    do
                    {
                        por = por->_pNext;
                    } while (por && por->IsSyntheticRun());
                    if (por)
                    {
                        vaoi._ptp = por->_ptp;
                        cchNewAdvance = por->_lscch;
                    }
                    else
                    {
                        fFastProcessing = FALSE;
                        vaoi._ptp = vaoi._ptp->NextTreePos();
                        cchNewAdvance = vaoi._ptp->GetCch();
                    }
                }
                else
                {
                    if (   _li._fCanBlastToScreen
                        && por
                        && lsme.GetCp() + cchAdvance == por->Cp())
                    {
                        fFastProcessing = TRUE;
                        vaoi._ptp = por->_ptp;
                        cchNewAdvance = por->_lscch;
                    }
                    else
                    {
			if(vaoi._ptp)
                            vaoi._ptp = vaoi._ptp->NextTreePos();
			if(vaoi._ptp)
	                    cchNewAdvance = vaoi._ptp->GetCch();
			else
                        {
                            cchNewAdvance = 0;
                            cchAdvance = 0;
                            break;
                        }
                    }
                }
            }
            else
            {
                cchNewAdvance = 0;
                vaoi._ptp = NULL;
            }
            lsme.Advance(cchAdvance, vaoi._ptp);
            vaoi._ptp = lsme.GetPtp();
            cchAdvance = min(cch, cchNewAdvance);
        }

        // Add the final chunk to line with relative if there is text left
        if (vaoi._fMeasuring && _fHasRelative && !fDisplayNone && 
            lsme.GetLastCp() > _cpLastChunk)
        {
            TestForTransitionToOrFromRelativeChunk(
                lsme.GetLastCp(),
                vaoi._pCF ? vaoi._pCF->IsRelative(SameScope(vaoi._pNode, vaoi._pElementFL))
                          : TRUE,  // _pCF is NULL if we failed to enter the loop
                TRUE /*fForceChunk*/,
                lsme.CurrBranch(),
                vaoi._pCF ? vaoi._pElementLayout : NULL);
        }

        // We have just finished measuring, update the line's ascent and descent.
        if(vaoi._fMeasuring)
        {
            // If we have ALIGN_TYPEABSBOTTOM or ALIGN_TYPETOP, they do not contribute
            // to ascent or descent based on the baseline
            if(vaoi._yAbsHeight > vaoi._yAscent + vaoi._yDescent)
            {
                if (vaoi._yAscent == 0 && vaoi._yDescent == 0)
                {
                    // Always add to ascent if there is not content but
                    // abs-aligned object
                    vaoi._yAscent = vaoi._yAbsHeight;
                }
                else if(vaoi._atAbs == htmlControlAlignAbsMiddle)
                {
                    LONG yDiff = vaoi._yAbsHeight - vaoi._yAscent - vaoi._yDescent;
                    vaoi._yAscent += (yDiff + 1) / 2;
                    vaoi._yDescent += yDiff / 2;
                }
                else if(vaoi._atAbs == htmlControlAlignAbsBottom)
                {
                    vaoi._yAscent = vaoi._yAbsHeight - vaoi._yDescent;
                }
                else
                {
                    vaoi._yDescent = vaoi._yAbsHeight - vaoi._yAscent;
                }
            }

            // now update the line height
            _li._yHeight = vaoi._yAscent + vaoi._yDescent;
            _li._yDescent = vaoi._yDescent;
            
            // Only do this if there is a layout-grid-line used somewhere.
            if (vaoi._yMaxHeight != LONG_MIN)
            {
                LONG lHeight = max(vaoi._yMaxHeight, _li._yHeight);
                _li._yDescent += (lHeight - _li._yHeight) / 2;
                _li._yHeight = lHeight;
            }

            // Without this line, line heights specified through
            // styles would override the natural height of the
            // image. This would be cool, but the W3C doesn't
            // like it. Absolute & aligned sites do not affect
            // line height.
            if(_fHasInlinedSites)
                _fFoundLineHeight = FALSE;

            Assert(_li._yHeight >= 0);

            // Allow last minute adjustment to line height, we need
            // to call this here, because when positioning all the
            // site in line for the display tree, we want the correct
            // YTop.
            AdjustLineHeight();

            // And now the positioning pass
            vaoi._fMeasuring = FALSE;
            vaoi._fPositioning = TRUE;
        }
        else
        {
            vaoi._fPositioning = FALSE;
        }
    }
}
#pragma warning(default:4701)
#pragma warning(default:4189) // local variable initialized but not used 

//-------------------------------------------------------------------------
//
//  Member:     VerticalAlignOneObjectFast
//
//  Synopsis:   VAlign one object in a line.
//              Fast version - not used in case of CSS:vertical-align.
//
//-------------------------------------------------------------------------
void
CLineServices::VerticalAlignOneObjectFast(CLSMeasurer& lsme, VAOFINFO *pvaoi)
{
    BOOL  fAbsolute;
    LONG  yTopMargin,   yBottomMargin;
    long  xLeftMargin,  xRightMargin;
    const CFancyFormat *pFF;

    MtAdd( Mt(CLineServices_VerticalAlignOneObjectFast), +1, 0 );

    fAbsolute = pvaoi->_pNode->IsAbsolute(LC_TO_FC(_pci->GetLayoutContext()));
    if (!(   fAbsolute
          || pvaoi->_pElementLayout->IsInlinedElement(LC_TO_FC(_pci->GetLayoutContext()))
         )
       )
        goto Cleanup;
    
    pFF = pvaoi->_pNode->GetFancyFormat(LC_TO_FC(_pci->GetLayoutContext()));
    Assert(fAbsolute || pvaoi->_pElementLayout->IsInlinedElement(LC_TO_FC(_pci->GetLayoutContext())));
    pvaoi->_pLayout->GetMarginInfo(_pci, &xLeftMargin, &yTopMargin, &xRightMargin, &yBottomMargin);

    // Do the horizontal positioning. We can do it either during
    // measuring or during vertical positioning. We arbitrarily
    // chose to do it during measuring.
    if (pvaoi->_fMeasuring)
    {
        LONG xPosOfCp;
        BOOL fSubtractWidthFromXProposed = FALSE;
        
        if (!fAbsolute || pFF->_fAutoPositioned)
        {
            LONG lscp = pvaoi->_lscp == -1 ? LSCPFromCP(pvaoi->_cp) : pvaoi->_lscp;
            BOOL  fRTLDisplay = _pFlowLayout->IsRTLFlowLayout();
            BOOL  fRTLFlow = fRTLDisplay;
            
            //
            // If editable, then the char at the above computed lscp
            // might be the glyph for that layout rather than the layout
            // itself. To do this right, we need to we need to find the
            // run at that lscp, and if it is a glyph-synthetic run then
            // we need to go to the next run which contains the nested
            // layout and look at its lscp.
            //
            if (_fIsEditable && !fAbsolute)
            {
                COneRun *por = FindOneRun(lscp);
                if (   por
                    && por->IsSyntheticRun()
                    && por->_synthType == SYNTHTYPE_GLYPH
                   )
                {
                    por = por->_pNext;

                    //
                    // Check that this run exists, and has nested layout
                    // and that the nested layout is indeed the one we
                    // are hunting for.
                    //
                    Assert(por);
                    Assert(por->_fCharsForNestedElement);
                    Assert(por->_fCharsForNestedLayout);
                    Assert(por->_ptp->Branch() == pvaoi->_pNode);
                    lscp = por->_lscpBase;
                }
            }

            xPosOfCp = _li._fCanBlastToScreen ? pvaoi->_xWidthSoFar : CalculateXPositionOfLSCP(lscp, FALSE, &fRTLFlow);

#if DBG==1
            {
                BOOL fRTLFlowDbg = fRTLDisplay;
                Assert(xPosOfCp == CalculateXPositionOfLSCP(lscp, FALSE, &fRTLFlowDbg));
                Assert(fRTLFlow == fRTLFlowDbg);
            }
#endif

            if ((!!_li._fRTLLn) != fRTLFlow)
            {
                // Postpone flow adjustment for absolute objects. Their size is not updated yet.

                //TODO (dmitryt, track bug 112318) I see that fSubtractWidthFromXProposed is used below after we 
                //calculated the actual width of abspositioned object. I think I can move that 
                //calculation in front of this and get rid of the flag.
                if (fAbsolute)
                {
                    fSubtractWidthFromXProposed = TRUE; 
                }
                else
                {
                    long xObjectWidth = pvaoi->_pLayout->GetApparentWidth();
                    xPosOfCp -= xObjectWidth;
                }
            }

            if (pvaoi->_pCF->HasCharGrid(FALSE))
            {
                long xWidth;
                _pMeasurer->GetSiteWidth(pvaoi->_pNode, pvaoi->_pLayout, _pci, FALSE, _xWidthMaxAvail, &xWidth);
                xPosOfCp += (GetClosestGridMultiple(GetCharGridSize(), xWidth) - xWidth)/2;
            }

            // absolute margins are added in CLayout::HandlePositionRequest
            // due to reverse flow issues.
            if(!fAbsolute)
            {
                if (!_li._fRTLLn)
                    xPosOfCp += xLeftMargin;
                else
                    xPosOfCp += xRightMargin;
            }
            
            pvaoi->_pLayout->SetXProposed(xPosOfCp);
        }
        else
        {
            xPosOfCp = 0;
        }

        if (fAbsolute)
        {
            // NOTE: (paulnel) What about when the left or right has been specified and the width is auto?
            //                  The xPos needs to be adjusted to properly place this case.

            // fix for #3214, absolutely positioned sites with width auto
            // need to be measure once we know the line shift, since their
            // size depends on the xPosition in the line.

            // NOTE: (dmitryt)
            //      This is the only place where we CalcSize absolutely positioned 
            //      objects that were on the current line. These objects were taken out during 
            //      normal MeasureLine pass, because they don't participate in line width. 
            //      Now we want to measure them. When this function will be called for 
            //      positioning pass (pvaoi->fPositioning==true) we will add/position their 
            //      dispnodes accordingly. So here is the main place where we measure/position 
            //      abspos objects.
            //      I think the comment for bug 3214 was intended for abspos'ed objects without
            //      horizontal position specified. Those have left=(x-position-of-their-cp-in-the-line).
            long xWidth;
            _pMeasurer->GetSiteWidth(pvaoi->_pNode, pvaoi->_pLayout, _pci, TRUE, _xWidthMaxAvail, &xWidth );

            // Subtract object width from XProposed if needed, now that we know the width
            if (fSubtractWidthFromXProposed)
            {
                xPosOfCp -= xWidth;
                pvaoi->_pLayout->SetXProposed(xPosOfCp);
            }
        }
    } // if (fMeasuring)

    if(!fAbsolute)
    {
        htmlControlAlign atSite;
        CSize            size;
        LONG             yObjHeight;
        LONG             yTmpAscent  = 0;
        LONG             yTmpDescent = 0;
        LONG             yProposed   = 0;
        LONG             lBorderSpace;
        LONG             lVPadding   = 0; 

        if (    pvaoi->_pElementLayout->TestClassFlag(CElement::ELEMENTDESC_VPADDING) 
            // In print preview an element inside a table cell with VPADDING and percent 
            // height may be pushed to the next page by CDisplay code during set cell 
            // position pass -- when table code does not expect it. The checks below 
            // prevent it (#23413)
            &&  (   !_pci->_fTableCalcInfo 
                ||  !_pci->GetLayoutContext() 
                ||  !_pci->GetLayoutContext()->ViewChain() 
                ||  !pvaoi->_pLayout->PercentHeight()       )   )
        {
            lVPadding = 1;
        }

        if(pvaoi->_pElementLayout->Tag() == ETAG_HR)
            lBorderSpace = GRABSIZE;
        else
            // Netscape has a pixel descent and ascent to the line if one of the sites
            // spans the entire line vertically(#20029, #25534).
            lBorderSpace = lVPadding;

        lBorderSpace = _pci->DeviceFromDocPixelsY(lBorderSpace);

        pvaoi->_pLayout->GetApparentSize(&size);
        yObjHeight = max(0L, size.cy + yTopMargin + yBottomMargin)+ (2 * lBorderSpace);

        if(pvaoi->_pCF->_fIsRubyText)
        {
            RubyInfo *pRubyInfo = GetRubyInfoFromCp(pvaoi->_cp);
            if(pRubyInfo)
            {
                yObjHeight += pRubyInfo->yHeightRubyBase - pvaoi->_yTxtDescent + pRubyInfo->yDescentRubyText;
            }                        
        }

        atSite   = pvaoi->_pElementLayout->GetSiteAlign(LC_TO_FC(_pci->GetLayoutContext()));
        switch (atSite)
        {
        // align to the baseline of the text
        case htmlControlAlignNotSet:
        case htmlControlAlignBottom:
        case htmlControlAlignBaseline:
        {
            LONG lDefDescent = 0;
            if (pvaoi->_pElementLayout->TestClassFlag(CElement::ELEMENTDESC_HASDEFDESCENT))
            {
                lDefDescent = _pci->DeviceFromDocPixelsY(4);
            }
            else if (!pFF->_fLayoutFlowChanged)    // Do not adjust layout's descent if flow has been changed
            {
                lDefDescent = pvaoi->_pLayout->GetDescent();

                // This is a hack to get IE5 compat when you have negative margins on inline sites.
                // See bug 103469.
                if (   yBottomMargin < 0 
                    && pvaoi->_pLayout->IsFlowLayout())
                {
                    lDefDescent += yBottomMargin;
                    lDefDescent = max(0l, lDefDescent);
                }
            }

            if(pvaoi->_fMeasuring)
            {
                yTmpDescent = lBorderSpace + lDefDescent;
                yTmpAscent  = yObjHeight - yTmpDescent;
            }
            else
            {
                yProposed += pvaoi->_yAscent - yObjHeight + 2 * lBorderSpace + lDefDescent;
            }
            break;
        }

        // align to the top of the text
        case htmlControlAlignTextTop:
            if(pvaoi->_fMeasuring)
            {
                yTmpAscent  = pvaoi->_yTxtAscent + lBorderSpace;
                yTmpDescent = yObjHeight - pvaoi->_yTxtAscent - lBorderSpace;
            }
            else
            {
                yProposed += pvaoi->_yAscent - pvaoi->_yTxtAscent + lBorderSpace;
            }
            break;

            // center of the image aligned to the baseline of the text
        case htmlControlAlignMiddle:
        case htmlControlAlignCenter:
            if(pvaoi->_fMeasuring)
            {
                yTmpAscent  = (yObjHeight + 1)/2; // + 1 for round off
                yTmpDescent = yObjHeight/2;
            }
            else
            {
                yProposed += (pvaoi->_yAscent + pvaoi->_yDescent - yObjHeight) / 2 + lBorderSpace;
            }
            break;

            // align to the top, absmiddle and absbottom of the line, doesn't really
            // effect the ascent and descent directly, so we store the
            // absolute height of the object and recompute the ascent
            // and descent at the end.
        case htmlControlAlignAbsMiddle:
            if(pvaoi->_fPositioning)
            {
                yProposed += (pvaoi->_yAscent + pvaoi->_yDescent - yObjHeight) / 2 + lBorderSpace;
                break;
            } // fall through when measuring and update max abs height
        case htmlControlAlignTop:
            if(pvaoi->_fPositioning)
            {
                yProposed += lBorderSpace;
                break;
            } // fall through when measuring and update the max abs height
        case htmlControlAlignAbsBottom:
            if(pvaoi->_fMeasuring)
            {
                yTmpAscent = 0;
                yTmpDescent = 0;
                if(yObjHeight > pvaoi->_yAbsHeight)
                {
                    pvaoi->_yAbsHeight = yObjHeight;
                    pvaoi->_atAbs = atSite;
                }
            }
            else
            {
                yProposed += pvaoi->_yAscent + pvaoi->_yDescent - yObjHeight + lBorderSpace;
            }
            break;

        default:        // we don't want to do anything for
            if(pvaoi->_pElementLayout->HasFlag(TAGDESC_OWNLINE))
            {
                LONG lDefDescent = 0;
                if (!pFF->_fLayoutFlowChanged)    // Do not adjust layout's descent if flow has been changed
                {
                    lDefDescent = pvaoi->_pLayout->GetDescent();
                }
                if(pvaoi->_fMeasuring)
                {
                    yTmpDescent = lBorderSpace + lDefDescent;
                    yTmpAscent  = yObjHeight - lBorderSpace;
                }
                else
                {
                    yProposed += pvaoi->_yAscent - yObjHeight + lBorderSpace + lDefDescent;
                }
            }
            break;      // left/center/right aligned objects
        } // switch(atSite)

        // Keep track of the max ascent and descent
        if(pvaoi->_fMeasuring)
        {
            if(pvaoi->_pCF->HasLineGrid(FALSE))
            {
                pvaoi->_yMaxHeight = max(pvaoi->_yMaxHeight, 
                    GetClosestGridMultiple(GetLineGridSize(), yTmpAscent + yTmpDescent));
            }

            if(yTmpAscent > pvaoi->_yAscent)
                pvaoi->_yAscent = yTmpAscent;
            if(yTmpDescent > pvaoi->_yDescent)
                pvaoi->_yDescent = yTmpDescent;
        }
        else
        {
            LONG yP;
            
            if(pvaoi->_pCF->HasLineGrid(FALSE))
            {
                yP = _li._yHeight - (pvaoi->_yAscent + _li._yDescent) + yTopMargin + yProposed;
            }
            else
            {
                yP = yProposed + lsme._cyTopBordPad + yTopMargin;
            }
            pvaoi->_pLayout->SetYProposed(yP - min((LONG)0, (LONG)_li._yHeightTopOff));

            if (pvaoi->_por)
            {
                pvaoi->_por->_yObjHeight = yObjHeight;
                pvaoi->_por->_yProposed  = yP;
            }
        }
    } // if(!fAbsolute)

    //
    // If positioning, add the current layout to the display tree
    //
    if (    pvaoi->_fPositioning
        && !pvaoi->_pElementLayout->IsAligned(LC_TO_FC(_pci->GetLayoutContext()))
        && _pci->IsNaturalMode()
       )
    {
        long dx;
        if (!_li.IsRTLLine())
            dx = _pMarginInfo->_xLeftMargin + _li._xLeft;
        else
        {
            dx = - _pMarginInfo->_xRightMargin - _li._xRight;
        }

        long xPos;
        if (!_li.IsRTLLine())
            xPos = dx + pvaoi->_pLayout->GetXProposed();
        else
            xPos = dx + _pFlowLayout->GetContainerWidth() 
                 - pvaoi->_pLayout->GetXProposed() - pvaoi->_pLayout->GetApparentWidth();


        if (   (    !pFF->_fPositioned
                ||  (   pvaoi->_pElementFL->HasSlavePtr()
                            // Non CSS1 compatible slave markup
                     && (   (   pvaoi->_pElementLayout->_etag == ETAG_BODY
                             && !pvaoi->_pElementLayout->GetMarkup()->IsHtmlLayout()
                            )
                            // CSS1 compatible slave markup
                         || (   pvaoi->_pElementLayout->_etag == ETAG_HTML
                             && pvaoi->_pElementLayout->GetMarkup()->IsHtmlLayout()
                            )
                        )
                    )
                )
            && !pvaoi->_pCF->_fRelative
            )
        {
            // we are not using GetYTop for to get the offset of the line because
            // the before space is not added to the height yet.
            lsme._pDispNodePrev = pvaoi->_pFL->AddLayoutDispNode(
                            _pci,
                            pvaoi->_pElementLayout->GetFirstBranch(),
                            xPos,
                            lsme._yli 
                                + _li._yBeforeSpace 
                                + _li._yHeightTopOff
                                + pvaoi->_pLayout->GetYProposed(),
                            lsme._pDispNodePrev);
        }
        else
        {
            //
            // If top and bottom or left and right are "auto", position the object
            //

            if (fAbsolute)
                pvaoi->_pLayout->SetYProposed(lsme._cyTopBordPad);

            CPoint ptAuto(xPos,
                          lsme._yli + _li._yBeforeSpace + _li._yHeightTopOff +
                          pvaoi->_pLayout->GetYProposed());

            pvaoi->_pElementLayout->RepositionElement(0, &ptAuto, _pci->GetLayoutContext());
        }
    }
    
Cleanup:
    return;
}

//-------------------------------------------------------------------------
//
//  Member:     GetNextNodeForVerticalAlign
//
//  Synopsis:   gets next node to be vertical aligned
//
//-------------------------------------------------------------------------
void
CLineServices::GetNextNodeForVerticalAlign(VAOINFO * pvaoi)
{
    Assert(pvaoi->_cchPreChars >= 0);
    Assert(pvaoi->_cchAdvance  == 0);

    if (pvaoi->_fFastProcessing)
    {
        Assert(pvaoi->_por);
        Assert(pvaoi->_ptpNext == NULL);
        pvaoi->_pNodeNext       = pvaoi->_por->_ptp->GetBranch();
    }
    else if (pvaoi->_cchPreChars == 0 && !pvaoi->_fPostCharsProcessing)
    {
        Assert(pvaoi->_por);
        pvaoi->_fFastProcessing = TRUE;
        pvaoi->_ptpNext         = NULL;
        pvaoi->_pNodeNext       = pvaoi->_por->_ptp->GetBranch();
    }
    else if (pvaoi->_ptpNext)
    {
        pvaoi->_ptpNext    = pvaoi->_ptpNext->NextNonPtrTreePos();
        pvaoi->_pNodeNext  = pvaoi->_ptpNext->GetBranch();
        pvaoi->_cchAdvance = pvaoi->_ptpNext->GetCch();
    }
    else
    {
        LONG ich;
        pvaoi->_ptpNext    = _pMarkup->TreePosAtCp(_cpStart + _li._cch - pvaoi->_cch, &ich, TRUE);
        pvaoi->_pNodeNext  = pvaoi->_ptpNext->GetBranch();
        pvaoi->_cchAdvance = pvaoi->_ptpNext->GetCch() - ich;
    }

    Assert(pvaoi->_cchPreChars == 0 || pvaoi->_cchPreChars >= pvaoi->_cchAdvance);
}

//-------------------------------------------------------------------------
//
//  Member:     VerticalAlignObjects
//
//  Synopsis:   Process all vertically aligned objects and adjust the line
//              height
//
//-------------------------------------------------------------------------
void
CLineServices::VerticalAlignObjects(
    CLSMeasurer & lsme, 
    long xLineShift)
{
    Assert(_li._cch >= 0 && _listCurrent._pHead);

    BOOL fPositioning = FALSE;

    VAOINFO vaoi;
    ZeroMemory(&vaoi, sizeof(VAOINFO));
    vaoi._xLineShift  = xLineShift;
    vaoi._fMeasuring  = TRUE;

    VANINFO vani;
    ZeroMemory(&vani, sizeof(VANINFO));

    COneRun * porHead = _listCurrent._pHead;
    while (porHead && porHead->IsSyntheticRun())
        porHead = porHead->_pNext;

    // First pass we measure the line's ascent and descent
    // second pass we set the height and yPosition of objects.
    while (vaoi._fMeasuring || fPositioning)
    {
        vaoi._fFastProcessing      = lsme._fMeasureFromTheStart;
        vaoi._fPostCharsProcessing = FALSE;
        vaoi._por         = porHead;
        vaoi._pvaniCached = &vani;
        vaoi._xWidthSoFar = 0;
        vaoi._cchPreChars = lsme._cchPreChars;
        vaoi._cch         = _li._cch + (vaoi._fFastProcessing ? 0 : vaoi._cchPreChars);
        vaoi._cchAdvance  = 0;
        vaoi._pNodeNext   = NULL;
        vaoi._ptpNext     = NULL;

        while (vaoi._cch > 0)
        {
            VANINFO * pvaniBlock;

            if (!vaoi._pNodeNext)
                GetNextNodeForVerticalAlign(&vaoi);
            Assert(vaoi._pNodeNext);

            if (vaoi._fMeasuring)
            {
                Assert(!vaoi._pvaniCached->_pNext);
                vaoi._pvaniCached->_pNext = new VANINFO;
                if (!vaoi._pvaniCached->_pNext)
                {
                    vaoi._fMeasuring = FALSE; // Error: skip positioning process
                    break;
                }
                ZeroMemory(vaoi._pvaniCached->_pNext, sizeof(VANINFO));
                // In case of tags overlaping we can VAlign node, which does't belong to current flow layout.
                // In this case VAlign this node.
                if (vaoi._pNodeNext->GetBeginPos()->GetCp() < _pFlowLayout->ElementOwner()->GetFirstCp())
                {
                    vaoi._pvaniCached->_pNext->_pNode = vaoi._pNodeNext;
                }
                else
                {
                    CTreeNode * pNodeBlock = _pMarkup->SearchBranchForBlockElement(vaoi._pNodeNext, _pFlowLayout);
                    if (!pNodeBlock)
                        pNodeBlock = vaoi._pNodeNext;
                    vaoi._pvaniCached->_pNext->_pNode = pNodeBlock;
                }
            }
            pvaniBlock = vaoi._pvaniCached = vaoi._pvaniCached->_pNext;
            
            Assert(pvaniBlock->_pNode);

            if (!VerticalAlignNode(lsme, &vaoi, pvaniBlock))
            {
                vaoi._fMeasuring = FALSE; // Error: skip positioning process
                break;
            }

            if (    vaoi._fMeasuring
                &&  vaoi._cchPreChars == 0)
            {
                vani._yAscent  = max(vani._yAscent, pvaniBlock->_yAscent);
                vani._yDescent = max(vani._yDescent, pvaniBlock->_yDescent);
            }
        }

        // We have just finished measuring, update the line's ascent and descent.
        if (vaoi._fMeasuring)
        {
            // now update the line height
            vaoi._yLineHeight = max(vaoi._yLineHeight, vani._yAscent + vani._yDescent);

            if (_lsMode == LSMODE_MEASURER)
            {
                /* BOOL fEmptyLine = (vaoi._xWidthSoFar == 0 && !vaoi._fHasAbsSites); */
                _li._yDescent = max((LONG)_li._yDescent, /*fEmptyLine ? 0L : */vani._yDescent);
                _li._yHeight  = max((LONG)_li._yHeight,  /*fEmptyLine ? 0L : */vaoi._yLineHeight);

                // Without this line, line heights specified through
                // styles would override the natural height of the
                // image. This would be cool, but the W3C doesn't
                // like it. Absolute & aligned sites do not affect
                // line height.
                if(_fHasInlinedSites)
                    _fFoundLineHeight = FALSE;

                Assert(_li._yHeight >= 0);

                // Allow last minute adjustment to line height, we need
                // to call this here, because when positioning all the
                // site in line for the display tree, we want the correct
                // YTop.
                if (vaoi._fHasLineGrid)
                {
                    _fFoundLineHeight = TRUE;
                    _lMaxLineHeight = GetClosestGridMultiple(GetLineGridSize(), max(_lMaxLineHeight, vaoi._yLineHeight));
                }
                AdjustLineHeight();
            }

            // And now the positioning pass
            vaoi._fMeasuring = FALSE;
            fPositioning = TRUE;
        }
        else
        {
            fPositioning = FALSE;
        }
    }

    // VANINFO list cleanup
    while (vani._pNext)
    {
        VANINFO * pTemp = vani._pNext;
        vani._pNext = pTemp->_pNext;
        delete pTemp;
    }
}

//-------------------------------------------------------------------------
//
//  Member:     VerticalAlignNode
//
//  Synopsis:   vartical align contents of the node
//
//-------------------------------------------------------------------------
BOOL
CLineServices::VerticalAlignNode(
    CLSMeasurer & lsme, 
    VAOINFO * pvaoi, 
    VANINFO * pvani)
{
    if (pvaoi->_fMeasuring)
    {
        pvani->_pCF = pvani->_pNode->GetCharFormat(LC_TO_FC(GetLayoutContext()));
        pvani->_pFF = pvani->_pNode->GetFancyFormat(LC_TO_FC(GetLayoutContext()));

        // If we are transisitioning from a normal chunk to relative or
        // relative to normal chunk, add a new chunk to the line.
        if (_fHasRelative && !pvani->_pCF->IsDisplayNone())
        {
            CElement * pElementLayout = (   _pFlowLayout->ElementOwner() != pvani->_pNode->Element()
                                        &&  pvani->_pFF->_fShouldHaveLayout)
                                        ? pvani->_pNode->Element()
                                        : NULL;

            TestForTransitionToOrFromRelativeChunk(_cpStart + _li._cch - pvaoi->_cch, 
                pvani->_pCF->IsRelative(SameScope(pvani->_pNode, _pFlowLayout->ElementOwner())), 
                FALSE /*fForceChunk*/,
                pvani->_pNode, pElementLayout);
        }

        pvaoi->_fHasLineGrid |= !!pvani->_pCF->HasLineGrid(TRUE);
        pvani->_fRubyVAMode   = !!pvani->_pCF->_fIsRuby;

        if (pvani->_yTxtAscent == 0)
        {
            Assert(pvani->_yTxtDescent == 0);

            // Get font's ascent and descent from ccs
            CCcs ccs;
            const CBaseCcs *pBaseCcs;

            if (   pvaoi->_fFastProcessing 
                && pvaoi->_cchPreChars == 0 
                && pvaoi->_por->Branch() == pvani->_pNode)
            {
                GetCcs(&ccs, pvaoi->_por, _pci->_hdc, _pci);
                pBaseCcs = ccs.GetBaseCcs();

                // TODO: (grzegorz): remove checking for null CBaseCcs object, when
                // 107681 is fixed.
                if (pBaseCcs)
                {
                    pvani->_yAscent  = pvani->_yTxtAscent  = pBaseCcs->_yHeight - pBaseCcs->_yDescent;
                    pvani->_yDescent = pvani->_yTxtDescent = pBaseCcs->_yDescent;
                }
            }
            else
            {
                fc().GetCcs(&ccs, _pci->_hdc, _pci, pvani->_pCF);
                pBaseCcs = ccs.GetBaseCcs();

                // TODO: (grzegorz): remove checking for null CBaseCcs object, when
                // 107681 is fixed.
                if (pBaseCcs)
                {
                    pvani->_yAscent  = pvani->_yTxtAscent  = pBaseCcs->_yHeight - pBaseCcs->_yDescent;
                    pvani->_yDescent = pvani->_yTxtDescent = pBaseCcs->_yDescent;
                }

                ccs.Release();
            }
        }
    }

    // Run this aligment loop until end of line is not reached
    // or we exiting this node scope ('break' statement)
    while (pvaoi->_cch > 0)
    {
        if (!pvaoi->_pNodeNext)
            GetNextNodeForVerticalAlign(pvaoi);

        if (pvani->_pNode == pvaoi->_pNodeNext)
        {
            //
            // We are at the same node level. Do regular aligment processing.
            // Align only normal text runs and objects with layout, but only
            // if we are done with pre chars.
            //
            if (pvaoi->_fFastProcessing && pvaoi->_cchPreChars == 0)
            {
                if (pvaoi->_por->_fCharsForNestedLayout)
                {
                    if ( !pvani->_pCF->IsDisplayNone())
                    {
                        if (!pvani->_pLayout)
                        {
                            pvani->_pLayout = pvani->_pNode->GetUpdatedLayout(_pci->GetLayoutContext());
                        }

                        VerticalAlignOneObject(lsme, pvaoi, pvani);
                    }
                }
                // NOTE: text run can be hidden (display:none) => not normal run
                else if (pvaoi->_por->_ptp->IsText() && pvaoi->_por->IsNormalRun())
                {
                    if (!pvaoi->_fMeasuring)
                    {
                        Assert(pvani->_yAscent >= pvani->_yTxtAscent);

                        pvaoi->_por->_yProposed  = pvani->_yProposed + pvani->_yAscent - pvani->_yTxtAscent;
                        pvaoi->_por->_yProposed += _li._yBeforeSpace + _li._cyTopBordPad + max((LONG)0, (LONG)_li._yHeightTopOff);
                        pvaoi->_por->_yObjHeight = pvani->_yTxtAscent + pvani->_yTxtDescent;
                        // If we have smallcaps we have to adjust _yProposed such that if there are only small letters, 
                        // the letters are brought down on base line.
                        if (pvani->_pCF->_fSmallCaps) 
                        {
                            CCcs ccs;
                            const CBaseCcs *pBaseCcs;
                            GetCcs(&ccs, pvaoi->_por, _pci->_hdc, _pci);
                            pBaseCcs = ccs.GetBaseCcs();

                            // TODO: (grzegorz): remove checking for null CBaseCcs object, when
                            // 107681 is fixed. 
                            if (pBaseCcs) 
                            {
                                pvaoi->_por->_yProposed -= (pBaseCcs->_yHeight - pBaseCcs ->_yDescent) - pvani->_yTxtAscent;
                            }
                        }
                    }
#if DBG==1
                    else
                    {
                        // Make sure we adjust ascent/descent correctly
                        Assert(pvani->_yAscent  >= pvani->_yTxtAscent);
                        Assert(pvani->_yDescent >= pvani->_yTxtDescent);
                    }
#endif
                    pvaoi->_xWidthSoFar += pvaoi->_por->_xWidth;
                    pvani->_fHasContent = TRUE;

                    // Cannot blast lines with RUBY inside
                    Assert(!pvani->_pCF->_fIsRubyText || !_li._fCanBlastToScreen);

                }

                pvaoi->_cch -= pvaoi->_por->_lscch;
                pvaoi->_por  = pvaoi->_por->_pNext;
#if DBG==1
                // Make sure we adjust _cch correctly
                if (pvaoi->_por && pvaoi->_cch > 0)
                    Assert(pvaoi->_por->Cp() - _cpStart == _li._cch - pvaoi->_cch);
#endif
            }
            else
            {
                //
                // We are during pre or post chars processing.
                //

                if (pvaoi->_fFastProcessing)
                {
                    Assert(pvaoi->_ptpNext    == NULL);
                    Assert(pvaoi->_cchAdvance == 0);
                    pvaoi->_ptpNext    = pvaoi->_por->_ptp;
                    pvaoi->_cchAdvance = pvaoi->_por->_lscch;
                }
                Assert(pvaoi->_ptpNext);
                Assert(pvaoi->_ptpNext->GetBranch() == pvani->_pNode);

                if (    pvaoi->_ptpNext->IsBeginElementScope()
                    &&  pvani->_pFF->IsAbsolute()
                    &&  pvani->_pNode->ShouldHaveLayout()
                   )
                {
                    if (!pvani->_pCF->IsDisplayNone())
                    {
                        pvani->_pLayout = pvani->_pNode->GetUpdatedLayout();
                        VerticalAlignOneObject(lsme, pvaoi, pvani);
                    }
                    LONG cchSite = GetNestedElementCch(pvani->_pNode->Element(), &pvaoi->_ptpNext);

                    Assert(pvaoi->_cchPreChars == 0 || pvaoi->_cchPreChars >= cchSite);

                    if (pvaoi->_cchPreChars)
                        pvaoi->_cchPreChars -= min(cchSite, pvaoi->_cchPreChars);
                    pvaoi->_cch        -= cchSite;
                    pvaoi->_cchAdvance  = 0;
                    pvaoi->_pNodeNext   = NULL;

                    if (pvaoi->_fFastProcessing)
                    {
                        pvaoi->_ptpNext = NULL;
                        pvaoi->_por     = pvaoi->_por->_pNext;
                    }

                    // We are finished with this node.
                    goto Cleanup;
                }
                else
                {
                    Assert(pvaoi->_cchPreChars == 0 || pvaoi->_cchPreChars >= pvaoi->_cchAdvance);

                    if (pvaoi->_cchPreChars)
                        pvaoi->_cchPreChars -= pvaoi->_cchAdvance;
                    pvaoi->_cch        -= pvaoi->_cchAdvance;
                    pvaoi->_cchAdvance  = 0;

                    if (pvaoi->_fFastProcessing)
                    {
                        pvaoi->_ptpNext = NULL;
                        pvaoi->_por     = pvaoi->_por->_pNext;
                    }
                }
            }

            // Skip synthetic runs and invalidate next node
            while (pvaoi->_por && pvaoi->_por->IsSyntheticRun())
            {
                pvaoi->_por = pvaoi->_por->_pNext;
            }
            pvaoi->_pNodeNext = NULL;

            if (!pvaoi->_por && pvaoi->_fFastProcessing)
            {
                pvaoi->_fFastProcessing      = FALSE;
                pvaoi->_fPostCharsProcessing = TRUE;
            }
        }
        else if (pvani->_pNode->AmIAncestorOf(pvaoi->_pNodeNext))
        {
            //
            // We are entering child node. Store 'pCurrentNode' for use
            // during child node processing.
            // 

            VANINFO * pvaniChild;
            if (pvaoi->_fMeasuring)
            {
                CTreeNode * pNodeChild = pvaoi->_pNodeNext;
                // Make sure we are going down only one level
                while (pNodeChild->Parent() != pvani->_pNode)
                    pNodeChild = pNodeChild->Parent();

                // Setup VANINFO for child node and add it cached list.
                // NOTE: Memory will be freed at the end of aligning process.
                pvaniChild = new VANINFO;
                if (!pvaniChild)
                    return FALSE;
                Assert(!pvaoi->_pvaniCached->_pNext);
                pvaoi->_pvaniCached->_pNext = pvaniChild;
                ZeroMemory(pvaniChild, sizeof(VANINFO));
                pvaniChild->_pNode = pNodeChild;
                pvaoi->_pvaniCached = pvaniChild;
            }
            else
            {
                pvaniChild = pvaoi->_pvaniCached = pvaoi->_pvaniCached->_pNext;

                // Set yProposed for child node
                switch (pvaniChild->_pFF->GetVerticalAlign(pvani->_pCF->HasVerticalLayoutFlow()))
                {
                case styleVerticalAlignSub:
                    {
                        LONG yOffset;
                        if (pvaniChild->_pCF->_fSubscript)
                        {
                            yOffset = (LONG)(pvaniChild->_pCF->GetHeightInPixelsEx(
                                                pvaniChild->_yTxtAscent + pvaniChild->_yTxtDescent, 
                                                _pci) / 2);
                        }
                        else
                        {
                            yOffset = pvaniChild->_yAscent - (LONG)((pvani->_yTxtAscent - pvani->_yTxtDescent) / 2);
                        }
                        pvaniChild->_yProposed = pvani->_yProposed + pvani->_yAscent - 
                            pvaniChild->_yAscent + yOffset;
                    }
                    break;

                case styleVerticalAlignSuper:
                    {
                        LONG yOffset;
                        if (pvaniChild->_pCF->_fSuperscript)
                        {
                            yOffset = (LONG)(pvaniChild->_pCF->GetHeightInPixelsEx(
                                                pvaniChild->_yTxtAscent + pvaniChild->_yTxtDescent, 
                                                _pci) / 2);
                        }
                        else
                        {
                            yOffset = pvaniChild->_yDescent + (LONG)((pvani->_yTxtAscent - pvani->_yTxtDescent) / 2);
                        }
                        pvaniChild->_yProposed = pvani->_yProposed + pvani->_yAscent - 
                            pvaniChild->_yAscent - yOffset;
                    }
                    break;

                case styleVerticalAlignTop:
                    pvaniChild->_yProposed = 0;
                    break;

                case styleVerticalAlignBottom:
                    pvaniChild->_yProposed = pvaoi->_yLineHeight - (pvaniChild->_yAscent + pvaniChild->_yDescent);
                    break;

                case styleVerticalAlignAbsMiddle:
                    pvaniChild->_yProposed = (pvaoi->_yLineHeight - (pvaniChild->_yAscent + pvaniChild->_yDescent)) / 2;
                    break;

                case styleVerticalAlignMiddle:
                    if (pvaniChild->_fRubyVAMode)
                    {
                        // Ruby in vertical text is aligned to the baseline
                        Assert(!pvaniChild->_pFF->HasCSSVerticalAlign());
                        pvaniChild->_yProposed = pvani->_yProposed + pvani->_yAscent - pvaniChild->_yAscent;
                    }
                    else
                    {
                        LONG yDiff = (pvaniChild->_yAscent + pvaniChild->_yDescent - (pvani->_yTxtAscent + pvani->_yTxtDescent)) / 2;
                        pvaniChild->_yProposed = pvani->_yProposed + (pvani->_yAscent - pvani->_yTxtAscent) - yDiff;
                    }
                    break;

                case styleVerticalAlignTextTop:
                    pvaniChild->_yProposed = pvani->_yProposed + pvani->_yAscent - pvani->_yTxtAscent;
                    break;

                case styleVerticalAlignTextBottom:
                    pvaniChild->_yProposed = pvani->_yProposed + pvani->_yAscent + pvani->_yTxtDescent - (pvaniChild->_yAscent + pvaniChild->_yDescent);
                    break;

                case styleVerticalAlignBaseline:
                    pvaniChild->_yProposed = pvani->_yProposed + pvani->_yAscent - pvaniChild->_yAscent;
                    break;

                case styleVerticalAlignPercent:
                case styleVerticalAlignNumber:
                    {
                        LONG lFontHeightTwips  = pvaniChild->_pCF->GetHeightInTwips(_pci->_pDoc);
                        LONG lFontHeightPixels = pvaniChild->_pCF->GetHeightInPixels(_pci->_hdc, _pci);
                        LONG lLineHeightPixels = lFontHeightPixels;
                        if (!pvaniChild->_pCF->_cuvLineHeight.IsNull())
                            lLineHeightPixels = pvaniChild->_pCF->_cuvLineHeight.YGetPixelValue(_pci, lFontHeightPixels, lFontHeightTwips);
                        const CUnitValue & cuvVA = pvaniChild->_pFF->GetVerticalAlignValue();
                        LONG yOffset = cuvVA.YGetPixelValue(_pci, lLineHeightPixels, lFontHeightTwips);

                        pvaniChild->_yProposed = pvani->_yProposed + pvani->_yAscent - pvaniChild->_yAscent - yOffset;
                    }
                    break;

                default:
                    Assert(FALSE);
                }
                Assert(pvaniChild->_yProposed >= 0);
            }

            // Vertical align child node
            if (!VerticalAlignNode(lsme, pvaoi, pvaniChild))
                return FALSE;

            if (pvaoi->_fMeasuring)
            {
                // Set ruby vertical align mode; can be cleared later.
                pvani->_fRubyVAMode = pvaniChild->_fRubyVAMode;

                // Height of child node may affect height of this node. 
                // Make necessary adjustments.
                if (pvaniChild->_pCF->_fIsRubyText)
                {
                    //
                    // Vertical align has no effect on RT tag
                    //

                    Assert(pvani->_pCF->_fIsRuby);

                    RubyInfo * pRubyInfo = GetRubyInfoFromCp(pvaniChild->_pNode->Element()->GetFirstCp());
                    if(pRubyInfo)
                    {
                        pvani->_yAscent = max(pvani->_yAscent, pRubyInfo->yHeightRubyBase - pRubyInfo->yDescentRubyBase + pvaniChild->_yAscent + pvaniChild->_yDescent);
                    }                        
                }
                else
                {
                    switch (pvaniChild->_pFF->GetVerticalAlign(pvani->_pCF->HasVerticalLayoutFlow()))
                    {
                    case styleVerticalAlignSub:
                        {
                            LONG yOffset;
                            if (pvaniChild->_pCF->_fSubscript)
                            {
                                yOffset = (LONG)(pvaniChild->_pCF->GetHeightInPixelsEx(
                                                    pvaniChild->_yTxtAscent + pvaniChild->_yTxtDescent, 
                                                    _pci) / 2);
                            }
                            else
                            {
                                yOffset = pvaniChild->_yAscent - (LONG)((pvani->_yTxtAscent - pvani->_yTxtDescent) / 2);
                            }
                            pvani->_yAscent  = max(pvani->_yAscent,  pvaniChild->_yAscent  - yOffset);
                            pvani->_yDescent = max(pvani->_yDescent, pvaniChild->_yDescent + yOffset);
                        }
                        break;

                    case styleVerticalAlignSuper:
                        {
                            LONG yOffset;
                            if (pvaniChild->_pCF->_fSuperscript)
                            {
                                yOffset = (LONG)(pvaniChild->_pCF->GetHeightInPixelsEx(
                                                    pvaniChild->_yTxtAscent + pvaniChild->_yTxtDescent, 
                                                    _pci) / 2);
                            }
                            else
                            {
                                yOffset = pvaniChild->_yDescent + (LONG)((pvani->_yTxtAscent - pvani->_yTxtDescent) / 2);
                            }
                            pvani->_yAscent  = max(pvani->_yAscent,  pvaniChild->_yAscent  + yOffset);
                            pvani->_yDescent = max(pvani->_yDescent, pvaniChild->_yDescent - yOffset);
                        }
                        break;

                    case styleVerticalAlignTop:
                    case styleVerticalAlignBottom:
                    case styleVerticalAlignAbsMiddle:
                        pvaoi->_yLineHeight = max(pvaoi->_yLineHeight, pvaniChild->_yAscent + pvaniChild->_yDescent);
                        break;

                    case styleVerticalAlignMiddle:
                        // allign to the middle of parent's element font
                        if (pvaniChild->_fRubyVAMode)
                        {
                            // ruby in vertical text is aligned to the baseline
                            Assert(!pvaniChild->_pFF->HasCSSVerticalAlign());
                            pvani->_yAscent  = max(pvani->_yAscent, pvaniChild->_yAscent);
                            pvani->_yDescent = max(pvani->_yDescent, pvaniChild->_yDescent);
                        }
                        else
                        {
                            LONG yDiff = pvaniChild->_yAscent + pvaniChild->_yDescent - (pvani->_yTxtAscent + pvani->_yTxtDescent);
                            pvani->_yAscent   = max(pvani->_yAscent, (LONG)(pvani->_yTxtAscent  + (yDiff + 1) / 2));
                            pvani->_yDescent  = max(pvani->_yDescent,(LONG)(pvani->_yTxtDescent + yDiff / 2));
                        }
                        break;

                    case styleVerticalAlignTextTop:
                        // ascent is not changed
                        pvani->_yDescent = max(pvani->_yDescent, pvaniChild->_yAscent + pvaniChild->_yDescent - pvani->_yTxtAscent);
                        break;

                    case styleVerticalAlignTextBottom:
                        pvani->_yAscent = max(pvani->_yAscent, pvaniChild->_yAscent + pvaniChild->_yDescent - pvani->_yTxtDescent);
                        // descent is not changed
                        break;

                    case styleVerticalAlignBaseline:
                        pvani->_yAscent  = max(pvani->_yAscent, pvaniChild->_yAscent);
                        pvani->_yDescent = max(pvani->_yDescent, pvaniChild->_yDescent);
                        break;

                    case styleVerticalAlignPercent:
                    case styleVerticalAlignNumber:
                        {
                            LONG lFontHeightTwips  = pvaniChild->_pCF->GetHeightInTwips(_pci->_pDoc);
                            LONG lFontHeightPixels = pvaniChild->_pCF->GetHeightInPixels(_pci->_hdc, _pci);
                            LONG lLineHeightPixels = lFontHeightPixels;
                            if (!pvaniChild->_pCF->_cuvLineHeight.IsNull())
                                lLineHeightPixels = pvaniChild->_pCF->_cuvLineHeight.YGetPixelValue(_pci, lFontHeightPixels, lFontHeightTwips);
                            const CUnitValue & cuvVA = pvaniChild->_pFF->GetVerticalAlignValue();
                            LONG yOffset = cuvVA.YGetPixelValue(_pci, lLineHeightPixels, lFontHeightTwips);

                            pvani->_yAscent  = max(pvani->_yAscent, pvaniChild->_yAscent + yOffset);
                            pvani->_yDescent = max(pvani->_yDescent, pvaniChild->_yDescent - yOffset);
                        }
                        break;

                    default:
                        Assert(FALSE);
                    }
                }

                // If we are transisitioning from a normal chunk to relative or
                // relative to normal chunk, add a new chunk to the line.
                if (_fHasRelative && !pvani->_pCF->IsDisplayNone() && pvaoi->_cch > 0)
                {
                    CElement * pElementLayout = (   _pFlowLayout->ElementOwner() != pvani->_pNode->Element()
                                                &&  pvani->_pFF->_fShouldHaveLayout)
                                                ? pvani->_pNode->Element()
                                                : NULL;

                    TestForTransitionToOrFromRelativeChunk(_cpStart + _li._cch - pvaoi->_cch, 
                        pvani->_pCF->IsRelative(SameScope(pvani->_pNode, _pFlowLayout->ElementOwner())),
                        FALSE /*fForceChunk*/,
                        pvani->_pNode, pElementLayout);
                }
            }
        }
        else
        {
            //
            // Vertical aligment for this node has been completed.
            // 
            break;
        }
    }
Cleanup:
    // Clear ruby vertical align mode, if this node is not a ruby 
    // and has content or has explicit vertical align.
    if (   pvani->_fRubyVAMode 
        && (   (pvani->_fHasContent && !pvani->_pCF->_fIsRuby)
            || pvani->_pFF->HasCSSVerticalAlign()))
    {
        pvani->_fRubyVAMode = FALSE;
    }

    return TRUE;
}

//-------------------------------------------------------------------------
//
//  Member:     VerticalAlignOneObject
//
//  Synopsis:   VAlign one object in a line.
//
//-------------------------------------------------------------------------
// TODO: (dmitryt, track bug 112319) Merge these two functions into one.
void
CLineServices::VerticalAlignOneObject(
    CLSMeasurer & lsme, 
    VAOINFO *pvaoi, 
    VANINFO *pvani)
{
    BOOL fAbsolute = pvani->_pNode->IsAbsolute();
    pvaoi->_fHasAbsSites |= !!fAbsolute;
    
    if (!(fAbsolute || pvani->_pNode->IsInlinedElement()))
        return;
    
    LONG yTopMargin,   yBottomMargin;
    LONG xLeftMargin,  xRightMargin;
    pvani->_pLayout->GetMarginInfo(_pci, &xLeftMargin, &yTopMargin, &xRightMargin, &yBottomMargin);

    // Do the horizontal positioning. We can do it either during
    // measuring or during vertical positioning. We arbitrarily
    // chose to do it during measuring.
    if (pvaoi->_fMeasuring && _lsMode == LSMODE_MEASURER)
    {
        LONG xPosOfCp;
        BOOL fSubtractWidthFromXProposed = FALSE;
        
        if (!fAbsolute || pvani->_pFF->_fAutoPositioned)
        {
            LONG lscp = (pvaoi->_cchPreChars == 0) ? pvaoi->_por->_lscpBase : LSCPFromCP(_cpStart + _li._cch - pvaoi->_cch);
            BOOL fRTLDisplay = _pFlowLayout->IsRTLFlowLayout();
            BOOL fRTLFlow = fRTLDisplay;
            
            //
            // If editable, then the char at the above computed lscp
            // might be the glyph for that layout rather than the layout
            // itself. To do this right, we need to we need to find the
            // run at that lscp, and if it is a glyph-synthetic run then
            // we need to go to the next run which contains the nested
            // layout and look at its lscp.
            //
            if (_fIsEditable && !fAbsolute)
            {
                COneRun *por = FindOneRun(lscp);
                if (   por
                    && por->IsSyntheticRun()
                    && por->_synthType == SYNTHTYPE_GLYPH
                   )
                {
                    por = por->_pNext;

                    //
                    // Check that this run exists, and has nested layout
                    // and that the nested layout is indeed the one we
                    // are hunting for.
                    //
                    Assert(por);
                    Assert(por->_fCharsForNestedElement);
                    Assert(por->_fCharsForNestedLayout);
                    Assert(por->_ptp->Branch() == pvani->_pNode);
                    lscp = por->_lscpBase;
                }
            }

            xPosOfCp = _li._fCanBlastToScreen ? pvaoi->_xWidthSoFar : CalculateXPositionOfLSCP(lscp, FALSE, &fRTLFlow);
#if DBG==1
            {
                BOOL fRTLFlowDbg = fRTLDisplay;
                Assert(xPosOfCp == CalculateXPositionOfLSCP(lscp, FALSE, &fRTLFlowDbg));
                Assert(fRTLFlow == fRTLFlowDbg);
            }
#endif

            if ((!!_li._fRTLLn) != fRTLFlow)
            {
                // Postpone flow adjustment for absolute objects. Their size is not calculated yet.
                if (fAbsolute)
                {
                    fSubtractWidthFromXProposed = TRUE; 
                }
                else
                {
                    long xObjectWidth = pvani->_pLayout->GetApparentWidth();
                    xPosOfCp -= xObjectWidth;
                }
            }

            if (pvani->_pCF->HasCharGrid(FALSE))
            {
                long xWidth;
                _pFlowLayout->GetSiteWidth(pvani->_pLayout, _pci, FALSE, _xWidthMaxAvail, &xWidth);
                xPosOfCp += (GetClosestGridMultiple(GetCharGridSize(), xWidth) - xWidth)/2;
            }

            // absolute margins are added in CLayout::HandlePositionRequest
            // due to reverse flow issues.
            if (!fAbsolute)
            {
                if (!_li._fRTLLn)
                    xPosOfCp += xLeftMargin;
                else
                    xPosOfCp += xRightMargin;
            }

            pvani->_pLayout->SetXProposed(xPosOfCp);
        }
        else
        {
            xPosOfCp = 0;
        }
        
        if (fAbsolute)
        {

            // fix for #3214, absolutely positioned sites with width auto
            // need to be measure once we know the line shift, since their
            // size depends on the xPosition in the line.

            // TODO RTL 112514: (dmitryt)
            //      This is the only place where we CalcSize absolutely positioned 
            //      objects that were on the current line. These objects were taken out during 
            //      normal MeasureLine pass, because they don't participate in line width. 
            //      Now we want to measure them. When this function will be called for 
            //      positioning pass (pvaoi->fPositioning==true) we will add/position their 
            //      dispnodes accordingly. So here is the main place where we measure/position 
            //      abspos objects.
            //      I think the comment for bug 3214 was intended for abspos'ed objects without
            //      horizontal position specified. Those have left=(x-position-of-their-cp-in-the-line).
            long xWidth;
            _pMeasurer->GetSiteWidth(pvani->_pNode, pvani->_pLayout, _pci, TRUE, _xWidthMaxAvail, &xWidth );

            // Subtract object width from XProposed if needed, now that we know the width
            if (fSubtractWidthFromXProposed)
            {
                xPosOfCp -= xWidth;
                pvani->_pLayout->SetXProposed(xPosOfCp);
            }
        }
    }

    if (!fAbsolute)
    {
        Assert(pvaoi->_cchPreChars == 0);

        LONG lBorderSpace;

        if (pvani->_pNode->Tag() == ETAG_HR)
            lBorderSpace = GRABSIZE;
        else
            // Netscape has a pixel descent and ascent to the line if one of the sites
            // spans the entire line vertically(#20029, #25534).
            lBorderSpace = pvani->_pNode->Element()->TestClassFlag(CElement::ELEMENTDESC_VPADDING) ? 1 : 0;

        if (pvaoi->_fMeasuring)
        {
            CSize size;
            pvani->_pLayout->GetApparentSize(&size);
            pvaoi->_por->_yObjHeight = max(0L, size.cy + yTopMargin + yBottomMargin)+ (2 * lBorderSpace);

            if (pvani->_pCF->_fIsRubyText)
            {
                RubyInfo *pRubyInfo = GetRubyInfoFromCp(pvani->_pNode->Element()->GetFirstCp());
                if (pRubyInfo)
                {
                    pvaoi->_por->_yObjHeight += pRubyInfo->yHeightRubyBase - pvani->_yTxtDescent + pRubyInfo->yDescentRubyText;
                }                        
            }
 
            LONG lDefDescent = 0;
            if (pvani->_pNode->Element()->TestClassFlag(CElement::ELEMENTDESC_HASDEFDESCENT))
            {
                lDefDescent = pvani->_yTxtDescent;
            }
            else if (!pvani->_pFF->_fLayoutFlowChanged)    // Do not adjust layout's descent if flow has been changed
            {
                lDefDescent = pvani->_pLayout->GetDescent();
            }

            // Override default ascent/descent (from font properties)
            pvani->_yDescent = lBorderSpace + lDefDescent + yBottomMargin;
            pvani->_yAscent  = pvaoi->_por->_yObjHeight - pvani->_yDescent;
        }
        else
        {
            pvaoi->_por->_yProposed  = pvani->_yProposed + (pvani->_yAscent + pvani->_yDescent - pvaoi->_por->_yObjHeight) / 2;
            pvaoi->_por->_yProposed += lBorderSpace + yTopMargin;
            pvaoi->_por->_yProposed += _li._cyTopBordPad;
            pvani->_pLayout->SetYProposed(pvaoi->_por->_yProposed - min((LONG)0, (LONG)_li._yHeightTopOff));
        }
    }

    //
    // If positioning, add the current layout to the display tree
    //
    if (   !pvaoi->_fMeasuring
        &&  _lsMode == LSMODE_MEASURER
        && !pvani->_pNode->IsAligned()
        && _pci->IsNaturalMode()
       )
    {
        long dx;
        if (!_pFlowLayout->IsRTLFlowLayout())
            dx = _pMarginInfo->_xLeftMargin + _li._xLeft;
        else
        {
            dx = - _pMarginInfo->_xRightMargin - _li._xRight;
        }

        long xPos;
        if (!_li.IsRTLLine())
            xPos = dx + pvani->_pLayout->GetXProposed();
        else
            xPos = dx + _pFlowLayout->GetContainerWidth() 
                 - pvani->_pLayout->GetXProposed() - pvani->_pLayout->GetApparentWidth();


        if (   (    !pvani->_pFF->_fPositioned
                ||  (   _pFlowLayout->ElementOwner()->HasSlavePtr()
                            // Non CSS1 compatible slave markup
                     && (   (   pvani->_pNode->Tag() == ETAG_BODY
                             && !pvani->_pNode->GetMarkup()->IsHtmlLayout()
                            )
                            // CSS1 compatible slave markup
                         || (   pvani->_pNode->Tag() == ETAG_HTML
                             && pvani->_pNode->GetMarkup()->IsHtmlLayout()
                            )
                        )
                    )
               )
            && !pvani->_pCF->_fRelative
            )
        {
            // we are not using GetYTop for to get the offset of the line because
            // the before space is not added to the height yet.
            lsme._pDispNodePrev = _pFlowLayout->AddLayoutDispNode(
                            _pci,
                            pvani->_pNode,
                            xPos,
                            lsme._yli 
                                + _li._yBeforeSpace 
                                + _li._yHeightTopOff
                                + pvani->_pLayout->GetYProposed(),
                            lsme._pDispNodePrev);
        }
        else
        {
            //
            // If top and bottom or left and right are "auto", position the object
            //
            if (fAbsolute)
                pvani->_pLayout->SetYProposed(lsme._cyTopBordPad);

            CPoint ptAuto(xPos,
                          lsme._yli + _li._yBeforeSpace + _li._yHeightTopOff +
                          pvani->_pLayout->GetYProposed());

            pvani->_pNode->Element()->RepositionElement(0, &ptAuto, _pci->GetLayoutContext());
        }
    }
    
    if (!fAbsolute)
    {
        CSize size;
        pvani->_pLayout->GetApparentSize(&size);
        pvaoi->_xWidthSoFar += size.cx;
    }

    return;
}

//-----------------------------------------------------------------------------
//
//  Member:     CLineServices::GetRubyInfoFromCp(LONG cpRubyText)
//
//  Synopsis:   Linearly searches through the list of ruby infos and
//              returns the info of the ruby object that contains the given
//              cp.  Note that this function should only be called with a
//              cp that corresponds to a position within Ruby pronunciation
//              text.
//
//              NOTE (t-ramar): this code does not take advantage of
//              the fact that this array is sorted by cp, but it does depend 
//              on this fact.  This may be a problem because the entries in this 
//              array are appended in the FetchRubyPosition Line Services callback.
//
//-----------------------------------------------------------------------------

RubyInfo *
CLineServices::GetRubyInfoFromCp(LONG cpRubyText)
{
    RubyInfo *pRubyInfo = NULL;
    int i;

    if((RubyInfo *)_aryRubyInfo == NULL)
        goto Cleanup;

    for (i = 0; i < _aryRubyInfo.Size(); i++)
    {
        if (_aryRubyInfo[i].cp > cpRubyText)
            break;
    }
    pRubyInfo = (i==0) ? NULL : &_aryRubyInfo[i-1];
    
    // if this assert fails, chances are that the cp isn't doesn't correspond
    // to a position within some ruby pronunciation text
    Assert(!pRubyInfo || pRubyInfo >= (RubyInfo *)_aryRubyInfo);

Cleanup:
    return pRubyInfo;
}


//-----------------------------------------------------------------------------
//
//  Member:     CLSMeasurer::AdjustLineHeight()
//
//  Synopsis:   Adjust for space before/after and line spacing rules.
//
//-----------------------------------------------------------------------------
void
CLineServices::AdjustLineHeight()
{
    // This had better be true.
    Assert (_li._yHeight >= 0);

    // Need to remember these for hit testing.
    _li._yExtent = _li._yHeight;

    // We remember the original natural descent of the line here since
    // it could be modified if there was a CSS height specified. We
    // need the original descent to compute the extent of the line
    // if it has MBP.
    _yOriginalDescent = _li._yDescent;
            
    // Only do this if there is a line height used somewhere.
    if (_lMaxLineHeight != LONG_MIN && _fFoundLineHeight)
    {
        LONG delta = _lMaxLineHeight - _li._yHeight;
        LONG yDescentIncr = delta / 2;
        
        _li._yHeightTopOff = delta - yDescentIncr;
        _li._yDescent += yDescentIncr;
        _li._yHeight = _lMaxLineHeight;
    }
    else
    {
        _li._yHeightTopOff = 0;
    }

    // Now, if there is any MBP take care of that -- MBP's increase
    // the extent of the line rather than change the height as was
    // in the previous case.
    if (_fHasMBP)
    {
        AdjustLineHeightForMBP();
    }
}

//-----------------------------------------------------------------------------
//
// Member:      CLineServices::MeasureLineShift (fZeroLengthLine)
//
// Synopsis:    Computes and returns the line x shift due to alignment
//
//-----------------------------------------------------------------------------
LONG
CLineServices::MeasureLineShift(LONG cp, LONG xWidthMax, BOOL fMinMax, LONG * pdxRemainder)
{
    long    xShift;
    UINT    uJustified;

    Assert(_li._fRTLLn == (unsigned)_pPFFirstPhysical->HasRTL(_fInnerPFFirstPhysical));

    xShift = ComputeLineShift(
                        (htmlAlign)_pPFFirstPhysical->GetBlockAlign(_fInnerPFFirstPhysical),
                        _pFlowLayout->IsRTLFlowLayout(),
                        _li._fRTLLn,
                        fMinMax,
                        xWidthMax,
                        _li.CalcLineWidth(),
                        &uJustified,
                        pdxRemainder);
    _li._fJustified = uJustified;
    return xShift;
}

//-----------------------------------------------------------------------------
//
// Member:      CalculateXPositionOfLSCP
//
// Synopsis:    Calculates the X position for LSCP
//
//-----------------------------------------------------------------------------

LONG
CLineServices::CalculateXPositionOfLSCP(
    LSCP lscp,          // LSCP to return the position of.
    BOOL fAfterPrevCp,  // Return the trailing point of the previous LSCP (for an ambigous bidi cp)
    BOOL* pfRTLFlow)    // Flow direction of LSCP.
{
    LSTEXTCELL lsTextCell;
    HRESULT hr;
    BOOL fRTLFlow = FALSE;
    BOOL fUsePrevLSCP = FALSE;
    LONG xRet;

    if (fAfterPrevCp && _pBidiLine != NULL)
    {
        LSCP lscpPrev = FindPrevLSCP(lscp, &fUsePrevLSCP);
        if (fUsePrevLSCP)
        {
            lscp = lscpPrev;
        }
    }

    hr = THR( QueryLineCpPpoint(lscp, FALSE, NULL, &lsTextCell, &fRTLFlow ) );

    if(pfRTLFlow)
        *pfRTLFlow = fRTLFlow;

    xRet = lsTextCell.pointUvStartCell.u;

    // If we're querying for a character which cannot be measured (e.g. a
    // section break char), then LS returns the last character it could
    // measure.  To get the x-position, we add the width of this character.

    if (S_OK == hr && (lsTextCell.cpEndCell < lscp || fUsePrevLSCP))
    {
        if(fRTLFlow == _li.IsRTLLine())
            xRet += lsTextCell.dupCell;
        else
        {
            xRet -= lsTextCell.dupCell;
            //
            // What is happening here is that we are being positioned at say pixel
            // pos 10 (xRet=10) and are asked to draw reverese a character which is
            // 11 px wide. So we would then draw at px10, at px9 ... and finally at
            // px 0 -- for at grand total of 11 px. Having drawn at 0, we would be
            // put back at -1. While the going back by 1px is correct, at the BOL
            // this will put us at -1, which is unaccepatble and hence the max with 0.
            //
            xRet = max(0L, xRet);
        }
    }
    else if (hr == S_OK && lsTextCell.cCharsInCell > 1 &&
             lscp > lsTextCell.cpStartCell)
    {
        long lClusterAdjust = MulDivQuick(lscp - lsTextCell.cpStartCell,
                                          lsTextCell.dupCell, lsTextCell.cCharsInCell);
        // we have multiple cps mapped to one glyph. This simply places the caret
        // a percentage of space between beginning and end
        if(fRTLFlow == _li.IsRTLLine())
            xRet += lClusterAdjust;
        else
        {
            xRet -= lClusterAdjust;
        }
    }

    return hr ? 0 : xRet;
}

//+----------------------------------------------------------------------------
//
// Member:      CLineServices::CalcPositionsOfRangeOnLine
//
// Synopsis:    Find the position of a stretch of text starting at cpStart and
//              and running to cpEnd, inclusive. The text may be broken into
//              multiple rects if the line has reverse objects (runs with
//              mixed directionallity) in it.
//
// Returns:     The number of chunks in the range. Usually this will just be
//              one. If an error occurs it will be zero. The actual width of
//              text (in device units) is returned in paryChunks as rects from
//              the beginning of the line. The top and bottom entries of each
//              rect will be 0. No assumptions should be made about the order
//              of the rects; the first rect may or may not be the leftmost or
//              rightmost.
//
//-----------------------------------------------------------------------------
LONG
CLineServices::CalcPositionsOfRangeOnLine(
    LONG cpStart,
    LONG cpEnd,
    LONG xShift,
    CDataAry<CChunk> * paryChunks,
    DWORD dwFlags)
{
    CStackDataAry<LSQSUBINFO, 4> aryLsqsubinfo(Mt(CLineServicesCalculatePositionsOfRangeOnLine_aryLsqsubinfo_pv));
    LSTEXTCELL lsTextCell;
    COneRun *porLast;
    LSCP lscpStart = LSCPFromCP(max(cpStart, _cpStart));
    LSCP lscpEnd = LSCPFromCPCore(cpEnd, &porLast);
    HRESULT hr;
    BOOL fSublineReverseFlow = FALSE;
    LONG xStart;
    LONG xEnd;
    CChunk rcChunk;
    LONG i;
    LSTFLOW tflow = (!_li._fRTLLn ? lstflowES : lstflowWS);
    BOOL fSelection = ((dwFlags  & RFE_SELECTION) == RFE_SELECTION);
    
    Assert(paryChunks != NULL && paryChunks->Size() == 0);
    Assert(cpStart <= cpEnd);

    if (fSelection)
    {
        if (porLast && porLast->IsSyntheticRun())
            lscpEnd++;
    }
    
    rcChunk.top = rcChunk.bottom = 0;

    aryLsqsubinfo.Grow(4); // Guaranteed to succeed since we're working from the stack.

    hr = THR(QueryLineCpPpoint(lscpStart, FALSE, &aryLsqsubinfo, &lsTextCell, FALSE));

    xStart = lsTextCell.pointUvStartCell.u;

    for (i = aryLsqsubinfo.Size() - 1; i >= 0; i--)
    {
        const LSQSUBINFO &qsubinfo = aryLsqsubinfo[i];
        const LSQSUBINFO &qsubinfoParent = aryLsqsubinfo[max((LONG)(i - 1), 0L)];

        if (lscpEnd < (LSCP) (qsubinfo.cpFirstSubline + qsubinfo.dcpSubline))
        {
            // lscpEnd is in this subline. Break out.
            break;
        }

        // If the subline and its parent are going in different directions
        // stuff the current range into the chunk array and move xStart to
        // the "end" (relative to the parent) of the current subline.
        if ((qsubinfo.lstflowSubline & fUDirection) !=
            (qsubinfoParent.lstflowSubline & fUDirection))
        {
            // Append the start of the chunk to the chunk array.
            rcChunk.left = xShift + xStart;

            fSublineReverseFlow = !!((qsubinfo.lstflowSubline ^ tflow) & fUDirection);

            // Append the end of the chunk to the chunk array.
            // If the subline flow doesn't match the line direction then we're
            // moving against the flow of the line and we will subtract the
            // subline width from the subline start to find the end point.
            rcChunk.right = xShift + qsubinfo.pointUvStartSubline.u + (fSublineReverseFlow ?
                            -qsubinfo.dupSubline : qsubinfo.dupSubline);

            // do some reverse flow cleanup before inserting rect into the array
            if(rcChunk.left > rcChunk.right)
            {
                Assert(fSublineReverseFlow);
                long temp = rcChunk.left;
                rcChunk.left = rcChunk.right + 1;
                rcChunk.right = temp + 1;
            }

            paryChunks->AppendIndirect(&rcChunk);

            xStart = qsubinfo.pointUvStartSubline.u + (fSublineReverseFlow ? 1 : -1);
        }
    }

    aryLsqsubinfo.Grow(4); // Guaranteed to succeed since we're working from the stack.

    hr = THR(QueryLineCpPpoint(lscpEnd, FALSE, &aryLsqsubinfo, &lsTextCell, FALSE));

    xEnd = lsTextCell.pointUvStartCell.u;
    if(lscpEnd <= lsTextCell.cpEndCell && lsTextCell.cCharsInCell > 1 ||
       lscpEnd > lsTextCell.cpEndCell)
    {
        xEnd += ((aryLsqsubinfo.Size() == 0 ||
                  !((aryLsqsubinfo[aryLsqsubinfo.Size() - 1].lstflowSubline ^ tflow) & fUDirection)) ?
                  lsTextCell.dupCell : -lsTextCell.dupCell );
    }

    for (i = aryLsqsubinfo.Size() - 1; i >= 0; i--)
    {
        const LSQSUBINFO &qsubinfo = aryLsqsubinfo[i];
        const LSQSUBINFO &qsubinfoParent = aryLsqsubinfo[max((LONG)(i - 1), 0L)];

        if (lscpStart >= qsubinfo.cpFirstSubline)
        {
            // lscpStart is in this subline. Break out.
            break;
        }

        // If the subline and its parent are going in different directions
        // stuff the current range into the chunk array and move xEnd to
        // the "start" (relative to the parent) of the current subline.
        if ((qsubinfo.lstflowSubline & fUDirection) !=
            (qsubinfoParent.lstflowSubline & fUDirection))
        {
            fSublineReverseFlow = !!((qsubinfo.lstflowSubline ^ tflow) & fUDirection);

            if (xEnd != qsubinfo.pointUvStartSubline.u)
            {
                // Append the start of the chunk to the chunk array.
                rcChunk.left = xShift + qsubinfo.pointUvStartSubline.u;
 
                // Append the end of the chunk to the chunk array.
                rcChunk.right = xShift + xEnd;

                // do some reverse flow cleanup before inserting rect into the array
                if(rcChunk.left > rcChunk.right)
                {
                    Assert(fSublineReverseFlow);
                    long temp = rcChunk.left;
                    rcChunk.left = rcChunk.right + 1;
                    rcChunk.right = temp + 1;
                }

                paryChunks->AppendIndirect(&rcChunk);
            }

            // If the subline flow doesn't match the line direction then we're
            // moving against the flow of the line and we will subtract the
            // subline width from the subline start to find the end point.
            xEnd = qsubinfo.pointUvStartSubline.u +
                   (fSublineReverseFlow ? -(qsubinfo.dupSubline - 1) : (qsubinfo.dupSubline - 1));
        }
    }

    rcChunk.left = xShift + xStart;
    rcChunk.right = xShift + xEnd;
    // do some reverse flow cleanup before inserting rect into the array
    if(rcChunk.left > rcChunk.right)
    {
        long temp = rcChunk.left;
        rcChunk.left = rcChunk.right + 1;
        rcChunk.right = temp + 1;
    }
    paryChunks->AppendIndirect(&rcChunk);

    return paryChunks->Size();
}


//+----------------------------------------------------------------------------
//
// Member:      CLineServices::CalcRectsOfRangeOnLine
//
// Synopsis:    Find the position of a stretch of text starting at cpStart and
//              and running to cpEnd, inclusive. The text may be broken into
//              multiple runs if different font sizes or styles are used, or there
//              is mixed directionallity in it.
//
// Returns:     The number of chunks in the range. Usually this will just be
//              one. If an error occurs it will be zero. The actual width of
//              text (in device units) is returned in paryChunks as rects of
//              offsets from the beginning of the line. 
//              No assumptions should be made about the order of the chunks;
//              the first chunk may or may not be the chunk which includes
//              cpStart.
//
//              Returned coordinates are LOGICAL (from the right in RTL line).
//
//-----------------------------------------------------------------------------
LONG
CLineServices::CalcRectsOfRangeOnLine(
    LSCP lscpRunStart,
    LSCP lscpEnd,
    LONG xShift,
    LONG yPos,
    CDataAry<CChunk> * paryChunks,
    DWORD dwFlags,
    LONG curTopBorder,
    LONG curBottomBorder)
{
    CStackDataAry<LSQSUBINFO, 4> aryLsqsubinfo(Mt(CLineServicesCalculateRectsOfRangeOnLine_aryLsqsubinfo_pv));
    HRESULT hr;
    LSTEXTCELL lsTextCell = {0}; // keep compiler happy
    BOOL fSublineReverseFlow;
    LSTFLOW tflow = (!_li._fRTLLn ? lstflowES : lstflowWS);
    LONG xStart;
    LONG xEnd;
    LONG yTop = 0;
    LONG yBottom = 0;
    LONG topBorder = 0;
    LONG bottomBorder = 0;
    LONG leftBorder = 0;
    LONG rightBorder = 0;
    CChunk rcChunk;
    CChunk rcLast;
    COneRun * porCurrent = _listCurrent._pHead;
    BOOL fIncludeBorders = (dwFlags & RFE_INCLUDE_BORDERS) ? TRUE : FALSE;
    BOOL fWigglyRects = (dwFlags & RFE_WIGGLY_RECTS) ? TRUE : FALSE;
    BOOL fOnlyOnce = fIncludeBorders && (lscpRunStart == lscpEnd);
    CTreeNode *pNodeStart;
    BOOL fSelection = ((dwFlags & RFE_SELECTION) == RFE_SELECTION);
    BOOL fForSynthetic = FALSE;

    // It may happen if the only thing in the line is <BR>
    if (lscpRunStart == lscpEnd)
        return paryChunks->Size();

    // we should never come in here with an LSCP that is in the middle of a COneRun. Those types (for selection)
    // should go through CalcPositionsOfRangeOnLine.
    
    // move quickly to the por that has the right lscpstart
    while(porCurrent->_lscpBase < lscpRunStart)
    {
        porCurrent = porCurrent->_pNext;

        // If we assert here, something is messed up. Please investigate
        Assert(porCurrent != NULL);
        // if we reached the end of the list we need to bail out.
        if(porCurrent == NULL)
            return paryChunks->Size();
    }

    // Save the node from the first one run
    pNodeStart = porCurrent->Branch();

    // for selection we want to start highlight invalidation at beginning of the run
    // to avoid vertical line turds with RTL text.
    if (fSelection)
        lscpRunStart = porCurrent->_lscpBase;

    Assert(paryChunks != NULL && paryChunks->Size() == 0);
    Assert(lscpRunStart <= lscpEnd);

    while(   fOnlyOnce
          || lscpRunStart < lscpEnd)
    {
        // if we reached the end of the list we need to bail out.
        if (porCurrent == NULL)
            break;

        if (porCurrent->_fHidden)
        {
            lscpRunStart = porCurrent->_lscpBase + porCurrent->_lscch;
            goto Next;
        }

        // Do not draw the selection around the \r inside a pre (bug 84801.htm)
        if (   _fScanForCR
            && 1 == porCurrent->_lscch
            && WCH_SYNTHETICLINEBREAK == *porCurrent->_pchBase
            && _li._fHasBreak
           )
        {
            goto Next;
        }
        
        switch(porCurrent->_fType)
        {
Normal:
        case COneRun::OR_NORMAL:
            {
                if (rcChunk != g_Zero.rc)
                {
                    Assert(leftBorder >= 0);
                    Assert(rightBorder >= 0);

                    rcChunk.left  -= leftBorder;
                    rcChunk.right += rightBorder;
                    rightBorder = leftBorder = 0;

                    // do some reverse flow cleanup before inserting rect into the array
                    if(rcChunk.left > rcChunk.right)
                    {
                        long temp = rcChunk.left;
                        rcChunk.left = rcChunk.right + 1;
                        rcChunk.right = temp + 1;
                    }

                    // In the event we have <A href="x"><B>text</B></A> we get two runs of
                    // the same rect. One for the Anchor and one for the bold. These two
                    // rects will xor themselves when drawing the wiggly and look like they
                    // did not select. This patch resolves this issue for the time being.
                    if (rcChunk != rcLast)
                    {
                        paryChunks->AppendIndirect(&rcChunk);
                        rcLast = rcChunk;
                    }
                    rcChunk.SetRectEmpty();
                }

                fOnlyOnce = FALSE;

                aryLsqsubinfo.Grow(4); // Guaranteed to succeed since we're working from the stack.

                // 1. If we failed, return what we have so far
                // 2. If LS returns less than the cell we have asked for we have situation
                //    where one glyph (2 or more characters) is split between separate runs.
                //    That usually happens during selection or drag & drop.
                //    To solve this problem we will go to the next cp in this run and try again.
                //    If we are out of characters in this run we go to the next COneRun and 
                //    try again.
                BOOL fContinueQuery = TRUE;
                hr = S_OK;  // to make compiler happy
                while (fContinueQuery)
                {
                    hr = THR(QueryLineCpPpoint(lscpRunStart, FALSE, &aryLsqsubinfo, &lsTextCell, FALSE));

                    if(hr || lsTextCell.cpStartCell < lscpRunStart)
                    {
                        ++lscpRunStart;
                        fContinueQuery = (lscpRunStart < porCurrent->_lscpBase + porCurrent->_lscch);
                    }
                    else
                    {
                        fContinueQuery = FALSE;
                    }
                }
                if(hr || lsTextCell.cpStartCell < lscpRunStart)
                {
                    lscpRunStart = porCurrent->_lscpBase + porCurrent->_lscch;
                    break;
                }

                long  nDepth = aryLsqsubinfo.Size() - 1;
                Assert(nDepth >= 0);
                const LSQSUBINFO &qsubinfo = aryLsqsubinfo[nDepth];
                WHEN_DBG( DWORD dwIDObj = qsubinfo.idobj );
                long lAscent = qsubinfo.heightsPresRun.dvAscent;
                long lDescent = fIncludeBorders
                                ? qsubinfo.heightsPresRun.dvDescent
                                : _pMeasurer->_li._yDescent;

                // now set the end position based on which way the subline flows
                fSublineReverseFlow = !!((qsubinfo.lstflowSubline ^ tflow) & fUDirection);

                xStart = lsTextCell.pointUvStartCell.u;

                // If we're querying for a character which cannot be measured (e.g. a
                // section break char), then LS returns the last character it could
                // measure. Therefore, if we are okay, use dupRun for the distance.
                // Otherwise, query the last character of porCurrent. This prevents us
                // having to loop when LS creates dobj's that are cch of five (5).
                if((LSCP)(porCurrent->_lscpBase + porCurrent->_lscch) <= (LSCP)(qsubinfo.cpFirstRun + qsubinfo.dcpRun))
                {
                    xEnd = xStart + (!fSublineReverseFlow
                                     ? qsubinfo.dupRun
                                     : -qsubinfo.dupRun);
                }
                else
                {
                    aryLsqsubinfo.Grow(4); // Guaranteed to succeed since we're working from the stack.
                    long lscpLast = min(lscpRunStart + porCurrent->_lscch, _lscpLim);

                    hr = THR(QueryLineCpPpoint(lscpLast, FALSE, &aryLsqsubinfo, &lsTextCell, FALSE));

                    // If LS returns the cell before than the cell we have asked for we have situation where:
                    // 1) we have queried on lscp pointing on a synthetic run
                    // 2) we have queried on lscp pointing on certain characters, like hyphen
                    // In this case add/subtract the width of the last cell given.
                    xEnd = lsTextCell.pointUvStartCell.u;
                    if (lsTextCell.cpStartCell < lscpLast)
                    {
                        if (fSublineReverseFlow)
                            xEnd -= lsTextCell.dupCell;
                        else
                            xEnd += lsTextCell.dupCell;
                    }
                }

                if (   fIncludeBorders
                    && _li._xWhite
                   )
                {
                    // If we are indeed the last run which contributes to the background
                    // color only then should we consider removing the whitespace from the background.
                    // To find that out, walk the list to verify that we are indeed the last
                    // *visible* run on the line.
                    COneRun *porTemp = porCurrent->_pNext;
                    LONG xWhiteToRemove = _li._xWhite;
                    while (   porTemp
                           && porTemp->_lscpBase < _lscpLim
                          )
                    {
                        if (    porTemp->_pchBase 
                            && *porTemp->_pchBase == WCH_SYNTHETICLINEBREAK
                           )
                        {
                            xWhiteToRemove -= porTemp->_xWidth;
                        }
                        else if (porTemp->IsNormalRun())
                        {
                            xWhiteToRemove = 0;
                            break;
                        }
                        porTemp = porTemp->_pNext;
                    }

                    // OK, so we have some white space which we will remove, but do not
                    // do so until and unless our parent block element does not have borders on it
                    // or it has borders, but is a layout, since if its a layout, we will
                    // not be able to write on its border in anycase!
                    if (xWhiteToRemove)
                    {
                        CTreeNode *pNode = _pMarkup->SearchBranchForBlockElement(pNodeStart);
                        if (pNode)
                        {
                            CElement *pElement = pNode->Element();
                            if (!pElement->_fDefinitelyNoBorders)
                            {
                                CBorderInfo borderinfo;
                                pElement->_fDefinitelyNoBorders = !GetBorderInfoHelper(pNode, _pci, &borderinfo, GBIH_NONE);
                            }
                            if (   pNode->ShouldHaveLayout()
                                || pElement->_fDefinitelyNoBorders
                               )
                            {
                                xWhiteToRemove = 0;
                            }
                        }
                    }
                    xEnd -= xWhiteToRemove;

                    // in reverse flow or RTL line, xStart and xEnd may be reversed
                    if (xStart > xEnd)
                    {
                        LONG xTemp = xStart; xStart = xEnd+1; xEnd = xTemp+1;
                    }
                }

                // get the top and bottom for the rect
                if(porCurrent->_fCharsForNestedLayout)
                {
// NOTICE: Absolutely positioned, aligned, and Bold elements are ONERUN_ANTISYNTH types. See note below
                    Assert(dwIDObj == LSOBJID_EMBEDDED);
            
                    CTreeNode *pNodeCur = porCurrent->_ptp->Branch();

                    //
                    // HACK ALERT!!!!!
                    // We do NOT paint selection backgrounds for tables (bug 84820)
                    //
                    if (   fSelection
                        && pNodeCur->Tag() == ETAG_TABLE
                       )
                    {
                        xEnd = xStart;
                    }
                    else
                    {
                        RECT rc;
                        long cyHeight;
                        const CCharFormat* pCF = porCurrent->GetCF();
                        CLayout *pLayout = pNodeCur->GetUpdatedLayout( _pci->GetLayoutContext() );

                        pLayout->GetRect(&rc, COORDSYS_TRANSFORMED);

                        cyHeight = rc.bottom - rc.top;

                        // XProposed and YProposed have been set to the amount of margin
                        // the layout has.                
                        xStart = pLayout->GetXProposed();
                        xEnd = xStart + (rc.right - rc.left);

                        yTop = yPos + pLayout->GetYProposed() + _pMeasurer->_li._yHeightTopOff + _pMeasurer->_li._yBeforeSpace;
                        yBottom = yTop + cyHeight;

                        // take care of any nested relatively positioned elements
                        if(   pCF->_fRelative 
                           && (dwFlags & RFE_NESTED_REL_RECTS))
                        {
                            long xRelLeft = 0, yRelTop = 0;

                            // get the layout's relative positioning to its parent. The parent's relative
                            // positioning would be adjusted in RegionFromElement
                            CTreeNode * pNodeParent = pNodeCur->Parent();
                            if(pNodeParent)
                            {
                                pNodeCur->GetRelTopLeft(pNodeParent->Element(), _pci, &xRelLeft, &yRelTop);
                            }

                            xStart += xRelLeft;
                            xEnd += xRelLeft;
                            yTop += yRelTop;
                            yBottom += yRelTop;
                        }
                    }
                }
                else
                {
                    Assert(dwIDObj == LSOBJID_TEXT || dwIDObj == LSOBJID_GLYPH || fForSynthetic);
                    const CCharFormat* pCF = porCurrent->GetCF();

                    if (porCurrent->_fIsBRRun)
                    {
                        if (fSelection)
                        {
                            if (lAscent == 0)
                            {
                                CCcs ccs;
                                if (GetCcs(&ccs, porCurrent, _pci->_hdc, _pci))
                                {
                                    const CBaseCcs *pBaseCcs = ccs.GetBaseCcs();
                                    lAscent = pBaseCcs->_yHeight - pBaseCcs->_yDescent;
                                }
                            }
                        }
                        else
                        {
                            lscpRunStart = porCurrent->_lscpBase + porCurrent->_lscch;
                            break;
                        }
                    }
                    // The current character does not have height. Throw it out.
                    else if(lAscent == 0 && !fForSynthetic)
                    {
                        lscpRunStart = porCurrent->_lscpBase + porCurrent->_lscch;
                        break;
                    }
                    
                    fForSynthetic = FALSE;

                    if (_fHasVerticalAlign)
                    {
                        yTop = yPos + porCurrent->_yProposed;
                        yBottom = yTop + porCurrent->_yObjHeight;
                    }
                    else
                    {
                        if (fSelection)
                        {
                            yBottom = yPos + _pMeasurer->_li.GetYBottom();
                            yTop = yPos + _pMeasurer->_li.GetYTop();
                        }
                        else
                        {
                            yBottom = yPos + _pMeasurer->_li._yHeight 
                                      - _pMeasurer->_li._yDescent + lDescent;
                            yTop = yBottom - lDescent - lAscent;
                        }
                    }

                    // If we are ruby text, adjust the height to the correct position above the line.
                    if(pCF->_fIsRubyText)
                    {
                        RubyInfo *pRubyInfo = GetRubyInfoFromCp(porCurrent->_lscpBase);

                        if(pRubyInfo)
                        {
                            yBottom = yPos + _pMeasurer->_li._yHeight - _pMeasurer->_li._yDescent 
                                + pRubyInfo->yDescentRubyBase - pRubyInfo->yHeightRubyBase;
                            yTop = yBottom - pRubyInfo->yDescentRubyText - lAscent;
                        }
                    }
                }

                if (fIncludeBorders)
                {
                    topBorder = porCurrent->_mbpTop;
                    bottomBorder = porCurrent->_mbpBottom;
                }
                else
                {
                    topBorder = 0;
                    bottomBorder = 0;
                }
                
                rcChunk.left = xShift + xStart;
                rcChunk.top = yTop - topBorder + curTopBorder;
                rcChunk.bottom = yBottom + bottomBorder - curBottomBorder;
                rcChunk.right = xShift + xEnd;
                rcChunk._fReversedFlow = fSublineReverseFlow;

                lscpRunStart = porCurrent->_lscpBase + porCurrent->_lscch;
            }
            break;

        case COneRun::OR_SYNTHETIC:
        {
            if (fIncludeBorders)
            {
                if (porCurrent->_synthType == SYNTHTYPE_MBPOPEN)
                {
                    if (rcChunk != g_Zero.rc)
                    {
                        Assert(leftBorder >= 0);
                        Assert(rightBorder >= 0);

                        rcChunk.left  -= leftBorder;
                        rcChunk.right += rightBorder;
                        rightBorder = leftBorder = 0;

                        // do some reverse flow cleanup before inserting rect into the array
                        if(rcChunk.left > rcChunk.right)
                        {
                            long temp = rcChunk.left;
                            rcChunk.left = rcChunk.right + 1;
                            rcChunk.right = temp + 1;
                        }

                        // In the event we have <A href="x"><B>text</B></A> we get two runs of
                        // the same rect. One for the Anchor and one for the bold. These two
                        // rects will xor themselves when drawing the wiggly and look like they
                        // did not select. This patch resolves this issue for the time being.
                        if (rcChunk != rcLast)
                        {
                            paryChunks->AppendIndirect(&rcChunk);
                            rcLast = rcChunk;
                        }
                        rcChunk.SetRectEmpty();
                    }

                    CRect rcDimensions;
                    BOOL fIgnore;
                    DWORD dwFlags = GIMBPC_BORDERONLY | GIMBPC_PADDINGONLY;

                    // Ignore negative margins
                    porCurrent->GetInlineMBP(_pci, GIMBPC_MARGINONLY, &rcDimensions, &fIgnore, &fIgnore);
                    dwFlags |= (rcDimensions.left > 0) ? GIMBPC_MARGINONLY : 0;

                    porCurrent->GetInlineMBP(_pci, dwFlags, &rcDimensions, &fIgnore, &fIgnore);
                    leftBorder += rcDimensions.left;
                }
                else if (porCurrent->_synthType == SYNTHTYPE_MBPCLOSE)
                {
                    CRect rcDimensions;
                    BOOL fIgnore;
                    DWORD dwFlags = GIMBPC_BORDERONLY | GIMBPC_PADDINGONLY;

                    // Ignore negative margins
                    porCurrent->GetInlineMBP(_pci, GIMBPC_MARGINONLY, &rcDimensions, &fIgnore, &fIgnore);
                    dwFlags |= (rcDimensions.right > 0) ? GIMBPC_MARGINONLY : 0;

                    porCurrent->GetInlineMBP(_pci, dwFlags, &rcDimensions, &fIgnore, &fIgnore);
                    rightBorder += rcDimensions.right;
                }
            }

            const CLineServices::SYNTHDATA & synthdata = CLineServices::s_aSynthData[porCurrent->_synthType];

            if (   (   synthdata.idObj == idObjTextChp
                    && fSelection
                    && porCurrent->IsSelected()
                   )
                || (    fWigglyRects
                     && (   porCurrent->_synthType == SYNTHTYPE_MBPOPEN
                         || porCurrent->_synthType == SYNTHTYPE_MBPCLOSE
                        )
                   )
               )
            {
                fForSynthetic = TRUE;
                goto Normal;
            }

            // We want to set the lscpRunStart to move to the next start position
            // when dealing with synthetics (reverse objects, etc.)
            lscpRunStart = porCurrent->_lscpBase + porCurrent->_lscch;
            break;
        }
        
        case COneRun::OR_ANTISYNTHETIC:
            // NOTICE:
            // this case covers absolutely positioned elements and aligned elements
            // However, per BrendanD and SujalP, this is not the correct place
            // to implement focus rects for these elements. Some
            // work needs to be done to the CAdorner to properly 
            // handle absolutely positioned elements. RegionFromElement should handle
            // frames for aligned objects.
            break;

        default:
            Assert("Missing COneRun type");
            break;
        }

Next:
        porCurrent = porCurrent->_pNext;
    }

    if (rcChunk != g_Zero.rc)
    {
        // We need to include the borders in the rects that we return
        if (fIncludeBorders)
        {
            // Figure out the width of the right border
            if (lscpEnd != _lscpLim)
            {
                COneRun * por = FindOneRun(lscpEnd);

                // The end might actually be before the por found by FindOneRun.
                // To find the actual por, we will need to go to a COneRun object
                // which has the same pNode as the start and also the same lscp
                if (!SameScope(por->Branch(), pNodeStart))
                {
                    COneRun *porTemp = por->_pPrev;
                    while(   porTemp
                          && porTemp->_lscpBase == por->_lscpBase
                         )
                    {
                        if (SameScope(porTemp->Branch(), pNodeStart))
                        {
                            por = porTemp;
                            break;
                        }
                        porTemp = porTemp->_pPrev;
                    }
                    // If we did not find a por with the same lscp as por and
                    // the same node as pNodeStart, then we do not touch the por at all
                }

                while (por && (por->_lscpBase >= lscpEnd))
                {
                    if (    por->_synthType == CLineServices::SYNTHTYPE_MBPCLOSE
                        && !por->_fHidden)
                    {
                        CRect rcDimensions;
                        BOOL fIgnore;
                        DWORD dwFlags = GIMBPC_BORDERONLY | GIMBPC_PADDINGONLY;

                        // Ignore negative margins
                        por->GetInlineMBP(_pci, GIMBPC_MARGINONLY, &rcDimensions, &fIgnore, &fIgnore);
                        dwFlags |= (rcDimensions.right > 0) ? GIMBPC_MARGINONLY : 0;

                        por->GetInlineMBP(_pci, dwFlags, &rcDimensions, &fIgnore, &fIgnore);
                        rightBorder += rcDimensions.right;
                    }
                            
                    por = por->_pPrev;
                }

                Assert(rightBorder >= 0);
            }
        }

        // do some reverse flow cleanup before inserting rect into the array
        if (rcChunk.left > rcChunk.right)
        {
            long temp = rcChunk.left;
            rcChunk.left = rcChunk.right + 1;
            rcChunk.right = temp + 1;
        }

        Assert(leftBorder >= 0);
        Assert(rightBorder >= 0);

        rcChunk.left  -= leftBorder;
        rcChunk.right += rightBorder;
        rightBorder = leftBorder = 0;

        // In the event we have <A href="x"><B>text</B></A> we get two runs of
        // the same rect. One for the Anchor and one for the bold. These two
        // rects will xor themselves when drawing the wiggly and look like they
        // did not select. This patch resolves this issue for the time being.
        if (rcChunk != rcLast)
        {
            paryChunks->AppendIndirect(&rcChunk);
            rcLast = rcChunk;
        }
        rcChunk.SetRectEmpty();
    }

    return paryChunks->Size();
}

//-----------------------------------------------------------------------------
//
// Member:      CLineServices::RecalcLineHeight()
//
// Synopsis:    Reset the height of the the line we are measuring if the new
//              run of text is taller than the current maximum in the line.
//
//-----------------------------------------------------------------------------
void CLineServices::RecalcLineHeight(const CCharFormat *pCF, LONG cp, CCcs * pccs, CLineFull *pli)
{
    AssertSz(pli,  "we better have a line!");
    AssertSz(pccs, "we better have a some metric's here");

    if(pccs)
    {
        LONG yAscent;
        LONG yDescent;

        pccs->GetBaseCcs()->GetAscentDescent(&yAscent, &yDescent);

        if(yAscent < pli->_yHeight - pli->_yDescent)
            yAscent = pli->_yHeight - pli->_yDescent;
        if(yDescent > pli->_yDescent)
            pli->_yDescent = yDescent;

        pli->_yHeight        = yAscent + pli->_yDescent;

        Assert(pli->_yHeight >= 0);

        if (!pCF->_cuvLineHeight.IsNull())
        {
            const CUnitValue *pcuvUseThis = &pCF->_cuvLineHeight;
            long lFontHeight = 1;

            if (pcuvUseThis->GetUnitType() == CUnitValue::UNIT_FLOAT)
            {
                CUnitValue cuv;
                cuv = pCF->_cuvLineHeight;
                cuv.ScaleTo ( CUnitValue::UNIT_EM );
                pcuvUseThis = &cuv;
                lFontHeight = pCF->GetHeightInTwips( _pFlowLayout->Doc() );
            }
            NoteLineHeight(cp, pcuvUseThis->YGetPixelValue(_pci, 0, lFontHeight));
        }
    }
}


//-----------------------------------------------------------------------------
//
// Member:      TestFortransitionToOrFromRelativeChunk
//
// Synopsis:    Test if we are transitioning from a relative chunk to normal
//                chunk or viceversa
//
//-----------------------------------------------------------------------------
void
CLineServices::TestForTransitionToOrFromRelativeChunk(
    LONG cp,
    BOOL fRelative,
    BOOL fForceChunk,
    CTreeNode *pNode,
    CElement *pElementLayout)
{
    CTreeNode * pNodeRelative = NULL;
    BOOL fRTLFlow;
    LONG xPos = CalculateXPositionOfCp(cp, FALSE, &fRTLFlow);
    BOOL fDirectionChange = (!fRTLFlow != !_fLastChunkRTL);

    // Also force a chunk when direction changes
    if (fDirectionChange)
        fForceChunk = TRUE;

    // if the current line is relative and the chunk is not
    // relative or if the current line is not relative and the
    // the current chunk is relative then break out.
    if (fForceChunk || fRelative)
        pNodeRelative = pNode->GetCurrentRelativeNode(_pFlowLayout->ElementOwner());

    // note: this is the only caller of UpdateRelativeChunk
    if (fForceChunk || DifferentScope(_pElementLastRelative, pNodeRelative))
        UpdateRelativeChunk(cp, pNodeRelative->SafeElement(), pElementLayout, xPos /*logical*/, fRTLFlow);
}

//-----------------------------------------------------------------------------
//
// Member:        UpdateRelativeChunk
//
// Synopsis:    We have just transitioned from a relative chunk to normal chunk
//              or viceversa, or inbetween relative chunks, so update the last
//              chunk information.
//
//-----------------------------------------------------------------------------
void
CLineServices::UpdateRelativeChunk(
    LONG cp,
    CElement *pElementRelative,
    CElement *pElementLayout,
    LONG xPosCurrChunk,  // logical
    BOOL fRTLFlow)
{
    // Mirror position if RTL line
    if (_li._fRTLLn)
    {
        xPosCurrChunk = _li._xWidth - xPosCurrChunk;
    }

    // only add a chunk if cp has advanced or if flow direction has changed
    // (an empty chunk of opposite direction is required for the logic of FixupChunks
    if (cp > _cpLastChunk || fRTLFlow != _fLastChunkRTL)
    {

        // If flow direction has changed, the current chunk position is not helpful for
        // calculation of last chunk width. We need to get the position of the end of previous chunk
        LONG xEndLastChunk;
        if (_fLastChunkRTL == fRTLFlow)
        {
            // same direction
            xEndLastChunk = xPosCurrChunk;
        }
        else
        {
            // direction change
            xEndLastChunk = _xPosLastChunk; // this works for the leading empty chunk

            // Find end of previous chunk (the point where direction changes 
            // is where the interesting X position is)
            for (LONG cpLimLastChunk = cp; cpLimLastChunk > _cpLastChunk; cpLimLastChunk--)
            {
                BOOL fRTLFlowPrev;
                xEndLastChunk = CalculateXPositionOfCp(cpLimLastChunk, TRUE /*fAfterPrevCp*/, &fRTLFlowPrev);
                if (fRTLFlowPrev != fRTLFlow)
                    break;
            }
        }

        // width and position calculations depend on direction of the chunk we are adding
        LONG xLeftLastChunk;
        LONG xWidthLastChunk;
        if (!_fLastChunkRTL)
        {
            // LTR
            xLeftLastChunk = _xPosLastChunk;
            xWidthLastChunk = xEndLastChunk - _xPosLastChunk;

            // TODO RTL 112514: for some reason, we don't need to remove a pixel for opposite flow in this case. Why?
        }
        else
        {
            // RTL
            xLeftLastChunk = xEndLastChunk;
            xWidthLastChunk = _xPosLastChunk - xEndLastChunk;

            // Adjust position for opposite-direction inclusiveness 
            if (!_li._fRTLLn)
            {
                xLeftLastChunk++;
            }
        }
        

        CLSLineChunk * plcNew = new CLSLineChunk();
        if (plcNew)
        {
            plcNew->_cch             = cp  - _cpLastChunk;
            plcNew->_xLeft           = xLeftLastChunk;
            plcNew->_xWidth          = xWidthLastChunk;
            plcNew->_fRelative       = _pElementLastRelative != NULL;
            plcNew->_fSingleSite     = _fLastChunkSingleSite;
            plcNew->_fRTLChunk       = _fLastChunkRTL;

            // append this chunk to the line
            if(_plcLastChunk)
            {
                Assert(!_plcLastChunk->_plcNext);

                _plcLastChunk->_plcNext = plcNew;
                _plcLastChunk = plcNew;
            }
            else
            {
                _plcLastChunk = _plcFirstChunk = plcNew;
            }
        }
    }
    
    // after a new chunk is added, the current chunk immediately becomes "last"
    _xPosLastChunk        = xPosCurrChunk;
    _fLastChunkRTL        = fRTLFlow;

    _cpLastChunk          = cp;
    _pElementLastRelative = pElementRelative;
    _fLastChunkSingleSite =    pElementLayout
                            && pElementLayout->IsOwnLineElement(_pFlowLayout);
}

//-----------------------------------------------------------------------------
//
// Member:      HasBorders()
//
// Synopsis:    Look at the fancy format to see if borders have been set
//
//-----------------------------------------------------------------------------
BOOL
CLineServices::HasBorders(const CFancyFormat* pFF, const CCharFormat* pCF, BOOL fIsPseudo)
{
    // Fill the CBorderInfo structure
    CBorderInfo borderInfo;
    GetBorderInfoHelperEx(pFF, pCF, _pci, &borderInfo, fIsPseudo ? GBIH_PSEUDO : GBIH_NONE);

    return (borderInfo.wEdges & BF_RECT);
}

//-----------------------------------------------------------------------------
//
// Member:      GetKashidaWidth()
//
// Synopsis:    gets the width of the kashida character (U+0640) for Arabic
//              justification
//
//-----------------------------------------------------------------------------
LSERR 
CLineServices::GetKashidaWidth(PLSRUN plsrun, int *piKashidaWidth)
{
    LSERR lserr = lserrNone;
    HRESULT hr = S_OK;
    XHDC hdc = _pci->_hdc;
    FONTIDX hfontOld = HFONT_INVALID;
    XHDC hdcFontProp(NULL,NULL);
    CCcs ccs;
    SCRIPT_CACHE *psc = NULL;

    SCRIPT_FONTPROPERTIES  sfp;
    sfp.cBytes = sizeof(SCRIPT_FONTPROPERTIES);

    if (!GetCcs(&ccs, plsrun, _pci->_hdc, _pci))
    {
        lserr = lserrOutOfMemory;
        goto Cleanup;
    }

    psc = ccs.GetUniscribeCache();
    Assert(psc != NULL);

    hr = ScriptGetFontProperties(hdcFontProp, psc, &sfp);
    
    AssertSz(hr != E_INVALIDARG, "You might need to update USP10.DLL");

    // Handle failure
    if(hr == E_PENDING)
    {
        Assert(hdcFontProp == NULL);

        // Select the current font into the hdc and set hdcFontProp to hdc.
        hfontOld = ccs.PushFont(hdc);
        hdcFontProp = hdc;

        hr = ScriptGetFontProperties(hdcFontProp, psc, &sfp);

    }
    Assert(hr == S_OK || hr == E_OUTOFMEMORY);

    lserr = LSERRFromHR(hr);

    if(lserr == lserrNone)
    {
        *piKashidaWidth = max(sfp.iKashidaWidth, 1);

        const CBaseCcs *pBaseCcs = ccs.GetBaseCcs();
        Assert(pBaseCcs);
        if(pBaseCcs->_fScalingRequired)
            *piKashidaWidth *= pBaseCcs->_flScaleFactor;
    }

Cleanup:
    // Restore the font if we selected it
    if (hfontOld != HFONT_INVALID)
    {
        ccs.PopFont(hdc, hfontOld);
    }

    return lserr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\text\lsm.cxx ===
/*
 *  LSM.CXX -- CLSMeasurer class
 *
 *  Authors:
 *      Sujal Parikh
 *      Chris Thrasher
 *      Paul  Parker
 *
 *  History:
 *      2/27/98     sujalp created
 *
 *  Copyright (c) 1997-1998 Microsoft Corporation. All rights reserved.
 */

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_LSM_HXX_
#define X_LSM_HXX_
#include "lsm.hxx"
#endif

#ifndef X__FONT_H_
#define X__FONT_H_
#include "_font.h"
#endif

#ifndef X__DISP_H_
#define X__DISP_H_
#include "_disp.h"
#endif

#ifndef X_TREEPOS_HXX_
#define X_TREEPOS_HXX_
#include "treepos.hxx"
#endif

#ifndef X_TEXTXFRM_HXX_
#define X_TEXTXFRM_HXX_
#include <textxfrm.hxx>
#endif

#ifndef X__FONTLNK_H_
#define X__FONTLNK_H_
#include "_fontlnk.h"
#endif

#ifndef X_LTCELL_HXX_
#define X_LTCELL_HXX_
#include "ltcell.hxx"
#endif

#ifndef X_LINESRV_HXX_
#define X_LINESRV_HXX_
#include "linesrv.hxx"
#endif

#ifndef X_LSCACHE_HXX_
#define X_LSCACHE_HXX_
#include "lscache.hxx"
#endif

#ifdef DLOAD1
extern "C"  // MSLS interfaces are C
{
#endif

#ifndef X_LSSETDOC_H_
#define X_LSSETDOC_H_
#include <lssetdoc.h>
#endif

#ifndef X_LSCRLINE_H_
#define X_LSCRLINE_H_
#include <lscrline.h>
#endif

#ifdef DLOAD1
} // extern "C"
#endif

#ifndef X_ONERUN_HXX_
#define X_ONERUN_HXX_
#include "onerun.hxx"
#endif

#define DEF_FRAMEMARGIN     _pci->DeviceFromTwipsX(TWIPS_FROM_POINTS(2))
// BRECREC_COUNT should be the maximum number of ILS objects we can embed one
// inside the other. Currently that is (16 reverse) + (1 NOBR) + (1 Ruby).
#define BRECREC_COUNT       20

MtDefine(CLSMeasurer, Layout, "CLSMeasurer")
MtDefine(CLSLineChunk, Layout, "CLSLineChunk")

#if DBG!=1
#pragma optimize(SPEED_OPTIMIZE_FLAGS, on)
#endif

//+----------------------------------------------------------------------------
//
// Member:      CLSMeasurer::CLSMeasurer
//
// Synopsis:    Ctors for CLSMeasurer
//
//+----------------------------------------------------------------------------
CLSMeasurer::CLSMeasurer (const CDisplay* const pdp, CCalcInfo * pci)
{
    CTreePos *ptpFirst, *ptpLast;

    Init(pdp, pci, TRUE);
    _pFlowLayout->GetContentTreeExtent(&ptpFirst, &ptpLast);
    do
    {
        ptpFirst = ptpFirst->NextTreePos();
    }
    while (ptpFirst->GetCch() == 0);
    SetPtp(ptpFirst, -1);
}

CLSMeasurer::CLSMeasurer (const CDisplay* const pdp, LONG cp, CCalcInfo * pci)
{
    Init(pdp, pci, TRUE);
    SetCp(cp, NULL);
}

CLSMeasurer::CLSMeasurer (const CDisplay* const pdp, CDocInfo * pdci, BOOL fStartUpLSDLL)
{
    Init(pdp, CalcInfoFromDocInfo(pdp, pdci), fStartUpLSDLL);
    SetCp(pdp->GetFirstCp(), NULL);
}

CLSMeasurer::CLSMeasurer (const CDisplay* const pdp, LONG cp, CDocInfo * pdci)
{
    Init(pdp, CalcInfoFromDocInfo(pdp, pdci), TRUE);
    SetCp(cp, NULL);
}

//+----------------------------------------------------------------------------
//
// Member:      CLSMeasurer::Init
//
// Synopsis:    Default inits -- called only from the ctors.
//
//+----------------------------------------------------------------------------
void
CLSMeasurer::Init(const CDisplay * pdp, CCalcInfo *pci, BOOL fStartUpLSDLL)
{
    CTreePos * ptpContentEnd;
    _pFlowLayout        = pdp->GetFlowLayout();
    _pFlowLayout->GetContentTreeExtent(&_ptpCurrent, &ptpContentEnd);
    Assert( _ptpCurrent && ptpContentEnd );
    _cp                 = _ptpCurrent->GetCp() + 1;
    _cpEnd              = ptpContentEnd->GetCp();
    Assert(_cp <= _cpEnd);
    _cchPreChars        = 0;
    _pdp                = pdp;
    _fLastWasBreak      = FALSE;
    _pci                = NULL;
    _hdc                = NULL;
    _fBrowseMode        = !_pFlowLayout->IsEditable();
    _fMeasureFromTheStart = FALSE;
    _pRunOwner          = _pFlowLayout;
    _fHasNestedLayouts  = FALSE;
    SetCalcInfo(pci);
    _hdc = _pci->_hdc;
    _pDispNodePrev      = NULL;
    _fPseudoLineEnabled = FALSE;
    _fPseudoLetterEnabled = FALSE;
    _fPseudoElementEnabled = FALSE;
    _fBreaklinesFromStyle = FALSE;

    _pLS = TLS(_pLSCache)->GetFreeEntry(_pdp->GetMarkup(), fStartUpLSDLL);
    if (_pLS)
        _pLS->SetPOLS(this, ptpContentEnd);
}

//+----------------------------------------------------------------------------
//
// Member:      CLSMeasurer::Reinit
//
// Synopsis:    reinitializes measurer for use across multiple table cells
//
//+----------------------------------------------------------------------------

void
CLSMeasurer::Reinit(const CDisplay * pdp, CCalcInfo *pci)
{
    CTreePos *ptpFirst, *ptpLast;

    Assert(pdp);

    // Deinitialize measurer.
    Deinit();

    // 1. Reinitialize measurer.
    Init(pdp, pci, TRUE);

    // 2. setup the cp and _ptp
    _pFlowLayout->GetContentTreeExtent(&ptpFirst, &ptpLast);
    do
    {
        ptpFirst = ptpFirst->NextTreePos();
    }
    while (ptpFirst->GetCch() == 0);
    SetPtp(ptpFirst, -1);

    Assert(_pdp);
}

//+----------------------------------------------------------------------------
//
// Member:      CLSMeasurer::Deinit
//
// Synopsis:    Default inits -- called only from the ctors.
//
//+----------------------------------------------------------------------------

void
CLSMeasurer::Deinit()
{
    if (_pLS)
    {
        _pLS->ClearPOLS();

        if (_pdp)
            TLS(_pLSCache)->ReleaseEntry(_pLS);

        _pLS = NULL;
    }
    Assert(_aryFormatStash_Line.Size() == 0);
    Assert(_aryFormatStashForNested_Line.Size() == 0);
    Assert(_aryFormatStash_Letter.Size() == 0);
    Assert(_aryFormatStashAfterDisable_Letter.Size() == 0);
}

//+----------------------------------------------------------------------------
//
// Member:      CLSMeasurer::SetCalcInfo
//
// Synopsis:    Setup the calc info in the LSMeasurer
//
//+----------------------------------------------------------------------------
void
CLSMeasurer::SetCalcInfo(CCalcInfo * pci)
{
    if (!pci)
    {
        _CI.Init(_pFlowLayout);
        _pci = &_CI;
    }
    else
    {
        _pci = pci;
    }
}

//+----------------------------------------------------------------------------
//
// Member:      CLSMeasurer::CalcInfoFromDocInfo
//
// Synopsis:
//
//+----------------------------------------------------------------------------
CCalcInfo *
CLSMeasurer::CalcInfoFromDocInfo(const CDisplay *pdp, CDocInfo * pdci)
{
    _pFlowLayout = pdp->GetFlowLayout();
    if (!pdci)
    {
        _CI.Init(pdp->GetFlowLayout());
    }
    else
    {
        _CI.Init(pdci, pdp->GetFlowLayout());
        _CI.SizeToParent(pdp->GetFlowLayout());
    }
    return &_CI;
}

//+----------------------------------------------------------------------------
//
// Member:      CLSMeasurer::~CLSMeasurer
//
// Synopsis:    The dtor
//
//+----------------------------------------------------------------------------

CLSMeasurer::~CLSMeasurer()
{
    Deinit();
}

//+----------------------------------------------------------------------------
//
// Member:      SetCp
//
// Synopsis:    Setsup the cp of the measurer
//
//-----------------------------------------------------------------------------
void
CLSMeasurer::SetCp(LONG cp, CTreePos *ptp)
{
    _cp = cp;
    if (ptp == NULL)
    {
         LONG notNeeded;
         Assert(_pFlowLayout->GetContentMarkup());
        _ptpCurrent = _pFlowLayout->GetContentMarkup()->TreePosAtCp(cp, &notNeeded, TRUE);
    }
    else
    {
        _ptpCurrent = ptp;
    }
    Assert(_ptpCurrent);
    Assert(   _ptpCurrent->GetCp() <= _cp
           && _ptpCurrent->GetCp() + _ptpCurrent->GetCch() >= _cp
          );
}


//+----------------------------------------------------------------------------
//
// Member:      SetPtp
//
// Synopsis:    Setup measurer at this ptp and cp. If cp not specified, then
//              set it to the beginning of the ptp
//
//-----------------------------------------------------------------------------
void
CLSMeasurer::SetPtp(CTreePos *ptp, LONG cp)
{
    Assert(ptp);
    if(!ptp)
    {
        return;
    }

    _ptpCurrent = ptp;
    _cp = (cp == -1) ? ptp->GetCp() : cp;

    Assert(_ptpCurrent);
    Assert(   _ptpCurrent->GetCp() <= _cp
           && _ptpCurrent->GetCp() + _ptpCurrent->GetCch() >= _cp
          );
}


//+----------------------------------------------------------------------------
//
// Member:      Advance
//
// Synopsis:    Advances the measurer by the cch specified.
//
//-----------------------------------------------------------------------------
void
CLSMeasurer::Advance(long cch, CTreePos *ptp /* = NULL */)
{
    _cp += cch;
    if (ptp)
    {
        _ptpCurrent = ptp;
    }
    else
    {
        SetCp(_cp, NULL);
    }
    Assert(_ptpCurrent);
    Assert(   _ptpCurrent->GetCp() <= _cp
           && _ptpCurrent->GetCp() + _ptpCurrent->GetCch() >= _cp
          );
}


//+----------------------------------------------------------------------------
//
// Member:      CLSMeasurer::InitLineSpace ()
//
// Synopsis:    Initializes a measurer object to have the same
//              line spacing state as the given one.
//
//
//-----------------------------------------------------------------------------
//
void
CLSMeasurer::InitLineSpace(const CLSMeasurer *pMe, CLinePtr &rpOld)
{
    // Zero it all out.
    NewLine(FALSE);

    // Set up the current cache from the given measurer.
    _fLastWasBreak   = pMe->_fLastWasBreak;

    // Flags given separately.
    _li._dwFlags() = rpOld->_dwFlags();
    _li._fPartOfRelChunk = rpOld->_fPartOfRelChunk;

    // Setup the pf
    CTreeNode *pNode = _pdp->FormattingNodeForLine(FNFL_NONE, GetCp(), GetPtp(), rpOld->_cch, NULL, NULL, NULL);
    MeasureSetPF(pNode->GetParaFormat(), SameScope(pNode, _pdp->GetFlowLayout()->ElementContent()));
}

//+----------------------------------------------------------------------------
//
// Member:      CLSMeasurer::NewLine (fFirstInPara)
//
// Synopsis:    Initialize this measurer at the start of a new line
//
//-----------------------------------------------------------------------------

void CLSMeasurer::NewLine(
    BOOL fFirstInPara)
{
    _li.Init();                     // Zero all members

    if(fFirstInPara)
        _li._fFirstInPara = TRUE;   // Need to know if first in para

    // Can't calculate xLeft till we get an HDC.
    _li._xLeft = 0;

    _li._cch = 0;   // No characters to start.

}

//+----------------------------------------------------------------------------
//
// Member:      CLSMeasurer::NewLine (&li)
//
// Synopsis:    Initialize this measurer at the start of a new line
//
//-----------------------------------------------------------------------------

void CLSMeasurer::NewLine(
    const CLineFull &li)
{
    _li           = li;
    _li._cch      = 0;
    _li._cchWhite = 0;
    _li._xWidth   = 0;

    // Can't calculate xLeft or xRight till we get an HDC
    _li._xLeft    = 0;
    _li._xRight   = 0;
}

//+----------------------------------------------------------------------------
//
// Member:      CLSMeasurer::MeasureText (cch)
//
// Synopsis:    Measure a stretch of text from current running position.
//
//              HACKHACK (t-ramar): This function calls DiscardLine() at the
//              end, but we would like to keep information about Ruby Base
//              heights around for hit testing purposes.  Thus, there is an
//              optional parameter:
//                  pRubyInfo (out):  is a pointer to storage that holds the
//                                    ruby info of the ruby object that contains
//                                    this cp
//              It's also important to note that this value is ignored if
//              line flag FLAG_HAS_RUBY is not set.  In this case the value pointed
//              to by pRubyInfo will remain unchanged.
//
// Returns:     width of text (in device units), < 0 if failed
//
//-----------------------------------------------------------------------------

LONG CLSMeasurer::MeasureText(
    LONG cch,
    LONG cchLine,       // Number of characters to measure
    BOOL fAfterPrevCp,  // Return the trailing point of the previous cp (for an ambigous bidi cp)
    BOOL *pfComplexLine,
    BOOL *pfRTLFlow,      // only used in ViewServices
    RubyInfo *pRubyInfo)  // = NULL (default)
{

    CMarginInfo marginInfo;
    LONG xLeft  = _li._xLeft;
    LONG lRet   = -1;
    LONG cpStart = GetCp();
    LONG cpStartContainerLine;
    LSERR lserr = lserrNone;
    LONG cpToMeasureTill;
    CLineCore *pliContainer;
    UINT uiFlags = 0; 
    
    SetBreakLongLines(_ptpCurrent->GetBranch(), &uiFlags);

    lserr = PrepAndMeasureLine(&_li, &pliContainer, &cpStartContainerLine, &marginInfo, cchLine, uiFlags);
    if (lserr != lserrNone)
    {
        lRet = 0;
        goto Cleanup;
    }

    if (pfComplexLine)
        *pfComplexLine = (_pLS->_pBidiLine != NULL);

    if(pfRTLFlow)
        *pfRTLFlow = _li._fRTLLn;

    cpToMeasureTill = cpStart + cch;

    if(cpToMeasureTill > cpStartContainerLine || _pLS->_pBidiLine != NULL)
    {
        BOOL fRTLFlow;
        lRet = _pLS->CalculateXPositionOfCp(cpToMeasureTill, fAfterPrevCp, &fRTLFlow);

        //
        // To get correct position of cp within the line (which may be just part of a line, e.g. when
        // there is relative positioning), we need to 
        // (1) calculate the whole line (container line)
        // (2) subtract the offset of the line within the container line.
        // Note that we can't just calcluate subline, since there may be justification.
        //
        // The line's offset within the container line is equal to the difference 
        // between the line's offset from left margin and container line's offset from left margin.
        //
        lRet -= xLeft - pliContainer->oi()->_xLeft;

        // this returned parameter is only used in ViewServices 
        if(pfRTLFlow)
            *pfRTLFlow = fRTLFlow;
    }
    else
        lRet = 0;

    Assert(lRet >= 0 || _pLS->_fHasNegLetterSpacing);

    Advance(cch);
    if((_pLS->_lineFlags.GetLineFlags(_cp) & FLAG_HAS_RUBY) && pRubyInfo)
    {
        if(CurrBranch()->GetCharFormat()->_fIsRubyText)
        {
            RubyInfo *pTempRubyInfo = _pLS->GetRubyInfoFromCp(_cp);
            if(pTempRubyInfo)
            {
                memcpy(pRubyInfo, pTempRubyInfo, sizeof(RubyInfo));
            }
        }
    }

Cleanup:
    _pLS->DiscardLine();
    PseudoLineDisable();
    return lRet;

}

//+----------------------------------------------------------------------------
//
// Member:      CLSMeasurer::MeasureRangeOnLine (ich, cch, li, paryChunks)
//
// Synopsis:    Measure a stretch of text starting at ich on the current line
//              and running for cch characters. The text may be broken into
//              multiple chunks if the line has reverse objects (runs with
//              mixed directionallity) in it. Other ILS objects may also cause
//              fragmentation.
//
// Returns:     The number of chunks in the range. Usually this will just be
//              one. If an error occurs it will be zero. The actual width of
//              text (in device units) is returned in paryChunks as paired
//              offsets from the beginning of the line. Thus, paryChunks[0]
//              will be the start of the first chunk (relative to the start of
//              the line) and paryChunks[1] will be the end of the first chunk.
//
// Comments:    The actual work of this function is actually done down in
//              CalculatePositionOfRangeOnLine() in CLineServices. This just
//              creates and destroys the line and lets that function do the
//              analysis on it.
//
//-----------------------------------------------------------------------------
LONG
CLSMeasurer::MeasureRangeOnLine(
    CElement *pElement,
    LONG ich,                       // Offset to first character in the range
    LONG cch,                       // Number of characters in the range
    const CLineCore &li,            // Information about the line
    LONG yPos,                      // The yPos of the line
    CDataAry<CChunk> * paryChunks,    // Array of chunks to return
    DWORD dwFlags)                  // RFE_FLAGS
{
    CMarginInfo marginInfo;
    LONG cpStart = GetCp() + ich;
    LONG cpEnd = cpStart + cch;

    LONG cpStartContainerLine;
    LSERR lserr;
    LONG cChunk;
    CLineCore * pliContainer;

    Assert(paryChunks != NULL);

    //
    // FUTURE (grzegorz): vertical alignment stuff may be moved to 
    // PrepAndMeasureLine(), but we need to investigate if other callers 
    // need vertical alignment information.
    //

    _pLS->_li = _li;

    lserr = PrepAndMeasureLine(&_li, &pliContainer, &cpStartContainerLine, &marginInfo, li._cch, 0);

    if (lserr == lserrNone)
    {
        LONG xShift;
        if (!pliContainer->IsRTLLine())
        {
            xShift = pliContainer->oi()->_xLeft - li.oi()->_xLeft;
        }
        else
        {
            xShift = pliContainer->_xRight - li._xRight;
        }

#if 0
        _pLS->_fHasVerticalAlign = (_pLS->_lineFlags.GetLineFlags(_pLS->_cpLim) & FLAG_HAS_VALIGN) ? TRUE : FALSE;

        if (_pLS->_fHasVerticalAlign)
        {
            _pLS->_li._cch = _pLS->_cpLim - cpStartContainerLine;
            _pLS->VerticalAlignObjects(*this, 0);
        }
#endif

        if(dwFlags & RFE_TIGHT_RECTS)
        {
            // If the element cp's for which we need to compute the rect are completely
            // in the pre chars, then we do not do anything since the rect will be empty
            // as it is.
            if (cpEnd < _pLS->_cpStart)
            {
                Assert(cpEnd > _pLS->_cpStart - _cchPreChars);
                cChunk = 0;
            }
            else
            {
                COneRun *porRet = NULL;
                BOOL fIncludeBorders = (dwFlags & RFE_INCLUDE_BORDERS) ? TRUE : FALSE;
                LSCP lscpStart = _pLS->LSCPFromCP(max(cpStart, _pLS->_cpStart));
                LSCP lscpEnd = min(_pLS->LSCPFromCPCore(cpEnd, &porRet), _pLS->_lscpLim);

                //
                // We want to include all the trailing mbpcloses.
                //
                if (porRet)
                {
                    COneRun *porMBPClose = NULL;
                    porRet = porRet->_pNext;
                    while (porRet)
                    {
                        if (   (   porRet->IsSyntheticRun()
                                && porRet->_synthType == CLineServices::SYNTHTYPE_MBPCLOSE
                               )
                            || porRet->IsAntiSyntheticRun()
                           )
                        {
                            if (!porRet->IsAntiSyntheticRun())
                                porMBPClose = porRet;
                            porRet = porRet->_pNext;
                        }
                        else
                        {
                            break;
                        }
                    }
                    if (porMBPClose)
                        lscpEnd = porMBPClose->_lscpBase;
                }
                
                if (   pElement
                    && fIncludeBorders
                    && pElement->GetFirstBranch()->HasInlineMBP()
                   )
                {
                    LONG mbpTop = 0;
                    LONG mbpBottom = 0;
                    CDataAry<CChunk> aryTemp(NULL);
                    CTreeNode *pNode = pElement->GetFirstBranch();
                    CBorderInfo borderInfo;
                    BOOL fBOLWrapped = FALSE;
                    BOOL fEOLWrapped = FALSE;
                    
                    LONG cpFirst = pElement->GetFirstCp() - 1;
                    if (cpFirst < _pLS->_cpStart - (_fMeasureFromTheStart ? 0 : _cchPreChars))
                    {
                        fBOLWrapped = TRUE;
                    }
                    LONG cpLast = pElement->GetLastCp() + 1;
                    if (cpLast >= _pLS->_cpLim)
                    {
                        fEOLWrapped = TRUE;
                    }
                    
                    FindMBPAboveNode(pElement, &mbpTop, &mbpBottom);
                    cChunk = _pLS->CalcRectsOfRangeOnLine(lscpStart,
                                                          lscpEnd, 
                                                          xShift,
                                                          yPos, 
                                                          &aryTemp, 
                                                          dwFlags,
                                                          mbpTop, mbpBottom);

                    pElement->GetBorderInfo(_pci, &borderInfo, TRUE, FALSE);
                    MassageRectsForInlineMBP(aryTemp, paryChunks, pNode,
                                             pNode->GetCharFormat(),
                                             pNode->GetFancyFormat(),
                                             borderInfo,
                                             pliContainer,
                                             FALSE, /* fIsPseudoMBP */
                                             FALSE, /* fSwapBorders */
                                             fBOLWrapped,
                                             fEOLWrapped,
                                             FALSE, /* DrawBackgrounds */
                                             FALSE /* DrawBorders */
                                            );
                }
                else
                {
                    dwFlags &= ~RFE_INCLUDE_BORDERS;
                    cChunk = _pLS->CalcRectsOfRangeOnLine(lscpStart,
                                                          lscpEnd, 
                                                          xShift,
                                                          yPos, 
                                                          paryChunks, 
                                                          dwFlags,
                                                          0, 0);
                }
            }
        }
        else
            cChunk = _pLS->CalcPositionsOfRangeOnLine(cpStart, cpEnd, xShift, paryChunks, dwFlags);
    }
    else
    {
        cChunk = 0;
    }

    _pLS->DiscardLine();
    PseudoLineDisable();
    return cChunk;
}

//+----------------------------------------------------------------------------
//
// Member:      CLSMeasurer::MeasureLine (xWidthMax, cchMax, uiFlags, pliTarget)
//
// Synopsis:    Measure a line of text from current cp and determine line break.
//              On return *this contains line metrics for _pdd device.
//
// Returns:     TRUE if success, FALSE if failed
//
//-----------------------------------------------------------------------------

BOOL CLSMeasurer::MeasureLine(
    LONG xWidthMax,     // max width to process (-1 uses CDisplay width)
    LONG cchMax,        // Max chars to process (-1 if no limit)
    UINT uiFlags,       // Flags controlling the process (see Measure())
    CMarginInfo *pMarginInfo,
    LONG *pxMinLine)    // returns min line width required for tables(optional)
{
    BOOL fRet = TRUE;
    LONG lRet;

    // Compute line break
    lRet = Measure(xWidthMax, cchMax, uiFlags, pMarginInfo, pxMinLine);

    // Stop here if failed
    if(lRet == MRET_FAILED)
    {
        AssertSz(0,"Measure returned MRET_FAILED");
        fRet = FALSE;
        goto Cleanup;
    }

Cleanup:
    _pLS->DiscardLine();
    PseudoLineDisable();
    return fRet;
}


#if DBG!=1
#pragma optimize(SPEED_OPTIMIZE_FLAGS, on)
#endif


//+----------------------------------------------------------------------------
//
// Member:      CLSMeasurer::LSDoCreateLine
//
// Synopsis:    Calls the lineservices LSCreateLine
//
//-----------------------------------------------------------------------------
HRESULT
CLSMeasurer::LSDoCreateLine(
    LONG cp,                  // IN
    CTreePos *ptp,            // IN
    CMarginInfo *pMarginInfo, // IN
    LONG xWidthMaxIn,         // IN
    const CLineFull * pli,    // IN
    BOOL fMinMaxPass,         // IN
    LSLINFO *plslinfo)        // OUT
    
{
    PLSC        plsc  = _pLS->GetContext();
    CCalcInfo  *pci   = GetCalcInfo();
    HRESULT     hr;
    LSDEVRES    lsdevres;
    BREAKREC    rgBreakRec[BRECREC_COUNT];
    DWORD       nBreakRec;
    LSLINFO     lslinfo;

    Assert(pci);
    AssertSz(!_pLS->_plsline, "plsline not freed, could be leaking memory here!");

    if (_pLS->_lsMode == CLineServices::LSMODE_MEASURER)
    {
        _pLS->_li._xMeasureWidth = fMinMaxPass ? -1 : xWidthMaxIn;
    }
    else
    {
        Assert(!fMinMaxPass);
        if (_pLS->_li._xMeasureWidth != -1)
            xWidthMaxIn = _pLS->_li._xMeasureWidth;
    }

    hr = THR(_pLS->Setup(xWidthMaxIn, cp, ptp, pMarginInfo, pli, fMinMaxPass));
    if (hr != S_OK)
        goto Cleanup;
    
    if (_cpEnd == 0)
        goto Cleanup;

    if (plslinfo == NULL)
        plslinfo = & lslinfo;

    SetupMBPInfoInLS(NULL);
    
    hr = THR(_pLS->CheckSetTables());
    if (hr)
        goto Cleanup;

    lsdevres.dxpInch = lsdevres.dxrInch = pci->GetResolution().cx;
    lsdevres.dypInch = lsdevres.dyrInch = pci->GetResolution().cy;
    hr = HRFromLSERR(LsSetDoc( plsc, TRUE, TRUE, &lsdevres ));
    if (hr)
        goto Cleanup;

    hr = HRFromLSERR(LsCreateLine( plsc, cp, pci->TwipsFromDeviceCeilX(_pLS->_xWidthMaxAvail),
                               NULL, 0, sizeof(rgBreakRec)/sizeof(BREAKREC), rgBreakRec, &nBreakRec,
                               plslinfo, &_pLS->_plsline ) );
    if (hr)
        goto Cleanup;

    _pLS->_lscpLim = plslinfo->cpLim;
    _pLS->_cpLim   = _pLS->CPFromLSCP(_pLS->_lscpLim);

    // PaulNel - We need to set this up in order to put widths into line
    // for bidi lines.
    if(_pLS->_pBidiLine)
    {
        long durWithTrailing, durWithoutTrailing;

        hr = _pLS->GetLineWidth(&durWithTrailing, &durWithoutTrailing);
        if (hr)
            goto Cleanup;
        _pLS->_li._xWidth = durWithTrailing;
    }

    hr = S_OK;

Cleanup:
    RRETURN1(hr, S_FALSE);
}

//+----------------------------------------------------------------------------
//
// Member:      CLSMeasurer::LSMeasure
//
// Synopsis:    Measures the line using lineservices and then sets up the
//              various li parameters.
//
//-----------------------------------------------------------------------------
HRESULT
CLSMeasurer::LSMeasure(
    CMarginInfo *pMarginInfo,
    LONG xWidthMaxIn,
    LONG * pxMinLineWidth )
{
    long           cp    = GetCp();
    HRESULT        hr    = S_OK;
    LSLINFO        lslinfo;
    long           durWithTrailing, durWithoutTrailing;
    DWORD          dwlf;
    BOOL           fLineHasBR;
    
    hr = THR( LSDoCreateLine(GetCp(), GetPtp(), pMarginInfo, xWidthMaxIn, NULL,
                             pxMinLineWidth != NULL, &lslinfo) );
    if (hr)
        goto Cleanup;

    if (_pLS->_fNeedRecreateLine)
    {
        _pLS->DiscardLine();
        hr = THR( LSDoCreateLine(GetCp(), GetPtp(), pMarginInfo, xWidthMaxIn, &_pLS->_li,
                                 pxMinLineWidth != NULL, &lslinfo) );
        if (hr)
            goto Cleanup;
    }

    hr = _pLS->GetLineWidth(&durWithTrailing, &durWithoutTrailing);
    if (hr)
        goto Cleanup;
    _pLS->_li._xWidth = durWithTrailing;

    //
    // We will now do all the cases where we might potentially reduce the
    // length of the line. To aid us in doing this we will use the line
    // flags to tell us if the stuff really needs to be done. If we do
    // end up reducing the length of the line, we need to recompute the
    // the flags. We will then pass these flags down to ComputeWhiteInfo.
    //
    {
        LONG cpLimOld = _pLS->_cpLim;
        BOOL fRetakeFlags = FALSE;
        
        dwlf = _pLS->_lineFlags.GetLineFlags(cpLimOld);

        fLineHasBR = dwlf & FLAG_HAS_A_BR;
        
        // Mimic the Nav BR bug, but don't bother if we're in a min-max pass.
        // NB (cthrash) We don't don't drop the BR if we have CSS text-jusitify,
        // since the justification rules can hinge on whether there's a BR on
        // the line or not.  Since Nav doesn't support text-justify, there's no
        // concert for compat.
        if (   fLineHasBR
            && !g_fInMoney98
            && !_pLS->_li._fJustified
           )
        {
            // Note: this call modifies _pLS->_cpLim
            _pLS->AdjustCpLimForNavBRBug(xWidthMaxIn, &lslinfo);
            fRetakeFlags = _pLS->_cpLim < cpLimOld;
        }

        if (   (dwlf & FLAG_HAS_RELATIVE)
            &&  lslinfo.endr == endrNormal
           )
        {
            _pLS->AdjustForRelElementAtEnd();
            fRetakeFlags = _pLS->_cpLim < cpLimOld;
        }

#if 0        
        if (   _pLS->_fWrapLongLines
            && _pLS->_li._xWidth > xWidthMaxIn
            && _pLS->_cpLim - cp > 1
           )
        {
            _pLS->AdjustForSpaceAtEnd();
            fRetakeFlags = _pLS->_cpLim < cpLimOld;
        }
#endif
        
        if (fRetakeFlags)
        {
            dwlf = _pLS->_lineFlags.GetLineFlags(_pLS->_cpLim);
        }
        else
        {
            Assert(_pLS->_cpLim == cpLimOld);
        }
    }
    
    _pLS->_li._cch = _pLS->_cpLim - cp;

    //
    // If this is a min-max pass, we need to deterine the correct widths.
    // Note that this is true even when there are aligned sites because
    // We will use that information to truncate the full min pass.
    //
    if (pxMinLineWidth)
    {
        Assert(_pLS->_fMinMaxPass);

        LONG dxMaxDelta;

        //
        // HACK (cthrash) For text, LS correctly computes the minimum value.
        // For embedded objects, however, LS assumes that the min and max
        // widths are the same, even though in the case of tables, for
        // example, these are typically not the same.  We therefore lie
        // to LS and tell that these embedded objects have the width of the
        // minimum width, and then in the post-pass sum the difference to
        // compute the true maximum width.
        //

        hr = HRFromLSERR(_pLS->GetMinDurBreaks( pxMinLineWidth, &dxMaxDelta ));
        if (hr)
            goto Cleanup;

        //
        // Also include the width for the margins!
        //
        *pxMinLineWidth += _pLS->_li._xLeft + _pLS->_li._xRight; // + _li._xOverHang
        // The line overhang is added into the min-line width in ComputeWhiteInfo
        // since its value is computed there.
        
        _pLS->_li._xWidth += dxMaxDelta;

    }

    // This is a bit funky. For lines ending at </P> which could not fit the </P>
    // glyph on the line we want to set _fEndSplayNotMeasured to be FALSE. This
    // would mean that later on in CalcAfterSpace, we would consume
    // atleast one ptp with a glyph (the one having the /P) before we stop consuming
    // more characters on the line.
    //
    // Now, the BR case: If we have a BR, then our ptp is *beyond* the last
    // ptp of the BR rather than at it. In this case we do not want to consume
    // any additional ptp's in CalcAfterSpace. Hence when we have a BR we
    // set _fEndSplayNotMeasured to be true.
    //
    _fEndSplayNotMeasured =  lslinfo.endr == endrNormal || fLineHasBR || _pLS->_li._fSingleSite;

    // LONG_MAX is the return value when (a) the only text on the line is
    // white, and (b) fFmiSpacesInfluenceHeight is not set in the PAP.
    // Since we do set the flag, our MultiLineHeight should never be LONG_MAX.

    // Arye: Trips all the time, yet things work. What's up?
    // This looks like a LS bug. The problem is that for a line with
    // only a BR on it, we get dvpDescent and dvpAscent to be correct
    // but dvpMultiLineHeight is not set.
    //Assert(lslinfo.dvpMultiLineHeight != LONG_MAX);

    ComputeHeights(&lslinfo);

    _pLS->ComputeWhiteInfo(&lslinfo, pxMinLineWidth, dwlf, durWithTrailing, durWithoutTrailing);

Cleanup:
    RRETURN1(hr, S_FALSE);
}

//+----------------------------------------------------------------------------
//
// Function:    CMeasure::InitForMeasure
//
// Synopsis:    Initializes some basic members of the measurer.
//
// Arguments:   uiFlags -  Details in comment block of MeasureLine
//
// Return:      Return      -   0 for success
//                          -   MRET_FAILED if failed
//
//-----------------------------------------------------------------------------

LONG
CLSMeasurer::InitForMeasure(UINT uiFlags)
{
    CElement *pElementFL = _pFlowLayout->ElementContent();
    _fLastWasBreak = FALSE;
    _xLeftFrameMargin = 0;
    _xRightFrameMargin = 0;

    _cAlignedSites = 0;
    _cAlignedSitesAtBeginningOfLine = 0;
    _cchWhiteAtBeginningOfLine = 0;

    CTreeNode *pNode;
    
    if (!_fMeasureFromTheStart)
        pNode = CurrBranch();
    else
    {
        LONG cp = GetCp() + _cchPreChars;
        CTreePos *ptp = GetMarkup()->TreePosAtCp(cp, NULL, TRUE);
        pNode = ptp ? ptp->GetBranch() : CurrBranch();
    }
    MeasureSetPF(pNode->GetParaFormat(LC_TO_FC(_pci->GetLayoutContext())), SameScope(pNode, pElementFL));

    // Get the device context
    if(_hdc.IsEmpty())
    {
        _hdc = _pci->_hdc;

        if(_hdc.IsEmpty())
        {
            AssertSz(FALSE, "CLSMeasurer::Measure could not get DC");
            return MRET_FAILED;
        }
    }

    return 0;
}

//+----------------------------------------------------------------------------
//
// Function:    CMeasure::Measure
//
// Synopsis:    Measure the width of text and the number of characters of text
//              that fits on a line based on the flags. Store the number of
//              characters in _cch.
//
// Arguments:   xWidthMax   -   max width of the line
//              cchMax      -   max chars to process (-1 if no limit)
//              uiFlags     -   flags controlling the process, which mean
//
//                  MEASURE_FIRSTINPARA     this is first line of paragraph
//                  MEASURE_BREAKATWORD     break out on a word break
//                  MEASURE_BREAKATWIDTH    break closest possible before
//                                          xWidthMax
//                  MEASURE_BREAKNEARWIDTH  break closest possible to xWidthMax
//                  MEASURE_MIN_MAX         measure both min and max size of
//                                          possible line size
//              pxMinLineWidth - if non-NULL, Measure() measures minimum line width.
//                                defaults to NULL if not specified.
// Return:      Return      -   o for success
//                          -   MRET_FAILED if failed
//                          -   MRET_NOWIDTH if a second pass is needed to
//                              compute correct width
//
//-----------------------------------------------------------------------------

LONG CLSMeasurer::Measure(
    LONG    xWidthMaxIn,
    LONG    cchMax,
    UINT    uiFlags,
    CMarginInfo *pMarginInfo,
    LONG *  pxMinLineWidth)
{
    LONG    xWidthMax  = xWidthMaxIn;
    LONG    xLineShift = 0;
    LONG    lRet       = 0;
    LONG    yEmptyLineHeight;
    LONG    yEmptyLineDescent;
    
    CLineFull*pli;
#if DBG==1
    LONG    cpStart = GetCp();
    CTxtPtr txtptr( _pFlowLayout->GetContentMarkup(), cpStart );
#endif

    AssertSz(pMarginInfo, "Margin info should never be NULL");

    _pLS->SetMeasurer(this, uiFlags & MEASURE_BREAKWORDS ?
                      CLineServices::LSMODE_HITTEST :
                      CLineServices::LSMODE_MEASURER,
                      uiFlags & MEASURE_BREAKLONGLINES ? TRUE : FALSE
                     );

    lRet = InitForMeasure(uiFlags);
    if(lRet)
    {
        //the only error code we anticipate from InitForMeasure
        Assert(lRet == MRET_FAILED);
        goto Error;
    }

    _li._fFirstInPara = uiFlags & MEASURE_FIRSTINPARA;
    _li._fFirstFragInLine = TRUE;
    _li._xWhite = 0;
    _li._fClearBefore = FALSE;
    _li._fClearAfter  = FALSE;
    
    // Always force a newline by default
    _li._fForceNewLine = TRUE;
    _li._fDummyLine    = FALSE;

    // Set the line direction here
    _li._fRTLLn = _pLS->_pPFFirst->HasRTL(_pLS->_fInnerPFFirst);

    // For hit testing we dont need to do any of the following, _xLeft
    // is computed is computed and available in the line.

    // Compute width to break out at
    if (uiFlags & MEASURE_BREAKATWORD)
    {
        // Adjust left indent
        MeasureListIndent();

        if (pMarginInfo->HasLeftFrameMargin())
        {
            _xLeftFrameMargin = DEF_FRAMEMARGIN;
        }
        if (pMarginInfo->HasRightFrameMargin())
        {
            _xRightFrameMargin = DEF_FRAMEMARGIN;
        }

        if(xWidthMax != MAXLONG ||
            (_li._xRight + _li._xLeft + _pdp->GetCaret() +
                        _xLeftFrameMargin + _xRightFrameMargin) > 0)
        {
            xWidthMax -= _li._xRight + _li._xLeft - _li._xNegativeShiftRTL +
                        _xLeftFrameMargin + _xRightFrameMargin;
        }
    }

    // Compute max number of characters to process, if -1 (no limit) is specified
    if (cchMax < 0)
        cchMax = GetLastCp() - GetCp();

    Assert(_pLS);
    _pLS->_li = _li;
    if(S_OK != LSMeasure(pMarginInfo, xWidthMax, pxMinLineWidth))
    {
        lRet = MRET_FAILED;
        goto Error;
    }

    pli = &_pLS->_li;

    //-------------- HACK HACK (SujalP) --------------------------
    //
    // Bug 46277 shows us that the measurer can measure beyond the end
    // of the layout. The problem could be anywhere and is difficult to
    // find out in a post-mortem manner. So till we have a better repro
    // case, I am going to put in a band-aid fix.
    //
    //-------------- HACK HACK (SujalP) --------------------------
    if (_pLS->_cpStart + _pLS->_li._cch > _pLS->_treeInfo._cpLayoutLast)
    {
        AssertSz(0, "This should not happen ... ever!");
        _pLS->_li._cch = _pLS->_treeInfo._cpLayoutLast - _pLS->_cpStart;
    }
    
    // If we can auto clear and the given space does not fit a word,
    // let's auto clear.
    if (pli->_xWidth > xWidthMax &&
        (uiFlags & MEASURE_AUTOCLEAR))
    {
        LONG cchAtBOL;


        if (_pLS->GetAlignedAtBOL() && !pli->_fHasBreak)
        {
            cchAtBOL = _pLS->CchSkipAtBOL() - (_fMeasureFromTheStart ? 0 : _pLS->GetWhiteAtBOL());
        }
        else
        {
            cchAtBOL = _pLS->CchSkipAtBOL();
        }
        
        pMarginInfo->_fAutoClear = TRUE;

        pli->_cch      = cchAtBOL;
        pli->_xWidth   = 0;
        pli->_xWhite   = 0;
        pli->_cchWhite = cchAtBOL;
        _pLS->DeleteChunks();
        Advance( pli->_cch );
        goto Cleanup;
    }

    Advance( _pLS->_li._cch, _pLS->FigureNextPtp(_pLS->_cpStart + _pLS->_li._cch) );

    // If the line is completely empty or the line contains
    // nothing but noscope element and potentially
    // a break character (that don't have any height of their own),
    // then we need to give the line the height of the prevailing font.
    //
    // NB (cthrash) pli->_cch can be less than _pLS->CchSkipAtBOL(),
    // in the case of an empty LI.  We start measuring at the new block
    // element, but end up bailing immediately.  Unfortunately, we will
    // have already bumped up the _cWhiteAtBOL when we looked at the
    // begin node character of this block element.
    if (   !pli->_fHidden
        && (!(pli->_cch + (_fBrowseMode ? _cchPreChars : 0))
            || (   (   pli->_fHasBreak
                    || pli->_fHasBulletOrNum
                   )
                && pli->_cch <= _pLS->CchSkipAtBOL()
               )
           )
        && (!_fEmptyLineForPadBord || !_fBrowseMode)
       )
    {
        // Possibly use the compose font for default line height.
        if (!_fBrowseMode)
        {
            // Have to load the empty line height.
            extern long GetSpringLoadedHeight(CCalcInfo *, CFlowLayout *, CTreePos *, long, long *);
            yEmptyLineHeight = GetSpringLoadedHeight(
                                    GetCalcInfo(),
                                    _pFlowLayout,
                                    GetPtp(), GetCp(),
                                    &yEmptyLineDescent);

            if (yEmptyLineHeight == -1)
            {
                yEmptyLineHeight = pli->_yHeight;//24;
                yEmptyLineDescent = pli->_yDescent; //4;
            }

            if (pli->_fHasBulletOrNum)
            {
                pli->_yHeight = max(pli->_yHeight, yEmptyLineHeight);
                pli->_yDescent = max(pli->_yDescent, yEmptyLineDescent);
            }
            else
            {
                pli->_yHeight = yEmptyLineHeight;
                pli->_yDescent = yEmptyLineDescent;
            }
        }
        else
        {
            COneRun *por;
            CCalcInfo *pci = GetCalcInfo();

            por = _pLS->_listFree.GetFreeOneRun(NULL);
            if (!por)
                goto Cleanup;
            por->_pCF = (CCharFormat*)_pLS->_treeInfo._pCF;
#if DBG == 1
            por->_pCFOriginal = por->_pCF;
#endif
            CCcs ccs;

            if (_pLS->GetCcs(&ccs, por, pci->_hdc, pci))
            {
                const CBaseCcs *pBaseCcs = ccs.GetBaseCcs();
                pli->_yHeight  = pBaseCcs->_yHeight;
                pli->_yDescent = pBaseCcs->_yDescent;
                pli->_fDummyLine = FALSE;
                pli->_fForceNewLine = TRUE;
            }

            _pLS->_listFree.SpliceIn(por);
        }

        if (!_pLS->_fFoundLineHeight)
            _pLS->_lMaxLineHeight = pli->_yHeight;
        Assert(pli->_yHeight >= 0);
    }

    // Line with only white space (only occurs in table cells with aligned
    // images), set the height to zero.
    else if (_pLS->IsDummyLine(GetCp()))
    {
        pli->_yHeight = pli->_yDescent = _pLS->_lMaxLineHeight = 0;
    }

    pli->_yTxtDescent = pli->_yDescent;

    if (!lRet && pli->_cch && pli->_fForceNewLine && pli->_xWidth != 0)
    {
        xLineShift = _xLeftFrameMargin;

        // TODO RTL 112514: if this code is now fully obsolete, we need to debug it and delete it.
        if(_pdp->IsRTLDisplay())
        {
            Assert(_xLeftFrameMargin == _xRightFrameMargin || !IsTagEnabled(tagDebugRTL));
        //  xLineShift = _xRightFrameMargin;
        }

        pli->_xLeft   += _xLeftFrameMargin;
        pli->_xRight  += _xRightFrameMargin;
    }

    if( (pli->_fForceNewLine || (pli->_fDummyLine)))
    {
        BOOL fMinMax = uiFlags & (MEASURE_MINWIDTH|MEASURE_MAXWIDTH);
        long xShift;
        long xRemainder = 0;

        // Note: fMinMax here doesn't really mean that we are calculating min/max.
        //       (in that case, MEASURE_MINWIDTH is set, and MeasureLineShift is 
        //       not called at all.
        //       fMinMax rather means "don't bother justifying lines, we either 
        //       don't need to do it at all, or we'll do it on a different pass)
        //       In case of _fSizeToContent, lines are justified by RecalcLineShift() later.
        //       If _fSizeToContent is set, but RecalcLineShift() is not called
        //       (which sounds like a possibility - look at how fNeedLineShift is calculated
        //       in CFlowLayout::CalcSizeCore), all lines will remain left-aligned.
        if(!(uiFlags & MEASURE_MINWIDTH))
            xShift = _pLS->MeasureLineShift(
                               GetCp(),
                               xWidthMaxIn,
                               fMinMax || _pLS->_pFlowLayout->_fSizeToContent,
                               &xRemainder);
        else
            xShift = 0;

        // Now that we know the line width, compute line shift due
        // to alignment, and add it to the left position
        if (!fMinMax)
        {
            pli->_xLeft += xShift;
            pli->_xRight += max(xRemainder, 0L);
            xLineShift += pli->_xLeft;
            
            // In RTL display, save shift if it is negative (that won't happen in LTR)
            if (_pdp->IsRTLDisplay() && xShift < 0)
                pli->_xNegativeShiftRTL = xShift;
        }
    }

    _pLS->_fHasRelative |= !!_fRelativePreChars;
    _pLS->_pFlowLayout->_fContainsRelative |= !!_fRelativePreChars;

    Assert(_pLS->_lsMode == CLineServices::LSMODE_MEASURER);
    if (   _pLS->_fHasInlinedSites 
        || _pLS->_cAbsoluteSites 
        || _cchAbsPosdPreChars 
        || _pLS->_fHasRelative 
       )
    {
        pli->_fRelative = _pLS->_fHasRelative;
        // Assume there are only sites in the line if the number of characters
        // is less than the number of characters given to sites, plus those
        // given to whitespace, plus break characters. (A less than comparison
        // is used since whitespace which occurs at the end of the line is not
        // counted in the cch for the line.)

        if (_pLS->_fHasVerticalAlign)
            _pLS->VerticalAlignObjects(*this, xLineShift);
        else
            _pLS->VerticalAlignObjectsFast(*this, xLineShift);
    }
    else if (_pLS->_fHasVerticalAlign)
    {
        _pLS->VerticalAlignObjects(*this, xLineShift);
    }
    else
    {
        // Allow last minute adjustment to line height
        _pLS->AdjustLineHeight();
    }

Cleanup:
    // SYNCUP THE LINE WITH THE LINE GENERATED BY LINESERVICES
    _li = *pli;

Error:
    return lRet;
}

#pragma optimize("", on)

CLineCore *
CLSMeasurer::AccountForRelativeLines(CLineFull& li,                 // IN
                                     LONG *pcpStartContainerLine,   // OUT
                                     LONG *pxWidthContainerLine,    // OUT
                                     LONG *pcpStartRender,          // OUT
                                     LONG *pcpStopRender,           // OUT
                                     LONG *pcchTotal                // OUT
                                    ) const
{
    CLineCore *pliContainer = &li;

    if (li._fPartOfRelChunk)
    {
        CLinePtr rp((CDisplay *)_pdp);
        BOOL fRet;

        // NOTE(SujalP): The li and the cp should be in sync. on calling
        rp.RpSetCp(GetCp(), FALSE, TRUE, TRUE);

        // Verify that rp was instantiated correctly
        Assert(rp->_fPartOfRelChunk);
 
        *pcpStartRender = *pcpStartContainerLine = GetCp();

        // Navigate backwards all the way so that we reach the start of
        // the current container line
        while(!rp->_fFirstFragInLine)
        {
            Verify(rp.PrevLine(FALSE, FALSE));
            *pcpStartContainerLine -= rp->_cch;
            Assert(rp->_fPartOfRelChunk);
        }

        pliContainer = rp.CurLine();

        // Navigate forward till the end of this container line
        // collecting all the interesting information along the way
        fRet = TRUE;
        if(!rp->_fRTLLn)
        {
            *pxWidthContainerLine = -rp->oi()->_xLeft;
        }
        else
        {
            *pxWidthContainerLine = -rp->_xRight;
        }
        *pcchTotal = 0;
        while (fRet)
        {
            *pcchTotal += rp->_cch;
            fRet = rp.NextLine(FALSE, FALSE);
            if (!fRet || rp->_fFirstFragInLine || rp->IsClear())
            {
                if (fRet)
                    Verify(rp.PrevLine(FALSE, FALSE));
                if(!rp->_fRTLLn)
                {
                    *pxWidthContainerLine += rp->_xLineWidth - rp->_xRight;
                }
                else
                {
                    *pxWidthContainerLine += rp->_xLineWidth - rp->oi()->_xLeft + rp->oi()->_xNegativeShiftRTL;
                }
                break;
            }
            Assert(rp->IsFrame() || rp->_fPartOfRelChunk);
        }
    }
    else
    {
        *pcchTotal = li._cch;
        *pcpStartRender = *pcpStartContainerLine = GetCp();

        //
        // Computing the width is tricky.
        // If the line is right aligned, because in that case the _xWhite 'hangs off'
        // the line, i.e. _xLeft + _xWidth + _xRight = _xLineWidth. Note there
        // is not _xWhite in the lhs of the above expression. So to the correct
        // width to which we need to measure, if the _xWhite hangs off the
        // _xLineWidth, then we need to add it in to the width of the line.
        //
        long xLeft = li._xLeft - li._xNegativeShiftRTL;
        
        *pxWidthContainerLine  = li._xLineWidth - (xLeft + li._xRight);
        if (li._xWidth + li._xWhite + xLeft + _li._xRight > _li._xLineWidth)
        {
            // Make sure were not full justified, since we *don't* want to
            // include the xWhite in the line width in that case.

            if (li._fJustified != JUSTIFY_FULL)
            {
                *pxWidthContainerLine += li._xWhite;
            }
        }

    }
    *pcpStopRender  = *pcpStartRender + li._cch;

    Assert(pliContainer);
    return pliContainer;
}

// Used by the full min pass to find the next island of
// aligned objects around which to advance.
BOOL
CLSMeasurer::AdvanceToNextAlignedObject()
{
    BOOL fFound = FALSE;
    CTreePos *ptp;
    CTreeNode *pNode;
    CTreePos *ptpStop = NULL;
    CTreePos *ptpStart = NULL;
    CTreePos *ptpPrev;
    const CCharFormat *pCF;
    CElement *pElement;

    Assert(_pFlowLayout);
    _pFlowLayout->GetContentTreeExtent(&ptpStart, &ptpStop);
    Assert(ptpStart && ptpStop);

    ptp = GetPtp();
    Assert(ptp);

    // Need to make sure that the ambiguous measurer cp is taken
    // and then moved back to the appropriate non-text node.
    if (ptp->IsText() && _cp == ptp->GetCp() || ptp->IsPointer())
    {
        for (ptpPrev = ptp->PreviousTreePos();
             ptpPrev != ptpStart && ptpPrev->IsBeginNode();
             ptpPrev = ptp->PreviousTreePos()
                     )
        {
            ptp = ptpPrev;
        }
    }

#if DBG == 1
// I don't actually know this is a problem, but AdvanceTreePos is
// a problem, and this looks similar (KTam)
#ifndef MULTI_LAYOUT
    {
        // We will never be positioned inside a nested run owner.
        CLayout *pRunOwner;
        CTreePos *ptpTemp;

        pRunOwner = _pFlowLayout->GetContentMarkup()->GetRunOwner(ptp->GetBranch(), _pFlowLayout);
        if (pRunOwner != _pFlowLayout)
        {
            pRunOwner->GetContentTreeExtent(&ptpTemp, NULL);
            Assert(ptp == ptpTemp);
        }
    }
#endif // MULTI_LAYOUT
#endif

    while (ptp != ptpStop)
    {
        if (ptp->IsNode())
        {
            pNode = ptp->Branch();
            pElement = pNode->Element();
            pCF = pNode->GetCharFormat();
            if (pCF->IsDisplayNone())
            {
                pElement->GetTreeExtent(NULL, &ptp);
            }
            else if (ptp->IsBeginElementScope())
            {
                if (pNode->ShouldHaveLayout())
                {
                    Assert (pElement != _pFlowLayout->ElementContent());
                    if (pElement->IsRunOwner())
                    {
                        if (pElement->GetElementCch())
                        {
                            fFound = TRUE;
                        }
                    }
                    else
                        fFound = TRUE;

                    // We've found a site and it is has content, is it aligned?
                    // If not, then we don't want to measure around it.
                    if (fFound)
                    {
                        if (!pNode->GetFancyFormat()->_fAlignedLayout)
                            fFound = FALSE;
                        else
                            break;
                    }

                    pElement->GetTreeExtent(NULL, &ptp);
                }
            }
        }
        ptp = ptp->NextTreePos();
    }

    Assert(ptp);
    SetCp(ptp->GetCp(), ptp);
    return fFound;
}

//+----------------------------------------------------------------------------
//
// Member:      CLSMeasurer::PrepAndMeasureLine()
//
// Synopsis:    Prepares a line for measurement and then measures it.
//
//
// Returns:     lserr result of line creation
//
//-----------------------------------------------------------------------------

LSERR CLSMeasurer::PrepAndMeasureLine(
    CLineFull *pliIn,             // CLineFull passed in
    CLineCore **ppliOut,          // CLineCore passed out (first frag or container)
    LONG  *pcpStartContainerLine,
    CMarginInfo *pMarginInfo,     // Margin information
    LONG   cchLine,               // number of characters in the line
    UINT   uiFlags)               // MEASURE_ flags
{
    LSERR lserr = lserrNone;
    LONG xWidthContainerLine;
    LONG cpIgnore;
    LONG cchTotal;
    CTreePos *ptp;
    LONG cpOriginal = GetCp();
    CTreePos *ptpOriginal = GetPtp();
    CLineFull li;

    *ppliOut = AccountForRelativeLines(*pliIn,
                                       pcpStartContainerLine,
                                       &xWidthContainerLine,
                                       &cpIgnore,
                                       &cpIgnore,
                                       &cchTotal
                                      );
    if (*pcpStartContainerLine != GetCp())
        SetCp(*pcpStartContainerLine, NULL);
    _cchPreChars = 0;
    _pdp->FormattingNodeForLine(FNFL_NONE, GetCp(), GetPtp(), cchLine, &_cchPreChars, &ptp, &_fMeasureFromTheStart);
    if (!_fMeasureFromTheStart)
    {
        *pcpStartContainerLine += _cchPreChars;
        SetPtp(ptp, *pcpStartContainerLine);
        if (cchTotal == _cchPreChars)
        {
            lserr = lserrInvalidLine;
            goto Cleanup;
        }
    }
    
    li = **ppliOut;

    // If we are part of relchunk, then AccountForRelLines returns the first line to us
    // which will have lesser number of chars than the container line. So lets change the
    // number of characters to be the total number of characters in the container lines.
    if (li._fPartOfRelChunk)
    {
        li._cch = cchTotal;
    }

    if (_cchPreChars != 0 && !_fMeasureFromTheStart)
    {
        li._cch  -= _cchPreChars;
    }

    if (   li._fFirstInPara
        && (   li._fHasFirstLine
            || li._fHasFirstLetter
           )
       )
    {
        CTreeNode *pNode = ptp->GetBranch();
        pNode = _pLS->_pMarkup->SearchBranchForBlockElement(pNode, _pFlowLayout);
        const CFancyFormat *pFF = pNode->GetFancyFormat();

        _cpStopFirstLetter = ((li._fHasFirstLetter && pFF->_fHasFirstLetter)
                             ? GetCpOfLastLetter(pNode)
                             : -1);
        
        if (li._fHasFirstLine && pFF->_fHasFirstLine)
        {
            PseudoLineEnable(pNode);
        }
        if (li._fHasFirstLetter && pFF->_fHasFirstLetter && _cpStopFirstLetter >= 0)
        {
            PseudoLetterEnable(pNode);
        }
    }

    NewLine(li);
    _li._cch = li._cch;
    _li._xLeft = li._xLeft;
    _li._xLeftMargin = li._xLeftMargin;
    _li._xRight = li._xRight;
    _li._xRightMargin = li._xRightMargin;

    // We want the measure width to the be the width at which the container line was measured.
    // This line is stored in li.
    //_pLS->_li._xMeasureWidth = li._xMeasureWidth;
    _pLS->_li = _li;

    _pLS->SetMeasurer(this,  CLineServices::LSMODE_HITTEST, uiFlags & MEASURE_BREAKLONGLINES ? TRUE : FALSE);
    InitForMeasure(uiFlags);
    lserr = LSDoCreateLine(*pcpStartContainerLine, GetPtp(), pMarginInfo, xWidthContainerLine, &li, FALSE, NULL);

    _pLS->_fHasVerticalAlign = (_pLS->_lineFlags.GetLineFlags(_pLS->_cpLim) & FLAG_HAS_VALIGN) ? TRUE : FALSE;

    if (_pLS->_fHasVerticalAlign)
    {
        _pLS->_li._cch = _pLS->_cpLim - *pcpStartContainerLine;
        _pLS->VerticalAlignObjects(*this, 0);
    }

Cleanup:
    SetCp(cpOriginal, ptpOriginal);
    return lserr;
}

#pragma optimize("", on)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\text\lsconst.cxx ===
/*
 *  @doc    INTERNAL
 *
 *  @module LSCONST.CXX -- line services constants
 *
 *
 *  Owner: <nl>
 *      Chris Thrasher <nl>
 *      Sujal Parikh <nl>
 *
 *  History: <nl>
 *      1/29/97     cthrash created
 *
 *  Copyright (c) 1997-1998 Microsoft Corporation. All rights reserved.
 */

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X__FONT_H_
#define X__FONT_H_
#include "_font.h"
#endif

#ifndef X_LINESRV_HXX_
#define X_LINESRV_HXX_
#include "linesrv.hxx"
#endif

#ifndef X_TREEPOS_HXX_
#define X_TREEPOS_HXX_
#include "treepos.hxx"
#endif

#ifdef DLOAD1
extern "C"  // MSLS interfaces are C
{
#endif

#ifndef X_RUBY_H_
#define X_RUBY_H_
#include <ruby.h>
#endif

#ifndef X_HIH_H_
#define X_HIH_H_
#include <hih.h>
#endif

#ifndef X_TATENAK_H_
#define X_TATENAK_H_
#include <tatenak.h>
#endif

#ifndef X_WARICHU_H_
#define X_WARICHU_H_
#include <warichu.h>
#endif

#ifndef X_ROBJ_H_
#define X_ROBJ_H_
#include <robj.h>
#endif

#ifdef DLOAD1
} // extern "C"
#endif

#ifndef X_WCHDEFS_H_
#define X_WCHDEFS_H_
#include <wchdefs.h>
#endif

#ifndef X_LSM_HXX_
#define X_LSM_HXX_
#include "lsm.hxx"
#endif

#ifdef _MAC
CLineServices::LSCBK CLineServices::s_lscbk =
#else
const CLineServices::LSCBK CLineServices::s_lscbk =
#endif
{
    CLineServices::NewPtr,
    CLineServices::DisposePtr,
    CLineServices::ReallocPtr,
    CLineServices::FetchRun,
    CLineServices::GetAutoNumberInfo,
    CLineServices::GetNumericSeparators,
    CLineServices::CheckForDigit,
    CLineServices::FetchPap,
    CLineServices::FetchTabs,
    CLineServices::GetBreakThroughTab,
    CLineServices::FGetLastLineJustification,
    CLineServices::CheckParaBoundaries,
    CLineServices::GetRunCharWidths,
    CLineServices::CheckRunKernability,
    CLineServices::GetRunCharKerning,
    CLineServices::GetRunTextMetrics,
    CLineServices::GetRunUnderlineInfo,
    CLineServices::GetRunStrikethroughInfo,
    CLineServices::GetBorderInfo,
    CLineServices::ReleaseRun,
    CLineServices::Hyphenate,
    CLineServices::GetHyphenInfo,
    CLineServices::DrawUnderline,
    CLineServices::DrawStrikethrough,
    CLineServices::DrawBorder,
    CLineServices::DrawUnderlineAsText,
    CLineServices::FInterruptUnderline,
    CLineServices::FInterruptShade,
    CLineServices::FInterruptBorder,
    CLineServices::ShadeRectangle,
    CLineServices::DrawTextRun,
    CLineServices::DrawSplatLine,
    CLineServices::FInterruptShaping,
    CLineServices::GetGlyphs,
    CLineServices::GetGlyphPositions,
    CLineServices::ResetRunContents,
    CLineServices::DrawGlyphs,
    CLineServices::GetGlyphExpansionInfo,
    CLineServices::GetGlyphExpansionInkInfo,
    CLineServices::GetEms,
    CLineServices::PunctStartLine,
    CLineServices::ModWidthOnRun,
    CLineServices::ModWidthSpace,
    CLineServices::CompOnRun,
    CLineServices::CompWidthSpace,
    CLineServices::ExpOnRun,
    CLineServices::ExpWidthSpace,
    CLineServices::GetModWidthClasses,
    CLineServices::GetBreakingClasses,
    CLineServices::FTruncateBefore,
    CLineServices::CanBreakBeforeChar,
    CLineServices::CanBreakAfterChar,
    CLineServices::FHangingPunct,
    CLineServices::GetSnapGrid,
    CLineServices::DrawEffects,
    CLineServices::FCancelHangingPunct,
    CLineServices::ModifyCompAtLastChar,
    CLineServices::EnumText,
    CLineServices::EnumTab,
    CLineServices::EnumPen,
    CLineServices::GetObjectHandlerInfo,
    CLineServices::AssertFailed
};


WHEN_DBG( int CLineServices::s_nSerialMax=0; )

const struct lstxtcfg CLineServices::s_lstxtcfg =
{
    LS_AVG_CHARS_PER_LINE,              // cEstimatedCharsPerLine; modify as necessary
    WCH_UNDEF,
    WCH_NULL,
    WCH_SPACE,
    WCH_HYPHEN,
    WCH_TAB,
    WCH_ENDPARA1,
    WCH_ENDPARA2,
    WCH_ALTENDPARA,
    WCH_SYNTHETICLINEBREAK,
    WCH_COLUMNBREAK,
    WCH_SECTIONBREAK,
    WCH_PAGEBREAK,
    WCH_UNDEF,                          // NB (cthrash) Don't let LS default-handle NONBREAKSPACE
    WCH_NONBREAKHYPHEN,
    WCH_NONREQHYPHEN,
    WCH_EMDASH,
    WCH_ENDASH,
    WCH_EMSPACE,
    WCH_ENSPACE,
    WCH_NARROWSPACE,
    WCH_OPTBREAK,
    WCH_NOBREAK,
    WCH_FESPACE,
    WCH_ZWJ,
    WCH_ZWNJ,
    WCH_TOREPLACE,
    WCH_REPLACE,
    WCH_VISINULL,
    WCH_VISIALTENDPARA,
    WCH_VISIENDLINEINPARA,
    WCH_VISIENDPARA,
    WCH_VISISPACE,
    WCH_VISINONBREAKSPACE,
    WCH_VISINONBREAKHYPHEN,
    WCH_VISINONREQHYPHEN,
    WCH_VISITAB,
    WCH_VISIEMSPACE,
    WCH_VISIENSPACE,
    WCH_VISINARROWSPACE,
    WCH_VISIOPTBREAK,
    WCH_VISINOBREAK,
    WCH_VISIFESPACE,
    WCH_ESCANMRUN,
};

CLineServices::LSIMETHODS
CLineServices::g_rgLsiMethods[CLineServices::LSOBJID_COUNT] =
{
    //
    // The order of these is determined by the order of 
    // enum LSOBJID
    //

    // LSOBJID_EMBEDDED
    {
        CLineServices::CreateILSObj,
        CEmbeddedILSObj::DestroyILSObj,
        CEmbeddedILSObj::SetDoc,
        CEmbeddedILSObj::CreateLNObj,
        CEmbeddedILSObj::DestroyLNObj,
        (LSERR (WINAPI CILSObjBase::*)(PCFMTIN, FMTRES*))CEmbeddedILSObj::Fmt,
        (LSERR (WINAPI CILSObjBase::*)(BREAKREC*, DWORD, PCFMTIN, FMTRES*))CEmbeddedILSObj::FmtResume,
        CDobjBase::GetModWidthPrecedingChar,
        CDobjBase::GetModWidthFollowingChar,
        CDobjBase::TruncateChunk,
        CEmbeddedDobj::FindPrevBreakChunk,
        CEmbeddedDobj::FindNextBreakChunk,
        CDobjBase::ForceBreakChunk,
        CDobjBase::SetBreak,  
        CDobjBase::GetSpecialEffectsInside,
        CDobjBase::FExpandWithPrecedingChar,
        CDobjBase::FExpandWithFollowingChar,
        CDobjBase::CalcPresentation,  
        CEmbeddedDobj::QueryPointPcp,
        CEmbeddedDobj::QueryCpPpoint,
        CEmbeddedDobj::Enum,
        CEmbeddedDobj::Display,
        CEmbeddedDobj::DestroyDObj
    },

    // LSOBJID_NOBR
    {
        CLineServices::CreateILSObj,
        CNobrILSObj::DestroyILSObj,
        CNobrILSObj::SetDoc,
        CNobrILSObj::CreateLNObj,
        CNobrILSObj::DestroyLNObj,
        (LSERR (WINAPI CILSObjBase::*)(PCFMTIN, FMTRES*))CNobrILSObj::Fmt,
        (LSERR (WINAPI CILSObjBase::*)(BREAKREC*, DWORD, PCFMTIN, FMTRES*))CNobrILSObj::FmtResume,
        CNobrDobj::GetModWidthPrecedingChar,
        CNobrDobj::GetModWidthFollowingChar,
        CNobrDobj::TruncateChunk,
        CNobrDobj::FindPrevBreakChunk,
        CNobrDobj::FindNextBreakChunk,
        CDobjBase::ForceBreakChunk,
        CNobrDobj::SetBreak,  
        CDobjBase::GetSpecialEffectsInside,
        CDobjBase::FExpandWithPrecedingChar,
        CDobjBase::FExpandWithFollowingChar,
        CNobrDobj::CalcPresentation,  
        CNobrDobj::QueryPointPcp,  
        CNobrDobj::QueryCpPpoint,
        CDobjBase::Enum,
        CNobrDobj::Display,
        CNobrDobj::DestroyDObj
    },

    // LSOBJID_GLYPH
    {
        CLineServices::CreateILSObj,
        CGlyphILSObj::DestroyILSObj,
        CGlyphILSObj::SetDoc,
        CGlyphILSObj::CreateLNObj,
        CGlyphILSObj::DestroyLNObj,
        (LSERR (WINAPI CILSObjBase::*)(PCFMTIN, FMTRES*))CGlyphILSObj::Fmt,
        (LSERR (WINAPI CILSObjBase::*)(BREAKREC*, DWORD, PCFMTIN, FMTRES*))CGlyphILSObj::FmtResume,
        CDobjBase::GetModWidthPrecedingChar,
        CDobjBase::GetModWidthFollowingChar,
        CGlyphDobj::TruncateChunk,
        CGlyphDobj::FindPrevBreakChunk,
        CGlyphDobj::FindNextBreakChunk,
        CDobjBase::ForceBreakChunk,
        CDobjBase::SetBreak,  
        CDobjBase::GetSpecialEffectsInside,
        CDobjBase::FExpandWithPrecedingChar,
        CDobjBase::FExpandWithFollowingChar,
        CDobjBase::CalcPresentation,  
        CGlyphDobj::QueryPointPcp,  
        CGlyphDobj::QueryCpPpoint,
        CDobjBase::Enum,
        CGlyphDobj::Display,
        CGlyphDobj::DestroyDObj
    },

    // LSOBJID_LAYOUTGRID
    {
        CLineServices::CreateILSObj,
        CLayoutGridILSObj::DestroyILSObj,
        CLayoutGridILSObj::SetDoc,
        CLayoutGridILSObj::CreateLNObj,
        CLayoutGridILSObj::DestroyLNObj,
        (LSERR (WINAPI CILSObjBase::*)(PCFMTIN, FMTRES*))CLayoutGridILSObj::Fmt,
        (LSERR (WINAPI CILSObjBase::*)(BREAKREC*, DWORD, PCFMTIN, FMTRES*))CLayoutGridILSObj::FmtResume,
        CDobjBase::GetModWidthPrecedingChar,
        CDobjBase::GetModWidthFollowingChar,
        CLayoutGridDobj::TruncateChunk,
        CLayoutGridDobj::FindPrevBreakChunk,
        CLayoutGridDobj::FindNextBreakChunk,
        CLayoutGridDobj::ForceBreakChunk,
        CLayoutGridDobj::SetBreak,  
        CLayoutGridDobj::GetSpecialEffectsInside,
        CDobjBase::FExpandWithPrecedingChar,
        CDobjBase::FExpandWithFollowingChar,
        CLayoutGridDobj::CalcPresentation,  
        CLayoutGridDobj::QueryPointPcp,  
        CLayoutGridDobj::QueryCpPpoint,
        CDobjBase::Enum,
        CLayoutGridDobj::Display,
        CLayoutGridDobj::DestroyDObj
    },

    // The remainder is populated by LineServices.
};

#if defined(UNIX) || defined(_MAC)
// UNIX uses s_unix_rgLsiMethods to replace g_rgLsiMethods
::LSIMETHODS
CLineServices::s_unix_rgLsiMethods[CLineServices::LSOBJID_COUNT] =
{
    // Will be filled later.
};

// It takes only 4 bytes of each Method pointer in g_rgLsiMethods
#if defined(SPARC) || defined(_MAC) || (defined(_HPUX_SOURCE) && defined(__APOGEE__))
void CLineServices::InitLsiMethodStruct()
{
    int i, j;
    DWORD *pdest = (DWORD*)s_unix_rgLsiMethods;
    DWORD *psrc = (DWORD*)g_rgLsiMethods;
    // The # of bytes of each member of LSIMETHODS
    // Macintosh uses 12 byte entries not 8
    int s_LSIMETHODS_Sizes[] = {8,8,8,8,8,8,8,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4};

    for (i=0; i< 3; i++) // 3 sub-structs were initialized in g_rgLsiMethods
        for (j=0; j< 23; j++) // Each sub-struct has 23 members
        {
            if (s_LSIMETHODS_Sizes[j] == 8)
            {
#ifdef _MAC
                psrc++; // skip an extra 4 bytes
#endif
                psrc++; // skip the first 4 bytes
            }
            *pdest++ = *psrc++;
        }
}
#else // HP
#error "HP uses 12 bytes method ptrs, so it needs to implement differently"
#endif //SPARC
#endif //UNIX

const CLineServices::RUBYINIT CLineServices::s_rubyinit =
{
    RUBY_VERSION,
    RubyMainLineFirst,
    WCH_ESCRUBY,
    WCH_ESCMAIN,
    WCH_NULL,
    WCH_NULL,
    CLineServices::FetchRubyPosition,
    CLineServices::FetchRubyWidthAdjust,
    CLineServices::RubyEnum,
};

#if defined(UNIX) || defined(_MAC)
::RUBYINIT CLineServices::s_unix_rubyinit =
{
    // will be filled out later
};
#if defined(SPARC) || defined(_MAC) || (defined(_HPUX_SOURCE) && defined(__APOGEE__))
int CLineServices::InitRubyinit()
{
    static BOOL fInit = FALSE;
    int cMethodPtrs = 3;
    if (!fInit)
    {
        BYTE* pdest = (BYTE*)&s_unix_rubyinit;
        BYTE* psrc  = (BYTE*)&s_rubyinit;

#ifdef _MAC
        int iFirst = sizeof(RUBYINIT) - cMethodPtrs * 12; // 3 12-bytes member;
#else
        int iFirst = sizeof(RUBYINIT) - cMethodPtrs * 8; // 3 8-bytes member;
#endif
        memcpy(pdest, psrc, iFirst);
        pdest += iFirst;
        psrc += iFirst;

        for(int i=0; i< cMethodPtrs; i++)
        {
#ifdef _MAC
            psrc += sizeof(DWORD);
#endif
            psrc += sizeof(DWORD);
            *(DWORD*)pdest = *(DWORD*)psrc;
            pdest += sizeof(DWORD);
            psrc  += sizeof(DWORD);
        }
        fInit = TRUE;
    }
    return cMethodPtrs * sizeof(DWORD);
}
#else
#error "HP needs to implement differently"
#endif
#endif // UNIX || _MAC

const CLineServices::TATENAKAYOKOINIT CLineServices::s_tatenakayokoinit =
{
    TATENAKAYOKO_VERSION,
    WCH_ENDTATENAKAYOKO,
    WCH_NULL,
    WCH_NULL,
    WCH_NULL,
    CLineServices::GetTatenakayokoLinePosition,
    CLineServices::TatenakayokoEnum,
};

#if defined(UNIX) || defined(_MAC)
::TATENAKAYOKOINIT CLineServices::s_unix_tatenakayokoinit =
{
    // will be filled later
};

int CLineServices::InitTatenakayokoinit()
{
    static BOOL fInit = FALSE;
    int cMethodPtrs = 2;
    if (!fInit)
    {
        BYTE* pdest = (BYTE*)&s_unix_tatenakayokoinit;
        BYTE* psrc  = (BYTE*)&s_tatenakayokoinit;

#ifdef _MAC
        int iFirst = sizeof(TATENAKAYOKOINIT) - cMethodPtrs * 12; // 2 12-bytes member;
#else
        int iFirst = sizeof(TATENAKAYOKOINIT) - cMethodPtrs * 8; // 2 8-bytes member;
#endif
        memcpy(pdest, psrc, iFirst);
        pdest += iFirst;
        psrc += iFirst;

        for(int i=0; i< cMethodPtrs; i++)
        {
#ifdef _MAC
            psrc += sizeof(DWORD);
#endif
            psrc += sizeof(DWORD);
            *(DWORD*)pdest = *(DWORD*)psrc;
            pdest += sizeof(DWORD);
            psrc  += sizeof(DWORD);
        }
        fInit = TRUE;
    }
    return cMethodPtrs * sizeof(DWORD);
}
#endif

const CLineServices::HIHINIT CLineServices::s_hihinit =
{
    HIH_VERSION,
    WCH_ENDHIH,
    WCH_NULL,
    WCH_NULL,
    WCH_NULL,
    CLineServices::HihEnum,
};

#if defined(UNIX) || defined(_MAC)
::HIHINIT CLineServices::s_unix_hihinit =
{
    // will be filled later
};
#if defined(SPARC) || (defined(_HPUX_SOURCE) && defined(__APOGEE__))
int CLineServices::InitHihinit()
{
    static BOOL fInit = FALSE;
    int cMethodPtrs = 1;
    if (!fInit)
    {
        BYTE* pdest = (BYTE*)&s_unix_hihinit;
        BYTE* psrc  = (BYTE*)&s_hihinit;

#ifdef _MAC
        int iFirst = sizeof(HIHINIT) - 12; // 1 12-bytes member;
#else
        int iFirst = sizeof(HIHINIT) - 8; // 1 8-bytes member;
#endif
        memcpy(pdest, psrc, iFirst);
        pdest += iFirst;
        psrc += iFirst;

#ifdef _MAC
        psrc += sizeof(DWORD);
#endif
        psrc += sizeof(DWORD);
        *(DWORD*)pdest = *(DWORD*)psrc;
        fInit = TRUE;
    }
    return cMethodPtrs * sizeof(DWORD);
}
#else
#error "HP needs to implement this function"
#endif
#endif // UNIX

const CLineServices::WARICHUINIT CLineServices::s_warichuinit =
{
    WARICHU_VERSION,
    WCH_ENDFIRSTBRACKET,
    WCH_ENDTEXT,
    WCH_ENDWARICHU,
    WCH_NULL,
    CLineServices::GetWarichuInfo,
    CLineServices::FetchWarichuWidthAdjust,
    CLineServices::WarichuEnum,
    FALSE
};

#if defined(UNIX) || defined(_MAC)
::WARICHUINIT CLineServices::s_unix_warichuinit =
{
    // will be filled later
};

#if defined(SPARC) || (defined(_HPUX_SOURCE) && defined(__APOGEE__))
int CLineServices::InitWarichuinit()
{
    static BOOL fInit = FALSE;
    int cMethodPtrs = 3; 
    if (!fInit)
    {
        BYTE* pdest = (BYTE*)&s_unix_warichuinit;
        BYTE* psrc  = (BYTE*)&s_warichuinit;

#ifdef _MAC
        int iFirst = sizeof(WARICHUINIT) - cMethodPtrs * 12; // 3 12-bytes member;
#else
        int iFirst = sizeof(WARICHUINIT) - cMethodPtrs * 8; // 3 8-bytes member;
#endif
        memcpy(pdest, psrc, iFirst);
        pdest += iFirst;
        psrc += iFirst;

        for(int i=0; i< cMethodPtrs; i++)
        {
#ifdef _MAC
            psrc += sizeof(DWORD);
#endif
            psrc += sizeof(DWORD);
            *(DWORD*)pdest = *(DWORD*)psrc;
            pdest += sizeof(DWORD);
            psrc  += sizeof(DWORD);
        }
        fInit = TRUE;
    }
    return cMethodPtrs * sizeof(DWORD);
}
#else
#error "HP needs to implement this function"
#endif
#endif // UNIX

const CLineServices::REVERSEINIT CLineServices::s_reverseinit =
{
    REVERSE_VERSION,
    WCH_ENDREVERSE,
    WCH_NULL,
    0,
    CLineServices::ReverseEnum,
};

#if defined(UNIX) || defined(_MAC)
::REVERSEINIT CLineServices::s_unix_reverseinit =
{
    // will be filled later
};

#if defined(SPARC) || (defined(_HPUX_SOURCE) && defined(__APOGEE__))
int CLineServices::InitReverseinit()
{
    static BOOL fInit = FALSE;
    int cMethodPtrs = 1;
    if (!fInit)
    {
        BYTE* pdest = (BYTE*)&s_unix_reverseinit;
        BYTE* psrc  = (BYTE*)&s_reverseinit;

#ifdef _MAC
        int iFirst = sizeof(REVERSEINIT) - 8; // 1 8-bytes member;
#else
        int iFirst = sizeof(REVERSEINIT) - 8; // 1 8-bytes member;
#endif
        memcpy(pdest, psrc, iFirst);
        pdest += iFirst;
        psrc += iFirst;

#ifdef _MAC
        psrc += sizeof(DWORD);
#endif
        psrc += sizeof(DWORD);
        *(DWORD*)pdest = *(DWORD*)psrc;
        fInit = TRUE;
    }
    return cMethodPtrs * sizeof(DWORD);
}
#else
#error "HP needs to implement this function"
#endif
#endif // UNIX

const WCHAR CLineServices::s_achTabLeader[tomLines] =
{
    WCH_NULL,
    WCH_DOT,
    WCH_HYPHEN
};

const CLineServices::SYNTHDATA
CLineServices::s_aSynthData[SYNTHTYPE_COUNT] =
{
//
//    wch               idObj               typeEndObj              idLevel     fObjStart   fObjEnd,    fHidden     fLSCPStop   pszSynthName
//
    { WCH_UNDEF,        idObjTextChp,       SYNTHTYPE_NONE,         0,          FALSE,      FALSE,      TRUE,       FALSE,      WHEN_DBG(_T("[none]")) },
    { WCH_SECTIONBREAK, idObjTextChp,       SYNTHTYPE_NONE,         0,          FALSE,      FALSE,      FALSE,      FALSE,      WHEN_DBG(_T("[sectionbreak]")) },
    { WCH_REVERSE,      LSOBJID_REVERSE,    SYNTHTYPE_ENDREVERSE,   2,          TRUE,       FALSE,      FALSE,      FALSE,      WHEN_DBG(_T("[reverse]")) },
    { WCH_ENDREVERSE,   LSOBJID_REVERSE,    SYNTHTYPE_NONE,         2,          FALSE,      TRUE,       FALSE,      FALSE,      WHEN_DBG(_T("[endreverse]")) },
    { WCH_NOBRBLOCK,    LSOBJID_NOBR,       SYNTHTYPE_ENDNOBR,      3,          TRUE,       FALSE,      FALSE,      FALSE,      WHEN_DBG(_T("[nobr]")) },
    { WCH_NOBRBLOCK,    LSOBJID_NOBR,       SYNTHTYPE_NONE,         3,          FALSE,      TRUE,       FALSE,      FALSE,      WHEN_DBG(_T("[endnobr]")) },
    { WCH_ENDPARA1,     idObjTextChp,       SYNTHTYPE_NONE,         0,          FALSE,      FALSE,      FALSE,      TRUE,       WHEN_DBG(_T("[endpara1]")) },
    { WCH_ALTENDPARA,   idObjTextChp,       SYNTHTYPE_NONE,         0,          FALSE,      FALSE,      FALSE,      FALSE,      WHEN_DBG(_T("[altendpara]")) },
    { WCH_UNDEF,     	LSOBJID_RUBY,       SYNTHTYPE_ENDRUBYTEXT,  1,          TRUE,       FALSE,      FALSE,      FALSE,      WHEN_DBG(_T("[rubymain]")) },
    { WCH_ESCMAIN,     	LSOBJID_RUBY,       SYNTHTYPE_NONE,         1,       	TRUE,       TRUE,       FALSE,      FALSE,      WHEN_DBG(_T("[endrubymain]")) },
    { WCH_ESCRUBY,     	LSOBJID_RUBY,       SYNTHTYPE_NONE,         1,       	FALSE,      TRUE,       FALSE,      FALSE,      WHEN_DBG(_T("[endrubytext]")) },
    { WCH_SYNTHETICLINEBREAK, idObjTextChp, SYNTHTYPE_NONE,         0,          FALSE,      FALSE,      FALSE,      TRUE,       WHEN_DBG(_T("[linebreak]")) },
    { WCH_UNDEF,        LSOBJID_GLYPH,      SYNTHTYPE_NONE,         0,          FALSE,      FALSE,      FALSE,      TRUE,       WHEN_DBG(_T("[glyph]")) },
    { WCH_LAYOUTGRID,   LSOBJID_LAYOUTGRID, SYNTHTYPE_ENDLAYOUTGRID,1,          TRUE,       FALSE,      FALSE,      FALSE,      WHEN_DBG(_T("[layoutgrid]")) },
    { WCH_ENDLAYOUTGRID,LSOBJID_LAYOUTGRID, SYNTHTYPE_NONE,         1,          FALSE,      TRUE,       FALSE,      FALSE,      WHEN_DBG(_T("[endlayoutgrid]")) },
    { WCH_NODE,         idObjTextChp,       SYNTHTYPE_NONE,         0,          FALSE,      FALSE,      FALSE,      TRUE,       WHEN_DBG(_T("[mbp open]")) },
    { WCH_NODE,         idObjTextChp,       SYNTHTYPE_NONE,         0,          FALSE,      FALSE,      FALSE,      TRUE,       WHEN_DBG(_T("[mbp close]")) },
    { WCH_NODE,         idObjTextChp,       SYNTHTYPE_NONE,         0,          FALSE,      FALSE,      FALSE,      FALSE,      WHEN_DBG(_T("[wbr]")) },
};

//
// This is a line-services structure defining an escape sequence.
// In this case, it is the escape sequence ending LS installed 
// object. A pair of characters represents a range of characters,
// which ends an object.
//
const LSESC CNobrILSObj::s_lsescEndNOBR[NBREAKCHARS] = 
{
    {WCH_NOBRBLOCK,  WCH_NOBRBLOCK},
};

const LSESC CLayoutGridILSObj::s_lsescEndLayoutGrid[NBREAKCHARS] = 
{
    {WCH_ENDLAYOUTGRID,  WCH_ENDLAYOUTGRID},
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\text\lsm2.cxx ===
/*
 *  LSM2.CXX -- CLSMeasurer class
 *
 *  Authors:
 *      Sujal Parikh
 *      Chris Thrasher
 *      Paul  Parker
 *
 *  History:
 *      2/27/98     sujalp created
 *
 *  Copyright (c) 1997-1998 Microsoft Corporation. All rights reserved.
 */

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_LSM_HXX_
#define X_LSM_HXX_
#include "lsm.hxx"
#endif

#ifndef X__FONT_H_
#define X__FONT_H_
#include "_font.h"
#endif

#ifndef X__DISP_H_
#define X__DISP_H_
#include "_disp.h"
#endif

#ifndef X_TREEPOS_HXX_
#define X_TREEPOS_HXX_
#include "treepos.hxx"
#endif

#ifndef X_NUMCONV_HXX_
#define X_NUMCONV_HXX_
#include "numconv.hxx"
#endif

#ifndef X_DOWNLOAD_HXX_
#define X_DOWNLOAD_HXX_
#include "download.hxx"
#endif

#ifndef X__FONTLNK_H_
#define X__FONTLNK_H_
#include "_fontlnk.h"
#endif

#ifndef X_OBJDIM_H_
#define X_OBJDIM_H_
#include <objdim.h>
#endif

#ifndef X_POBJDIM_H_
#define X_POBJDIM_H_
#include <pobjdim.h>
#endif

#ifndef X_HEIGHTS_H_
#define X_HEIGHTS_H_
#include <heights.h>
#endif

#ifndef X_FLOWLYT_HXX_
#define X_FLOWLYT_HXX_
#include <flowlyt.hxx>
#endif

#ifndef X_LINESRV_HXX_
#define X_LINESRV_HXX_
#include "linesrv.hxx"
#endif

#ifndef X_ONERUN_HXX_
#define X_ONERUN_HXX_
#include "onerun.hxx"
#endif

ExternTag(tagDontReuseLinkFonts);
MtDefine(CFormatStash_pv, Locals, "Format Stash");

#if DBG!=1
#pragma optimize(SPEED_OPTIMIZE_FLAGS, on)
#endif

//+----------------------------------------------------------------------------
//
//  Member:     CLSMeasurer::Resync()
//
//  Synopsis:   This is temporary fn till we are using the CLSMeasurer and
//              CMeasurer. Essentiall does me = lsme
//
//-----------------------------------------------------------------------------

void
CLSMeasurer::Resync()
{
    _cAlignedSites = _pLS->_cAlignedSites;
    _cAlignedSitesAtBeginningOfLine = _pLS->_cAlignedSitesAtBOL;
    _cchWhiteAtBeginningOfLine = _pLS->_cWhiteAtBOL;
    _fLastWasBreak = _pLS->_li._fHasBreak;
}

//+----------------------------------------------------------------------------
//  Member:     CLSMeasurer::MeasureListIndent()
//
//  Synopsis:   Compute and indent of line due to list properties (bullets and
//              numbering) in device units
//
//-----------------------------------------------------------------------------

void CLSMeasurer::MeasureListIndent()
{
    const   CParaFormat *pPF;
    BOOL    fInner = FALSE; // Keep retail compiler happy
    LONG    dxOffset = 0;
    LONG    dxPFOffset;
    CTreePos *ptp;
    
    if (!_fMeasureFromTheStart)
    {
        pPF = MeasureGetPF(&fInner);
        ptp = GetPtp();
    }
    else
    {
        LONG cp = GetCp() + _cchPreChars;
        ptp = GetMarkup()->TreePosAtCp(cp, NULL, FALSE);
        pPF = ptp->GetBranch()->GetParaFormat();
    }

    dxPFOffset = pPF->GetBulletOffset(GetCalcInfo());

    // Adjust the line height if the current line has a bullet or number.
    // Get offset of the bullet.
    if (_li._fHasBulletOrNum)
    {
        SIZE sizeImg;
        if (   pPF->GetImgCookie() 
            && MeasureImage(pPF->GetImgCookie(), &sizeImg))
        {
            // If we have an image cookie, try measuring the image.
            // If it has not come in yet or does not exist, fall through
            // to either bullet or number measuring.

            dxOffset = sizeImg.cx;

            // Adjust line height if necessary
            if (sizeImg.cy > _li._yHeight - _li._yDescent)
                _li._yHeight = sizeImg.cy + _li._yDescent;

            _li._yBulletHeight = sizeImg.cy;
        }
        else
        {
            switch (pPF->GetListing().GetType())
            {
                case CListing::BULLET:
                    MeasureSymbol(ptp, chDisc, &dxOffset);
                    break;

                case CListing::NUMBERING:
                    MeasureNumber(ptp, pPF, &dxOffset);
                    break;
            }
        }

        dxOffset = max(int(dxOffset), _pci->DeviceFromTwipsX(LIST_FIRST_REDUCTION_TWIPS));
    }

    // In case of bullet position inside adjust _xLeft, if necessary.
    if (   dxOffset > dxPFOffset
        && pPF->_bListPosition == styleListStylePositionInside)
    {
        if (!pPF->HasRTL(fInner))
        {
            _li._xLeft += dxOffset - dxPFOffset;
        }
        else
        {
            _li._xRight += dxOffset - dxPFOffset;
        }
    }
}

//+----------------------------------------------------------------------------
//
// Member:      CLSMeasurer::MeasureNumber(pxWidth, pyHeight)
//
// Synopsis:    Computes number width and height (if any)
//
// Returns:     number width and height
//
//-----------------------------------------------------------------------------

void CLSMeasurer::MeasureNumber(CTreePos *ptp, const CParaFormat *ppf, LONG *pxWidth)
{
    CCcs          ccs;
    CTreeNode   * pNodeLI;

    pNodeLI = GetMarkup()->SearchBranchForCriteriaInStory(ptp->GetBranch(), IsListItemNode);
    Assert(pNodeLI);
    
    const  CCharFormat *pCF = pNodeLI->GetCharFormat();
    GetCcsNumber(&ccs, pCF);
    AssertSz(pxWidth, "CLSMeasurer::MeasureNumber: invalid arg(s)");

    Assert(ccs.GetBaseCcs());

    // NOTE (cthrash) Currently we employ Netscape-sytle numbering.
    // This means we don't adjust for the size of the index value,
    // keeping the offset constant regardless of the size of the index value
    // string.
    *pxWidth = 0;

    if (ccs.GetBaseCcs())
    {
        LONG yAscent, yDescent;

        ccs.GetBaseCcs()->GetAscentDescent(&yAscent, &yDescent);
        _li._yBulletHeight = yAscent + yDescent;
        _pLS->RecalcLineHeight(pCF, GetCp(), &ccs, &_li);
        ccs.Release();
    }
}

//+----------------------------------------------------------------------------
//
// Member:      CLSMeasurer::GetCcsSymbol() (used for symbols & bullets)
//
// Synopsis:    Get CCcs for symbol font
//
// Returns:     ptr to symbol font CCcs
//
//-----------------------------------------------------------------------------

// Default character format for a bullet
static CCharFormat s_cfBullet;

BOOL
CLSMeasurer::GetCcsSymbol(
    CCcs *              pccs,
    TCHAR               chSymbol,
    const CCharFormat * pcf,
    CCharFormat *       pcfRet)
{
    CCharFormat         cf;
    CCharFormat *       pcfUsed = (pcfRet != NULL) ? pcfRet : &cf;
    static BOOL         s_fBullet = FALSE;
    BOOL                fRet;
    
    Assert(pccs);
    if (!s_fBullet)
    {
        // N.B. (johnv) For some reason, Win95 does not render the Windings font properly
        //  for certain characters at less than 7 points.  Do not go below that size!
        s_cfBullet.SetHeightInTwips( TWIPS_FROM_POINTS ( 7 ) );
        s_cfBullet._bCharSet = SYMBOL_CHARSET;
        s_cfBullet._fNarrow = FALSE;
        s_cfBullet._bPitchAndFamily = (BYTE) FF_DONTCARE;
        s_cfBullet.SetFaceNameAtom(fc().GetAtomWingdings());
        s_cfBullet._bCrcFont = s_cfBullet.ComputeFontCrc();

        s_fBullet = TRUE;
    }

    // Use bullet char format
    *pcfUsed = s_cfBullet;

    pcfUsed->_ccvTextColor    = pcf->_ccvTextColor;

    // Since we always cook up the bullet character format, we don't need
    // to cache it.
    if (fc().GetCcs(pccs, _pci->_hdc, _pci, pcfUsed))
    {
        // Important - CM_SYMBOL is a special mode where out WC chars are actually
        // zero-extended MB chars.  This allows us to have a codepage-independent
        // call to ExTextOutA. (cthrash)

        pccs->SetConvertMode(CM_SYMBOL);
        fRet = TRUE;
    }
    else
    {
        TraceTag((tagError, "CRchMeasurer::GetCcsBullet(): no CCcs"));
        fRet = FALSE;
    }

    return fRet;
}

//+----------------------------------------------------------------------------
//
//  Member:     CLSMeasurer::GetCcsNumber()
//
//  Synopsis:   Get CCcs for numbering font
//
//  Returns:    ptr to numbering CCcs
//
//  Comment:    The font for the number could change with every instance of a
//              number, because it is subject to the implied formatting of the
//              LI.
//
//-----------------------------------------------------------------------------

BOOL
CLSMeasurer::GetCcsNumber (CCcs *pccs, const CCharFormat * pCF, CCharFormat * pCFRet)
{
    CCharFormat cf = *pCF;

    cf._fSubscript = cf._fSuperscript = FALSE;
    cf._bCrcFont = cf.ComputeFontCrc();

    if(pCFRet)
        *pCFRet = cf;

    return fc().GetCcs(pccs, _pci->_hdc, _pci, &cf);
}

//+----------------------------------------------------------------------------
//
//  Member:     CLSMeasurer::MeasureSymbol()
//
//  Synopsis:   Measures the special character in WingDings
//
//  Returns:    Nothing
//
//  Note:       that this function returns ascent of the font
//              rather than the entire height. This means that the
//              selected symbol (bullet) character should NOT have a descender.
//
//-----------------------------------------------------------------------------

void CLSMeasurer::MeasureSymbol (CTreePos *ptp, TCHAR chSymbol, LONG *pxWidth)
{
    const      CCharFormat *pCF;
    LONG       xWidthTemp;
    CTreeNode *pNode;
    CCcs       ccs;

    AssertSz(pxWidth, "CLSMeasurer::MeasureSymbol: invalid arg(s)");
    
    pNode = GetMarkup()->SearchBranchForCriteriaInStory(ptp->GetBranch(), IsListItemNode);
    Assert(pNode);
    pCF = pNode->GetCharFormat();
    GetCcsSymbol(&ccs, chSymbol, pCF);

    xWidthTemp = 0;

    if(ccs.GetBaseCcs())
    {
        if(!ccs.Include(chSymbol, xWidthTemp))
        {
            TraceTag((tagError,
                "CLSMeasurer::MeasureSymbol(): Error filling CCcs"));
        }

        xWidthTemp += ccs.GetBaseCcs()->_xUnderhang + ccs.GetBaseCcs()->_xOverhangAdjust;
    }

    *pxWidth = xWidthTemp;

    if (ccs.GetBaseCcs())
    {
        LONG yAscent, yDescent;
        
        ccs.GetBaseCcs()->GetAscentDescent(&yAscent, &yDescent);
        _li._yBulletHeight = yAscent + yDescent;
        ccs.Release();

        // Get the height of normal text in the site.
        // I had originally used the height of the LI,
        // but Netscape doesn't seem to do that. It's
        // possible that they actually have a fixed
        // height for the bullets.
        // (dmitryt, staryear 2001) only do this ancient netscapizm if
        // we don't have line-height, otherwise use LI's CharFormat.
        if (pCF->_cuvLineHeight.IsNull()) 
        {
            CTreePos *ptpStart;
            _pFlowLayout->GetContentTreeExtent(&ptpStart, NULL);
            pCF = ptpStart->Branch()->GetCharFormat();
        }
        
        if (fc().GetCcs(&ccs, _pci->_hdc, _pci, pCF))
        {
            _pLS->RecalcLineHeight(pCF, GetCp(), &ccs, &_li);
            ccs.Release();
        }
    }
}

BOOL
CLSMeasurer::MeasureImage(long lImgCookie, SIZE * psizeImg)
{
    CMarkup * pMarkup = _pFlowLayout->GetOwnerMarkup();
    CDoc    * pDoc = pMarkup->Doc();
    CImgCtx * pImgCtx = pDoc->GetUrlImgCtx(lImgCookie);

    if (!pImgCtx || !(pImgCtx->GetState(FALSE, psizeImg) & IMGLOAD_COMPLETE))
    {
        psizeImg->cx = psizeImg->cy = 0;
        return FALSE;
    }

    // The *psizeImg obtained from getState() assumed to be in OM pixels
    _pci->DeviceFromDocPixels(*psizeImg, *psizeImg);

    return TRUE;
}


//-----------------------------------------------------------------------------
//
// Member:      TestForClear
//
// Synopsis:    Tests if the clear bit is to be set and returns the result
//
//-----------------------------------------------------------------------------

BOOL
CLSMeasurer::TestForClear(const CMarginInfo *pMarginInfo, LONG cp, BOOL fShouldMarginsExist, const CFancyFormat *pFF)
{
    //
    // If margins are not necessary for clear to be turned on, then lets ignore it
    // and just check the flags inside the char format. Bug 47575 shows us that
    // if clear has been applied to BR's and that line contains a aligned image, then 
    // the margins have not been setup yet (since the image will be measure
    // *after* the line is measured. However, if we do not turn on clear left/right
    // here then we will never clear the margins!
    //
    BOOL fClearLeft  =    (!fShouldMarginsExist || pMarginInfo->HasLeftMargin())
                       && pFF->_fClearLeft;
    BOOL fClearRight =    (!fShouldMarginsExist || pMarginInfo->HasRightMargin())
                       && pFF->_fClearRight;
    
    if (cp >= 0)
    {
        Assert(_pLS);
        if (fClearLeft)
            _pLS->_lineFlags.AddLineFlag(cp, FLAG_HAS_CLEARLEFT);
        if (fClearRight)
            _pLS->_lineFlags.AddLineFlag(cp, FLAG_HAS_CLEARRIGHT);
    }
    
    return fClearLeft || fClearRight;
}


//-----------------------------------------------------------------------------
//
//  Function:   AdjustForMargins
//
//  Synopsis:   Adjust the RECT for margins, including negative margins and
//              the beginning and end of lines.
//
//-----------------------------------------------------------------------------
void
CLSMeasurer::AdjustForMargins(CRect *prc, CBorderInfo *pborderInfo, CTreeNode *pNode,
                             const CFancyFormat *pFF, const CCharFormat *pCF,
                             BOOL fBOLWrapped, BOOL fEOLWrapped, BOOL fIsPseudoMBP)
{
    BOOL fNodeVertical = pCF->HasVerticalLayoutFlow();
    BOOL fWritingModeUsed = pCF->_fWritingModeUsed;
    LONG lFontHeight = pCF->GetHeightInTwips(_pdp->GetMarkup()->Doc());
    LONG xParentWidth = 0;

    CUnitValue cuvMarginLeft;
    CUnitValue cuvMarginRight;
    // We do not want to include the margin in the rect we 
    // are going to draw the border around
    if (fIsPseudoMBP)
    {
        const CPseudoElementInfo * pPEI = GetPseudoElementInfoEx(pFF->_iPEI);

        cuvMarginLeft  = pPEI->GetLogicalMargin(SIDE_LEFT, fNodeVertical, fWritingModeUsed, pFF);
        cuvMarginRight = pPEI->GetLogicalMargin(SIDE_RIGHT, fNodeVertical, fWritingModeUsed, pFF);

        if (cuvMarginLeft.IsPercent() || cuvMarginRight.IsPercent())
        {
            xParentWidth = pNode->GetParentWidth(_pci, _pci->_sizeParent.cx);
        }
    }
    else
    {
        cuvMarginLeft  = pFF->GetLogicalMargin(SIDE_LEFT, fNodeVertical, fWritingModeUsed);
        cuvMarginRight = pFF->GetLogicalMargin(SIDE_RIGHT, fNodeVertical, fWritingModeUsed);

        if (cuvMarginLeft.IsPercent() || cuvMarginRight.IsPercent())
        {
            xParentWidth = pNode->GetParentWidth(_pci, _pci->_sizeParent.cx);
        }
    }

    if (!fBOLWrapped)
    {
        long xMarginLeft = cuvMarginLeft.XGetPixelValue(_pci, cuvMarginLeft.IsPercent() ?  xParentWidth : _pci->_sizeParent.cx, lFontHeight);
        if (xMarginLeft > 0)
            prc->left += xMarginLeft;
    }

    if (!fEOLWrapped)
    {
        long xMarginRight = cuvMarginRight.XGetPixelValue(_pci, cuvMarginRight.IsPercent() ? xParentWidth : _pci->_sizeParent.cx, lFontHeight);
        if (xMarginRight > 0)
            prc->right -= xMarginRight;
    }
}

//-----------------------------------------------------------------------------
//
// Member:      FindMBPAboveNode
//
//-----------------------------------------------------------------------------
void
CLSMeasurer::FindMBPAboveNode(CElement *pElement, LONG *plmbpTop, LONG *plmbpBottom)
{
    CTreeNode *pNode = pElement->GetFirstBranch();
    CTreeNode *pNodeStop = _pdp->GetFlowLayout()->GetFirstBranch();
    WHEN_DBG(CTreeNode *pNodeTemp = NULL;)
    const CCharFormat *pCF;

    Assert(plmbpTop && plmbpBottom);
    
    if (!pNode || SameScope(pNode, pNodeStop))
        goto Cleanup;

    // Gather the MBP info from my parent up.
    pNode = pNode->Parent();
    if (!pNode)
        goto Cleanup;

    *plmbpTop = *plmbpBottom = 0;
    pCF = pNode->GetCharFormat(LC_TO_FC(_pci->GetLayoutContext()));

    while(   pCF->_wSpecialObjectFlags()
          && !SameScope(pNode, pNodeStop)
         )
    {
        CRect rcDimensions;
        BOOL fIgnore;

        // Check if the current node has any MBP, and if so, does it start before
        // this line. If it does, then add it to the stack.
        if (   pNode->HasInlineMBP(LC_TO_FC(_pci->GetLayoutContext()))
            && pNode->GetInlineMBPContributions(_pci, GIMBPC_ALL, &rcDimensions, &fIgnore, &fIgnore)
           )
        {
            *plmbpTop += rcDimensions.top;
            *plmbpBottom += rcDimensions.bottom;
        }

        WHEN_DBG(pNodeTemp = pNode;)
        pNode = pNode->Parent();
        if (!pNode)
        {
            Assert(   pNodeTemp->Element()->HasMasterPtr()
                   && pNodeTemp->Element()->GetMasterPtr() == pNodeStop->Element()
                  );
            break;
        }

        pCF = pNode->GetCharFormat();
    }

Cleanup:
    return;
}

//-----------------------------------------------------------------------------
//
// Member:      SetupMBPInfoInLS
//
//-----------------------------------------------------------------------------
void
CLSMeasurer::SetupMBPInfoInLS(CDataAry<CTreeNode*> *paryNodes)
{
    CTreeNode *pNode = GetPtp()->GetBranch();
    CTreeNode *pNodeStop = _pdp->GetFlowLayout()->GetFirstBranch();
    LONG cpFirstOnLine = GetCp() - (_fMeasureFromTheStart ? 0 : _cchPreChars);
    BOOL fFirstNode = TRUE;
    BOOL fAdded;
    BOOL fStartsOnPreviousLine;
    WHEN_DBG(CTreeNode *pNodeTemp = NULL;)

    Assert(_pLS->_mbpTopCurrent == 0);
    Assert(_pLS->_mbpBottomCurrent == 0);

    const CCharFormat *pCF;
    COneRun* por = _pLS->_listCurrent._pHead;

    // por is used only if paryNodes is not NULL. That happens when this function
    // is called from DrawInlineBordersAndBg(), in which case the one run list
    // *is* intialized. Make sure that it is.
    Assert(   paryNodes == NULL
           || por != NULL
          );

    if (   pNode->ShouldHaveLayout()
        && !SameScope(pNode, pNodeStop)
       )
    {
        pNode = pNode->Parent();
        Assert(SameScope(pNode, pNodeStop) || !pNode->ShouldHaveLayout());
        fFirstNode = FALSE;
    }

    pCF = pNode->GetCharFormat(LC_TO_FC(_pci->GetLayoutContext()));
    
    while(   pCF->_wSpecialObjectFlags()
          && !SameScope(pNode, pNodeStop)
         )
    {
        const CFancyFormat *pFF = pNode->GetFancyFormat(LC_TO_FC(_pci->GetLayoutContext()));

        fAdded = FALSE;
        fStartsOnPreviousLine = FALSE;

        // If the element begins before this line, then it will influence the
        // extent of the line, since this element has MBP
        if (pNode->Element()->GetFirstCp() - 1 < cpFirstOnLine)
        {
            fStartsOnPreviousLine = TRUE;
            
            // Check if the current node has any MBP, and if so, does it start before
            // this line. If it does, then add it to the stack.
            if (pNode->HasInlineMBP(LC_TO_FC(_pci->GetLayoutContext())))
            {
                CRect rcDimensions;
                BOOL fIgnore;

                if (pNode->GetInlineMBPContributions(_pci, GIMBPC_ALL, &rcDimensions, &fIgnore, &fIgnore))
                {
                    _pLS->_mbpTopCurrent += rcDimensions.top;
                    _pLS->_mbpBottomCurrent += rcDimensions.bottom;
                    _pLS->_lineFlags.AddLineFlag(_pLS->_cpStart, FLAG_HAS_NOBLAST | FLAG_HAS_MBP);
                    if (   _pLS->HasBorders(pNode->GetFancyFormat(), pNode->GetCharFormat(), FALSE)
                        || pFF->HasBackgrounds(FALSE))
                    {
                        if (   paryNodes
                            && (   !por->_fCharsForNestedElement
                                || !fFirstNode))
                        {
                            paryNodes->AppendIndirect(&pNode);
                            fAdded = TRUE;
                        }
                        _pLS->_lineFlags.AddLineFlag(_pLS->_cpStart, FLAG_HAS_INLINE_BG_OR_BORDER);
                    }
                }
            }
        }
        
        if (   !pFF->_fBlockNess
            && pFF->HasBackgrounds(FALSE))
        {
            _pLS->_lineFlags.AddLineFlag(_pLS->_cpStart, FLAG_HAS_NOBLAST | FLAG_HAS_INLINE_BG_OR_BORDER);
            if (   !fAdded
                && fStartsOnPreviousLine
                && paryNodes
                && (   !por->_fCharsForNestedElement
                    || !fFirstNode))
                paryNodes->AppendIndirect(&pNode);
        }

        WHEN_DBG(pNodeTemp = pNode;)
        pNode = pNode->Parent();
        if (!pNode)
        {
            Assert(pNodeTemp->Element()->HasMasterPtr() && pNodeTemp->Element()->GetMasterPtr() == pNodeStop->Element());
            break;
        }

        pCF = pNode->GetCharFormat();
        fFirstNode = FALSE;
    }
}

BOOL
CLSMeasurer::PseudoLineEnable(CTreeNode* pNodeBlock)
{
    BOOL fRet;
    CComputeFormatState * pcfState;
    Assert(pNodeBlock);
    Assert(!pNodeBlock->_fPseudoEnabled);
    Assert(pNodeBlock->GetFancyFormat()->_fHasFirstLine);
    CMarkup *pMarkup = pNodeBlock->GetMarkup();

    _fPseudoLineEnabled = TRUE;
    _fPseudoElementEnabled = TRUE;

    pcfState = pMarkup->EnsureCFState();
    if(pcfState)
    {
        pcfState->SetBlockNodeLine(pNodeBlock);
    }

    fRet = CopyStateFromTree(pNodeBlock, &_aryFormatStash_Line);
    _pLS->ClearFontCaches();
    return fRet;
}

void
CLSMeasurer::PseudoLineDisableCore()
{
    Assert(_fPseudoElementEnabled);
    if (_fPseudoLetterEnabled)
    {
        PseudoLetterDisable();
    }
    if (_fPseudoLineEnabled)
    {
        CMarkup * pMarkup = _pdp->GetMarkup();
        CComputeFormatState * pcfState = pMarkup->GetCFState();

        if (pcfState)
        {
            pcfState->ResetLine();
            pMarkup->EnsureDeleteCFState(pcfState);
        }

        _fPseudoLineEnabled = FALSE;

        CopyStateToTree(&_aryFormatStash_Line, FALSE);
        _pLS->ClearFontCaches();
    }
    if (_aryFormatStashAfterDisable_Letter.Size())
        PseudoLetterFree();
    _fPseudoElementEnabled = FALSE;
}

BOOL
CLSMeasurer::CopyStateFromTree(CTreeNode *pNodeBlock, CAryFormatStash *paryFormatStash)
{
    CTreePos *ptp;
    CTreePos *ptpStop;
    CFormatStash fmStash;
    HRESULT hr;

    // Walk the scope of the block element and stash away the formatting info
    Assert(paryFormatStash->Size() == 0);
    pNodeBlock->Element()->GetTreeExtent(&ptp, &ptpStop);
    while (ptp != ptpStop)
    {
        if (ptp->IsBeginNode())
        {
            CTreeNode *pNode = ptp->Branch();
            fmStash._iPF = pNode->_iPF;
            fmStash._iCF = pNode->_iCF;
            fmStash._iFF = pNode->_iFF;
            fmStash._fBlockNess = pNode->_fBlockNess;
            fmStash._fShouldHaveLayout = pNode->_fShouldHaveLayout;
            fmStash._pNode = pNode;
            hr = THR(paryFormatStash->AppendIndirect(&fmStash));
            if (hr != S_OK)
                goto Cleanup;
            pNode->_iPF = -1;
            pNode->_iCF = -1;
            pNode->_iFF = -1;
            pNode->_fPseudoEnabled = TRUE;
        }
        ptp = ptp->NextTreePos();
    }
Cleanup:
    return TRUE;
}

void
CLSMeasurer::CopyStateToTree(CAryFormatStash *paryFormatStash, BOOL fPseudoEnabled)
{
    LONG index;
    THREADSTATE * pts = GetThreadState();
    CFormatStash *pfmStash;
    CTreeNode *pNode;
    
    // Walk the scope of the block element and resotre the stashed formatting info
    Assert(paryFormatStash->Size() != 0);
    for (index = 0; index < paryFormatStash->Size(); index++)
    {
        pfmStash = &(*paryFormatStash)[index];
        pNode = pfmStash->_pNode;
        
        Assert(pNode->_fPseudoEnabled != fPseudoEnabled);
        
        if (pNode->_iPF != -1)
            (pts->_pParaFormatCache)->ReleaseData( pNode->_iPF );
        if (pNode->_iCF != -1)
            (pts->_pCharFormatCache)->ReleaseData( pNode->_iCF );
        if (pNode->_iFF != -1)
            (pts->_pFancyFormatCache)->ReleaseData( pNode->_iFF );

        pNode->_iPF = pfmStash->_iPF;
        pNode->_iCF = pfmStash->_iCF;
        pNode->_iFF = pfmStash->_iFF;

        pNode->_fBlockNess = pfmStash->_fBlockNess;
        pNode->_fShouldHaveLayout = pfmStash->_fShouldHaveLayout;
        pNode->_fPseudoEnabled = fPseudoEnabled;
    }
    paryFormatStash->DeleteAll();
}

BOOL
CLSMeasurer::CopyStateFromSpline(CTreeNode *pNodeFrom, CTreeNode *pNodeTo)
{
    CFormatStash fmStash;
    CTreeNode *pNode;
    BOOL fRet = FALSE;
    HRESULT hr;
    
    pNode = pNodeFrom;
    pNodeTo = pNodeTo->Parent(); // I want pNodeTo to be included in the walk
    
    while (pNode != pNodeTo)
    {
        fmStash._iPF = pNode->_iPF;
        fmStash._iCF = pNode->_iCF;
        fmStash._iFF = pNode->_iFF;
        fmStash._fBlockNess = pNode->_fBlockNess;
        fmStash._fShouldHaveLayout = pNode->_fShouldHaveLayout;
        fmStash._pNode = pNode;
        hr = THR(_aryFormatStashForNested_Line.AppendIndirect(&fmStash));
        if (hr != S_OK)
            goto Cleanup;
        pNode->_iPF = -1;
        pNode->_iCF = -1;
        pNode->_iFF = -1;
        pNode->_fPseudoEnabled = FALSE;
        pNode = pNode->Parent();
    }
    fRet = TRUE;
    
Cleanup:
    return fRet;
}

BOOL
CLSMeasurer::PseudoLetterEnable(CTreeNode *pNodeBlock)
{
    Assert(pNodeBlock);
    // No format computation can occur between enabling of pseudo line
    // and enabling of letter.
    CMarkup *pMarkup = pNodeBlock->GetMarkup();
    CComputeFormatState * pcfState;
    BOOL fRet = TRUE;


    Assert(_cpStopFirstLetter >= 0);
    Assert(!_fPseudoLetterEnabled);
    _fPseudoLetterEnabled = TRUE;
    _fPseudoElementEnabled = TRUE;

    pcfState = pMarkup->EnsureCFState();
    if(pcfState)
    {
        pcfState->SetBlockNodeLetter(pNodeBlock);
    }

    if (!_fPseudoLineEnabled)
        fRet = CopyStateFromTree(pNodeBlock, &_aryFormatStash_Letter);
    _pLS->ClearFontCaches();
    Assert(!_fPseudoLineEnabled || pNodeBlock->_iCF == -1);
    return fRet;
}

BOOL
CLSMeasurer::PseudoLetterDisable()
{
    BOOL fRet = FALSE;
    LONG index;
    CFormatStash *pfmStash;
    CFormatStash fmStash;
    CTreeNode *pNode;
    HRESULT hr;
    
    if (_fPseudoLetterEnabled)
    {
        CMarkup * pMarkup = _pdp->GetMarkup();

        if (pMarkup->HasCFState() )
        {
            CComputeFormatState * pcfState = pMarkup->GetCFState();

            pcfState->ResetLetter();
            pMarkup->EnsureDeleteCFState( pcfState );
        }
        _fPseudoLetterEnabled = FALSE;
        _cpStopFirstLetter = -1;
        _pLS->ClearFontCaches();

        if (_fPseudoLineEnabled)
        {
            Assert(_aryFormatStash_Letter.Size() == 0);
            Assert(_aryFormatStash_Line.Size() != 0);
            for(index = 0; index < _aryFormatStash_Line.Size(); index++)
            {
                pfmStash = &_aryFormatStash_Line[index];
                pNode = pfmStash->_pNode;
                
                if (   pNode->_iPF != -1
                    || pNode->_iCF != -1
                    || pNode->_iFF != -1
                   )
                {
                    fmStash._iPF = pNode->_iPF;
                    fmStash._iCF = pNode->_iCF;
                    fmStash._iFF = pNode->_iFF;
                    // other stash values are not interesting.

                    hr = THR(_aryFormatStashAfterDisable_Letter.AppendIndirect(&fmStash));
                    if (hr != S_OK)
                        goto Cleanup;

                    // Invalidate the format caches so that they will be computed
                    // for the line-formats if necessary
                    pNode->_iPF = -1;
                    pNode->_iCF = -1;
                    pNode->_iFF = -1;
                }
                Assert(pNode->_fPseudoEnabled);
            }
        }
        else
        {
            Assert(_aryFormatStash_Letter.Size() != 0);
            Assert(_aryFormatStashAfterDisable_Letter.Size() == 0);
            for (index = 0; index < _aryFormatStash_Letter.Size(); index++)
            {
                pfmStash = &_aryFormatStash_Letter[index];
                pNode = pfmStash->_pNode;

                if (   pNode->_iPF != -1
                    || pNode->_iCF != -1
                    || pNode->_iFF != -1
                   )
                {
                    fmStash._iPF = pNode->_iPF;
                    fmStash._iCF = pNode->_iCF;
                    fmStash._iFF = pNode->_iFF;
                    fmStash._pNode = pNode;
                    // other stash values are not interesting.

                    hr = THR(_aryFormatStashAfterDisable_Letter.AppendIndirect(&fmStash));
                    if (hr != S_OK)
                        goto Cleanup;
                }

                pNode->_iPF = pfmStash->_iPF;
                pNode->_iCF = pfmStash->_iCF;
                pNode->_iFF = pfmStash->_iFF;

                pNode->_fBlockNess = pfmStash->_fBlockNess;
                pNode->_fShouldHaveLayout = pfmStash->_fShouldHaveLayout;
                pNode->_fPseudoEnabled = FALSE;
            }
            _aryFormatStash_Letter.DeleteAll();
        }
    }
    fRet = TRUE;
Cleanup:
    return fRet;
}

void
CLSMeasurer::PseudoLetterFree()
{
    CFormatStash *pfmStash;
    THREADSTATE * pts = GetThreadState();
    LONG index;
    
    for (index = 0; index < _aryFormatStashAfterDisable_Letter.Size(); index++)
    {
        pfmStash = &_aryFormatStashAfterDisable_Letter[index];
        if (pfmStash->_iPF != -1)
            (pts->_pParaFormatCache)->ReleaseData( pfmStash->_iPF );
        if (pfmStash->_iCF != -1)
            (pts->_pCharFormatCache)->ReleaseData( pfmStash->_iCF );
        if (pfmStash->_iFF != -1)
            (pts->_pFancyFormatCache)->ReleaseData( pfmStash->_iFF );
    }
    _aryFormatStashAfterDisable_Letter.DeleteAll();
}

LONG
CLSMeasurer::GetCpOfLastLetter(CTreeNode *pNodeBlock)
{
    CTreePos *ptp, *ptpStop;
    CTreeNode *pNode;
    CElement *pElement;
    BOOL fFoundText = FALSE;
    LONG cp;
    LONG ich = 0;
    
    pNodeBlock->Element()->GetTreeExtent(&ptp, &ptpStop);
    // Go past out begin splay
    ptp = ptp->NextTreePos();
    while (ptp != ptpStop)
    {
        if (ptp->IsBeginNode())
        {
            pNode = ptp->Branch();
            pElement = pNode->Element();
            
            if (pNode->IsDisplayNone())
            {
                GetNestedElementCch(pElement, &ptp);
            }
            else if (  pNode->ShouldHaveLayout()
                     ||(pElement->Tag() == ETAG_BR)
                     ||(    _pFlowLayout->IsElementBlockInContext(pElement)
                        &&  pElement->IsInlinedElement()
                       )
                    )
            {
                ich = 0;
                break;
            }
        }
        else if (ptp->IsText())
        {
            CTxtPtr tp(_pdp->GetMarkup(), ptp->GetCp());
            BOOL fTerminated = FALSE;
            
            ich = 0;
            while (ich < ptp->Cch())
            {
                TCHAR ch = tp.GetChar();

                fFoundText = TRUE;
                if (   ch != _T(' ')
                    && ch != _T('\'')
                    && ch != _T('"')
                    && ch != WCH_NBSP
                   )
                {
                    ich++;
                    fTerminated = TRUE;
                    break;
                }

                ich++;
                tp.AdvanceCp(1);
            }
            if (fTerminated)
                break;
        }
        ptp = ptp->NextTreePos();
    }

    cp = fFoundText ? (ptp->GetCp() + ich) : -1;
    return cp;
}

BOOL
CLSMeasurer::GetSiteWidth(CTreeNode *pNodeLayout,
                          CLayout   *pLayout,
                          CCalcInfo *pci,
                          BOOL       fBreakAtWord,
                          LONG       xWidthMax,
                          LONG      *pxWidth,
                          LONG      *pyHeight,
                          INT       *pxMinSiteWidth,
                          LONG      *pyBottomMargin)
{
    BOOL fRet;
    
    Assert(!_fPseudoLetterEnabled);
    if (_fPseudoLineEnabled)
    {
        CMarkup * pMarkup = _pLS->_pMarkup;
        CComputeFormatState * pcfState = pMarkup->GetCFState();

        if (pcfState)
        {
            _cfStateSave = *pcfState;
            pcfState->ResetLine();
        }

        CopyStateFromSpline(pNodeLayout, _cfStateSave.GetBlockNodeLine());
    }

    fRet = _pFlowLayout->GetSiteWidth(pLayout, pci, fBreakAtWord, xWidthMax, pxWidth, pyHeight, pxMinSiteWidth, pyBottomMargin);

    if (_fPseudoLineEnabled)
    {
        CMarkup * pMarkup = _pLS->_pMarkup;
        CComputeFormatState * pcfState = pMarkup->GetCFState();

        if (pcfState)
        {
            *pcfState = _cfStateSave;
        }

        CopyStateToTree(&_aryFormatStashForNested_Line, TRUE);
    }

    return fRet;
}

void
CLSMeasurer::SetBreakLongLines(CTreeNode *pNode, UINT *puiFlags)
{
    const CParaFormat *pPF;
    if (   pNode->ShouldHaveLayout()
        && !SameScope(pNode, _pFlowLayout->ElementContent())
       )
    {
        pNode = pNode->Parent();
        if (pNode)
            pPF = pNode->GetParaFormat(LC_TO_FC(_pci->GetLayoutContext()));
        else
            pPF = NULL;
    }
    else
    {
        pPF = pNode->GetParaFormat(LC_TO_FC(_pci->GetLayoutContext()));
    }
    
    *puiFlags &= ~MEASURE_BREAKLONGLINES;
    _fBreaklinesFromStyle = FALSE;
    if (pPF)
    {
        if (pPF->_fWordWrap == styleWordWrapNotSet)
        {
            if (   _pdp->GetWordWrap()
                && _pdp->GetWrapLongLines()
               )
            {
                _fBreaklinesFromStyle = FALSE;
                *puiFlags |= MEASURE_BREAKLONGLINES;
            }
        }
        else
        {
            if (pPF->_fWordWrap == styleWordWrapOn)
            {
                _fBreaklinesFromStyle = TRUE;
                *puiFlags |= MEASURE_BREAKLONGLINES;
            }
        }
    }
}

BOOL
CLSMeasurer::GetBreakLongLines(CTreeNode *pNode)
{
    UINT uiFlags = 0;
    SetBreakLongLines(pNode, &uiFlags);
    return uiFlags & MEASURE_BREAKLONGLINES ? TRUE : FALSE;
}

#if 0
BOOL
CLSMeasurer::SearchBranchForPseudoElement(CTreeNode  *pNodeStateHere,
                                          CTreeNode **ppBlockElement,
                                          CTreeNode **ppBlockLine,
                                          CTreeNode **ppBlockLetter
                                         )
{
    BOOL fRet = FALSE;
    const CParaFormat *pPF;
    const CFancyFormat *pFF;
    CBlockElement *pBlockElement = NULL;
    CBlockElement *pBlockLine = NULL;
    CBlockElement *pBlockLetter = NULL;
    
    for (pNode = pNodeStartHere ; ; pNode = pNode->Parent())
    {
        if (!pNode)
            return NULL;

        pPF = pNode->GetParaFormat();
        if (!pPF->_fHasPseudoElement)
            break;
        
        if (pNode->Element()->IsBlockElement())
        {
            fRet = TRUE;
            
            pFF = pNode->GetFancyFormat();

            if (!pBlockElement)
                pBlockElement = pNode;

            if (   pFF->_fHasFirstLine
                && !pBlockLine
               )
                pBlockLine = pNode;

            if (   pFF->_fHasFirstLetter
                && !pBlockLetter
               )
                pBlockLetter = pNode;
        }

        if (pNode->HasFlowLayout())
            return NULL;
    }
    if (fRet)
    {
        *ppBlockElement = pBlockElement;
        *ppBlockLine = pBlockLine;
        *ppBlockLetter = pBlockLetter;
    }
    return fRet;
}
#endif

#pragma optimize("", on)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\text\lsobj.cxx ===
/*
 *  @doc    INTERNAL
 *
 *  @module LSOBJ.CXX -- line services object handlers
 *
 *
 *  Owner: <nl>
 *      Chris Thrasher <nl>
 *      Sujal Parikh <nl>
 *
 *  History: <nl>
 *      12/18/97     cthrash created
 *      04/28/99     grzegorz - LayoutGrid object added
 *
 *  Copyright (c) 1997-1998 Microsoft Corporation. All rights reserved.
 */

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

// NB (cthrash) The implemetation here is largely modeled on lscsk.cpp in Quill

#ifndef X_LSOBJ_HXX_
#define X_LSOBJ_HXX_
#include "lsobj.hxx"
#endif

#ifndef X__FONT_H_
#define X__FONT_H_
#include "_font.h"
#endif

#ifndef X_TREEPOS_HXX_
#define X_TREEPOS_HXX_
#include "treepos.hxx"
#endif

#ifndef X_LINESRV_HXX_
#define X_LINESRV_HXX_
#include "linesrv.hxx"
#endif

#ifndef X_LSRENDER_HXX_
#define X_LSRENDER_HXX_
#include "lsrender.hxx"
#endif

#ifndef X_TCELL_HXX_
#define X_TCELL_HXX_
#include "tcell.hxx"
#endif

#ifndef X_LTCELL_HXX_
#define X_LTCELL_HXX_
#include "ltcell.hxx"
#endif

#ifdef DLOAD1
extern "C" // MSLS interfaces are plain C
{
#endif

#ifndef X_FMTI_H_
#define X_FMTI_H_
#include <fmti.h>
#endif

#ifndef X_LSFRUN_H_
#define X_LSFRUN_H_
#include <lsfrun.h>
#endif

#ifndef X_OBJDIM_H_
#define X_OBJDIM_H_
#include <objdim.h>
#endif

#ifndef X_LSDNFIN_H_
#define X_LSDNFIN_H_
#include <lsdnfin.h>
#endif

#ifndef X_LSQSUBL_H_
#define X_LSQSUBL_H_
#include <lsqsubl.h>
#endif

#ifndef X_LSDNSET_H_
#define X_LSDNSET_H_
#include <lsdnset.h>
#endif

#ifndef X_PLOCCHNK_H_
#define X_PLOCCHNK_H_
#include <plocchnk.h>
#endif

#ifndef X_LOCCHNK_H_
#define X_LOCCHNK_H_
#include <locchnk.h>
#endif

#ifndef X_POSICHNK_H_
#define X_POSICHNK_H_
#include <posichnk.h>
#endif

#ifndef X_PPOSICHN_H_
#define X_PPOSICHN_H_
#include <pposichn.h>
#endif

#ifndef X_BRKO_H_
#define X_BRKO_H_
#include <brko.h>
#endif

#ifndef X_LSQOUT_H_
#define X_LSQOUT_H_
#include <lsqout.h>
#endif

#ifndef X_LSQIN_H_
#define X_LSQIN_H_
#include <lsqin.h>
#endif

#ifdef DLOAD1
} // extern "C"
#endif

#ifndef X_FLOWLYT_HXX_
#define X_FLOWLYT_HXX_
#include <flowlyt.hxx>
#endif

#define brkcondUnknown BRKCOND(-1)

ExternTag(tagLSCallBack);

DeclareLSTag( tagTraceILSBreak, "Trace ILS breaking");

MtDefine(CDobjBase, LineServices, "CDobjBase")
MtDefine(CNobrDobj, LineServices, "CNobrDobj")
MtDefine(CEmbeddedDobj, LineServices, "CEmbeddedDobj")
MtDefine(CGlyphDobj, LineServices, "CGlyphDobj")
MtDefine(CLayoutGridDobj, LineServices, "CLayoutGridDobj")
MtDefine(CILSObjBase, LineServices, "CILSObjBase")
MtDefine(CEmbeddedILSObj, LineServices, "CEmbeddedILSObj")
MtDefine(CNobrILSObj, LineServices, "CNobrILSObj")
MtDefine(CGlyphILSObj, LineServices, "CGlyphILSObj")
MtDefine(CLayoutGridILSObj, LineServices, "CLayoutGridILSObj")

// Since lnobj is worthless as far as we're concerned, we just point it back
// to the ilsobj.  lnobj's are instantiated once per object type per line.
typedef struct lnobj
{
    PILSOBJ pilsobj;
} LNOBJ;

//-----------------------------------------------------------------------------
//
//  Function:   CreateILSObj (member, LS callback)
//
//  Synopsis:   Create the ILS object for all 'idObj' objects.
//
//  Returns:    lserrNone if the function is successful
//
//-----------------------------------------------------------------------------
LSERR WINAPI
CLineServices::CreateILSObj(
    PLSC plsc,          // IN:  LS context
    PCLSCBK plscbk,     // IN:  callbacks to client application
    DWORD idObj,        // IN:  id of the object
    PILSOBJ* ppilsobj)  // OUT: object ilsobj
{
    LSTRACE(CreateILSObj);

    switch( idObj )
    {
    case LSOBJID_EMBEDDED:
        *ppilsobj= (PILSOBJ)(new CEmbeddedILSObj(this, plscbk));
        break;
    case LSOBJID_NOBR:
        *ppilsobj= (PILSOBJ)(new CNobrILSObj(this, plscbk));
        break;
    case LSOBJID_GLYPH:
        *ppilsobj= (PILSOBJ)(new CGlyphILSObj(this, plscbk));
        break;
    case LSOBJID_LAYOUTGRID:
        *ppilsobj= (PILSOBJ)(new CLayoutGridILSObj(this, plscbk));
        break;
    default:
        AssertSz(0, "Unknown lsobj_id");
    }

    return *ppilsobj ? lserrNone : lserrOutOfMemory;
}

CILSObjBase::CILSObjBase(CLineServices* pols, PCLSCBK plscbk)
: _pLS(pols)
{
    // We don't need plscbk.
}

CILSObjBase::~CILSObjBase()
{
}

CEmbeddedILSObj::CEmbeddedILSObj(CLineServices* pols, PCLSCBK plscbk)
: CILSObjBase(pols,plscbk)
{}

CNobrILSObj::CNobrILSObj(CLineServices* pols, PCLSCBK plscbk)
: CILSObjBase(pols,plscbk)
{}

CGlyphILSObj::CGlyphILSObj(CLineServices* pols, PCLSCBK plscbk)
: CILSObjBase(pols,plscbk)
{}

CLayoutGridILSObj::CLayoutGridILSObj(CLineServices* pols, PCLSCBK plscbk)
: CILSObjBase(pols,plscbk)
{}

CDobjBase::CDobjBase(PILSOBJ pilsobjNew, PLSDNODE plsdn, COneRun *por)
: _pilsobj(pilsobjNew), _plsdnTop(plsdn), _por(por)
{}

CEmbeddedDobj::CEmbeddedDobj(PILSOBJ pilsobjNew, PLSDNODE plsdn, COneRun *por)
: CDobjBase(pilsobjNew, plsdn, por)
{}

CNobrDobj::CNobrDobj(PILSOBJ pilsobjNew, PLSDNODE plsdn, COneRun *por)
: CDobjBase(pilsobjNew, plsdn, por), _plssubline(NULL)
{}

CGlyphDobj::CGlyphDobj(PILSOBJ pilsobjNew, PLSDNODE plsdn, COneRun *por)
: CDobjBase(pilsobjNew, plsdn, por)
{}

CLayoutGridDobj::CLayoutGridDobj(PILSOBJ pilsobjNew, PLSDNODE plsdn, COneRun *por)
: CDobjBase(pilsobjNew, plsdn, por), _plssubline(NULL)
{
    _lscpStart = _lscpStartObj = 0;
    _uSublineOffset = _uSubline = 0;
    _fCanBreak = TRUE;
    ZeroMemory(_brkRecord, NBreaksToSave * sizeof(RBREAKREC));
}

//-----------------------------------------------------------------------------
//
//  Function:   DestroyILSObj (member, LS callback)
//
//  Synopsis:   This function is called from Line Services when the 
//              Line Services Context is destroyed.
//
//  Returns:    lserrNone
//
//-----------------------------------------------------------------------------
LSERR WINAPI
CILSObjBase::DestroyILSObj()    // this = pilsobj
{
    LSTRACE(DestroyILSObj);

    delete this;

    return lserrNone;
}

//-----------------------------------------------------------------------------
//
//  Function:   SetDoc (member, LS callback)
//
//  Synopsis:   LsSetDoc calls pfnSetDoc for each non-text object type.
//
//  Returns:    lserrNone
//
//-----------------------------------------------------------------------------
LSERR WINAPI
CILSObjBase::SetDoc(PCLSDOCINF) // this = pilsobj
{
    LSTRACE(SetDoc);

    // We don't have anything to do.
    return lserrNone;
}

//-----------------------------------------------------------------------------
//
//  Function:   CreateLNObj (member, LS callback)
//
//  Synopsis:   Line Services calls pfnCreateLNObj to invoke the object handler.
//
//  Returns:    lserrNone
//
//-----------------------------------------------------------------------------
LSERR WINAPI
CILSObjBase::CreateLNObj(PLNOBJ* pplnobj)   // this = pcilsobj
{
    LSTRACE(CreateLNObj);

    // All LNobj's are the same object as our ilsobj.
    // This object's lifetime is determined by the ilsobj
    *pplnobj= (PLNOBJ) this;

    return lserrNone;
}

//-----------------------------------------------------------------------------
//
//  Function:   DestroyLNObj (member, LS callback)
//
//  Synopsis:   This function is called when the line containing the PDOBJ is 
//              destroyed.
//
//  Returns:    lserrNone
//
//-----------------------------------------------------------------------------
LSERR WINAPI
CILSObjBase::DestroyLNObj() // this= plnobj
{
    LSTRACE(DestroyLNObj);

    // Do nothing, since we never really created one.
    return lserrNone;
}

//-----------------------------------------------------------------------------
//
//  Function:   Fmt (member, LS callback)
//
//  Synopsis:   Line Services calls pfnFmt for the appropriate object each time
//              a run is fetched. This callback computes the position of each 
//              element in the run, and returns when the run is exhausted, or 
//              when a potential line break character is reached after the right 
//              margin is exceeded. 
//              During Fmt() an object handler must do one of the following:
//              1. Create an output dobj (display object) and register it with 
//                 a dnode by calling a Fini routine. This places a pointer to 
//                 dobj into a Line Services dnode. The output dobj should 
//                 contain sufficient data to facilitate line breaking and 
//                 display operations.
//              2. Call a Fini routine that deletes the dnode.
//
//  Returns:    lserrNone if the function is successful.
//
//-----------------------------------------------------------------------------
LSERR WINAPI
CEmbeddedILSObj::Fmt(  // this = plnobj
    PCFMTIN pfmtin,    // IN:  formatting input
    FMTRES* pfmtres)   // OUT: formatting result
{
    LSTRACE(EmbeddedFmt);

    BOOL            fOwnLine;
    INT             xMinWidth;
    LONG            cchSite;
    LONG            xWidth, yHeight;
    OBJDIM          objdim;
    LSERR           lserr           = lserrNone;
    CLineServices * pLS             = _pLS;
    CFlowLayout   * pFlowLayout     = pLS->_pFlowLayout;
    PLSRUN          plsrun          = PLSRUN(pfmtin->lsfrun.plsrun);
    CLayout       * pLayout         = plsrun->GetLayout(pFlowLayout, pLS->GetLayoutContext() ); 
    CElement      * pElementLayout;
    CTreeNode     * pNodeLayout;
    const CCharFormat  *pCF;
    const CFancyFormat *pFF;
    CEmbeddedDobj* pdobj= new CEmbeddedDobj(this, pfmtin->plsdnTop, plsrun);

    if (!pdobj)
    {
        lserr = lserrOutOfMemory;
        goto Cleanup;
    }

    // pLayout is the guy we're being asked to format here.
    Assert( pLayout && pLayout != pFlowLayout );

    pElementLayout  = pLayout->ElementOwner();
    pNodeLayout     = pElementLayout->GetFirstBranch();
    pCF             = pNodeLayout->GetCharFormat(LC_TO_FC(pLayout->LayoutContext()));
    pFF             = pNodeLayout->GetFancyFormat(LC_TO_FC(pLayout->LayoutContext()));

    // for overlapping layouts curtail the range of characters measured
    cchSite = pLS->GetNestedElementCch(pElementLayout);

    ZeroMemory( &objdim, sizeof(OBJDIM) );

    // Let's see if this an 'ownline' thingy.  Note that even if the element
    // is not by default and 'ownline' element, we may have morphed it into
    // one -- then too it has to be a block element. If it is not one (like
    // a span, then it will not live on its own line).  Check here.

    fOwnLine = pLS->IsOwnLineSite(plsrun);

    Assert(pElementLayout->IsInlinedElement(LC_TO_FC(pLayout->LayoutContext())));

    // Certain sites that only Microsoft supports can break with any
    // characters, so we hack that in right here.
    // NOTE (cthrash) This is goofy.  We should have a better way to
    // determine this than checking tag types.

    pdobj->_fIsBreakingSite =    pElementLayout->Tag() == ETAG_OBJECT
                              || pElementLayout->Tag() == ETAG_IFRAME
                              || pElementLayout->Tag() == ETAG_MARQUEE

    // This is really unfortunate -- if a site is percent sized then it becomes a breaking
    // site inside table cells. This is primarily for IE4x compat. See IE bug 42336 (SujalP)

                                 // width in parent's coordinate system
                              || pFF->GetLogicalWidth(pNodeLayout->IsParentVertical(), 
                                                      pCF->_fWritingModeUsed).IsPercent()

    // One last thing - if we have a morphed non-ownline element inside
    // a table, it's considered a breaking site.

                              || (!fOwnLine
                              && (!pElementLayout->_fLayoutAlwaysValid || pElementLayout->TestClassFlag(CElement::ELEMENTDESC_NOLAYOUT)));

    // If it's on its own line, and not first on line, FetchRun should have
    // terminated the line before we got here.
    // Assert( !( fOwnLine && !pfmtin->lsfgi.fFirstOnLine) );

    pLS->_pMeasurer->GetSiteWidth( pNodeLayout, pLayout, pLS->_pci,
                                   pLS->_lsMode == CLineServices::LSMODE_MEASURER,
                                   pLS->_xWrappingWidth,
                                   &xWidth, &yHeight, &xMinWidth);

    // v-Dimension computed in VerticalAlignObjects
    // NOTE (cthrash) We have rounding errors in LS; don't pass zero

    objdim.heightsRef.dvAscent = 1;
    objdim.heightsRef.dvDescent = 0;
    objdim.heightsRef.dvMultiLineHeight = 1;
    if (_pLS->_fMinMaxPass)
        objdim.heightsPres = objdim.heightsRef;

    if(pLS->_fIsRuby && !pLS->_fIsRubyText)
    {
        pLS->_yMaxHeightForRubyBase = max(pLS->_yMaxHeightForRubyBase, yHeight);
    }

    // We need to store two widths in the dobj: The width corresponding to
    // the wrapping width (urColumnMax) and the minimum width.  LsGetMinDur,
    // however, does not recognize two widths for ILS objects.  We therefore
    // cache the difference, and account for these in an enumeration callback
    // after the LsGetMinDur pass.

    if (!pLS->_fMinMaxPass)
    {
        LONG lMW = pLS->_pci->GetDeviceMaxX() - 1;
        pdobj->_dvMinMaxDelta = 0;
        // NOTE (SujalP, KTam):
        // We need to subtract the pen width because our max width (from GetDeviceMaxX())
        // is the same as a hardcoded lineservices limit (uLsInfiniteRM), and
        // there might be something else on the line already.
        // We cannot increase our max width beyond the LS limit!
        objdim.dur = max( 0L, min(LONG(lMW - pfmtin->lsfgi.urPen), xWidth) );
        plsrun->_xWidth = objdim.dur;
    }
    else
    {
        LONG lMW = pLS->_pci->GetDeviceMaxX() - 1;
        xWidth = min(lMW, xWidth);
        xMinWidth = min(INT(lMW), xMinWidth);
        
        pdobj->_dvMinMaxDelta = xWidth - xMinWidth;
        objdim.dur = xMinWidth;
        plsrun->_xWidth = xMinWidth;
    }

    // For StrictCSS1 this is a time to check for auto margins on the layout and 
    // adjust line left and right if necessary.

    if (    !pLS->_fMinMaxPass                      // this is a normal calc 
        &&  _pLS->_pMarkup->IsStrictCSS1Document()  // rendering in CSS1 strict mode 
        &&  !pFF->IsAbsolute()                      // skip if position is absolute  
        &&  pElementLayout->DetermineBlockness(pFF) // the element has blockness 
        &&  (pLS->_xWrappingWidth - xWidth) > 0  )  // there is a space left to redistribute 
    {
        const CCharFormat   *pCFParent      = pFlowLayout->GetFirstBranch()->GetCharFormat(LC_TO_FC(pFlowLayout->LayoutContext()));
        const CUnitValue    &uvLeftMargin   = pFF->GetLogicalMargin(SIDE_LEFT, pCFParent->HasVerticalLayoutFlow(), pCF->_fWritingModeUsed);
        const CUnitValue    &uvRightMargin  = pFF->GetLogicalMargin(SIDE_RIGHT, pCFParent->HasVerticalLayoutFlow(), pCF->_fWritingModeUsed);
        BOOL  fLeftMarginIsAuto  = (uvLeftMargin.GetUnitType()  == CUnitValue::UNIT_ENUM) && (uvLeftMargin.GetUnitValue()  == styleAutoAuto);
        BOOL  fRightMarginIsAuto = (uvRightMargin.GetUnitType() == CUnitValue::UNIT_ENUM) && (uvRightMargin.GetUnitValue() == styleAutoAuto);

        if (fLeftMarginIsAuto || fRightMarginIsAuto)
        {
            long xWidthToDistribute = pLS->_xWrappingWidth - xWidth;
            Assert(0 < xWidthToDistribute); 
        
            if (fLeftMarginIsAuto == fRightMarginIsAuto)
            {
                _pLS->_li._xLeft  += xWidthToDistribute / 2;
                _pLS->_li._xRight += xWidthToDistribute - xWidthToDistribute / 2;
            }
            else if (fLeftMarginIsAuto) 
            {
                _pLS->_li._xLeft += xWidthToDistribute;
            }
            else 
            {
                _pLS->_li._xRight += xWidthToDistribute;
            }
        }
    }

    if (pCF->HasCharGrid(TRUE))
    {
        long lCharGridSize = pLS->GetCharGridSize();
        objdim.dur = pLS->GetClosestGridMultiple(lCharGridSize, objdim.dur);
        if (pLS->_fMinMaxPass)
            pdobj->_dvMinMaxDelta = pLS->GetClosestGridMultiple(lCharGridSize, xWidth) - objdim.dur;
    }

    if (fOwnLine)
    {
        // If we are inside a something like say a PRE then too we do
        // not terminate, because if there was a \r right after the ownline site
        // then we will allow that \r to break the line. We do not check if the
        // subsequent char is a \r because there might be goop(comments, hidden
        // stuff etc etc) between this site and the \r. Hence here we just march
        // forward and if we run into text or layout later on we will terminate
        // the line then. This way we will eat up the goop if any in between.
        if (!pLS->_fScanForCR)
        {
            COneRun *porOut;
            COneRun *por = pLS->_listFree.GetFreeOneRun(plsrun);

            if (!por)
            {
                lserr = lserrOutOfMemory;
                goto Cleanup;
            }

            Assert(plsrun->IsNormalRun());
            Assert(plsrun->_lscch == plsrun->_lscchOriginal);
            por->_lscpBase += plsrun->_lscch;

            // If this object has to be on its own line, then it clearly
            // ends the current line.
            lserr = pLS->TerminateLine(por, CLineServices::TL_ADDEOS, &porOut);
            if (lserr != lserrNone)
                goto Cleanup;

            // Free the one run
            pLS->_listFree.SpliceIn(por);
        }
        else
        {
            // Flip this bit so that we will setup pfmtres properly later on
            fOwnLine = FALSE;
        }

        // If we have an 'ownline' site, by definition this is a breaking
        // site, meaning we can (or more precisely should) break on either
        // side of the site.
        pdobj->_fIsBreakingSite = TRUE;

        //
        // NOTE(SujalP): Bug 65906.
        // We originally used to set ourselves up to collect after space only
        // for morphed elements. As it turns out, we want to collect after space
        // from margins of _all_ ownline sites (including morphed elements),
        // because margins for ownline-sites are not accounted for in
        // VerticalAlignObjects (see CLayout::GetMarginInfo for more details --
        // it returns 0 for ownline sites).
        //
        pLS->_pNodeForAfterSpace = pNodeLayout;

        //
        // All ownline sites have their x position to be 0
        //
        if (pElementLayout->HasFlag(TAGDESC_OWNLINE))
        {
            pLayout->SetXProposed(0);
        }
    }

    if (fOwnLine)
    {
        *pfmtres = fmtrCompletedRun;
    }
    else
    {
        const long urWrappingWidth = max(pfmtin->lsfgi.urColumnMax, pLS->_xWrappingWidth);

        *pfmtres = (pfmtin->lsfgi.fFirstOnLine ||
                    pfmtin->lsfgi.urPen + objdim.dur <= urWrappingWidth)
                   ? fmtrCompletedRun
                   : fmtrExceededMargin;
    }

    // This is an accessor to the dnode, telling LS to set the dnode pointing
    // to our dobj.
    lserr = LsdnFinishRegular( pLS->_plsc, cchSite, pfmtin->lsfrun.plsrun,
                               pfmtin->lsfrun.plschp, (struct dobj*)pdobj, &objdim);

    //
    // CSS attributes page break before/after support.
    // There are two mechanisms that add to provide full support: 
    // 1. CRecalcLinePtr::CalcBeforeSpace() and CRecalcLinePtr::CalcAfterSpace() 
    //    is used to set CLineCore::_fPageBreakBefore/After flags only(!) for 
    //    nested elements which have no their own layout (i.e. paragraphs). 
    // 2. CEmbeddedILSObj::Fmt() sets CLineCore::_fPageBreakBefore for nested 
    //    element with their own layout that are NOT allowed to break (always) 
    //    and for nested elements with their own layout that ARE allowed to 
    //    break if this is the first layout in the view chain. 
    //
    if (   // this is print view
           pLS->GetLayoutContext() 
        && pLS->GetLayoutContext()->ViewChain()
           // and run is completed one
        && *pfmtres == fmtrCompletedRun )
    {
        if (GET_PGBRK_BEFORE(pFF->_bPageBreaks)) 
        {
            CLayoutBreak *  pLayoutBreak;
            BOOL            fSetPageBreakBefore = !pLayout->ElementCanBeBroken();

            if (!fSetPageBreakBefore)
            {
                pLS->GetLayoutContext()->GetLayoutBreak(pElementLayout, &pLayoutBreak); 
                fSetPageBreakBefore = (pLayoutBreak == NULL);
            }

            if (fSetPageBreakBefore)
            {
                pLS->_li._fPageBreakBefore  = TRUE;
                pLS->_pci->_fPageBreakLeft  |= IS_PGBRK_BEFORE_OF_STYLE(pFF->_bPageBreaks, stylePageBreakLeft); 
                pLS->_pci->_fPageBreakRight |= IS_PGBRK_BEFORE_OF_STYLE(pFF->_bPageBreaks, stylePageBreakRight); 

                pLS->GetLayoutContext()->GetEndingLayoutBreak(pFlowLayout->ElementOwner(), &pLayoutBreak);
                if (pLayoutBreak)
                {
                    DYNCAST(CFlowLayoutBreak, pLayoutBreak)->_pElementPBB = pElementLayout;
                }
            }

        }

        if (GET_PGBRK_AFTER(pFF->_bPageBreaks))
        {
            pLS->_li._fPageBreakAfter   = TRUE;
            pLS->_pci->_fPageBreakLeft  |= IS_PGBRK_AFTER_OF_STYLE(pFF->_bPageBreaks, stylePageBreakLeft); 
            pLS->_pci->_fPageBreakRight |= IS_PGBRK_AFTER_OF_STYLE(pFF->_bPageBreaks, stylePageBreakRight); 
        }
    }
    
Cleanup:

    return lserr;
}

//-----------------------------------------------------------------------------
//
//  Function:   Fmt (member, LS callback)
//
//  Synopsis:   Line Services calls pfnFmt for the appropriate object each time
//              a run is fetched. This callback computes the position of each 
//              element in the run, and returns when the run is exhausted, or 
//              when a potential line break character is reached after the right 
//              margin is exceeded. 
//              During Fmt() an object handler must do one of the following:
//              1. Create an output dobj (display object) and register it with 
//                 a dnode by calling a Fini routine. This places a pointer to 
//                 dobj into a Line Services dnode. The output dobj should 
//                 contain sufficient data to facilitate line breaking and 
//                 display operations.
//              2. Call a Fini routine that deletes the dnode.
//
//  Returns:    lserrNone if the function is successful.
//
//-----------------------------------------------------------------------------
LSERR WINAPI
CNobrILSObj::Fmt(       // this = plnobj
    PCFMTIN pfmtin,     // IN:  formatting input
    FMTRES* pfmtres)    // OUT: formatting result
{
    LSTRACE(NobrFmt);

    LSERR lserr = lserrNone;
    CLineServices * pLS = _pLS;
    FMTRES subfmtres;
    OBJDIM objdim;
    LSTFLOW lstflowDontcare;
    COneRun* por= (COneRun*) pfmtin->lsfrun.plsrun;
    //LONG lscpStart= pLS->LSCPFromCP(por->Cp());
    LONG lscpStart= por->_lscpBase + 1; // +1 to jump over the synth character
    LSCP lscpLast;
    LSCP lscpUsed;
    BOOL fSuccess;

    CNobrDobj* pdobj = new CNobrDobj(this, pfmtin->plsdnTop, por);
    if (!pdobj)
    {
        lserr = lserrOutOfMemory;
        goto Cleanup;
    }
    pdobj->_plssubline = NULL;
    pdobj->_lscpStart = pfmtin->lsfgi.cpFirst;
    pdobj->_lscpObjStart = lscpStart;
    pdobj->_lscpObjLast = lscpStart;
    pdobj->_fCanBreak = FALSE;

    AssertSz( ! pLS->_fNoBreakForMeasurer, "Can't nest NOBR's");

    pLS->_fNoBreakForMeasurer = TRUE;

    pdobj->_brkcondBefore = brkcondUnknown;
    pdobj->_brkcondAfter = brkcondUnknown;

    // Tell LS to prepare a subline
    lserr= LsCreateSubline(pLS->_plsc, lscpStart, MAX_MEASURE_WIDTH, pfmtin->lsfgi.lstflow, FALSE);
    if (lserr != lserrNone)
    {
        goto Cleanup;
    }

    // Tell LS to populate it.
    do
    {
        PLSDNODE plsdnStart;
        PLSDNODE plsdnEnd;

        // Format as much as we can - note we move max to maximum positive value.
        lserr = LsFetchAppendToCurrentSubline(pLS->_plsc,
                                              0,
                                              &s_lsescEndNOBR[0],
                                              NBREAKCHARS,
                                              &fSuccess,
                                              &subfmtres,
                                              &lscpLast,
                                              &plsdnStart,
                                              &plsdnEnd);

        if (lserr != lserrNone)
        {
            goto Cleanup;
        }
        Assert(subfmtres != fmtrExceededMargin); // we are passing max width!

    } while (   (subfmtres != fmtrCompletedRun)  //Loop until one of the conditions is met.
             && !fSuccess
            );

    *pfmtres = subfmtres;

    lserr = LsFinishCurrentSubline(pLS->_plsc, &pdobj->_plssubline);
    if (lserr != lserrNone)
        goto Cleanup;

    // get Object dimensions.
    lserr = LssbGetObjDimSubline(pdobj->_plssubline, &lstflowDontcare, &objdim);
    if (lserr != lserrNone)
        goto Cleanup;

    // We add 2 to include the two synthetic characters at the beginning and end.
    // That's just how it goes, okay.
    lscpUsed = lscpLast - lscpStart + 2;

    pdobj->_lscpObjLast = lscpLast;
    
    // Tell Line Services we have a special object which (a) is not to be broken,
    // and (b) have different min and max widths due to trailing spaces.

    lserr = LsdnSubmitSublines( pLS->_plsc,
                                pfmtin->plsdnTop,
                                1,
                                &pdobj->_plssubline,
                                TRUE, //pLS->_fExpansionOrCompression,  // fUseForJustification
                                TRUE, //pLS->_fExpansionOrCompression,  // fUseForCompression
                                FALSE,  // fUseForDisplay
                                FALSE,  // fUseForDecimalTab
                                TRUE ); // fUseForTrailingArea  

    // Give the data back to LS.
    lserr = LsdnFinishRegular( pLS->_plsc, lscpUsed,
                               pfmtin->lsfrun.plsrun,
                               pfmtin->lsfrun.plschp, (struct dobj *) pdobj, &objdim);
    
    
    if (lserr != lserrNone)
        goto Cleanup;

Cleanup:
    if (lserr != lserrNone && pdobj)
    {
        if (pdobj->_plssubline)
            LsDestroySubline(pdobj->_plssubline);  // Destroy the subline.
        delete pdobj;
    }

    pLS->_fNoBreakForMeasurer = FALSE;

    return lserr;
}

//-----------------------------------------------------------------------------
//
//  Function:   Fmt (member, LS callback)
//
//  Synopsis:   Line Services calls pfnFmt for the appropriate object each time
//              a run is fetched. This callback computes the position of each 
//              element in the run, and returns when the run is exhausted, or 
//              when a potential line break character is reached after the right 
//              margin is exceeded. 
//              During Fmt() an object handler must do one of the following:
//              1. Create an output dobj (display object) and register it with 
//                 a dnode by calling a Fini routine. This places a pointer to 
//                 dobj into a Line Services dnode. The output dobj should 
//                 contain sufficient data to facilitate line breaking and 
//                 display operations.
//              2. Call a Fini routine that deletes the dnode.
//
//  Returns:    lserrNone if the function is successful.
//
//-----------------------------------------------------------------------------
LSERR WINAPI
CGlyphILSObj::Fmt(     // this = plnobj
    PCFMTIN pfmtin,    // IN:  formatting input
    FMTRES* pfmtres)   // OUT: formatting result
{
    LSTRACE(GlyphFmt);
    LSERR           lserr          = lserrNone;
    OBJDIM          objdim;
    PLSRUN          por            = PLSRUN(pfmtin->lsfrun.plsrun);
    CLineServices * pLS            = _pLS;

    CGlyphDobj* pdobj= new CGlyphDobj(this, pfmtin->plsdnTop, por);
    if (!pdobj)
    {
        lserr = lserrOutOfMemory;
        goto Cleanup;
    }

    // For breaking we need to know two things:
    //  (a) is this a glyph represnting a no-scope?
    //  (b) if not, is this representing a begin or end tag?

    pdobj->_fBegin = por->_ptp->IsBeginNode();
    pdobj->_fNoScope = FALSE;

    pdobj->_RenderInfo.pImageContext = NULL;
    Assert(pLS->_fIsEditable);
    if (!por->_ptp->ShowTreePos(&pdobj->_RenderInfo))
    {
        AssertSz(0, "Inconsistent info in one run");
        lserr = lserrInvalidRun;
        goto Cleanup;
    }
    Assert(pdobj->_RenderInfo.pImageContext);

    objdim.heightsRef.dvAscent = pdobj->_RenderInfo.height;
    objdim.heightsRef.dvDescent = 0;
    objdim.heightsRef.dvMultiLineHeight = pdobj->_RenderInfo.height;
    objdim.heightsPres = objdim.heightsRef;
    objdim.dur = pdobj->_RenderInfo.width;

    // This is an accessor to the dnode, telling LS to set the dnode pointing
    // to our dobj.
    lserr = LsdnFinishRegular( pLS->_plsc, por->_lscch, pfmtin->lsfrun.plsrun,
                               pfmtin->lsfrun.plschp, (struct dobj*)pdobj, &objdim);

    *pfmtres = fmtrCompletedRun;

Cleanup:
    return lserr;
}

//-----------------------------------------------------------------------------
//
//  Function:   Fmt (member, LS callback)
//
//  Synopsis:   Line Services calls pfnFmt for the appropriate object each time
//              a run is fetched. This callback computes the position of each 
//              element in the run, and returns when the run is exhausted, or 
//              when a potential line break character is reached after the right 
//              margin is exceeded. 
//              During Fmt() an object handler must do one of the following:
//              1. Create an output dobj (display object) and register it with 
//                 a dnode by calling a Fini routine. This places a pointer to 
//                 dobj into a Line Services dnode. The output dobj should 
//                 contain sufficient data to facilitate line breaking and 
//                 display operations.
//              2. Call a Fini routine that deletes the dnode.
//
//  Returns:    lserrNone if the function is successful.
//
//-----------------------------------------------------------------------------
LSERR WINAPI
CLayoutGridILSObj::Fmt( // this = plnobj
    PCFMTIN pfmtin,     // IN:  formatting input
    FMTRES* pfmtres)    // OUT: formatting result
{
    LSTRACE(LayoutGridFmt);

    return FmtResume(NULL, 0, pfmtin, pfmtres);
}

//-----------------------------------------------------------------------------
//
//  Function:   FmtResume (member, LS callback)
//
//  Synopsis:   This routine is similar to pfnFmt, except it is used to format 
//              the wrapped portion of the object.
//
//  Returns:    lserrNone
//
//-----------------------------------------------------------------------------
LSERR WINAPI
CEmbeddedILSObj::FmtResume(             // this = plnobj
    const BREAKREC* rgBreakRecord,      // IN:  array of break records
    DWORD nBreakRecord,                 // IN:  size of the break records array
    PCFMTIN pfmtin,                     // IN:  formatting input
    FMTRES* pfmtres)                    // OUT: formatting result
{
    LSTRACE(EmbeddedFmtResume);
    LSNOTIMPL(FmtResume);

    // I believe that this should never get called for most embedded objects.
    // The only possible exception that comes to mind are marquees, and I do
    // not believe that they can wrap around lines.

    return lserrNone;
}

//-----------------------------------------------------------------------------
//
//  Function:   FmtResume (member, LS callback)
//
//  Synopsis:   This routine is similar to pfnFmt, except it is used to format 
//              the wrapped portion of the object.
//
//  Returns:    lserrNone
//
//-----------------------------------------------------------------------------
LSERR WINAPI
CNobrILSObj::FmtResume(                 // this = plnobj
    const BREAKREC* rgBreakRecord,      // IN:  array of break records
    DWORD nBreakRecord,                 // IN:  size of the break records array
    PCFMTIN pfmtin,                     // IN:  formatting input
    FMTRES* pfmtres)                    // OUT: formatting result
{
    LSTRACE(NobrFmtResume);
    LSNOTIMPL(FmtResume);

    return lserrNone;
}

//-----------------------------------------------------------------------------
//
//  Function:   FmtResume (member, LS callback)
//
//  Synopsis:   This routine is similar to pfnFmt, except it is used to format 
//              the wrapped portion of the object.
//
//  Returns:    lserrNone
//
//-----------------------------------------------------------------------------
LSERR WINAPI
CGlyphILSObj::FmtResume(                // this = plnobj
    const BREAKREC* rgBreakRecord,      // IN:  array of break records
    DWORD nBreakRecord,                 // IN:  size of the break records array
    PCFMTIN pfmtin,                     // IN:  formatting input
    FMTRES* pfmtres)                    // OUT: formatting result
{
    LSTRACE(GlyphFmtResume);
    LSNOTIMPL(FmtResume);

    return lserrNone;
}

//-----------------------------------------------------------------------------
//
//  Function:   FmtResume (member, LS callback)
//
//  Synopsis:   This routine is similar to pfnFmt, except it is used to format 
//              the wrapped portion of the object.
//
//  Returns:    lserrNone
//
//-----------------------------------------------------------------------------
LSERR WINAPI
CLayoutGridILSObj::FmtResume(           // this = plnobj
    const BREAKREC* rgBreakRecord,      // IN:  array of break records
    DWORD nBreakRecord,                 // IN:  size of the break records array
    PCFMTIN pfmtin,                     // IN:  formatting input
    FMTRES* pfmtres)                    // OUT: formatting result
{
    LSERR lserr = lserrNone;
    FMTRES subfmtres = fmtrCompletedRun;    // keep compiler happy
    OBJDIM objdim;
    LSTFLOW lstflowDontcare;
    LSCP lscpLast = 0;
    BOOL fSuccess = FALSE;
    LONG lObjWidth;
    LSCP dcp;
    BOOL fFmtResume = nBreakRecord != 0;
    PLSRUN por = PLSRUN(pfmtin->lsfrun.plsrun);

    // Create new object and initialize it
    CLayoutGridDobj* pdobjLG = new CLayoutGridDobj(this, pfmtin->plsdnTop, por);
    if (!pdobjLG)
    {
        lserr = lserrOutOfMemory;
        goto Cleanup;
    }
    pdobjLG->_lscpStart = pfmtin->lsfgi.cpFirst;
    pdobjLG->_lscpStartObj = (fFmtResume ? rgBreakRecord->cpFirst : pfmtin->lsfgi.cpFirst);

    // Calculate maximum width of the object
    lObjWidth = pdobjLG->AdjustColumnMax(pfmtin->lsfgi.urColumnMax - pfmtin->lsfgi.urPen);

    while (!fSuccess)
    {
        PLSDNODE    plsdnStart;
        PLSDNODE    plsdnEnd;

        // Tell LS to prepare a subline
        lserr = LsCreateSubline(_pLS->_plsc, pdobjLG->_lscpStart + 1, 
                                lObjWidth, pfmtin->lsfgi.lstflow, FALSE);
        if (lserr != lserrNone)
            goto Cleanup;

        if (fFmtResume)
        {
            lserr = LsFetchAppendToCurrentSublineResume(_pLS->_plsc, &rgBreakRecord[1], 
                            nBreakRecord - 1,
                            0, &s_lsescEndLayoutGrid[0], NBREAKCHARS, 
                            &fSuccess, &subfmtres, &lscpLast, &plsdnStart, &plsdnEnd);
            if (lserr != lserrNone)
                goto Cleanup;
        }
        else 
        {
            subfmtres = fmtrTab;
            fSuccess = TRUE;
        }
        while ((subfmtres == fmtrTab) && fSuccess)
        {
            lserr = LsFetchAppendToCurrentSubline(_pLS->_plsc, 
                            0, &s_lsescEndLayoutGrid[0], NBREAKCHARS, 
                            &fSuccess, &subfmtres, &lscpLast, &plsdnStart, &plsdnEnd);
            if (lserr != lserrNone)
                goto Cleanup;
        }

        if (!fSuccess)
        {
            // FetchAppend unsuccessful.
            // Finish and destroy subline, then repeat
            lserr = LsFinishCurrentSubline(_pLS->_plsc, &pdobjLG->_plssubline);
            if (lserr != lserrNone)
                goto Cleanup;
            lserr = LsDestroySubline(pdobjLG->_plssubline);
            if (lserr != lserrNone)
                goto Cleanup;
        }
        else
            *pfmtres = subfmtres;
    }

    lserr = LsFinishCurrentSubline(_pLS->_plsc, &pdobjLG->_plssubline);
    if (lserr != lserrNone)
        goto Cleanup;

    // Get object dimensions.
    lserr = LssbGetObjDimSubline(pdobjLG->_plssubline, &lstflowDontcare, &objdim);
    if (lserr != lserrNone)
        goto Cleanup;
    lObjWidth = _pLS->GetClosestGridMultiple(_pLS->GetCharGridSize(), objdim.dur);
    pdobjLG->_uSublineOffset = (lObjWidth - objdim.dur) / 2;
    pdobjLG->_uSubline = objdim.dur;
    objdim.dur = lObjWidth;

    // We do not submint the subline because object's width has been changed.

    // Set dcp for whole object
    // If we haven't reached right margin we add 1 to include the synthetic 
    // character (WCH_ENDLAYOUTGRID) at the end.
    dcp = lscpLast - pdobjLG->_lscpStart + (subfmtres == fmtrExceededMargin ? 0 : 1);

    // Give the data back to LS.
    lserr = LsdnFinishRegular( _pLS->_plsc, dcp, pfmtin->lsfrun.plsrun,
                               pfmtin->lsfrun.plschp, (struct dobj *) pdobjLG, &objdim);
    if (lserr != lserrNone)
        goto Cleanup;

Cleanup:
    if (lserr != lserrNone && pdobjLG)
    {
        if (pdobjLG->_plssubline)
        {
            // Finish and destroy subline
            LsFinishCurrentSubline(_pLS->_plsc, &pdobjLG->_plssubline);
            LsDestroySubline(pdobjLG->_plssubline);
        }
        delete pdobjLG;
    }

    return lserr;
}

//-----------------------------------------------------------------------------
//
//  Function:   GetModWidthPrecedingChar (static member, LS callback)
//
//  Synopsis:   Line Services calls pfnGetModWidthPrecedingChar to determine 
//              amount by which width of the preceding char is to be changed.
//
//  Returns:    lserrNone
//
//-----------------------------------------------------------------------------
LSERR WINAPI
CDobjBase::GetModWidthPrecedingChar(
    PDOBJ pdobj,            // IN:  dobj
    PLSRUN plsrun,          // IN:  plsrun of the object
    PLSRUN plsrunText,      // IN:  plsrun of the preceding char
    PCHEIGHTS heightsRef,   // IN:  height info about character
    WCHAR wch,              // IN:  preceding character
    MWCLS mwcls,            // IN:  ModWidth class of preceding character
    long* pdurChange)       // OUT: amount by which width of the preceding char is to be changed
{
    LSTRACE(GetModWidthPrecedingChar);

    *pdurChange = 0;

    return lserrNone;
}

//-----------------------------------------------------------------------------
//
//  Function:   GetModWidthPrecedingChar (static member, LS callback)
//
//  Synopsis:   Line Services calls pfnGetModWidthPrecedingChar to determine 
//              amount by which width of the preceding char is to be changed.
//
//  Returns:    lserrNone
//
//-----------------------------------------------------------------------------
LSERR WINAPI
CNobrDobj::GetModWidthPrecedingChar(
    PDOBJ pdobj,            // IN:  dobj
    PLSRUN plsrun,          // IN:  plsrun of the object
    PLSRUN plsrunText,      // IN:  plsrun of the preceding char
    PCHEIGHTS heightsRef,   // IN:  height info about character
    WCHAR wch,              // IN:  preceding character
    MWCLS mwcls,            // IN:  ModWidth class of preceding character
    long* pdurChange)       // OUT: amount by which width of the preceding char is to be changed
{
    LSTRACE(NobrGetModWidthPrecedingChar);

    // ????
    // NOTE (cthrash) This is wrong.  We need to determine the MWCLS of the
    // first char of the NOBR and determine how much we should adjust the width.

    *pdurChange = 0;

    return lserrNone;
}

//-----------------------------------------------------------------------------
//
//  Function:   GetModWidthFollowingChar (static member, LS callback)
//
//  Synopsis:   Line Services calls pfnGetModWidthFollowingChar to determine 
//              amount by which width of the following char is to be changed.
//
//  Returns:    lserrNone
//
//-----------------------------------------------------------------------------
LSERR WINAPI
CDobjBase::GetModWidthFollowingChar(
    PDOBJ pdobj,            // IN:  dobj
    PLSRUN plsrun,          // IN:  plsrun of the object
    PLSRUN plsrunText,      // IN:  plsrun of the following char
    PCHEIGHTS heightsRef,   // IN:  height info about character
    WCHAR wch,              // IN:  following character
    MWCLS mwcls,            // IN:  ModWidth class of the following character
    long* pdurChange)       // OUT: amount by which width of the following char is to be changed
{
    LSTRACE(GetModWidthFollowingChar);

    *pdurChange = 0;

    return lserrNone;
}

//-----------------------------------------------------------------------------
//
//  Function:   GetModWidthFollowingChar (static member, LS callback)
//
//  Synopsis:   Line Services calls pfnGetModWidthFollowingChar to determine 
//              amount by which width of the following char is to be changed.
//
//  Returns:    lserrNone
//
//-----------------------------------------------------------------------------
LSERR WINAPI
CNobrDobj::GetModWidthFollowingChar(
    PDOBJ pdobj,            // IN:  dobj
    PLSRUN plsrun,          // IN:  plsrun of the object
    PLSRUN plsrunText,      // IN:  plsrun of the following char
    PCHEIGHTS heightsRef,   // IN:  height info about character
    WCHAR wch,              // IN:  following character
    MWCLS mwcls,            // IN:  ModWidth class of the following character
    long* pdurChange)       // OUT: amount by which width of the following char is to be changed
{
    LSTRACE(NobrGetModWidthFollowingChar);

    // ????
    // NOTE (cthrash) This is wrong.  We need to determine the MWCLS of the
    // last char of the NOBR and determine how much we should adjust the width.
    
    *pdurChange = 0; 

    return lserrNone;
}

//-----------------------------------------------------------------------------
//
//  Function:   TruncateChunk (static member, LS callback)
//
//  Synopsis:   From LS docs: Purpose    To obtain the exact position within
//              a chunk where the chunk crosses the right margin.  A chunk is
//              a group of contiguous LS objects which are of the same type.
//
//  Returns:    lserrNone if the function is successful.
//
//-----------------------------------------------------------------------------
LSERR WINAPI
CDobjBase::TruncateChunk(
    PCLOCCHNK plocchnk,     // IN:  locchnk to truncate
    PPOSICHNK pposichnk)    // OUT: truncation point
{
    LSTRACE(TruncateChunk);
    LSERR lserr = lserrNone;
    long idobj;
    
    if (plocchnk->clschnk == 1)
    {
        idobj = 0;
    }
    else
    {
        long urColumnMax;
        long urTotal;
        OBJDIM objdim;

        urColumnMax = PDOBJ(plocchnk->plschnk[0].pdobj)->GetPLS()->_xWrappingWidth;
        urTotal = plocchnk->lsfgi.urPen;

        Assert(urTotal <= urColumnMax);

        for (idobj = 0; idobj < (long)plocchnk->clschnk; idobj++)
        {
            CDobjBase * pdobj = (CDobjBase *)plocchnk->plschnk[idobj].pdobj;
            lserr = pdobj->QueryObjDim(&objdim);
            if (lserr != lserrNone)
                goto Cleanup;

            urTotal += objdim.dur;
            if (urTotal > urColumnMax)
                break;
        }

        Assert(urTotal > urColumnMax);
        Assert(idobj < (long)plocchnk->clschnk);
        if (idobj >= (long)plocchnk->clschnk)
        {
            idobj = 0;
        }
    }

    // Tell it which chunk didn't fit.

    pposichnk->ichnk = idobj;

    // Tell it which cp inside this chunk the break occurs at.
    // In our case, it's always an all-or-nothing proposition.  So include the whole dobj

    pposichnk->dcp = plocchnk->plschnk[idobj].dcp;

    TraceTag((tagTraceILSBreak,
              "Truncate(cchnk=%d cpFirst=%d) -> ichnk=%d",
              plocchnk->clschnk,
              plocchnk->plschnk->cpFirst,
              idobj
             ));

Cleanup:

    return lserr;
}


//-----------------------------------------------------------------------------
//
//  Function:   TruncateChunk (static member, LS callback)
//
//  Synopsis:   From LS docs: Purpose    To obtain the exact position within
//              a chunk where the chunk crosses the right margin.  A chunk is
//              a group of contiguous LS objects which are of the same type.
//
//  Returns:    lserrNone if the function is successful.
//
//-----------------------------------------------------------------------------
LSERR WINAPI
CNobrDobj::TruncateChunk(
    PCLOCCHNK plocchnk,     // IN:  locchnk to truncate
    PPOSICHNK pposichnk)    // OUT: truncation point
{
    LSTRACE(NOBRTruncateChunk);

    LSERR   lserr = lserrNone;
    long    urColumnMax = plocchnk->lsfgi.urColumnMax;
    long    ur = plocchnk->ppointUvLoc[0].u;
    long    idobj;
    CNobrDobj *pdobjNOBR;
    OBJDIM  objdim = {0};   // keep compiler happy
    LONG    xWidthOfSpace;
    
    AssertSz(ur <= urColumnMax, "TruncateChunk - pen greater than column max");

    for (idobj = 0; idobj < (long)plocchnk->clschnk; idobj++)
    {
        CDobjBase * pdobj = (CDobjBase *)plocchnk->plschnk[idobj].pdobj;
        lserr = pdobj->QueryObjDim(&objdim);
        if (lserr != lserrNone)
            goto Cleanup;

        ur = plocchnk->ppointUvLoc[idobj].u + objdim.dur;
        if (ur > urColumnMax)
            break;
    }

    Assert(ur > urColumnMax);
    Assert(idobj < (long)plocchnk->clschnk);
    
    pdobjNOBR = (CNobrDobj*)plocchnk->plschnk[idobj].pdobj;
    
    // Tell it which chunk didn't fit.
    pposichnk->ichnk = idobj;

    if (PDOBJ(pdobjNOBR)->GetPLS()->ShouldBreakInNOBR(pdobjNOBR->_lscpObjStart,
            pdobjNOBR->_lscpObjLast, urColumnMax, ur, &xWidthOfSpace))
    {
        pdobjNOBR->_fCanBreak = TRUE;
        pdobjNOBR->_xShortenedWidth = objdim.dur - xWidthOfSpace;

        Assert(pdobjNOBR->_xShortenedWidth <= urColumnMax);
        
        // Tell it which cp inside this chunk the break occurs at.
        // In our case, before the space, hence one char for
        // the endnobr synth and one for the space.
        pposichnk->dcp = plocchnk->plschnk[idobj].dcp - 2;
    }
    else
    {
        // Tell it which cp inside this chunk the break occurs at.
        // In our case, it's always an all-or-nothing proposition.  So include the whole dobj
        pposichnk->dcp = plocchnk->plschnk[idobj].dcp;
    }

Cleanup:    
    return lserr;
}

//-----------------------------------------------------------------------------
//
//  Function:   TruncateChunk (static member, LS callback)
//
//  Synopsis:   From LS docs: Purpose    To obtain the exact position within
//              a chunk where the chunk crosses the right margin.  A chunk is
//              a group of contiguous LS objects which are of the same type.
//
//  Returns:    lserrNone if the function is successful.
//
//-----------------------------------------------------------------------------
LSERR WINAPI
CLayoutGridDobj::TruncateChunk(
    PCLOCCHNK plocchnk,     // IN:  locchnk to truncate
    PPOSICHNK pposichnk)    // OUT: truncation point
{
    LSTRACE(LayoutGridTruncateChunk);

    LSERR   lserr = lserrNone;
    long    urColumnMax = plocchnk->lsfgi.urColumnMax;
    long    ur = plocchnk->ppointUvLoc[0].u;
    OBJDIM  objdim;
    LSCP    lscp;
    long    idobj;
    CLayoutGridDobj * pdobjLG;
    long    urSublineColumnMax;

    AssertSz(ur <= urColumnMax, "TruncateChunk - pen greater than column max");

    for (idobj = 0; idobj < (long)plocchnk->clschnk; idobj++)
    {
        CDobjBase * pdobj = (CDobjBase *)plocchnk->plschnk[idobj].pdobj;
        lserr = pdobj->QueryObjDim(&objdim);
        if (lserr != lserrNone)
            goto Cleanup;

        ur = plocchnk->ppointUvLoc[idobj].u + objdim.dur;
        if (ur > urColumnMax)
            break;
    }

    Assert(ur > urColumnMax);
    Assert(idobj < (long)plocchnk->clschnk);

    // Found the object where truncation is to occur
    pdobjLG = (CLayoutGridDobj *)plocchnk->plschnk[idobj].pdobj;

    // Get the truncation point from the subline
    // We need to subtract offset of the subline (plocchnk->ppointUvLoc[idobj].u) from
    // 'urColumnMax', because if we change subline's width we need to adjust width of 
    // the object one again (in SetBreak()), so we don't care about current offset.
    urSublineColumnMax = pdobjLG->AdjustColumnMax(urColumnMax - plocchnk->ppointUvLoc[idobj].u);
    pdobjLG->_fCanBreak = urSublineColumnMax > 0;
    if (pdobjLG->_fCanBreak)
    {
        lserr = LsTruncateSubline(pdobjLG->_plssubline, urSublineColumnMax, &lscp);
        if (lserr != lserrNone) 
            goto Cleanup;
    }
    else
    {
        // If we set 0 then LS will return an error, so 
        // we set 1 and mark that we can't break
        lscp = pdobjLG->LSCPLocal2Global(1);
    }

    // Format return result
    pposichnk->ichnk = idobj;
    pposichnk->dcp = pdobjLG->LSCPGlobal2Local(lscp);
    Assert(pposichnk->dcp > 0 && pposichnk->dcp <= plocchnk->plschnk[idobj].dcp);

    TraceTag((tagTraceILSBreak,
              "Truncate(cchnk=%d cpFirst=%d) -> ichnk=%d",
              plocchnk->clschnk, plocchnk->plschnk->cpFirst, idobj));

Cleanup:

    return lserr;
}


//-----------------------------------------------------------------------------
//
//  Function:   TruncateChunk (static member, LS callback)
//
//  Synopsis:   From LS docs: Purpose    To obtain the exact position within
//              a chunk where the chunk crosses the right margin.  A chunk is
//              a group of contiguous LS objects which are of the same type.
//
//  Returns:    lserrNone if the function is successful.
//
//-----------------------------------------------------------------------------
LSERR WINAPI
CGlyphDobj::TruncateChunk(PCLOCCHNK plocchnk,     // IN:  locchnk to truncate
                          PPOSICHNK pposichnk)    // OUT: truncation point
{
    LSTRACE(GlyphDobjTruncateChunk);
    CDobjBase * pdobj = (CDobjBase *)plocchnk->plschnk[0].pdobj;
    CLineServices *pLS = PDOBJ(pdobj)->GetPLS();
    LONG idobj = 0;
    LONG minidobj = -1;
    LSERR lserr;
    
    // If we are measuring from the start then there were some glyphs
    // at the BOL which could also have some alogned objects inside them.
    // If that is the case then we can never break between glyphed objects
    // at BOL when they have aligned objects in between them since
    // these glyphed objects have already been "consumed" when we were
    // consuming the aligned objects. If we do break then the aligned object
    // may (will) get measured again -- resulting in bad layout or worse.
    // (See IE5 bug 107056)
    if (pLS->_pMeasurer->_fMeasureFromTheStart)
    {
        for (idobj = 0; idobj < (long)plocchnk->clschnk - 1; idobj++)
        {
            pdobj = (CDobjBase *)plocchnk->plschnk[idobj].pdobj;
            if (pdobj->Por()->Cp() - pLS->_cpStart >= pLS->_cchSkipAtBOL)
            {
                break;
            }
        }
    }
    minidobj = idobj;
    lserr = super::TruncateChunk(plocchnk, pposichnk);
    if (lserr == lserrNone)
    {
        // Our default method returned a berak opportunity _before_
        // the cchSkipAtBOL limit. Lets change it to the minimum
        // index required to skip the the cchSkipAtBOL.
        if (minidobj > pposichnk->ichnk)
        {
            pposichnk->ichnk = minidobj;
            pposichnk->dcp = plocchnk->plschnk[minidobj].dcp;
        }
    }
    return lserr;
}

//-----------------------------------------------------------------------------
//
//  Function:   CanBreakPair (local helper function)
//
//-----------------------------------------------------------------------------
inline BOOL
CanBreakPair(BRKCOND brkcondBefore, BRKCOND brkcondAfter)
{
    // brkcondPlease = 0
    // brkcondCan    = 1
    // brkcondNever  = 2
    //
    //
    //         | Please |   Can  |  Never
    // --------+--------+--------+---------
    //  Please |  TRUE  |  TRUE  |  FALSE
    // --------+--------+--------+---------
    //  Can    |  TRUE  |  FALSE |  FALSE
    // --------+--------+--------+---------
    //  Never  |  FALSE |  FALSE |  FALSE

    return (int(brkcondBefore) + int(brkcondAfter)) < 2;
}

//-----------------------------------------------------------------------------
//
//  Function:   DumpBrkopt (local helper function)
//
//-----------------------------------------------------------------------------
#if DBG==1
void
DumpBrkopt(
    char *szType,
    BOOL fMinMaxPass,
    PCLOCCHNK plocchnk,
    PCPOSICHNK pposichnk,
    BRKCOND brkcond,
    PBRKOUT pbrkout)
{
    static const char * achBrkCondStr[3] = { "Please", "Can", "Never" };

    // Make sure we don't try to break before the first object on the line.  This is bad.

    AssertSz(   !pbrkout->fSuccessful
             || !plocchnk->lsfgi.fFirstOnLine
             || pbrkout->posichnk.ichnk > 0
             || pbrkout->posichnk.dcp > 0,
             "Bad breaking position.  Cannot break at BOL.");

    TraceTag((tagTraceILSBreak,
              "%s(brkcond=%s cchnk=%d ichnk=%d) minmax=%s urPen=%d "
              "-> %s(%s) on %d(%s)",
              szType,
              achBrkCondStr[brkcond],
              plocchnk->clschnk,
              pposichnk->ichnk,
              fMinMaxPass ? "yes" : "no",
              plocchnk->lsfgi.urPen,
              pbrkout->fSuccessful ? "true" : "false",
              achBrkCondStr[pbrkout->brkcond],
              pbrkout->posichnk.ichnk,
              pbrkout->posichnk.dcp > 0 ? "after" : "before"));
}
#else
#define DumpBrkopt(a,b,c,d,e,f)
#endif

//-----------------------------------------------------------------------------
//
//  Function:   FindPrevBreakChunk (static member, LS callback)
//
//  Synopsis:   Line Services calls pfnFindPrevBreakChunk to find a break 
//              opportunity.
//              It is possible for pfnFindPrevBreakChunk to be called even when 
//              the right margin occurs beyond the object.
//
//  Returns:    lserrNone if the function is successful.
//
//-----------------------------------------------------------------------------
LSERR WINAPI
CEmbeddedDobj::FindPrevBreakChunk(
    PCLOCCHNK plocchnk,     // IN:  locchnk to break
    PCPOSICHNK pposichnk,   // IN:  place to start looking for break
    BRKCOND brkcond,        // IN:  recommmendation about the break after chunk
    PBRKOUT pbrkout)        // OUT: results of breaking
{
    LSTRACE(EmbeddedFindPrevBreakChunk);

    LSERR           lserr;
    BOOL            fSuccessful;
    BOOL            fBreakAfter = pposichnk->ichnk == ichnkOutside;
    long            ichnk = fBreakAfter
                            ? long(plocchnk->clschnk) - 1L
                            : long(pposichnk->ichnk);
    CEmbeddedDobj * pdobj = (CEmbeddedDobj *)(plocchnk->plschnk[ichnk].pdobj);
    CLineServices * pLS = pdobj->GetPLS();
    // An object may be first on line even though the fFirstOnLine bit is not set.
    // This can happen with synthetics -- since for LS they are actual objects, 
    // it claims that this embedded object is after them on the line and 
    // hence is not first on line -- but for us that synthetic object and 
    // this embedded object are inseparable -- 
    // i.e. we do not want to break before this object under any circumstance.
    BOOL fDontBreakBeforeMe = plocchnk->lsfgi.fFirstOnLine;
    if (!fDontBreakBeforeMe)
    {
        COneRun * por = pdobj->_por->_pPrev;
        while (por && !por->IsNormalRun())
            por = por->_pPrev;

        fDontBreakBeforeMe = !por;
    }
    
    WHEN_DBG( BRKCOND brkcondIn = brkcond );

    if (!pdobj->_fIsBreakingSite)
    {
        if (fBreakAfter)
        {
            //
            // If fBreakAfter is TRUE, we have the following scenario (| represents wrapping width):
            //
            // AAA<IMG><IMG>B|BB
            //

            if (!pLS->_fIsTD || !pLS->_fMinMaxPass || (pLS->_xTDWidth < MAX_MEASURE_WIDTH))
            {
                // If we're not in a TD, we can break after the dobj, the subsequent dobj permitting.
                // If the subsequent dobj is not willing, we can break between the dobjs in this chunk.

                if (brkcond == brkcondPlease)
                {
                    fSuccessful = TRUE;
                    brkcond = brkcondPlease;
                }
                else
                {
                    fBreakAfter = FALSE;
                    
                    fSuccessful = ichnk > 0 || !fDontBreakBeforeMe;
                    brkcond = fSuccessful ? brkcondPlease : brkcondNever;
                }
            }
            else
            {
                fSuccessful = FALSE;
                brkcond = brkcondCan;
            }
        }
        else if (ichnk == 0 && fDontBreakBeforeMe)
        {
            // We can never break before the first dobj on the line.

            fSuccessful = FALSE;
            brkcond = brkcondNever;
        }
        else
        {
            //
            // fBreakAfter is FALSE, meaning we're splitting up our dobj chunks
            //
            // AAA<IMG><IM|G>BBB
            //

            if (pLS->_fIsTD)
            {
                if (pLS->_xTDWidth == MAX_MEASURE_WIDTH)
                {
                    // TD has no stated width.
                    
                    if (ichnk == 0)
                    {
                        // To do this correctly in the MinMaxPass, we would need to know the
                        // brkcond of the character preceeding our chunk.  The incoming
                        // brkcond, however, is meaningless unless ichnk==ichnkOutside.
                        
                        fSuccessful = FALSE;//!pLS->_fMinMaxPass;
                        brkcond = brkcondCan;
                    }
                    else
                    {
                        // Our TD has no width, so we can break only if our wrapping width
                        // has been exceeded.  Note we will be called during LsGetMinDurBreaks
                        // even if our wrapping width isn't exceeded, because we don't know
                        // yet what that width is.

                        fSuccessful = !pLS->_fMinMaxPass || ((CEmbeddedDobj *)(plocchnk->plschnk[ichnk-1].pdobj))->_fIsBreakingSite;
                        brkcond = fSuccessful ? brkcondPlease : brkcondCan;
                    }
                }
                else
                {
                    // TD has a stated width.

                    if (pLS->_fMinMaxPass)
                    {
                        if (ichnk == 0)
                        {
                            fSuccessful = plocchnk->lsfgi.urColumnMax > pLS->_xTDWidth;
                            brkcond = fSuccessful ? brkcondPlease : brkcondCan;
                        }
                        else
                        {
                            // When we're called from LsGetMinDurBreaks, urColumnMax is the
                            // proposed wrapping width.  If this is greater than the TDs
                            // stated width, we can break.  Otherwise, we can't.

                            fSuccessful = plocchnk->lsfgi.urColumnMax > pLS->_xTDWidth;
                            brkcond = fSuccessful ? brkcondPlease : brkcondNever;
                        }
                    }
                    else
                    {
                        // If we're not in a min-max pass, we reach this point only if this
                        // particular dobj has caused an overflow.  We should break before it.

                        fSuccessful = TRUE;
                        brkcond = brkcondPlease;
                    }
                }
            }
            else
            {
                // We're not in a TD, meaning we will break between the dobjs in our chunks.

                if (ichnk)
                {
                    fSuccessful = TRUE;
                    brkcond = brkcondPlease;
                }
                else
                {
                    fSuccessful = TRUE;
                    brkcond = fSuccessful ? brkcondCan : brkcondNever;
                }
            }
        }
    }
    else
    {
        // We have a dobj around which we always break, such as a MARQUEE.
        // We will break as long as we're not at the beginning of the line.

        if (fBreakAfter)
        {
            fSuccessful = brkcond != brkcondNever;
            brkcond = brkcondPlease;
        }
        else
        {
            fSuccessful = ichnk > 0;
            brkcond = fDontBreakBeforeMe ? brkcondNever : brkcondPlease;
        }
    }

    pbrkout->fSuccessful = fSuccessful;
    pbrkout->brkcond = brkcond;
    pbrkout->posichnk.ichnk = ichnk;
    pbrkout->posichnk.dcp = fBreakAfter ? plocchnk->plschnk[ichnk].dcp : 0;

    lserr = pdobj->QueryObjDim(&pbrkout->objdim);

    DumpBrkopt( "Prev(E)", pLS->_fMinMaxPass, plocchnk, pposichnk, brkcondIn, pbrkout );

    return lserr;
}

//-----------------------------------------------------------------------------
//
//  Function:   FindNextBreakChunk (static member, LS callback)
//
//  Synopsis:   Line Services calls pfnFindPrevBreakChunk to find a break 
//              opportunity.
//
//  Returns:    lserrNone if the function is successful.
//
//-----------------------------------------------------------------------------
LSERR WINAPI
CEmbeddedDobj::FindNextBreakChunk(
    PCLOCCHNK plocchnk,     // IN:  locchnk to break
    PCPOSICHNK pposichnk,   // IN:  place to start looking for break
    BRKCOND brkcond,        // IN:  recommmendation about the break before chunk
    PBRKOUT pbrkout)        // OUT: results of breaking
{
    LSTRACE(EmbeddedFindNextBreakChunk);

    LSERR   lserr;
    BOOL    fSuccessful;
    BOOL    fBreakBefore = (pposichnk->ichnk == ichnkOutside);
    long    ichnk = fBreakBefore
                    ? 0
                    : pposichnk->ichnk;
    CEmbeddedDobj *pdobj = (CEmbeddedDobj *)(plocchnk->plschnk[ichnk].pdobj);
    CLineServices * pLS = pdobj->GetPLS();

    BOOL fDontBreakBeforeMe = plocchnk->lsfgi.fFirstOnLine;
    if (!fDontBreakBeforeMe)
    {
        COneRun * por = pdobj->_por->_pPrev;
        while (por && !por->IsNormalRun())
            por = por->_pPrev;

        fDontBreakBeforeMe = !por;
    }

    WHEN_DBG( BRKCOND brkcondIn = brkcond );

    if (!pdobj->_fIsBreakingSite)
    {
        if (fBreakBefore)
        {
            fBreakBefore = !fDontBreakBeforeMe;
            fSuccessful = fBreakBefore || (plocchnk->clschnk > 1);
            brkcond = fSuccessful ? brkcondPlease : brkcondCan;
        }
        else
        {
            if (ichnk == (long(plocchnk->clschnk) - 1))
            {
                // If this is the last dobj of the chunk, we need to ask the next
                // object if it's okay to break.

                fSuccessful = FALSE;
                brkcond = brkcondCan;
            }
            else
            {
                if (pLS->_fIsTD && pLS->_xTDWidth == MAX_MEASURE_WIDTH)
                {
                    // We are in TD with no width, so we cannot break between our dobjs.

                    fSuccessful = ((CEmbeddedDobj *)(plocchnk->plschnk[ichnk+1].pdobj))->_fIsBreakingSite;;
                    brkcond = fSuccessful ? brkcondPlease : brkcondCan;
                }
                else
                {
                    // We are not in a TD, or we're in a TD with a width.
                    // We've exceeded the wrapping width, so we can break.

                    fSuccessful = TRUE;
                    brkcond = brkcondPlease;
                }
            }
        }
    }
    else
    {
        if (fBreakBefore)
        {
            fSuccessful = !fDontBreakBeforeMe;
            brkcond = fSuccessful ? brkcondPlease : brkcondCan;
        }
        else
        {
            fSuccessful = TRUE;
            brkcond = brkcondPlease;
        }
    }

    pbrkout->fSuccessful = fSuccessful;
    pbrkout->brkcond = brkcond;
    pbrkout->posichnk.ichnk = ichnk;
    pbrkout->posichnk.dcp = fBreakBefore ? 0 : plocchnk->plschnk[ichnk].dcp;

    lserr = pdobj->QueryObjDim(&pbrkout->objdim);

    DumpBrkopt( "Next(E)", pLS->_fMinMaxPass, plocchnk, pposichnk, brkcondIn, pbrkout );

    return lserr;
}

//-----------------------------------------------------------------------------
//
//  Function:   FindPrevBreakChunk (static member, LS callback)
//
//  Synopsis:   Line Services calls pfnFindPrevBreakChunk to find a break 
//              opportunity.
//              It is possible for pfnFindPrevBreakChunk to be called even when 
//              the right margin occurs beyond the object.
//
//  Returns:    lserrNone if the function is successful.
//
//-----------------------------------------------------------------------------
LSERR WINAPI 
CNobrDobj::FindPrevBreakChunk(
    PCLOCCHNK plocchnk,     // IN:  locchnk to break
    PCPOSICHNK pposichnk,   // IN:  place to start looking for break
    BRKCOND brkcond,        // IN:  recommmendation about the break after chunk
    PBRKOUT pbrkout)        // OUT: results of breaking
{
    LSTRACE(NobrFindPrevBreakChunk);

    BOOL    fBreakAfter = pposichnk->ichnk == ichnkOutside;
    long    ichnk = fBreakAfter
                    ? long(plocchnk->clschnk) - 1L
                    : long(pposichnk->ichnk);
    LSERR   lserr;
    BOOL    fSuccessful;
    CNobrDobj *pdobj = (CNobrDobj *)(plocchnk->plschnk[ichnk].pdobj);

    WHEN_DBG( CLineServices * pLS = pdobj->GetPLS() );
    WHEN_DBG( BRKCOND brkcondIn = brkcond );

    if (fBreakAfter)
    {
        // break after?

        BRKCOND brkcondNext = brkcond;
        COneRun * por = (COneRun *)plocchnk->plschnk[ichnk].plsrun;

        // compute the brkcond of the last char of the last chunk.

        brkcond = pdobj->GetBrkcondAfter(por, plocchnk->plschnk[ichnk].dcp);

        // can we break immediately after the last NOBR?

        fSuccessful = CanBreakPair(brkcond, brkcondNext);

        if (!fSuccessful)
        {
            fBreakAfter = FALSE;

            if (plocchnk->clschnk > 1)
            {
                // if we have more than one NOBR objects, we can always break between them.

                Assert(!por->_fIsArtificiallyStartedNOBR);

                fSuccessful = TRUE;
                brkcond = brkcondPlease;
            }
            else
            {
                // if we only have one NOBR object, we need to see if we can break before it.

                if (plocchnk->lsfgi.fFirstOnLine)
                {
                    brkcond = brkcondNever;
                    fSuccessful = FALSE;
                }
                else
                {
                    brkcond = pdobj->GetBrkcondBefore(por);
                    fSuccessful = brkcond != brkcondNever;
                }
            }
        }
    }
    else
    {
        if (pdobj->_fCanBreak)
        {
            LONG cpBreak;
            OBJDIM objdimSubline;
            BRKPOS  brkpos;
            
            lserr = LsFindPrevBreakSubline(pdobj->_plssubline, plocchnk->lsfgi.fFirstOnLine,
                                       pdobj->LSCPLocal2Global(pposichnk->dcp),
                                       pdobj->_xShortenedWidth, &fSuccessful, 
                                       &cpBreak, &objdimSubline, &brkpos);

            
            long dcp;

            if (brkpos == brkposInside)
                dcp = pposichnk->dcp;
            else
                dcp = pdobj->LSCPGlobal2Local(cpBreak);
            pbrkout->fSuccessful = fSuccessful;
            if (brkcond == brkcondPlease || brkcond == brkcondCan || brkcond == brkcondNever)
                pbrkout->brkcond = brkcond;
            else
                pbrkout->brkcond = brkcondPlease;

            if (fSuccessful)
            {
                pbrkout->posichnk.ichnk = ichnk;
                pbrkout->posichnk.dcp = dcp;
                pbrkout->objdim = objdimSubline;
                pbrkout->objdim.dur = pdobj->_xShortenedWidth;
                goto Cleanup;
            }
        }
        else
        {
            if (ichnk)
            {
                // break in between?

                fSuccessful = TRUE;
                brkcond = brkcondPlease; // IE4 compat: for <NOBR>X</NOBR><NOBR>Y</NOBR> we are always willing to break between X and Y.
            }
            else if (plocchnk->lsfgi.fFirstOnLine)
            {
                fSuccessful = FALSE;
            }
            else
            {
                // break before?

                Assert(ichnk == 0); // It has to be the first object
                brkcond = pdobj->GetBrkcondBefore((COneRun *)plocchnk->plschnk[ichnk].plsrun);
                fSuccessful = FALSE;//brkcond != brkcondNever;
            }
        }
    }

    pbrkout->fSuccessful = fSuccessful;
    pbrkout->brkcond = brkcond;
    pbrkout->posichnk.ichnk = ichnk;
    pbrkout->posichnk.dcp = fBreakAfter ? plocchnk->plschnk[ichnk].dcp : 0;

    lserr = pdobj->QueryObjDim(&pbrkout->objdim);

    DumpBrkopt( "Prev(N)", pLS->_fMinMaxPass, plocchnk, pposichnk, brkcondIn, pbrkout );

Cleanup:    
    return lserr;
}

//-----------------------------------------------------------------------------
//
//  Function:   FindNextBreakChunk (static member, LS callback)
//
//  Synopsis:   Line Services calls pfnFindPrevBreakChunk to find a break 
//              opportunity.
//
//  Returns:    lserrNone if the function is successful.
//
//-----------------------------------------------------------------------------
LSERR WINAPI 
CNobrDobj::FindNextBreakChunk(
    PCLOCCHNK plocchnk,     // IN:  locchnk to break
    PCPOSICHNK pposichnk,   // IN:  place to start looking for break
    BRKCOND brkcond,        // IN:  recommmendation about the break before chunk
    PBRKOUT pbrkout)        // OUT: results of breaking
{
    LSTRACE(NobrFindNextBreakChunk);

    BOOL    fBreakBefore = (pposichnk->ichnk == ichnkOutside);
    long    ichnk = fBreakBefore
                    ? 0
                    : pposichnk->ichnk;
    LSERR   lserr;
    BOOL    fSuccessful;

    CNobrDobj *pdobj = (CNobrDobj *)(plocchnk->plschnk[ichnk].pdobj);

    WHEN_DBG( CLineServices * pLS = pdobj->GetPLS() );
    WHEN_DBG( BRKCOND brkcondIn = brkcond );

    if (fBreakBefore)
    {
        // Break before?

        BRKCOND brkcondBefore = brkcond;

        // Determine if we have an appropriate breaking boundary

        brkcond = pdobj->GetBrkcondBefore((COneRun *)plocchnk->plschnk[0].plsrun);
        fSuccessful = CanBreakPair(brkcondBefore, brkcond);

        if (!fSuccessful)
        {
            fBreakBefore = FALSE;

            if (plocchnk->clschnk > 1)
            {
                // if we have more than one NOBR objects, we can always break between them.

                fSuccessful = TRUE;
                brkcond = brkcondPlease;
            }
            else
            {
                // if we only have one NOBR object, we need to see if we can break after it.

                brkcond = pdobj->GetBrkcondAfter((COneRun *)plocchnk->plschnk[0].plsrun, plocchnk->plschnk[0].dcp );
                fSuccessful = FALSE;//brkcond != brkcondNever;
            }
        }
    }
    else
    {
        if (ichnk < (long(plocchnk->clschnk) - 1))
        {
            // if we're not the last NOBR object, we can always break after it.

            fSuccessful = TRUE;
            brkcond = brkcondPlease;
        }
        else
        {
            // break after?

            brkcond = pdobj->GetBrkcondAfter((COneRun *)plocchnk->plschnk[ichnk].plsrun, plocchnk->plschnk[ichnk].dcp );
            fSuccessful = FALSE;
        }
    }

    pbrkout->fSuccessful = fSuccessful;
    pbrkout->brkcond = brkcond;
    pbrkout->posichnk.ichnk = ichnk;
    pbrkout->posichnk.dcp = fBreakBefore ? 0 : plocchnk->plschnk[ichnk].dcp;

    lserr = pdobj->QueryObjDim(&pbrkout->objdim);

    DumpBrkopt( "Next(N)", pLS->_fMinMaxPass, plocchnk, pposichnk, brkcondIn, pbrkout );

    return lserr;
}

//-----------------------------------------------------------------------------
//
//  Function:   FindPrevBreakChunk (static member, LS callback)
//
//  Synopsis:   Line Services calls pfnFindPrevBreakChunk to find a break 
//              opportunity.
//              It is possible for pfnFindPrevBreakChunk to be called even when 
//              the right margin occurs beyond the object.
//
//  Returns:    lserrNone if the function is successful.
//
//-----------------------------------------------------------------------------
LSERR WINAPI 
CGlyphDobj::FindPrevBreakChunk(
    PCLOCCHNK plocchnk,     // IN:  locchnk to break
    PCPOSICHNK pposichnk,   // IN:  place to start looking for break
    BRKCOND brkcond,        // IN:  recommmendation about the break after chunk
    PBRKOUT pbrkout)        // OUT: results of breaking
{
    LSTRACE(GlyphFindPrevBreakChunk);

    BOOL         fSuccessful;
    BOOL         fBreakAfter = (pposichnk->ichnk == ichnkOutside);
    long         ichnk = fBreakAfter
                         ? long(plocchnk->clschnk) - 1L
                         : long(pposichnk->ichnk);
    CGlyphDobj * pdobj = (CGlyphDobj *)(plocchnk->plschnk[ichnk].pdobj);
    LSERR        lserr;

    WHEN_DBG( CLineServices * pLS = pdobj->GetPLS() );

    if (fBreakAfter)
    {
        //                         Second DOBJ
        //
        //                       TEXT   NOSCOPE   BEGIN    END
        //            --------+-------+--------+--------+--------
        //   First    TEXT    |  n/a  | before | before |  no
        //    DOBJ    NOSCOPE | after | after  | after  | after
        //            BEGIN   |   no  | after  |  no    |  no
        //            END     | after | after  | after  |  no
        //

        BOOL fNextWasEnd = FALSE;

        do
        {
            pdobj = (CGlyphDobj *)(plocchnk->plschnk[ichnk].pdobj);

            // break after NOSCOPE, or END unless followed by END

            fSuccessful =    pdobj->_fNoScope
                          || (!pdobj->_fBegin && !fNextWasEnd);

            if (fSuccessful)
                break;

            fNextWasEnd = !pdobj->_fBegin;

        } while (ichnk--);

        if (!fSuccessful)
        {
            // break before text and BEGIN

            ichnk = 0;
            fSuccessful = !plocchnk->lsfgi.fFirstOnLine && pdobj->_fBegin;
            fBreakAfter = FALSE;
        }
    }
    else
    {
        if (pdobj->_fNoScope)
        {
            // break before NOSCOPE

            fSuccessful = TRUE;
        }
        else
        {
            // break before BEGIN preceeded by TEXT/END/NOSCOPE

            if (ichnk)
            {
                if (pdobj->_fBegin)
                {
                    CGlyphDobj * pdobjPrev = (CGlyphDobj *)(plocchnk->plschnk[ichnk-1].pdobj);

                    fSuccessful = pdobjPrev->_fNoScope || !pdobjPrev->_fBegin;
                }
                else
                {
                    fSuccessful = FALSE;
                }
            }
            else
            {
                fSuccessful = !plocchnk->lsfgi.fFirstOnLine && pdobj->_fBegin;
            }
        }
    }

    pbrkout->fSuccessful = fSuccessful;
    pbrkout->brkcond = fSuccessful ? brkcondPlease : brkcondNever;
    pbrkout->posichnk.ichnk = ichnk;
    pbrkout->posichnk.dcp = fBreakAfter ? plocchnk->plschnk[ichnk].dcp : 0;

    lserr = pdobj->QueryObjDim(&pbrkout->objdim);

    DumpBrkopt( "Prev(G)", pLS->_fMinMaxPass, plocchnk, pposichnk, brkcond, pbrkout );

    return lserr;
}

//-----------------------------------------------------------------------------
//
//  Function:   FindNextBreakChunk (static member, LS callback)
//
//  Synopsis:   Line Services calls pfnFindPrevBreakChunk to find a break 
//              opportunity.
//
//  Returns:    lserrNone if the function is successful.
//
//-----------------------------------------------------------------------------
LSERR WINAPI 
CGlyphDobj::FindNextBreakChunk(
    PCLOCCHNK plocchnk,     // IN:  locchnk to break
    PCPOSICHNK pposichnk,   // IN:  place to start looking for break
    BRKCOND brkcond,        // IN:  recommmendation about the break before chunk
    PBRKOUT pbrkout)        // OUT: results of breaking
{
    LSTRACE(GlyphFindNextBreakChunk);

    BOOL         fSuccessful;
    BOOL         fBreakBefore = (pposichnk->ichnk == ichnkOutside);
    long         ichnk = fBreakBefore
                         ? 0
                         : long(pposichnk->ichnk);
    CGlyphDobj * pdobj = (CGlyphDobj *)(plocchnk->plschnk[ichnk].pdobj);
    LSERR        lserr;

    WHEN_DBG( CLineServices * pLS = pdobj->GetPLS() );

    if (fBreakBefore)
    {
        //                         Second DOBJ
        //
        //                       TEXT   NOSCOPE   BEGIN    END
        //            --------+-------+--------+--------+--------
        //   First    TEXT    |  n/a  | before | before |  no
        //    DOBJ    NOSCOPE | after | after  | after  | after
        //            BEGIN   |   no  | after  |  no    |  no
        //            END     | after | after  | after  |  no
        //

        BOOL fPrevWasEnd = TRUE;

        do
        {
            pdobj = (CGlyphDobj *)(plocchnk->plschnk[ichnk].pdobj);

            // break after NOSCOPE, or END unless followed by END

            fSuccessful =    pdobj->_fNoScope
                          || (pdobj->_fBegin && fPrevWasEnd);

            if (fSuccessful)
                break;

            fPrevWasEnd = !pdobj->_fBegin;

        } while (++ichnk < long(plocchnk->clschnk) );

        if (!fSuccessful)
        {
            // break after END

            ichnk = long(plocchnk->clschnk) - 1;
            fSuccessful = !pdobj->_fBegin;
            fBreakBefore = FALSE;
        }
    }
    else
    {
        if (pdobj->_fNoScope)
        {
            // break after NOSCOPE

            fSuccessful = TRUE;
        }
        else
        {
            // break after END followed by TEXT/BEGIN/NOSCOPE

            if (ichnk < (long(plocchnk->clschnk) - 1))
            {
                if (!pdobj->_fBegin)
                {
                    CGlyphDobj * pdobjNext = (CGlyphDobj *)(plocchnk->plschnk[ichnk+1].pdobj);

                    fSuccessful = pdobjNext->_fNoScope || pdobjNext->_fBegin;
                }
                else
                {
                    fSuccessful = TRUE;
                }
            }
            else
            {
                fSuccessful = !pdobj->_fBegin;
            }
        }
    }

    pbrkout->fSuccessful = fSuccessful;
    pbrkout->brkcond = fSuccessful ? brkcondPlease : brkcondNever;
    pbrkout->posichnk.ichnk = ichnk;
    pbrkout->posichnk.dcp = fBreakBefore ? 0 : plocchnk->plschnk[ichnk].dcp;

    lserr = pdobj->QueryObjDim(&pbrkout->objdim);

    DumpBrkopt( "Next(G)", pLS->_fMinMaxPass, plocchnk, pposichnk, brkcond, pbrkout );

    return lserr;
}

//-----------------------------------------------------------------------------
//
//  Function:   FindPrevBreakChunk (static member, LS callback)
//
//  Synopsis:   Line Services calls pfnFindPrevBreakChunk to find a break 
//              opportunity.
//              It is possible for pfnFindPrevBreakChunk to be called even when 
//              the right margin occurs beyond the object.
//
//  Returns:    lserrNone if the function is successful.
//
//-----------------------------------------------------------------------------
LSERR WINAPI 
CLayoutGridDobj::FindPrevBreakChunk(
    PCLOCCHNK plocchnk,     // IN:  locchnk to break
    PCPOSICHNK pposichnk,   // IN:  place to start looking for break
    BRKCOND brkcond,        // IN:  recommmendation about the break after chunk
    PBRKOUT pbrkout)        // OUT: results of breaking
{
    LSTRACE(LayoutGridFindPrevBreakChunk);

    LSERR   lserr = lserrNone;
    BOOL    fSuccessful;
    BOOL    fBreakAfter = pposichnk->ichnk == ichnkOutside;
    long    ichnk = fBreakAfter
                    ? long(plocchnk->clschnk) - 1L
                    : long(pposichnk->ichnk);
    LSDCP   dcp   = fBreakAfter
                    ? plocchnk->plschnk[ichnk].dcp
                    : pposichnk->dcp;

    WHEN_DBG( BRKCOND brkcondIn = brkcond );

    CLayoutGridDobj * pdobjLG = (CLayoutGridDobj *)plocchnk->plschnk[ichnk].pdobj;

    if (fBreakAfter && brkcond != brkcondNever)
    {
        // Break at end of chunk
        pdobjLG->SetSublineBreakRecord(brkkindPrev, breakSublineAfter);
        lserr = pdobjLG->FillBreakData(TRUE, pbrkout->brkcond, ichnk, dcp, NULL, pbrkout);
    }
    else
    {
        LSCP    cpBreak = 0;
        BRKPOS  brkpos;
        OBJDIM  objdimSubline;

        if (pdobjLG->_fCanBreak)
        {
            long    urSublineColumnMax = pdobjLG->AdjustColumnMax(plocchnk->lsfgi.urColumnMax);

            Assert(dcp >= 1 && dcp <= plocchnk->plschnk[ichnk].dcp);

            lserr = LsFindPrevBreakSubline(pdobjLG->_plssubline, plocchnk->lsfgi.fFirstOnLine,
                                           pdobjLG->LSCPLocal2Global(dcp),
                                           urSublineColumnMax, &fSuccessful, 
                                           &cpBreak, &objdimSubline, &brkpos);
            if (lserr != lserrNone)
                goto Cleanup;
        }
        else
        {
            // Cannot break  inside object
            fSuccessful = FALSE;
            brkpos = brkposBeforeFirstDnode;
        }

        // 1. Unsuccessful or break before first DNode
        if (    !fSuccessful 
            ||  (fSuccessful && brkpos == brkposBeforeFirstDnode))
        {
            if (ichnk == 0)
            {
                //
                // First in the chunk, cannot break.
                //
                // If cp of this object is the same as cp of the first run in the line
                // don't allow breaking before this object. In this case set 'brkcondNever'.
                // This allows us to handle following situation:
                // <REV beg><REV end><LG beg><REV beg>some_te|xt<REV end><LF end>
                //
                BRKCOND brkcondNew = brkcondPlease;
                if (pdobjLG->_por->Cp() == pdobjLG->_pilsobj->_pLS->_listCurrent._pHead->Cp())
                    brkcondNew = brkcondNever;

                lserr = pdobjLG->FillBreakData(FALSE, brkcondNew, ichnk, dcp, NULL, pbrkout);
            }
            else 
            {
                // Put break at the end of previous DNode
                --ichnk;
                pdobjLG = (CLayoutGridDobj *)plocchnk->plschnk[ichnk].pdobj;
                dcp = plocchnk->plschnk[ichnk].dcp;

                pdobjLG->SetSublineBreakRecord(brkkindPrev, breakSublineAfter);
                lserr = pdobjLG->FillBreakData(TRUE, pbrkout->brkcond, ichnk, dcp, NULL, pbrkout);
            }
        }
        // 2. Successful break after last DNode
        else if (brkpos == brkposAfterLastDnode)
        {
            if (fBreakAfter && brkcond == brkcondNever) // Can not reset dcp
            {
                // Original position was "outside" and we were not allowed to break "after",
                // so we are trying another previous break if possible

                POSICHNK posichnk;
                posichnk.ichnk = ichnk;
                posichnk.dcp = dcp - 1;

                return FindPrevBreakChunk(plocchnk, &posichnk, brkcond, pbrkout);
            }
            else // Can reset dcp
            {
                // We reset dcp of the break so it happends after object but in break
                // record we remember that we should call SetBreakSubline with brkkindPrev
                dcp = plocchnk->plschnk[ichnk].dcp;

                pdobjLG->SetSublineBreakRecord(brkkindPrev, breakSublineInside);
                lserr = pdobjLG->FillBreakData(TRUE, pbrkout->brkcond, ichnk, dcp, &objdimSubline, pbrkout);
            }
        }
        // 3. Successful break inside subline
        else
        {
            dcp = pdobjLG->LSCPGlobal2Local(cpBreak);

            pdobjLG->SetSublineBreakRecord(brkkindPrev, breakSublineInside);
            lserr = pdobjLG->FillBreakData(TRUE, pbrkout->brkcond, ichnk, dcp, &objdimSubline, pbrkout);
        }
    }

    DumpBrkopt("Prev(LG)", pdobjLG->GetPLS()->_fMinMaxPass, plocchnk, pposichnk, brkcondIn, pbrkout);

Cleanup:

    return lserr;
}

//-----------------------------------------------------------------------------
//
//  Function:   FindNextBreakChunk (static member, LS callback)
//
//  Synopsis:   Line Services calls pfnFindPrevBreakChunk to find a break 
//              opportunity.
//
//  Returns:    lserrNone if the function is successful.
//
//-----------------------------------------------------------------------------
LSERR WINAPI 
CLayoutGridDobj::FindNextBreakChunk(
    PCLOCCHNK plocchnk,     // IN:  locchnk to break
    PCPOSICHNK pposichnk,   // IN:  place to start looking for break
    BRKCOND brkcond,        // IN:  recommmendation about the break before chunk
    PBRKOUT pbrkout)        // OUT: results of breaking
{
    LSTRACE(LayoutGridFindNextBreakChunk);

    LSERR   lserr = lserrNone;
    OBJDIM  objdimSubline;
    BOOL    fSuccessful;
    BOOL    fBreakAfter = pposichnk->ichnk == ichnkOutside;
    long    ichnk = fBreakAfter
                    ? 0
                    : long(pposichnk->ichnk);
    LSDCP   dcp   = fBreakAfter
                    ? 1 // 1, not 0, because dcp means "cpLim" of the truncation point
                    : pposichnk->dcp;

    WHEN_DBG( BRKCOND brkcondIn = brkcond );

    CLayoutGridDobj * pdobjLG = (CLayoutGridDobj *)plocchnk->plschnk[ichnk].pdobj;

    if (fBreakAfter && brkcond != brkcondNever)
    {
        // Break before the chunk
        ZeroMemory (&objdimSubline, sizeof(objdimSubline));
        dcp = 0;

        lserr = pdobjLG->FillBreakData(TRUE, brkcond, ichnk, dcp, &objdimSubline, pbrkout);
    }
    else
    {
        LSCP    cpBreak;
        BRKPOS  brkpos = brkposBeforeFirstDnode; // keep compiler happy

        if (pdobjLG->_fCanBreak)
        {
            long    urSublineColumnMax = pdobjLG->AdjustColumnMax(plocchnk->lsfgi.urColumnMax);

            Assert(dcp >= 1 && dcp <= plocchnk->plschnk[ichnk].dcp);

            lserr = LsFindNextBreakSubline(pdobjLG->_plssubline, plocchnk->lsfgi.fFirstOnLine,
                                           pdobjLG->_lscpStart + dcp - 1,
                                           urSublineColumnMax, &fSuccessful, 
                                           &cpBreak, &objdimSubline, &brkpos);
            if (lserr != lserrNone)
                goto Cleanup;
        }
        else
        {
            // Cannot break inside object
            fSuccessful = FALSE;
            cpBreak = 0; // keep compiler happy
        }

        // 1. Unsuccessful
        if (!fSuccessful)
        {
            if (ichnk == (long)plocchnk->clschnk - 1)
            {
                // Last in the chunk, cannot break
                lserr = pdobjLG->FillBreakData(FALSE, brkcondPlease, ichnk, dcp, NULL, pbrkout);
                
                // Break condition is not next => have to store break record
                pdobjLG->SetSublineBreakRecord(brkkindNext, breakSublineAfter);
            }
            else 
            {
                // Put break at the end of object
                dcp = plocchnk->plschnk[ichnk].dcp;

                pdobjLG->SetSublineBreakRecord(brkkindNext, breakSublineAfter);
                lserr = pdobjLG->FillBreakData(TRUE, brkcond, ichnk, dcp, NULL, pbrkout);
            }
        }
        // 2. Successful break after last DNode
        else if (brkpos == brkposAfterLastDnode)
        {
            // We reset dcp of the break so it happends after object but in break
            // record we remember that we should call SetBreakSubline
            dcp = plocchnk->plschnk[ichnk].dcp;

            pdobjLG->SetSublineBreakRecord(brkkindNext, breakSublineInside);
            lserr = pdobjLG->FillBreakData(TRUE, brkcond, ichnk, dcp, &objdimSubline, pbrkout);
        }
        // 3. Successful break inside subline
        else
        {
            dcp = cpBreak - pdobjLG->_lscpStart;

            pdobjLG->SetSublineBreakRecord(brkkindNext, breakSublineInside);
            lserr = pdobjLG->FillBreakData(TRUE, brkcond, ichnk, dcp, &objdimSubline, pbrkout);
        }
    }

    DumpBrkopt("Next(LG)", pdobjLG->GetPLS()->_fMinMaxPass, plocchnk, pposichnk, brkcondIn, pbrkout);

Cleanup:

    return lserr;
}

//-----------------------------------------------------------------------------
//
//  Function:   ForceBreakChunk (static member, LS callback)
//
//  Synopsis:   If neither of pfnFindNextBreakChunk or pfnFindPrevBreakChunk 
//              methods returns a valid break and Line Services requires 
//              a break in this chunk, Line Services calls pfnForceBreakChunk 
//              to force a break opportunity.
//
//  Returns:    lserrNone
//
//-----------------------------------------------------------------------------
LSERR WINAPI
CDobjBase::ForceBreakChunk(
    PCLOCCHNK plocchnk,     // IN:  locchnk to break
    PCPOSICHNK pposichnk,   // IN:  place to start looking for break
    PBRKOUT pbrkout)        // OUT: results of breaking
{
    LSTRACE(ForceBreakChunk);
    TraceTag((tagTraceILSBreak,
              "CDobjBase::ForceBreakChunk(ichnk=%d)",
              pposichnk->ichnk));

    ZeroMemory( pbrkout, sizeof(BRKOUT) );

    pbrkout->fSuccessful = fTrue;

    if (   plocchnk->lsfgi.fFirstOnLine
        && pposichnk->ichnk == 0
        || pposichnk->ichnk == ichnkOutside)
    {
        CDobjBase * pdobj = (CDobjBase *)plocchnk->plschnk[0].pdobj;

        pbrkout->posichnk.dcp = plocchnk->plschnk[0].dcp;
        pdobj->QueryObjDim(&pbrkout->objdim);
    }
    else
    {
        pbrkout->posichnk.ichnk = pposichnk->ichnk;
        pbrkout->posichnk.dcp = 0;
    }

    return lserrNone;
}

//-----------------------------------------------------------------------------
//
//  Function:   ForceBreakChunk(static member, LS callback)
//
//  Synopsis:   If neither of pfnFindNextBreakChunk or pfnFindPrevBreakChunk 
//              methods returns a valid break and Line Services requires 
//              a break in this chunk, Line Services calls pfnForceBreakChunk 
//              to force a break opportunity.
//
//  Returns:    lserrNone if the function is successful.
//
//-----------------------------------------------------------------------------
LSERR WINAPI 
CLayoutGridDobj::ForceBreakChunk(
    PCLOCCHNK plocchnk,     // IN:  locchnk to break
    PCPOSICHNK pposichnk,   // IN:  place to start looking for break
    PBRKOUT pbrkout)        // OUT: results of breaking
{
    LSTRACE(LayoutGridForceBreakChunk);
    TraceTag((tagTraceILSBreak,
              "CLayoutGridDobj::ForceBreakChunk(ichnk=%d)",
              pposichnk->ichnk));

    LSERR   lserr = lserrNone;
    OBJDIM  objdimSubline;
    BOOL    fBreakAfter = pposichnk->ichnk == ichnkOutside;
    long    ichnk = fBreakAfter
                    ? 0
                    : long(pposichnk->ichnk);
    LSDCP   dcp   = fBreakAfter
                    ? 1 // 1, not 0, because dcp means "cpLim" of the truncation point
                    : pposichnk->dcp;

    CLayoutGridDobj * pdobjLG = (CLayoutGridDobj *)plocchnk->plschnk[ichnk].pdobj;

    if (plocchnk->lsfgi.fFirstOnLine && (ichnk == 0))
    {
        // Object is the first on line (can not break before)

        Assert(dcp >= 1 && dcp <= plocchnk->plschnk[ichnk].dcp);

        BOOL fEmpty = TRUE;
        lserr = LssbFIsSublineEmpty(pdobjLG->_plssubline, &fEmpty);

        if (fEmpty || !pdobjLG->_fCanBreak)
        {
            // Can not ForceBreak empty subline
            ichnk = 0;
            pdobjLG = (CLayoutGridDobj *)plocchnk->plschnk[ichnk].pdobj;
            dcp = plocchnk->plschnk[ichnk].dcp;

            pdobjLG->SetSublineBreakRecord(brkkindForce, breakSublineAfter);
            lserr = pdobjLG->FillBreakData(TRUE, brkcondPlease, ichnk, dcp, NULL, pbrkout);
        }
        else
        {
            // Subline is not empty => do force break
            LSCP    cpBreak;
            BRKPOS  brkpos;
            long    urSublineColumnMax = pdobjLG->AdjustColumnMax(plocchnk->lsfgi.urColumnMax);

            lserr = LsForceBreakSubline(pdobjLG->_plssubline, plocchnk->lsfgi.fFirstOnLine,
                                        pdobjLG->_lscpStart + dcp - 1,
                                        urSublineColumnMax, 
                                        &cpBreak, &objdimSubline, &brkpos);
            if (lserr != lserrNone)
                goto Cleanup;
    
            Assert(brkpos != brkposBeforeFirstDnode);

            if (brkpos == brkposAfterLastDnode)
            {
                // We reset dcp so that closing brace stays on the same line
                dcp = plocchnk->plschnk[ichnk].dcp;

                pdobjLG->SetSublineBreakRecord(brkkindForce, breakSublineInside);
                lserr = pdobjLG->FillBreakData(TRUE, brkcondPlease, ichnk, dcp, &objdimSubline, pbrkout);
            }
            else
            {
                // ForceBreak inside subline.
                dcp = cpBreak - pdobjLG->_lscpStart;

                pdobjLG->SetSublineBreakRecord(brkkindForce, breakSublineInside);
                lserr = pdobjLG->FillBreakData(TRUE, brkcondPlease, ichnk, dcp, &objdimSubline, pbrkout);
            }
        }
    }
    else
    {
        // Can break before ichnk
        ZeroMemory (&objdimSubline, sizeof(objdimSubline));
        dcp = 0;

        lserr = pdobjLG->FillBreakData(TRUE, brkcondPlease, ichnk, dcp, &objdimSubline, pbrkout);

        // Do not need to save break record when break "before", because it will be
        // translated by manager to SetBreak (previous_dnode, ImposeAfter)
    }

Cleanup:

    return lserr;
}

//-----------------------------------------------------------------------------
//
//  Function:   SetBreak(static member, LS callback)
//
//  Synopsis:   Called by LsCreateLine to notify you to break an object because 
//              it is straddling the margin.
//
//  Returns:    lserrNone
//
//-----------------------------------------------------------------------------
LSERR WINAPI
CDobjBase::SetBreak(
    PDOBJ pdobj,                    // IN:  dobj which is broken
    BRKKIND brkkind,                // IN:  Previous/Next/Force/Imposed was chosen
    DWORD nBreakRecord,             // IN:  size of array
    BREAKREC* rgBreakRecord,        // OUT: array of break records
    DWORD* pnActualBreakRecord)     // OUT: actual number of used elements in array
{
    LSTRACE(SetBreak);

    // This function is called telling us that a new break has occured
    // in the line that we're in.  This is so we can adjust our geometry
    // for it.  We're not gonna do that.  So we ignore it.
    // This function is actually a lot like a "commit" saying that the
    // break is actually being used.  The break is discovered using
    // findnextbreak and findprevbreak functions, and truncate and stuff
    // like that.

    return lserrNone;
}


//-----------------------------------------------------------------------------
//
//  Function:   SetBreak(static member, LS callback)
//
//  Synopsis:   Called by LsCreateLine to notify you to break an object because 
//              it is straddling the margin.
//
//  Returns:    lserrNone
//
//-----------------------------------------------------------------------------
LSERR WINAPI
CNobrDobj::SetBreak(
    PDOBJ pdobj,                    // IN:  dobj which is broken
    BRKKIND brkkind,                // IN:  Previous/Next/Force/Imposed was chosen
    DWORD nBreakRecord,             // IN:  size of array
    BREAKREC* rgBreakRecord,        // OUT: array of break records
    DWORD* pnActualBreakRecord)     // OUT: actual number of used elements in array
{
    LSTRACE(NOBRSetBreak);
    LSERR lserr = lserrNone;

    CNobrDobj *pdobjNOBR = (CNobrDobj*)pdobj;

    if (pdobjNOBR->_fCanBreak)
    {
        if (nBreakRecord < 1)
        {
            lserr = lserrInsufficientBreakRecBuffer;
            goto Cleanup;
        }

        lserr = LsSetBreakSubline(  pdobjNOBR->_plssubline, brkkind, 
                                    nBreakRecord-1, &rgBreakRecord[1], 
                                    pnActualBreakRecord);
        (*pnActualBreakRecord) += 1;

        rgBreakRecord[0].idobj = CLineServices::LSOBJID_NOBR;
        rgBreakRecord[0].cpFirst = pdobjNOBR->_lscpStart;
    }
    
Cleanup:    
    return lserr;
}

//-----------------------------------------------------------------------------
//
//  Function:   SetBreak(static member, LS callback)
//
//  Synopsis:   Called by LsCreateLine to notify you to break an object because 
//              it is straddling the margin.
//
//  Returns:    lserrNone if the function is successful.
//
//-----------------------------------------------------------------------------
LSERR WINAPI
CLayoutGridDobj::SetBreak(
    PDOBJ pdobj,                    // IN:  subline context
    BRKKIND brkkind,                // IN:  Prev/Next/Force/Imposed
    DWORD nBreakRecord,             // IN:  size of array
    BREAKREC* rgBreakRecord,        // OUT: array of break records
    DWORD* pnActualBreakRecord)     // OUT: number of used elements of the array
{
    LSTRACE(LayoutGridSetBreak);

    LSERR lserr = lserrNone;
    CLayoutGridDobj * pdobjLG = (CLayoutGridDobj *)pdobj;

    if (nBreakRecord < 1) 
        return lserrInsufficientBreakRecBuffer;
    
    if (    brkkind == brkkindImposedAfter
        ||  pdobjLG->GetSublineBreakRecord(brkkind) == breakSublineAfter)
    {
        // Break is ater DNone
        lserr = LsSetBreakSubline(  pdobjLG->_plssubline, brkkindImposedAfter, 
                                    nBreakRecord-1, &rgBreakRecord[1], 
                                    pnActualBreakRecord);
        if (lserr != lserrNone) 
            goto Cleanup;

        Assert (*pnActualBreakRecord == 0);
    }
    else
    {
        OBJDIM  objdimSubline;
        LSTFLOW lstflowDontCare;
        LONG    lObjWidth;

        lserr = LsSetBreakSubline(  pdobjLG->_plssubline, brkkind, 
                                    nBreakRecord-1, &rgBreakRecord[1], 
                                    pnActualBreakRecord);
        if (lserr != lserrNone) 
            goto Cleanup;

        (*pnActualBreakRecord) += 1;

        rgBreakRecord[0].idobj = CLineServices::LSOBJID_LAYOUTGRID;
        rgBreakRecord[0].cpFirst = pdobjLG->_lscpStartObj;

        // Update subline information
        lserr = LssbGetObjDimSubline(pdobjLG->_plssubline, &lstflowDontCare, &objdimSubline);
        if (lserr != lserrNone) 
            goto Cleanup;
        lObjWidth = pdobjLG->GetPLS()->GetClosestGridMultiple(  pdobjLG->GetPLS()->GetCharGridSize(), 
                                                                objdimSubline.dur);
        pdobjLG->_uSublineOffset = (lObjWidth - objdimSubline.dur) / 2;
        pdobjLG->_uSubline = objdimSubline.dur;
    }

Cleanup:

    return lserr;
}

//-----------------------------------------------------------------------------
//
//  Function:   GetSpecialEffectsInside(static member, LS callback)
//
//  Synopsis:   Called by LsCreateLine to get the special effects flags for 
//              the object.
//
//  Returns:    lserrNone if the function is successful.
//
//-----------------------------------------------------------------------------
LSERR WINAPI
CDobjBase::GetSpecialEffectsInside(
    PDOBJ pdboj,        // IN:  dobj
    UINT* pEffectsFlag) // OUT: Special effects inside of this object
{
    LSTRACE(GetSpecialEffectsInside);

    *pEffectsFlag = 0;

    return lserrNone;
}

//-----------------------------------------------------------------------------
//
//  Function:   GetSpecialEffectsInside(static member, LS callback)
//
//  Synopsis:   Called by LsCreateLine to get the special effects flags for 
//              the object.
//
//  Returns:    lserrNone if the function is successful.
//
//-----------------------------------------------------------------------------
LSERR WINAPI
CLayoutGridDobj::GetSpecialEffectsInside(
    PDOBJ pdobj,        // IN:  dobj
    UINT* pEffectsFlag) // OUT: Special effects inside of this object
{
    LSTRACE(LayoutGridGetSpecialEffectsInside);

    return LsGetSpecialEffectsSubline(((CLayoutGridDobj *)pdobj)->_plssubline, pEffectsFlag);
}

//-----------------------------------------------------------------------------
//
//  Function:   FExpandWithPrecedingChar(static member, LS callback)
//
//  Synopsis:   
//
//  Returns:    lserrNone if the function is successful.
//
//-----------------------------------------------------------------------------
LSERR WINAPI
CDobjBase::FExpandWithPrecedingChar(
    PDOBJ pdobj,            // IN:  dobj
    PLSRUN plsrun,          // IN:  plsrun of the object
    PLSRUN plsrunText,      // IN:  plsrun of the preceding char
    WCHAR wchar,            // IN:  preceding character
    MWCLS mwcls,            // IN:  ModWidth class of preceding character
    BOOL* pfExpand)         // OUT: expand preceding character?
{
    LSTRACE(FExpandWithPrecedingChar);

    *pfExpand = TRUE;

    return lserrNone;
}

//-----------------------------------------------------------------------------
//
//  Function:   FExpandWithFollowingChar(static member, LS callback)
//
//  Synopsis:   
//
//  Returns:    lserrNone if the function is successful.
//
//-----------------------------------------------------------------------------
LSERR WINAPI
CDobjBase::FExpandWithFollowingChar(
    PDOBJ pdobj,            // IN:  dobj
    PLSRUN plsrun,          // IN:  plsrun of the object
    PLSRUN plsrunText,      // IN:  plsrun of the following char
    WCHAR wchar,            // IN:  following character
    MWCLS mwcls,            // IN:  ModWidth class of the following character
    BOOL* pfExpand)         // OUT: expand object?
{
    LSTRACE(FExpandWithFollowingChar);

    *pfExpand = TRUE;

    return lserrNone;
}

//-----------------------------------------------------------------------------
//
//  Function:   CalcPresentation (static member, LS callback)
//
//  Synopsis:   This function is called from LsDisplayLine, only if there is 
//              a custom object on the line.
//
//  Returns:    lserrNone if the function is successful.
//
//-----------------------------------------------------------------------------
LSERR WINAPI
CDobjBase::CalcPresentation(
    PDOBJ pdobj,                // IN:  dobj
    long dup,                   // IN:  dup of dobj
    LSKJUST lskjust,            // IN:  current justification mode
    BOOL fLastVisibleOnLine )   // IN:  this object is last visible object on line
{
    LSTRACE(CalcPresentation);
    return lserrNone;
}

//-----------------------------------------------------------------------------
//
//  Function:   CalcPresentation (static member, LS callback)
//
//  Synopsis:   This function is called from LsDisplayLine, only if there is 
//              a custom object on the line.
//
//  Returns:    lserrNone if the function is successful.
//
//-----------------------------------------------------------------------------
LSERR WINAPI
CNobrDobj::CalcPresentation(
    PDOBJ pdobj,                // IN:  dobj
    long dup,                   // IN:  dup of dobj
    LSKJUST lskjust,            // IN:  current justification mode
    BOOL fLastVisibleOnLine)    // IN:  this object is last visible object on line
{
    LSTRACE(NobrCalcPresentation);

    // This is taken from the Reverse object's code (in robj.c).

    CNobrDobj* pNobr= (CNobrDobj*)pdobj;

    LSERR lserr;
    BOOL fDone;

    /* Make sure that justification line has been made ready for presentation */
    lserr = LssbFDonePresSubline(pNobr->_plssubline, &fDone);

    if ((lserrNone == lserr) && !fDone)
    {
        lserr = LsMatchPresSubline(pNobr->_plssubline);
    }

    return lserr;
}

//-----------------------------------------------------------------------------
//
//  Function:   CalcPresentation (static member, LS callback)
//
//  Synopsis:   This function is called from LsDisplayLine, only if there is 
//              a custom object on the line.
//
//  Returns:    lserrNone if the function is successful.
//
//-----------------------------------------------------------------------------
LSERR WINAPI
CLayoutGridDobj::CalcPresentation(
    PDOBJ pdobj,                // IN:  dobj
    long dup,                   // IN:  dup of dobj
    LSKJUST lskjust,            // IN:  current justification mode
    BOOL fLastVisibleOnLine)    // IN:  this object is last visible object on line
{
    LSTRACE(LayoutGridCalcPresentation);

    LSERR lserr;
    BOOL fDone;
    CLayoutGridDobj * pdobjLG = (CLayoutGridDobj *)pdobj;

    // Make sure that justification line has been made ready for presentation
    lserr = LssbFDonePresSubline(pdobjLG->_plssubline, &fDone);
    if ((lserrNone == lserr) && !fDone)
    {
        lserr = LsMatchPresSubline(pdobjLG->_plssubline);
    }

    return lserr;
}

//-----------------------------------------------------------------------------
//
//  Function:   CreateQueryResult(static member)
//
//  Synopsis:   Common routine to fill in query output record for Query methods.
//
//  Returns:    lserrNone
//
//-----------------------------------------------------------------------------
LSERR 
CDobjBase::CreateQueryResult(
    PLSSUBL plssubl,        // IN:  subline of ruby
    long dupAdj,            // IN:  u offset of start of subline
    long dvpAdj,            // IN:  v offset of start of subline
    PCLSQIN plsqin,         // IN:  query input
    PLSQOUT plsqout)        // OUT: query output
{
    // I agree with my dimensions reported during formatting
    ZeroMemory(plsqout, sizeof(LSQOUT));
    plsqout->heightsPresObj = plsqin->heightsPresRun;
    plsqout->dupObj = plsqin->dupRun;
    // I am not terminal object and here is my subline for you to continue querying
    plsqout->plssubl = plssubl;
    // My subline starts with offset
    plsqout->pointUvStartSubline.u += dupAdj;
    plsqout->pointUvStartSubline.v += dvpAdj;

    // I am not terminal, so textcell should not be filled by me.
    ZeroMemory(&plsqout->lstextcell, sizeof(plsqout->lstextcell));

    return lserrNone;
}

//-----------------------------------------------------------------------------
//
//  Function:   QueryPointPcp (static member, LS callback)
//
//  Synopsis:   
//
//  Returns:    lserrNone if the function is successful.
//
//-----------------------------------------------------------------------------
LSERR WINAPI
CEmbeddedDobj::QueryPointPcp(
    PDOBJ pdobj,            // IN:  dobj to query
    PCPOINTUV pptuvQuery,   // IN:  query point (uQuery,vQuery)
    PCLSQIN plsqIn,         // IN:  query input
    PLSQOUT plsqOut)        // OUT: query output
{
    LSTRACE(EmbeddedQueryPointPcp);

    CLineServices* pLS = pdobj->GetPLS();
    CFlowLayout * pFlowLayout = pLS->_pFlowLayout;
    PLSRUN plsrun = PLSRUN(plsqIn->plsrun);
    CLayout * pLayout = plsrun->GetLayout(pFlowLayout, pLS->GetLayoutContext() );
    long xWidth;

    ZeroMemory( plsqOut, sizeof(LSQOUT) );

    pLS->_pMeasurer->GetSiteWidth( pLayout->ElementOwner()->GetFirstBranch(), pLayout, pLS->_pci, FALSE, 0, &xWidth);

    plsqOut->dupObj  = xWidth;
    plsqOut->plssubl = NULL;

    // Element conent may be NULL in empty container.
    // TODO LRECT 112511: are we doing the right thing in that case?
    CElement *pElementContent = pLayout->ElementContent();
    if (pElementContent)
    {
        plsqOut->lstextcell.cpStartCell = pElementContent->GetFirstCp();
        plsqOut->lstextcell.cpEndCell   = pElementContent->GetLastCp();
    }

    plsqOut->lstextcell.dupCell      = xWidth;
    plsqOut->lstextcell.pCellDetails = NULL;

    return lserrNone;
}


//-----------------------------------------------------------------------------
//
//  Function:   QueryPointPcp (static member, LS callback)
//
//  Synopsis:   
//
//  Returns:    lserrNone if the function is successful.
//
//-----------------------------------------------------------------------------
LSERR WINAPI
CNobrDobj::QueryPointPcp(
    PDOBJ pdobj,            // IN:  dobj to query
    PCPOINTUV pptuvQuery,   // IN:  query point (uQuery,vQuery)
    PCLSQIN plsqIn,         // IN:  query input
    PLSQOUT plsqOut)        // OUT: query output
{
    LSTRACE(NobrQueryPointPcp);

    CNobrDobj * pdobjNB = (CNobrDobj *)pdobj;
    return CreateQueryResult(pdobjNB->_plssubline, 0, 0, plsqIn, plsqOut);
}

//-----------------------------------------------------------------------------
//
//  Function:   QueryPointPcp (static member, LS callback)
//
//  Synopsis:   
//
//  Returns:    lserrNone if the function is successful.
//
//-----------------------------------------------------------------------------
LSERR WINAPI
CGlyphDobj::QueryPointPcp(
    PDOBJ pdobj,            // IN:  dobj to query
    PCPOINTUV pptuvQuery,   // IN:  query point (uQuery,vQuery)
    PCLSQIN plsqIn,         // IN:  query input
    PLSQOUT plsqOut)        // OUT: query output
{
    LSTRACE(GlyphQueryPointPcp);
    CGlyphDobj *pGlyphdobj = DYNCAST(CGlyphDobj, pdobj);

    PLSRUN plsrun = PLSRUN(plsqIn->plsrun);

    ZeroMemory( plsqOut, sizeof(LSQOUT) );

    plsqOut->dupObj  = pGlyphdobj->_RenderInfo.width;
    plsqOut->plssubl = NULL;

    plsqOut->lstextcell.cpStartCell = plsrun->_lscpBase;
    plsqOut->lstextcell.cpEndCell   = plsrun->_lscpBase + 1;

    plsqOut->lstextcell.dupCell      = pGlyphdobj->_RenderInfo.width;
    plsqOut->lstextcell.pCellDetails = NULL;

    return lserrNone;
}

//-----------------------------------------------------------------------------
//
//  Function:   QueryPointPcp (static member, LS callback)
//
//  Synopsis:   ...
//
//  Returns:    lserrNone
//
//-----------------------------------------------------------------------------
LSERR WINAPI
CLayoutGridDobj::QueryPointPcp(
    PDOBJ pdobj,            // IN:  dobj to query
    PCPOINTUV pptuvQuery,   // IN:  query point (uQuery,vQuery)
    PCLSQIN plsqIn,         // IN:  query input
    PLSQOUT plsqOut)        // OUT: query output
{
    LSTRACE(LayoutGridQueryPointPcp);

    CLayoutGridDobj * pdobjLG = (CLayoutGridDobj *)pdobj;
    return CreateQueryResult(pdobjLG->_plssubline, pdobjLG->_uSublineOffset, 0, plsqIn, plsqOut);
}

//-----------------------------------------------------------------------------
//
//  Function:   QueryCpPpoint (static member, LS callback)
//
//  Synopsis:   
//
//  Returns:    lserrNone if the function is successful.
//
//-----------------------------------------------------------------------------
// It's not documented, but I'm guessing that this routine is asking for
// a bounding box around the foreign object.
// From the quill code:
//    "Given a CP, we return the dimensions of the object.
//     Because we have a simple setup where there is only one dobj per CP,
//     it is easy to do."
LSERR WINAPI
CEmbeddedDobj::QueryCpPpoint(
    PDOBJ pdobj,            // IN:  dobj to query
    LSDCP dcp,              // IN:  dcp for the query
    PCLSQIN plsqIn,         // IN:  rectangle info of querying dnode
    PLSQOUT plsqOut)        // OUT: rectangle info of this cp
{
    LSTRACE(EmbeddedQueryCpPpoint);

    CLineServices* pLS = pdobj->GetPLS();
    CFlowLayout * pFlowLayout = pLS->_pFlowLayout;

    PLSRUN plsrun = PLSRUN(plsqIn->plsrun);  // why do I have to cast this?
    CLayout * pLayout = plsrun->GetLayout(pFlowLayout, pLS->GetLayoutContext() );
    long xWidth;
    pLS->_pMeasurer->GetSiteWidth( pLayout->ElementOwner()->GetFirstBranch(), pLayout, pLS->_pci, FALSE, 0, &xWidth);

    // Do we need to set cpStartCell and cpEndCell?

    plsqOut->plssubl= NULL;
    plsqOut->lstextcell.dupCell= xWidth;

    return lserrNone;
}

//-----------------------------------------------------------------------------
//
//  Function:   QueryCpPpoint (static member, LS callback)
//
//  Synopsis:   
//
//  Returns:    lserrNone if the function is successful.
//
//-----------------------------------------------------------------------------
LSERR WINAPI
CNobrDobj::QueryCpPpoint(
    PDOBJ pdobj,            // IN:  dobj to query
    LSDCP dcp,              // IN:  dcp for the query
    PCLSQIN plsqIn,         // IN: rectangle info of querying dnode
    PLSQOUT plsqOut)        // OUT: rectangle info of this cp
{
    LSTRACE(NobrQueryCpPpoint);

    CNobrDobj * pdobjNB = (CNobrDobj *)pdobj;
    return CreateQueryResult(pdobjNB->_plssubline, 0, 0, plsqIn, plsqOut);
}

//-----------------------------------------------------------------------------
//
//  Function:   QueryCpPpoint (static member, LS callback)
//
//  Synopsis:   
//
//  Returns:    lserrNone if the function is successful.
//
//-----------------------------------------------------------------------------
LSERR WINAPI
CGlyphDobj::QueryCpPpoint(
    PDOBJ pdobj,            // IN:  dobj to query
    LSDCP dcp,              // IN:  dcp for the query
    PCLSQIN plsqIn,         // IN:  rectangle info of querying dnode
    PLSQOUT plsqOut)        // OUT: rectangle info of this cp
{
    LSTRACE(GlyphQueryCpPpoint);
    CGlyphDobj *pGlyphdobj = DYNCAST(CGlyphDobj, pdobj);

    // Do we need to set cpStartCell and cpEndCell?
    plsqOut->plssubl= NULL;
    plsqOut->lstextcell.dupCell= pGlyphdobj->_RenderInfo.width;

    return lserrNone;
}

//-----------------------------------------------------------------------------
//
//  Function:   QueryCpPpoint (static member, LS callback)
//
//  Synopsis:   
//
//  Returns:    lserrNone if the function is successful.
//
//-----------------------------------------------------------------------------
LSERR WINAPI
CLayoutGridDobj::QueryCpPpoint(
    PDOBJ pdobj,            // IN:  dobj to query
    LSDCP dcp,              // IN:  dcp for the query
    PCLSQIN plsqIn,         // IN:  rectangle info of querying dnode
    PLSQOUT plsqOut)        // OUT: rectangle info of this cp
{
    LSTRACE(LayoutGridQueryCpPpoint);

    CLayoutGridDobj * pdobjLG = (CLayoutGridDobj *)pdobj;
    return CreateQueryResult(pdobjLG->_plssubline, pdobjLG->_uSublineOffset, 0, plsqIn, plsqOut);
}

//-----------------------------------------------------------------------------
//
//  Function:   Enum (static member, LS callback)
//
//  Synopsis:   
//
//  Returns:    lserrNone if the function is successful.
//
//-----------------------------------------------------------------------------
LSERR WINAPI
CDobjBase::Enum(
    PDOBJ pdobj,                // IN:  dobj to enumerate
    PLSRUN plsrun,              // IN:  from DNODE
    PCLSCHP plschp,             // IN:  from DNODE
    LSCP cpFirst,               // IN:  from DNODE
    LSDCP dcp,                  // IN:  from DNODE
    LSTFLOW lstflow,            // IN:  text flow
    BOOL fReverseOrder,         // IN:  enumerate in reverse order
    BOOL fGeometryNeeded,       // IN:
    const POINT * pptStart,     // IN:  starting position, iff fGeometryNeeded
    PCHEIGHTS pheightsPres,     // IN:  from DNODE, relevant iff fGeometryNeeded
    long dupRun)                // IN:  from DNODE, relevant iff fGeometryNeeded
{
    LSTRACE(Enum);

    return lserrNone;
}

//-----------------------------------------------------------------------------
//
//  Function:   Enum (static member, LS callback)
//
//  Synopsis:   
//
//  Returns:    lserrNone if the function is successful.
//
//-----------------------------------------------------------------------------
LSERR WINAPI
CEmbeddedDobj::Enum(
    PDOBJ pdobj,                // IN:  dobj to enumerate
    PLSRUN plsrun,              // IN:  from DNODE
    PCLSCHP plschp,             // IN:  from DNODE
    LSCP cpFirst,               // IN:  from DNODE
    LSDCP dcp,                  // IN:  from DNODE
    LSTFLOW lstflow,            // IN:  text flow
    BOOL fReverseOrder,         // IN:  enumerate in reverse order
    BOOL fGeometryNeeded,       // IN:
    const POINT * pptStart,     // IN:  starting position, iff fGeometryNeeded
    PCHEIGHTS pheightsPres,     // IN:  from DNODE, relevant iff fGeometryNeeded
    long dupRun)                // IN:  from DNODE, relevant iff fGeometryNeeded
{
    LSTRACE(EmbeddedEnum);

    CLineServices *pLS = pdobj->GetPLS();

    //
    // During a min-max pass, we set the width of the dobj to the minimum
    // width.  The maximum width therefore is off by the delta amount.
    //

    pLS->_dvMaxDelta += ((CEmbeddedDobj *)pdobj)->_dvMinMaxDelta;

    return lserrNone;
}

//-----------------------------------------------------------------------------
//
//  Function:   Display (static member, LS callback)
//
//  Synopsis:   Calculates the positions of the various lines for the display 
//              and then displays them
//
//  Returns:    lserrNone if the function is successful.
//
//-----------------------------------------------------------------------------
LSERR WINAPI 
CEmbeddedDobj::Display(      // this = PDOBJ pdobj,
    PDOBJ pdobj,             // IN:  dobj to display
    PCDISPIN pdispin)        // IN:  input display info
{
    LSTRACE(EmbeddedDisplay);

    PLSRUN plsrun = PLSRUN(pdispin->plsrun);
    CEmbeddedILSObj *pEmbeddedILSObj = DYNCAST(CEmbeddedILSObj, DYNCAST(CEmbeddedDobj, pdobj)->_pilsobj);
    CLSRenderer  *pRenderer = pEmbeddedILSObj->_pLS->GetRenderer();

    //
    // Ignore the return value of this, but the call updates the _xAccumulatedWidth
    // if the run needs to be skipped. This allows following runs to be displayed
    // correctly if they are relatively positioned (Bug 46346).
    // NOTE RTL (alexmog, 1/19/00): _xAccumulatedWidth is debug-only now.
    //
    pRenderer->ShouldSkipThisRun(plsrun, pdispin->dup);
    return lserrNone;
}

//-----------------------------------------------------------------------------
//
//  Function:   Display (static member, LS callback)
//
//  Synopsis:   Calculates the positions of the various lines for the display 
//              and then displays them
//
//  Returns:    lserrNone if the function is successful.
//
//-----------------------------------------------------------------------------
LSERR WINAPI 
CNobrDobj::Display(         // this = PDOBJ pdobj,
    PDOBJ pdobj,            // IN:  dobj to display
    PCDISPIN pdispin)       // IN:  input display info
{
    LSTRACE(NobrDisplay);

    CNobrDobj* pNobr= (CNobrDobj *)pdobj;

    return LsDisplaySubline(pNobr->_plssubline, // The subline to be drawn
                            &pdispin->ptPen,    // The point at which to draw the line
                            pdispin->kDispMode, // Draw in transparent mode
                            pdispin->prcClip    // The clipping rectangle
                           );
}

//-----------------------------------------------------------------------------
//
//  Function:   Display (static member, LS callback)
//
//  Synopsis:   Calculates the positions of the various lines for the display 
//              and then displays them
//
//  Returns:    lserrNone if the function is successful.
//
//-----------------------------------------------------------------------------
LSERR WINAPI
CGlyphDobj::Display(         // this = PDOBJ pdobj,
    PDOBJ pdobj,             // IN:  dobj to display
    PCDISPIN pdispin)        // IN:  input display info
{
    LSTRACE(GlyphDisplay);

    CGlyphRenderInfoType *pRenderInfo = &(DYNCAST(CGlyphDobj, pdobj)->_RenderInfo);
    extern void DrawTextSelectionForRect(XHDC hdc, CRect *prc, CRect *prcClip, BOOL fSwapColor);

    if (pRenderInfo->pImageContext)
    {
        CRect rc;
        PLSRUN plsrun = PLSRUN(pdispin->plsrun);
        CGlyphILSObj *pGlyphILSObj = DYNCAST(CGlyphILSObj, DYNCAST(CGlyphDobj, pdobj)->_pilsobj);
        CLSRenderer  *pRenderer = pGlyphILSObj->_pLS->GetRenderer();

        if (pRenderer->ShouldSkipThisRun(plsrun, pdispin->dup))
            goto Cleanup;

        pRenderer->_ptCur.x = rc.left = pdispin->ptPen.x - pRenderer->GetChunkOffsetX();
        rc.right = rc.left + pRenderInfo->width;

        rc.bottom = pdispin->ptPen.y + pRenderer->_li._yHeight - pRenderer->_li._yDescent;
        rc.top    = rc.bottom - pRenderInfo->height;

        if (!rc.FastIntersects(pRenderer->_pDI->_rcClip))
            goto Cleanup;

        // TODO TEXT 112556 (grzegorz): we want to either wrap this (and deal with bitmap rotation),
        //                        or to use a TT font for glyphs. The latter may not be an option
        //                        if we have client-customizable glyphs
        HDC rawHDC = 0; // keep compiler happy
        CSize sizeTranslate = g_Zero.size; // keep compiler happy
        if (pRenderer->_hdc.GetTranslatedDC(&rawHDC, &sizeTranslate))
        {
            CRect rcTranslated(rc);
            rcTranslated.OffsetRect(sizeTranslate);
            pRenderInfo->pImageContext->Draw(rawHDC, &rcTranslated);
        }
        else
        {
            // TODO TEXT 112556 donmarsh (9/14/99): For now, we handle translation, but not scaling or rotation.
            //                          In the future, we will rev the IImgCtx interface to accept a
            //                          matrix along with the HDC.  We will query for the enhanced interface
            //                          here.  If we are in a rotated or scaled context, we will only render
            //                          if we can call the enhanced interface.
            // AssertSz(FALSE, "Can't display glyph with complex transformation");
            // HACKHACK (grzegorz): To support glyphs in case of complex transformations
            // we need this BIG HACK. This is safe to do, because we know implementation details.
            ((CImgCtx*)pRenderInfo->pImageContext)->Draw(pRenderer->_hdc, &rc);
        }

        if (plsrun->_fSelected)
            DrawTextSelectionForRect(pRenderer->_hdc, &rc, &rc, plsrun->GetCF()->SwapSelectionColors());
    }

Cleanup:
    return lserrNone;
}

//-----------------------------------------------------------------------------
//
//  Function:   Display (static member, LS callback)
//
//  Synopsis:   Calculates the positions of the various lines for the display 
//              and then displays them
//
//  Returns:    lserrNone if the function is successful.
//
//-----------------------------------------------------------------------------
LSERR WINAPI
CLayoutGridDobj::Display(   // this = PDOBJ pdobj,
    PDOBJ pdobj,            // IN:  dobj to display
    PCDISPIN pdispin)       // IN:  input display info
{
    LSTRACE(LayoutGridDisplay);

    CLayoutGridDobj* pdobjLG= (CLayoutGridDobj *)pdobj;

    // The subline needs to be shifted in U direction
    POINT ptPenNew = pdispin->ptPen;
    ptPenNew.y += (pdispin->lstflow & fUVertical) ? pdobjLG->_uSublineOffset : 0;
    ptPenNew.x += (pdispin->lstflow & fUVertical) ? 0 : pdobjLG->_uSublineOffset;

    return LsDisplaySubline(pdobjLG->_plssubline, // The subline to be drawn
                            &ptPenNew,            // The point at which to draw the line
                            pdispin->kDispMode,   // Draw in transparent mode
                            pdispin->prcClip      // The clipping rectangle
                           );
}

//-----------------------------------------------------------------------------
//
//  Function:   DestroyDObj (static member, LS callback)
//
//-----------------------------------------------------------------------------
LSERR WINAPI
CEmbeddedDobj::DestroyDObj(
    PDOBJ pdobj)        // IN:  dobj to destroy
{
    LSTRACE(EmbeddedDestroyDObj);
    delete (CEmbeddedDobj *)pdobj;
    return lserrNone;
}

//-----------------------------------------------------------------------------
//
//  Function:   DestroyDObj (static member, LS callback)
//
//-----------------------------------------------------------------------------
LSERR WINAPI
CNobrDobj::DestroyDObj(
    PDOBJ pdobj)        // IN:  dobj to destroy
{
    LSTRACE(NobrDestroyDObj);
    LsDestroySubline(((CNobrDobj *)pdobj)->_plssubline);
    delete (CNobrDobj *)pdobj;
    return lserrNone;
}

//-----------------------------------------------------------------------------
//
//  Function:   DestroyDObj (static member, LS callback)
//
//-----------------------------------------------------------------------------
LSERR WINAPI
CGlyphDobj::DestroyDObj(
    PDOBJ pdobj)        // IN:  dobj to destroy
{
    LSTRACE(GlyphDestroyDObj);
    delete (CGlyphDobj *)pdobj;
    return lserrNone;
}

//-----------------------------------------------------------------------------
//
//  Function:   DestroyDObj (static member, LS callback)
//
//-----------------------------------------------------------------------------
LSERR WINAPI
CLayoutGridDobj::DestroyDObj(
    PDOBJ pdobj)        // IN:  dobj to destroy
{
    LSTRACE(LayoutGridDestroyDObj);
    LsDestroySubline(((CLayoutGridDobj *)pdobj)->_plssubline);
    delete (CLayoutGridDobj *)pdobj;
    return lserrNone;
}

//-----------------------------------------------------------------------------
//
//  Function:   GetBrkcondBefore (member)
//
//-----------------------------------------------------------------------------
BRKCOND
CNobrDobj::GetBrkcondBefore(COneRun * por)
{
    if (_brkcondBefore == brkcondUnknown)
    {
        if (!por->_fIsArtificiallyStartedNOBR)
        {
            CLineServices::BRKCLS brkcls, dummy;

            // find the first character of the nobr.
            while (!por->IsNormalRun())
            {
                por = por->_pNext;
            }

            if (por->_pchBase != NULL)
            {
                GetPLS()->GetBreakingClasses( por, por->_lscpBase, por->_pchBase[0], &brkcls, &dummy );
                _brkcondBefore = CLineServices::s_rgbrkcondBeforeChar[brkcls];
            }
            else
            {
                _brkcondBefore = brkcondPlease;
            }
        }
        else
        {
            _brkcondBefore = brkcondNever;
        }               
    }

    return _brkcondBefore;
}

//-----------------------------------------------------------------------------
//
//  Function:   GetBrkcondAfter (member)
//
//-----------------------------------------------------------------------------
BRKCOND
CNobrDobj::GetBrkcondAfter(COneRun * por, LONG dcp)
{
    if (_brkcondAfter == brkcondUnknown)
    {
        if (!por->_fIsArtificiallyTerminatedNOBR)
        {
            CLineServices::BRKCLS brkcls, dummy;
            COneRun * porText = por;

            // find the last character of the nobr.
            // the last cp is the [endnobr] character, which we're not interested in; hence
            // the loop stops at 1

            while (dcp > 1)
            {
                if (por->IsNormalRun())
                    porText = por;

                dcp -= por->_lscch;
                por = por->_pNext;
            };

            if (porText->_pchBase != NULL)
            {
                GetPLS()->GetBreakingClasses( porText, porText->_lscpBase+porText->_lscch-1, porText->_pchBase[porText->_lscch-1], &brkcls, &dummy );
                _brkcondAfter = CLineServices::s_rgbrkcondAfterChar[brkcls];
            }
            else
            {
                _brkcondAfter = brkcondPlease;
            }
        }
        else
        {
            _brkcondAfter = brkcondNever;
        }
    }

    return _brkcondAfter;
}

//-----------------------------------------------------------------------------
//
//  Function:   QueryObjDim (member)
//
//  Synopsis:   Calculates object's dimention.
//
//  Returns:    lserrNone if the function is successful.
//
//-----------------------------------------------------------------------------
LSERR 
CDobjBase::QueryObjDim(POBJDIM pobjdim)
{
    return LsdnQueryObjDimRange(GetPLS()->_plsc, _plsdnTop, _plsdnTop, pobjdim);
}

//-----------------------------------------------------------------------------
//
//  Function:   FillBreakData (member)
//
//  Synopsis:   
//
//  Returns:    lserrNone if the function is successful.
//
//-----------------------------------------------------------------------------
LSERR 
CLayoutGridDobj::FillBreakData( BOOL fSuccessful,       // IN
                                BRKCOND brkcond,        // IN
                                LONG ichnk,             // IN
                                LSDCP dcp,              // IN
                                POBJDIM pobjdimSubline, // IN
                                PBRKOUT pbrkout)        // OUT
{
    LSERR lserr = lserrNone;

    pbrkout->fSuccessful = fSuccessful;
    if (brkcond == brkcondPlease || brkcond == brkcondCan || brkcond == brkcondNever)
        pbrkout->brkcond = brkcond;
    else
        pbrkout->brkcond = brkcondPlease;


    if (fSuccessful)
    {
        pbrkout->posichnk.ichnk = ichnk;
        pbrkout->posichnk.dcp = dcp;
    }

    if (pobjdimSubline)
    {
        pbrkout->objdim = *pobjdimSubline;
        pbrkout->objdim.dur = GetPLS()->GetClosestGridMultiple(GetPLS()->GetCharGridSize(), pobjdimSubline->dur);
    }
    else
    {
        lserr = QueryObjDim(&pbrkout->objdim);
    }
    return lserr;
}

//-----------------------------------------------------------------------------
//
//  Function:   AdjustColumnMax (member)
//
//  Synopsis:   Reduces passed width to closest grid multiplication.
//
//  Returns:    calculated width.
//
//-----------------------------------------------------------------------------
LONG 
CLayoutGridDobj::AdjustColumnMax(LONG urColumnMax)
{
    LONG lGridSize = GetPLS()->GetCharGridSize();
    LONG urNewColumnMax = GetPLS()->GetClosestGridMultiple(lGridSize, urColumnMax);
    if (urColumnMax != urNewColumnMax)
    {
        // Adjusted width has to be not greated then 'urColumnMax', 
        // so we need to decrease it.
        urNewColumnMax -= lGridSize;
    }
    return urNewColumnMax;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\text\miscprot.h ===
#ifndef I_MISCPROT_H_
#define I_MISCPROT_H_
#pragma INCMSG("--- Beg 'miscprot.h'")

// This function is defined in treenode.cxx
styleBorderStyle ConvertFmToCSSBorderStyle(BYTE bFmBorderStyle);

// This function is defined in disp.cxx
void BoundingRectForAnArrayOfRectsWithEmptyOnes(RECT *prcBound, CDataAry<RECT> * paryRects);

void BoundingRectForAnArrayOfRects(RECT *prcBound, CDataAry<RECT> * paryRects);

#pragma INCMSG("--- End 'miscprot.h'")
#else
#pragma INCMSG("*** Dup 'miscprot.h'")
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\text\lsrender.cxx ===
/*
 *  LSRENDER.CXX -- CLSRenderer class
 *
 *  Authors:
 *      Sujal Parikh
 *      Chris Thrasher
 *      Paul  Parker
 *
 *  History:
 *      2/6/98     sujalp created
 *
 *  Copyright (c) 1997-1998 Microsoft Corporation. All rights reserved.
 */

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X__FONT_H_
#define X__FONT_H_
#include "_font.h"
#endif

#ifndef X__DISP_H_
#define X__DISP_H_
#include "_disp.h"
#endif

#ifndef X_TREEPOS_HXX_
#define X_TREEPOS_HXX_
#include "treepos.hxx"
#endif

#ifndef X_NUMCONV_HXX_
#define X_NUMCONV_HXX_
#include "numconv.hxx"
#endif

#ifndef X_DOWNLOAD_HXX_
#define X_DOWNLOAD_HXX_
#include "download.hxx"
#endif

#ifndef X_COLOR3D_HXX_
#define X_COLOR3D_HXX_
#include "color3d.hxx"
#endif

#ifndef X_INTL_HXX_
#define X_INTL_HXX_
#include "intl.hxx"
#endif

#ifndef X_HYPLNK_HXX_
#define X_HYPLNK_HXX_
#include "hyplnk.hxx"
#endif

#ifndef X_EANCHOR_HXX_
#define X_EANCHOR_HXX_
#include "eanchor.hxx"
#endif

#ifndef X_TEXTXFRM_HXX_
#define X_TEXTXFRM_HXX_
#include <textxfrm.hxx>
#endif

#ifndef X__FONTLNK_H_
#define X__FONTLNK_H_
#include "_fontlnk.h"
#endif

#ifndef X_LINESRV_HXX_
#define X_LINESRV_HXX_
#include "linesrv.hxx"
#endif

#ifndef X_LSRENDER_HXX_
#define X_LSRENDER_HXX_
#include "lsrender.hxx"
#endif

#ifndef X_FLOWLYT_HXX_
#define X_FLOWLYT_HXX_
#include <flowlyt.hxx>
#endif

#ifndef X_TXTDEFS_H_
#define X_TXTDEFS_H_
#include "txtdefs.h"
#endif

#ifndef X_ELI_HXX_
#define X_ELI_HXX_
#include <eli.hxx>
#endif

#ifndef X_DISPSURFACE_HXX_
#define X_DISPSURFACE_HXX_
#include "dispsurface.hxx"
#endif

#ifndef X_DISPNODE_HXX_
#define X_DISPNODE_HXX_
#include "dispnode.hxx"
#endif

#ifndef X_LSTXM_H_
#define X_LSTXM_H_
#include <lstxm.h>
#endif

// This is the number of characters we allocate by default on the stack
// for string buffers. Only if the number of characters in a string exceeds
// this will we need to allocate memory for string buffers.
#define STACK_ALLOCED_BUF_SIZE 256

DeclareTag(tagLSPrintDontAdjustContrastForWhiteBackground, "Print", "Print: Don't adjust contrast for white background");
MtDefine(LSReExtTextOut_aryDx_pv, Locals, "LSReExtTextOut aryDx::_pv")
MtDefine(LSReExtTextOut_aryBuf_pv, Locals, "LSReExtTextOut aryBuf::_pv")
MtDefine(LSUniscribeTextOut_aryAnalysis_pv, Locals, "LSUniscribeTextOut aryAnalysis::_pv")
MtDefine(LSUniscribeTextOutMem, Locals, "LSUniscribeTextOutMem::MemAlloc")
MtDefine(CLSRendererRenderLine_aryBuf_pv, Locals, "CLSRenderer::RenderLine aryBuf::_pv")
MtDefine(CLSRendererRenderLine_aryPassBuf_pv, Locals, "CLSRenderer::RenderLine aryPassBuf::_pv")
MtDefine(CLSRendererTextOut_aryDx_pv, Locals, "CLSRenderer::TextOut aryDx::_pv")
MtDefine(CLSRenderer_aryHighlight, Locals  , "CClsRender::_aryHighlight")

MtDefine(RenderLines, Metrics, "Render/Blast Lines")
MtDefine(BlastedLines, RenderLines, "Lines blasted to the screen")
MtDefine(LSRenderLines, RenderLines, "Lines rendered using LS to the screen");

#ifndef MACPORT
/*
 *  LSReExtTextOutW(CCcs *pccs, hdc, x, y, fuOptions, lprc, lpString, cbCount,lpDx)
 *
 *  @mfunc
 *      Patch around the Win95 FE bug.
 *
 *  @rdesc
 *      Returns whatever ExtTextOut returns
 */

BOOL LSReExtTextOutW(
    CCcs * pccs,                //@parm the font
    XHDC hdc,                   //@parm handle to device context
    int xp,                     //@parm x-coordinate of reference point
    int yp,                     //@parm y-coordinate of reference point
    UINT fuOptions,             //@parm text-output options
    CONST RECT *lprect,         //@parm optional clipping and/or opaquing rectangle
    const WCHAR *lpwchString,   //@parm points to string
    UINT cchCount,              //@parm number of characters in string
    CONST INT *lpDx)            //@parm Ptr to array of intercharacter spacing values
{
    // NB (cthrash) Ported from RichEdit rel0144 11/22/96
    // This is a protion of Word code adapted for our needs.
    // This is a work around for Win95FE bugs that cause GPFs in GDI if multiple
    // characters above Unicode 0x7F are passed to ExtTextOutW.

    int           cch;
    const WCHAR * lpwchT = lpwchString;
    const WCHAR * lpwchStart = lpwchT;
    const WCHAR * lpwchEnd = lpwchString + cchCount;
    const int *   lpdxpCur;
    BOOL          fRet = 0;
    LONG          lWidth=0;
    UINT          uiTA = GetTextAlign(hdc);
    
    if (uiTA & TA_UPDATECP)
    {
        POINT pt;

        SetTextAlign(hdc, uiTA & ~TA_UPDATECP);

        GetCurrentPositionEx(hdc, &pt);

        xp = pt.x;
        yp = pt.y;
    }

    while (lpwchT < lpwchEnd)
    {
        // characters less than 0x007F do not need special treatment
        // we output then in contiguous runs
        if (*lpwchT > 0x007F)
        {
            if ((cch = lpwchT - lpwchStart) > 0)
            {
                lpdxpCur = lpDx ? lpDx + (lpwchStart - lpwchString) : NULL;

                 // Output the run of chars less than 0x7F
                fRet = ::ExtTextOutW( hdc, xp, yp, fuOptions, lprect,
                                      lpwchStart, cch, (int *) lpdxpCur);
                if (!fRet)
                    return fRet;

                fuOptions &= ~ETO_OPAQUE; // Don't erase mutliple times!!!

                // Advance
                if (lpdxpCur)
                {
                    while (cch--)
                    {
                        xp += *lpdxpCur++;
                    }
                }
                else
                {
                    while (cch)
                    {
                        pccs->Include(lpwchStart[--cch], lWidth);
                        xp += lWidth;
                    }
                }

                lpwchStart = lpwchT;
            }

            // Output chars above 0x7F one at a time to prevent Win95 FE GPF
            lpdxpCur = lpDx ? lpDx + (lpwchStart - lpwchString) : NULL;

            fRet = ::ExtTextOutW(hdc, xp, yp, fuOptions, lprect, 
                                 lpwchStart, 1, (int *)lpdxpCur);

            if (!fRet)
                return fRet;

            fuOptions &= ~ETO_OPAQUE; // Don't erase mutliple times!!!

            // Advance
            if (lpdxpCur)
            {
                xp += *lpdxpCur;
            }
            else
            {
                pccs->Include( *lpwchStart, lWidth );

                xp += lWidth;
            }

            lpwchStart++;
        }

        lpwchT++;
    }

    // output the final run; also, if we were called with cchCount == 0,
    // make a call here to erase the rectangle
    if ((cch = lpwchT - lpwchStart) > 0 || !cchCount)
    {
        fRet = ::ExtTextOutW( hdc, xp, yp, fuOptions, lprect, lpwchStart, cch,
                              (int *) (lpDx ? lpDx + (lpwchStart - lpwchString) : NULL) );
    }

    if (uiTA & TA_UPDATECP)
    {
        SetTextAlign(hdc, uiTA);

        // Update the xp for the final run.

        AssertSz(!lpDx, "In blast mode -- lpDx should be null.");

        while (cch)
        {
            pccs->Include( lpwchStart[--cch], lWidth );

            xp += lWidth;
        }                
            
        MoveToEx(hdc, xp, yp, NULL);
    }

    return fRet;

}

#endif // MACPORT

//-----------------------------------------------------------------------------
//
//  Function:   WideCharToMultiByteForSymbol
//
//  Purpose:    This function is a hacked-up version of WC2MB that we use to
//              convert when rendering in the symbol font.  Since symbol fonts
//              exist in a codepage-free world, we need to always convert to
//              multibyte to get the desired result.  The only problem comes
//              when you've got content such as the following:
//
//                  <font face="Wingdings">&#171;</font>
//
//              This, incidentally, is the recommended way of creating a little
//              star in your document.  We wouldn't need this hacky converter
//              if the user entered the byte value for 171 instead of the named
//              entity -- this however is problematic for DBCS locales when
//              the byte value may be a leadbyte (and thus would absorb the
//              subsequent byte.)
//
//              Anyway, the hack here is to 'convert' all Unicode codepoints
//              less than 256 by stripping the MSB, and converting normally
//              the rest.
//
//              Note the other unfortunate hack is that we need to convert
//              the offset array
//
//-----------------------------------------------------------------------------

int WideCharToMultiByteForSymbolQuick(UINT,DWORD,LPCWSTR,int,LPSTR,int);
int WideCharToMultiByteForSymbolSlow(UINT,DWORD,LPCWSTR,int,LPSTR,int,const int*,int*,XHDC,const CBaseCcs*);

int
WideCharToMultiByteForSymbol(
    UINT        uiCodePage,
    DWORD       dwFlags,
    LPCWSTR     pch,
    int         cch,
    LPSTR       pb,
    int         cb,
    const int * lpDxSrc,
    int *       lpDxDst,
    XHDC        hdc,
    const CBaseCcs * pBaseCcs )
{
    AssertSz( cch != -1, "Don't pass -1 here.");
    int iRet;

    if (lpDxSrc)
    {
        iRet = WideCharToMultiByteForSymbolSlow( uiCodePage, dwFlags, pch, cch, pb, cb, lpDxSrc, lpDxDst, hdc, pBaseCcs );
    }
    else
    {
        iRet = WideCharToMultiByteForSymbolQuick( uiCodePage, dwFlags, pch, cch, pb, cb );
    }

    return iRet;
}

int
WideCharToMultiByteForSymbolQuick(
    UINT        uiCodePage,
    DWORD       dwFlags,
    LPCWSTR     pch,
    int         cch,
    LPSTR       pb,
    int         cb )
{
    //
    // This is the quick pass, where we don't need to readjust the width array (lpDx)
    //

    const WCHAR * pchStop = pch + cch;
    const WCHAR * pchStart = NULL;
    const char *  pbStart = pb;
    const char *  pbStop = pb + cb;

    for (;pch < pchStop; pch++)
    {
        TCHAR ch = *pch;

#ifndef UNIX
        if (ch > 255)
        {
            const BYTE b = InWindows1252ButNotInLatin1(ch);
            
            if (b)
            {
                ch = b;
            }
        }
#endif

        if (ch > 255)
        {
            //
            // Accumulate the non Latin-1 characters -- remember the start
            //
            
            pchStart = pchStart ? pchStart : pch;
        }
        else
        {
            if (pchStart)
            {
                //
                // We have accumulated some non-Latin1 chars -- convert these first
                //

                const int cb = WideCharToMultiByte( uiCodePage, dwFlags,
                                                    pchStart, pch - pchStart,
                                                    pb, pbStop - pb,
                                                    NULL, NULL );

                pb += cb;

                pchStart = NULL;
            }

            if (pb < pbStop)
            {
                //
                // Tack on the Latin1 character
                //
                
                *pb++ = ch;
            }
            else
            {
                break;
            }
        }
    }

    if (pchStart)
    {
        //
        // Take care of non-Latin1 chars at the end of the string
        //

        const int cb = WideCharToMultiByte( uiCodePage, dwFlags,
                                            pchStart, pch - pchStart,
                                            pb, pbStop - pb,
                                            NULL, NULL );

        pb += cb;
    }

    return pb - pbStart;
}

int
WideCharToMultiByteForSymbolSlow(
    UINT        uiCodePage,
    DWORD       dwFlags,
    LPCWSTR     pch,
    int         cch,
    LPSTR       pb,
    int         cb,
    const int * lpDxSrc,
    int *       lpDxDst,
    XHDC        hdc,
    const CBaseCcs * pBaseCcs )
{
    //
    // This is the slow pass, where we need to readjust the width array (lpDx)
    // Note lpDxDst is assumed to have (at least) cb bytes in it.
    //

    const WCHAR * pchStop = pch + cch;
    const char *  pbStart = pb;
    const char *  pbStop = pb + cb;

    while (pch < pchStop && pb < pbStop)
    {
        const TCHAR ch = *pch++;

        if (ch < 256)
        {
            *pb++ = char(ch);
            *lpDxDst++ = *lpDxSrc++;
        }
        else
        {
#ifndef UNIX
            const unsigned char chSB = InWindows1252ButNotInLatin1(ch);
            
            if (chSB)
            {
                *pb++ = chSB;
                *lpDxDst++ = *lpDxSrc++;
            }
            else
#endif
            {
                const int cb = WideCharToMultiByte( uiCodePage, dwFlags, &ch, 1, 
                                                    pb, pbStop - pb, NULL, NULL );
                INT xWidthSBC;
                int c = cb;
                while (c)
                {
                    unsigned char uch = pb[c-1];
                    if (GetCharWidthA( hdc, uch, uch, &xWidthSBC ))
                        lpDxDst[c-1] = xWidthSBC;
                    else
                        lpDxDst[c-1] = pBaseCcs->_xAveCharWidth;
                    --c;
                }

                ++lpDxSrc;
                lpDxDst += cb;
                pb += cb;
            }
        }
    }

    return pb - pbStart;
}


/*
 *  LSReExtTextOut
 *
 *  @mfunc
 *      Dispatchs to ExtTextOut that is appropriate for the O/S.
 *
 *  @rdesc
 *      Returns whatever ExtTextOut returns
 */

#define MAX_CHUNK 4000L

DWORD
GetMaxRenderLine() {
 
    static DWORD dwMaxRenderLine = 0;
    HKEY hkInetSettings;
    DWORD dwVal;
    DWORD dwSize;
    DWORD dwType;
    long lResult;

    if(!dwMaxRenderLine) {
        dwMaxRenderLine = MAX_CHUNK;
        if (g_dwPlatformID == VER_PLATFORM_WIN32_NT) 
        {
            lResult = RegOpenKeyEx(HKEY_LOCAL_MACHINE, _T("Software\\Microsoft\\Internet Explorer\\Main"), 0, KEY_QUERY_VALUE, &hkInetSettings);
            if (ERROR_SUCCESS == lResult)  
            {
                dwSize = sizeof(dwVal);
                lResult = RegQueryValueEx(hkInetSettings, _T("MaxRenderLine"), 0, &dwType, (LPBYTE) &dwVal, &dwSize);
                if (ERROR_SUCCESS == lResult && dwSize == sizeof(dwVal) && 
                        (dwType == REG_DWORD || dwType == REG_BINARY)) 
                    dwMaxRenderLine = dwVal;
                RegCloseKey(hkInetSettings);
            } 
        }
    }

    return dwMaxRenderLine;
}

BOOL
LSReExtTextOut(
    CCcs * pccs,                  //@parm the font
    XHDC hdc,                     //@parm handle to device context
    int x,                        //@parm x-coordinate of reference point
    int y,                        //@parm y-coordinate of reference point
    UINT fuOptions,               //@parm text-output options
    CONST RECT *lprc,             //@parm optional clipping and/or opaquing rectangle
    const WCHAR *pchString,       //@parm points to string
    long cchString,               //@parm number of characters in string
    CONST INT *lpDx,              //@parm pointer to array of intercharacter spacing values
    CONVERTMODE cm)               //@parm CM_NONE, CM_SYMBOL, CM_MULTIBYTE, CM_FEONNONFE
{
    BOOL fRetVal=TRUE;
    UINT uiCodePage = pccs->GetBaseCcs()->_sCodePage;
                      

    // Win95 has trouble drawing long strings, even drawing large coordinates.
    // So, we just stop after a few thousand characters.

    cchString = min ((long) GetMaxRenderLine(), cchString);

    //
    // For EUDC-chars (which must be in their own text run, and thus it's own
    // LsReExtTextOut call) cannot be rendered in Win95 through ExtTextOutW; it
    // must be rendered using ExtTextOutA.  For Win98, NT4, and W2K, ExtTextOutW
    // will work just fine.
    //
    
    if (   CM_FEONNONFE == cm
        && cchString
        && IsEUDCChar(pchString[0]))
    {
        // NB (cthrash) We've seen emprically that Win98-PRC is not up to
        // the task, so continue to call ETOA for this platform.

        cm = (   g_dwPlatformVersion < 0x40000
              || (   g_dwPlatformVersion == 0x4000a // win98
                  && g_cpDefault == CP_CHN_GB))     // prc
             ? CM_MULTIBYTE
             : CM_NONE;
    }

    if (CM_SYMBOL == cm || CM_MULTIBYTE == cm)
    {
        // If we are doing LOWBYTE or MULTIBYTE conversion,
        // unless we have a FE font on a non-FE machine.

        CStackDataAry < char, STACK_ALLOCED_BUF_SIZE > aryBuf(Mt(LSReExtTextOut_aryBuf_pv));
        CStackDataAry < int, STACK_ALLOCED_BUF_SIZE> aryDx(Mt(LSReExtTextOut_aryDx_pv));

        char *pbString;
        int * lpDxT = NULL;
        int cbString = 0;
        BOOL fDoDxMap = lpDx && cchString > 1;

        // Double the buffer size, unless in LOWBYTE mode
        int cbBuffer = cchString * 2;

        // Get a buffer as big as it needs to be.
        if (   aryBuf.Grow(cbBuffer) != S_OK
            || (   lpDx
                && aryDx.Grow(cbBuffer) != S_OK
               )
           )
        {
            cbBuffer = STACK_ALLOCED_BUF_SIZE;
        }
        pbString = aryBuf;

        if (lpDx)
        {
            lpDxT = aryDx;
        }

        //
        // NOTE (cthrash) We should really clean this code up a bit --
        // The only difference between CM_MULTIBYTE and CM_SYMBOL as it
        // currently exists is the handling of the U+0080-U+009F range.
        //
        
        if (cm == CM_MULTIBYTE)
        {
            // Convert string

            cbString = WideCharToMultiByte( uiCodePage, 0, pchString, cchString,
                                            pbString, cbBuffer, NULL, NULL );

            if (lpDx && !fDoDxMap)
            {
                lpDxT[0] = *lpDx;
                lpDxT[1] = 0;
            }
        }
        else
        {
            // Note here that we do the lpDx conversion as we go, unlike the
            // CM_MULTIBYTE scenario.

            cbString = WideCharToMultiByteForSymbol( uiCodePage, 0, pchString, cchString,
                                                     pbString, cbBuffer, lpDx, lpDxT, 
                                                     hdc, pccs->GetBaseCcs() );

            // If we were successful, we don't need to map the lpDx
            
            fDoDxMap &= cbString == 0;
        }

        if (!cbString)
        {
            // The conversion failed for one reason or another.  We should
            // make every effort to use WCTMB before we fall back to
            // taking the low-byte of every wchar (below), otherwise we
            // risk dropping the high-bytes and displaying garbage.

            // Use the cpg from the font, since the uiCodePage passed is
            //  the requested codepage and the font-mapper may very well
            //  have mapped to a different one.

            TEXTMETRIC tm;
            UINT uAltCodePage = GetLatinCodepage();

            if (GetTextMetrics(hdc, &tm) && tm.tmCharSet != DEFAULT_CHARSET)
            {
                UINT uFontCodePage =
                      DefaultCodePageFromCharSet( tm.tmCharSet,
                                                  g_cpDefault, 0 );

                if (uFontCodePage != uiCodePage)
                {
                    uAltCodePage = uFontCodePage;
                }
            }

            if (uAltCodePage != uiCodePage)
            {
                cbString = WideCharToMultiByte( uAltCodePage, 0, pchString, cchString,
                                              pbString, cbBuffer, NULL, NULL);
                uiCodePage = uAltCodePage;
            }
        }

        if (!cbString)                         // Convert WCHARs to CHARs
        {
            int cbCopy;

            // FUTURE:  We come here for both SYMBOL_CHARSET fonts and for
            // DBCS bytes stuffed into wchar's (one byte per wchar) when
            // the requested code page is not installed on the machine and
            // the MBTWC fails. Instead, we could have another conversion
            // mode that collects each DBCS char as a single wchar and then
            // remaps to a DBCS string for ExtTextOutA. This would allow us
            // to display text if the system has the right font even tho it
            // doesn't have the right cpg.

            // If we are converting this WCHAR buffer in this manner
            // (by taking only the low-byte's of the WCHAR's), it is
            // because:
            //  1) cm == CM_SYMBOL
            //  2) WCTMB above failed for some reason or another.  It may
            //      be the case that the string is entirely ASCII in which
            //      case dropping the high-bytes is not a big deal (otherwise
            //      we assert).

            cbCopy = cbString = cchString;

            while(cbCopy--)
            {
                AssertSz(pchString[cbCopy] <= 0xFF, "LSReExtTextOut():  Found "
                            "a WCHAR with non-zero high-byte when using "
                            "CM_SYMBOL conversion mode.");
                pbString[cbCopy] = pchString[cbCopy];
            }

            fDoDxMap = FALSE;
            lpDxT = (int *)lpDx;
        }

        // This is really ugly -- our lpDx array is for wide chars, and we
        // may need to convert it for multibyte chars.  Do this only when
        // necessary.

        if (fDoDxMap)
        {
            Assert( cbString <= cbBuffer );

            const int * lpDxSrc = lpDx;
            int * lpDxDst = lpDxT;
            int cb = cbString;
            const WCHAR * pch = pchString;

            memset(lpDxT, 0, cbString * sizeof(int));

            while (cb)
            {
                int cbChar = WideCharToMultiByte( uiCodePage, 0,
                                                  pch, 1, NULL, NULL,
                                                  NULL, NULL );

                Assert( cbChar && cb >= cbChar );

                *lpDxDst = *lpDxSrc++;
                lpDxDst += cbChar;
                cb -= cbChar;
                pch++;
            }
        }

        fRetVal = ExtTextOutA( hdc, x, y, fuOptions, lprc, pbString, cbString, lpDxT );
    }
    else
#ifndef MACPORT
    // do we need the Win95 FE bug workaround??
    if (CM_FEONNONFE == cm)
    {
        fRetVal = LSReExtTextOutW( pccs, hdc, x, y, fuOptions, lprc,
                                   pchString, cchString, lpDx);
    }
    else
#endif
        fRetVal = ::ExtTextOutW(hdc, x, y, fuOptions, lprc,
                                pchString, cchString, (int *)lpDx);

    return (fRetVal);
}

/*
 *  LSUniscribeTextOut
 *
 *  @mfunc
 *      Shapes, places and prints complex text through Uniscribe (USP10.DLL);
 *
 *  @rdesc
 *      Returns indication that we successfully printed through Uniscribe
 */
HRESULT LSUniscribeTextOut(
    const XHDC& hdc,
    int iX,
    int iY,
    UINT uOptions,
    CONST RECT *prc,
    LPCTSTR pString,
    UINT cch,
    int *piDx)
{
    HRESULT hr = S_OK;
    SCRIPT_STRING_ANALYSIS ssa;
    DWORD dwFlags;
    int   xWidth = 0;
    const SIZE *pSize = NULL;
    const int *pich = NULL;
    const SCRIPT_LOGATTR* pSLA = NULL;

    if(piDx)
        *piDx = 0;

    Assert(!g_fExtTextOutGlyphCrash);

    dwFlags = SSA_GLYPHS | SSA_FALLBACK | SSA_BREAK;
    if(uOptions & ETO_RTLREADING)
        dwFlags |= SSA_RTL;

    // BUG 29234 - prc is sometimes passed in NULL
    if (prc != NULL)
    {
        xWidth = prc->right - prc->left;
        dwFlags |= SSA_CLIP;
    }

    while(cch)
    {
        // Using a 0 as the fourth parameter will default the max glyph count at cch * 1.5
        hr = ScriptStringAnalyse(hdc, pString, cch, 0, -1, dwFlags, xWidth,
                                 NULL, NULL, NULL, NULL, NULL, &ssa);

        if (FAILED(hr))
        {
            goto done;
        }

        pich = ScriptString_pcOutChars(ssa);
        if (!pich)
        {
            hr = E_FAIL;
            goto done;
        }

        if((UINT)*pich < cch)
        {
            pSLA = ScriptString_pLogAttr(ssa);

            int i = *pich;

            if(pSLA)
            {
                pSLA += *pich;
                while(i > 0 && !(pSLA->fSoftBreak) && !(pSLA->fWhiteSpace))
                {
                    pSLA--;
                    i--;
                }

                if(i != *pich)
                {
                    ScriptStringFree(&ssa);

                    // Using a 0 as the fourth parameter will default the max glyph count at cch * 1.5
                    hr = ScriptStringAnalyse(hdc, pString, i, 0, -1, dwFlags, xWidth,
                                             NULL, NULL, NULL, NULL, NULL, &ssa);

                    if (FAILED(hr))
                    {
                        goto done;
                    }

                    pich = ScriptString_pcOutChars(ssa);
                    Assert(*pich == i);
                }
            }
        }

        pSize = ScriptString_pSize(ssa);
        
        if(piDx)
        {
            if(pSize->cx > *piDx)
                *piDx = pSize->cx;
        }

        // NOTE: instead of calling ScriptStringOut directly, we call a method on XHDC
        // in order to implement the coordinate transformations that are necessary.
        // This is normally done by GDI wrappers for other rendering methods, but
        // ScriptStringOut has to be treated specially, because it doesn't have an
        // HDC parameter (it's been hidden in ssa by ScriptStringAnalyse).
        hr = hdc.ScriptStringOut(ssa, iX, iY, uOptions, prc, 0, 0, FALSE);

        iY += pSize->cy;

        if(*pich > 0 && (UINT)*pich < cch)
        {
            cch -= *pich;
            pString += *pich;
        }
        else
            cch = 0;

        ScriptStringFree(&ssa);
    }

done:
    return hr;

}


/*
 *  LSIsEnhancedMetafileDC( hDC )
 *
 *  @mfunc
 *      Check if hDC is a Enhanced Metafile DC.
 *      There is work around the Win95 FE ::GetObjectType() bug.
 *
 *  @rdesc
 *      Returns TRUE for EMF DC.
 */

BOOL LSIsEnhancedMetafileDC (
    const XHDC& hDC)            //@parm handle to device context
{
    BOOL fEMFDC = FALSE;

#if !defined(MACPORT) && !defined(WINCE)
    DWORD dwObjectType;

    dwObjectType = ::GetObjectType( hDC );

    if ( OBJ_ENHMETADC == dwObjectType || OBJ_ENHMETAFILE == dwObjectType )
    {
        fEMFDC = TRUE;
    }
    else if ( OBJ_DC == dwObjectType )
    {
        // HACK Alert,  Enhanced Metafile DC does not support any Escape function
        // and shoudl return 0.
        int iEscapeFuction = QUERYESCSUPPORT;
        fEMFDC = Escape( hDC, QUERYESCSUPPORT, sizeof(int),
                         (LPCSTR)&iEscapeFuction, NULL) == 0;
    }
#endif

    return fEMFDC;
}


//-----------------------------------------------------------------------------
//
//  Function:   CLSRenderer::CLSRenderer
//
//  Synopsis:   Constructor for the LSRenderer
//
//-----------------------------------------------------------------------------
CLSRenderer::CLSRenderer (const CDisplay * const pdp, CFormDrawInfo * pDI) :
    CLSMeasurer (pdp, pDI, FALSE),
    _aryHighlight( Mt( CLSRenderer_aryHighlight) )
{
    Assert(pdp);
    Init(pDI);
    _hdc       = pDI->GetDC();

    // TODO TEXT 112556: we shouldn't do this! Drawing DC is for rendering.
    //                 All measuring shoudl be done on a separate DC.
    //                 When printing, this is particularly important.
    //                 Unfortunately, nothing works if this line is removed.
    //                 We'll resort to explicitly using screen DC when we get
    //                 font metrics for IE5.5, and change this in the next release.
    // FUTURE (alexmog): we may actually need the physical DC if we start using
    //                   WYSIWYG support in LS.
    _pci->_hdc = _hdc;
    _hfontOrig = (HFONT)::GetCurrentObject(_hdc, OBJ_FONT);

    _pccsEllipsis = NULL;
    CTreeNode * pFormattingNode = _pdp->GetFlowLayout()->GetFirstBranch();
    _fHasEllipsis = pFormattingNode->HasEllipsis();
    if (_fHasEllipsis)
    {
        const CCharFormat * pCF = pFormattingNode->GetCharFormat();

        _pccsEllipsis = new CCcs;
        if (   _pccsEllipsis
            && !fc().GetCcs(_pccsEllipsis, _hdc, pDI, pCF))
        {
            delete _pccsEllipsis;
            _pccsEllipsis = NULL;
        }
        _fHasEllipsis = (_pccsEllipsis != NULL);
    }
}

//+====================================================================================
//
// Method: Destructor for CLSRenderer
//
// Synopsis: Remove any Highlight Segments which may have been allocated.
//
//------------------------------------------------------------------------------------


CLSRenderer::~CLSRenderer()
{
    // restore original font, including CBaseCcs pointer in CDispSurface
    _hdc.SetBaseCcsPtr(NULL);
    SelectFontEx(_hdc, _hfontOrig);

    if (_pccsEllipsis)
    {
        _pccsEllipsis->Release();
        delete _pccsEllipsis;
    }
}

/*
 *  CLSRenderer::Init
 *
 *  @mfunc
 *      initialize everything to zero
 */
void CLSRenderer::Init(CFormDrawInfo * pDI)
{
    Assert(pDI);

    _pDI        = pDI;
    _rcView     =
    _rcRender   =
    _rcClip     = g_Zero.rc;
    _dwFlags()  = 0;
    _ptCur.x    = 0;
    _ptCur.y    = 0;
    _fRenderSelection = TRUE;

}

/*
 *  CLSRenderer::StartRender (&rcView, &rcRender, yHeightBitmap)
 *
 *  @mfunc
 *      Prepare this renderer for rendering operations
 *
 *  @rdesc
 *      FALSE if nothing to render, TRUE otherwise
 */
BOOL CLSRenderer::StartRender (
    const RECT &rcView,         //@parm View rectangle
    const RECT &rcRender,       //@parm Rectangle to render
    const INT  iliViewStart,
    const LONG cpViewStart)
{
    CRenderInfo     ri;
    CFlowLayout*    pFLayout = _pdp->GetFlowLayout();
    CMarkup*        pMarkup = _pdp->GetMarkup();
    
    if (_hdc.IsEmpty())
    {
        _hdc = _pDI->GetDC();
    }

    AssertSz(!_hdc.IsEmpty(), "CLSRenderer::StartRender() - No rendering DC");

    // Set view and rendering rects
    _rcView = rcView;
    _rcRender = rcRender;

    // Set background mode
    SetBkMode(_hdc, TRANSPARENT);

    _lastTextOutBy = DB_NONE;

    // If this is not the main display or it is a metafile
    // we want to ignore the logic to render selections
    if (pMarkup->IsPrintMedia() || _pDI->IsMetafile())
    {
        _fRenderSelection = FALSE;
    }

    // For hack around ExtTextOutW Win95FE Font and EMF problems.
    _fEnhancedMetafileDC = ((VER_PLATFORM_WIN32_WINDOWS == g_dwPlatformID) &&
                            LSIsEnhancedMetafileDC(_hdc));

    ri._pdp = _pdp;
    ri._pDI = _pDI;
    ri._iliStart = iliViewStart;
    ri._cpStart = cpViewStart;
    pMarkup->GetSelectionChunksForLayout( pFLayout, &ri, &_aryHighlight, & _cpSelMin, & _cpSelMax );

    return TRUE;
}

/*
 *  CLSRenderer::NewLine (&li)
 *
 *  @mfunc
 *      Init this CLSRenderer for rendering the specified line
 */
void CLSRenderer::NewLine (const CLineFull &li)
{
    _li = li;

    Assert(GetCp() + _li._cch <= GetLastCp());

    //  for LTR display
    //
    //  |--------------------------------Container width---------------------|
    //  |------------display view width------------------|                   |
    //  |  X-------------- LTR wraping line ---------->  |                   |
    //  |  X-------------- LTR overflowing line ---------|-------------->    |
    //  |  <-------------- RTL wrapping line ---------X  |                   |
    //  |  <-------------- RTL overflowing line ---------|-----------------X |
    //
    if(!_li._fRTLLn)
    {
        _ptCur.x = _rcView.left + _li._xLeftMargin + _li._xLeft;
    }
    else
    {
        _ptCur.x = _rcView.left + _li._xLeftMargin + _li._xLeft + _li._xWidth + _li._xLineOverhang - 1;
    }
        
    //  for RTL display, all content is offset to the right by the difference 
    //  between original view width and container width (that's where logical zero is). 
    //  Overflow lines have negative offsets, calculated at layout time.
    //
    //  |--------------------------------Container width---------------------|
    //  |                   |------------display view width------------------|
    //  |                   |  <-------------- RTL wrapping line ---------X  |
    //  |  <-------------- RTL overflowing line --------------------------X  |
    //  |                   |  X-------------- LTR wraping line ---------->  |
    //  |    X--------------|----------------- LTR overflowing line ------>  |
    //
    if (_pdp->IsRTLDisplay())
    {
        // add content origin, which is non-zero for RTL lines with overflow.
        // TODO RTL 112514: if _rcView.left is ever set to something meaningful for reasons other
        //                  than RTL overflow, this code won't work. 
        _ptCur.x -= _rcView.left;   
    }
    else
    {
        // TODO RTL 112514: need to understand where in LTR _rcView.left is non-zero
        Assert(_rcView.left == 0);
    }

    if(_li._fRelative) // if the current line is relative
    {
        _ptCur.x += _xRelOffset;
    }

    _cchWhiteAtBeginningOfLine = 0;
#if DBG==1
    _xAccumulatedWidth = 0;
    _fBiDiLine = FALSE;
#endif

    // Ellipsis support
    _xRunWidthSoFar = 0;
    _xEllipsisPos = -1;
    _fEllipsisPosSet = FALSE;
}

//-----------------------------------------------------------------------------
//
//  Function:   RenderLine
//
//  Synopsis:   Renders one line of text
//
//  Params:     [li]: The line to be drawn
//
//  Returns:    void
//
//-----------------------------------------------------------------------------
VOID CLSRenderer::RenderLine (CLineFull &li, long xRelOffset)
{
    Assert(_pDI);
    Assert(_pDI->_pSurface);
    
    CMarginInfo marginInfo;
    POINT ptLS;
    LONG cpStartContainerLine;
    LONG xWidthContainerLine;
    LONG cchTotal;
    CTreePos *ptpNext = NULL;
    CTreePos *ptp;
    HRESULT hr;
    CLineCore *pliContainer;
    BOOL fIntersectSelection = FALSE;

    _xRelOffset = xRelOffset;

    NewLine(li);

    if (_li._fHidden)
        goto Cleanup;

    if(_li.IsFrame())
        goto Cleanup;

    if (_li._cch == 0)
        goto Cleanup;

    //
    // We need to render all the characters in the line
    //
    _cpStartRender = GetCp();
    _cpStopRender  = _cpStartRender + _li._cch;

    //
    // marka - examine Cached _cpSelMin, _cpSelMax for when we render.
    //
    if ( _cpSelMax != -1 )
    {
        //
        // Selection starts outside the line and ends
        // inside or beyond the line, then use old method to render
        //

        if (   _cpSelMin <= _cpStartRender
            && _cpSelMax > _cpStartRender
           )
            fIntersectSelection = TRUE;

        //
        // Selection starts inside the line. Irrespective
        // of where it ends, use the old method
        //
        if (   _cpSelMin >= _cpStartRender
            && _cpSelMin <  _cpStopRender
           )
            fIntersectSelection = TRUE;
    }

    if (   _li._fFirstInPara
        && (   _li._fHasFirstLine
            || _li._fHasFirstLetter
           )
       )
    {
        LONG junk;
        AccountForRelativeLines(li,
                                &cpStartContainerLine,
                                &xWidthContainerLine,
                                &_cpStartRender,
                                &_cpStopRender,
                                &cchTotal
                               );
        _pdp->FormattingNodeForLine(FNFL_NONE, GetCp(), GetPtp(), cchTotal - 1, &junk, &ptp, NULL);
        
        CTreeNode *pNode = ptp->GetBranch();
        pNode = _pLS->_pMarkup->SearchBranchForBlockElement(pNode, _pFlowLayout);
        const CFancyFormat *pFF = pNode->GetFancyFormat();
        
        _cpStopFirstLetter = ((li._fHasFirstLetter && pFF->_fHasFirstLetter)
                              ? GetCpOfLastLetter(pNode)
                              : -1);
        
        if (pFF->_fHasFirstLine && _li._fHasFirstLine)
        {
            PseudoLineEnable(pNode);
        }
        if (pFF->_fHasFirstLetter && _li._fHasFirstLetter && _cpStopFirstLetter >= 0)
        {
            PseudoLetterEnable(pNode);
        }
    }
    
    _rcClip = *_pDI->ClipRect();

    if (_li._fHasBulletOrNum)
    {
        CMarginInfo marginInfo;
        LONG cp = GetCp();
        CTreePos *ptp = GetPtp();

        hr = THR(StartUpLSDLL(_pLS, _pdp->GetMarkup()));
        if (hr)
            goto Cleanup;

        AccountForRelativeLines(li,
                                &cpStartContainerLine,
                                &xWidthContainerLine,
                                &_cpStartRender,
                                &_cpStopRender,
                                &cchTotal
                               );
        
        _pdp->FormattingNodeForLine(FNFL_NONE, cp, ptp, cchTotal - 1, &_cchPreChars, &ptp, NULL);
        cp += _cchPreChars;

        _pLS->_treeInfo._fInited = FALSE;

        //
        // Subsequently we will also reset the renderer inside renderbulletchar
        // with the correct pCFLI. Do it for now so that Setup works.
        //
        _pLS->SetRenderer(this, FALSE);
        if (S_OK == _pLS->Setup(0, cp, ptp, &marginInfo, NULL, FALSE))
        {
            COneRun *por = _pLS->_listFree.GetFreeOneRun(NULL);
            if (por)
            {
                por->_lscpBase = GetCp();
                por->_pPF = _pLS->_treeInfo._pPF;
                por->_fInnerPF = _pLS->_treeInfo._fInnerPF;
                por->_pCF = (CCharFormat*)_pLS->_treeInfo._pCF;
#if DBG == 1
                por->_pCFOriginal = por->_pCF;
#endif
                por->_fInnerCF = _pLS->_treeInfo._fInnerCF;
                por->_pFF = (CFancyFormat*)_pLS->_treeInfo._pFF;

                por->_fCharsForNestedElement  = _pLS->_treeInfo._fHasNestedElement;
                por->_fCharsForNestedLayout   = _pLS->_treeInfo._fHasNestedLayout;
                por->_fCharsForNestedRunOwner = _pLS->_treeInfo._fHasNestedRunOwner;
                por->_ptp = _pLS->_treeInfo._ptpFrontier;
                por->_sid = sidAsciiLatin;

                por = _pLS->AttachOneRunToCurrentList(por);
                if (por)
                {
                    if (_lastTextOutBy != DB_LINESERV)
                    {
                        _lastTextOutBy = DB_LINESERV;
                        SetTextAlign(_hdc, TA_TOP | TA_LEFT);
                    }

                    RenderStartLine(por);
                }
            }
        }
        
        //
        // reset so that the next person to call setup on CLineServices
        // will cleanup after us.
        //
        _pLS->_treeInfo._fInited = FALSE;
    }

    // Set the renderer before we do any output.
    _pLS->SetRenderer(this, GetBreakLongLines(_ptpCurrent->GetBranch()));

    //
    // If the line can be blasted to the screen and it was successfully blasted
    // then we are done.
    //
    if (_li._fCanBlastToScreen && !DontBlastLines() && !fIntersectSelection && !_fHasEllipsis)
    {
        _pLS->_fHasVerticalAlign = FALSE;

        ptpNext = BlastLineToScreen(li);
        if (ptpNext)
        {
            MtAdd(Mt(BlastedLines), 1, 0);
            goto Done;
        }
    }

    hr = THR(StartUpLSDLL(_pLS, _pdp->GetMarkup()));
    if (hr)
        goto Cleanup;

    MtAdd(Mt(LSRenderLines), 1, 0);

    if (_lastTextOutBy != DB_LINESERV)
    {
        _lastTextOutBy = DB_LINESERV;
        SetTextAlign(_hdc, TA_TOP | TA_LEFT);
    }

    pliContainer = AccountForRelativeLines(li,
                            &cpStartContainerLine,
                            &xWidthContainerLine,
                            &_cpStartRender,
                            &_cpStopRender,
                            &cchTotal
                           );

    _li._cch += _cp - cpStartContainerLine;

    if (cpStartContainerLine != GetCp())
        SetCp(cpStartContainerLine, NULL);

    _pdp->FormattingNodeForLine(FNFL_NONE, GetCp(), GetPtp(), _li._cch, &_cchPreChars, &ptp, &_fMeasureFromTheStart);
    if (!_fMeasureFromTheStart)
    {
        cpStartContainerLine += _cchPreChars;
        _li._cch   -= _cchPreChars;
        SetPtp(ptp, cpStartContainerLine);
    }

    _pLS->_li = _li;

    InitForMeasure(MEASURE_BREAKATWORD);
    LSDoCreateLine(cpStartContainerLine, NULL, &marginInfo,
                   xWidthContainerLine, &_li, FALSE, NULL);
    if (!_pLS->_plsline)
        goto Cleanup;

    ptLS = _ptCur;

    _pLS->_fHasVerticalAlign = (_pLS->_lineFlags.GetLineFlags(_pLS->_cpLim) & FLAG_HAS_VALIGN) ? TRUE : FALSE;

    if (_pLS->_fHasVerticalAlign)
    {
        _pLS->_li._cch = _pLS->_cpLim - cpStartContainerLine;
        _pLS->VerticalAlignObjects(*this, 0);
    }

    // Calculate chunk offset for relative lines
    _xChunkOffset  = CalculateChunkOffsetX();

    if (   _li._fHasInlineBgOrBorder
        || fIntersectSelection
       )
    {
        DrawInlineBordersAndBg(pliContainer);
    }

    LsDisplayLine(_pLS->_plsline,   // The line to be drawn
                  &ptLS,            // The point at which to draw the line
                  1,                // Draw in transparent mode
                  &_rcClip          // The clipping rectangle
                 );

    if (_fHasEllipsis && _fEllipsisPosSet)
    {
        RenderEllipsis();
    }

    ptpNext = _pLS->FigureNextPtp(_cp + _li._cch);

Cleanup:

    _pLS->DiscardLine();

Done:
    // increment y position to next line
    if (_li._fForceNewLine)
    {
        _ptCur.y += _li._yHeight;
    }

    // Go past the contents of this line
    Advance(_li._cch, ptpNext);

    PseudoLineDisable();
    
    return;
}

//-----------------------------------------------------------------------------
//
//  Function:   DrawInlineBordersAngBg
//
//  Synopsis:   Draws borders around the inline elements in the 
//              one run list.
//
//  Returns:    void
//
//-----------------------------------------------------------------------------
void 
CLSRenderer::DrawInlineBordersAndBg(CLineCore *pliContainer)
{
    COneRun* por = _pLS->_listCurrent._pHead;
    COneRun *porTemp;
    LSCP lscpStartBorder = -1;
    LSCP lscpEndBorder = -1;
    LSCP lscpStartRender = _pLS->LSCPFromCP(_cpStartRender);
    LSCP lscpStopRender = _pLS->LSCPFromCP(_cpStopRender);
    CTreeNode *pNode;
    BOOL fDrawBorders;
    BOOL fDrawBackgrounds;  // working loop variable
    BOOL fNoBackgroundsForPrinting = !GetMarkup()->PaintBackground();   // used to override fDrawBackgrounds
                                                                        // perf: make it a member var?
    BOOL fDrawSelection;
    const CFancyFormat *pFF = NULL;
    const CCharFormat  *pCF = NULL;

    // If this physical line has a relative chunk in it, 
    // we'll get called several times with a different lscpStart/StopRender
    // for each chunk.  Only process runs within the range we're being
    // called for.
    // This entire "if" block is responsible for the drawing of 
    // inline borders that are continued from a previous line (i.e.
    // borders that didn't start on this line.
    if (!_li._fPartOfRelChunk
         || (   por->_lscpBase >= lscpStartRender
             && por->_lscpBase < lscpStopRender))
    {
        CStackDataAry<CTreeNode*, 8> aryNodes(NULL);
        LONG mbpTop = 0;
        LONG mbpBottom = 0;
        LONG i;

        // Walk up the tree to find all of the nested spans with borders
        _pLS->_mbpTopCurrent = _pLS->_mbpBottomCurrent = 0;
        SetupMBPInfoInLS(&aryNodes);

        lscpStartBorder = por->_lscpBase;

        // Now draw the background for each node in the array.
        for (i = aryNodes.Size() - 1; i >= 0; i--)
        {
            pNode = aryNodes[i];

            pFF = pNode->GetFancyFormat();
            pCF = pNode->GetCharFormat();

            Assert(pCF->HasVerticalLayoutFlow() == pNode->IsParentVertical());
            
            lscpEndBorder = FindEndLSCP(pNode);

            DrawBorderAndBgOnRange(pFF, pCF, pNode, por, lscpStartBorder, lscpEndBorder,
                                   pliContainer, TRUE, mbpTop, mbpBottom,
                                   _pLS->HasBorders(pFF, pCF, por->_fIsPseudoMBP), 
                                   fNoBackgroundsForPrinting ? FALSE : pFF->HasBackgrounds(por->_fIsPseudoMBP),
                                   FALSE);

            if (pNode->HasInlineMBP())
            {
                CRect rcDimensions;
                BOOL fIgnore;
                if (pNode->GetInlineMBPContributions(GetCalcInfo(), GIMBPC_ALL, &rcDimensions, &fIgnore, &fIgnore))
                {
                    mbpTop += rcDimensions.top;
                    mbpBottom += rcDimensions.bottom;
                }
            }
        }
    }

    // Examine the rest of the one run for borders
    while (   por 
           && por->_lscpBase < _pLS->_lscpLim)
    {
        // Figure out if we need to draw borders or backgrounds
        // for this one run
        if (_li._fPartOfRelChunk)
        {
            if (   por->_lscpBase >= lscpStartRender
                && por->_lscpBase < lscpStopRender)
            {
                fDrawBorders = _pLS->HasBorders(por->GetFF(), por->GetCF(), por->_fIsPseudoMBP);
                fDrawBackgrounds = por->GetFF()->HasBackgrounds(por->_fIsPseudoMBP);
                fDrawSelection = por->IsSelected();
            }
            else
            {
                fDrawBorders = FALSE;
                fDrawBackgrounds = FALSE;
                fDrawSelection = FALSE;
            }
        }
        else
        {
            fDrawBorders = _pLS->HasBorders(por->GetFF(), por->GetCF(), por->_fIsPseudoMBP);
            fDrawBackgrounds = por->GetFF()->HasBackgrounds(por->_fIsPseudoMBP);
            fDrawSelection = por->IsSelected();
        }

        // If we don't want backgrounds for printing, override whatever we got from formats.
        if ( fNoBackgroundsForPrinting )
            fDrawBackgrounds = FALSE;

        // See if a border or background has been set. 
        if (   fDrawBorders
            || fDrawBackgrounds)
        {
            // Draw borders when we come to a begin node
          if (   por->_synthType == CLineServices::SYNTHTYPE_MBPOPEN
              || (   por->_ptp->IsBeginNode()
                  && por->Branch()->IsFirstBranch()
                  && !por->_fNotProcessedYet
                  && !por->_fCharsForNestedElement
                  && !por->IsSyntheticRun()
                 )
             )
            {
                lscpStartBorder = por->_lscpBase;
                pNode = por->Branch();
              
                if (por->_fIsPseudoMBP)
                {
                    // Get the formats
                    pFF = por->GetFF();
                    pCF = por->GetCF();

                    // Find the next closing PseudoMBP this the right edge of the border
                    porTemp = por->_pNext;
                    while (   porTemp
                           && porTemp->_synthType != CLineServices::SYNTHTYPE_MBPCLOSE 
                           && !porTemp->_fIsPseudoMBP)
                    {
                        porTemp = porTemp->_pNext;
                    }

                    if (porTemp)
                    {
                        lscpEndBorder = porTemp->_lscpBase;
                        Assert(lscpEndBorder != _pLS->_lscpLim);
                    }
                    else
                    {
                        porTemp = _pLS->_listCurrent._pTail;
                        if (porTemp)
                            lscpEndBorder = porTemp->_lscpBase;
                        else
                        {
                            // This is really a whacky case, which should never happen
                            lscpEndBorder = lscpStartBorder;
                        }
                    }
                }
                else
                {
                    // Get the formats
                    pFF = por->GetFF();
                    pCF = por->GetCF();

                    // Don't draw borders for block elements
                    if (pFF->_fBlockNess)
                        goto Skip;

                    lscpEndBorder = FindEndLSCP(pNode);
                }

                if (lscpStartBorder < lscpEndBorder)
                {
                    DrawBorderAndBgOnRange(pFF, pCF, por->Branch(), por, lscpStartBorder, lscpEndBorder,
                                           pliContainer, FALSE, 0, 0,
                                           fDrawBorders, fDrawBackgrounds, por->_fIsPseudoMBP);
                }
            }
        }

        // If the one run is marked as selected then draw
        // a selection background for it.
        if (fDrawSelection)
        {
            DrawSelection(pliContainer, por);
        }

Skip:
        // Skip the AntiSynth run after MBP runs
        if (por->IsSpecialCharRun() && por->IsMBPRun() && por->_pNext && por->_pNext->IsAntiSyntheticRun())
        {
            por = por->_pNext;
        }

        por = por->_pNext;
    }
}

//-----------------------------------------------------------------------------
//
//  Function:   DrawBorderAngBgOnRange
//
//  Synopsis:   Draw a border around an LSCP range
//
//  Returns:    void
//
//-----------------------------------------------------------------------------
void
CLSRenderer::DrawBorderAndBgOnRange(const CFancyFormat* pFF, const CCharFormat* pCF, CTreeNode *pNodeContext,
                                    COneRun *por, LSCP lscpStartBorder, LSCP lscpEndBorder,
                                    CLineCore *pliContainer, BOOL fFirstOneRun,
                                    LONG mbpTop, LONG mbpBottom,
                                    BOOL fDrawBorders, BOOL fDrawBackgrounds,
                                    BOOL fIsPseudoMBP)
{
    Assert(pNodeContext);
    if (!pNodeContext->IsVisibilityHidden())
    {
        CBorderInfo borderInfo;
        CDataAry<CChunk> aryRects(NULL);
        BOOL fSwapBorders = (   por->_synthType == CLineServices::SYNTHTYPE_MBPOPEN
                             && !por->_fIsLTR);

        // Fill the CBorderInfo structure
        GetBorderInfoHelperEx(pFF,
                              pCF,
                              _pDI, 
                              &borderInfo,
                              (por->_fIsPseudoMBP) ? GBIH_PSEUDO | GBIH_ALL : GBIH_ALL);

        aryRects.DeleteAll(); // Need to pass an empty array to CalcRects...

        // Figure out how much to offset the rects calcluated by CalcRects...
        LONG xShift = GetXOffset(pliContainer);

        // Get an array of rects that compose the range of
        // text we are going to draw the border around
        _pLS->CalcRectsOfRangeOnLine(lscpStartBorder, 
                                     lscpEndBorder,
                                     xShift,      // x offset
                                     _ptCur.y,    // y offset
                                     &aryRects,
                                     RFE_INCLUDE_BORDERS,
                                     (fFirstOneRun) ? mbpTop : por->_mbpTop,
                                     (fFirstOneRun) ? mbpBottom : por->_mbpBottom);

        BOOL fBOLWrapped = fFirstOneRun && !por->_fIsPseudoMBP;
        BOOL fEOLWrapped = lscpEndBorder == _pLS->_lscpLim;
        MassageRectsForInlineMBP(aryRects, NULL, pNodeContext, pCF, pFF, borderInfo,
                                 pliContainer,
                                 fIsPseudoMBP, fSwapBorders,
                                 fBOLWrapped, fEOLWrapped,
                                 fDrawBackgrounds, fDrawBorders
                                );
    }
}

void
CLSMeasurer::MassageRectsForInlineMBP(
                                      CDataAry<CChunk> & aryRects,     // Array of chunks comping in
                                      CDataAry<CChunk> * paryRectsOut,  // Could be NULL
                                      CTreeNode *pNode,
                                      const CCharFormat *pCF,
                                      const CFancyFormat *pFF,
                                      CBorderInfo &borderInfo,
                                      CLineCore *pliContainer,
                                      BOOL fIsPseudoMBP,
                                      BOOL fSwapBorders,
                                      BOOL fBOLWrapped,
                                      BOOL fEOLWrapped,
                                      BOOL fDrawBackgrounds,
                                      BOOL fDrawBorders
                                     )
{
    // If CalcRects does not return any rects then
    // don't display anything
    if (aryRects.Size() > 0)
    {
        LONG i;
        CChunk rcChunk;
        BOOL fNodeVertical = pCF->HasVerticalLayoutFlow();
        BOOL fWritingModeUsed = pCF->_fWritingModeUsed;
        LONG lFontHeight = pCF->GetHeightInTwips(_pdp->GetMarkup()->Doc());
        BOOL fReversed = FALSE;
        BOOL fFirstRTLChunk = TRUE;
        CRect rc;

        rc.SetRectEmpty();

        // Union all of the rects in the array
        for (i=0; i<aryRects.Size(); i++)
        {
            rcChunk = aryRects[i];
            LONG xStartChunk = rcChunk.left;
            LONG xEndChunk = rcChunk.right;

            if (rcChunk._fReversedFlow)
                fReversed = TRUE;

            // Adjust for RTL flow
            pliContainer->AdjustChunkForRtlAndEnsurePositiveWidth(pliContainer->oi(), xStartChunk, xEndChunk,
                                                        &rcChunk.left, &rcChunk.right);

            // Fixup the rect for top and bottom margins
            if (fIsPseudoMBP)
            {
                const CPseudoElementInfo* pPEI = GetPseudoElementInfoEx(pFF->_iPEI);

                rcChunk.top    += pPEI->GetLogicalMargin(SIDE_TOP, fNodeVertical, fWritingModeUsed, pFF).YGetPixelValue(_pci, _pci->_sizeParent.cy, lFontHeight);
                rcChunk.bottom -= pPEI->GetLogicalMargin(SIDE_BOTTOM, fNodeVertical, fWritingModeUsed, pFF).YGetPixelValue(_pci, _pci->_sizeParent.cy, lFontHeight);
            }
            else
            {
                if (pNode->HasInlineMBP())
                {
                    CRect rc;
                    BOOL fJunk;
                    pNode->GetInlineMBPContributions(_pci, GIMBPC_MARGINONLY, &rc, &fJunk, &fJunk);
                    rcChunk.top += rc.top;
                    rcChunk.bottom -= rc.bottom;
                }
            }

            if (!rc.IsEmpty())
            {
                // See if we hit text with a different flow direction
                if (   (rcChunk.left < rc.left && rcChunk.right < rc.left)
                    || (rc.left < rcChunk.left && rc.right < rcChunk.left))
                {
                    AdjustForMargins(&rc, &borderInfo, pNode, pFF, pCF, FALSE, FALSE, fIsPseudoMBP);

                    if (paryRectsOut)
                    {
                        CChunk rcChunk(rc);
                        paryRectsOut->AppendIndirect(&rcChunk);
                    }
                
                    if (fDrawBackgrounds)
                    {
                        DYNCAST(CLSRenderer, this)->DrawInlineBackground(rc, pFF, pNode, fIsPseudoMBP);
                    }

                    if (fDrawBorders)
                    {
                        DYNCAST(CLSRenderer, this)->DrawInlineBorderChunk(rc, &borderInfo, pFF, i, aryRects.Size(),
                                              fSwapBorders, fFirstRTLChunk, fReversed, fIsPseudoMBP);
                    }

                    fSwapBorders = !fSwapBorders;

                    fFirstRTLChunk = fReversed = FALSE;
                    rc.SetRectEmpty();
                }
                else
                {
                    // Height of the chunk can be negative because of negative margins.
                    // But we need to union width. In this case make the chunk's height equal to 
                    // combined rectangle's height (it won't affect the height), because Union()
                    // ignores empty rectangles.
                    if (rcChunk.Height() <= 0)
                    {
                        rcChunk.top = rc.top;
                        rcChunk.bottom = rc.bottom;
                    }
                }
            }

            rc.Union(rcChunk);
        }

        // If the text continues on to the next line
        // then don't draw the end border
        if (fEOLWrapped)
        {
            if (!_li.IsRTLLine())
                borderInfo.abStyles[SIDE_RIGHT] = fmBorderStyleNone;
            else
                borderInfo.abStyles[SIDE_LEFT] = fmBorderStyleNone;
        }
                  
        // Don't draw the left border if we are drawing 
        // a line that has been continued from the last line
        if (fBOLWrapped)
        {
            if (!_li.IsRTLLine())
                borderInfo.abStyles[SIDE_LEFT] = fmBorderStyleNone;
            else
                borderInfo.abStyles[SIDE_RIGHT] = fmBorderStyleNone;
        }

        AdjustForMargins(&rc, &borderInfo, pNode, pFF, pCF, fBOLWrapped, fEOLWrapped, fIsPseudoMBP);

        if (paryRectsOut)
        {
            CChunk rcChunk(rc);
            paryRectsOut->AppendIndirect(&rcChunk);
        }
        
        if (fDrawBackgrounds)
        {
            DYNCAST(CLSRenderer, this)->DrawInlineBackground(rc, pFF, pNode, fIsPseudoMBP); 
        }

        if (fDrawBorders)
        {
            DYNCAST(CLSRenderer, this)->DrawInlineBorderChunk(rc, &borderInfo, pFF, i - 1, aryRects.Size(),
                                  fSwapBorders, fFirstRTLChunk, fReversed, fIsPseudoMBP);
        }
    }
}

//-----------------------------------------------------------------------------
//
//  Function:   DrawInlineBorderChunk
//
//  Synopsis:   Ranges with multiple flow directions are broken up into
//              chunks. This function draws border around one such
//              chunk.
//
//  Returns:    void
//
//-----------------------------------------------------------------------------
void
CLSRenderer::DrawInlineBorderChunk(CRect rc, CBorderInfo *pborderInfo, const CFancyFormat *pFF,
                                   LONG nChunkPos, LONG nChunkCount,
                                   BOOL fSwapBorders, BOOL fFirstRTLChunk, BOOL fReversed,
                                   BOOL fIsPseudoMBP)
{
    // Disable a border if the chunk continues on
    if (nChunkPos != nChunkCount - 1)
    {
        if (!fReversed)
            pborderInfo->abStyles[SIDE_LEFT] = fmBorderStyleNone;
        else
            pborderInfo->abStyles[SIDE_RIGHT] = fmBorderStyleNone;
    }

    // Disable a border if the chunk has more chunks before it
    if (   nChunkPos < nChunkCount
        && !fFirstRTLChunk)
    {
        if (!fReversed)
            pborderInfo->abStyles[SIDE_RIGHT] = fmBorderStyleNone;
        else
            pborderInfo->abStyles[SIDE_LEFT] = fmBorderStyleNone;
    }

    if (fSwapBorders)
    {
        int nTemp = pborderInfo->aiWidths[SIDE_LEFT];
        pborderInfo->aiWidths[SIDE_LEFT] = pborderInfo->aiWidths[SIDE_RIGHT];
        pborderInfo->aiWidths[SIDE_RIGHT] = nTemp;
    }

    if (!rc.IsEmpty())
        DrawBorder(_pDI, &rc, pborderInfo);

    if (fSwapBorders)
    {
        int nTemp = pborderInfo->aiWidths[SIDE_LEFT];
        pborderInfo->aiWidths[SIDE_LEFT] = pborderInfo->aiWidths[SIDE_RIGHT];
        pborderInfo->aiWidths[SIDE_RIGHT] = nTemp;
    }
}

//-----------------------------------------------------------------------------
//
//  Function:   DrawInlineBackground
//
//  Synopsis:   Draw an inline background in the rect
//
//  Returns:    void
//
//-----------------------------------------------------------------------------
void
CLSRenderer::DrawInlineBackground(CRect rc, const CFancyFormat *pFF, CTreeNode *pNodeContext,
                                  BOOL fIsPseudoMBP)
{
    CBackgroundInfo bgInfo;
    SIZE            sizeImg;
    CPoint          ptBackOrg;
    CImgCtx       * pImgCtx;
    
    Assert(pNodeContext && pFF);

    // Set the color and image context cookie in the BACKGROUNDINFO struct
    if (fIsPseudoMBP)
    {
        const CPseudoElementInfo* pPEI = GetPseudoElementInfoEx(pFF->_iPEI);
        bgInfo.crBack = (pPEI->_ccvBackColor.IsDefined())
            ? pPEI->_ccvBackColor.GetColorRef()
            : COLORREF_NONE;
        bgInfo.lImgCtxCookie = pPEI->_lImgCtxCookie;
    }
    else
    {
        bgInfo.crBack = pFF->_ccvBackColor.IsDefined() ? pFF->_ccvBackColor.GetColorRef()
                                                       : COLORREF_NONE;
        bgInfo.lImgCtxCookie = pFF->_lImgCtxCookie;
    }

    // Assert that we have something to draw on the screen
    Assert(bgInfo.lImgCtxCookie || bgInfo.crBack);

    // Get the image context from the cookie
    pImgCtx = (bgInfo.lImgCtxCookie
                            ? _pFlowLayout->Doc()->GetUrlImgCtx(bgInfo.lImgCtxCookie)
                            : 0);

    if (pImgCtx && !(pImgCtx->GetState(FALSE, &sizeImg) & IMGLOAD_COMPLETE))
        pImgCtx = NULL;

    // if the background image is not loaded yet and there is no background color
    // return (we dont have anything to draw)
    if(!pImgCtx && bgInfo.crBack == COLORREF_NONE)
        return;

    bgInfo.pImgCtx       = pImgCtx;
    bgInfo.crTrans       = COLORREF_NONE;

    if (pImgCtx)
    {
        SIZE sizeBound;
        CDataAry<RECT> aryRects(NULL);
        CPoint ptOffset(((CRect*)&_rcView)->TopLeft());

        // TODO RTL 112514: this is a hack, which makes inline background work in mormal case, 
        //                  but it is completely broken for relative.
        if (_pdp->IsRTLDisplay())
            ptOffset.x = 0;
        
        CTreePos *ptpBegin = pNodeContext->GetBeginPos();
        CTreePos *ptpEnd = pNodeContext->GetEndPos();
        LONG cpStart = ptpBegin->GetCp();
        LONG cpEnd = ptpEnd->GetCp();
        RECT rcBound;

        // If the element does not cross multiple lines then
        // we have all the info we need and do not have to
        // call RFE
        if (   cpStart >= _cp
            && cpEnd < _cp + _li._cch)
        {
            sizeBound.cx = rc.Width();
            sizeBound.cy = rc.Height();
            rcBound = rc;
        }
        else
        {
            // In the case of inlined elements with background images
            // we need to know the bounding rects of the element. So we
            // have to call RFE to get it.
            _pFlowLayout->RegionFromElement(pNodeContext->Element(),
                                            &aryRects, 
                                            &ptOffset,
                                            _pDI,
                                            0,
                                            cpStart,
                                            cpEnd,
                                            &rcBound);

            // Set the size of the bounding rect
            sizeBound.cx = rcBound.right - rcBound.left;
            sizeBound.cy = rcBound.bottom - rcBound.top;
        }

        GetBgImgSettings(pFF, &bgInfo);
        CalcBgImgRect(pNodeContext, _pDI, &sizeBound, &sizeImg, &ptBackOrg, &bgInfo);

        OffsetRect(&bgInfo.rcImg, rcBound.left, rcBound.top);

        if (!pNodeContext->IsRelative())
        {
            if (   cpStart >= _cp
                && cpEnd < _cp + _li._cch)
            {
                ptBackOrg.x += rc.left;
                ptBackOrg.y += rc.top;
            }
            else
            {
                ptBackOrg.x += rcBound.left;
                ptBackOrg.y += rcBound.top;
            }
        }

        bgInfo.ptBackOrg = ptBackOrg;

        IntersectRect(&bgInfo.rcImg, &bgInfo.rcImg, &rc);
        IntersectRect(&bgInfo.rcImg, &_rcClip, &bgInfo.rcImg);
    }

    _pFlowLayout->DrawBackground(_pDI, &bgInfo, &rc);
}

//-----------------------------------------------------------------------------
//
//  Function:   FindEndLSCP
//
//  Synopsis:   Find the LSCP value for the end of the tree node.
//
//-----------------------------------------------------------------------------
LSCP
CLSRenderer::FindEndLSCP(CTreeNode* pNode)
{
    LSCP lscpEndBorder;
    COneRun *porTemp;
    LONG cpEndBorder;
    CTreePos *ptpEndPos;

    // Find the last branch
    while (!pNode->IsLastBranch())
        pNode = pNode->NextBranch();
      
    ptpEndPos = pNode->GetEndPos();
    cpEndBorder = ptpEndPos->GetCp();
    lscpEndBorder = _pLS->LSCPFromCP(cpEndBorder);

    porTemp = _pLS->FindOneRun(lscpEndBorder);

    if (   lscpEndBorder >= _pLS->_lscpLim
        || !porTemp)
    {
        // This line is wraps so just end the border at
        // the end of the line
        lscpEndBorder = _pLS->_lscpLim;
    }
    else
    {
        // LSCPFromCP might return the position of an MBP closing
        // a Pseudo element. In this case we might want move to the
        // next one run if its an MBP
        if (   porTemp->_synthType == CLineServices::SYNTHTYPE_MBPCLOSE 
               && porTemp->_fIsPseudoMBP)
        {
            Assert(porTemp->_pNext);
            if (porTemp->_pNext->_synthType == CLineServices::SYNTHTYPE_MBPCLOSE)
                porTemp = porTemp->_pNext;
            else
                porTemp = porTemp->_pPrev;
        }

        lscpEndBorder = porTemp->_lscpBase;
        Assert(lscpEndBorder != _pLS->_lscpLim);
    }

    return lscpEndBorder;
}

//-----------------------------------------------------------------------------
//
//  Function:   DrawSelection
//
//  Synopsis:   Draw a selection background for this one run.
//
//-----------------------------------------------------------------------------
void
CLSRenderer::DrawSelection(CLineCore *pliContainer, COneRun *por)
{
    if (!por->Branch()->IsVisibilityHidden())
    {
        CRect rc;
        COLORREF crBackColor;
        CStackDataAry<CChunk, 8> aryRects(NULL);
        LONG xShift;
    
        if (por->GetCurrentBgColor().IsDefined())
            crBackColor = por->GetCurrentBgColor().GetColorRef();
        else
            goto Cleanup;

        // Figure out how much to offset the rects calcluated by CalcRects...
        xShift = GetXOffset(pliContainer);

        // Get the rect for the one run
        _pLS->CalcRectsOfRangeOnLine(por->_lscpBase,
                                     por->_lscpBase + (por->IsAntiSyntheticRun() ? 0 : por->_lscch),
                                     xShift,
                                     _ptCur.y,
                                     &aryRects,
                                     RFE_SELECTION, 0, 0);
    
        Assert(aryRects.Size() <= 1);

        if (aryRects.Size() == 0)
            goto Cleanup;

        // Get the rect for the one run
        rc = aryRects[0];

        // Fixup the rect so that its height is the extent of the line
        rc.top = _ptCur.y + _li.GetYTop();
        rc.bottom = _ptCur.y + _li.GetYBottom();
    
        //
        // Fix up rects for RTL text
        //
        _li.AdjustChunkForRtlAndEnsurePositiveWidth(&_li, rc.left, rc.right,
                                                    &rc.left, &rc.right);

        // Create the BACKGROUNDINFO structure
        CBackgroundInfo bgInfo;
        bgInfo.crBack = crBackColor;
        bgInfo.pImgCtx = NULL;
        bgInfo.crTrans = COLORREF_NONE;

        // Now just draw the background
        _pFlowLayout->DrawBackground(_pDI, &bgInfo, &rc);
    }

Cleanup:
    return;
}

//-----------------------------------------------------------------------------
//
//  Function:   GetXOffset
//
//  Synopsis:   Calculate the offset to pass to CalcRects...
//
//  Return value is LOGICAL (from right if the line is RTL).
//
//-----------------------------------------------------------------------------
LONG
CLSRenderer::GetXOffset(CLineCore *pliContainer)
{
    LONG xOffset;

    if (!pliContainer->IsRTLLine())
    {
        if (!_li._fRelative)
        {
            if (_li._fPartOfRelChunk)
            {
                xOffset = pliContainer->oi()->_xLeft + pliContainer->oi()->_xLeftMargin;
            }
            else
            {
                xOffset = _ptCur.x;
            }
        }
        else
        {
            xOffset = _li._xLeftMargin + pliContainer->oi()->_xLeft + _xRelOffset;
        }
    }
    else
    {
        // TODO RTL 112514: this doesn't work yet, and it may 
        //                  not start working properly until we rewrite relative positioning.
        if (!_li._fRelative)
        {
            if (_li._fPartOfRelChunk)
            {
                xOffset = pliContainer->_xRight + pliContainer->oi()->_xRightMargin;
            }
            else
            {
                xOffset = _li._xRightMargin +  pliContainer->_xRight;
            }
        }
        else
        {
            xOffset = _li._xRightMargin + pliContainer->_xRight + _xRelOffset;
        }
    }

    return xOffset;
}


//-----------------------------------------------------------------------------
//
//  Function:   BlastLineToScreen
//
//  Synopsis:   Renders one line in one shot w/o remeasuring if it can be done.
//
//  Params:     li: The line to be rendered
//
//  Returns:    Whether it rendered anything at all
//
//-----------------------------------------------------------------------------
CTreePos *
CLSRenderer::BlastLineToScreen(CLineFull& li)
{
    CTreePos   *ptpRet = NULL;

    Assert(_li._fCanBlastToScreen);
    Assert(!_li._fHidden);

    //
    // We need to render all the characters in the line
    //
    _cpStartRender = GetCp();
    _cpStopRender  = _cpStartRender + _li._cch;

    // We don't need to calculate chunk offset here - we won't blast relative lines.
    // (and there is an assert in GetChunkOffsetX() that ensures that this is true)
    _xChunkOffset  = 0;

    //
    // For now, lets not do relative lines...
    //
    if (_li._fPartOfRelChunk || _pdp->HasLongLine())
        goto Cleanup;

    //
    // Now we are pretty sure that we can blast this line, so lets go do it.
    //
    {
        CTreePos *ptp;
        LONG      cp  = GetCp();
        LONG      cch = _li._cch;
        LONG      cpAtPtp;

        LONG      cchToRender;
        LONG      cchSkip;
        CTreeNode*pNode = _pdp->FormattingNodeForLine(FNFL_NONE, cp, GetPtp(), cch, &cchSkip, &ptp, NULL);

        if(!pNode)
            goto Cleanup;

        COneRun   onerun;

        const TCHAR *pch = NULL;
        CTxtPtr      tp(_pdp->GetMarkup(), cp += cchSkip);
        LONG         cchValid = 0;

        LONG      xOld = -1;
        LONG      yOld = LONG_MIN;
        LONG      xCur = _ptCur.x;
        LONG      yCur = _ptCur.y;
        LONG      yOriginal = _ptCur.y;
        BOOL      fRenderedText = FALSE;
        LONG      cchCharsTrimmed = 0;
        BOOL      fHasInclEOLWhite = pNode->GetParaFormat(LC_TO_FC(_pci->GetLayoutContext()))->HasInclEOLWhite(SameScope(pNode, _pFlowLayout->ElementContent()));
      
        WHEN_DBG( BOOL fNoMoreTextOut = FALSE;)

        if (_lastTextOutBy != DB_BLAST)
        {
            _lastTextOutBy = DB_BLAST;
            SetTextAlign(_hdc, TA_TOP | TA_LEFT | TA_UPDATECP);
        }

        cch -= cchSkip;
        cpAtPtp = ptp->GetCp();
        while (cch > 0)
        {
            if (cchValid == 0)
            {
                Assert(cp == (long)tp.GetCp());

                pch = tp.GetPch(cchValid);
                Assert(pch != NULL);
                if (pch == NULL)
                    goto Cleanup;
                cchValid = min(cchValid, cch);
                tp.AdvanceCp(cchValid);
            }

            cchToRender = 0;
            if (ptp->IsPointer())
            {
                ptp = ptp->NextTreePos();
                continue;
            }
            if (ptp->IsNode())
            {
                pNode = ptp->Branch();

                // Start off with a default number of chars to render
                cchToRender = ptp->NodeCch();

                if (ptp->IsBeginElementScope())
                {
                    const CCharFormat *pCF = pNode->GetCharFormat(LC_TO_FC(_pci->GetLayoutContext()));
                    CElement *pElement = pNode->Element();

                    if (pCF->IsDisplayNone())
                    {
                        cchToRender = GetNestedElementCch(pElement, &ptp);
                    }
                    else if (pElement->ShouldHaveLayout(LC_TO_FC(_pci->GetLayoutContext())))
                    {
                        CLayout *pLayout = pElement->GetUpdatedLayout(_pci->GetLayoutContext());

                        Assert(pLayout != _pFlowLayout);
                        if (pElement->IsInlinedElement(LC_TO_FC(_pci->GetLayoutContext())))
                        {
                            LONG xWidth;

                            GetSiteWidth(pNode, pLayout, _pci, FALSE, 0, &xWidth);
                            xCur += xWidth;
                            MoveToEx(_hdc, xCur, yCur, NULL);
                            fRenderedText = TRUE;
                        }
                        cchToRender = _pLS->GetNestedElementCch(pElement, &ptp);

                        pNode = ptp->Branch();

                        // We either have overlapping layouts (which is when the cchToRender
                        // etc test will succeed), or our last ptp has to be that of the
                        // layout we just rendered.
                        Assert(   cchToRender != (pNode->Element()->GetElementCch() + 2)
                               || pNode->Element() == ptp->Branch()->Element()
                              );
                    }
                }

                if (ptp->IsEndNode())
                    pNode = pNode->Parent();
                ptp = ptp->NextTreePos();
                cpAtPtp += cchToRender;
            }
            else
            {
                Assert(ptp->IsText());
                Assert(pNode);

                if (ptp->Cch() == 0)
                {
                    ptp = ptp->NextTreePos();
                    continue;
                }
                
                LONG cchRemainingInTextPos = ptp->Cch() - (cp - cpAtPtp);
                LONG cchCanRenderNow = min(cchRemainingInTextPos, cchValid);
                BOOL fWhiteSpaceSkip = FALSE;
                CTreePos * ptpThis = ptp;

                if (fRenderedText)
                {
                    cchToRender = cchCanRenderNow;
                }
                else
                {
                    LONG i = 0;
                    if (!fHasInclEOLWhite)
                    {
                        for(i = 0; i < cchCanRenderNow; i++)
                        {
                            if (!IsWhite(pch[i]))
                                break;
                            fWhiteSpaceSkip = TRUE;
                        }
                    }
                    if (fWhiteSpaceSkip)
                        cchToRender = i;
                    else
                        cchToRender = cchCanRenderNow;
                }

                cchRemainingInTextPos -= cchToRender;
                if (cchRemainingInTextPos == 0)
                {
                    cpAtPtp += ptp->Cch();
                    ptp = ptp->NextTreePos();
                }

                if (!fWhiteSpaceSkip)
                {
                    POINT ptTemp;
                    CCcs ccs;
                    const CBaseCcs *pBaseCcs;
                    BOOL fUnderlined;

                    fRenderedText = TRUE;

                    // Is this needed?
                    memset(&onerun, 0, sizeof(onerun));

                    onerun._fInnerCF = SameScope(pNode, _pFlowLayout->ElementOwner());
                    onerun._pCF = (CCharFormat* )pNode->GetCharFormat(LC_TO_FC(_pci->GetLayoutContext()));
#if DBG == 1
                    onerun._pCFOriginal = onerun._pCF;
#endif
                    onerun._pFF = (CFancyFormat*)pNode->GetFancyFormat(LC_TO_FC(_pci->GetLayoutContext()));
                    onerun._bConvertMode = CM_UNINITED;
                    onerun._ptp = ptpThis;
                    onerun.SetSidFromTreePos(ptpThis);
                    onerun._lscpBase = cp;
                    Assert(onerun._pCF);

                    fUnderlined =    onerun._pCF->_fStrikeOut
                                  || onerun._pCF->_fOverline
                                  || onerun._pCF->_fUnderline;


                    if (   fUnderlined
                        && !pNode->GetParaFormat(LC_TO_FC(_pci->GetLayoutContext()))->HasPre(onerun._fInnerCF)
                       )
                    { 
                        cchCharsTrimmed = TrimTrailingSpaces(
                                            cchToRender,       // number of chars being rendered now
                                            cp + cchToRender,  // cp of next run to be blasted
                                            ptp,
                                            cch - cchToRender);// chars remaining to be rendered
                        cchToRender -= cchCharsTrimmed;
                        Assert(cchToRender >= 0);
                        if (cchToRender == 0)
                        {
                            fUnderlined = FALSE;
                            cchToRender = cchCharsTrimmed;
                        }
                    }

                    if (!_pLS->GetCcs(&ccs, &onerun, _hdc, _pDI))
                        goto Cleanup;

                    pBaseCcs = ccs.GetBaseCcs();
                    Assert(pBaseCcs);
                    
                    yCur = yOriginal + _li._yHeight - _li._yDescent +
                           pBaseCcs->_yDescent - pBaseCcs->_yHeight;
                    if (yCur != yOld)
                    {
                        yOld = yCur;
#if DBG==1
                        BOOL fSuccess =
#endif
                        MoveToEx(_hdc, xCur, yCur, NULL);
#if DBG==1
                        AssertSz(fSuccess, "Failed to do moveto, bad HDC?");
                        if (!fSuccess)
                        {
                            DWORD winerror;
                            winerror = ::GetLastError();
                        }
#endif
                    }
                    xOld = xCur;

                    WHEN_DBG(GetCurrentPositionEx(_hdc, &ptTemp));
                    Assert(   ptTemp.x == xCur
                           || (   VER_PLATFORM_WIN32_WINDOWS == g_dwPlatformID
                               && xCur >= 0x8000
                              )
                          );
                    Assert(ptTemp.y == yCur);
                    Assert(fNoMoreTextOut == FALSE);

                    onerun._lscpBase = cp;
                    TextOut(&onerun,                 // por
                            FALSE,                   // fStrikeOut
                            FALSE,                   // fUnderLine
                            NULL,                    // pptText
                            pch,                     // pch
                            NULL,                    // lpDx
                            cchToRender,             // cwchRun
                            lstflowES,               // ktFlow
                            0,                       // kDisp
                            (const POINT*)&g_Zero,   // pptRun
                            NULL,                    // heightPres
                            -1,                      // dupRun
                            0,                       // dupLineUnderline
                            NULL);                   // pRectClip

                    // We will have moved to the right so get our new position
                    GetCurrentPositionEx(_hdc, &ptTemp);
                    xCur = ptTemp.x;
                    
                    // Keep yCur as it is.

                    if (fUnderlined)
                    {
                        LSULINFO lsUlInfo;

                        if (lserrNone != _pLS->GetRunUnderlineInfo(&onerun,        // PLSRUN
                            NULL,       // PCHEIGHTS
                            lstflowES,  // ktFlow
                            &lsUlInfo)
                           )
                            goto Cleanup;

                        ptTemp.x = xOld;
                        ptTemp.y = yOriginal;
                        DrawUnderline(&onerun,                              // por
                                      lsUlInfo.kulbase,                 // kUlBase
                                      &ptTemp,                          // pptStart
                                      xCur - xOld,                      // dupUl
                                      lsUlInfo.dvpFirstUnderlineSize,   // dvpUl
                                      lstflowES,                        // kTFlow
                                      0,                                // kDisp
                                      &_rcClip                          // prcClip
                                     );
                        MoveToEx(_hdc, xCur, yCur, NULL);
                        cchToRender += cchCharsTrimmed;
                        WHEN_DBG(fNoMoreTextOut = !!cchCharsTrimmed;)
                    }
                }
            }
            cp += cchToRender;
            cch -= cchToRender;

            cchValid -= cchToRender;

            // cchValid can go to < 0 if the current text run finishes *within* a
            // site or hidden stuff. In both these cases we will have cchToRender
            // be > cchValid. Take care of this.
            if (cchValid < 0)
            {
                tp.AdvanceCp(-cchValid);
                cchValid = 0;
            }
            else
            {
                pch += cchToRender;
            }
        }
        memset(&onerun, 0, sizeof(onerun));
        ptpRet = ptp;
    }

Cleanup:
    return ptpRet;
}

//-----------------------------------------------------------------------------
//
//  Function:   TrimTrailingSpaces
//
//  Synopsis:   Returns the number of white chars to be trimmed (if necessary)
//              at the end of a run
//
//  Returns:    Number of characters to be trimmed
//
//-----------------------------------------------------------------------------
LONG
CLSRenderer::TrimTrailingSpaces(LONG cchToRender,
                                LONG cp,
                                CTreePos *ptp,
                                LONG cchRemainingInLine)
{
    LONG  cchAdvance = 0;
    BOOL  fTrim      = TRUE;
    const CCharFormat *pCF;
    LONG  cchTrim;
    CTreeNode *pNode;
    CElement *pElement;
    LONG  cpMostOfRunToTrim = cp;
    
    LONG  junk;
    //Assert(ptp && ptp == _pdp->GetMarkup()->TreePosAtCp(cp, &junk));

    ptp = _pdp->GetMarkup()->TreePosAtCp(cp, &junk);
    while (cchRemainingInLine > 0)
    {
        Assert(   ptp->GetCp() <= cp
               && ptp->GetCp() + ptp->GetCch() >= cp
              );

        if (ptp->GetCch() == 0)
            cchAdvance = 0;
        else
        {
            pNode = ptp->GetBranch();
            pCF   = pNode->GetCharFormat(LC_TO_FC(_pci->GetLayoutContext()));

            if (ptp->IsNode())
            {
                cchAdvance = ptp->NodeCch();
                if (ptp->IsBeginNode())
                {
                    pElement = pNode->Element();

                    if (pCF->IsDisplayNone())
                    {
                        cchAdvance = GetNestedElementCch(pElement, &ptp);
                    }
                    else if (   ptp->IsEdgeScope()
                             && pElement->ShouldHaveLayout()
                            )
                    {
                        if (pElement->IsInlinedElement())
                        {
                            if (!pElement->IsOwnLineElement(_pFlowLayout))
                                fTrim = FALSE;
                            break;
                        }
                        else
                        {
                            //
                            // If in edit mode we are showing aligned site tags then
                            // we will not blast the line.
                            //
                            Assert( !_pdp->GetFlowLayout()->IsEditable()                        ||                                                              
                                    !_pdp->GetFlowLayout()->GetContentMarkup()->HasGlyphTable() ||
                                    !_pdp->GetFlowLayout()->GetContentMarkup()->GetGlyphTable()->_fShowAlignedSiteTags );
              
                            cchAdvance = GetNestedElementCch(pElement, &ptp);
                        }
                    }
                }
            }
            else if (ptp->Cch() > 0)
            {
                fTrim = FALSE;
                break;
            }
        }

        cp += cchAdvance;
        cchRemainingInLine -= cchAdvance;
        ptp = ptp->NextTreePos();

        // Should never happen, but does in stress cases
        if (!ptp)
        {
            fTrim = FALSE;
            break;
        }
        cchAdvance = ptp->GetCch();
    }

    if (fTrim)
    {
        CTxtPtr tp(_pdp->GetMarkup(), cpMostOfRunToTrim);

        cchTrim = 0;
        while(cchToRender && IsWhite(tp.GetPrevChar()))
        {
            cchToRender--;
            cchTrim++;
            tp.AdvanceCp(-1);
        }
    }
    else
        cchTrim = 0;

    return cchTrim;
}

//-----------------------------------------------------------------------------
//
//  Function:   TextOut
//
//  Synopsis:   Renders one run of text
//
//  Params:     Same as that for LineServices DrawTextRun callback
//
//  Returns:    Number of characters rendered
//
//  Dev Note:   Any changes made to this function should be reflected in
//              CLSRenderer::GlyphOut() (as appropriate)
//
//-----------------------------------------------------------------------------

LONG
CLSRenderer::TextOut(
    COneRun *por,           // IN
    BOOL fStrikeout,        // IN
    BOOL fUnderline,        // IN
    const POINT* pptText,   // IN
    LPCWSTR pch,            // IN was plwchRun
    const int* lpDx,        // IN was rgDupRun
    DWORD cwchRun,          // IN
    LSTFLOW kTFlow,         // IN
    UINT kDisp,             // IN
    const POINT* pptRun,    // IN
    PCHEIGHTS heightPres,   // IN
    long dupRun,            // IN
    long dupLimUnderline,   // IN
    const RECT* pRectClip)  // IN
{
    CONVERTMODE cm;
    TCHAR ch;
    CStr     strTransformedText;
    COLORREF crTextColor = 0;
    COLORREF crNewTextColor = 0;
    DWORD    cch = cwchRun;
    const    CCharFormat *pCF = por->GetCF();
    CCcs     ccs;
    const CBaseCcs *pBaseCcs;
    RECT     rcClipSave = _rcClip;
    LONG     yDescent = _li._yDescent;
    CDataAry<int> aryDx(Mt(CLSRendererTextOut_aryDx_pv));
    LONG     yCur;
    
    FONTIDX hfontOld = SetNewFont(&ccs, por);
    if (hfontOld == HFONT_INVALID)
        goto Cleanup;
    
    if (ShouldSkipThisRun(por, dupRun))
        goto Cleanup;

    pBaseCcs = ccs.GetBaseCcs();
    
    cm = pBaseCcs->GetConvertMode(_fEnhancedMetafileDC, _pDI->IsMetafile());

    // This is where this run will be drawn.
    _ptCur.x = pptRun->x - ((!(kTFlow & fUDirection)) ? 0 : dupRun - 1) - GetChunkOffsetX();

#ifdef NOTYET // TODO RTL 112514: this fixes bug 86548, but selection and hit testing get broken.
              //                  Needs more investigation.
    // In RTL lines, overhang needs to be added to the right, effectively pushing the run to the left
    if (_li._fRTLLn && por->_xOverhang)
        _ptCur.x -= por->_xOverhang;
#endif
        
    // If pptText is NULL, that means that we are blasting to the screen, so we
    // should just use _ptCur.y as our yCur
    AssertSz((pptText == NULL || _ptCur.y == (pptText->y + por->_lsCharProps.dvpPos) || por->GetCF()->_fIsRuby),
             "Our baseline differs from LS baseline!");
    yCur = (pptText == NULL) ? _ptCur.y : pptText->y + por->_lsCharProps.dvpPos;
        
    // Trim all nondisplayable linebreaking chars off end
    for ( ; cch ; cch-- )
    {
        ch = pch[cch - 1];

        if (!(   ch == LF
              || ch == CR))
            break;
    }

    if (!cch)
        goto Cleanup;


#if DBG==1
    if (!IsTagEnabled(tagLSPrintDontAdjustContrastForWhiteBackground))
#endif
    if (!GetMarkup()->PaintBackground())
    {
        // If we are part of a print doc and the background is not printed,
        // we conceptually replace the background with white (because most
        // paper is white).  This means that we have to enhance the contrast
        // of bright-colored text on dark backgrounds.

        COLORREF crNewBkColor = RGB(255, 255, 255); // white background
        int      nMinimalLuminanceDifference = 150; // for now

        crNewTextColor = GetTextColor(_hdc);

        // Sujal insists that if both colors are the same (in this case both
        // white), then the second color will be modified.
        ContrastColors(crNewTextColor, crNewBkColor, nMinimalLuminanceDifference);

        // Finally, turn off the higher order bits
        crNewTextColor  = (crNewTextColor & CColorValue::MASK_COLOR) | 0x02000000;

        crTextColor = SetTextColor (_hdc, crNewTextColor);
    }

    AssertSz(pCF, "CLSRenderer::TextOut: We better have char format here");

    // In some fonts in some locales, NBSPs aren't rendered like spaces.
    // Under these circumstances, we need to convert NBSPs to spaces
    // Before calling LSReExtTextOut.
    if (pCF && _li._fHasNBSPs && ccs.ConvertNBSPs(_hdc, _pDI->_pDoc))
    {
        const TCHAR * pchStop;
        TCHAR * pch2;

        HRESULT hr = THR( strTransformedText.Set( pch, cch ) );
        if (hr)
            goto Cleanup;
        pch = strTransformedText;

        pch2 = (TCHAR *)pch;
        pchStop = pch + cch;

        while ( pch2 < pchStop )
        {
            if (*pch2 == WCH_NBSP)
            {
                *pch2 = L' ';
            }

            pch2++;
        }
    }

    // Reverse the run if our text is flowing from right to left.
    // NOTE (mikejoch) We actually want to be more conditional about doing
    // this for metafiles, as we don't want to reverse runs that would
    // otherwise be glyphed. Maybe by looking at
    // por->GetComplexRun()->GetAnalysis()?
    if (kTFlow & fUDirection)
    {
        TCHAR * pch1;
        TCHAR * pch2;
        const int * pDx1;
        int * pDx2;

        if (pch != strTransformedText)
        {
            HRESULT hr = THR(strTransformedText.Set(pch, cch));
            if (hr)
                goto Cleanup;
            pch = strTransformedText;
        }

        if (FAILED(aryDx.Grow(cch)))
            goto Cleanup;

        pch1 = (TCHAR *) pch;
        pch2 = pch1 + cch - 1;
        while (pch1 < pch2)
        {
            TCHAR ch = *pch1;
            *pch1 = *pch2;
            *pch2 = ch;
            pch1++;
            pch2--;
        }

        pDx1 = lpDx + cch - 1;
        pDx2 = aryDx;
        while (pDx1 >= lpDx)
        {
            *pDx2++ = *pDx1--;
        }
        lpDx = aryDx;
    }

    if (_pLS->IsAdornment())
    {
        const CFancyFormat * pFFLi = _pLS->_pNodeLi->GetFancyFormat();

        LONG yTextHeight = _li._yHeight - _li.GetYTop();

        // If the first line in the LI is a frame line, then its _yDescent
        // value is garbage. This also means that we will not center WRT
        // the text following the frame line. However, this is much better
        // than before when we did not render the bullet at all when the
        // first line in a LI was a frame line.(SujalP)
        if (_li.IsFrame())
        {
            yDescent = 0;
        }

        // Center the bullet in the ascent of the text line only if
        // the line of text is smaller than the bullet. This adjustment
        // keeps the bullets visible, but tends to keep them low on the
        // line for large text fonts.
        if (pBaseCcs->_yHeight - pBaseCcs->_yDescent > yTextHeight - yDescent)
        {
            yCur += ((pBaseCcs->_yHeight - pBaseCcs->_yDescent) -
                     (yTextHeight - yDescent)) / 2;
            _ptCur.y = yCur;
        }
        else if (pFFLi->HasCSSVerticalAlign())
        {
            LONG yDiff;
            switch (pFFLi->GetVerticalAlign(_pLS->_pNodeLi->Parent()->GetCharFormat()->HasVerticalLayoutFlow()))
            {
            case styleVerticalAlignTop:
            case styleVerticalAlignTextTop:
                yDiff = (pBaseCcs->_yHeight - pBaseCcs->_yDescent) - (yTextHeight - yDescent);
                break;

            case styleVerticalAlignBottom:
            case styleVerticalAlignTextBottom:
                yDiff = yDescent - pBaseCcs->_yDescent;
                break;

            case styleVerticalAlignAbsMiddle:
            case styleVerticalAlignMiddle:
                yDiff = (yDescent - pBaseCcs->_yDescent) - (yTextHeight - pBaseCcs->_yHeight) / 2;
                break;

                break;

            case styleVerticalAlignSuper:
                yDiff =  (yDescent - pBaseCcs->_yDescent) - yTextHeight / 2;
                break;

            case styleVerticalAlignSub:
                yDiff = yTextHeight / 2 - ((yTextHeight - yDescent) - (pBaseCcs->_yHeight - pBaseCcs->_yDescent));
                break;

            case styleVerticalAlignPercent:
            case styleVerticalAlignNumber:
            case styleVerticalAlignBaseline:
            default:
                yDiff = 0;
            }
            yCur += yDiff;
            _ptCur.y = yCur;
        }
    }

    if (!pCF->IsVisibilityHidden())
    {
        int *lpDxNew = NULL;
        const int *lpDxPtr = lpDx;
        long lGridOffset = 0;

        if (pCF->HasCharGrid(por->_fInnerCF) && por->_pPF)
        {
            switch (por->GetPF()->GetLayoutGridType(por->_fInnerPF))
            {
            case styleLayoutGridTypeStrict:
            case styleLayoutGridTypeFixed:
                // Only characters which has its own grid cell need 
                // special processing. Other characters are handled by 
                // LS installed LayoutGrid object.
                if (por->IsOneCharPerGridCell())
                {
                    lpDxNew = new int[cch];
                    if(!lpDxNew)
                        goto Cleanup;
                    lpDxPtr = lpDxNew;

                    long durThisChar = 0;
                    long durNextChar = 0;
                    long lThisDoubleGridOffset = 0;
                    long lError = 0;

                    ccs.Include(pch[0], durThisChar);
                    lThisDoubleGridOffset = lpDx[0] - durThisChar;
                    lGridOffset = lThisDoubleGridOffset/2;

                    for (unsigned int i = 0; i < cch-1; i++)
                    {
                        long lNextDoubleGridOffset = 0;

                        ccs.Include(pch[i+1], durNextChar);
                        lNextDoubleGridOffset = lpDx[i+1] - durNextChar;

                        // The width of the this char is essentially it's width
                        // plus the remaining space ahead of it in its grid cell,
                        // plus the space between the beginning of the next grid
                        // cell and the next character.
                        lpDxNew[i] = lpDx[i] - (lThisDoubleGridOffset - lNextDoubleGridOffset + lError)/2;
                        lError = (lThisDoubleGridOffset - lNextDoubleGridOffset + lError)%2;

                        lThisDoubleGridOffset = lNextDoubleGridOffset;
                        durThisChar = durNextChar;
                    }
                    lpDxNew[cch-1] = lpDx[cch-1] - (lThisDoubleGridOffset + lError)/2;
                }
                break;

            case styleLayoutGridTypeLoose:
            default:
                // In loose grid mode (default mode) the width of a char is 
                // width of its grid cell.
                break;
            }
        }

        Assert(GetBkMode(_hdc) == TRANSPARENT);

        if (por->_fKerned)
        {
            LONG lA = (_li._yHeight - _li._yBeforeSpace - _li._yDescent);
            yCur += _li._yBeforeSpace + lA - (pBaseCcs->_yHeight - pBaseCcs->_yDescent);
        }
        else if (_pLS->_fHasVerticalAlign)
        {
                yCur += por->_yProposed;
        }
        else
        {
            yCur += _li._yHeight - yDescent + pBaseCcs->_yDescent - pBaseCcs->_yHeight;
        }

        BOOL fSelectCont = FALSE;

        if (por->IsSelected())
        {
            // Find the next one run that is not an antisynth
            COneRun *porNext = por->_pNext;
            while (   porNext
                   && porNext->IsAntiSyntheticRun())
            {
                porNext = porNext->_pNext;
            }

            fSelectCont = porNext ? porNext->IsSelected()
                                  : FALSE;
        }

        //
        // If ellipsis is needed in the line, establish truncation point
        // and truncate text if necessary.
        //
        if (_fHasEllipsis)
        {
            DWORD cchOld    = cch;
            BOOL fRTLLayout = _pdp->IsRTLDisplay();
            BOOL fReverse   = fRTLLayout;
            if (por->_pComplexRun)
            {
                fReverse =    (fRTLLayout && !por->_pComplexRun->GetAnalysis()->fRTL)
                           || (!fRTLLayout && por->_pComplexRun->GetAnalysis()->fRTL);
            }

            PrepareForEllipsis(por, cwchRun, dupRun, lGridOffset, fReverse, lpDxPtr, &cch);
            if (cch == 0)
                goto Cleanup;   // Nothing to render

            if (fReverse && cchOld != cch)
            {
                pch += cchOld - cch;
                lpDxPtr += cchOld - cch;
            }
        }

        LONG xCur = _ptCur.x + lGridOffset;

        if (!fSelectCont)
        {
            if (   !_pdp->HasLongLine() 
                || NeedRenderText(xCur, &_rcClip, dupRun))
            {
                if (_fDisabled)
                {
                    if (_crForeDisabled != _crShadowDisabled)
                    {
                        //draw the shadow
                        SetTextColor(_hdc, _crShadowDisabled);
                        LSReExtTextOut(&ccs,
                                       _hdc,
                                       xCur + 1,
                                       yCur + 1,
                                       ETO_CLIPPED,
                                       &_rcClip,
                                       pch,
                                       cch,
                                       lpDxPtr,
                                       cm);
                    }
                    SetTextColor(_hdc, _crForeDisabled);
                }

                LSReExtTextOut(&ccs,
                               _hdc,
                               xCur,
                               yCur,                       
                               ETO_CLIPPED,
                               &_rcClip,
                               pch,
                               cch,
                               lpDxPtr,
                               cm);
            }
        }

        if (por->IsSelected())
        {
            RECT rcSelect;
            COLORREF crTextColor = por->GetCF()->_ccvTextColor.GetColorRef();

            SetTextColor (_hdc, crTextColor);

            // Determine the bounds of the selection.
            rcSelect.left = _ptCur.x;
            rcSelect.right = rcSelect.left + dupRun;
            rcSelect.top = yCur;
            rcSelect.bottom = rcSelect.top + pBaseCcs->_yHeight;

            // If current run is selected, fix up _rcClip.
            if (por->IsSelected())
                FixupClipRectForSelection();

            // Clip the rect to the view and current clipping rect.
            IntersectRect(&rcSelect, &rcSelect, &_rcClip);

            RECT * prcClip = fSelectCont ? &_rcClip : &rcSelect;
            if (   !_pdp->HasLongLine() 
                || NeedRenderText(xCur, prcClip, dupRun))
            {
                if (_fDisabled)
                {
                    if (_crForeDisabled != _crShadowDisabled)
                    {
                        //draw the shadow
                        SetTextColor(_hdc, _crShadowDisabled);
                        LSReExtTextOut(&ccs,
                                       _hdc,
                                       xCur + 1,
                                       yCur + 1,
                                       ETO_CLIPPED,
                                       prcClip,
                                       pch,
                                       cch,
                                       lpDxPtr,
                                       cm);
                    }
                    SetTextColor(_hdc, _crForeDisabled);
                }

                LSReExtTextOut(&ccs,
                               _hdc,
                               xCur,
                               yCur,                       
                               ETO_CLIPPED,
                               prcClip,
                               pch,
                               cch,
                               lpDxPtr,
                               cm);
            }
        }

        if (lpDxNew)
            delete lpDxNew;
    }

    _ptCur.x = ((!(kTFlow & fUDirection)) ? _rcClip.right : _rcClip.left);

Cleanup:
//#if DBG==1
#ifdef NEVER
    // We need this only in case of DEBUG. We will assert otherwise.
    // In retail code we dctor of the renderer will unselect currently selected font.
    if (hfontOld != HFONT_INVALID)
        ccs.PopFont(_hdc, hfontOld);
#endif

    _rcClip = rcClipSave;
    return cch;
}

//-----------------------------------------------------------------------------
//
//  Function:   GlyphOut
//
//  Synopsis:   Renders one run of glyphs
//
//  Params:     Same as that for LineServices DrawGlyphs callback
//
//  Returns:    Number of glyphs rendered
//
//  Dev Note:   Any changes made to this function should be reflected in
//              CLSRenderer::TextOut() (as appropriate)
//
//-----------------------------------------------------------------------------
LONG
CLSRenderer::GlyphOut(
    COneRun * por,          // IN was plsrun
    BOOL fStrikeout,        // IN
    BOOL fUnderline,        // IN
    PCGINDEX pglyph,        // IN
    const int* pDx,         // IN was rgDu
    const int* pDxAdvance,  // IN was rgDuBeforeJust
    PGOFFSET pOffset,       // IN was rgGoffset
    PGPROP pVisAttr,        // IN was rgGProp
    PCEXPTYPE pExpType,     // IN was rgExpType
    DWORD cglyph,           // IN
    LSTFLOW kTFlow,         // IN
    UINT kDisp,             // IN
    const POINT* pptRun,    // IN
    PCHEIGHTS heightsPres,  // IN
    long dupRun,            // IN
    long dupLimUnderline,   // IN
    const RECT* pRectClip)  // IN
{
    COLORREF            crTextColor = 0;
    COLORREF            crNewTextColor = 0;
    const CCharFormat * pCF = por->GetCF();
    CComplexRun *       pcr = por->GetComplexRun();
    CCcs                ccs;
    const CBaseCcs *    pBaseCcs;
    RECT                rcClipSave = _rcClip;
    LONG                yDescent = _li._yDescent;
    SCRIPT_CACHE *      psc;
    LONG yCur;

    // LS should not be calling this function for metafiles.
    Assert(!g_fExtTextOutGlyphCrash);
    Assert(!_fEnhancedMetafileDC && !_pDI->IsMetafile());

    FONTIDX hfontOld = SetNewFont(&ccs, por);
    if (hfontOld == HFONT_INVALID)
        goto Cleanup;
    
    if (ShouldSkipThisRun(por, dupRun))
        goto Cleanup;

    pBaseCcs = ccs.GetBaseCcs();
    psc = ccs.GetUniscribeCache();
    
    // This is where this run will be drawn.
    _ptCur.x = pptRun->x - ((kTFlow & fUDirection) ? dupRun - 1 : 0) - GetChunkOffsetX();

    AssertSz((_ptCur.y == (pptRun->y + por->_lsCharProps.dvpPos) || por->GetCF()->_fIsRuby),
             "Our baseline differs from LS baseline!");
    yCur = pptRun->y + por->_lsCharProps.dvpPos;

#if DBG==1
    if (!IsTagEnabled(tagLSPrintDontAdjustContrastForWhiteBackground))
#endif
    if (!GetMarkup()->PaintBackground())
    {
        // If we are part of a print doc and the background is not printed,
        // we conceptually replace the background with white (because most
        // paper is white).  This means that we have to enhance the contrast
        // of bright-colored text on dark backgrounds.

        COLORREF crNewBkColor = RGB(255, 255, 255); // white background
        int      nMinimalLuminanceDifference = 150; // for now

        crNewTextColor = GetTextColor(_hdc);

        // Sujal insists that if both colors are the same (in this case both
        // white), then the second color will be modified.
        ContrastColors(crNewTextColor, crNewBkColor, nMinimalLuminanceDifference);

        // Finally, turn off the higher order bits
        crNewTextColor  = (crNewTextColor & CColorValue::MASK_COLOR) | 0x02000000;

        crTextColor = SetTextColor (_hdc, crNewTextColor);
    }

    AssertSz(pCF, "CLSRenderer::GlyphOut: We better have char format here");
    AssertSz(pcr, "CLSRenderer::GlyphOut: We better have CComplexRun here");

    if (_pLS->IsAdornment())
    {
        LONG yTextHeight = _li._yHeight - _li.GetYTop();

        // If the first line in the LI is a frame line, then its _yDescent
        // value is garbage. This also means that we will not center WRT
        // the text following the frame line. However, this is much better
        // than before when we did not render the bullet at all when the
        // first line in a LI was a frame line.(SujalP)
        if (_li.IsFrame())
        {
            yDescent = 0;
        }

        // Center the bullet in the ascent of the text line only if
        // the line of text is smaller than the bullet. This adjustment
        // keeps the bullets visible, but tends to keep them low on the
        // line for large text fonts.
        if (pBaseCcs->_yHeight - pBaseCcs->_yDescent > yTextHeight - yDescent)
        {
            yCur += ((pBaseCcs->_yHeight - pBaseCcs->_yDescent) -
                         (yTextHeight - yDescent)) / 2;
            _ptCur.y = yCur;
        }
    }

    if (!pCF->IsVisibilityHidden())
    {
        int *pDxNew = NULL;
        const int *pDxPtr = pDx;
        long lGridOffset = 0;

        if (pCF->HasCharGrid(por->_fInnerCF) && por->_pPF)
        {
            switch (por->GetPF()->GetLayoutGridType(por->_fInnerPF))
            {
            case styleLayoutGridTypeStrict:
            case styleLayoutGridTypeFixed:
                // Only characters which has its own grid cell need 
                // special processing. Other characters are handled by 
                // LS installed LayoutGrid object.
                if (por->IsOneCharPerGridCell())
                {
                    pDxNew = new int[cglyph];
                    if (!pDxNew)
                        goto Cleanup;
                    pDxPtr = pDxNew;

                    long durThisChar = 0;
                    long durNextChar = 0;
                    long lThisDoubleGridOffset = 0;
                    long lError = 0;
                    unsigned int nGlyphIndex = 0;

                    ccs.Include(por->_pchBase[0], durThisChar);
                    lThisDoubleGridOffset = pDx[0] - durThisChar;
                    lGridOffset = lThisDoubleGridOffset/2;

                    for (unsigned int i = 0; i < cglyph-1; i++)
                    {
                        if (pDx[i+1] != 0)
                        {
                            ccs.Include(por->_pchBase[i+1], durNextChar);
                            long lNextDoubleGridOffset = pDx[i+1] - durNextChar;

                            // The width of the this char is essentially it's width
                            // plus the remaining space ahead of it in its grid cell,
                            // plus the space between the beginning of the next grid
                            // cell and the next character.
                            pDxNew[nGlyphIndex] = pDx[nGlyphIndex] - (lThisDoubleGridOffset - lNextDoubleGridOffset + lError)/2;
                            while (nGlyphIndex != i)
                                pOffset[++nGlyphIndex].du -= (lThisDoubleGridOffset + lNextDoubleGridOffset - lError)/2;
                            lError = (lThisDoubleGridOffset - lNextDoubleGridOffset + lError)%2;

                            lThisDoubleGridOffset = lNextDoubleGridOffset;
                            durThisChar = durNextChar;
                            nGlyphIndex = i+1;
                        }
                        else
                        {
                            pDxNew[i+1] = 0;
                        }
                    }
                    pDxNew[nGlyphIndex] = pDx[nGlyphIndex] - (lThisDoubleGridOffset + lError)/2;
                    while (nGlyphIndex != cglyph-1)
                        pOffset[++nGlyphIndex].du -= (lThisDoubleGridOffset - lError)/2;
                }
                break;

            case styleLayoutGridTypeLoose:
            default:
                // In loose grid mode (default mode) the width of a char is 
                // width of its grid cell.
                break;
            }
        }

        Assert(GetBkMode(_hdc) == TRANSPARENT);

        if (_pLS->_fHasVerticalAlign)
            yCur += por->_yProposed;
        else
            yCur += _li._yHeight - yDescent + pBaseCcs->_yDescent - pBaseCcs->_yHeight;

        BOOL fSelectCont = FALSE;

        if (por->IsSelected())
        {
            // Find the next one run that is not an antisynth
            COneRun *porNext = por->_pNext;
            while (   porNext
                   && porNext->IsAntiSyntheticRun())
            {
                porNext = porNext->_pNext;
            }

            fSelectCont = porNext ? porNext->IsSelected()
                                  : FALSE;

            // In RTL text a character actually overhangs the previous character
            porNext = por->_pPrev;
            while (   porNext
                   && porNext->IsAntiSyntheticRun())
            {
                porNext = porNext->_pPrev;
            }

            if (   porNext 
                && porNext->IsSelected())
            {
                fSelectCont = TRUE;
            }
        }

        //
        // If ellipsis is needed in the line, establish truncation point
        // and truncate text if necessary.
        //
        if (_fHasEllipsis)
        {
            DWORD cglyphOld = cglyph;
            BOOL fRTLLayout = _pdp->IsRTLDisplay();
            BOOL fReverse   = fRTLLayout;
            if (por->_pComplexRun)
            {
                fReverse =    (fRTLLayout && !por->_pComplexRun->GetAnalysis()->fRTL)
                           || (!fRTLLayout && por->_pComplexRun->GetAnalysis()->fRTL);
            }

            cglyphOld = cglyph;
            PrepareForEllipsis(por, cglyph, dupRun, lGridOffset, fReverse, pDxPtr, &cglyph);
            if (cglyph == 0)
                goto Cleanup;   // Nothing to render

            if (fReverse && cglyphOld != cglyph)
            {
                pglyph += cglyphOld - cglyph;
                pDxAdvance += cglyphOld - cglyph;
                pDxPtr += cglyphOld - cglyph;
                pOffset += cglyphOld - cglyph;
            }
        }

        if (!fSelectCont)
        {
            if (_fDisabled)
            {
                if (_crForeDisabled != _crShadowDisabled)
                {
                    //draw the shadow
                    SetTextColor(_hdc, _crShadowDisabled);
                    ScriptTextOut(_hdc,
                                  psc,
                                  _ptCur.x + 1 + lGridOffset,
                                  yCur + 1,
                                  ETO_CLIPPED,
                                  &_rcClip,
                                  pcr->GetAnalysis(),
                                  NULL,
                                  0,
                                  pglyph,
                                  cglyph,
                                  pDxAdvance,
                                  pDxPtr,
                                  pOffset);
                }
                SetTextColor(_hdc, _crForeDisabled);
            }

            ScriptTextOut(_hdc,
                          psc,
                          _ptCur.x + lGridOffset,
                          yCur,
                          ETO_CLIPPED,
                          &_rcClip,
                          pcr->GetAnalysis(),
                          NULL,
                          0,
                          pglyph,
                          cglyph,
                          pDxAdvance,
                          pDxPtr,
                          pOffset);
        }

        // If the run is selected, then we need to set up selection colors.
        if (por->IsSelected())
        {
            RECT rcSelect;
            COLORREF crTextColor = por->GetCF()->_ccvTextColor.GetColorRef();

            SetTextColor (_hdc, crTextColor);

            // Determine the bounds of the selection.
            rcSelect.left = _ptCur.x;
            rcSelect.right = rcSelect.left + dupRun;
            rcSelect.top = yCur;
            rcSelect.bottom = rcSelect.top + pBaseCcs->_yHeight;

            // If current run is selected, fix up _rcClip.
            if (por->IsSelected())
                FixupClipRectForSelection();

            // Clip the rect to the view and current clipping rect.
            IntersectRect(&rcSelect, &rcSelect, &_rcClip);

            if (_fDisabled)
            {
                if (_crForeDisabled != _crShadowDisabled)
                {
                    //draw the shadow
                    SetTextColor(_hdc, _crShadowDisabled);
                    ScriptTextOut(_hdc,
                                  psc,
                                  _ptCur.x + 1 + lGridOffset,
                                  yCur + 1,
                                  ETO_CLIPPED,
                                  fSelectCont ? &_rcClip : &rcSelect,
                                  pcr->GetAnalysis(),
                                  NULL,
                                  0,
                                  pglyph,
                                  cglyph,
                                  pDxAdvance,
                                  pDxPtr,
                                  pOffset);
                }
                SetTextColor(_hdc, _crForeDisabled);
            }

            ScriptTextOut(_hdc,
                          psc,
                          _ptCur.x + lGridOffset,
                          yCur,
                          ETO_CLIPPED,
                          fSelectCont ? &_rcClip : &rcSelect,
                          pcr->GetAnalysis(),
                          NULL,
                          0,
                          pglyph,
                          cglyph,
                          pDxAdvance,
                          pDxPtr,
                          pOffset);
        }

        if (pDxNew)
            delete pDxNew;
    }

    _ptCur.x = ((kTFlow & fUDirection) ? _rcClip.left : _rcClip.right);

Cleanup:
//#if DBG==1
#ifdef NEVER
    // We need this only in case of DEBUG. We will assert otherwise.
    // In retail code we dctor of the renderer will unselect currently selected font.
    if (hfontOld != HFONT_INVALID)
        ccs.PopFont(_hdc, hfontOld);
#endif

    _rcClip = rcClipSave;
    return cglyph;
}

//+----------------------------------------------------------------------------
//
// Member:      CLSRenderer::FixupClipRectForSelection()
//
// Synopsis:    This function shrinks the clip rect when we have a selection
//              in order to avoid rendering selection out of bounds.
//              ONLY TO BE CALLED WHEN THERE IS A SELECTION !!!!
//
//-----------------------------------------------------------------------------

void CLSRenderer::FixupClipRectForSelection()
{
    long xOrigin;

    xOrigin = _rcView.left  + _xRelOffset;

    // RTL display may have a negative _rcView.left, but the origin is at zero
    if (_pdp->IsRTLDisplay() && _rcView.left < 0)
    {
        xOrigin -= _rcView.left;
    }

    _pdp->GetClipRectForLine(&_rcClip, _ptCur.y, xOrigin,
                             (CLineCore *)&_li, (CLineOtherInfo *)&_li);
    IntersectRect(&_rcClip, &_rcClip, _pDI->ClipRect());
}


//+----------------------------------------------------------------------------
//
// Member:      CLSRenderer::AdjustColors()
//
// Synopsis:    This function adjusts colors for selection
//
//-----------------------------------------------------------------------------

void CLSRenderer::AdjustColors(const CCharFormat* pCF,    // IN
                               COLORREF& crTextColor,  // IN/OUT
                               COLORREF& crBkColor)    // IN/OUT
{
    COLORREF crNewTextColor, crNewBkColor;

    // TODO (MohanB) Shouldn't this check the editability of the element instead?
    if (GetMarkup()->IsEditable())
    {
        // If we are in edit mode, then we just invert the text color
        // and the back color and draw in opaque mode. We cannot rely
        // on the hdc to provide us accurate bk color info, (because
        // bk could have been painted earlier and we are painting the
        // text in transparent mode, so the bk color may be invalid)
        // Hence, lets get the TRUE bk color.

        crNewTextColor = ~crTextColor;
        if (crBkColor != COLORREF_NONE)
        {
            crNewBkColor = ~crBkColor;
        }
        else
        {
            crNewBkColor = crTextColor;
        }

        ContrastColors (crNewTextColor, crNewBkColor, 100);

        // Finally, turn off the higher order bits
        crNewTextColor &= CColorValue::MASK_COLOR;
        crNewBkColor   &= CColorValue::MASK_COLOR;
    }
    else
    {
        Assert(pCF);

        crNewTextColor = GetSysColor (COLOR_HIGHLIGHTTEXT);
        crNewBkColor   = GetSysColor (COLOR_HIGHLIGHT);

        if (((CCharFormat *)pCF)->SwapSelectionColors())
        {
            COLORREF crTemp;

            crTemp = crNewBkColor;
            crNewBkColor = crNewTextColor;
            crNewTextColor = crTemp;
        }
    }

    crNewTextColor = GetNearestColor (_hdc, crNewTextColor);
    crNewBkColor   = GetNearestColor (_hdc, crNewBkColor);

    crTextColor = crNewTextColor;
    crBkColor = crNewBkColor;
}


/*
 *  CLSRenderer::SetNewFont (BOOL fJustRestore)
 *
 *  @mfunc
 *      Select appropriate font and color in the _hdc based on the
 *      current character format. Also sets the background color
 *      and mode.
 *
 *  @rdesc
 *      Font index if success
 */
FONTIDX
CLSRenderer::SetNewFont(CCcs * pccs, COneRun *por)
{
    const CCharFormat *pCF = por->GetCF();
    COLORREF cr;
    FONTIDX hfontOld = HFONT_INVALID;
    
    Assert(pCF);

    // get information about disabled

    if(pCF->_fDisabled)
    {
        _fDisabled = TRUE;

        _crForeDisabled   = GetSysColorQuick(COLOR_3DSHADOW);
        _crShadowDisabled = GetSysColorQuick(COLOR_3DHILIGHT);

        if (   _crForeDisabled == CLR_INVALID
            || _crShadowDisabled == CLR_INVALID
           )
        {
            _crForeDisabled   =
            _crShadowDisabled = GetSysColorQuick(COLOR_GRAYTEXT);
        }
    }
    else
    {
        _fDisabled = FALSE;
    }

    // Retrieves new font to use
    Assert(!_pDI->_hic.IsEmpty());
    Assert(_hdc != NULL);

   if (!_pLS->GetCcs(pccs, por, _hdc, _pDI))
        goto Cleanup;

    //
    // 1. Select font in _hdc
    //
    AssertSz(pccs->GetBaseCcs()->HasFont(), "CLSRenderer::SetNewFont pBaseCcs->_hfont is NULL");

    hfontOld = pccs->PushFont(_hdc);

    //
    // 2. Select the pen color
    //
    cr = pCF->_ccvTextColor.GetColorRef();


    if(cr == RGB(255,255,255))
    {
        const INT nTechnology = GetDeviceCaps(_hdc, TECHNOLOGY);

        if(nTechnology == DT_RASPRINTER || nTechnology == DT_PLOTTER)
        {
            cr = RGB(0,0,0);
        }
    }
    SetTextColor(_hdc, cr);


    //
    // 3. Set up the drawing mode.
    //
    SetBkMode(_hdc, TRANSPARENT);

Cleanup:
    return hfontOld;
}


/*
 *  CLSRenderer::RenderStartLine()
 *
 *  @mfunc
 *      Render bullet if at start of line
 *
 *  @rdesc
 *      TRUE if this method succeeded
 */
BOOL CLSRenderer::RenderStartLine(COneRun *por)
{
    if (_li._fHasBulletOrNum)
    {
        if (por->GetPF()->GetListing().HasAdornment())
        {
            RenderBullet(por);
        }
        else
        {
#if DBG==1
            {
                CTreeNode *pNode = por->Branch();
                BOOL fFound = FALSE;
                
                while(pNode && !SameScope(pNode, _pFlowLayout->ElementContent()))
                {
                    if (IsGenericListItem(pNode))
                    {
                        fFound = TRUE;
                        break;
                    }
                    pNode = pNode->Parent();
                }
                if (!fFound)
                {
                    fFound = por->_ptp->IsPointer();
                }
                AssertSz(fFound, "Hmm... this needs arye's look forward hack!");
            }
#endif
        }
#if 0
        else
        // NOTE: Arye. This is very hackish, but efficient for now.
        // What's this? We have a bullet bit set on the line, but
        // the immediate paragraph format doesn't have it? This must
        // mean that there is more than one paragraph on this line,
        // a legal state when aligned images occupy an entire paragraph.
        // Get the paraformat from the LAST run in the line paragraph instead.
        {
            // Briefly make it look like we're a little further along than
            // we really are so that we can render the bullet properly.
            por->Advance(_li._cch);

            if (por->GetPF()->GetListing(SameScope(por->Branch(), _pFlowLayout->Element())).HasAdornment())
            {
                RenderBullet(por);
            }
            // If we still can't find a paraformat with a bullet,
            // turn of the bit.
            else
            {
                _li._fHasBulletOrNum = FALSE;
            }
            por->Advance(-long(_li._cch));
        }
#endif
    }

    return TRUE;
}

/*
 *  CLSRenderer::RenderBullet()
 *
 *  @mfunc
 *      Render bullet at start of line
 *
 *  @rdesc
 *      TRUE if this method succeeded
 */
BOOL CLSRenderer::RenderBullet(COneRun *por)
{
    const CParaFormat *pPF;
    const CCharFormat *pCF;
    const CCharFormat *pCFLi;
    CTreeNode * pNodeLI;
    CTreeNode * pNodeFormatting = por->Branch();
    CMarkup *   pMarkup = _pLS->_treeInfo._pMarkup;
    BOOL        fRTLBullet;
    LONG        dxOffset = 0;

    //
    // Consider: <LI><P><B>text
    // The bold is the current branch, so we want to find the LI that's causing
    // the bullet, and accumulate margin/borders/padding for all nodes in between.
    //
    pNodeLI = pMarkup->SearchBranchForCriteriaInStory(pNodeFormatting, IsListItemNode);
    // Windows bug #546122: We may get pNodeLI == NULL in case of weird overlapping.
    if (!pNodeLI)
        goto Cleanup;

    pPF        = pNodeFormatting->GetParaFormat();
    pCF        = pNodeFormatting->GetCharFormat();
    pCFLi      = pNodeLI->GetCharFormat();
    fRTLBullet = pNodeLI->GetParaFormat()->_fRTL;

    // do not display the bullet if the list item is hidden
    if (pCFLi->IsVisibilityHidden() || pCFLi->IsDisplayNone())
        return TRUE;

    // we should be here only if the current paragraph has bullet or number.
    AssertSz(pPF->GetListing().HasAdornment(),
             "CLSRenderer::RenderBullet called for non-bullet");

    //
    // If we have nested block elements, we need to go back by
    // by margin, padding & border space of the nested block elements
    // under the LI to draw the bullet, unless the list position is "inside".
    // (meaning the bullet should be drawn inside the borders/padding)
    //
    if (pPF->_bListPosition != styleListStylePositionInside)
    {
        dxOffset = pPF->GetBulletOffset(GetCalcInfo()) +
                        pPF->GetNonBulletIndent(GetCalcInfo(), FALSE);

        if (pCF->_fPadBord)
        {
            long        xBorderLeft, xPaddingLeft, xBorderRight, xPaddingRight;
            CTreeNode * pNodeStart = pNodeFormatting;

            // If the formatting node itself has layout, then its borders
            // and padding are inside, so start accumulating from its parent.
            if(pNodeFormatting->ShouldHaveLayout())
                pNodeStart = pNodeFormatting->Parent();
                
            pNodeStart->Element()->ComputeHorzBorderAndPadding(
                GetCalcInfo(), pNodeStart, pNodeLI->Parent()->Element(),
                &xBorderLeft, &xPaddingLeft, &xBorderRight, &xPaddingRight);

            if (!fRTLBullet)
            {
                dxOffset += xBorderLeft + xPaddingLeft;
            }
            else
            {
                dxOffset += xBorderRight + xPaddingRight;
            }
        }
        dxOffset = max(int(dxOffset), _pci->DeviceFromTwipsX(LIST_FIRST_REDUCTION_TWIPS));
    }

    if (!pPF->GetImgCookie() || !RenderBulletImage(pPF, dxOffset))
    {
        TCHAR achBullet[NUMCONV_STRLEN];
        GetListIndexInfo(pNodeLI, por, pCFLi, achBullet);
        por->_pchBase = por->SetString(achBullet);
        if (por->_pchBase == NULL)
            goto Cleanup;
        por->_lscch   = _tcslen(achBullet);
        _pLS->CHPFromCF(por, pCFLi);
        return RenderBulletChar(pNodeLI, dxOffset, fRTLBullet);
    }

Cleanup:
    return TRUE;
}

BOOL
CLSRenderer::RenderBulletImage(const CParaFormat *pPF, LONG dxOffset)
{
    SIZE sizeImg;
    RECT imgRect;
    CMarkup * pMarkup = _pFlowLayout->GetOwnerMarkup();
    CDoc    * pDoc = pMarkup->Doc();
    CImgCtx * pImgCtx = pDoc->GetUrlImgCtx(pPF->_lImgCookie);
    IMGANIMSTATE * pImgAnimState = _pFlowLayout->Doc()->GetImgAnimState(pPF->_lImgCookie);

    if (!pImgCtx || !(pImgCtx->GetState(FALSE, &sizeImg) & IMGLOAD_COMPLETE))
        return FALSE;

    // The sizeImg obtained from getState() assumed to be in OM pixels
    _pDI->DeviceFromDocPixels(sizeImg, sizeImg);

    if(!_li._fRTLLn)
    {
        imgRect.right  = min(_ptCur.x, _ptCur.x - dxOffset + sizeImg.cx);
        imgRect.left   = imgRect.right - sizeImg.cx;
    }
    else
    {
        imgRect.left  = max(_ptCur.x, _ptCur.x + dxOffset - sizeImg.cx);
        imgRect.right = imgRect.left + sizeImg.cx;
    }
    imgRect.top    = _ptCur.y + ( _li._yHeight - _li._yDescent +
                     _li._yBeforeSpace - sizeImg.cy) / 2;
    imgRect.bottom = imgRect.top + sizeImg.cy;

    //obtain physically-clipped hdc (IE bug 104651)
    XHDC hdcClipped = _pDI->GetDC(TRUE);
    
    if (pImgAnimState)
    {
        pImgCtx->DrawFrame(hdcClipped, pImgAnimState, &imgRect, NULL, NULL, _pDI->DrawImageFlags());
    }
    else
    {
        pImgCtx->DrawEx(hdcClipped, &imgRect, _pDI->DrawImageFlags());
    }
    
    return TRUE;
}

BOOL
CLSRenderer::RenderBulletChar(CTreeNode * pNodeLi, LONG dxOffset, BOOL fRTLOutter)
{
    BOOL fRet = TRUE;

    LONG  xSave = _ptCur.x;
    LONG  ySave = _ptCur.y;
    DWORD dwFlags  = _dwFlags();
    long  upStartAnm;
    long  upLimAnm;
    long  upStartText;
    long  upTrailingText;
    long  upLimText;
    POINT ptLS;
    CMarginInfo marginInfo;
    LSLINFO     lslinfo;
    LSTEXTCELL lsTextCell;
    LONG cpLastChar;
    LSERR lserr;
    HRESULT hr;

    _pLS->SetRenderer(this, GetBreakLongLines(_ptpCurrent->GetBranch()), pNodeLi);
    InitForMeasure(MEASURE_BREAKATWORD);
    LSDoCreateLine(GetCp(), NULL, &marginInfo,
                   (!fRTLOutter) ? _li._xLeft : _li._xRight,
                   NULL, FALSE, &lslinfo);
    
    if (!_pLS->_plsline)
    {
        fRet = FALSE;
        goto Cleanup;
    }

    lserr = LsQueryLineDup(_pLS->_plsline, &upStartAnm, &upLimAnm,
                           &upStartText, &upTrailingText, &upLimText);
    if (lserr != lserrNone)
    {
        fRet = FALSE;
        goto Cleanup;
    }

    cpLastChar = lslinfo.cpLim - 2;
    AssertSz(cpLastChar >= 0, "There should be atleast one char in the bullet string!");
    
    _cpStartRender = GetCp();
    _cpStopRender  = cpLastChar;
    _xChunkOffset  = CalculateChunkOffsetX();

    hr = _pLS->QueryLineCpPpoint(cpLastChar, FALSE, NULL, &lsTextCell);
    if (hr)
    {
        fRet = FALSE;
        goto Cleanup;
    }

    if (pNodeLi->GetParaFormat()->_bListPosition != styleListStylePositionInside)
    {
        dxOffset += upLimText - upStartAnm;
        dxOffset -= lsTextCell.dupCell;
    }
    else
    {
        Assert(dxOffset == 0);
        dxOffset = max((LONG)lsTextCell.dupCell, (LONG)_pci->DeviceFromTwipsX(LIST_FIRST_REDUCTION_TWIPS));
    }

    if (!fRTLOutter)
    {
        if(!_li._fRTLLn)
            _ptCur.x -= dxOffset;           // basically _xLeft - dxOffset;
        // TODO (paulnel, track bug 4345) We have a mixed direction problem here.
        //                  On which side should the bullet be rendered?
        else
            _ptCur.x -= _li._xWidth + (dxOffset - lsTextCell.dupCell);
    }
    else
    {
        if(_li._fRTLLn)
            _ptCur.x += dxOffset;           // basically _xRight + dxOffset;
        // TODO (paulnel, track bug 4345) We have a mixed direction problem here.
        //                  On which side should the bullet be rendered?
        else
            _ptCur.x += _li._xWidth + (dxOffset - lsTextCell.dupCell);
    }

    _rcClip = *_pDI->ClipRect();

    ptLS = _ptCur;

#ifdef UNIX //IEUNIX draw bullets
    LPCWSTR pwchRun;
    DWORD  cchRun;
    COneRun *por = FetchLIRun(GetCp(), &pwchRun, &cchRun);
    WCHAR chUnixBulletStyle = por->_pchBase[0];
    if(chUnixBulletStyle == chDisc || chUnixBulletStyle == chCircle ||
       chUnixBulletStyle == chSquare )
    {
        CCcs ccs;
        CBaseCcs *pBaseCcs;
        int x = _ptCur.x;
        int y;
        int xWidth = pccs->GetBaseCcs()->_xAveCharWidth;
        COLORREF crText = GetTextColor(_hdc);
        HPEN hPen = CreatePen(PS_SOLID, 1, crText);
        HPEN hOldPen = (HPEN)SelectObject(_hdc, hPen);

        if (!SetNewFont(&ccs, por))
            goto Cleanup;

        pBaseCcs = ccs.GetBaseCcs();
        y = _ptCur.y + _li._yHeight - _li._yDescent +
                pBaseCcs->_yDescent - pBaseCcs->_yHeight - pBaseCcs->_yOffset;
        
        switch (chUnixBulletStyle)
        {
            case chDisc:
            {
                HBRUSH hNewBrush = CreateSolidBrush(crText);
                HBRUSH hOldBrush = (HBRUSH)SelectObject(_hdc, hNewBrush);
                Ellipse(_hdc, x, y, x+xWidth, y+xWidth);
                SelectObject(_hdc, hOldBrush);
                DeleteObject(hNewBrush);
                break;
            }
            case chCircle:
            {
                Arc(_hdc, x, y, x+xWidth, y+xWidth, x, y, x, y);
                break;
            }
            default: // must be square
            {
                RECT rc = {x, y, x+xWidth, y+xWidth};
                HBRUSH hNewBrush = CreateSolidBrush(crText);
                FillRect(_hdc, &rc, hNewBrush);
                DeleteObject(hNewBrush);
                break;
            }
        }
        SelectObject(_hdc, hOldPen);
        DeleteObject(hPen);
    }
    else // draw number
#endif // UNIX
    LsDisplayLine(_pLS->_plsline,   // The line to be drawn
                  &ptLS,            // The point at which to draw the line
                  1,                // Draw in transparent mode
                  &_rcClip          // The clipping rectangle
                 );
    // Restore render vars to continue with remainder of line.
    _dwFlags() = dwFlags;
    _ptCur.y = ySave;
    _ptCur.x = xSave;

Cleanup:
    _pLS->DiscardLine();

    return fRet;
}

void
CLSRenderer::GetListIndexInfo(CTreeNode *pLINode,
                              COneRun *por,
                              const CCharFormat *pCFLi,
                              TCHAR achNumbering[NUMCONV_STRLEN])
{
    LONG len;
    CListValue LI;

    Assert(pLINode);

    GetValidValue(pLINode, _pLS->_pMarkup->FindMyListContainer(pLINode), _pLS->_pMarkup,
                  _pFlowLayout->ElementContent(), &LI);
    
    switch ( LI._style )
    {
        case styleListStyleTypeNone:
        case styleListStyleTypeNotSet:
            *achNumbering = L'\0';
            break;
        case styleListStyleTypeUpperAlpha:
            NumberToAlphaUpper(LI._lValue, achNumbering);
            _pLS->GetCFNumber(por, pCFLi);      // get ccs for numbered bullet
            break;
        case styleListStyleTypeLowerAlpha:
            NumberToAlphaLower(LI._lValue, achNumbering);
            _pLS->GetCFNumber(por, pCFLi);      // get ccs for numbered bullet
            break;
        case styleListStyleTypeUpperRoman:
            NumberToRomanUpper(LI._lValue, achNumbering);
            _pLS->GetCFNumber(por, pCFLi);      // get ccs for numbered bullet
            break;
        case styleListStyleTypeLowerRoman:
            NumberToRomanLower(LI._lValue, achNumbering);
            _pLS->GetCFNumber(por, pCFLi);      // get ccs for numbered bullet
            break;
        case styleListStyleTypeDecimal:
            NumberToNumeral(LI._lValue, achNumbering);
            _pLS->GetCFNumber(por, pCFLi);      // get ccs for numbered bullet
            break;
        case styleListStyleTypeDisc:
            achNumbering[0] = chDisc;
            achNumbering[1] = L'\0';
            _pLS->GetCFSymbol(por, chDisc, pCFLi);
            break;
        case styleListStyleTypeCircle:
            achNumbering[0] = chCircle;
            achNumbering[1] = L'\0';
            _pLS->GetCFSymbol(por, chCircle, pCFLi);
            break;
        case styleListStyleTypeSquare:
            achNumbering[0] = chSquare;
            achNumbering[1] = L'\0';
            _pLS->GetCFSymbol(por, chSquare, pCFLi);
            break;
        default:
            AssertSz(0, "Unknown numbering style.");
    }
    len = _tcslen(achNumbering);
    if (len > 1 && por->GetPF()->HasRTL(por->_fInnerPF))
    {
        // If we have RTL numbering run it through the bidi algorithm and order
        // the characters visually.
        CBidiLine * pBidiLine = new CBidiLine(TRUE, len, achNumbering);

        if (pBidiLine != NULL)
        {
            TCHAR achNumberingVisual[NUMCONV_STRLEN];

            pBidiLine->LogicalToVisual(TRUE, len, achNumbering, achNumberingVisual);
            CopyMemory(achNumbering, achNumberingVisual, len  * sizeof(WCHAR));
            delete pBidiLine;
        }
    }
    achNumbering[len] = CLineServices::s_aSynthData[CLineServices::SYNTHTYPE_SECTIONBREAK].wch;
    achNumbering[len+1] = '\0';
}


COneRun *
CLSRenderer::FetchLIRun(
    LSCP lscp,          // IN
    LPCWSTR* ppwchRun,  // OUT
    DWORD* pcchRun)     // OUT
{
    COneRun *por = _pLS->_listCurrent._pHead;
    Assert(por);
    Assert(   lscp >= por->_lscpBase
           && lscp < por->_lscpBase + por->_lscch
          );
    LONG cpOffset = lscp - por->_lscpBase;
    *ppwchRun = por->_pchBase;
    *pcchRun = por->_lscch;
    if (cpOffset > 0)
    {
        *ppwchRun += cpOffset;
        *pcchRun -= cpOffset;
    }
    Assert(*pcchRun > 0);
    por->CheckForUnderLine(_pLS->_fIsEditable);
    
    return por;
}


//+---------------------------------------------------------------------------
//
//  Function:   LSDeinitUnderlinePens
//
//  Synopsis:   Releases any pen still stored in the cache
//
//----------------------------------------------------------------------------
void
LSDeinitUnderlinePens(
    THREADSTATE *   pts)
{
    Assert(pts);

    if (!pts->hpenUnderline)
        return;

    DeleteObject(pts->hpenUnderline);

    return;
}

//-----------------------------------------------------------------------------
//
//  Function:   Drawunderline
//
//  Synopsis:   Draws an underline
//
//  Params:     Same as that passed by lineservices to drawunderline
//
//  Returns:    LSERR
//
//-----------------------------------------------------------------------------
LSERR
CLSRenderer::DrawUnderline(
    COneRun *por,           // IN
    UINT kUlBase,           // IN
    const POINT* pptStart,  // IN
    DWORD dupUl,            // IN
    DWORD dvpUl,            // IN
    LSTFLOW kTFlow,         // IN
    UINT kDisp,             // IN
    const RECT* prcClip)    // IN
{
    LSERR lserr = lserrNone;

    if (   por->Cp() >= _cpStartRender
        && por->Cp() <  _cpStopRender
       )
    {
        const CCharFormat  *pCF = por->GetCF();
        POINT ptStart           = *pptStart;
        CComplexRun *pCcr       = por->GetComplexRun();
        BOOL  fUnderline        = (pCcr && pCcr->_RenderStyleProp._fStyleUnderline);
        BOOL  fUnderlineAbove   = FALSE;
        BOOL  fOverline         = pCF->_fOverline  || (pCcr && pCcr->_RenderStyleProp._fStyleOverline);
        BOOL  fLineThrough      = pCF->_fStrikeOut || (pCcr && pCcr->_RenderStyleProp._fStyleLineThrough);

        if (pCF->_fUnderline)
        {
            const LANGID langid = PRIMARYLANGID(LANGIDFROMLCID(pCF->_lcid));
            BOOL fAbove =    (pCF->_bTextUnderlinePosition == styleTextUnderlinePositionAbove)
                          || (   pCF->HasVerticalLayoutFlow()
                              && (pCF->_bTextUnderlinePosition == styleTextUnderlinePositionAuto)
                              && (   (langid == LANG_JAPANESE) 
                                  || (langid == 0 && GetMarkup()->GetFamilyCodePage() == CP_JPN_SJ)
                                 )
                             );
            fUnderline = fUnderline || !fAbove;
            fUnderlineAbove = fUnderlineAbove || fAbove;
        }

        CCcs ccs;
        const CBaseCcs *pBaseCcs;
        COLORREF crTextColor = por->GetCF()->_ccvTextColor.GetColorRef();

        FONTIDX hfontOld = SetNewFont(&ccs, por);
        if (hfontOld == HFONT_INVALID)
        {
            lserr = lserrOutOfMemory;
            goto Cleanup;
        }
        pBaseCcs = ccs.GetBaseCcs();

        if (por->IsSelected())
        {
            SetTextColor (_hdc, crTextColor);
        }

        ptStart.x -= GetChunkOffsetX();
        ptStart.y += por->_lsCharProps.dvpPos;

        // draw line-through
        if (fLineThrough)
        {
            POINT pt       = ptStart;
            CColorValue cv = por->IsSelected() 
                             ? ((pCcr && pCcr->_RenderStyleProp._ccvDecorationColor.IsDefined())
                                ? pCcr->_RenderStyleProp._ccvDecorationColor
                                : GetTextColor(_hdc) )
                             : por->GetTextDecorationColor(TD_LINETHROUGH);
            LONG dwWidth   = max(1L, LONG(((pBaseCcs->_yHeight / 10) / 2) * 2 + 1 )); // must be odd
            
            if (_pLS->_fHasVerticalAlign)
            {
                pt.y += por->_yProposed + por->_yObjHeight / 2;
            }
            else
            {
                pt.y += _li._yHeight - _li._yDescent + 
                        pBaseCcs->_yDescent - (pBaseCcs->_yHeight + 1) / 2;
            }
            
            DrawEnabledDisabledLine(cv, kUlBase, &pt, dupUl, dwWidth, kTFlow, kDisp, prcClip);
        }

        // draw overline
        if (fOverline || fUnderlineAbove)
        {
            POINT pt       = ptStart;
            CColorValue cv = por->IsSelected() 
                             ? ((pCcr && pCcr->_RenderStyleProp._ccvDecorationColor.IsDefined())
                                ? pCcr->_RenderStyleProp._ccvDecorationColor
                                : GetTextColor(_hdc) ) 
                             : por->GetTextDecorationColor(fUnderlineAbove ? TD_UNDERLINE : TD_OVERLINE);

            if (_pLS->_fHasVerticalAlign)
            {
                pt.y += por->_yProposed;
            }
            else
            {
                pt.y += _li._yHeight - _li._yDescent + pBaseCcs->_yDescent - pBaseCcs->_yHeight;
            }

            DrawEnabledDisabledLine(cv, kUlBase, &pt, dupUl, dvpUl, kTFlow, kDisp, prcClip);
        }

        // draw underline
        if (fUnderline)
        {
            POINT pt       = ptStart;
            CColorValue cv = (pCcr && pCcr->_RenderStyleProp._ccvDecorationColor.IsDefined())
                             ? pCcr->_RenderStyleProp._ccvDecorationColor
                             : (por->IsSelected()) 
                               ? GetTextColor(_hdc) 
                               : por->GetTextDecorationColor(TD_UNDERLINE);

            if (_pLS->_fHasVerticalAlign)
            {
                pt.y += por->_yProposed + por->_yObjHeight - (pBaseCcs->_yDescent + 1) / 2;
            }
            else
            {
                // NOTE (t-ramar): Since we are using _li._yTxtDescent here, this causes a bit of
                // strangeness with underlining of Ruby pronunciation text. Basically, since the pronunciation
                // text is 50% the size of the base text (_li._yTxtDescent is usually based on the base text)
                // underlining of the pronunciation text will appear a little too low
                pt.y += _li._yHeight - _li._yDescent + _li._yTxtDescent / 2;
            }

            // NOTE(SujalP): Some fonts may have no descent in which we can show the
            // underline, and we may end up with pt.y being below the line. So adjust
            // the underline such that it is always within the line.
            if (pt.y >= pptStart->y + _li.GetYBottom())
                pt.y = pptStart->y + _li.GetYBottom() - 1;
            

            if(  pCcr && pCcr->_RenderStyleProp._fStyleUnderline 
                 && (pCcr->_RenderStyleProp._underlineStyle == styleTextUnderlineStyleWave) )
                 DrawEnabledDisabledLine(cv, CFU_SQUIGGLE, &pt, dupUl, dvpUl, kTFlow, kDisp, prcClip);
            else
                 DrawEnabledDisabledLine(cv, kUlBase, &pt, dupUl, dvpUl, kTFlow, kDisp, prcClip);

        }
//#if DBG==1
#ifdef NEVER
        // We need this only in case of DEBUG. We will assert otherwise.
        // In retail code we dctor of the renderer will unselect currently selected font.
        Assert(hfontOld != HFONT_INVALID);
        ccs.PopFont(_hdc, hfontOld);
#endif
    }

Cleanup:
    return lserr;
}

//-----------------------------------------------------------------------------
//
//  Function:   DrawEnabledDisabledLine
//
//  Synopsis:   Draws an enabled or a disabled line at the specified coordinates
//
//  Returns:    LSERR
//
//-----------------------------------------------------------------------------
LSERR
CLSRenderer::DrawEnabledDisabledLine(
    const CColorValue & cv,     // IN
    UINT     kUlBase,           // IN
    const    POINT* pptStart,   // IN
    DWORD    dupUl,             // IN
    DWORD    dvpUl,             // IN
    LSTFLOW  kTFlow,            // IN
    UINT     kDisp,             // IN
    const    RECT* prcClip)     // IN
{
    LSERR lserr    = lserrNone;
    COLORREF color = cv.GetColorRef();
    CRect ulRect;

    // If we're drawing from RtL then we need to shift one pixel to the right
    // in order to account for the left biased drawing of rects (pixel at
    // rc.left is drawn, pixel at rc.right is not).
    ulRect.left   = pptStart->x - ((!(kTFlow & fUDirection)) ? 0 : dupUl - 1);
    ulRect.top    = pptStart->y;
    ulRect.right  = pptStart->x + ((!(kTFlow & fUDirection)) ? dupUl : 1);
    ulRect.bottom = pptStart->y + dvpUl;

    if (IntersectRect(&ulRect, &ulRect, prcClip))
    {
        int bkModeOld = 0;
        
        if (_fDisabled)
        {
            if (_crForeDisabled != _crShadowDisabled)
            {
                CRect ulRectDisabled(ulRect);

                // draw the shadow
                color = _crShadowDisabled;
                ulRectDisabled.OffsetRect(1, 1);
                lserr = DrawLine(kUlBase, color, &ulRectDisabled);
                if (lserr != lserrNone)
                    goto Cleanup;

                // now set the drawing mode to transparent
                bkModeOld = SetBkMode(_hdc, TRANSPARENT);
            }
            color = _crForeDisabled;
        }

        // draw the actual line
        if (kUlBase & CFU_SQUIGGLE)
        {
            lserr = DrawSquiggle(pptStart, color, dupUl);
        }
        else if ((kUlBase& CFU_UNDERLINE_BITS) == CFU_UNDERLINETHICKDASH)
        {
            POINT pt;
            if (kTFlow & fUDirection)
            {
                pt.x = pptStart->x - dupUl;
                pt.y = pptStart->y;
            }
            else
            {
                pt.x = pptStart->x;
                pt.y = pptStart->y;
            }
            lserr = DrawThickDash(&pt, color, dupUl);
        }
        else
        {
            lserr = DrawLine(kUlBase, color, &ulRect);
        }
        if (lserr != lserrNone)
            goto Cleanup;
        
        // restore the background mode.
        if (_fDisabled && _crForeDisabled != _crShadowDisabled)
        {
            SetBkMode(_hdc, bkModeOld);
        }
    }

Cleanup:
    return lserr;
}

LSERR 
CLSRenderer::DrawSquiggle(
    const    POINT* pptStart,   // IN
    COLORREF colorUnderLine,    // IN
    DWORD    dupUl)             // IN
{
    // This table represents the change in y that the wavy underline needs.
    // If this is changed the other numbers below must change.
    const int  ldyTable[4] = { 0, 1, 0, -1 };
    const int  ySquiggleHeight = 3; //height of the squiggle
    LSERR      lserr = lserrNone;
    POINT      pt;
    HPEN       hPen, hPenOld;

    hPen = CreatePen(PS_SOLID, 0, colorUnderLine);

    if (hPen && dupUl)
    {  
        int i, dx, tableSize = 4;
        LONG x, y;
        XHDC hdc = _pDI->GetDC(TRUE);

        hPenOld = (HPEN) SelectObject(hdc, hPen);        
        GetViewportOrgEx(hdc, &pt);
        i = (pt.x-pptStart->x)%tableSize;
        i = (i > 0) ? i : (i+tableSize)%tableSize;
        x = pptStart->x;
        //adjust y position. Squiggle should fit into text descent, otherwise
        //lets move it up so that it doesn't go lower then text descent.
        y = pptStart->y - max(0L, ySquiggleHeight - _li.oi()->_yTxtDescent);

        MoveToEx(hdc, x, y + ldyTable[i], NULL );
        for( dx = (dupUl>1)?1+(i%2):dupUl; dupUl > 0; dx = ((dupUl <= 1)?1:2) )
        {
            dupUl -= dx;
            x += dx;
            i = (i + dx) % tableSize;
            LineTo(hdc, x, y + ldyTable[i] );
        }

        SelectObject(hdc, hPenOld);
        DeleteObject(hPen);
    }

    return lserr;
}

LSERR 
CLSRenderer::DrawThickDash(
    const    POINT* pptStart,   // IN
    COLORREF colorUnderLine,    // IN
    DWORD    dupUl)             // IN
{
    const int  xDashWidth = 3;
    LSERR      lserr = lserrNone;
    HPEN       hPen, hPenOld;

    hPen = CreatePen(PS_SOLID, 0, colorUnderLine);

    if (hPen && dupUl)
    {
        LONG dx, x;
        XHDC hdc = _pDI->GetDC(TRUE);

        hPenOld = (HPEN) SelectObject(hdc, hPen);

        dx = (pptStart->x/(2*xDashWidth))*(2*xDashWidth);
        dx -= ((dx >= 0) ? 0 : (((pptStart->x%(2*xDashWidth)) == 0) ? 0 : 2*xDashWidth));
        x = pptStart->x%(2*xDashWidth);
        x += dx + ((x >= 0) ? 0 : 2*xDashWidth);

        if (x - dx >= xDashWidth)
        {
            dx += 2*xDashWidth;
            x = dx;
        }

        while (x < pptStart->x + (LONG)dupUl)
        {
            MoveToEx(hdc, x, pptStart->y, NULL);
            LineTo(hdc, min((LONG)(dx+xDashWidth-(x-dx)), (LONG)(pptStart->x+(LONG)dupUl)), pptStart->y);
            MoveToEx(hdc, x, pptStart->y+1, NULL);
            LineTo(hdc, min((LONG)(dx+xDashWidth-(x-dx)), (LONG)(pptStart->x+(LONG)dupUl)), pptStart->y+1);

            dx += 2*xDashWidth;
            x = dx;
        }

        SelectObject(hdc, hPenOld);
        DeleteObject(hPen);
    }

    return lserr;
}

LSERR
CLSRenderer::DrawLine(
    UINT     kUlBase,        // IN
    COLORREF colorUnderLine, // IN
    CRect    *pRectLine)     // IN
{
    LSERR    lserr = lserrNone;
    HPEN     hPen,   hPenOld;
    UINT     lopnStyle = PS_SOLID;
    if (((kUlBase & CFU_UNDERLINE_BITS) == CFU_UNDERLINEDOTTED))
    {
        lopnStyle = PS_DOT;
    }

    hPen = CreatePen(lopnStyle, 0, colorUnderLine);
    if (hPen)
    {    
        hPenOld = (HPEN) SelectObject(_hdc, hPen);        
        if (pRectLine->bottom - pRectLine->top <= 1)
        {
            MoveToEx( _hdc, pRectLine->left, pRectLine->top, NULL );
            LineTo( _hdc, pRectLine->right, pRectLine->top );
        }
        else
        {
            HBRUSH  hBrush, hBrushOld;

            hBrush = CreateSolidBrush(colorUnderLine);
            if (hBrush)
            {
                hBrushOld = (HBRUSH) SelectObject(_hdc, hBrush);
                Rectangle(_hdc, pRectLine->left, pRectLine->top, pRectLine->right, pRectLine->bottom);
                SelectObject(_hdc, hBrushOld);
                DeleteObject(hBrush);
            }
        }
        SelectObject(_hdc, hPenOld);
        DeleteObject(hPen);
    }

    return lserr;
}

//
// Get offset of the line within a relative chunk
//
// The offset is physical (positive direction is always left-to-right)
// For RTL lines, the offset is from the right margin (and usually negative).
//
LONG    
CLSRenderer::CalculateRelativeChunkOffsetX() const
{
    // Non-relative case should be handled by the inline method
    Assert(_li._fPartOfRelChunk);

    // Get position of chunk start in the master line
    BOOL fRTLFlow;
    LONG xOffset = GetLS()->CalculateXPositionOfCp(_cpStartRender, FALSE, &fRTLFlow);

    // adjust for line and flow direction
    if (GetLS()->_li.IsRTLLine())
    {
        // In RTL lines, chunks move in opposite direction 
        xOffset = -xOffset;

        // LTR in RTL
        // note: opposite-flow adjustment is one-pixel different for RTL and LTR lines
        if (!fRTLFlow)
            xOffset += _li._xWidth;
    }
    else if (fRTLFlow)
    {
        // RTL in LTR
        xOffset -= _li._xWidth - 1;
    }

#if DBG==1
    // check that in all LTR case, xOffset always matches accumulated width
    // (old code used accumulated width to caclulate chunk offset)
    if (fRTLFlow != GetLS()->_li.IsRTLLine())
        const_cast<CLSRenderer*>(this)->_fBiDiLine = TRUE;
        
    Assert(GetLS()->_li.IsRTLLine() || fRTLFlow || _fBiDiLine || xOffset == _xAccumulatedWidth 
           || !IsTagEnabled(tagDebugRTL));
#endif
    
    return xOffset;
}

//-----------------------------------------------------------------------------
//
//  Function:   NeedRenderText
//
//  Synopsis:   Determines whether to render text or not, by comparing
//              clipping rectangle to text position and width.
//
//-----------------------------------------------------------------------------
BOOL
CLSRenderer::NeedRenderText(long x, const RECT *prcClip, long dup) const
{
    Assert(_pdp->HasLongLine());

    BOOL fRenderText = x < prcClip->right;
    if (fRenderText)
    {
        AssertSz(dup != -1, "Cannot use dup.");
        if (dup != -1)
        {
            fRenderText = (x + dup >= prcClip->left);
        }
    }
    return fRenderText;
}

//-----------------------------------------------------------------------------
//
//  Function:   RenderEllipsis
//
//  Synopsis:   Renders ellipsis at the end of the line.
//
//-----------------------------------------------------------------------------
VOID
CLSRenderer::RenderEllipsis()
{
    Assert(_fHasEllipsis);
    Assert(_pccsEllipsis && _pccsEllipsis->GetBaseCcs());

    // Select font in _hdc
    FONTIDX hfontOld = HFONT_INVALID;
    XHDC hdc = _pccsEllipsis->GetHDC();
    AssertSz(_pccsEllipsis->GetBaseCcs()->HasFont(), "CLSRenderer::RenderEllipsis pBaseCcs->_hfont is NULL");
    hfontOld = _pccsEllipsis->PushFont(hdc);

    // Select the pen color
    CTreeNode * pFormattingNode = _pdp->GetFlowLayout()->GetFirstBranch();
    const CCharFormat  * pCF = pFormattingNode->GetCharFormat();
    COLORREF cr = pCF->_ccvTextColor.GetColorRef();
    if (cr == RGB(255,255,255))
    {
        const INT nTechnology = GetDeviceCaps(hdc, TECHNOLOGY);
        if (nTechnology == DT_RASPRINTER || nTechnology == DT_PLOTTER)
            cr = RGB(0,0,0);
    }
    SetTextColor(hdc, cr);

    // Set up the drawing mode.
    SetBkMode(hdc, TRANSPARENT);

    // Get ellipsis metrics
    LONG xEllipsisWidth;
    _pccsEllipsis->Include(WCH_DOT, xEllipsisWidth);
    wchar_t achEllipsis[3] = { WCH_DOT, WCH_DOT, WCH_DOT };
    LONG aEllipsisWidth[3] = { xEllipsisWidth, xEllipsisWidth, xEllipsisWidth };
    LONG yEllipsisPos = _ptCur.y + (_li._yHeight - _li._yDescent) - 
                        (_pccsEllipsis->GetBaseCcs()->_yHeight - _pccsEllipsis->GetBaseCcs()->_yDescent);

    // Render ellipsis
    if (pCF->_fDisabled)
    {
        COLORREF crForeDisabled   = GetSysColorQuick(COLOR_3DSHADOW);
        COLORREF crShadowDisabled = GetSysColorQuick(COLOR_3DHILIGHT);

        if (crForeDisabled == CLR_INVALID || crShadowDisabled == CLR_INVALID)
            crForeDisabled = crShadowDisabled = GetSysColorQuick(COLOR_GRAYTEXT);

        SetTextColor(hdc, crShadowDisabled);
        ::ExtTextOutW(hdc, _xEllipsisPos+1, yEllipsisPos+1, ETO_CLIPPED, &_rcClip, achEllipsis, 3, (const int *)&aEllipsisWidth);
        SetTextColor(hdc, crForeDisabled);
    }
    ::ExtTextOutW(hdc, _xEllipsisPos, yEllipsisPos, ETO_CLIPPED, &_rcClip, achEllipsis, 3, (const int *)&aEllipsisWidth);

    if (hfontOld != HFONT_INVALID)
    {
        _pccsEllipsis->PopFont(hdc, hfontOld);
    }
}

//-----------------------------------------------------------------------------
//
//  Function:   RenderEllipsis
//
//  Synopsis:   Renders ellipsis at the end of the line.
//
//-----------------------------------------------------------------------------
VOID
CLSRenderer::PrepareForEllipsis(
    COneRun *por, 
    DWORD cchRun, 
    long dupRun, 
    long lGridOffset, 
    BOOL fReverse,
    const int *lpDxPtr, 
    DWORD *pcch)
{
    Assert(_pccsEllipsis && _pccsEllipsis->GetBaseCcs());

    LONG xRenderWidth;
    RECT rcView;
    BOOL fRTLLayout = _pdp->IsRTLDisplay();

    //
    // Retrieve the width of rendered content.
    //
    _pFlowLayout->GetElementDispNode()->GetClientRect(&rcView, CLIENTRECT_CONTENT);
    if (fRTLLayout)
        xRenderWidth = _li._xWidth - rcView.left + _li._xNegativeShiftRTL;
    else
        xRenderWidth = rcView.right - _li._xLeft - max(0L, rcView.right - (_li._xLeft + _li._xWidth));

    //
    // Need to show ellipsis, when the line's width is greater than the width
    // used for measuring.
    //
    if (   xRenderWidth > 0
        && _li._xWidth > xRenderWidth)
    {
        LONG xWidthBefore;
        LONG xEllipsisWidth;

        //
        // Get the width of ellipsis.
        //
        xEllipsisWidth = 0; // to make compiler happy
        _pccsEllipsis->Include(WCH_DOT, xEllipsisWidth);
        xEllipsisWidth *= 3;

        if (fRTLLayout)
            xWidthBefore = _li._xWidth - (_ptCur.x - _li._xNegativeShiftRTL + dupRun);
        else
            xWidthBefore = _ptCur.x - _li._xLeft;

        //
        // If the text run doesn't overlap ellipsis position, don't need to truncate the run.
        //
        if (xWidthBefore + dupRun > xRenderWidth - xEllipsisWidth)
        {
            //
            // If truncation occurs in this text run.
            // Find index of the last rendered character and truncate the rendered text.
            // NOTE: In case of selection don't show ellipsis.
            //
            if (!por->_fSelected)
            {
                long dur;
                unsigned int i;
                unsigned int idx;
                LONG xRunWidthRemaining = (long(cchRun) == por->_lscch) ? dupRun : por->_xWidth - _xRunWidthSoFar;

                dur = lGridOffset;
                for (i = 0; i < *pcch; i++)
                {
                    idx = fReverse ? *pcch - i - 1 : i;
                    dur += lpDxPtr[idx];

                    if (xWidthBefore + dur > xRenderWidth - xEllipsisWidth)
                    {
                        // Truncation point after 'i' characters. 
                        dur -= lpDxPtr[idx];

                        //
                        // If this is not the last rendered run, we need to check if:
                        // (1) following visible runs are selected
                        // (2) following visible runs are objects
                        // In these case don't show ellipsis for the current text run.
                        //
                        if (xWidthBefore + xRunWidthRemaining < xRenderWidth)
                        {
                            BOOL fStop = TRUE;
                            COneRun * porLast = por;
                            POINT ptTest = _ptCur;
                            if (fRTLLayout)
                                ptTest.x = _ptCur.x - 1;
                            else
                                ptTest.x = _li._xLeft + xWidthBefore + xRunWidthRemaining + 1;

                            do
                            {
                                COneRun * porFollowing;
                                LONG cpFollowingRun;

                                // Get cp of the following run (in the text flow direction)
                                cpFollowingRun = ((CDisplay *)_pdp)->CpFromPoint(ptTest, NULL, NULL, NULL, CDisplay::CFP_EXACTFIT, NULL, NULL, NULL, NULL);
                                Assert(cpFollowingRun >= 0);

                                // Find run, which contains the requested cp.
                                _pLS->LSCPFromCPCore(cpFollowingRun, &porFollowing);
                                Assert(porFollowing);
                                Assert(porFollowing->IsNormalRun() && !porFollowing->_fHidden);
                                if (porFollowing == porLast)
                                    break;

                                if (   porFollowing->_fSelected
                                    || porFollowing->_fCharsForNestedLayout)
                                {
                                    // Don't truncate the current text run
                                    i = *pcch;
                                    break;
                                }

                                porLast = porFollowing;
                                if (fRTLLayout)
                                {
                                    ptTest.x -= porFollowing->_xWidth;
                                    fStop = (ptTest.x < 0);
                                }
                                else
                                {
                                    ptTest.x += porFollowing->_xWidth;
                                    fStop = (ptTest.x > xRenderWidth + _li._xLeft);
                                }

                            } while (!fStop);
                        }
                        break;
                    }
                }
                Assert((i < *pcch) || (xWidthBefore + xRunWidthRemaining < xRenderWidth));

                //
                // If this run has been truncated, need to:
                // * set ellipsis position
                // * move rendering position in case of RTL layout
                //
                if (i != *pcch)
                {
                    // In RTL layout need to move rendering point to the beginning
                    // of rendered text
                    if (fRTLLayout)
                        _ptCur.x += dupRun - dur;

                    // Reset ellipsis position, if:
                    // (1) need to render any characters in the run
                    // (2) ellipsis position hasn't been set yet
                    // (3) new ellipsis position is closer to the logical beginning of 
                    //     the line, this case handles BIDI text
                    if (   i != 0
                        || !_fEllipsisPosSet
                        || (!fRTLLayout && (_xEllipsisPos > _ptCur.x + dur))
                        || (fRTLLayout && (_xEllipsisPos < _ptCur.x - xEllipsisWidth))
                       )
                    {
                        _fEllipsisPosSet = TRUE;
                        if (fRTLLayout)
                            _xEllipsisPos = _ptCur.x - xEllipsisWidth;
                        else
                            _xEllipsisPos = _ptCur.x + dur;
                    }

                    *pcch = i;
                }
            }
        }

        //
        // If rendering only part of the text run, accumulate width of the run.
        // This situation can occur in case of hyphens.
        //
        if (long(cchRun) != por->_lscch)
        {
            if (dupRun + _xRunWidthSoFar >= por->_xWidth)
                _xRunWidthSoFar = 0;
            else
                _xRunWidthSoFar += dupRun;
        }
        else
        {
            _xRunWidthSoFar = 0;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\text\lsmisc.cxx ===
/*
 *  @doc    INTERNAL
 *
 *  @module LSMISC.CXX -- line services misc support
 *
 *
 *  Owner: <nl>
 *      Chris Thrasher <nl>
 *      Sujal Parikh <nl>
 *
 *  History: <nl>
 *      01/05/98     cthrash created
 *
 *  Copyright (c) 1997-1998 Microsoft Corporation. All rights reserved.
 */

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X__FONT_H_
#define X__FONT_H_
#include "_font.h"
#endif

#ifndef X_CDUTIL_HXX_
#define X_CDUTIL_HXX_
#include "cdutil.hxx"
#endif

#ifndef X_TREEPOS_HXX_
#define X_TREEPOS_HXX_
#include "treepos.hxx"
#endif

#ifndef X_LINESRV_HXX_
#define X_LINESRV_HXX_
#include "linesrv.hxx"
#endif

#ifndef X_TXTDEFS_H_
#define X_TXTDEFS_H_
#include "txtdefs.h"
#endif

#ifdef DLOAD1
extern "C"  // MSLS interfaces are C
{
#endif

#ifndef X_LSPAP_H_
#define X_LSPAP_H_
#include <lspap.h>
#endif

#ifndef X_LSCHP_H_
#define X_LSCHP_H_
#include <lschp.h>
#endif

#ifndef X_LSFFI_H_
#define X_LSFFI_H_
#include <lsffi.h>
#endif

#ifndef X_OBJDIM_H_
#define X_OBJDIM_H_
#include <objdim.h>
#endif

#ifndef X_LIMITS_H_
#define X_LIMITS_H_
#include <limits.h>
#endif

#ifndef X_LSKTAB_H_
#define X_LSKTAB_H_
#include <lsktab.h>
#endif

#ifndef X_LSENUM_H_
#define X_LSENUM_H_
#include <lsenum.h>
#endif

#ifndef X_POSICHNK_H_
#define X_POSICHNK_H_
#include <posichnk.h>
#endif

#ifdef DLOAD1
} // extern "C"
#endif

#ifndef X_LSRENDER_HXX_
#define X_LSRENDER_HXX_
#include "lsrender.hxx"
#endif

#ifndef X_FLOWLYT_HXX_
#define X_FLOWLYT_HXX_
#include <flowlyt.hxx>
#endif

#ifndef X_LTCELL_HXX_
#define X_LTCELL_HXX_
#include <ltcell.hxx>
#endif

#ifndef X__FONTLINK_H_
#define X__FONTLINK_H_
#include "_fontlnk.h"
#endif

#ifndef X_STYLE_HXX_
#define X_STYLE_HXX_
#include "style.hxx"
#endif

#ifndef X_INTL_HXX_
#define X_INTL_HXX_
#include <intl.hxx>
#endif

#ifndef X_MLANG_H_
#define X_MLANG_H_
#include <mlang.h>
#endif

#ifndef X_LSTXM_H_
#define X_LSTXM_H_
#include <lstxm.h>
#endif

#define MSLS_MIN_VERSION 337
//#define MSLS_MIN_VERSION 349
#define MSLS_MAX_VERSION INT_MAX
#define MSLS_BUILD_LOCATION "\\\\word2\\lineserv\\rel0337"
//#define MSLS_BUILD_LOCATION "\\\\word2\\lineserv\\rel0349"

DeclareLSTag(tagLSAllowEmergenyBreaks, "Allow emergency breaks");
DeclareLSTag(tagLSTraceLines, "Trace plsline setup/discardal");

DeclareTag(tagCCcsCacheHits, "LineServices", "Trace Ccs cache hit %");
DeclareTag(tagFontLinkFonts, "Font", "Trace fontlinking on selected text");

MtDefine(QueryLinePointPcp_aryLsqsubinfo_pv, Locals, "CLineServices::QueryLinePointPcp::aryLsqsubinfo_pv");
MtDefine(QueryLineCpPpoint_aryLsqsubinfo_pv, Locals, "CLineServices::QueryLineCpPpoint::aryLsqsubinfo_pv");
MtDefine(GetGlyphOutline, Locals, "CLineServices::KernHeightToGlyph::GetGlyphOutline");
MtDefine(LSVerCheck, Locals, "LS Version check")
MtDefine(CFLSlab_pv, LineServices, "CLineServices::KernHeightToGlyph");

#if DBG==1
void CLineServices::InitTimeSanityCheck()
{
    //
    // First verify we're looking at the right version of msls.
    //

    static BOOL fCheckedVersion = FALSE;

    if (!fCheckedVersion)
    {
        BOOL fAOK = FALSE;
        HMODULE hmoduleMSLS;
#ifdef DLOAD1
        hmoduleMSLS = GetModuleHandleA("msls31"); // note - no need to free
#else        
        extern DYNLIB g_dynlibMSLS;
        hmoduleMSLS = g_dynlibMSLS.hinst;
#endif

        AssertSz( hmoduleMSLS, "Line Services (msls31.dll) was not loaded.  This is bad.");

        if (hmoduleMSLS)
        {
            char achPath[MAX_PATH];

            if (GetModuleFileNameA( hmoduleMSLS, achPath, sizeof(achPath) ))
            {
                DWORD dwHandle;
                DWORD dwVerInfoSize = GetFileVersionInfoSizeA(achPath, &dwHandle);

                if (dwVerInfoSize)
                {
                    void * lpBuffer = MemAlloc( Mt(LSVerCheck), dwVerInfoSize );

                    if (lpBuffer)
                    {
                        if (GetFileVersionInfoA(achPath, dwHandle, dwVerInfoSize, lpBuffer))
                        {
                            char * pchVersion;
                            UINT uiLen;
                                                    
                            if (VerQueryValueA(lpBuffer, "\\StringFileInfo\\040904E4\\FileVersion", (void **)&pchVersion, &uiLen) && uiLen)
                            {
                                char * pchDot = StrChrA( pchVersion, '.' );

                                if (pchDot)
                                {
                                    pchDot = StrChrA( pchDot + 1, '.' );

                                    if (pchDot)
                                    {
                                        int iVersion = atoi(pchDot + 1);

                                        fAOK = iVersion >= MSLS_MIN_VERSION && iVersion <= MSLS_MAX_VERSION;
                                    }
                                }
                            }
                        }

                        MemFree(lpBuffer);
                    }
                }
            }
        }

        fCheckedVersion = TRUE;

        AssertSz(fAOK, "MSLS31.DLL version mismatch.  You should get a new version from " MSLS_BUILD_LOCATION );
    }

    
    // lskt values should be indentical tomAlign values
    

    AssertSz( lsktLeft == tomAlignLeft &&
              lsktCenter == tomAlignCenter &&
              lsktRight == tomAlignRight &&
              lsktDecimal == tomAlignDecimal &&
              lsktChar == tomAlignChar,
              "enum values have changed!" );

    AssertSz( tomSpaces == 0 &&
              tomDots == 1 &&
              tomDashes == 2 &&
              tomLines == 3,
              "enum values have changed!" );

    // Checks for synthetic characters.
    
    AssertSz( (SYNTHTYPE_REVERSE & 1) == 0 &&
              (SYNTHTYPE_ENDREVERSE & 1) == 1,
              "synthtypes order has been broken" );

    // The breaking rules rely on this to be true.

    Assert( long(ichnkOutside) < 0 );

    // Check some basic classifications.

    Assert( !IsGlyphableChar(WCH_NBSP) &&
            !IsGlyphableChar(TEXT('\r')) &&
            !IsGlyphableChar(TEXT('\n')) &&
            !IsRTLChar(WCH_NBSP) &&
            !IsRTLChar(TEXT('\r')) &&
            !IsRTLChar(TEXT('\n')) );

    // Check the range for justification (uses table lookup)
    // Don't add to this list unless you have also updated
    // s_ablskjustMap[].
    AssertSz(    0 == styleTextJustifyNotSet
              && 1 == styleTextJustifyInterWord
              && 2 == styleTextJustifyNewspaper
              && 3 == styleTextJustifyDistribute
              && 4 == styleTextJustifyDistributeAllLines
              && 5 == styleTextJustifyInterIdeograph
              && 6 == styleTextJustifyInterCluster
              && 7 == styleTextJustifyKashida
              && 8 == styleTextJustifyAuto,
              "CSS text-justify values have changed.");
    //
    // Test alternate font functionality.
    //

    {
        const WCHAR * pchMSGothic;

        pchMSGothic = AlternateFontName( L"\xFF2D\xFF33\x0020\x30B4\x30B7\x30C3\x30AF" );

        Assert( pchMSGothic && StrCmpC( L"MS Gothic", pchMSGothic ) == 0 );
        
        pchMSGothic = AlternateFontName( L"ms GOthic" );

        Assert( pchMSGothic && StrCmpC( L"\xFF2D\xFF33\x0020\x30B4\x30B7\x30C3\x30AF", pchMSGothic ) == 0 );
    }
}
#endif

//+----------------------------------------------------------------------------
//
// Member:      CLineServices::SetRenderer
//
// Synopsis:    Sets up the line services object to indicate that we will be
//              using for rendering.
//
//+----------------------------------------------------------------------------
void
CLineServices::SetRenderer(CLSRenderer *pRenderer, BOOL fWrapLongLines, CTreeNode * pNodeLi)
{
    _pMeasurer = pRenderer;
    _pNodeLi   = pNodeLi;
    _lsMode    = LSMODE_RENDERER;
    _fWrapLongLines = fWrapLongLines;
}

//+----------------------------------------------------------------------------
//
// Member:      CLineServices::SetMeasurer
//
// Synopsis:    Sets up the line services object to indicate that we will be
//              using for measuring / hittesting.
//
//+----------------------------------------------------------------------------
void
CLineServices::SetMeasurer(CLSMeasurer *pMeasurer, LSMODE lsMode, BOOL fWrapLongLines)
{
    _pMeasurer = pMeasurer;
    Assert(lsMode != LSMODE_NONE && lsMode != LSMODE_RENDERER);
    _lsMode    = lsMode;
    _fWrapLongLines = fWrapLongLines;
}

//+----------------------------------------------------------------------------
//
// Member:      CLineServices::GetRenderer
//
//+----------------------------------------------------------------------------
CLSRenderer *
CLineServices::GetRenderer()
{
    return (_pMeasurer && _lsMode == LSMODE_RENDERER) ?
            DYNCAST(CLSRenderer, _pMeasurer) : NULL;
}

//+----------------------------------------------------------------------------
//
// Member:      CLineServices::GetMeasurer
//
//+----------------------------------------------------------------------------
CLSMeasurer *
CLineServices::GetMeasurer()
{
    return (_pMeasurer && _lsMode == LSMODE_MEASURER) ? _pMeasurer : NULL;
}

//+----------------------------------------------------------------------------
//
//  Member:     CLineServices::PAPFromPF
//
//  Synopsis:   Construct a PAP from PF
//
//-----------------------------------------------------------------------------

static const BYTE s_ablskjustMap[] =
{
    lskjFullInterWord,          // NotSet (default)
    lskjFullInterWord,          // InterWord
    lskjFullInterLetterAligned, // Newspaper
    lskjFullInterLetterAligned, // Distribute
    lskjFullInterLetterAligned, // DistributeAllLines
    lskjFullScaled,             // InterIdeograph
    lskjFullInterLetterAligned, // InterCluster
    lskjFullInterLetterAligned, // Kashida
    lskjFullInterWord           // Auto (?)
};

void
CLineServices::PAPFromPF(PLSPAP pap, const CParaFormat *pPF, BOOL fInnerPF, CComplexRun *pcr)
{
    _fExpectCRLF = pPF->HasPre(fInnerPF) || _fIsTextLess;
    const BOOL fJustified = pPF->GetBlockAlign(fInnerPF) == htmlBlockAlignJustify
                            && !pPF->HasInclEOLWhite(fInnerPF)
                            && !_fMinMaxPass;
        
    // line services format flags (lsffi.h)

    pap->grpf =   fFmiApplyBreakingRules     // Use our breaking tables
                | fFmiSpacesInfluenceHeight; // Whitespace contributes to extent

    if (_fWrapLongLines)
        pap->grpf |= fFmiWrapAllSpaces;
    else
        pap->grpf |= fFmiForceBreakAsNext;   // No emergency breaks

#if DBG==1
    // To test possible bugs with overriding emergency breaks in LS, we
    // provide an option here to turn it off.  Degenerate lines will break
    // at the wrapping width (default LS behavior.)

    if (IsTagEnabled(tagLSAllowEmergenyBreaks))
    {
        pap->grpf &= ~fFmiForceBreakAsNext;
    }
#endif // DBG

    pap->uaLeft = 0;
    pap->uaRightBreak = 0;
    pap->uaRightJustify = 0;
    pap->duaIndent = 0;
    pap->duaHyphenationZone = 0;
 
    // Justification type
    pap->lsbrj = lsbrjBreakJustify;

    // Justification
    if (fJustified)
    {
        _li._fJustified = JUSTIFY_FULL;
        
        // A. If we are a complex script or have a complex script style,
        //    set lskj to do glyphing
        // NOTE: (paulnel) if you ever do something other than check pcr != NULL,
        //       you will need to make sure we have a good pcr. See FetchPap
        if(   pcr != NULL 
           || _li._fRTLLn
           || pPF->_uTextJustify == styleTextJustifyInterCluster)
        {
            pap->lskj = lskjFullGlyphs;
            // no compress for glyph based stuff
            pap->lsbrj = lsbrjBreakThenExpand;
            // make sure that we don't get microspacing with connected text
            pap->grpf &= ~(fFmiPresExactSync | fFmiPresSuppressWiggle | fFmiHangingPunct);


            if(!pPF->_cuvTextKashida.IsNull())
            {
                Assert(_xWidthMaxAvail > 0);

                // set the amount of the right break
                long xKashidaPercent = pPF->_cuvTextKashida.GetPercentValue(CUnitValue::DIRECTION_CX, _xWidthMaxAvail);
                _xWrappingWidth = _xWidthMaxAvail - xKashidaPercent;
                
                // we need to set this amount as twips
                Assert(_pci);
                pap->uaRightBreak = _pci->TwipsFromDeviceX(xKashidaPercent);

                Assert(_xWrappingWidth >= 0);
            }
        }
        else
        {
            pap->lskj = LSKJUST(s_ablskjustMap[ pPF->_uTextJustify ]);
#if 0            
            if (   pap->lskj == lskjFullInterLetterAligned
                || pap->lskj == lskjFullScaled
               )
            {
                pap->lsbrj = lsbrjBreakWithCompJustify;
            }
#endif
            
        }
        _fExpansionOrCompression = pPF->_uTextJustify > styleTextJustifyInterWord;

        // Clear justification if we have a 'strict' or 'fixed' character grid
        if (    styleLayoutGridTypeFixed == pPF->GetLayoutGridType(fInnerPF)
            ||  styleLayoutGridTypeStrict == pPF->GetLayoutGridType(fInnerPF))
            pap->lskj = lskjNone;
    }
    else
    {
        _fExpansionOrCompression = FALSE;
        pap->lskj = lskjNone;
    }

    // Alignment

    pap->lskal = lskalLeft;

    // Autonumbering

    pap->duaAutoDecimalTab = 0;

    // kind of paragraph ending

    pap->lskeop = _fExpectCRLF ? lskeopEndPara1 : lskeopEndParaAlt;

    // Main text flow direction

    Assert(pPF->HasRTL(fInnerPF) == (BOOL) _li._fRTLLn);
    if (!_li._fRTLLn)
    {
        pap->lstflow = lstflowES;
    }
    else
    {
        if (_pBidiLine == NULL)
        {
            _pBidiLine = new CBidiLine(_treeInfo, _cpStart, _li._fRTLLn, _pli);
        }
#if DBG==1
        else
        {
            Assert(_pBidiLine->IsEqual(_treeInfo, _cpStart, _li._fRTLLn, _pli));
        }
#endif
        pap->lstflow = lstflowWS;
    }
}

//+----------------------------------------------------------------------------
//
//  Member:     CLineServices::CHPFromCF
//
//  Synopsis:   Construct a CHP from CF
//
//-----------------------------------------------------------------------------
void
CLineServices::CHPFromCF(
    COneRun * por,
    const CCharFormat * pCF )
{
    PLSCHP pchp = &por->_lsCharProps;

    // The structure has already been zero'd out in fetch run, which sets almost
    // everything we care about to the correct value (0).

    if (pCF->_fTextAutospace)
    {
        _lineFlags.AddLineFlag(por->Cp(), FLAG_HAS_NOBLAST);

        if (pCF->_fTextAutospace & TEXTAUTOSPACE_ALPHA)
        {
            pchp->fModWidthOnRun = TRUE;
            por->_csco |= cscoAutospacingAlpha;
        }
        if (pCF->_fTextAutospace & TEXTAUTOSPACE_NUMERIC)
        {
            pchp->fModWidthOnRun = TRUE;
            por->_csco |= cscoAutospacingDigit;
        }
        if (pCF->_fTextAutospace & TEXTAUTOSPACE_SPACE)
        {
            pchp->fModWidthSpace = TRUE;
            por->_csco |= cscoAutospacingAlpha;
        }
        if (pCF->_fTextAutospace & TEXTAUTOSPACE_PARENTHESIS)
        {
            pchp->fModWidthOnRun = TRUE;
            por->_csco |= cscoAutospacingParen;
        }
    }

    if (_fExpansionOrCompression)
    {
        pchp->fCompressOnRun = TRUE;
        pchp->fCompressSpace = TRUE; 
        pchp->fCompressTable = TRUE;
        pchp->fExpandOnRun = 0 == (pCF->_bPitchAndFamily & FF_SCRIPT);
        pchp->fExpandSpace = TRUE;
        pchp->fExpandTable = TRUE;
    }

    pchp->idObj = LSOBJID_TEXT;
}

//+----------------------------------------------------------------------------
//
//  Member:     CLineServices::SetPOLS
//
//  Synopsis:   We call this function when we assign a CLineServices
//              to a CLSMeasurer.
//
//-----------------------------------------------------------------------------
void
CLineServices::SetPOLS(CLSMeasurer * plsm, CTreePos * ptpContentEnd)
{

    _pFlowLayout = plsm->_pFlowLayout;
    _fIsEditable = !plsm->_fBrowseMode;

    CElement * pElementOwner = _pFlowLayout->ElementOwner();

    _fIsTextLess = pElementOwner->HasFlag(TAGDESC_TEXTLESS);
    _fIsTD = pElementOwner->Tag() == ETAG_TD;
    _pMarkup = _pFlowLayout->GetContentMarkup();
    _fHasSites = FALSE;
    _pci = plsm->_pci;
    _plsline = NULL;
    _chPassword = _pFlowLayout->GetPasswordCh();

    //
    // We have special wrapping rules inside TDs with width specified.
    // Make note so the ILS breaking routines can break correctly.
    //
    
    _xTDWidth = MAX_MEASURE_WIDTH;
    if (_fIsTD)
    {
        const LONG iUserWidth = DYNCAST(CTableCellLayout, _pFlowLayout)->GetSpecifiedPixelWidth(_pci, 
            _pFlowLayout->GetFirstBranch()->GetCharFormat()->HasVerticalLayoutFlow());

        if (iUserWidth)
        {
            _xTDWidth = iUserWidth;
        }
    }

    ClearLinePropertyFlags();
    
    _treeInfo._cpLayoutFirst = plsm->_cp;
    _treeInfo._cpLayoutLast  = plsm->_cpEnd;
    _treeInfo._ptpLayoutLast = ptpContentEnd;
    _treeInfo._tpFrontier.BindToCp(0);
    
    InitChunkInfo(_treeInfo._cpLayoutFirst);

    _pPFFirst = NULL;
    WHEN_DBG( _cpStart = -1 );
}

//+----------------------------------------------------------------------------
//
//  Member:     CLineServices::ClearPOLS
//
//  Synopsis:   We call this function when we have finished using the measurer.
//
//-----------------------------------------------------------------------------
void
CLineServices::ClearPOLS()
{
    // This assert will fire if we are leaking lsline's.  This happens
    // if somebody calls LSDoCreateLine without ever calling DiscardLine.
    Assert(_plsline == NULL);
    _pMarginInfo = NULL;
    if (_plcFirstChunk)
        DeleteChunks();
    DiscardOneRuns();

    ClearFontCaches();
}

void
CLineServices::ClearFontCaches()
{
    if (_ccsCache.GetBaseCcs())
    {
        _ccsCache.Release();
//        Assert(_pCFCache);
        _pCFCache = NULL;
    }
    if (_ccsAltCache.GetBaseCcs())
    {
        _ccsAltCache.Release();
//        Assert(_pCFAltCache);
        _pCFAltCache = NULL;
        _bCrcFontAltCache = 0;
    }
}

static CCharFormat s_cfBullet;

//+----------------------------------------------------------------------------
//
//  Member:     CLineServices::GetCFSymbol
//
//  Synopsis:   Get the a CF for the symbol passed in and put it in the COneRun.
//
//-----------------------------------------------------------------------------
void
CLineServices::GetCFSymbol(COneRun *por, TCHAR chSymbol, const CCharFormat *pcfIn)
{
    static BOOL s_fBullet = FALSE;

    CCharFormat *pcfOut = por->GetOtherCF();

    Assert(pcfIn && pcfOut);
    if (pcfIn == NULL || pcfOut == NULL)
        goto Cleanup;

    if (!s_fBullet)
    {
        // N.B. (johnv) For some reason, Win95 does not render the Windings font properly
        //  for certain characters at less than 7 points.  Do not go below that size!
        s_cfBullet.SetHeightInTwips( TWIPS_FROM_POINTS ( 7 ) );
        s_cfBullet._bCharSet = SYMBOL_CHARSET;
        s_cfBullet._fNarrow = FALSE;
        s_cfBullet._bPitchAndFamily = (BYTE) FF_DONTCARE;
        s_cfBullet.SetFaceNameAtom(fc().GetAtomWingdings());
        s_cfBullet._bCrcFont = s_cfBullet.ComputeFontCrc();

        s_fBullet = TRUE;
    }

    // Use bullet char format
    *pcfOut = s_cfBullet;

    pcfOut->_ccvTextColor = pcfIn->_ccvTextColor;

    // Important - CM_SYMBOL is a special mode where out WC chars are actually
    // zero-extended MB chars.  This allows us to have a codepage-independent
    // call to ExTextOutA. (cthrash)
    por->SetConvertMode(CM_SYMBOL);

Cleanup:
    return;
}

//+----------------------------------------------------------------------------
//
//  Member:     CLineServices::GetCFNumber
//
//  Synopsis:   Get the a CF for the number passed in and put it in the COneRun.
//
//-----------------------------------------------------------------------------
void
CLineServices::GetCFNumber(COneRun *por, const CCharFormat * pcfIn)
{
    CCharFormat *pcfOut = por->GetOtherCF();
    *pcfOut = *pcfIn;
    pcfOut->_fSubscript = pcfOut->_fSuperscript = FALSE;
    pcfOut->_bCrcFont   = pcfOut->ComputeFontCrc();
}

LONG
CLineServices::GetDirLevel(LSCP lscp)
{
    LONG nLevel;
    COneRun *pHead;

    nLevel = _li._fRTLLn;
    for (pHead = _listCurrent._pHead; pHead; pHead = pHead->_pNext)
    {
        if (lscp >= pHead->_lscpBase)
        {
            if (pHead->IsSyntheticRun())
            {
                SYNTHTYPE synthtype = pHead->_synthType;
                // Since SYNTHTYPE_REVERSE preceeds SYNTHTYPE_ENDREVERSE and only
                // differs in the last bit, we can compute nLevel with bit magic. We
                // have to be sure this condition really exists of course, so we
                // Assert() it above.
                if (IN_RANGE(SYNTHTYPE_DIRECTION_FIRST, synthtype, SYNTHTYPE_DIRECTION_LAST))
                {
                    nLevel -= (((synthtype & 1) << 1) - 1);
                }
            }
        }
        else
            break;
    }

    return nLevel;
}

//-----------------------------------------------------------------------------
//
//  Member:     CLineFlags::AddLineFlag
//
//  Synopsis:   Set flags for a given cp.
//
//-----------------------------------------------------------------------------

LSERR
CLineFlags::AddLineFlag(LONG cp, DWORD dwlf)
{
    int c = _aryLineFlags.Size();

    if (!c || cp >= _aryLineFlags[c-1]._cp)
    {
        CFlagEntry fe(cp, dwlf);

        return S_OK == _aryLineFlags.AppendIndirect(&fe)
                ? lserrNone
                : lserrOutOfMemory;
    }
    return lserrNone;
}

LSERR
CLineFlags::AddLineFlagForce(LONG cp, DWORD dwlf)
{
    CFlagEntry fe(cp, dwlf);

    _fForced = TRUE;
    return S_OK == _aryLineFlags.AppendIndirect(&fe)
            ? lserrNone
            : lserrOutOfMemory;
}

//+----------------------------------------------------------------------------
//
//  Member:     CLineServices::GetLineFlags
//
//  Synopsis:   Given a cp, it computes all the flags which have been turned
//              on till that cp.
//
//-----------------------------------------------------------------------------

DWORD
CLineFlags::GetLineFlags(LONG cpMax)
{
    DWORD dwlf;
    LONG i;
    
    dwlf = FLAG_NONE;
    
    for (i = 0; i < _aryLineFlags.Size(); i++)
    {
        if (_aryLineFlags[i]._cp >= cpMax)
        {
            if (_fForced)
                continue;
            else
                break;
        }
        else
            dwlf |= _aryLineFlags[i]._dwlf;
    }

#if DBG==1
    if (!_fForced)
    {
        //
        // This verifies that LS does indeed ask for runs in a monotonically
        // increasing manner as far as cp's are concerned
        //
        for (; i < _aryLineFlags.Size(); i++)
        {
            Assert(_aryLineFlags[i]._cp >= cpMax);
        }
    }
#endif

    return dwlf;
}

//+----------------------------------------------------------------------------
//
//  Member:     CLineServices::AddLineCount
//
//  Synopsis:   Adds a particular line count at a given cp. It also checks if the
//              count has already been added at that cp. This is needed to solve
//              2 problems with maintaining line counts:
//              1) A run can be fetched multiple times. In this case we want to
//                 increment the counts just once.
//              2) LS can over fetch runs, in which case we want to disregard
//                 the counts of those runs which did not end up on the line.
//
//-----------------------------------------------------------------------------
LSERR
CLineCounts::AddLineCount(LONG cp, LC_TYPE lcType, LONG count)
{
    CLineCount lc(cp, lcType, count);
    int i = _aryLineCounts.Size();

    while (i--)
    {
        if (_aryLineCounts[i]._cp != cp)
            break;

        if (_aryLineCounts[i]._lcType == lcType)
            return lserrNone;
    }
    
    return S_OK == _aryLineCounts.AppendIndirect(&lc)
            ? lserrNone
            : lserrOutOfMemory;
}

//+----------------------------------------------------------------------------
//
//  Member:     CLineServices::GetLineCount
//
//  Synopsis:   Finds a particular line count at a given cp.
//
//-----------------------------------------------------------------------------
LONG
CLineCounts::GetLineCount(LONG cp, LC_TYPE lcType)
{
    LONG count = 0;

    for (LONG i = 0; i < _aryLineCounts.Size(); i++)
    {
        if (   _aryLineCounts[i]._lcType == lcType
            && _aryLineCounts[i]._cp < cp
           )
        {
            count += _aryLineCounts[i]._count;
        }
    }
    return count;
}

//+----------------------------------------------------------------------------
//
//  Member:     CLineServices::GetMaxLineValue
//
//  Synopsis:   Finds a particular line value uptil a given cp.
//
//-----------------------------------------------------------------------------
LONG
CLineCounts::GetMaxLineValue(LONG cp, LC_TYPE lcType)
{
    LONG value = LONG_MIN;

    for (LONG i = 0; i < _aryLineCounts.Size(); i++)
    {
        if (   _aryLineCounts[i]._lcType == lcType
            && _aryLineCounts[i]._cp < cp
           )
        {
            value = max(value, _aryLineCounts[i]._count);
        }
    }
    return value;
}

#define MIN_FOR_LS 1

HRESULT
CLineServices::Setup(
    LONG xWidthMaxAvail,
    LONG cp,
    CTreePos *ptp,
    const CMarginInfo *pMarginInfo,
    const CLineFull * pli,
    BOOL fMinMaxPass )
{
    const CParaFormat *pPF;
    BOOL fWrapLongLines = _fWrapLongLines;
    HRESULT hr = S_OK;
    
    Assert(_pMeasurer);

    if (!_treeInfo._fInited || cp != long(_pMeasurer->GetCp()))
    {
        DiscardOneRuns();
        hr = THR(_treeInfo.InitializeTreeInfo(_pFlowLayout, _fIsEditable, cp, ptp));
        if (hr != S_OK)
            goto Cleanup;
    }

    _lineFlags.InitLineFlags();
    _cpStart     = _cpAccountedTill = cp;
    _pMarginInfo = pMarginInfo;
    _cWhiteAtBOL = 0;
    _cAlignedSitesAtBOL = 0;
    _cAbsoluteSites = 0;
    _cAlignedSites = 0;
    _pNodeForAfterSpace = NULL;
    _fHasVerticalAlign = FALSE;
    _fNeedRecreateLine = FALSE;

    if (_lsMode == LSMODE_MEASURER)
    {
        _pli = NULL;
    } 
    else
    {
        Assert(_lsMode == LSMODE_HITTEST || _lsMode == LSMODE_RENDERER);
        _pli = pli;
        _li._fLookaheadForGlyphing = (_pli ? _pli->_fLookaheadForGlyphing : FALSE);
    }
    
    ClearLinePropertyFlags(); // zero out all flags
    _fWrapLongLines = fWrapLongLines; // preserve this flag when we 0 _dwProps
    
    // We're getting max, so start really small.
    _lMaxLineHeight = LONG_MIN;
    _fFoundLineHeight = FALSE;

    _xWrappingWidth = -1;

    pPF = _treeInfo._pPF;
    _fInnerPFFirst = _treeInfo._fInnerPF;

    // TODO (a-pauln, track bug IE6 1740) some elements are getting assigned a PF from the
    //        wrong branch in InitializeTreeInfo() above. This hack is a
    //        temporary correction of the problem's manifestation until
    //        we determine how to correct it.
    if(!_treeInfo._fHasNestedElement || !ptp)
        _li._fRTLLn = pPF->HasRTL(_fInnerPFFirst);
    else
    {
        pPF = ptp->Branch()->GetParaFormat(LC_TO_FC(_pFlowLayout->LayoutContext()));
        _li._fRTLLn = pPF->HasRTL(_fInnerPFFirst);
    }

    if (    !_pMeasurer->_pdp->GetWordWrap()
        ||  (pPF && pPF->HasPre(_fInnerPFFirst) && !_fWrapLongLines))
    {
        //
        // If we are in min-max mode inside a table cell and the table cell has a specified
        // width and we have the word-wrap property, then we should measure at the
        // _xTDWidth so that we correctly report the max width.
        //
        if (   fMinMaxPass
            && _fIsTD
            && _xTDWidth != MAX_MEASURE_WIDTH
            && _pMeasurer->_fBreaklinesFromStyle
           )
        {
            xWidthMaxAvail = _xTDWidth;
        }
        else
        {
            _xWrappingWidth = xWidthMaxAvail;
            xWidthMaxAvail = MAX_MEASURE_WIDTH;
        }
    }
    else if (xWidthMaxAvail <= MIN_FOR_LS)
    {
        //TODO (SujalP, track bug 4358): Remove hack when LS gets their in-efficient calc bug fixed.
        xWidthMaxAvail = 0;
    }
    
    _xWidthMaxAvail = xWidthMaxAvail;
    if (_xWrappingWidth == -1)
        _xWrappingWidth = _xWidthMaxAvail;

    _fMinMaxPass = fMinMaxPass;
    _pPFFirst = pPF;
    DeleteChunks();
    InitChunkInfo(cp - (_pMeasurer->_fMeasureFromTheStart ? 0 : _pMeasurer->_cchPreChars));

    // Reset layout grid related stuff
    _lCharGridSizeInner = 0;
    _lCharGridSize = 0;
    _lLineGridSizeInner = 0;
    _lLineGridSize = 0;
    _cLayoutGridObj = 0;
    _cLayoutGridObjArtificial = 0;

Cleanup:
    RRETURN(hr);
}

//-----------------------------------------------------------------------------
//
//  Function:   CLineServices::GetMinDurBreaks (member)
//
//  Synopsis:   Determine the minimum width of the line.  Also compute any
//              adjustments to the maximum width of the line.
//
//-----------------------------------------------------------------------------

LSERR
CLineServices::GetMinDurBreaks( 
    LONG * pdvMin,
    LONG * pdvMaxDelta )
{
    LSERR lserr;

    Assert(_plsline);
    Assert(_fMinMaxPass);
    Assert(pdvMin);
    Assert(pdvMaxDelta);

    //
    // First we call LsGetMinDurBreaks.  This call does the right thing only
    // for text runs, not ILS objects.
    //

    if (!_fScanForCR)
    {
        LONG  dvDummy;
        
        lserr = LsGetMinDurBreaks( GetContext(), _plsline, &dvDummy, pdvMin );
        if (lserr)
            goto Cleanup;
    }
    
    //
    // Now we need to go and compute the true max width.  The current max
    // width is incorrect by the difference in the min and max widths of
    // dobjs for which these values are not the same (e.g. tables).  We've
    // cached the difference in the dobj's, so we need to enumerate these
    // and add them up.  The enumeration callback adjusts the value in
    // CLineServices::dvMaxDelta;
    //

    _dvMaxDelta = 0;

    lserr = LsEnumLine( _plsline,
                        FALSE,        // fReverseOrder
                        FALSE,        // fGeometryNeeded
                        &g_Zero.pt ); // pptOrg

    *pdvMaxDelta = _dvMaxDelta;
    
    if (_fScanForCR)
    {
        *pdvMin = _li._xWidth + _dvMaxDelta;
    }

Cleanup:
    return lserr;
}

void COneRun::Deinit()
{
    if (   _fMustDeletePcf
        && _pCF
       )
    {
        Assert(_pCF != _pCFOriginal);
        delete _pCF;
    }
    _pCF = NULL;
#if DBG == 1
    _pCFOriginal = NULL;
#endif

    _bConvertMode = CM_UNINITED;
    
    if (_pComplexRun)
    {
        delete _pComplexRun;
        _pComplexRun = NULL;
    }

    _cstrRunChars.Free();

    // Finally, clear out all the flags
    _dwProps = 0;
}


#ifdef FASTER_GAOR

//
// This is for the presently unused tweaked GetAvailableOneRuns
//

// Like ReSetup, but just scoots along from where it is.
void 
COneRun::RelativeSetup(CTreePosList *ptpl, 
                       CElement *pelRestricting, 
                       LONG cp, 
                       CFlowLayout *pRunOwner, 
                       BOOL fRight)
{
    Deinit();

    // The cp-threshhold number here is a performance-tuned number.  Any number will work.
    // (It will never do the wrong thing, it just might take a while to do it.)
    // It represents the largest cp-distance that can be covered with Advance that will
    // take the same amount of time as setting one up from scratch.
    if( ptpl != _ptpl || (abs(cp - Cp()) > 100) )
        super::ReSetUp(ptpl,pelRestricting,cp,pRunOwner,fRight);
    {
#if DBG == 1
        COneRun orDebug(this);
        orDebug.ReSetUp(ptpl,pelRestricting,cp,pRunOwner,fRight);
#endif // DBG == 1
        SetRestrictingElement(pelRestricting);
        Advance( cp - Cp() );
        Assert( !memcmp( this, &orDebug, sizeof(this) ) );
    }
}

#endif // FASTER_GAOR

//-----------------------------------------------------------------------------
//
//  Function:   CLineServices destructor
//
//  Synopsis:   Free the COneRun cache
//
//-----------------------------------------------------------------------------

CLineServices::~CLineServices()
{
    _ccsCache.Release();
    _ccsAltCache.Release();
}

//-----------------------------------------------------------------------------
//
//  Function:   CLineServices::DiscardLine (member)
//
//  Synopsis:   The lifetime of a CLineServices object is that of it's
//              containing CDoc.  This function is used to clear state
//              after each use of the object, as opposed to the destructor.
//              This function needs to be called after each measured/rendered
//              line (~CLine.)
//
//-----------------------------------------------------------------------------

void
CLineServices::DiscardLine()
{
    WHEN_DBG( static int nCall = 0 );
    
    TraceTag((tagLSTraceLines,
              "CLineServices::DiscardLine[%d] sn=%d null=%s ",
              nCall++, _nSerial, _plsline ? "true" : "false"));

    if (_plsline)
    {
        LsDestroyLine( _plsc, _plsline );
        _lineFlags.DeleteAll();
        _lineCounts.DeleteAll();
        _plsline = NULL;
    }


    _mbpTopCurrent = _mbpBottomCurrent = 0;
    
    // For now just do this simple thing here. Eventually we will do more
    // complex things like holding onto tree state.
    _treeInfo._fInited = FALSE;

    if (_pBidiLine != NULL)
    {
        delete _pBidiLine;
        _pBidiLine = NULL;
    }

    _aryRubyInfo.DeleteAll();
}


//+----------------------------------------------------------------------------
//
// Member:      InitChunkInfo
//
// Synopsis:    Initializest the chunk info store.
//
//-----------------------------------------------------------------------------
void
CLineServices::InitChunkInfo(LONG cp)
{
    _cpLastChunk = cp;
    _xPosLastChunk = 0;
    _plcFirstChunk = _plcLastChunk = NULL;
    _pElementLastRelative = NULL;
    _fLastChunkSingleSite = FALSE;

    // Note: It would be more precise to initialize _fLastChunkRTL from the line flag,
    // but the line is not available yet. It is OK to make a guess from layout - 
    // if the guess is wrong, and the line is in different direction, it will just 
    // cause an empty chunk in the beginning of a line with relative text.
    _fLastChunkRTL = _pFlowLayout ? _pFlowLayout->IsRTLFlowLayout() : FALSE;
}

//+----------------------------------------------------------------------------
//
// Member:      DeleteChunks
//
// Synopsis:    Delete chunk related information in the line
//
//-----------------------------------------------------------------------------
void
CLineServices::DeleteChunks()
{
    while(_plcFirstChunk)
    {
        CLSLineChunk * plc = _plcFirstChunk;

        _plcFirstChunk = _plcFirstChunk->_plcNext;
        delete plc;
    }
    _plcLastChunk = NULL;
}

//-----------------------------------------------------------------------------
//
//  Function:   QueryLinePointPcp (member)
//
//  Synopsis:   Wrapper for LsQueryLinePointPcp
//
//  Returns:    S_OK    - Success
//              S_FALSE - depth was zero
//              E_FAIL  - error
//
//-----------------------------------------------------------------------------

HRESULT
CLineServices::QueryLinePointPcp(
    LONG u,                     // IN
    LONG v,                     // IN
    LSTFLOW *pktFlow,           // OUT
    PLSTEXTCELL plstextcell)    // OUT
{
    POINTUV uvPoint;
    CStackDataAry < LSQSUBINFO, 4 > aryLsqsubinfo( Mt(QueryLinePointPcp_aryLsqsubinfo_pv) );
    HRESULT hr;
    DWORD nDepthIn = 4;

    uvPoint.u = u;
    uvPoint.v = v;

    Assert(_plsline);

    #define NDEPTH_MAX 32

    for (;;)
    {
        DWORD nDepth;
        LSERR lserr = LsQueryLinePointPcp( _plsline,
                                           &uvPoint,
                                           nDepthIn,
                                           aryLsqsubinfo,
                                           &nDepth,
                                           plstextcell);

        if (lserr == lserrNone)
        {
            hr = S_OK;
            // get the flow direction for proper x+/- manipulation
            if(nDepth > 0)
            {
                if (   aryLsqsubinfo[nDepth - 1].idobj != LSOBJID_TEXT
                    && aryLsqsubinfo[nDepth - 1].idobj != LSOBJID_GLYPH
                    && aryLsqsubinfo[nDepth - 1].idobj != LSOBJID_EMBEDDED
                   )
                {
                    LSQSUBINFO &qsubinfo = aryLsqsubinfo[nDepth-1];
                    plstextcell->dupCell = qsubinfo.dupObj;
                    plstextcell->pointUvStartCell = qsubinfo.pointUvStartSubline;
                    plstextcell->cCharsInCell = 0;
                    plstextcell->cpStartCell = qsubinfo.cpFirstSubline;
                    plstextcell->cpEndCell = qsubinfo.cpFirstSubline + qsubinfo.dcpSubline;
                }
                else
                    plstextcell->cCharsInCell = plstextcell->cpEndCell - plstextcell->cpStartCell + 1;
                *pktFlow = aryLsqsubinfo[nDepth - 1].lstflowSubline;

            }
            else if (nDepth == 0)
            {
                // HACK ALERT(MikeJoch):
                // See hack alert by SujalP below. We can run into this case
                // when the line is terminated by a [section break] type
                // character. We should take it upon ourselves to fill in
                // plstextcell and pktFlow when this happens.
                LONG duIgnore;

                plstextcell->cpStartCell = _lscpLim - 1;
                plstextcell->cpEndCell = _lscpLim;
                plstextcell->dupCell = 0;
                plstextcell->cCharsInCell = 1;

                hr = THR(GetLineWidth( &plstextcell->pointUvStartCell.u, &duIgnore) );

                // If we don't have a level, assume that the flow is in the line direction.
                if (pktFlow)
                {
                    *pktFlow = _li._fRTLLn ? fUDirection : 0;
                }

            }
            else
            {
                hr = E_FAIL;
            }
            break;
        }
        else if (lserr == lserrInsufficientQueryDepth ) 
        {
            if (nDepthIn > NDEPTH_MAX)
            {
                hr = E_FAIL;
                break;
            }
            
            nDepthIn *= 2;
            Assert( nDepthIn <= NDEPTH_MAX );  // That would be rediculous

            hr = THR(aryLsqsubinfo.Grow(nDepthIn));
            if (hr)
                break;

            // Loop back.
        }
        else
        {
            hr = E_FAIL;
            break;
        }
    }

    RRETURN1(hr, S_FALSE);
}

//-----------------------------------------------------------------------------
//
//  Function:   QueryLineCpPpoint (member)
//
//  Synopsis:   Wrapper for LsQueryLineCpPpoint
//
//  Returns:    S_OK    - Success
//              S_FALSE - depth was zero
//              E_FAIL  - error
//
//-----------------------------------------------------------------------------

HRESULT
CLineServices::QueryLineCpPpoint(
    LSCP lscp,                              // IN
    BOOL fFromGetLineWidth,                 // IN
    CDataAry<LSQSUBINFO> * paryLsqsubinfo,  // IN/OUT
    PLSTEXTCELL plstextcell,                // OUT
    BOOL *pfRTLFlow)                        // OUT
{
    CStackDataAry < LSQSUBINFO, 4 > aryLsqsubinfo( Mt(QueryLineCpPpoint_aryLsqsubinfo_pv) );
    HRESULT hr;
    DWORD nDepthIn;
    LSTFLOW ktFlow;
    DWORD nDepth;

    Assert(_plsline);

    if (paryLsqsubinfo == NULL)
    {
        aryLsqsubinfo.Grow(4); // Guaranteed to succeed since we're working from the stack.
        paryLsqsubinfo = &aryLsqsubinfo;
    }
    nDepthIn = paryLsqsubinfo->Size();

    #define NDEPTH_MAX 32

    for (;;)
    {
        LSERR lserr = LsQueryLineCpPpoint( _plsline,
                                           lscp,
                                           nDepthIn,
                                           *paryLsqsubinfo,
                                           &nDepth,
                                           plstextcell);

        if (lserr == lserrNone)
        {
            // HACK ALERT(SujalP):
            // Consider the case where the line contains just 3 characters:
            // A[space][blockbreak] at cp 0, 1 and 2 respectively. If we query
            // LS at cp 2, if would expect lsTextCell to point to the zero
            // width cell containing [blockbreak], meaning that
            // lsTextCell.pointUvStartCell.u would be the width of the line
            // (including whitespaces). However, upon being queried at cp=2
            // LS returns a nDepth of ***0*** because it thinks this is some
            // splat garbage. This problem breaks a lot of our callers, hence
            // we attemp to hack around this problem.
            // NOTE: In case LS fixes their problem, be sure that hittest.htm
            // renders all its text properly for it exhibits a problem because
            // of this problem.
            // ORIGINAL CODE: hr = nDepth ? S_OK : S_FALSE;
            if (nDepth == 0)
            {
                LONG duIgnore;
                
                if (!fFromGetLineWidth && lscp >= _lscpLim - 1)
                {
                    plstextcell->cpStartCell = _lscpLim - 1;
                    plstextcell->cpEndCell = _lscpLim;
                    plstextcell->dupCell = 0;

                    hr = THR(GetLineWidth( &plstextcell->pointUvStartCell.u, &duIgnore) );

                }
                else
                    hr = S_FALSE;

                // If we don't have a level, assume that the flow is in the line direction.
                if(pfRTLFlow)
                    *pfRTLFlow = _li._fRTLLn;

            }
            else
            {
                hr = S_OK;
                LSQSUBINFO &qsubinfo = (*paryLsqsubinfo)[nDepth-1];

                if (   qsubinfo.idobj != LSOBJID_TEXT
                    && qsubinfo.idobj != LSOBJID_GLYPH
                    && qsubinfo.idobj != LSOBJID_EMBEDDED
                   )
                {
                    plstextcell->dupCell = qsubinfo.dupObj;
                    plstextcell->pointUvStartCell = qsubinfo.pointUvStartObj;
                    plstextcell->cCharsInCell = 0;
                    plstextcell->cpStartCell = qsubinfo.cpFirstSubline;
                    plstextcell->cpEndCell = qsubinfo.cpFirstSubline + qsubinfo.dcpSubline;
                }

                // if we are going in the opposite direction of the line we
                // will need to compensate for proper xPos

                ktFlow = qsubinfo.lstflowSubline;
                if(pfRTLFlow)
                    *pfRTLFlow = (ktFlow == lstflowWS);
            }
            break;
        }
        else if (lserr == lserrInsufficientQueryDepth ) 
        {
            if (nDepthIn > NDEPTH_MAX)
            {
                hr = E_FAIL;
                break;
            }
            
            nDepthIn *= 2;
            Assert( nDepthIn <= NDEPTH_MAX );  // That would be ridiculous

            hr = THR(paryLsqsubinfo->Grow(nDepthIn));
            if (hr)
                break;

            // Loop back.
        }
        else
        {
            hr = E_FAIL;
            break;
        }
    }

    if (hr == S_OK)
    {
        Assert((LONG) nDepth <= paryLsqsubinfo->Size());
        paryLsqsubinfo->SetSize(nDepth);
    }

    RRETURN1(hr, S_FALSE);
}

HRESULT
CLineServices::GetLineWidth(LONG *pdurWithTrailing, LONG *pdurWithoutTrailing)
{
    LSERR lserr;
    LONG  duIgnore;
    
    lserr = LsQueryLineDup( _plsline, &duIgnore, &duIgnore, &duIgnore,
                            pdurWithoutTrailing, pdurWithTrailing);
    if (lserr != lserrNone)
        goto Cleanup;

Cleanup:
    return HRFromLSERR(lserr);
}

//-----------------------------------------------------------------------------
//
//  Function:   CLineServices::GetCcs
//
//  Synopsis:   Gets the suitable font (CCcs) for the given COneRun.
//
//  Returns:    CCcs
//
//-----------------------------------------------------------------------------

BOOL
CLineServices::GetCcs(CCcs * pccs, COneRun *por, XHDC hdc, CDocInfo *pdi, BOOL fFontLink)
{
    Assert(pccs);
    
    const CCharFormat *pCF = por->GetCF();
    const BOOL fDontFontLink =    !por->_ptp
                               || !por->_ptp->IsText()
                               || _chPassword
                               || !fFontLink
                               || pCF->_bCharSet == SYMBOL_CHARSET
                               || pCF->_fDownloadedFont
                               || (pdi->_pDoc->_pWindowPrimary && _pMarkup->GetCodePage() == 50000);


    //
    // NB (cthrash) Although generally it will, CCharFormat::_latmFaceName need
    // not necessarily match CBaseCcs::_latmLFFaceName.  This is particularly true
    // when a generic CSS font-family is used (Serif, Fantasy, etc.)  We won't
    // know the actual font properties until we call CCcs::MakeFont.  For this
    // reason, we always compute the _ccsCache first, even though it's
    // possible (not likely, but possible) that we'll never use the font.
    //

           // If we have a different pCF then what _ccsCache is based on,
    if (   pCF != _pCFCache
           // *or* If we dont have a cached _ccsCache
        || !_ccsCache.GetBaseCcs()
           // *or* If we are switching from TT mode to non-TT mode, or vice versa 
        || (!!pccs->GetForceTTFont() ^ !!_ccsCache.GetForceTTFont()) 
       )
    {
        if (fc().GetCcs(pccs, hdc, pdi, pCF))
        {
            if (CM_UNINITED != por->_bConvertMode)
            {
                pccs->SetConvertMode((CONVERTMODE)por->_bConvertMode); 
            }

            _pCFCache = (!por->_fMustDeletePcf ? pCF : NULL);
            _ccsCache.Release();
            _ccsCache = *pccs;
        }
        else
        {
            AssertSz(0, "CCcs failed to be created.");
            goto Cleanup;
        }
    }

    Assert(pCF == _pCFCache || por->_fMustDeletePcf);
    *pccs = _ccsCache;
    
    if (fDontFontLink)
        goto Cleanup;
    else
    {
        BOOL fCheckAltFont;   // TRUE if _pccsCache does not have glyphs needed for sidText
        BOOL fPickNewAltFont; // TRUE if _pccsAltCache needs to be created anew
        SCRIPT_ID sidAlt = 0;
        BYTE bCharSetAlt = 0;
        SCRIPT_ID sidText;
        
        //
        // Check if the _ccsCache covers the sid of the text run
        //

        sidText = por->_sid;

        AssertSz( sidText != sidMerge, "Script IDs should have been merged." );
        AssertSz( sidText != sidAmbiguous || por->_synthType != CLineServices::SYNTHTYPE_NONE, "Script IDs should have been disambiguated." );
        Assert(     por->_lsCharProps.fGlyphBased 
                ||  (   !_pNodeLi && por->_ptp->Sid() == sidHan
                    &&  (   sidText == sidHangul          //
                        ||  sidText == sidBopomofo        // UnunifyHanScript can change sidHan to one of them,
                        ||  sidText == sidKana            // sidDefault when MLang is not loaded
                        ||  sidText == sidHan             //
                        ||  sidText == sidDefault)        //
                    )
                ||  (!_pNodeLi && por->_ptp->Sid() == sidAmbiguous)
                ||  sidText == (!_pNodeLi ? DWORD(por->_ptp->Sid()) : sidAsciiLatin));


        {
            // sidHalfWidthKana has to be treated as sidKana
            if (sidText == sidHalfWidthKana)
                sidText = sidKana;

            const CBaseCcs * pBaseCcs = _ccsCache.GetBaseCcs();
            Assert(pBaseCcs);

            if (sidText == sidDefault)
            {
                fCheckAltFont = FALSE; // Assume the author picked a font containing the glyph.  Don't fontlink.
            }
            else if (sidText == sidEUDC)
            {
                const UINT uiFamilyCodePage = _pMarkup->GetFamilyCodePage();
                SCRIPT_ID sidForPUA;

                fCheckAltFont = ShouldSwitchFontsForPUA( hdc, uiFamilyCodePage, pBaseCcs, pCF, &sidForPUA );
                if (fCheckAltFont)
                {
                    sidText = sidAlt = sidAmbiguous;
                    bCharSetAlt = DefaultCharSetFromScriptAndCodePage( sidForPUA, uiFamilyCodePage );
                }
            }
            else 
            {
                fCheckAltFont = (pBaseCcs->_sids & ScriptBit(sidText)) == sidsNotSet;
            }
        }

        if (!fCheckAltFont)
            goto Cleanup;

        //
        // Check to see if the _ccsAltCache covers the sid of the text run
        //

        if (sidText != sidAmbiguous)
        {
            SCRIPT_IDS sidsFace = fc().EnsureScriptIDsForFont(hdc, _ccsCache.GetBaseCcs(), FC_SIDS_USEMLANG);

            if (IsFESid(sidText))
            {
                // 
                // To render FE characters we need to keep current font if only possible,
                // even if it is used to render non-native characters.
                // So try to pickup the most appropriate charset, because GDI prefers 
                // charset over font face during font creation.
                // In case of FE lang id, use charset appropriate for it. This is because
                // lang id has highest priority font selection in case of FE characters.
                //
                if (pCF->_lcid)
                {
                    bCharSetAlt = CharSetFromLangId(LANGIDFROMLCID(pCF->_lcid));
                    if (!IsFECharset(bCharSetAlt))
                    {
                        bCharSetAlt = DefaultCharSetFromScriptsAndCodePage(sidsFace, sidText, _pMarkup->GetFamilyCodePage());
                    }
                }
                else
                    bCharSetAlt = DefaultCharSetFromScriptsAndCodePage(sidsFace, sidText, _pMarkup->GetFamilyCodePage());
            }
            else
                bCharSetAlt = DefaultCharSetFromScriptAndCodePage(sidText, _pMarkup->GetFamilyCodePage());

            if ((sidsFace & ScriptBit(sidText)) == sidsNotSet)
            {
                sidAlt = sidText;           // current face does not cover
            }
            else
            {
                sidAlt = sidAmbiguous;      // current face does cover
            }
        }

        fPickNewAltFont =   !_ccsAltCache.GetBaseCcs()
                         || sidAlt != sidAmbiguous
                         || _pCFAltCache != pCF
                         || _bCrcFontAltCache != pCF->_bCrcFont   // pCF might be equal to _pCFAltCache even if they
                                                                  // point to different objects. It may happen when 
                                                                  // _pCFAltCache is cached in the previous line and memory
                                                                  // is deallocated, so there is a chance to reuse it
                                                                  // for another object in the next line.
                         || _ccsAltCache.GetBaseCcs()->_bCharSet != bCharSetAlt;

        //
        // Looks like we need to pick a new alternate font
        //

        if (!fPickNewAltFont)
        {
            Assert(_ccsAltCache.GetBaseCcs());
            *pccs = _ccsAltCache;
        }
        else
        {
            CCharFormat cfAlt = *pCF;

            // sidAlt of sidAmbiguous at this point implies we have the right facename,
            // but the wrong GDI charset.  Otherwise, lookup in the registry/mlang to
            // determine an appropriate font for the given script id.

            if (sidAlt != sidAmbiguous)
            {
                SelectScriptAppropriateFont( sidAlt, bCharSetAlt, pdi->_pDoc, pdi->_pMarkup, &cfAlt );
            }
            else
            {
                cfAlt._bCharSet = bCharSetAlt;
                cfAlt._bCrcFont = cfAlt.ComputeFontCrc();
            }

            if (fc().GetFontLinkCcs(pccs, hdc, pdi, &_ccsCache, &cfAlt))
            {
                // Remember the pCF from which the pccs was derived.
                _pCFAltCache = pCF;
                _bCrcFontAltCache = pCF->_bCrcFont;
                _ccsAltCache.Release();
                _ccsAltCache = *pccs;
                _ccsAltCache.MergeSIDs(ScriptBit(sidAlt));
            }
        }
    }
    
Cleanup:
    Assert(!pccs->GetBaseCcs() || pccs->GetHDC() == hdc);
    return !!pccs->GetBaseCcs();
}

//-----------------------------------------------------------------------------
//
//  Function:   LineHasNoText
//
//  Synopsis:   Utility function which returns TRUE if there is no text (only nested
//              layout or antisynth'd goop) on the line till the specified cp.
//
//  Returns:    BOOL
//
//-----------------------------------------------------------------------------
BOOL
CLineServices::LineHasNoText(LONG cp)
{
    LONG fRet = TRUE;
    for (COneRun *por = _listCurrent._pHead; por; por = por->_pNext)
    {
        if (por->Cp() >= cp)
            break;

        if (!por->IsNormalRun())
            continue;
        
        if (por->_lsCharProps.idObj == LSOBJID_TEXT)
        {
            fRet = FALSE;
            break;
        }
    }
    return fRet;
}

void
CLineServices::AdjustLineHeightForMBP()
{
    Assert(_fHasMBP);

    COneRun *por;
    LONG cpLast = GetMeasurer()->_cp;
    LONG ld = _yOriginalDescent;        // Line descent
    LONG la = _li._yExtent - ld;        // Line ascent
    LONG rd;                            // Run descent
    LONG ra;                            // Run ascent
    LONG da;                            // Distance from the top of extent to top of run
    LONG dd;                            // Distance from bottom of run to bottom of extent
    LONG mbpa = 0;                      // This much to increase the top of extent by
    LONG mbpd = 0;                      // This much to increase bottom of extent by
    
    por = _listCurrent._pHead;
    while(   por
          && por->Cp() < cpLast
         )
    {
        if (   por->IsNormalRun()
            && (!por->_fNoTextMetrics || por->_fCharsForNestedLayout)
           )
        {
            // If this run is included in the line, then it had better been processed.
            Assert(!por->_fNotProcessedYet);
            
            if (por->_fCharsForNestedLayout || _fHasVerticalAlign)
            {
                ra = la - por->_yProposed;
                rd = por->_yObjHeight - ra;
            }
            else
            {
                const CCharFormat * pCF;
                const CBaseCcs *pBaseCcs;
                CCcs ccs;

                Assert(por->_lsCharProps.idObj == LSOBJID_TEXT);
                pCF = por->GetCF();
                if (!GetCcs(&ccs, por, _pci->_hdc, _pci))
                {
                    goto Cleanup;
                }
                pBaseCcs = ccs.GetBaseCcs();
                rd = pBaseCcs->_yDescent;
                ra = pBaseCcs->_yHeight - rd;
            }
            
            da = la - ra;
            dd = ld - rd;

            // da is the height available to place MBPTop in. If it is insufficient
            // then we will have to increase the extent to satisfy it. Similar for
            // the bottom/descent case.
            mbpa = max(mbpa, por->_mbpTop - da);
            mbpd = max(mbpd, por->_mbpBottom - dd);
        }
        por = por->_pNext;
    }
    _li._yExtent += mbpa + mbpd;
    _li._yHeightTopOff -= mbpa;

Cleanup:    
    return;
}

DeclareTag(tagCharShape, "LineServices", "Char shape information");

void
CLineServices::KernHeightToGlyph(COneRun *por, CCcs *pccs, PLSTXM plsTxMet)
{
    LONG dvA = 0;
    LONG dvD = 0;
    GLYPHMETRICS gm = {0};  // keep compiler happy
    LONG i;
    MAT2 mat;
    DWORD retVal = 0;
    CLSMeasurer &me = *_pMeasurer;
    
    Assert(retVal != GDI_ERROR);
    
    memset(&mat, 0, sizeof(mat));
    mat.eM11.value = 1;
    mat.eM22.value = 1;
    
    FONTIDX hFontOld = pccs->PushFont(pccs->GetHDC());
    
    Assert(por->_pchBase);
    for (i = 0; i < por->_lscch; i++)
    {
        LONG yChAscent;
        LONG yChDescent;

        if (g_dwPlatformID >= VER_PLATFORM_WIN32_NT)
        {
            retVal = GetGlyphOutlineW(pccs->GetHDC(), por->_pchBase[i], GGO_METRICS, &gm, 0, NULL, &mat);
        }
        else
        {
            // WIN9x does not implement the 'W' version of this function and it also cannot take
            // multibyte values. So we just hack here -- if the value is is in the lower ascii
            // range we do the kerning, else we just forget it.
            if (CanQuickBrkclsLookup(por->_pchBase[i]))
                retVal = GetGlyphOutlineA(pccs->GetHDC(), por->_pchBase[i], GGO_METRICS, &gm, 0, NULL, &mat);
            else
                retVal = GDI_ERROR;
        }

        if (GDI_ERROR == retVal)
        {
            break;
        }

        yChAscent = gm.gmptGlyphOrigin.y;
        dvA = max(dvA, yChAscent);

        yChDescent = gm.gmBlackBoxY - yChAscent;
        dvD = max(dvD, yChDescent);
    }

    me._aryFLSlab.DeleteAll();
    
#ifdef FL_TIGHTWRAP
    if (por->_lscch == 1)
    {
        LONG memAllocSize = GetGlyphOutlineW(pccs->GetHDC(), por->_pchBase[0], GGO_BITMAP, &gm, 0, NULL, &mat);
        if (memAllocSize != GDI_ERROR)
        {
            BYTE *aBits = (BYTE*)MemAlloc(Mt(GetGlyphOutline), memAllocSize);
            if (aBits != NULL)
            {
                WHEN_DBG(CStr str;)
                LONG nRows = gm.gmBlackBoxY;
                LONG nCols = gm.gmBlackBoxX;
                LONG iRow, iCol, pixel;
                LONG nPixelsPerByte = 8;
                LONG rowStart = 0;

                CFLSlab flSlab;
                LONG xCurrIndent;
                
                LONG nBytesPerRow = memAllocSize / nRows;
                LONG retVal = GetGlyphOutlineW(pccs->GetHDC(), por->_pchBase[0], GGO_BITMAP, &gm, memAllocSize, aBits, &mat);

                flSlab._xWidth = LONG_MAX;
                flSlab._yHeight = 0;
                for (iRow = 0;iRow < nRows; iRow++)
                {
                    WHEN_DBG(str.Free();)
                    xCurrIndent = 0;
                    for (iCol = nCols - 1; iCol >= 0; iCol--)
                    {
                        LONG rowOffset = iCol / nPixelsPerByte;
                        LONG bitOffset = iCol % nPixelsPerByte;
                        pixel = aBits[rowStart + rowOffset] & (1 << (7 - bitOffset));
                        if (pixel)
                        {
                            WHEN_DBG(str.Append(_T("*"));)
                            break;
                        }
                        else
                        {
                            xCurrIndent++;
                            WHEN_DBG(str.Append(_T("_"));)
                        }
                    }
                    flSlab._xWidth = min(flSlab._xWidth, xCurrIndent);
                    flSlab._yHeight++;
                    if ((iRow % 2) != 0)
                    {
                        me._aryFLSlab.AppendIndirect(&flSlab);
                        flSlab._xWidth = LONG_MAX;
                        flSlab._yHeight = 0;
                    }
                    
                    rowStart += nBytesPerRow;
                    TraceTag((tagCharShape, "%S", LPTSTR(str)));
                }
                if ((nRows % 2) != 0)
                {
                    me._aryFLSlab.AppendIndirect(&flSlab);
                }
                
                MemFree(aBits);
            }
        }
    }
#endif

    const CBaseCcs *pBaseCcs = pccs->GetBaseCcs();
    Assert(pBaseCcs);
    if(pBaseCcs->_fScalingRequired)
    {
        dvA *= pBaseCcs->_flScaleFactor;
        dvD *= pBaseCcs->_flScaleFactor;
    }

    if (me._aryFLSlab.Size() == 0)
    {
        CFLSlab flSlab;
        flSlab._xWidth = 0;
        flSlab._yHeight = dvA + dvD;
        me._aryFLSlab.AppendIndirect(&flSlab);
    }
    
    if (retVal != GDI_ERROR)
    {
        plsTxMet->dvAscent = dvA;
        plsTxMet->dvDescent = dvD;
        por->_fKerned = TRUE;
    }
    
    pccs->PopFont(pccs->GetHDC(), hFontOld);
}


//-----------------------------------------------------------------------------
//
//  Function:   CheckSetTables (member)
//
//  Synopsis:   Set appropriate tables for Line Services
//
//  Returns:    HRESULT
//
//-----------------------------------------------------------------------------

HRESULT
CLineServices::CheckSetTables()
{
    LSERR lserr;

    lserr = CheckSetBreaking();

    if (   lserr == lserrNone
        && _pPFFirst->_uTextJustify > styleTextJustifyInterWord)
    {
        lserr = CheckSetExpansion();

        if (lserr == lserrNone)
        {
            lserr = CheckSetCompression();
        }
    }

    RRETURN(HRFromLSERR(lserr));
}


//-----------------------------------------------------------------------------
//
//  Function:   CheckForPaddingBorder
//
//  Synopsis: If we going to consume a block element and it has
//              either padding or borders, then the line cannot be a
//              dummy line. To ensure that mark the line as being
//              empty, but having padding or borders. Ideally,
//              CalcBeforeSpace should have marked this, byut there
//              might be intervening spaces which might cause
//              CalcBeforeSpace to not see this end splay tag.
//
//  Returns:    Nothing
//
//-----------------------------------------------------------------------------
void
CLineServices::CheckForPaddingBorder(COneRun *por)
{
    CTreePos *ptp = por->_ptp;
    
    // If it is already marked correctly, the do nothing.
    if (_pMeasurer->_fEmptyLineForPadBord)
        goto Cleanup;

    if (ptp->IsEndElementScope())
    {
        CTreeNode *pNode = ptp->GetBranch();
        CElement  *pElement = pNode->Element();
        LONG       lFontHeight = por->GetCF()->GetHeightInTwips(pElement->Doc());

        Assert(_pFlowLayout->IsElementBlockInContext(pElement));
        
        if (!pElement->_fDefinitelyNoBorders)
        {
            CBorderInfo borderinfo;

            pElement->_fDefinitelyNoBorders = !GetBorderInfoHelper(pNode, _pci, &borderinfo, GBIH_NONE);
            if (!pElement->_fDefinitelyNoBorders)
            {
                if (borderinfo.aiWidths[SIDE_BOTTOM])
                {
                    _pMeasurer->_fEmptyLineForPadBord = TRUE;
                    goto Cleanup;
                }
            }
        }

        if (por->GetFF()->GetLogicalPadding(SIDE_BOTTOM, por->GetCF()->HasVerticalLayoutFlow(), 
                                                         por->GetCF()->_fWritingModeUsed).YGetPixelValue(
                _pci,
                _pci->_sizeParent.cx, 
                lFontHeight))
        {
            _pMeasurer->_fEmptyLineForPadBord = TRUE;
            goto Cleanup;
        }
    }
Cleanup:
    return;
}


//-----------------------------------------------------------------------------
//
//  Function:   ShouldBreakInNOBR
//
//  Synopsis: This function decies whether we should cut up a NOBR or not. We cut
//      up a NOBR only in one situation -- when it has a trailing space and that
//      space causes the NOBR object to overflow the right margin. In this case,
//      we return TRUE and return the width of the overflowing space.
//
//-----------------------------------------------------------------------------
BOOL
CLineServices::ShouldBreakInNOBR(LONG lscpForStartOfNOBR,
                                 LONG lscpForEndOfNOBR,
                                 LONG xOverflowWidth,
                                 LONG xNOBRTermination,
                                 LONG *pxWidthOfSpace)
{
    BOOL fBreak = FALSE;
    COneRun *por = FindOneRun(lscpForEndOfNOBR);

    *pxWidthOfSpace = -1;
    
    if (!por)
        goto Cleanup;

    if (_lsMode != LSMODE_MEASURER)
        goto Cleanup;
    
    while(por)
    {
        if (   s_aSynthData[por->_synthType].idObj != idObjTextChp
            || por->IsAntiSyntheticRun()
           )
        {
            por = por->_pPrev;
        }
        else
        {
            if (por->_fCharsForNestedLayout)
                break;
            AssertSz(!por->_fCharsForNestedElement, "All of these which are not nestedlo's should be antisynth'd");
            if (!por->_lscch)
            {
                por = por->_pPrev;
            }

            // Be sure the you have not crossed over to before the NOBR
            // and that the trailing character is a space character.
            else if (   por->_lscpBase + por->_lscch > lscpForStartOfNOBR

                        // The check below was for isspace, but was made
                        // a comparison with just WCH_SPACE because we do
                        // not want to cause a NBSP to go to the next line
                        // since that may unecessarily give the next line
                        // a height and moreover, an NBSP will contribute
                        // to width on _this_ line. (Bug 106014)
                     && (WCH_SPACE == por->_pchBase[por->_lscch - 1])
                    )
            {
                CCcs  ccs;
                if (GetCcs(&ccs, por, _pci->_hdc, _pci))
                {
                    if (ccs.Include(por->_pchBase[por->_lscch - 1], (long&)*pxWidthOfSpace))
                    {
                        // We break if we are overflowing because of the space's width
                        fBreak = xOverflowWidth >= (xNOBRTermination - *pxWidthOfSpace);
                    }
                }
                break;
            }
            else
            {
                break;
            }
        }
    } // while

    // if the NOBR is followed by a BR, then too we do not want to break since
    // it will cause the next line to have a space and a BR and hence have a height
    if (   fBreak
        && _lineFlags.GetLineFlags(CPFromLSCP(lscpForEndOfNOBR) + 1) & FLAG_HAS_A_BR
       )
        fBreak = FALSE;
    
Cleanup:
    return fBreak;
}

//-----------------------------------------------------------------------------
//
//  Function:   HasVisualContent
//
//  Synopsis:   Returns true if we have any rendered content on the line.
//
//  Returns:    BOOL
//
//-----------------------------------------------------------------------------

BOOL
CLineServices::HasVisualContent()
{
    BOOL fHasContent = FALSE;
    
    for (COneRun *por = _listCurrent._pHead; por; por = por->_pNext)
    {
        if (por->_lscpBase >= _lscpLim)
            break;

        if (por->IsNormalRun())
        {
            fHasContent = TRUE;
            break;
        }
    }
    return fHasContent;
}

BOOL
CLineServices::HasSomeSpacing(const CCharFormat *pCF)
{
    return (GetLetterSpacing(pCF) || GetWordSpacing(pCF));
}

//-----------------------------------------------------------------------------
//
//  Function:   GetLOrWSpacing
//
//  Synopsis:   Returns the value of letterspacing/wordspacing
//
//  Returns:    int
//
//-----------------------------------------------------------------------------

int
CLineServices::GetLOrWSpacing(const CCharFormat *pCF, BOOL fLetter)
{
    int xSpacing;
    CUnitValue cuvSpacing;

    // CSS Letter-spacing/word-spacing
    cuvSpacing = fLetter ? pCF->_cuvLetterSpacing : pCF->_cuvWordSpacing;
    switch (cuvSpacing.GetUnitType())
    {
        case CUnitValue::UNIT_INTEGER:
                xSpacing = (int)cuvSpacing.GetUnitValue();
        break;

        case CUnitValue::UNIT_ENUM:
                xSpacing = 0;     // the only allowable enum value for l-s is normal=0
        break;

        default:
            xSpacing = (int)cuvSpacing.XGetPixelValue(_pci, 0,
                _pFlowLayout->GetFirstBranch()->GetFontHeightInTwips(&cuvSpacing));
    }

    return xSpacing;
}


//-----------------------------------------------------------------------------
//
//  Function:   HRFromLSERR (global)
//
//  Synopsis:   Utility function to converts a LineServices return value
//              (LSERR) into an appropriate HRESULT.
//
//  Returns:    HRESULT
//
//-----------------------------------------------------------------------------

HRESULT
HRFromLSERR( LSERR lserr )
{
    HRESULT hr;

#if DBG==1
    if (lserr != lserrNone)
    {
        char ach[64];

        StrCpyA( ach, "Line Services returned an error: " );
        StrCatA( ach, LSERRName(lserr) );

        AssertSz( FALSE, ach );
    }
#endif
    
    switch (lserr)
    {
        case lserrNone:         hr = S_OK;          break;
        case lserrOutOfMemory:  hr = E_OUTOFMEMORY; break;
        default:                hr = E_FAIL;        break;
    }

    return hr;
}

//-----------------------------------------------------------------------------
//
//  Function:   LSERRFromHR (global)
//
//  Synopsis:   Utility function to converts a HRESULT into an appropriate
//              LineServices return value (LSERR).
//
//  Returns:    LSERR
//
//-----------------------------------------------------------------------------

LSERR
LSERRFromHR( HRESULT hr )
{
    LSERR lserr;

    if (SUCCEEDED(hr))
    {
        lserr = lserrNone;
    }
    else
    {
        switch (hr)
        {
            default:
                AssertSz(FALSE, "Unmatched error code; returning lserrOutOfMemory");
            case E_OUTOFMEMORY:     lserr = lserrOutOfMemory;   break;
        }
    }

    return lserr;
}

#if DBG==1
//-----------------------------------------------------------------------------
//
//  Function:   LSERRName (global)
//
//  Synopsis:   Return lserr in a string form.
//
//-----------------------------------------------------------------------------

static const char * rgachLSERRName[] =
{
    "None",
    "InvalidParameter",//           (-1L)
    "OutOfMemory",//                (-2L)
    "NullOutputParameter",//        (-3L)
    "InvalidContext",//             (-4L)
    "InvalidLine",//                (-5L)
    "InvalidDnode",//               (-6L)
    "InvalidDeviceResolution",//    (-7L)
    "InvalidRun",//                 (-8L)
    "MismatchLineContext",//        (-9L)
    "ContextInUse",//               (-10L)
    "DuplicateSpecialCharacter",//  (-11L)
    "InvalidAutonumRun",//          (-12L)
    "FormattingFunctionDisabled",// (-13L)
    "UnfinishedDnode",//            (-14L)
    "InvalidDnodeType",//           (-15L)
    "InvalidPenDnode",//            (-16L)
    "InvalidNonPenDnode",//         (-17L)
    "InvalidBaselinePenDnode",//    (-18L)
    "InvalidFormatterResult",//     (-19L)
    "InvalidObjectIdFetched",//     (-20L)
    "InvalidDcpFetched",//          (-21L)
    "InvalidCpContentFetched",//    (-22L)
    "InvalidBookmarkType",//        (-23L)
    "SetDocDisabled",//             (-24L)
    "FiniFunctionDisabled",//       (-25L)
    "CurrentDnodeIsNotTab",//       (-26L)
    "PendingTabIsNotResolved",//    (-27L)
    "WrongFiniFunction",//          (-28L)
    "InvalidBreakingClass",//       (-29L)
    "BreakingTableNotSet",//        (-30L)
    "InvalidModWidthClass",//       (-31L)
    "ModWidthPairsNotSet",//        (-32L)
    "WrongTruncationPoint",//       (-33L)
    "WrongBreak",//                 (-34L)
    "DupInvalid",//                 (-35L)
    "RubyInvalidVersion",//         (-36L)
    "TatenakayokoInvalidVersion",// (-37L)
    "WarichuInvalidVersion",//      (-38L)
    "WarichuInvalidData",//         (-39L)
    "CreateSublineDisabled",//      (-40L)
    "CurrentSublineDoesNotExist",// (-41L)
    "CpOutsideSubline",//           (-42L)
    "HihInvalidVersion",//          (-43L)
    "InsufficientQueryDepth",//     (-44L)
    "InsufficientBreakRecBuffer",// (-45L)
    "InvalidBreakRecord",//         (-46L)
    "InvalidPap",//                 (-47L)
    "ContradictoryQueryInput",//    (-48L)
    "LineIsNotActive",//            (-49L)
    "Unknown"
};

const char *
LSERRName( LSERR lserr )
{
    int err = -(int)lserr;

    if (err < 0 || err >= ARRAY_SIZE(rgachLSERRName))
    {
        err = ARRAY_SIZE(rgachLSERRName) - 1;
    }

    return rgachLSERRName[err];
}

#endif // DBG==1

#if DBG == 1 || defined(DUMPTREE)
void
CLineServices::DumpTree()
{
    GetMarkup()->DumpTree();
}

void
CLineServices::DumpUnicodeInfo(TCHAR ch)
{
    CHAR_CLASS CharClassFromChSlow(WCHAR wch);
    char ab[180];
    UINT u;

    HANDLE hf = CreateFile(
                _T("c:\\x"),
                GENERIC_WRITE | GENERIC_READ,
                FILE_SHARE_WRITE | FILE_SHARE_READ,
                NULL,
                OPEN_ALWAYS,
                FILE_ATTRIBUTE_NORMAL,
                NULL);
    
    for (u=0;u<0x10000;u++)
    {
        ch = TCHAR(u);
        
        CHAR_CLASS cc = CharClassFromChSlow(ch);
        SCRIPT_ID sid = ScriptIDFromCharClass(cc);

        if (sid == sidDefault)
        {
            DWORD nbw;
            int i = wsprintfA(ab, "{ 0x%04X, %d },\r", ch, cc );
            WriteFile( hf, ab, i, &nbw, NULL);
        }
    }
}

#ifndef X_TXTDEFS_H_
#define X_TXTDEFS_H_
#include "txtdefs.h"
#endif

DWORD TestAmb()
{
    int i;

    for (i=0;i<65536;i++)
    {
        SCRIPT_ID sid = ScriptIDFromCh(WCHAR(i));

        if (sid == sidDefault)
        {
            char abBuf[32];
            
            wsprintfA(abBuf, "0x%04x\r\n", i);
            OutputDebugStringA(abBuf);
        }
    }

    return 0;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\text\paste.cxx ===
//+----------------------------------------------------------------------------
// WARNING WARNING WARNING WARNING WARNING WARNING WARNING WARNING WARNING
// WARNING WARNING WARNING WARNING WARNING WARNING WARNING WARNING WARNING
//
// This file contains the object model paste and ie50 compat ui paste.  No
// changes in behavior should be introduced for compatibility with
// ie40/ie50.  For the new ui paste (>ie60), see uipaste.cxx.
//
// WARNING WARNING WARNING WARNING WARNING WARNING WARNING WARNING WARNING
// WARNING WARNING WARNING WARNING WARNING WARNING WARNING WARNING WARNING
//-----------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_TPOINTER_HXX_
#define X_TPOINTER_HXX_
#include "tpointer.hxx"
#endif

#ifndef X_MARKUP_HXX_
#define X_MARKUP_HXX_
#include "markup.hxx"
#endif

#ifndef X_TREEPOS_HXX_
#define X_TREEPOS_HXX_
#include "treepos.hxx"
#endif

#ifndef X_BREAKER_HXX_
#define X_BREAKER_HXX_
#include "breaker.hxx"
#endif

#ifndef X_FLOWLYT_HXX_
#define X_FLOWLYT_HXX_
#include "flowlyt.hxx"
#endif

#ifndef X_COMMENT_HXX_
#define X_COMMENT_HXX_
#include "comment.hxx"
#endif

#ifndef X_WCHDEFS_H_
#define X_WCHDEFS_H_
#include "wchdefs.h"
#endif

//+----------------------------------------------------------------------------
//
//  Functions:  Equal & Compare
//
//  Synopsis:   Helpers for comparing IMarkupPointers
//
//-----------------------------------------------------------------------------

static inline BOOL
IsEqualTo ( IMarkupPointer * p1, IMarkupPointer * p2 )
{
    BOOL fEqual;
    IGNORE_HR( p1->IsEqualTo( p2, & fEqual ) );
    return fEqual;
}

static inline int
Compare ( IMarkupPointer * p1, IMarkupPointer * p2 )
{
    int result;
    IGNORE_HR( OldCompare( p1, p2, & result ) );
    return result;
}

//+----------------------------------------------------------------------------
//
//  Function:   FixupPasteSourceFragComments
//
//  Synopsis:   Remove the fragment begin and end comments which occur
//              in CF_HTML.
//
//-----------------------------------------------------------------------------

static HRESULT
FixupPasteSourceFragComments(
    CDoc * pDoc,
    IMarkupPointer * pSourceStart,
    IMarkupPointer * pSourceFinish )
{
    HRESULT        hr = S_OK;
    CMarkupPointer pmp ( pDoc );

    //
    // Remove the start frag comment
    //

    hr = THR( pmp.MoveToPointer( pSourceStart ) );

    if (hr)
        goto Cleanup;

    for ( ; ; )
    {
        CTreeNode *         pNode;
        MARKUP_CONTEXT_TYPE ct;
        
        hr = THR( pmp.Left( TRUE, & ct, & pNode, NULL, NULL, NULL ) );

        if (hr)
            goto Cleanup;

        if (ct == CONTEXT_TYPE_None)
            break;

        if (ct == CONTEXT_TYPE_NoScope && pNode->Tag() == ETAG_RAW_COMMENT)
        {
            CCommentElement * pElemComment;
            
            pElemComment = DYNCAST( CCommentElement, pNode->Element() );

            if (pElemComment->_fAtomic &&
                !StrCmpIC( pElemComment->_cstrText, _T( "<!--StartFragment-->" ) ))
            {
                hr = THR( pDoc->RemoveElement( pElemComment ) );

                if (hr)
                    goto Cleanup;

                break;
            }
        }
    }

    //
    // Remove the end frag comment
    //

    hr = THR( pmp.MoveToPointer( pSourceFinish ) );

    if (hr)
        goto Cleanup;

    for ( ; ; )
    {
        CTreeNode *         pNode;
        MARKUP_CONTEXT_TYPE ct;
        
        hr = THR( pmp.Right( TRUE, & ct, & pNode, NULL, NULL, NULL ) );

        if (hr)
            goto Cleanup;

        if (ct == CONTEXT_TYPE_None)
            break;

        if (ct == CONTEXT_TYPE_NoScope && pNode->Tag() == ETAG_RAW_COMMENT)
        {
            CCommentElement * pElemComment;
            
            pElemComment = DYNCAST( CCommentElement, pNode->Element() );

            if (pElemComment->_fAtomic &&
                !StrCmpIC( pElemComment->_cstrText, _T( "<!--EndFragment-->" ) ))
            {
                hr = THR( pDoc->RemoveElement( pElemComment ) );

                if (hr)
                    goto Cleanup;

                break;
            }
        }
    }

Cleanup:

    RRETURN( hr );
}
                             
//+----------------------------------------------------------------------------
//
//  Function:   FixupPasteSourceTables
//
//  Synopsis:   Makes sure that whole (not parts of) tables are included in
//              the source of a paste.
//
//-----------------------------------------------------------------------------

static HRESULT
FixupPasteSourceTables (
    CDoc * pDoc,
    CMarkupPointer * pSourceStart,
    CMarkupPointer * pSourceFinish )
{
    HRESULT hr = S_OK;
    CMarkupPointer pointer ( pDoc );

    Assert( pSourceStart->IsLeftOfOrEqualTo( pSourceFinish ) );
    
    for ( pointer.MoveToPointer( pSourceStart ) ; pointer.IsLeftOf( pSourceFinish ) ; )
    {
        MARKUP_CONTEXT_TYPE ct;
        CTreeNode * pNode;
        
        hr = THR( pointer.Right( TRUE, & ct, & pNode, NULL, NULL, NULL ) );

        if (hr)
            goto Cleanup;

        if (ct == CONTEXT_TYPE_EnterScope)
        {
            switch ( pNode->Element()->Tag() )
            {
            case ETAG_TC : case ETAG_TD : case ETAG_TR : case ETAG_TBODY :
            case ETAG_THEAD : case ETAG_TFOOT : case ETAG_TH : case ETAG_TABLE :
            {
                CTreeNode * pNodeTable =
                    pNode->SearchBranchToRootForTag( ETAG_TABLE );

                if (pNodeTable)
                {
                    CMarkupPointer pointerTable ( pDoc );

                    hr = THR(
                        pointerTable.MoveAdjacentToElement(
                            pNodeTable->Element(), ELEM_ADJ_BeforeBegin ) );

                    if (hr)
                        goto Cleanup;

                    if (pointerTable.IsLeftOf( pSourceStart ))
                    {
                        hr = THR( pSourceStart->MoveToPointer( & pointerTable ) );

                        if (hr)
                            goto Cleanup;
                    }
                    
                    hr = THR(
                        pointerTable.MoveAdjacentToElement(
                            pNodeTable->Element(), ELEM_ADJ_AfterEnd ) );

                    if (hr)
                        goto Cleanup;

                    if (pointerTable.IsRightOf( pSourceFinish ))
                    {
                        hr = THR( pSourceFinish->MoveToPointer( & pointerTable ) );

                        if (hr)
                            goto Cleanup;
                    }
                    hr = THR( pointer.MoveToPointer( &pointerTable ) );
                    if (hr)
                        goto Cleanup;
                    
                }
            }
        }
        }
    }

Cleanup:

    RRETURN( hr );
}

//+----------------------------------------------------------------------------
//
//  Function:   FixupPasteSourceBody
//
//  Synopsis:   Makes sure the <body> is NOT included in the source of the
//              paste.
//
//-----------------------------------------------------------------------------

static HRESULT
Contain (
    CMarkupPointer * pointer,
    CMarkupPointer * pointerLeft,
    CMarkupPointer * pointerRight )
{
    HRESULT hr = S_OK;
    
    if (Compare( pointerLeft, pointer ) > 0)
    {
        hr = THR( pointer->MoveToPointer( pointerLeft ) );

        if (hr)
            goto Cleanup;
    }

    if (Compare( pointerRight, pointer ) < 0)
    {
        hr = THR( pointer->MoveToPointer( pointerRight ) );

        if (hr)
            goto Cleanup;
    }

Cleanup:

    RRETURN( hr );
}

static HRESULT
FixupPasteSourceBody (
    CDoc *           pDoc,
    CMarkupPointer * pPointerSourceStart,
    CMarkupPointer * pPointerSourceFinish )
{
    HRESULT        hr = S_OK;
    CElement *     pElementClient;
    CMarkup *      pMarkup;
    CMarkupPointer pointerBodyStart( pDoc );
    CMarkupPointer pointerBodyFinish( pDoc );

    //
    // Get the markup container associated with the sel
    //

    pMarkup = pPointerSourceStart->Markup();

    Assert( pMarkup );

    //
    // Get the client element from the markup and check to make sure
    // it's there and is a body element.
    //

    pElementClient = pMarkup->GetElementClient();

    if (!pElementClient || pElementClient->Tag() != ETAG_BODY)
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    //
    // Move temp pointers to the inside edges of the body
    //

    hr = THR(
        pointerBodyStart.MoveAdjacentToElement(
            pElementClient, ELEM_ADJ_AfterBegin ) );

    if (hr)
        goto Cleanup;

    hr = THR(
        pointerBodyFinish.MoveAdjacentToElement(
            pElementClient, ELEM_ADJ_BeforeEnd ) );

    if (hr)
        goto Cleanup;

    //
    // Make sure the source start and finish are within the body
    //

    hr = THR( Contain( pPointerSourceStart, & pointerBodyStart, & pointerBodyFinish ) );

    if (hr)
        goto Cleanup;
    
    hr = THR( Contain( pPointerSourceFinish, & pointerBodyStart, & pointerBodyFinish ) );
    
    if (hr)
        goto Cleanup;

Cleanup:
    
    RRETURN( hr );
}

//+----------------------------------------------------------------------------
//
//  Function:   FixupPasteSource
//
//  Synopsis:   Makes sure the source of a paste is valid.  This means, for
//              the most part, that sub-parts of tables must not be pasted
//              without their corresponding table.
//
//-----------------------------------------------------------------------------

static HRESULT
FixupPasteSource (
    CDoc *           pDoc,
    BOOL             fFixupFragComments,
    CMarkupPointer * pPointerSourceStart,
    CMarkupPointer * pPointerSourceFinish )
{
    HRESULT hr = S_OK;

    if (fFixupFragComments)
    {
        hr = THR(
            FixupPasteSourceFragComments(
                pDoc, pPointerSourceStart, pPointerSourceFinish ) );

        if (hr)
            goto Cleanup;
    }

    hr = THR( FixupPasteSourceBody( pDoc, pPointerSourceStart, pPointerSourceFinish ) );

    if (hr)
        goto Cleanup;

    hr = THR( FixupPasteSourceTables( pDoc, pPointerSourceStart, pPointerSourceFinish ) );

    if (hr)
        goto Cleanup;

Cleanup:

    RRETURN( hr );
}


//+----------------------------------------------------------------------------
//
//  Function:   GetRightPartialBlockElement
//
//  Synopsis:   Get the partial block element on the right
//
//-----------------------------------------------------------------------------

static void
GetRightPartialBlockElement (
    CMarkupPointer * pPointerLeft,
    CMarkupPointer * pPointerRight,
    CElement * *     ppElementPartialRight )
{
    CTreeNode * pNode;

    Assert( pPointerLeft && pPointerRight );
    Assert( ppElementPartialRight );
    
    *ppElementPartialRight = NULL;
    
    //
    // We want to only examine elements which partially overlapp either side.
    //
    // Set the mark bits on the left and right branches such that _fMark1
    // on the left branch being 1 means that that elements does not totally
    // overalpp.  Also _fMark2 on the right.
    //

    for ( pNode = pPointerLeft->Branch() ; pNode ; pNode = pNode->Parent() )
        pNode->Element()->_fMark1 = 1;

    for ( pNode = pPointerRight->Branch() ; pNode ; pNode = pNode->Parent() )
        pNode->Element()->_fMark2 = 1;
    
    for ( pNode = pPointerLeft->Branch() ; pNode ; pNode = pNode->Parent() )
        pNode->Element()->_fMark2 = 0;

    for ( pNode = pPointerRight->Branch() ; pNode ; pNode = pNode->Parent() )
        pNode->Element()->_fMark1 = 0;

    //
    // Run up the right for a partial overlapping block element
    //
    
    for ( pNode = pPointerRight->Branch() ; pNode ; pNode = pNode->Parent() )
    {
        CElement * pElement = pNode->Element();
        
        if (!pElement->_fMark2)
            continue;

        if (!*ppElementPartialRight && pElement->IsBlockElement())
            *ppElementPartialRight = pElement;
                    
        if (pElement->IsRunOwner())
            *ppElementPartialRight = NULL;
    }
}
    
//+----------------------------------------------------------------------------
//
//  Function:   ResolveConflict
//
//  Synopsis:   Resolves an HTML DTD conflict between two elements by removing
//              the top element over a limited range (defined by the bottom
//              element).
//
//-----------------------------------------------------------------------------

static HRESULT
ResolveConflict(
    CDoc *     pDoc,
    CElement * pElementBottom,
    CElement * pElementTop )
{
    HRESULT          hr = S_OK;

    if(!pDoc)
        return E_FAIL;

    BOOL             fFoundContent;
    CElement *       pElementClone = NULL;
    CMarkupPointer   pointerTopStart ( pDoc );
    CMarkupPointer   pointerTopFinish ( pDoc );
    CMarkupPointer   pointerBottomStart ( pDoc );
    CMarkupPointer   pointerBottomFinish ( pDoc );
    CMarkupPointer   pointerTemp ( pDoc );

    Assert( pElementBottom->IsInMarkup() );
    Assert( pElementTop->IsInMarkup() );

    //
    // Addref the top element to make sure it does not go away while it
    // is out of the tree.
    //

    pElementTop->AddRef();

    //
    // In IE4, we would never remove a ped (IsContainer is nearly equivalent).
    // So, if a conflict arises where the top element is a ccontainer, remove
    // the bottom element instead.  Also, if there is no container above the
    // top element, we should not remove it.  THis takes care to not remove
    // elements like HTML.
    //

    if (pElementTop->IsContainer() || ! pElementTop->GetFirstBranch()->GetContainer())
    {
        hr = THR( pDoc->RemoveElement( pElementBottom ) );

        if (hr)
            goto Cleanup;

        goto Cleanup;
    }

#if DBG == 1
    pointerTopStart.SetDebugName( _T( "Top Start" ) );
    pointerTopFinish.SetDebugName( _T( "Top Finish" ) );
    pointerBottomStart.SetDebugName( _T( "Bottom Start" ) );
    pointerBottomFinish.SetDebugName( _T( "Bottom Finish" ) );
#endif
    
    //
    // First, more pointer to the locations of the elements in question.
    //
    
    hr = THR(
        pointerTopStart.MoveAdjacentToElement(
            pElementTop, ELEM_ADJ_BeforeBegin ) );

    if (hr)
        goto Cleanup;
    
    hr = THR(
        pointerTopFinish.MoveAdjacentToElement(
            pElementTop, ELEM_ADJ_AfterEnd ) );

    if (hr)
        goto Cleanup;

    hr = THR(
        pointerBottomStart.MoveAdjacentToElement(
            pElementBottom, ELEM_ADJ_BeforeBegin ) );

    if (hr)
        goto Cleanup;
    
    hr = THR(
        pointerBottomFinish.MoveAdjacentToElement(
            pElementBottom, ELEM_ADJ_AfterEnd ) );

    if (hr)
        goto Cleanup;

    //
    // Make sure the input elements are where we think they 'aught to be
    //

    Assert( pointerTopStart.IsLeftOf( & pointerBottomStart ) );
    Assert( pointerTopFinish.IsRightOf( & pointerBottomStart ) );

    //
    // Now, remove the top element and reinsert it so that it is no
    // over the bottom element.
    //

    hr = THR( pDoc->RemoveElement( pElementTop ) );

    if (hr)
        goto Cleanup;

    //
    // Look left.  If we can get to the beginning of the top element,
    // without seeing any text (including break chars) or any elements
    // terminating then we must not put the top element back in before
    // the bottom.
    //

    hr = THR( pointerTemp.MoveToPointer( & pointerBottomStart ) );

    if (hr)
        goto Cleanup;

    fFoundContent = TRUE;

    for ( ; ; )
    {
        MARKUP_CONTEXT_TYPE ct;
        DWORD               dwBreaks;

        //
        // Where a break is relative to a pointer is ambiguous.  Assume they
        // are to the left of the pointer.  Thus, before moving left, check
        // for breaks.
        //

        hr = THR( pointerTemp.QueryBreaks( & dwBreaks ) );

        if (hr)
            goto Cleanup;

        if (dwBreaks)
            break;

        //
        // See if we have reached the beginning of the top element
        //

        if (pointerTemp.IsEqualTo( & pointerTopStart ))
        {
            fFoundContent = FALSE;
            break;
        }

        //
        // Now, move the pointer left
        //

        hr = THR( pointerTemp.Left( TRUE, & ct, NULL, NULL, NULL, NULL ) );

        if (hr)
            goto Cleanup;

        if (ct != CONTEXT_TYPE_ExitScope)
            break;
    }

    if (fFoundContent)
    {
        hr = THR(
            pDoc->InsertElement(
                pElementTop, & pointerTopStart, & pointerBottomStart ) );

        if (hr)
            goto Cleanup;
    }

    //
    // Look right.
    //

    hr = THR( pointerTemp.MoveToPointer( & pointerBottomFinish ) );

    if (hr)
        goto Cleanup;

    fFoundContent = TRUE;

    for ( ; ; )
    {
        MARKUP_CONTEXT_TYPE ct;
        DWORD               dwBreaks;
        
        hr = THR( pointerTemp.QueryBreaks( & dwBreaks ) );

        if (hr)
            goto Cleanup;

        if (dwBreaks)
            break;

        if (pointerTemp.IsEqualTo( & pointerTopFinish ))
        {
            fFoundContent = FALSE;
            break;
        }
        
        hr = THR( pointerTemp.Right( TRUE, & ct, NULL, NULL, NULL, NULL ) );

        if (hr)
            goto Cleanup;

        if (ct != CONTEXT_TYPE_ExitScope)
            break;
    }

    if (fFoundContent)
    {
        hr = THR( pElementTop->Clone( & pElementClone, pDoc ) );

        if (hr)
            goto Cleanup;

        //
        // If we have overlapping tags, then TopFinish can be to the right of BottonFinish.
        // In this case, the right resolution to the conflict is not to insert the element.
        // 
        // For example:
        //
        //     <E1> x <E2> y </E1> z </E2> should be <E1> x </E1><E2> y z </E2>
        //
        if (pointerTopFinish.IsRightOfOrEqualTo( & pointerBottomFinish ))
        {
            hr = THR(
                pDoc->InsertElement(
                    pElementClone, & pointerBottomFinish, & pointerTopFinish ) );
    
            if (hr)
                goto Cleanup;
        }
    }

Cleanup:

    if (pElementClone)
        pElementClone->Release();

    pElementTop->Release();
    
    RRETURN( hr );
}


//+----------------------------------------------------------------------------
//
//  Function:   IsEmbeddedElement
//
//  Synopsis:   Intrinsic control and tables are special elements that we must
//              "jump over" while doing a block merge.
//
//-----------------------------------------------------------------------------

BOOL
IsEmbeddedElement ( CTreeNode * pNode )
{
    switch ( pNode->Tag() )
    {
    case ETAG_BUTTON:
    case ETAG_TEXTAREA:
    case ETAG_FIELDSET:
    case ETAG_LEGEND:
    case ETAG_MARQUEE:
    case ETAG_SELECT:
    case ETAG_TABLE:
        
        return TRUE;

    default:

        return pNode->ShouldHaveLayout();
    }
}

//+----------------------------------------------------------------------------
//
//  Function:   SanitizeRange
//
//  Synopsis:   ...
//
//-----------------------------------------------------------------------------

static HRESULT
ConvertShouldCrLf ( CMarkupPointer * pmp, BOOL & fShouldConvert )
{
    HRESULT     hr = S_OK;
    CTreeNode * pNode;

    fShouldConvert = FALSE;

    for ( pNode = pmp->Branch() ; pNode ; pNode = pNode->Parent() )
    {
        CElement * pElement = pNode->Element();

        if (pElement->IsContainer())
        {
            fShouldConvert = pElement->HasFlag( TAGDESC_ACCEPTHTML );

            goto Cleanup;
        }

        if (pElement->HasFlag( TAGDESC_LITERALTAG ))
        {
            fShouldConvert = FALSE;

            goto Cleanup;
        }

        //
        // Special case for PRE because it is not marked as literal
        //

        if (pElement->Tag() == ETAG_PRE)
        {
            fShouldConvert = FALSE;

            goto Cleanup;
        }
    }
    
Cleanup:

    RRETURN( hr );
}

static HRESULT
LaunderEdge ( CMarkupPointer * pmp )
{
    HRESULT                hr = S_OK;
    IHTMLEditingServices * pedserv = NULL;
    CMarkupPointer         pmpOther ( pmp->Doc() );

    if (!pedserv)
    {
        IHTMLEditor * phtmed = pmp->Doc()->GetHTMLEditor();

        if (!phtmed)
        {
            hr = E_FAIL;
            goto Cleanup;
        }

        hr = THR(
            phtmed->QueryInterface(
                IID_IHTMLEditingServices, (void **) & pedserv ) );

        if (hr)
            goto Cleanup;
    }

    hr = THR( pmpOther.MoveToPointer( pmp ) );

    if (hr)
        goto Cleanup;

    hr = THR( pedserv->LaunderSpaces( pmp, & pmpOther ) );

    if (hr)
        goto Cleanup;
    
Cleanup:

    ReleaseInterface( pedserv );
    
    RRETURN( hr );
}

static HRESULT
SanitizeCrLf ( CMarkupPointer * pmp, long & cchAfter )
{
    HRESULT             hr = S_OK;
    CDoc *              pDoc = pmp->Doc();
    CMarkupPointer      mp2 ( pDoc );
    CElement *          pElementNew = NULL;
    TCHAR               ch1, ch2;
    MARKUP_CONTEXT_TYPE ct;
    BOOL                fShouldConvert;
    long                cch;

    //
    // cchAfter is the numner of characters this member deals with after the
    // passed in pointer.
    //

    cchAfter = 0;

    //
    // First, determine the combination of CR/LF chars here
    //

    hr = THR( mp2.MoveToPointer( pmp ) );

    if (hr)
        goto Cleanup;

    hr = THR( mp2.Left( TRUE, & ct, NULL, & (cch = 1), & ch1, NULL ) );

    if (hr)
        goto Cleanup;

    Assert( ct == CONTEXT_TYPE_Text && cch == 1 );
    Assert( ch1 == _T('\r') || ch1 == _T('\n') );

    hr = THR( pmp->Right( FALSE, & ct, NULL, & (cch = 1), & ch2, NULL ) );

    if (hr)
        goto Cleanup;

    if (ct != CONTEXT_TYPE_Text || cch != 1)
        ch2 = 0;

    if ((ch2 == _T('\r') || ch2 == _T('\n')) && ch1 != ch2)
    {
        hr = THR( pmp->Right( TRUE, NULL, NULL, & (cch = 1), NULL, NULL ) );

        if (hr)
            goto Cleanup;
        
        cchAfter++;
    }

    //
    // Now, the text between mp2 and pmp comprises a single line break.
    // Replace it with some marup if needed.
    //

    hr = THR( ConvertShouldCrLf( pmp, fShouldConvert ) );

    if (hr)
        goto Cleanup;

    if (fShouldConvert)
    {
        //
        // Remove the Cr/LF and insert a BR
        //

        hr = THR( pDoc->Remove( & mp2, pmp ) );

        if (hr)
            goto Cleanup;

        hr = THR( pDoc->PrimaryMarkup()->CreateElement( ETAG_BR, & pElementNew ) );

        if (hr)
            goto Cleanup;

        hr = THR( pDoc->InsertElement( pElementNew, pmp, NULL ) );

        if (hr)
            goto Cleanup;
    }
    
Cleanup:

    if (pElementNew)
        pElementNew->Release();

    RRETURN( hr );
}

static HRESULT
SanitizeRange ( CMarkupPointer * pmpStart, CMarkupPointer * pmpFinish )
{
    HRESULT        hr = S_OK;
    CDoc *         pDoc = pmpStart->Doc();
    CMarkupPointer mp ( pDoc );
    TCHAR *        pchBuff = NULL;
    long           cchBuff = 0;

    hr = THR( mp.MoveToPointer( pmpStart ) );

    if (hr)
        goto Cleanup;

    IGNORE_HR( mp.SetGravity( POINTER_GRAVITY_Right ) );

// move the start and finish out to catch adjacent space...
// --> instead, use launder spaces to deal with spaces at the edges of block element

    while ( mp.IsLeftOf( pmpFinish ) )
    {
        MARKUP_CONTEXT_TYPE ct;
        long                cch = cchBuff;
        long                ich;
        TCHAR *             pch;

        //
        // NOTE: 
        //
        // It is quite possible to process text AFTER pmpFinish.  This
        // should not be a problem, but if it is, I should add a feature
        // to the There member to stop at a give pointer.  THis may be difficult
        // in that unembedded pointers will have to be searched!
        //

        hr = THR( mp.Right( TRUE, & ct, NULL, & cch, pchBuff, NULL ) );

        if (hr)
            goto Cleanup;
        
        if (ct != CONTEXT_TYPE_Text)
            continue;

        //
        // See if we were not able to get the entire run of text into the buffer
        //

        if (cch == cchBuff)
        {
            long cchMore = -1;
            
            hr = THR( mp.Right( TRUE, & ct, NULL, & cchMore, NULL, NULL ) );

            if (hr)
                goto Cleanup;

            //
            // In order to know if we got all the text, we try to get one more
            // char than we know is there.
            //

            Assert( cchBuff <= cch + cchMore );

            delete pchBuff;

            pchBuff = new TCHAR [ cch + cchMore + 1 ];

            if (!pchBuff)
            {
                hr = E_OUTOFMEMORY;
                goto Cleanup;
            }

            cchBuff = cch + cchMore + 1;

            //
            // Now, move the pointer back and attempt to get the text again.
            //

            cchMore += cch;

            hr = THR( mp.Left( TRUE, NULL, NULL, & cchMore, NULL, NULL ) );

            if (hr)
                goto Cleanup;

            continue;
        }

        //
        // Now, examine the buffer for CR/LF or adjacent spaces
        //

        for ( ich = 0, pch = pchBuff ; ich < cch ; ich++, pch++ )
        {
            TCHAR ch = *pch;
            
            if (ch == _T('\r') || ch == _T('\n'))
            {
                CMarkupPointer mpCRLF ( pDoc );
                long           cchMoveBack, cchAfter;

                hr = THR( mpCRLF.MoveToPointer( & mp ) );

                if (hr)
                    goto Cleanup;

                cchMoveBack = cch - ich - 1;

                hr = THR( mpCRLF.Left( TRUE, NULL, NULL, & cchMoveBack, NULL ) );

                if (hr)
                    goto Cleanup;
                
                hr = THR( SanitizeCrLf( & mpCRLF, cchAfter ) );

                if (hr)
                    goto Cleanup;

                ich += cchAfter;
                pch += cchAfter;
            }
            else if (ch == _T(' ') && ich + 1 < cch && *(pch + 1) == _T(' '))
            {
                BOOL fShouldConvert;
                
                hr = THR( ConvertShouldCrLf( & mp, fShouldConvert ) );

                if (hr)
                    goto Cleanup;

                if (fShouldConvert)
                {
                    CMarkupPointer mpBeforeSpace ( pDoc );
                    CMarkupPointer mpAfterSpace ( pDoc );
                    long           cchMoveBack;
                    TCHAR          cpSpace;

                    hr = THR( mpAfterSpace.MoveToPointer( & mp ) );

                    if (hr)
                        goto Cleanup;

                    cchMoveBack = cch - ich - 1;

                    hr = THR( mpAfterSpace.Left( TRUE, NULL, NULL, & cchMoveBack, NULL ) );

                    if (hr)
                        goto Cleanup;
                    
                    hr = THR( mpBeforeSpace.MoveToPointer( & mpAfterSpace ) );

                    if (hr)
                        goto Cleanup;

                    cchMoveBack = 1;

                    hr = THR( mpBeforeSpace.Left( TRUE, NULL, NULL, & cchMoveBack, NULL ) );

                    if (hr)
                        goto Cleanup;

                    hr = THR( pDoc->Remove( & mpBeforeSpace, & mpAfterSpace ) );

                    if (hr)
                        goto Cleanup;

                    cpSpace = WCH_NBSP;

                    hr = THR( pDoc->InsertText( & mpBeforeSpace, & cpSpace, 1 ) );

                    if (hr)
                        goto Cleanup;
                }
            }
        }
    }

    hr = THR( LaunderEdge( pmpStart ) );

    if (hr)
        goto Cleanup;

    hr = THR( LaunderEdge( pmpFinish ) );

    if (hr)
        goto Cleanup;

Cleanup:

    delete pchBuff;

    RRETURN( hr );
}

//+----------------------------------------------------------------------------
//
//  Function:   MergeBlock
//
//  Synopsis:   Does a block merge.  The content after the give block element
//              is merged with that block elements content.
//
//-----------------------------------------------------------------------------

static BOOL
IsAccessDivHack( CTreeNode * pNode )
{
    CElement * pElement;
    LPCTSTR    strClass;
    
    if (!pNode)
        return FALSE;
    
    if (pNode->Tag() != ETAG_DIV)
        return FALSE;

    pElement = pNode->Element();

    if (!pElement)
        return FALSE;

    strClass = pElement->GetAAclassName();

    if (!strClass)
        return FALSE;

    if (!StrCmpC( strClass, _T( "MicrosoftAccessBanner" ) ))
        return TRUE;
    
    if (!StrCmpC( strClass, _T( "MSOShowDesignGrid" ) ))
        return TRUE;

    return FALSE;
}

HRESULT
MergeBlock ( CMarkupPointer * pPointerMerge )
{
    HRESULT          hr = S_OK;
    CDoc *           pDoc = pPointerMerge->Doc();
    CMarkup *        pMarkup = pPointerMerge->Markup();
    CElement *       pElementContainer;
    CFlowLayout *    pFlowContainer;
    CMarkupPointer   pointer ( pDoc );
    CMarkupPointer   pointerEnd ( pDoc );
    CElement *       pElementBlockMerge;
    CTreeNode *      pNodeBlockMerge;
    CTreeNode *      pNode;
    CLineBreakCompat breaker;
    BOOL             fFoundContent;
    CElement *       pElementBlockContent = NULL;
    int              i;
    CStackPtrAry < CElement *, 4 > aryMergeLeftElems ( Mt( Mem ) );
    CStackPtrAry < CElement *, 4 > aryMergeRightElems ( Mt( Mem ) );
    CStackPtrAry < INT_PTR, 4 > aryMergeRightElemsRemove ( Mt( Mem ) );

    breaker.SetWantPendingBreak( TRUE );

    Assert( pPointerMerge->IsPositioned() );

    //
    // The merge must be contained to certain elements.  For example, a TD
    // cannot be merged with stuff after it.
    //
    // Text sites are the limiting factor here.  Locate the element which
    // will contain the merge.  
    //

    if (!pPointerMerge->Branch())
        goto Cleanup;
    
    pElementContainer = pPointerMerge->Branch()->GetFlowLayoutElement();

    if (!pElementContainer)
        goto Cleanup;

    pFlowContainer = pElementContainer->HasFlowLayout();

    Assert( pFlowContainer );

    //
    // Locate the block element the merge pointer is currently in.  This
    // is the block element which will subsume the content to its right.
    //

    pNodeBlockMerge =
        pMarkup->SearchBranchForBlockElement(
            pPointerMerge->Branch(), pFlowContainer );

    if (!pNodeBlockMerge)
        goto Cleanup;

    pElementBlockMerge = pNodeBlockMerge->Element();

    //
    // Search right looking for real content.  The result of this will
    // be the element under which this content exists.
    //

    hr = THR( pointer.MoveToPointer( pPointerMerge ) );

    if (hr)
        goto Cleanup;

    fFoundContent = FALSE;
    
    for ( ; ; )
    {
        DWORD dwBreaks;
        CTreeNode * pNode;
        CElement * pElementFlow;
        MARKUP_CONTEXT_TYPE ct;

        //
        // Make sure we are still under the influence of the container
        //

        pNode = pointer.Branch();

        if (!pNode)
            break;

        pElementFlow = pNode->GetFlowLayoutElement();

        if (!pElementFlow || pElementFlow != pElementContainer)
            break;

        //
        // Get the current block element
        //
        
        pNode =
            pMarkup->SearchBranchForBlockElement( pNode, pFlowContainer );

        if (!pNode)
            break;
        
        pElementBlockContent = pNode->Element();

        //
        // Get the current break
        //

        hr = THR( breaker.QueryBreaks( & pointer, & dwBreaks ) );

        if (hr)
            goto Cleanup;

        if (dwBreaks && pElementBlockContent != pElementBlockMerge)
        {
            fFoundContent = TRUE;
            break;
        }
        //
        // See if there is content to the right
        //

        hr = THR( pointer.Right( TRUE, & ct, & pNode, NULL, NULL, NULL ) );

        if (hr)
            goto Cleanup;

        if (ct == CONTEXT_TYPE_None)
            break;

        //
        //
        //

        if (ct == CONTEXT_TYPE_NoScope || ct == CONTEXT_TYPE_Text)
        {
            fFoundContent = TRUE;
            break;
        }
        else if (ct == CONTEXT_TYPE_EnterScope)
        {
            if (IsAccessDivHack( pNode ))
                break;
            
            if (IsEmbeddedElement( pNode ))
            {
                fFoundContent = TRUE;
            
                hr = THR( pointer.MoveAdjacentToElement( pNode->Element(), ELEM_ADJ_AfterEnd ) );

                if (hr)
                    goto Cleanup;

                break;
            }
        }
    }

    if (!fFoundContent)
        goto Cleanup;

    //
    // Now, locate the extent of this content un this element
    //

    hr = THR( pointerEnd.MoveToPointer( & pointer ) );

    if (hr)
        goto Cleanup;

    for ( ; ; )
    {
        DWORD dwBreaks;
        CTreeNode * pNode;
        CElement * pElementFlow;
        MARKUP_CONTEXT_TYPE ct;

        //
        // Make sure we are still under the influence of the container
        //

        pNode = pointer.Branch();

        if (!pNode)
            break;

        pElementFlow = pNode->GetFlowLayoutElement();

        if (!pElementFlow || pElementFlow != pElementContainer)
            break;

        //
        // Get the current block element
        //
        
        pNode =
            pMarkup->SearchBranchForBlockElement( pNode, pFlowContainer );

        if (!pNode || pNode->Element() != pElementBlockContent)
            break;

        //
        // Get the current break
        //

        hr = THR( breaker.QueryBreaks( & pointer, & dwBreaks ) );

        if (hr)
            goto Cleanup;

        if (dwBreaks)
        {
            hr = THR( pointerEnd.MoveToPointer( & pointer ) );

            if (hr)
                goto Cleanup;
        }

        //
        // See if there is content to the right
        //

        hr = THR( pointer.Right( TRUE, & ct, & pNode, NULL, NULL, NULL ) );

        if (hr)
            goto Cleanup;

        if (ct == CONTEXT_TYPE_None)
            break;

        //
        //
        //

        if (ct == CONTEXT_TYPE_NoScope || ct == CONTEXT_TYPE_Text)
        {
            hr = THR( pointerEnd.MoveToPointer( & pointer ) );

            if (hr)
                goto Cleanup;
        }
        else if (ct == CONTEXT_TYPE_EnterScope)
        {
            if (IsAccessDivHack( pNode ))
                break;

            if (IsEmbeddedElement( pNode ))
            {
                hr = THR( pointerEnd.MoveAdjacentToElement( pNode->Element(), ELEM_ADJ_AfterEnd ) );

                if (hr)
                    goto Cleanup;

                hr = THR( pointer.MoveToPointer( & pointerEnd ) );

                if (hr)
                    goto Cleanup;
            }
        }
    }

    //
    // Locate all the elements which will subsume content
    //

    for ( pNode = pPointerMerge->Branch() ;
          pNode->Element() != pElementContainer ;
          pNode = pNode->Parent() )
    {
        if (pFlowContainer->IsElementBlockInContext( pNode->Element() ))
        {
            hr = THR( aryMergeLeftElems.Append( pNode->Element() ) );

            if (hr)
                goto Cleanup;
        }
    }

    //
    // Locate all the elements which will loose content
    //

    for ( pNode = pointerEnd.Branch() ;
          pNode->Element() != pElementBlockMerge && pNode->Element() != pElementContainer ;
          pNode = pNode->Parent() )
    {
        BOOL fHasContentLeftover;
        
        if (!pFlowContainer->IsElementBlockInContext( pNode->Element() ))
            continue;

        {
            CMarkupPointer p ( pDoc );

            fHasContentLeftover = FALSE;
            
            hr = THR( p.MoveToPointer( & pointerEnd ) );

            if (hr)
                goto Cleanup;

            for ( ; ; )
            {
                MARKUP_CONTEXT_TYPE ct;
                CTreeNode * pNode2;
                
                hr = THR( p.Right( TRUE, & ct, & pNode2, NULL, NULL, NULL ) );

                if (hr)
                    goto Cleanup;

                if (ct == CONTEXT_TYPE_ExitScope && pNode2->Element() == pNode->Element())
                    break;

                if (ct == CONTEXT_TYPE_Text)
                {
                    fHasContentLeftover = TRUE;
                    break;
                }
            }
        }
        
        hr = THR( aryMergeRightElemsRemove.Append( ! fHasContentLeftover ) );

        if (hr)
            goto Cleanup;

        hr = THR( aryMergeRightElems.Append( pNode->Element() ) );

        if (hr)
            goto Cleanup;
    }
    
    //
    // Now, move the end of the left elements to subsume the content
    //

    hr = THR( pointerEnd.SetGravity( POINTER_GRAVITY_Right ) );

    if (hr)
        goto Cleanup;

    for ( i = 0 ; i < aryMergeLeftElems.Size() ; i++ )
    {
        CMarkupPointer pointerStart ( pDoc );
        CElement *     pElement = aryMergeLeftElems[i];

        //
        // Make sure we don't move an end tag to the left.
        //

        {
            CMarkupPointer p2 ( pDoc );

            hr = THR( p2.MoveAdjacentToElement( pElement, ELEM_ADJ_BeforeEnd ) );

            if (hr)
                goto Cleanup;

            if (p2.IsRightOfOrEqualTo( & pointerEnd ))
                continue;
        }
        
        hr = THR(
            pointerStart.MoveAdjacentToElement(
                pElement, ELEM_ADJ_BeforeBegin ) );

        if (hr)
            goto Cleanup;

        pElement->AddRef();
        
        hr = THR( pDoc->RemoveElement( pElement ) );

        if (hr)
            goto Cleanup;

        hr = THR(
            pDoc->InsertElement(
                pElement, & pointerStart, & pointerEnd ) );
        
        if (hr)
            goto Cleanup;

        pElement->Release();
    }

    //
    // Move the begin of the right elements to loose the content
    //

    hr = THR( pointerEnd.SetGravity( POINTER_GRAVITY_Left ) );

    if (hr)
        goto Cleanup;

    for ( i = 0 ; i < aryMergeRightElems.Size() ; i++ )
    {
        CMarkupPointer pointerFinish ( pDoc );
        CElement *     pElement = aryMergeRightElems[i];

        {
            CMarkupPointer p2 ( pDoc );

            hr = THR( p2.MoveAdjacentToElement( pElement, ELEM_ADJ_AfterBegin ) );

            if (hr)
                goto Cleanup;

            if (p2.IsLeftOfOrEqualTo( pPointerMerge ))
                continue;
        }
        
        hr = THR(
            pointerFinish.MoveAdjacentToElement(
                pElement, ELEM_ADJ_AfterEnd ) );

        if (hr)
            goto Cleanup;

        pElement->AddRef();
        
        hr = THR( pDoc->RemoveElement( pElement ) );

        if (hr)
            goto Cleanup;

        if (!aryMergeRightElemsRemove[i])
        {
            CMarkupPointer * p1 = & pointerEnd, * p2 = & pointerFinish;

            EnsureLogicalOrder( p1, p2 );

            hr = THR( pDoc->InsertElement( pElement, p1, p2 ) );

            if (hr)
                goto Cleanup;
        }

        pElement->Release();
    }

    //
    // THe content which was "moved" may have \r or multiple spaces which are
    // not legal under the new context.  Sanitize this range.
    //
    
    hr = THR( SanitizeRange( pPointerMerge, & pointerEnd ) );

    if (hr)
        goto Cleanup;

Cleanup:

    RRETURN( hr );
}

static HRESULT
UiDeleteContent ( CMarkupPointer * pmpStart, CMarkupPointer * pmpFinish )
{
    HRESULT                hr = S_OK;
    CDoc *                 pDoc = pmpStart->Doc();
    IHTMLEditingServices * pedserv = NULL;

    if (!pDoc->GetHTMLEditor())
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    hr = THR(
        pDoc->GetHTMLEditor()->QueryInterface(
            IID_IHTMLEditingServices, (void **) & pedserv ) );

    if (hr)
        goto Cleanup;

    hr = THR( pedserv->Delete( pmpStart, pmpFinish, TRUE ) );

    if (hr)
        goto Cleanup;

Cleanup:
    
    ReleaseInterface( pedserv );

    RRETURN( hr );
}

//+----------------------------------------------------------------------------
//
//  Function:   RemoveWithBreakOnEmpty
//
//  Synopsis:   Helper fcn which removes stuff between two pointers, and
//              sets the break on empty bit of the block element above
//              the left hand side of the removal.  This is needed for
//              compatibility with IE4 RemoveChars which was used for most
//              text removal operations.
//
//-----------------------------------------------------------------------------

HRESULT
RemoveWithBreakOnEmpty (
    CMarkupPointer * pPointerStart, CMarkupPointer * pPointerFinish )
{
    CMarkup *   pMarkup = pPointerStart->Markup();
    CDoc *      pDoc = pPointerStart->Doc();
    CTreeNode * pNodeBlock;
    HRESULT     hr = S_OK;

    //
    // First, locate the block element above here and set the break on empty bit
    //

    pNodeBlock = pMarkup->SearchBranchForBlockElement( pPointerStart->Branch() );

    if (pNodeBlock)
        pNodeBlock->Element()->_fBreakOnEmpty = TRUE;

    //
    // Now, do the remove
    //

    hr = THR( pDoc->Remove( pPointerStart, pPointerFinish ) );

    if (hr)
        goto Cleanup;

Cleanup:

    RRETURN( hr );
}

//+----------------------------------------------------------------------------
//
//  Function:   UnoverlapPartials
//
//  Synopsis:   Assuming the contents of an element have been gutted by a
//              Remove operation, this function will take any elements which
//              partially overlapp it, and remove that partial overalpping.
//
//              For example: calling this on y where we have y overlapped
//              from both sides: "<x><y></x><z></y></z>" will produce
//              "<x><y></y></x><z></z>".
//
//-----------------------------------------------------------------------------

#if DBG == 1

static void
IsBefore (
    CElement * pElement1, ELEMENT_ADJACENCY eAdj1,
    CElement * pElement2, ELEMENT_ADJACENCY eAdj2 )
{
    CMarkupPointer pmp1 ( pElement1->Doc() );
    CMarkupPointer pmp2 ( pElement2->Doc() );

    IGNORE_HR( pmp1.MoveAdjacentToElement( pElement1, eAdj1 ) );
    IGNORE_HR( pmp2.MoveAdjacentToElement( pElement2, eAdj2 ) );

    Assert( pmp1.IsLeftOf( & pmp2 ) );
}

#endif

HRESULT
UnoverlapPartials ( CElement * pElement )
{
    HRESULT        hr = S_OK;
    CDoc *         pDoc = pElement->Doc();
    CMarkupPointer pmp ( pDoc );
    CElement *     pElementOverlap = NULL;
    CMarkupPointer pmpStart ( pDoc ), pmpFinish ( pDoc );

    Assert( pElement->IsInMarkup() );

    pElement->GetMarkup()->AddRef();

    hr = THR( pmp.MoveAdjacentToElement( pElement, ELEM_ADJ_BeforeEnd ) );

    if (hr)
        goto Cleanup;

    for ( ; ; )
    {
        MARKUP_CONTEXT_TYPE ct;
        CTreeNode *         pNodeOverlap;

        hr = THR( pmp.Left( TRUE, & ct, & pNodeOverlap, NULL, NULL, NULL ) );

        if (hr)
            goto Cleanup;

        //
        // All text and no-scopes better have been removed.
        //

        if (ct != CONTEXT_TYPE_EnterScope && ct != CONTEXT_TYPE_ExitScope)
            break;

        if (ct == CONTEXT_TYPE_ExitScope && pNodeOverlap->Element() == pElement)
            break;

        pElementOverlap = pNodeOverlap->Element();
        pElementOverlap->AddRef();

        if (ct == CONTEXT_TYPE_EnterScope)
        {
            WHEN_DBG( IsBefore( pElementOverlap, ELEM_ADJ_BeforeBegin, pElement, ELEM_ADJ_BeforeBegin ) );

            hr = THR( pmpStart.MoveAdjacentToElement( pElementOverlap, ELEM_ADJ_BeforeBegin ) );

            if (hr)
                goto Cleanup;
            
            hr = THR( pmpFinish.MoveAdjacentToElement( pElement, ELEM_ADJ_AfterEnd ) );
            
            if (hr)
                goto Cleanup;
        }
        else
        {
            WHEN_DBG( IsBefore( pElement, ELEM_ADJ_AfterEnd, pElementOverlap, ELEM_ADJ_AfterEnd ) );

            hr = THR( pmpFinish.MoveAdjacentToElement( pElementOverlap, ELEM_ADJ_AfterEnd ) );

            if (hr)
                goto Cleanup;
            
            hr = THR( pmpStart.MoveAdjacentToElement( pElement, ELEM_ADJ_AfterEnd ) );
            
            if (hr)
                goto Cleanup;
        }
        
        hr = THR( pDoc->RemoveElement( pElementOverlap ) );

        if (hr)
            goto Cleanup;

        hr = THR( pDoc->InsertElement( pElementOverlap, & pmpStart, & pmpFinish ) );

        if (hr)
            goto Cleanup;
        
        pElementOverlap->Release();
        
        pElementOverlap = NULL;
    }

Cleanup:

    pElement->GetMarkup()->Release();
    
    if (pElementOverlap)
        pElementOverlap->Release();

    RRETURN( hr );
}


//+----------------------------------------------------------------------------
//
//  Function:   HandleUIPasteHTML
//
//  Synopsis:   Performs the actual work of pasting (like, ctrl-V)
//
//-----------------------------------------------------------------------------

HRESULT
HandleIE50CompatUIPasteHTML (
    CMarkupPointer * pPointerTargetStart,
    CMarkupPointer * pPointerTargetFinish,
    HGLOBAL          hglobal,
    BOOL             fAutomation )
{
    HRESULT                hr = S_OK;
    
    if(!pPointerTargetStart)
        return E_FAIL;

    CDoc *                 pDoc = pPointerTargetStart->Doc();
    CMarkup *              pMarkup = NULL;
    CMarkupPointer         pointerSourceStart ( pDoc );
    CMarkupPointer         pointerSourceFinish ( pDoc );
    CMarkupPointer         pointerNewContentLeft ( pDoc );
    CMarkupPointer         pointerNewContentRight ( pDoc );
    CMarkupPointer         pointerMergeRight ( pDoc );
    CMarkupPointer         pointerMergeLeft ( pDoc );
    CMarkupPointer         pointerRemoveLeft ( pDoc );
    CMarkupPointer         pointerRemoveRight ( pDoc );
    CMarkupPointer         pointerStatus ( pDoc );
    CElement *             pElementMergeRight;

    //
    // Make sure the pointers are in the same markup and are ordered
    // correctly.
    //

    Assert( pPointerTargetStart->IsPositioned() );
    Assert( pPointerTargetFinish->IsPositioned() );
    Assert( pPointerTargetStart->Markup() == pPointerTargetFinish->Markup() );

    WHEN_DBG( pPointerTargetStart->SetDebugName( _T( "Target Start" ) ) );
    WHEN_DBG( pPointerTargetFinish->SetDebugName( _T( "Target Finish" ) ) );

    //
    // Make sure the target start and end are properly oriented (the
    // start must be before the end.
    //

    EnsureLogicalOrder ( pPointerTargetStart, pPointerTargetFinish );

    Assert( Compare( pPointerTargetStart, pPointerTargetFinish ) <= 0 );

    //
    // Now, parse (or attempt to) the HTML given to us
    //

    hr = THR(
        pDoc->ParseGlobal(
            hglobal,
            PARSE_ABSOLUTIFYIE40URLS,
            pPointerTargetStart->Markup(),  // pContextMarkup
            & pMarkup,
            & pointerSourceStart,
            & pointerSourceFinish ) );

    if (hr)
        goto Cleanup;

    WHEN_DBG( pointerSourceStart.SetDebugName( _T( "Source Start" ) ) );
    WHEN_DBG( pointerSourceFinish.SetDebugName( _T( "Source Finish" ) ) );

    //
    // If there was nothing really there to parse, just do a remove
    //
    
    if (!pMarkup)
    {
        hr = THR( UiDeleteContent( pPointerTargetStart, pPointerTargetFinish ) );

        if (hr)
            goto Cleanup;
        
        goto Cleanup;
    }

    //
    // Make sure this current range is one which is valid to delete and/or
    // replace with something else.  In the old IE4 code, the function
    // ValidateRplace was used to determine this.
    //
    // Also, the ole code used to call ValidateInsert which would decide if
    // the target location was a validate place to insert stuff.
    //
    //

// ValidateInsert code goes here (or similar)

    //
    // Cleanup the source to paste, possibly adjusting the sel range.
    // We paste NULL for the last parameter because I do not want the
    // fixup code to conditionally not do the table check.
    //

    hr = THR( FixupPasteSource(
            pDoc, !fAutomation, & pointerSourceStart, & pointerSourceFinish ) );
    if (FAILED(hr))
        goto Cleanup;            
            
    //
    // Compute right block element to merge
    //

    GetRightPartialBlockElement (
        & pointerSourceStart, & pointerSourceFinish, & pElementMergeRight );

    if (hr)
        goto Cleanup;

    //
    // In IE4 because of the way the splice operation was written, any
    // elements which partially overlapped the left side of the stuff to
    // move would not be move to the target.  This implicit behaviour
    // was utilized to effectively get left handed block merging (along
    // with not moving any elements which partially overlapped).
    //
    // Here, I remove all elements which partially overlap the left
    // hand side so that the move operation does not move a clone of them
    // to the target.
    //

    {
        CTreeNode * pNode;
        int i;
        CStackPtrAry < CElement *, 4 > aryRemoveElems ( Mt( Mem ) );
        
        for ( pNode = pointerSourceStart.Branch() ; pNode ; pNode = pNode->Parent() )
            pNode->Element()->_fMark1 = 1;

        for ( pNode = pointerSourceFinish.Branch() ; pNode ; pNode = pNode->Parent() )
            pNode->Element()->_fMark2 = 1;

        for ( pNode = pointerSourceStart.Branch() ; pNode ; pNode = pNode->Parent() )
            pNode->Element()->_fMark2 = 0;

        for ( pNode = pointerSourceFinish.Branch() ; pNode ; pNode = pNode->Parent() )
            pNode->Element()->_fMark1 = 0;

        for ( pNode = pointerSourceStart.Branch() ; pNode ; pNode = pNode->Parent() )
        {
            if (pNode->Element()->_fMark1)
            {
                hr = THR( aryRemoveElems.Append( pNode->Element() ) );
                if (hr)
                    goto Cleanup;
            }
        }

        for ( i = 0 ; i < aryRemoveElems.Size() ; i++ )
        {
            hr = THR( pDoc->RemoveElement( aryRemoveElems[i] ) );

            if (hr)
                goto Cleanup;
        }
    }

    //
    // Before actually performing the move, insert two pointers into the
    // target such that they will surround the moved source.
    //
    
    IGNORE_HR( pointerNewContentLeft.SetGravity( POINTER_GRAVITY_Left ) );
    IGNORE_HR( pointerNewContentRight.SetGravity( POINTER_GRAVITY_Right ) );

    hr = THR( pointerNewContentLeft.MoveToPointer( pPointerTargetStart ) );

    if (hr)
        goto Cleanup;

    hr = THR( pointerNewContentRight.MoveToPointer( pPointerTargetStart ) );

    if (hr)
        goto Cleanup;

    //
    // Locate the target with pointers which stay to the right of
    // the newly inserted stuff.  This is especially needed when
    // the two are equal.
    //

    hr = THR( pointerRemoveLeft.MoveToPointer( pPointerTargetStart ) );

    if (hr)
        goto Cleanup;
    
    hr = THR( pointerRemoveRight.MoveToPointer( pPointerTargetFinish ) );

    if (hr)
        goto Cleanup;

    IGNORE_HR( pointerRemoveLeft.SetGravity( POINTER_GRAVITY_Right ) );
    IGNORE_HR( pointerRemoveRight.SetGravity( POINTER_GRAVITY_Right ) );

    //
    // Before performing the move, we insert pointers with cling next
    // to elements which we will later perform a merge.  We need to do
    // this because (potentially) clones of the merge elements in the
    // source will be moved to the target because those elements are
    // only partially selected int the source.
    //

    if (pElementMergeRight)
    {
        hr = THR(
            pointerMergeRight.MoveAdjacentToElement(
                pElementMergeRight, ELEM_ADJ_BeforeBegin ) );

        if (hr)
            goto Cleanup;

        IGNORE_HR( pointerMergeRight.SetGravity( POINTER_GRAVITY_Right ) );
        
        IGNORE_HR( pointerMergeRight.SetCling( TRUE ) );
    }

    //
    // Now, move the source to the target. Here I insert two pointers
    // to record the location of the source after it has moved to the
    // target.
    //

    hr = THR( pDoc->Move(
            & pointerSourceStart, & pointerSourceFinish,
            pPointerTargetStart ) );
    if (FAILED(hr))
        goto Cleanup;            

    //
    // Now that the new stuff is in, make the pointers which indicate
    // it point inward so that the isolating char does not get in between
    // them.
    //

    IGNORE_HR( pointerNewContentLeft.SetGravity( POINTER_GRAVITY_Right ) );
    IGNORE_HR( pointerNewContentRight.SetGravity( POINTER_GRAVITY_Left ) );

    //
    // Now, remove the old stuff.  Because we use a rather high level
    // operation to do this, we have to make sure the newly inserted
    // stuff does not get mangled.  We do this by inserting an insulating
    // character.
    //

    {
        long  cch;
        TCHAR ch = _T('~');

        hr = THR( pDoc->InsertText( & pointerNewContentRight, & ch, 1 ) );

        if (hr)
            goto Cleanup;

        hr = THR(
            UiDeleteContent(
                & pointerRemoveLeft, & pointerRemoveRight ) );

        if (hr)
            goto Cleanup;

#if DBG == 1
        {
            MARKUP_CONTEXT_TYPE ct;
        
            IGNORE_HR(
                pointerNewContentRight.Right(
                    FALSE, & ct, NULL, & (cch = 1), & ch ) );

            Assert( ct == CONTEXT_TYPE_Text && ch == _T('~') );
        }
#endif

        hr = THR( pointerRemoveLeft.MoveToPointer( & pointerNewContentRight ) );

        if (hr)
            goto Cleanup;

        hr = THR(
            pointerRemoveLeft.Right(
                TRUE, NULL, NULL, & (cch = 1), NULL ) );

        hr = THR( pDoc->Remove( & pointerNewContentRight, & pointerRemoveLeft ) );

        if (hr)
            goto Cleanup;

        hr = THR( pointerRemoveLeft.Unposition() );

        if (hr)
            goto Cleanup;
        
        hr = THR( pointerRemoveRight.Unposition() );

        if (hr)
            goto Cleanup;
    }

    //
    // Now, recover the elements to merge in the target tree
    //

    if (pElementMergeRight)
    {
        MARKUP_CONTEXT_TYPE ct;
        CTreeNode * pNode;
        
        Assert( pointerMergeRight.IsPositioned() );
        
        pointerMergeRight.Right( FALSE, & ct, & pNode, NULL, NULL, NULL );

        Assert( ct == CONTEXT_TYPE_EnterScope );

        pElementMergeRight = pNode->Element();

        hr = THR( pointerMergeRight.Unposition() );

        if (hr)
            goto Cleanup;
    }

    //
    // Now, look for conflicts and remove them
    //

    //
    // Make sure changes to the document get inside the new content pointers
    //
    
    IGNORE_HR( pointerNewContentLeft.SetGravity( POINTER_GRAVITY_Left ) );
    IGNORE_HR( pointerNewContentRight.SetGravity( POINTER_GRAVITY_Right ) );
    
    for ( ; ; )
    {
        CTreeNode * pNodeFailBottom;
        CTreeNode * pNodeFailTop;

        hr = THR(
            pDoc->ValidateElements(
                & pointerNewContentLeft, & pointerNewContentRight, NULL,
                VALIDATE_ELEMENTS_REQUIREDCONTAINERS,
                &pointerStatus, & pNodeFailBottom, & pNodeFailTop ) );

        if (hr && hr != S_FALSE)
            goto Cleanup;

        if (hr == S_OK)
            break;

        hr = THR(
            ResolveConflict(
                pDoc, pNodeFailBottom->Element(), pNodeFailTop->Element() ) );

        if (hr)
            goto Cleanup;
    }

    //
    // Perform any merging
    //

    if (pElementMergeRight && pElementMergeRight->GetMarkup())
    {
        CMarkupPointer pointer ( pDoc );

        hr = THR(
            pointer.MoveAdjacentToElement(
                pElementMergeRight, ELEM_ADJ_BeforeEnd ) );

        if (hr)
            goto Cleanup;

        hr = THR( MergeBlock( & pointer ) );

        if (hr)
            goto Cleanup;
    }

    //
    // Look to see if only site-like elements were pasted in and return them
    // so that htey may be selected after this operation.
    //

    //
    // Because the source context for the paste may have allowed \r's and
    // the like in the text which we just pasted to the target, and the
    // recieving target element may not allow these kind of chars, we must
    // sanitize here.
    //

    hr = THR( SanitizeRange( & pointerNewContentLeft, & pointerNewContentRight ) );

    //
    //
    //

    hr = THR( pointerNewContentLeft.Unposition() );

    if (hr)
        goto Cleanup;
    
    hr = THR( pointerNewContentRight.Unposition() );

    if (hr)
        goto Cleanup;

    ULONG cDie;

    cDie = pDoc->_cDie;

    hr = THR(pDoc->CommitDeferredScripts(FALSE, pPointerTargetStart->Markup()));
    
    if (hr)
        goto Cleanup;

    if (cDie != pDoc->_cDie)
    {
        hr = E_ABORT;
    }

Cleanup:

    if (pMarkup)
        pMarkup->Release();
    
    RRETURN( hr );
}

//+----------------------------------------------------------------------------
//
//  Function:   HandleUIPasteHTML
//
//  Synopsis:   Helper function which taks string, coverts it to a global
//              and calls real function.
//
//-----------------------------------------------------------------------------

HRESULT
HandleIE50CompatUIPasteHTML (
    CMarkupPointer * pPointerTargetStart,
    CMarkupPointer * pPointerTargetFinish,
    const TCHAR *    pStr,
    long             cch,
    BOOL             fAutomation )
{
    HRESULT hr = S_OK;
    HGLOBAL hHtmlText = NULL;

    if (pStr && *pStr)
    {
        extern HRESULT HtmlStringToSignaturedHGlobal (
            HGLOBAL * phglobal, const TCHAR * pStr, long cch );

        hr = THR(
            HtmlStringToSignaturedHGlobal(
                & hHtmlText, pStr, _tcslen( pStr ) ) );

        if (hr)
            goto Cleanup;

        Assert( hHtmlText );
    }

    hr = THR(
        HandleIE50CompatUIPasteHTML(
            pPointerTargetStart, pPointerTargetFinish, hHtmlText, fAutomation ) );

    if (hr)
        goto Cleanup;

Cleanup:
    
    if (hHtmlText)
        GlobalFree( hHtmlText );
    
    RRETURN( hr );
}

//+----------------------------------------------------------------------------
//
//  Function:   HandleHTMLInjection
//
//  Synopsis:   Workhorse for innerHTML, outerHTML and insertAdjacentHTML and
//              data binding
//
//-----------------------------------------------------------------------------

HRESULT
HandleHTMLInjection (
    CMarkupPointer * pPointerTargetStart,
    CMarkupPointer * pPointerTargetFinish,
    HGLOBAL          hglobal,
    CElement *       pElementInside )
{
    HRESULT            hr = S_OK;
    CDoc *             pDoc = pPointerTargetStart->Doc();
    CMarkup *          pMarkupContainer = NULL;
    CMarkup *          pMarkupTarget = NULL;
    CMarkupPointer     pointerSourceStart( pDoc );
    CMarkupPointer     pointerSourceFinish( pDoc );
    CMarkupPointer     pointerStatus( pDoc );
    BOOL               fInHTMLInjectionPrev;
    DWORD              dwFlags = 0;
    
    //
    // Make sure the pointers are in the same markup and are ordered
    // correctly.
    //

    Assert( pPointerTargetStart->IsPositioned() );
    Assert( pPointerTargetFinish->IsPositioned() );
    Assert( pPointerTargetStart->Markup() == pPointerTargetFinish->Markup() );

    //
    // Make sure the target start and end are properly oriented (the
    // start must be before the end.
    //

    EnsureLogicalOrder ( pPointerTargetStart, pPointerTargetFinish );

    Assert( Compare( pPointerTargetStart, pPointerTargetFinish ) <= 0 );

    //
    // Now, parse (or attempt to) the HTML given to us
    //

    fInHTMLInjectionPrev = pDoc->_fInHTMLInjection;
    pDoc->_fInHTMLInjection = TRUE;

    dwFlags = INTERNAL_PARSE_INNERHTML;
    if (    pPointerTargetStart->Markup()
        &&  pPointerTargetStart->Markup()->IsPrintTemplate())
        dwFlags |= INTERNAL_PARSE_PRINTTEMPLATE;

    hr = THR(
        pDoc->ParseGlobal(
            hglobal,
            PARSE_ABSOLUTIFYIE40URLS,
            pPointerTargetStart->Markup(),  // pContextMarkup
            & pMarkupContainer,
            & pointerSourceStart,
            & pointerSourceFinish,
            dwFlags) );

    pDoc->_fInHTMLInjection = fInHTMLInjectionPrev;

    if (hr)
        goto Cleanup;

    pMarkupTarget = pPointerTargetStart->Markup();
    pMarkupTarget->AddRef();

    //
    // If there was nothing really there to parse, just do a remove
    //
    // NOTE: May be merged with the removal after inserting the
    // new stuff.
    //
    
    if (!pMarkupContainer)
    {
        hr = THR(
            RemoveWithBreakOnEmpty(
                pPointerTargetStart, pPointerTargetFinish ) );

        if (hr)
            goto Cleanup;

        if (pElementInside)
        {
            hr = THR( UnoverlapPartials( pElementInside ) );

            if (hr)
                goto Cleanup;
        }

        //
        // We're done, git outta here
        //

        goto Cleanup;
    }
    
    //
    // Cleanup the source to paste, possibly adjusting the sel range.
    // Also, the fixup of the source is dependant on the location where
    // it is to be placed.
    //

    hr = THR(
        FixupPasteSource(
            pDoc, FALSE, & pointerSourceStart, & pointerSourceFinish ) );

    if (hr)
        goto Cleanup;

    //
    // See if the source is valid under the context
    //

    hr = THR(
        pDoc->ValidateElements(
            & pointerSourceStart, & pointerSourceFinish, pPointerTargetStart,
            0, &pointerStatus, NULL, NULL ) );

    if (hr == S_FALSE)
    {
        hr = CTL_E_INVALIDPASTESOURCE;
        goto Cleanup;
    }

    if (hr)
        goto Cleanup;

    //
    // Now, remove the old contents, and put the new in.
    //

    hr = THR( RemoveWithBreakOnEmpty( pPointerTargetStart, pPointerTargetFinish ) );

    if (hr)
        goto Cleanup;

    if (pElementInside)
    {
        hr = THR( UnoverlapPartials( pElementInside ) );

        if (hr)
            goto Cleanup;
    }

    hr = THR(
        pDoc->Move(
            & pointerSourceStart, & pointerSourceFinish, pPointerTargetStart ) );

    if (hr)
        goto Cleanup;
    
    ULONG cDie;

    cDie = pDoc->_cDie;

    hr = THR(pDoc->CommitDeferredScripts(FALSE, pMarkupTarget));
    
    if (hr)
        goto Cleanup;

    if (cDie != pDoc->_cDie)
    {
        hr = E_ABORT;
    }

Cleanup:

    if (pMarkupContainer)
        pMarkupContainer->Release();
    
    if (pMarkupTarget)
        pMarkupTarget->Release();

    RRETURN( hr );
}

//+----------------------------------------------------------------------------
//
//  Function:   HandleHTMLInjection
//
//  Synopsis:   Helper function which taks string, coverts it to a global
//              and calls real function.
//
//-----------------------------------------------------------------------------

HRESULT
HandleHTMLInjection (
    CMarkupPointer * pPointerTargetStart,
    CMarkupPointer * pPointerTargetFinish,
    const TCHAR *    pStr,
    long             cch,
    CElement *       pElementInside )
{
    HRESULT hr = S_OK;
    HGLOBAL hHtmlText = NULL;

    if (pStr && *pStr)
    {
        extern HRESULT HtmlStringToSignaturedHGlobal (
            HGLOBAL * phglobal, const TCHAR * pStr, long cch );

        hr = THR(
            HtmlStringToSignaturedHGlobal(
                & hHtmlText, pStr, _tcslen( pStr ) ) );

        if (hr)
            goto Cleanup;

        Assert( hHtmlText );
    }

    hr = THR(
        HandleHTMLInjection(
            pPointerTargetStart, pPointerTargetFinish,
            hHtmlText, pElementInside ) );

    if (hr)
        goto Cleanup;

Cleanup:
    
    if (hHtmlText)
        GlobalFree( hHtmlText );
    
    RRETURN( hr );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\text\lswidth.cxx ===
/*
 *  @doc    INTERNAL
 *
 *  @module LSWIDTH.CXX -- line services width callbacks
 *
 *
 *  Owner: <nl>
 *      Chris Thrasher <nl>
 *      Sujal Parikh <nl>
 *
 *  History: <nl>
 *      08/11/98     cthrash created
 *
 *  Copyright (c) 1997-1998 Microsoft Corporation. All rights reserved.
 */

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X__FONT_H_
#define X__FONT_H_
#include "_font.h"
#endif

#ifndef X_INTL_HXX_
#define X_INTL_HXX_
#include "intl.hxx"
#endif

#ifndef X_LINESRV_HXX_
#define X_LINESRV_HXX_
#include "linesrv.hxx"
#endif

#ifndef X_TXTDEFS_H
#define X_TXTDEFS_H
#include "txtdefs.h"
#endif

#ifdef DLOAD1
extern "C"  // MSLS interfaces are C
{
#endif

#ifndef X_LSSETDOC_H_
#define X_LSSETDOC_H_
#include <lssetdoc.h>
#endif

#ifndef X_LSEMS_H_
#define X_LSEMS_H_
#include <lsems.h>
#endif

#ifndef X_LSCBK_H_
#define X_LSCBK_H_
#include <lscbk.h>
#endif

#ifndef X_BRKCLS_H_
#define X_BRKCLS_H_
#include <brkcls.h>
#endif

#ifdef DLOAD1
} // extern "C"
#endif

#ifndef X_ONERUN_HXX_
#define X_ONERUN_HXX_
#include "onerun.hxx"
#endif

//
// Documentation for CSS text-justify can be found on http://ie/specs/secure/trident/text/Line_just.htm
// Documentation for CSS text-autospace can be found on http://ie/specs/secure/trident/text/csc.htm
//

ExternTag(tagLSCallBack);

#define prior5 5        // REVIEW elik (asmusf)
#define priorNum 5

enum CSC
{
    cscUndefined,                       // 0
    cscOpenParenthesisNH,               // 1
    cscOpenParenthesisW,                // 2
    cscCloseParenthesisNH,              // 3
    cscCloseParenthesisW,               // 4
    cscNeutralCharactersNH,             // 5
    cscCommaW,                          // 6
    cscHiraganaOrKatakanaW,             // 7
    cscQuestionOrExclamationW,          // 8
    cscPunctuationN,                    // 9
    cscCenteredCharactersW,             // 10
    cscHiraganaOrKatakanaN,             // 11
    cscPeriodW,                         // 12
    cscSpaceN,                          // 13
    cscSpaceW,                          // 14
    cscIdeographicW,                    // 15
    cscAlphabetsOptionsN,               // 16
    cscDigitsWOrAutospacingOnN,         // 17
    cscInseparableCharactersA,          // 18
    cscGlueCharactersN,                 // 19
    cscPrefixCurrenciesAndSymbol,       // 20
    cscPostfixCurrenciesAndSymbols,     // 21
    cscDigitsWOrAutospacingOffN,        // 22
    cscOpenQuotesA,                     // 23
    cscLim
};

typedef struct
{
    unsigned short csc:5;       // CSC
    unsigned short cscAlt:5;    // Alternate CSC
    unsigned short csco:6;      // CSCOPTION
} PACKEDCSC;

const PACKEDCSC s_aCscMap[] =
{
    { cscOpenParenthesisW,            cscUndefined,               cscoNone             }, // WOB_   1 (  0)  
    { cscNeutralCharactersNH,         cscOpenParenthesisNH,       cscoAutospacingParen }, // NOPP   2 (  1)  
    { cscNeutralCharactersNH,         cscOpenParenthesisNH,       cscoAutospacingParen }, // NOPA   2 (  2)  
    { cscNeutralCharactersNH,         cscOpenParenthesisNH,       cscoAutospacingParen }, // NOPW   2 (  3)  
    { cscNeutralCharactersNH,         cscOpenParenthesisNH,       cscoAutospacingParen }, // HOP_   3 (  4)  
    { cscOpenParenthesisW,            cscUndefined,               cscoNone             }, // WOP_   4 (  5)  
    { cscNeutralCharactersNH,         cscOpenParenthesisNH,       cscoAutospacingParen }, // WOP5   5 (  6)  
    { cscNeutralCharactersNH,         cscOpenParenthesisNH,       cscoAutospacingParen }, // NOQW   6 (  7)  
    { cscNeutralCharactersNH,         cscOpenParenthesisNH,       cscoAutospacingParen }, // AOQW   7 (  8)  
    { cscNeutralCharactersNH,         cscOpenParenthesisNH,       cscoAutospacingParen }, // WOQ_   8 (  9)  
    { cscCloseParenthesisW,           cscUndefined,               cscoNone             }, // WCB_   9 ( 10)
    { cscNeutralCharactersNH,         cscCloseParenthesisNH,      cscoAutospacingParen }, // NCPP  10 ( 11)
    { cscNeutralCharactersNH,         cscCloseParenthesisNH,      cscoAutospacingParen }, // NCPA  10 ( 12)
    { cscNeutralCharactersNH,         cscCloseParenthesisNH,      cscoAutospacingParen }, // NCPW  10 ( 13)
    { cscNeutralCharactersNH,         cscCloseParenthesisNH,      cscoAutospacingParen }, // HCP_  11 ( 14)
    { cscCloseParenthesisW,           cscUndefined,               cscoNone             }, // WCP_  12 ( 15)
    { cscNeutralCharactersNH,         cscCloseParenthesisNH,      cscoAutospacingParen }, // WCP5  13 ( 16)
    { cscNeutralCharactersNH,         cscCloseParenthesisNH,      cscoAutospacingParen }, // NCQW  14 ( 17)
    { cscNeutralCharactersNH,         cscCloseParenthesisNH,      cscoAutospacingParen }, // ACQW  15 ( 18)
    { cscNeutralCharactersNH,         cscCloseParenthesisNH,      cscoAutospacingParen }, // WCQ_  16 ( 19)
    { cscNeutralCharactersNH,         cscCloseParenthesisNH,      cscoAutospacingParen }, // ARQW  17 ( 20)
    { cscNeutralCharactersNH,         cscUndefined,               cscoNone             }, // NCSA  18 ( 21)
    { cscNeutralCharactersNH,         cscUndefined,               cscoNone             }, // HCO_  19 ( 22)
    { cscCommaW,                      cscUndefined,               cscoNone             }, // WC__  20 ( 23)
    { cscCommaW,                      cscUndefined,               cscoNone             }, // WCS_  20 ( 24)
    { cscNeutralCharactersNH,         cscUndefined,               cscoNone             }, // WC5_  21 ( 25)
    { cscNeutralCharactersNH,         cscUndefined,               cscoNone             }, // WC5S  21 ( 26)
    { cscHiraganaOrKatakanaN,         cscUndefined,               cscoNone             }, // NKS_  22 ( 27)
    { cscIdeographicW,                cscUndefined,               cscoNone             }, // WKSM  23 ( 28)
    { cscIdeographicW,                cscUndefined,               cscoNone             }, // WIM_  24 ( 29)
    { cscNeutralCharactersNH,         cscUndefined,               cscoNone             }, // NSSW  25 ( 30)
    { cscIdeographicW,                cscUndefined,               cscoNone             }, // WSS_  26 ( 31)
    { cscIdeographicW,                cscUndefined,               cscoNone             }, // WHIM  27 ( 32)
    { cscIdeographicW,                cscUndefined,               cscoNone             }, // WKIM  28 ( 33)
    { cscHiraganaOrKatakanaN,         cscUndefined,               cscoNone             }, // NKSL  29 ( 34)
    { cscIdeographicW,                cscHiraganaOrKatakanaW,     cscoCompressKana     }, // WKS_  30 ( 35)
    { cscIdeographicW,                cscHiraganaOrKatakanaW,     cscoCompressKana     }, // WKSC  30 ( 36)
    { cscIdeographicW,                cscHiraganaOrKatakanaW,     cscoCompressKana     }, // WHS_  31 ( 37)
    { cscNeutralCharactersNH,         cscUndefined,               cscoNone             }, // NQFP  32 ( 38)
    { cscNeutralCharactersNH,         cscUndefined,               cscoNone             }, // NQFA  32 ( 39)
    { cscQuestionOrExclamationW,      cscUndefined,               cscoNone             }, // WQE_  33 ( 40)
    { cscNeutralCharactersNH,         cscUndefined,               cscoNone             }, // WQE5  34 ( 41)
    { cscHiraganaOrKatakanaN,         cscUndefined,               cscoNone             }, // NKCC  35 ( 42)
    { cscCenteredCharactersW,         cscUndefined,               cscoNone             }, // WKC_  36 ( 43)
    { cscPunctuationN,                cscUndefined,               cscoNone             }, // NOCP  37 ( 44)
    { cscPunctuationN,                cscUndefined,               cscoNone             }, // NOCA  37 ( 45)
    { cscPunctuationN,                cscUndefined,               cscoNone             }, // NOCW  37 ( 46)
    { cscIdeographicW,                cscUndefined,               cscoVerticalFont     }, // WOC_  38 ( 47)
    { cscIdeographicW,                cscUndefined,               cscoVerticalFont     }, // WOCS  38 ( 48)
    { cscPunctuationN,                cscUndefined,               cscoNone             }, // WOC5  39 ( 49)
    { cscPunctuationN,                cscUndefined,               cscoNone             }, // WOC6  39 ( 50)
    { cscPunctuationN,                cscCenteredCharactersW,     cscoWide             }, // AHPW  40 ( 51)
    { cscPunctuationN,                cscUndefined,               cscoNone             }, // NPEP  41 ( 52)
    { cscPunctuationN,                cscUndefined,               cscoNone             }, // NPAR  41 ( 53)
    { cscPunctuationN,                cscUndefined,               cscoNone             }, // HPE_  42 ( 54)
    { cscPeriodW,                     cscUndefined,               cscoNone             }, // WPE_  43 ( 55)
    { cscPeriodW,                     cscUndefined,               cscoNone             }, // WPES  43 ( 56)
    { cscPunctuationN,                cscUndefined,               cscoNone             }, // WPE5  44 ( 57)
    { cscInseparableCharactersA,      cscUndefined,               cscoNone             }, // NISW  45 ( 58)
    { cscInseparableCharactersA,      cscUndefined,               cscoNone             }, // AISW  46 ( 59)
    { cscGlueCharactersN,             cscUndefined,               cscoNone             }, // NQCS  47 ( 60)
    { cscGlueCharactersN,             cscUndefined,               cscoNone             }, // NQCW  47 ( 61)
    { cscGlueCharactersN,             cscUndefined,               cscoNone             }, // NQCC  47 ( 62)
    { cscPrefixCurrenciesAndSymbol,   cscUndefined,               cscoNone             }, // NPTA  48 ( 63)
    { cscPrefixCurrenciesAndSymbol,   cscUndefined,               cscoNone             }, // NPNA  48 ( 64)
    { cscPrefixCurrenciesAndSymbol,   cscUndefined,               cscoNone             }, // NPEW  48 ( 65)
    { cscPrefixCurrenciesAndSymbol,   cscUndefined,               cscoNone             }, // NPEH  48 ( 66)
    { cscPrefixCurrenciesAndSymbol,   cscUndefined,               cscoNone             }, // NPEV  48 ( 67)
    { cscPrefixCurrenciesAndSymbol,   cscUndefined,               cscoNone             }, // APNW  49 ( 68)
    { cscPrefixCurrenciesAndSymbol,   cscUndefined,               cscoNone             }, // HPEW  50 ( 69)
    { cscPrefixCurrenciesAndSymbol,   cscUndefined,               cscoNone             }, // WPR_  51 ( 70)
    { cscPostfixCurrenciesAndSymbols, cscUndefined,               cscoNone             }, // NQEP  52 ( 71)
    { cscPostfixCurrenciesAndSymbols, cscUndefined,               cscoNone             }, // NQEW  52 ( 72)
    { cscPostfixCurrenciesAndSymbols, cscUndefined,               cscoNone             }, // NQNW  52 ( 73)
    { cscPostfixCurrenciesAndSymbols, cscUndefined,               cscoNone             }, // AQEW  53 ( 74)
    { cscPostfixCurrenciesAndSymbols, cscUndefined,               cscoNone             }, // AQNW  53 ( 75)
    { cscPostfixCurrenciesAndSymbols, cscUndefined,               cscoNone             }, // AQLW  53 ( 76)
    { cscPostfixCurrenciesAndSymbols, cscUndefined,               cscoNone             }, // WQO_  54 ( 77)
    { cscSpaceN,                      cscUndefined,               cscoNone             }, // NSBL  55 ( 78)
    { cscSpaceW,                      cscUndefined,               cscoNone             }, // WSP_  56 ( 79)
    { cscIdeographicW,                cscHiraganaOrKatakanaW,     cscoCompressKana     }, // WHI_  57 ( 80)
    { cscHiraganaOrKatakanaN,         cscUndefined,               cscoNone             }, // NKA_  58 ( 81)
    { cscIdeographicW,                cscHiraganaOrKatakanaW,     cscoCompressKana     }, // WKA_  59 ( 82)
    { cscNeutralCharactersNH,         cscIdeographicW,            cscoWide             }, // ASNW  60 ( 83)
    { cscNeutralCharactersNH,         cscIdeographicW,            cscoWide             }, // ASEW  60 ( 84)
    { cscNeutralCharactersNH,         cscIdeographicW,            cscoWide             }, // ASRN  60 ( 85)
    { cscNeutralCharactersNH,         cscIdeographicW,            cscoWide             }, // ASEN  60 ( 86)
    { cscNeutralCharactersNH,         cscIdeographicW,            cscoWide             }, // ALA_  61 ( 87)
    { cscNeutralCharactersNH,         cscIdeographicW,            cscoWide             }, // AGR_  62 ( 88)
    { cscNeutralCharactersNH,         cscIdeographicW,            cscoWide             }, // ACY_  63 ( 89)
    { cscIdeographicW,                cscUndefined,               cscoNone             }, // WID_  64 ( 90)
    { cscIdeographicW,                cscUndefined,               cscoNone             }, // WPUA  65 ( 91)
    { cscNeutralCharactersNH,         cscUndefined,               cscoNone             }, // NHG_  66 ( 92)
    { cscIdeographicW,                cscUndefined,               cscoNone             }, // WHG_  67 ( 93)
    { cscIdeographicW,                cscUndefined,               cscoNone             }, // WCI_  68 ( 94)
    { cscNeutralCharactersNH,         cscUndefined,               cscoNone             }, // NOI_  69 ( 95)
    { cscIdeographicW,                cscUndefined,               cscoNone             }, // WOI_  70 ( 96)
    { cscIdeographicW,                cscUndefined,               cscoNone             }, // WOIC  70 ( 97)
    { cscIdeographicW,                cscUndefined,               cscoNone             }, // WOIL  70 ( 98)
    { cscIdeographicW,                cscUndefined,               cscoNone             }, // WOIS  70 ( 99)
    { cscIdeographicW,                cscUndefined,               cscoNone             }, // WOIT  70 (100)
    { cscNeutralCharactersNH,         cscUndefined,               cscoNone             }, // NSEN  71 (101)
    { cscNeutralCharactersNH,         cscUndefined,               cscoNone             }, // NSET  71 (102)
    { cscNeutralCharactersNH,         cscUndefined,               cscoNone             }, // NSNW  71 (103)
    { cscNeutralCharactersNH,         cscIdeographicW,            cscoWide             }, // ASAN  72 (104)
    { cscNeutralCharactersNH,         cscIdeographicW,            cscoWide             }, // ASAE  72 (105)
    { cscDigitsWOrAutospacingOffN,    cscDigitsWOrAutospacingOnN, cscoAutospacingDigit }, // NDEA  73 (106)
    { cscIdeographicW,                cscUndefined,               cscoNone             }, // WD__  74 (107)
    { cscNeutralCharactersNH,         cscAlphabetsOptionsN,       cscoAutospacingAlpha }, // NLLA  75 (108)
    { cscIdeographicW,                cscUndefined,               cscoNone             }, // WLA_  76 (109)
    { cscNeutralCharactersNH,         cscUndefined,               cscoNone             }, // NWBL  77 (110)
    { cscNeutralCharactersNH,         cscUndefined,               cscoNone             }, // NWZW  77 (111)
    { cscNeutralCharactersNH,         cscAlphabetsOptionsN,       cscoAutospacingAlpha }, // NPLW  78 (112)
    { cscNeutralCharactersNH,         cscAlphabetsOptionsN,       cscoAutospacingAlpha }, // NPZW  78 (113)
    { cscNeutralCharactersNH,         cscAlphabetsOptionsN,       cscoAutospacingAlpha }, // NPF_  78 (114)
    { cscNeutralCharactersNH,         cscAlphabetsOptionsN,       cscoAutospacingAlpha }, // NPFL  78 (115)
    { cscNeutralCharactersNH,         cscAlphabetsOptionsN,       cscoAutospacingAlpha }, // NPNW  78 (116)
    { cscNeutralCharactersNH,         cscIdeographicW,            cscoWide             }, // APLW  79 (117)
    { cscNeutralCharactersNH,         cscIdeographicW,            cscoWide             }, // APCO  79 (118)
    { cscNeutralCharactersNH,         cscIdeographicW,            cscoWide             }, // ASYW  80 (119)
    { cscNeutralCharactersNH,         cscUndefined,               cscoNone             }, // NHYP  81 (120)
    { cscNeutralCharactersNH,         cscUndefined,               cscoNone             }, // NHYW  81 (121)
    { cscNeutralCharactersNH,         cscIdeographicW,            cscoWide             }, // AHYW  82 (122)
    { cscNeutralCharactersNH,         cscAlphabetsOptionsN,       cscoAutospacingAlpha }, // NAPA  83 (123)
    { cscNeutralCharactersNH,         cscUndefined,               cscoNone             }, // NQMP  84 (124)
    { cscNeutralCharactersNH,         cscUndefined,               cscoNone             }, // NSLS  85 (125)
    { cscNeutralCharactersNH,         cscUndefined,               cscoNone             }, // NSF_  86 (126)
    { cscNeutralCharactersNH,         cscUndefined,               cscoNone             }, // NSBS  86 (127)
    { cscNeutralCharactersNH,         cscUndefined,               cscoNone             }, // NSBB  86 (128)
    { cscNeutralCharactersNH,         cscAlphabetsOptionsN,       cscoAutospacingAlpha }, // NLA_  87 (129)
    { cscNeutralCharactersNH,         cscAlphabetsOptionsN,       cscoAutospacingAlpha }, // NLQ_  88 (130)
    { cscNeutralCharactersNH,         cscAlphabetsOptionsN,       cscoAutospacingAlpha }, // NLQN  88 (131)
    { cscNeutralCharactersNH,         cscAlphabetsOptionsN,       cscoAutospacingAlpha }, // NLQC  88 (132)
    { cscNeutralCharactersNH,         cscIdeographicW,            cscoWide             }, // ALQ_  89 (133)
    { cscNeutralCharactersNH,         cscIdeographicW,            cscoWide             }, // ALQN  89 (134)
    { cscNeutralCharactersNH,         cscAlphabetsOptionsN,       cscoAutospacingAlpha }, // NGR_  90 (135)
    { cscNeutralCharactersNH,         cscAlphabetsOptionsN,       cscoAutospacingAlpha }, // NGRN  90 (136)
    { cscNeutralCharactersNH,         cscAlphabetsOptionsN,       cscoAutospacingAlpha }, // NGQ_  91 (137)
    { cscNeutralCharactersNH,         cscAlphabetsOptionsN,       cscoAutospacingAlpha }, // NGQN  91 (138)
    { cscNeutralCharactersNH,         cscAlphabetsOptionsN,       cscoAutospacingAlpha }, // NCY_  92 (139)
    { cscNeutralCharactersNH,         cscAlphabetsOptionsN,       cscoAutospacingAlpha }, // NCYP  93 (140)
    { cscNeutralCharactersNH,         cscAlphabetsOptionsN,       cscoAutospacingAlpha }, // NCYC  93 (141)
    { cscNeutralCharactersNH,         cscAlphabetsOptionsN,       cscoAutospacingAlpha }, // NAR_  94 (142)
    { cscNeutralCharactersNH,         cscAlphabetsOptionsN,       cscoAutospacingAlpha }, // NAQL  95 (143)
    { cscNeutralCharactersNH,         cscAlphabetsOptionsN,       cscoAutospacingAlpha }, // NAQN  95 (144)
    { cscNeutralCharactersNH,         cscAlphabetsOptionsN,       cscoAutospacingAlpha }, // NHB_  96 (145)
    { cscNeutralCharactersNH,         cscAlphabetsOptionsN,       cscoAutospacingAlpha }, // NHBC  96 (146)
    { cscNeutralCharactersNH,         cscAlphabetsOptionsN,       cscoAutospacingAlpha }, // NHBW  96 (147)
    { cscNeutralCharactersNH,         cscAlphabetsOptionsN,       cscoAutospacingAlpha }, // NHBR  96 (148)
    { cscNeutralCharactersNH,         cscAlphabetsOptionsN,       cscoAutospacingAlpha }, // NASR  97 (149)
    { cscNeutralCharactersNH,         cscAlphabetsOptionsN,       cscoAutospacingAlpha }, // NAAR  97 (150)
    { cscNeutralCharactersNH,         cscAlphabetsOptionsN,       cscoAutospacingAlpha }, // NAAC  97 (151)
    { cscNeutralCharactersNH,         cscAlphabetsOptionsN,       cscoAutospacingAlpha }, // NAAD  97 (152)
    { cscNeutralCharactersNH,         cscAlphabetsOptionsN,       cscoAutospacingAlpha }, // NAED  97 (153)
    { cscNeutralCharactersNH,         cscAlphabetsOptionsN,       cscoAutospacingAlpha }, // NANW  97 (154)
    { cscNeutralCharactersNH,         cscAlphabetsOptionsN,       cscoAutospacingAlpha }, // NAEW  97 (155)
    { cscNeutralCharactersNH,         cscAlphabetsOptionsN,       cscoAutospacingAlpha }, // NAAS  97 (156)
    { cscNeutralCharactersNH,         cscAlphabetsOptionsN,       cscoAutospacingAlpha }, // NHI_  98 (157)
    { cscNeutralCharactersNH,         cscAlphabetsOptionsN,       cscoAutospacingAlpha }, // NHIN  98 (158)
    { cscNeutralCharactersNH,         cscAlphabetsOptionsN,       cscoAutospacingAlpha }, // NHIC  98 (159)
    { cscNeutralCharactersNH,         cscAlphabetsOptionsN,       cscoAutospacingAlpha }, // NHID  98 (160)
    { cscNeutralCharactersNH,         cscAlphabetsOptionsN,       cscoAutospacingAlpha }, // NBE_  99 (161)
    { cscNeutralCharactersNH,         cscAlphabetsOptionsN,       cscoAutospacingAlpha }, // NBEC  99 (162)
    { cscNeutralCharactersNH,         cscAlphabetsOptionsN,       cscoAutospacingAlpha }, // NBED  99 (163)
    { cscNeutralCharactersNH,         cscAlphabetsOptionsN,       cscoAutospacingAlpha }, // NBET  99 (164)
    { cscNeutralCharactersNH,         cscAlphabetsOptionsN,       cscoAutospacingAlpha }, // NGM_ 100 (165)
    { cscNeutralCharactersNH,         cscAlphabetsOptionsN,       cscoAutospacingAlpha }, // NGMC 100 (166)
    { cscNeutralCharactersNH,         cscAlphabetsOptionsN,       cscoAutospacingAlpha }, // NGMD 100 (167)
    { cscNeutralCharactersNH,         cscAlphabetsOptionsN,       cscoAutospacingAlpha }, // NGJ_ 101 (168)
    { cscNeutralCharactersNH,         cscAlphabetsOptionsN,       cscoAutospacingAlpha }, // NGJC 101 (169)
    { cscNeutralCharactersNH,         cscAlphabetsOptionsN,       cscoAutospacingAlpha }, // NGJD 101 (170)
    { cscNeutralCharactersNH,         cscAlphabetsOptionsN,       cscoAutospacingAlpha }, // NOR_ 102 (171)
    { cscNeutralCharactersNH,         cscAlphabetsOptionsN,       cscoAutospacingAlpha }, // NORC 102 (172)
    { cscNeutralCharactersNH,         cscAlphabetsOptionsN,       cscoAutospacingAlpha }, // NORD 102 (173)
    { cscNeutralCharactersNH,         cscAlphabetsOptionsN,       cscoAutospacingAlpha }, // NTA_ 103 (174)
    { cscNeutralCharactersNH,         cscAlphabetsOptionsN,       cscoAutospacingAlpha }, // NTAC 103 (175)
    { cscNeutralCharactersNH,         cscAlphabetsOptionsN,       cscoAutospacingAlpha }, // NTAD 103 (176)
    { cscNeutralCharactersNH,         cscAlphabetsOptionsN,       cscoAutospacingAlpha }, // NTE_ 104 (177)
    { cscNeutralCharactersNH,         cscAlphabetsOptionsN,       cscoAutospacingAlpha }, // NTEC 104 (178)
    { cscNeutralCharactersNH,         cscAlphabetsOptionsN,       cscoAutospacingAlpha }, // NTED 104 (179)
    { cscNeutralCharactersNH,         cscAlphabetsOptionsN,       cscoAutospacingAlpha }, // NKD_ 105 (180)
    { cscNeutralCharactersNH,         cscAlphabetsOptionsN,       cscoAutospacingAlpha }, // NKDC 105 (181)
    { cscNeutralCharactersNH,         cscAlphabetsOptionsN,       cscoAutospacingAlpha }, // NKDD 105 (182)
    { cscNeutralCharactersNH,         cscAlphabetsOptionsN,       cscoAutospacingAlpha }, // NMA_ 106 (183)
    { cscNeutralCharactersNH,         cscAlphabetsOptionsN,       cscoAutospacingAlpha }, // NMAC 106 (184)
    { cscNeutralCharactersNH,         cscAlphabetsOptionsN,       cscoAutospacingAlpha }, // NMAD 106 (185)
    { cscUndefined,                   cscUndefined,               cscoNone             }, // NTH_ 107 (186)
    { cscUndefined,                   cscUndefined,               cscoNone             }, // NTHC 107 (187)
    { cscUndefined,                   cscUndefined,               cscoNone             }, // NTHD 107 (188)
    { cscUndefined,                   cscUndefined,               cscoNone             }, // NTHT 107 (189)
    { cscNeutralCharactersNH,         cscAlphabetsOptionsN,       cscoAutospacingAlpha }, // NLO_ 108 (190)
    { cscNeutralCharactersNH,         cscAlphabetsOptionsN,       cscoAutospacingAlpha }, // NLOC 108 (191)
    { cscNeutralCharactersNH,         cscAlphabetsOptionsN,       cscoAutospacingAlpha }, // NLOD 108 (192)
    { cscNeutralCharactersNH,         cscAlphabetsOptionsN,       cscoAutospacingAlpha }, // NTI_ 109 (193)
    { cscNeutralCharactersNH,         cscAlphabetsOptionsN,       cscoAutospacingAlpha }, // NTIC 109 (194)
    { cscNeutralCharactersNH,         cscAlphabetsOptionsN,       cscoAutospacingAlpha }, // NTID 109 (195)
    { cscNeutralCharactersNH,         cscAlphabetsOptionsN,       cscoAutospacingAlpha }, // NTIN 109 (196)
    { cscNeutralCharactersNH,         cscAlphabetsOptionsN,       cscoAutospacingAlpha }, // NGE_ 110 (197)
    { cscNeutralCharactersNH,         cscAlphabetsOptionsN,       cscoAutospacingAlpha }, // NGEQ 111 (198)
    { cscNeutralCharactersNH,         cscAlphabetsOptionsN,       cscoAutospacingAlpha }, // NBO_ 112 (199)
    { cscGlueCharactersN,             cscUndefined,               cscoNone             }, // NBSP 113 (200)
    { cscGlueCharactersN,             cscUndefined,               cscoNone             }, // NBSS 113 (201)
    { cscNeutralCharactersNH,         cscUndefined,               cscoNone             }, // NOF_ 114 (202)
    { cscNeutralCharactersNH,         cscUndefined,               cscoNone             }, // NOBS 114 (203)
    { cscNeutralCharactersNH,         cscUndefined,               cscoNone             }, // NOEA 114 (204)
    { cscNeutralCharactersNH,         cscUndefined,               cscoNone             }, // NONA 114 (205)
    { cscNeutralCharactersNH,         cscUndefined,               cscoNone             }, // NONP 114 (206)
    { cscNeutralCharactersNH,         cscUndefined,               cscoNone             }, // NOEP 114 (207)
    { cscNeutralCharactersNH,         cscUndefined,               cscoNone             }, // NONW 114 (208)
    { cscNeutralCharactersNH,         cscUndefined,               cscoNone             }, // NOEW 114 (209)
    { cscNeutralCharactersNH,         cscUndefined,               cscoNone             }, // NOLW 114 (210)
    { cscNeutralCharactersNH,         cscUndefined,               cscoNone             }, // NOCO 114 (211)
    { cscNeutralCharactersNH,         cscUndefined,               cscoNone             }, // NOSP 114 (212)
    { cscNeutralCharactersNH,         cscUndefined,               cscoNone             }, // NOEN 114 (213)
    { cscNeutralCharactersNH,         cscUndefined,               cscoNone             }, // NOBN 114 (214)
    { cscNeutralCharactersNH,         cscAlphabetsOptionsN,       cscoAutospacingAlpha }, // NET_ 115 (215)
    { cscNeutralCharactersNH,         cscAlphabetsOptionsN,       cscoAutospacingAlpha }, // NETP 115 (216)
    { cscNeutralCharactersNH,         cscAlphabetsOptionsN,       cscoAutospacingAlpha }, // NETD 115 (217)
    { cscNeutralCharactersNH,         cscAlphabetsOptionsN,       cscoAutospacingAlpha }, // NCA_ 116 (218)
    { cscNeutralCharactersNH,         cscAlphabetsOptionsN,       cscoAutospacingAlpha }, // NCH_ 117 (219)
    { cscNeutralCharactersNH,         cscAlphabetsOptionsN,       cscoAutospacingAlpha }, // WYI_ 118 (220)
    { cscNeutralCharactersNH,         cscAlphabetsOptionsN,       cscoAutospacingAlpha }, // WYIN 118 (221)
    { cscNeutralCharactersNH,         cscAlphabetsOptionsN,       cscoAutospacingAlpha }, // NBR_ 119 (222)
    { cscNeutralCharactersNH,         cscAlphabetsOptionsN,       cscoAutospacingAlpha }, // NRU_ 120 (223)
    { cscNeutralCharactersNH,         cscAlphabetsOptionsN,       cscoAutospacingAlpha }, // NOG_ 121 (224)
    { cscNeutralCharactersNH,         cscAlphabetsOptionsN,       cscoAutospacingAlpha }, // NOGS 121 (225)
    { cscNeutralCharactersNH,         cscAlphabetsOptionsN,       cscoAutospacingAlpha }, // NOGN 121 (226)
    { cscNeutralCharactersNH,         cscAlphabetsOptionsN,       cscoAutospacingAlpha }, // NSI_ 122 (227)
    { cscNeutralCharactersNH,         cscAlphabetsOptionsN,       cscoAutospacingAlpha }, // NSIC 122 (228)
    { cscNeutralCharactersNH,         cscAlphabetsOptionsN,       cscoAutospacingAlpha }, // NTN_ 123 (229)
    { cscNeutralCharactersNH,         cscAlphabetsOptionsN,       cscoAutospacingAlpha }, // NTNC 123 (230)
    { cscNeutralCharactersNH,         cscAlphabetsOptionsN,       cscoAutospacingAlpha }, // NKH_ 124 (231)
    { cscNeutralCharactersNH,         cscAlphabetsOptionsN,       cscoAutospacingAlpha }, // NKHC 124 (232)
    { cscNeutralCharactersNH,         cscAlphabetsOptionsN,       cscoAutospacingAlpha }, // NKHD 124 (233)
    { cscNeutralCharactersNH,         cscAlphabetsOptionsN,       cscoAutospacingAlpha }, // NKHT 124 (234)
    { cscNeutralCharactersNH,         cscAlphabetsOptionsN,       cscoAutospacingAlpha }, // NBU_ 125 (235)
    { cscNeutralCharactersNH,         cscAlphabetsOptionsN,       cscoAutospacingAlpha }, // NBUC 125 (236)
    { cscNeutralCharactersNH,         cscAlphabetsOptionsN,       cscoAutospacingAlpha }, // NBUD 125 (237)
    { cscNeutralCharactersNH,         cscAlphabetsOptionsN,       cscoAutospacingAlpha }, // NSY_ 126 (238)
    { cscNeutralCharactersNH,         cscAlphabetsOptionsN,       cscoAutospacingAlpha }, // NSYP 126 (239)
    { cscNeutralCharactersNH,         cscAlphabetsOptionsN,       cscoAutospacingAlpha }, // NSYC 126 (240)
    { cscNeutralCharactersNH,         cscAlphabetsOptionsN,       cscoAutospacingAlpha }, // NSYW 126 (241)
    { cscNeutralCharactersNH,         cscAlphabetsOptionsN,       cscoAutospacingAlpha }, // NMO_ 127 (242)
    { cscNeutralCharactersNH,         cscAlphabetsOptionsN,       cscoAutospacingAlpha }, // NMOC 127 (243)
    { cscNeutralCharactersNH,         cscAlphabetsOptionsN,       cscoAutospacingAlpha }, // NMOD 127 (244)
    { cscNeutralCharactersNH,         cscAlphabetsOptionsN,       cscoAutospacingAlpha }, // NMOB 127 (245)
    { cscNeutralCharactersNH,         cscAlphabetsOptionsN,       cscoAutospacingAlpha }, // NMON 127 (246)
    { cscNeutralCharactersNH,         cscAlphabetsOptionsN,       cscoAutospacingAlpha }, // NHS_ 128 (247)
    { cscNeutralCharactersNH,         cscUndefined,               cscoNone             }, // WHT_ 129 (248)
    { cscNeutralCharactersNH,         cscUndefined,               cscoNone             }, // LS__ 130 (249)
    { cscNeutralCharactersNH,         cscUndefined,               cscoNone             }, // XNW_ 131 (250)
    { cscNeutralCharactersNH,         cscUndefined,               cscoNone             }, // XNWA 131 (251)
};

//
// Following table maps character class (CHAR_CLASS) to width increment in the loose layout grid mode.
// We store this information on 5 bits only.
// The 4-th bit keeps information about class:
//   * 0 - stands for unambigous class (either wide or narrow),
//   * 1 - stands for ambigous class (wide or narrow - at this point we can not determine)
// Bits 2-3:
//   * for ambigous class stores width increment for narrow characters (see. table)
//   * for unambigous class are not used and set to 0
// Bits 0-1:
//   * for ambigous class stores width increment for wide characters (see. table)
//   * for unambigous class stores width increment for wide or narrow (depends on class) characters (see. table)
//
// Following table presents all possible combination:
//    | bit 1 (3) | bit 0 (2) |
//    |-----------|-----------|
//    |     0     |     0     | width is not incremented                   | width = char_width
//    |     0     |     1     | width is not incremented                   | width = char_width
//    |     1     |     0     | width is incremented by full grid size     | width = char_width + grid
//    |     1     |     1     | width is incremented by half of grid size  | width = char_width + grid/2
// 
const unsigned char s_aLooseTypeWidthIncrement[] =
{
    0x02, // WOB_ 0   
    0x03, // NOPP 1   
    0x03, // NOPA 2   
    0x03, // NOPW 3   
    0x03, // HOP_ 4   
    0x02, // WOP_ 5   
    0x02, // WOP5 6   
    0x03, // NOQW 7   
    0x1e, // AOQW 8   
    0x02, // WOQ_ 9   
    0x02, // WCB_ 10  
    0x03, // NCPP 11  
    0x03, // NCPA 12  
    0x03, // NCPW 13  
    0x03, // HCP_ 14  
    0x02, // WCP_ 15  
    0x02, // WCP5 16  
    0x03, // NCQW 17  
    0x1e, // ACQW 18  
    0x02, // WCQ_ 19  
    0x1e, // ARQW 20  
    0x03, // NCSA 21  
    0x03, // HCO_ 22  
    0x02, // WC__ 23  
    0x02, // WCS_ 24  
    0x02, // WC5_ 25  
    0x02, // WC5S 26  
    0x03, // NKS_ 27  
    0x02, // WKSM 28  
    0x02, // WIM_ 29  
    0x03, // NSSW 30  
    0x02, // WSS_ 31  
    0x02, // WHIM 32  
    0x02, // WKIM 33  
    0x03, // NKSL 34  
    0x02, // WKS_ 35  
    0x00, // WKSC 36  
    0x02, // WHS_ 37  
    0x03, // NQFP 38  
    0x03, // NQFA 39  
    0x02, // WQE_ 40  
    0x02, // WQE5 41  
    0x03, // NKCC 42  
    0x02, // WKC_ 43  
    0x03, // NOCP 44  
    0x03, // NOCA 45  
    0x03, // NOCW 46  
    0x02, // WOC_ 47  
    0x02, // WOCS 48  
    0x02, // WOC5 49  
    0x02, // WOC6 50  
    0x1e, // AHPW 51  
    0x03, // NPEP 52  
    0x03, // NPAR 53  
    0x03, // HPE_ 54  
    0x02, // WPE_ 55  
    0x02, // WPES 56   ???
    0x02, // WPE5 57  
    0x03, // NISW 58  
    0x1e, // AISW 59  
    0x03, // NQCS 60  
    0x03, // NQCW 61  
    0x00, // NQCC 62  
    0x03, // NPTA 63  
    0x03, // NPNA 64  
    0x03, // NPEW 65  
    0x03, // NPEH 66  
    0x03, // NPEV 67  
    0x1e, // APNW 68  
    0x03, // HPEW 69  
    0x02, // WPR_ 70  
    0x03, // NQEP 71  
    0x03, // NQEW 72  
    0x03, // NQNW 73  
    0x1e, // AQEW 74  
    0x1e, // AQNW 75  
    0x1e, // AQLW 76  
    0x02, // WQO_ 77  
    0x03, // NSBL 78  
    0x02, // WSP_ 79  
    0x02, // WHI_ 80  
    0x03, // NKA_ 81  
    0x02, // WKA_ 82  
    0x1e, // ASNW 83  
    0x1e, // ASEW 84  
    0x1e, // ASRN 85  
    0x1e, // ASEN 86  
    0x1e, // ALA_ 87  
    0x1e, // AGR_ 88  
    0x1e, // ACY_ 89  
    0x02, // WID_ 90  
    0x02, // WPUA 91  
    0x03, // NHG_ 92  
    0x02, // WHG_ 93  
    0x02, // WCI_ 94  
    0x03, // NOI_ 95  
    0x02, // WOI_ 96  
    0x00, // WOIC 97  
    0x02, // WOIL 98  
    0x02, // WOIS 99  
    0x02, // WOIT 100 
    0x03, // NSEN 101 
    0x03, // NSET 102 
    0x03, // NSNW 103 
    0x1e, // ASAN 104 
    0x1e, // ASAE 105 
    0x03, // NDEA 106 
    0x02, // WD__ 107 
    0x03, // NLLA 108 
    0x02, // WLA_ 109 
    0x03, // NWBL 110 
    0x03, // NWZW 111 
    0x03, // NPLW 112 
    0x03, // NPZW 113 
    0x03, // NPF_ 114 
    0x03, // NPFL 115 
    0x03, // NPNW 116 
    0x1e, // APLW 117 
    0x00, // APCO 118 
    0x00, // ASYW 119 
    0x03, // NHYP 120 
    0x03, // NHYW 121 
    0x1e, // AHYW 122 
    0x03, // NAPA 123 
    0x03, // NQMP 124 
    0x03, // NSLS 125 
    0x03, // NSF_ 126 
    0x03, // NSBS 127 
    0x03, // NSBB 128 
    0x03, // NLA_ 129 
    0x03, // NLQ_ 130 
    0x03, // NLQN 131 
    0x00, // NLQC 132 
    0x1e, // ALQ_ 133 
    0x03, // ALQN 134 
    0x03, // NGR_ 135 
    0x03, // NGRN 136 
    0x03, // NGQ_ 137 
    0x03, // NGQN 138 
    0x03, // NCY_ 139 
    0x03, // NCYP 140 
    0x00, // NCYC 141 
    0x03, // NAR_ 142 
    0x03, // NAQL 143 
    0x03, // NAQN 144 
    0x03, // NHB_ 145 
    0x00, // NHBC 146 
    0x03, // NHBW 147 
    0x03, // NHBR 148 
    0x00, // NASR 149 
    0x00, // NAAR 150 
    0x00, // NAAC 151 
    0x00, // NAAD 152 
    0x00, // NAED 153 
    0x00, // NANW 154 
    0x00, // NAEW 155 
    0x00, // NAAS 156 
    0x00, // NHI_ 157 
    0x00, // NHIN 158 
    0x00, // NHIC 159 
    0x00, // NHID 160 
    0x00, // NBE_ 161 
    0x00, // NBEC 162 
    0x00, // NBED 163 
    0x00, // NBET 164 
    0x00, // NGM_ 165 
    0x00, // NGMC 166 
    0x00, // NGMD 167 
    0x00, // NGJ_ 168 
    0x00, // NGJC 169 
    0x00, // NGJD 170 
    0x00, // NOR_ 171 
    0x00, // NORC 172 
    0x00, // NORD 173 
    0x00, // NTA_ 174 
    0x00, // NTAC 175 
    0x00, // NTAD 176 
    0x00, // NTE_ 177 
    0x00, // NTEC 178 
    0x00, // NTED 179 
    0x00, // NKD_ 180 
    0x00, // NKDC 181 
    0x00, // NKDD 182 
    0x00, // NMA_ 183 
    0x00, // NMAC 184 
    0x00, // NMAD 185 
    0x00, // NTH_ 186 
    0x00, // NTHC 187 
    0x00, // NTHD 188 
    0x00, // NTHT 189 
    0x00, // NLO_ 190 
    0x00, // NLOC 191 
    0x00, // NLOD 192 
    0x00, // NTI_ 193 
    0x00, // NTIC 194 
    0x00, // NTID 195 
    0x00, // NTIN 196 
    0x03, // NGE_ 197 
    0x03, // NGEQ 198 
    0x03, // NBO_ 199 
    0x03, // NBSP 200 
    0x03, // NBSS 201 
    0x03, // NOF_ 202 
    0x03, // NOBS 203 
    0x03, // NOEA 204 
    0x03, // NONA 205 
    0x03, // NONP 206 
    0x03, // NOEP 207 
    0x03, // NONW 208 
    0x03, // NOEW 209 
    0x03, // NOLW 210 
    0x00, // NOCO 211 
    0x03, // NOSP 212 
    0x03, // NOEN 213 
    0x00, // NOBN 214 
    0x03, // NET_ 215 
    0x03, // NETP 216
    0x03, // NETD 217
    0x03, // NCA_ 218
    0x03, // NCH_ 219
    0x02, // WYI_ 220
    0x02, // WYIN 221
    0x03, // NBR_ 222
    0x03, // NRU_ 223
    0x03, // NOG_ 224
    0x03, // NOGS 225
    0x03, // NOGN 226
    0x00, // NSI_ 227
    0x00, // NSIC 228
    0x03, // NTN_ 229
    0x00, // NTNC 230
    0x00, // NKH_ 231
    0x00, // NKHC 232
    0x00, // NKHD 233
    0x00, // NKHT 234
    0x00, // NBU_ 235
    0x00, // NBUC 236
    0x00, // NBUD 237
    0x00, // NSY_ 238
    0x00, // NSYP 239
    0x00, // NSYC 240
    0x00, // NSYW 241
    0x00, // NMO_ 242
    0x00, // NMOC 243
    0x00, // NMOD 244
    0x00, // NMOB 245
    0x00, // NMON 246
    0x00, // NHS_ 247
    0x02, // WHT_ 248
    0x00, // LS__ 249
    0x00, // XNW_ 250
    0x00, // XNWA 251
};

//-----------------------------------------------------------------------------
//
//  Function:   LooseTypeWidthIncrement
//
//  Synopsis:   Calculate width increment for specified character in 
//              the loose grid layout.
//
//  Returns:    width increment
//
//-----------------------------------------------------------------------------

LONG 
LooseTypeWidthIncrement(
    TCHAR c, 
    BOOL fWide, 
    LONG lGrid)
{
    unsigned char flag = s_aLooseTypeWidthIncrement[CharClassFromCh(c)];

    // If character is narrow and class is ambigous we switch to bits 2-3.
    if (!fWide && (flag & 0x10))
    {
        flag = flag >> 2;
    }

    //
    // We look first at second bit and if it is set to:
    // * 0 - we don't increment character width, so we return '0'
    // * 1 - we look now at first bit and if it set to:
    //   * 0 - we increment character width by grid, so we return 'grid >> 0'
    //   * 1 - we increment character width by grid/2, so we return 'grid >> 1'
    // 
    return (flag & 0x02) ? lGrid >> (flag & 0x01): 0;
}

//-----------------------------------------------------------------------------
//
//  Function:   CscFromCh
//
//  Synopsis:   Determine the CSC from the char with additional information
//              about the run
//
//  Returns:    CSC
//
//-----------------------------------------------------------------------------

CSC
CscFromCh(
    const WCHAR wch,
    long csco )
{
    const PACKEDCSC pcsc = s_aCscMap[CharClassFromCh(wch)];
    CSC csc;

    if (!(pcsc.csco & csco))
    {
        csc = CSC(pcsc.csc);
    }
    else
    {
        csc = CSC(pcsc.cscAlt);
    }

    return csc;
}


//-----------------------------------------------------------------------------
//
//  Function:   PunctStartLine (member, LS callback)
//
//  Synopsis:   Unimplemented LineServices callback
//
//  Returns:    lserrNone
//
//-----------------------------------------------------------------------------

LSERR WINAPI
CLineServices::PunctStartLine(
    PLSRUN plsrun,      // IN
    MWCLS mwcls,        // IN
    WCHAR wch,          // IN
    LSACT* plsact)      // OUT
{
    LSTRACE(PunctStartLine);
    LSNOTIMPL(PunctStartLine);
    return lserrNone;
}

//-----------------------------------------------------------------------------
//
//  Function:   ModWidthOnRun (member, LS callback)
//
//  Synopsis:   Inter-run width modification
//
//  Returns:    lserrNone
//
//-----------------------------------------------------------------------------

LSERR WINAPI
CLineServices::ModWidthOnRun(
    PLSRUN plsrunFirst,     // IN
    WCHAR wchFirst,         // IN
    PLSRUN plsrunSecond,    // IN
    WCHAR wchSecond,        // IN
    LSACT* plsact)          // OUT
{
    LSTRACE(ModWidthOnRun);
    const CSC cscFirst = CscFromCh( wchFirst, plsrunFirst->_csco );
    const CSC cscSecond = CscFromCh( wchSecond, plsrunSecond->_csco );

    //
    // See http://ie/specs/secure/trident/text/csc.htm#Auto_spacing
    //

    if (   (   (cscSecond == 7 || cscSecond == 15)
            && (cscFirst == 3 || cscFirst == 16 || cscFirst == 17))
        || (   (cscFirst == 7 || cscFirst == 15)
            && (cscSecond == 1 || cscSecond == 16 || cscSecond == 17))
        || (   (cscFirst == 8)
            && (cscFirst == 16 || cscFirst == 17)))
    {
        plsact->side = sideRight;
        plsact->kamnt = kamntByQuarterEm;
    }
    else
    {
        plsact->side = sideNone;
        plsact->kamnt = kamntNone;
    }

    return lserrNone;
}

//-----------------------------------------------------------------------------
//
//  Function:   ModWidthSpace (member, LS callback)
//
//  Synopsis:   Space width modification
//
//  Returns:    lserrNone
//
//-----------------------------------------------------------------------------

LSERR WINAPI
CLineServices::ModWidthSpace(
    PLSRUN plsrunCur,   // IN
    PLSRUN plsrunPrev,  // IN
    WCHAR wchPrev,      // IN
    PLSRUN plsrunNext,  // IN
    WCHAR wchNext,      // IN
    LSACT* plsact)      // OUT
{
    LSTRACE(ModWidthSpace);

    plsact->side = sideNone;
    plsact->kamnt = kamntNone;

    if (plsrunPrev && plsrunNext)
    {
        const CSC cscFirst = CscFromCh( wchPrev, plsrunPrev->_csco );
        const CSC cscSecond = CscFromCh( wchNext, plsrunNext->_csco );

        //
        // See http://ie/specs/secure/trident/text/csc.htm#Auto_spacing
        //

        if (   (cscFirst == 7 || cscFirst == 15)
            && (cscSecond == 7 || cscSecond == 15))
        {
            plsact->side = sideRight;
            plsact->kamnt = kamntByHalfEm;
        }
    }

    return lserrNone;
}

//-----------------------------------------------------------------------------
//
//  Function:   ExpandOrCompress (static)
//
//  Synopsis:   Whether we can expand or compress is based on the same csc
//              combination for expansion and compression.  The amount and
//              the side will vary.
//
//  Returns:    BOOL - Whether the char/option combination should be subject
//              of expansion or compression
//
//-----------------------------------------------------------------------------

BOOL
ExpandOrCompress(
    WCHAR wchFirst,     // IN
    long cscoFirst,     // IN
    WCHAR wchSecond,    // IN
    long cscoSecond )   // IN
{
    const CSC cscFirst  = CscFromCh( wchFirst,  cscoFirst );
    const CSC cscSecond = CscFromCh( wchSecond, cscoSecond );

    //
    // See http://ie/specs/secure/trident/text/Line_Just.htm
    //

    return (   (   (cscSecond == 7 || cscSecond == 15)
                && (cscFirst == 1 || cscFirst == 16 || cscFirst == 17))
            || (   (cscFirst == 7 || cscFirst == 15)
                && (cscSecond == 1 || cscSecond == 16 || cscSecond == 17))
            || (   (cscFirst == 8)
                && (cscFirst == 16 || cscFirst == 17)));
}

//-----------------------------------------------------------------------------
//
//  Function:   CompOnRun (member, LS callback)
//
//  Synopsis:   Compression on Run behavior
//
//  Returns:    lserrNone
//
//-----------------------------------------------------------------------------

LSERR WINAPI
CLineServices::CompOnRun(
    PLSRUN plsrunFirst,     // IN
    WCHAR wchFirst,         // IN
    PLSRUN plsrunSecond,    // IN
    WCHAR wchSecond,        // IN
    LSPRACT* plsract)       // OUT
{
    LSTRACE(CompOnRun);

    if (ExpandOrCompress( wchFirst, plsrunFirst->_csco, wchSecond, plsrunSecond->_csco ))
    {
        plsract->lsact.side = sideRight;
        plsract->lsact.kamnt = kamntByEighthEm;
    }
    else
    {
        plsract->lsact.side = sideNone;
        plsract->lsact.kamnt = kamntNone;
    }

    plsract->prior = prior4;

    return lserrNone;
}

//-----------------------------------------------------------------------------
//
//  Function:   CompWidthSpace (member, LS callback)
//
//  Synopsis:   Space width compression
//
//  Returns:    lserrNone
//
//-----------------------------------------------------------------------------

LSERR WINAPI
CLineServices::CompWidthSpace(
    PLSRUN plsrunCur,   // IN
    PLSRUN plsrunPrev,  // IN
    WCHAR wchPrev,      // IN
    PLSRUN plsrunNext,  // IN
    WCHAR wchNext,      // IN
    LSPRACT* plspract)  // OUT
{
    LSTRACE(CompWidthSpace);

    if (_pPFFirst->_uTextJustify == styleTextJustifyNewspaper)
    {
        // Newspaper justification is independent of surrounding character classes
        plspract->lsact.kamnt = kamntToUserDefinedComp;
    }
    else
    {
        const BOOL fNonFixedPitch = 0 == (plsrunCur->GetCF()->_bPitchAndFamily & FIXED_PITCH);

        if (   plsrunPrev
            && plsrunNext
            && fNonFixedPitch
            && ExpandOrCompress(wchPrev, plsrunPrev->_csco, wchNext, plsrunNext->_csco))
        {
            plspract->lsact.kamnt = kamntToHalfEm;
        }
        else if (fNonFixedPitch)
        {
            plspract->lsact.kamnt = kamntToQuarterEm;
        }
        else
        {
            plspract->lsact.kamnt = kamntNone;
        }
    }

    //plspract->lsact.side = plspract->lsact.kamnt ? sideLeft : sideNone;
    plspract->lsact.side = sideRight; // LS requires sideRight
    plspract->prior = plspract->lsact.kamnt ? prior1 : prior0;

    return lserrNone;
}

//-----------------------------------------------------------------------------
//
//  Function:   ExpOnRun (member, LS callback)
//
//  Synopsis:   Determine if we should expand inbetween a given pair of runs
//
//  Returns:    lserrNone
//
//-----------------------------------------------------------------------------

LSERR WINAPI
CLineServices::ExpOnRun(
    PLSRUN plsrunFirst,     // IN
    WCHAR wchFirst,         // IN
    PLSRUN plsrunSecond,    // IN
    WCHAR wchSecond,        // IN
    LSACT* plsact)          // OUT
{
    LSTRACE(ExpOnRun);

    if (ExpandOrCompress( wchFirst, plsrunFirst->_csco, wchSecond, plsrunSecond->_csco ))
    {
        plsact->side = sideRight;
        plsact->kamnt = kamntByQuarterEm;
    }
    else
    {
        plsact->side = sideNone;
        plsact->kamnt = kamntNone;
    }

    return lserrNone;
}

//-----------------------------------------------------------------------------
//
//  Function:   ExpWidthSpace (member, LS callback)
//
//  Synopsis:   Space width expansion
//
//  Returns:    lserrNone
//
//-----------------------------------------------------------------------------

LSERR WINAPI
CLineServices::ExpWidthSpace(
    PLSRUN plsrunCur,   // IN
    PLSRUN plsrunPrev,  // IN
    WCHAR wchPrev,      // IN
    PLSRUN plsrunNext,  // IN
    WCHAR wchNext,      // IN
    LSACT* plsact)      // OUT
{
    LSTRACE(ExpWidthSpace);

    if (_pPFFirst->_uTextJustify == styleTextJustifyNewspaper)
    {
        // Newspaper justification is independent of surrounding character classes
        plsact->kamnt = kamntToUserDefinedExpan;
    }
    else
    {
        plsact->kamnt = kamntToHalfEm;
    }

    plsact->side = sideRight;

    return lserrNone;
}

//-----------------------------------------------------------------------------
//
//  Function:   GetModWidthClasses (member, LS callback)
//
//  Synopsis:   Return the width-modification index for each character
//
//  Returns:    lserrNone
//
//-----------------------------------------------------------------------------

LSERR WINAPI
CLineServices::GetModWidthClasses(
    PLSRUN plsrun,      // IN
    const WCHAR* rgwch, // IN
    DWORD cwch,         // IN
    MWCLS* rgmwcls)     // OUT
{
    LSTRACE(GetModWidthClasses);

    const WCHAR * pchSrc = rgwch;
    MWCLS * pbDst = rgmwcls;
#ifdef _MAC
    PACKEDCSC pcscT  = { 0, 0, 0 };
    pcscT.csco = plsrun->_csco;
#else
    const PACKEDCSC pcscT = { 0, 0, plsrun->_csco };
#endif
    const unsigned short uValue = *(unsigned short *)&pcscT;

    while (cwch--)
    {
        WHEN_DBG( const CHAR_CLASS cc = CharClassFromCh(*pchSrc); Assert(!g_Zero.ab[0] || cc); )

        PACKEDCSC pcsc = s_aCscMap[CharClassFromCh(*pchSrc++)];

        if (!((*(unsigned short *)&pcsc) & uValue))
        {
            *pbDst++ = pcsc.csc;
        }
        else
        {
            *pbDst++ = pcsc.cscAlt;
        }
    }

    return lserrNone;
}

// The following table contains indices into the rgpairact table of actions
const BYTE s_rgmodwidthpairs[cscLim][cscLim] =
{
//  0, 1, 2, 3, 4, 5, 6, 7, 8, 9,10,11,12,13,14,15,16,17,18,19,20,21,22,23 =cscAfter / cscBefore:
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,    //  0 cscUndefined
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,    //  1 cscOpenParenN
    0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4,    //  2 cscOpenParenW
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,    //  3 cscCloseParenN
    0, 0, 2, 0, 2, 0, 2, 0, 0, 0, 2, 0, 2, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 2,    //  4 cscCloseParenW
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,    //  5 cscNeutralN
    0, 0, 2, 0, 2, 0, 2, 0, 0, 0, 2, 0, 2, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 2,    //  6 cscCommaW
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,    //  7 cscKanaW
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,    //  8 cscPunctW
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,    //  9 cscCenteredN
    0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4,    // 10 cscCenteredW
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,    // 11 cscPeriodN
    0, 0, 2, 0, 2, 0, 2, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2,    // 12 cscPeriodW
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,    // 13 cscSpaceN
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,    // 14 cscSpaceW
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,    // 15 cscIdeoW
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,    // 16 cscAlphaN
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,    // 17 cscEllipse
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,    // 18 cscGlueA
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,    // 19 cscPrefixN
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,    // 20 cscPostfixN
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,    // 21 cscDigitsN
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,    // 22 cscDigits
    0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3     // 23 cscOpenQuotesA
};

const LSPAIRACT s_rglspairactV[] =
// first:  side, amount, second: side, amount
{
    sideRight, kamntNone,       sideLeft, kamntNone,
    sideRight, kamntNone,       sideLeft, kamntByHalfEm,
    sideRight, kamntByHalfEm,   sideLeft, kamntNone,
    sideRight, kamntByHalfEm,   sideLeft, kamntNone,
    sideRight, kamntNone,       sideLeft, kamntNone,
    sideRight, kamntByHalfEm,   sideLeft, kamntByHalfEm,
};

HRESULT
CLineServices::SetModWidthPairs()
{
    WHEN_DBG(LSERR lserr = )
            LsSetModWidthPairs( _plsc, sizeof(s_rglspairactV) / sizeof(LSPAIRACT),
                                s_rglspairactV, cscLim, (BYTE *)s_rgmodwidthpairs );

    Assert(!g_Zero.ab[0] || lserr);

    return S_OK;
}

//-----------------------------------------------------------------------------
//
//  Function:   GetEms (member, LS callback)
//
//  Synopsis:   Determine the adjustment amount
//
//  Returns:    lserrNone
//
//-----------------------------------------------------------------------------

const long kcchWide     = 41; // approx 5.5" at 10 points
const long kcchNarrow   = 14; // approx 2" at 10 points
const long klCompWide   = 85;
const long klCompNarrow = 75;
const long klExpWide    = 150;
const long klExpNarrow  = 250;

long
Interpolate(int cch, long lMinVal, long lMaxVal)
{
    return (cch <= kcchNarrow)
            ? lMinVal
            : ( (cch >= kcchWide)
                ? lMaxVal
                : lMinVal + MulDivQuick(lMaxVal - lMinVal, cch, kcchWide - kcchNarrow) );
}

LSERR WINAPI
CLineServices::GetEms(
    PLSRUN plsrun,      // IN
    LSTFLOW kTFlow,     // IN
    PLSEMS plems)       // OUT
{
    LSTRACE(GetEms);
    LSERR  lserr;
    CCcs  ccs;

    if (GetCcs(&ccs, plsrun, _pci->_hdc, _pci))
    {
        const int em = ccs.GetBaseCcs()->_xAveCharWidth;

        plems->em   = em;
        plems->em2  = em / 2;
        plems->em3  = em / 3;
        plems->em4  = em / 4;
        plems->em8  = em / 8;
        plems->em16 = MulDivQuick( em, 15, 16 );

        if (_pPFFirst->_uTextJustify == styleTextJustifyNewspaper)
        {
            // get number of chars in column of text
            const int cchCol = _xWrappingWidth / ccs.GetBaseCcs()->_xAveCharWidth;

            plems->udExp  = max(1, MulDivQuick(em, Interpolate(cchCol, klExpNarrow,  klExpWide),  100));
            plems->udComp = max(1, MulDivQuick(em, Interpolate(cchCol, klCompNarrow, klCompWide), 100));
        }
        lserr = lserrNone;
    }
    else
    {
        lserr = lserrOutOfMemory;
    }
    return lserr;
}

//+----------------------------------------------------------------------------
//
//  Function:   CheckSetExpansion (member)
//
//  Returns:    LSERR
//
//-----------------------------------------------------------------------------

// The following array contains indices into the rgexp array of expansion actions
#define A 3 // A means expansion allowed always
#define X 2 // X means expansion never
            // 0 means expansion allowed for distributed alignment only

// Expansion actions
const LSEXPAN s_alsexpanTable[] =
{
    // FullScaled  Distributed
    {      0,          1     }, // "0" Distributed only
    {      1,          0     }, //     Justified only -- NOT USED
    {      0,          0     }, // "X" No expansion ever
    {      1,          1     }  // "A" Distributed or Justified (FullScaled)
};

const BYTE s_abIndexExpansion[cscLim][cscLim] =
{
//  0, 1, 2, 3, 4, 5, 6, 7, 8, 9,10,11,12,13,14,15,16,17,18,19,20,21,22,23 =cscAfter / cscBefore:
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,    //  0 cscUndefined
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, A, 0, 0, 0, 0, 0, X, 0, 0, 0, 0,    //  1 cscOpenParenN
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, A, A, 0, 0, 0, 0, X, 0, 0, 0, 0,    //  2 cscOpenParenW
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, A, 0, 0, 0, 0, 0, X, 0, 0, 0, 0,    //  3 cscCloseParenN
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, A, A, 0, 0, 0, 0, X, 0, 0, 0, 0,    //  4 cscCloseParenW
    0, 0, 0, 0, 0, 0, 0, A, 0, 0, 0, A, 0, A, 0, A, 0, 0, 0, X, A, A, 0, 0,    //  5 cscNeutralN
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, A, 0, 0, 0, 0, 0, X, 0, 0, 0, 0,    //  6 cscCommaW
    0, 0, 0, 0, 0, A, 0, A, 0, 0, 0, A, 0, A, A, A, A, A, 0, X, A, A, A, 0,    //  7 cscKanaW
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, A, 0, 0, 0, 0, 0, X, 0, 0, 0, 0,    //  8 cscPunctW
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, A, 0, 0, 0, 0, 0, X, 0, 0, 0, 0,    //  9 cscCenteredN
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, A, A, 0, 0, 0, 0, X, 0, 0, 0, 0,    // 10 cscCenteredW
    0, 0, 0, 0, 0, A, 0, A, 0, 0, 0, A, 0, A, A, A, A, A, 0, X, A, A, A, 0,    // 11 cscPeriodN
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, A, A, 0, 0, 0, 0, X, 0, 0, 0, 0,    // 12 cscPeriodW
    0, A, A, A, A, A, A, A, A, A, A, A, A, A, A, A, A, A, A, X, A, A, A, A,    // 13 cscSpaceN
    0, 0, A, 0, A, 0, 0, A, 0, 0, A, A, A, A, A, A, 0, 0, 0, X, A, A, 0, 0,    // 14 cscSpaceW
    0, 0, 0, 0, 0, A, 0, A, 0, 0, 0, A, 0, A, A, A, A, A, 0, X, A, A, A, 0,    // 15 cscIdeoW
    0, 0, 0, 0, 0, 0, 0, A, 0, 0, 0, A, 0, A, 0, A, 0, 0, 0, X, A, A, 0, 0,    // 16 cscAlphaN
    0, 0, 0, 0, 0, 0, 0, A, 0, 0, 0, 0, A, A, 0, A, 0, 0, 0, X, A, 0, 0, 0,    // 17 cscEllipse
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, A, 0, 0, A, 0, X, X, 0, 0, 0, 0,    // 18 cscGlueA
    0, X, X, X, X, X, X, X, X, X, X, X, X, X, X, X, X, X, X, X, X, X, X, X,    // 19 cscPrefixN
    0, 0, 0, 0, 0, A, 0, A, 0, 0, 0, A, 0, A, A, A, A, 0, 0, X, A, A, 0, 0,    // 20 cscPostfixN
    0, 0, 0, 0, 0, A, 0, A, 0, 0, 0, A, 0, A, A, A, A, A, 0, X, A, A, A, 0,    // 21 cscDigitsN
    0, 0, 0, 0, 0, 0, 0, A, 0, 0, 0, 0, A, A, 0, A, 0, 0, 0, X, A, 0, 0, 0,    // 22 cscDigits
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, A, A, 0, 0, 0, 0, X, 0, 0, 0, 0     // 23 cscOpenQuotesA
};


const BYTE s_abIndexExpansionNewspaperNonFE[cscLim][cscLim] =
{
//  0, 1, 2, 3, 4, 5, 6, 7, 8, 9,10,11,12,13,14,15,16,17,18,19,20,21,22,23 =cscAfter / cscBefore:
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,    //  0 cscUndefined
    0, A, A, A, A, A, A, A, A, A, A, A, A, A, A, A, A, A, A, X, A, A, A, A,    //  1 cscOpenParenN
    0, A, A, A, A, A, A, A, A, A, A, A, A, A, A, A, A, A, A, X, A, A, A, A,    //  2 cscOpenParenW
    0, A, A, A, A, A, A, A, A, A, A, A, A, A, A, A, A, A, A, X, A, A, A, A,    //  3 cscCloseParenN
    0, A, A, A, A, A, A, A, A, A, A, A, A, A, A, A, A, A, A, X, A, A, A, A,    //  4 cscCloseParenW
    0, A, A, A, A, A, A, A, A, A, A, A, A, A, A, A, A, A, A, X, A, A, A, A,    //  5 cscNeutralN
    0, A, A, A, A, A, A, A, A, A, A, A, A, A, A, A, A, A, A, X, A, A, A, A,    //  6 cscCommaW
    0, A, A, A, A, A, A, A, A, A, A, A, A, A, A, A, A, A, A, X, A, A, A, A,    //  7 cscKanaW
    0, A, A, A, A, A, A, A, A, A, A, A, A, A, A, A, A, A, A, X, A, A, A, A,    //  8 cscPunctW
    0, A, A, A, A, A, A, A, A, A, A, A, A, A, A, A, A, A, A, X, A, A, A, A,    //  9 cscCenteredN
    0, A, A, A, A, A, A, A, A, A, A, A, A, A, A, A, A, A, A, X, A, A, A, A,    // 10 cscCenteredW
    0, A, A, A, A, A, A, A, A, A, A, A, A, A, A, A, A, A, A, X, A, A, A, A,    // 11 cscPeriodN
    0, A, A, A, A, A, A, A, A, A, A, A, A, A, A, A, A, A, A, X, A, A, A, A,    // 12 cscPeriodW
    0, A, A, A, A, A, A, A, A, A, A, A, A, A, A, A, A, A, A, X, A, A, A, A,    // 13 cscSpaceN
    0, A, A, A, A, A, A, A, A, A, A, A, A, A, A, A, A, A, A, X, A, A, A, A,    // 14 cscSpaceW
    0, A, A, A, A, A, A, A, A, A, A, A, A, A, A, A, A, A, A, X, A, A, A, A,    // 15 cscIdeoW
    0, A, A, A, A, A, A, A, A, A, A, A, A, A, A, A, A, A, A, X, A, A, A, A,    // 16 cscAlphaN
    0, A, A, A, A, A, A, A, A, A, A, A, A, A, A, A, A, A, A, X, A, A, A, A,    // 17 cscEllipse
    0, A, A, A, A, A, A, A, A, A, A, A, A, A, A, A, A, A, X, X, A, A, A, A,    // 18 cscGlueA
    0, X, X, X, X, X, X, X, X, X, X, X, X, X, X, X, X, X, X, X, X, X, X, X,    // 19 cscPrefixN
    0, A, A, A, A, A, A, A, A, A, A, A, A, A, A, A, A, A, A, X, A, A, A, A,    // 20 cscPostfixN
    0, A, A, A, A, A, A, A, A, A, A, A, A, A, A, A, A, A, A, X, A, A, A, A,    // 21 cscDigitsN
    0, A, A, A, A, A, A, A, A, A, A, A, A, A, A, A, A, A, A, X, A, A, A, A,    // 22 cscDigits
    0, A, A, A, A, A, A, A, A, A, A, A, A, A, A, A, A, A, A, X, A, A, A, A     // 23 cscOpenQuotesA
};

#undef A
#undef X

LSERR
CLineServices::CheckSetExpansion()
{
    LSERR lserr;
    BYTE * abIndexExpansion = (BYTE *)
                              ( _pPFFirst->_uTextJustify == styleTextJustifyInterIdeograph 
                                ? s_abIndexExpansion
                                : s_abIndexExpansionNewspaperNonFE );

    if (_abIndexExpansion == abIndexExpansion)
    {
        lserr = lserrNone;
    }
    else
    {
        lserr = LsSetExpansion( _plsc,
                                ARRAY_SIZE(s_alsexpanTable), s_alsexpanTable,
                                cscLim, abIndexExpansion);

        _abIndexExpansion = abIndexExpansion;
    }

    return lserr;
}

//+----------------------------------------------------------------------------
//
//  Function:   CheckSetCompression (member)
//
//  Returns:    LSERR
//
//-----------------------------------------------------------------------------

const LSPRACT s_alspractCompression[] =
{
    prior0,     sideNone,       kamntNone,          // not defined
    prior3,     sideLeft,       kamntToHalfEm,      // Open Paren
    prior3,     sideRight,      kamntToHalfEm,      // Close Paren, Comma+Period
    prior5,     sideLeftRight,  kamntTo15Sixteenth, // Kana Compression
    prior2,     sideLeftRight,  kamntToHalfEm,      // Centered Characters

    // Priority 4 is not defined here, reserved for CompOnRun
    // Priority 1 is not defined here, reserved for CompWidthSpace
};

const BYTE s_abIndexPract[cscLim] =
{
    0,  //  0 cscUndefined
    0,  //  1 cscOpenParenN
    1,  //  2 cscOpenParenW
    0,  //  3 cscCloseParenN
    2,  //  4 cscCloseParenW
    0,  //  5 cscNeutralN
    2,  //  6 cscCommaW
    3,  //  7 cscKanaW
    0,  //  8 cscPunctW
    0,  //  9 cscCenteredN
    4,  // 10 cscCenteredW
    0,  // 11 cscPeriodN
    2,  // 12 cscPeriodW
    0,  // 13 cscSpaceN
    0,  // 14 cscSpaceW
    0,  // 15 cscIdeoW
    0,  // 16 cscAlphaN
    0,  // 17 cscEllipse
    0,  // 18 cscGlueA
    0,  // 19 cscPrefixN
    0,  // 20 cscPostfixN
    0,  // 21 cscDigitsN
    0,  // 22 cscDigits
    0,  // 23 cscOpenQuotesA
};

LSERR
CLineServices::CheckSetCompression()
{
    LSERR lserr;

    if (!_abIndexPract)
    {
        lserr = LsSetCompression( _plsc, priorNum,
                                  ARRAY_SIZE(s_alspractCompression), s_alspractCompression,
                                  cscLim, (BYTE *)s_abIndexPract );

        _abIndexPract = (BYTE *)s_abIndexPract;
    }
    else
    {
        lserr = lserrNone;
    }

    return lserr;
}

//-----------------------------------------------------------------------------
//
//  Function:   FGetLastLineJustification (member, LS callback)
//
//  Synopsis:   When you have a justified line, you can either justify or not
//              the last line.  Under some circumstance, you may want to 
//              justfify the line at BRs in addition to block boundaries.
//
//  Returns:    lserrNone
//
//-----------------------------------------------------------------------------

LSERR WINAPI
CLineServices::FGetLastLineJustification(
    LSKJUST lskj,               // IN
    LSKALIGN lskal,             // IN
    ENDRES endr,                // IN
    BOOL * pfJustifyLastLine,   // OUT
    LSKALIGN * plskalLine)      // OUT
{
    LSTRACE(FGetLastLineJustification);

    BOOL fJustifyLastLine;

    //
    // We get endr == endrSoftCR whether we have a <BR> or a </P>.  We're interested
    // in the former, but we need to dig around some to determine it.  Note that the
    // assumption here is that if we're being called, any BR we seen in the COneRun
    // linklist is in fact on the line (ie we didn't end up breaking somewhere before
    // the BR after having scanned it.)
    //

    if (   _pPFFirst->_uTextJustify == styleTextJustifyDistributeAllLines
        || _pPFFirst->_uTextAlignLast == styleTextAlignLastJustify)
    {
        fJustifyLastLine = TRUE;
    }
    else if (   _pPFFirst->_uTextJustify == styleTextJustifyNewspaper 
             || _pPFFirst->_uTextJustify == styleTextJustifyInterCluster
             || _pPFFirst->_uTextJustify == styleTextJustifyKashida)
    {
        fJustifyLastLine =    endr == endrSoftCR
                           && _listCurrent._pTail->Branch()->Tag() == ETAG_BR;
    }
    else
    {
        fJustifyLastLine = FALSE;
    }

    *pfJustifyLastLine = fJustifyLastLine;
    switch (_pPFFirst->_uTextAlignLast)
    {
    default:
        *plskalLine = lskal;
        break;

    case styleTextAlignLastLeft:
        *plskalLine = !_li._fRTLLn ? lskalLeft : lskalRight;
        break;

    case styleTextAlignLastCenter:
        *plskalLine = endr == endrSoftCR
                      && _listCurrent._pTail->Branch()->Tag() == ETAG_BR 
                      ? lskal : lskalCentered;
        break;

    case styleTextAlignLastRight:
        *plskalLine = !_li._fRTLLn ? lskalRight : lskalLeft;
        break;
    }
    
    return lserrNone;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\text\onerun.cxx ===
/*
 *  @doc    INTERNAL
 *
 *  @module ONERUN.CXX -- line services one run interface.
 *
 *
 *  Owner: <nl>
 *      Sujal Parikh <nl>
 *
 *  History: <nl>
 *      5/6/97     sujalp created
 *
 *  Copyright (c) 1997-1998 Microsoft Corporation. All rights reserved.
 */

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_LINESRV_HXX_
#define X_LINESRV_HXX_
#include "linesrv.hxx"
#endif

#ifndef X_LSM_HXX_
#define X_LSM_HXX_
#include "lsm.hxx"
#endif

#ifndef X_LSRENDER_HXX_
#define X_LSRENDER_HXX_
#include "lsrender.hxx"
#endif

#ifndef X_ONERUN_HXX_
#define X_ONERUN_HXX_
#include "onerun.hxx"
#endif

#ifndef X_ELEMENTP_HXX_
#define X_ELEMENTP_HXX_
#include "elementp.hxx"
#endif

#ifndef X__UNIWBK_H_
#define X__UNIWBK_H_
#include "uniwbk.h"
#endif

ExternTag(tagLSCallBack);

#if DBG == 1 || defined(DUMPRUNS)
long COneRunFreeList::s_NextSerialNumber = 0;
MtDefine(CLineServicesDumpList_aryLsqsubinfo_pv, Locals, "CLineServices::DumpList::aryLsqsubinfo_pv");
#endif

//-----------------------------------------------------------------------------
//
//  Function:   Deinit
//
//  Synopsis:   This function is called during the destruction of the
//              COneRunFreeList. It frees up any allocated COneRun objects.
//
//  Returns:    nothing
//
//-----------------------------------------------------------------------------
void
COneRunFreeList::Deinit()
{
    COneRun *por;
    COneRun *porNext;

    por = _pHead;
    while (por)
    {
        Assert(por->_pCF == NULL);
        Assert(por->_pCFOriginal == NULL);
        Assert(por->_pComplexRun == NULL);
        porNext = por->_pNext;
        delete por;
        por = porNext;
    }
}

//-----------------------------------------------------------------------------
//
//  Function: Clone
//
//  Synopsis: Clones a one run object making copies of all the stuff which
//            is needed.
//
//  Returns:  The cloned run -- either this or NULL depending upon if we could
//            allocate mem for subobjects.
//
//-----------------------------------------------------------------------------
COneRun *
COneRun::Clone(COneRun *porClone)
{
    COneRun *porRet = this;

    // Copy over all the memory
    memcpy (this, porClone, sizeof(COneRun));
    
    _pchBase = NULL;

    // If we have a pcf then it needs to be cloned too
    if (_fMustDeletePcf)
    {
        Assert(porClone->GetCF() != NULL);
        _pCF = new CCharFormat(*(porClone->GetCF()));
        if (!_pCF)
        {
            _fMustDeletePcf = FALSE;
            porRet = NULL;
            goto Cleanup;
        }
    }

    // Clone the CStr properly.
    memset (&_cstrRunChars, 0, sizeof(CStr));
    _cstrRunChars.Set(porClone->_cstrRunChars);

    // Cloned runs do not inherit their selection status from the guy
    // it clones from
    _fSelected = FALSE;
    
    // Setup the complex run related stuff properly
    porRet->_pComplexRun = NULL;
    porRet->_lsCharProps.fGlyphBased = FALSE;
    porRet->SetSidFromTreePos(porClone->_ptp);

    // Structure stuff should not copy
    porRet->_pNext = porRet->_pPrev = NULL;

Cleanup:
    return porRet;
}

//-----------------------------------------------------------------------------
//
//  Function: GetFreeOneRun
//
//  Synopsis: Gets a free one run object. If we already have some in the free
//            list, then we need to use those, else allocate off the heap.
//            If porClone is non-NULL then we will clone in that one run
//            into the newly allocated one.
//
//  Returns:  The run
//
//-----------------------------------------------------------------------------
COneRun *
COneRunFreeList::GetFreeOneRun(COneRun *porClone)
{
    COneRun *por = NULL;

    if (_pHead)
    {
        por = _pHead;
        _pHead = por->_pNext;
    }
    else
    {
        por = new COneRun();
    }
    if (por)
    {
        if (porClone)
        {
            if (por != por->Clone(porClone))
            {
                SpliceIn(por);
                por = NULL;
                goto Cleanup;
            }
        }
        else
        {
            memset(por, 0, sizeof(COneRun));
            por->_bConvertMode = CM_UNINITED;
        }
        
#if DBG == 1 || defined(DUMPRUNS)
        por->_nSerialNumber = s_NextSerialNumber++;
#endif
    }
Cleanup:    
    return por;
}

//-----------------------------------------------------------------------------
//
//  Function:   SpliceIn
//
//  Synopsis:   Returns runs which are no longer needed back to the free list.
//              It also uninits all the runs.
//
//  Returns:    Nothing
//
//-----------------------------------------------------------------------------
void
COneRunFreeList::SpliceIn(COneRun *pFirst)
{
    Assert(pFirst);
    COneRun *por = pFirst;
    COneRun *porLast = NULL;
    
    // Clear out the runs when they are put into the free list.
    while(por)
    {
        porLast = por;
        por->Deinit();

        // TODO(SujalP): por->_pNext is valid after Deinit!!!! Change this so
        // that this code does not depend on this.
        por = por->_pNext;
    }

    Assert(porLast);
    porLast->_pNext = _pHead;
    _pHead = pFirst;
}

//-----------------------------------------------------------------------------
//
//  Function:   Init
//
//-----------------------------------------------------------------------------
void
COneRunCurrList::Init()
{
    _pHead = _pTail = NULL;
}

//-----------------------------------------------------------------------------
//
//  Function:   Deinit
//
//-----------------------------------------------------------------------------
void
COneRunCurrList::Deinit()
{
    Assert(_pHead == NULL && _pTail == NULL);
}

//-----------------------------------------------------------------------------
//
//  Function:   SpliceOut
//
//  Synopsis:   Removes a chunk of runs from pFirst to pLast from the current list.
//
//  Returns:    Nothing
//
//-----------------------------------------------------------------------------
void
COneRunCurrList::SpliceOut(COneRun *pFirst, COneRun *pLast)
{
    Assert(pFirst && pLast);
    
    //
    // If the first node being removed is the head node then
    // let us deal with that
    //
    if (pFirst->_pPrev == NULL)
    {
        Assert(pFirst == _pHead);
        _pHead = pLast->_pNext;
    }
    else
    {
        pFirst->_pPrev->_pNext = pLast->_pNext;
    }

    //
    // If the last node being removed is the tail node then
    // let us deal with that
    //
    if (pLast->_pNext == NULL)
    {
        Assert(pLast == _pTail);
        _pTail = pFirst->_pPrev;
    }
    else
    {
        pLast->_pNext->_pPrev = pFirst->_pPrev;
    }

    //
    // Clear the next and prev pointers in the spliced out portion
    //
    pFirst->_pPrev = NULL;
    pLast->_pNext = NULL;
}

#if DBG==1
//-----------------------------------------------------------------------------
//
//  Function:   VerifyStuff
//
//  Synopsis:   A debug only function which verifies that the state of the
//              current onerun list is good.
//
//  Returns:    Nothing
//
//-----------------------------------------------------------------------------
void
COneRunCurrList::VerifyStuff(CLineServices *pLS)
{
    COneRun *por = _pHead;
    LONG lscp;
    LONG cchSynths;
    
    if (!por)
        goto Cleanup;
    lscp = por->_lscpBase;
    cchSynths = por->_chSynthsBefore;
    
    while (por)
    {
        Assert(por->_lscch == por->_lscchOriginal);
        Assert(por->_lscpBase == lscp);
        lscp += (por->IsAntiSyntheticRun() ? 0 : por->_lscch);
        
        Assert(cchSynths == por->_chSynthsBefore);
        cchSynths += por->IsSyntheticRun() ? por->_lscch : 0;
        cchSynths -= por->IsAntiSyntheticRun() ? por->_lscch : 0;

        // NestedElement should be true if NestedLayout is true.
        Assert(!por->_fCharsForNestedLayout || por->_fCharsForNestedElement);
        // Nestedlayout should be true if nestedrunowner is true.
        Assert(!por->_fCharsForNestedRunOwner || por->_fCharsForNestedLayout);
        
        // NOTE: non Pseudo MBP one runs can have a _iPEI.
        Assert((por->_fIsPseudoMBP) ? (por->GetFF()->_iPEI >= 0) : TRUE);
        
        por = por->_pNext;
    }

    por = _pTail;
    Assert(por);
    if (por->_fNotProcessedYet)
    {
        // Only one not processed yet run at the end
        por = por->_pPrev;
        while (por)
        {
            Assert(!por->_fNotProcessedYet);
            por = por->_pPrev;
        }
    }
    
Cleanup:
    return;
}
#endif

//-----------------------------------------------------------------------------
//
//  Function:   SpliceInAfterMe
//
//  Synopsis:   Adds pFirst into the currentlist after the position
//              indicated by pAfterMe. If pAfterMe is NULL its added to the head.
//
//  Returns:    Nothing
//
//-----------------------------------------------------------------------------
void
#if DBG==1
COneRunCurrList::SpliceInAfterMe(CLineServices *pLS, COneRun *pAfterMe, COneRun *pFirst)
#else
COneRunCurrList::SpliceInAfterMe(COneRun *pAfterMe, COneRun *pFirst)
#endif
{
    COneRun **ppor;
#if DBG==1
    COneRun *pOldTail = _pTail;
#endif
    
    WHEN_DBG(VerifyStuff(pLS));
    
    ppor = (pAfterMe == NULL) ? &_pHead : &pAfterMe->_pNext;
    pFirst->_pNext = *ppor;
    *ppor = pFirst;
    pFirst->_pPrev = pAfterMe;
    
    COneRun *pBeforeMe = pFirst->_pNext;
    ppor = pBeforeMe == NULL ? &_pTail : &pBeforeMe->_pPrev;
    *ppor = pFirst;

#if DBG==1    
    {
        LONG chSynthsBefore = 0;

        if (pOldTail != NULL)
        {
            chSynthsBefore = pOldTail->_chSynthsBefore;

            chSynthsBefore += pOldTail->IsSyntheticRun()     ? pOldTail->_lscch : 0;
            chSynthsBefore -= pOldTail->IsAntiSyntheticRun() ? pOldTail->_lscch : 0;
        }
        
        Assert(chSynthsBefore == pFirst->_chSynthsBefore);
    }
#endif
}

//-----------------------------------------------------------------------------
//
//  Function:   SpliceInBeforeMe
//
//  Synopsis:   Adds the onerun identified by pFirst before the run
//              identified by pBeforeMe. If pBeforeMe is NULL then it
//              adds it at the tail.
//
//  Returns:    Nothing
//
//-----------------------------------------------------------------------------
void
COneRunCurrList::SpliceInBeforeMe(COneRun *pBeforeMe, COneRun *pFirst)
{
    COneRun **ppor;

    ppor = pBeforeMe == NULL ? &_pTail : &pBeforeMe->_pPrev;
    pFirst->_pPrev = *ppor;
    *ppor = pFirst;
    pFirst->_pNext = pBeforeMe;

    COneRun *pAfterMe = pFirst->_pPrev;
    ppor = pAfterMe == NULL ? &_pHead : &pAfterMe->_pNext;
    *ppor = pFirst;
}

//-----------------------------------------------------------------------------
//
//  Function:   DiscardOneRuns
//
//  Synopsis:   Removes all the runs from the current list and gives them
//              back to the free list.
//
//  Returns:    Nothing
//
//-----------------------------------------------------------------------------
void
CLineServices::DiscardOneRuns()
{
    COneRun *pFirst = _listCurrent._pHead;
    COneRun *pTail  = _listCurrent._pTail;
    
    if (pFirst)
    {
        _listCurrent.SpliceOut(pFirst, pTail);
        _listFree.SpliceIn(pFirst);
    }
}

//-----------------------------------------------------------------------------
//
//  Function:   AdvanceOneRun
//
//  Synopsis:   This is our primary function to get the next run at the
//              frontier.
//
//  Returns:    The one run.
//
//-----------------------------------------------------------------------------
COneRun *
CLineServices::AdvanceOneRun(LONG lscp)
{
    COneRun *por;
    BOOL fRet = FALSE;
    
    //
    // Get the memory for a one run
    //
    por = _listFree.GetFreeOneRun(NULL);
    if (!por)
        goto Cleanup;

    // Setup the lscp...
    por->_lscpBase = lscp;
    
    if (!_treeInfo._fHasNestedElement)
    {
        //
        // If we have run out of characters in the tree pos then we need
        // advance to the next tree pos.
        //
        if (!_treeInfo.GetCchRemainingInTreePos())
        {
            if (!_treeInfo.AdvanceTreePos(LC_TO_FC(GetLayoutContext())))
                goto Cleanup;
            por->_fCannotMergeRuns = TRUE;
        }

        //
        // If we have run out of characters in the text then we need
        // to advance to the next text pos
        //
        if (!_treeInfo._cchValid)
        {
            if (!_treeInfo.AdvanceTxtPtr())
                goto Cleanup;
            por->_fCannotMergeRuns = TRUE;
        }

        Assert(_treeInfo._lscpFrontier == lscp);
    }

    //
    // If we have a nested run owner then the number of characters given to
    // the run are the number of chars in that nested run owner. Else the
    // number of chars is the minimum of the chars in the tree pos and that
    // in the text node.
    //
    if (!_treeInfo._fHasNestedElement)
    {
        por->_lscch = min(_treeInfo.GetCchRemainingInTreePosReally(),
                          _treeInfo._cchValid);

        if (_lsMode == LSMODE_MEASURER)
        {
            por->_lscch = min(por->_lscch, MAX_CHARS_FETCHRUN_RETURNS);
        }
        else
        {
            // NB Additional 5 chars corresponds to a fudge factor.
#if DBG==1
            if (!((CDisplay*)_pMeasurer->_pdp)->_fBuildFontList)
#endif
                por->_lscch = min(por->_lscch, LONG(_pMeasurer->_li._cch + 5));
        }
        AssertSz(por->_lscch > 0 || _treeInfo.IsNonEdgePos(), "Cannot measure 0 or -ve chars!");

        por->_pchBase = _treeInfo._pchFrontier;
    }
    else
    {
        //
        // NOTE(SujalP): The number of characters _returned_ to LS will not be
        // _lscch. We will catch this case in FetchRun and feed only a single
        // char with the pch pointing to a valid location so that LS does not
        // choke on it.
        //
        CElement *pElemNested = _treeInfo._ptpFrontier->Branch()->Element();

        por->_lscch = GetNestedElementCch(pElemNested);
        por->_fCannotMergeRuns = TRUE;
        por->_pchBase = NULL;
        por->_fCharsForNestedElement  = TRUE;
        por->_fCharsForNestedLayout   = _treeInfo._fHasNestedLayout;
        por->_fCharsForNestedRunOwner = _treeInfo._fHasNestedRunOwner;
    }

    //
    // Update all the other information in the one run
    //
    por->_fIsNonEdgePos = _treeInfo.IsNonEdgePos();
    por->_chSynthsBefore = _treeInfo._chSynthsBefore;
    por->_lscchOriginal = por->_lscch;
    por->_pchBaseOriginal = por->_pchBase;
    por->_ptp = _treeInfo._ptpFrontier;
    por->SetSidFromTreePos(por->_ptp);
    por->_mbpTop = _mbpTopCurrent;
    por->_mbpBottom = _mbpBottomCurrent;
    
    por->_pCF = (CCharFormat *)_treeInfo._pCF;
#if DBG == 1
    por->_pCFOriginal = por->_pCF;
#endif
    por->_fInnerCF = _treeInfo._fInnerCF;
    por->_pPF = _treeInfo._pPF;
    por->_fInnerPF = _treeInfo._fInnerPF;
    por->_pFF = _treeInfo._pFF;
    
    //
    // At last let us go and move out frontier
    //
    _treeInfo.AdvanceFrontier(por);
    
    fRet = TRUE;
    
Cleanup:
    if (!fRet && por)
    {
        delete por;
        por = NULL;
    }
    
    return por;
}

//-----------------------------------------------------------------------------
//
//  Function:   CanMergeTwoRuns
//
//  Synopsis:   Decided if the 2 runs can be merged into one
//
//  Returns:    BOOL
//
//-----------------------------------------------------------------------------
BOOL
CLineServices::CanMergeTwoRuns(COneRun *por1, COneRun *por2)
{
    BOOL fRet;
    
    if (   por1->_dwProps
        || por2->_dwProps
        || por1->_pCF != por2->_pCF
        || por1->_bConvertMode != por2->_bConvertMode
        || por1->_ccvBackColor.GetRawValue() != por2->_ccvBackColor.GetRawValue()
        || por1->_pComplexRun
        || por2->_pComplexRun
        || (por1->_pchBase + por1->_lscch != por2->_pchBase) // happens with passwords.
       )
        fRet = FALSE;
    else
        fRet = TRUE;
    return fRet;
}

//-----------------------------------------------------------------------------
//
//  Function:   MergeIfPossibleIntoCurrentList
//
//-----------------------------------------------------------------------------
COneRun *
CLineServices::MergeIfPossibleIntoCurrentList(COneRun *por)
{
    COneRun *pTail = _listCurrent._pTail;
    if (   pTail != NULL
        && CanMergeTwoRuns(pTail, por)
       )
    {
        Assert(pTail->_lscpBase + pTail->_lscch == por->_lscpBase);
        Assert(pTail->_pchBase  + pTail->_lscch == por->_pchBase);
        Assert(!pTail->_fNotProcessedYet); // Cannot merge into a run not yet processed
        
        pTail->_lscch += por->_lscch;
        pTail->_lscchOriginal += por->_lscchOriginal;
        
        //
        // Since we merged our por into the previous one, let us put the
        // present one back on the free list.
        //
        _listFree.SpliceIn(por);
        por = pTail;
    }
    else
    {
#if DBG==1
        _listCurrent.SpliceInAfterMe(this, pTail, por);
#else
        _listCurrent.SpliceInAfterMe(pTail, por);
#endif
    }
    return por;
}

//-----------------------------------------------------------------------------
//
//  Function:   SplitRun
//
//  Synopsis:   Splits a single run into 2 runs. The original run remains
//              por and the number of chars it has is cchSplitTill, while
//              the new split off run is the one which is returned and the
//              number of characters it has is cchOriginal-cchSplit.
//
//  Returns:    The 2nd run (which we got from cutting up por)
//
//-----------------------------------------------------------------------------
COneRun *
CLineServices::SplitRun(COneRun *por, LONG cchSplitTill)
{
    LONG cchDelta;
    
    //
    // Create an exact copy of the run
    //
    COneRun *porNew = _listFree.GetFreeOneRun(por);
    if (!porNew)
        goto Cleanup;
    por->_lscch = cchSplitTill;
    cchDelta = por->_lscchOriginal - por->_lscch;
    por->_lscchOriginal = por->_lscch;
    Assert(por->_lscch);
    
    //
    // Then setup the second run so that it can be spliced in properly
    //
    porNew->_pPrev = porNew->_pNext = NULL;
    porNew->_lscpBase += por->_lscch;
    porNew->_lscch = cchDelta;
    porNew->_lscchOriginal = porNew->_lscch;
    porNew->_pchBase = por->_pchBaseOriginal + cchSplitTill;
    porNew->_pchBaseOriginal = porNew->_pchBase;
    porNew->_fGlean = TRUE;
    porNew->_fNotProcessedYet = TRUE;
    porNew->_fIsBRRun = FALSE;
    Assert(porNew->_lscch);
    
#if DBG==1
    if (por->_fSelected)
    {
        Assert(!porNew->_pComplexRun);
        Assert(!porNew->_fSelected);
    }
#endif

    //
    // New run needs original CCharFormat
    //
    if (porNew->_fMustDeletePcf)
    {
        porNew->_fMustDeletePcf = FALSE;
        delete porNew->_pCF;
        porNew->_pCF = (CCharFormat *)porNew->_ptp->GetBranch()->GetCharFormat();
        Assert(porNew->_pCF == porNew->_pCFOriginal);
    }

Cleanup:
    return porNew;
}


//-----------------------------------------------------------------------------
//
//  Function:   AttachOneRunToCurrentList
//
//  Note: We always return the pointer to the run which is contains the
//  lscp for por. Consider the following cases:
//  1) No splitting:
//          If merged then return the ptr of the run we merged por into
//          If not merged then return por itself
//  2) Splitting:
//          Split into por and porNew
//          If por is merged then return ptr of the run we merged por into
//          If not morged then return por itself
//          Just attach/merge porNew
//
//  Returns:    The attached/merged-into run.
//
//-----------------------------------------------------------------------------
COneRun *
CLineServices::AttachOneRunToCurrentList(COneRun *por)
{
    COneRun *porRet;

    Assert(por);
    Assert(por->_lscchOriginal >= por->_lscch);

    if (por->_lscchOriginal > por->_lscch)
    {
        Assert(por->IsNormalRun());
        COneRun *porNew = SplitRun(por, por->_lscch);
        if (!porNew)
        {
            porRet = NULL;
            goto Cleanup;
        }

        //
        // Then splice in the current run and then the one we split out.
        //
        porRet = MergeIfPossibleIntoCurrentList(por);

        // can replace this with a SpliceInAfterMe
        MergeIfPossibleIntoCurrentList(porNew);
    }
    else
        porRet = MergeIfPossibleIntoCurrentList(por);

Cleanup:
    return porRet;
}

//-----------------------------------------------------------------------------
//
//  Function:   AppendSynth
//
//  Synopsis:   Appends a synthetic into the current one run store.
//
//  Returns:    LSERR
//
//-----------------------------------------------------------------------------
LSERR
CLineServices::AppendSynth(COneRun *por, SYNTHTYPE synthtype, COneRun **pporOut)
{
    COneRun *pTail = _listCurrent._pTail;
    LONG     lscp  = por->_lscpBase;
    LSERR    lserr = lserrNone;
    BOOL     fAdd;
    LONG     lscpLast;
    
    // Atmost one node can be un-processed
    if (pTail && pTail->_fNotProcessedYet)
    {
        pTail = pTail->_pPrev;
    }

    if (pTail)
    {
        lscpLast  = pTail->_lscpBase + (pTail->IsAntiSyntheticRun() ? 0 : pTail->_lscch);
        Assert(lscp <= lscpLast);
        if (lscp == lscpLast)
        {
            fAdd = TRUE;
        }
        else
        {
            fAdd = FALSE;
            while (pTail)
            {
                Assert(pTail->_fNotProcessedYet == FALSE);
                if (pTail->_lscpBase == lscp)
                {
                    Assert(pTail->IsSyntheticRun());
                    *pporOut = pTail;
                    break;
                }
                pTail = pTail->_pNext;
            }

            if (NULL == *pporOut)
            {
                lserr = lserrOutOfMemory;
                AssertSz(*pporOut, "Cannot find the synthetic char which should have been there!");
            }
        }
    }
    else
        fAdd = TRUE;

    if (fAdd)
    {
        COneRun *porNew;
        
        porNew = _listFree.GetFreeOneRun(por);
        if (!porNew)
        {
            lserr = lserrOutOfMemory;
            goto Cleanup;
        }

        //
        // Tell our clients which run the synthetic character was added
        //
        *pporOut = porNew;
        
        //
        // Let us change our synthetic run
        //
        porNew->MakeRunSynthetic();
        porNew->FillSynthData(synthtype);
        
#if DBG==1
        _listCurrent.SpliceInAfterMe(this, pTail, porNew);
#else
        _listCurrent.SpliceInAfterMe(pTail, porNew);
#endif
        
        //
        // Now change the original one run itself
        //
        por->_lscpBase++;       // for the synthetic character
        por->_chSynthsBefore++;
        
        //
        // Update the tree info
        //
        _treeInfo._lscpFrontier++;
        _treeInfo._chSynthsBefore++;
    }
    
Cleanup:
    WHEN_DBG(_listCurrent.VerifyStuff(this));
    return lserr;
}

//-----------------------------------------------------------------------------
//
//  Function:   FillSynthData
//
//  Synopsis:   Fills information about a synthetic into the run
//
//  Returns:    nothing
//
//-----------------------------------------------------------------------------
void
COneRun::FillSynthData(CLineServices::SYNTHTYPE synthtype)
{
    const CLineServices::SYNTHDATA & synthdata = CLineServices::s_aSynthData[synthtype];
    
    _lscch = 1;
    _lscchOriginal = 1;
    _synthType = synthtype;
    _pchBase = (TCHAR *)&synthdata.wch;
    _pchBaseOriginal = _pchBase;
    _fHidden = synthdata.fHidden;
    _lsCharProps.idObj = synthdata.fObjStart ? synthdata.idObj : CLineServices::LSOBJID_TEXT;
    _fIsStartOrEndOfObj = synthdata.fObjStart || synthdata.fObjEnd;
    _fCharsForNestedElement  = FALSE;
    _fCharsForNestedLayout   = FALSE;
    _fCharsForNestedRunOwner = FALSE;

    // We only want the run to be considered processed if it is a true synthetic.
    // For the normal runs with synthetic data, this flag will be turned off
    // later in the FetchRun code.
    _fNotProcessedYet = IsSyntheticRun() ? FALSE : TRUE;
    
    _fCannotMergeRuns = TRUE;
    _fGlean = FALSE;
}

//-----------------------------------------------------------------------------
//
//  Function:   AppendAntiSynthetic
//
//  Synopsis:   Appends a anti-synthetic run
//
//  Returns:    LSERR
//
//-----------------------------------------------------------------------------
LSERR
CLineServices::AppendAntiSynthetic(COneRun *por)
{
    LSERR lserr = lserrNone;
    LONG  cch   = por->_lscch;

    Assert(por->IsAntiSyntheticRun());
    Assert(por->_lscch == por->_lscchOriginal);
    
    //
    // If the run is not in the list yet, please go and add it to the list
    //
    if (   por->_pNext == NULL
        && por->_pPrev == NULL
       )
    {
#if DBG==1
        _listCurrent.SpliceInAfterMe(this, _listCurrent._pTail, por);
#else
        _listCurrent.SpliceInAfterMe(_listCurrent._pTail, por);
#endif
    }

    //
    // This run has now been processed
    //
    por->_fNotProcessedYet = FALSE;

    //
    // Update the tree info
    //
    _treeInfo._lscpFrontier   -= cch;
    _treeInfo._chSynthsBefore -= cch;

    //
    // Now change all the subsequent runs in the list
    //
    por = por->_pNext;
    while(por)
    {
        por->_lscpBase       -= cch;
        por->_chSynthsBefore -= cch;
        por = por->_pNext;
    }
    
    WHEN_DBG(_listCurrent.VerifyStuff(this));
    return lserr;
}

//-----------------------------------------------------------------------------
//
//  Member:     CLineServices::TerminateLine
//
//  Synopsis:   Close any open LS objects. This will add end of object
//              characters to the synthetic store for any open LS objects and
//              also optionally add a synthetic WCH_SECTIONBREAK (fAddEOS).
//              If it adds any synthetic character it will set *psynthAdded to
//              the type of the first synthetic character added. FetchRun()
//              callers should be sure to check the *psynthAdded value; if it
//              is not SYNTHTYPE_NONE then the run should be filled using
//              FillSynthRun() and returned to Line Services.
//
//-----------------------------------------------------------------------------
LSERR
CLineServices::TerminateLine(COneRun * por,
                             TL_ENDMODE tlEndMode,
                             COneRun **pporOut
                            )
{
    LSERR lserr = lserrNone;
    SYNTHTYPE synthtype;
    COneRun *porOut = NULL;
    COneRun *porRet;
    COneRun *pTail = _listCurrent._pTail;

    if (pTail)
    {
        int aObjRef[LSOBJID_COUNT];

        // Zero out the object refcount array.
        ZeroMemory( aObjRef, LSOBJID_COUNT * sizeof(int) );

        // End any open LS objects.
        for (; pTail; pTail = pTail->_pPrev)
        {
            if (!pTail->_fIsStartOrEndOfObj)
                continue;

            synthtype = pTail->_synthType;
            WORD idObj = s_aSynthData[synthtype].idObj;

            // If this synthetic character starts or stops an LS object...
            if (idObj != idObjTextChp)
            {
                // Adjust the refcount up or down depending on whether the object
                // is started or ended.
                if (s_aSynthData[synthtype].fObjEnd)
                {
                    aObjRef[idObj]--;
                }
                if (s_aSynthData[synthtype].fObjStart)
                {
                    aObjRef[idObj]++;
                }

                // If the refcount is positive we have an unclosed object (we're
                // walking backward). Close it.
                if (aObjRef[idObj] > 0)
                {
                    synthtype = s_aSynthData[synthtype].typeEndObj;
                    Assert(synthtype != SYNTHTYPE_NONE &&
                           s_aSynthData[synthtype].idObj == idObj &&
                           s_aSynthData[synthtype].fObjStart == FALSE &&
                           s_aSynthData[synthtype].fObjEnd == TRUE);

                    // If we see an open ruby object but the ruby main text
                    // has not been closed yet, then we must close it here
                    // before we can close off the ruby object by passing
                    // and ENDRUBYTEXT to LS.
                    if(idObj == LSOBJID_RUBY && _fIsRuby && !_fIsRubyText)
                    {
                        synthtype = SYNTHTYPE_ENDRUBYMAIN;
                        _fIsRubyText = TRUE;
                    }

                    lserr = AppendSynth(por, synthtype, &porRet);
                    if (lserr != lserrNone)
                    {
                        //
                        // NOTE(SujalP): The linker (even in debug build) will
                        // not link in DumpList() since it is not called anywhere.
                        // This call here forces the linker to link in the DumpList
                        // function, so that we can use it during debugging.
                        //
                        WHEN_DBG(DumpList());
                        WHEN_DBG(DumpFlags());
                        WHEN_DBG(DumpTree());
                        WHEN_DBG(_lineFlags.DumpFlags());
                        WHEN_DBG(DumpCounts());
                        WHEN_DBG(_lineCounts.DumpCounts());
                        WHEN_DBG(DumpUnicodeInfo(0));
                        WHEN_DBG(DumpSids(sidsAll));
                        WHEN_DBG(fc().DumpFontInfo());
                        goto Cleanup;
                    }

                    //
                    // Terminate line needs to return the pointer to the run
                    // belonging to the first synthetic character added.
                    //
                    if (!porOut)
                        porOut = porRet;
                    
                    aObjRef[idObj]--;
                    
                    Assert(aObjRef[idObj] == 0);
                }
            }
        }

        // All opened objects have been closed. Time to clean up any states.
        _cLayoutGridObjArtificial = 0;
    }

    if (tlEndMode != TL_ADDNONE)
    {
        // Add a synthetic section break character.  Note we add a section
        // break character as this has no width.
        synthtype = tlEndMode == TL_ADDLBREAK ? SYNTHTYPE_LINEBREAK : SYNTHTYPE_SECTIONBREAK;
        lserr = AppendSynth(por, synthtype, &porRet);
        if (lserr != lserrNone)
            goto Cleanup;

        porRet->_fNoTextMetrics = TRUE;

        if (tlEndMode == TL_ADDLBREAK)
        {
            porRet->_fMakeItASpace = TRUE;
            SetRenderingHighlights(porRet);
        }
        
        if (!porOut)
            porOut = porRet;
        
        por->_fIsBRRun = FALSE;
    }
    else
    {
        por->_fIsBRRun = TRUE;
        SetRenderingHighlights(por);
        if (por->IsSelected())
            por->_fMakeItASpace = TRUE;

    }

    // Lock up the synthetic character store. We've terminated the line, so we
    // don't want anyone adding any more synthetics.
    FreezeSynth();

Cleanup:
    *pporOut = porOut;
    return lserr;
}

//+----------------------------------------------------------------------------
//
//  Member:     CLineServices::IsSynthEOL
//
//  Synopsis:   Determines if there is some synthetic end of line mark at the
//              end of the synthetic array.
//
//  Returns:    TRUE if the synthetic array is terminated by a synthetic EOL
//              mark; otherwise FALSE.
//
//-----------------------------------------------------------------------------
BOOL
CLineServices::IsSynthEOL()
{
    COneRun *pTail = _listCurrent._pTail;
    SYNTHTYPE synthEnd = SYNTHTYPE_NONE;
    
    if (pTail != NULL)
    {
        if (pTail->_fNotProcessedYet)
            pTail = pTail->_pPrev;
        while (pTail)
        {
            if (pTail->IsSyntheticRun())
            {
                synthEnd = pTail->_synthType;
                break;
            }
            pTail = pTail->_pNext;
        }
    }

    return (   synthEnd == SYNTHTYPE_SECTIONBREAK
            || synthEnd == SYNTHTYPE_ENDPARA1
            || synthEnd == SYNTHTYPE_ALTENDPARA
           );
}

//-----------------------------------------------------------------------------
//
//  Function:   CPFromLSCPCore
//
//-----------------------------------------------------------------------------
LONG
CLineServices::CPFromLSCPCore(LONG lscp, COneRun **ppor)
{
    COneRun *por = _listCurrent._pHead;
    LONG     cp  = lscp;

    Assert(lscp >= por->_lscpBase);

    while (por)
    {
        if (por->IsAntiSyntheticRun())
            cp += por->_lscch;
        else if (   lscp >= por->_lscpBase
                 && lscp <  por->_lscpBase + por->_lscch
                )
            break;
        else if (por->IsSyntheticRun())
            cp--;
        por = por->_pNext;
    }

    if (ppor)
        *ppor = por;

    return cp;
}

//-----------------------------------------------------------------------------
//
//  Function:   LSCPFromCPCore
//
//  FUTURE(SujalP): The problem with this function is that it is computing lscp
//                  and is using it to terminate the loop. Probably the better
//                  approach would be to use Cp's to determine termination
//                  conditions. That would be a radical change and we leave
//                  that to be fixed in IE5+.
//
//                  Another change which we need to make is that we do not
//                  inc/dec the lscp (and cp in the function above) as we
//                  march along the linked list. All the loop has to do is
//                  ensure that we end up with the correct COneRun and from
//                  that it should be pretty easy for us to determine the
//                  lscp/cp to be returned.
//
//-----------------------------------------------------------------------------
LONG
CLineServices::LSCPFromCPCore(LONG cp, COneRun **ppor)
{
    COneRun *por = _listCurrent._pHead;
    LONG lscp = (cp < por->_lscpBase) ? por->_lscpBase : cp;

    while (por)
    {
        if (   lscp >= por->_lscpBase
            && lscp <  por->_lscpBase + por->_lscch
           )
            break;
        if (por->IsAntiSyntheticRun())
            lscp -= por->_lscch;
        else if (por->IsSyntheticRun())
            lscp++;
        por = por->_pNext;
    }

    // If we have stopped at an anti-synthetic it means that the cp is within this
    // run. This implies that the lscp is the same for all the cp's in this run.
    if (por && por->IsAntiSyntheticRun())
    {
        Assert(por->WantsLSCPStop());
        lscp = por->_lscpBase;
    }
    else
    {
        while(por && !por->WantsLSCPStop())
        {
            por = por->_pNext;
            lscp++;
        }
    }
    
    Assert( !por || por->WantsLSCPStop() );

    // It is possible that we can return a NULL por if there is a semi-valid
    // lscp that could be returned.
    if (ppor)
        *ppor = por;

    return lscp;
}
   
//-----------------------------------------------------------------------------
//
//  Function:   FindOneRun
//
//  Synopsis:   Given an lscp, find the one run if it exists in the current list
//
//  Returns:    The one run
//
//-----------------------------------------------------------------------------
COneRun *
CLineServices::FindOneRun(LSCP lscp)
{
    COneRun *por = _listCurrent._pTail;

    if (!por)
    {
        por = NULL;
    }
    else if (lscp >= por->_lscpBase + por->_lscch)
    {
        por = NULL;
    }
    else
    {
        while (por)
        {
            if (   lscp >= por->_lscpBase
                && lscp <  por->_lscpBase + por->_lscch
               )
                break;
            por = por->_pPrev;
        }
    }
    return por;
}

//-----------------------------------------------------------------------------
//
//  Function:   FindPrevLSCP (member)
//
//  Synopsis:   Find the LSCP of the first actual character to preceed lscp.
//              Synthetic characters are ignored.
//
//  Returns:    LSCP of the character prior to lscp, ignoring synthetics. If no
//              characters preceed lscp, or lscp is beyond the end of the line,
//              then lscp itself is returned. Also returns a flag indicating if
//              any reverse objects exist between these two LSCPs.
//
//-----------------------------------------------------------------------------

LSCP
CLineServices::FindPrevLSCP(
    LSCP lscp,
    BOOL * pfReverse)
{
    COneRun * por;
    LSCP lscpPrev = lscp;
    BOOL fReverse = FALSE;

    // Find the por matching this lscp.
    por = FindOneRun(lscp);

    // If lscp was outside the limits of the line just bail out.
    if (por == NULL)
    {
        goto cleanup;
    }

    Assert(lscp >= por->_lscpBase && lscp < por->_lscpBase + por->_lscch);

    if (por->_lscpBase < lscp)
    {
        // We're in the midst of a run. lscpPrev is just lscp - 1.
        lscpPrev--;
        goto cleanup;
    }

    // Loop over the pors
    while (por->_pPrev != NULL)
    {
        por = por->_pPrev;

        // If the por is a reverse object set fReverse.
        if (por->IsSyntheticRun() &&
            s_aSynthData[por->_synthType].idObj == LSOBJID_REVERSE)
        {
            fReverse = TRUE;
        }

        // If the por is a text run then find the last lscp in it and break.
        if (por->IsNormalRun())
        {
            lscpPrev = por->_lscpBase + por->_lscch - 1;
            break;
        }
    }

cleanup:

    Assert(lscpPrev <= lscp);

    if (pfReverse != NULL)
    {
        // If we hit a reverse object but lscpPrev == lscp, then the reverse
        // object preceeds the first character in the line. In this case there
        // isn't actually a reverse object between the two LSCPs, since the
        // LSCPs are the same.
        *pfReverse = (fReverse && lscpPrev < lscp);
    }

    return lscpPrev;
}

//-----------------------------------------------------------------------------
//
//  Function:   FetchRun (member, LS callback)
//
//  Synopsis:   This is a key callback from lineservices.  LS calls this method
//              when performing LsCreateLine.  Here it is asking for a run, or
//              an embedded object -- whatever appears next in the stream.  It
//              passes us cp, and CLineServices (which we fool C++ into getting
//              to be the object of this method).  We return a bunch of stuff
//              about the next thing to put in the stream.
//
//  Returns:    lserrNone
//              lserrOutOfMemory
//
//-----------------------------------------------------------------------------
LSERR WINAPI
CLineServices::FetchRun(
    LSCP lscp,          // IN
    LPCWSTR* ppwchRun,  // OUT
    DWORD* pcchRun,     // OUT
    BOOL* pfHidden,     // OUT
    PLSCHP plsChp,      // OUT
    PLSRUN* pplsrun )   // OUT
{
    LSTRACE(FetchRun);

    LSERR         lserr = lserrNone;
    COneRun      *por;
    COneRun      *pTail;
    LONG          cchDelta;
    COneRun      *porOut;

    AssertSz(_lockRecrsionGuardFetchRun == FALSE,
             "Cannot call FetchRun recursively!");
    WHEN_DBG(_lockRecrsionGuardFetchRun = TRUE;)
            
    ZeroMemory(plsChp, sizeof(LSCHP));  // Otherwise, we're gonna forget and leave some bits on that we shouldn't.
    *pfHidden = FALSE;
    
    if (IsAdornment())
    {
        por = GetRenderer()->FetchLIRun(lscp, ppwchRun, pcchRun);
        CHPFromCF(por, por->GetCF());
        goto Cleanup;
    }

    pTail = _listCurrent._pTail;
    //
    // If this was already cached before
    //
    if (lscp < _treeInfo._lscpFrontier)
    {
        Assert(pTail);
        Assert(_treeInfo._lscpFrontier == pTail->_lscpBase + pTail->_lscch);
        WHEN_DBG(_listCurrent.VerifyStuff(this));
        while (pTail)
        {
            if (lscp >= pTail->_lscpBase)
            {
                //
                // Should never get a AS run since the actual run will the run
                // following it and we should have found that one before since
                // we are looking from the end.
                //
                Assert(!pTail->IsAntiSyntheticRun());
                
                // We should be in this run since 1) if check above 2) walking backwards
                AssertSz(lscp <  pTail->_lscpBase + pTail->_lscch, "Inconsistent linked list");
               
                //
                // Gotcha. Got a previously cached one
                //
                por = pTail;
                Assert(por->_lscchOriginal == por->_lscch);
                cchDelta = lscp - por->_lscpBase;
                if (por->_fGlean)
                {
                    // We never have to reglean a synth or an antisynth run
                    Assert(por->IsNormalRun());

                    //
                    // NOTE(SujalP+MikeJoch):
                    // This can never happen because ls always fetches sequentially.
                    // If this happened it would mean that we were asked to fetch
                    // part of the run which was not gleaned. Hence the part before
                    // this one was not gleaned and hence not fetched. This violates
                    // the fact that LS will fetch all chars before the present one
                    // atleast once before it fetches the present one.
                    //
                    AssertSz(cchDelta == 0, "CAN NEVER HAPPEN!!!!");
#if 0
                    //
                    // If we are going to glean info from a run, then we need
                    // to split out the run if the lscp is not at the beginning
                    // of that run -- this is needed to avoid gleaning chars
                    // in por which are before lscp
                    //
                    if (cchDelta)
                    {
                        
                        // We cannot be asked to split an unprocessed run...
                        Assert(!por->_fNotProcessedYet);
                        
                        Assert(lscp > por->_lscpBase);

                        COneRun *porNew = SplitRun(por, cchDelta);
                        if (!porNew)
                        {
                            lserr = lserrOutOfMemory;
                            goto Cleanup;
                        }
#if DBG==1                        
                        _listCurrent.SpliceInAfterMe(this, por, porNew);
#else
                        _listCurrent.SpliceInAfterMe(por, porNew);
#endif
                        por = porNew;
                    }
#endif // if 0
                    
                    for(;;)
                    {
                        // We still have to be interested in gleaning
                        Assert(por->_fGlean);

                        // We will should never have a anti-synthetic run here
                        Assert(!por->IsAntiSyntheticRun());
                        
                        //
                        // Now go and glean information into the run ...
                        //
                        por->_xWidth = 0;
                        lserr = GleanInfoFromTheRun(por, &porOut);
                        if (lserr != lserrNone)
                            goto Cleanup;

                        //
                        // Did the run get marked as Antisynth. If so then
                        // we need to ignore that run and go onto the next one.
                        //
                        if (por->IsAntiSyntheticRun())
                        {
                            Assert(por == porOut);
                            
                            //
                            // The run was marked as an antisynthetic run. Be sure
                            // that no splitting was requested...
                            //
                            Assert(por->_lscch == por->_lscchOriginal);
                            Assert(por->_fNotProcessedYet);
                            AppendAntiSynthetic(por);
                            por = por->_pNext;
                        }
                        else
                            break;
                        
                        //
                        // If we ran out of already cached runs (all the cached runs
                        // turned themselves into anti-synthetics) then we need to
                        // advance the frontier and fetch new runs from the story.
                        //
                        if (por == NULL)
                            goto NormalProcessing;
                    }

                    //
                    // The only time a different run is than the one passed in is returned is
                    // when the run has not been procesed as yet, and during processing we
                    // notice that to process it we need to append a synthetic character.
                    // The case to handle here is:
                    // <table><tr><td nowrap>abcd</td></tr></table>
                    //
                    Assert(porOut == por || por->_fNotProcessedYet);

                    if (porOut != por)
                    {
                        //
                        // If we added a synthetic, then the present run should not be split!
                        //
                        Assert(por->_lscch == por->_lscchOriginal);
                        Assert(por->_fNotProcessedYet);
                        
                        //
                        // Remember we have to re-glean the information the next time we come around.
                        // However, we will not make the decision to append a synth that time since
                        // the synth has already been added this time and hence will fall into the
                        // else clause of this if and everything should be fine.
                        //
                        // DEPENDING ON WHETHER porOut WAS ADDED IN THE PRESENT GLEAN
                        // OR WAS ALREADY IN THE LIST, WE EITHER RETURN porOut OR por
                        //
                        por->_fGlean = TRUE;
                        por = porOut;
                    }
                    else
                    {
                        por->_fNotProcessedYet = FALSE;

                        //
                        // Did gleaning give us reason to further split the run?
                        //
                        if (por->_lscchOriginal > por->_lscch)
                        {
                            COneRun *porNew = SplitRun(por, por->_lscch);
                            if (!porNew)
                            {
                                lserr = lserrOutOfMemory;
                                goto Cleanup;
                            }

#if DBG==1
                            _listCurrent.SpliceInAfterMe(this, por, porNew);
#else
                            _listCurrent.SpliceInAfterMe(por, porNew);
#endif
                        }
                    }
                    por->_fGlean = FALSE;
                    cchDelta = 0;
                }

                //
                // This is our quickest way outta here! We had already done all
                // the hard work before so just reuse it here
                //
                *ppwchRun  = por->_pchBase + cchDelta;
                *pcchRun   = por->_lscch   - cchDelta;
                goto Cleanup;
            }
            pTail = pTail->_pPrev;
        } // while
        AssertSz(0, "Should never come here!");
    } // if


NormalProcessing:
    for(;;)
    {
        por = AdvanceOneRun(lscp);
        if (!por)
        {
            lserr = lserrOutOfMemory;
            goto Cleanup;
        }

        lserr = GleanInfoFromTheRun(por, &porOut);
        if (lserr != lserrNone)
            goto Cleanup;
    
        Assert(porOut);

        if (por->IsAntiSyntheticRun())
        {
            Assert(por == porOut);
            AppendAntiSynthetic(por);
        }
        else
            break;
    }
    
    if (por != porOut)
    {
        *ppwchRun = porOut->_pchBase;
        *pcchRun  = porOut->_lscch;
        por->_fGlean = TRUE;
        por->_fNotProcessedYet = TRUE;
        Assert(por->_lscch == por->_lscchOriginal); // be sure no splitting takes place
        Assert(porOut->_fCannotMergeRuns);
        Assert(porOut->IsSyntheticRun());
        
        if (por->_lscch)
        {
            COneRun *porLastSynth = porOut;
            COneRun *porTemp = porOut;

            //
            // GleanInfoFromThrRun can add multiple synthetics to the linked
            // list, in which case we will have to jump across all of them
            // before we can add por to the list. (We need to add the por
            // because the frontier has already moved past that run).
            //
            while (porTemp && porTemp->IsSyntheticRun())
            {
                porLastSynth = porTemp;
                porTemp = porTemp->_pNext;
            }

            // FUTURE: porLastSynth should equal pTail.  Add a check for this, and
            // remove above while loop.
#if DBG==1        
            _listCurrent.SpliceInAfterMe(this, porLastSynth, por);
#else
            _listCurrent.SpliceInAfterMe(porLastSynth, por);
#endif
        }
        else
        {
            // Run not needed, please do not leak memory
            _listFree.SpliceIn(por);
        }
        
        // Finally remember that por is the run which we give to LS
        por = porOut;
    }
    else
    {
        por->_fNotProcessedYet = FALSE;
        *ppwchRun  = por->_pchBase;
        *pcchRun  = por->_lscch;
        por = AttachOneRunToCurrentList(por);
        if (!por)
        {
            lserr = lserrOutOfMemory;
            goto Cleanup;
        }
    }
    
Cleanup:
    if (lserr == lserrNone)
    {
        Assert(por);
        Assert(por->_lscch);
        
        //
        // We can never return an antisynthetic run to LS!
        //
        Assert(!por->IsAntiSyntheticRun());

        if (por->_fCharsForNestedLayout && !IsAdornment())
        {
            static const TCHAR chConst = _T('A');
            
            // Give LS a junk character in this case. Fini will jump
            // accross the number of chars actually taken up by the
            // nested run owner.
            *ppwchRun = &chConst;
            *pcchRun = 1;
        }
        
        *pfHidden  = por->_fHidden;
        *plsChp    = por->_lsCharProps;
        *(PLSRUN *)pplsrun = por;
    }
    else
    {
        *(PLSRUN *)pplsrun = NULL;
    }
    
    WHEN_DBG(_lockRecrsionGuardFetchRun = FALSE;)
    return lserr;
}

//+----------------------------------------------------------------------------
//
//  Member:     CLineServices::AppendILSControlChar
//
//  Synopsis:   Appends an ILS object control character to the synthetic store.
//              This function allows us to begin and end line services objects
//              by inserting the control characters that begin and end them
//              into the text stream. It also keeps track of the state of the
//              object stack at the end of the synthetic store and returns the
//              synthetic type that matches the first added charcter.
//
//              A curiousity of Line Services dictates that ILS objects cannot
//              be overlapped; it is not legal to have:
//
//                  <startNOBR><startReverse><endNOBR><endReverse>
//
//              If this case were to arise the <endNOBR> would get ignored and
//              the NOBR object would continue until the line was terminated
//              by a TerminateLine() call. Furthermore, the behavior of ILS
//              objects is not always inherited; the reverse object inside of
//              a NOBR will still break.
//
//              To get around these problems it is necessary to keep the object
//              stack in good order. We define a hierarchy of objects and make
//              certain that whenever a new object is created any objects which
//              are lower in the heirarchy are closed and reopened after the
//              new object is opened. (Smaller number means higher positioin in
//              hierarchy). The current hierarchy is:
//
//                  Ruby objects        (1)
//                  LayoutGrid objects  (1)
//                  Reverse objects     (2)
//                  NOBR objects        (3)
//                  Embedding objects   (4)
//
//              Additional objects (FE objects) will be inserted into this
//              heirarchy.
//
//              Embedding objects require no special handling due to their
//              special handling (recursive calls to line services).
//
//              If we apply our strategy to the overlapped case above, we will
//              end up with the following:
//
//                  <startNOBR><endNOBR><startReverse><startNOBR><endNOBR><endReverse>
//
//              As can be seen the objects are well ordered and each object's
//              start character is paired with its end character.
//
//              One problem which is introduced by this solution is the fact
//              that a break opprotunity is introduced between the two NOBR
//              objects. This can be fixed in the NOBR breaking code.
//
//  Returns:    An LSERR value. The function also returns synthetic character
//              at lscp in *psynthAdded. This is the first charcter added by
//              this function, NOT necessarily the character that matches idObj
//              and fOpen. For example (again using the case above) when we
//              ask to open the LSOBJID_REVERSE inside the NOBR object we will
//              return SYNTHTYPE_ENDNOBR in *psynthAdded (though we will also
//              append the SYNTHTYPE_REVERSE and START_NOBR to the store).
//
//-----------------------------------------------------------------------------
LSERR
CLineServices::AppendILSControlChar(COneRun *por, SYNTHTYPE synthtype, COneRun **pporOut)
{
    Assert(synthtype > SYNTHTYPE_NONE && synthtype < SYNTHTYPE_COUNT);

    const SYNTHDATA & synthdata = s_aSynthData[synthtype];
    LSERR lserr = lserrNone;

    // We can only APPEND REAL OBJECTS to the store.
    Assert(   synthdata.idObj == LSOBJID_REVERSE
           || synthdata.idObj == LSOBJID_NOBR
           || synthdata.idObj == LSOBJID_RUBY
           || synthdata.idObj == LSOBJID_LAYOUTGRID);
    
    *pporOut = NULL;

    if (IsFrozen())
    {
        // We cannot add to the store if it is frozen.
        goto Cleanup;
    }

    if (synthdata.idObj != LSOBJID_NOBR)
    {
        // Open or close an object.
        lserr = AppendSynthClosingAndReopening(por, synthtype, pporOut);
        if (lserr != lserrNone)
            goto Cleanup;
    }
    else
    {
        // NOBR objects just need to be opened or closed. Note that we cannot
        // close an object unless it has been opened, nor can we open an object
        // if one is already open.
#if DBG == 1
        BOOL fOpen = synthdata.fObjStart;

        Assert(!!_fNoBreakForMeasurer != !!fOpen);

        if (!fOpen)
        {
            COneRun *porTemp = _listCurrent._pTail;
            BOOL fFoundTemp = FALSE;
            
            while (porTemp)
            {
                if (porTemp->IsSyntheticRun())
                {
                    CLineServices::SYNTHTYPE sType = porTemp->_synthType;
                
                    //it's OK to overlap with MBPOPEN/MBPCLOSE because they don't
                    //cause LS to create subline or use ILS object, they are just
                    //'special characters'
                    if (    sType != SYNTHTYPE_NOBR 
                        &&  sType != SYNTHTYPE_MBPOPEN 
                        &&  sType != SYNTHTYPE_MBPCLOSE)
                    {
                        AssertSz(0, "Should have found an STARTNOBR before any other synth");
                    }
                    fFoundTemp = TRUE;
                    break;
                }
                porTemp = porTemp->_pPrev;
            }
            AssertSz(fFoundTemp, "Did not find the STARTNOBR you are closing!");
        }
#endif
        lserr = AppendSynth(por, synthtype, pporOut);
        if (lserr != lserrNone)
            goto Cleanup;
    }

Cleanup:
    // Make sure the store is still in good shape.
    WHEN_DBG(_listCurrent.VerifyStuff(this));

    return lserr;
}

//-----------------------------------------------------------------------------
//
//  Function:   AppendSynthClosingAndReopening
//
//  Synopsis:   Appends a synthetic into the current one run store, but first
//              closes all open LS objects, which are below in object's 
//              hierarchy, and then reopens them afterwards.
//
//  Returns:    LSERR
//
//-----------------------------------------------------------------------------
LSERR
CLineServices::AppendSynthClosingAndReopening(COneRun *por, SYNTHTYPE synthtype, COneRun **pporOut)
{
    Assert(s_aSynthData[synthtype].fObjStart || s_aSynthData[synthtype].fObjEnd);

    LSERR lserr = lserrNone;
    COneRun *porOut = NULL, *porTail;
    CStackDataAry<SYNTHTYPE, 16> arySynths(0);
    int aObjRef[LSOBJID_COUNT];
    int i;

    WORD idObj = s_aSynthData[synthtype].idObj;
    WORD idLevel = s_aSynthData[synthtype].idLevel;
    Assert(idLevel > 0);
    SYNTHTYPE curSynthtype;

    // Zero out the object refcount array.
    ZeroMemory(aObjRef, LSOBJID_COUNT * sizeof(int) );

    *pporOut = NULL;

    // End any open LS objects.
    for (porTail = _listCurrent._pTail; porTail; porTail = porTail->_pPrev)
    {
        if (!porTail->_fIsStartOrEndOfObj)
            continue;

        curSynthtype = porTail->_synthType;
        WORD curIdObj = s_aSynthData[curSynthtype].idObj;

        // If this synthetic character starts or stops an LS object...
        if (curIdObj != idObj)
        {
            // Adjust the refcount up or down depending on whether the object
            // is started or ended.
            if (s_aSynthData[curSynthtype].fObjEnd)
            {
                aObjRef[curIdObj]--;
            }
            if (s_aSynthData[curSynthtype].fObjStart)
            {
                aObjRef[curIdObj]++;
            }

            // If the refcount is positive we have an unclosed object (we're
            // walking backward). Close it, if necessary.
            if (aObjRef[curIdObj] > 0)
            {
                // When closing an object, we want to close any opened objects
                // at the same level. So, bump the level down.
                if (s_aSynthData[synthtype].fObjEnd)
                {
                    --idLevel;
                }

                // If opened object is below in the object's hierarchy (larger idLevel), 
                // close it.
                if (idLevel < s_aSynthData[curSynthtype].idLevel)
                {
                    arySynths.AppendIndirect(&curSynthtype);
                    curSynthtype = s_aSynthData[curSynthtype].typeEndObj;
                    Assert(   curSynthtype != SYNTHTYPE_NONE 
                           && s_aSynthData[curSynthtype].idObj == curIdObj 
                           && s_aSynthData[curSynthtype].fObjStart == FALSE 
                           && s_aSynthData[curSynthtype].fObjEnd == TRUE);

                    lserr = AppendSynth(por, curSynthtype, &porOut);
                    if (lserr != lserrNone)
                    {
                        goto Cleanup;
                    }
                    if (_fNoBreakForMeasurer && curSynthtype == SYNTHTYPE_ENDNOBR)
                    {
                        // We need to mark the starting por that it was artificially
                        // terminated, so we can break appropriate in the ILS handlers.
                        // Can't break after this END-NOBR
                        porTail->_fIsArtificiallyTerminatedNOBR = 1;            
                    }

                    if (*pporOut == NULL) 
                    {
                        *pporOut = porOut;
                    }
                }

                aObjRef[curIdObj]--;
                Assert(aObjRef[curIdObj] == 0);
            }
        }
        else
        {
#if DBG == 1
            if (idObj != LSOBJID_REVERSE)
            {
                // We don't allow object nesting of the same type
                Assert(s_aSynthData[synthtype].fObjStart || s_aSynthData[curSynthtype].fObjStart);
                Assert(s_aSynthData[synthtype].fObjEnd   || s_aSynthData[curSynthtype].fObjEnd);
            }
#endif
            break;
        }
    }

    // Append the synth that was passed in
    lserr = AppendSynth(por, synthtype, &porOut);
    if (lserr != lserrNone)
    {
        goto Cleanup;
    }
    if (*pporOut == NULL) 
    {
        *pporOut = porOut;
    }

    // Re-open the LS objects that we closed
    for (i = arySynths.Size(); i > 0; i--)
    {
        curSynthtype = arySynths[i-1];
        Assert(   curSynthtype != SYNTHTYPE_NONE 
               && s_aSynthData[curSynthtype].fObjStart == TRUE 
               && s_aSynthData[curSynthtype].fObjEnd == FALSE);
        lserr = AppendSynth(por, curSynthtype, &porOut);
        if (lserr != lserrNone)
        {
            goto Cleanup;
        }
        if (_fNoBreakForMeasurer && curSynthtype == SYNTHTYPE_NOBR)
        {
            // Can't break before this BEGIN-NOBR
            porOut->_fIsArtificiallyStartedNOBR = 1;            
        }
    }

Cleanup:
    // Make sure the store is still in good shape.
    WHEN_DBG(_listCurrent.VerifyStuff(this));

    return lserr;
}
   
//-----------------------------------------------------------------------------
//
//  Function:   GetCharWidthClass
//
//  Synopsis:   Determines the characters width class within this run
//
//  Returns:    character width class
//
//-----------------------------------------------------------------------------
COneRun::charWidthClass
COneRun::GetCharWidthClass() const
{
    charWidthClass cwc = charWidthClassUnknown;

    if (_ptp->IsText() && IsNormalRun())
    {
        switch (_ptp->Sid())
        {
        case sidHan:
        case sidHangul:
        case sidKana:
        case sidBopomofo:
        case sidYi:
        case sidHalfWidthKana:
            cwc = charWidthClassFullWidth;
            break;

        case sidHebrew:
        case sidArabic:
            cwc = charWidthClassCursive;
            break;

        default:
            cwc = charWidthClassHalfWidth;
        }
    }
    return cwc;
}
   
//-----------------------------------------------------------------------------
//
//  Function:   GetTextDecorationColorFromAncestor
//
//  Synopsis:   Gets color of specified text decoration type from ancestor
//              of current node.
//
//  Returns:    color
//
//-----------------------------------------------------------------------------
CColorValue
COneRun::GetTextDecorationColorFromAncestor(ULONG td)
{
    CColorValue cv;
    CTreeNode * pNode = _ptp->GetBranch();
    CElement *  pElemTemp;

    do
    {
        // In case of FONT or BASEFONT tags we need to check if 'color'
        // attribute changed text color. If yes we need to use this color.
        // NOTE: CSS 'color' property has higher priority than 'color' attribute
        //       in this case we ignore 'color' attribute
        if (pNode->Tag() == ETAG_FONT || pNode->Tag() == ETAG_BASEFONT)
        {
            CAttrArray ** ppAA = pNode->Element()->GetAttrArray();
            if (*ppAA)
            {
                CAttrValue *pAVColor = (*ppAA)->Find(DISPID_A_COLOR, CAttrValue::AA_Attribute);
                if (pAVColor)
                {
                    // Following condition implies that there is no different color
                    // set through CSS 'color' property.
                    if (pNode->GetCascadedcolor().GetRawValue() == pAVColor->GetLong())
                    {
                        cv = pNode->GetCharFormat()->_ccvTextColor;
                        break;
                    }
                }
            }
        }

        // Get parent (or master, if we should inherit style from master)
        pElemTemp = pNode->Element();
        pNode = pNode->Parent();
        if (!pNode && pElemTemp->HasMasterPtr())
        {
            CElement * pElemMaster  = pElemTemp->GetMasterPtr();
            CDefaults *pDefaults    = pElemMaster->GetDefaults();                
            ELEMENT_TAG etag        = pElemMaster->TagType();

            if (    etag == ETAG_INPUT
                ||  !pDefaults && etag == ETAG_GENERIC
                ||  pDefaults && pDefaults->GetAAviewInheritStyle()
               )
            {
                pNode = pElemMaster->GetFirstBranch();
            }
        }

        // Check if parent has explicit text-decoration.
        if (pNode)
        {
            const CFancyFormat * pFF = pNode->GetFancyFormat();
            if (pFF->HasExplicitTextDecoration(td))
            {
                cv = pNode->GetCharFormat()->_ccvTextColor;
                break;
            }
        }
    } while (pNode);

    // Must find a parent with explicit text decoration or 
    // FONT/BASEFONT tag with 'color' attr
    Assert(pNode);

    return cv;
}

//+----------------------------------------------------------------------------
//
//  Function:   GetOtherCF
//
//  Synopsis:   Replace current CF by new one.
//
//  Returns:    new CF
//
//-----------------------------------------------------------------------------
CCharFormat *
COneRun::GetOtherCF()
{
    if (!_fMustDeletePcf)
    {
        _pCF = new CCharFormat();
        if( _pCF != NULL )
            _fMustDeletePcf = TRUE;
    }
    Assert(_pCF != NULL);

    return _pCF;
}

//+----------------------------------------------------------------------------
//
//  Function:   GetOtherCloneCF
//
//  Synopsis:   Replace current CF by new one with the old CF's properties.
//
//  Returns:    new CF
//
//-----------------------------------------------------------------------------
CCharFormat *
COneRun::GetOtherCloneCF()
{
    CCharFormat *pCFOld = _pCF;
    CCharFormat *pCFNew = GetOtherCF();
    if( pCFOld ) 
    {
        *pCFNew = *pCFOld;
    }
    return pCFNew;
}

//-----------------------------------------------------------------------------
//
// Member:      SetCurrentBgColor()
//
// Synopsis:    Set the current background color for the current chunk.
//
//-----------------------------------------------------------------------------
void
COneRun::SetCurrentBgColor(CFlowLayout *pFlowLayout)
{
    CTreeNode * pNode = Branch();
    CElement  * pElementFL = pFlowLayout->ElementOwner();
    const CFancyFormat * pFF;

    while(pNode)
    {
        pFF = pNode->GetFancyFormat();

        if (pFF->_ccvBackColor.IsDefined())
        {
            _ccvBackColor = pFF->_ccvBackColor;
            goto Cleanup;
        }
        else
        {
            if (DifferentScope(pNode, pElementFL))
                pNode = pNode->Parent();
            else
                pNode = NULL;
        }
    }
    
    _ccvBackColor.Undefine();

Cleanup:
    return;
}


//-----------------------------------------------------------------------------
//
//  Function:   Selected
//
//  Synopsis:   Mark the run as being selected. If selected, then also set the
//              background color.
//
//-----------------------------------------------------------------------------
void
COneRun::Selected(CLSRenderer *pRenderer, 
                  CFlowLayout *pFlowLayout, 
                  CPtrAry<CRenderStyle*> *papRenderStyle)
{
    if (!_fSelected)
    {
        _fSelected = TRUE;

        COLORREF crTextColor, crBackColor;
        CColorValue ccvNewTextColor, ccvNewBackColor, ccvDecorationColor;
        CCharFormat *pCF;
        BOOL fDef = FALSE;
        CComplexRun *pCcr = GetComplexRun();

        if( pCcr == NULL )
            pCcr = GetNewComplexRun();

        if( pCcr == NULL )
            return;

        SetCurrentBgColor(pFlowLayout);
        crTextColor = _pCF->_ccvTextColor.GetColorRef();
        crBackColor = GetCurrentBgColor().GetColorRef();
        pRenderer->AdjustColors(_pCF, crTextColor, crBackColor);
        pCF = GetOtherCloneCF();

        if( (*papRenderStyle).Size() ) 
        {
            for(int i=0; i<(*papRenderStyle).Size();i++)
            {
                if( (*papRenderStyle)[i]->GetAAdefaultTextSelection() == TRUE )
                {
                    fDef = TRUE;
                    continue;
                }
                if( ccvNewTextColor.IsNull() == TRUE )
                    ccvNewTextColor = (*papRenderStyle)[i]->GetAAtextColor();
                if( ccvNewBackColor.IsNull() == TRUE )
                    ccvNewBackColor = (*papRenderStyle)[i]->GetAAtextBackgroundColor();
                if( ccvDecorationColor.IsNull() == TRUE )
                    ccvDecorationColor = (*papRenderStyle)[i]->GetAAtextDecorationColor();
                if( pCcr->_RenderStyleProp._lineThroughStyle == styleTextLineThroughStyleUndefined )
                    pCcr->_RenderStyleProp._lineThroughStyle = (*papRenderStyle)[i]->GetAAtextLineThroughStyle();
                if( pCcr->_RenderStyleProp._underlineStyle == styleTextUnderlineStyleUndefined )
                    pCcr->_RenderStyleProp._underlineStyle = (*papRenderStyle)[i]->GetAAtextUnderlineStyle();

                switch( (*papRenderStyle)[i]->GetAAtextDecoration() )
                {
                case styleTextDecorationUnderline:
                    pCcr->_RenderStyleProp._fStyleUnderline = TRUE;
                    break;
                case styleTextDecorationOverline:
                    pCcr->_RenderStyleProp._fStyleOverline = TRUE;
                    break;
                case styleTextDecorationLineThrough:
                    pCcr->_RenderStyleProp._fStyleLineThrough = TRUE;
                    break;
                case styleTextDecorationBlink:
                    pCcr->_RenderStyleProp._fStyleBlink = TRUE;
                    break;
                }
            }

            // Check for a "default" person who wants to reverse the colors
            if( fDef == FALSE )
            {
                if( ccvNewTextColor.IsNull() == FALSE )
                {
                    // Check for transparent
                    if( ccvNewTextColor.IsDefined() == TRUE )
                        crTextColor = ccvNewTextColor.GetColorRef();
                    else
                        crTextColor = _pCF->_ccvTextColor.GetColorRef();
                }
                if( ccvNewBackColor.IsNull() == FALSE )
                {
                    // Check for transparent
                    if( ccvNewBackColor.IsDefined() == TRUE )
                        crBackColor = ccvNewBackColor.GetColorRef();
                    else
                        crBackColor = VALUE_UNDEF;
                }
            }
             
            if( ccvDecorationColor.IsNull() == FALSE )
            {
                // Check for transparent
                if( ccvDecorationColor.IsDefined() == TRUE )
                    pCcr->_RenderStyleProp._ccvDecorationColor = ccvDecorationColor;
                else
                    pCcr->_RenderStyleProp._ccvDecorationColor = GetCurrentBgColor();
            }
            else
                pCcr->_RenderStyleProp._ccvDecorationColor = crTextColor;
        }

        pCF->_ccvTextColor = crTextColor;
        _ccvBackColor = crBackColor;
        _pCF = pCF;
        CheckForUnderLine(FALSE);
    }
}

//+---------------------------------------------------------------------------
//
//  Method:     GetInlineMBP
//
//  Synopsis:   This function computes the actual M/B/P values for this run.
//
//----------------------------------------------------------------------------
BOOL
COneRun::GetInlineMBP(CCalcInfo *pci,
                      DWORD dwFlags,
                      CRect *pResults,
                      BOOL *pfHorzPercentAttr,
                      BOOL *pfVertPercentAttr)
{
    if (_fIsPseudoMBP)
        return GetInlineMBPForPseudo(pci, dwFlags, pResults, pfHorzPercentAttr, pfVertPercentAttr);

    return Branch()->GetInlineMBPContributions(pci, dwFlags, pResults, pfHorzPercentAttr, pfVertPercentAttr);
}

//+---------------------------------------------------------------------------
//
//  Method:     GetInlineMBPForPseudo
//
//  Synopsis:   This function computes the actual M/B/P values for pseudo element.
//
//----------------------------------------------------------------------------
BOOL
COneRun::GetInlineMBPForPseudo(CCalcInfo *pci,
                               DWORD dwFlags,
                               CRect *pResults,
                               BOOL *pfHorzPercentAttr,
                               BOOL *pfVertPercentAttr)
{
    CRect rcEmpty(CRect::CRECT_EMPTY);
    BOOL  fInlineBackground = FALSE;

    if (_pFF->_iPEI >= 0)
    {
        CTreeNode * pNode = Branch();
        CBorderInfo borderinfo;
        const CPseudoElementInfo *pPEI = GetPseudoElementInfoEx(_pFF->_iPEI);
        LONG lFontHeight = _pCF->GetHeightInTwips(pNode->Doc());
        BOOL fVertical = _pCF->HasVerticalLayoutFlow();
        BOOL fWM = _pCF->_fWritingModeUsed;
        Assert(fVertical == pNode->IsParentVertical());
        LONG xParentWidth;

        BOOL fMargin  = (dwFlags & GIMBPC_MARGINONLY ) ? TRUE : FALSE;
        BOOL fBorder  = (dwFlags & GIMBPC_BORDERONLY ) ? TRUE : FALSE;
        BOOL fPadding = (dwFlags & GIMBPC_PADDINGONLY) ? TRUE : FALSE;

        Assert(fMargin || fBorder || fPadding);

        //
        // Handle the borders first
        //
        if (fBorder && GetBorderInfoHelperEx(_pFF, _pCF, pci, &borderinfo, GBIH_PSEUDO))
        {
            pResults->left = borderinfo.aiWidths[SIDE_LEFT];
            pResults->right = borderinfo.aiWidths[SIDE_RIGHT];
            pResults->top = borderinfo.aiWidths[SIDE_TOP];
            pResults->bottom = borderinfo.aiWidths[SIDE_BOTTOM];
        }
        else
        {
            pResults->SetRectEmpty();
        }

        //
        // Handle the padding next (only positive padding allowed)
        //
        if (fPadding || fMargin)
        {
            const CUnitValue & cuvPaddingTop    = pPEI->GetLogicalPadding(SIDE_TOP,    fVertical, fWM, _pFF);
            const CUnitValue & cuvPaddingRight  = pPEI->GetLogicalPadding(SIDE_RIGHT,  fVertical, fWM, _pFF);
            const CUnitValue & cuvPaddingBottom = pPEI->GetLogicalPadding(SIDE_BOTTOM, fVertical, fWM, _pFF);
            const CUnitValue & cuvPaddingLeft   = pPEI->GetLogicalPadding(SIDE_LEFT,   fVertical, fWM, _pFF);

            const CUnitValue & cuvMarginLeft   = pPEI->GetLogicalMargin(SIDE_LEFT,   fVertical, fWM, _pFF);
            const CUnitValue & cuvMarginRight  = pPEI->GetLogicalMargin(SIDE_RIGHT,  fVertical, fWM, _pFF);
            const CUnitValue & cuvMarginTop    = pPEI->GetLogicalMargin(SIDE_TOP,    fVertical, fWM, _pFF);
            const CUnitValue & cuvMarginBottom = pPEI->GetLogicalMargin(SIDE_BOTTOM, fVertical, fWM, _pFF);

            // If we have horizontal padding in percentages, flag the display
            // so it can do a full recalc pass when necessary (e.g. parent width changes)
            // Also see ApplyLineIndents() where we do this for horizontal indents.
            *pfHorzPercentAttr = (   cuvPaddingLeft.IsPercent()
                                  || cuvPaddingRight.IsPercent()
                                  || cuvMarginLeft.IsPercent()
                                  || cuvMarginRight.IsPercent()
                                 );
            *pfVertPercentAttr = (   cuvPaddingTop.IsPercent()
                                  || cuvPaddingBottom.IsPercent()
                                  || cuvMarginTop.IsPercent()
                                  || cuvMarginBottom.IsPercent()
                                 );

            xParentWidth = (*pfHorzPercentAttr) ? pNode->GetParentWidth(pci, pci->_sizeParent.cx) : pci->_sizeParent.cx;

            //
            // Handle the padding next (only positive padding allowed)
            //
            if (fPadding)
            {
                pResults->left   += max(0l, cuvPaddingLeft.XGetPixelValue(pci, cuvPaddingLeft.IsPercent() ? xParentWidth : pci->_sizeParent.cx, lFontHeight));
                pResults->right  += max(0l, cuvPaddingRight.XGetPixelValue(pci, cuvPaddingRight.IsPercent() ? xParentWidth : pci->_sizeParent.cx, lFontHeight));
                pResults->top    += max(0l, cuvPaddingTop.YGetPixelValue(pci, pci->_sizeParent.cy, lFontHeight));
                pResults->bottom += max(0l, cuvPaddingBottom.YGetPixelValue(pci, pci->_sizeParent.cy, lFontHeight));
            }

            //
            // Finally, handle the margin information
            //
            if (fMargin)
            {
                pResults->left   += cuvMarginLeft.XGetPixelValue(pci, cuvMarginLeft.IsPercent() ? xParentWidth : pci->_sizeParent.cx, lFontHeight);
                pResults->right  += cuvMarginRight.XGetPixelValue(pci, cuvMarginRight.IsPercent() ? xParentWidth : pci->_sizeParent.cx, lFontHeight);
                pResults->top    += cuvMarginTop.YGetPixelValue(pci, pci->_sizeParent.cx, lFontHeight);
                pResults->bottom += cuvMarginBottom.YGetPixelValue(pci, pci->_sizeParent.cx, lFontHeight);
            }
        }

        fInlineBackground = _pFF->HasBackgrounds(TRUE);
    }
    else
    {
        *pResults = rcEmpty;
    }
    
    return (   *pResults != rcEmpty
            || fInlineBackground);
}


//+---------------------------------------------------------------------------
//
//  Method:     ConvertToSmallCaps
//
//  Synopsis:   Apply small caps transformation to the run. Will modify _lscch
//              at the first switch from uppercase to lowercase characters,
//              or vice versa.
//
//----------------------------------------------------------------------------
void 
COneRun::ConvertToSmallCaps(TCHAR chPrev)
{
    const CCharFormat* pCF = GetCF();
    long cch = _lscch;
    const TCHAR * pch = _pchBase;
    BOOL fCapitalize = (pCF->_bTextTransform == styleTextTransformCapitalize);
    BOOL fCurrentLowerCase =    !(fCapitalize && IsWordBreakBoundaryDefault(chPrev, *pch)) 
                             && IsCharLower(*pch);
    BOOL fNextLowerCase;

    Assert(pCF->_fSmallCaps);
    Assert(cch > 0);

    //
    // Find first switch point from uppercase to lowercase or vice versa.
    //
    while (--cch > 0)
    {
        chPrev = *pch;
        ++pch;
        fNextLowerCase =    !(fCapitalize && IsWordBreakBoundaryDefault(chPrev, *pch)) 
                         && IsCharLower(*pch);

        if (   (!fNextLowerCase && fCurrentLowerCase)
            || (fNextLowerCase && !fCurrentLowerCase))
        {
            break;
        }
    }

    // If text case is changing inside the run, mark this point 
    // to properly split the run later.
    if (cch)
    {
        _lscch = _lscch - cch;
    }

    //
    // Clone CCharFormat and apply appropriate attributes for small-caps.
    //
    if (GetOtherCloneCF())
    {
        _pCF->_bTextTransform = styleTextTransformUppercase;
        if (fCurrentLowerCase)
            _pCF->_fSCBumpSizeDown = TRUE;            
        _pCF->_bCrcFont = _pCF->ComputeFontCrc();
    }
}

//-----------------------------------------------------------------------------
//
//  Function:   DumpList
//
//-----------------------------------------------------------------------------
#if DBG==1

void
CLineServices::DumpList()
{
    int nCount = 0;
    COneRun *por = _listCurrent._pHead;
    
    if (!InitDumpFile())
        goto Cleanup;

    WriteString( g_f,
                 _T("\r\n------------- OneRunList Dump -------------------------------\r\n" ));
    while(por)
    {
        nCount++;
        WriteHelp(g_f, _T("\r\n[<0d>]: lscp:<1d>, lscch:<2d>, synths:<3d>, ptp:<4d>, width:<5d>, mbpTop:<6d>, mbpBot:<7d>\r\n"),
                          por->_nSerialNumber, por->_lscpBase, por->_lscch,
                          por->_chSynthsBefore, por->_ptp == NULL ? -1 : por->_ptp->_nSerialNumber,
                          por->_xWidth, por->_mbpTop, por->_mbpBottom);
        if (por->IsNormalRun())
            WriteHelp(g_f, _T("Normal, "));
        else if (por->IsSyntheticRun())
            WriteHelp(g_f, _T("Synth, "));
        else if (por->IsAntiSyntheticRun())
            WriteHelp(g_f, _T("ASynth, "));
        if (por->_fGlean)
            WriteHelp(g_f, _T("Glean, "));
        if (por->_fNotProcessedYet)
            WriteHelp(g_f, _T("!Processed, "));
        if (por->_fHidden)
            WriteHelp(g_f, _T("Hidden, "));
        if (por->_fCannotMergeRuns)
            WriteHelp(g_f, _T("NoMerge, "));
        if (por->_fCharsForNestedElement)
            WriteHelp(g_f, _T("NestedElem, "));
        if (por->_fCharsForNestedLayout)
            WriteHelp(g_f, _T("NestedLO, "));
        if (por->_fCharsForNestedRunOwner)
            WriteHelp(g_f, _T("NestedRO, "));
        if (por->_fSelected)
            WriteHelp(g_f, _T("Sel, "));
        if (por->_fNoTextMetrics)
            WriteHelp(g_f, _T("NoMetrics, "));
        if (por->_fMustDeletePcf)
            WriteHelp(g_f, _T("DelCF, "));
        if (por->_lsCharProps.fGlyphBased)
            WriteHelp(g_f, _T("Glyphed, "));
        if (por->_fIsPseudoMBP)
            WriteHelp(g_f, _T("PseudoMBP, "));
        if (   por->_synthType == SYNTHTYPE_MBPOPEN
            || por->_synthType == SYNTHTYPE_MBPCLOSE)
        {
            if (por->_fIsLTR)
                WriteHelp(g_f, _T("LTR"));
            else
                WriteHelp(g_f, _T("RTL"));
        }
        WriteHelp(g_f, _T("\r\nText:'"));
        if(por->_synthType != SYNTHTYPE_NONE)
        {        
            WriteFormattedString(g_f,  s_aSynthData[por->_synthType].pszSynthName, _tcslen(s_aSynthData[por->_synthType].pszSynthName));
        }
        else
        {
            WriteFormattedString(g_f,  (TCHAR*)por->_pchBase, por->_lscch);
        }        

        if(por->_fType == COneRun::OR_NORMAL)
        {
            CStackDataAry<LSQSUBINFO, 4> aryLsqsubinfo(Mt(CLineServicesDumpList_aryLsqsubinfo_pv));
            HRESULT hr;
            LSTEXTCELL lsTextCell;
            aryLsqsubinfo.Grow(4); // Guaranteed to succeed since we're working from the stack.

            hr = THR(QueryLineCpPpoint(por->_lscpBase, FALSE, &aryLsqsubinfo, &lsTextCell, FALSE));

            if(!hr)
            {
                long  nDepth = aryLsqsubinfo.Size() - 1;
                if (nDepth >= 0)
                {
                    const LSQSUBINFO &qsubinfo = aryLsqsubinfo[nDepth];

                    WriteHelp(g_f, _T("\r\nStart: <0d> Dup:<1d>, Flow:<2d>, Level:<3d>"),
                              lsTextCell.pointUvStartCell.u, qsubinfo.dupRun, qsubinfo.lstflowSubline, nDepth);
                }
            }
            else
            {
                WriteString( g_f,
                             _T("\r\nError in QueryLineCpPpoint()" ));
            }

        }

        WriteHelp(g_f, _T("'\r\n"));

        por = por->_pNext;
    }

    WriteHelp(g_f, _T("\r\nTotalRuns: <0d>\r\n"), (long)nCount);

Cleanup:
    CloseDumpFile();
}

void
CLineServices::DumpFlags()
{
    _lineFlags.DumpFlags();
}

void
CLineFlags::DumpFlags()
{
    TCHAR *str;
    int i;
    LONG nCount;
    
    if (!InitDumpFile())
        goto Cleanup;
    
    WriteString( g_f,
                 _T("\r\n------------- Line Flags Dump -------------------------------\r\n" ));

    nCount = _aryLineFlags.Size();
    WriteHelp(g_f, _T("Total Flags: <0d>\r\n"), (long)nCount);
    for (i = 0; i < nCount; i++)
    {
        switch(_aryLineFlags[i]._dwlf)
        {
            case FLAG_NONE              : str = _T("None"); break;
            case FLAG_HAS_INLINEDSITES  : str = _T("Inlined sites"); break;
            case FLAG_HAS_VALIGN        : str = _T("Vertical Align"); break;
            case FLAG_HAS_EMBED_OR_WBR  : str = _T("Embed/Wbr"); break;
            case FLAG_HAS_NESTED_RO     : str = _T("NestedRO"); break;
            case FLAG_HAS_RUBY          : str = _T("Ruby"); break;
            case FLAG_HAS_BACKGROUND    : str = _T("Background"); break;
            case FLAG_HAS_A_BR          : str = _T("BR"); break;
            case FLAG_HAS_RELATIVE      : str = _T("Relative"); break;
            case FLAG_HAS_NBSP          : str = _T("NBSP"); break;
            case FLAG_HAS_NOBLAST       : str = _T("NoBlast"); break;
            case FLAG_HAS_CLEARLEFT     : str = _T("ClearLeft"); break;
            case FLAG_HAS_CLEARRIGHT    : str = _T("ClearRight"); break;
            case FLAG_HAS_LINEHEIGHT    : str = _T("Lineheight"); break;
            case FLAG_HAS_MBP           : str = _T("MBP"); break;
            default                     : str = _T(""); break;
        }
        WriteHelp(g_f, _T("cp=<0d> has <1s>\r\n"), _aryLineFlags[i]._cp, str);
    }
    WriteString(g_f, _fForced ? _T("Forced") : _T("NotForced"));

Cleanup:
    CloseDumpFile();
}

void
CLineServices::DumpCounts()
{
    _lineCounts.DumpCounts();
}

void
CLineCounts::DumpCounts()
{
    LONG nCount;
    int  i;
    
    static WCHAR *g_astr[] = {_T("Undefined"), _T("LineHeight"), _T("Aligned"),
                              _T("Hidden"),    _T("Absolute")};
    
    if (!InitDumpFile())
        goto Cleanup;

    WriteString( g_f,
                 _T("\r\n------------- Line Counts Dump -------------------------------\r\n" ));

    nCount = _aryLineCounts.Size();
    WriteHelp(g_f, _T("Total Counts: <0d>\r\n"), (long)nCount);
    for (i = 0; i < nCount; i++)
    {
        WriteHelp(g_f, _T("cp=<0d> cch=<1d> for <2s>\r\n"),
                  _aryLineCounts[i]._cp,
                  _aryLineCounts[i]._count,
                  g_astr[_aryLineCounts[i]._lcType]);
    }
Cleanup:
    CloseDumpFile();
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\text\seglist.cxx ===
#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)


#ifndef X_CDUTIL_HXX_
#define X_CDUTIL_HXX_
#include "cdutil.hxx"
#endif

#ifndef X_QI_IMPL_H_
#define X_QI_IMPL_H_
#include "qi_impl.h"
#endif

#ifndef _X_SEGLIST_HXX_
#define _X_SEGLIST_HXX_
#include "seglist.hxx"
#endif

#ifndef _X_SLIST_HXX_
#define _X_SLIST_HXX_
#include "slist.hxx"
#endif

#ifndef X_TPOINTER_HXX_
#define X_TPOINTER_HXX_
#include "tpointer.hxx"
#endif

MtDefine(CSelectionSaver, Utilities, "CSelectionSaver")


#define IFC(expr) {hr = THR(expr); if (FAILED(hr)) goto Cleanup;}


//+---------------------------------------------------------------------------
//
//  Member:    SaveSelection
//
//  Synopsis:  Store what the current selection is.
//
//----------------------------------------------------------------------------

HRESULT
CSelectionSaver::SaveSelection()
{
    HRESULT                 hr;
    ISegmentList            *pSegmentList = NULL;
    ISegmentListIterator    *pIter = NULL;
    ISegment                *pISegment = NULL;
    ISegment                *pISegmentAdded = NULL;
    IMarkupPointer          *pILeft = NULL;
    IMarkupPointer          *pIRight = NULL;
    SELECTION_TYPE          eType;
    IHTMLElement            *pIElement = NULL;
    IElementSegment         *pIElemSegmentAdded = NULL ;
    IElementSegment         *pIElementSegment = NULL ;


    // Get the current segment list, and create an iterator
    IFC( _pDoc->GetCurrentSelectionSegmentList( & pSegmentList ));

    IFC( pSegmentList->GetType(&eType) );
    IFC( pSegmentList->CreateIterator( &pIter ) );

    IFC( SetSelectionType(eType) );
    
    while( pIter->IsDone() == S_FALSE )
    {
        IFC( GetDoc()->CreateMarkupPointer( &pILeft ) );
        IFC( GetDoc()->CreateMarkupPointer( &pIRight ) );

        // Retrieve the position of the current segment
        IFC( pIter->Current( &pISegment ) );

        // Add to our linked list
        if (eType == SELECTION_TYPE_Control)
        {
            IFC( pISegment->QueryInterface(IID_IElementSegment, (void**)&pIElementSegment));
            IFC( pIElementSegment->GetElement(&pIElement));
            IFC( AddElementSegment( pIElement, &pIElemSegmentAdded ));
            Assert( pIElementSegment );
        }
        else
        {
            IFC( pISegment->GetPointers( pILeft, pIRight ) );
            IFC( AddSegment( pILeft, pIRight, &pISegmentAdded ) );
            Assert( pISegmentAdded );
        }
        
        ClearInterface(&pIElement);
        ClearInterface(&pIElementSegment);
        ClearInterface(&pIElemSegmentAdded);
        ClearInterface(&pISegmentAdded);
        ClearInterface(&pILeft);
        ClearInterface(&pIRight);
        ClearInterface(&pISegment);
        
        IFC( pIter->Advance() );
    }

Cleanup:
    ReleaseInterface( pIElement);
    ReleaseInterface( pIElementSegment);
    ReleaseInterface( pIElemSegmentAdded);
    ReleaseInterface( pSegmentList );
    ReleaseInterface( pIter );
    ReleaseInterface( pISegmentAdded );
    ReleaseInterface( pISegment );
    ReleaseInterface( pILeft );
    ReleaseInterface( pIRight );
    RRETURN( hr );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\text\rclclptr.cxx ===
//+------------------------------------------------------------------------
//
//  Class:      CRecalcLinePtr implementation
//
//  Synopsis:   Special line pointer. Encapsulate the use of a temporary
//              line array when building lines. This pointer automatically
//              switches between the main and the temporary new line array
//              depending on the line index.
//
//-------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X__DISP_H_
#define X__DISP_H_
#include "_disp.h"
#endif

#ifndef X_LSM_HXX_
#define X_LSM_HXX_
#include "lsm.hxx"
#endif

#ifndef X_TREEPOS_HXX_
#define X_TREEPOS_HXX_
#include "treepos.hxx"
#endif

#ifndef X_TASKMAN_HXX_
#define X_TASKMAN_HXX_
#include "taskman.hxx"
#endif

#ifndef X_MARQUEE_HXX_
#define X_MARQUEE_HXX_
#include "marquee.hxx"
#endif

#ifndef X_RCLCLPTR_HXX_
#define X_RCLCLPTR_HXX_
#include "rclclptr.hxx"
#endif

MtDefine(CRecalcLinePtr, Layout, "CRecalcLinePtr")
MtDefine(CRecalcLinePtr_aryLeftAlignedImgs_pv, CRecalcLinePtr, "CRecalcLinePtr::_aryLeftAlignedImgs::_pv")
MtDefine(CRecalcLinePtr_aryRightAlignedImgs_pv, CRecalcLinePtr, "CRecalcLinePtr::_arRightAlignedImgs::_pv")

#pragma warning(disable:4706) /* assignment within conditional expression */

//+------------------------------------------------------------------------
//
//  Member:     CRecalcLinePtr::CRecalcLinePtr
//
//  Synopsis:   constructor, initializes (caches) margins for the current
//              display
//
//-------------------------------------------------------------------------

CRecalcLinePtr::CRecalcLinePtr(CDisplay *pdp, CCalcInfo *pci)
    : _aryLeftAlignedImgs(Mt(CRecalcLinePtr_aryLeftAlignedImgs_pv)),
      _aryRightAlignedImgs(Mt(CRecalcLinePtr_aryRightAlignedImgs_pv))
{
    CFlowLayout *   pFlowLayout = pdp->GetFlowLayout();
    CElement *      pElementFL  = pFlowLayout->ElementContent();
    long            lPadding[SIDE_MAX];

    WHEN_DBG( _cAll = -1; )

    _pdp = pdp;
    _pci = pci;
    _iPF = -1;
    _fInnerPF = FALSE;
    _xLeft       =
    _xRight      =
    _yBordTop    =
    _xBordLeft   =
    _xBordRight  =
    _yBordBottom = 0;
    _xPadLeft    =
    _yPadTop     =
    _xPadRight   =
    _yPadBottom  = 0;

    // I am not zeroing out the following because it is not necessary. We zero it out
    // everytime we call CalcBeforeSpace
    // _yBordLeftPerLine = _xBordRightPerLine = _xPadLeftPerLine = _xPadRightPerLine = 0;
    
    ResetPosAndNegSpace();

    _cLeftAlignedLayouts =
    _cRightAlignedLayouts = 0;
    _fIsEditable = pFlowLayout->IsEditable();

    if (    pElementFL->Tag() == ETAG_MARQUEE
        &&  !_fIsEditable
        &&  !pElementFL->IsPrintMedia())
    {
        _xMarqueeWidth = DYNCAST(CMarquee, pElementFL)->_lXMargin;
    }
    else
    {
        _xMarqueeWidth  = 0;
    }

    _pdp->GetPadding(pci, lPadding, pci->_smMode == SIZEMODE_MMWIDTH);
    _xLayoutLeftIndent  = lPadding[SIDE_LEFT];
    _xLayoutRightIndent = lPadding[SIDE_RIGHT];
    _fNoMarginAtBottom = FALSE;
    _ptpStartForListItem = NULL;
    _fMoveBulletToNextLine = FALSE;
}


//+------------------------------------------------------------------------
//
//  Member:     CRecalcLinePtr::Init
//
//  Synopsis:   Initialize the old and new line array and reset the
//              RecalcLineptr.
//
//-------------------------------------------------------------------------

void CRecalcLinePtr::Init(CLineArray * prgliOld, int iNewFirst, CLineArray * prgliNew)
{
    _prgliOld = prgliOld;
    _prgliNew = prgliNew;
    _xMaxRightAlign = 0;
    Reset(iNewFirst);
}

//+------------------------------------------------------------------------
//
//  Member:     CRecalcLinePtr::Reset
//
//  Synopsis:   Resets the RecalcLinePtr to use the given offset. Look
//              for all references to line >= iNewFirst to be looked up in the
//              new line array else in the old line array.
//
//-------------------------------------------------------------------------

void CRecalcLinePtr::Reset(int iNewFirst)
{
    _iNewFirst = iNewFirst;
    _iLine = 0;
    _iNewPast = _prgliNew ? _iNewFirst + _prgliNew->Count() : 0;
    _cAll = _prgliNew ? _iNewPast : _prgliOld->Count();
    Assert(_iNewPast <= _cAll);
}


//+------------------------------------------------------------------------
//
//  Member:     CRecalcLinePtr::operator
//
//  Synopsis:   returns the line from the old or the new line array based
//              on _iNewFirst.
//
//-------------------------------------------------------------------------

CLineCore * CRecalcLinePtr::operator [] (int iLine)
{
    Assert(iLine < _cAll);
    if (iLine >= _iNewFirst && iLine < _iNewPast)
    {
        return _prgliNew->Elem(iLine - _iNewFirst);
    }
    else
    {
        return _prgliOld->Elem(iLine);
    }
}


//+------------------------------------------------------------------------
//
//  Member:     CRecalcLinePtr::AddLine
//
//  Synopsis:   Add's a new line at the end of the new line array.
//
//-------------------------------------------------------------------------

CLineCore * CRecalcLinePtr::AddLine()
{
    CLineCore * pLine = _prgliNew ? _prgliNew->Add(1, NULL): _prgliOld->Add(1, NULL);
    if(pLine)
    {
        Reset(_iNewFirst);  // Update _cAll, _iNewPast, etc. to reflect
                            // the correct state after adding line
        pLine->_iLOI = -1;  // to prevent this index to have value 0 (valid cache index)
    }
    
    return pLine;
}


//+------------------------------------------------------------------------
//
//  Member:     CRecalcLinePtr::InsertLine
//
//  Synopsis:   Inserts a line to the old or new line array before the given
//              line.
//
//-------------------------------------------------------------------------

CLineCore * CRecalcLinePtr::InsertLine(int iLine)
{
    CLineCore * pLine = _prgliNew ? _prgliNew->Insert(iLine - _iNewFirst, 1):
                                _prgliOld->Insert(iLine, 1);
    if(pLine)
    {
        Reset(_iNewFirst);  // Update _cAll, _iNewPast, etc. to reflect
                            // the correct state after the newly inserted line
        pLine->_iLOI = -1;  // to prevent this index to have value 0 (valid cache index)
    }
    return pLine;
}


//+------------------------------------------------------------------------
//
//  Member:     CRecalcLinePtr::First
//
//  Synopsis:   Sets the iLine to be the current line and returns it
//
//  Returns:    returns iLine'th line if there is one.
//
//-------------------------------------------------------------------------

CLineCore * CRecalcLinePtr::First(int iLine)
{
    _iLine = iLine;
    if (_iLine < _cAll)
        return (*this)[_iLine];
    else
        return NULL;
}

//+------------------------------------------------------------------------
//
//  Member:     CRecalcLinePtr::Next
//
//  Synopsis:   Moves the current line to the next line, if there is one
//
//  Returns:    returns the next line if there is one.
//
//-------------------------------------------------------------------------

CLineCore * CRecalcLinePtr::Next()
{
    if (_iLine + 1 < _cAll)
        return (*this)[++_iLine];
    else
        return NULL;
}

//+------------------------------------------------------------------------
//
//  Member:     CRecalcLinePtr::Prev
//
//  Synopsis:   Moves the current line to the previous line, if there is one
//
//  Returns:    returns the previous line if there is one.
//
//-------------------------------------------------------------------------

CLineCore * CRecalcLinePtr::Prev()
{
    if (_iLine > 0)
        return (*this)[--_iLine];
    else
        return NULL;
}


//+----------------------------------------------------------------------------
//
// Member:      CRecalcLinePtr::InitPrevAfter ()
//
// Synopsis:    Initializes the after spacing of the previous line's paragraph
//
//-----------------------------------------------------------------------------
void CRecalcLinePtr::InitPrevAfter(BOOL *pfLastWasBreak, CLinePtr& rpOld)
{
    int oldLine;

    *pfLastWasBreak = FALSE;

    // Now initialize the linebreak stuff.
    oldLine = rpOld;
    if (rpOld.PrevLine(TRUE, FALSE))
    {
        // If we encounter a break in the previous line, then we
        // need to remember that for the accumulation to work.
        if (rpOld->_fHasBreak)
        {
            *pfLastWasBreak = TRUE;
        }
    }

    rpOld = oldLine;
}


//+------------------------------------------------------------------------
//
//  Member:     ApplyLineIndents
//
//  Synopsis:   Apply left and right indents for the current line.
//
//-------------------------------------------------------------------------
void
CRecalcLinePtr::ApplyLineIndents(
    CTreeNode * pNode,     
    CLineFull * pLineMeasured,
    UINT uiFlags,
    BOOL fPseudoElementEnabled)
{
    LONG        xLeft;      // Use logical units
    LONG        xRight;     // Use logical units
    long        iPF;
    const CParaFormat * pPF;
    CFlowLayout   * pFlowLayout = _pdp->GetFlowLayout();
    CElement      * pElementFL  = pFlowLayout->ElementContent();
    BOOL            fInner      = SameScope(pNode, pElementFL);

    if(!pNode)
	    return;
    pPF = pNode->GetParaFormat();
    iPF = pNode->GetParaFormatIndex(LC_TO_FC(_pci->GetLayoutContext()));
    BOOL fRTLLine = pPF->HasRTL(TRUE);

    if (   _iPF != iPF
        || _fInnerPF != fInner
        || fPseudoElementEnabled
       )
    {
        if (!fPseudoElementEnabled)
        {
            _iPF    = iPF;
            _fInnerPF = fInner;
        }
        LONG xParentWidth = _pci->_sizeParent.cx;
        if (   pPF->_cuvLeftIndentPercent.GetUnitValue()
            || pPF->_cuvRightIndentPercent.GetUnitValue()
           )
        {
            // 
            // (olego, IEv60 31646) CSS1 Strict Mode specific. In this mode _pci->_sizeParent.cx 
            // contains the width of pFlowLayout's parent (in compat mode it is overwritten in 
            // CFlowLayout::CalcTextSize), but pFlowLayout->_sizeProposed is what is expected here. 
            // Since xParentWidth is used only when indent is a percent value, and to minimize 
            // perf impact this code is placed under the if statement, instead of xParentWidth's 
            //  initialization.
            // 
            if (    pElementFL->HasMarkupPtr() 
                &&  pElementFL->GetMarkupPtr()->IsStrictCSS1Document()  )
            {
                xParentWidth = pFlowLayout->_sizeProposed.cx;
            }
            xParentWidth = pNode->GetParentWidth(_pci, xParentWidth);
        }
        _xLeft  = pPF->GetLeftIndent(_pci, fInner, xParentWidth);
        _xRight = pPF->GetRightIndent(_pci, fInner, xParentWidth);

        if (_xLeft < 0 || _xRight < 0)
            _pdp->_fHasNegBlockMargins = TRUE;

        // If we have horizontal indents in percentages, flag the display
        // so it can do a full recalc pass when necessary (e.g. parent width changes)
        // Also see CalcBeforeSpace() where we do this for horizontal padding.
        if ( (pPF->_cuvLeftIndentPercent.IsNull() ? FALSE :
              pPF->_cuvLeftIndentPercent.GetUnitValue() )   ||
             (pPF->_cuvRightIndentPercent.IsNull() ? FALSE :
              pPF->_cuvRightIndentPercent.GetUnitValue() ) )
        {
            _pdp->_fContainsHorzPercentAttr = TRUE;
        }
    }

    xLeft = _xLeft;
    xRight = _xRight;

    // (changes in the next section should be reflected in AlignObjects() too)
    
    // Adjust xLeft to account for marquees, padding and borders.
    xLeft += _xMarqueeWidth + _xLayoutLeftIndent;
    xRight += _xMarqueeWidth + _xLayoutRightIndent;
    
    xLeft  += _xPadLeft + _xBordLeft;
    xRight += _xPadRight + _xBordRight;

    if(!fRTLLine)
        xLeft += _xLeadAdjust;
    else
        xRight += _xLeadAdjust;

    // xLeft is now the sum of indents, border, padding.  CSS requires that when
    // possible, this indent is shared with the space occupied by floated/ALIGN'ed
    // elements (our code calls that space "margin").  Thus we want to apply a +ve
    // xLeft only when it's greater than the margin, and the amount applied excludes
    // what's occupied by the margin already.  (We never want to apply a -ve xLeft)
    // Same reasoning applies to xRight.
    // Note that xLeft/xRight has NOT accumulated CSS text-indent values yet;
    // this is because we _don't_ want that value to be shared the way the above
    // values have been shared.  We'll factor in text-indent after this.
    if (_marginInfo._xLeftMargin)
        pLineMeasured->_xLeft = max( 0L, xLeft - _marginInfo._xLeftMargin );
    else
        pLineMeasured->_xLeft = xLeft;

    if (_marginInfo._xRightMargin)
        pLineMeasured->_xRight = max( 0L, xRight - _marginInfo._xRightMargin );
    else
        pLineMeasured->_xRight = xRight;

    // text indent is inherited, so if the formatting node correspond's to a layout,
    // indent the line only if the layout is not a block element. For layout element's
    // the have blockness, text inherited and first line of paragraph's inside are
    // indented.
    if (    uiFlags & MEASURE_FIRSTINPARA
        && (   pNode->Element() == pElementFL
            || !pNode->ShouldHaveLayout(LC_TO_FC(_pci->GetLayoutContext()))
            || !pNode->Element()->IsBlockElement(LC_TO_FC(_pci->GetLayoutContext())))
       )
    {
        if(!fRTLLine)
            pLineMeasured->_xLeft += pPF->GetTextIndent(_pci);
        else
            pLineMeasured->_xRight += pPF->GetTextIndent(_pci);
    }
}

//+------------------------------------------------------------------------
//
//  Member:     CalcInterParaSpace
//
//  Synopsis:   Calculate space before the current line.
//
//  Arguments:  [pMe]              --
//              [iLineFirst]       --  line to start calculating from
//              [yHeight]          --  y coordinate of the top of line
//
//
//-------------------------------------------------------------------------
CTreeNode *
CRecalcLinePtr::CalcInterParaSpace(CLSMeasurer * pMe, LONG iPrevLine, UINT *puiFlags)
{
    LONG iLine;
    CLineCore *pPrevLine = NULL;
    CTreeNode *pNodeFormatting;
    BOOL fFirstLineInLayout = *puiFlags & MEASURE_FIRSTLINE ? TRUE : FALSE;

    INSYNC(pMe);
    
    // Get the previous line that's on a different physical line
    // and is not a frame line. Note that the initial value of
    // iPrevLine IS the line before the one we're about to measure.
    for (iLine = iPrevLine; iLine >= 0; --iLine)
    {
        pPrevLine = (*this)[iLine];

        if (pPrevLine->_fForceNewLine && pPrevLine->_cch > 0)
            break;
    }
    
    //pMe->MeasureSetPF(pPF);
    //pMe->_pLS->_fInnerPFFirst = SameScope(pMe->CurrBranch(), _pdp->GetFlowLayoutElement());

    pNodeFormatting = CalcParagraphSpacing(pMe, fFirstLineInLayout);

    // If a line consists of only a BR character and a block tag,
    // fold the previous line height into the before space, too.
    if (pPrevLine && pPrevLine->_fEatMargin)
    {
        //
        // NOTE(SujalP): When we are eating margin we have to be careful to
        // take into account both +ve and -ve values for both LineHeight
        // yBS. The easiest way to envision this is to think both of them
        // as margins which need to be merged -- which is similar to the
        // case where we are computing before and after space. Hence the
        // code here is similar to the code one would seen in CalcBeforeSpace
        // where we set up up _yPosSpace and _yNegSpace.
        //
        // If you have the urge to change this code please make sure you
        // do not change the behaviour of 38561 and 61132.
        //
        LONG yPosSpace;
        LONG yNegSpace;
        LONG yBeforeSpace = pMe->_li._yBeforeSpace;
        
        yPosSpace = max(0L, pPrevLine->_yHeight);
        yPosSpace = max(yPosSpace, yBeforeSpace);

        yNegSpace = min(0L, pPrevLine->_yHeight);
        yNegSpace = min(yNegSpace, yBeforeSpace);

        pMe->_li._yBeforeSpace = (yPosSpace + yNegSpace) - pPrevLine->_yHeight;
    }

    //
    //  Support for WORD-WRAP attribute
    //
    // word wrap should not affect minwidth mode
    if (pNodeFormatting)
    {
        pMe->SetBreakLongLines(pNodeFormatting, puiFlags);
    }
    
    if (pMe->_li._fFirstInPara)
    {
        *puiFlags |= MEASURE_FIRSTINPARA;
        CTreeNode *pNode = pNodeFormatting;
	if(!pNode)
		return NULL;
        if (pNode->GetParaFormat(LC_TO_FC(_pci->GetLayoutContext()))->_fHasPseudoElement)
        {
            const CFancyFormat *pFF;
            pNode = _pdp->GetMarkup()->SearchBranchForBlockElement(pNode, pMe->_pFlowLayout);
            Assert(pMe->_pFlowLayout->IsElementBlockInContext(pNode->Element()));
            pFF = pNode->GetFancyFormat(LC_TO_FC(_pci->GetLayoutContext()));
            BOOL fHasFirstLine = pFF->_fHasFirstLine;
            BOOL fHasFirstLetter = pFF->_fHasFirstLetter;

            if (   fHasFirstLetter
                && pNode->ShouldHaveLayout()
                && !SameScope(pNode, pMe->_pFlowLayout->ElementOwner())
               )
            {
                fHasFirstLetter = FALSE;
            }
            
            if (fHasFirstLine || fHasFirstLetter)
            {
                BOOL fFirstLetterFound = FALSE;
                pMe->_cpStopFirstLetter = fHasFirstLetter ? pMe->GetCpOfLastLetter(pNode) : -1;

                if (pMe->_cpStopFirstLetter < pMe->GetCp())
                {
                    fHasFirstLetter = FALSE;
                    pMe->_cpStopFirstLetter = -1;
                }
                
                if (fHasFirstLine)
                {
                    LONG cchFirstLetter = 0;

                    if (iPrevLine >= 0)
                    {
                        CLineCore *pPrevLine = (*this)[iPrevLine];
                        CLineOtherInfo *ploi = pPrevLine ? pPrevLine->oi() : NULL;
                        
                        if (   ploi
                            && ploi->_fHasFirstLine
                            && ploi->_fHasFirstLetter
                            && pPrevLine->IsFrame()
                            && !pPrevLine->_fFrameBeforeText
                            && SameScope(ploi->_pNodeForFirstLetter, pNode)
                           )
                        {
                            cchFirstLetter = ploi->_cchFirstLetter;
                        }
                    }

                    // If this block element (ElemA) begins _BEFORE_ this line, it means
                    // that we have a nested block element (ElemB) inside ElemA and
                    // hence this line is not really the first line in ElemA.
                    // Note: the pMe->_li._cch stores the count of the prechars -- it has
                    // yet to be transferred over to _cchPreChars, which unfortunately
                    // happens after this function.
                    if (pNode->Element()->GetFirstCp() + cchFirstLetter >= (pMe->GetCp() - pMe->_li._cch))
                    {
                        pMe->_li._fHasFirstLine = TRUE;
                        pMe->PseudoLineEnable(pNode);
                    }
                }

                if (fHasFirstLetter)
                {
                    // Walk back over here to pay attention to the "float" line
                    // which contains the first letter. If you find it, then do
                    // no turn on this bit, else do so.
                    iLine = iPrevLine;
                    while (iLine >= 0)
                    {
                        pPrevLine = (*this)[iLine];
                        if (pPrevLine->_fForceNewLine && !pPrevLine->IsClear())
                            break;
                        if (   pPrevLine->IsFrame()
                            && pPrevLine->oi()->_fHasFloatedFL
                            && SameScope(pPrevLine->oi()->_pNodeForFirstLetter, pNode)
                           )
                        {
                            fFirstLetterFound = TRUE;
                            break;
                        }
                        iLine--;
                    }
                    if (   !fFirstLetterFound
                        && pMe->_cpStopFirstLetter >= 0
                        )
                    {

                        pMe->PseudoLetterEnable(pNode);
                        Assert(pMe->_fPseudoLetterEnabled);
                        pMe->_li._fHasFirstLetter = TRUE;
                    }
                }

                if (   pMe->_li._fHasFirstLine
                    || pMe->_li._fHasFirstLetter 
                   )
                {
                    pFF = pNode->GetFancyFormat(LC_TO_FC(_pci->GetLayoutContext()));

                    // If we did not get the clear attribute from the pseudo element
                    // then there is no point in clearing here since it would already
                    // have been cleared.
                    // If we have found the first letter, it means that clearing has
                    // already happened. We do not want to clear the aligned line for
                    // the first letter, now do we?
                    if (   pFF->_fClearFromPseudo
                        && !fFirstLetterFound
                       )
                    {
                        _marginInfo._fClearLeft  |= pFF->_fClearLeft;
                        _marginInfo._fClearRight |= pFF->_fClearRight;
                    }
                    if (fFirstLetterFound)
                    {
                        _marginInfo._fClearLeft = FALSE;
                        _marginInfo._fClearRight = FALSE;
                    }
                }
            }
        }
    }    
    INSYNC(pMe);
    
    return pNodeFormatting;
}

/*
 *  CRecalcLinePtr::NetscapeBottomMargin(pMe, pDI)
 *
 *  This function is called for the last line in the display.
 *  It exists because Netscape displays by streaming tags and it
 *  increases the height of a table cell when an end tag passes
 *  by without determining if there is any more text. This makes
 *  it impossible to have a bunch of cells with headers in them
 *  where the cells are tight around the text, but c'est la vie.
 *
 *  We store the extra space in an intermediary and then add it
 *  into the bottom margin later.
 *
 */
LONG
CRecalcLinePtr::NetscapeBottomMargin(CLSMeasurer * pMe)
{
    if (   _fNoMarginAtBottom
        || _pdp->GetFlowLayout()->ElementContent()->Tag() == ETAG_BODY
       )
    {
        ResetPosAndNegSpace();
        _fNoMarginAtBottom = FALSE;
    }
    
    // For empty paragraphs at the end of a layout, we create a dummy line
    // so we can just use the before space of that dummy line. If there is 
    // no dummy line, then we need to use the after space of the previous 
    // line.
    return pMe->_li._fDummyLine
            ? pMe->_li._yBeforeSpace
            : _lTopPadding + _lNegSpaceNoP + _lPosSpaceNoP;
}


//+------------------------------------------------------------------------
//
//  Member:     RecalcMargins
//
//  Synopsis:   Calculate new margins for the current line.
//
//  Arguments:  [iLineStart]       --  new lines start at
//              [iLineFirst]       --  line to start calculating from
//              [yHeight]          --  y coordinate of the top of line
//              [yBeforeSpace]     --  before space of the current line
//
//-------------------------------------------------------------------------
void CRecalcLinePtr::RecalcMargins(
    int iLineStart,
    int iLineFirst,
    LONG yHeight,
    LONG yBeforeSpace)
{
    LONG            y;
    CLineCore     * pLine;
    int             iAt;
    CFlowLayout   * pFlowLayout = _pdp->GetFlowLayout();
    LONG            xWidth      = pFlowLayout->GetMaxLineWidth();

    // Initialize margins to defaults.
    _marginInfo.Init();
    _fMarginFromStyle = FALSE;

    // Update the state of the line array.
    Reset(iLineStart);

    // go back to find the first line which is clear (i.e., a line
    // with default margins)
    y = yHeight;
    iAt = -1;

    First(iLineFirst);

    for (pLine = Prev(); pLine; pLine = Prev())
    {
        if (pLine->IsFrame())
        {
            // Cache the line which is aligned
            iAt = At();
        }
        else
        {
            if (pLine->HasMargins(pLine->oi()))
            {
                // current line has margins
                if(pLine->_fForceNewLine)
                    y -= pLine->_yHeight;
            }
            else
                break;
        }
    }

    // iAt now holds the last aligned frame line we saw while walking back,
    // and pLine is either NULL or points to the first clear line (i.e.,
    // no margins were specified).  The Rclclptr state (_iLine) also indexes
    // that clear line.

    // y is the y coordinate of first clear line.

    // if there were no frames there is nothing to do...
    if (iAt == -1)
        return;

    // There are aligned sites, so calculate margins.
    int             iLeftAlignedImages = 0;
    int             iRightAlignedImages = 0;
    CAlignedLine *  pALine;
    CLineCore *     pLineLeftTop = NULL;
    CLineCore *     pLineRightTop = NULL;
    
    // stacks to keep track of the number of left & right aligned sites
    // adding margins to the current line.
    _aryLeftAlignedImgs.SetSize(0);
    _aryRightAlignedImgs.SetSize(0);

    // have to adjust the height of the aligned frames.
    // iAt is the last frame line we saw, so start there and
    // walk forward until we get to iLineFirst.

    // _yBottomLeftMargin and _yBottomRightMargin are the max y values
    // for which the current left/right margin values are valid; i.e.,
    // once y increases past _yBottomLeftMargin, there's a new left margin
    // that must be used.
    
    for (pLine = First(iAt);
        pLine && At() <= iLineFirst;
        pLine = Next())
    {

        // update y to skip by 
        if(At() == iLineFirst)
            y += yBeforeSpace;
        else
        {
            // Include the text or center aligned height
            if (pLine->_fForceNewLine)
            {
                y += pLine->_yHeight;
            }
        }

        // If there are any left aligned images
        while(iLeftAlignedImages)
        {
            // check to see if we passed the left aligned image, if so pop it of the
            // stack and set its height
            pALine = & _aryLeftAlignedImgs [ iLeftAlignedImages - 1 ];

            if(y >= pALine->_pLine->_yHeight + pALine->_yLine)
            {
                _aryLeftAlignedImgs.Delete( -- iLeftAlignedImages );
            }
            else
                break;
        }
        // If there are any right aligned images
        while(iRightAlignedImages)
        {
            pALine = & _aryRightAlignedImgs [ iRightAlignedImages - 1 ];

            // check to see if we passed the right aligned image, if so pop it of the
            // stack and set its height
            if(y >= pALine->_pLine->_yHeight + pALine->_yLine)
            {
                _aryRightAlignedImgs.Delete( -- iRightAlignedImages );
            }
            else
                break;
        }

        if (pLine->IsFrame() && At() != iLineFirst)
        {
            HRESULT hr = S_OK;
            const CFancyFormat * pFF = pLine->AO_GetFancyFormat(NULL);
            CAlignedLine al;

            al._pLine = pLine;
            al._yLine = y;

            // If the current line is left aligned push it on to the left aligned images
            // stack and adjust the _yBottomLeftMargin.
            if (pLine->IsLeftAligned())
            {
                //
                // If the current aligned element needs to clear left, insert
                // the current aligned layout below all other left aligned
                // layout's since it is the last element that establishes
                // the margin.
                //
                if ((pFF && pFF->_fClearLeft)
                    || (pLine->oi()->_fHasFloatedFL && pLine->_fClearBefore))
                {
                    hr = _aryLeftAlignedImgs.InsertIndirect(0, &al);

                    if (hr)
                        return;
                }
                else
                {
                    CAlignedLine *  pAlignedLine;

                    hr = _aryLeftAlignedImgs.AppendIndirect(NULL, &pAlignedLine);

                    if (hr)
                        return;

                    *pAlignedLine = al;
                }

                iLeftAlignedImages++;

                if (y + pLine->_yHeight > _marginInfo._yBottomLeftMargin)
                {
                    _marginInfo._yBottomLeftMargin = y + pLine->_yHeight;
                }
            }
            // If the current line is right aligned push it on to the right aligned images
            // stack and adjust the _yBottomRightMargin.
            else if (pLine->IsRightAligned())
            {
                //
                // If the current aligned element needs to clear right, insert
                // the current aligned layout below all other right aligned
                // layout's since it is the last element that establishes
                // the margin.
                //
                if (pFF && pFF->_fClearRight)
                {
                    hr = _aryRightAlignedImgs.InsertIndirect(0, &al);

                    if (hr)
                        return;
                }
                else
                {
                    CAlignedLine *  pAlignedLine;

                    hr = _aryRightAlignedImgs.AppendIndirect(NULL, &pAlignedLine);

                    if (hr)
                        return;

                    *pAlignedLine = al;
                }

                iRightAlignedImages++;

                if (y + pLine->_yHeight > _marginInfo._yBottomRightMargin)
                {
                    _marginInfo._yBottomRightMargin = y + pLine->_yHeight;
                }
            }
        }
    }

    // Only use remaining floated objects.
    _fMarginFromStyle = FALSE;

    // If we have any left aligned sites left on the stack, calculate the
    // left margin.
    if(iLeftAlignedImages)
    {
        CLineOtherInfo *pLineLeftTopOI;
        const CFancyFormat *pFF;
        
        // get the topmost left aligned line and compute the current lines
        // left margin
        pALine = & _aryLeftAlignedImgs [ iLeftAlignedImages - 1 ];
        pLineLeftTop = pALine->_pLine;
        pLineLeftTopOI = pLineLeftTop->oi();
        if(!_pdp->IsRTLDisplay())
            _marginInfo._xLeftMargin = pLineLeftTopOI->_xLeftMargin + pLineLeftTop->_xLineWidth;
        else
        {
            _marginInfo._xLeftMargin = max(0L, xWidth - pLineLeftTopOI->_xRightMargin);
            // TODO RTL 112514: this is probably bogus. how to get here?
            Assert(_marginInfo._xLeftMargin == pLineLeftTopOI->_xLeftMargin + pLineLeftTop->_xLineWidth 
                   || !IsTagEnabled(tagDebugRTL));
        }
        _marginInfo._yLeftMargin = pLineLeftTop->_yHeight + pALine->_yLine;

        // Note if a "frame" margin may be needed
        _marginInfo._fAddLeftFrameMargin = pLineLeftTop->_fAddsFrameMargin;

        // Note whether margin space is due to CSS float (as opposed to ALIGN attr).
        // We need to know this because if it's CSS float, we autoclear after the line.
        pFF = pLineLeftTop->AO_GetFancyFormat(pLineLeftTopOI);
        _fMarginFromStyle |= pFF && pFF->_fCtrlAlignFromCSS;
    }
    else
    {
        // no left aligned sites for the current line, so set the margins to
        // defaults.
        _marginInfo._yBottomLeftMargin = MINLONG;
        _marginInfo._yLeftMargin = MAXLONG;
        _marginInfo._xLeftMargin = 0;
    }
    // If we have any right aligned sites left on the stack, calculate the
    // right margin.
    if(iRightAlignedImages)
    {
        CLineOtherInfo *pLineRightTopOI;
        const CFancyFormat *pFF;
        
        // get the topmost right aligned line and compute the current lines
        // right margin
        pALine = & _aryRightAlignedImgs [ iRightAlignedImages - 1 ];
        pLineRightTop = pALine->_pLine;
        pLineRightTopOI = pLineRightTop->oi();
        if(!_pdp->IsRTLDisplay())
            _marginInfo._xRightMargin = max(0L, xWidth - pLineRightTopOI->_xLeftMargin);
        else
        {
            _marginInfo._xRightMargin = pLineRightTopOI->_xRightMargin + pLineRightTop->_xLineWidth;
            // TODO RTL 112514: this is probably bogus. how to get here?
            Assert(_marginInfo._xRightMargin == max(0L, xWidth - pLineRightTopOI->_xLeftMargin)
                   || !IsTagEnabled(tagDebugRTL));
        }
        _marginInfo._yRightMargin = pLineRightTop->_yHeight + pALine->_yLine;

        // Note if a "frame" margin may be needed
        _marginInfo._fAddRightFrameMargin = pLineRightTop->_fAddsFrameMargin;

        // Note whether margin space is due to CSS float (as opposed to ALIGN attr).
        // We need to know this because if it's CSS float, we autoclear after the line.
        pFF = pLineRightTop->AO_GetFancyFormat(pLineRightTopOI);
        _fMarginFromStyle |= pFF && pFF->_fCtrlAlignFromCSS;
    }
    else
    {
        // no right aligned sites for the current line, so set the margins to
        // defaults.
        _marginInfo._yBottomRightMargin = MINLONG;
        _marginInfo._yRightMargin = MAXLONG;
        _marginInfo._xRightMargin = 0;
    }
}

//+------------------------------------------------------------------------
//
//  Member:     AlignObjects
//
//  Synopsis:   Process all aligned objects on a line and create new
//              "frame" lines for them.
//
//  Arguments:  [pMe]              --  measurer used to recalc lines
//              [uiFlags]          --  flags
//              [iLineStart]       --  new lines start at
//              [iLineFirst]       --  line to start calculating from
//              [pyHeight]         --  y coordinate of the top of line
//
//-------------------------------------------------------------------------
int CRecalcLinePtr::AlignObjects(
    CLSMeasurer *pme,
    CLineFull   *pLineMeasured,
    LONG         cch,
    BOOL         fMeasuringSitesAtBOL,
    BOOL         fBreakAtWord,
    BOOL         fMinMaxPass,
    int          iLineStart,
    int          iLineFirst,
    LONG        *pyHeight,
    int          xWidthMax,
    LONG        *pyAlignDescent,
    LONG        *pxMaxLineWidth)
{
    CFlowLayout *       pFlowLayout = _pdp->GetFlowLayout();
    CLayout *           pLayout;
    LONG                xWidth      = pFlowLayout->GetMaxLineWidth();
    htmlControlAlign    atSite;
    CLineCore *         pLine;
    CLineCore *         pLineNew;
    CLineFull           lifNew;
    LONG                yHeight;
    LONG                yHeightCurLine = 0;
    int                 xMin = 0;
    int                 iClearLines=0;
    CTreePos           *ptp;
    CTreeNode          *pNodeLayout;
    LONG                cchInTreePos;

    CLayoutContext     *pLayoutContext = _pci->GetLayoutContext();
    BOOL                fViewChain     = (pLayoutContext && pLayoutContext->ViewChain());
    CFlowLayoutBreak   *pEndingBreak   = NULL; 

    if (fViewChain)
    {
        // 
        // Retrieve ending layout break to provide access to Site Tasks queue.
        // 
        CLayoutBreak *pLayoutBreak;

        pLayoutContext->GetEndingLayoutBreak(_pdp->GetFlowLayoutElement(), &pLayoutBreak);
        if (pLayoutBreak)
        {
            pEndingBreak = DYNCAST(CFlowLayoutBreak, pLayoutBreak);
        }
    }

    Reset(iLineStart);
    pLine = (*this)[iLineFirst];

    // Make sure the current line has aligned sites
    Assert(pLine->_fHasAligned);

    yHeight = *pyHeight;

    // If we are measuring sites at the beginning of the line,
    // measurer is positioned at the current site. So we dont
    // need to back up the measurer. Also, margins the current
    // line apply to the line being inserted before the current
    // line.
    if(!fMeasuringSitesAtBOL)
    {
        // fliForceNewLine is set for lines that have text in them.
        Assert (pLine->_fForceNewLine);

        // adjust the height and recalc the margins for the aligned
        // lines being inserted after the current line
        yHeightCurLine = pLine->_yHeight;
        yHeight += yHeightCurLine;

        if (fViewChain)
        {
            //  Adjust Y consumed if this is not BOL
            _pci->_yConsumed += yHeightCurLine;
        }

        iLineFirst++;
        if (!IsValidMargins(yHeight))
        {
            RecalcMargins(iLineStart, iLineFirst, yHeight, 0);
        }
    }

    ptp = pme->GetPtp();
    pNodeLayout = ptp->GetBranch();
    if (ptp->IsText())
        cchInTreePos = ptp->Cch() - (pme->GetCp() - ptp->GetCp());
    else
        cchInTreePos = ptp->GetCch();
    while (cch > 0)
    {
        if (ptp->IsBeginElementScope())
        {
            pNodeLayout = ptp->Branch();
            if (pNodeLayout->ShouldHaveLayout())
            {
                const CCharFormat  * pCF = pNodeLayout->GetCharFormat( LC_TO_FC(_pci->GetLayoutContext()) );
                const CParaFormat  * pPF = pNodeLayout->GetParaFormat( LC_TO_FC(_pci->GetLayoutContext()) );
                const CFancyFormat * pFF = pNodeLayout->GetFancyFormat( LC_TO_FC(_pci->GetLayoutContext()) );
                BOOL        fClearLeft      = pFF->_fClearLeft;
                BOOL        fClearRight     = pFF->_fClearRight;
                CElement *  pElementLayout  = pNodeLayout->Element();
                
                cchInTreePos = pme->GetNestedElementCch(pElementLayout, &ptp);
                
                atSite = pNodeLayout->GetSiteAlign( LC_TO_FC(_pci->GetLayoutContext()) );

                if ( !pCF->IsDisplayNone() && pFF->_fAlignedLayout)
                {
                    LONG xWidthSite, yHeightSite, yBottomMarginSite;

                    pLayout = pNodeLayout->GetUpdatedLayout( _pci->GetLayoutContext() );
 
                    // measuring sites at the Beginning of the line,
                    // insert the aligned line before the current line
                    lifNew.Init();
                    if(fMeasuringSitesAtBOL)
                    {
                        pLineNew = InsertLine(iLineFirst);
                        if (!pLineNew)
                            goto Cleanup;
                        
                        lifNew._fFrameBeforeText = TRUE;
                        lifNew._yBeforeSpace = pLineMeasured->_yBeforeSpace;
                    }
                    else
                    {
                        // insert the aligned line after the current line
                        pLineNew = AddLine();
                        if (!pLineNew)
                            goto Cleanup;

                        lifNew._fHasEOP = (*this)[iLineFirst - 1]->_fHasEOP;
                    }

                    // Update the line width and new margins caused by the aligned line
                    for(;;)
                    {
                        int     yConsumedSafe = 0;
                        BOOL    fLayoutOverflowSafe = FALSE;

                        if (fViewChain)
                        {
                            //  save consumed space
                            yConsumedSafe = _pci->_yConsumed;
                            //  save overflow flag 
                            fLayoutOverflowSafe = _pci->_fLayoutOverflow;

                            //  make adjustments to Y consumed if the align object has clear attribute(s)
                            if(atSite == htmlAlignLeft)
                            {
                                if (    fClearLeft
                                    && _marginInfo._xLeftMargin
                                    &&  lifNew._yBeforeSpace < _marginInfo._yBottomLeftMargin - yHeight)
                                {
                                    _pci->_yConsumed += (_marginInfo._yBottomLeftMargin - yHeight);
                                }
                            }
                            else if(atSite == htmlAlignRight)
                            {
                                if (    fClearRight
                                    &&  _marginInfo._xRightMargin
                                    &&  lifNew._yBeforeSpace < _marginInfo._yBottomRightMargin - yHeight)
                                {
                                    _pci->_yConsumed += (_marginInfo._yBottomRightMargin - yHeight);
                                }
                            }
                        }

                        // Measure the site
                        pme->GetSiteWidth(pNodeLayout, pLayout, _pci, fBreakAtWord,
                                          max(0l, xWidthMax - _xLayoutLeftIndent - _xLayoutRightIndent),
                                          &xWidthSite, &yHeightSite, &xMin, &yBottomMarginSite);

                        if (fViewChain)
                        {
                            // if align object didn't fit to space provided...
                            if (pEndingBreak)
                            {
                                // we want to remember element's tree node into Site Tasks queue.
                                // (if element knows how to break)
                                if (_pci->_fLayoutOverflow)
                                {
                                    CFlowLayoutBreak::CArySiteTask *pArySiteTask;

                                    pArySiteTask = pEndingBreak->GetSiteTasks();
                                    Assert(pArySiteTask);

                                    if (pArySiteTask)
                                    {
                                        CFlowLayoutBreak::CSiteTask *pSiteTask; 
                                        pSiteTask = pArySiteTask->Append();
                                        pSiteTask->_pTreeNode = pNodeLayout;

                                        if (atSite == htmlAlignLeft)
                                        {
                                            pSiteTask->_xMargin = fClearLeft ? 0 : _marginInfo._xLeftMargin;
                                        }
                                        else if (atSite == htmlAlignRight)
                                        {
                                            pSiteTask->_xMargin = fClearRight ? 0 : _marginInfo._xRightMargin;
                                        }
                                        else 
                                        {
                                            pSiteTask->_xMargin = 0;
                                        }
                                    }
                                }

                                //  (bug #111362) yHeightSite must be adjusted to available height 
                                //  to avoid unnecessary deletion of lines during CDisplay::UndoMeasure. 
                                //  It's also safe since it doesn't affect any properties of the 
                                //  aligned object. 
                                if ((_pci->_cyAvail - _pci->_yConsumed) < yHeightSite) 
                                {
                                    yHeightSite = _pci->_cyAvail - _pci->_yConsumed;
                                }
                            }

                            //  restore saved values
                            _pci->_yConsumed = yConsumedSafe;
                            //  aligned objects should not affect pagination of the main flow
                            _pci->_fLayoutOverflow = fLayoutOverflowSafe;
                        }

                        //
                        // if clear is set on the layout, we don need to auto clear.
                        //
                        if (fClearLeft || fClearRight)
                            break;

                        // If we've overflowed, and the current margin allows for auto
                        // clearing, we have to introduce a clear line.
                        if (_fMarginFromStyle &&
                            _marginInfo._xLeftMargin + _marginInfo._xRightMargin > 0 &&
                            xWidthSite > xWidthMax)
                        {
                            int iliClear;

                            _marginInfo._fAutoClear = TRUE;

                            // Find the index of the clear line that is being added.
                            if(fMeasuringSitesAtBOL)
                            {
                                iliClear = iLineFirst + iClearLines;
                            }
                            else
                            {
                                iliClear = Count() - 1;
                            }

                            // ---------------------------------------------------------
                            //
                            // BEGIN       HACK! HACK! HACK! HACK!
                            //
                            // ClearObjects will look at the line array to make some
                            // of its decisions. It will also *reuse* the line in line
                            // array -- but will assume that it has no line other info
                            // associated with it. Hence, we just transfer the lifNew
                            // over to the core line and do not bother with the other
                            // info part of lifNew since (a)ClearObjects would have to
                            // release it -- since it is reusing pliNew and (b)ClearObjects
                            // does not require to look at the other info of pliNew. 

                            Assert(lifNew._iLOI < 0);
                             *pLineNew = lifNew;
                            //
                            // END         HACK! HACK! HACK! HACK!
                            //
                            // ---------------------------------------------------------
                            
                            // add a clear line
                            ClearObjects(&lifNew, iLineStart,
                                         iliClear,
                                         &yHeight);

                            iClearLines++;

                            //
                            // Clear line takes any beforespace, so clear the
                            // beforespace for the current line
                            //
                            pme->_li._yBeforeSpace = 0;
                            ResetPosAndNegSpace();

                            // insert the new line for the alined element after the
                            // clear line.
                            lifNew.Init();
                            if(fMeasuringSitesAtBOL)
                            {
                                pLineNew = InsertLine(iLineFirst + iClearLines);

                                if (!pLineNew)
                                    goto Cleanup;

                                lifNew._fFrameBeforeText = TRUE;
                            }
                            else
                            {
                                pLineNew = AddLine();

                                if (!pLineNew)
                                    goto Cleanup;

                                lifNew._fFrameBeforeText = FALSE;
                            }

                            RecalcMargins(iLineStart,
                                          fMeasuringSitesAtBOL
                                            ? iLineFirst + iClearLines
                                            : Count() - 1,
                                          yHeight, 0);

                            xWidthMax = GetAvailableWidth();
                        }

                        // We fit just fine, but keep track of total available width.
                        else
                        {
                            xWidthMax -= xWidthSite;
                            break;
                        }
                    } // end of for loop

                    // Start out assuming that there are no style floated objects.
                    _fMarginFromStyle = FALSE;

                    // Note if the site adds "frame" margin space
                    // (e.g., tables do, images do not)
                    lifNew._fAddsFrameMargin = !(pNodeLayout->Element()->Tag() == ETAG_IMG);

                    // Top Margin is included in the line height for aligned lines,
                    // at the top of the document. Before paragraph spacing is
                    // also included in the line height.

                    long xLeftMargin, yTopMargin, xRightMargin;
                    // get the site's margins
                    pLayout->GetMarginInfo(_pci, &xLeftMargin, &yTopMargin, &xRightMargin, NULL);

                    // note: RTL display (but not RTL line) needs different calculations, because when
                    //       an RTL object doesn't fit in dislpay width, it needs to shift to the left.
                    //       Also, aligned RTL objects affect min/max calculations in combination with 
                    //       right margin (instead of left).
                    //       Therefore, calculations are done from the right margin
                    long xPos;
                    if (!_pdp->IsRTLDisplay())
                        xPos = xLeftMargin;
                    else
                        xPos = xRightMargin;

                    // Set proposed relative to the line
                    pLayout->SetXProposed(xPos);
                    pLayout->SetYProposed(yTopMargin + (fMeasuringSitesAtBOL ? (_yPadTop + _yBordTop) : 0));

                    if (pCF->HasCharGrid(FALSE))
                    {
                        long xGridWidthSite = pme->_pLS->GetClosestGridMultiple(pme->_pLS->GetCharGridSize(), xWidthSite);
                        pLayout->SetXProposed(xPos + ((xGridWidthSite - xWidthSite)/2));
                        xWidthSite = xGridWidthSite;
                    }
                    if (pCF->HasLineGrid(FALSE))
                    {
                        long yGridHeightSite = pme->_pLS->GetClosestGridMultiple(pme->_pLS->GetLineGridSize(), yHeightSite);
                        pLayout->SetYProposed(yTopMargin + ((yGridHeightSite - yHeightSite)/2));
                        yHeightSite = yGridHeightSite;
                    }

                    // _cch, _xOverhang and _xLeft are initialized to zero
                    Assert(lifNew._cch == 0 &&
                           lifNew._xLineOverhang == 0 &&
                           lifNew._xLeft == 0 &&
                           lifNew._xRight == 0);

                    // for the current line measure the left and the right indent
                    {
                        long xParentWidth = _pci->_sizeParent.cx;
                        if (   pPF->_cuvLeftIndentPercent.GetUnitValue()
                            || pPF->_cuvRightIndentPercent.GetUnitValue()
                           )
                        {
                            xParentWidth = pNodeLayout->GetParentWidth(_pci, xParentWidth);
                        }
                        long  xLeftIndent   = pPF->GetLeftIndent(_pci, FALSE, xParentWidth);
                        long  xRightIndent  = pPF->GetRightIndent(_pci, FALSE, xParentWidth);

                        if (pCF->_fHasBgColor || pCF->_fHasBgImage)
                        {
                            lifNew._fHasBackground = TRUE;
                        }

                        // (changes to the next block should be reflected in
                        //  ApplyLineIndents() too)
                        if(atSite == htmlAlignLeft)
                        {
                            _marginInfo._fAddLeftFrameMargin = lifNew._fAddsFrameMargin;
                            
                            xLeftIndent += _xMarqueeWidth + _xLayoutLeftIndent;
                            xLeftIndent += _xPadLeft + _xBordLeft;

                            // xLeftIndent is now the sum of indents.  CSS requires that when possible, this
                            // indent is shared with the space occupied by floated/ALIGN'ed elements
                            // (our code calls that space "margin").  Thus we want to apply a +ve xLeftIndent
                            // only when it's greater than the margin, and the amount applied excludes
                            // what's occupied by the margin already.  (We never want to apply a -ve xLeftIndent)

                            if (!fClearLeft)
                                lifNew._xLeft = max( 0L, xLeftIndent - _marginInfo._xLeftMargin );
                            else
                                lifNew._xLeft = xLeftIndent;

                            // If the current layout has clear left, then we need to adjust its
                            // before space so we're beneath all other left-aligned layouts.
                            // For the current layout to be clear left, its yBeforeSpace + yHeight must
                            // equal or exceed the current yBottomLeftMargin.
                            if (    fClearLeft
                                && _marginInfo._xLeftMargin
                                &&  lifNew._yBeforeSpace < _marginInfo._yBottomLeftMargin - yHeight)
                            {
                                lifNew._yBeforeSpace = _marginInfo._yBottomLeftMargin - yHeight;
                            }
                        }
                        else if(atSite == htmlAlignRight)
                        {
                            _marginInfo._fAddRightFrameMargin = lifNew._fAddsFrameMargin;
                            
                            xRightIndent += _xMarqueeWidth + _xLayoutRightIndent;
                            xRightIndent += _xPadRight + _xBordRight;

                            // xRightIndent is now the sum of indents.  CSS requires that when possible, this
                            // indent is shared with the space occupied by floated/ALIGN'ed elements
                            // (our code calls that space "margin").  Thus we want to apply a +ve xRightIndent
                            // only when it's greater than the margin, and the amount applied excludes
                            // what's occupied by the margin already.  (We never want to apply a -ve xRightIndent)

                            if (!fClearRight)
                                lifNew._xRight = max( 0L, xRightIndent - _marginInfo._xRightMargin );                            
                            else
                                lifNew._xRight = xRightIndent;

                            LONG xLeft = xLeftIndent + _xMarqueeWidth + _xLayoutLeftIndent + _xPadLeft + _xBordLeft;

                            if (!fClearLeft)
                                xLeft = max(0L, xLeft - _marginInfo._xLeftMargin);

                            xMin += xLeft + lifNew._xRight;

                            // If it's right aligned, remember the widest one in max mode.
                            _xMaxRightAlign = max(_xMaxRightAlign, long(xMin));

                            // If the current layout has clear right, then we need to adjust its
                            // before space so we're beneath all other right-aligned layouts.
                            // For the current layout to be clear right, its yBeforeSpace + yHeight must
                            // equal or exceed the current yBottomRightMargin.
                            
                            if (    fClearRight
                                &&  _marginInfo._xRightMargin
                                &&  lifNew._yBeforeSpace < _marginInfo._yBottomRightMargin - yHeight)
                            {
                                lifNew._yBeforeSpace = _marginInfo._yBottomRightMargin - yHeight;
                            }
                        }
                    }

                    // RTL line needs the adjustment at the right
                    if(!pme->_li.IsRTLLine())
                        lifNew._xLeft   += _xLeadAdjust;
                    else
                        lifNew._xRight  += _xLeadAdjust;

                    lifNew._xWidth       = xWidthSite;
                    lifNew._xLineWidth   = lifNew._xWidth;

                    if (fMeasuringSitesAtBOL)
                        lifNew._yExtent  = _yPadTop + _yBordTop;

                    lifNew._yExtent      += yHeightSite;
                    lifNew._yHeight      = lifNew._yExtent + lifNew._yBeforeSpace;

                    lifNew._pNodeForLayout = pNodeLayout;

                    _fMarginFromStyle = pFF->_fCtrlAlignFromCSS;

                    // Update the left and right margins
                    if (atSite == htmlAlignLeft)
                    {
                        lifNew.SetLeftAligned();

                        _cLeftAlignedLayouts++;

                        lifNew._xLineWidth  += lifNew._xLeft;

                        // note: for LTR display, right-aligned objects affect min/max calculations.
                        //       for RTL it is vice versa
                        if (!_pdp->IsRTLDisplay())
                        {
                            lifNew._xLeftMargin = fClearLeft ? 0 : _marginInfo._xLeftMargin;
                        }
                        else
                        {
                            if (fClearLeft)
                            {
                                lifNew._xLeftMargin = 0;
                            }
                            if (fMinMaxPass)
                            {
                                lifNew._xRightMargin = _marginInfo._xRightMargin;
                            }
                            else
                            {
                                lifNew._xRightMargin = max(_marginInfo._xRightMargin,
                                                           xWidth + 2 * _xMarqueeWidth -                                                       
                                                           (fClearLeft ? 0 : _marginInfo._xLeftMargin) -
                                                           lifNew._xLineWidth);
                                lifNew._xRightMargin = max(_xLayoutRightIndent,
                                                            lifNew._xRightMargin);
                            }
                        }

                        //
                        // if the current layout has clear then it may not
                        // establish the margin, because it needs to clear
                        // any left aligned layouts if any, in which case
                        // the left margin remains the same.
                        //
                        if (!fClearLeft || _marginInfo._xLeftMargin == 0 )
                        {
                            _marginInfo._xLeftMargin += lifNew._xLineWidth;
                            _marginInfo._yLeftMargin = yHeight + lifNew._yHeight;
                        }

                        //
                        // Update max y of all the left margin's
                        //

                        if (yHeight + lifNew._yHeight > _marginInfo._yBottomLeftMargin)
                        {
                            _marginInfo._yBottomLeftMargin = yHeight + lifNew._yHeight;
                            if (yHeight + lifNew._yHeight > *pyAlignDescent)
                            {
                                *pyAlignDescent = yHeight + lifNew._yHeight - yBottomMarginSite;
                            }
                        }
                    }
                    else
                    {
                        lifNew.SetRightAligned();

                        _cRightAlignedLayouts++;

                        lifNew._xLineWidth  += lifNew._xRight;
                        
                        if (!_pdp->IsRTLDisplay())
                        {
                            if (fMinMaxPass)
                            {
                                lifNew._xLeftMargin = _marginInfo._xLeftMargin;
                            }
                            else
                            {
                                lifNew._xLeftMargin = max(_marginInfo._xLeftMargin,
                                                         xWidth + 2 * _xMarqueeWidth -                                                     
                                                         (fClearRight ? 0 : _marginInfo._xRightMargin) -
                                                         lifNew._xLineWidth);
                                lifNew._xLeftMargin = max(_xLayoutLeftIndent,
                                                         lifNew._xLeftMargin);
                            }
                        }
                        else
                        {
                            lifNew._xRightMargin = fClearRight ? 0 : _marginInfo._xRightMargin;
                        }

                        //
                        // if the current layout has clear then it may not
                        // establish the margin, because it needs to clear
                        // any left aligned layouts if any, in which case
                        // the left margin remains the same.
                        //
                        if (!fClearRight || _marginInfo._xRightMargin == 0)
                        {
                            _marginInfo._xRightMargin += lifNew._xLineWidth;
                            _marginInfo._yRightMargin = yHeight + lifNew._yHeight;
                        }

                        //
                        // Update max y of all the right margin's
                        //

                        if (yHeight + lifNew._yHeight > _marginInfo._yBottomRightMargin)
                        {
                            _marginInfo._yBottomRightMargin = yHeight + lifNew._yHeight;
                            if (yHeight + lifNew._yHeight > *pyAlignDescent)
                            {
                                *pyAlignDescent = yHeight + lifNew._yHeight;
                            }
                        }
                    }
                    
                    if (pxMaxLineWidth)
                    {
                        if(!_pdp->IsRTLDisplay())
                        {
                            *pxMaxLineWidth = max(*pxMaxLineWidth, lifNew._xLeftMargin +
                                                                   lifNew._xLineWidth);
                        }
                        else
                        {
                            *pxMaxLineWidth = max(*pxMaxLineWidth, lifNew._xRightMargin +
                                                                   lifNew._xLineWidth);
                        }
                    }

                    if (_pci->IsNaturalMode())
                    {
                        const CFancyFormat * pFF = pNodeLayout->GetFancyFormat();
                        Assert(pFF->_bPositionType != stylePositionabsolute);

                        long dx;
                        if (!_pdp->IsRTLDisplay())
                            dx = lifNew._xLeftMargin + lifNew._xLeft;
                        else
                        {
                            dx = - lifNew._xRightMargin - lifNew._xRight;
                        }

                        long xPos; 
                        
                        // Aligned elements have their CSS margin stored in _ptProposed of
                        // their layout.  In the static case above, AddLayoutDispNode()
                        // accounts for it.  This is where we account for it in the
                        // relative case.  (Bug #65664)
                        if(!_pdp->IsRTLDisplay())
                            xPos = dx + pLayout->GetXProposed();
                        else
                        {
                            // we need to set the top left corner.
                            AssertSz(!IsTagEnabled(tagDebugRTL), "AlignObjects case 65664"); // TODO RTL 112514
                            CSize size;
                            pLayout->GetApparentSize(&size);

                            xPos = dx + _pdp->GetViewWidth() - pLayout->GetXProposed() - size.cx;
                        }


                        if (pFF->_bPositionType != stylePositionrelative)
                        {
                            pme->_pDispNodePrev =
                                _pdp->AddLayoutDispNode(
                                        _pci,
                                        pNodeLayout,
                                        xPos,
                                        yHeight + lifNew.GetYTop() + pLayout->GetYProposed(),
                                        pme->_pDispNodePrev
                                        );
                        }
                        else
                        {
                            CPoint  ptAuto(xPos, yHeight + lifNew._yBeforeSpace + pLayout->GetYProposed());
                            pNodeLayout->Element()->ZChangeElement(0, &ptAuto, _pci->GetLayoutContext());
                        }
                    }

                    // save back into the line array here
                    pLineNew->AssignLine(lifNew);
                    
                    // If we are measuring sites at the Beginning of the line. We are
                    // interested only in the current site.
                    if(fMeasuringSitesAtBOL)
                    {
                        break;
                    }
                }
            }
        }
    
        cch -= cchInTreePos;
        ptp = ptp->NextTreePos();
        Assert(ptp);
        cchInTreePos = ptp->GetCch();
    }

Cleanup:
    // Height of the current text line that contains the embedding characters for
    // the aligned sites is added at the end of CRecalcLinePtr::MeasureLine.
    // Here we are taking care of only the clear lines here.
    *pyHeight = yHeight - yHeightCurLine;

    if (fViewChain)
    {
        // restore Y consumed
        _pci->_yConsumed -= yHeightCurLine;
    }

    return iClearLines;
}


//+--------------------------------------------------------------------------
//
//  Member:     ClearObjects
//
//  Synopsis:   Insert new line for clearing objects at the left/right margin
//
//  Arguments:  [pLineMeasured]    --  Current line measured.
//              [iLineStart]       --  new lines start at
//              [iLineFirst]       --  line to start calculating from
//              [pyHeight]         --  y coordinate of the top of line
//
//
//---------------------------------------------------------------------------
BOOL CRecalcLinePtr::ClearObjects(
    CLineFull   *pLineMeasured,
    int          iLineStart,
    int &        iLineFirst,
    LONG        *pyHeight)
{
    CLineCore * pLine;
    LONG    yAt;
    CLineCore * pLineNew;

    Reset(iLineStart);
    pLine = (*this)[iLineFirst];

    Assert(_marginInfo._fClearLeft || _marginInfo._fClearRight || _marginInfo._fAutoClear);

    // Find the height to clear
    yAt = *pyHeight;

    if (_marginInfo._fClearLeft && yAt < _marginInfo._yBottomLeftMargin)
    {
        yAt = _marginInfo._yBottomLeftMargin;
    }
    if (_marginInfo._fClearRight && yAt < _marginInfo._yBottomRightMargin)
    {
        yAt = _marginInfo._yBottomRightMargin;
    }
    if (_marginInfo._fAutoClear)
    {
        yAt = max(yAt, min(_marginInfo._yRightMargin, _marginInfo._yLeftMargin));
    }

    if(pLine->_cch > 0 &&
       yAt <= (*pyHeight + pLine->_yHeight))
    {
        // nothing to clear
        pLine->_fClearBefore = pLine->_fClearAfter = FALSE;
    }

    // if the current line has any characters or is an aligned site line,
    // then add a new line, otherwise, re-use the current line.
    else if (pLine->_cch || pLine->IsFrame() && !_marginInfo._fAutoClear)
    {
        if(yAt > *pyHeight)
        {
            BOOL fIsFrame = pLine->IsFrame();
            pLineNew = AddLine();
            pLine = (*this)[iLineFirst];
            if (pLineNew)
            {
                CLineFull lif;
                CLineOtherInfo *pLineInfo = pLine->oi();
                
                lif.Init();
                lif._cch = 0;
                lif._xLeft = pLineInfo->_xLeft;
                lif._xRight = pLine->_xRight;
                lif._xLeftMargin = _marginInfo._xLeftMargin;
                lif._xRightMargin = _marginInfo._xRightMargin;
                lif._xLineWidth = max (0L, (_marginInfo._xLeftMargin ? _xMarqueeWidth : 0) +
                                                 (_marginInfo._xRightMargin ? _xMarqueeWidth : 0) +
                                                 _pdp->GetFlowLayout()->GetMaxLineWidth() -
                                                 _marginInfo._xLeftMargin -
                                                 _marginInfo._xRightMargin);
                 
                lif._xWidth = 0;

                // Make the line the right size to clear.
                if (fIsFrame)
                    lif._yHeight = pLine->_yHeight;
                else if (pLine->_fForceNewLine)
                {
                    lif._yHeight = yAt - *pyHeight - pLine->_yHeight;
                }
                else
                {
                    //
                    // if the previous line does not force new line,
                    // then we need to propagate the beforespace.
                    //
                    lif._yBeforeSpace = pLineInfo->_yBeforeSpace;
                    lif._yHeight = yAt - *pyHeight;

                    Assert(lif._yHeight >= lif._yBeforeSpace);
                }

                *pyHeight += lif._yHeight;

                lif._yExtent = lif._yHeight - lif._yBeforeSpace;
                lif._yDescent = 0;
                lif._yTxtDescent = 0;
                lif._fForceNewLine = TRUE;
                lif._fClearAfter = !pLineMeasured->_fClearBefore;
                lif._fClearBefore = pLineMeasured->_fClearBefore;
                lif._xLineOverhang = 0;
                lif._cchWhite = 0;
                lif._fHasEOP = pLine->_fHasEOP;

                if (_pci->GetLayoutContext())
                {
                    lif._fClearLeft  = _marginInfo._fClearLeft;
                    lif._fClearRight = _marginInfo._fClearRight;
                    lif._fAutoClear  = _marginInfo._fAutoClear;
                }

                pLine->_fClearBefore = pLine->_fClearAfter = FALSE;

                pLineNew->AssignLine(lif);
            }
            else
            {
                Assert(FALSE);
                return FALSE;
            }
        }
    }
    // Just replacing the existing empty line.
    else
    {
        CLineFull lif;

        Assert(pLine->_iLOI < 0);
        
        lif.Init();
        lif._xWidth = 0;

        // The clear line needs to have a margin for
        // recalc margins to work.
        lif._xLeftMargin = _marginInfo._xLeftMargin;
        lif._xRightMargin = _marginInfo._xRightMargin;

        lif._xLineWidth = max (0L, (_marginInfo._xLeftMargin ? _xMarqueeWidth : 0) +
                                                 (_marginInfo._xRightMargin ? _xMarqueeWidth : 0) +
                                                 _pdp->GetFlowLayout()->GetMaxLineWidth() -
                                                 _marginInfo._xLeftMargin - _marginInfo._xRightMargin);
        lif._xLeft = pLineMeasured->_xLeft;
        lif._xRight = pLineMeasured->_xRight;

        lif._yHeight = yAt - *pyHeight;
        lif._yExtent = lif._yHeight;
        lif._yDescent = 0;
        lif._yTxtDescent = 0;
        lif._xLineOverhang = 0;
        lif._cchWhite = 0;
        lif._fHasBulletOrNum = FALSE;
        lif._fClearAfter = !pLineMeasured->_fClearBefore;
        lif._fClearBefore = pLineMeasured->_fClearBefore;
        lif._fForceNewLine = TRUE;

        if (_pci->GetLayoutContext())
        {
            lif._fClearLeft  = _marginInfo._fClearLeft;
            lif._fClearRight = _marginInfo._fClearRight;
            lif._fAutoClear  = _marginInfo._fAutoClear;
        }

        pLine->AssignLine(lif);
        if (!_marginInfo._fAutoClear)
            iLineFirst--;

        // If we are clearing the line, then we will come around again to measure
        // the line and we will call CalcBeforeSpace all over again which will
        // add in the padding+border of block elements coming into scope again.
        // To avoid this, remove the padding+border added in this time.
        if (pLineMeasured->_fFirstInPara)
        {
            _xBordLeft  -= _xBordLeftPerLine;
            _xBordRight -= _xBordRightPerLine;
            _xPadLeft   -= _xPadLeftPerLine;
            _xPadRight  -= _xPadRightPerLine;
        }
    }
    if(pLine->_fForceNewLine)
        *pyHeight += pLine->_yHeight;

    // Prepare for the next pass of the measurer.
    _marginInfo._fClearLeft  = FALSE;
    _marginInfo._fClearRight = FALSE;
    
    return TRUE;
}

//+----------------------------------------------------------------------------
//
//  Member:     CRecalcLinePtr::MeasureLine()
//
//  Synopsis:   Measures a new line, creates aligned and clear lines if
//              current text line has aligned objects or clear flags set on it.
//              Updates iNewLine to point to the last text line. -1 if there is
//              no text line before the current line
//
//-----------------------------------------------------------------------------

BOOL
CRecalcLinePtr::MeasureLine(CLSMeasurer &me,
                            UINT    uiFlags,
                            INT  *  piLine,
                            LONG *  pyHeight,
                            LONG *  pyAlignDescent,
                            LONG *  pxMinLineWidth,
                            LONG *  pxMaxLineWidth
                            )
{
    LONG                cchSkip = 0;
    LONG                xWidth = 0;
    CLineCore          *pliNew;
    INT                 iTLine = *piLine - 1;
    BOOL                fAdjustForCompact = FALSE;
    CFlowLayout        *pFlowLayout = _pdp->GetFlowLayout();
    BOOL                fClearMarginsRequired;
    CTreeNode          *pNodeFormatting;

    Reset(_iNewFirst);
    pliNew = (*this)[*piLine];

    _xLeadAdjust = 0;
    _ptpStartForListItem = NULL;

    me._cchAbsPosdPreChars = 0;
    me._fRelativePreChars = FALSE;
    me._fMeasureFromTheStart = FALSE;
    me._fSeenAbsolute = FALSE;
    
    _marginInfo._fClearLeft  =
    _marginInfo._fClearRight =
    _marginInfo._fAutoClear  = FALSE;

    // If the current line being measure has an offset of 0, It implies
    // the current line is the top most line.
    if (*pyHeight == 0 )
        uiFlags |= MEASURE_FIRSTLINE;

#if DBG==1
    // We should never have an index off the end of the line array.
    if (iTLine >= 0 && (*this)[iTLine] == NULL)
    {
        Assert(FALSE);
        goto err;
    }
#endif

    // If we are measuring aligned sites at the beginnning of the line,
    // we have initialized the line once.
    me.NewLine(uiFlags & MEASURE_FIRSTINPARA);

    Assert(!me._fPseudoLineEnabled);
    
    // Space between paragraphs.
    pNodeFormatting = CalcInterParaSpace(&me, iTLine, &uiFlags);

    //
    // Note: CalcBeforeSpace needs to be call ed before we call RecalcMargins
    // because before space is used to compute margins.
    //
    
    // If the current line being measured has invalid margins, a line that is
    // below an aligned line, margins have changed so recalculate margins.
    if (!IsValidMargins(*pyHeight + max(0l, me._li._yBeforeSpace)))
    {
        BOOL fClearLeft  = _marginInfo._fClearLeft;
        BOOL fClearRight = _marginInfo._fClearRight;

        RecalcMargins(_iNewFirst, *piLine, *pyHeight, me._li._yBeforeSpace);

        if (_fMarginFromStyle)
            uiFlags |= MEASURE_AUTOCLEAR;

        //
        // Restore the clear flags on _marginInfo, since RecalcMargins init's
        // the marginInfo. CalcBeforeSpace set's up clear flags on the marginInfo
        // if any elements comming into scope have clear attribute/style set.
        //
        _marginInfo._fClearLeft  = fClearLeft;
        _marginInfo._fClearRight = fClearRight;
    }

    if (   _pci->GetLayoutContext()                 // layout in context
        && _pci->GetLayoutContext()->ViewChain()    // there is a view chain 
        && _pdp->LineCount() == 1)                  // this is the first line
    {
        me._cyTopBordPad = _yBordTop + _yPadTop;
        me._li._cyTopBordPad = me._cyTopBordPad;

        // Compute the available width for the current line.
        // (Do this after determining the margins for the line)
        xWidth = GetAvailableWidth();

        ProcessAlignedSiteTasksAtBOB(&me, &me._li, uiFlags, piLine,
                                     pyHeight, &xWidth, pyAlignDescent,
                                     pxMaxLineWidth, &fClearMarginsRequired);
    }

    //
    // If we need to clear aligned elements, don't bother measuring text
    //
    if (!CheckForClear())
    {
        // Apply the line indents, _xLeft and _xRight
        ApplyLineIndents(pNodeFormatting, &me._li, uiFlags, me._fPseudoElementEnabled);
        
        if( iTLine >= 0 )
        {
            BOOL  fInner = FALSE;
            const CParaFormat* pPF;

            pPF = me.MeasureGetPF(&fInner);

            CLineCore *pli = (*this)[iTLine];

            // If we have the compact attribute set, see if we can fit the DT and the DD on the
            //  same line.
            if( pPF->HasCompactDL(fInner) && pli->_fForceNewLine )
            {
                CTreeNode * pNodeCurrBlockElem = pNodeFormatting;

                if (pNodeCurrBlockElem->Element()->IsTagAndBlock(ETAG_DD))
                {
                    CLineFull lif = *pli;
                    CTreePos  * ptp;
                    CTreePos  * ptpFirst;
                    CTreeNode * pNodePrevBlockElem;

                    //
                    // Find the DT which should have appeared before the DD
                    //
                    // Get the max we will travel backwards in search of the DT
                    pFlowLayout->GetContentTreeExtent(&ptpFirst, NULL);

                    pNodePrevBlockElem = NULL;
                    ptp = me.GetPtp();
                    for(;;)
                    {
                        ptp = ptp->PreviousTreePos();
                        Assert(ptp);
                        if (   (ptp == ptpFirst)
                            || ptp->IsText()
                           )
                            break;

                        if (   ptp->IsEndElementScope()
                            && ptp->Branch()->Element()->IsTagAndBlock(ETAG_DT)
                           )
                        {
                            pNodePrevBlockElem = ptp->Branch();
                            break;
                        }
                    }

#if DBG==1                
                    if (pNodePrevBlockElem)
                    {
                        Assert(pNodePrevBlockElem->Element()->IsTagAndBlock(ETAG_DT));
                        Assert((pFlowLayout->GetContentMarkup()->FindMyListContainer(pNodeCurrBlockElem) ==
                                pFlowLayout->GetContentMarkup()->FindMyListContainer(pNodePrevBlockElem)));
                    }
#endif
                    // Make sure that the DT is thin enough to fit the DD on the same line.
                    // TODO RTL 112514: avoid obscure formulas in offset calculations
                    if (   pNodePrevBlockElem
                        && (!pPF->_fRTL ? me._li._xLeft > lif._xWidth + lif._xLeft + lif._xLineOverhang
                                        : me._li._xRight > lif._xWidth + lif._xRight + lif._xLineOverhang
                           )
                       )
                    {
                        fAdjustForCompact = TRUE;
                        lif._fForceNewLine = FALSE;
                        if(!pPF->_fRTL)
                        {
                            lif._xRight = 0;
                            lif._xLineWidth = me._li._xLeft;
                        }
                        else
                        {
                            lif._xLeft = 0;
                            lif._xLineWidth = me._li._xRight;
                        }
                        *pyHeight -= lif._yHeight;
                        
                        if (me._li._yBeforeSpace < lif._yBeforeSpace)
                            me._li._yBeforeSpace = lif._yBeforeSpace;
                        if (lif._yBeforeSpace < me._li._yBeforeSpace)
                            lif._yBeforeSpace = me._li._yBeforeSpace;
                        
                        // If the current line being measured has an offset of 0, It implies
                        // the current line is the top most line.
                        if (*pyHeight == 0 )
                            uiFlags |= MEASURE_FIRSTLINE;

                        lif.ReleaseOtherInfo();
                        pli->AssignLine(lif);

                        // Adjust the margins
                        RecalcMargins(_iNewFirst, *piLine, *pyHeight, me._li._yBeforeSpace);
                        if (_fMarginFromStyle)
                            uiFlags |= MEASURE_AUTOCLEAR;
                    }
                }
            }
        }

        me._cyTopBordPad = _yBordTop + _yPadTop;
        me._li._cyTopBordPad = me._cyTopBordPad;

        // Compute the available width for the current line.
        // (Do this after determining the margins for the line)
        xWidth = GetAvailableWidth();

        cchSkip = CalcAlignedSitesAtBOL(&me, &me._li, uiFlags,
                                        piLine, pyHeight,
                                        &xWidth, pyAlignDescent,
                                        pxMaxLineWidth, &fClearMarginsRequired);

        pliNew = (*this)[*piLine];
        if (!fClearMarginsRequired)
        {
            me._cchPreChars = me._li._cch;
            me._li._cch = 0;

            if (me._fMeasureFromTheStart)
                me.SetCp(me.GetCp() - me._cchPreChars, NULL);
            
            if (_fMarginFromStyle)
                uiFlags |= MEASURE_AUTOCLEAR;

            me._pLS->_cchSkipAtBOL = cchSkip;
            me._yli = *pyHeight;
            if(!me.MeasureLine(xWidth, -1, uiFlags, &_marginInfo, pxMinLineWidth))
            {
                Assert(FALSE);
                goto err;
            }

            Check(cchSkip <= me._li._cch);
            
            // if it is in edit mode _fNoContent will be always FALSE
            // If it has a LI on it then too we will say that the display has contents
            _pdp->_fNoContent =    !_fIsEditable
                                && !!(uiFlags & MEASURE_FIRSTLINE && me._li._cch == 0)
                                && !me._li._fHasBulletOrNum;

            me.Resync();
            if (!me._fMeasureFromTheStart)
                me._li._cch += me._cchPreChars;

            if (   me._li._fHasBulletOrNum
                && (_yBordTop || _yPadTop)
                && !IsListItem(me.GetPtp()->GetBranch())
                && !me._pLS->HasVisualContent()
               )
            {
                _fMoveBulletToNextLine = TRUE;
                me._li._fHasBulletOrNum = FALSE;
                me._li._fHasTransmittedLI = TRUE;
                me._li._yExtent = me._li._yHeight = me._li._yDescent = me._li._yTxtDescent = 0;
                _ptpStartForListItem = NULL;
            }

            // If we couldn't fit anything on the line, clear an aligned thing and
            // we'll try again afterwards.
            if (!_marginInfo._fAutoClear || me._li._cch > 0)
            {
                // CalcAfterSpace modifies, _xBordLeft and _xBordRight
                // to account for block elements going out of scope,
                // set the flag before they are modified.
                me._li._fHasParaBorder = (_xBordLeft + _xBordRight) != 0;

                CalcAfterSpace(&me,
                               me._li._fDummyLine && (uiFlags & MEASURE_FIRSTLINE ? TRUE : FALSE),
                               LONG_MAX);

                // Monitor progress here
                Assert(me._li._cch != 0 || _pdp->GetLastCp() == me.GetCp());

                me._li._yHeight  += _yBordTop + _yBordBottom + 
                                    _yPadTop  + _yPadBottom;
                me._li._yDescent += _yBordBottom + _yPadBottom;
                me._li._yHeight  += (LONG)me._li._yBeforeSpace;
                me._li._yExtent  += _yBordTop + _yBordBottom + 
                                    _yPadTop  + _yPadBottom;
                me._li._fHasParaBorder |= (_yBordTop + _yBordBottom) != 0;

                AssertSz(!IsBadWritePtr(pliNew, sizeof(CLineCore)),
                         "Line Array has been realloc'd and now pliNew is invalid! "
                         "Memory corruption is about to occur!");

                // Remember the longest word.
                if(pxMinLineWidth && _pdp->_xMinWidth >= 0)
                {
                    _pdp->_xMinWidth = max(_pdp->_xMinWidth, *pxMinLineWidth);
                }
            }
            else
            {
                ResetPosAndNegSpace();
            }
        }
        else
        {
            me.Advance(cchSkip);
            ResetPosAndNegSpace();
            me._li._cch            += cchSkip;
            me._li._fHasEmbedOrWbr = TRUE;
            me._li._fDummyLine     = TRUE;
            me._li._fForceNewLine  = FALSE;
            me._li._fClearAfter    = TRUE;
        }
    }
    else
    {
        me.Advance(-me._li._cch);
        me._li._fClearBefore = TRUE;
        me._li._xWhite =
        me._li._xWidth = 0;
        me._li._cch =
        me._li._cchWhite = 0;
        me._li._yBeforeSpace = me._li._yBeforeSpace;
    }

    if (me._li._fForceNewLine)
        _yPadTop = _yPadBottom = _yBordTop = _yBordBottom = 0;

    // If we're autoclearing, we don't need to do anything here.
    if (!_marginInfo._fAutoClear || me._li._cch > 0)
    {
        if( fAdjustForCompact )
        {
            CLineCore *pli = (*this)[iTLine];       // since fAdjustForCompact is set, we know iTLine >= 0
            CLineFull lif = *pli;

            lif.ReleaseOtherInfo();
            
            // The DT and DL have different heights, need to make them each the height of the
            //  greater of the two.

            LONG iDTHeight = lif._yHeight - lif._yBeforeSpace - lif._yDescent;
            LONG iDDHeight = me._li._yHeight - me._li._yBeforeSpace - me._li._yDescent;

            lif._yBeforeSpace    += max( 0l, iDDHeight - iDTHeight );
            me._li._yBeforeSpace += max( 0l, iDTHeight - iDDHeight );
            lif._yDescent        += max( 0l, me._li._yDescent - lif._yDescent );
            me._li._yDescent     += max( 0l, lif._yDescent - me._li._yDescent );

            lif._yHeight = me._li._yHeight =
                lif._yBeforeSpace +  iDTHeight + lif._yDescent;

            pli->AssignLine(lif);
        }

        me._li._xLeftMargin = _marginInfo._xLeftMargin;
        me._li._xRightMargin = _marginInfo._xRightMargin;
        me._li._xLineWidth  = me._li.CalcLineWidth();

        if(me._li._fForceNewLine && xWidth > me._li._xLineWidth)
            me._li._xLineWidth = xWidth;
        
        if(me._li._fHidden)
        {
            me._li._yExtent = 0;
        }
        
        if(pxMaxLineWidth)
        {
            *pxMaxLineWidth = max(*pxMaxLineWidth, (!me._li._fRTLLn ? me._li._xLeftMargin : me._li._xRightMargin)   +
                                                   me._li._xWidth        +
                                                   me._li._xLeft         - me._li._xNegativeShiftRTL +
                                                   me._li._xLineOverhang +
                                                   me._li._xRight);
        }

        if (   me._li._cch
            || (uiFlags & MEASURE_EMPTYLASTLINE)
           )
        {
            Assert(pliNew);
            // This innocent looking line is where we transfer
            // the calculated values to the permanent line array.
            pliNew->AssignLine(me._li);
        }
        
        // Align those sites which occur somewhere in the middle or at end of the line
        // (Those occurring at the start are handled in the above loop)
        if(   me._li._fHasAligned
           && me._cAlignedSites > me._cAlignedSitesAtBeginningOfLine)
        {
            // Position the measurer so that it points to the beginning of the line
            // excluding all the whitespace characters.
            LONG cch = pliNew->_cch - me.CchSkipAtBeginningOfLine();

            CTreePos *ptpOld = me.GetPtp();
            LONG cpOld = me.GetCp();
            
            me.Advance(-cch);

            AlignObjects(&me, &me._li, cch, FALSE,
                                   (uiFlags & MEASURE_BREAKATWORD) ? TRUE : FALSE,
                                   pxMinLineWidth ? TRUE : FALSE,
                                   _iNewFirst, *piLine, pyHeight, xWidth,
                                   pyAlignDescent, pxMaxLineWidth);

            me.SetPtp(ptpOld, cpOld);
            
            Assert(me._li == *(*this)[*piLine]);
            WHEN_DBG(pliNew = NULL);
        }

        if (   me._li._fHasFirstLetter
            && me._li._fHasFloatedFL
           )
        {
            AlignFirstLetter(&me, _iNewFirst, *piLine, pyHeight, pyAlignDescent, pNodeFormatting);
        }

        // NETSCAPE: Right-aligned sites are not normally counted in the maximum line width.
        //           However, the maximum line width should not be allowed to shrink below
        //           the minimum (which does include all left/right-aligned sites guaranteed
        //           to occur on a single line).
        if (pxMaxLineWidth && pxMinLineWidth)
        {
            *pxMaxLineWidth = max(*pxMaxLineWidth, *pxMinLineWidth);
        }

        if(me._pLS->HasChunks())
        {
            FixupChunks(me, piLine);
            pliNew = (*this)[*piLine];
            me._li = *pliNew;
        }
    }
    
    if (_marginInfo._fClearLeft || _marginInfo._fClearRight || _marginInfo._fAutoClear)
    {
        ClearObjects(&me._li, _iNewFirst, *piLine, pyHeight);

        // The calling function(s) expect to point to the last text line.
        while(*piLine >= 0)
        {
            pliNew = (*this)[*piLine];
            if(pliNew->IsTextLine())
                break;
            else
                (*piLine)--;
        }
        me._li = *pliNew;
    }
    else if (me._li._fForceNewLine)
    {
        *pyHeight += me._li._yHeight;
    }
    me.PseudoLineDisable();
    me._cchPreChars = 0;
    me._fMeasureFromTheStart = 0;
    me._pLS->_cchSkipAtBOL = 0;
    return TRUE;

err:
    me.PseudoLineDisable();
    return FALSE;
}

//+----------------------------------------------------------------------------
//
//  Member:   CRecalcLinePtr::ProcessAlignedSiteTasksAtBOB()
//
//  NOTE:     Print View specific !!! Should be called once for block 
//            (before any line is calculated) 
//
//  Synopsis: Process Site Tasks queue by measuring aligned sites.
//
//  Params:   see CRecalcLinePtr::CalcAlignedSitesAtBOL params.
//
//  Return:   nothing.
//
//-----------------------------------------------------------------------------
void 
CRecalcLinePtr::ProcessAlignedSiteTasksAtBOB(
      CLSMeasurer * pme,
      CLineFull   * pLineMeasured,
      UINT          uiFlags,
      INT         * piLine,
      LONG        * pyHeight,
      LONG        * pxWidth,
      LONG        * pyAlignDescent,
      LONG        * pxMaxLineWidth,
      BOOL        * pfClearMarginsRequired)
{
    CLayoutContext *pLayoutContext = _pci->GetLayoutContext();
    
    Assert( pLayoutContext 
        &&  pLayoutContext->ViewChain()
        &&  _pdp->LineCount() == 1);

    //  if this is print view and we are called for the first 
    //  line of a block, additional work may be needed
    CLayoutBreak *pLayoutBreak;

    pLayoutContext->GetLayoutBreak(_pdp->GetFlowLayoutElement(), &pLayoutBreak);
    if (   pLayoutBreak 
        && DYNCAST(CFlowLayoutBreak, pLayoutBreak)->HasSiteTasks())
    {
        CFlowLayoutBreak::CArySiteTask *pArySiteTask; 
        CFlowLayoutBreak               *pFlowLayoutBreak = DYNCAST(CFlowLayoutBreak, pLayoutBreak);

        pArySiteTask = pFlowLayoutBreak->GetSiteTasks();

        //  If there are Site Tasks, go ahead and process them 
        if (pArySiteTask)
        {
            int       i;
            int       cLimit = pArySiteTask->Size();
            long      cpSafe = pme->GetCp();

            for (i = 0; i < cLimit; ++i)
            {
                CFlowLayoutBreak::CSiteTask *pSiteTask;
                htmlControlAlign             atSite;

                pSiteTask = &((*pArySiteTask)[i]);
                // Adjust ls measurer
                pme->SetPtp(pSiteTask->_pTreeNode->GetBeginPos(), -1);

                Check(pme->GetCp() <= cpSafe);

                if (pme->GetCp() < cpSafe) // (olego) otherwise this site will be processed during CalcAlignedSitesAtBOL. 
                {
                    // if last time (previous block) the element was placed with offset (margin), 
                    // restore it here
                    atSite = pSiteTask->_pTreeNode->GetSiteAlign(LC_TO_FC(_pci->GetLayoutContext()));
                    if (atSite == htmlAlignLeft)
                    {
                        if (_marginInfo._xLeftMargin < pSiteTask->_xMargin)
                        {
                            _marginInfo._xLeftMargin = pSiteTask->_xMargin;
                        }
                    }
                    else if (atSite == htmlAlignRight)
                    {
                        if (_marginInfo._xRightMargin < pSiteTask->_xMargin)
                        {
                            _marginInfo._xRightMargin = pSiteTask->_xMargin;
                        }
                    }

                    //  Call CalcAlignedSitesAtBOLCore to process tasks
                    CalcAlignedSitesAtBOLCore(pme, pLineMeasured, uiFlags, piLine,
                                             pyHeight, pxWidth, pyAlignDescent,
                                             pxMaxLineWidth, pfClearMarginsRequired, 
                                             TRUE // Here we want only one element to be processed 
                                             );
                }
            }

            _marginInfo._fClearLeft  = pFlowLayoutBreak->_fClearLeft; 
            _marginInfo._fClearRight = pFlowLayoutBreak->_fClearRight; 
            _marginInfo._fAutoClear  = pFlowLayoutBreak->_fAutoClear; 

            pme->SetCp(cpSafe, NULL);
        }
    }
}                                        

//+----------------------------------------------------------------------------
//
//  Member:   CRecalcLinePtr::CalcAlignedSitesAtBOL()
//
//  Synopsis: Measures any aligned sites which are at the BOL.
//
//  Params:
//    prtp(i,o):          The position in the runs for the text
//    pLineMeasured(i,o): The line being measured
//    uiFlags(i):         The flags controlling the measurer behaviour
//    piLine(i,o):        The line before which all aligned lines are added.
//                           Incremented to reflect addition of lines.
//    pxWidth(i,o):       Contains the available width for the line. Aligned
//                           lines will decrease the available width.
//    pxMinLineWidth(o):  These two are passed directly to AlignObjects.
//    pxMaxLineWidth(o):
//
//  Return:     LONG    -   the no of character's to skip at the beginning of
//                          the line
//
//-----------------------------------------------------------------------------
LONG
CRecalcLinePtr::CalcAlignedSitesAtBOL(
      CLSMeasurer * pme,
      CLineFull   * pLineMeasured,
      UINT          uiFlags,
      INT         * piLine,
      LONG        * pyHeight,
      LONG        * pxWidth,
      LONG        * pyAlignDescent,
      LONG        * pxMaxLineWidth,
      BOOL        * pfClearMarginsRequired)
{
    CTreePos *ptp;

    ptp = pme->GetPtp();
    if (ptp->IsText() && ptp->Cch())
    {
        TCHAR ch = CTxtPtr(_pdp->GetMarkup(), pme->GetCp()).GetChar();
        CTreeNode *pNode = pme->CurrBranch();

        // Check to see whether this line begins with whitespace;
        // if it doesn't, or if it does but we're in a state where whitespace is significant
        // (e.g. inside a PRE tag), then by definition there are no aligned
        // sites at BOL (because there's something else there first).
        // Similar code is in CalcAlignedSitesAtBOLCore() for handling text
        // between aligned elements.

        if ( !IsWhite(ch) 
             || pNode->GetParaFormat(LC_TO_FC(_pci->GetLayoutContext()))->HasInclEOLWhite( SameScope(pNode, pme->_pFlowLayout->ElementContent()) ) )
        {
            *pfClearMarginsRequired = FALSE;
            return 0;
        }
    }
    
    return CalcAlignedSitesAtBOLCore(pme, pLineMeasured, uiFlags, piLine,
                                     pyHeight, pxWidth, pyAlignDescent,
                                     pxMaxLineWidth, pfClearMarginsRequired);
}

LONG
CRecalcLinePtr::CalcAlignedSitesAtBOLCore(
        CLSMeasurer *pme,
        CLineFull   *pLineMeasured,
        UINT         uiFlags,
        INT         *piLine,
        LONG        *pyHeight,
        LONG        *pxWidth,
        LONG        *pyAlignDescent,
        LONG        *pxMaxLineWidth,
        BOOL        *pfClearMarginsRequired, 
        BOOL         fProcessOnce)  // this parameter is added for print view support. It is TRUE when 
                                    // the function is called to process Site Tasks for the block. In this 
                                    // case we want only the first site to be processed.
{
    CFlowLayout *pFlowLayout = _pdp->GetFlowLayout();
    CElement    *pElementFL  = pFlowLayout->ElementContent();
    const        CCharFormat *pCF;              // The char format
    LONG         cpSave   = pme->GetCp();       // Saves the cp the measurer is at
    CTreePos    *ptpSave  = pme->GetPtp();
    BOOL         fAnyAlignedSiteMeasured;       // Did we measure any aligned site at all?
    CTreePos    *ptpLayoutLast;
    CTreePos    *ptp;
    LONG         cp;
    CTreeNode   *pNode;
    CElement    *pElement;
    BOOL         fInner;
    
    AssertSz(!(uiFlags & MEASURE_BREAKWORDS),
             "Cannot call CalcSitesAtBOL when we are hit testing!");

    AssertSz(!fProcessOnce || (_pci->GetLayoutContext() && _pci->GetLayoutContext()->ViewChain()), 
        "Improper usage of CalcAlignedSitesAtBOLCore parameters in non print view mode !!!");

    //
    // By default, do not clear margins
    //
    *pfClearMarginsRequired = FALSE;
    fAnyAlignedSiteMeasured = FALSE;

    pFlowLayout->GetContentTreeExtent(NULL, &ptpLayoutLast);
    ptp = ptpSave;
    cp  = cpSave;
    pNode = ptp->GetBranch();
    pElement = pNode->Element();
    pCF = pNode->GetCharFormat(LC_TO_FC(_pci->GetLayoutContext()));
    fInner = SameScope(pNode, pElementFL);
            
    for (;;)
    {
        pme->SetPtp(ptp, cp);

        if (ptp == ptpLayoutLast)
            break;

        if (ptp->IsPointer())
        {
            ptp = ptp->NextTreePos();
            continue;
        }

        if (ptp->IsNode())
        {
            pNode = ptp->Branch();
            pElement = pNode->Element();
            fInner = SameScope(pNode, pElementFL);
            if (ptp->IsEndNode())
                pNode = pNode->Parent();
	    if(pNode)
                pCF = pNode->GetCharFormat(LC_TO_FC(_pci->GetLayoutContext()));
	    else
                break;
        }

        //
        // NOTE(SujalP):
        // pCF should never be NULL since though it starts out as NULL, it should
        // be initialized the first time around in the code above. It has happened
        // in stress once that pCF was NULL. Hence the check for pCF and the assert.
        // (Bug 18065).
        //
        AssertSz(pNode && pElement && pCF, "None of these should be NULL");
        if (!(pNode && pElement && pCF))
            break;

        if (   !_fIsEditable
            && ptp->IsBeginElementScope()
            && pCF->IsDisplayNone()
           )
        {
            cp += pme->GetNestedElementCch(pNode->Element(), &ptp);
            cp -= ptp->GetCch();
        }
        else if (   ptp->IsBeginElementScope()
                 && pNode->ShouldHaveLayout()
                )
        {
            pme->_fHasNestedLayouts = TRUE;
            pLineMeasured->_fHasNestedRunOwner |= pNode->Element()->IsRunOwner();
            
            if (!pElement->IsInlinedElement(LC_TO_FC(_pci->GetLayoutContext())))
            {
                //
                // Absolutely positioned sites are measured separately
                // inside the measurer. They also count as whitespace and
                // hence we will continue looking for aligned sites after
                // them at BOL.
                //
                if (!pNode->IsAbsolute(LC_TO_FC(_pci->GetLayoutContext())))
                {
                    CLineCore *pLine;

                    //
                    // Mark the line which will contain the WCH_EMBEDDING as having
                    // an aligned site in it.
                    //
                    pLine = (*this)[*piLine];
                    pLine->_fHasAligned = TRUE;

                    //
                    // Measure the aligned site and create a line for it.
                    // AlignObjects returns the number of clear lines, so we need
                    // to add the number of clear lines + the aligned line that is
                    // inserted to *piLine to make *piLine point to the text line
                    // that contains the embedding characters for the aligned site.
                    //
                    *piLine += AlignObjects(pme, pLineMeasured, 1, TRUE,
                                            (uiFlags & MEASURE_BREAKATWORD) ? TRUE : FALSE,
                                            (uiFlags & MEASURE_MAXWIDTH)    ? TRUE : FALSE,
                                            _iNewFirst, *piLine, pyHeight, *pxWidth,
                                            pyAlignDescent, pxMaxLineWidth);

                    //
                    // This the now the next available line, because we just inserted
                    // a line for the aligned site.
                    //
                    (*piLine)++;

                    //
                    // Aligned objects change the available width for the line
                    //
                    *pxWidth = GetAvailableWidth();

                    //
                    // This is ONLY used for DD. Weird, does it need to be that special?
                    //
                    _xLeadAdjust = 0;

                    //
                    // Also update the xLeft and xRight for the next line
                    // to be inserted.
                    //
                    ApplyLineIndents(pNode, pLineMeasured, uiFlags, pme->_fPseudoElementEnabled);
                    
                    //
                    // Remember we measured an aligned site in this pass
                    //
                    fAnyAlignedSiteMeasured = TRUE;
                }

                cp += pme->GetNestedElementCch(pElement, &ptp);
                cp -= ptp->GetCch();
            }
            else
            {
                if (CheckForClear(pNode))
                {
                    *pfClearMarginsRequired = TRUE;
                }
                break;
            }
        }
        else if (ptp->IsText())
        {
            CTxtPtr tp(_pdp->GetMarkup(), cp);
            // NOTE: Cch() could return 0 here but we should be OK with that.
            LONG cch = ptp->Cch();
            BOOL fNonWhitePresent = FALSE;
            TCHAR ch;
            
            while (cch)
            {
                ch = tp.GetChar();
                //
                // These characters need to be treated like whitespace
                //
                if (!(   ch == _T(' ')
                      || (   InRange(ch, TEXT('\t'), TEXT('\r'))
                          && !pNode->GetParaFormat()->HasInclEOLWhite(
                                SameScope(pNode, pme->_pFlowLayout->ElementContent()))
                         )
                       )
                   )
                {
                    fNonWhitePresent = TRUE;
                    break;
                }
                cch--;
                tp.AdvanceCp(1);
            }
            if (fNonWhitePresent)
                break;
        }
        else if (   ptp->IsEdgeScope()
                 && pElement != pElementFL
                 && (   pFlowLayout->IsElementBlockInContext(pElement)
                     || pElement->Tag() == ETAG_BR
                    )
                )
        {
            break;
        }
        else if ( ptp->IsBeginElementScope() && CheckForClear(pNode) )
        {
            *pfClearMarginsRequired = TRUE;
            break;
        }

        if (fProcessOnce)
            break;
        
        //
        // Goto the next tree position
        //
        cp += ptp->GetCch();
        ptp = ptp->NextTreePos();
    }

    //
    // Restore the measurer to where it was when we came in
    //
    pme->SetPtp(ptpSave, cpSave);

    return fAnyAlignedSiteMeasured ? cp - cpSave : 0;
}

//+----------------------------------------------------------------------------
//
//  Member:     CRecalcLinePtr::CheckForClear()
//
//  Synopsis:   CalcBeforeSpace set's up _fClearLeft & _fClearRight on the
//              _marginInfo, if a pNode is passed the use its clear flags,
//              check if we need to clear based on margins.
//
//  Arguments:  pNode - (optional) can be null.
//
//  Returns: A bool indicating if clear is required.
//
//-----------------------------------------------------------------------------
BOOL
CRecalcLinePtr::CheckForClear(CTreeNode * pNode)
{
    BOOL fClearLeft;
    BOOL fClearRight;

    if (pNode)
    {
        const CFancyFormat * pFF = pNode->GetFancyFormat(LC_TO_FC(_pci->GetLayoutContext()));

        fClearLeft  = pFF->_fClearLeft;
        fClearRight = pFF->_fClearRight;
    }
    else
    {
        fClearLeft  = _marginInfo._fClearLeft;
        fClearRight = _marginInfo._fClearRight;
    }

    _marginInfo._fClearLeft  = _marginInfo._xLeftMargin && fClearLeft;
    _marginInfo._fClearRight = _marginInfo._xRightMargin && fClearRight;

    return _marginInfo._fClearLeft || _marginInfo._fClearRight;
}

//+----------------------------------------------------------------------------
//
//  Member:     CRecalcLinePtr::FixupChunks
//
//  Synopsis:   If the current line has multiple chunks in the line (caused by
//              relative chunks), then break the line into multiple lines that
//              form a single screen line and fix up justification.
//
//  REMINDER:   RightToLeft lines measure from the right. Therefore, the
//              chunks need to be handled accordingly.
//-----------------------------------------------------------------------------

void
CRecalcLinePtr::FixupChunks(CLSMeasurer &me, INT *piLine)
{
    CLSLineChunk * plc  = me._pLS->GetFirstChunk();
    CLineCore * pliT    = (*this)[*piLine];
    CLineFull li        = *pliT;
    LONG    cchLeft     = li._cch;
    LONG    xWidthLeft  = li._xWidth;
    LONG    xPos        = li._xLeft;    // chunk position. note: if any BiDi is involved, 
                                        // position is always taken from the chunk
    BOOL    fFirstLine  = TRUE;
    LONG    iFirstChunk = *piLine;
    
    BOOL    fBiDiLine   = FALSE;

    // if all we have is one chunk in the line, we dont need to create
    // additional lines
    if(plc->_cch >= cchLeft)
    {
        li._fRelative            = me._pLS->_pElementLastRelative != NULL;
        li._fPartOfRelChunk      = TRUE;
        _pdp->NoteMost(&li);
        return;
    }

    while(plc || cchLeft)
    {
        BOOL fLastLine = !plc || cchLeft <= plc->_cch;
        CLineFull lifNew;

        // get x position from plc (if available)
        if (plc)
        {
            if (!plc->_fRTLChunk != !li.IsRTLLine())
                fBiDiLine = TRUE;
            
            // limit xPos by line width (right-aligned lines may have hanging white space)
            LONG xPosNew = li._xLeft + min(li._xWidth, plc->_xLeft);
#if DBG==1
            // Assert that in strictly LTR case, current xPos matches the saved chunk position
            // TODO RTL 112514: make xPos calculation debug-only (when it works)
            AssertSz(li.IsRTLLine() || fBiDiLine || xPos == xPosNew
                     || !IsTagEnabled(tagDebugRTL), // TODO RTL 112514: this fires in some LTR cases
                     "chunk position doesn't match accumulated widh");
#endif

            xPos = xPosNew;
        }
        else
        {
            AssertSz(xWidthLeft <= 0 || !IsTagEnabled(tagDebugRTL), 
                     "no plc for a chunk, and it is not a trailing empty chunk"); 
        }

        lifNew = li;
        lifNew._xLeft = xPos;
            
        if(!fFirstLine)
        {
            pliT = InsertLine(++(*piLine));
            if (!pliT)
                break;

            // TODO RTL 112514: will bullets work with mixed-flow positioned lines?
            lifNew._fHasBulletOrNum  = FALSE;
            lifNew._fFirstFragInLine = FALSE;
        }
        else
        {
            li.ReleaseOtherInfo();
            lifNew._iLOI = -1;
        }

        lifNew._cch                  = min(cchLeft, long(plc ? plc->_cch : cchLeft));
        lifNew._xWidth               = plc ? min(long(plc->_xWidth), xWidthLeft) : xWidthLeft;
        lifNew._fRelative            = plc ? plc->_fRelative : me._pLS->_pElementLastRelative != NULL;
        lifNew._fSingleSite          = plc ? plc->_fSingleSite : me._pLS->_fLastChunkSingleSite;
        lifNew._fPartOfRelChunk      = TRUE;
        lifNew._fHasEmbedOrWbr       = li._fHasEmbedOrWbr;

        // TODO RTL 112514:    First/last chunks must have correct xLeft, xRight, fCleanBefore, etc.
        //                     Calculations like CalcRectsOfRangeOnLine depend on that.
        //                     It is unlcear to me if this must be true for first/last rather or
        //                     leftmost/rightmost. Both seem to be unnecessary complex. Why can't all
        //                     chunks have same flags and consistent offsets? The chunks are merely duplicates
        //                     of the container line, nothing is important there beyond offset and width.
        
        if(fLastLine) 
        {
            lifNew._cchWhite         = min(lifNew._cch, long(li._cchWhite));
            lifNew._xWhite           = min(lifNew._xWidth, long(li._xWhite));
            lifNew._xLineOverhang    = li._xLineOverhang;
            lifNew._fClearBefore     = li._fClearBefore;
            lifNew._fClearAfter      = li._fClearAfter;
            lifNew._fForceNewLine    = li._fForceNewLine;
            lifNew._fHasEOP          = li._fHasEOP;
            lifNew._fHasBreak        = li._fHasBreak;

            // TODO RTL 112514:
            //                     I would suppose that _xLineWidth should 
            //                     always equal to conainer line, but some code
            //                     elsewhere only expects that from the last fragment.
            //                     If a middle fragment has width that matches container width,
            //                     it causes line borders to ignore right margin.
            lifNew._xLineWidth       = li._xLineWidth;

            // TODO RTL 112514:
            //                     pure LTR case benefits from _xRight taken from original line
            //                     In other cases, we need to something trickier, and it is not quite working yet
            if(!li.IsRTLLine() && !fBiDiLine)
                lifNew._xRight       = li._xRight;
            else
            {
                // calculate _xRight to match line width
                // TODO RTL 112514:
                //                     this may not work in tables
                //                     (because _xLineWidth is very big during min/max pass)
                lifNew._xRight       = 0;
                lifNew._xRight       = lifNew._xLineWidth - lifNew.CalcLineWidth();
                Assert(lifNew._xRight >= 0 || !IsTagEnabled(tagDebugRTL));
            }
        }
        else
        {
            lifNew._cchWhite         = 0;
            lifNew._xWhite           = 0;
            lifNew._xLineOverhang    = 0;
            lifNew._fClearBefore     = FALSE;
            lifNew._fClearAfter      = FALSE;
            lifNew._fForceNewLine    = FALSE;
            lifNew._fHasEOP          = FALSE;
            lifNew._fHasBreak        = FALSE;

            lifNew._xRight       = 0;
            lifNew._xLineWidth   = lifNew.CalcLineWidth();
        }

        if (   !fFirstLine
            && _ptpStartForListItem
           )
        {
            LONG cpLIStart = _ptpStartForListItem->GetCp();
            LONG cpThisLine = me.GetCp() - cchLeft;
            LONG cchThisLine = lifNew._cch;

            if (   cpLIStart >= cpThisLine
                && cpLIStart < cpThisLine + cchThisLine
               )
            {
                CLineCore * pli0 = (*this)[iFirstChunk];

                lifNew._fHasBulletOrNum  = pli0->_fHasBulletOrNum;
                pli0->_fHasBulletOrNum  = FALSE;

                _ptpStartForListItem = NULL;
            }
        }
        fFirstLine  =  FALSE;
        plc         =  plc ? plc->_plcNext : NULL;
        xPos        =  lifNew._xLineWidth;  // note: unused unless all LTR
        xWidthLeft  -= lifNew._xWidth;
        cchLeft     -= lifNew._cch;
        
        _pdp->NoteMost(&lifNew);

        pliT->AssignLine(lifNew);
    }
}

//+----------------------------------------------------------------------------
//
//  Member:     CRecalcLinePtr::CalcParagraphSpacing
//
//  Synopsis:   Compute paragraph spacing for the current line
//
//-----------------------------------------------------------------------------
CTreeNode *
CRecalcLinePtr::CalcParagraphSpacing(
    CLSMeasurer *pMe,
    BOOL         fFirstLineInLayout)
{
    CTreePos *ptp = pMe->GetPtp();
    CTreeNode *pNode;
    
    Assert(   !ptp->IsBeginNode()
           || !_pdp->GetFlowLayout()->IsElementBlockInContext(ptp->Branch()->Element())
           || !ptp->Branch()->Element()->IsInlinedElement()
           || pMe->_li._fFirstInPara
           || ptp->GetBranch()->Element()->IsOverlapped()
          );
    
    // no bullet on the line
    pMe->_li._fHasBulletOrNum = FALSE;

    if (_fMoveBulletToNextLine)
    {
        pMe->_li._fHasBulletOrNum = TRUE;
        _fMoveBulletToNextLine = FALSE;
        _ptpStartForListItem = pMe->GetPtp();
    }
    
    // Reset these flags for every line that we measure.
    _fNoMarginAtBottom = FALSE;
    
    // Only interesting for the first line of a paragraph.
    if (pMe->_li._fFirstInPara || pMe->_fLastWasBreak)
    {
        ptp = CalcBeforeSpace(pMe, fFirstLineInLayout);
        pMe->_li._yBeforeSpace = _lTopPadding + _lNegSpace + _lPosSpace;

        if (_pci->_smMode == SIZEMODE_MMWIDTH)
        {
            DWORD uTextAlignLast = ptp->GetBranch()->GetParaFormat(LC_TO_FC(_pci->GetLayoutContext()))->_uTextAlignLast;

            if (    uTextAlignLast != styleTextAlignLastNotSet 
                &&  uTextAlignLast != styleTextAlignLastAuto    )
            {
                _pdp->SetLastLineAligned();
            }
        }

        //
        //  pre para space adjustment for print preview 
        //
        {
            CFlowLayout * pFlowLayout = _pdp->GetFlowLayout();
            Assert(pFlowLayout);

            if (pFlowLayout->ElementCanBeBroken())
            {
                CLayoutContext * pLayoutContext = pFlowLayout->LayoutContext();

                if (pLayoutContext && pLayoutContext->ViewChain())
                {
                    // adjust the Current y.
                    pMe->_pci->_yConsumed += pMe->_li._yBeforeSpace;
                }
            }
        }
    }
    // Not at the beginning of a paragraph, we have no interline spacing.
    else
    {
        pMe->_li._yBeforeSpace = 0;
    }
    if(ptp)
        pNode = ptp->GetBranch();
    else
        return NULL;
    pMe->MeasureSetPF(pNode->GetParaFormat(LC_TO_FC(_pci->GetLayoutContext())),
                      SameScope(pNode, _pdp->GetFlowLayout()->ElementContent()),
                      TRUE);

    return pNode; // formatting node
}

//+----------------------------------------------------------------------------
//
//  Member:     CRecalcLinePtr::SetupMeasurerForBeforeSpace
//
//  Synopsis:   Setup the measurer so that it has all the post space info collected
//              from the previous line. This function is called only ONCE when
//              per recalclines loop. Subsequenlty we keep then spacing in sync
//              as we are measuring the lines.
//
//  Returns:    Nothing
//
//-----------------------------------------------------------------------------

void
CRecalcLinePtr::SetupMeasurerForBeforeSpace(CLSMeasurer *pMe, LONG yHeight)
{
    CFlowLayout  *pFlowLayout = _pdp->GetFlowLayout();
    CElement     *pElementFL  = pFlowLayout->ElementContent();
    LONG          cpSave      = pMe->GetCp();
    CTreePos     *ptp;
    CTreeNode    *pNode;

    INSYNC(pMe);

    ResetPosAndNegSpace();
    
    _pdp->EndNodeForLine(pMe->GetCp(), pMe->GetPtp(), _pci, NULL, &ptp, &pMe->_pLS->_pNodeForAfterSpace);

    if (   ptp != pMe->GetPtp()
        || pMe->_pLS->_pNodeForAfterSpace
       )
    {
        pMe->SetPtp(ptp, -1);
    
        //
        // Having gone back to a point where there is some text or a layout(which
        // effectively means some text) we compute the "after" space. The point
        // which we go back to is effectively the point at which we would have
        // stopped measuring the previous line.
        //
        CalcAfterSpace(pMe, yHeight == 0, cpSave);
    }
    
    //
    // Be sure that calc after space gets us at the beginning of the
    // current line. If it leaves us before the current line then there is a
    // _VERY_ good chance that we will end up with more characters in the line
    // array than there are in the backing story.
    //
    Assert(pMe->GetCp() == cpSave);

    // initialize left and right padding & borderspace for parent block elements
    _xPadLeft = _xPadRight = _xBordLeft = _xBordRight = 0;
    _yPadTop = _yPadBottom = _yBordTop = _yBordBottom = 0;
    _xBordLeftPerLine = _xBordRightPerLine = _xPadLeftPerLine = _xPadRightPerLine = 0;

    pNode     = pMe->CurrBranch();

    // Measurer can be initialized for any line in the line array, so
    // compute the border and padding for all the block elements that
    // are currently in scope.
    if(DifferentScope(pNode, pElementFL))
    {
        CDoc      * pDoc = pFlowLayout->Doc();
        CTreeNode * pNodeTemp;
        CElement  * pElement;

        pNodeTemp = pMe->GetPtp()->IsBeginElementScope()
                        ? pNode->Parent()
                        : pNode;

        while(   pNodeTemp 
              && DifferentScope(pNodeTemp, pElementFL))
        {
            pElement = pNodeTemp->Element();
 
            if(     !pNodeTemp->ShouldHaveLayout()
                &&   pNodeTemp->GetCharFormat()->HasPadBord(FALSE)
                &&   pFlowLayout->IsElementBlockInContext(pElement))
            {
                const CFancyFormat * pFF = pNodeTemp->GetFancyFormat();
                const CCharFormat  * pCF = pNodeTemp->GetCharFormat();
                LONG lFontHeight = pCF->GetHeightInTwips(pDoc);
                BOOL fNodeVertical = pCF->HasVerticalLayoutFlow();
                BOOL fWritingModeUsed = pCF->_fWritingModeUsed;

                if ( !pElement->_fDefinitelyNoBorders )
                {
                    CBorderInfo borderinfo;

                    pElement->_fDefinitelyNoBorders =
                        !GetBorderInfoHelper( pNodeTemp, _pci, &borderinfo, GBIH_NONE );
                    if ( !pElement->_fDefinitelyNoBorders )
                    {
                        _xBordLeftPerLine  += borderinfo.aiWidths[SIDE_LEFT];
                        _xBordRightPerLine += borderinfo.aiWidths[SIDE_RIGHT];
                    }
                }

                _xPadLeftPerLine  += pFF->GetLogicalPadding(SIDE_LEFT, fNodeVertical, fWritingModeUsed).XGetPixelValue(
                                        _pci,
                                        _pci->_sizeParent.cx, 
                                        lFontHeight);
                _xPadRightPerLine += pFF->GetLogicalPadding(SIDE_RIGHT, fNodeVertical, fWritingModeUsed).XGetPixelValue(
                                        _pci,
                                        _pci->_sizeParent.cx, 
                                        lFontHeight);
            }
            pNodeTemp = pNodeTemp->Parent();
        }

        _xBordLeft  = _xBordLeftPerLine;
        _xBordRight = _xBordRightPerLine;
        _xPadLeft   = _xPadLeftPerLine;
        _xPadRight  = _xPadRightPerLine;
    }

    INSYNC(pMe);
    return;
}

//+----------------------------------------------------------------------------
//
//  Member:     CRecalcLinePtr::CalcAfterSpace
//
//  Synopsis:   This function computes the after space of the line and adds
//              on the extra characters at the end of the line. Also positions
//              the measurer correctly (to the ptp at the ptp belonging to
//              the first character in the next line).
//
//  Returns:    Nothing
//
//-----------------------------------------------------------------------------

void
CRecalcLinePtr::CalcAfterSpace(CLSMeasurer *pMe, BOOL fFirstLineInLayout, LONG cpMax)
{
    CFlowLayout  *pFlowLayout = _pdp->GetFlowLayout();
    CTreeNode    *pNode;
    CElement     *pElement;
    CTreePos     *ptpStop;
    CTreePos     *ptp;
    CUnitValue    cuv;
    LONG          cpCurrent;
    BOOL          fConsumedFirstOne = pMe->_fEndSplayNotMeasured;
    BOOL          fContinueLooking = TRUE;
    BOOL          fConsumedBlockElement = FALSE;
    LONG          cchInPtp;
    
    INSYNC(pMe);
    
    if (pMe->_li._fForceNewLine)
    {
        ResetPosAndNegSpace();
    }

    if (pMe->_pLS->_pNodeForAfterSpace)
    {
        BOOL fConsumed;
        CollectSpaceInfoFromEndNode(pMe, pMe->_pLS->_pNodeForAfterSpace, fFirstLineInLayout,
                                    FALSE, &fConsumed);
    }
    
    Assert(_yPadBottom == 0);
    Assert(_yBordBottom == 0);

    ptpStop = pMe->_pLS->_treeInfo._ptpLayoutLast;
#if DBG==1
    {
        CTreePos *ptpStartDbg;
        CTreePos *ptpStopDbg;
        pFlowLayout->GetContentTreeExtent(&ptpStartDbg, &ptpStopDbg);
        Assert(ptpStop == ptpStopDbg);
    }
#endif
    
    for (cpCurrent = pMe->GetCp(), ptp = pMe->GetPtp();
         ptp && cpCurrent < cpMax && fContinueLooking;
         ptp = ptp->NextTreePos())
    {
        cchInPtp = ptp->GetCch();
        if (cchInPtp == 0)
        {
            Assert(   ptp->IsPointer()
                   || ptp->IsText()
                   || !ptp->IsEdgeScope()
                  );
            continue;
        }

        if (ptp == ptpStop)
            break;

        Assert(cpCurrent >= ptp->GetCp() && cpCurrent < ptp->GetCp() + ptp->GetCch());
        
        if (ptp->IsNode())
        {
            Assert(ptp->IsEdgeScope());
            pNode = ptp->Branch();
            pElement = pNode->Element();
            const CCharFormat *pCF = pNode->GetCharFormat(LC_TO_FC(_pci->GetLayoutContext()));
            
            if (ptp->IsEndNode())
            {
                //
                // NOTE(SujalP):
                // If we had stopped because we had a line break then I cannot realistically
                // consume the end block element on this line. This would break editing when
                // the user hit shift-enter to put in a BR -- the P tag I was under has to
                // end in the next line since that is where the user wanted to see the caret.
                // IE bug 44561
                //
                if (pMe->_fLastWasBreak && _fIsEditable)
                    break;
                
                if (pFlowLayout->IsElementBlockInContext(pElement))
                {
                    const CFancyFormat * pFF = pNode->GetFancyFormat();
                    
                    pMe->_li._fHasEOP = TRUE;

                    ENI_RETVAL retVal = CollectSpaceInfoFromEndNode(pMe, pNode, fFirstLineInLayout,
                                                                    FALSE, &fConsumedBlockElement);
                    if (retVal == ENI_CONSUME_TERMINATE)
                    {
                        fContinueLooking = FALSE;
                    }
                    else if (retVal == ENI_TERMINATE)
                    {
                        fContinueLooking = FALSE;
                        break;
                    }

                    _fNoMarginAtBottom =    pElement->Tag() == ETAG_P
                                         && pElement->_fExplicitEndTag
                                         && !pFF->HasExplicitLogicalMargin(SIDE_BOTTOM, pCF->HasVerticalLayoutFlow(), pCF->_fWritingModeUsed);

                }
                // Else do nothing, just continue looking ahead

                // Just verifies that an element is block within itself.
                Assert(ptp != ptpStop);
            }
            else if (ptp->IsBeginNode())
            {
                if (pCF->IsDisplayNone())
                {
                    LONG cchHidden = pMe->GetNestedElementCch(pElement, &ptp);
                    
                    // Ptp gets updated inside GetNestedElementCch, so be sure to
                    // update cchInPtp too
                    cchInPtp = ptp->GetCch();

                    // Since we update the count below for everything, lets dec the
                    // count over here.
                    cchHidden -= cchInPtp;

                    // Add the characters to the line.
                    pMe->_li._cch += cchHidden;

                    // Also add them to the whitespace of the line
                    pMe->_li._cchWhite += (SHORT)cchHidden;

                    // Add to cpCurrent
                    cpCurrent += cchHidden;

                }
                
                // We need to stop when we see a new block element
                else if (pFlowLayout->IsElementBlockInContext(pElement))
                {
                    pMe->_li._fHasEOP = TRUE;
                    break;
                }

                // Or a new layout (including aligned ones, since these
                // will now live on lines of their own.
                else if (pNode->ShouldHaveLayout(LC_TO_FC(_pci->GetLayoutContext())) || pNode->IsRelative(LC_TO_FC(_pci->GetLayoutContext())))
                    break;
                else if (pElement->Tag() == ETAG_BR)
                    break;
                else if (!pNode->Element()->IsNoScope())
                    break;
            }
            
            if (_fIsEditable )
            {
                if (fConsumedFirstOne && ptp->ShowTreePos())
                    break;
                else
                    fConsumedFirstOne = TRUE;
            }
        }
        else
        {
            Assert(ptp->IsText() && ptp->Cch() != 0);
            break;
        }

        Assert(cchInPtp == ptp->GetCch());
        
        // Add the characters to the line.
        pMe->_li._cch += cchInPtp;

        // Also add them to the whitespace of the line
        Assert((LONG)pMe->_li._cchWhite + cchInPtp < SHRT_MAX);
        pMe->_li._cchWhite += (SHORT)cchInPtp;

        // Add to cpCurrent
        cpCurrent += cchInPtp;
    }

    pMe->_fEmptyLineForPadBord = !fContinueLooking;

    // The last paragraph of a layout shouldn't have this flag set
    if( ptp == ptpStop )
        pMe->_li._fHasEOP = FALSE;
        
    if (pMe->GetPtp() != ptp)
        pMe->SetPtp(ptp, cpCurrent);

    INSYNC(pMe);
}


//+----------------------------------------------------------------------------
//
//  Member:     CRecalcLinePtr::CalcBeforeSpace
//
//  Synopsis:   This function computes the before space of the line and remembers
//              the characters it has gone past in _li._cch.
//
//              Also computes border and padding (left and right too!) for
//              elements coming into scope.
//
//  Returns:    Nothing
//
//-----------------------------------------------------------------------------

CTreePos *
CRecalcLinePtr::CalcBeforeSpace(CLSMeasurer *pMe, BOOL fFirstLineInLayout)
{
    const CFancyFormat * pFF;
    const CParaFormat  * pPF;
    const CCharFormat  * pCF;
    CFlowLayout  *pFlowLayout = _pdp->GetFlowLayout();
    CDoc         *pDoc        = pFlowLayout->Doc();
    CTreeNode    *pNode       = NULL;
    CElement     *pElement;
    CTreePos     *ptpStop;
    CTreePos     *ptp;
    CTreePos     *ptpFormatting = NULL;
    BOOL          fSeenBeginBlockTag = FALSE;
    BOOL          fContinueLooking = TRUE;
    
    pMe->_fSeenAbsolute = FALSE;
    ptpStop = pMe->_pLS->_treeInfo._ptpLayoutLast;
#if DBG==1
    {
        CTreePos *ptpStartDbg;
        CTreePos *ptpStopDbg;
        pFlowLayout->GetContentTreeExtent(&ptpStartDbg, &ptpStopDbg);
        Assert(ptpStop == ptpStopDbg);
    }
#endif

    _xBordLeftPerLine = _xBordRightPerLine = _xPadLeftPerLine = _xPadRightPerLine = 0;
    pMe->_fEmptyLineForPadBord = FALSE;
    
    if (fFirstLineInLayout)
    {
        LONG lPadding[SIDE_MAX];
        _pdp->GetPadding(_pci, lPadding, _pci->_smMode == SIZEMODE_MMWIDTH);
        if (pFlowLayout->ElementContent()->TestClassFlag(CElement::ELEMENTDESC_TABLECELL))
        {
            _lTopPadding = lPadding[SIDE_TOP];
        }
        else
        {
            _lPosSpace = max(_lPosSpace, lPadding[SIDE_TOP]);
            _lNegSpace = min(_lNegSpace, lPadding[SIDE_TOP]);
            _lTopPadding = 0;
        }
    }
    else
        _lTopPadding = 0;

    for (ptp = pMe->GetPtp(); fContinueLooking; ptp = ptp->NextTreePos())
    {
	if(!ptp)
            break;

        if (ptp->IsPointer())
            continue;

        if (ptp == ptpStop)
            break;
        
        if (ptp->IsNode())
        {
            if (_fIsEditable && ptp->ShowTreePos())
                pMe->_fMeasureFromTheStart = TRUE;

            pNode = ptp->Branch();
            pElement = pNode->Element();
            BOOL fShouldHaveLayout = pNode->ShouldHaveLayout(LC_TO_FC(_pci->GetLayoutContext()));

            if (pNode->HasInlineMBP(LC_TO_FC(_pci->GetLayoutContext())))
                pMe->_fMeasureFromTheStart = TRUE;

            if (ptp->IsEndElementScope())
            {
                if(pNode->IsRelative() && !fShouldHaveLayout)
                    pMe->_fRelativePreChars = TRUE;

                if (pFlowLayout->IsElementBlockInContext(pElement))
                {
                    //
                    // If we encounter a break on empty block end tag, then we should
                    // give vertical space otherwise a <X*></X> where X is a block element
                    // will not produce any vertical space. (Bug 45291).
                    //
                    if (  pElement->_fBreakOnEmpty
                        && (   fSeenBeginBlockTag
                            || (   pMe->_fLastWasBreak
                                && _fIsEditable
                               )
                           )
                       )
                    {
                        break;
                    }

                    if (pMe->_fSeenAbsolute)
                        break;
                    
                    //
                    // If we are at an end LI it means that we have an
                    // empty LI for which we need to create an empty
                    // line. Hence we just break out of here. We will
                    // fall into the measurer with the ptp positioned
                    // at the end splay. The measurer will immly bail
                    // out, creating an empty line. CalcAfterSpace will
                    // go and then add the node char for the end LI to
                    // the line.
                    //
                    if (   IsGenericListItem(pNode)
                        && (   pMe->_li._fHasBulletOrNum
                            || (   pMe->_fLastWasBreak
                                && _fIsEditable
                               )
                           )
                       )
                    {
                        break;
                    }
                    
                    //
                    // Collect space info from the end node *only* if the previous
                    // line does not end in a BR. If it did, then the end block
                    // tag after does not contribute to the inter-paraspacing.
                    // (Remember, that a subsequent begin block tag will still
                    // contribute to the spacing!)
                    //
                    else if (!_fIsEditable || !pMe->_fLastWasBreak)
                    {
                        ENI_RETVAL retVal =
                               CollectSpaceInfoFromEndNode(pMe, pNode, fFirstLineInLayout, TRUE, NULL);
                        if (retVal == ENI_CONSUME_TERMINATE)
                        {
                            fContinueLooking = FALSE;
                        }
                        else if (retVal == ENI_TERMINATE)
                        {
                            pMe->_li._fIsPadBordLine = TRUE;
                            fContinueLooking = FALSE;
                            break;
                        }
                    }
                }
                // Else do nothing, just continue looking ahead

                // Just verifies that an element is block within itself.
                Assert(ptp != ptpStop);
            }
            else if (ptp->IsBeginElementScope())
            {
                pCF = pNode->GetCharFormat(LC_TO_FC(_pci->GetLayoutContext()));
                pFF = pNode->GetFancyFormat(LC_TO_FC(_pci->GetLayoutContext()));
                pPF = pNode->GetParaFormat(LC_TO_FC(_pci->GetLayoutContext()));
                BOOL fNodeVertical = pCF->HasVerticalLayoutFlow();
                BOOL fWritingModeUsed = pCF->_fWritingModeUsed;
                
                if (pCF->IsDisplayNone())
                {
                    // The extra one is added in the normal processing.
                    pMe->_li._cch += pMe->GetNestedElementCch(pElement, &ptp);
                    pMe->_li._cch -= ptp->GetCch();
                }
                else if (pElement->Tag() == ETAG_BR)
                {
                    break;
                }
                else
                {

                    BOOL fBlockElement = pFlowLayout->IsElementBlockInContext(pElement);

                    if(pNode->IsRelative(LC_TO_FC(_pci->GetLayoutContext())) && !fShouldHaveLayout)
                        pMe->_fRelativePreChars = TRUE;

                    if(     (pFF->_fClearLeft || pFF->_fClearRight)
                       // IE6 #32464
                       // Setting this bit will cause a cleared element to go searching for a text
                       // line anchor.  ON a new page, this won't exist, and the clear info is already
                       // implicit in the page break.                   
                       &&  !(   _pci->GetLayoutContext() 
                            &&  _pci->GetLayoutContext()->ViewChain()
                            &&  !_pci->_fHasContent )
                       )
                    {
                        _marginInfo._fClearLeft  |= pFF->_fClearLeft;
                        _marginInfo._fClearRight |= pFF->_fClearRight;
                    }

                    if (   fBlockElement
                        && pElement->IsInlinedElement())
                    {
                        fSeenBeginBlockTag = TRUE;
                        
                        if (pMe->_fSeenAbsolute)
                            break;
                        
                        LONG lFontHeight = pCF->GetHeightInTwips(pDoc);

                        if (pElement->HasFlag(TAGDESC_LIST))
                        {
                            Assert(pElement->IsBlockElement(LC_TO_FC(_pci->GetLayoutContext())));
                            if (pMe->_li._fHasBulletOrNum)
                            {
                                ptpFormatting = ptp;
                                
                                do
                                {
                                    ptpFormatting = ptpFormatting->PreviousTreePos();
                                } while (ptpFormatting->GetCch() == 0);

                                break;
                            }
                        }

                        //
                        // NOTE(SujalP): Bug 38806 points out a problem where an
                        // abs pos'd LI does not have a bullet follow it. To fix that
                        // one we decided that we will _not_ draw the bullet for LI's
                        // with layout (&& !fHasLayout). However, 61373 and its dupes
                        // indicate that this is overly restrictive. So we will change
                        // this case and not draw a bullet for only abspos'd LI's.
                        //
                        else if (   IsListItem(pNode)
                                 && !pNode->IsAbsolute()
                                )
                        {
                            Assert(pElement->IsBlockElement(LC_TO_FC(_pci->GetLayoutContext())));
                            pMe->_li._fHasBulletOrNum = TRUE;
                            _ptpStartForListItem = ptp;
                        }

                        // if a dd is comming into scope and is a
                        // naked DD, then compute the first line indent
                        if(     pElement->Tag() == ETAG_DD
                            &&  pPF->_fFirstLineIndentForDD)
                        {
                            CUnitValue cuv;
                        
                            cuv.SetPoints(LIST_INDENT_POINTS);
                            _xLeadAdjust += cuv.XGetPixelValue(_pci, 0, 1);
                        }

                        // if a block element is comming into scope, it better be
                        // the first line in the paragraph.
                        Assert(pMe->_li._fFirstInPara || pMe->_fLastWasBreak);
                        pMe->_li._fFirstInPara = TRUE;
                        
                        // compute padding and border height for the elements comming
                        // into scope
                        if(     !fShouldHaveLayout
                            &&  pCF->HasPadBord(FALSE))
                        {
                            LONG yPadTop;
                            const CUnitValue & cuvPaddingLeft  = pFF->GetLogicalPadding(SIDE_LEFT, fNodeVertical, fWritingModeUsed);
                            const CUnitValue & cuvPaddingRight = pFF->GetLogicalPadding(SIDE_RIGHT, fNodeVertical, fWritingModeUsed);

                            if ( !pElement->_fDefinitelyNoBorders )
                            {
                                CBorderInfo borderinfo;

                                pElement->_fDefinitelyNoBorders = !GetBorderInfoHelper( pNode, _pci, &borderinfo, GBIH_NONE );
                                if ( !pElement->_fDefinitelyNoBorders )
                                {
                                    // If the blockelement has any border (or padding) and the
                                    // top padding is non zero then we need to
                                    // create a line to draw the border. The line
                                    // will just contain the start of the block element.
                                    // Similar thing happens at the end of the block element.
                                    if (borderinfo.aiWidths[SIDE_TOP])
                                    {
                                        fContinueLooking = FALSE;
                                        _yBordTop      += borderinfo.aiWidths[SIDE_TOP];
                                    }
                                    _xBordLeftPerLine  += borderinfo.aiWidths[SIDE_LEFT];
                                    _xBordRightPerLine += borderinfo.aiWidths[SIDE_RIGHT];
                                }
                            }

                            yPadTop = pFF->GetLogicalPadding(SIDE_TOP, fNodeVertical, fWritingModeUsed).YGetPixelValue(
                                                    _pci,
                                                    _pci->_sizeParent.cx, 
                                                    lFontHeight);
                            if (yPadTop)
                            {
                                fContinueLooking = FALSE;
                                _yPadTop += yPadTop;
                            }
                            
                            _xPadLeftPerLine  += cuvPaddingLeft.XGetPixelValue(_pci, _pci->_sizeParent.cx, lFontHeight);
                            _xPadRightPerLine += cuvPaddingRight.XGetPixelValue(_pci, _pci->_sizeParent.cx, lFontHeight);
                                                    
                            // If we have horizontal padding in percentages, flag the display
                            // so it can do a full recalc pass when necessary (e.g. parent width changes)
                            // Also see ApplyLineIndents() where we do this for horizontal indents.
                            if (cuvPaddingLeft.IsPercent() || cuvPaddingRight.IsPercent())
                            {
                                _pdp->_fContainsHorzPercentAttr = TRUE;
                            }
                        }

                        //
                        // CSS attributes page break before/after support.
                        // There are two mechanisms that add to provide full support: 
                        // 1. CRecalcLinePtr::CalcBeforeSpace() and CRecalcLinePtr::CalcAfterSpace() 
                        //    is used to set CLineCore::_fPageBreakBefore/After flags only(!) for 
                        //    nested elements which have no their own layout (i.e. paragraphs). 
                        // 2. CEmbeddedILSObj::Fmt() sets CLineCore::_fPageBreakBefore for nested 
                        //    element with their own layout that are NOT allowed to break (always) 
                        //    and for nested elements with their own layout that ARE allowed to 
                        //    break if this is the first layout in the view chain. 
                        //
                        if (   // print view 
                               _pci->GetLayoutContext() 
                            && _pci->GetLayoutContext()->ViewChain() 
                               // and element is nested element without a layout
                            && !fShouldHaveLayout    
                            )
                        {
                            // does any block elements comming into scope force a
                            // page break before this line
                            if (GET_PGBRK_BEFORE(pFF->_bPageBreaks))
                            {
                                CLayoutBreak *  pLayoutBreak;

                                pMe->_li._fPageBreakBefore = TRUE;
                                _pci->_fPageBreakLeft  |= IS_PGBRK_BEFORE_OF_STYLE(pFF->_bPageBreaks, stylePageBreakLeft); 
                                _pci->_fPageBreakRight |= IS_PGBRK_BEFORE_OF_STYLE(pFF->_bPageBreaks, stylePageBreakRight); 

                                _pci->GetLayoutContext()->GetEndingLayoutBreak(pFlowLayout->ElementOwner(), &pLayoutBreak);
                                if (pLayoutBreak)
                                {
                                    DYNCAST(CFlowLayoutBreak, pLayoutBreak)->_pElementPBB = pElement;
                                }
                            }
                        }

                        // If we're the first line in the scope, we only care about our
                        // pre space if it has been explicitly set.
                        if ((   !pMe->_li._fHasBulletOrNum
                             && !fFirstLineInLayout
                            )
                            || pFF->HasExplicitLogicalMargin(SIDE_TOP, fNodeVertical, fWritingModeUsed)
                           )
                        {
                            // If this is in a PRE block, then we have no
                            // interline spacing.
                            if (!(   pNode->Parent()
                                  && pNode->Parent()->GetParaFormat(LC_TO_FC(_pci->GetLayoutContext()))->HasPre(FALSE)
                                 )
                               )
                            {
                                LONG lTemp;

                                lTemp = pFF->_cuvSpaceBefore.YGetPixelValue(_pci,
                                                           _pci->_sizeParent.cx,
                                                           lFontHeight);

                                // Maintain the positives.
                                _lPosSpace = max(lTemp, _lPosSpace);

                                // Keep the negatives separately.
                                _lNegSpace =  min(lTemp, _lNegSpace);
                            }
                        }
                    }
                    else if (!fBlockElement)
                    {
                        if (pCF->_fHasInlineBg)
                        {
                            pMe->_fMeasureFromTheStart = TRUE;
                        }
                    }

                    //
                    // If we have hit a nested layout then we quit so that it can be measured.
                    // Note that we have noted the before space the site contributes in the
                    // code above.
                    //
                    // Absolute positioned nested layouts at BOL are a part of the pre-chars
                    // of the line. We also skip over them in FormattingNodeForLine.
                    //
                    if (fShouldHaveLayout)
                    {
                        pMe->_fHasNestedLayouts = TRUE;

                        //
                        // Should never be here for hidden layouts. They should be
                        // skipped over earlier in this function.
                        //
                        Assert(!pCF->IsDisplayNone());
                        if (pNode->IsAbsolute(LC_TO_FC(_pci->GetLayoutContext())))
                        {
                            LONG cchElement = pMe->GetNestedElementCch(pElement, &ptp);

                            pMe->_fSeenAbsolute = TRUE;
                            
                            // The extra one is added in the normal processing.
                            pMe->_li._cch +=  cchElement - ptp->GetCch();
                            pMe->_cchAbsPosdPreChars += cchElement; 
                        }
                        else
                        {
                            break;
                        }
                    }
                }
            }
        }
        else
        {
            Assert(ptp->IsText());
            if (ptp->Cch())
                break;
        }

        pMe->_li._cch += ptp->GetCch();
    }

    pMe->_fEmptyLineForPadBord = !fContinueLooking;

    if (ptp != pMe->GetPtp())
        pMe->SetPtp(ptp, -1);

    _xBordLeft  += _xBordLeftPerLine;
    _xBordRight += _xBordRightPerLine;
    _xPadLeft   += _xPadLeftPerLine;
    _xPadRight  += _xPadRightPerLine;

     return ptpFormatting ? ptpFormatting : ptp;
}

//+----------------------------------------------------------------------------
//
//  Member:     CRecalcLinePtr::CollectSpaceInfoFromEndNode
//
//  Synopsis:   Computes the space info when we are at the end of a block element.
//
//  Returns:    A BOOL indicating if any space info was collected.
//
//-----------------------------------------------------------------------------

ENI_RETVAL
CRecalcLinePtr::CollectSpaceInfoFromEndNode(
    CLSMeasurer *pMe, 
    CTreeNode *  pNode,
    BOOL         fFirstLineInLayout,
    BOOL         fPadBordForEmptyBlock,
    BOOL *       pfConsumedBlockElement)
{
    Assert(pNode);

    ENI_RETVAL retVal = ENI_CONTINUE;
    const CFancyFormat *pFF = pNode->GetFancyFormat(LC_TO_FC(_pci->GetLayoutContext()));
    const CCharFormat *pCF  = pNode->GetCharFormat(LC_TO_FC(_pci->GetLayoutContext()));
    BOOL fNodeVertical = pCF->HasVerticalLayoutFlow();
    BOOL fWritingModeUsed = pCF->_fWritingModeUsed;
    
    CUnitValue cuv;
    
    Assert(   _pdp->GetFlowLayout()->IsElementBlockInContext(pNode->Element())
           || pNode->Element()->IsOwnLineElement(_pdp->GetFlowLayout())
          );
    CElement *pElement = pNode->Element();
    CDoc     *pDoc     = pElement->Doc();
    BOOL      fPadBord = pCF->HasPadBord(FALSE);
    BOOL      fShouldHaveLayout = pNode->ShouldHaveLayout(LC_TO_FC(_pci->GetLayoutContext()));
    
    // compute any padding or border height from elements
    // going out of scope 
    if(     !fShouldHaveLayout 
        &&   fPadBord)
    {
        LONG lFontHeight = pCF->GetHeightInTwips(pDoc);
        LONG xBordLeft, xBordRight, xPadLeft, xPadRight;

        xBordLeft = xBordRight = xPadLeft = xPadRight = 0;
        
        if ( !pElement->_fDefinitelyNoBorders )
        {
            CBorderInfo borderinfo;

            pElement->_fDefinitelyNoBorders = !GetBorderInfoHelper( pNode, _pci, &borderinfo, GBIH_NONE );
            if ( !pElement->_fDefinitelyNoBorders )
            {
                if (borderinfo.aiWidths[SIDE_BOTTOM])
                {
                    // If we are called from CalcBeforeSpace, and we run into an end node
                    // which has border, then just terminate without processing the node
                    // (ie dont collect spacing info, dont consume the character, dont
                    // modify xBordLeft/xBordRight etc). This is because this node should
                    // be consume in *CalcAfterSpace* since the width of the bottom border
                    // needs to be added into _yBordBottom -- which will eventually find
                    // its way into the descent of the line. This way we will get a line
                    // similar to others, except its natural height will be 0, but will
                    /// will eventually get a height after CalcAfterSpace is called.
                    if(fPadBordForEmptyBlock)
                    {
                        // Cause the line to be no more than just this /div character
                        retVal = ENI_TERMINATE;
                    }

                    // We got here during CalcBeforeSpace. 2 cases are worth mentioning:
                    // 1) There was text before this ptp, which was collected during
                    //    measuring the line.
                    // 2) We got here because measure line terminated right away because
                    //    it saw an end splay without seeing any characters. This would
                    //    happen if the line begins with a end splay (CalcBeforeSpace
                    //    would have terminated right away as we saw before).
                    else
                    {
                        Assert(pfConsumedBlockElement);

                        // Now, if during CalcAfterSpace, we saw an end block (block element A)
                        // ptp which did not have a bottom border (in which case
                        // *pfConsumeBlockElement will be TRUE) and then we see an end block
                        // (block element B) ptp which had a bottom border then we should
                        // terminate the line without consuming the end splay, since all the
                        // content on the line belongs to block element A and putting more
                        // content on the same line from block element B is incorrect (remember
                        // rendered border constitues content).
                        // Also note, that CalcAfterSpace always stops when it sees a beging
                        // ptp for a block  element. Hence *pfConsumedBlockElement is only
                        // telling us whether we have seen an end ptp of a block element.
                        if (*pfConsumedBlockElement)
                        {
                            retVal = ENI_TERMINATE;
                        }

                        // Finally, we have seen an end block element which has a bottom
                        // border. Consume it and stop further consumption, since we cannot
                        // add more stuff on this line now.
                        else
                        {
                            _yBordBottom += borderinfo.aiWidths[SIDE_BOTTOM];
                            retVal = ENI_CONSUME_TERMINATE;
                        }
                    }
                }

                // Remember, if we are not consuming the character, we should not
                // adjust the borders.
                if (retVal != ENI_TERMINATE)
                {
                    xBordLeft   = borderinfo.aiWidths[SIDE_LEFT];
                    xBordRight  = borderinfo.aiWidths[SIDE_RIGHT];
                }
            }
        }

        // The same argument as for borders is valid for padding too.
        LONG yPadBottom = pFF->GetLogicalPadding(SIDE_BOTTOM, fNodeVertical, fWritingModeUsed).YGetPixelValue(
            _pci,
            _pci->_sizeParent.cx, 
            lFontHeight);
        if (yPadBottom)
        {
            if(fPadBordForEmptyBlock)
            {
                retVal = ENI_TERMINATE;
            }
            else
            {
                Assert(pfConsumedBlockElement);
                if (*pfConsumedBlockElement)
                {
                    retVal = ENI_TERMINATE;
                }
                else
                {
                    _yPadBottom += yPadBottom;
                    retVal = ENI_CONSUME_TERMINATE;
                }
            }
        }
        if (retVal != ENI_TERMINATE)
        {
            xPadLeft  = pFF->GetLogicalPadding(SIDE_LEFT, fNodeVertical, fWritingModeUsed).XGetPixelValue(
                                    _pci,
                                    _pci->_sizeParent.cx, 
                                    lFontHeight);
            xPadRight = pFF->GetLogicalPadding(SIDE_RIGHT, fNodeVertical, fWritingModeUsed).XGetPixelValue(
                                    _pci,
                                    _pci->_sizeParent.cx, 
                                    lFontHeight);
        }
        
        //
        // If fPadBordForEmptyBlock is true it means that we are called from CalcBeforeSpace.
        // During CalcBeforeSpace, the padding and border is collected in the per-line variables
        // and then accounted into _x[Pad|Bord][Left|Right] variables at the end of the call.
        // Hence when we are measuring for empty block elements, we remove their padding
        // and border from the perline varaibles, but when we are called from CalcAfterSpace
        // we remove it from the actual _x[Pad|Bord][Left|Right] variables.
        //
        if (fPadBordForEmptyBlock)
        {
            _xBordLeftPerLine  -= xBordLeft;
            _xBordRightPerLine -= xBordRight;
            _xPadLeftPerLine   -= xPadLeft;
            _xPadRightPerLine  -= xPadRight;
        }
        else
        {
            _xBordLeft  -= xBordLeft;
            _xBordRight -= xBordRight;
            _xPadLeft   -= xPadLeft;
            _xPadRight  -= xPadRight;
        }
    }

    if (   !fFirstLineInLayout
        && retVal != ENI_TERMINATE
       )
    {
        if (pfConsumedBlockElement)
            *pfConsumedBlockElement = TRUE;
        
        // Treading the fine line of Nav3, Nav4 and IE3 compat,
        // we include the bottom margin as long as we're not
        // the last line in the text site or not a P tag. This
        // is broadly Nav4 compatible.
        if (   pElement->_fExplicitEndTag
            || pFF->HasExplicitLogicalMargin(SIDE_BOTTOM, fNodeVertical, fWritingModeUsed)
           )
        {
            // Deal with things proxied around text sites differently,
            // so we need to know when we're above the containing site.
            //if (pElement->GetLayout() == pFlowLayout)
            //break;

            // If this is in a PRE block, then we have no
            // interline spacing.
            if (!(   pNode->Parent()
                     && pNode->Parent()->GetParaFormat()->HasPre(TRUE)
                 )
               )
            {
                LONG lTemp;
                cuv = pFF->_cuvSpaceAfter;

                lTemp = cuv.YGetPixelValue(_pci,
                                           _pci->_sizeParent.cx,
                                           pNode->GetFontHeightInTwips(&cuv));

                _lPosSpace = max(lTemp, _lPosSpace);
                _lNegSpace = min(lTemp, _lNegSpace);
                if (pElement->Tag() != ETAG_P || pFF->HasExplicitLogicalMargin(SIDE_BOTTOM, fNodeVertical, fWritingModeUsed))
                {
                    _lPosSpaceNoP = max(lTemp, _lPosSpaceNoP);
                    _lNegSpaceNoP = min(lTemp, _lNegSpaceNoP);
                }
            }
        }
    }

    //
    // CSS attributes page break before/after support.
    // There are two mechanisms that add to provide full support: 
    // 1. CRecalcLinePtr::CalcBeforeSpace() and CRecalcLinePtr::CalcAfterSpace() 
    //    is used to set CLineCore::_fPageBreakBefore/After flags only(!) for 
    //    nested elements which have no their own layout (i.e. paragraphs). 
    // 2. CEmbeddedILSObj::Fmt() sets CLineCore::_fPageBreakBefore for nested 
    //    element with their own layout that are NOT allowed to break (always) 
    //    and for nested elements with their own layout that ARE allowed to 
    //    break if this is the first layout in the view chain. 
    //
    if (   // print view 
           _pci->GetLayoutContext() 
        && _pci->GetLayoutContext()->ViewChain() 
           // and element is nested element without a layout
        && !fShouldHaveLayout 
        )
    {
        // does any blocks going out of scope force a page break
        if (fPadBordForEmptyBlock)
        {
            if (GET_PGBRK_AFTER(pFF->_bPageBreaks))
            {
                CLayoutBreak *  pLayoutBreak;

                // if this is an empty block set page break BEFORE for the line
                pMe->_li._fPageBreakBefore = TRUE; 

                _pci->GetLayoutContext()->GetEndingLayoutBreak(_pdp->GetFlowLayout()->ElementOwner(), &pLayoutBreak);
                if (pLayoutBreak)
                {
                    DYNCAST(CFlowLayoutBreak, pLayoutBreak)->_pElementPBB = pElement;
                }
            }
        }
        else 
        {
            pMe->_li._fPageBreakAfter |= !!GET_PGBRK_AFTER(pFF->_bPageBreaks);
        }

        _pci->_fPageBreakLeft  |= IS_PGBRK_AFTER_OF_STYLE(pFF->_bPageBreaks, stylePageBreakLeft); 
        _pci->_fPageBreakRight |= IS_PGBRK_AFTER_OF_STYLE(pFF->_bPageBreaks, stylePageBreakRight); 
    }

    return retVal;
}

BOOL
CRecalcLinePtr::AlignFirstLetter(CLSMeasurer *pme,
                                 int iLineStart,
                                 int iLineFirst,
                                 LONG *pyHeight,
                                 LONG *pyAlignDescent,
                                 CTreeNode *pNodeFormatting
                                )
{
    BOOL fRet = FALSE;
    LONG yHeight = *pyHeight;
    CLineFull lif;
    CLineCore *pli;
    CTreeNode *pNode;
    LONG yBS = pme->_li._yBeforeSpace;
    
    Assert(pme->_li._fHasFirstLetter);
    Assert(pme->_li._fHasFloatedFL);
    Assert(!pme->_li.IsFrame());

    pNode = _pdp->GetMarkup()->SearchBranchForBlockElement(pNodeFormatting, pme->_pFlowLayout);
    Assert(pNode);
    Assert(pNode->GetFancyFormat()->_fHasFirstLetter);

    Reset(iLineStart);
    for (LONG i = 0; i < pme->_aryFLSlab.Size(); i++)
    {
        pli = AddLine();
        if (!pli)
            goto Cleanup;

        lif = pme->_li;
        lif._iLOI = -1;
        lif._fLeftAligned = TRUE;
        lif._cchFirstLetter = lif._cch - lif._cchWhite;
        lif._cch = 0;
        lif._cchWhite = 0;
        lif._fClearBefore = i > 0;
        lif._fClearAfter = FALSE;
        lif._xLineWidth = (lif._xWidth - pme->_aryFLSlab[i]._xWidth) + lif._xLeft; 
        lif._fFrameBeforeText = FALSE;
        lif._pNodeForFirstLetter = pNode;
        lif._yBeforeSpace = yBS;
        if (pme->_aryFLSlab.Size() > 1)
            lif._yHeight = pme->_aryFLSlab[i]._yHeight + yBS;
        yBS += pme->_aryFLSlab[i]._yHeight;
        
        pli->AssignLine(lif);

        if (i == 0)
        {
            _marginInfo._xLeftMargin += lif._xLineWidth;
            _marginInfo._fAddLeftFrameMargin = FALSE;
            _marginInfo._yLeftMargin = yHeight + lif._yHeight;
        }
        if (yHeight + lif._yHeight > _marginInfo._yBottomLeftMargin)
        {
            _marginInfo._yBottomLeftMargin = yHeight + lif._yHeight;
            if (yHeight + lif._yHeight > *pyAlignDescent)
            {
                *pyAlignDescent = yHeight + lif._yHeight;
            }
        }
    }
    
    fRet = TRUE;
Cleanup:
    return fRet;
}

CSaveRLP::CSaveRLP(CRecalcLinePtr *prlp)
{
    Assert(prlp);
    _prlp = prlp;
    _marginInfo = prlp->_marginInfo;
    _xLeadAdjust = prlp->_xLeadAdjust;
    _xBordLeftPerLine = prlp->_xBordLeftPerLine;
    _xBordLeft = prlp->_xBordLeft;
    _xBordRightPerLine = prlp->_xBordRightPerLine;
    _xBordRight = prlp->_xBordRight;
    _yBordTop = prlp->_yBordTop;
    _yBordBottom = prlp->_yBordBottom;
    _xPadLeftPerLine = prlp->_xPadLeftPerLine;
    _xPadLeft = prlp->_xPadLeft;
    _xPadRightPerLine = prlp->_xPadRightPerLine;
    _xPadRight = prlp->_xPadRight;
    _yPadTop = prlp->_yPadTop;
    _yPadBottom = prlp->_yPadBottom;
    _ptpStartForListItem = prlp->_ptpStartForListItem;
    _lTopPadding = prlp->_lTopPadding;
    _lPosSpace = prlp->_lPosSpace;
    _lNegSpace = prlp->_lNegSpace;
    _lPosSpaceNoP = prlp->_lPosSpaceNoP;
    _lNegSpaceNoP = prlp->_lNegSpaceNoP;
}

CSaveRLP::~CSaveRLP()
{
    Assert(_prlp);
    _prlp->_marginInfo = _marginInfo;
    _prlp->_xLeadAdjust = _xLeadAdjust;
    _prlp->_xBordLeftPerLine = _xBordLeftPerLine;
    _prlp->_xBordLeft = _xBordLeft;
    _prlp->_xBordRightPerLine = _xBordRightPerLine;
    _prlp->_xBordRight = _xBordRight;
    _prlp->_yBordTop = _yBordTop;
    _prlp->_yBordBottom = _yBordBottom;
    _prlp->_xPadLeftPerLine = _xPadLeftPerLine;
    _prlp->_xPadLeft = _xPadLeft;
    _prlp->_xPadRightPerLine = _xPadRightPerLine;
    _prlp->_xPadRight = _xPadRight;
    _prlp->_yPadTop = _yPadTop;
    _prlp->_yPadBottom = _yPadBottom;
    _prlp->_ptpStartForListItem = _ptpStartForListItem;
    _prlp->_lTopPadding = _lTopPadding;
    _prlp->_lPosSpace = _lPosSpace;
    _prlp->_lNegSpace = _lNegSpace;
    _prlp->_lPosSpaceNoP = _lPosSpaceNoP;
    _prlp->_lNegSpaceNoP = _lNegSpaceNoP;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\text\runptr.cxx ===
/*
 *  @doc    INTERNAL
 *
 *  @module RUNPTR.C -- Text run and run pointer class |
 *  
 *  Original Authors: <nl>
 *      Original RichEdit code: David R. Fulmer
 *      Christian Fortini
 *      Murray Sargent
 *
 *  History: <nl>
 *      6/25/95 alexgo  Commented and Cleaned up.
 */

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X__RUNPTR_H_
#define X__RUNPTR_H_
#include "_runptr.h"
#endif

#ifndef X__TEXT_H_
#define X__TEXT_H_
#include "_text.h"
#endif

//
//  Invariant stuff
//
#define DEBUG_CLASSNAME CRunPtrBase

#include "_invar.h"

// ===========================  CRunPtrBase class  ==================================================

#if DBG==1
   
/*
 *  CRunPtrBase::Invariant()
 *
 *  @mfunc
 *      Debug-only function that validates the internal state consistency
 *      for CRunPtrBase
 *
 *  @rdesc
 *      TRUE always (failures assert)
 */
BOOL CRunPtrBase::Invariant() const
{
    CTxtRun *pRun;

    if( _prgRun == NULL )
    {
        Assert( GetIRun() == 0 );
        // we let ich zoom around a conceptual 
        // run so it can stay in sync with a text pointer
        Assert( GetIch() >= 0 );
        
        return TRUE;
    }

    pRun = _prgRun->Elem( GetIRun() );

    if( pRun == NULL )
    {
        Assert(GetIRun() == 0);
        // we let ich zoom around a conceptual 
        // run so it can stay in sync with a text pointer
        Assert( GetIch() >= 0 );
    }
    else
    {
        Assert( GetIRun() < NumRuns() );
        Assert( GetIch() <= long( pRun->_cch ) );
    }

    return TRUE;
}

/*
 *  CRunPtrBase::GetTotalCch()
 *
 *  @mfunc
 *      Calculate length of text by summing text runs accessible by this
 *      run ptr
 *
 *  @rdesc
 *      length of text so calculated, or -1 if failed
 */

long
CRunPtrBase::GetTotalCch ( ) const
{
    long iRun;
    long cchText = 0;

    AssertSz(_prgRun, "CTxtPtr::GetCch() - Invalid operation on single run CRunPtr");

    for( iRun = NumRuns() ; iRun && iRun-- ; )
        cchText += _prgRun->Elem(iRun)->_cch;

    return cchText;
}

#endif


/* 
 *  CRunPtrBase::SetRun(iRun, ich)
 *
 *  @mfunc
 *      Sets this run ptr to the given run.  If it does not
 *      exist, then we set ourselves to the closest valid run
 *
 *  @rdesc
 *      TRUE if moved to iRun
 */

BOOL
CRunPtrBase::SetRun( long iRun, long ich )
{
    BOOL      bRet = TRUE;
    long      nRuns = NumRuns();
    CTxtRun * pRun;
 
    if (!_prgRun)
        return FALSE;

    if (iRun >= nRuns)
    {
        bRet = FALSE;
        iRun = nRuns - 1;
    }
    
    if (iRun < 0)
    {
        bRet = FALSE;
        iRun = 0;
    }
    
    SetIRun( iRun );

    // Set the offset

    pRun = _prgRun->Elem( iRun );

    if (pRun)
        SetIch( min( ich, long( pRun->_cch ) ) );

    return bRet;
}
                                                
/*
 *  CRunPtrBase::NextRun()
 *
 *  @mfunc
 *      Change this RunPtr to that for the next text run
 *
 *  @rdesc
 *      TRUE if succeeds, i.e., target run exists
 */

BOOL
CRunPtrBase::NextRun()
{
    _TEST_INVARIANT_

    if (_prgRun)
    {    
        if (GetIRun() < NumRuns() - 1)
        {
            SetIRun( GetIRun() + 1 );
            SetIch( 0 );
            
            return TRUE;
        }
    }
    
    return FALSE;
}

/*
 *  CRunPtrBase::PrevRun()
 *
 *  @mfunc
 *      Change this RunPtr to that for the previous text run
 *
 *  @rdesc
 *      TRUE if succeeds, i.e., target run exists
 */

BOOL
CRunPtrBase::PrevRun()
{
    _TEST_INVARIANT_

    if (_prgRun)
    {
        SetIch( 0 );
        
        if (GetIRun() > 0)
        {
            SetIRun( GetIRun() - 1 );
            
            return TRUE;
        }
    }
    
    return FALSE;
}

/*
 *  CRunPtrBase::GetCp()
 *
 *  @mfunc
 *      Get cp of this RunPtr
 *
 *  @rdesc
 *      cp of this RunPtr
 *
 *  @devnote
 *      May be computationally expensive if there are many elements
 *      in the array (we have to run through them all to sum cch's.
 *      Used by TOM collections and Move commands, so needs to be fast.
 */

DWORD
CRunPtrBase::GetCp () const
{
    DWORD       cp   = GetIch();
    DWORD       iRun = GetIRun();
    CTxtRun *   pRun;

    _TEST_INVARIANT_

    if (_prgRun && iRun)
    {
        DWORD cb = _prgRun->Size();
        
        pRun = GetRunRel( -1 );
        
        while ( iRun-- )
        {
            Assert( pRun );
            
            cp += pRun->_cch;
            
            pRun = (CTxtRun *)((BYTE *)pRun - cb);
        }
    }
    
    return cp;
}

/*
 *  CRunPtrBase::BindToCp(cp)
 *
 *  @mfunc
 *      Set this RunPtr to correspond to a cp.
 *
 *  @rdesc
 *      the cp actually set to
 */

DWORD
CRunPtrBase::BindToCp( DWORD cp )
{
    SetIRun( 0 );
    SetIch( 0 );
    
    return DWORD( AdvanceCp( cp ) );
}

/*
 *  CRunPtrBase::AdvanceCp(cch)
 *
 *  @mfunc
 *      Advance this RunPtr by (signed) cch chars.  If it lands on the
 *      end of a run, it automatically goes to the start of the next run
 *      (if one exists). If this is violated, many bad things may happen,
 *      so change at your peril.
 *
 *  @rdesc
 *      Count of characters actually moved
 */
LONG CRunPtrBase::AdvanceCp(
    LONG cch)           //@parm signed count of chars to move this RunPtr by
{
    DWORD   cchSave = cch;
    WHEN_DBG( long lRunCount = NumRuns(); )

    AssertSz(GetIRun() == 0 || (GetIRun() > 0 && _prgRun), "Invalid CRunPtr");

    // No runs, so just update _ich as if there were a run
    if(!IsValid())
    {
        SetIch( GetIch() + cch );

        // We have to assume that caller ensures that cch isn't too large,
        // since a runless run ptr doesn't know the cch of the document.
        // But we can check for too-negative values of cch: 
        if( GetIch() < 0 )
        {
            cch = -cch + GetIch();              // Calculate actual cch moved
            SetIch( 0 );
        }
        return cch;
    }


    if(cch < 0)
    {
        while(cch < 0)
        {
            // this cast to LONG is OK, since -cch will be positive
            // (and we aren't likely to have 3 billion characters in 
            // a given run :-)
            if( -cch <= GetIch() )
            {
                SetIch( GetIch() + cch );
                cch = 0;
                break;
            }
            // otherwise, we need to go to the previous run

            cch += GetIch();                        // we moved by the number of
                                                // characters left in the 
                                                // current run.
            if (GetIRun() <= 0)                      // Already in first run
            {
                SetIRun( 0 );
                SetIch( 0 );                       // Move to run beginning
                break;
            }
            
            // move to previous run.
            
            Assert(_prgRun->Elem(GetIRun() - 1));

            SetIRun( GetIRun() - 1 );
            
            SetIch( _prgRun->Elem( GetIRun() )->_cch );
        }
    }
    else
    {
        while(cch > 0)                          // Move forward
        {
            const long cchRun = _prgRun->Elem(GetIRun())->_cch;

            SetIch( GetIch() + cch );

            if (GetIch() < cchRun)                   // Target is in this run
            {
                cch = 0;                        // Signal countdown completed
                break;                          // (if _ich = cchRun, go to
            }                                   //  next run)   

            cch = GetIch() - cchRun;                // Advance to next run

            if (GetIRun() + 1 >= NumRuns())
            {
                Assert(GetIRun() == NumRuns() - 1);
                Assert(_prgRun->Elem(GetIRun())->_cch == cchRun);
                SetIch( cchRun );
                break;
            }

            SetIRun( GetIRun() + 1 );
            
            SetIch( 0 );  // Start at beginning of new run.
        }
    }

#if DBG == 1
    // Guarantee that a) we're not changing the run count and
    //                b) We're not at the end of a non-empty run.
    // Much code depends on this behaviour of AdvanceCp().
    // - Arye
    Assert (lRunCount == NumRuns());
    Assert (GetCchRemaining() != 0 ||
            cch == 0 ||
            GetIRun() == NumRuns() - 1);
#endif


    // NB! we check the invariant at the end to handle the case where
    // we are updating the cp for a floating range (i.e., we know that
    // the cp is invalid, so we fix it up).  So we have to check for
    // validity *after* the fixup.
    _TEST_INVARIANT_

    return cchSave - cch;                       // Return TRUE if countdown
}                                               // completed

/*
 *  CRunPtrBase::AdjustBackward()
 *
 *  @mfunc
 *      If the cp for this run ptr is at the "boundary" or edge between two
 *      runs, then make sure this run ptr points to the end of the first run.
 *
 *  @comm
 *      This function does nothing unless this run ptr points to the beginning
 *      or the end of a run.  This function may be needed in those cases
 *      because a cp at the beginning of a run is identical to the cp for the
 *      end of the previous run (if it exists), i.e., such an "edge" cp is
 *      ambiguous, and you may need to be sure that this run ptr points to the
 *      end of the first run.
 *
 *      For example, consider a run that describes characters at cp's 0 to 10
 *      followed by a run that describes characters at cp's 11 through 12. For
 *      a cp of 11, it is possible for the run ptr to be either at the *end*
 *      of the first run or at the *beginning* of the second run.
 *
 *
 *  @rdesc  nothing
 */
BOOL CRunPtrBase::AdjustBackward()
{
    _TEST_INVARIANT_

    //
    // If not at beginning of run or can't go to rev run then can't
    // adjust forward
    //

    if (GetIch() || !PrevRun())
        return FALSE;

    SetIch( _prgRun->Elem(GetIRun())->_cch );
    
    return TRUE;
}

/*
 *  CRunPtrBase::AdjustForward()
 *
 *  @mfunc
 *      If the cp for this run ptr is at the "boundary" or edge between two
 *      runs, then make sure this run ptr points to the start of the second
 *      run.
 *
 *  @rdesc
 *      nothing
 *
 *  @xref
 *      <mf CRunPtrBase::AdjustBackward>
 */
BOOL CRunPtrBase::AdjustForward()
{
    _TEST_INVARIANT_

    if( !_prgRun )
        return FALSE;

    CTxtRun *pRun = _prgRun->Elem(GetIRun());

    Assert( pRun );

    Assert( GetIch() <= long( pRun->_cch ) );
        
    if (long( pRun->_cch ) == GetIch())
        return NextRun();
    
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\text\rel.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1997.
//
//  File:       rel.cxx
//
//  Contents:   Implementation of some code for relatively positioned lines.
//
//  Classes:    CDisplay
//
//----------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X__DISP_H_
#define X__DISP_H_
#include "_disp.h"
#endif

#ifndef X_TREEPOS_HXX_
#define X_TREEPOS_HXX_
#include "treepos.hxx"
#endif

#ifndef X__FONT_H_
#define X__FONT_H_
#include "_font.h"
#endif

#ifndef X_MISCPROT_H_
#define X_MISCPROT_H_
#include "miscprot.h"
#endif

#ifndef X_CSITE_HXX_
#define X_CSITE_HXX_
#include "csite.hxx"
#endif

#ifndef X_COLLECT_HXX_
#define X_COLLECT_HXX_
#include "collect.hxx"
#endif

#ifndef X_RCLCLPTR_HXX_
#define X_RCLCLPTR_HXX_
#include "rclclptr.hxx"
#endif

#ifndef X_LINESRV_HXX_
#define X_LINESRV_HXX_
#include "linesrv.hxx"
#endif

#ifndef X_LSRENDER_HXX_
#define X_LSRENDER_HXX_
#include "lsrender.hxx"
#endif

#ifndef X_DISPLEAFNODE_HXX_
#define X_DISPLEAFNODE_HXX_
#include "displeafnode.hxx"
#endif

#ifndef X_DISPCONTAINER_HXX_
#define X_DISPCONTAINER_HXX_
#include "dispcontainer.hxx"
#endif

#ifndef X_TPOINTER_HXX_
#define X_TPOINTER_HXX_
#include "tpointer.hxx"
#endif

DeclareTag(tagRelPositioning, "Relative Positioning", "Relative Positioning");

MtDefine(CDisplayDrawRelElemBgAndBorder_aryNodesWithBgOrBorder_pv, Locals, "CDisplay::DrawRelElemBgAndBorder aryNodesWithBgOrBorder::_pv")
MtDefine(CDisplayDrawRelElemBgAndBorder_aryRects_pv, Locals, "CDisplay::DrawRelElemBgAndBorder aryRects::_pv")
MtDefine(CDisplayAddRelDispNodes_aryRelDispNodeCtxs_pv, Locals, "CDisplay::AddRelDispNodes aryRelDispNodeCtxs::_pv")
MtDefine(CDisplayUpdateRelDispNodeCache_rdnc_pv, Locals, "CDisplay::UpdateRelDispNodeCache rdnc::_pv")

MtExtern(CDisplay)
MtDefine(MtStoredRFE, CDisplay, "CStoredRFE")
MtDefine(MtStoredRFE_aryRect_pv, CDisplay, "MtStoredRFE_aryRect_pv")


extern CDispNode * EnsureContentNode(CDispNode * pDispNode);

void CDisplay::RcFromLine(RECT *prc, LONG top, LONG ili, CLineCore *pli, CLineOtherInfo *ploi)
{
    Assert(pli == Elem(ili));
    Assert(pli->oi() == ploi);

    // If it is the first fragment in a line with relative chunks use only
    // the margin space otherwise use the text left or right.
    if (!pli->IsRTLLine())
    {
        /* LTR */
        prc->left   = ((IsLogicalFirstFrag(ili) || pli->_fHasBulletOrNum)
                    ? ploi->_xLeftMargin
                    : ploi->GetTextLeft());

        prc->right  = ploi->_xLeftMargin + pli->_xLineWidth
                    + (pli->_fForceNewLine ? ploi->_xWhite : 0);
    }
    else
    {
        /* RTL */
        // TODO RTL 112514: this should be using same code as RegionFromElement()
        prc->right  = GetViewWidth()
                    - ((IsLogicalFirstFrag(ili) || pli->_fHasBulletOrNum)
                                ? ploi->_xRightMargin
                                : pli->GetRTLTextRight(ploi));

        prc->left   = GetViewWidth()
                    - (ploi->_xRightMargin + pli->_xLineWidth
                        + (pli->_fForceNewLine ? ploi->_xWhite : 0));
    }

    // If the line has negative margin, we need to use the larger
    // rect because text goes into the negative margin space.
    prc->top    = top + pli->GetYTop(ploi);
    prc->bottom = top + max(pli->GetYHeight(), pli->GetYBottom(ploi));
}

void
CDisplay::VoidRelDispNodeCache()
{
    if(HasRelDispNodeCache())
    {
        CRelDispNodeCache * prdnc = GetRelDispNodeCache();

        prdnc->DestroyDispNodes();

        delete DelRelDispNodeCache();
    }
}

CRelDispNodeCache *
CDisplay::GetRelDispNodeCache() const
{
    CDoc * pDoc = GetFlowLayout()->Doc();
#if DBG == 1
    if(HasRelDispNodeCache())
    {
        void * pLookasidePtr =  pDoc->GetLookasidePtr((DWORD *)this);

        Assert(pLookasidePtr == _pRelDispNodeCache);

        return (CRelDispNodeCache *)pLookasidePtr;
    }
    else
        return NULL;
#else
    return (CRelDispNodeCache *)(HasRelDispNodeCache() ? pDoc->GetLookasidePtr((DWORD *)this) : NULL);
#endif
}

HRESULT
CDisplay::SetRelDispNodeCache(void * pvVal)
{
    HRESULT hr = THR(GetFlowLayout()->Doc()->SetLookasidePtr((DWORD *)this, pvVal));

    if (hr == S_OK)
    {
        _fHasRelDispNodeCache = 1;
#if DBG == 1
        Assert(!_pRelDispNodeCache);

        _pRelDispNodeCache = (CRelDispNodeCache *)pvVal;
#endif
    }

    RRETURN(hr);
}

CRelDispNodeCache *
CDisplay::DelRelDispNodeCache()
{
    if (HasRelDispNodeCache())
    {
        void * pvVal = GetFlowLayout()->Doc()->DelLookasidePtr((DWORD *)this);
        _fHasRelDispNodeCache = 0;
#if DBG == 1
        Assert(_pRelDispNodeCache == pvVal);

        _pRelDispNodeCache = NULL;

        TraceTag((tagRelPositioning, "Deleting RelDispNodeCache - Element(Tag: %ls, SN:%ld)",
                                        GetFlowLayoutElement()->TagName(),
                                        GetFlowLayoutElement()->SN()));
#endif
        return(CRelDispNodeCache *)pvVal;
    }

    return(NULL);
}


CRelDispNodeCache *
CDisplay::EnsureRelDispNodeCache()
{
    Assert(!HasRelDispNodeCache());

    CRelDispNodeCache * prdnc = new CRelDispNodeCache(this);

    if(prdnc)
    {
        TraceTag((tagRelPositioning, "Creating RelDispNodeCache - %x", prdnc));
        SetRelDispNodeCache(prdnc);
    }

    return prdnc;
}

//+----------------------------------------------------------------------------
//
// Member:      CDisplay::UpdateDispNodeCache
//
// Synopsis:    Update the relative line cache smartly using the line edit
//              descriptor
//
//-----------------------------------------------------------------------------

void
CDisplay::UpdateRelDispNodeCache(CLed * pled)
{
    CRelDispNodeCache * prdnc = GetRelDispNodeCache();
    CStackDataAry<CRelDispNode, 4>  rdnc(Mt(CDisplayUpdateRelDispNodeCache_rdnc_pv));
    CLed                led;
    long                iliMatchNew;
    long                dy;
    long                dili;

    TraceTag((tagRelPositioning, "Entering: CDisplay::UpdateRelDispNodeCache - Element(Tag: %ls, SN:%ld)",
                                    GetFlowLayoutElement()->TagName(),
                                    GetFlowLayoutElement()->SN()));

    if(!pled)
    {
        pled = &led;
        pled->_yFirst = pled->_iliFirst = 0;
        pled->_cpFirst = GetFlowLayout()->GetContentFirstCpForBrokenLayout();
        pled->SetNoMatch();
    }

    dy   = pled->_yMatchNew - pled->_yMatchOld;
    dili = pled->_iliMatchNew - pled->_iliMatchOld;

    iliMatchNew = pled->_iliMatchNew == MAXLONG ? LineCount() : pled->_iliMatchNew;

    {
        CRelDispNode      * prdn = NULL;
        long                lSize;
        long                iEntry, iEntryStart, iEntryFinish;
        long                iliFirst   = pled->_iliFirst;
        long                yFirst     = pled->_yFirst;
        long                cpFirst    = pled->_cpFirst;
        long                cNewEntries;

        lSize = prdnc ? prdnc->Size() : 0;

        if(prdnc)
        {
            // find the node that corresponds to iliFirst
            for ( iEntryStart = 0, prdn = (*prdnc)[0];
                  iEntryStart < lSize && prdn->_ili + prdn->_cLines <= iliFirst;
                  iEntryStart++, prdn++);
        }
        else
        {
            iEntryStart = 0;
        }

        iEntryFinish = -1;

        // find the last entry affected by the lines changed
        if ( iEntryStart < lSize)
        {
            // if the region affected starts in the middle of the
            // disp node, then update the affected range to include
            // the entire dispnode.
            if(prdn->_ili < iliFirst)
            {
                iliFirst = prdn->_ili;
                yFirst  = prdn->_yli;
                cpFirst = prdn->GetElement()->GetFirstCp() - 1;
            }

            if (iliMatchNew != LineCount())
            {
                for(iEntryFinish = iEntryStart;
                    iEntryFinish < lSize && prdn->_ili < pled->_iliMatchOld;
                    iEntryFinish++, prdn++);
            }
            else
            {
                iEntryFinish = lSize;
            }

        }

        //
        // Add the new entries to temporary stack
        //
        AddRelNodesToCache(cpFirst, yFirst, iliFirst, iliMatchNew, &rdnc);
        cNewEntries = rdnc.Size();


        //
        // Destroy the display nodes that correspond to the entries
        // in the dirty range
        //
        if(iEntryStart < lSize)
        {
            long i, iNewEntry = 0;
            long diEntries;

            prdn = (*prdnc)[iEntryStart];
            // now remove all the entries that are affected
            for ( iEntry = iEntryStart; iEntry < iEntryFinish; iEntry++, prdn++)
            {
                i = iNewEntry;

                if(cNewEntries && prdn->_pDispNode->IsContainer())
                {
                    //
                    // Replace old disp containers with the new ones, to ensure that all
                    // children are properly parented to the new container.
                    //
                    for( ; i < cNewEntries; i++)
                    {
                        CRelDispNode * prdnNewEntry = &rdnc.Item(i);

                        //
                        // Do not dereference, prdn->_pElement, it might have been destroyed.
                        //
                        if(     prdn->GetElement()
                            &&  prdnNewEntry->GetElement() == prdn->GetElement()
                            &&  prdnNewEntry->_pDispNode->IsContainer())
                        {
                            CSize       size;

                            // start at the next entry, so that we can start
                            // the search for the next container after the
                            // current entry. Both the caches are in source order
                            iNewEntry = i + 1;

                            GetFlowLayout()->GetView()->ExtractDispNode(prdn->_pDispNode);

                            TraceTag((tagRelPositioning, "\tReplacing dispnode for element(Tag: %ls, SN:%ld) from %ld",
                                        prdnNewEntry->GetElement()->TagName(),
                                        prdnNewEntry->GetElement()->SN(),
                                        iEntry));

                            size = prdnNewEntry->_pDispNode->GetSize();
                            prdnNewEntry->_pDispNode->ReplaceNode(prdn->_pDispNode);
                            prdnNewEntry->_pDispNode->SetSize(size, NULL, FALSE);

                            if (IsRTLDisplay())
                                SetRelDispNodeContentOrigin(prdnNewEntry->_pDispNode);

                            for (CDispNode* pDispNode = prdnNewEntry->_pDispNode->GetFirstFlowChildNode();
                                            pDispNode;
                                            pDispNode = pDispNode->GetNextFlowNode())
                            {
                                if (pDispNode->IsOwned())
                                {
                                    CElement *  pElement;

                                    pDispNode->GetDispClient()->GetOwner(pDispNode, (void **)&pElement);

                                    if (    pElement
                                        &&  pElement->ShouldHaveLayout())
                                    {
                                        pElement->ZChangeElement();
                                    }
                                }
                            }
                            break;
                        }
                    }

                    if( i == cNewEntries)
                    {
                        prdn->ClearContents();
                    }
                }
                else
                {
                    prdn->ClearContents();
                }
            }

            diEntries = cNewEntries - iEntryFinish + iEntryStart;

            // move all the disp nodes that follow the
            // affected entries
            if( iEntryFinish != lSize && (dy || dili || diEntries))
            {
                TraceTag((tagRelPositioning, "\tMoving Entries %ld - %ld by %ld",
                    iEntryFinish,
                    lSize,
                    diEntries));

                long iLastLine = -1;

                for (iEntry = iEntryFinish, prdn = (*prdnc)[iEntryFinish];
                     iEntry < lSize;
                     iEntry++, prdn++)
                {
                    prdn->_ili += dili;
                    prdn->_yli += dy;

                    if (iLastLine <= prdn->_ili)
                    {
                        prdn->_pDispNode->SetPosition(prdn->_pDispNode->GetPosition() + CSize(0, dy));
                        iLastLine = prdn->_ili + prdn->_cLines;
                    }

                    prdn->_pDispNode->SetExtraCookie((void *)(LONG_PTR)(iEntry + diEntries));
                }
            }

            if(iEntryStart < iEntryFinish)
            {
                // delete all the old entries in the dirty range
                prdnc->Delete(iEntryStart, iEntryFinish - 1);
            }
        }

        //
        // Insert the new entries in the dirty range, back to the cache
        //
        if(cNewEntries)
        {
            long iEntryInsert = iEntryStart;
            prdnc = GetRelDispNodeCache();

            Assert(prdnc);

            prdn = &rdnc.Item(0);
            for(iEntry = 0; iEntry < cNewEntries; iEntry++, prdn++, iEntryInsert++)
            {
                long xPos = prdn->_ptOffset.x;
                CPoint ptAuto(xPos, prdn->_ptOffset.y + prdn->_yli);

                prdnc->InsertAt(iEntryInsert, *prdn);

                prdn->_pDispNode->SetExtraCookie((void *)(LONG_PTR)(iEntryInsert));

                //
                // Ensure flow node for each of the newly created containers
                //
                if(prdn->_pDispNode->IsContainer())
                {
                    CDispNode * pDispContent = EnsureContentNode(prdn->_pDispNode);

                    if(pDispContent)
                    {
                        pDispContent->SetSize(prdn->_pDispNode->GetSize(), NULL, FALSE);

                        // note: content origin and position are initialized in EnsureContentNode
                    }
                }

                TraceTag((tagRelPositioning, "\tAdding Element(Tag: %ls, SN:%ld) at %ld",
                                prdn->GetElement()->TagName(),
                                prdn->GetElement()->SN(),
                                iEntryInsert));
                //
                // Fire off a ZChange notification to insert it in the appropriate
                // ZLayer and ZParent.
                //
                prdn->GetElement()->ZChangeElement(NULL, &ptAuto, GetFlowLayout()->LayoutContext());

                Assert(prdnc->Size() > (iEntryInsert));
            }
        }
    }

    prdnc = GetRelDispNodeCache();

    if(prdnc && !prdnc->Size())
        delete DelRelDispNodeCache();

    GetFlowLayout()->_fContainsRelative = HasRelDispNodeCache();
    TraceTag((tagRelPositioning, "\tContainsRelative: %ls", HasRelDispNodeCache() ? "TRUE" : "FALSE"));
    TraceTag((tagRelPositioning, "Leaving: CDisplay::UpdateRelDispNodeCache"));
}

struct CRelDispNodeCtx
{
    CElement *  _pElement;
    CRect       _rc;
    long        _cpEnd;
    long        _cLines;
    long        _ili;
    long        _yli;
    long        _iEntry;
    BOOL        _fHasChildren;
    LONG        _xAnchor;  // descending's anchor point x-coordinate
};

//+----------------------------------------------------------------------------
//
// Member:      CDisplay::AddDispNodesToCache
//
// Synopsis:    Add new display nodes to the cache in the range of lines changed
//
//-----------------------------------------------------------------------------
void
CDisplay::AddRelNodesToCache(
    long cpFirst,
    long yli,
    long iliStart,
    long iliMatchNew,
    CDataAry<CRelDispNode> * prdnc)
{
    CStackDataAry<CRelDispNodeCtx, 4> aryRelDispNodeCtx(Mt(CDisplayAddRelDispNodes_aryRelDispNodeCtxs_pv));
    CRelDispNodeCtx   * prdnCtx = NULL;
    CFlowLayout * pFlowLayout = GetFlowLayout();
    CMarkup     * pMarkup = pFlowLayout->GetContentMarkup();
    CLineCore   * pli;
    long          ili;
    long          ich;
    long          iTop = -1;
    long          cpTopEnd = MINLONG;
    long          cpLayoutMax = pFlowLayout->GetContentLastCp();
    long          iEntryInsert = 0;
    long          lCount = LineCount();
    BOOL          fDesignMode = pFlowLayout->IsEditable(TRUE);

    CLayoutContext *pLayoutContext = pFlowLayout->LayoutContext();
    BOOL            fViewChain = pLayoutContext && pLayoutContext->ViewChain();

    if (fViewChain)
    {
        CTreePos *  ptp = pMarkup->TreePosAtCp(cpFirst, &ich);
        CTreeNode * pNode = ptp->GetBranch();
        CElement *  pElementRel = pNode->Element();

        //  If elment just begins we will insert later;
        if (ptp->IsBeginElementScope())
        {
            pNode = pNode->Parent();
            pElementRel = pNode->Element();
        }

        while (pElementRel != pFlowLayout->ElementOwner())
        {
            if (pElementRel->IsRelative() && !pElementRel->ShouldHaveLayout())
            {
                CRelDispNode rdn;
                CRelDispNodeCtx rdnCtx;

                if(!GetRelDispNodeCache())
                {
                    if(!EnsureRelDispNodeCache())
                        return;
                }

                prdnc->InsertIndirect(0, &rdn);
                aryRelDispNodeCtx.InsertIndirect(0, &rdnCtx);
                prdnCtx = &aryRelDispNodeCtx.Item(0);

                if(!prdnCtx)
                    return;

                prdnCtx->_pElement = pElementRel;
                prdnCtx->_ili      = iliStart;
                prdnCtx->_yli      = yli;
                prdnCtx->_cpEnd    = min(pElementRel->GetLastCp(), cpLayoutMax);
                prdnCtx->_rc       = g_Zero.rc;
                prdnCtx->_cLines   = 0;
                prdnCtx->_fHasChildren = FALSE;

                iTop++;

                Assert(aryRelDispNodeCtx.Size() == iTop + 1);
            }

            pNode = pNode->Parent();
            pElementRel = pNode->Element();
        }

        {
            int i;

            for (i = 0; i <= iTop; ++i)
            {
                prdnCtx = &aryRelDispNodeCtx.Item(i);

                prdnCtx->_iEntry = i;
                cpTopEnd = prdnCtx->_cpEnd;
            }

            iEntryInsert = iTop + 1;    //  (bug #12997)
        }
    }

    //
    // Note: here we are trying to walk lines beyond iliMatchNew to update the
    // rc of the elements that came into scope in the dirty region
    //

    for (ili = iliStart;
         ili < lCount && (ili < iliMatchNew || cpFirst <= cpTopEnd);
         ili++)
    {
        pli = Elem(ili);

        // create a new entry only for elements in the dirty range
        // (ili < iliMatchNew)
        if (pli->_fRelative && pli->_cch && ili < iliMatchNew)
        {
            CTreePos *ptp = pMarkup->TreePosAtCp(cpFirst, &ich);
            CElement *pElementRel = ptp->GetBranch()->Element();

            // if the current line is relative and a new element
            // is comming into scope, then push a new reldispnode
            // context on to the stack.
            if(     ptp->IsBeginElementScope()
                &&  pElementRel->IsRelative()
                &&  !pElementRel->ShouldHaveLayout())
            {
                CRelDispNode rdn;

                if(!GetRelDispNodeCache())
                {
                    if(!EnsureRelDispNodeCache())
                        return;
                }

                prdnc->InsertIndirect(iEntryInsert, &rdn);

                prdnCtx = aryRelDispNodeCtx.Append();

                if(!prdnCtx)
                    return;

                cpTopEnd           = min(pElementRel->GetLastCp(), cpLayoutMax);
                prdnCtx->_pElement = pElementRel;
                prdnCtx->_ili      = ili;
                prdnCtx->_yli      = yli;
                prdnCtx->_cpEnd    = cpTopEnd;
                prdnCtx->_rc       = g_Zero.rc;
                prdnCtx->_xAnchor  = 0;
                prdnCtx->_iEntry   = iEntryInsert++;

                iTop++;

                Assert(aryRelDispNodeCtx.Size() == iTop + 1);
            }

        }

        // if we have a relative element in context, add the
        // current line to it
        if(iTop >= 0)
        {
            CRect rcLine;

            Assert(prdnCtx);

            prdnCtx->_cLines++;

            // TODO RTL 112514:    This doesn't work in bidi scenarios. It occasionally returns
            //                     correct rectangle. The way it is currently implementede, it
            //                     is really hard to fix. The whole relative positioning should
            //                     be re-implemented using a cleaner desing; when that happens,
            //                     RTL won't be a problem.
            // note: this is the only caller of RcFromLine
            RcFromLine(&rcLine, yli, ili, pli, pli->oi());

            // Relative elements define a positioning origin whose x-coord
            // is where its text on its first line begins.
            if (prdnCtx->_cLines == 1)
                prdnCtx->_xAnchor = pli->oi()->GetTextLeft();

            // Add non-empty lines to the rect
            if(!IsRectEmpty(&rcLine))
            {
                UnionRect((RECT *)&prdnCtx->_rc, (RECT *)&prdnCtx->_rc, (RECT *)&rcLine);
            }
            // If we're dealing with the 1st line, even an empty rect is important,
            // because it contains offset information (i.e. top = bottom = 5)
            else if ( prdnCtx->_cLines == 1)
            {
                prdnCtx->_rc = rcLine;
            }

            if(pli->IsFrame() || pli->_fHasEmbedOrWbr || pli->_fRelative)
                prdnCtx->_fHasChildren = TRUE;

        }

        cpFirst  += pli->_cch;

        if(pli->_fForceNewLine)
            yli += pli->_yHeight;


        // if the current relative element is going out of scope,
        // then create a disp node for the element and send a zchange
        // notification.
        while(((cpFirst > cpTopEnd) || (ili == lCount - 1)) && iTop >= 0)
        {
            VISIBILITYMODE vis = VISIBILITYMODE_INHERIT;

            CRelDispNode * prdn = &prdnc->Item(prdnCtx->_iEntry);

            // pop the top rel disp node context and create a disp item for it
            // and update the parent disp node context
            prdn->SetElement( prdnCtx->_pElement);
            prdn->_ili        = prdnCtx->_ili;
            prdn->_yli        = prdnCtx->_yli;
            prdn->_cLines     = prdnCtx->_cLines;
            prdn->_ptOffset.x = prdnCtx->_rc.left;
            prdn->_ptOffset.y = prdnCtx->_rc.top - prdnCtx->_yli;
            prdn->_xAnchor    = prdnCtx->_xAnchor;

            // TODO RTL 112514: This is not always correct in RTL
            prdn->_xAnchor -= prdn->_ptOffset.x;

            // guess what extras the display node will need
            DWORD dwDispExtras = DISPEX_EXTRACOOKIE;
            if (IsRTLDisplay())
                dwDispExtras |= DISPEX_CONTENTORIGIN;

            // create the display node
            if(prdnCtx->_fHasChildren)
            {
                prdn->_pDispNode = CDispContainer::New(
                                                GetRelDispNodeCache(),
                                                dwDispExtras);

                if (prdn->_pDispNode != NULL)
                {
                    // Some of the children may be -ve'ly positioned, so we need to set
                    // the background bit on the dispnode to get called with a DrawClientBackground
                    // before we draw any -ve'ly positioned children
                    prdn->_pDispNode->SetBackground(TRUE);

                }
            }
            else
            {
                prdn->_pDispNode = (CDispNode *)CDispLeafNode::New(
                                                GetRelDispNodeCache(),
                                                dwDispExtras);
            }

            if(!prdn->_pDispNode)
                goto Error;

            prdn->_pDispNode->SetSize(prdnCtx->_rc.Size() , NULL, FALSE);
            prdn->_pDispNode->SetOwned(TRUE);
            prdn->_pDispNode->SetAffectsScrollBounds(fDesignMode);

            if (IsRTLDisplay())
                SetRelDispNodeContentOrigin(prdn->_pDispNode);

            switch (prdn->GetElement()->GetFirstBranch()->GetCascadedvisibility())
            {
            case styleVisibilityVisible:
                vis = VISIBILITYMODE_VISIBLE;
                break;

            case styleVisibilityHidden:
                vis = VISIBILITYMODE_INVISIBLE;
                break;

            case styleVisibilityInherit:
            default:
                vis = prdn->GetElement()->GetFirstBranch()->GetCharFormat()->_fVisibilityHidden
                                        ? VISIBILITYMODE_INVISIBLE
                                        : VISIBILITYMODE_VISIBLE;
            }

            Assert(vis == VISIBILITYMODE_VISIBLE || vis == VISIBILITYMODE_INVISIBLE);
            prdn->_pDispNode->SetVisible(vis == VISIBILITYMODE_VISIBLE);

            //
            // Append the current cLines & rc to the parent's
            // cache entry, if the current element is nested.
            //
            if(iTop > 0)
            {
                CRelDispNodeCtx * prdnCtxT = prdnCtx;

                prdnCtx = &aryRelDispNodeCtx.Item(iTop - 1);
                prdnCtx->_fHasChildren = TRUE;
                prdnCtx->_cLines += prdnCtxT->_cLines;
                cpTopEnd = prdnCtx->_cpEnd;

                // update the parent's context
                UnionRect( (RECT *)&prdnCtx->_rc,
                           (RECT *)&prdnCtx->_rc,
                           (RECT *)&prdnCtxT->_rc);

            }
            else
            {
                prdnCtx  = NULL;
                cpTopEnd = MINLONG;
            }

            aryRelDispNodeCtx.Delete(iTop--);
        }
    }
Cleanup:

#if DBG==1
    {
        CRelDispNode *  prdn        = &prdnc->Item(0);
        int             cNewEntries = prdnc->Size();

        while (--cNewEntries >= 0)
        {
            Assert(     prdn->_pDispNode
                    &&  prdn->GetElement()
                    &&  "CDisplay::AddRelNodesToCache() is about to return inconsistent RelDispNode array!!!");
            prdn++;
        }
    }
#endif

    return;
Error:
    goto Cleanup;
}

// note: DestroyDispNode is here and not an inline to prevent a dependency from
// _disp.h on dispnode.hxx, which makes Display Tree development difficult due
// to the large number of files that must be compiled when dispnode.hxx changes.
void
CRelDispNode::DestroyDispNode()
{
    Assert(_pDispNode != NULL);
    _pDispNode->Destroy();
    _pDispNode = NULL;
}

//+----------------------------------------------------------------------------
//
// Function:    CRelDispNodeCache::GetOwner
//
// Synopsis:    Get the owning element of the given disp node.
//
//-----------------------------------------------------------------------------
void
CRelDispNodeCache::GetOwner(
    CDispNode const* pDispNode,
    void ** ppv)
{
    CRelDispNode *  prdn;
    long            lEntry;

    Assert(pDispNode);
    Assert(pDispNode->GetDispClient() == this);
    Assert(ppv);
    Assert(Size());

    // we could be passed in a dispNode corresponding to the
    // content node of a container, in which case return the
    // element owner of the container.
    if(!pDispNode->IsOwned())
    {
        CDispNode * pDispNodeParent = pDispNode->GetParentNode();

        Assert(pDispNodeParent); // Relative disp nodes must have a parent.
        Assert(pDispNodeParent->GetDispClient() == this);

        lEntry = (LONG)(LONG_PTR)pDispNodeParent->GetExtraCookie();
    }
    else
    {
        lEntry = (LONG)(LONG_PTR)pDispNode->GetExtraCookie();
    }

    Assert(lEntry >= 0 && lEntry < Size());

    prdn = (*this)[lEntry];

    Assert (prdn->_pDispNode == pDispNode ||
            prdn->_pDispNode == pDispNode->GetParentNode());

    *ppv = prdn->GetElement();
}


long GetRelCacheEntry(CDispNode * pDispNode)
{
    long    lEntry;

    //
    // Find the index of the the cache entry that corresponds to the given node.
    // Extra cookie on the disp node stores the index into the cache.
    //
    // For container nodes, their flow node is passed in as a display node
    // to be rendered, so we need to get the parent's cookie instead.
    //
    if(!pDispNode->IsOwned())
    {
        CDispNode * pDispNodeParent = pDispNode->GetParentNode();

        Assert(pDispNodeParent); // Relative disp nodes must have a parent.

        lEntry = (LONG)(LONG_PTR)pDispNodeParent->GetExtraCookie();
    }
    else
    {
        lEntry = (LONG)(LONG_PTR)pDispNode->GetExtraCookie();
    }

    return lEntry;
}

BOOL
CRelDispNodeCache::GetAnchorPoint(CDispNode* pDispNode, CPoint* pPoint)
{
    long index = GetRelCacheEntry(pDispNode);
    if (unsigned(index) >= unsigned(Size()))
        return FALSE;
    CRelDispNode * pdn = &_aryRelDispNodes[index];
    pPoint->x = pdn->_xAnchor;
    pPoint->y = 0;
    return TRUE;
}


BOOL
CRelDispNodeCache::HitTestContent(
    const POINT *pptHit,
    CDispNode *pDispNode,
    void *pClientData,
    BOOL  fDeclinedByPeer)
{
    Assert(pptHit);
    Assert(pDispNode);
    Assert(pClientData);

    CFlowLayout   * pFL = _pdp->GetFlowLayout();
    CElement      * pElementDispNode;
    CRelDispNode *  prdn;
    CHitTestInfo *  phti        = (CHitTestInfo *)pClientData;
    BOOL            fBrowseMode = !pFL->ElementContent()->IsEditable(/*fCheckContainerOnly*/FALSE);
    long            lEntry      = GetRelCacheEntry(pDispNode);
    long            lSize       = Size();
    long            ili;
    long            iliLast;
    long            yli;
    long            cp;
    CPoint          pt;

    Assert(lSize && lEntry >= 0 && lEntry < lSize);

    prdn    = (*this)[lEntry];
    cp      = prdn->GetElement()->GetFirstCp() - 1;
    ili     = prdn->_ili;
    iliLast = ili + prdn->_cLines;
    yli     = prdn->_yli;

    //
    // convert the point relative to the layout parent
    //

    pt.x = pptHit->x + prdn->_ptOffset.x;
    pt.y = pptHit->y + prdn->_ptOffset.y + prdn->_yli;

    pElementDispNode = prdn->GetElement();

    //
    // HitTest lines that are owned by the given relative node.
    //
    while(ili < iliLast)
    {
        CLineCore * pli = _pdp->Elem(ili);

         // Hit test the current line here.
        if (    !pli->_fHidden
            && (!pli->_fDummyLine || fBrowseMode) )
        {
            CLineOtherInfo *ploi = pli->oi();

            // if the point is in the vertical bounds of the line
            if ( pt.y >= yli + pli->GetYTop(ploi) &&
                 pt.y <  yli + pli->GetYLineBottom(ploi))
            {
                // check if the point lies in the horzontal bounds of the
                // line
                if (pt.x >= ploi->_xLeftMargin &&
                    pt.x < (pli->_fForceNewLine
                                    ? ploi->_xLeftMargin + pli->_xLineWidth
                                    : pli->GetTextRight(ploi, ili == _pdp->LineCount() - 1)))
                {
                    break;
                }
            }

        }

        if(pli->_fForceNewLine)
            yli += pli->_yHeight;

        cp += pli->_cch;
        ili++;
    }

    //
    // If a line is hit, find the branch hit.
    //
    if ( ili < iliLast)
    {
        HITTESTRESULTS * presultsHitTest = phti->_phtr;
        HTC              htc = HTC_YES;
        BOOL             fPseudoHit;
        CTreeNode      * pNodeHit = NULL;

        //
        // If the line hit belongs to a nested relative line then it is
        // a pseudo hit.
        //
        fPseudoHit = FALSE;

        for (++lEntry; lEntry < lSize; lEntry++)
        {
            prdn++;

            if(ili >= prdn->_ili && ili < prdn->_ili + prdn->_cLines)
            {
                fPseudoHit = TRUE;
                break;
            }
        }

        if(!fPseudoHit)
        {
            CLinePtr    rp(_pdp);
            CTreePos *  ptp = NULL;
            DWORD       dwFlags = 0;

            dwFlags |= !!(phti->_grfFlags & HT_ALLOWEOL)
                            ? CDisplay::CFP_ALLOWEOL : 0;
            dwFlags |=  !(phti->_grfFlags & HT_DONTIGNOREBEFOREAFTER)
                            ? CDisplay::CFP_IGNOREBEFOREAFTERSPACE : 0;
            dwFlags |=  !(phti->_grfFlags & HT_NOEXACTFIT)
                            ? CDisplay::CFP_EXACTFIT : 0;

            cp = _pdp->CpFromPointEx(
                            ili, yli,
                            cp, pt,
                            &rp, &ptp, NULL, dwFlags,
                            &phti->_phtr->_fRightOfCp,
                            &fPseudoHit, &presultsHitTest->_cchPreChars,
                            &presultsHitTest->_fGlyphHit,
                            &presultsHitTest->_fBulletHit, NULL);

            if (   cp < pElementDispNode->GetFirstCp() - 1
                || cp > pElementDispNode->GetLastCp() + 1
               )
            {
                return FALSE;
            }

            presultsHitTest->_iliHit = rp;
            presultsHitTest->_ichHit = rp.RpGetIch();


            if (!fBrowseMode && ptp->IsNode() && ptp->ShowTreePos()
                             && (cp + 1 == ptp->GetBranch()->Element()->GetFirstCp()))
            {
                htc        = HTC_YES;
                pNodeHit   = ptp->GetBranch();
                presultsHitTest->_fWantArrow = TRUE;
            }
            else
            {
                htc = pFL->BranchFromPointEx(pt, rp, ptp,
                                    pElementDispNode->GetFirstBranch(),
                                    &pNodeHit,
                                    fPseudoHit,
                                    &presultsHitTest->_fWantArrow,
                                    dwFlags & CDisplay::CFP_IGNOREBEFOREAFTERSPACE);
            }
        }
        else
        {
            pNodeHit                 = pElementDispNode->GetFirstBranch();
            presultsHitTest->_iliHit = ili;
            presultsHitTest->_ichHit = 0;
        }

        presultsHitTest->_cpHit  = cp;

        if (htc != HTC_YES)
        {
            presultsHitTest->_fWantArrow = TRUE;
        }
        else
        {
            // pNodeHit is the child of the Flowlayout owner of this cache.
            // if it should NOT have layout, or is the owner themself, then
            //     register this information in the HTI and return success.
            // If, on the other hand, this child should have layout then we are in
            //    one of 2 cases:
            //      1> the child is higher in the z-order and previously declined the hit.
            //         in this case, we should only touch the HTI if there is NOTHING there
            //         already, and that should only be to add ourselves to it. i.e. the
            //          child said NO, and no one else is registered for the hit.
            //      2> the child is below our content in the z-order, and so hasn't been
            //          hit test yet by the display tree. in this case, don't touch the
            //          HTI (unles it is empty) since if the child is hit, they will override anyhow
            htc = (   pNodeHit
                   && (   pNodeHit == pElementDispNode->GetFirstBranch()
                       || !pNodeHit->ShouldHaveLayout()
                  )   ) ? HTC_YES : HTC_NO;

            if (htc == HTC_YES
                && !(fPseudoHit && phti->_pDispNode)
                )
            {
                phti->_ptContent    = *pptHit;
                phti->_pDispNode    = pDispNode;
                phti->_pNodeElement = pNodeHit;
            }
            else if (phti->_pNodeElement == NULL)
            {
                Assert(pNodeHit != pElementDispNode->GetFirstBranch());

                // register ourselves as the soft hit, since no one previous has.
                phti->_pNodeElement = pElementDispNode->GetFirstBranch();
            }
        }

        phti->_htc = htc;

        // If this is not a pseudo hit then just return the current settings.
        // If this IS a pseudo hit, we are hit on nested relative lines and so, return FALSE to
        // allow the hit testing process to continue, but leave the data in the HitTestInfo so
        // that if nothing else is a hit, then this data is returned.
        return (fPseudoHit) ? FALSE : htc == HTC_YES;
    }
    else
        return FALSE;
}

BOOL
CRelDispNodeCache::HitTestFuzzy(
    const POINT *pptHitInBoxCoords,
    CDispNode *pDispNode,
    void *pClientData)
{
    // no fuzzy hit test
    return FALSE;
}

LONG
CRelDispNodeCache::CompareZOrder(
    CDispNode const* pDispNode1,
    CDispNode const* pDispNode2)
{
    CElement *  pElement1 = ::GetDispNodeElement(pDispNode1);
    CElement *  pElement2 = ::GetDispNodeElement(pDispNode2);

    return pElement1 != pElement2
                ? pElement1->CompareZOrder(pElement2)
                : 0;
}

LONG
CRelDispNodeCache::GetZOrderForSelf(CDispNode const* pDispNode)
{
    CElement *  pElement = ::GetDispNodeElement(pDispNode);
    if( pElement && pElement->GetFirstBranch())
        return pElement->GetFirstBranch()->GetCascadedzIndex();
    else
        return -1;
}


//+----------------------------------------------------------------------------
//
// Function:    CRelDispNodeCache::DrawClient
//
// Synopsis:    Draw the background of the given disp node
//
//-----------------------------------------------------------------------------
void
CRelDispNodeCache::DrawClientBackground(
    const RECT* prcBounds,
    const RECT* prcRedraw,
    CDispSurface *pSurface,
    CDispNode *pDispNode,
    void *pClientData,
    DWORD dwFlags)
{
    long            lEntry = GetRelCacheEntry(pDispNode);

    Assert(Size() && lEntry >= 0 && lEntry < Size());

    if (lEntry >= 0)
    {
        Assert(pClientData);

        CFormDrawInfo * pDI = (CFormDrawInfo *)pClientData;
        CSetDrawSurface sds(pDI, prcBounds, prcRedraw, pSurface);
        CRelDispNode *  prdn;

        prdn = (*this)[lEntry];

        Assert(!prdn->GetElement()->ShouldHaveLayout());

        CTreePos *  ptp;
        CDisplay *  pdp = GetDisplay();
        long        cp;

        prdn = (*this)[lEntry];

        ((CRect &)(pDI->_rcClip)).IntersectRect(*prcBounds);

        prdn->GetElement()->GetTreeExtent(&ptp, NULL);

        cp = ptp->GetCp();

        // Draw background and border of the current relative
        // element or any of it's descendents.
        pdp->DrawRelElemBgAndBorder(cp, ptp, prdn, prcBounds, prcRedraw, pDI);
    }
}

//+----------------------------------------------------------------------------
//
// Function:    CRelDispNodeCache::DrawClient
//
// Synopsis:    Draw the given disp node
//
//-----------------------------------------------------------------------------
void
CRelDispNodeCache::DrawClient(
    const RECT* prcBounds,
    const RECT* prcRedraw,
    CDispSurface *pSurface,
    CDispNode *pDispNode,
    void *cookie,
    void *pClientData,
    DWORD dwFlags)
{
    CRelDispNode *  prdn;
    long            lEntry = GetRelCacheEntry(pDispNode);

    Assert(Size() && lEntry >= 0 && lEntry < Size());

    if (lEntry >= 0)
    {
        Assert(pClientData);

        // draw the lines here
        CFormDrawInfo * pDI = (CFormDrawInfo *)pClientData;
        CSetDrawSurface sds(pDI, prcBounds, prcRedraw, pSurface);

        prdn = (*this)[lEntry];

        Assert(!prdn->GetElement()->ShouldHaveLayout());

        //
        // Draw the lines that correspond to the given disp node
        //
        XHDC        hdc = pDI->GetDC();
        long        ili;
        CTreePos *  ptp;
        CDisplay *  pdp = GetDisplay();
        CElement *  pElementFL = pdp->GetFlowLayoutElement();
        CLineCore * pli;
        CLSRenderer lsre(pdp, pDI);
        long        cp;

        CLayoutContext *pLayoutContext  = pdp->GetFlowLayout()->LayoutContext();
        BOOL            fViewChain      = pLayoutContext && pLayoutContext->ViewChain();

        if (!lsre.GetLS())
            return;

        prdn = (*this)[lEntry];

        ((CRect &)(pDI->_rcClip)).IntersectRect(*prcBounds);

        lsre.StartRender(*prcBounds, pDI->_rcClip, -1, -1);

        prdn->GetElement()->GetTreeExtent(&ptp, NULL);

        cp = ptp->GetCp();

        if (fViewChain)
        {
            //
            //  In print view probably correction should be made (cp and lsre)
            //

            Assert(pLayoutContext);

            CLayoutBreak *  pLayoutBreak;
            long            cpStart;
            pLayoutContext->GetLayoutBreak(pElementFL, &pLayoutBreak);

            if (pLayoutBreak)
            {
                cpStart = DYNCAST(CFlowLayoutBreak, pLayoutBreak)->GetMarkupPointer()->GetCp();

                //  This means that relatively positioned element (span) is broken and we need to
                //  advance cp and lsre to the beginning of the element on the curent line.
                if (cp < cpStart)
                {
                    cp = cpStart;
                }
            }
        }

        if ( !prdn->_pDispNode->IsContainer())
        {
            // If the current relative element is not a container,
            // draw its background and border (or those of its
            // descendents).  Containers have their background
            // drawn via DrawClientBackground().
            pdp->DrawRelElemBgAndBorder(cp, ptp, prdn, prcBounds, prcRedraw, pDI);
        }

        lsre.SetCurPoint(CPoint(0, prcBounds->top - prdn->_ptOffset.y));

        if (fViewChain)
        {
            //  In print view ptp probably should be updated
            lsre.SetCp(cp, NULL);
            ptp = lsre.GetPtp();
        }
        else
        {
            lsre.SetCp(cp, ptp);
        }

        for (ili = prdn->_ili; ili < prdn->_ili + prdn->_cLines; ili++)
        {
            //
            // Find the current relative node that owns the current line
            //
            CTreeNode * pNodeRelative =
                            ptp->GetBranch()->GetCurrentRelativeNode(pElementFL);

            pli = pdp->Elem(ili);

            //
            // Skip the current line if the owner is not the same element
            // that owns the current display node.
            //
            if( pNodeRelative && pNodeRelative->Element() != prdn->GetElement())
            {
                lsre.SkipCurLine(pli);
            }
            else
            {
                CLineFull lif = *pli;
                lsre.RenderLine(lif, prcBounds->left - prdn->_ptOffset.x);
            }

            Assert(pli == pdp->Elem(ili));

            ptp = lsre.GetPtp();
            // It's possible for the renderer to return a pointer treepos; this is no good
            // to us, since we need the next content related node.  Keep walking till we
            // find one. (Bug #72264).
            while ( ptp->Type() == CTreePos::EType::Pointer )
            {
                ptp = ptp->NextTreePos();
            }
        }

        //
        // restore the original text align, the renderer might have modified the
        // text align. This caused some pretty bad rendering problems(specially with
        // radio buttons).
        //
        if (lsre._lastTextOutBy != CLSRenderer::DB_LINESERV)
        {
            lsre._lastTextOutBy = CLSRenderer::DB_NONE;
            SetTextAlign(hdc, TA_TOP | TA_LEFT);
        }
    }
}

//+----------------------------------------------------------------------------
//
// Member:      CDisplay::DrawRelElemBgAndBorder
//
// Synopsis:    CDisplay::DrawRelElemBgAndBorder draws the backround or borders
//              on itself and any child elements that are not relative.
//
//-----------------------------------------------------------------------------
void
CDisplay::DrawRelElemBgAndBorder(
    long            cp,
    CTreePos      * ptp,
    CRelDispNode  * prdn,
    const RECT    * prcView,
    const RECT    * prcClip,
    CFormDrawInfo * pDI)
{
    CDataAry <RECT> aryRects(Mt(CDisplayDrawRelElemBgAndBorder_aryRects_pv));
    CLineCore   *   pli;
    CFlowLayout *   pFlowLayout     = GetFlowLayout();
    CMarkup     *   pMarkup         = pFlowLayout->GetContentMarkup();
    BOOL            fPaintBackground= pMarkup->PaintBackground();
    long            iliStop = min(LineCount(), prdn->_ili + prdn->_cLines);
    long            yli     = - prdn->_ptOffset.y;
    long            cpLine;
    long            cpNextLine;
    long            cpPtp;
    long            ili, ich;
    CPoint          ptOffset = prdn->_ptOffset;

    // If the disp node has a content origin, incorporate that into the offset
    if (prdn->_pDispNode->HasContentOrigin())
        ptOffset += prdn->_pDispNode->GetContentOrigin();

    ptOffset.x = -ptOffset.x;
    ptOffset.y = -ptOffset.y - prdn->_yli;

    cpPtp = cpLine = cpNextLine = cp;
    for (ili = prdn->_ili; ili < iliStop && yli < prcClip->bottom; ili++)
    {
        pli = Elem(ili);

        cpNextLine += pli->_cch;

        if (pli->_fForceNewLine)
            yli += pli->_yHeight;

        if (pli->_cch)
        {
            if (    (fPaintBackground && pli->_fHasBackground)
                ||  pli->_fHasParaBorder)
            {
                if(cpPtp < cpLine)
                {
                    ptp = pMarkup->TreePosAtCp(cpLine, &ich);

                    cpPtp = cpLine;
                    if(ich)
                    {
                        cpPtp += ptp->Cch() - ich; // (olego) fix for 26845
                        ptp = ptp->NextTreePos();
                        Assert(cpPtp == ptp->GetCp());
                    }
                }

                while(cpNextLine > cpPtp)
                {
                    if(ptp->IsBeginElementScope())
                    {
                        CTreeNode * pNode = ptp->GetBranch();
                        CElement  * pElement = pNode->Element();
                        const CCharFormat * pCF = pNode->GetCharFormat();
                        const CFancyFormat* pFF = pNode->GetFancyFormat();

                        if(     pCF->IsVisibilityHidden() || pCF->IsDisplayNone()
                            ||  (cp != cpPtp && (pFF->_fRelative || pNode->ShouldHaveLayout())))
                        {
                            pElement->GetTreeExtent(NULL, &ptp);
                            ptp = ptp->NextTreePos();
                            cpPtp = ptp->GetCp();
                            continue;
                        }
                        else
                        {
                            BOOL fDrawBackground = fPaintBackground &&
                                                     pFF->_fBlockNess &&
                                                    (pFF->_lImgCtxCookie ||
                                                     pFF->_ccvBackColor.IsDefined());
                            BOOL fDrawBorder     = pCF->_fPadBord &&
                                                   pFF->_fBlockNess;

                            // Draw the background if the element comming into scope
                            // has background or border.
                            if ( fDrawBackground || fDrawBorder)
                            {
                                DrawElemBgAndBorder(
                                    pElement, &aryRects,
                                    prcView, prcClip,
                                    pDI, &ptOffset,
                                    fDrawBackground, fDrawBorder, -1, -1, !pCF->_cuvLineHeight.IsNull(), TRUE);
                            }
                        }

                    }
                    cpPtp += ptp->GetCch();
                    ptp    = ptp->NextTreePos();
                }
            }
        }

        cpLine = cpNextLine;
    }
}

//+----------------------------------------------------------------------------
//
// Member:      CDisplay::ClearStoredRFEs
//
// Synopsis:    Clears CDisplay's cache of precalculated RFE results for 
//              block elements. Used in drawing their backgrounds and borders.
//
//-----------------------------------------------------------------------------

//This struct will hold result of RFE - aryRect and rcBound
class CStoredRFE
{
public:
    DECLARE_MEMALLOC_NEW_DELETE(Mt(MtStoredRFE))

    RECT _rcBound;

    DECLARE_CDataAry(CRectAry, RECT, Mt(Mem), Mt(MtStoredRFE_aryRect_pv))
    CRectAry _aryRects;
};

//Clears cache of stored RFEs - called when we reclac or die.
void 
CDisplay::ClearStoredRFEs()
{
    UINT index;
    
    CStoredRFE *pRFE = (CStoredRFE *) _htStoredRFEs.GetFirstEntry(&index);

    while(pRFE)
    {
        delete pRFE;
        pRFE = (CStoredRFE *) _htStoredRFEs.GetNextEntry(&index);
    }

    _htStoredRFEs.ReInit();
}



//+----------------------------------------------------------------------------
//
// Member:      CDisplay::DrawElemBgAndBorder
//
// Synopsis:    Draw the border and background on an element if any. cpStart
//              and cpFinish define the clip region. iRunStart and iRunFinish
//              are for performance reasons so that we dont have run around in
//              the tree for the element.
//
//-----------------------------------------------------------------------------

void
CDisplay::DrawElemBgAndBorder(
                     CElement        *  pElement,
                     CDataAry <RECT> *  paryRects,
                     const RECT      *  prcView,
                     const RECT      *  prcClip,
                     CFormDrawInfo   *  pDI,
                     const CPoint    *  pptOffset,
                     BOOL               fDrawBackground,
                     BOOL               fDrawBorder,
                     LONG               cpStart,
                     LONG               cpFinish,
                     BOOL               fClipToCPs,
                     BOOL               fNonRelative,
                     BOOL               fPseudo)
{
    Assert (pElement && pDI && prcView && prcClip && paryRects);
    Assert (!pElement->ShouldHaveLayout());

    // If a clip range has been specified (e.g. either cpStart or cpFinish
    // is not -1), then we want a bounding rect.
    RECT        rcBound;
    RECT *      prcBound = ((pElement->IsBlockElement() || cpStart != -1 || cpFinish != -1)
                                    ? &rcBound
                                    : NULL);

    Assert ( fDrawBorder || fDrawBackground );

    CPoint  ptOffset(((CRect *)prcView)->TopLeft());

    // TODO RTL 112514: this won't work with relative positioning
    if (IsRTLDisplay())
        ptOffset.x = 0;

    if (pptOffset)
    {
        ptOffset += (SIZE &)*pptOffset;
    }

    DWORD dwRFEFlags = RFE_BACKGROUND;

    if ( fNonRelative )
        dwRFEFlags |= RFE_IGNORE_RELATIVE;

#if 0
    // If we're not drawing borders, we don't need to compute the
    // region for the whole element, only for what's visible.
    // fDrawBorder is sometimes true even when we don't have a border,
    // because some callers pass in the PF's _fPadBord, which is true
    // if either padding or borders exist -- hence we also look at
    // _fDefinitelyNoBorders.
    // (clipping to visible in the border drawing case would cause
    // them to appear around the visible part of the element,
    // instead of the entire element).

    // Sujalp and KTam: Temp fix for bug 82208 -- need better fix
    if ( !fDrawBorder || pElement->_fDefinitelyNoBorders )
        dwRFEFlags |= RFE_CLIP_TO_VISIBLE;
#endif

    if (!fDrawBorder || pElement->_fDefinitelyNoBorders)
        dwRFEFlags |= RFE_ONLY_BACKGROUND;

    //Call RFE for the element to calc where to draw background/border
    //Use cache to avoid unneccessary calls to RFE.
    {
        CStoredRFE *pStoredRFE = (CStoredRFE *) _htStoredRFEs.Lookup(pElement);

        if (pStoredRFE && !fClipToCPs)  
        {
            // We have cached result of RFE - use it
            paryRects->Copy(pStoredRFE->_aryRects, FALSE);
            *prcBound = pStoredRFE->_rcBound;
        }
        else
        {
            //(dmitryt) changed to -1 because since we don't pass RFE_CLIP_TO_VISIBLE flag,
            // RFE will go through entire range of pElement anyway, it only will not append
            // the rects lying outside of the cp range to the output aryRect.
            // Ideally this "optimization" in RFE should be fixed away since it doesn't 
            // really save much. Also it breaks our caching here because we can cache 
            // incomplete region. So for now (IE6 RC) I remove cpStart/cpFinish from here.

            // (gschneid) In case of pseudo we have to take care about cpStart and cpEnd because
            // we only want to render the first-line or first-element.

            // (grzegorz) fClipToCPs is set to true in case of:
            // * pseudo elements (see comment above)
            // * explicit line height, in this case we may have overlapping lines
            //   and this may cause drawing background for a line which is visible,
            //   but hasn't been drawn because the previous line goes beyond clipping
            //   rect
            if (fClipToCPs)
            {
                RegionFromElement(pElement, paryRects, &ptOffset, pDI,
                    dwRFEFlags, cpStart, cpFinish, prcBound);
            }
            else
            {
                RegionFromElement(pElement, paryRects, &ptOffset, pDI,
                    dwRFEFlags, -1, -1, prcBound);
            }
            
            if (!fClipToCPs)
            {
                //Cache result of RFE for later use (painting, 
                // scrolling and banding benefit from it)
                pStoredRFE = new CStoredRFE();
                pStoredRFE->_aryRects.Copy(*paryRects, FALSE);
                pStoredRFE->_rcBound = *prcBound;
                _htStoredRFEs.Insert(pElement, pStoredRFE);
            }
        }
    }

    if(paryRects->Size())
    {

        // now that we have its region render its background or border
        if(fDrawBackground)    // if we have background color
        {
            // draw element background

            DrawElementBackground(pElement->GetFirstBranch(), paryRects, prcBound,
                                    prcView, prcClip,
                                    pDI, fPseudo);
                                    
        }

        if (fDrawBorder)
        {

            // Draw a border if necessary
            DrawElementBorder(pElement->GetFirstBranch(), paryRects, prcBound,
                                prcView, prcClip,
                                pDI);
                                
        }
    }
}

CDispNode *
CRelDispNodeCache::FindElementDispNode(CElement * pElement)
{
    int lSize = _aryRelDispNodes.Size();

    if (lSize)
    {
        CRelDispNode * prdn = _aryRelDispNodes;
        for (; lSize ; lSize--, prdn++)
        {
            if(prdn->GetElement() == pElement)
            {
                return prdn->_pDispNode;
            }
        }
    }
    return NULL;
}

void
CRelDispNodeCache::Delete(long iPosFrom, long iPosTo)
{
    // we need to clearContents on each item
    if (iPosTo >= iPosFrom)
    {
        int            i = iPosFrom;
        CRelDispNode * prdn = (*this)[i];

        for (; i<=iPosTo; i++, prdn++)
        {
            prdn->SetElement( NULL );
        }
    }

    _aryRelDispNodes.DeleteMultiple(iPosFrom, iPosTo);
}

void
CRelDispNodeCache::SetElementDispNode(
    CElement *  pElement,
    CDispNode * pDispNode)
{
    Assert(pElement);
    Assert(pDispNode);

    int lSize = _aryRelDispNodes.Size();

    if (lSize)
    {
        CRelDispNode * prdn = _aryRelDispNodes;
        for (; lSize ; lSize--, prdn++)
        {
            if(prdn->GetElement() == pElement)
            {
                prdn->_pDispNode = pDispNode;
            }
        }
    }
}

void
CRelDispNodeCache::EnsureDispNodeVisibility(
    CElement * pElement)
{
    CLayout *       pLayout = _pdp->GetFlowLayout();
    CRelDispNode *  prdn    = _aryRelDispNodes;
    long            cSize   = _aryRelDispNodes.Size();

    for (; cSize; prdn++, cSize--)
    {
        if (    !pElement
            ||  prdn->GetElement() == pElement)
        {
            pLayout->EnsureDispNodeVisibility(prdn->GetElement(), prdn->_pDispNode);
        }
    }
}

void
CRelDispNodeCache::HandleDisplayChange()
{
    CRelDispNode *  prdn    = _aryRelDispNodes;
    long            cSize   = _aryRelDispNodes.Size();
    BOOL            fDisplayNone = _pdp->GetFlowLayoutElement()->IsDisplayNone();

    for (; cSize; prdn++, cSize--)
    {
        if (fDisplayNone || prdn->GetElement()->IsDisplayNone())
        {
            _pdp->GetFlowLayout()->GetView()->ExtractDispNode(prdn->_pDispNode);
        }
        else
        {
            CPoint ptAuto(prdn->_ptOffset.x, prdn->_ptOffset.y + prdn->_yli);

            prdn->GetElement()->ZChangeElement(NULL, &ptAuto);
        }
    }
}

void
CRelDispNodeCache::DestroyDispNodes()
{
    long lSize = _aryRelDispNodes.Size();

    if (lSize)
    {
        CRelDispNode *  prdn;
        for (prdn = (*this)[0]; lSize; lSize--, prdn++)
        {
            prdn->ClearContents();
        }
    }
}

void
CRelDispNodeCache::Invalidate(
    CElement *pElement,         // Relative element to invalidate
    const RECT * prc /*=NULL*/, // array of rects describing region to inval
    int nRects /*=1*/ )         // count of rects in array
{
    // The element must itself actually be relative; it is insufficient for
    // it to have "inherited" relativeness (see element.hxx discussion of
    // IsRelative vs. IsInheritingRelativeness), since the RDNC tracks only
    // only relative elements and not their children.
    // We could use GetCurrentRelativeNode() instead of relying on the caller
    // to do that, but it would require an additional param (pElementFL)
    // that might obfuscate.
    Assert( pElement->IsRelative() );

    CDispNode *pDispNode = FindElementDispNode( pElement );

    // If callers pass a relative element that we aren't responsible for, then
    // bail!  This shouldn't happen.
    if ( !pDispNode )
    {
        // NOTE: this assert is valid.  See CFlowLayout::Notify() comments
        // on handling of invalidation.
        //Assert( FALSE && "Caller passed a relative element that doesn't belong to this RDNC!" );
        return;
    }

    if ( _pdp->GetFlowLayout()->Doc()->_state >= OS_INPLACE )
    {
        if ( _pdp->GetFlowLayout()->OpenView())
        {
            // Incoming rects are in the coordinate system of the
            // flow layout.  We need to convert them into the system
            // of the dispnode, so we need the flow offset of the
            // dispnode..
            CPoint pt;
            _pdp->GetRelNodeFlowOffset( pDispNode, &pt );

            // Conversion involves subtracting flow offset of dispnode
            // from each rect:
            pt.x = -pt.x;
            pt.y = -pt.y;

            Assert( prc );
            for (int i=0; i < nRects; i++, prc++)
            {
                ::OffsetRect( (RECT *)prc, pt.x, pt.y );
                pDispNode->Invalidate((CRect &)*prc, COORDSYS_FLOWCONTENT);
            }
        }
    }
}


void
CDisplay::GetRelNodeFlowOffset(CDispNode * pDispNode, CPoint *ppt)
{
    CRelDispNode      * prdn;
    CRelDispNodeCache * prdnc = GetRelDispNodeCache();
    long                lEntry = (LONG)(LONG_PTR)pDispNode->GetExtraCookie();

    Assert(prdnc);
    Assert(prdnc == pDispNode->GetDispClient());
    Assert(lEntry >= 0 && lEntry < prdnc->Size());


    prdn = (*prdnc)[lEntry];

    Assert(prdn->_pDispNode == pDispNode);

    ppt->x = prdn->_ptOffset.x;
    ppt->y = prdn->_ptOffset.y + prdn->_yli;
}

void
CDisplay::GetRelElementFlowOffset(CElement * pElement, CPoint *ppt)
{
    CRelDispNode      * prdn;
    CRelDispNodeCache * prdnc = GetRelDispNodeCache();
    long                lEntry, lSize;

    *ppt = g_Zero.pt;

    if(prdnc)
    {
        lSize = prdnc->Size();
        prdn  = (*prdnc)[0];

        for(lEntry = 0; lEntry < lSize; lEntry++, prdn++)
        {
            if (prdn->GetElement() == pElement)
            {
                ppt->x = prdn->_ptOffset.x;
                ppt->y = prdn->_ptOffset.y + prdn->_yli;
            }
        }
    }
}


void
CDisplay::TranslateRelDispNodes(const CSize & size, long lStart)
{
    CDispNode         * pDispNode;
    CRelDispNodeCache * prdnc = GetRelDispNodeCache();
    CRelDispNode      * prdn;
    long                lSize = prdnc->Size();
    long                lEntry;
    long                iLastLine = -1;

    Assert(lSize && lStart < lSize);

    prdn = (*prdnc)[lStart];

    for(lEntry = lStart; lEntry < lSize; lEntry++, prdn++)
    {
        if (iLastLine <= prdn->_ili)
        {
            pDispNode = prdn->_pDispNode;
            pDispNode->SetPosition(pDispNode->GetPosition() + size);
            iLastLine = prdn->_ili + prdn->_cLines;
        }
    }
}


void
CDisplay::ZChangeRelDispNodes()
{
    CRelDispNodeCache * prdnc = GetRelDispNodeCache();
    CRelDispNode      * prdn;
    long                cEntries = prdnc->Size();
    long                iEntry   = 0;
    long                iLastLine = -1;

    Assert( cEntries
        &&  iEntry < cEntries);

    prdn = (*prdnc)[iEntry];

    for(; iEntry < cEntries; iEntry++, prdn++)
    {
        if (iLastLine < prdn->_ili)
        {
            prdn->GetElement()->ZChangeElement();
            iLastLine = prdn->_ili + prdn->_cLines;
        }
    }
}

//
// Calculate content origin for relative disp node
// This is slightly different from SizeRTLDispNode because the relative disp nodes
// have random sizes and offsets, so their content origins can't be calculated from
// CDisplay data.
//
void
CDisplay::SetRelDispNodeContentOrigin(CDispNode *pDispNode)
{
    if(pDispNode && pDispNode->HasContentOrigin())
    {
        // This is an RTL case. If not, we need to check for something else, as this is RTL-specific
        Assert(IsRTLDisplay());

        // We only care about containers, because other nodes get positioned relatively to them.
        int cxOrigin = GetRTLOverflow();

        // When this is called, the relative position has not been set yet.
        // Any offset from left that the node has, is due to its calculated bounds.
        // We need to adjust content origin so that any nested content gets positioned correctly.
        cxOrigin -= pDispNode->GetPosition().x;

        // TODO RTL 112514: figure out where to get offset from right (and do we need to?)
        pDispNode->SetContentOrigin(CSize(cxOrigin, 0), -1);
    }
    else
    {
        // If we have a disp node, it must have content origin allocated.
        // If it doesn't, it means that GetDispNodeInfo() is buggy
        AssertSz(!pDispNode, "No content origin on an RTL flow node ???");
    }

}

BOOL CDisplay::IsLogicalFirstFrag(const LONG ili)
{
    BOOL fFirstLogicalFrag;
    CLineCore *pli = Elem(ili);

    fFirstLogicalFrag = pli->_fFirstFragInLine;

    if (pli->_fRelative && !pli->_fFirstFragInLine && !pli->IsFrame() && !pli->IsClear() && !pli->_fDummyLine)
    {
        Assert(pli->_fPartOfRelChunk);

        CLineCore *pliCore;
        for(LONG i = ili - 1; i >= 0; i--)
        {
            pliCore = Elem(i);
            Assert(pliCore->_fPartOfRelChunk);

            // There exists a line before which has width and hence
            // this line (ili) is truly not the first frag
            if (pliCore->_xWidth != 0)
                break;

            // If we reached the first frag without running into a frag
            // which has width, then this line is the logical first line
            if (pliCore->_fFirstFragInLine)
            {
                fFirstLogicalFrag = TRUE;
                break;
            }

            AssertSz(i != 0, "We should never since we should find a firstfragline.");
        }
    }

    return fFirstLogicalFrag;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\text\segment.cxx ===
//+----------------------------------------------------------------------------
//
// File:        Segment.CXX
//
// Contents:    Implementation of CSegment and CElementSegment class
//
// Copyright (c) 1998 Microsoft Corporation. All rights reserved.
//
//
//-----------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_SEGMENT_HXX_
#define X_SEGMENT_HXX_
#include "segment.hxx"
#endif

#ifndef X_INITGUID_H_
#define X_INITGUID_H_
#include "initguid.h"
#endif

PRIVATE_GUID(CLSID_CSegment, 0x3050f693, 0x98B5, 0x11CF, 0xBB, 0x82, 0x00, 0xAA, 0x00, 0xBD, 0xCE, 0x0B)

MtDefine(CCaretSegment, Utilities, "CCaretSegment")
MtDefine(CSegment, Utilities, "CSegment")
MtDefine(CElementSegment, Utilities, "CElementSegment")

#define IFC(expr) {hr = THR(expr); if (FAILED(hr)) goto Cleanup;}

//-----------------------------------------------------------------------------
//
//  Function:   CSegment::CSegment
//
//  Synopsis:   Constructor
//
//-----------------------------------------------------------------------------
CSegment::CSegment()
{
    Assert( _pIStart == NULL );
    Assert( _pIEnd == NULL );
    Assert( _pPrev == NULL );
    Assert( _pNext == NULL );

    _ulRefs = 1;
}

//+-------------------------------------------------------------------------
//
//  Method:     CSegment::~CSegment
//
//  Synopsis:   Destructor
//
//--------------------------------------------------------------------------
CSegment::~CSegment(void)
{
#if DBG == 1
    // Verify that no other elements in the list are 
    // referencing this object
    if( GetPrev() )
        Assert( GetPrev()->GetNext() != this );

    if( GetNext() )
        Assert( GetNext()->GetPrev() != this );
#endif        
    ReleaseInterface(_pIStart);
    ReleaseInterface(_pIEnd);
}


//+-------------------------------------------------------------------------
//
//  Method:     CSegment::Init
//
//  Synopsis:   Initializes a segment.  Makes a copy of the markup pointers
//              passed in.
//
//  Arguments:  pIStart = Start of segment
//              pIEnd = End of segment
//
//  Returns:    HRESULT indicating success
//
//--------------------------------------------------------------------------
HRESULT
CSegment::Init( IMarkupPointer  *pIStart,
                IMarkupPointer  *pIEnd )
{
    HRESULT hr = E_INVALIDARG;

    Assert( pIStart && pIEnd );

    if( pIStart && pIEnd )
    {
        _pIStart = pIStart;
        _pIStart->AddRef();

        _pIEnd = pIEnd;
        _pIEnd->AddRef();

        hr = S_OK;
    }        

    RRETURN( hr );
}

//+-------------------------------------------------------------------------
//
//  Method:     CSegment::GetPointers   
//
//  Synopsis:   Sets pIStart and pIEnd to the beginning and end of the
//              current segment, respectively
//
//  Arguments:  pIStart = Pointer to move to the start
//              pIEnd = Pointer to move to the end
//
//  Returns:    HRESULT indicating success
//
//--------------------------------------------------------------------------
HRESULT
CSegment::GetPointers(  IMarkupPointer *pIStart,
                        IMarkupPointer *pIEnd )
{
    HRESULT hr = E_INVALIDARG;
    BOOL    fResult = FALSE;
    
    Assert( pIStart && pIEnd );

    if( pIStart && pIEnd )
    {
        //
        // Position the pointers in the correct order
        //
        IFC( _pIStart->IsLeftOfOrEqualTo( _pIEnd, &fResult ) );

        if( fResult )
        {
            IFC( pIStart->MoveToPointer( _pIStart ) );
            IFC( pIEnd->MoveToPointer( _pIEnd ) );
        }
        else
        {
            IFC( pIStart->MoveToPointer( _pIEnd ) );
            IFC( pIEnd->MoveToPointer( _pIStart ) );
        }
            
        //
        // Set the gravity up for the commands
        //
        IFC( pIStart->SetGravity( POINTER_GRAVITY_Right ) );
        IFC( pIEnd->SetGravity( POINTER_GRAVITY_Left ) );
    }        

Cleanup:

#if DBG == 1
    if( hr == S_OK )
    {
        BOOL fPositionedStart = FALSE;
        BOOL fPositionedEnd = FALSE;

        IGNORE_HR( pIStart->IsPositioned( & fPositionedStart ));
        IGNORE_HR( pIEnd->IsPositioned( & fPositionedEnd ));

        Assert( fPositionedStart && fPositionedEnd );
    }        
#endif

    RRETURN( hr );
}

//////////////////////////////////////////////////////////////////////////
//
//  IUnknown's Implementation
//
//////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CSegment::QueryInterface(
    REFIID  iid, 
    LPVOID  *ppvObj )
{
    if (!ppvObj)
        RRETURN(E_INVALIDARG);
  
    if( iid == IID_IUnknown || iid == IID_ISegment )
    {
        *ppvObj = (ISegment *)this;
    }
    else if( iid == CLSID_CSegment )
    {
        *ppvObj = this;
        return S_OK;
    }
    else
    {
        *ppvObj = NULL;
        RRETURN_NOTRACE(E_NOINTERFACE);
    }

    ((IUnknown *)(*ppvObj))->AddRef();

    return S_OK;
}

//-----------------------------------------------------------------------------
//
//  Function:   CElementSegment::CElementSegment
//
//  Synopsis:   Constructor
//
//-----------------------------------------------------------------------------
CElementSegment::CElementSegment() : CSegment()
{
    Assert( _pIElement == NULL );
    _ulRefs = 1;
}

//+-------------------------------------------------------------------------
//
//  Method:     CElementSegment::~CElementSegment
//
//  Synopsis:   Destructor
//
//--------------------------------------------------------------------------
CElementSegment::~CElementSegment(void)
{
    ReleaseInterface(_pIElement);
}


//+-------------------------------------------------------------------------
//
//  Method:     CElementSegment::Init
//
//  Synopsis:   Initializes a segment around an IHTMLElement.
//
//  Arguments:  pIElement = IHTMLElement to initialize segment around
//
//  Returns:    HRESULT indicating success
//
//--------------------------------------------------------------------------
HRESULT
CElementSegment::Init( IHTMLElement *pIElement )
{
    HRESULT hr = E_INVALIDARG;

    Assert( pIElement );

    if( pIElement )
    {
        _pIElement = pIElement;
        _pIElement->AddRef();
        hr = S_OK;
    }        

    RRETURN( hr );
}

//+-------------------------------------------------------------------------
//
//  Method:     CElementSegment::GetPointers   
//
//  Synopsis:   Sets pIStart and pIEnd to the beginning and end of the
//              IHTMLElement for the element segment
//
//  Arguments:  pIStart = Pointer to move to the start
//              pIEnd = Pointer to move to the end
//
//  Returns:    HRESULT indicating success
//
//--------------------------------------------------------------------------
HRESULT
CElementSegment::GetPointers(   IMarkupPointer *pIStart,
                                IMarkupPointer *pIEnd )
{
    HRESULT hr = E_INVALIDARG;

    Assert( pIStart && pIEnd );

    if( pIStart && pIEnd )
    {
        // Position the pointers
        IFC( ( pIStart->MoveAdjacentToElement(_pIElement, ELEM_ADJ_BeforeBegin) ) );
        IFC( ( pIEnd->MoveAdjacentToElement(_pIElement, ELEM_ADJ_AfterEnd) ) );

        // Setup the gravity
        IFC( pIStart->SetGravity( POINTER_GRAVITY_Right ) );
        IFC( pIEnd->SetGravity( POINTER_GRAVITY_Left ) );        

        hr = S_OK;
    }        

Cleanup:    
    RRETURN( hr );
}

//+-------------------------------------------------------------------------
//
//  Method:     CElementSegment::GetElement
//
//  Synopsis:   Returns the element represented by this segment
//
//  Arguments:  ppIElement = Output pointer to IHTMLElement
//
//  Returns:    HRESULT indicating success
//
//--------------------------------------------------------------------------
HRESULT
CElementSegment::GetElement(IHTMLElement **ppIElement)
{
    HRESULT hr = E_INVALIDARG;

    Assert( ppIElement );

    if( ppIElement )
    {
        hr = _pIElement->QueryInterface(IID_IHTMLElement, (void **)ppIElement );
    }

    RRETURN( hr );
}

HRESULT
CElementSegment::SetPrimary( BOOL fPrimary )
{
    _fPrimary = fPrimary;
    return S_OK;
}

HRESULT
CElementSegment::IsPrimary( BOOL* pfIsPrimary)
{
    Assert( pfIsPrimary );
    if ( pfIsPrimary)
    {
        *pfIsPrimary = _fPrimary;
        return S_OK;
    }
    else
        return E_INVALIDARG;
}
        
//////////////////////////////////////////////////////////////////////////
//
//  IUnknown's Implementation
//
//////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CElementSegment::QueryInterface(
    REFIID  iid, 
    LPVOID  *ppvObj )
{
    if (!ppvObj)
        RRETURN(E_INVALIDARG);
  
    if (iid == IID_IUnknown || iid == IID_ISegment)
    {
        *ppvObj = (ISegment *)((IElementSegment *)this);
    }
    else if (iid == IID_IElementSegment)
    {
        *ppvObj = (IElementSegment *)this;
    }
    else if( iid == CLSID_CSegment )
    {
        *ppvObj = this;
        return S_OK;
    }   
    else
    {
        *ppvObj = NULL;
        RRETURN_NOTRACE(E_NOINTERFACE);
    }

    ((IUnknown *)(*ppvObj))->AddRef();

    return S_OK;
}

//-----------------------------------------------------------------------------
//
//  Function:   CCaretSegment::CCaretSegment
//
//  Synopsis:   Constructor
//
//-----------------------------------------------------------------------------
CCaretSegment::CCaretSegment() : CSegment()
{
    _ulRefs = 1;
    _pICaret = NULL;
}

//+-------------------------------------------------------------------------
//
//  Method:     CCaretSegment::~CCaretSegment
//
//  Synopsis:   Destructor
//
//--------------------------------------------------------------------------
CCaretSegment::~CCaretSegment(void)
{
    ReleaseInterface(_pICaret);
}

//+-------------------------------------------------------------------------
//
//  Method:     CCaretSegment::Init
//
//  Synopsis:   Initializes a caret segment.
//
//  Arguments:  pICaret = Pointer to caret interface
//
//  Returns:    HRESULT indicating success
//
//--------------------------------------------------------------------------
HRESULT
CCaretSegment::Init( IHTMLCaret *pICaret )
{
    HRESULT hr = E_INVALIDARG;

    Assert( pICaret );

    if( pICaret )
    {
        _pICaret = pICaret;
        _pICaret->AddRef();

        hr = S_OK;
    }        

    RRETURN( hr );
}

//+-------------------------------------------------------------------------
//
//  Method:     CCaretSegment::GetPointers   
//
//  Synopsis:   Sets pIStart and pIEnd to the caret position.
//
//  Arguments:  pIStart = Pointer to move to the start
//              pIEnd = Pointer to move to the end
//
//  Returns:    HRESULT indicating success
//
//--------------------------------------------------------------------------
HRESULT
CCaretSegment::GetPointers( IMarkupPointer *pIStart,
                            IMarkupPointer *pIEnd )
{
    HRESULT     hr = S_OK;

    Assert( pIStart && pIEnd );
    
    // Position our pointers at the caret
    IFC( _pICaret->MoveMarkupPointerToCaret( pIStart ) );
    IFC( _pICaret->MoveMarkupPointerToCaret( pIEnd ) );

    // Set up the gravity
    IFC( pIStart->SetGravity( POINTER_GRAVITY_Right ) );
    IFC( pIEnd->SetGravity( POINTER_GRAVITY_Left ) );         

Cleanup:
    RRETURN( hr );
}

//////////////////////////////////////////////////////////////////////////
//
//  IUnknown's Implementation
//
//////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CCaretSegment::QueryInterface(
    REFIID  iid, 
    LPVOID  *ppvObj )
{
    if (!ppvObj)
        RRETURN(E_INVALIDARG);
  
    if (iid == IID_IUnknown || iid == IID_ISegment)
    {
        *ppvObj = (ISegment *)this;
    }
    else
    {
        *ppvObj = NULL;
        RRETURN_NOTRACE(E_NOINTERFACE);
    }

    ((IUnknown *)(*ppvObj))->AddRef();

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\text\seldrag.cxx ===
#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)


#ifndef X_CDUTIL_HXX_
#define X_CDUTIL_HXX_
#include "cdutil.hxx"
#endif

#ifndef X_QI_IMPL_H_
#define X_QI_IMPL_H_
#include "qi_impl.h"
#endif

#ifndef _X_SELDRAG_HXX_
#define _X_SELDRAG_HXX_
#include "seldrag.hxx"
#endif

#ifndef X_XBAG_HXX_
#define X_XBAG_HXX_
#include "xbag.hxx"
#endif

#ifndef X_IRANGE_HXX_
#define X_IRANGE_HXX_
#include "irange.hxx"
#endif

#ifndef X__DXFROBJ_H_
#define X__DXFROBJ_H_
#include "_dxfrobj.h"
#endif

#ifndef X_FLOWLYT_HXX_
#define X_FLOWLYT_HXX_
#include "flowlyt.hxx"
#endif

#ifndef X_TPOINTER_HXX_
#define X_TPOINTER_HXX_
#include "tpointer.hxx"
#endif

#ifndef X_INPUTTXT_HXX_
#define X_INPUTTXT_HXX_
#include "inputtxt.hxx"
#endif

extern const int CFETC;                   // global in dataxfrobj

extern FORMATETC g_rgFETC[];

MtDefine(CDropTargetInfo, Utilities, "CDropTargetInfo ")
MtDefine(CSelDragDropSrcInfo, Utilities, "CSelDragDropSrcInfo")

//
// Constants for comparison of results of IMarkupPointer::Compare method.
//
const int LEFT = 1;   
const int RIGHT = -1 ;
const int SAME = 0;

#define IFC(expr) {hr = THR(expr); if (FAILED(hr)) goto Cleanup;}

HRESULT
OldCompare(IDisplayPointer* pDisp1, IDisplayPointer* pDisp2, int * pi )
{
    HRESULT hr;
    BOOL    fResult;

    Assert(pi);

    IFC( pDisp1->IsEqualTo(pDisp2, &fResult) );
    if (fResult)
    {
        *pi = 0;
        goto Cleanup;
    }
    
    IFC( pDisp1->IsLeftOf(pDisp2, &fResult)  );

    *pi = fResult ? -1 : 1;

Cleanup:
    RRETURN(hr);
}


CDropTargetInfo::CDropTargetInfo(CLayout * pLayout, CDoc* pDoc , POINT pt)
{
    _pDoc = pDoc;

    //  Bug 93494, 101542: If we are dragging within our own instance, we want to check if
    //  we are in the same spot as the initial hit.

    if (pDoc->_pDragDropSrcInfo)
    {
        _ptInitial = pt;
    }
    else
    {
        _ptInitial.x = -1;
        _ptInitial.y = -1;
    }

    Init(  );

    UpdateDragFeedback( pLayout, pt, NULL, TRUE );
}

CDropTargetInfo::~CDropTargetInfo()
{
    ReleaseInterface( _pCaret );
    ReleaseInterface( _pDispPointer );
    ReleaseInterface( _pDispTestPointer );
}

void 
CDropTargetInfo::Init()
{ 
    HRESULT hr;

    IFC( _pDoc->CreateDisplayPointer( & _pDispPointer ));
    IFC( _pDoc->CreateDisplayPointer( & _pDispTestPointer ));
    IFC( _pDoc->GetCaret( & _pCaret ));

Cleanup:
    _fFurtherInStory = FALSE;
    _fPointerPositioned = FALSE;
}
    
void 
CDropTargetInfo::UpdateDragFeedback(CLayout*                pLayout, 
                                    POINT                   pt,
                                    CSelDragDropSrcInfo *   pInfo,
                                    BOOL                    fPositionLastToTest )
{
    HRESULT hr = S_OK;
    BOOL fInside = FALSE;
    BOOL fSamePointer = FALSE;
    int iWherePointer = SAME;
    CPoint ptContent(pt);
    IHTMLElement *pElement = NULL;

    Assert(pLayout && pLayout->ElementContent());
    
    pLayout->TransformPoint( &ptContent, COORDSYS_GLOBAL, COORDSYS_FLOWCONTENT, NULL );

    hr = THR( pLayout->ElementContent()->QueryInterface(IID_IHTMLElement, (LPVOID *)&pElement) );
    if (hr)
        goto Cleanup;

    g_uiDisplay.DocPixelsFromDevice(&ptContent);    
    hr = THR( _pDispTestPointer->MoveToPoint(ptContent, COORD_SYSTEM_CONTENT, pElement, 0, NULL) );

    if ( hr )
        goto Cleanup;

    if ( _fPointerPositioned )
    {
        hr = THR( OldCompare( _pDispPointer, _pDispTestPointer, & iWherePointer ));
        if ( hr )
            goto Cleanup;
        _fFurtherInStory = ( iWherePointer == RIGHT );            
    }
    
    if ( fPositionLastToTest )
    {
        hr = THR( _pDispPointer->MoveToPointer( _pDispTestPointer ));        
        if ( hr )
           goto Cleanup;
        _fPointerPositioned = TRUE;           
    }
    
    if ( pInfo )
    {
        CMarkupPointer mp(_pDoc);

        hr = THR( _pDispTestPointer->PositionMarkupPointer(&mp) );
        if (hr)
            goto Cleanup;
            
        fInside = pInfo->IsInsideSelection(&mp);
    }
        
    if ( fInside )
    {
        if (!_pDoc->_fSlowClick)
        {
            // Hide caret
            DrawDragFeedback(FALSE);
        }

        _pDoc->_fSlowClick = TRUE;
    }
    else
    {
        // If feedback is currently displayed and the feedback location
        // is changing, then erase the current feedback.

        if ( ! fPositionLastToTest )
        {
            hr = THR ( _pDispPointer->IsEqualTo( _pDispTestPointer, & fSamePointer ));
            if ( hr )
                goto Cleanup;
        }
        else 
            fSamePointer = TRUE;

        if ( ! fSamePointer  )
        {
            //  Hide caret
            DrawDragFeedback(FALSE);
            hr = THR ( _pDispPointer->MoveToPointer( _pDispTestPointer ));
            if ( hr )
                goto Cleanup;
            _fPointerPositioned = TRUE;                
        }

        // Draw new feedback.
        if (_pDoc->_fSlowClick || ! _pDoc->_fDragFeedbackVis)
        {
            //  Show caret
            DrawDragFeedback(TRUE);
        }

        _pDoc->_fSlowClick = FALSE;
    }
Cleanup:
    ReleaseInterface(pElement);
    return;
}

//+---------------------------------------------------------------------------
//
//  Member:     DrawDragFeedback
//
//  Synopsis:
//
//----------------------------------------------------------------------------

void
CDropTargetInfo::DrawDragFeedback(BOOL fCaretVisible)
{
    if (fCaretVisible)
    {
        _pCaret->MoveCaretToPointerEx( _pDispPointer, TRUE, FALSE, CARET_DIRECTION_INDETERMINATE );
        _pDoc->_fDragFeedbackVis = 1;
    }
    else
    {
        _pCaret->Hide();
        _pDoc->_fDragFeedbackVis = 0;
    }
}
//+---------------------------------------------------------------------------
//
//  Member:     PasteDataObject
//
//  Synopsis: Paste a Data Object at a MarkupPointer
//
//----------------------------------------------------------------------------


HRESULT
CDropTargetInfo::PasteDataObject( 
                    IDataObject * pdo,
                    IMarkupPointer* pInsertionPoint,
                    IMarkupPointer* pStart,
                    IMarkupPointer* pEnd )
{
    HRESULT hr = S_OK;
    
    IHTMLEditor* pHTMLEditor = _pDoc->GetHTMLEditor();
    IHTMLEditingServices * pEditingServices = NULL;

    Assert( pHTMLEditor );
    if ( ! pHTMLEditor )
    {
        hr = E_FAIL;
        goto Cleanup;
    }
    
    hr = THR( pHTMLEditor->QueryInterface( IID_IHTMLEditingServices, ( void** ) & pEditingServices ));
    if ( hr )
        goto Cleanup;

    //
    // We'll use Markup Services "magic" to move the pointers around where we insert
    //

    hr = THR( pStart->MoveToPointer( pInsertionPoint ));
    if ( hr )
        goto Cleanup;
    hr = THR( pStart->SetGravity ( POINTER_GRAVITY_Left ));
    if ( hr )   
        goto Cleanup;
    hr = THR( pEnd->MoveToPointer( pInsertionPoint ));
    if ( hr )
        goto Cleanup;
    hr = THR( pEnd->SetGravity ( POINTER_GRAVITY_Right ));
    if ( hr )   
        goto Cleanup;    

    hr = THR( pEditingServices->PasteFromClipboard( pInsertionPoint, NULL, pdo ));
    if ( hr )
       goto Cleanup;

Cleanup:

    ReleaseInterface( pEditingServices );
    RRETURN ( hr );    
}
            
//+====================================================================================
//
// Method: EquivalentElements
//
// Synopsis: Test elements for 'equivalency' - ie if they are the same element type,
//           and have the same class, id , and style.
//
//------------------------------------------------------------------------------------

BOOL 
CDropTargetInfo::EquivalentElements( IHTMLElement* pIElement1, IHTMLElement* pIElement2 )
{
    CElement* pElement1 = NULL;
    CElement* pElement2 = NULL;
    BOOL fEquivalent = FALSE;
    HRESULT hr = S_OK;
    IHTMLStyle * pIStyle1 = NULL;
    IHTMLStyle * pIStyle2 = NULL;
    BSTR id1 = NULL;
    BSTR id2 = NULL;
    BSTR class1 = NULL;
    BSTR class2 = NULL;
    BSTR style1 = NULL;
    BSTR style2 = NULL;
    
    hr = THR( pIElement1->QueryInterface( CLSID_CElement, (void**) & pElement1 ));
    if ( hr )
        goto Cleanup;
    hr = THR( pIElement2->QueryInterface( CLSID_CElement, (void**) & pElement2 ));
    if ( hr )
        goto Cleanup;

    //
    // Compare Tag Id's
    //
    if ( pElement1->_etag != pElement2->_etag )
        goto Cleanup;

    //
    // Compare Id's
    //
    hr = THR( pIElement1->get_id( & id1 ));
    if ( hr )
        goto Cleanup;
    hr = THR( pIElement2->get_id( & id2 ));
    if ( hr )   
        goto Cleanup;  
    if ((( id1 != NULL ) || ( id2 != NULL )) && 
        ( StrCmpIW( id1, id2) != 0))
        goto Cleanup;

    //
    // Compare Class
    //
    hr = THR( pIElement1->get_className( & class1 ));
    if ( hr )
        goto Cleanup;
    hr = THR( pIElement2->get_className( & class2 ));
    if ( hr )   
        goto Cleanup;   
        
    if ((( class1 != NULL ) || ( class2 != NULL )) &&
        ( StrCmpIW( class1, class2) != 0 ) )
        goto Cleanup;

    //
    // Compare Style's
    //        
    hr = THR( pIElement1->get_style( & pIStyle1 ));
    if ( hr )
        goto Cleanup;
    hr = THR( pIElement2->get_style( & pIStyle2 ));
    if ( hr )   
        goto Cleanup;                
    hr = THR( pIStyle1->toString( & style1 ));
    if ( hr )
        goto Cleanup;
    hr = THR( pIStyle2->toString( & style2 ));
    if ( hr )
        goto Cleanup;        
    if ((( style1 != NULL ) || ( style2 != NULL )) &&
        ( StrCmpIW( style1, style2) != 0 ))
        goto Cleanup;

    fEquivalent = TRUE;        
Cleanup:
    SysFreeString( id1 );
    SysFreeString( id2 );
    SysFreeString( class1 );
    SysFreeString( class2 );
    SysFreeString( style1 );
    SysFreeString( style2 );
    ReleaseInterface( pIStyle1 );
    ReleaseInterface( pIStyle2 );
    
    AssertSz(!FAILED(hr), "Unexpected failure in Equivalent Elements");

    return ( fEquivalent );
}


//+---------------------------------------------------------------------------
//
//  Member:     Drop
//
//  Synopsis: Do everything you need to do as a result of a drop operation
//
//----------------------------------------------------------------------------

HRESULT 
CDropTargetInfo::Drop (  
                    CLayout* pLayout, 
                    IDataObject *   pDataObj,
                    DWORD           grfKeyState,
                    POINT          ptScreen,
                    DWORD *         pdwEffect)
{

    HRESULT hr = S_OK;


    IMarkupPointer* pStart = NULL;
    IMarkupPointer* pEnd = NULL;
    IHTMLEditingServices * pEdServices = NULL;
    IMarkupPointer* pBoundaryStart = NULL;
    IMarkupPointer* pBoundaryEnd = NULL;
    IMarkupPointer2* pBoundaryStart2 = NULL;
    IMarkupPointer2* pBoundaryEnd2 = NULL;
    CElement* pDropElement = NULL;
    CSelDragDropSrcInfo* pSelDragSrc = NULL;    
    HRESULT hrDrop = S_OK;
    CMarkupPointer mpPointer(_pDoc);
    BOOL fAtBOL;
    IHTMLElement* pIElementDrop = NULL;
    DOCHOSTUIINFO           info;
    BOOL                    fIgnoreHR = FALSE;

    IFC( _pDispTestPointer->PositionMarkupPointer(&mpPointer) );
        
    pSelDragSrc = _pDoc->GetSelectionDragDropSource();
    if ( pSelDragSrc )
    {
        hrDrop = THR( pSelDragSrc->IsValidDrop(&mpPointer, (grfKeyState & MK_CONTROL)) );
    }
    
    if ( hrDrop == S_OK && 
        (  *pdwEffect == DROPEFFECT_COPY 
        || *pdwEffect == DROPEFFECT_MOVE 
        || *pdwEffect == DROPEFFECT_NONE ))
    {
        IFC( _pDoc->GetEditingServices(& pEdServices ));
        IFC( _pDoc->CreateMarkupPointer( & pBoundaryStart));            
        IFC( _pDoc->CreateMarkupPointer( & pBoundaryEnd));

        pDropElement = pLayout->ElementOwner();
        Assert( pDropElement);
        if ( ! pDropElement )
        {
            hr = E_FAIL;
            goto Cleanup;
        }

        hr = pDropElement->QueryInterface(IID_IHTMLInputFileElement, (void**)&pIElementDrop);
        if (hr == S_OK)
        {
            //Don't drop on a file upload control
            hr = S_FALSE;
            goto Cleanup;
        }

        IFC( pDropElement->QueryInterface( IID_IHTMLElement, (void**) & pIElementDrop ));

        if( pDropElement->HasSlavePtr())
        {
            IFC( pEdServices->PositionPointersInMaster( pIElementDrop , pBoundaryStart, pBoundaryEnd ));
        }
        else
        {
            IFC( pBoundaryStart->QueryInterface( IID_IMarkupPointer2, (void**) & pBoundaryStart2 ));
            IFC( pBoundaryEnd->QueryInterface( IID_IMarkupPointer2, (void**) & pBoundaryEnd2 ));
       
            IFC( pBoundaryStart2->MoveToContent( pIElementDrop, TRUE ));
            IFC( pBoundaryEnd2->MoveToContent( pIElementDrop, FALSE ));
        }
        
        IFC( _pDispPointer->IsAtBOL(&fAtBOL) );
        IFC( pEdServices->AdjustPointerForInsert( _pDispPointer, fAtBOL /* fFurtherInDoc */, pBoundaryStart, pBoundaryEnd ) );
        IFC( _pDispPointer->PositionMarkupPointer(&mpPointer) );
        
        pSelDragSrc = _pDoc->GetSelectionDragDropSource();
        if ( pSelDragSrc )
        {
            //
            // Test if the point after we do the adjust is ok.
            //
            hrDrop = THR( pSelDragSrc->IsValidDrop( &mpPointer, (grfKeyState & MK_CONTROL) ));
        }           

        if ( hrDrop == S_OK )
        {
            if ( *pdwEffect == DROPEFFECT_COPY || *pdwEffect == DROPEFFECT_MOVE )
            {
                IFC( _pDoc->CreateMarkupPointer( & pStart ));
                IFC( _pDoc->CreateMarkupPointer( & pEnd ));
                            
                hr = THR( PasteDataObject( pDataObj, &mpPointer, pStart, pEnd )) ;
                if ( hr )
                {
                    AssertSz(0, "Paste Failed !");
                    goto Cleanup;            
                }
                   
                

                if ( _pDoc->_pHostUIHandler)
                {
                    memset(reinterpret_cast<VOID **>(&info), 0, sizeof(DOCHOSTUIINFO));
                    info.cbSize = sizeof(DOCHOSTUIINFO);
                    
                    if ( SUCCEEDED( _pDoc->_pHostUIHandler->GetHostInfo(&info) )
                         && (info.dwFlags & DOCHOSTUIFLAG_DISABLE_EDIT_NS_FIXUP) )
                    {
                        fIgnoreHR = TRUE;
                    }

                }

                hr = THR( SelectAfterDrop( pDataObj, pStart, pEnd ) );
                if ( FAILED(hr) )
                {
                    if ( fIgnoreHR )
                    {
                        hr = S_OK;
                    }
                    else
                    {
                        goto Cleanup;
                    }
                }
            }
            else
            {
                *pdwEffect = DROPEFFECT_NONE;
                //
                // For None we put the caret here 
                //
                hr = THR( _pDoc->Select(&mpPointer, &mpPointer, SELECTION_TYPE_Caret ));
                _pDoc->_fDragFeedbackVis = FALSE;

            }
        }
        else
        {
            if ( hrDrop == S_FALSE &&  pSelDragSrc &&       
                (  *pdwEffect == DROPEFFECT_COPY 
                || *pdwEffect == DROPEFFECT_MOVE ))
            {
                hr = S_FALSE;
            }
        
            //
            // NOTE - what should we do ?
            //
            *pdwEffect = DROPEFFECT_NONE ;
        }
    }
    else
    {    
        if ( hrDrop == S_FALSE &&  pSelDragSrc &&       
            (  *pdwEffect == DROPEFFECT_COPY 
            || *pdwEffect == DROPEFFECT_MOVE ))
        {
            hr = S_FALSE;
        }
    
        //
        // NOTE - what should we do ?
        //
        *pdwEffect = DROPEFFECT_NONE ;
    }


Cleanup:
    AssertSz( ! FAILED(hr), "Drag & Drop failed");
    ReleaseInterface( pBoundaryStart );
    ReleaseInterface( pBoundaryEnd );
    ReleaseInterface( pBoundaryStart2 );
    ReleaseInterface( pBoundaryEnd2 );    
    ReleaseInterface( pStart );
    ReleaseInterface( pEnd );
    ReleaseInterface( pEdServices );
    ReleaseInterface( pIElementDrop );
    
    RRETURN1 ( hr, S_FALSE );
}

//+---------------------------------------------------------------------------
//
//  Member:     SelectAfterDrag
//
//  Synopsis:   Make a selection after you just did a drag/drop operation.
//
//----------------------------------------------------------------------------


HRESULT
CDropTargetInfo::SelectAfterDrop(
                                        IDataObject* pDataObj, 
                                        IMarkupPointer* pStart,
                                        IMarkupPointer* pEnd)
{
    HRESULT                 hr;
    ISegmentList            *pSegmentList = NULL;
    ISegmentList            *pSelectList = NULL;
    ISegmentListIterator    *pIter = NULL;
    ISegment                *pISegment = NULL;
    IElementSegment         *pISegmentAdded = NULL;
    IHTMLEditingServices    *pEdServices = NULL;
    IHTMLEditor             *pIEditor = NULL;
    SELECTION_TYPE          eType;
    BOOL                    fSelected = FALSE;
    IMarkupPointer          *pTempStart = NULL;
    IMarkupPointer          *pElemStart = NULL;
    IMarkupPointer          *pElemEnd = NULL;
    IHTMLElement            *pIDragElement = NULL;
    BOOL                    fHasSelection = FALSE;
    

    pIEditor = _pDoc->GetHTMLEditor();
    if( pIEditor == NULL )
    {
        hr = E_FAIL;
        goto Cleanup;
    }
    
    IFC( _pDoc->GetEditingServices(& pEdServices ));

    //
    // We QI the IDataObj for ISegmentList - true for IE 5 & IE 6. If we have
    // one - we use the segment list based select. If not - we do it the IE 4 way
    // and "look" for something site selectable.
    //
    hr = THR ( pDataObj->QueryInterface( IID_ISegmentList, (void**) & pSegmentList ));
    if ( !hr && pSegmentList )
    {
        IFC( pSegmentList->GetType( &eType ));

        if ( eType == SELECTION_TYPE_Control )
        {
            //
            // if we have multiple controls site selected - 
            // we need to create a CSegmentList - and call select on it
            //
            Assert( hr == S_OK );                

            CSegmentList segmentList;
            segmentList.SetSelectionType( eType );

            // Create an iterator, and a pointer to keep track of the
            // current start position.
            IFC( pSegmentList->CreateIterator( &pIter ) );
            IFC( _pDoc->CreateMarkupPointer( & pTempStart ));
            IFC( pTempStart->MoveToPointer( pStart ) );

            // Create and position our pointers
            IFC( _pDoc->CreateMarkupPointer( &pElemStart ));
            IFC( _pDoc->CreateMarkupPointer( &pElemEnd ));

            while( pIter->IsDone() == S_FALSE )
            {
                IFC( pIter->Current(&pISegment) );

                IFC( pElemStart->MoveToPointer( pTempStart ) );
                IFC( pElemEnd->MoveToPointer( pEnd ));

                ClearInterface(&pIDragElement);
                IFC( pEdServices->FindSiteSelectableElement( pElemStart, pElemEnd, & pIDragElement));
                
                if ( pIDragElement )
                {
                    IFC( segmentList.AddElementSegment( pIDragElement, &pISegmentAdded ));

                    // Reposition our temporary starting position
                    IFC( pTempStart->MoveAdjacentToElement( pIDragElement, ELEM_ADJ_AfterEnd ) );
                }
                else
                {
                    IFC( pISegment->GetPointers( pElemStart, pTempStart ) );
                }

                // Advance to next segment
                IFC( pIter->Advance() );

                // Clear interfaces
                ClearInterface(&pISegmentAdded);
                ClearInterface(&pISegment);
            }

            IFC( segmentList.QueryInterface( IID_ISegmentList, (void **)&pSelectList) );

            IFC( pSelectList->IsEmpty(&fHasSelection) );
            if (!fHasSelection )
            {
                IFC( _pDoc->Select(pSelectList));
            }

            fSelected = TRUE;                
        }
    }

    if ( ! fSelected )
    {
        ClearInterface(&pIDragElement);
        hr = THR( pEdServices->FindSiteSelectableElement( pStart, pEnd, & pIDragElement));
        if ( hr == S_OK )                
        {
            eType = SELECTION_TYPE_Control ;
            
            IFC( pStart->MoveAdjacentToElement( pIDragElement, ELEM_ADJ_BeforeBegin ));
            IFC( pEnd->MoveAdjacentToElement( pIDragElement, ELEM_ADJ_AfterEnd ));
        }
        else
            eType = SELECTION_TYPE_Text;
       
        IFC( _pDoc->Select( pStart, pEnd, eType ));

        if ( eType != SELECTION_TYPE_Control )
        {
            IFC( _pDoc->ScrollPointersIntoView( pStart, pEnd ));
        }

    }

Cleanup:

    ReleaseInterface( pIter );
    ReleaseInterface( pISegment );
    ReleaseInterface( pISegmentAdded );
    ReleaseInterface( pTempStart );
    ReleaseInterface( pSegmentList );
    ReleaseInterface( pSelectList );
    ReleaseInterface( pEdServices );
    ReleaseInterface( pElemStart );
    ReleaseInterface( pElemEnd );
    ReleaseInterface( pIDragElement );
    
    RRETURN( hr );
}

BOOL
CDropTargetInfo::IsAtInitialHitPoint(POINTL pt)
{
    CPoint  ptCurrent;

    //  See if we're still where we started
    ptCurrent.x = pt.x;
    ptCurrent.y = pt.y;

    ScreenToClient( _pDoc->_pInPlace->_hwnd, & ptCurrent );

    return (_ptInitial.x == ptCurrent.x && _ptInitial.y == ptCurrent.y);
}

CSelDragDropSrcInfo::CSelDragDropSrcInfo( CDoc* pDoc ) : 
    CDragDropSrcInfo() ,
    _selSaver( pDoc )
{
    _ulRefs = 1;
    _srcType = DRAGDROPSRCTYPE_SELECTION;
    _pDoc = pDoc;
    Assert( ! _pBag );
}

CSelDragDropSrcInfo::~CSelDragDropSrcInfo()
{
    ReleaseInterface(_pStart);
    ReleaseInterface(_pEnd);
    
    delete _pBag;   // To break circularity
}


//+====================================================================================
//
// Method:GetSegmentList
//
// Synopsis: Hide the getting of the segment list on the doc - so we can easily be moved
//
//------------------------------------------------------------------------------------

HRESULT
CSelDragDropSrcInfo::GetSegmentList( ISegmentList** ppSegmentList )
{
    return ( _pDoc->GetCurrentSelectionSegmentList( ppSegmentList ) ) ; 
}

HRESULT
CSelDragDropSrcInfo::GetMarkup( IMarkupServices** ppMarkup)
{
    return ( _pDoc->PrimaryMarkup()->QueryInterface( IID_IMarkupServices, (void**) ppMarkup )) ; 
}

//+====================================================================================
//
// Method: Init
//
// Synopsis: Inits the SelDragDrop Info. Basically positions two TreePointers around 
// the selection, creates a range, and invokes the saver on that to create a Bag.
// 
//
//------------------------------------------------------------------------------------

HRESULT 
CSelDragDropSrcInfo::Init(CElement* pElement)
{
    HRESULT         hr = S_OK;
    ISegmentList    *pSegmentList = NULL;
    ISegmentListIterator    *pIter = NULL;
    ISegment                *pISegment = NULL;
    IMarkupServices *pMarkup = NULL;
    CBaseBag        *pBag = NULL;;
    CMarkup         *pMarkupInternal;
    DWORD            dwFlags = 0;
    SELECTION_TYPE  eType;

    Assert( pElement );
    
    //
    // Position the Pointers
    //
    IFC( _pDoc->CreateMarkupPointer( &_pStart ) );
    IFC( _pDoc->CreateMarkupPointer( &_pEnd ) );
  
    IFC( GetSegmentList( & pSegmentList ));
    IFC( pSegmentList->GetType(&eType) );

    IFC( _selSaver.SetSelectionType(eType) );
    IFC( _selSaver.SaveSelection());

    pMarkupInternal = pElement->GetMarkup();

    if( pElement->GetFirstBranch()->SupportsHtml() )
    {
        dwFlags |= CREATE_FLAGS_SupportsHtml;
    }
    if (eType == SELECTION_TYPE_Control &&
        !_selSaver.HasMultipleSegments())
    {
        //  Bug 18795, 13330: The saver includes <FORM> elements if the <FORM> contains one
        //  control, and the user is dragging the control.  In this case we don't want to 
        //  adjust out so we set the CREATE_FLAGS_NoIE4SelCompat flag.

        IFC( _selSaver.CreateIterator( &pIter ) );

        if( pIter->IsDone() == S_FALSE )
        {
            CMarkupPointer      *pTest;

            IFC( pIter->Current(&pISegment) );

            IFC( pISegment->GetPointers( _pStart, _pEnd ) );
            IFC( _pStart->QueryInterface(CLSID_CMarkupPointer, (void**)&pTest) );

            CTreeNode   *pNode = pTest->CurrentScope();

            //  Since pTest is positioned outside of the control, the scope will be the parent
            //  element.  We're interested in seeing whether the parent is a <form> element.

            if (pNode && pNode->Tag() == ETAG_FORM)
            {
                dwFlags |= CREATE_FLAGS_NoIE4SelCompat;
            }

            //  Since we checked that HasMultipleSegments() was FALSE, we
            //  should not have any more segments here.
            IFC( pIter->Advance() );
            Assert(pIter->IsDone() == S_OK);
        }
        else
        {
            AssertSz(FALSE, "We're dragging a control but we have no segments!");
        }
    }

    IFC(CTextXBag::Create( pMarkupInternal, 
                                dwFlags, 
                                pSegmentList, 
                                TRUE, 
                                (CTextXBag **)&pBag, 
                                this ));

    _pBag = pBag;

    hr = THR( SetInSameFlow());

Cleanup:
    ReleaseInterface( pMarkup );
    ReleaseInterface( pSegmentList );
    ReleaseInterface( pIter );
    ReleaseInterface( pISegment );

    RRETURN(hr);    
}

HRESULT
CSelDragDropSrcInfo::SetInSameFlow()
{
    ISegmentListIterator    *pIter = NULL;
    ISegment                *pISegment = NULL;
    HRESULT                 hr = S_OK;
    BOOL                    fSameFlow = FALSE;    

    _fInSameFlow = TRUE;

    IFC( _selSaver.CreateIterator( &pIter ) );

    while( pIter->IsDone() == S_FALSE )
    {
        IFC( pIter->Current(&pISegment) );

        IFC( GetInSameFlowSegment( pISegment, & fSameFlow ));
        if ( ! fSameFlow )
        {
            _fInSameFlow = FALSE;
            break;
        }
       
        IFC( pIter->Advance() );

        ClearInterface(&pISegment);
    }

Cleanup:
    ReleaseInterface(pIter);
    ReleaseInterface(pISegment);
    
    RRETURN( hr );
}

//+====================================================================================
//
// Method:SetInSameFlowSegment
//
// Synopsis: Set the _pfInSameFlow Bit per Selection Segment.
//
//------------------------------------------------------------------------------------

HRESULT
CSelDragDropSrcInfo::GetInSameFlowSegment( ISegment *pISegment, BOOL *pfSameFlow )
{
    HRESULT hr = S_OK;
    
    CElement* pElement1 = NULL;
    CElement* pElement2 = NULL;
    CFlowLayout* pFlow1 = NULL;
    CFlowLayout* pFlow2 = NULL;
    IHTMLElement* pIHTMLElement1 = NULL;
    IHTMLElement* pIHTMLElement2 = NULL;

    Assert( pfSameFlow );
    Assert( pISegment );

    IFC( pISegment->GetPointers( _pStart, _pEnd ) );
    
    IFC( _pDoc->CurrentScopeOrSlave( _pStart, & pIHTMLElement1));

    if ( ! pIHTMLElement1 )
    {
        AssertSz(0, "Didn't get an element");
        hr = E_FAIL;
        goto Cleanup;
    }

    IFC( pIHTMLElement1->QueryInterface( CLSID_CElement, (void**) & pElement1 ));

    IFC( _pDoc->CurrentScopeOrSlave( _pEnd, & pIHTMLElement2));

    if ( ! pIHTMLElement2 )
    {
        AssertSz(0, "Didn't get an element");
        hr = E_FAIL;
        goto Cleanup;
    }

    IFC( pIHTMLElement2->QueryInterface( CLSID_CElement, (void**) & pElement2 ));

    pFlow1 = pElement1->GetFirstBranch()->GetFlowLayout();

    pFlow2 = pElement2->GetFirstBranch()->GetFlowLayout();

    if ( pfSameFlow )
        *pfSameFlow =  ( pFlow1 == pFlow2 );
    
Cleanup:
    ReleaseInterface( pIHTMLElement1 );
    ReleaseInterface( pIHTMLElement2 );

    RRETURN ( hr );
    
}

//+---------------------------------------------------------------------------
//
//  Member:     IsInsideSelection
//
//  Synopsis:   Is the given pointer inside the saved selection ?
//
//----------------------------------------------------------------------------

BOOL
CSelDragDropSrcInfo::IsInsideSelection(IMarkupPointer* pTestPointer)
{
    ISegmentListIterator    *pIter = NULL;
    ISegment                *pISegment = NULL;
    HRESULT                 hr = S_OK;
    BOOL                    fInside = FALSE;

    IFC( _selSaver.CreateIterator( &pIter ) );

    while( pIter->IsDone() == S_FALSE )
    {
        IFC( pIter->Current(&pISegment) );

        fInside = IsInsideSavedSelectionSegment( pISegment, pTestPointer );
        if ( fInside )
            break;
       
        IFC( pIter->Advance() );

        ClearInterface(&pISegment);
    }

Cleanup:
    ReleaseInterface(pIter);
    ReleaseInterface(pISegment);

    return fInside;
}

//+---------------------------------------------------------------------------
//
//  Member:     IsInsideSavedSelectionSegment
//
//  Synopsis:   Is the given pointer inside a given saved selection segment ? 
//
//----------------------------------------------------------------------------


BOOL
CSelDragDropSrcInfo::IsInsideSavedSelectionSegment( ISegment *pISegment, IMarkupPointer* pTestPointer)
{
    BOOL                fInsideSelection    = FALSE;
    CMarkupPointer *    pTest               = NULL;
    CMarkupPointer *    pStart              = NULL;
    CMarkupPointer *    pEnd                = NULL;
    CElement *          pElement            = NULL;
    CMarkup *           pMarkupSel;
    CMarkup *           pMarkupTest;
#ifdef NEVER
    CElement *          pElemMaster;
#endif
    BOOL                fRefOnTest          = FALSE;
    SELECTION_TYPE      eType;
    HRESULT             hr = S_OK;
    BOOL                fDifferentMarkups   = FALSE;
    
    Assert( pISegment );

    IFC( pISegment->GetPointers( _pStart, _pEnd ) );

    // Handle the case where pTestPointer is not in the same markup as
    // _pStart and _pEnd.
    Verify(
        S_OK == pTestPointer->QueryInterface(CLSID_CMarkupPointer, (void**)&pTest)
     && S_OK == _pStart->QueryInterface(CLSID_CMarkupPointer, (void**)&pStart)
     && S_OK == _pEnd->QueryInterface(CLSID_CMarkupPointer, (void**)&pEnd));

    pMarkupSel = pStart->Markup();
    Assert(pMarkupSel && pMarkupSel == pEnd->Markup());

    pMarkupTest = pTest->Markup();
    Assert(pMarkupTest);

    if (pMarkupTest != pMarkupSel)
    {
        CTreeNode * pNodeTest = pTest->CurrentScope(MPTR_SHOWSLAVE);

        while (pNodeTest && pNodeTest->GetMarkup() != pMarkupSel)
        {
            while (pNodeTest && !pNodeTest->Element()->HasMasterPtr())
            {
                pNodeTest = pNodeTest->Parent();
            }
            if (pNodeTest)
            {
                pNodeTest = pNodeTest->Element()->GetMasterPtr()->GetFirstBranch();
            }
        }
        if (pNodeTest)
        {
            if (S_OK != _pDoc->CreateMarkupPointer(&pTest))
                goto Cleanup;
            fRefOnTest = TRUE;
            pElement = pNodeTest->Element();
            if (S_OK != pTest->MoveAdjacentToElement(pElement, ELEM_ADJ_BeforeBegin))
                goto Cleanup;
            fDifferentMarkups = TRUE;
        }
    }

    //
    // Why are the rules for AreWeInside A selection different ? 
    // We want to not compare on equality for character selection
    // otherwise we can't drag characters adjacent to each other ( bug 11490 ).
    // BUT we want to not allow controls to be dragged onto each other - for example dragging a Text box
    // onto iteself with nothing else in the tree ( bug 54338 )
    //
    _selSaver.GetType( &eType );

    //
    // This seems ok now - we don't need to copare isEqualTo on control elemnets
    // and it fixes bugs like 102011.
    //
    if (pTest->Markup() == pStart->Markup())
    {
        if ( eType == SELECTION_TYPE_Control )
        {
            // Bug 104536: If we're in different markups, we need to test equality on the start
            // and test pointer since we've positioned the test pointer at the start of the nested
            // markup.

            BOOL    fRightOfStart = FALSE;
            fRightOfStart = (fDifferentMarkups) ? pTest->IsRightOfOrEqualTo(pStart ) :
                                                  pTest->IsRightOf(pStart );
            if ( fRightOfStart )
            {        
                if ( pTest->IsLeftOf( pEnd ) )
                {
                    fInsideSelection = TRUE;
                }
            }
        }
        else 
        {
            BOOL    fTestLeft = FALSE;

            if ( pTest->IsRightOf(pStart ) )
            {
                fTestLeft = TRUE;
            }
            else if (fDifferentMarkups)
            {
                //  We may have positioned the test pointer to the same position as the start markup pointer.
                //  If this is the case, we'll check to see if the end of the nested markup is between the
                //  start and end markup pointers.  If so, we are inside the selection.

                if (pTest->IsEqualTo(pStart))
                {
                    if (S_OK != pTest->MoveAdjacentToElement(pElement, ELEM_ADJ_AfterEnd))
                        goto Cleanup;
                    fTestLeft = TRUE;
                }
            }

            if (fTestLeft && pTest->IsLeftOf(pEnd))
            {
                fInsideSelection = TRUE;
            }
        }
    }

Cleanup:
    if (fRefOnTest)
        ReleaseInterface(pTest);
    return ( fInsideSelection );
}

//+====================================================================================
//
// Method: IsValidPaste
//
// Synopsis: Ask if the drop is valid. If the pointer is within the selection it isn't valid
//
//------------------------------------------------------------------------------------


HRESULT
CSelDragDropSrcInfo::IsValidDrop(IMarkupPointer* pTestPointer, BOOL fDuringCopy /*=FALSE*/)
{
    ISegmentListIterator    *pIter = NULL;
    ISegment                *pISegment = NULL;
    HRESULT                 hr = S_OK;
    BOOL                    fInsideSelection = FALSE;
    CMarkupPointer          *pTest = NULL;
    CMarkupPointer          *pStart = NULL;
    CMarkupPointer          *pEnd = NULL;
    BOOL                    fSelectionHasMultipleSegments = FALSE;

    IFC( pTestPointer->QueryInterface(CLSID_CMarkupPointer, (void**)&pTest));

    IFC( _selSaver.CreateIterator( &pIter ) );
    fSelectionHasMultipleSegments = _selSaver.HasMultipleSegments();

    //  If we have multiple selection segments, we are interested in seeing whether we are
    //  dropping at a point that is in or next to any segment in the selection.

    while( pIter->IsDone() == S_FALSE )
    {
        IFC( pIter->Current(&pISegment) );

        IFC( pISegment->GetPointers( _pStart, _pEnd ) );
        
        IFC( _pStart->QueryInterface(CLSID_CMarkupPointer, (void**)&pStart));        
        IFC( _pEnd->QueryInterface(CLSID_CMarkupPointer, (void**)&pEnd));

        if ( pTest->Markup() != pStart->Markup() ||
             pTest->Markup() != pEnd->Markup() )
        {
            goto Cleanup;
        }

        //  If we are doing a copy, we should allow the user to drop next to
        //  our selection.
        
        if ( fDuringCopy || fSelectionHasMultipleSegments )
        {
            if ( pTest->IsRightOf(pStart ) )
            {        
                if ( pTest->IsLeftOf( pEnd ) )
                {
                    fInsideSelection = TRUE;
                    break;
                }
            }
        }
        else
        {
            if ( pTest->IsRightOfOrEqualTo(pStart ) )
            {        
                if ( pTest->IsLeftOfOrEqualTo( pEnd ) )
                {
                    fInsideSelection = TRUE;
                    break;
                }
            }
        }
            
        IFC( pIter->Advance() );

        ClearInterface(&pISegment);
    }

Cleanup:
    ReleaseInterface(pIter);
    ReleaseInterface(pISegment);

    if ( fInsideSelection )
        hr = S_FALSE;
    else if ( ! hr )
        hr = S_OK;
    
    RRETURN1( hr, S_FALSE );        
}

    
HRESULT 
CSelDragDropSrcInfo::GetDataObjectAndDropSource(    IDataObject **  ppDO,
                                                    IDropSource **  ppDS )
{
    HRESULT hr = S_OK;

    hr = THR( QueryInterface(IID_IDataObject, (void **)ppDO));
    if (hr)
        goto Cleanup;

    hr = THR( QueryInterface(IID_IDropSource, (void **)ppDS));
    if (hr)
    {
        (*ppDO)->Release();
        goto Cleanup;
    }
    
Cleanup:
    RRETURN ( hr );
}

//+---------------------------------------------------------------------------
//
//  Member:     PostDragDelete
//
//  Synopsis: The drag is over and has successfully finished ( on a move)
//            We want to now delete the contents of the selection
//
//----------------------------------------------------------------------------

 
HRESULT 
CSelDragDropSrcInfo::PostDragDelete()
{
    IHTMLEditingServices    *pEdServices = NULL;
    IHTMLEditor             *pEditor = NULL ;
    BOOL                    fInSameFlow;
    ISegmentListIterator    *pIter = NULL;
    ISegment                *pISegment = NULL;
    HRESULT                 hr = S_OK;

    pEditor = _pDoc->GetHTMLEditor();

    if ( pEditor )
    {
        IFC( pEditor->QueryInterface( IID_IHTMLEditingServices, ( void**) & pEdServices ));

        IFC( _selSaver.CreateIterator( &pIter ) );

        while( pIter->IsDone() == S_FALSE )
        {
            IFC( pIter->Current(&pISegment) );

            // Delete the segment
            IFC( GetInSameFlowSegment( pISegment, & fInSameFlow ));

            IFC( pISegment->GetPointers(_pStart, _pEnd) );
            
            if ( fInSameFlow )
            {
                IFC( pEdServices->Delete( _pStart, _pEnd, TRUE ));
            }                    
           
            IFC( pIter->Advance() );

            ClearInterface(&pISegment);
        }
    }
    else
        hr = E_FAIL;

Cleanup:
    ReleaseInterface(pIter);
    ReleaseInterface(pISegment);
    ReleaseInterface(pEdServices );

    RRETURN ( hr );
}

HRESULT 
CSelDragDropSrcInfo::PostDragSelect()
{
    ISegmentList    *pSegmentList = NULL;
    HRESULT         hr = E_FAIL;

    IFC( _selSaver.QueryInterface(IID_ISegmentList, (void **)&pSegmentList ) );
    
    IFC( _pDoc->Select( pSegmentList ) );

Cleanup:
    ReleaseInterface(pSegmentList);
    RRETURN(hr);
}

// ISegmentList methods
HRESULT
CSelDragDropSrcInfo::GetType(SELECTION_TYPE *peType)
{
    return _selSaver.GetType(peType);
}

HRESULT
CSelDragDropSrcInfo::CreateIterator(ISegmentListIterator **ppIIter)
{
    return _selSaver.CreateIterator(ppIIter);
}

HRESULT
CSelDragDropSrcInfo::IsEmpty(BOOL *pfEmpty)
{
    return _selSaver.IsEmpty(pfEmpty);
}

STDMETHODIMP
CSelDragDropSrcInfo::QueryInterface(
    REFIID              iid, 
    LPVOID *            ppv )
{
    if (!ppv)
        RRETURN(E_INVALIDARG);

    *ppv = NULL;
    
    switch(iid.Data1)
    {
        QI_INHERITS( this, IDataObject )
        QI_INHERITS( this, IDropSource )
        QI_INHERITS2( this, IUnknown, IDropSource  )
        
    case Data1_ISegmentList:    
        if ( iid == IID_ISegmentList )
        {                                   
            return _selSaver.QueryInterface( iid, ppv );
        }                                   
        break;

    default:
        if (_pBag)
            return _pBag->QueryInterface(iid, ppv);
        break;
    }

    if (*ppv)
    {
        ((IUnknown *)*ppv)->AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
    
}

//
// Methods that we delegate to our _pBag
//

HRESULT CSelDragDropSrcInfo::DAdvise( FORMATETC FAR* pFormatetc,
        DWORD advf,
        LPADVISESINK pAdvSink,
        DWORD FAR* pdwConnection) 
{
    if ( _pBag )
    {
        RRETURN ( _pBag->DAdvise( pFormatetc, advf, pAdvSink, pdwConnection ) ); 
    }
    else
        return E_FAIL;
}

HRESULT
CSelDragDropSrcInfo::DUnadvise( DWORD dwConnection)
{ 
    if ( _pBag )
    {
        RRETURN ( _pBag->DUnadvise( dwConnection ) );
    }
    else
        return E_FAIL;
}

HRESULT
CSelDragDropSrcInfo::EnumDAdvise( LPENUMSTATDATA FAR* ppenumAdvise)
{ 
    if ( _pBag )
    {
        RRETURN ( _pBag->EnumDAdvise( ppenumAdvise ));
    }
    else
        return E_FAIL;
}

HRESULT
CSelDragDropSrcInfo::EnumFormatEtc(
            DWORD dwDirection,
            LPENUMFORMATETC FAR* ppenumFormatEtc)
{ 
    if ( _pBag )
    {
        RRETURN ( _pBag->EnumFormatEtc( dwDirection, ppenumFormatEtc ) );
    }
    else
        return E_FAIL;
}

HRESULT
CSelDragDropSrcInfo::GetCanonicalFormatEtc(
            LPFORMATETC pformatetc,
            LPFORMATETC pformatetcOut)
{ 
    if ( _pBag )
    {
        RRETURN( _pBag->GetCanonicalFormatEtc( pformatetc, pformatetcOut) );
    }
    else
        return E_FAIL;
}

HRESULT
CSelDragDropSrcInfo::GetData(LPFORMATETC pformatetcIn, LPSTGMEDIUM pmedium )
{ 
    if ( _pBag )
    {
        RRETURN ( _pBag->GetData( pformatetcIn, pmedium ));
    }
    else
        return E_FAIL;
}

HRESULT 
CSelDragDropSrcInfo::GetDataHere(LPFORMATETC pformatetc, LPSTGMEDIUM pmedium)
{ 
    if ( _pBag )
    {
        RRETURN( _pBag->GetDataHere( pformatetc, pmedium ));
    }
    else
        return E_FAIL;
}


HRESULT 
CSelDragDropSrcInfo::QueryGetData(LPFORMATETC pformatetc )
{ 
    if ( _pBag )
    {
        RRETURN( _pBag->QueryGetData( pformatetc ));
    }
    else
        return E_FAIL;
}

HRESULT
CSelDragDropSrcInfo::SetData(LPFORMATETC pformatetc, STGMEDIUM FAR * pmedium, BOOL fRelease)
{
    if ( _pBag )
    {
        RRETURN( _pBag->SetData( pformatetc, pmedium , fRelease));  
    }
    else
        return E_FAIL;
}


HRESULT
CSelDragDropSrcInfo::QueryContinueDrag(BOOL fEscapePressed, DWORD grfKeyState)
{
    if ( _pBag )
    {
        return( _pBag->QueryContinueDrag( fEscapePressed, grfKeyState ));
    }
    else
        return E_FAIL;
}

HRESULT 
CSelDragDropSrcInfo::GiveFeedback (DWORD dwEffect)
{
    if ( _pBag )
    {
        return( _pBag->GiveFeedback (dwEffect));
    }
    else
        return E_FAIL;
}




CDragDropTargetInfo::CDragDropTargetInfo(CDoc* pDoc )
{
    _pDoc = pDoc;
    _pSaver = NULL;
    _fSelectionSaved = FALSE;
    if( _pDoc->_pElemCurrent && _pDoc->_pElemCurrent->IsEditable(/*fCheckContainerOnly*/FALSE) )
    {
        StoreSelection();
        //
        // Tell the Selection to tear itself down for the duration of the drag    
        //
        _pDoc->DestroySelection();
    }
}

CDragDropTargetInfo::~CDragDropTargetInfo()
{
    ReleaseInterface( _pSaver );        
}


HRESULT 
CDragDropTargetInfo::StoreSelection()
{
    HRESULT hr = S_OK ;

    Assert( ! _pSaver );

    _pElemCurrentAtStoreSel = _pDoc->_pElemCurrent ;

    _pSaver = new CSelectionSaver( _pDoc );
    if ( ! _pSaver )
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }
    IFC( _pSaver->SaveSelection());
    _fSelectionSaved = TRUE;
    
Cleanup:
    RRETURN( hr );
}

HRESULT 
CDragDropTargetInfo::RestoreSelection()
{
    ISegmentList    *pSegmentList = NULL;
    HRESULT         hr = E_FAIL;
    //
    // Ensure that the current element we began a drag & drop with is the same
    // as the currency now. This makes us not whack selection back - if our host
    // has changed currency on us in some way ( as access does over ole controls)
    //
    if ( _pDoc->_pElemCurrent == _pElemCurrentAtStoreSel &&
         _pSaver->HasSegmentsToRestore() )
    {
        IFC( _pSaver->QueryInterface(IID_ISegmentList, (void **)&pSegmentList ) );
        
        IFC( _pDoc->Select( pSegmentList ) );
    }

    _pElemCurrentAtStoreSel = NULL;

Cleanup:
    ReleaseInterface( pSegmentList );
    RRETURN( hr );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\text\splice.cxx ===
//+---------------------------------------------------------------------------
//
//  splice.cxx
//
//  CMarkup::SpliceTree implementation
//
//  SpliceTree can remove, copy, or move, or undo a remove 
//  of a range in the tree.
//  
//  Remove: SpliceTree's behavior is to remove all the text in the
//          specified range, as well as all elements that fall completely
//          in the range.
//
//          The sematics are such that if an element is not in a range
//          completely, its end tags will not be moved with respect
//          to other elements.  However, it may be necessary to
//          reduce the number of nodes for that element.  When this
//          happens, the nodes will be removed from the right edge.
//
//          Pointers without cling in the range end up in the space
//          between the end tags and the begin tags (arguably they should
//          stick between the end tags). Pointers with cling are removed.
//
//  Copy:   All the text in the specified range, as well as elements that
//          fall completely in the range, are copied.
//
//          Elements that overlap the range on the left are copied; begin
//          edges are implied at the very beginning of the range, in the
//          same order in which the begin edges appear in the source.
//
//          Elements that overlap the range on the right are copied; end
//          edges are implied at the very end of the range, in the same
//          order in which they appear in the source.
//
//  Move:   All the text in the specified range, as well as elements that
//          fall completely in the range, are moved (removed and inserted
//          into the new location, not copied).
//
//          Elements that overlap on the right or the left are modified
//          using the same rules as Remove, then copied to the new location
//          using the same rules as Copy.
//
//  Undo Remove: This use of SpliceTree is only called from the undo code.
//          Essentially it is a move driven by data that collected in
//          a previous remove.  To complicate matters, we must weave the
//          saved data through the already present tree.
//
//----------------------------------------------------------------------------
#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X__DOC_H_
#define X__DOC_H_
#include "_doc.h"
#endif

#ifndef X_TREEPOS_HXX_
#define X_TREEPOS_HXX_
#include "treepos.hxx"
#endif

#ifndef X_TXTDEFS_H_
#define X_TXTDEFS_H_
#include "txtdefs.h"
#endif

#ifndef X_TPOINTER_HXX_
#define X_TPOINTER_HXX_
#include "tpointer.hxx"
#endif

#ifndef X_WCHDEFS_H_
#define X_WCHDEFS_H_
#include "wchdefs.h"
#endif

#ifndef X__TEXT_H_
#define X__TEXT_H_
#include "_text.h"
#endif

#ifndef X_MARKUPUNDO_HXX_
#define X_MARKUPUNDO_HXX_
#include "markupundo.hxx"
#endif

#ifndef X_LOGMGR_HXX_
#define X_LOGMGR_HXX_
#include "logmgr.hxx"
#endif

PerfDbgExtern(tagPerfWatch)
MtExtern(CollapsedWhitespace);

//+---------------------------------------------------------------------------
//
//  SpliceTree and supporting classes
//
//----------------------------------------------------------------------------

MtDefine(CSpliceTreeEngine_pchRecord, Locals, "CSpliceTreeEngine_pchRecord");
MtDefine(CSpliceTreeEngine_aryElement, Locals, "CSpliceTreeEngine_aryElement");
MtDefine(CSpliceTreeEngine_InsertSplice_aryNodeStack_pv, Locals, "CSpliceTreeEngine::InsertSplice aryNodeStack::_pv");
MtDefine(CSpliceTreeEngine_RemoveSplice_aryDelayRelease_pv, Locals, "CSpliceTreeEngine::RemoveSplice aryDelayRelease::_pv");
MtDefine(CSpliceTreeEngine_pchRemoved, Locals, "CSpliceTreeEngine_pchRemoved");
MtDefine(CSpliceRecordList, Undo, "CSpliceRecordList (used in SpliceTree and undo)");
MtDefine(CSpliceRecordList_pv, CSpliceRecordList, "CSpliceRecordList::_pv");

//+---------------------------------------------------------------------------
//
//  Class:      CSpliceTreeEngine
//
//  Synposis:   The class that actually does the work for SpliceTree
//
//----------------------------------------------------------------------------
class CSpliceTreeEngine
{
public:
    CSpliceTreeEngine( CDoc * pDoc );
    ~CSpliceTreeEngine();
    
    HRESULT Init(CMarkup *pMarkupSource, CTreePosGap *ptpgSourceL, CTreePosGap *ptpgSourceR,
                         CMarkup *pMarkupTarget, CTreePosGap *ptpgTarget, BOOL fRemove, DWORD dwFlags);

    HRESULT InitUndoRemove( CMarkup * pMarkupTarget, CTreePosGap * ptpgTarget,
                            CSpliceRecordList * paryRegion, long cchRemove, 
                            TCHAR * pchRemove, DWORD dwFlags );
                         
    HRESULT RecordSplice();
    HRESULT RemoveSplice();
    HRESULT InsertSplice();

    // Used by RecordSplice
    HRESULT NoteRightElement(CElement *pel);
    HRESULT RecordLeftBeginElement(CElement *pel);
    HRESULT RecordBeginElement(CElement *pel);
    HRESULT RecordEndElement(long cInclTotal, long cInclSkip, BOOL fElementStays, BOOL fSynth);
    HRESULT RecordTextPos(unsigned long cch, unsigned long sid, long lTextID);
    HRESULT RecordPointer(CMarkupPointer *pmp);
    HRESULT RecordCollapsedWhitespace(TCHAR *pchCollapsedWhitespace, BOOL fGravity);
    void    RecordReverse();
    HRESULT RecordText(const TCHAR *pch, long cch);
    HRESULT RecordStory(CTxtPtr *ptx, long cch);
    HRESULT RecordNodeChars(long cch);
    LONG    LeftOverlap();

    // Used by InsertSplice
    CSpliceRecord *FirstRecord();
    CSpliceRecord *NextRecord();
    void GetNodeCharsRemove( long *pcchNode );
    void GetTextRecorded(const TCHAR **ppch, long *pcch);

    // Control flags
    BOOL _fInsert;
    BOOL _fRemove;
    BOOL _fDOMOperation;

    // Source pointers
    CMarkup *_pMarkupSource;
    CTreeNode *_pnodeSourceTop;
    CTreePos *_ptpSourceL;
    CTreePos *_ptpSourceR;
    CTreeNode *_pnodeSourceL;
    CTreeNode *_pnodeSourceR;
    
    // Target pointers
    CMarkup *_pMarkupTarget;
    CTreePos *_ptpTarget;

    // Text
    TCHAR *_pchRecord;
    LONG _cchRecord;
    LONG _cchRecordAlloc;
    
    // Recorded information

    CSpliceRecord *_prec;
    LONG _crec;
    enum WhichAry { AryNone = 0, AryLeft = 1, AryInside = 2, AryDone = 3 } _cAry;
    BOOL _fReversed;

    // Undo source
    CSpliceRecordList * _paryRemoveUndo;
    BOOL                _fNoFreeRecord;
    
    // TreeSync / Remove Undo
    DWORD    _fTreeSyncSource:1;            // Sync-ing source?
    DWORD    _fTreeSyncTarget:1;            // Sync-ing target?
    DWORD    _fRecordRemoveUndo:1;          // Do we need to record remove splice info?
    DWORD    _fDontReleaseRUInfo:1;         // Don't release Remove Undo info - Undo unit now owns

    CSpliceRecordList * _paryRemovedRegion; // Remove splice info.
    TCHAR * _pchRemoved;                    // Text removed

    CElement **_ppelRight;
    
    WHEN_DBG( BOOL  _fRemoveUndo );

    //------------------------------------------
    // Everything below this line will *not*
    // get memset to 0

    CSpliceRecordList _aryLeft;
    CSpliceRecordList _aryInside;
    
    CPtrAry<CElement *> _aryElementRight;

    // Undo classes
    CRemoveSpliceUndo   _RemoveUndo;
    CInsertSpliceUndo   _InsertUndo;
};

//+---------------------------------------------------------------------------
//
//  Method:     CSpliceRecordList dtor
//
//  Synposis:   Releases everything from the CSpliceRecordList
//
//----------------------------------------------------------------------------
CSpliceRecordList::~CSpliceRecordList()
{
    CSpliceRecord * prec = (CSpliceRecord*)PData();
    long            c = Size();

    for( ; c ; c--, prec++ )
    {
        Assert( prec->_type != CTreePos::NodeEnd
            ||  prec->_pel == NULL );

        if (prec->_type == CTreePos::NodeBeg)
        {
            Assert( prec->_pel );
            prec->_pel->Release();
        }
        else if (prec->_type == CTreePos::Pointer)
        {
            if (prec->_fMarkupPointer)
            {
                if (prec->_pPointer)
                    prec->_pPointer->Release();
            }
            else
            {
                delete [] prec->_pchCollapsedWhitespace;
            }
        }
    }
}

//+---------------------------------------------------------------------------
//
//  Method:     SpliceTreeEngine constructor
//
//  Synposis:   Zero initialize members
//
//----------------------------------------------------------------------------

CSpliceTreeEngine::CSpliceTreeEngine(CDoc * pDoc) :
    _aryElementRight(Mt(CSpliceTreeEngine_aryElement)),
    _RemoveUndo( pDoc ), _InsertUndo( pDoc )
{
    // Zero up to but not including the arrays
    
    memset(this, 0, offsetof(CSpliceTreeEngine, _aryLeft));
}


//+---------------------------------------------------------------------------
//
//  Method:     SpliceTreeEngine destructor
//
//  Synposis:   Release pointers
//
//----------------------------------------------------------------------------
    
CSpliceTreeEngine::~CSpliceTreeEngine()
{
    CElement **ppel;
    long c;

    for (ppel = _aryElementRight, c = _aryElementRight.Size(); c; ppel++, c--)
    {
        (*ppel)->Release();
    }
    
    if( !_fNoFreeRecord )
        MemFree(_pchRecord);

    if (_pMarkupTarget)
        _pMarkupTarget->PrivateRelease();

    if (_pMarkupSource)
        _pMarkupSource->PrivateRelease();

    // If we recorded info, but undo doesn't need it, delete it.
    if( _fRecordRemoveUndo && !_fDontReleaseRUInfo )
    {
        // We may have bailed out of RemoveSplice as a no-op, leaving _pchRemoved as NULL
        // But in that case, we better not have recorded anything.
        Assert( _paryRemovedRegion && ( _pchRemoved || _paryRemovedRegion->Size() == 0 ) );

        delete _paryRemovedRegion;
        MemFree( _pchRemoved );
    }
}


//+---------------------------------------------------------------------------
//
//  Method:     CSpliceTreeEngine::Init
//
//  Synposis:   Initialize members of CSpliceTreeEngine based on arguments.
//
//              Unpositions gaps that come in as input.
//
//----------------------------------------------------------------------------
HRESULT
CSpliceTreeEngine::Init(CMarkup *pMarkupSource, CTreePosGap *ptpgSourceL, CTreePosGap *ptpgSourceR,
                        CMarkup *pMarkupTarget, CTreePosGap *ptpgTarget, BOOL fRemove, DWORD dwFlags)
{
    HRESULT hr = S_OK;

    Assert(_fRemoveUndo == !pMarkupSource);
    Assert(_fRemoveUndo || ptpgSourceL && ptpgSourceL->IsPositioned() && ptpgSourceL->IsValid());
    Assert(_fRemoveUndo || ptpgSourceR && ptpgSourceR->IsPositioned() && ptpgSourceR->IsValid());
    Assert(_fRemoveUndo || ptpgSourceL->AttachedTreePos()->GetMarkup() == pMarkupSource);
    Assert(_fRemoveUndo || ptpgSourceR->AttachedTreePos()->GetMarkup() == pMarkupSource);
    Assert(_fRemoveUndo || ptpgSourceL->Branch() && ptpgSourceR->Branch());
    Assert(_fRemoveUndo || 0 >= ptpgSourceL->AdjacentTreePos(TPG_LEFT)->InternalCompare( ptpgSourceR->AdjacentTreePos(TPG_LEFT)));

    Assert(!_fRemoveUndo || pMarkupTarget);
    Assert(!!pMarkupTarget == !!ptpgTarget);
    Assert(!ptpgTarget || ptpgTarget->AttachedTreePos()->GetMarkup() == pMarkupTarget);
    Assert(!ptpgTarget || (ptpgTarget->IsPositioned() && ptpgTarget->IsValid()));
    Assert(pMarkupTarget || fRemove);

    Assert( !pMarkupTarget || !pMarkupSource || pMarkupTarget->Doc() == pMarkupSource->Doc() );
    
    _fInsert = !!pMarkupTarget;
    _fRemove = fRemove;

    _fDOMOperation = dwFlags & MUS_DOMOPERATION;

    if (_fInsert)
    {
        _pMarkupTarget = pMarkupTarget;
        _pMarkupTarget->PrivateAddRef();

        _InsertUndo.Init( _pMarkupTarget, dwFlags );

        _fTreeSyncTarget = _pMarkupTarget->HasLogManager() && _pMarkupTarget->GetLogManager()->IsAnyoneListening();
        
        if (_pMarkupTarget->Doc()->_lLastTextID)
        {
            _pMarkupTarget->SplitTextID(
                ptpgTarget->AdjacentTreePos( TPG_LEFT ),
                ptpgTarget->AdjacentTreePos( TPG_RIGHT) );
        }

        ptpgTarget->PartitionPointers(_pMarkupTarget, _fDOMOperation);

        _ptpTarget = _pMarkupTarget->NewPointerPos( NULL, FALSE, FALSE );

        if (!_ptpTarget)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }

        hr = THR(
            _pMarkupTarget->Insert(
                _ptpTarget, ptpgTarget->AdjacentTreePos( TPG_LEFT ), FALSE ) );

        if (hr)
            goto Cleanup;

        ptpgTarget->UnPosition();
    }
    
    if (pMarkupSource)
    {
        _pMarkupSource = pMarkupSource;
        _pMarkupSource->PrivateAddRef();

        if( _fRemove )
        {
            ptpgSourceL->PartitionPointers(_pMarkupSource, _fDOMOperation);
            ptpgSourceR->PartitionPointers(_pMarkupSource, _fDOMOperation);

            if (_pMarkupSource->Doc()->_lLastTextID)
            {
                _pMarkupSource->SplitTextID(
                    ptpgSourceL->AdjacentTreePos( TPG_LEFT ),
                    ptpgSourceL->AdjacentTreePos( TPG_RIGHT) );

                _pMarkupSource->SplitTextID(
                    ptpgSourceR->AdjacentTreePos( TPG_LEFT ),
                    ptpgSourceR->AdjacentTreePos( TPG_RIGHT) );
            }

            _RemoveUndo.Init( _pMarkupSource, dwFlags );

            // See if we need to record TreeSync at all
            _fTreeSyncSource    = _pMarkupSource->HasLogManager() && _pMarkupSource->GetLogManager()->IsAnyoneListening();
            // See if we need to record backwards info for remove (either for TreeSync or for Undo)
            _fRecordRemoveUndo  = _RemoveUndo.AcceptingUndo() || ( _fTreeSyncSource && _pMarkupSource->GetLogManager()->TestBackward() );

            // Now if we're recording info, make a list
            if( _fRecordRemoveUndo )
            {
                _paryRemovedRegion = new CSpliceRecordList();
                if( !_paryRemovedRegion )
                {
                    _fRecordRemoveUndo = FALSE;
                }
            }
        }

        _ptpSourceL = ptpgSourceL->AdjacentTreePos(TPG_RIGHT);
        _ptpSourceR = ptpgSourceR->AdjacentTreePos(TPG_LEFT);
        _pnodeSourceL = ptpgSourceL->Branch();
        _pnodeSourceR = ptpgSourceR->Branch();
        _pnodeSourceTop = _pnodeSourceL->GetFirstCommonAncestorNode(_pnodeSourceR, NULL);
        ptpgSourceL->UnPosition();
        ptpgSourceR->UnPosition();
    }

Cleanup:
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Method:     CSpliceTreeEngine::InitUndoRemove
//
//  Synposis:   Initialize for the undo of a remove operation
//
//----------------------------------------------------------------------------
HRESULT 
CSpliceTreeEngine::InitUndoRemove(CMarkup * pMarkupTarget, CTreePosGap * ptpgTarget,
                                  CSpliceRecordList * paryRegion, long cchRemove, 
                                  TCHAR * pchRemove, DWORD dwFlags )
{
    HRESULT hr = S_OK;

    WHEN_DBG( _fRemoveUndo = TRUE );

    hr = THR( Init( NULL, NULL, NULL, pMarkupTarget, ptpgTarget, FALSE, dwFlags ) );
    if (hr)
        goto Cleanup;

    Assert( paryRegion );
    _paryRemoveUndo = paryRegion;

    Assert( pchRemove );
    _pchRecord = pchRemove;
    _cchRecord = cchRemove;
    _fNoFreeRecord = TRUE;

Cleanup:
    RRETURN( hr );
}

//+---------------------------------------------------------------------------
//
//  Method:     CSpliceTreeEngine::NoteRightElement
//
//  Synposis:   Note element on the right, in bottom-to-top order
//
//----------------------------------------------------------------------------
HRESULT
CSpliceTreeEngine::NoteRightElement(CElement *pel)
{
    HRESULT hr;

    Assert(!_ppelRight || _ppelRight == _aryElementRight + _aryElementRight.Size() - 1);
    
    hr = THR(_aryElementRight.Append(pel));
    if (hr) 
        goto Cleanup;

    _ppelRight = _aryElementRight + _aryElementRight.Size() - 1;

    pel->AddRef();

Cleanup:
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Method:     CSpliceTreeEngine::RecordLeftBeginElement
//
//  Synposis:   Records a begin-edge before the left edge of the source;
//              these are fed in reverse (bottom up, right-to-left) order.
//
//----------------------------------------------------------------------------
HRESULT
CSpliceTreeEngine::RecordLeftBeginElement(CElement *pel)
{
    HRESULT hr;
    CElement *pelClone = NULL;
    CSpliceRecord *prec;
    long lTreeVersionOld = _pMarkupSource->GetMarkupTreeVersion();

    Assert(_pMarkupTarget && _fInsert);
    
    hr = THR(pel->Clone(&pelClone, _pMarkupTarget->Doc()));
    if (hr)
        goto Cleanup;

    if( lTreeVersionOld != _pMarkupSource->GetMarkupTreeVersion() )
    {
        hr = E_ABORT;
        goto Cleanup;
    }
        
    hr = THR(_aryLeft.AppendIndirect(NULL, &prec));
    if (hr) 
        goto Cleanup;

    prec->_type = CTreePos::NodeBeg;
    prec->_pel = pelClone;
    prec->_fSkip = FALSE;
    pelClone = NULL;

Cleanup:
    CElement::ReleasePtr(pelClone);
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Method:     CSpliceTreeEngine::RecordBeginElement
//
//  Synposis:   Records a begin-edge in the source, and clones the
//              element if needed.
//
//----------------------------------------------------------------------------
HRESULT
CSpliceTreeEngine::RecordBeginElement(CElement *pel)
{
    HRESULT         hr = S_OK;
    CSpliceRecord * prec;
    BOOL            fElementStays = FALSE;
    CElement *      pelNew = NULL;

    if( _fRemove && _ppelRight && pel == *_ppelRight )
    {
        fElementStays = TRUE;

        if (_ppelRight != _aryElementRight)
            _ppelRight -= 1;
        else
            _ppelRight = NULL;
    }

    // Handle the insert case
    if( _fInsert )
    {
        if (!_fRemove || fElementStays)
        {
            long lTreeVersionOld = _pMarkupSource->GetMarkupTreeVersion();

            hr = THR(pel->Clone(&pelNew, _pMarkupTarget->Doc()));
            if (hr)
                goto Cleanup;

            if( lTreeVersionOld != _pMarkupSource->GetMarkupTreeVersion() )
            {
                hr = E_ABORT;
                goto Cleanup;
            }
        
        }
        else
        {
            pelNew = pel;
            pel->AddRef();
        }
        
        hr = THR(_aryInside.AppendIndirect(NULL, &prec));
        if (hr) 
            goto Cleanup;

        prec->_type = CTreePos::NodeBeg;
        prec->_pel = pelNew;
        prec->_fSkip = FALSE;
        pelNew = NULL;
    }

    // Handle the undo case
    if ( _fRecordRemoveUndo )
    {
        Assert( _paryRemovedRegion );
        hr = THR( _paryRemovedRegion->AppendIndirect( NULL, &prec ) );
        if( hr )
        {
            _fRecordRemoveUndo = FALSE;
            delete _paryRemovedRegion;
            _paryRemovedRegion = NULL;

            // Don't fail the splice just becasue we can't undo it.
            // CONSIDER (JHarding): We may want to let TreeSync clients
            // know they're missing information
            hr = S_OK;
            goto Cleanup;
        }

        prec->_type = CTreePos::NodeBeg;
        prec->_pel = pel;
        pel->AddRef();
        prec->_fSkip = fElementStays;
    }

Cleanup:
    CElement::ReleasePtr(pelNew);
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Method:     CSpliceTreeEngine::RecordEndElement
//
//  Synposis:   Records a end-edge in the source, and the amount of
//              overlapping (the depth of the inclusion) at the point
//              at which it ends.
//
//----------------------------------------------------------------------------
HRESULT
CSpliceTreeEngine::RecordEndElement(long cInclTotal, long cInclSkip, BOOL fElementStays, BOOL fSynth)
{
    HRESULT hr = S_OK;
    CSpliceRecord *prec;
    
    if (_fInsert)
    {
        hr = THR(_aryInside.AppendIndirect(NULL, &prec));
        if (hr)
            goto Cleanup;

        prec->_type = CTreePos::NodeEnd;
        prec->_pel = NULL;
        prec->_cIncl = cInclTotal - cInclSkip;
    }

    if ( !fSynth && _fRecordRemoveUndo )
    {
        Assert( _paryRemovedRegion );
        hr = THR( _paryRemovedRegion->AppendIndirect( NULL, &prec ) );
        if( hr )
        {
            _fRecordRemoveUndo = FALSE;
            delete _paryRemovedRegion;
            _paryRemovedRegion = NULL;

            // Don't fail the splice just becasue we can't undo it.
            // CONSIDER (JHarding): We may want to let TreeSync clients
            // know they're missing information
            hr = S_OK;
            goto Cleanup;
        }

        prec->_type = CTreePos::NodeEnd;
        prec->_pel = NULL;
        prec->_cIncl = cInclTotal;
    }

Cleanup:
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Method:     CSpliceTreeEngine::LeftOverlap
//
//  Synposis:   Returns the number of elements partially overlapping range
//              to the left
//
//----------------------------------------------------------------------------
LONG
CSpliceTreeEngine::LeftOverlap()
{
    return _aryLeft.Size();
}


//+---------------------------------------------------------------------------
//
//  Method:     CSpliceTreeEngine::RecordTextPos
//
//  Synposis:   Records a text pos in the source, and merges adjacent
//              text poses if possible (this happens when tree pointers
//              are not copied out of the splice).
//
//----------------------------------------------------------------------------
HRESULT
CSpliceTreeEngine::RecordTextPos(unsigned long cch, unsigned long sid, long lTextID)
{
    HRESULT hr = S_OK;
    CSpliceRecord *prec;

    if (_fInsert)
    {
        if (    _aryInside.Size() 
            &&  (prec = _aryInside + _aryInside.Size() - 1, prec->_type == CTreePos::Text) 
            &&  prec->_sid == sid
            &&  prec->_lTextID == lTextID)
        {
            prec->_cch += cch;
        }
        else
        {
            hr = THR(_aryInside.AppendIndirect(NULL, &prec));
            if (hr)
                goto Cleanup;

            prec->_type = CTreePos::Text;
            prec->_cch = cch;
            prec->_sid = sid;
            prec->_lTextID = lTextID;
        }
    }

    if ( _fRecordRemoveUndo )
    {
        Assert( _paryRemovedRegion );

        prec = _paryRemovedRegion->Size() ? ( (CSpliceRecord*)(*_paryRemovedRegion) + _paryRemovedRegion->Size() - 1 ) : NULL;

        if(    prec
            && prec->_type == CTreePos::Text 
            && prec->_sid == sid
            && prec->_lTextID == lTextID)
        {
            prec->_cch += cch;
        }
        else
        {
            hr = THR( _paryRemovedRegion->AppendIndirect( NULL, &prec ) );
            if( hr )
            {
                _fRecordRemoveUndo = FALSE;
                delete _paryRemovedRegion;
                _paryRemovedRegion = NULL;

                // Don't fail the splice just becasue we can't undo it.
                // CONSIDER (JHarding): We may want to let TreeSync clients
                // know they're missing information
                hr = S_OK;
                goto Cleanup;
            }

            prec->_type = CTreePos::Text;
            prec->_cch = cch;
            prec->_sid = sid;
            prec->_lTextID = lTextID;
        }
    }

Cleanup:
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Method:     CSpliceTreeEngine::RecordPointer
//
//  Synposis:   Records a markup pointer in the source, and addrefs it.
//
//----------------------------------------------------------------------------
HRESULT
CSpliceTreeEngine::RecordPointer(CMarkupPointer *pmp)
{
    HRESULT hr = S_OK;
    CSpliceRecord *prec;
    
    if (_fInsert)
    {
        hr = THR(_aryInside.AppendIndirect(NULL, &prec));
        if (hr)
            goto Cleanup;

        prec->_type = CTreePos::Pointer;
        prec->_fMarkupPointer = TRUE;
        prec->_pPointer = pmp;
        pmp->AddRef();
    }

Cleanup:
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Method:     CSpliceTreeEngine::RecordCollapsedWhitespace
//
//  Synposis:   Records a collapsed whitespace pointer pos
//
//----------------------------------------------------------------------------
HRESULT 
CSpliceTreeEngine::RecordCollapsedWhitespace(TCHAR *pchCollapsedWhitespace, BOOL fGravity)
{
    HRESULT       hr = S_OK;
    CSpliceRecord *prec;
    TCHAR         *pch;
    
    Assert(pchCollapsedWhitespace);

    if (_fInsert)
    {
        long cch = _tcslen(pchCollapsedWhitespace)+1;

        pch = new(Mt(CollapsedWhitespace)) TCHAR[cch];
        if (!pch)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }
        
        memcpy(pch, pchCollapsedWhitespace, cch*sizeof(TCHAR));
            
        hr = THR(_aryInside.AppendIndirect(NULL, &prec));
        if (hr)
        {
            delete [] pch;
            goto Cleanup;
        }

        prec->_type = CTreePos::Pointer;
        prec->_fMarkupPointer = FALSE;
        prec->_pchCollapsedWhitespace = pch;
        prec->_fCollapsedWhitespaceGravity = BYTE(fGravity);
    }

Cleanup:
    RRETURN(hr);
}


//+---------------------------------------------------------------------------
//
//  Method:     CSpliceTreeEngine::FirstRecord
//
//  Synposis:   Returns the leftmost item recorded in RecordSplice
//
//----------------------------------------------------------------------------
CSpliceRecord *
CSpliceTreeEngine::FirstRecord()
{
    Assert(_paryRemoveUndo || _fReversed || (!_prec && !_crec && !_cAry));

    // 1. Reverse _aryLeft

    if (!_paryRemoveUndo && !_fReversed)
    {
        CSpliceRecord *precL;
        CSpliceRecord *precR;
        CSpliceRecord rec;

        if (_aryLeft.Size() > 1)
        {
            precL = _aryLeft;
            precR = _aryLeft + _aryLeft.Size() - 1;

            while (precL < precR)
            {
                memcpy(&rec, precL, sizeof(CSpliceRecord));
                memcpy(precL, precR, sizeof(CSpliceRecord));
                memcpy(precR, &rec, sizeof(CSpliceRecord));
                precL += 1;
                precR -= 1;
            }
        }

        _fReversed = TRUE;
    }

    // 2. Return first thing
    
    _prec = NULL;
    _crec = 0;
    _cAry = AryNone;

    return NextRecord();
}


//+---------------------------------------------------------------------------
//
//  Method:     CSpliceTreeEngine::NextRecord
//
//  Synposis:   Advances to the next (to the right) item recorded
//              in RecordSplice
//
//----------------------------------------------------------------------------
CSpliceRecord *
CSpliceTreeEngine::NextRecord()
{
    Assert(_paryRemoveUndo || _fReversed);
    
    _prec += 1;
    
    while (!_crec)
    {
        _cAry = (WhichAry)(_cAry + 1);

        switch (_cAry)
        {
        case AryLeft:
            if (!_paryRemoveUndo)
            {
                _crec = _aryLeft.Size();
                _prec = _aryLeft;
            }
            break;
            
        case AryInside:
            if (!_paryRemoveUndo)
            {
                _crec = _aryInside.Size();
                _prec = _aryInside;
            }
            else
            {
                _crec = _paryRemoveUndo->Size();
                _prec = *_paryRemoveUndo;
            }
            break;
            
        case AryDone:
            return NULL;

        default:
            AssertSz(0, "Iterated past end");
        }
    }
    
    _crec -= 1;

    return _prec;
}

//+---------------------------------------------------------------------------
//
//  Method:     CSpliceTreeEngine::RecordStory
//
//  Synposis:   Accumulates text to be copied from the splice.
//
//              ptx should also be advanced by cch
//
//----------------------------------------------------------------------------
HRESULT
CSpliceTreeEngine::RecordStory(CTxtPtr *ptx, long cch)
{
    HRESULT hr = S_OK;
    const TCHAR *pch;
    LONG cchValid;

    Assert( _fInsert );
    
    while (cch)
    {
        pch = ptx->GetPch(cchValid);
        if (!pch)
        {
            hr = E_FAIL;
            goto Cleanup;
        }
        if (cchValid > cch)
            cchValid = cch;

        hr = THR(RecordText(pch, cchValid));
        if (hr)
            goto Cleanup;
            
        ptx->AdvanceCp(cchValid);
        cch -= cchValid;
    }

Cleanup:
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Method:     CSpliceTreeEngine::RecordText
//
//  Synposis:   Records a string
//
//----------------------------------------------------------------------------
HRESULT
CSpliceTreeEngine::RecordText(const TCHAR *pch, long cch)
{
    HRESULT hr = S_OK;

    Assert( _fInsert );
    
    if (_cchRecord + cch > _cchRecordAlloc)
    {
        if (!_cchRecordAlloc)
             _cchRecordAlloc = 16;

        do _cchRecordAlloc *= 2;
            while (_cchRecord + cch > _cchRecordAlloc);
            
        hr = THR(MemRealloc(Mt(CSpliceTreeEngine_pchRecord), (void **)&_pchRecord, _cchRecordAlloc * sizeof(TCHAR)));
        if (hr)
            goto Cleanup;
    }

    memcpy(_pchRecord + _cchRecord, pch, cch * sizeof(TCHAR));

    _cchRecord += cch;

Cleanup:
    RRETURN(hr);
}

static const TCHAR achNodeChars[32] = {
    WCH_NODE, WCH_NODE, WCH_NODE, WCH_NODE, WCH_NODE, WCH_NODE, WCH_NODE, WCH_NODE,
    WCH_NODE, WCH_NODE, WCH_NODE, WCH_NODE, WCH_NODE, WCH_NODE, WCH_NODE, WCH_NODE,
    WCH_NODE, WCH_NODE, WCH_NODE, WCH_NODE, WCH_NODE, WCH_NODE, WCH_NODE, WCH_NODE,
    WCH_NODE, WCH_NODE, WCH_NODE, WCH_NODE, WCH_NODE, WCH_NODE, WCH_NODE, WCH_NODE };

//+---------------------------------------------------------------------------
//
//  Method:     CSpliceTreeEngine::RecordNodeChars
//
//  Synposis:   Records a certain number of nodechars
//
//----------------------------------------------------------------------------
HRESULT
CSpliceTreeEngine::RecordNodeChars(long cch)
{
    HRESULT hr = S_OK;
    LONG cch2;

    Assert( _fInsert );

    cch2 = ARRAY_SIZE(achNodeChars);

    while (cch)
    {
        if (cch < cch2)
            cch2 = cch;
            
        hr = THR(RecordText(achNodeChars, cch2));
        if (hr)
            goto Cleanup;

        cch -= cch2;
    }
    
Cleanup:
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Method:     CSpliceTreeEngine::TextRecorded
//
//  Synposis:   Returns the text recorded by RecordText
//
//----------------------------------------------------------------------------
void
CSpliceTreeEngine::GetTextRecorded(const TCHAR **ppch, long *pcch)
{
    *ppch = _pchRecord;
    *pcch = _cchRecord;
}


//+---------------------------------------------------------------------------
//
//  Method:     CSpliceTreeEngine::RecordSplice
//
//  Synposis:   Does not change the tree; is paired with InsertSplice
//
//              Traverses the region to be spliced and records all
//              begin-edges, end-edges, text poses, text, and pointers
//              to be spliced.
//
//              Elements that partially overlap the left or the right
//              of the region are treated specially: implicit begin-edges
//              (on the left) and end-edges (on the right) are noted.
//
//              Elements are cloned into the record if !_fRemove or
//              if they partially overlap the region.
//
//              Differentiates pointers with cling from those
//              without, and only records those with cling.
//
//              Most text is copied verbatim. But elements that entirely
//              cover the region are special: node chars for those
//              elements must be skipped when they appear in inclusions.
//
//----------------------------------------------------------------------------
HRESULT
CSpliceTreeEngine::RecordSplice()
{
    // Record all begin edges, end edges, and text
    HRESULT hr = S_OK;
    CTxtPtr tx(_pMarkupSource, _ptpSourceL->GetCp());
    CTreeNode *pnode;
    CTreeNode *pnodeLimit;
    CTreePos *ptp;
    LONG c;
    LONG cIncl;
    LONG cLimit;
    LONG cSkip;
    LONG cch;

    // Step 1: mark and record all the L-overlapping elements and
    // note all the R-overlapping elements

    for (pnode = _pnodeSourceR; pnode != _pnodeSourceTop; pnode = pnode->Parent())
        pnode->Element()->_fMark1 = FALSE;

    for (pnode = _pnodeSourceL; pnode != _pnodeSourceTop; pnode = pnode->Parent())
        pnode->Element()->_fMark1 = TRUE;
        
    for (pnode = _pnodeSourceR; pnode != _pnodeSourceTop; pnode = pnode->Parent())
    {
        if (pnode->Element()->_fMark1 == FALSE)
        {
            hr = THR(NoteRightElement(pnode->Element()));
            if (hr)
                goto Cleanup;
        }
        else
        {
            pnode->Element()->_fMark1 = FALSE;
        }
    }

    if (_fInsert)
    {
        for (pnode = _pnodeSourceL; pnode != _pnodeSourceTop; pnode = pnode->Parent())
        {
            if (pnode->Element()->_fMark1)
            {
                hr = THR(RecordLeftBeginElement(pnode->Element()));
                if (hr)
                    goto Cleanup;
            }
        }

        hr = THR(RecordNodeChars(LeftOverlap()));
        if (hr)
            goto Cleanup;
    }

    // Step 2: scan range, recording all begin-edges, end-edges, and text

    cIncl = 0;
    cch = 0;
    pnodeLimit = _pnodeSourceL;
    
    if (_ptpSourceR->NextTreePos() != _ptpSourceL) for (ptp = _ptpSourceL; ; ptp = ptp->NextTreePos())
    {
        Assert( ptp->InternalCompare( _ptpSourceR ) <= 0 );

        switch (ptp->Type())
        {
        case CTreePos::NodeBeg:
        
            if (ptp->IsEdgeScope())
            {
                Assert(!cIncl);
                
                hr = THR(RecordBeginElement(ptp->Branch()->Element()));
                if (hr)
                    goto Cleanup;

                cch++;
            }
            else
            {
                cIncl -= 1;
            }
            
            break;

        case CTreePos::NodeEnd:
        
            if (ptp->Branch() == pnodeLimit) // it's an inclusion out of which we need to skip some poses
            {
                cSkip = 0;

                for (c = 0; !ptp->IsEdgeScope(); ptp = ptp->NextTreePos(), c += 1)
                    if (!ptp->Branch()->Element()->_fMark1)
                        cSkip += 1;
                
                Assert(ptp->IsEndElementScope());

                hr = THR(RecordEndElement(cIncl + c, cSkip, TRUE, FALSE));
                if (hr)
                    goto Cleanup;

                cch++;
                
                for (; c; ptp = ptp->NextTreePos(), c -= 1);

                pnodeLimit = ptp->IsEdgeScope() ? pnodeLimit->Parent() : ptp->Branch();

                if (cSkip && _fInsert)
                {
                    hr = THR(RecordStory(&tx, cch));
                    if (hr)
                        goto Cleanup;
                        
                    cch = 0;
                }
            }
            else
            {
                if (ptp->IsEdgeScope())
                {
                    hr = THR(RecordEndElement(cIncl, 0, FALSE, FALSE));
                    if (hr)
                        goto Cleanup;

                    cch++;
                }
                else
                {
                    cIncl += 1;
                }
            }

            break;
            
        case CTreePos::Text:

            Assert(cIncl == 0);
        
            hr = THR(RecordTextPos(ptp->Cch(), ptp->Sid(), _fRemove ? ptp->TextID() : 0));
            if (hr)
                goto Cleanup;

            cch += ptp->Cch();
            
            break;

        case CTreePos::Pointer:

            Assert(cIncl == 0);
        
            if (ptp->Cling() && _fRemove && ptp->MarkupPointer())
            {
                hr = THR(RecordPointer(ptp->MarkupPointer()));
                if (hr)
                    goto Cleanup;
            }
            else if (ptp->GetCollapsedWhitespace())
            {
                hr = THR(RecordCollapsedWhitespace(ptp->GetCollapsedWhitespace(), ptp->Gravity()));
                if (hr)
                    goto Cleanup;
            }
        }
        
        if (ptp == _ptpSourceR)
            break;
    }

    Assert(cIncl == 0);
    
    // 3. Flush text
    
    if (cch && _fInsert)
    {
        hr = THR(RecordStory(&tx, cch));
        if (hr)
            goto Cleanup;
    }

    // 4. Finish scan to get right-overlap element end edges in correct order
    if (_fInsert)
    {
        for (pnode = _pnodeSourceR, cLimit = 0; pnode != pnodeLimit; pnode = pnode->Parent(), cLimit += 1);
        pnode = _pnodeSourceR;
        cch = 0;

        while (cLimit)
        {
            for (ptp = pnode->GetEndPos(), cIncl = 0; !ptp->IsEdgeScope(); ptp = ptp->NextTreePos(), cIncl += 1);
        
            if (cIncl < cLimit)
            {
                hr = THR(RecordEndElement(cIncl, 0, FALSE, TRUE));
                if (hr)
                    goto Cleanup;
                cch++;
                cLimit -= 1;
            }
        
            for (; cIncl; ptp = ptp->NextTreePos(), cIncl -= 1);

            pnode = ptp->IsEdgeScope() ? pnode->Parent() : ptp->Branch();
        }

        hr = THR(RecordNodeChars(cch));
        if (hr)
            goto Cleanup;
    }

Cleanup:

    RRETURN(hr);
    
}

//+---------------------------------------------------------------------------
//
//  Helper functions for sending notifications in InsertSplice
//
//----------------------------------------------------------------------------

static void 
SendTextAddedNotification( CMarkup * pMarkup, CTreeNode * pNode, long cp, long cch )
{
    CNotification nfText;
    
    nfText.CharsAdded( cp, cch, pNode );
    WHEN_DBG( nfText._fNoTextValidate = TRUE );
    
    pMarkup->Notify( nfText );
}

static void 
SendElementAddedNotification( CMarkup * pMarkup, long si, long cel )
{
    CNotification nfElements;
    
    nfElements.ElementsAdded( si, cel );
    WHEN_DBG( nfElements._fNoElementsValidate = TRUE );
    
    pMarkup->Notify( nfElements );
}

//+---------------------------------------------------------------------------
//
//  Method:     CSpliceTreeEngine::InsertSplice
//
//  Synposis:   Inserts the elements and text noted by RecordSplice
//
//----------------------------------------------------------------------------
HRESULT
CSpliceTreeEngine::InsertSplice()
{
    HRESULT hr;

    CSpliceRecord *prec;
    long c, cpTarget;
    CTreeNode *pnodeNew;
    CTreeNode *pnodeCur;
    CTreePos *ptpIns;
    CTreePos *ptp;
    CTreePos *ptpNew;
    long      cchNodeRemove = 0;

    // As we make the pass inserting stuff,
    // we will fix up the parent chain as we hit
    // the end of the node instead of at the begining
    // We do this so that notifications won't go to elements
    // that are currently being inserted.
    CStackPtrAry<CTreeNode *, 32> aryNodeStack(Mt(CSpliceTreeEngine_InsertSplice_aryNodeStack_pv));

    long        siNotify, cElementsNotify = 0;
    long        cpNotify, cchNotify = 0;
    CTreeNode * pNodeNotify;

    // NOTE (JHarding): Potentially when we send notifications from the remove splice phase,
    // someone could have messed with pointers in the target (cough in the editor's direction).
    // So we'll check again here.
    if( _pMarkupTarget->HasUnembeddedPointers() )
    {
        hr = THR( _pMarkupTarget->EmbedPointers() );
        if( hr )
            goto Cleanup;
    }

    ptpIns = _ptpTarget->NextTreePos();
    
    pnodeCur = _ptpTarget->GetBranch();
    pNodeNotify = pnodeCur;

    // Record where we will want to insert the text
    cpTarget = _ptpTarget->GetCp();
    cpNotify = cpTarget;

    siNotify = _ptpTarget->SourceIndex();

    // 1. Prime the node stack
    aryNodeStack.Append( pnodeCur );

    // 2. Replay the recorded tree
    
    for (prec = FirstRecord(); prec; prec = NextRecord())
    {
        switch (prec->_type)
        {
        case CTreePos::NodeBeg:
            
            // If _fSkip is turned on, the make sure that the target
            // and our list are in sync.  Just flush notifications and
            // skip over the pos in the target
            if( prec->_fSkip )
            {
                // Move past any pointer pos
                while (ptpIns->IsPointer())
                    ptpIns = ptpIns->NextTreePos();

                Assert( ptpIns->IsBeginElementScope( prec->_pel ) );

                if( cchNotify )
                    SendTextAddedNotification( _pMarkupTarget, pNodeNotify , cpNotify, cchNotify);

                cpNotify += cchNotify + 1;
                cchNotify = 0;
                ++cchNodeRemove;
                pNodeNotify = ptpIns->Branch();

                if( cElementsNotify )
                    SendElementAddedNotification( _pMarkupTarget, siNotify, cElementsNotify );

                siNotify += cElementsNotify + 1;
                cElementsNotify = 0;

                pnodeCur = ptpIns->Branch();
                aryNodeStack.Append( pnodeCur );

                // Advance ptpIns (while adjusting pointers)
                {
                    CTreePosGap tpgAdjust( ptpIns, TPG_RIGHT );
                    tpgAdjust.PartitionPointers(_pMarkupTarget, _fDOMOperation);
                    ptpIns = tpgAdjust.AdjacentTreePos( TPG_RIGHT );
                }
            }
            else
            {
                // The element may have gotten ensured into a markup while it was in the
                // undo stack.  There is no undo unit to pull it out of there, so we have
                // to do it now.
                // NOTE (JHarding): This element going out of the tree can end
                // up calling external code and hosing us.  But there's not really
                // a good time to do it.
                if( prec->_pel->IsInMarkup() )
                {
                    CMarkup * pMarkup = prec->_pel->GetMarkupPtr();

                    Assert( pMarkup->_fEnsuredMarkupDbg );

                    hr = THR( pMarkup->RemoveElementInternal( prec->_pel ) );
                    if( hr )
                        goto Cleanup;
                }

                // Create a new node and insert it in the markup
                pnodeNew = new CTreeNode(pNodeNotify, prec->_pel);
                if (!pnodeNew)
                    goto OutOfMemory;

                ptpNew = pnodeNew->InitBeginPos(TRUE);

                hr = THR(_pMarkupTarget->Insert(ptpNew, ptpIns, TRUE));
                if (hr)
                    goto Cleanup;

                prec->_pel->__pNodeFirstBranch = pnodeNew;

                prec->_pel->SetMarkupPtr(_pMarkupTarget);
                prec->_pel->PrivateEnterTree();

                pnodeNew->PrivateEnterTree();

                pnodeCur = pnodeNew;
                aryNodeStack.Append( pnodeCur );
                cElementsNotify++;
                cchNotify++; 
            }
            break;

        case CTreePos::NodeEnd:
            // There are three cases we have to handle here:
            // 1) The inclusion is all-new
            // 2) The inclusion is new but includes some elements
            //    which were already in the tree
            // 3) The inclusion already exists and we need to thread
            //    elements through it
            //
            // 1 and 2 happen when fSkip is off.  2 happens as soon
            // as we hit pNodeNotify as we are couting off the inclusions.
            // 3 happens only when fSkip is on.
            {
                CTreePos *  ptpKernel;
                CTreeNode * pNodeStay = pNodeNotify;
                CTreeNode * pNodeCurL;
                long        iNodeStack = aryNodeStack.Size() - 1;
                long        cInclStay = 0;
                BOOL        fInclusionCreated = FALSE;
                BOOL        fSkip = TRUE;

                {
                    CTreeNode * pNodeEnd;

                    if( prec->_cIncl <= iNodeStack )
                    {
                        pNodeEnd = aryNodeStack[ iNodeStack - prec->_cIncl ];
                        fSkip = !pNodeEnd->GetEndPos()->IsUninit();
                    }
                }


                // Move past any pointer pos
                if( fSkip )
                {
                    while (ptpIns->IsPointer())
                        ptpIns = ptpIns->NextTreePos();
                }

                // Create/skip the left half of the inclusion.  We use the parent 
                // chain starting with pNodeNotify as the list of elements already 
                // in the tree and we use aryNodeStack as the total list of elements at
                // this point

                for( c = prec->_cIncl; c; c--, iNodeStack-- )
                {
                    Assert( pnodeCur == aryNodeStack[ aryNodeStack.Size() - 1 ] );

                    if (pnodeCur == pNodeStay)
                    {
                        if( fSkip )
                        {
                            if( cchNotify )
                                SendTextAddedNotification( _pMarkupTarget, pNodeNotify , cpNotify, cchNotify);

                            Assert( !ptpIns->IsEdgeScope() );
                            cpNotify += cchNotify;
                            cchNotify = 0;
                        }
                        // We hit case 2 so create an inclusion so we
                        // can sorta treat it like case 3
                        else if (!fInclusionCreated)
                        {
                            CTreePosGap tpgLocation( ptpIns, TPG_LEFT, TPG_LEFT );
                            CTreeNode * pNodeStop = aryNodeStack[ iNodeStack - c ]->Parent();

                            hr = THR( _pMarkupTarget->CreateInclusion( 
                                        pNodeStop, &tpgLocation, NULL, pnodeCur ) );
                            if (hr)
                                goto Cleanup;

                            fInclusionCreated = TRUE;

                            ptpIns = tpgLocation.AdjacentTreePos( TPG_RIGHT );
                        }

                        Assert( ptpIns->IsEndNode() 
                            &&  !ptpIns->IsEdgeScope() 
                            &&  ptpIns->Branch() == pNodeStay );

                        ptpIns = ptpIns->NextTreePos();

                        pNodeStay = pNodeStay->Parent();
                        cInclStay++;
                    }
                    else
                    {
                        // This is an element that is being inserted
                        // so thread it through the inclusion

                        Assert( pnodeCur->GetEndPos()->IsUninit() );
                        ptpNew = pnodeCur->InitEndPos(FALSE);
            
                        hr = THR(_pMarkupTarget->Insert(ptpNew, ptpIns, TRUE));
                        if (hr)
                            goto Cleanup;

                    }

                    Assert( iNodeStack >= 0 && iNodeStack == aryNodeStack.Size() - 1 );
                    aryNodeStack.Delete( iNodeStack );
                    if( iNodeStack == 0 )
                    {
                        iNodeStack = 1;
                        aryNodeStack.Append( pnodeCur->Parent() );
                    }
                    pnodeCur = aryNodeStack[ iNodeStack - 1 ];
                }

                //
                // Now handle the kernel of the inclusion
                //

                if( fSkip )
                {                            
                    if( cchNotify )
                        SendTextAddedNotification( _pMarkupTarget, pNodeNotify , cpNotify, cchNotify);

                    cpNotify += cchNotify + 1;
                    cchNotify = 0;
                    ++cchNodeRemove;

                    Assert( pnodeCur == pNodeStay );
                    Assert( ptpIns->IsEndElementScope() && ptpIns->Branch() == pnodeCur );

                    ptpKernel = ptpIns;
                    ptpIns = ptpIns->NextTreePos();
                }
                else
                {
                    // Insert the kernel of the inclusion
                    Assert( pnodeCur->GetEndPos()->IsUninit() );
                    ptpKernel = pnodeCur->InitEndPos(TRUE);
        
                    hr = THR(_pMarkupTarget->Insert(ptpKernel, ptpIns, TRUE));
                    if (hr)
                        goto Cleanup;

                    cchNotify++;
                }

                pNodeStay = pNodeNotify = pnodeCur->Parent();

                // pop the kernel off of the stack
                Assert( iNodeStack >= 0 && iNodeStack == aryNodeStack.Size() - 1 );
                aryNodeStack.Delete( iNodeStack );
                if( iNodeStack == 0 )
                {
                    iNodeStack = 1;
                    aryNodeStack.Append( pnodeCur->Parent() );
                }
                iNodeStack--;
                pnodeCur = aryNodeStack[ iNodeStack ];

                // reparent the kernel node
                ptpKernel->Branch()->SetParent( pnodeCur );

                //
                // Find the node to send notifications on the right
                //
                if (cInclStay)
                {
                    for( c = cInclStay - 1, ptp = ptpIns; c; c--, ptp = ptp->NextTreePos() )
                    {
                        Assert( ptp->IsBeginNode() && ! ptp->IsEdgeScope() );
                    }

                    Assert( ptp->IsBeginNode() && ! ptp->IsEdgeScope() );

                    pNodeNotify = ptp->Branch();
                }

                //
                // Finish off the right side of the inclusion and fix up the parent
                // chain on the left
                //

                pNodeCurL = ptpKernel->Branch();

                for (ptp = ptpKernel->PreviousTreePos(), c = prec->_cIncl; c; ptp = ptp->PreviousTreePos(), c--)
                {
                    Assert( ptp->IsEndNode() && !ptp->IsEdgeScope() );

                    if( cInclStay && ptp->Branch()->Element() == ptpIns->Branch()->Element() )
                    {
                        // Advance past the node that is already there
                        Assert( pNodeStay == ptpIns->Branch()->Parent() );
                        pNodeStay = ptpIns->Branch();

                        if( fSkip )
                        {
                            if( cchNotify )
                                SendTextAddedNotification( _pMarkupTarget, pNodeNotify , cpNotify, cchNotify);

                            cpNotify += cchNotify;
                            cchNotify = 0;
                        }

                        pnodeNew = pNodeStay;

                        ptpIns = ptpIns->NextTreePos();

                        cInclStay--;
                    }
                    else
                    {
                    
                        // Insert a new node into the tree, parented to an element that
                        // is not being inserted
                        pnodeNew = new CTreeNode(pNodeStay, ptp->Branch()->Element());
                        if (!pnodeNew)
                            goto OutOfMemory;

                        ptpNew = pnodeNew->InitBeginPos(FALSE);
                
                        hr = THR(_pMarkupTarget->Insert(ptpNew, ptpIns, TRUE));
                        if (hr)
                            goto Cleanup;

                        pnodeNew->PrivateEnterTree();
                    }

                    pnodeCur = pnodeNew;
                    aryNodeStack.Append( pnodeCur );

                    // Reparent the node on the left
                    ptp->Branch()->SetParent( pNodeCurL );
                    pNodeCurL = ptp->Branch();
                }

                Assert( pNodeStay == pNodeNotify );

                //
                // Finally, if we skipped over something, partition pointers
                //
                if( fSkip )
                {
                    CTreePosGap tpgAdjust( ptpIns, TPG_LEFT );
                    tpgAdjust.PartitionPointers(_pMarkupTarget, _fDOMOperation);
                    ptpIns = tpgAdjust.AdjacentTreePos( TPG_RIGHT );
                }
            }
            break;

        case CTreePos::Text:

            // CONSIDER (JBeda): do we want to merge with pervious/next text pos here?
            ptpNew = _pMarkupTarget->NewTextPos(prec->_cch, prec->_sid, prec->_lTextID);
            if (!ptpNew)
                goto OutOfMemory;

            hr = THR(_pMarkupTarget->Insert(ptpNew, ptpIns, TRUE));
            if (hr) 
                goto Cleanup;

            cchNotify += prec->_cch;
            
            break;

        case CTreePos::Pointer:
            {
                CTreePosGap tpg(ptpIns, TPG_LEFT);

                if (prec->_fMarkupPointer)
                {
                    Assert(prec->_pPointer);
                    hr = THR( prec->_pPointer->MoveToGap( & tpg, _pMarkupTarget, TRUE ) );
                    if (hr)
                        goto Cleanup;

                    Assert(ptpIns->PreviousTreePos()->MarkupPointer() == prec->_pPointer);
                }
                else 
                {
                    CTreePos *ptp = _pMarkupTarget->NewPointerPos(NULL, TRUE, TRUE, TRUE);

                    if (!ptp)
                    {
                        hr = E_OUTOFMEMORY;
                        goto Cleanup;
                    }

                    Assert(prec->_pchCollapsedWhitespace);

                    ptp->SetCollapsedWhitespace(prec->_pchCollapsedWhitespace);
                    prec->_pchCollapsedWhitespace = NULL;

                    ptp->SetGravity(prec->_fCollapsedWhitespaceGravity);
                    ptp->SetCling(TRUE);

                    hr = THR(_pMarkupTarget->Insert(ptp, &tpg));
                    if (hr)
                        goto Cleanup;
                }
            }
            break;
        }
    }

    // Flush any left over notifications
    if( cchNotify )
        SendTextAddedNotification( _pMarkupTarget, pNodeNotify , cpNotify, cchNotify);
    WHEN_DBG( cpNotify += cchNotify );

    if( cElementsNotify )
        SendElementAddedNotification( _pMarkupTarget, siNotify, cElementsNotify );

    // 3. Merge text on the left and right (keeping L and R clear of the action),
    //    and unposition tree pointer at right

    // ptpIns is at the right.  So try to merge with whatever is before it
    _pMarkupTarget->MergeText(ptpIns->PreviousTreePos());

    // _ptpTarget is at the left.  Removing it will merge as
    Assert( ! _pMarkupTarget->HasUnembeddedPointers() );
    Assert( _ptpTarget );
    hr = THR(_pMarkupTarget->RemovePointerPos( _ptpTarget, NULL, NULL ) );
    if (hr)
        goto Cleanup;

    // 4. Insert recorded text
    {
        CTxtPtr tx(_pMarkupTarget, cpTarget);
        const TCHAR *pch;
        LONG cch;

        GetTextRecorded(&pch, &cch);

#if DBG==1
        CTxtPtr tpDbg( _pMarkupTarget, cpTarget );
        for( int cchDbg = cchNodeRemove; cchDbg; cchDbg-- )
        {
            Assert( tpDbg.GetChar() == WCH_NODE );
            tpDbg.NextChar();
        }
#endif
        tx.DeleteRange( cchNodeRemove );

        if (tx.InsertRange(cch, pch) != cch)
            goto OutOfMemory;

        Assert( cpTarget + cch == cpNotify );
        _InsertUndo.SetData( cpTarget, cpTarget + cch );
    }

    // 5. Send ENTERTREE notifications, top town
    
    for (prec = FirstRecord(); prec; prec = NextRecord())
    {
        if (    prec->_type == CTreePos::NodeBeg
            &&  ! prec->_fSkip )
        {
            CNotification nf;
            nf.ElementEntertree(prec->_pel);
            nf.SetData( (_pnodeSourceL == _pnodeSourceR && _fRemove) ? ENTERTREE_MOVE : 0 );
            prec->_pel->Notify(&nf);
        }

    }
    
    _pMarkupTarget->UpdateMarkupTreeVersion();

    _InsertUndo.CreateAndSubmit();

    if( _fTreeSyncTarget )
    {
        if( _paryRemoveUndo )
        {
            IGNORE_HR( _pMarkupTarget->GetLogManager()->InsertSplice( cpTarget, _cchRecord, _pchRecord, NULL, _paryRemoveUndo ) );
        }
        else
        {
            IGNORE_HR( _pMarkupTarget->GetLogManager()->InsertSplice( cpTarget, _cchRecord, _pchRecord, &_aryLeft, &_aryInside ) );
        }
    }

Cleanup:

    Assert( _pMarkupTarget->IsNodeValid() );

    RRETURN(hr);

OutOfMemory:

    hr = E_OUTOFMEMORY;
    goto Cleanup;
}

//+---------------------------------------------------------------------------
//
//  Helper functions for sending notifications in RemoveSplice
//
//----------------------------------------------------------------------------

static void 
SendTextDeletedNotification( CMarkup * pMarkup, CTreeNode * pNode, long cp, long cch )
{
    CNotification nfText;
    
    nfText.CharsDeleted( cp, cch, pNode );
    WHEN_DBG( nfText._fNoTextValidate = TRUE );
    
    pMarkup->Notify( nfText );
}

static void 
SendElementDeletedNotification( CMarkup * pMarkup, long si, long cel )
{
    CNotification nfElements;
    
    nfElements.ElementsDeleted( si, cel );
    WHEN_DBG( nfElements._fNoElementsValidate = TRUE );
    
    pMarkup->Notify( nfElements );
}

//+---------------------------------------------------------------------------
//
//  Method:     CSpliceTreeEngine::RemoveSplice
//
//  Synposis:   Remove all
//
//  TODO (JBeda): There might be an issue node caches not being cleared properly.
//
//----------------------------------------------------------------------------
HRESULT
CSpliceTreeEngine::RemoveSplice()
{
    HRESULT             hr = S_OK;
    long                cchNodeReinsert = 0, cchRemove = 0;
    long                cpBegin = 0, cpEnd = 0;
    long                cp = _ptpSourceR->GetCp() + _ptpSourceR->GetCch();
    long                cElementsExitTotal = 0;
    CStackPtrAry<CElement *, 32> aryDelayRelease(Mt(CSpliceTreeEngine_RemoveSplice_aryDelayRelease_pv));
    CTreePos *          ptpOutsideL;
    CMarkup::CLock      MarkupLock( _pMarkupSource );

    if (!_fRemove || _ptpSourceL == _ptpSourceR->NextTreePos())
        goto Cleanup;

     if( _fTreeSyncSource )
     {
         cpBegin= _ptpSourceL->GetCp();
         cpEnd = _ptpSourceR->GetCp() + _ptpSourceR->GetCch();
     }

    // 0. Get rid of pointers with cling on the edges.  We do this so
    //    that _ptpSourceL/R can be repositioned on non pointer
    //    poses.  We do this so elements can muck with selection
    //    in their exit tree notification.
    while (_ptpSourceL->IsPointer())
    {
        if( _ptpSourceL == _ptpSourceR )
            break;

        if (_ptpSourceL->Cling())
        {
            CTreePos * ptp = _ptpSourceL->NextTreePos();

            Verify( ! _pMarkupSource->Remove( _ptpSourceL ) );

            _ptpSourceL = ptp;
        }
        else
        {
            _ptpSourceL = _ptpSourceL->NextTreePos();
        }
    }

    while (_ptpSourceR->IsPointer())
    {
        if( _ptpSourceL == _ptpSourceR )
            break;

        if (_ptpSourceR->Cling())
        {
            CTreePos * ptp = _ptpSourceR->PreviousTreePos();

            Verify( ! _pMarkupSource->Remove( _ptpSourceR ) );

            _ptpSourceR = ptp;
        }
        else
        {
            _ptpSourceR = _ptpSourceR->PreviousTreePos();
        }
    }

    // 1. Nondestructive: Mark all elements leaving the tree as about 
    //    to leave.  Also send ElementsDeleted to the markup

    if (_ptpSourceR->NextTreePos() != _ptpSourceL)
    {
        CTreeNode * pNodeLimit = _pnodeSourceR;
        CElement *  pelLimit = _pnodeSourceR->Element();
        CElement *  pel;
        CTreePos *  ptp;

        // First go through and set the _fExitTreePending bit on
        // all of the elements that are leaving the tree.  Also
        // send ElementsDeleted notifications to the markup.
        long cElements = 0;

        for (ptp = _ptpSourceR; ; ptp = ptp->PreviousTreePos())
        {
            if (!ptp->IsBeginElementScope())
                goto Previous1;
            
            pel = ptp->Branch()->Element();

            if (pel == pelLimit)
            {
                pNodeLimit = pNodeLimit->Parent();
                pelLimit = pNodeLimit->Element();

                if( cElements )
                {
                    SendElementDeletedNotification( _pMarkupSource, ptp->SourceIndex() + 1, cElements );
                    cElements = 0;
                }

                goto Previous1;
            }
        
            Assert( ! pel->_fExittreePending );
            pel->_fExittreePending = TRUE;
            cElements++;
            cElementsExitTotal++;
            
        Previous1:
            if (ptp == _ptpSourceL)
                break;
        }

        // finish up any elements left
        if( cElements )
        {
            SendElementDeletedNotification( 
                _pMarkupSource, 
                ptp->SourceIndex() + ptp->GetCElements(), 
                cElements );
        }
    }

    // 2. Nondestructive: Actually send the exit tree notification to
    //    the elements that are leaving the markup
    if( cElementsExitTotal )
    {
        CTreeNode * pNodeLimit = _pnodeSourceR;
        CElement *  pelLimit = _pnodeSourceR->Element();
        CElement *  pel;
        CTreePos *  ptp;

        // Now actually send the notification
        for (ptp = _ptpSourceR; ; ptp = ptp->PreviousTreePos())
        {
            if (!ptp->IsBeginElementScope())
                goto Previous2;
            
            pel = ptp->Branch()->Element();

            if (pel == pelLimit)
            {
                pNodeLimit = pNodeLimit->Parent();
                pelLimit = pNodeLimit->Element();
                goto Previous2;
            }
        
            Assert( pel->_fExittreePending );

            {
                CNotification   nf;
                DWORD           dwData = 0;

                if( _pnodeSourceL == _pnodeSourceR && _fInsert )
                    dwData |= EXITTREE_MOVE;

                if( pel->GetObjectRefs() == 1 )
                {
                    dwData |= EXITTREE_PASSIVATEPENDING;
                    Assert( !pel->_fPassivatePending );
                    WHEN_DBG( pel->_fPassivatePending = TRUE );
                }

                nf.ElementExittree1(pel);

                Assert( nf.IsSecondChanceAvailable() );

                nf.SetData( dwData );
                pel->Notify(&nf);

                //
                // During exit tree, someone may have repositioned pointers within the
                // markup.  THey may not be embedded.  Do so now.
                //

                if (_pMarkupSource->HasUnembeddedPointers())
                {
                    hr = THR( _pMarkupSource->EmbedPointers() );

                    if (hr)
                        goto Cleanup;
                }

                dwData = nf.DataAsDWORD();

                if (nf.IsSecondChanceRequested() || (dwData & EXITTREE_DELAYRELEASENEEDED))
                {
                    CElement * pElementStore = pel;

                    WHEN_DBG( pel->_fDelayRelease = TRUE );

                    pel->AddRef();

                    if( nf.IsSecondChanceRequested() )
                        pElementStore = (CElement*)((DWORD_PTR)pElementStore | 0x1);

                    hr = THR( aryDelayRelease.Append( pElementStore ) );

                    if (hr)
                        goto Cleanup;
                }
                WHEN_DBG( else pel->_fDelayRelease = FALSE );
            }

        Previous2:
            if (ptp == _ptpSourceL)
                break;
        }
    }

    // 3. Destructive: remove all text and elements that are completely in the area
    //    being removed.
    {
        CTreePos *  ptp;
        long        cchRemoveNotify = 0;
        CTreePos *  ptpRemoveR = NULL;
        CTreePos *  ptpLast = NULL, * ptpPrev;
        CTreeNode * pNodeNotify = _pnodeSourceR;
        CTreeNode * pNodeCurrStay = _pnodeSourceR;

        long        cInclTotal = 0;
        long        cInclKeep = 0;
        BOOL        fInclEdgeKeep = TRUE;
        BOOL        fWasEdge;

        ptpOutsideL = _ptpSourceL->PreviousTreePos();

        for ( ptp = _ptpSourceR, ptpPrev = ptp->PreviousTreePos(); 
              ptp != ptpOutsideL; 
              ptpLast = ptp, ptp = ptpPrev )
        {
            ptpPrev = ptp->PreviousTreePos();

            switch( ptp->Type() )
            {
            case CTreePos::NodeBeg:
                fWasEdge = ptp->IsEdgeScope();

                {
                    // If we are not an edge, we are in an inclusion
                    if (!ptp->IsEdgeScope())
                        cInclTotal++;

                    // If we are an edge, we can't be in an inclusion
                    Assert( ptp->IsEdgeScope() == !cInclTotal );

                    CTreeNode * pNode = ptp->Branch();
                    CElement *  pElement = pNode->Element();

                    if( fWasEdge )
                        cchRemove++;

                    // This node is really going away...remove
                    // this tree pos and tell the element/node
                    if (pElement->_fExittreePending)
                    {
                        Assert( pNode != pNodeCurrStay );
                        Assert( pNode != pNodeNotify );

                        if (!ptpRemoveR)
                            ptpRemoveR = ptp;

                        _pMarkupSource->Remove( ptp, ptpRemoveR );
                        ptp = NULL;

                        pNode->PrivateExitTree();

                        Assert( ! _pMarkupSource->HasUnembeddedPointers() );

                        if (!cInclTotal)
                        {
#if DBG == 1
                            // If we are delay release, then we want
                            // to clear the passivate pending here to protect
                            // against the assert check in PrivateExitTree
                            BOOL fDelayRelease = pElement->_fDelayRelease;
                            BOOL fPassivatePending = pElement->_fPassivatePending;

                            if (fDelayRelease)
                                pElement->_fPassivatePending = FALSE;
#endif

                            pElement->_fExittreePending = FALSE;

                            pElement->__pNodeFirstBranch = NULL;
                            pElement->DelMarkupPtr();
                            pElement->PrivateExitTree(_pMarkupSource);
                            
                            Assert( ! _pMarkupSource->HasUnembeddedPointers() );

#if DBG == 1
                            // Restore the passivate pending debug flag
                            if (fDelayRelease)
                                pElement->_fPassivatePending = fPassivatePending;
#endif
                        }

                        if( fWasEdge )
                            cchRemoveNotify++;
                    }
                    else
                    // The node is staying, so just remove everything accumulated
                    // and send the text notification.
                    {
                        Assert( pNode == pNodeCurrStay );
                        pNodeCurrStay = pNode->Parent();
                        Assert( !pNodeCurrStay->Element()->_fExittreePending );

                        if (ptpRemoveR)
                            _pMarkupSource->Remove( ptpLast, ptpRemoveR );

                        // Send any needed text notifications
                        if (cchRemoveNotify)
                        {
                            Assert( cp == ptp->GetCp() + fWasEdge ? 1 : 0 );

                            // CONSIDER (JBeda): we can probably get rid of this notification if we
                            // know that we are in an inclusion and the inclusion is going
                            // to be closed
                            SendTextDeletedNotification( 
                                _pMarkupSource, pNodeNotify, cp, cchRemoveNotify);

                            cchRemoveNotify = 0;
                        }

                        if( fWasEdge )
                            cchNodeReinsert++;

                        if (!ptp->IsEdgeScope())
                            cInclKeep++;
                        else
                            pNodeNotify = pNodeCurrStay;
                    }

                    ptpRemoveR = NULL;
                }

                if( fWasEdge )
                    cp--;

                break;

            case CTreePos::NodeEnd:
                fWasEdge = ptp->IsEdgeScope();
                {
                    CTreeNode * pNode = ptp->Branch();
                    CElement *  pElement = pNode->Element();

                    // If we are a non edge, we must be in an inclusion
                    Assert( fWasEdge || cInclTotal );

                    if( fWasEdge )
                        cchRemove++;

                    if( pElement->_fExittreePending )
                    {
                        // mark this node pos to be removed
                        Assert( pNode != pNodeCurrStay );
                        Assert( pNode != pNodeNotify );

                        if (!ptpRemoveR)
                            ptpRemoveR = ptp;

                        if( fWasEdge )
                            cchRemoveNotify++;
                    }
                    else
                    {
                        // Remove anything marked to be removed
                        if (ptpRemoveR)
                            _pMarkupSource->Remove( ptpLast, ptpRemoveR );

                        ptpRemoveR = NULL;

                        pNode->SetParent( pNodeCurrStay );
                        pNodeCurrStay = pNode;

                        if( fWasEdge )
                            cchNodeReinsert++;

                        // If we are the last kept non edge
                        // of an inclusion in which the edge was removed
                        // we have to go back and cleanup the inclusion
                        if (!fWasEdge && cInclKeep == 1 && !fInclEdgeKeep)
                        {
                            CTreePos *  ptpIncl = ptp;
                            CTreePosGap tpgIncl;

                            do
                            {
                                Assert( ptpIncl->IsEndNode() && !ptpIncl->IsEdgeScope() );
                                ptpIncl = ptpIncl->NextTreePos();
                            } while (ptpIncl->IsEndNode());

                            tpgIncl.MoveTo( ptpIncl, TPG_LEFT );

                            Verify( ! _pMarkupSource->CloseInclusion( &tpgIncl ) );

                            // These pointers should no longer be used
                            ptp = NULL;
                            _ptpSourceR = NULL;

                            Assert( cchNodeReinsert >= 0 );

                            // We are now exiting the inclusion and 
                            // pNodeNotify should be back in sync with pNodeCurrStay
                            Assert( pNodeNotify == pNodeCurrStay );
                        }
                        // Send any needed text notifications if we didn't remove the inclusion
                        else if (cchRemoveNotify)
                        {
                            Assert( cp == ptp->GetCp() + fWasEdge ? 1 : 0 );
                            SendTextDeletedNotification(
                                _pMarkupSource, pNodeNotify, cp, cchRemoveNotify);

                            cchRemoveNotify = 0;
                        }
                    }

                    // Fix up the parent chains on the left side of 
                    // the inclusion if there is any so that 
                    // notifications go to the right place.
                    if (fWasEdge)
                    {
                        if (cInclKeep)
                        {
                            CTreePos *  ptpFixup;
                            CTreeNode * pNodeReparent = pNodeCurrStay, *pNodeFixup;
                            long        cInclFixup;
                        
                            for( cInclFixup = cInclKeep, ptpFixup = ptp->PreviousTreePos();
                                 cInclFixup;
                                 ptpFixup = ptpFixup->PreviousTreePos() )
                            {
                                Assert( ptpFixup->IsEndNode() && !ptpFixup->IsEdgeScope() );

                                pNodeFixup = ptpFixup->Branch();

                                if( !pNodeFixup->Element()->_fExittreePending )
                                {
                                    pNodeFixup->SetParent( pNodeReparent );
                                    pNodeReparent = pNodeFixup;

                                    cInclFixup--;
                                }
                            }

                            pNodeNotify = pNodeReparent;
                        }
                        else if( !pElement->_fExittreePending )
                            pNodeNotify = pNodeCurrStay;


                        // this flag will tell us if we have to come back
                        // and close this inclusion later
                        fInclEdgeKeep = !pElement->_fExittreePending;
                    }
                    // keep all of our inclusion data up to date
                    else
                    {
                        cInclTotal--;
                        if (!pElement->_fExittreePending)
                            cInclKeep--;
                    }
                }

                if( fWasEdge )
                    cp--;

                break;
            case CTreePos::Text:
                {
                    Assert( !cInclTotal );

                    long cch = ptp->Cch();
                
                    // Mark the text for removal

                    cp              -= cch;
                    Assert( cp == ptp->GetCp() );
                    cchRemove       += cch;
                    cchRemoveNotify += cch;

                    if ( !ptpRemoveR )
                        ptpRemoveR = ptp;
                }

                break;
            case CTreePos::Pointer:

                Assert( !cInclTotal );

                // If the pointer has cling, mark it for removal, otherwise
                // save the pointer by flushing the remove range
                if (!ptp->Cling())
                {
                    if (ptpRemoveR)
                    {
                        _pMarkupSource->Remove( ptpLast, ptpRemoveR );
                        ptpRemoveR = NULL;
                    }
                }
                else if (!ptpRemoveR)
                {
                    ptpRemoveR = ptp;
                }
                break;
            default:
                AssertSz( FALSE, "Unknown CTreePos type" );
            } // end switch
        } // end loop

        Assert( cp == ptp->GetCp() + ptp->GetCch() );

        // finish up by removing anything marked to be removed and
        // by sending any pending notifications
        if (ptpRemoveR)
        {
            _pMarkupSource->Remove( ptpLast, ptpRemoveR );
        }

        if (cchRemoveNotify)
        {
            SendTextDeletedNotification(
                _pMarkupSource, pNodeNotify, cp, cchRemoveNotify );
        }

        // May need to merge two adjacent remaining textposes
        Verify( !_pMarkupSource->MergeText(ptpOutsideL) );
    }

    // 4. Destructive: Actually muck with the text story
    if( _fRecordRemoveUndo )
    {
        CTxtPtr tp( _pMarkupSource, cp );

        Assert( _paryRemovedRegion );

        _pchRemoved = (TCHAR *)MemAlloc( Mt(CSpliceTreeEngine_pchRemoved), cchRemove * sizeof(TCHAR) );
        if( !_pchRemoved )
        {
            // We now have to abort all attempt at recording this remove
            delete _paryRemovedRegion;
            _paryRemovedRegion  = NULL;
            _fRecordRemoveUndo = FALSE;
        }
        else
        {
            Verify( tp.GetRawText( cchRemove, _pchRemoved ) == cchRemove );
            // At this point, we've recorded all necessary info for undo, so commit it into the undo unit
            if( _RemoveUndo.AcceptingUndo() )
            {
                _RemoveUndo._paryRegion = _paryRemovedRegion;
                _RemoveUndo.SetText( cp, cchRemove, _pchRemoved );
                _fDontReleaseRUInfo = TRUE;
            }
        }
    }

    // If for some reason recording the info failed, set appropriate flags.
    _RemoveUndo._fAcceptingUndo = _RemoveUndo._fAcceptingUndo && _fRecordRemoveUndo;
    _fTreeSyncSource = _fTreeSyncSource && _fRecordRemoveUndo;

    Assert( cchRemove >= cchNodeReinsert );
    if( cchRemove > cchNodeReinsert )
    {
        CTxtPtr tx( _pMarkupSource, cp );

        tx.DeleteRange( cchRemove );

        if (cchNodeReinsert)
        {
            Verify( tx.InsertRepeatingChar( cchNodeReinsert, WCH_NODE ) == cchNodeReinsert );
        }
    }

    Assert( _pMarkupSource->IsNodeValid() );
    _pMarkupSource->UpdateMarkupTreeVersion();

    if( _fTreeSyncSource )
    {
        IGNORE_HR( _pMarkupSource->GetLogManager()->RemoveSplice( cpBegin, 
                                                                  cpEnd, 
                                                                  _paryRemovedRegion, 
                                                                  _pchRemoved, 
                                                                  cchRemove ) );
    }

    _RemoveUndo.CreateAndSubmit();

    // Do delay release/after exit tree notifications
    {
        int         cDelay = aryDelayRelease.Size();
        CElement ** ppElement = aryDelayRelease;

        for( ; cDelay ; cDelay--, ppElement++ )
        {
            CElement *  pElement = (CElement*)((DWORD_PTR)*ppElement & ~0x1);
            BOOL        fExitTreeSc = (DWORD_PTR)*ppElement & 0x1;

            // Send any needed AfterExitTree notification
            if (fExitTreeSc)
            {
                CNotification nf;

                nf.ElementExittree2( pElement );
                pElement->Notify( &nf );
            }

            // Release the element
            Assert( pElement->_fDelayRelease );
            WHEN_DBG( pElement->_fDelayRelease = FALSE );
            Assert( !pElement->_fPassivatePending || pElement->GetObjectRefs() == 1 );
            pElement->Release();
        }
    }

Cleanup:
    
    RRETURN( hr );
}

//+---------------------------------------------------------------------------
//
//  Method:     CMarkup::SpliceTree
//
//  Synposis:   Copies, moves, or removes the region of the tree from
//              ptpgStartSource to ptpgEndSource.
//
//----------------------------------------------------------------------------
HRESULT
CMarkup::SpliceTreeInternal(
    CTreePosGap *   ptpgStartSource,
    CTreePosGap *   ptpgEndSource,
    CMarkup *       pMarkupTarget  /* = NULL */,
    CTreePosGap *   ptpgTarget /* = NULL */,
    BOOL            fRemove    /* = TRUE */,
    DWORD           dwFlags    /* = NULL */)
{
    PerfDbgLog(tagPerfWatch, this, "+CMarkup::SpliceTreeInternal");

    HRESULT hr;
    CSpliceTreeEngine engine( Doc() );

    Assert( ptpgStartSource && ptpgEndSource );
    Assert( ptpgStartSource->GetAttachedMarkup() == this );
    Assert( !fRemove || ptpgEndSource->GetAttachedMarkup() == this );

    Assert( ! ptpgStartSource->GetAttachedMarkup()->HasUnembeddedPointers() );
    Assert( !ptpgTarget || ! ptpgTarget->GetAttachedMarkup()->HasUnembeddedPointers() );

    Assert( ! HasUnembeddedPointers() );
    Assert( ! pMarkupTarget || ! pMarkupTarget->HasUnembeddedPointers() );

    //
    // The incoming source gaps must be logically ordered, but they may not be totally
    // ordered.  Make sure of that.
    //

    EnsureTotalOrder( ptpgStartSource, ptpgEndSource );

    hr = THR(engine.Init(this, ptpgStartSource, ptpgEndSource, pMarkupTarget, ptpgTarget, fRemove, dwFlags));
    
    if (hr)
        goto Cleanup;

    if (    engine._fInsert 
        ||  engine._fRemove && engine._fRecordRemoveUndo )
    {
        hr = THR(engine.RecordSplice());
        if (hr)
            goto Cleanup;
    }

    if (engine._fRemove)
    {
        hr = THR(engine.RemoveSplice());
        if (hr)
            goto Cleanup;
    }
    
    if (engine._fInsert)
    {
        hr = THR(engine.InsertSplice());
        if (hr)
            goto Cleanup;
    }

Cleanup:

    PerfDbgLog(tagPerfWatch, this, "-CMarkup::SpliceTreeInternal");

    RRETURN(hr);
}


//+---------------------------------------------------------------------------
//
//  Method:     CMarkup::UndoRemoveSplice
//
//  Synposis:   Undoes the remove part of a splice operation
//
//----------------------------------------------------------------------------
HRESULT
CMarkup::UndoRemoveSplice(
    CMarkupPointer *    pmpBegin,
    CSpliceRecordList * paryRegion,
    long                cchRemove,
    TCHAR *             pchRemove,
    DWORD               dwFlags)
{
    HRESULT hr;
    CTreePosGap       tpgBegin;
    CSpliceTreeEngine engine( Doc() );

    Assert( pmpBegin );

    hr = THR( EmbedPointers() );
    if (hr)
        goto Cleanup;

    Verify( ! tpgBegin.MoveTo( pmpBegin->GetEmbeddedTreePos(), TPG_LEFT ) );

    hr = THR(engine.InitUndoRemove(this, & tpgBegin, paryRegion, cchRemove, pchRemove, dwFlags));
    if (hr)
        goto Cleanup;

    hr = THR(engine.InsertSplice());
    if (hr)
        goto Cleanup;

Cleanup:

    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\text\selrensv.cxx ===
//+---------------------------------------------------------------------
//
//   File:      Selrensv.cpp
//
//  Contents:   Implementation of ISelectionRenderServices on CTxtEdit.
//
//  Classes:    CTxtEdit
//
//------------------------------------------------------------------------


#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_SELRENSV_HXX_
#define X_SELRENSV_HXX_
#include "selrensv.hxx"
#endif

#ifndef X_TPOINTER_HXX_
#define X_TPOINTER_HXX_
#include "tpointer.hxx"
#endif

#ifndef X_FLOWLYT_HXX_
#define X_FLOWLYT_HXX_
#include "flowlyt.hxx"
#endif

#ifndef X_TREEPOS_HXX_
#define X_TREEPOS_HXX_
#include "treepos.hxx"
#endif

#ifndef X_LSRENDER_HXX_
#define X_LSRENDER_HXX_
#include "lsrender.hxx"
#endif

#ifndef X_SEGMENT_HXX_
#define X_SEGMENT_HXX_
#include "segment.hxx"
#endif

#ifndef X_INITGUID_H_
#define X_INITGUID_H_
#include "initguid.h"
#endif

const int LEFT = 1;   
const int RIGHT = -1 ;
const int SAME = 0;
const int INVALIDATE_VERSION = - 1000000;

#define IFC(expr) {hr = THR(expr); if (FAILED(hr)) goto Cleanup;}

MtDefine(CSelectionRenderingServiceProvider, Tree , "CSelectionRenderingServiceProvider" )    
MtDefine(CHighlightSegment, Utilities, "CHighlightSegment")

DeclareTag(tagValidateSelRenSv, "Selection", "Validate Selection Rendering Changes")

#if DBG == 1
static const LPCTSTR strSelectionStartName = _T(" Start Selection Segment");
static const LPCTSTR strSelectionEndName = _T(" End Selection Segment");
#endif

CSelectionRenderingServiceProvider::CSelectionRenderingServiceProvider(CDoc* pDoc, CMarkup* pMarkup )
{
    _lContentsVersion = INVALIDATE_VERSION;
    _pDoc = pDoc;
    _pMarkup = pMarkup ;
    _nSize = 0;
}

CSelectionRenderingServiceProvider::~CSelectionRenderingServiceProvider()
{
    ClearSegments(FALSE);
}

//+============================================================================================
//
//  Method:     InvalidateSegment
//
//  Arguments:  pStart = Starting pointer which needs to be invalidated
//              pEnd = End pointer which needs to be invalidated
//              pNewStart = This is where the new selection begins
//              pNewEnd = This is where the new selection ends
//              fSelected = Turn on or off selection

//  Synopsis:   The Area from pStart to pEnd's "selectioness" has changed. 
//              Tell the renderer about it.
//
//---------------------------------------------------------------------------------------------

DeclareTag(tagDisplayShowInvalSegment, "Selection", "Selection show InvalidateSegment")

HRESULT 
CSelectionRenderingServiceProvider::InvalidateSegment(  CMarkupPointer  *pStart, 
                                                        CMarkupPointer  *pEnd,
                                                        CMarkupPointer  *pNewStart,
                                                        CMarkupPointer  *pNewEnd ,
                                                        BOOL            fSelected )
{
    CTreePos    *pCurPos;                   // Current tree position in invalidation walk
    CTreePos    *pEndPos;                   // End position of range that needs to be inval'd
    CTreeNode   *pNode;                     // The node at pCurPos
    CLayout     *pCurLayout = NULL;         // The layout for the node at pCurPos
    CTreePos    *pPrevPos = NULL;           // The last position we looked at
    CTreeNode   *pFirstNode;                // Node corresponding to start
    CLayout     *pPrevLayout = NULL;        // Previous layout we examined
    CTreePos    *pLayoutStart = NULL;       // Start position of current layout that is being examined
    BOOL        fLayoutEnclosed = FALSE;    // Is the layout enclosed completely by our inval segment
    BOOL        fLayoutChange = FALSE;      // Have we had a layout change?
    HRESULT     hr = S_OK;

    Assert(pStart && pEnd);
    if ( pNewStart && pNewEnd )
    {
        Assert(pNewStart->Markup() == pNewEnd->Markup());
        if (pNewStart->Markup() != pNewEnd->Markup())
        {
            return E_FAIL;
        }
    }

    IGNORE_HR( pStart->Markup()->EmbedPointers() );
  
    //
    // Setup the ending position, the initial layout, and the starting TREEPOS
    // for this layout
    //
    pEndPos = pEnd->GetEmbeddedTreePos();
    pFirstNode = pStart->Branch();
    pPrevLayout = pFirstNode->GetUpdatedNearestLayout();
    pLayoutStart =  pStart->GetEmbeddedTreePos() ;

    // If the selection is in a slave markup, GetNearestLayout() will return NULL
    // on the top-level nodes. In such a case, we use the layout of the markup's
    // master element.
    if (!pPrevLayout && pFirstNode->Element()->HasMasterPtr())
    {
        pPrevLayout = pFirstNode->Element()->GetMasterPtr()->GetUpdatedLayout();
    }

#if DBG == 1
    //
    // marka - we shouldn't be invalidating if End < Start or End == SAME 
    //
    int layoutStartCp , layoutEndCp;

    layoutEndCp = pEndPos->GetCp();
    layoutStartCp = pLayoutStart->GetCp( FALSE );

    Assert( pStart->IsLeftOf( pEnd ) );
    Assert( layoutStartCp <= layoutEndCp );
#endif

    //
    // Loop from the starting point which needs to be inval'd and 
    // go to the end pointer
    // 
    for ( pCurPos = pStart->GetEmbeddedTreePos() ; 
          (pCurPos ) &&  (pCurPos != pEndPos); 
          pCurPos = pCurPos->NextTreePos() )
    {
        //
        // Code to handle rendering glyphs in between the two pos's
        //
        if ( pCurPos->IsNode() && pCurPos->ShowTreePos(NULL) )
        {
            CTreeNode* pGlyphNode = pCurPos->Branch();
            CLayout* pParentLayout = pGlyphNode->GetUpdatedParentLayout();

            pParentLayout->ShowSelected( pGlyphNode->GetBeginPos() ,
                                         pGlyphNode->GetEndPos(), 
                                         fSelected, 
                                         fLayoutEnclosed );
        }            

        //
        // If we have a begin or end scope, we need to check if we 
        // crossed a layout boundary
        //
        if (  ( pCurPos && pCurPos->IsBeginElementScope() )
           || ( pPrevPos && pPrevPos->IsEndElementScope()) )
               
        {            
            pNode = pCurPos->GetBranch();
            pCurLayout = pNode->GetUpdatedNearestLayout();

            //
            // If we have a new layout - then we draw the previous layout.
            //
            if ( pPrevLayout != pCurLayout )
            {
                //
                // If this is the first time we are looping, then
                // pLayoutRunOwner will be NULL, so we need to check
                // that it is not
                //
                if ( pPrevLayout )
                {
                    TraceTag((tagDisplayShowInvalSegment, "InvalidteSegment: Inval prevLayout from tp:%d to %d:",pLayoutStart->_nSerialNumber, pCurPos->_nSerialNumber ));
#if DBG == 1
                    layoutEndCp = pCurPos->GetCp( FALSE );
                    layoutStartCp = pLayoutStart->GetCp( FALSE );
                    Assert( layoutStartCp <= layoutEndCp );
#endif  

                    fLayoutEnclosed = IsLayoutCompletelyEnclosed( pPrevLayout, pNewStart, pNewEnd);

                    pPrevLayout->ShowSelected( pLayoutStart, pCurPos, fSelected, fLayoutEnclosed );

                    //
                    // If this layout has a slave pointer, invalidate all of the layouts
                    // in the slave markup.
                    //
                    if( pPrevLayout->ElementOwner()->HasSlavePtr() )
                    {
                        InvalidateLayout( pPrevLayout, pStart->Markup(), fSelected );
                    }
                        
                    IGNORE_HR( InvalidateParentLayout( pPrevLayout, pStart->Markup(), fSelected ) );
                }

                pPrevLayout = pCurLayout;
                pLayoutStart = pCurPos;
                fLayoutChange = TRUE;
            }
        }
        pPrevPos = pCurPos;
    }

    //
    // Add final layout
    //
    if ( pPrevLayout )
    {
        TraceTag((tagDisplayShowInvalSegment, "InvalidateSegment: Inval Final Layout from tp:%d to %d:",pLayoutStart->_nSerialNumber, pEndPos->_nSerialNumber ));

#if DBG == 1
        layoutEndCp = pEndPos->GetCp();
        layoutStartCp = pLayoutStart->GetCp( FALSE );
        Assert( layoutStartCp <= layoutEndCp );
#endif

        //
        // Invalidate our layout
        //
        fLayoutEnclosed = IsLayoutCompletelyEnclosed( pPrevLayout, pNewStart, pNewEnd);

        pPrevLayout->ShowSelected( pLayoutStart, pEndPos, fSelected, fLayoutEnclosed );

        if( pPrevLayout->ElementOwner()->HasSlavePtr() )
        {
            InvalidateLayout( pPrevLayout, pStart->Markup(), fSelected );
        }

        //
        // We only need to inval our parent layout if we crossed a layout boundary.  This
        // only happens if pCurLayout != pPrevLayout
        // 
        if( fLayoutChange )
        {
            IGNORE_HR( InvalidateParentLayout( pPrevLayout, pStart->Markup(), fSelected ) );
        }
    }     

    return hr;
}


//+============================================================================================
//
// Method:      CHighlightRenderingServices::InvalidateLayout
//
// Synopsis:    We need to invalidate the flow layout.  We must call ShowSelected() on the
//              layout, and potentially invalidate any of the children layout as well.
//
// Arguments:   pLayout = Base layout 
//              fSelected = Is the layout being selected?
//---------------------------------------------------------------------------------------------
void CSelectionRenderingServiceProvider::InvalidateLayout(  CLayout     *pLayout,
                                                            CMarkup     *pMarkup,
                                                            BOOL        fSelected )
{
    DWORD_PTR   dwIterator;
    CLayout *pSubLayout = NULL;

    Assert( pMarkup && pLayout );
    
    //
    // Check to see if this flow layout has additional flow layouts
    //
    if( pLayout->ContainsChildLayout() )
    {
        pSubLayout = pLayout->GetFirstLayout(&dwIterator);
        Assert( pSubLayout );

        //
        // Loop thru each of our children layout, invalidating
        // them recursively (all of our children flow layout need to
        // have the text selected bit turned on our off )
        // 
        while( pSubLayout )
        {
            InvalidateLayout( pSubLayout, pMarkup, fSelected );
            
            pSubLayout->SetSelected( fSelected, TRUE );

            pSubLayout = pLayout->GetNextLayout(&dwIterator);
        }

        pLayout->ClearLayoutIterator( dwIterator );
    }
}

//+============================================================================================
//
// Method:      CHighlightRenderingServices::InvalidateParentLayout
//
// Synopsis:    We need to invalidate the parent flow layout.  This is because the new selection
//              code has the parent flow layout paint the site as selected, and then the 
//              flow layout of the site paints on top of the selection.  When the site becomes
//              unselected partially, we need to notify the parent.
//
// Arguments:   pLayout = Base layout from which parent's should be updated
//              pStart = Start pos of base layout
//              pEnd = End pos of base layout
//              pMarkup = Base markup in which selection is being invalidated
//              fSelected = Is the layout being selected?
//              fEnclosed = Is the layout fully enclosed?
//
// Returns:     HRESULT indicating success
//---------------------------------------------------------------------------------------------
HRESULT CSelectionRenderingServiceProvider::InvalidateParentLayout( CLayout    *pLayout,
                                                                    CMarkup    *pMarkup,
                                                                    BOOL       fSelected )
{
    CLayout         *pParentLayout;
    CElement        *pLayoutOwner;
    CTreePos        *pStartPos;             // Starting treepos
    CTreePos        *pEndPos;               // Ending treepos
    HRESULT         hr=S_OK;
    
    Assert( pLayout && pMarkup);

    //
    // Get the parent layout, and the tree pos's for the layout
    // which needs to be invalidated
    //
    pParentLayout = pLayout->GetUpdatedParentLayout();
    pLayoutOwner = pLayout->ElementOwner();
    Assert( pLayoutOwner );

    if( !pLayoutOwner )
        goto Cleanup;

    pLayoutOwner->GetTreeExtent( &pStartPos, &pEndPos );
       
    Assert( pStartPos && pEndPos );
    
    if( !pStartPos || !pEndPos)
        goto Cleanup;
          
    //
    // Walk up the parent chain until we hit a flowlayout
    //
    while(  pParentLayout                                   && 
            !pParentLayout->IsFlowLayout()                  &&
            pParentLayout->GetContentMarkup() == pMarkup )
    {
        pParentLayout = pParentLayout->GetUpdatedParentLayout();            
    }


    //
    // If we found a flow layout, then we need to invalidate it
    //
    if( pParentLayout                   && 
        pParentLayout->IsFlowLayout()   && 
        pParentLayout->GetContentMarkup() == pMarkup )
    {
        //
        // Adjust the end to be in the parent's flow layout, so that 
        // ShowSelected is able to call RegionFromElement successfull.
        //

        pEndPos = pEndPos->NextTreePos();

        pParentLayout->ShowSelected(pStartPos, pEndPos, fSelected, FALSE /* fEnclosed */ );
    }

Cleanup:
    RRETURN(hr);
}


//+============================================================================================
//
// Method: UpdateSegment
//
// Synopsis: The Given Segment is about to be changed. Work out what needs to be invalidated
//           and tell the renderer about it.
//
//  Passing pIStart, and pIEnd == NULL, makes the given segment hilite ( used on AddSegment )
//
//---------------------------------------------------------------------------------------------

DeclareTag(tagDisplaySelectedSegment , "Selection", "Selection Show Update Segement")


//+====================================================================================
//
// Method: IsLayoutCompletelySelected
//
// Synopsis: Check to see if a layout is completely enclosed by a pair of treepos's
//
//------------------------------------------------------------------------------------


BOOL 
CSelectionRenderingServiceProvider::IsLayoutCompletelyEnclosed( 
                                                                CLayout* pLayout, 
                                                                CMarkupPointer* pStart, 
                                                                CMarkupPointer* pEnd )
{
    BOOL fCompletelyEnclosed = FALSE;
    int iWhereStart = 0;
    int iWhereEnd = 0;
    CMarkupPointer* pLayoutStart = NULL;
    CMarkupPointer* pLayoutEnd = NULL;
    HRESULT hr = S_OK;

    if ( !pStart || ! pEnd )
        return FALSE;

    if ( ! pLayout->ElementOwner()->GetFirstBranch() )
        return FALSE;

    Assert(pStart->Markup() == pEnd->Markup());
    if (pStart->Markup() != pEnd->Markup())
        return FALSE;
        
    //
    // Create two markup pointers, and move them before and after
    // our element in question
    //
    IFC( pStart->Doc()->CreateMarkupPointer( &pLayoutStart ) );        
    IFC( pEnd->Doc()->CreateMarkupPointer( & pLayoutEnd ) );
        
    IFC( pLayoutStart->MoveAdjacentToElement( pLayout->ElementOwner(), ELEM_ADJ_BeforeBegin) );
    IFC( pLayoutEnd->MoveAdjacentToElement( pLayout->ElementOwner(), ELEM_ADJ_AfterEnd ) );

    if ( pLayoutStart->Markup() != pStart->Markup() )
        goto Cleanup;
        
    iWhereStart = OldCompare( pStart, pLayoutStart );

    if ( pLayoutEnd->Markup() != pEnd->Markup() )
        goto Cleanup;
        
    iWhereEnd = OldCompare( pEnd, pLayoutStart );

    fCompletelyEnclosed = ( ( iWhereStart != LEFT ) && ( iWhereEnd != RIGHT ) ) ;
    if ( fCompletelyEnclosed )
    {
        iWhereStart = OldCompare( pStart, pLayoutEnd);
        iWhereEnd = OldCompare( pEnd, pLayoutEnd );
        fCompletelyEnclosed = ( ( iWhereStart != LEFT ) && ( iWhereEnd != RIGHT ) ) ;        
    }

Cleanup:
    ReleaseInterface( pLayoutStart );
    ReleaseInterface( pLayoutEnd );
    return fCompletelyEnclosed ;
}


HRESULT
CSelectionRenderingServiceProvider::UpdateSegment( CMarkupPointer* pOldStart, CMarkupPointer* pOldEnd, CMarkupPointer* pNewStart, CMarkupPointer* pNewEnd )
{
    int ssStart;
    int ssStop;
    BOOL fSame = FALSE;
    int compareStartEnd = SAME;
    HRESULT hr = S_OK;
    
    Assert(pNewStart && pNewEnd);
    Assert(pNewStart->Markup() == pNewEnd->Markup());
    if (pOldStart && pOldEnd)
    {
        Assert(pOldStart->Markup() == pOldEnd->Markup());
    }
    if (pNewStart->Markup() != pNewEnd->Markup())
    {
        return E_FAIL;
    }

    _fInUpdateSegment = TRUE;
    
    compareStartEnd = OldCompare( pNewStart, pNewEnd ) ;
    switch( compareStartEnd )
    {
        case LEFT:
        {
            CMarkupPointer* pTemp = pNewStart;
            pNewStart = pNewEnd;
            pNewEnd = pTemp;
        }
        break;

        case SAME:
        fSame = TRUE;
        break;
    }

    
    if ( !fSame && ( pOldStart != NULL ) && ( pOldEnd != NULL ) )
    {
        //
        // Initialize pOldStart, pOldEnd, pNewStart, pNewEnd, handling Start > End.
        //
        if ( OldCompare( pOldStart, pOldEnd ) == LEFT )
        {
            CMarkupPointer* pTemp2 = pOldStart;
            pOldStart = pOldEnd;
            pOldEnd = pTemp2;
        }

        
        if ( ( OldCompare( pOldStart, pNewEnd ) == LEFT ) ||  // New End is to the left
             ( OldCompare( pOldEnd, pNewStart) == RIGHT ) )   // New Start is to right
        {
            //
            // Segments do not overlap
            //   
            TraceTag( ( tagDisplaySelectedSegment, "Non Overlap") );
            if (OldCompare( pOldStart, pOldEnd ) != SAME)
            {
                IFC( InvalidateSegment( pOldStart, pOldEnd, pNewStart, pNewEnd , FALSE )); // hide old selection
            }
            if (OldCompare( pNewStart, pNewEnd ) != SAME)
            {
                IFC( InvalidateSegment( pNewStart, pNewEnd,  pNewStart, pNewEnd , TRUE ));
            }
        }
        else
        {
            ssStart = OldCompare( pOldStart, pNewStart) ;
            ssStop  = OldCompare( pOldEnd, pNewEnd );

            //
            // Note that what we invalidate is the Selection 'delta', ie that portion of the selection
            //  whose "highlightness" is now different. We don't turn on/off parts that havent' changed
            //
            switch( ssStart )
            {
                case RIGHT:
                    switch( ssStop )
                    {
                        //
                        //      S    NS     NE   E
                        //
                        case LEFT:
                        {
                            TraceTag(( tagDisplaySelectedSegment, "Overlap 1. ssStart:%d, ssEnd:%d", ssStart, ssStop ));
                            IFC( InvalidateSegment( pOldStart, pNewStart,  pNewStart, pNewEnd ,FALSE )); // hide old selection
                            IFC( InvalidateSegment( pNewEnd, pOldEnd, pNewStart, pNewEnd , FALSE ));
                        }
                        break;
                        //
                        //      S    NS      E    NE
                        //
                        case RIGHT: 
                        {
                            TraceTag(( tagDisplaySelectedSegment, "Overlap 2. ssStart:%d, ssEnd:%d", ssStart, ssStop ));
                            IFC( InvalidateSegment( pOldStart, pNewStart,pNewStart, pNewEnd ,FALSE ));
                            IFC( InvalidateSegment( pOldEnd, pNewEnd, pNewStart, pNewEnd, TRUE ));
                        }
                        break;
                        //
                        //      S    NS      E   
                        //                   NE
                        case SAME:
                        {
                            TraceTag(( tagDisplaySelectedSegment, "Overlap 3. ssStart:%d, ssEnd:%d", ssStart, ssStop ));                        
                            IFC( InvalidateSegment( pOldStart, pNewStart, pNewStart, pNewEnd , FALSE  ));
                        }
                        break;
                    }
                    break;
                    
                case LEFT : 
                    switch( ssStop )
                    {
                        //
                        //      NS  S   NE E
                        //
                        case LEFT:
                        {
                            TraceTag(( tagDisplaySelectedSegment, "Overlap 4. ssStart:%d, ssEnd:%d", ssStart, ssStop ));
                            IFC( InvalidateSegment( pNewEnd , pOldEnd ,  pNewStart, pNewEnd , FALSE )); // hide old selection
                            IFC( InvalidateSegment( pNewStart, pOldStart, pNewStart, pNewEnd, TRUE  ));
                        }
                        break;
                        //
                        //     NS    S      E    NE
                        //
                        case RIGHT : 
                        {
                            TraceTag(( tagDisplaySelectedSegment, "Overlap 5. ssStart:%d, ssEnd:%d", ssStart, ssStop ));                            
                            IFC( InvalidateSegment( pNewStart, pOldStart, pNewStart, pNewEnd  , TRUE ));
                            IFC( InvalidateSegment( pOldEnd, pNewEnd, pNewStart, pNewEnd , TRUE  ));                                 
                        }
                        break;
                        
                       //
                       //      NS    S      E
                       //                   NE
                        case SAME:
                        {
                            TraceTag(( tagDisplaySelectedSegment, "Overlap 6. ssStart:%d, ssEnd:%d", ssStart, ssStop ));
                            IFC( InvalidateSegment( pNewStart, pOldStart, pNewStart, pNewEnd , TRUE ));
                        }
                        break;
                    }
                    break;
                    
                default: // or same - which gives us less invalidation
                    switch( ssStop )
                    {
                        //
                        //      NS     NE E
                        //      S    
                        case LEFT:
                        {
                            TraceTag(( tagDisplaySelectedSegment, "Overlap 7. ssStart:%d, ssEnd:%d", ssStart, ssStop ));
                            IFC( InvalidateSegment( pNewEnd , pOldEnd , pNewStart, pNewEnd , FALSE )); // hide old selection
                        }
                        break;
                        //
                        //      S         E    NE
                        //      NS
                        case RIGHT : 
                        {
                            TraceTag(( tagDisplaySelectedSegment, "Overlap 8. ssStart:%d, ssEnd:%d", ssStart, ssStop ));
                            IFC( InvalidateSegment( pOldEnd, pNewEnd,  pNewStart, pNewEnd, TRUE  ));
                        }
                        break;

                        //
                        // For SAME case - we do nothing.
                        //
                        case SAME : 
                        {
                            TraceTag(( tagDisplaySelectedSegment, "Overlap 9. ssStart:%d, ssEnd:%d", ssStart, ssStop ));
                        }
                        break;
                    }
                    break;                    
            } 
        }
    }
    else
    {
        TraceTag(( tagDisplaySelectedSegment, "New Segment Invalidation"));

        if ( !fSame )
        {
            IFC( InvalidateSegment( pNewStart , pNewEnd ,  pNewStart, pNewEnd , TRUE ));        
        }            
        else if ( ( pOldStart != NULL ) && ( pOldEnd != NULL ) )
        {
            int iCompareOld = OldCompare( pOldStart, pOldEnd );
            if ( iCompareOld == LEFT )
            {
                CMarkupPointer* pTemp2 = pOldStart;
                pOldStart = pOldEnd;
                pOldEnd = pTemp2;
            }        
            if ( iCompareOld != SAME )
            {
                IFC( InvalidateSegment( pOldStart , pOldEnd ,  pNewStart, pNewEnd , FALSE ));   
            }                
        }
    }

    _fInUpdateSegment = FALSE;
    
Cleanup:
    RRETURN( hr );
}

//+==================================================================================
//
// Method: AddSegment
//
// Synopsis: Add a Selection Segment, at the position given by two MarkupPointers.
//           Expected that Segment Type is either SELECTION_RENDER_Selected or None
//
//-----------------------------------------------------------------------------------
HRESULT 
CSelectionRenderingServiceProvider::AddSegment( 
    IDisplayPointer      *pDispStart, 
    IDisplayPointer      *pDispEnd,
    IHTMLRenderStyle    *pIRenderStyle,
    IHighlightSegment   **ppISegment )
{
    HRESULT             hr = S_OK;
    CMarkupPointer      *pInternalStart = NULL;
    CMarkupPointer      *pInternalEnd = NULL;
    CHighlightSegment   *pSegment = NULL;
    POINTER_GRAVITY     eGravity = POINTER_GRAVITY_Left;    // need to initialize

    Assert( pDispStart && pDispEnd && pIRenderStyle );
    if ( ! _fSelectionVisible )
        _fSelectionVisible = TRUE;

    pInternalStart = new CMarkupPointer( _pDoc );
    if ( ! pInternalStart ) goto Error;
    pInternalStart->SetAlwaysEmbed( TRUE );
    
    pInternalEnd = new CMarkupPointer( _pDoc );
    if ( ! pInternalEnd ) goto Error;
    pInternalEnd->SetAlwaysEmbed( TRUE);


    // Copy the pointers for our internal data structure.
    // Copy over the position, and the gravity
    hr = pDispStart->PositionMarkupPointer(pInternalStart);
    if ( !hr ) hr = pDispStart->GetPointerGravity( &eGravity );
    if ( !hr ) hr = pInternalStart->SetGravity( eGravity );

    if ( !hr ) hr = pDispEnd ->PositionMarkupPointer(pInternalEnd);
    if ( !hr ) hr = pDispEnd->GetPointerGravity( &eGravity );
    if ( !hr ) hr = pInternalEnd->SetGravity( eGravity );

    if( FAILED(hr) )
        goto Cleanup;    

    Assert(pInternalStart->Markup() == pInternalEnd->Markup());
    if (pInternalStart->Markup() != pInternalEnd->Markup())
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    pSegment = new CHighlightSegment();
    if( !pSegment )
        goto Error;

    hr = pSegment->Init( pInternalStart, pInternalEnd, pIRenderStyle );
    if( FAILED(hr) )
        goto Cleanup;

    //
    // Check that we are in the same tree.
    //
#if DBG == 1
    Assert( pInternalStart->Markup() == _pMarkup );
    Assert( pInternalEnd->Markup() == _pMarkup );
    pInternalStart->SetDebugName( strSelectionStartName );
    pInternalEnd->SetDebugName( strSelectionEndName );
#endif

    // Add this segment, and get the IHighlightSegment for the caller
    IFC( PrivateAdd( pSegment ) );
    IFC( pSegment->QueryInterface( IID_IHighlightSegment, (void **)ppISegment) );
    
    // Invalidate CP cache.
    _lContentsVersion = INVALIDATE_VERSION;
    
    hr = THR( UpdateSegment( NULL, NULL, pInternalStart, pInternalEnd ));    
    
Cleanup:
    TraceTag( (tagValidateSelRenSv, "SelRen::Added Segment"));

    //
    // Release our ref's
    //
    ReleaseInterface( pInternalStart );
    ReleaseInterface( pInternalEnd );

    RRETURN( hr );

Error:
    return E_OUTOFMEMORY;
}

HRESULT 
CSelectionRenderingServiceProvider::MoveSegmentToPointers( 
    IHighlightSegment *pISegment,
    IDisplayPointer* pDispStart, 
    IDisplayPointer* pDispEnd)  
{
    HRESULT             hr = S_OK;
    CMarkupPointer      mpNewStart(_pDoc);
    CMarkupPointer      mpNewEnd(_pDoc);
    CMarkupPointer      *pOldStart = NULL;
    CMarkupPointer      *pOldEnd = NULL;
    CHighlightSegment   *pSegment = NULL;
    POINTER_GRAVITY     eGravity = POINTER_GRAVITY_Left;

    Assert( pISegment && pDispStart && pDispEnd);
    
#if DBG == 1
    BOOL fPositioned = FALSE;
    IGNORE_HR( pDispStart->IsPositioned( & fPositioned ));
    Assert ( fPositioned );
    IGNORE_HR( pDispEnd->IsPositioned( & fPositioned ));
    Assert ( fPositioned );
    int cpStartNew =0;
    int cpEndNew = 0;
    int cchNewSel = 0;
    int cpStart = 0;
    int cpEnd = 0;
    int cchSel = 0;
#endif
  
    if ( ! _fSelectionVisible )
        _fSelectionVisible = TRUE;

    if ( !pISegment )
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    IFC( PrivateLookup( pISegment, &pSegment ) );
  
#if DBG == 1
    IGNORE_HR( pDispStart->PositionMarkupPointer(&mpNewStart) );
    IGNORE_HR( pDispEnd->PositionMarkupPointer(&mpNewEnd) );

    Assert(mpNewStart.Markup() == mpNewEnd.Markup());
    if (mpNewStart.Markup() != mpNewEnd.Markup())
    {
        hr = E_FAIL;
        goto Cleanup;
    }
    
    if ( IsTagEnabled( tagValidateSelRenSv))
    {
        cpStartNew = mpNewStart.GetCp();
        cpEndNew= mpNewEnd.GetCp();
        cchNewSel = abs( cpStartNew - cpEndNew );
        cpStart = pSegment->GetStart()->GetCp();
        cpEnd = pSegment->GetEnd()->GetCp();
        cchSel = abs( cpStart - cpEnd );
        TraceTag(( tagValidateSelRenSv, "Selection - Old Start:%d End:%d Size:%d New Start:%d End:%d Size:%d\n", 
                cpStart, cpEnd, cchSel, cpStartNew, cpEndNew, cchNewSel ));
        _cchLast = cchSel;
    }
#endif

    //
    // Move Old Pointers to start and end.
    //
    IFC( _pDoc->CreateMarkupPointer( & pOldStart ));
    IFC( _pDoc->CreateMarkupPointer( & pOldEnd ));
    IFC( pOldStart->MoveToPointer( pSegment->GetStart() ));
    IFC( pOldEnd->MoveToPointer( pSegment->GetEnd() ));

    Assert(pOldStart->Markup() == pOldEnd->Markup());
    
    IFC( pDispStart->PositionMarkupPointer(pSegment->GetStart()) );
    IFC( pDispEnd->PositionMarkupPointer(pSegment->GetEnd()) );

    // Set the new markup
    pSegment->SetMarkup( pSegment->GetStart()->Markup() );
    
    //
    // Copy Gravity on pointers.
    //
    IFC( pDispStart->GetPointerGravity ( & eGravity));
    IFC( pSegment->GetStart()->SetGravity( eGravity ));
    IFC( pDispEnd->GetPointerGravity ( & eGravity));
    IFC( pSegment->GetEnd()->SetGravity( eGravity ));

    //
    // TODO (track bug 4354) - rewrite Update Segment sometime - so it doesn't need to take
    // CMarkupPointers as parameters for the old selection boundarys (perf).
    //
    IFC( UpdateSegment( pOldStart, pOldEnd,  pSegment->GetStart(), pSegment->GetEnd() ) );
   
    _lContentsVersion = INVALIDATE_VERSION; // Invalidate CP cache.

    //
    // While processing this - we got an Invalidate call, which is invalid (as we had'nt 
    // updated our selection as yet.
    //
    if ( _fPendingInvalidate )
    {
        InvalidateSelection( TRUE );
        _fPendingInvalidate = FALSE;
    }

Cleanup:
    if ( pOldStart ) pOldStart->Release();
    if ( pOldEnd ) pOldEnd->Release();
  
    RRETURN( hr );
}    
    
//+===================================================================================
//
// Method: ClearSegments
//
// Synopsis: Empty ( remove all ) selection segments. ( ie nothing is selected )
//
//-----------------------------------------------------------------------------------

HRESULT
CSelectionRenderingServiceProvider::ClearSegments(BOOL fInvalidate /* = FALSE */)
{
    TraceTag( (tagValidateSelRenSv, "SelRen::ClearSegs" ));

    while( !IsEmpty() )
    {
        PrivateClearSegment( _pFirst, fInvalidate );
    }
    
    return S_OK;
}

HRESULT
CSelectionRenderingServiceProvider::RemoveSegment(IHighlightSegment *pISegment)
{
    return PrivateClearSegment(pISegment, TRUE);
}    

HRESULT
CSelectionRenderingServiceProvider::PrivateClearSegment(IHighlightSegment *pISegment, 
                                                        BOOL fInvalidate)
{
    CHighlightSegment   *pSegment = NULL;
    HRESULT             hr = E_INVALIDARG;

    Assert( pISegment );

    if( pISegment )
    {

        IFC( PrivateLookup( pISegment, &pSegment ) );
   
        if ( fInvalidate && _pDoc->_pInPlace )
        {
            CMarkupPointer *pStart = pSegment->GetStart();
            CMarkupPointer *pEnd = pSegment->GetEnd();

            Assert(pStart->Markup() == pEnd->Markup());
            
            if (pStart && pEnd &&
                pStart->Markup() == pEnd->Markup())
            {
                int wherePointer = OldCompare( pStart, pEnd );

                switch( wherePointer )
                {
                    case RIGHT:
                        InvalidateSegment( pStart, pEnd, NULL, NULL , FALSE);
                        break;

                    case LEFT:
                        InvalidateSegment( pEnd, pStart, NULL, NULL, FALSE);
                        break;
                }
            }
        }

        IFC( PrivateRemove( pSegment ) );
    }
    
Cleanup:
    RRETURN1(hr, S_FALSE);
}
   
//+===============================================================================
//
// Method: ConstructSelectionRenderCache
//
// Synopsis: This method is called by the renderer at the start of a paint,
//
//             As it is expected that the work involved in "chunkifying" the selection
//             will be expensive. So this work is done once per render.
//
//             As each flow layout is rendered, the Renderer calls GetSelectionChunksForLayout,
//             which essentially returns part of the array built on this call.
// 
// Build an array of FlowLayoutChunks. A "chunk" is a FlowLayout, and pair of 
// cps within that FlowLayout that are selected. Hence Selections that span multiple
// layouts are broken up by this routine into separate chunks for the renderer.
// 
//--------------------------------------------------------------------------------

VOID 
CSelectionRenderingServiceProvider::ConstructSelectionRenderCache()
{
    CHighlightSegment *pSegment = NULL;
    int start, end;

    //
    // We only need to recompute CP's if our version nos' are different.
    //
    Assert(_pMarkup && _pMarkup->GetMarkupContentsVersion() != _lContentsVersion);

    pSegment = _pFirst;

    while( pSegment != NULL )
    {       
        start = pSegment->GetStart()->GetCp();
        end = pSegment->GetEnd()->GetCp(); 

        //
        // Make sure we are embedded.
        //
        Assert( pSegment->GetStart()->GetEmbeddedTreePos() != NULL );
        Assert( pSegment->GetEnd()->GetEmbeddedTreePos() != NULL );

        if ( start > end )
        {
            pSegment->SetStartCP(end); 
            pSegment->SetEndCP(start);
        }
        else
        {
            pSegment->SetStartCP(start);
            pSegment->SetEndCP(end);
        }

        pSegment = pSegment->GetNext();
    }

    //
    // marka - take this call out for now - we will try to use _lContentsVersion
    // to figure out when we need to reconstruct the cache.
    //
#ifdef NEVER
    WHEN_DBG( _fInPaint = TRUE; )    
#endif    
}
//+====================================================================================
//
// Method: HideSelection
//
// Synopsis: Selection is to be hidden. Anticipated use is switching focus to another window
//
//------------------------------------------------------------------------------------

VOID
CSelectionRenderingServiceProvider::HideSelection()
{
    _fSelectionVisible = FALSE; 
    if ( _pDoc->GetView()->IsActive() )
    {
        InvalidateSelection( FALSE );
    }        
}

//+====================================================================================
//
// Method: ShowSelection
//
// Synopsis: Selection is to be shown. Anticipated use is gaining focus from another window
//
//------------------------------------------------------------------------------------
VOID
CSelectionRenderingServiceProvider::ShowSelection()
{
    _fSelectionVisible = TRUE;

    InvalidateSelection( TRUE );            
}

VOID
CSelectionRenderingServiceProvider::OnRenderStyleChange( CNotification * pnf )
{
    const int LEFT = 1;   
    const int RIGHT = -1;
    const int SAME = 0;
    IHTMLRenderStyle *pIRenderStyle=NULL;
    CHighlightSegment *pSegment = GetFirst();
    int wherePointer;
    IUnknown* pUnkRenderStyle = NULL;
    IUnknown* pUnk = NULL;
    HRESULT hr;

    IFC( ((IHTMLRenderStyle*) pnf->DataAsPtr())->QueryInterface( IID_IUnknown, ( void**) & pUnkRenderStyle ));
    
    for( ; pSegment; pSegment = pSegment->GetNext() )
    {
        wherePointer = SAME;
        pSegment->GetType(&pIRenderStyle);
        IFC( pIRenderStyle->QueryInterface( IID_IUnknown, ( void**) & pUnk ));
        
        if( pUnk == pUnkRenderStyle )
        {
            wherePointer = OldCompare( pSegment->GetStart(), pSegment->GetEnd() );
            switch( wherePointer )
            {
            case RIGHT:
                InvalidateSegment( 
                                   pSegment->GetStart(), pSegment->GetEnd(),
                                   pSegment->GetStart(), pSegment->GetEnd(), TRUE );
                break;

            case LEFT:
                InvalidateSegment( 
                                   pSegment->GetEnd(), pSegment->GetStart(),
                                   pSegment->GetEnd(), pSegment->GetStart(), TRUE );
                break;
            }

        }
        ClearInterface(&pUnk );
        ClearInterface(&pIRenderStyle);
    }
Cleanup:    
    ReleaseInterface( pUnkRenderStyle );
    ReleaseInterface( pUnk );
    ReleaseInterface( pIRenderStyle );    
}

//+====================================================================================
//
// Method: InvalidateSelection
//
// Synopsis: Invalidate the Selection
//
//------------------------------------------------------------------------------------

VOID
CSelectionRenderingServiceProvider::InvalidateSelection( BOOL fSelectionOn )
{
    CHighlightSegment *pSegment = NULL;
    int wherePointer = SAME;

    if ( _fInUpdateSegment )
    {
        _fPendingInvalidate = TRUE;
        return;
    }        

    pSegment = _pFirst;
    
    while( pSegment != NULL )
    {
        Assert(pSegment->GetStart()->Markup() == pSegment->GetEnd()->Markup());
        wherePointer = OldCompare( pSegment->GetStart(), pSegment->GetEnd() );

        switch( wherePointer )
        {
            case RIGHT:
                //
                // We really want to emulate PrivateClearSegment() here.  When we 
                // are clearing seleciton, the arguements to InvalidateSegment
                // are pretty important.  We need to set pNewStart and pNewEnd to NULL
                //
                InvalidateSegment(  pSegment->GetStart(), pSegment->GetEnd(),
                                    fSelectionOn ? pSegment->GetStart() : NULL,
                                    fSelectionOn ? pSegment->GetEnd() : NULL,
                                    fSelectionOn );
                break;

            case LEFT:
                InvalidateSegment(  pSegment->GetEnd(), pSegment->GetStart(),
                                    fSelectionOn ? pSegment->GetEnd() : NULL,
                                    fSelectionOn ? pSegment->GetStart() : NULL,               
                                    fSelectionOn );
                break;
        }

        pSegment = pSegment->GetNext();
    } 
}          


//+==============================================================================
// 
// Method: GetSelectionChunksForLayout
//
// Synopsis: Get the 'chunks" for a given Flow Layout, as well as the Max and Min Cp's of the chunks
//              
//            A 'chunk' is a part of a SelectionSegment, broken by FlowLayout
//
//-------------------------------------------------------------------------------
VOID
CSelectionRenderingServiceProvider::GetSelectionChunksForLayout( 
    CFlowLayout* pFlowLayout, 
    CRenderInfo *pRI,
    CDataAry<HighlightSegment> *paryHighlight, 
    int* piCpMin, 
    int * piCpMax )
{
    int cpMin = LONG_MAX;  // using min() macro on this will always give a smaller number.
    int cpMax = - 1;
    int segmentStart, segmentEnd ;    
    long cpFlowStart = pFlowLayout->GetContentFirstCp();
    long cpFlowEnd = pFlowLayout->GetContentLastCp();
    long cp;
    int chunkStart = -1;
    int chunkEnd = -1;
    int ili;
    HighlightSegment *pNewSegment;
    const int iInitSizeMax = 2000;
    RECT rcView;
    enum SELEDGE
    {
        SE_INSIDE, SE_OUTSIDE
    };
    SELEDGE ssSelStart;
    SELEDGE ssSelEnd;   
    const INT iIntersectWithViewThreshold = 30; // TODO: tune this number
    const CDisplay *pdp = pRI->_pdp;
    int iliViewStart = pRI->_iliStart;
    long cpViewStart = pRI->_cpStart;
    
    Assert( paryHighlight->Size() == 0 );

    CHighlightSegment *pSegment = NULL;

    if( !IsEmpty() && _fSelectionVisible && !pFlowLayout->_fTextSelected )
    {
        Assert(_pMarkup);
        if ( _pMarkup->GetMarkupContentsVersion() != _lContentsVersion  )
        {
            ConstructSelectionRenderCache();
            _lContentsVersion = _pMarkup->GetMarkupContentsVersion();
        }
        
        paryHighlight->EnsureSize(min(iInitSizeMax, _nSize));

        // Only intersect with the view if there are enough segments to make the call to 
        // LineFromPos worthwhile
        //
        
        if( _nSize  > iIntersectWithViewThreshold )
        {
            //
            // Intersect cpFlowStart view start
            //

            rcView = pRI->_pDI->_rcClip;

            if (cpViewStart < 0 || iliViewStart < 0)
            {
                iliViewStart = pdp->LineFromPos(rcView, NULL, &cpViewStart, 0, -1, -1);
            }

            cpFlowStart = max(cpViewStart, cpFlowStart);

            //
            // Intersect cpFlowEnd view end
            //
            
            // Because rcView.top might be positioned in the middle of the line
            // we need to add the offset from the begining of the line to the rcView.top.
            Assert(iliViewStart >= 0);
            CLineCore * pliViewStart = pdp->Elem(iliViewStart);
            CLineOtherInfo * ploiViewStart = pliViewStart->oi();

            rcView.bottom -= pliViewStart->GetYTop(ploiViewStart);
            rcView.top = 0;

            ili = pdp->LineFromPos(rcView, NULL, &cp, CDisplay::LFP_INTERSECTBOTTOM, iliViewStart, -1);

            cp += pdp->Elem(ili)->_cch;
        
            cpFlowEnd = min(cp, cpFlowEnd);        
        }
        else if (cpViewStart >= 0)
        {
            // If we have cpViewStart passed, we should intersect with cpFlowStart
            cpFlowStart = max(cpViewStart, cpFlowStart);
        }

        //
        // Create segments
        //
        pSegment = _pFirst;

        while( pSegment != NULL )
        {
            segmentStart = pSegment->GetStartCP();
            segmentEnd = pSegment->GetEndCP(); 

            if( !( (segmentEnd <= cpFlowStart) || (cpFlowEnd <= segmentStart)) )
            {                
                ssSelStart = segmentStart  <= cpFlowStart  ? SE_OUTSIDE : SE_INSIDE;
                ssSelEnd  = segmentEnd >= cpFlowEnd ? SE_OUTSIDE : SE_INSIDE;

                switch (ssSelStart)
                {
                case SE_OUTSIDE:
                {
                    switch (ssSelEnd)
                    {
                    case SE_OUTSIDE:
                        //
                        // Selection completely encloses layout
                        //
                        chunkStart = cpFlowStart;
                        chunkEnd = cpFlowEnd;
                        break;
                    
                    case SE_INSIDE:
                        //
                        // Overlap with selection ending inside
                        //
                        chunkStart = cpFlowStart;
                        chunkEnd = segmentEnd ;                 
                        break;
                    }
                    break;
                }
                case SE_INSIDE:
                {
                    switch( ssSelEnd )
                    {
                    case SE_OUTSIDE:
                        //
                        // Overlap with selection ending outside
                        //
                        chunkStart = segmentStart;
                        chunkEnd = cpFlowEnd;
                        break;
                    
                    case SE_INSIDE:
                        //
                        // Layout completely encloses selection
                        //
                        chunkStart = segmentStart;
                        chunkEnd = segmentEnd  ;                 
                        break;
                    }
                    break;
                }
                }
                if (( chunkStart != -1 ) && ( chunkEnd != -1))
                {
                    //
                    // Insertion Sort on The Array we've been given.
                    //
                    pNewSegment = paryHighlight->Append();

                    pNewSegment->_cpStart = chunkStart;
                    pNewSegment->_cpEnd = chunkEnd;
                    pNewSegment->_pRenderStyle = pSegment->GetType();
                                        
                    cpMin = min ( chunkStart, cpMin );
                    cpMax = max ( chunkEnd, cpMax );
                    
                    chunkStart = -1;
                    chunkEnd = -1;
                }
            }

            pSegment = pSegment->GetNext();
        }
    }
    if ( piCpMin )
        *piCpMin = cpMin;
    if ( piCpMax )
        *piCpMax = cpMax;
}

//+-------------------------------------------------------------------------
//
//  Method:     CSelectionRenderingServiceProvider::PrivateAdd
//
//  Synopsis:   Adds a segment to the linked list
//
//  Arguments:  pSegment = Segment to add
//
//  Returns:    HRESULT indicating success.
//
//--------------------------------------------------------------------------
HRESULT 
CSelectionRenderingServiceProvider::PrivateAdd( CHighlightSegment *pSegment )
{
    Assert( pSegment );
    Assert( pSegment->GetStart() && pSegment->GetEnd() );
    Assert( pSegment->GetStart()->Markup() == pSegment->GetEnd()->Markup() );

    if( IsEmpty() )
    {
        // Handle the case when this is the
        // first element
        _pFirst = pSegment;
        _pLast = pSegment;
        _pFirst->SetNext(NULL);
        _pFirst->SetPrev(NULL);
    }
    else
    {
        // Append this element
        pSegment->SetNext(NULL);
        pSegment->SetPrev(_pLast);
        _pLast->SetNext(pSegment);
        _pLast = pSegment;   
    }

    _nSize++;

    RRETURN(S_OK);
}

//+-------------------------------------------------------------------------
//
//  Method:     CSelectionRenderingServiceProvider::PrivateLookup
//
//  Synopsis:   Given an ISegment, this function will find the underlying
//              CSegment.
//
//  Arguments:  pISegment = ISegment to retreive CHighlightSegment for
//              ppSegment = Returned CHighlightSegment pointer
//
//  Returns:    HRESULT indicating success.
//
//--------------------------------------------------------------------------
HRESULT 
CSelectionRenderingServiceProvider::PrivateLookup( IHighlightSegment *pISegment, CHighlightSegment **ppSegment )
{  
    HRESULT hr = S_OK;
    
    Assert( pISegment && ppSegment );

    // Query for the CSegment
    IFC( pISegment->QueryInterface(CLSID_CHighlightSegment, (void **)ppSegment));

Cleanup:
    RRETURN(hr);
}

//+-------------------------------------------------------------------------
//
//  Method:     CSelectionRenderingServiceProvider::PrivateRemove
//
//  Synopsis:   Removes a CHighlightSegment from the list
//
//  Arguments:  pSegment = CHighlightSegment to remove
//
//  Returns:    HRESULT indicating success.
//
//--------------------------------------------------------------------------
HRESULT 
CSelectionRenderingServiceProvider::PrivateRemove( CHighlightSegment *pSegment )
{  
    CHighlightSegment    *pNext = NULL;
    CHighlightSegment    *pPrev = NULL;

    pPrev = pSegment->GetPrev();
    pNext = pSegment->GetNext();

    Assert( pSegment );
    Assert( pSegment->GetStart()->Markup() == pSegment->GetEnd()->Markup() );

    // Item certainly isn't in our list, and it looks like it
    // should be in our list, tell our client
    if( ( (_pFirst == _pLast) && (pSegment != _pFirst) ) || 
        ( (_pFirst != _pLast) && (pPrev == NULL) && (pNext == NULL) ) )
    {
        return S_FALSE;
    }

    if( _pFirst == _pLast )
    {
        _pFirst = NULL;
        _pLast = NULL;
    }
    else if( pSegment == _pFirst )
    {
        // Removing first element
        _pFirst = pSegment->GetNext();
        _pFirst->SetPrev(NULL);
    }
    else if( pSegment == _pLast )
    {
        // Removing last element
        _pLast = pSegment->GetPrev();
        _pLast->SetNext(NULL);
    }
    else
    {
        // Should be somewhere in the middle of the list
        Assert( pSegment->GetNext() );
        Assert( pSegment->GetPrev() );

        pPrev->SetNext(pNext);
        pNext->SetPrev(pPrev);
    }

    pSegment->SetNext(NULL);
    pSegment->SetPrev(NULL);
    
    // Clean up the CHighlightSegment object
    ReleaseInterface(pSegment);

    _nSize--;
    
    RRETURN(S_OK);
}

//-----------------------------------------------------------------------------
//
//  Function:   CHighlightSegment::CHighlightSegment
//
//  Synopsis:   Constructor
//
//-----------------------------------------------------------------------------
CHighlightSegment::CHighlightSegment()
{
    _pIRenderStyle = NULL;
    _ulRefs = 1;
    _fInitialized = FALSE;
}

//+-------------------------------------------------------------------------
//
//  Method:     CHighlightSegment::~CHighlightSegment
//
//  Synopsis:   Destructor
//
//--------------------------------------------------------------------------
CHighlightSegment::~CHighlightSegment(void)
{
    ReleaseInterface(_pIRenderStyle );

    _pMarkup->Release();
    
    //
    // Unposition the pointers
    //
    _pStart->Unposition();
    _pEnd->Unposition();

    //
    // Release our ref
    //
    ReleaseInterface( _pStart );
    ReleaseInterface( _pEnd );
      
#if DBG == 1
    // Verify that no other elements in the list are 
    // referencing this object
    if( GetPrev() )
        Assert( GetPrev()->GetNext() != this );

    if( GetNext() )
        Assert( GetNext()->GetPrev() != this );
#endif
}

//+-------------------------------------------------------------------------
//
//  Method:     CHighlightSegment::Init
//
//  Synopsis:   Initializes a highlight segment
//
//  Arguments:  pStart = Starting position of segment
//              pEnd = Ending position of segment
//              pRenderStyle = Style highlight segment
//
//  Returns:    HRESULT indicating success
//
//--------------------------------------------------------------------------
HRESULT
CHighlightSegment::Init(CMarkupPointer *pStart, 
                        CMarkupPointer *pEnd,
                        IHTMLRenderStyle *pIRenderStyle )
{
    Assert( pStart && pEnd );
    Assert( pStart->Markup() == pEnd->Markup() );

    _pStart = pStart;
    _pStart->AddRef();

    _pEnd = pEnd;
    _pEnd->AddRef();

    ReplaceInterface( &_pIRenderStyle, pIRenderStyle );

    //
    // Add-ref the markup (we need to guarantee it will be around to destroy us)
    //
    _pMarkup = _pStart->Markup();
    _pMarkup->AddRef();
    
    _fInitialized = TRUE;
    
    RRETURN(S_OK);
}


//+-------------------------------------------------------------------------
//
//  Method:     CHighlightSegment::SetType
//
//  Synopsis:   Sets the highlight type of selection, without adjusting 
//              the pointers
//
//  Arguments:  eType = New highlight type
//
//  Returns:    HRESULT indicating success
//
//--------------------------------------------------------------------------
HRESULT
CHighlightSegment::SetType( IHTMLRenderStyle *pIRenderStyle )
{
    ReplaceInterface( & _pIRenderStyle , pIRenderStyle );
    return S_OK;
}

//+-------------------------------------------------------------------------
//
//  Method:     CHighlightSegment::GetType
//
//  Synopsis:   Retrieves the type of highlight
//              
//  Arguments:  peType = Output pointer to receive type
//
//  Returns:    HRESULT indicating success
//
//--------------------------------------------------------------------------
HRESULT
CHighlightSegment::GetType( IHTMLRenderStyle **ppIRenderStyle )
{
    Assert( ppIRenderStyle );

    *ppIRenderStyle = _pIRenderStyle;
    _pIRenderStyle->AddRef();

    return S_OK;
}

CRenderStyle *
CHighlightSegment::GetType(void)
{ 
    CRenderStyle *pRenderStyle = NULL;
    _pIRenderStyle->QueryInterface( CLSID_HTMLRenderStyle, (void **)&pRenderStyle);
    return pRenderStyle; 
}

void
CHighlightSegment::SetMarkup(CMarkup *pMarkup)
{
    Assert( pMarkup );

    _pMarkup->Release();

    _pMarkup = pMarkup;
    _pMarkup->AddRef();
}

//+-------------------------------------------------------------------------
//
//  Method:     CHighlightSegment::GetPointers   
//
//  Synopsis:   Sets pIStart and pIEnd to the beginning and end of the
//              current segment, respectively
//
//  Arguments:  pIStart = Pointer to move to the start
//              pIEnd = Pointer to move to the end
//
//  Returns:    HRESULT indicating success
//
//--------------------------------------------------------------------------
HRESULT
CHighlightSegment::GetPointers( IMarkupPointer *pIStart,
                                IMarkupPointer*pIEnd )
{
    HRESULT hr = E_INVALIDARG;
    BOOL    fResult = FALSE;
    
    Assert( pIStart && pIEnd );

    if( pIStart && pIEnd )
    {       
        hr = THR( _pStart->IsLeftOfOrEqualTo( _pEnd, &fResult ) );
        if( hr )
            goto Cleanup;

        //
        // Swap pointers if they're out of order.
        //
        if( fResult == TRUE )
        {
            hr = pIStart->MoveToPointer( _pStart );
            if (!hr) hr = pIEnd->MoveToPointer( _pEnd );
        }
        else
        {
            hr = pIStart->MoveToPointer( _pEnd );
            if (!hr) hr = pIEnd->MoveToPointer( _pStart );
        }
        
        //
        // copy gravity - important for commands
        //
        if ( !hr ) hr = pIStart->SetGravity( POINTER_GRAVITY_Right );
        if ( !hr ) hr = pIEnd->SetGravity( POINTER_GRAVITY_Left );
    }        

Cleanup:
#if DBG == 1
    if( hr == S_OK )
    {
        BOOL fPositionedStart = FALSE;
        BOOL fPositionedEnd = FALSE;

        IGNORE_HR( pIStart->IsPositioned( & fPositionedStart ));
        IGNORE_HR( pIEnd->IsPositioned( & fPositionedEnd ));

        Assert( fPositionedStart && fPositionedEnd );
    }        
#endif

    RRETURN(hr);
}

//////////////////////////////////////////////////////////////////////////
//
//  IUnknown's Implementation
//
//////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CHighlightSegment::QueryInterface(
    REFIID  iid, 
    LPVOID  *ppvObj )
{
    if(!ppvObj)
        RRETURN(E_INVALIDARG);
  
    if( iid == IID_IUnknown || iid == IID_ISegment )
    {
        *ppvObj = (ISegment *)((IHighlightSegment *)this);
    }
    else if( iid == IID_IHighlightSegment )
    {
        *ppvObj = (IHighlightSegment *)this;
    }
    else if( iid == CLSID_CHighlightSegment )
    {
        *ppvObj = this;
        return S_OK;
    }   
    else
    {
        *ppvObj = NULL;
        RRETURN_NOTRACE(E_NOINTERFACE);
    }

    ((IUnknown *)(*ppvObj))->AddRef();

    return S_OK;
}

#if DBG == 1 

MtDefine(CTxtEdit_aryChunkTest_pv, Utilities , "TestSelectionRenderServices::_aryChunkTest::_pv")

void TestSelectionRenderServices( CMarkup* pMarkup , CElement* pTestElement)
{
    // NOTE - t-mbodel - Sept 10, 1999
    // We need to eventually make the notify call here a default property
    // of all of the put_ functions.  Unfortuately they are all currently
    // generated by pdl magic.
    // When this is fixed should take out the changes in formkrnl.cxx, 
    // formkrnl.hxx that make reference to TestSelectionRenderServices.

    CDocument *pDoc = pMarkup->Document();
    IHTMLRenderStyle    *pIRenderStyle = NULL;
    VARIANT             vtColorValue;
    CNotification       nf;

    VariantInit(& vtColorValue );
    V_VT( & vtColorValue ) = VT_I4;
    V_I4( & vtColorValue ) = 0x00ff00;

    pDoc->createRenderStyle( NULL, &pIRenderStyle );
    pIRenderStyle->put_textBackgroundColor(vtColorValue);
    VariantClear(& vtColorValue );
    
    pIRenderStyle->put_defaultTextSelection(SysAllocString(_T("false")));
    nf.MarkupRenderStyle( 0, 0, pIRenderStyle, 0);
    pMarkup->Notify(&nf);

    pMarkup->DumpTree();

    ReleaseInterface( pIRenderStyle );
   //
    // NOTE - this is just a test. Note that this WILL LEAK MEMORY.
    //
#ifdef NEVER
    CDoc* pDoc = ped->Doc();
    CMarkupPointer* pStart = new CMarkupPointer( pDoc );
    CMarkupPointer* pEnd = new CMarkupPointer( pDoc );
    int firstSelCp, lastSelCp, firstCp, firstFlow, lastFlow;
    IMarkupPointer* pIStart = NULL ;
    IMarkupPointer* pIEnd = NULL ;
    IHTMLElement* pElement = NULL;
    IHTMLElement* pNewElement = NULL;
    IHTMLElement* pNewElement2 = NULL;
    IMarkupServices* pTreeServices = NULL;
    LONG pch = 0;
    
    IHighlightRenderingServices* pIHighlightRenderSvcs = NULL;
    int iSelectionIndex = -1;

    THR(pTestElement->QueryInterface( IID_IHTMLElement, ( void**) & pElement ));
    THR(pStart->QueryInterface( IID_IMarkupPointer, (void * *) & pIStart ) );
    THR( pIStart->SetGravity( POINTER_GRAVITY_Left ));
    THR(pEnd->QueryInterface( IID_IMarkupPointer, (void * *) & pIEnd ) );
//
// Test Select All
//
    /*THR( pIStart->MoveAdjacentToElement( pElement, ELEM_ADJ_AfterBegin ));
    THR( pIEnd->MoveAdjacentToElement( pElement, ELEM_ADJ_BeforeEnd ));
    THR( pMarkup->QueryInterface( IID_IHighlightRenderingServices, ( void**) & pIHighlightRenderSvcs ));
    THR( pIHighlightRenderSvcs->AddSegment( pIStart, pIEnd, & iSelectionIndex ));
    */

    //
    // Test Multiple selection.
    //
    //
    // Segment 1 from 0 to 30.

    THR( pMarkup->QueryInterface( IID_IHighlightRenderingServices, ( void**) & pIHighlightRenderSvcs ));

    //
    // Test Case 1 Non-Overlapped Segments.
    //
    THR( pIStart->MoveAdjacentToElement( pElement, ELEM_ADJ_AfterBegin ));
    THR( pIEnd->MoveAdjacentToElement( pElement, ELEM_ADJ_AfterBegin ));
    pch = 9;
    firstCp = pStart->TreePos()->GetCp(FALSE);
    BSTR testString = SysAllocString(_T("                "));
    THR( pIStart->Right(TRUE, NULL, NULL, &pch, testString ));
   
    firstSelCp = pStart->TreePos()->GetCp(FALSE);
    
    pch = 19;
    THR( pIEnd->Right(TRUE, NULL, NULL, &pch, testString ));
    lastSelCp = pEnd->TreePos()->GetCp( FALSE);
    THR( pIHighlightRenderSvcs->AddSegment( pIStart, pIEnd, & iSelectionIndex ));

    CFlowLayout *pFLayout = pTestElement->GetFlowLayout();
    firstFlow = pFLayout->GetFirstCp();
    lastFlow = pFLayout->GetLastCp();
/*
    THR( pIStart->MoveAdjacentToElement( pElement, ELEM_ADJ_AfterBegin ));
    THR( pIEnd->MoveAdjacentToElement( pElement, ELEM_ADJ_AfterBegin ));
    pch = 32;
    THR( pIStart->Right(TRUE, NULL, NULL, &pch, NULL ));
    pch = 41;
    THR( pIEnd->Right(TRUE, NULL, NULL, &pch, NULL ));
    THR( pIHighlightRenderSvcs->AddSegment( pIStart, pIEnd, & iSelectionIndex ));
*/
    //
    // TestCaseII Overlapped Segments.
    //
  /*  THR( pIStart->MoveAdjacentToElement( pElement, ELEM_ADJ_AfterBegin ));
    THR( pIEnd->MoveAdjacentToElement( pElement, ELEM_ADJ_AfterBegin ));
    pch = 29;
    THR( pIStart->Right(TRUE, NULL, NULL, &pch, NULL ));
    pch = 31;
    THR( pIEnd->Right(TRUE, NULL, NULL, &pch, NULL ));
    THR( pMarkup->QueryInterface( IID_IHighlightRenderingServices, ( void**) & pIHighlightRenderSvcs ));
    THR( pIHighlightRenderSvcs->AddSegment( pIStart, pIEnd, & iSelectionIndex ));*/

    //Segment 2 10 to 20
/*     pch = 10;
    THR( pIStart->Right( TRUE, NULL, NULL, &pch, NULL ));
    THR( pIEnd->Left( TRUE, NULL, NULL, &pch, NULL ));
    THR( pIHighlightRenderSvcs->AddSegment( pIStart, pIEnd, & iSelectionIndex ));

    // Segment 3 110 to 120
    pch = 100;
    THR( pIStart->Right( TRUE, NULL, NULL, &pch, NULL ));
    THR( pIEnd->Right( TRUE, NULL, NULL, &pch, NULL ));
    THR( pIHighlightRenderSvcs->AddSegment( pIStart, pIEnd, & iSelectionIndex )); */
/*    THR( pDoc->QueryInterface( IID_IHTMLTreeServices, ( void**) & pTreeServices ));
    THR( pTreeServices->CreateElement( TAGID_INPUT, NULL, & pNewElement ));
    THR( pTreeServices->InsertElement( pNewElement, pIStart, pIStart ));
    THR( pTreeServices->CreateElement( TAGID_INPUT, NULL, &pNewElement2 ));
    THR( pTreeServices->InsertElement( pNewElement2, pIEnd, pIEnd ));*/


    //THR( pIHighlightRenderSvcs->AddElementSegment( pElement, &iSelectionIndex  ));

 /*   pMarkup->ConstructSelectionRenderCache();
    CStackDataAry<int, 10> aryChunkCp(Mt( CTxtEdit_aryChunkTest_pv ) );
    CStackDataAry<int, 10> aryChunkCCh(Mt( CTxtEdit_aryChunkTest_pv ) );
    int cpMax = 0;
    int cpMin = 0;

    pMarkup->GetSelectionChunksForLayout( pMarkup->Root()->GetFlowLayout(), &aryChunkCp, &aryChunkCCh, &cpMin, &cpMax );
    aryChunkCp.DeleteAll();
    aryChunkCCh.DeleteAll();
    CElement* pNewElementClass = NULL;
    THR( pNewElement->QueryInterface( CLSID_CElement,  ( void**) & pNewElementClass ));

    CFlowLayout* pNewLayout = pNewElementClass->GetFlowLayout();
    pMarkup->GetSelectionChunksForLayout( pNewLayout, &aryChunkCp, &aryChunkCCh, &cpMin,  &cpMax );
    pMarkup->InvalidateSelectionRenderCache();

    pMarkup->InvalidateSelectionRenderCache();*/

    ReleaseInterface( pIStart );
    ReleaseInterface( pIEnd );
    ReleaseInterface( pElement );
    ReleaseInterface( pNewElement );
    ReleaseInterface( pNewElement2 );
    ReleaseInterface( pIHighlightRenderSvcs );

    pStart->Release();
    pEnd->Release();

#endif // NEVER
}

void
CSelectionRenderingServiceProvider::DumpSegments()
{
    CHighlightSegment *pSegment = NULL;
    int i = 0;
    
    if( !IsEmpty() )
    {
        pSegment = _pFirst;

        while( pSegment != NULL )
        {
            char buf[256];

            wsprintfA(buf, "%3d : cp=(%d,%d) sn=(%d,%d) type=%d\r\n",
                      i++,
                      pSegment->GetStartCP(),
                      pSegment->GetEndCP(),
                      pSegment->GetStart()->SN(),
                      pSegment->GetEnd()->SN(),
                      pSegment->GetType() );

            OutputDebugStringA( buf );
        }
    }
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\text\text.cxx ===
/*
 *  @doc    INTERNAL
 *
 *  @module TEXT.C -- CTxtPtr implementation |
 *
 *  Authors: <nl>
 *      Original RichEdit code: David R. Fulmer <nl>
 *      Christian Fortini <nl>
 *      Murray Sargent <nl>
 *
 *  History: <nl>
 *      6/25/95     alexgo  cleanup and reorganization (use run pointers now)
 *
 *  @todo
 *      On deactivating, collapse buffer gap.  If no text, _prgRun should be
 *      set to point at a global null array.
 *
 *  Copyright (c) 1995-1996, Microsoft Corporation. All rights reserved.
 */

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X__TEXT_H_
#define X__TEXT_H_
#include "_text.h"
#endif

#ifndef X_WCHDEFS_H_
#define X_WCHDEFS_H_
#include "wchdefs.h"
#endif

#ifndef X_TXTDEFS_H_
#define X_TXTDEFS_H_
#include "txtdefs.h"
#endif

#ifndef X_INTL_HXX_
#define X_INTL_HXX_
#include <intl.hxx>
#endif

#ifndef X_FLOWLYT_HXX_
#define X_FLOWLYT_HXX_
#include "flowlyt.hxx"
#endif

#ifndef X_TREEPOS_H_
#define X_TREEPOS_H_
#include "treepos.hxx"
#endif

#ifndef X_UNIWBK_H_
#define X_UNIWBK_H_
#include "uniwbk.h"
#endif

#ifndef X_VRSSCAN_H_
#define X_VRSSCAN_H_
#include "vrsscan.h"
#endif

MtDefine(CTxtPtr, Tree, "CTxtPtr")
MtDefine(CTxtPtrFindThaiTypeWordBreak_aryNodePos_pv, Locals, "CTxtPtr::FindThaiTypeWordBreak::aryNodePos::_pv")
MtDefine(CTxtPtrMoveCluster_aryNodePos_pv, Locals, "CTxtPtr::MoveCluster::aryNodePos::_pv")
MtDefine(CTxtPtrItemizeAndBreakRun_aryItems_pv, Locals, "CTxtPtr::ItemizeAndBreakRun::aryItems::_pv")

extern CGlobalCriticalSection g_csJitting;
extern BYTE g_bUSPJitState;

// NB (cthrash) Our partners in Korea have requested that ideographs be
// selected differently in Korean mode.  Turn this debug tag on to force
// Trident into Korean seleciton mode.

DeclareTag( tagKoreanSelection, "TextSelection", "Korean Selection Mode.");

DeclareTag( tagOneCharTextInsert, "TextInsert", "Insert text one character at a time");

DeclareTag( tagUrlDetection, "UrlDetection", "trace Url Auto Detection");

// internal functions
// Text Block management
void TxDivideInsertion(DWORD cch, DWORD ichBlock, DWORD cchAfter,
            DWORD *pcchFirst, DWORD *pcchLast);


//
// Node classifications.
//
enum NODE_CLASS
{
    NODECLASS_NONE = 0,
    NODECLASS_SEPARATOR,
    NODECLASS_NOSCOPE,
    NODECLASS_LINEBREAK,
    NODECLASS_BLOCKBREAK,
    NODECLASS_SITEBREAK,
};

NODE_CLASS
ClassifyNodePos( CTreePos *ptp, BOOL * pfBegin )
{
    CTreeNode   * pNode;
    CFlowLayout * pFL;
    CElement    * pElement;
    ELEMENT_TAG   etag;
    NODE_CLASS    ncClass = NODECLASS_NONE;

    Assert( ptp->IsNode() );

    if( ptp->IsEdgeScope() )
    {
        pNode = ptp->Branch();
        pFL = pNode->GetFlowLayout();
        pElement = pNode->Element();
        etag = (ELEMENT_TAG) pElement->_etag;

        if( pFL && pFL->IsElementBlockInContext( pElement ) )
        {
            if(    etag == ETAG_TABLE
                || etag == ETAG_TEXTAREA
#ifdef  NEVER
                || etag == ETAG_HTMLAREA
#endif
              )
            {
                ncClass = NODECLASS_SITEBREAK;
            }
            else if(    etag == ETAG_TD
                     || etag == ETAG_TH
                     || etag == ETAG_TC )
            {
                ncClass = NODECLASS_SITEBREAK;
            }
            else
            {
                ncClass = NODECLASS_BLOCKBREAK;
            }
        }
        else if (pElement->IsNoScope())
        {
            if( etag == ETAG_BR )
            {
                ncClass = NODECLASS_LINEBREAK;
            }
            else if (pNode->ShouldHaveLayout())
            {
                ncClass = NODECLASS_NOSCOPE;
            }
        }
        else if ( etag == ETAG_RT || etag == ETAG_RP )
        {
            ncClass = NODECLASS_SEPARATOR;
        }

        if( pfBegin )
        {
            *pfBegin = ptp->IsBeginNode();

            // Table cell boundaries are sort of reverse no-scopes.
            if( etag == ETAG_TD || etag == ETAG_TH || etag == ETAG_TC )
                *pfBegin = !*pfBegin;
        }

    }

    return ncClass;
}


/*
 * Classify
 *
 * Synopsis: Classifies the node correpsonding to the character just
 * after _cp.
 *
 * Returns:
 *  NODECLASS_NONE: "Uninteresting" node, such as <B>s, <I>s, etc.
 *  NODECLASS_SEPARATOR: Words separation, such as <RT>s
 *  NODECLASS_NOSCOPE: Nodes with no scope, such as <IMG>s
 *  NODECLASS_LINEBREAK: Line breaks, such as <BR>s
 *  NODECLASS_BLOCKBREAK: Nodes that cause breaks, such as <P>s
 *  NODECLASS_SITEBREAK: Things like <TABLE>s, <TEXTAREA>s
 */

static NODE_CLASS
Classify( CTxtPtr * ptp, BOOL * pfBegin )
{
    CTreePos * ptpScan;

    Assert( ptp->GetChar() == WCH_NODE );

    ptpScan = ptp->_pMarkup->TreePosAtCp( ptp->GetCp(), NULL );
    while( ptpScan->IsText() || ptpScan->IsPointer() )
    {
        Assert( ptpScan->IsPointer() || ptpScan->Cch() == 0 );
        ptpScan = ptpScan->NextTreePos();
    }

    Assert( ptpScan->IsNode() );

    return ClassifyNodePos( ptpScan, pfBegin );
}

/*
 *  IsWhiteSpace(CTxtPtr *)
 *
 *  @func
 *      Used to determine if ch is an EOP char (see IsEOP() for definition),
 *      TAB or blank. This function is used in identifying sentence start
 *      and end.
 *
 *  @devnote
 *      It is very important that ch be unsigned, since to determine if ch is
 *      in a range (from TAB (= 9) to CR (= 13), we need an unsigned compare.
 *      In this way values below range get mapped into very large unsigned
 *      values that have their sign bit set.
 */
BOOL IsWhiteSpace(CTxtPtr *ptp)
{
    TCHAR ch = ptp->GetChar();

    return (    ch == L' '
             || InRange( ch, TAB, CR )
             || (ch | 1) == PS
             || (    ch == WCH_NODE
                  && Classify( ptp, NULL ) ) );
}

/*
 *  IsSentenceTerminator(ch)
 *
 *  @func
 *      Used to determine if ch is a standard sentence terminator character,
 *      namely, '?', '.', or '!'
 */
BOOL IsSentenceTerminator(TCHAR ch)
{
    return ch <= '?' && (ch == '?' || ch == '.' || ch == '!');
}


// ===========================  Invariant stuff  ==================================================

#define DEBUG_CLASSNAME CTxtPtr
#include "_invar.h"

// ===============================  CTxtPtr  ======================================================

/*
 *  CTxtPtr::CTxtPtr(ped, cp)
 *
 *  @mfunc  constructor
 */
CTxtPtr::CTxtPtr (
    CMarkup *pMarkup,   //@parm Ptr to CMarkup instance
    DWORD cp)           //@parm cp to set the pointer to
{
    Reinit(pMarkup, cp);
}

/*
 *  CTxtPtr::CTxtPtr(&tp)
 *
 *  @mfunc  Copy Constructor
 */
CTxtPtr::CTxtPtr (
    const CTxtPtr &tp)
{
    // copy all the values over
    *this = tp;
}

/*
 *  CTxtPtr::Reinit(ped, cp)
 *
 *  @mfunc  reinitializes txt ptr just like constructor
 */
void CTxtPtr::Reinit (
    CMarkup *pMarkup,   //@parm Ptr to CMarkup instance
    DWORD cp)           //@parm cp to set the pointer to
{
    _pMarkup = pMarkup;
    _cp = 0;
    SetRunArray((CRunArray *) &pMarkup->_TxtArray);
    _cp = BindToCp(cp);
}

/*
 *  CTxtPtr::GetChar()
 *
 *  @mfunc
 *      Return character at this text pointer, NULL if text pointer is at
 *      end of text
 *
 *  @rdesc
 *      Character at this text ptr
 */
TCHAR CTxtPtr::GetChar()
{
    LONG         cchValid;
    const TCHAR *pch = GetPch(cchValid);

    return ( pch && cchValid ) ? *pch : 0;
}

/*
 *  CTxtPtr::GetPrevChar()
 *
 *  @mfunc
 *      Return character just before this text pointer, NULL if text pointer
 *      beginning of text
 *
 *  @rdesc
 *      Character just before this text ptr
 */
TCHAR CTxtPtr::GetPrevChar()
{
    long cchValid;
    const TCHAR * pch = GetPchReverse( cchValid );

    return (pch && cchValid) ? *(pch - 1) : 0;
}

/*
 *  CTxtPtr::GetPch(&cchValid)
 *
 *  @mfunc
 *      return a character pointer to the text at this text pointer
 *
 *  @rdesc
 *      a pointer to an array of characters.  May be NULL.  If non-null,
 *      then cchValid is guaranteed to be at least 1
 */
const TCHAR * CTxtPtr::GetPch(
    long &  cchValid)       //@parm Count of characters for which the
{
    _TEST_INVARIANT_

    DWORD       ich = GetIch();
    TCHAR *     pchBase;
    CTxtBlk *   ptb = _prgRun ? GetCurrRun() : NULL;

    if( !ptb )
    {
        cchValid = 0;
        return NULL;
    }

    // if we're at the edge of a run, grab the next run or
    // stay at the current run.

    if( GetIch() == ptb->_cch )
    {
        if( GetIRun() < NumRuns() - 1 )
        {
            // set us to the next text block
            ptb = GetNextRun();
            ich = 0;
        }
        else
        {
            //we're at the very end of the text, just return NULL
            cchValid = 0;
            return NULL;
        }
    }

    AssertSz(CbOfCch(ich) <= ptb->_cbBlock,
        "CTxtPtr::GetPch(): _ich bigger than block");

    pchBase = ptb->_pch + ich;


    // Check to see if we need to skip over gap.  Recall that
    // the game may come anywhere in the middle of a block,
    // so if the current ich (note, no underscore, we want
    // the active ich) is beyond the gap, then recompute pchBase
    // by adding in the size of the block.
    //
    // cchValid will then be the number of characters left in
    // the text block (or _cch - ich)

    if(CbOfCch(ich) >= ptb->_ibGap)
    {
        pchBase += CchOfCb(ptb->_cbBlock) - ptb->_cch;
        cchValid = ptb->_cch - ich;
    }
    else
    {
        //we're valid until the buffer gap (or see below).
        cchValid = CchOfCb(ptb->_ibGap) - ich;
    }

    Assert(cchValid);
    return pchBase;
}

/*
 *  CTxtPtr::GetPchReverse(&cchValidReverse, *pcchValid)
 *
 *  @mfunc
 *      return a character pointer to the text at this text pointer
 *      adjusted so that there are some characters valid *behind* the
 *      pointer.
 *
 *  @rdesc
 *      a pointer to an array of characters.  May be NULL.  If non-null,
 *      then cchValidReverse is guaranteed to be at least 1
 */
const TCHAR * CTxtPtr::GetPchReverse(
    long &  cchValidReverse,        //@parm length for reverse
    long *  pcchValid)              //@parm length forward
{
    _TEST_INVARIANT_

    LONG        cchTemp;
    DWORD       ich = GetIch();
    TCHAR *     pchBase;
    CTxtBlk *   ptb = GetCurrRun();

    if( !ptb )
    {
        cchValidReverse = 0;
        return NULL;
    }

    // if we're at the edge of a run, grab the previous run or
    // stay at the current run.

    if( !GetIch() )
    {
        if( GetIRun() )
        {
            // set us to the next text block
            ptb = GetPrevRun();
            ich = ptb->_cch;
        }
        else
        {
            //we're at the very beginning of the text, just return NULL
            cchValidReverse = 0;
            return NULL;
        }
    }

    AssertSz(CbOfCch(ich) <= ptb->_cbBlock,
        "CTxtPtr::GetPchReverse(): _ich bigger than block");

    pchBase = ptb->_pch + ich;

    // Check to see if we need to skip over gap.  Recall that
    // the game may come anywhere in the middle of a block,
    // so if the current ich (note, no underscore, we want
    // the active ich) is at least one char past the gap, then recompute
    // pchBase by adding the size of the gap (so that it's after
    // the gap).  This differs from GetPch(), which works forward and
    // wants pchBase to include the gap size if ich is at the gap, let
    // alone one or more chars past it.
    //
    // Also figure out the count of valid characters.  It's
    // either the count of characters from the beginning of the
    // text block, i.e. ich, or the count of characters from the
    // end of the buffer gap.

    cchValidReverse = ich;                  // Default for ich <= gap offset
    cchTemp = ich - CchOfCb(ptb->_ibGap);   // Calculate displacement
    if(cchTemp > 0)                         // Positive: pchBase is after gap
    {
        cchValidReverse = cchTemp;
        pchBase += CchOfCb(ptb->_cbBlock) - ptb->_cch;  // Add in gap size
    }
    if ( pcchValid )                         // if client needs forward length
    {
        if ( cchTemp > 0 )
            cchTemp = ptb->_cch - ich;
        else
            cchTemp = -cchTemp;

        *pcchValid = cchTemp;
    }

    return pchBase;
}

/*
 *  CTxtPtr::BindToCp(cp)
 *
 *  @mfunc
 *      set cached _cp = cp (or nearest valid value)
 *
 *  @rdesc
 *      _cp actually set
 *
 *  @comm
 *      This method overrides CRunPtrBase::BindToCp to keep _cp up to date
 *      correctly.
 *
 *  @devnote
 *      Do *not* call this method when high performance is needed; use
 *      AdvanceCp() instead, which advances from 0 or from the cached
 *      _cp, depending on which is closer.
 */
DWORD
CTxtPtr::BindToCp ( DWORD cp )
{
    if(_prgRun)
    {
        //
        // Special case binding to the end of the string to be fast
        //
        if (NumRuns() > 0 && long(cp) == GetTextLength())
        {
            SetIRun( NumRuns() - 1 );

            SetIch( _prgRun->Elem( GetIRun() )->_cch );
            _cp = cp;
        }
        else
        {
            _cp = CRunPtrBase::BindToCp(cp);
        }
    }

    // We want to be able to use this routine to fix up things so we don't do
    // the invariant checking at entry.

    _TEST_INVARIANT_

    return _cp;
}


/*
 *  CTxtPtr::SetCp(cp)
 *
 *  @mfunc
 *      'efficiently' sets cp by advancing from current position or from 0,
 *      depending on which is closer
 *
 *  @rdesc
 *      cp actually set to
 */
DWORD CTxtPtr::SetCp(
    DWORD   cp)     //@parm char position to set to
{
    LONG    cch = (LONG)cp - (LONG)_cp;
    AdvanceCp(cch);

    return _cp;
}

/*
 *  CTxtPtr::AdvanceCp(cch)
 *
 *  @mfunc
 *      Advance cp by cch characters
 *
 *  @rdesc
 *      Actual number of characters advanced by
 *
 *  @comm
 *      We override CRunPtrBase::AdvanceCp so that the cached _cp value
 *      can be correctly updated and so that the advance can be made
 *      from the cached _cp or from 0, depending on which is closer.
 *
 *  @devnote
 *      It's also easy to bind at the end of the story. So an improved
 *      optimization would bind there if 2*(_cp + cch) > _cp + text length.
 */
LONG CTxtPtr::AdvanceCp(
    LONG cch)           // @parm count of chars to advance by
{
    if (!IsValid())
        return 0;

    const LONG  cpSave = _cp;               // Save entry _cp
    LONG        cp = cpSave + cch;          // Requested target cp (maybe < 0)

    if(2*cp < cpSave)                       // Closer to 0 than cached cp
    {
        cp = max(cp, 0L);                    // Don't undershoot
        _cp = CRunPtrBase::BindToCp(cp);
    }
    else
        _cp += CRunPtrBase::AdvanceCp(cch); //  exist

    // NB! the invariant check needs to come at the end; we may be
    // moving 'this' text pointer in order to make it valid again
    // (for the floating range mechanism).

    _TEST_INVARIANT_
    return _cp - cpSave;                    // cch this CTxtPtr moved
}

/*
 *  CTxtPtr::GetText(cch, pch)
 *
 *  @mfunc
 *      get a range of cch characters starting at this text ptr. A literal
 *      copy is made, i.e., with no CR -> CRLF and WCH_EMBEDDING -> ' '
 *      translations.  For these translations, see CTxtPtr::GetPlainText()
 *
 *  @rdesc
 *      count of characters actually copied
 *
 *  @comm
 *      Doesn't change this text ptr
 */

long
CTxtPtr::GetRawText(
    long   cch,          //@parm count of characters to get
    TCHAR *pch)         //@parm buffer to copy the text into
{
    const TCHAR *pchRead;
    long  cchValid;
    long  cchCopy = 0;
    CTxtPtr tp(*this);

    _TEST_INVARIANT_

    // simply take our clone text pointer, and read valid blocks
    // of text until we've either read all the requested text or
    // we've run out of text to read.
    while( cch )
    {
        pchRead = tp.GetPch( cchValid );

        if (!pchRead)
            break;

        cchValid = min( cchValid, cch );
        CopyMemory( pch, pchRead, cchValid * sizeof( TCHAR ) );
        pch += cchValid;
        cch -= cchValid;
        cchCopy += cchValid;
        tp.AdvanceCp( cchValid );

        _TEST_INVARIANT_ON( tp );
    }

    return cchCopy;
}

long
CTxtPtr::GetPlainTextLength ( long cch )
{
    long cchCopy = 0;
    CTxtPtr tp( * this );

    _TEST_INVARIANT_

    while ( cch > 0 )
    {
        long cchValid;
        const TCHAR * pchRead = tp.GetPch( cchValid );

        if (!pchRead || cchValid <= 0)
            break;

        cchValid = min( cchValid, cch );
        cchCopy += cchValid;
        cch -= cchValid;

        //
        // Look for synthetic break chars, and count two chars for them,
        // for we will turn them into \r\n later.
        //

        for ( long i = 0 ; i < cchValid ; i++ )
        {
            TCHAR ch = pchRead[i];

            if (ch == _T('\r'))
                cchCopy++;
            else if (ch == WCH_NODE)
                cchCopy--;
        }

        tp.AdvanceCp( cchValid );
    }

    return cchCopy;
}

/*
 *  CTxtPtr::GetPlainText(cchBuff, pch, cpMost, fTextize)
 *
 *  @mfunc
 *      Copy up to cchBuff characters or up to cpMost, whichever comes
 *      first, translating lone CRs into CRLFs.  Move this text ptr just
 *      past the last character processed.  If fTextize, copy up to but
 *      not including the first WCH_EMBEDDING char. If not fTextize,
 *      replace WCH_EMBEDDING by a blank since RichEdit 1.0 does.
 *
 *  @rdesc
 *      Count of characters copied
 *
 *  @comm
 *      An important feature is that this text ptr is moved just past the
 *      last char copied.  In this way, the caller can conveniently read
 *      out plain text in bufferfuls of up to cch chars, which is useful for
 *      stream I/O.  This routine won't copy the final CR even if cpMost
 *      is beyond it.
 */

long
CTxtPtr::GetPlainText( long cch, TCHAR * pch )
{
    const TCHAR * pchRead;
    long          cchValid;
    CTxtPtr       tp ( * this );
    TCHAR *       pchStart = pch;
    TCHAR *       pchEnd = pch + cch;

    _TEST_INVARIANT_

    // simply take our clone text pointer, and read valid blocks
    // of text until we've either read all the requested text or
    // we've run out of text to read.

    // Assume cch is the count of characters *including* extra \r\n insertions

    while ( pch < pchEnd )
    {
        pchRead = tp.GetPch( cchValid );

        if (!pchRead)
            break;

        const TCHAR * pchReadEnd = pchRead + cchValid;

        for ( ; pchRead < pchReadEnd && pch < pchEnd ; pchRead++ )
        {
            TCHAR ch = *pchRead;

            if (ch == _T('\r'))
            {
                *pch++ = _T('\r');

                Assert( pch < pchEnd );

                *pch++ = _T('\n');
            }
            else if (ch != WCH_NODE)
            {
                *pch++ = ch;
            }
        }

        if (pch < pchEnd)
        {
            tp.AdvanceCp( cchValid );

            _TEST_INVARIANT_ON( tp );
        }
    }

    return pch - pchStart;
}

/*
 *  CTxtPtr::NextChar()
 *
 *  @mfunc
 *      Increment this text ptr and return char it points at
 *
 *  @rdesc
 *      Next char
 */
TCHAR CTxtPtr::NextChar()
{
    _TEST_INVARIANT_

    AdvanceCp(1);
    return GetChar();
}

/*
 *  CTxtPtr::PrevChar()
 *
 *  @mfunc
 *      Decrement this text ptr and return char it points at
 *
 *  @rdesc
 *      Previous char
 */
TCHAR CTxtPtr::PrevChar()
{
    _TEST_INVARIANT_

    return AdvanceCp(-1) ? GetChar() : 0;
}

/*
 *  CTxtPtr::AdjustCpCRLF()
 *
 *  @mfunc
 *      Adjust the position of this text pointer to the beginning of a CRLF,
 *      CRCRLF, or UTF-16 combination if it is in the middle of such a
 *      combination
 *
 *  @rdesc
 *      Number of characters text pointer has been moved by
 *
 *  @future
 *      Adjust to beginning of sequence containing Unicode combining marks
 */
LONG CTxtPtr::AdjustCpCRLF()
{
    _TEST_INVARIANT_

    LONG     cpSave = _cp;
    TCHAR    ch     = GetChar();

//  To support UTF-16, include the following code
//  if((ch & UTF16) == UTF16_TRAIL)
//      AdvanceCp(-1);

    if(!IsASCIIEOP(ch))                         // Early out
        return 0;

    if (ch == LF && cpSave && PrevChar() != CR) // Landed on LF not preceded
    {                                           //  by CR, so go back to LF
        AdvanceCp(1);                           // Else on CR of CRLF or
    }                                           //  second CR of CRCRLF

    if(GetChar() == CR)                         // Land on a CR of CRLF or
    {                                           //  second CR of CRCRLF?
        CTxtPtr tp(*this);

        if(tp.NextChar() == LF)
        {
            tp.AdvanceCp(-2);                   // First CR of CRCRLF ?
            if(tp.GetChar() == CR)              // Yes or CRLF is at start of
                AdvanceCp(-1);                  //  story. Try to back up over
        }                                       //  CR (If at BOS, no effect)
    }
    return _cp - cpSave;
}

/*
 *  CTxtPtr::IsAtEOP()
 *
 *  @mfunc
 *      Return TRUE iff this text pointer is at an end-of-paragraph mark
 *
 *  @rdesc
 *      TRUE if at EOP
 *
 *  @devnote
 *      End of paragraph marks for RichEdit 1.0 and the MLE can be CRLF
 *      and CRCRLF.  For RichEdit 2.0, EOPs can also be CR, VT (0xb - Shift-
 *      Enter), and FF (0xc - page break).
 */
BOOL CTxtPtr::IsAtEOP()
{
    _TEST_INVARIANT_

    TCHAR ch = GetChar();
    BOOL  bRet;

    if(IsASCIIEOP(ch))                          // See if LF <= ch <= CR
    {                                           // Clone tp in case
        CTxtPtr tp(*this);                      //  AdjustCpCRLF moves
        bRet = !tp.AdjustCpCRLF();              // Return TRUE unless in
    }                                           //  middle of CRLF or CRCRLF
    else
    {
        bRet = (ch | 1) == PS;
                                                // Allow synthetic break char
                                                // End of site means end of para.
                                                // Note that text site break
                                                // characters don't denote the
                                                // end of a paragraph.
                                                // and Unicode 0x2028/9 also
    }


    return bRet;
}

/*
 * AdvanceChars
 *
 * Synopsis: Moves by the given number of "interesting" characters - in other
 * words, it skips NODECLASS_NONE node characters.
 */
static long
AdvanceChars( CTxtPtr *ptp, long cch )
{
    long iDir;
    long nMoved = 0;
    long nSkip;
    long cpLimit;

    if( cch > 0)
    {
        iDir = 1;
        cpLimit = ptp->GetTextLength() - 1;
    }
    else
    {
        iDir = -1;
        cch = -cch;
        cpLimit = 1;
    }

    for( ; long(ptp->_cp) != cpLimit && cch; cch-- )
    {
        do
        {
            nSkip = ptp->AdvanceCp( iDir );
            nMoved += nSkip;
        } while (   ptp->GetChar() == WCH_NODE
                 && Classify( ptp, NULL ) == NODECLASS_NONE
                 && nSkip
                 && long(ptp->_cp) != cpLimit );

        // If we can't move any further
        if( !nSkip )
            break;
    }

    return nMoved;
}

/*
 * CTxtPtr::MoveChar( fForward )
 *
 * Synopsis: Moves one character in the given direction, optionally limiting
 *  the search to the given cp.  If cpMost is -1, it will search to the edge
 *  of the document.  This looks strictly at TEXT.
 *
 * Returns: number of characters moved
 */
long
CTxtPtr::MoveChar( BOOL fForward )
{
    long    cpOrig  = _cp;
    long    iDir    = fForward ? 1 : -1;
    long    cch     = fForward ? GetTextLength() - 1 - _cp : _cp - 1;

    // As long as we have room left...
    if( cch-- )
    {
        AdvanceCp( iDir );

        // Move past nodes to user-level text
        while( cch-- && GetChar() == WCH_NODE )
        {
            AdvanceCp( iDir );
        }
    }

    return( _cp - cpOrig );
}


BOOL AutoUrl_IsSpecialChar(TCHAR ch)
{
    return (
        ch == _T(':')
        || ch == _T('/')
        || ch == _T('.')
        || ch == _T('\\')
        || ch == _T('@')
        || ch == _T('#')
        || ch == _T('=')
        || ch == _T('+')
        || ch == _T('&')
        || ch == _T('%')
        || ch == _T('_')
        || ch == _T('"')
        || ch == _T('?')
        || ch == _T('$')
        || ch == _T('~')
        || ch == _T('-')
        || ch == _T(',')
        || ch == _T('|')
        || ch == _T(';')   // (tomfakes) semi-colon is special too
        || ch == ((WCHAR) 0x20ac)   // The Euro.  This cast will cause a non-Unicode compile to fail
        );
}

/*
 *  CTxtPtr::FindWordBreak(action, cpMost)
 *
 *  Synopsis: Finds and moves to the word boundary as specified by action,
 *      and returns the offset from the old position to the new position.
 *
 *  WB_CLASSIFY
 *      Returns char class and word break flags of char at start position.
 *
 *  WB_ISDELIMITER
 *      Returns TRUE iff char at start position is a delimeter.
 *
 *  WB_LEFT (MOVEUNIT_PREVPROOFWORD)
 *      Finds nearest proof word beginning before start position.
 *
 *  WB_LEFTBREAK (MOVEUNIT_PREVWORDEND)
 *      Finds nearest word end before start position.
 *
 *  WB_MOVEWORDLEFT (MOVEUNIT_PREVWORDBEGIN)
 *      Finds nearest word beginning before start position.
 *      This value is used during CTRL+LEFT key processing.
 *
 *  WB_MOVEWORDRIGHT (MOVEUNIT_NEXTWORDBEGIN)
 *      Finds nearest word beginning after start position.
 *      This value is used during CTRL+RIGHT key processing.
 *
 *  WB_RIGHT (MOVEUNIT_NEXTPROOFWORD)
 *      Finds nearest proof word beginning after start position.
 *
 *  WB_RIGHTEDGE == WB_RIGHTBREAK (MOVEUNIT_NEXTWORDEND)
 *      Finds nearest word end after start position.
 *
 *
 *  NB (t-johnh): WB_MOVEURLLEFT/RIGHT are used for the autodetector to
 *      determine a range of characters that should be checked for being a
 *      URL.  This is no way implies that the given boundary is the boundary
 *      of a URL, just that should the tp be positioned in a URL, that would
 *      be the end of it.
 *
 *  WB_MOVEURLLEFT
 *      Finds previous boundary of what could be a URL
 *
 *  WB_MOVEURLRIGHT
 *      Finds next boundary of what could be a URL
 *
 *  @rdesc
 *      Character offset from start of buffer (pch) of the word break
 *
 *
 *  Note: The word navigation actions are grouped into 2 different groups
 *      which follow the same pattern:  WB_MOVEWORDRIGHT, WB_RIGHT, and
 *      WB_LEFTBREAK are group 1; WB_MOVEWORDLEFT, WB_LEFT, and WB_RIGHTBREAK
 *      are group 2.  The two steps in finding the appropriate word break
 *      are (a) Find the end of the current word, and (b) Skip whitespace to
 *      the edge of the next.
 *      The group 1 actions perform step (a) and then step (b).  The group
 *      2 actions perform step (b) and then step (a). In addition, the end-
 *      seeking actions (LEFT/RIGHTBREAK) must adjust for the fact that the
 *      tp is position just _before_ the last character in a word.
 *
 */
long CTxtPtr::FindWordBreak( int action, BOOL fAutoURL )
{
    _TEST_INVARIANT_

    CTxtPtr     tp( *this );
    TCHAR       chPrev, chNext;
    long        iDir = ( action & 1 ) ? 1 : -1;

    long        cpLast = 0;
    long        cpOrig = _cp;
    long        cch;
    BOOL        fEnd = ( action == WB_LEFTBREAK || action == WB_RIGHTBREAK );


    if( action == WB_CLASSIFY || action == WB_ISDELIMITER )
    {
        // NOTE (t-johnh): Things that were calling WB_CLASSIFY and
        // WB_ISDELIMITER were based upon the old kinsoku classification,
        // rather than the new character classes and word breaking classes.
        // Any code calling with these actions should be modified to use
        // character classes and/or word break classes.
        AssertSz( FALSE, "WB_CLASSIFY and WB_ISDELIMITER are no longer valid." );

        return 0;
    }

    // Moving left, we need to be looking at the prev char.
    if( iDir == -1 && tp._cp > 1 )
        tp.AdvanceCp( -1 );

    cch = ( iDir == 1 ) ? GetTextLength() - 1 - tp._cp : tp._cp - 1;

    //
    // Set up the tp to be prior to the first interesting character -
    //  this is our start position
    //

    while( cch && tp.GetChar() == WCH_NODE && !Classify( &tp, NULL ) )
    {
        tp.AdvanceCp( iDir );
        --cch;
    }


    // Initial state
    cpLast = tp._cp;

    if( !cch )
        goto done;

    chNext = tp.GetChar();

    // If starting at Thai-type, we need to go into FTTWB
    if(!fAutoURL && NoWhiteBetweenWords( chNext ) )
    {
        // Re-adjust for FTTWB
        if( iDir == -1 )
            tp.AdvanceCp( 1 );

        long cchOffset = tp.FindThaiTypeWordBreak( action );
        cpLast = tp._cp + cchOffset;

        goto done;
    }


    //
    // NextBegin, NextProof, PrevEnd: First step is to get out of the
    //  current word
    //

    if(    action == WB_MOVEWORDRIGHT
        || action == WB_RIGHT
        || action == WB_LEFTBREAK )
    {
        if( chNext == WCH_NODE )
        {
            chNext = _T(' ');
        }

        for( ; ; )
        {
            chPrev = chNext;

            do
            {
                tp.AdvanceCp( iDir );
                --cch;
            } while( cch && tp.GetChar() == WCH_NODE && !Classify( &tp, NULL ) );

            chNext = tp.GetChar();

            //
            // Conditions for leaving a word:
            // 1) !cch                  => ran out of characters
            // 2) chNext == WCH_NODE    => Hit an interesting node
            // 3) NoWhiteBetweenWords(chNext) and not auto URL detection => Transition to Thai type
            // 4) WordBreakBoundary     => Word boundary between chars
            // (Varies depending on direction and type of word break)
            //
            if(    !cch
                || chNext == WCH_NODE
                || (!fAutoURL && NoWhiteBetweenWords( chNext ))
                || ( action == WB_RIGHT && IsProofWordBreakBoundary( chPrev, chNext ) )
                || ( action == WB_MOVEWORDRIGHT && IsWordBreakBoundaryDefault( chPrev, chNext ) )
                || ( action == WB_LEFTBREAK && IsWordBreakBoundaryDefault( chNext, chPrev ) ) )
            {
                break;
            }
        }
    }

    //
    // All options: Skip past whitespace.  Note that for
    // Next/prev proof word, this has been done/would be done anyway
    //
    while(    cch
           && (    chNext == WCH_NODE
                || WordBreakClassFromCharClass( CharClassFromCh( chNext ) ) == wbkclsSpaceA ) )
    {
        // No-scope nodes are basically one-character words, but only
        //  on the appropriate edge.
        if( chNext == WCH_NODE )
        {
            BOOL fBegin;
            NODE_CLASS nc = Classify( &tp, &fBegin );
            if (    (   nc == NODECLASS_NOSCOPE || nc == NODECLASS_SEPARATOR )
                     && ( ( fEnd ) ? !fBegin : fBegin ) )
                break;
        }

        chPrev = chNext;

        tp.AdvanceCp( iDir );
        --cch;
        chNext = tp.GetChar();
    }

    cpLast = tp._cp;



    //
    // NextBegin, NextProof and PrevEnd: Done here, except that PrevEnd is
    //  one character too far, so account for that (but only if we actually
    //  did find some non-node, non-spacing character
    //

    if(    action == WB_MOVEWORDRIGHT
        || action == WB_RIGHT
        || action == WB_LEFTBREAK )
    {
        // If we did find text or no-scope of a previous word, then we
        // should be just past it for WB_LEFTBREAK
        if(    action == WB_LEFTBREAK
            && (    (    chNext != WCH_NODE
                      && WordBreakClassFromCharClass(
                            CharClassFromCh( chNext ) ) != wbkclsSpaceA )
                 || (    chNext == WCH_NODE
                      && (    Classify( &tp, NULL ) == NODECLASS_NOSCOPE
                           || Classify( &tp, NULL ) == NODECLASS_SEPARATOR ) ) ) )
        {
            Assert( (long)tp._cp < cpOrig );
            ++cpLast;
        }

        goto done;
    }

    if( !cch )
        goto done;



    if( chNext == WCH_NODE )
    {
        chNext = _T(' ');
    }
    else if(!fAutoURL && NoWhiteBetweenWords( chNext ) )
    {
        if(iDir == -1)
            tp.AdvanceCp(1);
        // Moving from space->Thai, we need to go into FTTWB
        long cchOffset = tp.FindThaiTypeWordBreak( action );
        cpLast = tp._cp + cchOffset;

        goto done;
    }

    //
    // NextEnd, NextProof and PrevBegin: Need to move to the next
    //  breaking boundary (see conditions for leaving a word above)
    //
    for( ; ; )
    {
        chPrev = chNext;
        cpLast = tp._cp;

        do
        {
            tp.AdvanceCp( iDir );
            --cch;
        } while( cch && tp.GetChar() == WCH_NODE && !Classify( &tp, NULL ) );

        chNext = tp.GetChar();

        // Same break conditions as above
        if(    !cch
            || chNext == WCH_NODE
            || (!fAutoURL && NoWhiteBetweenWords( chNext ))
            || ( action == WB_LEFT && IsProofWordBreakBoundary( chNext, chPrev ) )
            || ( action == WB_MOVEWORDLEFT && IsWordBreakBoundaryDefault( chNext, chPrev ) )
            || ( action == WB_RIGHTBREAK && IsWordBreakBoundaryDefault( chPrev, chNext ) ) )
        {
            if( !cch )
                cpLast = tp._cp;
            break;
        }
    }

    //
    // cpLast is now the cp just before the last character of the
    //  word.  For NextEnd, we want to be past this character.
    //
    if( action == WB_RIGHTBREAK )
    {
        Assert( (long)tp._cp > cpOrig );
        if( cch )
            ++cpLast;
    }

done:
    Assert( cpLast >= 0 && cpLast < GetTextLength() );

    SetCp( cpLast );
    return _cp - cpOrig;
}

/*
 *  CTxtPtr::FindBlockBreak
 *
 *  Synopsis: Moves to the next paragraph in the direction specified by
 *      fForward.  Paragraphs are defined by nodes classified as BlockBreaks
 *
 *  Returns: Offset to the paragraph beginning.
 *
 */
long
CTxtPtr::FindBlockBreak( BOOL fForward )
{
    long            cchOffset;
    CTreePos *      ptp     = _pMarkup->TreePosAtCp( _cp, &cchOffset );
    long            cpBound = fForward ? GetTextLength() - 1 : 1;
    long            cpOrig  = _cp;
    long            cpNew   = _cp;

    if(    ( fForward && ptp->GetCp() >= cpBound )
        || ( !fForward && ptp->GetCp() <= 1 ) )
        goto Done;

    if( fForward )
    {
        //
        // Move out of this paragraph
        //
        do
        {
            ptp = ptp->NextTreePos();
            Assert( ptp );

            // Hitting a table begin from outside, we skip the table
            if( ptp->IsNode() && ptp->IsBeginElementScope() )
            {
                CTreeNode * pNode       = ptp->Branch();
                CElement *  pElement    = pNode->Element();

                if( ClassifyNodePos( ptp, NULL ) == NODECLASS_SITEBREAK )
                {
                    // Skip to the ending treepos
                    pElement->GetTreeExtent( NULL, &ptp );
                    Assert( ptp );
                    ptp = ptp->NextTreePos();
                }
            }
        } while(    ptp->GetCp() < cpBound
                 && (   !ptp->IsNode()
                     ||  ClassifyNodePos( ptp, NULL ) < NODECLASS_BLOCKBREAK ) );

        //
        // And into the next - until we see text or noscope.
        //
        while(    ptp->GetCp() < cpBound
               && (    !ptp->IsText()
                    && !(    ptp->IsNode()
                          && (    ClassifyNodePos( ptp, NULL ) == NODECLASS_NOSCOPE
                               || ClassifyNodePos( ptp, NULL ) == NODECLASS_SEPARATOR ) ) ) )
        {
            ptp = ptp->NextTreePos();
        }

        cpNew = min(ptp->GetCp(), cpBound);
    }
    else
    {
        //
        // Move to the previous paragraph (text or noscope)
        //
        do
        {
            ptp = ptp->PreviousTreePos();
        } while(    ptp->GetCp() > 1
                 && (    !ptp->IsText()
                      && !(    ptp->IsNode()
                            && (    ClassifyNodePos( ptp, NULL ) == NODECLASS_NOSCOPE
                                 || ClassifyNodePos( ptp, NULL ) == NODECLASS_SEPARATOR ) ) ) );

        // Now, find a blockbreak to define a paragraph boundary
        while(    ptp->GetCp() > 1
               && (    !ptp->IsNode()
                    ||  ClassifyNodePos( ptp, NULL ) < NODECLASS_BLOCKBREAK ) )
        {
            ptp = ptp->PreviousTreePos();

            // Hitting a table end from outside, we skip the table
            if( ptp->IsNode() && ptp->IsEndElementScope() )
            {
                CTreeNode * pNode       = ptp->Branch();
                CElement *  pElement    = pNode->Element();

                if( ClassifyNodePos( ptp, NULL ) == NODECLASS_SITEBREAK )
                {
                    // Skip to the beginning treepos
                    pElement->GetTreeExtent( &ptp, NULL );
                    Assert( ptp );
                    ptp = ptp->PreviousTreePos();
                }
            }
        }

        // Adjust back forward to actual text-type stuff
        while(    ptp->GetCp() < cpOrig
               && (    !ptp->IsText()
                    && !(    ptp->IsNode()
                          && (    ClassifyNodePos( ptp, NULL ) == NODECLASS_NOSCOPE
                               || ClassifyNodePos( ptp, NULL ) == NODECLASS_SEPARATOR ) ) ) )
        {
            ptp = ptp->NextTreePos();
        }

        // No greater than cpOrig, and no less than cpMost
        cpNew = max(min(ptp->GetCp(), cpOrig), 1L);
    }

Done:
    SetCp( cpNew );
    return _cp - cpOrig;
}


//
// AutoUrl stuff
//

#define AUTOURL_WILDCARD_CHAR   _T('\b')

//+---------------------------------------------------------------------------

// used by UrlAutodetector and associated helper functions
enum {
    AUTOURL_TEXT_PREFIX,
    AUTOURL_HREF_PREFIX
};

// A PrefixMatchContext keeps track of state for pattern
// matching.  Basically, when we see a character that could
// imply a URL prefix ('/', ':', '.', '\', '@'), we attempt
// to match, in parallel, the prefixes we know that end
// with that character.
typedef struct {
    const TCHAR *   pchPattern;
    long            iCharsLeft;
    BOOL            fMatched;
}
PrefixMatchContext;

typedef struct {
    UINT  iTextLength;                    // Number of characters in the text prefix
    UINT  iSignificantLength;             // Number of characters of significance when comparing HREF_PREFIXs for equality
    const TCHAR* pszPattern[2];           // the text prefix and the href prefix
}
AUTOURL_TAG;

// NOTE (JHarding): Entries in this table must be kept in sync with
// the corresponding table in EDUTIL.CXX.  However, this table
// contains additional information and is reordered to optimize
// for detecting URLs
// This table is sorted by the final character of the text prefix.
// This way, we can optimize our pattern match by only attempting to
// match when we see one of these characters, and then only attempting
// to match patterns that end in that character.

AUTOURL_TAG const s_urlTags[] = {
    { 7, 7, {_T("http://"),      _T("http://")}},           // 0    -   /
    { 8, 8, {_T("https://"),     _T("https://")}},          // 1    -   /
    { 6, 6, {_T("ftp://"),       _T("ftp://")}},            // 2    -   /
    { 9, 9, {_T("gopher://"),    _T("gopher://")}},         // 3    -   /
    { 7, 7, {_T("file://"),      _T("file://")}},           // 4    -   /
    { 7, 7, {_T("nntp://"),      _T("nntp://")}},           // 5    -   /
    { 7, 7, {_T("ldap://"),      _T("ldap://")}},           // 6    -   /
    { 8, 8, {_T("ldaps://"),     _T("ldaps://")}},          // 7    -   /
    { 6, 6, {_T("mic://"),       _T("mic://")}},            // 8    -   /
    { 5, 5, {_T("news:"),        _T("news:")}},             // 9    -   :
    { 6, 6, {_T("snews:"),       _T("snews:")}},            // 10   -   :
    { 7, 7, {_T("telnet:"),      _T("telnet:")}},           // 11   -   :
    { 5, 5, {_T("wais:"),        _T("wais:")}},             // 12   -   :
    { 7, 7, {_T("mailto:"),      _T("mailto:")}},           // 13   -   :
    { 7, 7, {_T("newsrc:"),      _T("newsrc:")}},           // 14   -   :
    { 4, 0, {_T("url:"),         _T("")}},                  // 15   -   :
    { 8, 8, {_T("outlook:"),     _T("outlook:")}},          // 16   -   :
    { 4, 7, {_T("www."),         _T("http://www.")}},       // 17   -   .
    { 4, 6, {_T("ftp."),         _T("ftp://ftp.")}},        // 18   -   .
    { 7, 9, {_T("gopher."),      _T("gopher://gopher.")}},  // 19   -   .
    { 7, 10, {_T("file:\\\\"),   _T("file:///\\\\")}},      // 20   -   '\\'
    { 2,  8, {_T("\\\\"),        _T("file://\\\\")}},       // 21   -   '\\'
};

// This is the largest search space for a given trigger character.  This MUST
// be kept up to date with the above table.
#define MAX_SEARCH_SPACE 10

// NOTE (JHarding): This table lists offsets into the above table of URL tags.
// Each entry in this table reflects the first offset in the above table of
// prefixes ending in the character specified in comments for the entry.
// For example, s_anOffsets[1] is 10, with comment ':'.  This means the first
// entry in s_UrlTags that keys off of a colon is s_UrlTags[10].
int const s_anOffsets[] = {
    0,          // '/'
    9,          // ':'
    17,         // '.'
    20,         // '\\'
    22,         // End
};

// Special characters as defined by RFC 822 for the local part of
// e-mail addresses.
static inline AutoUrl_IsEmailSpecialChar( TCHAR ch )
{
    return (   ch <= 31     ||
               ch == '('    ||
               ch == ')'    ||
               ch == '<'    ||
               ch == '>'    ||
               ch == '@'    ||
               ch == ','    ||
               ch == ';'    ||
               ch == ':'    ||
               ch == '\\'   ||
               ch == '"'    ||
               ch == '.'    ||
               ch == '['    ||
               ch == ']' );
}

//+----------------------------------------------------------------------------
//
//  Method: AutoUrl_EmailWildcard
//
//  Synopsis: Handles checking for an e-mail wildcard URL.  This is anything
//      of the format "A@B.C".  Additionally, the A component can be a quoted
//      string per RFC 822, so a full url of something like
//      ""Homer Simpson"@fox.com" is conceivable.
//
//+----------------------------------------------------------------------------
HRESULT CTxtPtr::AutoUrl_EmailWildcard( BOOL *pfFound )
{
    BOOL    fFound          = FALSE;
    BOOL    fQuotedLocal    = FALSE;
    BOOL    fHaveSeenText   = FALSE;
    HRESULT hr              = S_OK;
    long    cpSave          = _cp;
    long    cpStart         = _cp;
    TCHAR   ch;
    BOOL    fSpaceFoundInQuoted  = FALSE;

    Assert( pfFound );

    // Scan backwards for local-part of e-mail addr
    for( ; ; )
    {
        do
        {
            AdvanceCp( -1 );
        } while( ( ch = GetChar() ) == WCH_NODE && !Classify( this, NULL ) );

        // Interesting node - end of local-part
        if( ch == WCH_NODE )
            break;
        else
        {

            if( ch == '"' && !fHaveSeenText )
            {
                fQuotedLocal = TRUE;
                continue;
            }

            if( fQuotedLocal && IsURLBreak( ch ) )
            {
                fSpaceFoundInQuoted = TRUE;
                continue;
            }

            // CONSIDER (jharding): Escaped quotes, ie. \" should not toggle fQuotedLocal,
            // But Word ignores these.
            // CONSIDER (jharding): Also, once we see that we're in a quoted local, we
            // currently don't give up until we see an interesting node.  We probably should
            // just take up to the first space in this case.
            if( ch == '"' && fQuotedLocal )
            {
                fQuotedLocal = FALSE;
                cpStart = _cp;
                break;
            }
            else if( ch == '@' && fQuotedLocal && fSpaceFoundInQuoted )
            {
                // IE Bug# 18648 (mharper): to avoid the situation where "homer@simpson family"@fox.com
                // can cause an endless loop.
                fFound = FALSE;
                goto Cleanup;
            }
            else if( !fQuotedLocal &&
                        ( ( AutoUrl_IsEmailSpecialChar( ch ) && ch != '.' ) ||
                          IsURLBreak(ch) ) )
                break;

            fHaveSeenText = TRUE;
            cpStart = _cp;
        }
    }

    // If we didn't see real text or didn't finish a quoted local, no URL.
    if( !fHaveSeenText || fQuotedLocal )
        goto Cleanup;

    SetCp( cpSave + 1 );

    fFound = TRUE;

    //
    // We no longer require the '.' in the domain name to be work 2k compat.
    //

#if 0
    fHaveSeenText = FALSE;

    // Now scan forwards for domain part
    for( ; ; )
    {
        while( ( ch = GetChar() ) == WCH_NODE && !Classify( this, NULL ) )
        {
            AdvanceCp( 1 );
        }

        if( ch == WCH_NODE )
            break;
        else
        {
            if( ch == '.' )
            {
                if( fHaveSeenText )
                {
                    fFound = TRUE;
                    break;
                }
            }
            else
            {
                if( AutoUrl_IsEmailSpecialChar( ch ) ||
                    wbkclsSpaceA == WordBreakClassFromCharClass( CharClassFromCh( ch ) ) )
                    break;
                fHaveSeenText = TRUE;
            }
        }

        AdvanceCp( 1 );
    }
#endif

Cleanup:
    *pfFound = fFound;
    if( fFound )
    {
        SetCp( cpStart );
    }
    else
    {
        SetCp( cpSave );
    }

    RRETURN( hr );
}


//+----------------------------------------------------------------------------
//
//  Method: AutoUrl_ScanForPrefix
//
//  Synopsis: Scans for a URL prefix (or e-mail address) in the text, in
//      the specified direction.  The search is performed by scanning text
//      for certain "trigger" characters, which signify the possibility of
//      a URL.  These are slash(/), colon(:), period(.), backslash(\), and
//      at(@).
//      When one of these characters is encountered, the appropriate prefixes
//      are selected out of the table to match against.  It then attempts
//      to match the longest possible prefix (so that things like "file:\\"
//      match over "\\".  If a prefix matches, it sets *pfFound to true and
//      *pcpStart to the starting cp over the prefix.
//
//  (t-amolke 01/06/99) Added parameter pchQuoted - NULL if _cp is neither "
//      nor >. Otherwise, it is the corresponding character. While scanning
//      for prefix if pchQuoted is non-NULL, then we should keep going back
//      till we get a matching " or <, and not stop after seeing a space.
//+----------------------------------------------------------------------------
MtDefine( CTxtPtr_AutoUrl_ScanForPrefix_aryCtxs_pv, Locals, "CTxtPtr::AutoUrl_ScanForPrefix aryCtxs::_pv" );
HRESULT CTxtPtr::AutoUrl_ScanForPrefix( int iDir, BOOL *pfFound, long *pcpStart , TCHAR *pchQuoted /* = NULL */ )
{
    CStackDataAry<PrefixMatchContext, MAX_SEARCH_SPACE> aryCtxs(Mt(CTxtPtr_AutoUrl_ScanForPrefix_aryCtxs_pv));
    CTxtPtr tpClone( *this );
    BOOL    fFound  = FALSE;
    long    cch     = 0;
    long    cpStart = _cp;
    HRESULT hr      = S_OK;

    Assert( pfFound && pcpStart );

    // Set up for backwards scan
    if( -1 == iDir )
    {
        if( tpClone._cp > 1 )
            tpClone.AdvanceCp( -1 );
        else
            goto Cleanup;
    }

    for( ; ; )
    {
        TCHAR   ch      = tpClone.GetChar();
        long    cpSave  = tpClone._cp;
        long    cpMatched = cpSave;
        int     nOffset = 0;
        int     nPatterns;
        int     nIndex;
        int     nLeft;
        int     nLongest = -1;

        switch( ch )
        {
            // Check to see if we've got something
            // The patterns are organized by what keys the URL, so that we can limit
            // our search to a contiguous subset of the table.
            case '/':
            case ':':
            case '.':
            case '\\':
                // Determine which offset to use
                switch( ch )
                {
                    case '/' : nOffset = 0; break;
                    case ':' : nOffset = 1; break;
                    case '.' : nOffset = 2; break;
                    case '\\': nOffset = 3; break;
                }

                // Total number of patterns to check
                nPatterns = s_anOffsets[ nOffset + 1 ] - s_anOffsets[ nOffset ];
                Assert( nPatterns <= MAX_SEARCH_SPACE );

                // Make sure we've got enough space to parallel search all patterns of this type
                aryCtxs.EnsureSize( nPatterns );

                // Set up our contexts
                for( nIndex = 0; nIndex < nPatterns; nIndex++ )
                {
                    AUTOURL_TAG tagCurr = s_urlTags[ s_anOffsets[ nOffset ] + nIndex ];

                    // We already know the last character matched.
                    aryCtxs[ nIndex ].iCharsLeft = tagCurr.iTextLength - 1;
                    aryCtxs[ nIndex ].pchPattern = tagCurr.pszPattern[0] + tagCurr.iTextLength - 2;
                    aryCtxs[ nIndex ].fMatched = TRUE;
                }

                nLeft = nPatterns;

                while( nLeft )
                {
                    TCHAR chScan;
                    do
                    {
                        tpClone.AdvanceCp( -1 );
                        chScan = tpClone.GetChar();
                    } while( chScan == WCH_NODE && !Classify( &tpClone, NULL ) );

                    // Grab the character and convert to lowercase
                    if( chScan <= _T('Z') && chScan >= _T('A') )
                        chScan += 0x20;

                    // For each pattern
                    for( nIndex = 0; nIndex < nPatterns; nIndex++ )
                    {
                        // If it hasn't already been ruled out, check the next char
                        if( aryCtxs[ nIndex ].iCharsLeft )
                        {
                            if( chScan != *aryCtxs[ nIndex ].pchPattern )
                            {
                                // This one failed.
                                --nLeft;
                                aryCtxs[ nIndex ].iCharsLeft = 0;
                                aryCtxs[ nIndex ].fMatched = FALSE;
                            }
                            else
                            {
                                if( --aryCtxs[ nIndex ].iCharsLeft == 0 )
                                {
                                    nLongest = nIndex;
                                    cpMatched = tpClone._cp;
                                    --nLeft;
                                }
                                --aryCtxs[ nIndex ].pchPattern;
                            }
                        }
                    }

                }

                if( -1 != nLongest )
                {
                    // Schweet - we found something.
                    fFound = TRUE;
                    cpStart = cpMatched;
                    tpClone.SetCp( cpSave );
                    goto Cleanup;
                }
                else
                {
                    ++cch;
                    tpClone.SetCp( cpSave + iDir );
                }

                break;
            case '@':
                // Wildcard match
                tpClone.AutoUrl_EmailWildcard( &fFound );
                if( fFound )
                {
                    cpStart = tpClone._cp;
                    tpClone.SetCp( cpSave );
                    goto Cleanup;
                }
                else if( !tpClone.AdvanceCp( iDir ) )
                    goto NoMatch;

                break;
            case WCH_NODE:
                // Check to see if we've hit a boundary
                if( Classify( &tpClone, NULL ) )
                    goto NoMatch;

                if( !tpClone.AdvanceCp( iDir ) )
                    goto NoMatch;

                break;
            default:
                // Look for a space-type character.  We will look past one space-type
                // character in front of us to handle hitting space in front of a
                // URL (to separate it from preceding text).

                WBKCLS wbkcls = WordBreakClassFromCharClass( CharClassFromCh( ch ) );

                // Now we also need to take into consideration whether we are looking for a
                // matching quote or not
                if (pchQuoted)
                {
                    TCHAR chMatchingQuote = (*pchQuoted == '>') ? '<' : *pchQuoted;
                    if( chMatchingQuote == ch && ( long(tpClone._cp) != cpStart-1 ) )
                        goto NoMatch;
                }
                else
                {
                    if( wbkclsSpaceA == wbkcls && ( iDir == -1 || long(tpClone._cp) != cpStart ) )
                        goto NoMatch;
                }

                ++cch;

                if( !tpClone.AdvanceCp( iDir ) )
                    goto NoMatch;
        }

        if( cch >= MAX_URL_LENGTH || tpClone._cp <= 1 || long(tpClone._cp) >= GetTextLength() - 1 )
NoMatch:
            break;
    }


Cleanup:
    *pfFound = fFound;
    if( fFound )
    {
        *pcpStart = cpStart;
    }
    SetCp( tpClone._cp );
    RRETURN( hr );
}

//+----------------------------------------------------------------------------
//
//  Method: AutoUrl_FindAndVerifyBoundaries
//
//  Synopsis: Finds the appropriate boundaries for the URL and verifies that
//      they are valid.  The only characters allowed to prefix an autodetected
//      URL are: Whitespace, Open Paren('('), Open Angle Bracket ('<'),
//      Quote ('"'), as well as interesting nodes.
//      Anything else means that the URL should not be autodetected at this
//      point.
//
//+----------------------------------------------------------------------------
HRESULT CTxtPtr::AutoUrl_FindAndVerifyBoundaries( BOOL *pfValid, long cpStart, long *pcpEnd )
{
    Assert( pfValid && pcpEnd );

    HRESULT hr = S_OK;
    CTxtPtr tpClone( _pMarkup, cpStart );
    BOOL    fValid  = FALSE;
    long    cpSave  = _cp;
    long    cpEnd   = cpSave;
    TCHAR   ch;

    // Find the character preceeding the start of the URL.
    while( ( ch = tpClone.GetPrevChar() ) == WCH_NODE )
    {
        tpClone.AdvanceCp( -1 );
        if( Classify( &tpClone, NULL ) )
            break;
    }

    // Quote chars, open paren, space, and interesting nodes are OK.
    if( ch != _T('"')   &&
        ch != _T('<')   &&
        ch != _T('(')   &&
        ch != WCH_NODE  &&
        !IsURLBreak(ch)
        )
    {
        goto Cleanup;
    }

    // Now find the end of the URL
    tpClone.SetCp( cpSave );

    for( ; ; )
    {
        TCHAR ch = tpClone.GetChar();

        // If we hit space or a node character, we be done.
        if( ch == WCH_NODE && Classify( &tpClone, NULL ) ||
            IsURLBreak(ch)
            )
            break;

        // Advance past this character
        tpClone.AdvanceCp( 1 );

        // Don't update our end position for a node character.
        // Don't update for Korean Hangul chars, either (bug 63801).
        if( ch != WCH_NODE && WordBreakClassFromCharClass( CharClassFromCh( ch ) ) != wbkclsHangul )
            cpEnd = tpClone._cp;
    }

    // Reset tpClone to the last committed position.
    tpClone.SetCp( cpEnd );

    // Any punctuation mark should be trimmed from the end of the URL
    // NOTE (krisma): apparently '/' and '\' aren't considered punction symbols by CharClassFromCh.
    while( long(tpClone._cp) > cpStart &&
           ( (WordBreakClassFromCharClass( CharClassFromCh( tpClone.GetPrevChar() ) ) == wbkclsPunctSymb)
             || tpClone.GetPrevChar() == WCH_NODE ) )
    {
        tpClone.AdvanceCp( -1 );
    }

    // JHarding (95006) if we didn't find anything interesting after the prefix trigger, it's
    // not valid.  We can do the straight +1 check, because cpSave was always the last trigger
    // character, so we're guaranteed that
    // if tpClone.cp == cpSave + 1, then there were no interesting characters after the trigger
    // if tpClone.cp < cpSave + 1, then the trigger itself got trimmed off.
    // either way, this isn't valid.
    // Note that this is a discrepancy with Word, who considers "ftp." with the quotes to be a
    // URL.
    if( long(tpClone._cp) <= cpSave + 1 )
        goto Cleanup;

    fValid      = TRUE;
    *pcpEnd     = tpClone._cp;

Cleanup:
    *pfValid    = fValid;
    RRETURN( hr );
}


//+----------------------------------------------------------------------------
//
//  Method: IsInsideUrl
//
//  Synopsis:   Determines if the TxtPtr is inside or at the end of a URL.
//      If it is, this function returns TRUE and sets pcpStart and pcpEnd to
//      the start and end cps of the url containing the TxtPtr.
//
//  (t-amolke 06/01/99) Modified to handle quoted URLs - If we find a quote
//      ( " or > ) at the current cp, then we go into quoted URL mode. In
//      this mode, the URL is scanned backwards till a matching quote
//      ( " or < ) is found.
//-----------------------------------------------------------------------------
BOOL CTxtPtr::IsInsideUrl( long *pcpStart, long *pcpEnd )
{
    HRESULT     hr      = S_OK;
    BOOL        fFound  = FALSE;
    BOOL        fValid  = FALSE;
    CTxtPtr     tpClone( *this );
    CTxtPtr     tpStart( *this );
    CTreePos *  ptp;
    CTreeNode * pNode;
    long        cchIgnore;
    TCHAR       chQuoted;
    TCHAR *     pchQuoted;

    Assert( pcpStart && pcpEnd );

    // Look at the current char. If it is a white space go back on position
    // e.g. "www.cnn.com"_ If the user just hit the space after the quoted
    // URL, we need to scan from the quote at the end.
    chQuoted = tpClone.GetChar();
    WBKCLS wbkcls = WordBreakClassFromCharClass( CharClassFromCh( chQuoted ) );
    if (wbkclsSpaceA == wbkcls)
    {
        // Move tpClone back and to keep them synchronized, move this back.
        PrevChar();
        chQuoted = tpClone.PrevChar();
    }

    // Look past punctuation for the quote
    tpStart.SetCp(GetCp());
    while (chQuoted
           && WordBreakClassFromCharClass(CharClassFromCh(GetChar())) == wbkclsPunctSymb
           && GetChar() != '"'
           && GetChar() != '>'
           )
   {
        // Move tpClone back and to keep them synchronized, move this back.
        PrevChar();
        chQuoted = tpClone.PrevChar();
   }

    // if chQuoted is a quote then pchQuoted points to the quote, else is NULL.
    if (chQuoted != '"' && chQuoted != '>')
    {
        SetCp(tpStart.GetCp());
        tpClone.SetCp(tpStart.GetCp());

        pchQuoted = NULL;
    }
    else
        pchQuoted = &chQuoted;

    // Check if we're inside an anchor
    ptp = _pMarkup->TreePosAtCp( _cp, &cchIgnore );
    Assert( ptp );
    pNode = _pMarkup->SearchBranchForAnchor( ptp->GetBranch() );

    // Found anchor
    if( pNode )
    {
        CElement *  pElement;
        CTreePos *  ptpStart;
        CTreePos *  ptpEnd;
        long        cpStart, cpEnd;

        pElement = pNode->Element();
        Assert( pElement );
        pElement->GetTreeExtent( &ptpStart, &ptpEnd );
        Assert( ptpStart->IsNode() && ptpEnd->IsNode() );

        // Use the insides of the anchor as our URL.
        cpStart = ptpStart->GetCp() + ptpStart->GetCch();
        cpEnd   = ptpEnd->GetCp();

        tpClone.SetCp( cpStart );

        // Verify that it's autodetectable
        hr = THR( tpClone.AutoUrl_ScanForPrefix( 1, &fFound, pcpStart, pchQuoted ) );
        if( hr )
            goto Cleanup;

        if( fFound )
        {
            *pcpEnd = cpEnd;
            fValid  = TRUE;
        }

        goto Cleanup;
    }

    // No anchor - Run backwards and then forwards.
    // We need to keep going backwards when we find an autodetectable
    // URL on an invalid boundary.  This accounts for things like
    // url:http://www.foo.com where we'd match "www." and then "http://"
    // and then finally "url:".
    do
    {
        hr = THR( tpClone.AutoUrl_ScanForPrefix( -1, &fFound, pcpStart, pchQuoted ) );
        if( hr )
            goto Cleanup;

        if( fFound )
        {
            hr = THR( tpClone.AutoUrl_FindAndVerifyBoundaries( &fValid, *pcpStart, pcpEnd ) );
            if( hr )
                goto Cleanup;
        }
    } while( fFound && !fValid );

    // If we didn't find anything backwards, reset and look forwards.
    if( !fFound || !fValid )
    {
        tpClone.SetCp( _cp );

        hr = THR( tpClone.AutoUrl_ScanForPrefix( 1, &fFound, pcpStart, pchQuoted ) );
        if( hr )
            goto Cleanup;

        if( fFound )
        {
            hr = THR( tpClone.AutoUrl_FindAndVerifyBoundaries( &fValid, *pcpStart, pcpEnd ) );
            if( hr )
                goto Cleanup;
        }
    }

    if( fFound && fValid )
    {
        // If we are looking for quoted URL (pchQuoted != NULL) then we better find a matching
        // quote just before the URL. Otherwise we fail.
        // If we are not looking for quoted URL and we find a quote just before the URL, then
        // we do not recognize the URL

        TCHAR chStart;
        CTxtPtr tpStart(*this);
        BOOL bStartQuote = FALSE;

        tpStart.SetCp(*pcpStart-1);
        chStart = tpStart.GetChar();

        // If we are in quoted mode, we must find a proper matching quote at the start of URL
        if (pchQuoted)
        {
            if ((chQuoted == '"' && chStart == '"') ||
                (chQuoted == '>' && chStart == '<'))
                    bStartQuote = TRUE;
        }
        // else any type of quote at the start is illegal.
        else
        {
            if (chStart == '"' || chStart == '<' || chStart == '>')
                bStartQuote = TRUE;
        }

        // How do we modify URL boundaries before setting up the URL?
        //
        //         pchQuoted               bStartQuote    Action
        //           !NULL                      TRUE         set extent of URL from starting
        //                                                   quote to ending quote
        //           !NULL                      FALSE        Fail
        //           NULL                       TRUE         Fail
        //           NULL                       FALSE        Nothing
        if (pchQuoted)
            if (bStartQuote)
                *pcpEnd = _cp;
            else
                fFound = FALSE;
        else
            if (bStartQuote)
                fFound = FALSE;

        SetCp( tpClone._cp );
        goto Cleanup;
    }


Cleanup:
    return ( fFound && fValid && !hr );
}


//+----------------------------------------------------------------------------
//
//  Method: FindUrl
//
//  Synopsis:   Finds the requested URL boundary, looking in the specified
//      direction.
//
//-----------------------------------------------------------------------------
MtDefine( CTxtPtr_FindUrl_aryWord_pv, Locals, "CTxtPtr::FindUrl aryWord::_pv" );
BOOL
CTxtPtr::FindUrl( BOOL fForward, BOOL fBegin, long cpBoundary )
{
    long cpStart, cpEnd = 0;
    int iDir = fForward ? 1 : -1;
    BOOL fFound;
    BOOL fValid;
    HRESULT hr;

    do
    {
        fValid = FALSE;
        hr = THR( AutoUrl_ScanForPrefix( iDir, &fFound, &cpStart, NULL ) );
        if( hr )
            goto Cleanup;

        if( fFound )
        {
            long cchIgnore;
            CTreePos    *   ptp     = _pMarkup->TreePosAtCp( _cp, &cchIgnore );
            CTreeNode   *   pNode   = _pMarkup->SearchBranchForAnchor( ptp->GetBranch() );

            if( pNode )
            {
                CElement    *   pElement = pNode->Element();
                CTreePos    *   ptpStart;
                CTreePos    *   ptpEnd;

                pElement->GetTreeExtent( &ptpStart, &ptpEnd );

                cpEnd   = ptpEnd->GetCp();

                Assert( cpStart == ptpStart->GetCp() + ptpStart->GetCch() );

                fValid = TRUE;
            }
            else
            {
                hr = THR( AutoUrl_FindAndVerifyBoundaries( &fValid, cpStart, &cpEnd ) );
                if( hr )
                    goto Cleanup;
            }
        }

        if( !fFound || !fValid )
        {
            AdvanceCp( iDir );
        }
    }
    while( ( !fFound || !fValid ) && ( cpBoundary == -1 ||
                                       ( fForward && long(_cp) <= cpBoundary ) ||
                                       (!fForward && long(_cp) >= cpBoundary ) ) );

Cleanup:
    if( fFound && fValid )
        SetCp( fBegin ? cpStart : cpEnd );

    return fFound && fValid;
}


/*
 *  CTxtPtr::InsertRepeatingChar(cch, ch)
 *
 *  @mfunc
 *      insert a character a number of tiems
 *
 *  @rdesc
 *      count of new characters added
 *
 *  @comm   SideEffects: <nl>
 *      moves this text pointer to end of replaced text <nl>
 *      moves text block array <nl>
 */
long
CTxtPtr::InsertRepeatingChar(
    LONG cch,                   //@parm number of chars to insert
    TCHAR ch)                   //@parm character to insert
{
    Assert( cch > 0 );
    TCHAR ach[32];
    TCHAR *pch;
    LONG cch2;
    LONG cchLeft;

    // fill up temp array with chars
    for (cch2 = min((LONG)ARRAY_SIZE(ach), cch), pch = ach; cch2; pch += 1,
cch2 -= 1)
        *pch = ch;

    // Insert chars in chunks
    for (cchLeft = cch; cchLeft; cchLeft -= cch2)
    {
        cch2 = InsertRange(min((LONG)ARRAY_SIZE(ach), cchLeft), ach);
        if (!cch2)
            break;
    }

    return cch - cchLeft;
}

/*
 *  TxFindEOP (pchBuff, cch)
 *
 *  @func
 *      Given a string, find the offset to the next EOP marker
 *
 *  @rdesc
 *      Offset to next EOP marker
 *
 *  @devnote
 *      This could probably be replaced by FindEOP()
 */
LONG TxFindEOP(
    const TCHAR *pchBuff,       //@parm the string buffer to look in
    LONG cch)                  //@parm the number valid characters
{
    LONG cchToUse = 0;

    for(; cchToUse < cch && *pchBuff != CR && *pchBuff != LF;
          cchToUse++, pchBuff++) ;

#if DBG==1
    if(cchToUse != cch)
        TraceTag((tagWarning, "TxFindEOP(): found CR or LF at %ld of %ld", cchToUse, cch));
#endif

    return cchToUse;
}

/*
 *  CTxtPtr::InsertRange(cch, pch)
 *
 *  @mfunc
 *      Insert a range of characters at this text pointer
 *
 *  @rdesc
 *      Count of characters successfully inserted
 *
 *  @comm Side Effects: <nl>
 *      moves this text pointer to end of inserted text <nl>
 *      moves the text block array <nl>
 */
long CTxtPtr::InsertRange (
    DWORD cch,              //@parm length of text to insert
    TCHAR const *pch)       //@parm text to insert
{
    _TEST_INVARIANT_

    DWORD cchSave = cch;
    DWORD cchInBlock;
    DWORD cchFirst;
    DWORD cchLast = 0;
    DWORD ctbNew;
    long cRuns;
    CTxtBlk *ptb;

#if DBG == 1
    if (IsTagEnabled(tagOneCharTextInsert) && cch > 1)
    {
        long cchTotal = 0;
        long cchInserted;

        while (cch)
        {
            cchInserted = InsertRange(1, pch);
            AssertSz(cchInserted == 1, "Failed to insert single char in one-char-at-a-time mode");
            pch += 1;
            cch -= 1;
            cchTotal += 1;
        }

        return cchTotal;
    }
#endif

    // Ensure text array is allocated
    cRuns = NumRuns();

    if(!cRuns)
    {
        LONG    cbSize = -1;

        // If we don't have any blocks, allocate first block to be big enuf
        // for the inserted text *only* if it's smaller than the normal block
        // size. This allows us to be used efficiently as a display engine
        // for small amounts of text.

        if (_pMarkup->_fIncrementalAlloc)
        {
            if( cch < CchOfCb(cbBlockInitial) )
                cbSize = CbOfCch(cch);
        }

        if( !((CTxtArray *)_prgRun)->AddBlock(0, cbSize) )
        {
            goto done;
        }
    }

    ptb = GetCurrRun();
    cchInBlock = CchOfCb(ptb->_cbBlock) - ptb->_cch;
    AssertSz(ptb->_cbBlock <= cbBlockMost, "block too big");

    // try and resize without splitting...
    if(cch > cchInBlock &&
        cch <= cchInBlock + CchOfCb(cbBlockMost - ptb->_cbBlock)
        && (!_pMarkup->IsStreaming() || _pMarkup->_fIncrementalAlloc))
    {
        if (!ptb->ResizeBlock(min((DWORD)cbBlockMost,
                                  CbOfCch(ptb->_cch + cch +
                                          (_pMarkup->_fIncrementalAlloc
                                           ? 0 : cchGapInitial)))))
        {
            goto done;
        }
        cchInBlock = CchOfCb(ptb->_cbBlock) - ptb->_cch;
    }
    if(cch <= cchInBlock)
    {
        // all fits into block without any hassle
        ptb->MoveGap(GetIch());
        CopyMemory(ptb->_pch + GetIch(), pch, CbOfCch(cch));
        _cp             += cch;                 // *this points at end of
        SetIch( GetIch() + cch );
        ptb->_cch       += cch;
        ((CTxtArray *)_prgRun)->_cchText    += cch;
        ptb->_ibGap     += CbOfCch(cch);

        return long( cch );
    }

    // logic added (dbau 11/98): before splitting:
    // first try using free space that's in the next block. If we
    // blindly split all the time, we can end up with a pile of mostly-empty
    // huge blocks resulting from splitting one nearly-full block near its edge
    // repeatedly. Note that the problem is exacerbated by our initial small block.
    // To fix the general case, we also need to add logic to try using the
    // previous block as well (not done yet - maybe we should rewrite the
    // whole thing with these considerations...)

    if (cRuns > GetIRun() + 1)
    {
        CTxtBlk *ptbAdj;

        ptbAdj = GetNextRun();
        if (ptbAdj)
        {
            DWORD cchInAdj = CchOfCb(ptbAdj->_cbBlock) - ptbAdj->_cch;
            if (cch <= cchInAdj + cchInBlock)
            {
                // ooh, we have enough room. Do the shuffling around and the insert
                DWORD cchPostGap;

                // move the gaps to the right place
                ptb->MoveGap(GetIch());
                ptbAdj->MoveGap(0);

                cchPostGap = ptb->_cch - GetIch();

                if (cch <= cchInBlock + cchPostGap)
                {
                    // Case 1: if post-gap text is moved to the second block,
                    // all the new text fits in first block

                    // move as much as we can to the second block to maximize gap in the first block
                    DWORD cchToMove = (cchPostGap <= cchInAdj) ? cchPostGap : cchInAdj;
                    CopyMemory(ptbAdj->_pch + CchOfCb(ptbAdj->_cbBlock) - ptbAdj->_cch - cchToMove,
                               ptb->_pch + CchOfCb(ptb->_cbBlock) - cchToMove, CbOfCch(cchToMove));

                    // Slide anything remaining in the first block to the right
                    if (cchToMove < cchPostGap)
                        MoveMemory(ptb->_pch + CchOfCb(ptb->_cbBlock) - cchPostGap + cchToMove,
                                   ptb->_pch + CchOfCb(ptb->_cbBlock) - cchPostGap, CbOfCch(cchPostGap - cchToMove));

                    // Copy the inserted text
                    CopyMemory(ptb->_pch + GetIch(), pch, CbOfCch(cch));

                    // Then update pointers and counters
                    _cp             += cch;
                    SetIch(GetIch() + cch);
                    ptb->_cch       += cch - cchToMove;
                    ptb->_ibGap     += CbOfCch(cch);
                    ptbAdj->_cch    += cchToMove;
                    ((CTxtArray *)_prgRun)->_cchText    += cch;

                    return long(cch);
                }
                else
                {
                    // Case 2: even after moving post-gap text to the second block,
                    // the new text will overflow to the second block.

                    // move all post-gap text to the second block
                    CopyMemory(ptbAdj->_pch + CchOfCb(ptbAdj->_cbBlock) - ptbAdj->_cch - cchPostGap,
                               ptb->_pch + CchOfCb(ptb->_cbBlock) - cchPostGap, CbOfCch(cchPostGap));

                    // move the part of the new text that fits in the first block
                    CopyMemory(ptb->_pch + GetIch(), pch, CbOfCch(cchInBlock + cchPostGap));

                    // move the part of the new text that needs to go in the second block
                    CopyMemory(ptbAdj->_pch, pch + cchInBlock + cchPostGap, CbOfCch(cch - cchInBlock - cchPostGap));

                    // Then update pointers and counters
                    _cp             += cch;
                    SetIRun(GetIRun() + 1);
                    SetIch(cch - cchInBlock - cchPostGap);
                    ptb->_cch       += cchInBlock;
                    ptb->_ibGap     = 0;                     // first gap is empty; its location is moot
                    ptbAdj->_cch    += cch - cchInBlock;
                    ptbAdj->_ibGap  = CbOfCch(cch - cchInBlock - cchPostGap);
                    ((CTxtArray *)_prgRun)->_cchText    += cch;

                    return long(cch);
                }
            }
        }
    }

    // won't all fit in this block

    // figure out best division into blocks
    TxDivideInsertion(cch, GetIch(), ptb->_cch - GetIch(), & cchFirst, &cchLast);

    if (GetIch() == ptb->_cch)
    {
        // BUGFIX (dbau): we should not do a split at the very end of a block,
        // or else we'll introduce an empty block, which causes problems.
        // NOTE (dbau): I don't know if the beginning-of-the-block case is exposed
        // to a similar problem.
        // (Really, when splitting _near_ either edge of a block, we also should try
        // to use an adjacent block's gap instead of always creating a whole new
        // block - but most cases are already fixed by the use-adjacent logic above;
        // further fixes should probably wait until a rewrite).

        ptb->MoveGap(GetIch());
        cchFirst = CchOfCb(ptb->_cbBlock) - ptb->_cch;
        cchLast = 0;
    }
    else
    {
        // Subtract cchLast up front so return value isn't negative
        // if SplitBlock() fails
        cch -= cchLast; // don't include last block in count for middle blocks

        // split block containing insertion point

        // ***** moves _prgtb ***** //
        if(!((CTxtArray *)_prgRun)->SplitBlock(GetIRun(), GetIch(), cchFirst, cchLast,
            _pMarkup->IsStreaming()))
        {
            goto done;
        }
        ptb = GetCurrRun();            // recompute ptb after (*_prgRun) moves
    }

    // copy into first block (first half of split)
    if(cchFirst > 0)
    {
        AssertSz(ptb->_ibGap == CbOfCch(GetIch()), "split first gap in wrong place");
        AssertSz(cchFirst <= CchOfCb(ptb->_cbBlock) - ptb->_cch, "split first not big enough");

        CopyMemory(ptb->_pch + GetIch(), pch, CbOfCch(cchFirst));
        cch             -= cchFirst;
        pch             += cchFirst;
        SetIch( GetIch() + cchFirst );
        ptb->_cch       += cchFirst;
        ((CTxtArray *)_prgRun)->_cchText    += cchFirst;
        ptb->_ibGap     += CbOfCch(cchFirst);
    }

    // copy into middle blocks
    // NOTE: review (jonmat) I increased the size for how large a split block
    // could be and this seems to increase the performance, we need to test the
    // block size difference on a retail build, however. 5/15/1995
    ctbNew = cch / cchBlkInsertmGapI /* cchBlkInitmGapI */;
    if(ctbNew <= 0 && cch > 0)
        ctbNew = 1;
    for(; ctbNew > 0; ctbNew--)
    {
        cchInBlock = cch / ctbNew;
        AssertSz(cchInBlock > 0, "nothing to put into block");

        // ***** moves _prgtb ***** //
        SetIRun( GetIRun() + 1 );
        if(!((CTxtArray *)_prgRun)->AddBlock(GetIRun(),
            CbOfCch(cchInBlock + cchGapInitial)))
        {
            BindToCp(_cp);  //force a rebind;
            goto done;
        }
        // NOTE: next line intentionally advances ptb to next CTxtBlk

        ptb = GetCurrRun();
        AssertSz(ptb->_ibGap == 0, "New block not added correctly");

        CopyMemory(ptb->_pch, pch, CbOfCch(cchInBlock));
        cch             -= cchInBlock;
        pch             += cchInBlock;
        SetIch( cchInBlock );
        ptb->_cch       = cchInBlock;
        ((CTxtArray *)_prgRun)->_cchText    += cchInBlock;
        ptb->_ibGap     = CbOfCch(cchInBlock);
    }
    AssertSz(cch == 0, "Didn't use up all text");

    // copy into last block (second half of split)
    if(cchLast > 0)
    {
        AssertSz(GetIRun() < NumRuns()-1, "no last block");
        SetIRun( GetIRun() + 1 );
        ptb = GetRunAbs(GetIRun());
        AssertSz(ptb->_ibGap == 0,  "split last gap in wrong place");
        AssertSz(cchLast <= CchOfCb(ptb->_cbBlock) - ptb->_cch,
                                    "split last not big enuf");

        CopyMemory(ptb->_pch, pch, CbOfCch(cchLast));
        // don't subtract cchLast from cch; it's already been done
        SetIch( cchLast );
        ptb->_cch       += cchLast;
        ((CTxtArray *)_prgRun)->_cchText    += cchLast;
        ptb->_ibGap     = CbOfCch(cchLast);
        cchLast = 0;                        // Inserted all requested chars
    }

done:
    AssertSz(cch + cchLast <= cchSave, "don't insert more than was asked for");

    cch = cchSave - cch - cchLast;          // # chars successfully inserted
    _cp += cch;

    AssertSz (GetTextLength() ==
                ((CTxtArray *)_prgRun)->GetCch(),
                "CTxtPtr::InsertRange(): _prgRun->_cchText screwed up !");
    return long( cch );
}


/*
 *  TxDivideInsertion(cch, ichBlock, cchAfter, pcchFirst, pcchLast)
 *
 *  @func
 *      Find best way to distribute an insertion
 *
 *  @rdesc
 *      nothing
 */
void TxDivideInsertion(
    DWORD cch,              //@parm length of text to insert
    DWORD ichBlock,         //@parm offset within block to insert text
    DWORD cchAfter,         //@parm length of text after insertion in block
    DWORD *pcchFirst,       //@parm exit: length of text to put in first block
    DWORD *pcchLast)        //@parm exit: length of text to put in last block
{
    DWORD cchFirst = max(0L, (LONG)(cchBlkCombmGapI - ichBlock));
    DWORD cchLast  = max(0L, (LONG)(cchBlkCombmGapI - cchAfter));
    DWORD cchPartial;
    DWORD cchT;

    // Fill first and last blocks to min block size if possible

    cchFirst = min(cch, cchFirst);
    cch     -= cchFirst;
    cchLast = min(cch, cchLast);
    cch     -= cchLast;

    // How much is left over when we divide up the rest?
    cchPartial = cch % cchBlkInsertmGapI;
    if(cchPartial > 0)
    {
        // Fit as much as the leftover as possible in the first and last
        // w/o growing the first and last over cbBlockInitial
        cchT        = max(0L, (LONG)(cchBlkInsertmGapI - ichBlock - cchFirst));
        cchT        = min(cchT, cchPartial);
        cchFirst    += cchT;
        cch         -= cchT;
        cchPartial  -= cchT;
        if(cchPartial > 0)
        {
            cchT    = max(0L, (LONG)(cchBlkInsertmGapI - cchAfter - cchLast));
            cchT    = min(cchT, cchPartial);
            cchLast += cchT;
        }
    }
    *pcchFirst = cchFirst;
    *pcchLast = cchLast;
}


/*
 *  CTxtPtr::DeleteRange(cch)
 *
 *  @mfunc
 *      Delete cch characters starting at this text pointer
 *
 *  @rdesc
 *      nothing
 *
 *  @comm Side Effects: <nl>
 *      moves text block array
 */
void CTxtPtr::DeleteRange(
    DWORD cch)      //@parm length of text to delete
{
    _TEST_INVARIANT_

    DWORD       cchInBlock;
    DWORD       ctbDel = 0;                 // Default no blocks to delete
    DWORD       itb;
    CTxtBlk *   ptb = GetCurrRun();

    AssertSz(ptb,
        "CTxtPtr::DeleteRange: want to delete, but no text blocks");

    if (cch > GetTextLength() - _cp)// Don't delete beyond EOT
        cch = GetTextLength() - _cp;

    ((CTxtArray *)_prgRun)->_cchText -= cch;

    // remove from first block
    ptb->MoveGap(GetIch());
    cchInBlock = min(long(cch), ptb->_cch - GetIch());
    cch -= cchInBlock;
    ptb->_cch -= cchInBlock;

#if DBG==1
    ((CTxtArray *)_prgRun)->Invariant();
#endif

    for(itb = ptb->_cch ? GetIRun() + 1 : GetIRun();
            cch && long(cch) >= GetRunAbs(itb)->_cch; ctbDel++, itb++)
    {
        // More to go: scan for complete blocks to remove
        cch -= GetRunAbs(itb)->_cch;
    }

    if(ctbDel)
    {
        // ***** moves (*_prgRun) ***** //
        itb -= ctbDel;
        ((CTxtArray *)_prgRun)->RemoveBlocks(itb, ctbDel);
    }


    // remove from last block
    if(cch > 0)
    {
        ptb = GetRunAbs(itb);
        AssertSz(long(cch) < ptb->_cch, "last block too small");
        ptb->MoveGap(0);
        ptb->_cch -= cch;
#if DBG==1
        ((CTxtArray *)_prgRun)->Invariant();
#endif

    }

    if (    ((CTxtArray *)_prgRun)->CombineBlocks(GetIRun())
        ||  GetIRun() >= NumRuns()
        || !GetRunAbs(GetIRun())->_cch)
        BindToCp(_cp);                  // Empty block or blocks combined: force tp rebind

    AssertSz (GetTextLength() ==
                ((CTxtArray *)_prgRun)->GetCch(),
                "CTxtPtr::DeleteRange(): _prgRun->_cchText screwed up !");
}


/*
 * Method: FindText
 *
 * Synopsis: This does a search optimized for ascii text, using the
 *  Knuth-Morris-Pratt string matching algorithm as described in
 *  "Introduction to Algorithms" by Cormen, Leiserson and Rivest.
 *
 *  The basic idea of the algorithm is to calculate a "prefix function"
 *  (which is a bit of a misnomer for backwards searching) that contains
 *  information about how the pattern to be found matches against itself.
 *  When a partial match fails, all the characters up to the failing point
 *  are known, so there's no reason to look at them again.  By using the
 *  prefix function, we know where the next possible match could occur, so
 *  we skip up to that point.
 *
 *  Positions this at the beginning of the match if found; if not, this does
 *  not move.  Returns the cp just after the match if found; if not, returns
 *  -1.
 */

MtDefine( CTxtPtr_FindAsciiText_aryPrefixFunction_pv, Locals, "CTxtPtr::FindAsciiText aryPrefixFunction::_pv" );
MtDefine( CTxtPtr_FindAsciiText_aryPatternBuffer_pv, Locals, "CTxtPtr::FindAsciiText aryPatterBuffer::_pv" );
LONG CTxtPtr::FindText(
    LONG            cpLimit,
    DWORD           dwFlags,
    TCHAR const *   pch,
    long            cchToFind )
{
    CStackPtrAry<LONG_PTR, 20>  aryPrefixFunction( Mt(CTxtPtr_FindAsciiText_aryPrefixFunction_pv) );
    CStackPtrAry<LONG_PTR, 20>  aryPatternBuffer(  Mt(CTxtPtr_FindAsciiText_aryPatternBuffer_pv) );

    // Flags
    BOOL            fIgnoreCase;
    BOOL            fWholeWord;
    BOOL            fRaw;
    long            iDir;

    const TCHAR *   pchCurr = pch;
    LONG            cchMatched = 0;
    LONG            cch;

    CTxtPtr         tp( *this );

    Assert( pchCurr );
    AssertSz( cchToFind > 0, "Zero length pattern should get caught before here" );

    //
    // Argument checking and set-up
    //

    // Set up our options from dwFlags
    fIgnoreCase    = !(FR_MATCHCASE & dwFlags);
    fWholeWord     =   FR_WHOLEWORD & dwFlags;
    fRaw           =   FINDTEXT_RAW & dwFlags;

    iDir = ( FINDTEXT_BACKWARDS & dwFlags ) ? -1 : 1;

    //
    // Compute the prefix function
    //
    {
        LONG          cchDone;
        LONG          cchPrefixLength = 0;

        aryPrefixFunction.EnsureSize( cchToFind );
        aryPatternBuffer.EnsureSize(  cchToFind );

        // If we're searching backwards, start at the end of the pattern
        if( -1 == iDir )
        {
            pchCurr += cchToFind - 1;
        }

        for( cchDone = 0; cchDone < cchToFind; cchDone++ )
        {
            // Make sure we've just got ascii
            if( !fRaw && *pchCurr >= 0xff )
            {
                return FindComplexHelper(
                        cpLimit,
                        dwFlags,
                        pch,
                        cchToFind );
            }

            // Copy into the buffer - for a case insensitive compare,
            // convert to lower case if necessary
            TCHAR ch = *pchCurr;

            if( fIgnoreCase){
                CharLowerBuffW((LPWSTR)&ch, 1);
            }

            aryPatternBuffer.Append(ch);

            // We can't extend the current match
            while(  cchPrefixLength > 0
                &&  aryPatternBuffer[cchPrefixLength] != aryPatternBuffer[cchDone] )
            {
                // Go to the next smallest match
                cchPrefixLength = (LONG)aryPrefixFunction.Item( cchPrefixLength - 1 );
            };

            // The first entry is always 0
            if( cchDone && aryPatternBuffer[cchPrefixLength] == *pchCurr )
            {
                ++cchPrefixLength;
            }

            aryPrefixFunction.Append( cchPrefixLength );
            pchCurr += iDir;
        }
    }   // Done with prefix function


    //
    // Perform the search
    //

    // Set/check the limit - cch is the amount of characters left
    // in the document in the appropriate direction.
    if( 1 == iDir )
    {
        LONG cchText = GetTextLength();

        if( cpLimit < 0 || cpLimit > cchText )
            cpLimit = cchText;

        cch = cpLimit - _cp;
    }
    else
    {
        if( cpLimit < 0 )
            cpLimit = 0;

        // Make sure we didn't get a limit farther down than us
        Assert( cpLimit <= (LONG)_cp);

        cch = _cp - cpLimit;
    }

    // Make sure the limit is valid.
    Assert(   ( iDir == -1 && cpLimit <= (long)_cp )
           || ( iDir ==  1 && cpLimit >= (long)_cp ) );

    // Make sure we have enough characters to attempt to match
    if ( cchToFind > cch )
    {
        return -1;
    }

    // Outer loop: Keep getting chunks while there's text left
    while( cch > 0 )
    {
        long    cchChunk;
        TCHAR   chCurr;

        // Get the current chunk of text.  cchChunk is how many
        // characters are left in the current chunk.
        if( 1 == iDir )
        {
            pchCurr = tp.GetPch( cchChunk );
            cchChunk = min( cch, cchChunk );
            tp.AdvanceCp( cchChunk );
        }
        else
        {
            // GetPchReverse returns a pointer to the character
            // just after tp, but with text _before_ the pointer,
            // so we skip back to the first thing before this spot.
            pchCurr = tp.GetPchReverse( cchChunk );
            --pchCurr;
            cchChunk = min( cch, cchChunk );
            tp.AdvanceCp( -cchChunk );
        }

        cch -= cchChunk;

        Assert( cch >= 0 );


        // Chunk loop: This does the main bulk of the work
        while( cchChunk > 0 )
        {
            // In case this chunk starts with node characters, skip 'em.
            while( cchChunk && *pchCurr == WCH_NODE )
            {
                pchCurr += iDir;
                --cchChunk;
            }

            if( !cchChunk )
                break;

            chCurr = *pchCurr;

            // Make sure we've just got ascii
            if( chCurr >= 0xff )
            {
                return FindComplexHelper(
                        cpLimit,
                        dwFlags,
                        pch,
                        cchToFind );
            }

            if( fIgnoreCase)
                CharLowerBuffW((LPWSTR)&chCurr, 1);

            if( chCurr == WCH_NONBREAKSPACE)
            {
                // &nbsp's have their own character, but should match spaces.
                chCurr = _T(' ');
            }

            // While we can't match any more characters, try jumping back
            // to a smaller match and see if we can match from there
            while( cchMatched > 0 && chCurr != aryPatternBuffer[cchMatched] )
            {
                cchMatched = (LONG)aryPrefixFunction[cchMatched - 1];
            }

            // If the next character matches, then increment match count
            if( chCurr == aryPatternBuffer[cchMatched] )
            {
                ++cchMatched;
            }

            // Matched the string - now do some checking
            if( cchMatched == cchToFind)
            {
                CTxtPtr tpStart( _pMarkup, tp._cp );
                CTxtPtr tpEnd ( *this );
                long    cchLength;

                // Here we have to set pointers at the beginning and
                // end of the match.  We only know the edge of the match
                // that we most recently saw (end if going forward,
                // beginning if going backward), so we start from there
                // and count characters to the other side, checking
                // for breaking nodes on the way.
                if( -1 == iDir )
                {
                    // Move tp to the beginning of match
                    tpStart.AdvanceCp( cchChunk - 1 );
                    tpEnd.SetCp( tpStart._cp);

                    // We want to be at the cp just after the last
                    // character matched, so go right before it, and
                    // then one more cp past.
                    for( cchLength = cchToFind; cchLength; tpEnd.AdvanceCp( 1 ) )
                    {
                        if( tpEnd.GetChar() != WCH_NODE )
                        {
                            --cchLength;
                        }
                        else if( Classify( &tpEnd, NULL ) != NODECLASS_NONE )
                            goto invalid_match;
                    }
                }
                else
                {
                    tpStart.AdvanceCp( -cchChunk + 1 );
                    tpEnd.SetCp( tpStart._cp );

                    for( cchLength = cchToFind; cchLength; )
                    {
                        tpStart.AdvanceCp( -1 );

                        if( tpStart.GetChar() != WCH_NODE )
                        {
                            --cchLength;
                        }
                        else if( Classify( &tpStart, NULL ) != NODECLASS_NONE )
                            goto invalid_match;
                    }
                }

                // Check for whole word matching
                if(     !fWholeWord
                    || ( ( tpStart.IsAtBOWord() || tpStart.IsAtEOWord() ) &&
                         ( tpEnd.IsAtBOWord() || tpEnd.IsAtEOWord() ) ) )
                {
                    SetCp(tpStart._cp);
                    return tpEnd._cp;
                }

                // Either we didn't satisfy the whole word match, or
                // there was a break in the middle, so skip to next
                // smallest match

invalid_match:
                cchMatched = (LONG)aryPrefixFunction[cchMatched - 1];
            }

            // Next char - if we run out of chars in this chunk,
            // we'll drop out of the loop and get some more.
            pchCurr += iDir;
            --cchChunk;

        } // while( cchChunk > 0 )

    } // while( cch > 0 )

    // We ran out of characters without finding a match.
    return -1;
}


typedef struct
{
    long cp;
    long cch;
} StripRecord;


// TODO (t-johnh): This will be replaced with a new version once some stuff
//  is added to shlwapi.

MtDefine( CTxtPtr_FindComplexHelper_aryMatchBuffer_pv, Locals, "CTxtPtr::FindComplexHelper aryMatchBuffer::_pv" );
MtDefine( CTxtPtr_FindComplexHelper_aryPatternBuffer_pv, Locals, "CTxtPtr::FindComplexHelper aryPatternBuffer::_pv" );
MtDefine( CTxtPtr_FindComplexHelper_aryStripped_pv, Locals, "CTxtPtr::FindComplexHelper aryStripped::_pv" );

LONG CTxtPtr::FindComplexHelper(
    LONG            cpLimit,
    DWORD           dwFlags,
    TCHAR const *   pch,
    long            cchToFind )
{
    CDataAry<TCHAR>       aryMatchBuffer( Mt(CTxtPtr_FindComplexHelper_aryMatchBuffer_pv) );
    CDataAry<TCHAR>       aryPatternBuffer( Mt(CTxtPtr_FindComplexHelper_aryPatternBuffer_pv) );
    CDataAry<StripRecord> aryStripped( Mt(CTxtPtr_FindComplexHelper_aryStripped_pv) );

    TCHAR WCH_ALEF = 0x0627;

    _TEST_INVARIANT_

    CTxtPtr         tp(*this);      // Keeps track of where we're looking

    LONG            cch;
    long            cchText = GetTextLength();

    // Flags
    BOOL            fIgnoreCase;
    BOOL            fWholeWord;
    long            iDir;

    // For tree navigation
    long            cchOffset;
    CTreePos *      ptp  = _pMarkup->TreePosAtCp( _cp, &cchOffset );

    // For buffer navigation
    const TCHAR *   pchCurr;
    long            cchPatternSize;
    long            cchForward;
    long            cchLeft;
    long            nIndex;         // For looping through records
    long            nRecords;       // of stripped characters


    Assert(pch);

    //
    // Argument checking and set-up
    //

    // Set up our options from dwFlags
    fIgnoreCase    = !(FR_MATCHCASE & dwFlags);
    fWholeWord     =   FR_WHOLEWORD & dwFlags;

    iDir = (FINDTEXT_BACKWARDS & dwFlags ) ? -1 : 1;

    // They didn't give us any characters to find!
    if(cchToFind <= 0)
    {
        return -1;
    }

    // Doctor up the pattern to match
    {
        cchLeft = cchToFind;

        aryPatternBuffer.EnsureSize( cchToFind );
        cchPatternSize = 0;
        pchCurr       = pch;

        for( ; cchLeft; cchLeft--, pchCurr++ )
        {
            // If we're ignoring Diacritics/Kashidas, we want to
            // strip them out of our pattern.
            if(   ( !( dwFlags & FR_MATCHDIAC ) && IsBiDiDiacritic( *pchCurr ) )
               || ( !( dwFlags & FR_MATCHKASHIDA ) && *pchCurr == WCH_KASHIDA ) )
            {
                continue;
            }
            else if( !( dwFlags & FR_MATCHALEFHAMZA ) && IsAlef( *pchCurr ) )
            {
                aryPatternBuffer[cchPatternSize++] = WCH_ALEF;
            }
            else
            {
                aryPatternBuffer[cchPatternSize++] = *pchCurr;
            }
        }

        aryPatternBuffer.SetSize( cchPatternSize );
    }

    // Set/check the limiting cp for search.
    if( 1 == iDir )
    {
        if( cpLimit < 0 || cpLimit > cchText )
            cpLimit = cchText;
    }
    else
    {
        if( cpLimit < 0 )
            cpLimit = 0;
    }

    // Loop through paragraphs, buffering up the interesting text
    // and attempting to match on it.
    for( ; ; )
    {
        StripRecord    sr;
        BOOL           fStripping;
        long           cchPara;
        CTxtPtr        tpParaStart( *this );
        CTxtPtr        tpParaEat( *this );
        CTxtPtr        tpParaEnd( *this );

        sr.cp = 0;      // init
        sr.cch = 0;
        //////////////////////////////////////////////////////////////////
        //
        // Step 1: Define the paragraph boundaries by getting node
        // information from the tree.
        //
        //////////////////////////////////////////////////////////////////

        cch = 0;
        nRecords = 0;
        fStripping = FALSE;

        // If moving backwards, set ptp to the first interesting pos
        // in the paragraph.

        if (iDir == -1)
        {
            // Skip back to an embedding or block break

            for ( ; ; )
            {
                CTreePos * pPrevPos = ptp->PreviousTreePos();

                if (!pPrevPos)
                    break;

                if (ptp->IsNode() && ClassifyNodePos( ptp, NULL ) != NODECLASS_NONE)
                    break;

                ptp = pPrevPos;
            }

            // Then move forward to the interesting one.
            ptp = ptp->NextTreePos();

            // Paragraph starts here, but

            tpParaStart.SetCp( ptp->GetCp() );

            // Limit our buffer start based on tp and the limit

            if (tpParaStart._cp > tp._cp)
                tpParaStart.SetCp( tp._cp );
            else if (long( tpParaStart._cp ) < cpLimit)
                tpParaStart.SetCp( cpLimit );

            tpParaEnd.SetCp( tp._cp );
        }
        else
        {
            // Moving forwards, find the end of this paragraph

            for ( ; ; )
            {
                if (!ptp)
                    break;

                if (ptp->IsNode() && ClassifyNodePos( ptp, NULL ) != NODECLASS_NONE)
                    break;

                ptp = ptp->NextTreePos();
            }


            tpParaEnd.SetCp( ptp ? ptp->GetCp() : cpLimit );

            // Limit the buffer ending based on the limit.

            if (long(tpParaEnd._cp) > cpLimit)
                tpParaEnd.SetCp( cpLimit );

            tpParaStart.SetCp( tp._cp );
        }

        // Make sure we've got enough space.
        // NOTE (t-johnh): This will be a quite
        // wasteful (twice the space needed), but better than repeated
        // allocations to grow the buffer.  The thing is, I can't just
        // Append with a DataAry - I'd have to allocate new StripRecords
        // and AppendIndirect - this way I can just use [] and assign.

        if (tpParaEnd._cp < tpParaStart._cp)
            goto no_match;

        aryMatchBuffer.EnsureSize( tpParaEnd._cp - tpParaStart._cp );
        aryStripped.EnsureSize( tpParaEnd._cp - tpParaStart._cp );

        //////////////////////////////////////////////////////////////////
        //
        // Step 2: Build up the buffer from tpParaStart to tpParaEnd
        // by stripping out any un-interesting characters and storing
        // StripRecords noting where we pulled out characters so that
        // we can rebuild Cp's later.
        //
        //////////////////////////////////////////////////////////////////

        cchPara = tpParaEnd._cp - tpParaStart._cp;
        tpParaEat.SetCp( tpParaStart.GetCp() );
        while( cchPara )

        {
            long cchChunk;

            pch = tpParaEat.GetPch( cchChunk );
            cchChunk = min(cchChunk, cchPara);
            tpParaEat.AdvanceCp( cchChunk );
            cchPara -= cchChunk;

            while( cchChunk )
            {
                // Do we want to strip this character out of our buffer?
                if(   ( *pch == WCH_NODE )
                   || ( !( dwFlags & FR_MATCHDIAC ) && IsBiDiDiacritic( *pch ) )
                   || ( !( dwFlags & FR_MATCHKASHIDA ) && *pch == WCH_KASHIDA )
                  )
                {
                    if( !fStripping )
                    {
                        // If we're not stripping yet, set up a new
                        // strip record.
                        fStripping = TRUE;
                        sr.cp  = cch;
                        sr.cch = 1;
                    }
                    else
                    {
                        // otherwise, just tally up another character.
                        ++sr.cch;
                    }
                }
                else
                {
                    // Real character
                    if( fStripping )
                    {
                        // If we were stripping, save the record.
                        aryStripped[nRecords++] = sr;
                        fStripping = FALSE;
                    }

                    if( !( dwFlags & FR_MATCHALEFHAMZA ) && IsAlef( *pch ) )
                    {
                        aryMatchBuffer[cch++] = WCH_ALEF;
                    }
                    else
                    {
                        aryMatchBuffer[cch++] = *pch;
                    }
                }

                ++pch;
                --cchChunk;
            }
        }

        // Set the correct sizes for our buffers.
        aryMatchBuffer.SetSize( cch );
        aryStripped.SetSize( nRecords );



        //////////////////////////////////////////////////////////////////
        //
        // Step 3: Scan through this buffer in the appropriate direction
        // looking for a match, and then verify it if necessary.
        //
        //////////////////////////////////////////////////////////////////

        if( 1 == iDir )
        {
            // Search forward from buffer start
            pchCurr = (TCHAR *)aryMatchBuffer;
            cchForward = cch;
        }
        else
        {
            // Search backwards from buffer end.
            pchCurr = (TCHAR *)aryMatchBuffer + cch - 1;
            cchForward = 1;
        }

        // Now that we've got our buffer, try and match on it.
        cchLeft = cch;

        while( cchLeft > 0 )
        {
            if( 2 == CompareStringAltW(
                        LOCALE_USER_DEFAULT,
                        SORT_STRINGSORT | ( fIgnoreCase ? ( NORM_IGNORECASE | NORM_IGNOREWIDTH ) : 0 ),
                        pchCurr,
                        min(cchForward, cchPatternSize),
                        aryPatternBuffer,
                        cchPatternSize ) )
            {
                CTxtPtr tpStart( _pMarkup, tpParaStart._cp + pchCurr - aryMatchBuffer );
                CTxtPtr tpEnd( *this );

                // Move start to the match point, and adjust for stripped nodes.
                for( nIndex = 0, nRecords = aryStripped.Size();
                     nRecords > 0 && aryStripped[nIndex].cp <= pchCurr - aryMatchBuffer;
                     nRecords--, nIndex++ )
                {
                    tpStart.AdvanceCp( aryStripped[nIndex].cch );
                }

                // Now do the same for the ending cp.
                tpEnd.SetCp( tpStart._cp + cchPatternSize );
                for( ;
                     nRecords > 0 && aryStripped[nIndex].cp < pchCurr + cchPatternSize - aryMatchBuffer;
                     nRecords--, nIndex++ )
                {
                    tpEnd.AdvanceCp( aryStripped[nIndex].cch );
                }

                if( !fWholeWord ||
                    ( ( tpStart.IsAtBOWord() || tpStart.IsAtEOWord() ) &&
                      ( tpEnd.IsAtBOWord()   || tpEnd.IsAtEOWord() ) ) )
                {
                    SetCp( tpStart._cp );
                    return tpEnd._cp;
                }
            }

            pchCurr += iDir;
            cchForward -= iDir;
            --cchLeft;
        }

        // No match if we've hit the limit.
        if( (long)tpParaStart._cp == cpLimit || (long)tpParaEnd._cp == cpLimit )
            goto no_match;

        // Move over to the next paragraph.
        if( 1 == iDir )
        {
            ptp = _pMarkup->TreePosAtCp( tpParaEnd._cp, &cchOffset );
            while( ptp->IsNode() && ( !ptp->IsEdgeScope() ||
                                      ClassifyNodePos( ptp, NULL ) != NODECLASS_NONE ) )
            {
                ptp = ptp->NextTreePos();
                if ( !ptp )
                    goto no_match;
            }
            tp.SetCp( ptp->GetCp() );
        }
        else
        {
            ptp = _pMarkup->TreePosAtCp( tpParaStart._cp - 1, &cchOffset );

            while( ptp->IsNode() && ( !ptp->IsEdgeScope() ||
                                      ClassifyNodePos( ptp, NULL ) != NODECLASS_NONE ) )
            {
                ptp = ptp->PreviousTreePos();
                if ( !ptp )
                    goto no_match;
            }
            tp.SetCp( ptp->GetCp() + ptp->GetCch() );
        }

     }
no_match:
     return -1;
}


/*
 *  CTxtPtr::FindBOSentence(cch)
 *
 *  @mfunc
 *      Find beginning of sentence in the document.
 *
 *  @rdesc
 *      Count of chars moved *this moves
 *
 *  @comm
 *      This routine defines a sentence as a character string that ends with
 *      period followed by at least one whitespace character or the EOD.  This
 *      should be replacable so that other kinds of sentence endings can be
 *      used.  This routine also matches initials like "M. " as sentences.
 *      We could eliminate those by requiring that sentences don't end with
 *      a word consisting of a single capital character.  Similarly, common
 *      abbreviations like "Mr." could be bypassed.  To allow a sentence to
 *      end with these "words", two blanks following a period could be used
 *      to mean an unconditional end of sentence.
 */
LONG CTxtPtr::FindBOSentence ( BOOL fForward )
{
    _TEST_INVARIANT_

    LONG    cchWhite = 0;                       // No whitespace chars yet
    long    cpSave   = _cp;                     // Save value for return
    long    cch      = fForward ? GetTextLength() - 1 - _cp : _cp - 1;
    BOOL    fST;                                // TRUE if sent terminator
    LONG    iDir     = fForward ? 1 : -1;       // AdvanceCp() increment
    CTxtPtr tp(*this);                          // tp to search with


    //
    // If moving forward, backup over whitespace.
    // This makes sure we recognize a new sentence
    // if we were in whitespace between 2 previous
    // sentences.
    //
    if(iDir == 1)
    {
        while( IsWhiteSpace(&tp) && cch )
        {
            long cchMoved = AdvanceChars( &tp, -1 );

            cch -= cchMoved;
            if( !cchMoved )
                break;
        }
    }

    while( cch )
    {
        //
        // Find a sentence terminator
        //
        for( fST = FALSE; cch; )
        {
            fST = IsSentenceTerminator( tp.GetChar() );
            if( fST )
                break;

            cch -= iDir * AdvanceChars( &tp, iDir );
        }

        // No ST, or hit forward end of document
        if( !fST || ( fForward && !cch ) )
            break;

        //
        // Skip forward past whitespace
        //
        cchWhite = 0;
        cch -= iDir * AdvanceChars( &tp, 1 );
        while(    IsWhiteSpace( &tp )
               && (    ( fForward && cch )
                    || ( !fForward && long(tp._cp) < cpSave ) ) )
        {
            cchWhite++;
            cch -= iDir * AdvanceChars( &tp, 1 );
        }

        //
        // Needed whitespace, but if we're moving backwards,
        // make sure we actually are prior to start position.
        //
        if( cchWhite && ( fForward || long(tp._cp) < cpSave ) )
            break;

        //
        // Didn't match - adjust prior to ST if backwards
        //
        if( !fForward )
        {
            cch += AdvanceChars( &tp, -cchWhite - 2 );
        }
    }

    if(cchWhite || !cch )                       // If sentence found or got
        SetCp(tp._cp);                          //  start/end of story, set
                                                //  _cp to tp's
    return _cp - cpSave;                        // Tell caller cch moved
}

/*
 *  CTxtPtr::IsAtBOWord()
 *
 *  @mfunc
 *      Return TRUE iff *this is at the beginning of a word, that is,
 *      the char at _cp isn't whitespace and either _cp = 0 or the char at
 *      _cp - 1 is whitespace.
 *
 *  @rdesc
 *      TRUE iff *this is at the beginning of a Word
 */
BOOL CTxtPtr::IsAtBOWord()
{
    if(!_cp || IsAtEOP())                   // Story beginning is also
        return TRUE;                        //  a word beginning

    CTxtPtr tp(*this);
    AdvanceChars( &tp, -1 );
    tp.FindWordBreak(WB_MOVEWORDRIGHT);
    return _cp == tp._cp;
}

/*
 *  CTxtPtr::IsAtEOWord()
 *
 *  @mfunc
 *      Return TRUE iff *this is at the end of a word.
 *
 *  @rdesc
 *      TRUE iff *this is at the end of a Word
 */
BOOL CTxtPtr::IsAtEOWord()
{
    if(!_cp == (GetTextLength() - 1) || IsAtEOP())      // Story end is also
        return TRUE;                                    //  a word end

    CTxtPtr tp(*this);
    AdvanceChars( &tp, -1 );
    tp.FindWordBreak(WB_RIGHTBREAK);
    return _cp == tp._cp;
}

/*
 * CTxtPtr::MoveCluster( fForward )
 *
 * Synopsis: Moves one cluster in the given direction. A cluster is defined as
 * one or more characters that are grouped into a unit.  This looks strictly
 * at TEXT.
 *
 * Returns: number of characters moved
 */
#define MAX_MOVE_BUFFER  33
#define NODE_EXTRA       20

long
CTxtPtr::MoveCluster( BOOL fForward )
{
    TCHAR aryItemize [ MAX_MOVE_BUFFER ];
    CStackDataAry <TCHAR, MAX_MOVE_BUFFER + NODE_EXTRA> aryNodePos(Mt(CTxtPtrFindThaiTypeWordBreak_aryNodePos_pv));
    SCRIPT_LOGATTR arySLA [ MAX_MOVE_BUFFER ];
    long cchMove, cchBefore, cchAfter, lHoldNode;
    long cchNodesSkipped = 0;
    long cpSave, cchText;
    BOOL fMovedPastSignificantNodes = FALSE;
    CTxtPtr tp(*this);
    BOOL fCurrentIsNode = FALSE;
    TCHAR ch;

    cchMove = cchBefore = cchAfter = lHoldNode = 0;

    cpSave = GetCp();
    cchText = GetTextLength();

    // Adjust starting position
    if(cchText)
    {
        //
        // Note, we don't include the root node's WCH_NODE chars as valid chars to deal with.
        //

        int  iDir = fForward ? 1 : -1;
        long cchLeft = fForward ? cchText - 1 - tp._cp : tp._cp;

        //
        // If we are going backward, and there are characters behind us
        //

        if (!fForward && cchLeft)
        {
            tp.AdvanceCp( -1 );
            cchLeft--;
        }

        //
        // Skip over all non scope node chars
        //

        fMovedPastSignificantNodes = FALSE;

        while ( cchLeft && tp.GetChar() == WCH_NODE )
        {
            switch ( Classify( & tp, NULL ) )
            {
            case NODECLASS_NONE       :
                break;

            case NODECLASS_SEPARATOR  :
            case NODECLASS_LINEBREAK  :
            case NODECLASS_BLOCKBREAK :
            case NODECLASS_SITEBREAK  :
                fMovedPastSignificantNodes = TRUE;
                break;

            case NODECLASS_NOSCOPE    :
                fMovedPastSignificantNodes = TRUE;

                //
                // Move past the two node chars to get past this noscope, then
                // set cchLeft to 0 to blow out of the loop
                //

                tp.AdvanceCp( 2 * iDir );

                cchLeft = 0;
                break;

            default :
                AssertSz( 0, "Unexpected Node class" );
                break;
            }

            if (cchLeft != 0)
            {
                tp.AdvanceCp( iDir );
                ++cchNodesSkipped;
                cchLeft--;
            }
        }
    }


    //
    // If the current character is not a clustering char, then we can quickly
    // deal with it.
    //
    // paulnel - we want to handle password characters in Clusters as normal text
    //           since it is drawn as normal text (with "*")
    ch = tp.GetChar();
    if (!IsMoveByClusterChar( ch ) || tp.IsPasswordChar())
    {
        //
        // If we are moving backwards, we have already adjusted to the correct
        // position.  Otherwise, if we are moving forward to the next beginning of
        // a cluster, only do so if we have not skipped past any significant
        // 'synthetic' characters.  THis deals with the case of "a</p><p>b" where
        // one moves from just after the 'a' to just before the 'b'.
        //

#ifndef NO_UTF16
        if (IsSurrogateChar(ch))
        {
            if (!fMovedPastSignificantNodes)
            {
                if (fForward)
                {
                    if (   cchText > 1
                        && IsHighSurrogateChar(ch))
                    {
                        CTxtPtr tpNext(tp);

                        ch = tpNext.NextChar();

                        if (IsLowSurrogateChar(ch))
                        {
                            tp.AdvanceCp( 2 );
                        }
                    }
                }
                else
                {
                    if (   tp._cp > 0
                        && IsLowSurrogateChar(ch))
                    {
                        CTxtPtr tpPrev(tp);

                        ch = tpPrev.PrevChar();

                        if (IsHighSurrogateChar(ch))
                        {
                            tp.AdvanceCp( -1 );
                        }
                    }
                }
            }
        }
        else
#endif
        if (fForward && !fMovedPastSignificantNodes)
            tp.AdvanceCp( 1 );

        SetCp( tp.GetCp() );

        return GetCp() - cpSave;
    }

    //
    // Did we just arrive on a Thai type character? Move to it.
    //
    // TODO (paulnel, IE6 bug 64): if moving backwards do we need to adjust the _cp?
    if(fMovedPastSignificantNodes)
    {
        SetCp( tp.GetCp() );

        return GetCp() - cpSave;
    }

    tp.SetCp( cpSave );
    if(tp.GetChar() == WCH_NODE)
        fCurrentIsNode = TRUE;

    if(!tp.PrepThaiTextForBreak(FALSE,
                                fForward,
                                fCurrentIsNode,
                                cchText,
                                &aryNodePos,
                                aryItemize,
                                &cchBefore,
                                &cchAfter,
                                &cchMove,
                                &lHoldNode))
    {
        cchMove = AdvanceCp(cchMove);
        return cchMove;
    }

    long offset = ItemizeAndBreakRun( aryItemize, &cchBefore, &cchAfter, arySLA );

    if (fForward)
    {

        do
        {
            cchBefore++;
            cchAfter--;
            cchMove++;

        }
        while ( cchAfter >= 0 && ! arySLA[cchBefore].fCharStop );

    }
    else
    {
        // go backwards in the attribute array until the first word break is encountered

        while ( cchBefore > 0 && ! arySLA[cchBefore].fCharStop )
        {
            cchBefore--;
            cchMove--;

        }

        // We decremented cchBefore before passing it in to be itemized.
        // Therefore we need to increase the offset to move it to the
        // correct place.
        offset++;

    }

    Assert(offset + cchMove >= 0 &&
           offset + cchMove < aryNodePos.Size());
    Assert( fForward ? aryNodePos [ offset + cchMove ] - aryNodePos [ offset ] >= 0
                     : aryNodePos [ offset + cchMove ] - aryNodePos [ offset ] <= 0);

    if( fForward )
    {
        cchMove += aryNodePos [ offset + cchMove ] - aryNodePos [ offset ] + cchNodesSkipped;
    }
    else
    {
        Assert( offset > 0 );

        cchMove += aryNodePos [ offset + cchMove ] - aryNodePos [ offset - 1 ] - cchNodesSkipped;
    }

    AdvanceCp( cchMove );

    return cchMove;
}

//+----------------------------------------------------------------------------
//
//  Member: MoveClusterEnd
//
//  Synopsis: Moves the TxtPtr to the next cluster ending in the given
//      direction.  This accounts for non-interesting nodes, too.
//
//-----------------------------------------------------------------------------
long CTxtPtr::MoveClusterEnd( BOOL fForward )
{
    long cpOrig = _cp;
    long cpSave = _cp;
    long cch;

    // To set up for previous end, we have to start at the next begin

    if (!fForward)
        MoveCluster( TRUE );

    for( ; ; )
    {
        if( fForward && !MoveCluster( TRUE ) )
            break;

        // Set limits
        cch     = fForward ? _cp -cpSave : _cp - 1;
        cpSave  = _cp;

        // Scan backwards across nodes,
        while( cch && GetPrevChar() == WCH_NODE )
        {
            AdvanceCp( -1 );
            --cch;
        }

        cch = cpSave - _cp;

        // Then scan forward across un-interesting nodes
        while( cch && GetChar() == WCH_NODE && !Classify( this, NULL ) )
        {
            AdvanceCp( 1 );
            --cch;
        }

        // Make sure we're ending up in the right direction
        if(    (  fForward && long(_cp) > cpOrig )
            || ( !fForward && long(_cp) < cpOrig ) )
            break;

        // If not, try the next one
        if( !MoveCluster( fForward ) )
            break;
    }

    return _cp - cpOrig;
}

/*
 *  CTxtPtr::FindThaiTypeWordBreak(int action )
 *
 *  @mfunc
 *      Find a word break in Thai script and move this text pointer to it.
 *
 *  @rdesc
 *      Offset from cp of the word break
 */
#define MAX_BREAK_BUFFER 75

LONG CTxtPtr::FindThaiTypeWordBreak(
    int     action)     //@parm Direction of movement in run
                        // NOTE: The limit character MUST be on a block boundary if < 47 characters
                        //       to give certainty of valid break location.
{
    long    cchMove = 0;

    if(action == WB_MOVEWORDRIGHT || action == WB_MOVEWORDLEFT ||
       action == WB_RIGHTBREAK || action == WB_LEFTBREAK)
    {

        TCHAR aryItemize[MAX_BREAK_BUFFER];
        CStackDataAry <TCHAR, MAX_BREAK_BUFFER + NODE_EXTRA> aryNodePos(Mt(CTxtPtrFindThaiTypeWordBreak_aryNodePos_pv));
        SCRIPT_LOGATTR arySLA[MAX_BREAK_BUFFER];
        long  cchBefore = 0;
        long  cchAfter = 0;
        CTxtPtr tp(*this);
        BOOL  fForward = (action == WB_RIGHTBREAK || action == WB_MOVEWORDRIGHT);

        // Set up for ScriptItemize(). We need to re-itemize the string instead
        // of using the cached _Analysis struct because we don't know how many
        // characters are involved.

        // Make sure the current character is ThaiType
        Assert(fForward ? NoWhiteBetweenWords(tp.GetChar()) : NoWhiteBetweenWords(tp.GetPrevChar()));

        if(!tp.PrepThaiTextForBreak(TRUE,
                                    fForward,
                                    GetChar() == WCH_NODE,
                                    GetTextLength(),
                                    &aryNodePos,
                                    aryItemize,
                                    &cchBefore,
                                    &cchAfter,
                                    &cchMove))
        {
            cchMove = AdvanceCp(cchMove);
            return cchMove;
        }

        if( !fForward && cchBefore > 0 )
        {
            cchBefore--;
            cchMove--;
        }

        long offset = ItemizeAndBreakRun(aryItemize, &cchBefore, &cchAfter, arySLA);

        if(fForward)
        {
            do
            {
                cchBefore++;
                cchAfter--;
                cchMove++;

            }while(    cchAfter >= 0
                   && (  !(arySLA[cchBefore].fSoftBreak)
                       || (action == WB_MOVEWORDRIGHT ? (arySLA[cchBefore].fWhiteSpace) : FALSE) )
                   && ( action != WB_RIGHTBREAK || wbkclsSpaceA != WordBreakClassFromCharClass( CharClassFromCh( aryItemize[cchBefore] ) ) ) );


            // if we are at the end of Thai text and have spaces, move past the spaces
            if(cchAfter == -1)
            {
                tp.AdvanceCp(cchMove + aryNodePos[offset + cchMove] - aryNodePos[offset]);

                while(IsCharBlank(tp.GetChar()) || (tp.GetChar() == WCH_NODE && !Classify (&tp, NULL)))
                {
                    aryNodePos[offset + cchMove] += 1;
                    if(tp.AdvanceCp(1) != 1)
                        break;
                }

            }

        }
        else
        {
            // go backwards in the attribute array until the first word break is encountered
            while(cchBefore > 0 && !(arySLA[cchBefore].fSoftBreak))
            {
                cchBefore--;
                cchMove --;
            }

        }

        // Adjust back to original position for calculating node characters.
        offset += fForward ? 0 : 1;

        Assert( offset + cchMove >= 0 &&
                offset + cchMove < aryNodePos.Size() );
        Assert( (action & 1) ? aryNodePos [ offset + cchMove ] - aryNodePos [ offset ] >= 0
                             : aryNodePos [ offset + cchMove ] - aryNodePos [ offset ] <= 0);
        cchMove += aryNodePos[offset + cchMove] - aryNodePos[offset];

    }

    return cchMove;                            // Offset of where to break

}

/*
 *  CTxtPtr::PrepThaiTextForBreak(int action )
 *
 *  @mfunc
 *      Prepare text for Thai breaking by removing all nodes from the text to be
 *      itemized. paryNodePos will keep track of node positions so the tp can
 *      be moved correctly.
 *
 *  @rdesc
 *      TRUE/FALSE to indicate completion of preparing the itemize array.
 */
#define BREAK_BEFORE     30
#define BREAK_AFTER      30
#define MOVE_BEFORE      16
#define MOVE_AFTER       15

BOOL
CTxtPtr::PrepThaiTextForBreak(
        BOOL fWordBreak,
        BOOL fForward,
        BOOL fCurrentIsNode,
        long cchText,
        CDataAry<TCHAR> *paryNodePos,
        TCHAR *paryItemize,
        long *pcchBefore,
        long *pcchAfter,
        long *pcchMove,
        long *plHoldNode)
{
    long cpSave = GetCp();
    long cchCtrlBefore = 0;
    long cchCtrlAfter = 0;
    long cchTotal = 0;
    long cch = 0;
    long cchBeforeMax = fWordBreak ? BREAK_BEFORE : MOVE_BEFORE;
    long cchAfterMax = fWordBreak ? BREAK_AFTER : MOVE_AFTER;
    BOOL  fOffEnd = FALSE;

    if(!paryNodePos || !paryItemize || !pcchBefore || !pcchAfter || !pcchMove)
        return FALSE;

    // Advance until cchAfterMax characters have passed or a non-ThaiType character
    // is encountered. If we encounter a breaking type of WCH_NODE we will
    // stop looking. Space type characters are included

    if( !fCurrentIsNode || !Classify(this, NULL) )
    {
        while(*pcchAfter < cchAfterMax)
        {
            TCHAR chCur = NextChar();

            if (NoWhiteBetweenWords( chCur ) || IsMoveByClusterChar( chCur ) ||
                wbkclsSpaceA == WordBreakClassFromCharClass( CharClassFromCh( chCur ) ) )
                *pcchAfter += 1;
            else if (chCur == WCH_NODE)
            {
                if(Classify( this, NULL ))
                    break;

                cchCtrlAfter++;
            }
            else
            {
                if(chCur == 0)
                    fOffEnd = TRUE;
                break;
            }
        }
    }

    // (paulnel) We are making an assumption that a node character is always present at the
    // end of a story
    Assert(fOffEnd ? cchCtrlAfter > 0 : cchCtrlAfter >= 0);

    // Back up until cchAfterMax characters have passed or a non-ThaiType character
    // is encountered. If we encounter a breaking type of WCH_NODE we will
    // stop looking. Space type characters are included
    SetCp( cpSave );

    while ( *pcchBefore < cchBeforeMax )
    {
        TCHAR chCur = PrevChar();

        if (NoWhiteBetweenWords( chCur ) || IsMoveByClusterChar( chCur ) ||
            wbkclsSpaceA == WordBreakClassFromCharClass( CharClassFromCh( chCur ) ) )
            *pcchBefore += 1;
        else if (chCur == WCH_NODE)
        {
            if(_cp == 0 || Classify( this, NULL ))
                break;

            cchCtrlBefore++;
        }
        else
            break;
    }

    if (fForward && *pcchAfter == 0)
    {
        *pcchMove = 1;
        return FALSE;
    }
    else if (!fForward && *pcchBefore == 0)
    {
        *pcchMove = 0;
        return FALSE;
    }

    if(*pcchBefore == 0)
        cchCtrlBefore = 0;

    // Position the tp to the start of the Thai-type text. If we do not have
    // *pcchBefore, don't move for ctrl chars.
    Assert(*pcchBefore + cchCtrlBefore <= cpSave &&
           cpSave + *pcchAfter + cchCtrlAfter < cchText);

    SetCp(cpSave - *pcchBefore - cchCtrlBefore);

    cch = *pcchBefore + *pcchAfter + (fCurrentIsNode ? 0 : 1); // we need to include ourself
    cchTotal = cch + cchCtrlBefore + cchCtrlAfter;

    long cchValid;
    paryNodePos->Grow(cchTotal + 1);
    cchValid = GetRawText(cchTotal, *paryNodePos);

    Assert(cchValid == cchTotal);

    // Strip out any control characters
    long lCount = 0;
    long lTotal = 0;
    long lNode = 0;
    const TCHAR* pchCur = (*paryNodePos);

    while ( lCount < cch )
    {
        Assert( lTotal <= cchTotal );

        if (*pchCur != WCH_NODE)
        {
            // paulnel and john harding - If we have a space type character we want
            // to force it to be a normal space character so that Uniscribe keeps it
            // as part of the Thai type text run during itemization.
            if(wbkclsSpaceA != WordBreakClassFromCharClass( CharClassFromCh( *pchCur ) ))
                paryItemize[lCount] = *pchCur;
            else
                paryItemize[lCount] = _T(' ');

            (*paryNodePos)[lCount] = lNode;
            lCount++;
        }
        else
        {
            lNode++;
            if(lCount == *pcchBefore)
            {
                if(plHoldNode)
                    *plHoldNode += 1;
            }
        }

        lTotal++;
        pchCur++;
    }

    Assert(lCount <= cchTotal);

    // subtract the ending node so we don't walk off of the end.
    if(!fWordBreak)
    {
        (*paryNodePos)[lCount] = cchCtrlBefore + cchCtrlAfter + (fCurrentIsNode ? 1 : 0) - (fOffEnd ? 1 : 0);
    }
    else
    {
        (*paryNodePos)[lCount] = lNode;
    }
    paryNodePos->SetSize( lCount + 1 );

    Assert( cch == lCount );

    if(!fForward && !fWordBreak)
    {
        Assert( *pcchBefore > 0 );

        *pcchBefore -= 1;
        *pcchAfter +=1;
        *pcchMove -=1;
    }

    if(fCurrentIsNode && *pcchAfter > 0)
        *pcchAfter -= 1;

    return TRUE;
}

/*
 *  CTxtPtr::ItemizeAndBreakRun
 *
 *  @mfunc
 *      Uses Uniscribe to itemize Thai type text and mark word and character boundaries.
 *
 *  @rdesc
 *      Offset from the beginning of the string to the run in which the desired
 *      breaking opportunities will be used. This will help match up with the
 *      aryNodePos array
 */
long
CTxtPtr::ItemizeAndBreakRun(TCHAR* aryItemize, long* pcchBefore, long* pcchAfter, SCRIPT_LOGATTR* arySLA)
{
    HRESULT hr;
    CStackDataAry<SCRIPT_ITEM, 8> aryItems(Mt(CTxtPtrItemizeAndBreakRun_aryItems_pv));
    int cItems, nItem;
    long offset = 0;
    long cch = *pcchBefore + *pcchAfter + 1;

    // Prepare SCRIPT_ITEM buffer
    if (FAILED(aryItems.Grow(8)))
    {
        // We should always be able to grow to 8 itemse as we are based on
        // a CStackDataAry of this size.
        Assert(FALSE);
    }

    // Call ScriptItemize() wrapper in usp.cxx.
    if(g_bUSPJitState == JIT_OK)
        hr = ScriptItemize(aryItemize, cch, 16,
                           NULL, NULL, &aryItems, &cItems);
    else
        hr = E_PENDING;

    if (FAILED(hr))
    {
        if(hr == USP10_NOT_FOUND)
        {
            g_csJitting.Enter();
            if(g_bUSPJitState == JIT_OK)
            {
                g_bUSPJitState = JIT_PENDING;

                // We must do this asyncronously.
                IGNORE_HR(GWPostMethodCall(_pMarkup->Doc(),
                                           ONCALL_METHOD(CDoc, FaultInUSP, faultinusp),
                                           0, FALSE, "CDoc::FaultInUSP"));

            }
            g_csJitting.Leave();
        }
        // ScriptItemize() failed (for whatever reason). We are unable to
        // break, so assume we've got a single word and return.
        goto done;
    }

    // Find the SCRIPT_ITEM containing cp.
    for(nItem = aryItems.Size() - 1;
        *pcchBefore < aryItems[nItem].iCharPos;
        nItem--);
    if (nItem < 0 || nItem + 1 >= aryItems.Size())
    {
        // Somehow the SCRIPT_ITEM array has gotten messed up. We can't
        // break, so assume we've got a single word and return.
        goto done;
    }

    // Adjust cch to correspond to the text indicated by this item.
    cch = aryItems[nItem + 1].iCharPos - aryItems[nItem].iCharPos;
    *pcchBefore -= aryItems[nItem].iCharPos;
    *pcchAfter = cch - *pcchBefore - 1;

    Assert(*pcchBefore >= 0 && *pcchAfter >= 0 && *pcchBefore + *pcchAfter + 1 == cch);

    // do script break
    hr = ScriptBreak(aryItemize + aryItems[nItem].iCharPos, cch,
                     (SCRIPT_ANALYSIS *) &aryItems[nItem].a,
                     arySLA);

    if (FAILED(hr))
    {
        // ScriptBreak() failed (for whatever reason). We are unable to break,
        // so assume we've got a single word and return.
        goto done;
    }

    offset = *pcchBefore + aryItems[nItem].iCharPos;
done:
    return offset;                            // Offset of where to break
}


//
// Bookmark get/set methods
//

#define BOOKMARK_CURRENT_VERSION 2

// Structures
struct NastyCharsCounts
{
    long cchEmbed;
    long cchLineBreak;
    long cchBlockBreak;
    long cchWordBreak;
    long cchTxtSiteBreak;
    long cchTxtSiteEnd;
    long cchMiscNasty;
};

#define NUM_ADJACENT_CHARS 10

struct BookEnd
{
    long cp;

    NastyCharsCounts nastyCounts;

    char cchLeft, cchRight;
    TCHAR achLeft [ NUM_ADJACENT_CHARS ];
    TCHAR achRight [ NUM_ADJACENT_CHARS ];
};

struct Bookmark
{
    TCHAR chZero;

    char chVersion;
    char chDegenerate;

    BookEnd left;
    BookEnd right; // Only if not degenerate
};

/*
 * FindBookend:
 *
 * Synopsis: Looks forward or backward, as specified by fForward, trying
 *  to find the given bookend.  If found, the given CTxtPtr will be positioned
 *  at the bookend.
 *
 * Returns: TRUE if found, FALSE if not.
 */
static BOOL FindBookend( CTxtPtr * ptp, BookEnd & bookend, BOOL fForward )
{
    long    cpOrig     = ptp->_cp;
    long    cchLeft, cchRight, cch;
    BOOL    fFoundIt   = FALSE;
    TCHAR   achLeft[NUM_ADJACENT_CHARS], achRight[NUM_ADJACENT_CHARS];

    //
    // Make copies of the achLeft/Right strings, stripping out
    // non-text characters that don't exist now.
    //
    for( cch = 0, cchLeft = 0; cch < bookend.cchLeft; cch++ )
    {
        if( IsValidWideChar( bookend.achLeft[cch] ) )
            achLeft[cchLeft++] = bookend.achLeft[cch];
    }
    for( cch = 0, cchRight = 0; cch < bookend.cchRight; cch++ )
    {
        if( IsValidWideChar( bookend.achRight[cch] ) )
            achRight[cchRight++] = bookend.achRight[cch];
    }

    // Now scan along in the given direction, trying to match achLeft/Right
    for( ; ; )
    {
        long cpSave = ptp->_cp;

        if (0 == cchLeft)
        {
            // If there is no left text, automatically match
            fFoundIt = TRUE;
        }
        else
        {
            for( cch = 0; ptp->MoveChar( FALSE ) && ptp->GetChar() == achLeft[cch]; )
            {
                // Matched achLeft
                if( ++cch >= cchLeft )
                {
                    fFoundIt = TRUE;
                    break;
                }
            }
        }


        ptp->SetCp( cpSave );

        // Only check achRight if we matched achLeft.
        if( fFoundIt )
        {
            fFoundIt = FALSE;
            cch = 0;

            if (0 == cchRight)
            {
                fFoundIt = TRUE;
            }
            else
            {
                for( cch = 0; ptp->GetChar() == achRight[cch]; )
                {
                    // Matched achRight
                    if( ++cch >= cchRight )
                    {
                        fFoundIt = TRUE;
                        break;
                    }

                    // out of characters
                    if( !ptp->MoveChar( TRUE ) )
                        break;
                }
            }
        }

        ptp->SetCp( cpSave );

        if( fFoundIt )
            return TRUE;

        if( !ptp->MoveChar( fForward ) )
            break;
    }

    // Couldn't find it.
    ptp->SetCp( cpOrig );
    return FALSE;
}

/*
 * Member: CTxtPtr::MoveToBookmark
 *
 * Synopsis: Moves this to the beginning of given bookmark, and moves
 *  pTxtPtrend to the end of the bookmark.  If bookmark can not be found,
 *  neither is moved.
 *
 * Returns: S_OK if found, S_FALSE if not.
 */
HRESULT CTxtPtr::MoveToBookmark( BSTR bstrBookmark, CTxtPtr *pTxtPtrEnd )
{
    HRESULT             hr      = S_OK;
    Bookmark            bm;
    long                cchBookmark;
    TCHAR *             pch;

    BOOL                fFoundIt;


    Assert( pTxtPtrEnd );

    //
    // Parse out and verify the bookmark string.
    //
    cchBookmark = FormsStringLen( bstrBookmark );

    cchBookmark *= sizeof(TCHAR);

    if (cchBookmark != sizeof( Bookmark ) &&
        cchBookmark != sizeof( Bookmark ) - sizeof( BookEnd ))
    {
        goto InvalidBookmark;
    }

    memcpy( & bm, & bstrBookmark[ 0 ], cchBookmark );

    cchBookmark /= sizeof(TCHAR);

    pch = (TCHAR *) & bm;

    for ( ; ; )
    {
        for (int i = 0 ; i < cchBookmark ; i++ )
            pch[i]--;

        if (bm.chZero == 0)
            break;
    }

    if (bm.chVersion > char( BOOKMARK_CURRENT_VERSION ))
        goto InvalidBookmark;

    //
    // Look for bookends
    //

    // Adjust inside of document
    if (bm.left.cp >= GetTextLength())
        bm.left.cp = GetTextLength() - 1;

    SetCp( bm.left.cp );
    fFoundIt =    FindBookend( this, bm.left, FALSE )
               || FindBookend( this, bm.left, TRUE );

    if( !bm.chDegenerate )
    {
        // Adjust inside of document
        if (bm.right.cp >= GetTextLength())
            bm.right.cp = GetTextLength() - 1;

        pTxtPtrEnd->SetCp( bm.right.cp );
        fFoundIt = fFoundIt && (    FindBookend( pTxtPtrEnd, bm.right, FALSE )
                                 || FindBookend( pTxtPtrEnd, bm.right, TRUE ) );
    }
    else
    {
        pTxtPtrEnd->SetCp( _cp );
    }


    // If we couldn't find it, return S_FALSE to notify caller.
    if( !fFoundIt )
    {
        hr = S_FALSE;
    }

Cleanup:
    RRETURN1( hr, S_FALSE );

InvalidBookmark:
    hr = E_INVALIDARG;
    goto Cleanup;
}

static void CountNasties (
    CTxtPtr * pTxtPtr, long cp, NastyCharsCounts & nasties )
{
    long cchLeft;
    long cpSave = pTxtPtr->_cp;

    nasties.cchEmbed = 0;
    nasties.cchLineBreak = 0;
    nasties.cchBlockBreak = 0;
    nasties.cchWordBreak = 0;
    nasties.cchTxtSiteBreak = 0;
    nasties.cchTxtSiteEnd = 0;
    nasties.cchMiscNasty = 0;

    // Count word breaks.
    while( long(pTxtPtr->_cp) < cp )
    {
        nasties.cchWordBreak++;
        pTxtPtr->FindWordBreak( WB_MOVEWORDRIGHT );
    }

    pTxtPtr->SetCp( cpSave );
    cchLeft = cp - pTxtPtr->_cp;

    // Count everything else.
    while( cchLeft-- > 0)
    {
        BOOL    fBegin;

        if ( WCH_NODE == pTxtPtr->GetChar() )
        {
            switch( Classify( pTxtPtr, &fBegin ) )
            {
            case NODECLASS_NONE:        nasties.cchMiscNasty++;     break;
            case NODECLASS_SEPARATOR:   nasties.cchEmbed++;         break;
            case NODECLASS_NOSCOPE:     nasties.cchEmbed++;         break;
            case NODECLASS_LINEBREAK:   nasties.cchLineBreak++;     break;
            case NODECLASS_BLOCKBREAK:  nasties.cchBlockBreak++;    break;
            case NODECLASS_SITEBREAK:
                if( fBegin )
                    nasties.cchTxtSiteBreak++;
                else
                    nasties.cchTxtSiteEnd++;
                break;
            }
        }
        pTxtPtr->AdvanceCp( 1 );
    }

}

/*
 * ComputeAdjacent:
 *
 * Synopsis: Computes the text adjacent to the given TxtPtr and fills
 *  bookend appropriately.
 */
static void ComputeAdjacent (
    CTxtPtr * pTxtPtr, BookEnd & bookend )
{
    long    cch, cpSave;
    long    cchText = pTxtPtr->GetTextLength();
    TCHAR * pch;

    cpSave = pTxtPtr->GetCp();
    pch = bookend.achLeft;

    // Look left
    for( cch = 0, pTxtPtr->MoveChar( FALSE );
         pTxtPtr->_cp > 1 && cch < NUM_ADJACENT_CHARS;
         cch++, pTxtPtr->MoveChar( FALSE ) )
    {
        *pch++ = pTxtPtr->GetChar();
    }
    bookend.cchLeft = cch;

    // Look right, but make sure we start at text.
    pTxtPtr->SetCp( cpSave );

    if( pTxtPtr->GetChar() == WCH_NODE )
        pTxtPtr->MoveChar( TRUE );

    pch = bookend.achRight;
    for( cch = 0;
         long(pTxtPtr->_cp) < cchText - 1 && cch < NUM_ADJACENT_CHARS;
         cch++, pTxtPtr->MoveChar( TRUE ) )
    {
        *pch++ = pTxtPtr->GetChar();
    }
    bookend.cchRight = cch;
}

/*
 * Member: CTxtPtr::GetBookmark
 *
 * Synopsis: Gets a bookmark string represnting the positions of
 * this and pTxtPtrEnd, and fills *pbstrBookmark with the string.
 */
HRESULT CTxtPtr::GetBookmark(
    BSTR *pbstrBookmark,
    CTxtPtr *pTxtPtrEnd )
{
    HRESULT     hr      = S_OK;
    long        cchBookmark;
    TCHAR       achBookmark[ sizeof( Bookmark ) / sizeof( TCHAR ) + 1 ];
    Bookmark    bm;

    bm.chZero = 0;
    bm.chVersion = char(BOOKMARK_CURRENT_VERSION);
    bm.chDegenerate = pTxtPtrEnd->_cp == _cp;

    // Left edge
    bm.left.cp = _cp;
    SetCp( 1 );
    CountNasties( this, bm.left.cp, bm.left.nastyCounts );
    Assert( long(_cp) == bm.left.cp );

    ComputeAdjacent( this, bm.left );

    // Right edge
    if( !bm.chDegenerate )
    {
        bm.right.cp = pTxtPtrEnd->_cp;
        pTxtPtrEnd->SetCp( bm.left.cp );

        CountNasties( pTxtPtrEnd, bm.right.cp, bm.right.nastyCounts );
        Assert( long(pTxtPtrEnd->_cp) == bm.right.cp );
        ComputeAdjacent( pTxtPtrEnd, bm.right );
    }

    //
    // Garble the bookmark.
    //
    cchBookmark = sizeof( Bookmark );

    if (bm.chDegenerate)
        cchBookmark -= sizeof( BookEnd );

    memcpy( achBookmark, & bm, cchBookmark );

    cchBookmark /= sizeof( TCHAR );

    for ( ; ; )
    {
        BOOL fFoundZero = FALSE;

        for ( int i = 0 ; i < cchBookmark ; i++ )
            if (++achBookmark[i] == 0)
                fFoundZero = TRUE;

        if (!fFoundZero)
            break;
    }

    hr = THR( FormsAllocStringLen( achBookmark, cchBookmark, pbstrBookmark ) );

    if (hr)
        goto Cleanup;

Cleanup:
    RRETURN(hr);
}


/*
 * Member: CTxtPtr::IsPasswordChar
 *
 * Synopsis: Find out if _cp has the char format to indicate
 * that it is a password character. Used to bypass cluster movement
 * for cluster type text
 */
BOOL CTxtPtr::IsPasswordChar()
{
    long        ich;
    CTreePos *  ptp = _pMarkup->TreePosAtCp( _cp, &ich );

    if(ptp->IsText())
        return ptp->GetBranch()->GetCharFormat()->_fPassword;
    else
        return FALSE;
}


BOOL CTxtPtr::IsAtWordBreak()
{
    TCHAR   chBefore = WCH_NODE, chAfter = WCH_NODE;
    long    cchText = GetTextLength();
    long    cpSave = _cp;
    long    cpRight;

    // Find the next character
    while( long(_cp) < cchText - 1 &&
           ( chAfter = GetChar() ) == WCH_NODE      &&
           Classify( this, NULL ) == NODECLASS_NONE )
    {
        AdvanceCp( 1 );
    }

    // Interesting nodes are breaks, as is running off the end of the doc
    if( chAfter == WCH_NODE || long(_cp) >= cchText - 1 )
        return TRUE;

    cpRight = _cp;
    SetCp( cpSave - 1 );

    while( _cp > 1 &&
           ( chBefore = GetChar() ) == WCH_NODE     &&
           Classify( this, NULL ) == NODECLASS_NONE )
    {
        AdvanceCp( -1 );
    }

    // Interesting nodes are breaks, as is running off the end of the doc
    if( chBefore == WCH_NODE || long(_cp) <= 1 )
        return TRUE;

    // If we've got 2 Thai-type chars, we have to use the dictionary word moves
    if( NoWhiteBetweenWords(chBefore) && NoWhiteBetweenWords(chAfter) )
    {
        SetCp( cpRight );
        FindWordBreak( WB_MOVEWORDRIGHT, FALSE );
        FindWordBreak( WB_MOVEWORDLEFT, FALSE );
        return( long(_cp) == cpRight );
    }

    // Otherwise, check the table
    return IsWordBreakBoundaryDefault( chBefore, chAfter );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\text\slist.cxx ===
#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)


#ifndef X_CDUTIL_HXX_
#define X_CDUTIL_HXX_
#include "cdutil.hxx"
#endif

#ifndef X_QI_IMPL_H_
#define X_QI_IMPL_H_
#include "qi_impl.h"
#endif

#ifndef _X_SEGLIST_HXX_
#define _X_SEGLIST_HXX_
#include "slist.hxx"
#endif

#ifndef _X_SEGLIST_HXX_
#define _X_SEGLIST_HXX_
#include "segment.hxx"
#endif

MtDefine(CSegmentList, Utilities, "CSegmentList")
MtDefine(CSegmentListIterator, Utilities, "CSegmentListIterator")

#define IFC(expr) {hr = THR(expr); if (FAILED(hr)) goto Cleanup;}

//+-------------------------------------------------------------------------
//
//  Method:     CSegmentList::CSegmentList
//
//  Synopsis:   Constructor
//
//  Arguments:  VOID
//
//  Returns:    VOID
//
//--------------------------------------------------------------------------
CSegmentList::CSegmentList() 
{
    _eType = SELECTION_TYPE_None;
    _ulRefs = 1;

    //
    // May be used on the stack Not Memcleared.
    //
    _pFirst = NULL;
    _pLast = NULL;
    _nSize = 0;
}

//+-------------------------------------------------------------------------
//
//  Method:     CSegmentList::~CSegmentList
//
//  Synopsis:   Destructor
//
//  Arguments:  VOID
//
//  Returns:    VOID
//
//--------------------------------------------------------------------------
CSegmentList::~CSegmentList()
{
    RemoveAll();
}

//+-------------------------------------------------------------------------
//
//  Method:     CSegmentList::QueryInterface
//
//  Synopsis:   IUnknown QueryInterface implementation
//--------------------------------------------------------------------------
STDMETHODIMP
CSegmentList::QueryInterface(
    REFIID              iid, 
    LPVOID *            ppvObj )
{
    if(!ppvObj)
        RRETURN(E_INVALIDARG);
  
    if( iid == IID_IUnknown || iid == IID_ISegmentList )
    {
        *ppvObj = (ISegmentList *)this;
    }
    else
    {
        *ppvObj = NULL;
        RRETURN_NOTRACE(E_NOINTERFACE);
    }

    ((IUnknown *)(*ppvObj))->AddRef();

    return S_OK;
}

//
//  ISegmentList methods
//

//+-------------------------------------------------------------------------
//
//  Method:     CSegmentList::GetType
//
//  Synopsis:   Retrieves the type of selection this segment list contains
//
//  Arguments:  peType = OUT pointer
//
//  Returns:    HRESULT indicating success.
//
//--------------------------------------------------------------------------
HRESULT
CSegmentList::GetType( SELECTION_TYPE *peType )
{
    HRESULT hr = E_FAIL;
    
    Assert( peType );

    if( peType )
    {
        *peType = _eType; 
        hr = S_OK;
    }        

    return hr;
}

//+-------------------------------------------------------------------------
//
//  Method:     CSegmentList::IsEmpty
//
//  Synopsis:   Determines whether the segment list is empty or not
//
//  Arguments:  pfEmpty = Empty pointer to BOOL
//
//  Returns:    HRESULT indicating success.
//
//--------------------------------------------------------------------------
HRESULT
CSegmentList::IsEmpty( BOOL *pfEmpty )
{
    HRESULT hr = E_FAIL;
    
    Assert( pfEmpty );

    if( pfEmpty )
    {
        *pfEmpty = (_pFirst == NULL) ? TRUE :FALSE; 
        hr = S_OK;
    }        

    return hr;
}

//+-------------------------------------------------------------------------
//
//  Method:     CSegmentList::CreateIterator
//
//  Synopsis:   Creates an iterator that can be used to iterate over the 
//              segments in our list.
//
//  Arguments:  pIIter = Iterator to return
//
//  Returns:    HRESULT indicating success.
//
//--------------------------------------------------------------------------
HRESULT
CSegmentList::CreateIterator( ISegmentListIterator **pIIter )
{
    HRESULT hr = S_OK;

    CSegmentListIterator *pListIter = new CSegmentListIterator();

    if( pListIter == NULL )
        goto Error;

    // Initialize the iterator, and retrieve the ISegmentListIterator interface
    IFC( pListIter->Init( _pFirst ) );
    IFC( pListIter->QueryInterface(IID_ISegmentListIterator, (void **)pIIter) );
  
Cleanup:
    ReleaseInterface( pListIter );
    RRETURN(hr);

Error:
    hr = E_OUTOFMEMORY;
    goto Cleanup;
}

//+-------------------------------------------------------------------------
//
//  Method:     CSegmentList::SetSelectionType
//
//  Synopsis:   Sets the type of selection this segment list contains
//
//  Arguments:  eType = selection type
//
//  Returns:    HRESULT indicating success.
//
//--------------------------------------------------------------------------
HRESULT
CSegmentList::SetSelectionType( SELECTION_TYPE eType )
{
    while( !IsEmpty() )
    {
        PrivateRemove( _pFirst );
    }

    _eType = eType;
    
    return S_OK;
}

//+-------------------------------------------------------------------------
//
//  Method:     CSegmentList::AddSegment
//
//  Synopsis:   Adds a segment to our list.
//
//  Arguments:  pStart = Start position
//              pEnd = End position
//              pISegmentAdded = OUTPUT ISegment pointer to added segment
//
//  Returns:    HRESULT indicating success.
//
//--------------------------------------------------------------------------
HRESULT 
CSegmentList::AddSegment( IMarkupPointer    *pIStart,
                          IMarkupPointer    *pIEnd,
                          ISegment          **pISegmentAdded)
{
    HRESULT     hr = E_INVALIDARG;
    CSegment    *pSegment = NULL;
    
    Assert( pIStart && pIEnd && pISegmentAdded );
//        Assert( (GetSelectionType() == SELECTION_TYPE_Caret) || 
//                (GetSelectionType() == SELECTION_TYPE_Text ) );

    if( pIStart && pIEnd && pISegmentAdded )
    {
        pSegment = new CSegment();
        if ( pSegment == NULL )
            goto Error;

        // Add this to our linked list, and retrieve the ISegment interface
        IFC( pSegment->Init( pIStart, pIEnd ) );
        IFC( PrivateAdd( pSegment ) );

        IFC( pSegment->QueryInterface( IID_ISegment, (void **)pISegmentAdded) );
    }        
             
Cleanup:
    RRETURN( hr );

Error:
    hr = E_OUTOFMEMORY;
    goto Cleanup;
}

//+-------------------------------------------------------------------------
//
//  Method:     CSegmentList::AddElementSegment
//
//  Synopsis:   Adds an element segment. The element segment is used to 
//              keep track of control selections.
//
//  Arguments:  pIElement = Element to bound selection to
//              ppISegmentAdded = ISegment pointer to added segment
//
//  Returns:    HRESULT indicating success.
//
//--------------------------------------------------------------------------
HRESULT 
CSegmentList::AddElementSegment( IHTMLElement       *pIElement,
                                 IElementSegment    **pISegmentAdded )
{
    HRESULT         hr = E_INVALIDARG;
    CElementSegment *pSegment = NULL;
    
    Assert( pIElement && pISegmentAdded );
//    Assert( GetSelectionType() == SELECTION_TYPE_Control );

    if( pIElement && pISegmentAdded)
    {
        pSegment = new CElementSegment();
        if ( pSegment == NULL )
            goto Error;
  
        // Initialize and add our new segment
        IFC( pSegment->Init( pIElement ) );
        IFC( PrivateAdd( pSegment ) );

        IFC( pSegment->QueryInterface( IID_IElementSegment, (void **)pISegmentAdded) );
    }        
             
Cleanup:
    RRETURN( hr );

Error:
    hr = E_OUTOFMEMORY;
    goto Cleanup;
}

//+-------------------------------------------------------------------------
//
//  Method:     CSegmentList::AddCaretSegment
//
//  Synopsis:   Adds a caret segment. The caret segment is used to keep track
//              of the caret.
//
//  Arguments:  pICaret = Caret pointer
//
//  Returns:    HRESULT indicating success.
//
//--------------------------------------------------------------------------
HRESULT 
CSegmentList::AddCaretSegment(IHTMLCaret *pICaret, ISegment **pISegmentAdded)
{
    HRESULT         hr = E_INVALIDARG;
    CCaretSegment   *pSegment = NULL;
    
    Assert( pICaret );
    Assert( GetSelectionType() == SELECTION_TYPE_Caret );

    if( pICaret )
    {
        pSegment = new CCaretSegment();
        if ( pSegment == NULL )
            goto Error;
  
        // Initialize and add our new segment
        IFC( pSegment->Init( pICaret ) );
        IFC( PrivateAdd( pSegment ) );

        // Retrieve the ISegment pointer
        if( pISegmentAdded )
        {
            IFC( pSegment->QueryInterface( IID_ISegment, (void **)pISegmentAdded) );
        }            
    }        
             
Cleanup:
    RRETURN( hr );

Error:
    hr = E_OUTOFMEMORY;
    goto Cleanup;
}

//+-------------------------------------------------------------------------
//
//  Method:     CSegmentList::RemoveSegment
//
//  Synopsis:   Removes a segment.
//
//  Arguments:  pISegment = Segment to remove
//
//  Returns:    HRESULT indicating success.
//
//--------------------------------------------------------------------------
HRESULT 
CSegmentList::RemoveSegment( ISegment *pISegment )
{
    HRESULT     hr = E_INVALIDARG;
    CSegment    *pSegment = NULL;
    
    Assert( pISegment );

    if( pISegment )
    {
        // Lookup our element
        IFC( PrivateLookup(pISegment, &pSegment) );
        
        // Remove it
        IFC( PrivateRemove( pSegment ) );
    }        
            
Cleanup:
    RRETURN1( hr, S_FALSE );
}

//+-------------------------------------------------------------------------
//
//  Method:     CSegmentList::PrivateAdd
//
//  Synopsis:   Adds a segment to the linked list
//
//  Arguments:  pSegment = Segment to add
//
//  Returns:    HRESULT indicating success.
//
//--------------------------------------------------------------------------
HRESULT 
CSegmentList::PrivateAdd( CSegment *pSegment )
{
    Assert( pSegment );

    if( IsEmpty() )
    {
        // Handle the case when this is the
        // first element
        _pFirst = pSegment;
        _pLast = pSegment;
        _pFirst->SetNext(NULL);
        _pFirst->SetPrev(NULL);
    }
    else
    {
        // Append this element
        pSegment->SetNext(NULL);
        pSegment->SetPrev(_pLast);
        _pLast->SetNext(pSegment);
        _pLast = pSegment;   
    }

    _nSize++;
    
    RRETURN(S_OK);
}

//+-------------------------------------------------------------------------
//
//  Method:     CSegmentList::PrivateLookup
//
//  Synopsis:   Given an ISegment, this function will find the underlying
//              CSegment.
//
//  Arguments:  pISegment = ISegment to retreive CSegment for
//              ppSegment = Returned CSegment pointer
//
//  Returns:    HRESULT indicating success.
//
//--------------------------------------------------------------------------
HRESULT 
CSegmentList::PrivateLookup( ISegment *pISegment, CSegment **ppSegment )
{  
    HRESULT hr = S_OK;
    
    Assert( pISegment && ppSegment );

    // Query for the CSegment
    IFC( pISegment->QueryInterface(CLSID_CSegment, (void **)ppSegment));

Cleanup:
    RRETURN(hr);
}

//+-------------------------------------------------------------------------
//
//  Method:     CSegmentList::RemoveAll
//
//  Synopsis:   Removes all of the segments from the linked list.
//
//  Arguments:  VOID
//
//  Returns:    HRESULT indicating success.
//
//--------------------------------------------------------------------------
HRESULT 
CSegmentList::RemoveAll(void)
{  
    HRESULT hr = S_OK;
    
    while( !IsEmpty() )
    {
        IFC( PrivateRemove( _pFirst ) );
    }

Cleanup:
    RRETURN(S_OK);
}

//+-------------------------------------------------------------------------
//
//  Method:     CSegmentList::PrivateRemove
//
//  Synopsis:   Removes a CSegment from the list
//
//  Arguments:  pSegment = CSegment to remove
//
//  Returns:    HRESULT indicating success.
//
//--------------------------------------------------------------------------
HRESULT 
CSegmentList::PrivateRemove( CSegment *pSegment )
{  
    CSegment    *pNext = NULL;
    CSegment    *pPrev = NULL;

    pPrev = pSegment->GetPrev();
    pNext = pSegment->GetNext();

    Assert( pSegment );

    // Item certainly isn't in our list, and it looks like it
    // should be in our list, tell our client
    if( ( (_pFirst == _pLast) && (pSegment != _pFirst) ) || 
        ( (_pFirst != _pLast) && (pPrev == NULL) && (pNext == NULL) ) )
    {
        return S_FALSE;
    }

    if( _pFirst == _pLast )
    {
        _pFirst = NULL;
        _pLast = NULL;
    }
    else if( pSegment == _pFirst )
    {
        // Removing first element
        _pFirst = pSegment->GetNext();
        _pFirst->SetPrev(NULL);
    }
    else if( pSegment == _pLast )
    {
        // Removing last element
        _pLast = pSegment->GetPrev();
        _pLast->SetNext(NULL);
    }
    else
    {
        // Should be somewhere in the middle of the list
        Assert( pSegment->GetNext() );
        Assert( pSegment->GetPrev() );

        pPrev->SetNext(pNext);
        pNext->SetPrev(pPrev);
    }

    pSegment->SetNext(NULL);
    pSegment->SetPrev(NULL);
    
    ReleaseInterface(pSegment);

    _nSize--;
    
    RRETURN(S_OK);
}

//+-------------------------------------------------------------------------
//
//  Method:     CSegmentListIterator::CSegmentListIterator
//
//  Synopsis:   Constructor for our Segment list iterator.
//
//  Arguments:  VOID
//
//  Returns:    VOID
//
//--------------------------------------------------------------------------
CSegmentListIterator::CSegmentListIterator()
{
    Assert( _pCurrent == NULL );
    Assert( _pFirst == NULL );
    _ulRefs = 1;
}

//+-------------------------------------------------------------------------
//
//  Method:     CSegmentListIterator::~CSegmentListIterator
//
//  Synopsis:   Destructor for our Segment list iterator.
//
//  Arguments:  VOID
//
//  Returns:    VOID
//
//--------------------------------------------------------------------------
CSegmentListIterator::~CSegmentListIterator()
{
    
}

//+-------------------------------------------------------------------------
//
//  Method:     CSegmentListIterator::Init
//
//  Synopsis:   Initializes our segment list iterator
//
//  Arguments:  pFirst = Pointer to first segment
//
//  Returns:    HRESULT indicating success
//
//--------------------------------------------------------------------------
HRESULT
CSegmentListIterator::Init(CSegment *pFirst)
{   
    _pFirst = pFirst;
    _pCurrent = pFirst;
        
    RRETURN(S_OK);
}

//+-------------------------------------------------------------------------
//
//  Method:     CSegmentListIterator::First
//
//  Synopsis:   Resets the iterator
//
//  Arguments:  VOID
//
//  Returns:    HRESULT indicating success
//
//--------------------------------------------------------------------------
HRESULT 
CSegmentListIterator::First()
{
    return Init(_pFirst);
}

//+-------------------------------------------------------------------------
//
//  Method:     CSegmentListIterator::Current
//
//  Synopsis:   Returns the current ISegment position of the iterator.
//
//  Arguments:  ppISegment = OUTPUT pointer to an ISegment which will contain
//                the current segment for this iterator.
//
//  Returns:    HRESULT indicating success
//
//--------------------------------------------------------------------------
HRESULT 
CSegmentListIterator::Current(ISegment **pISegment)
{
    HRESULT hr = E_FAIL;

    Assert( pISegment != NULL );
    
    if( (_pCurrent != NULL) && (pISegment != NULL ) )
    {
        hr = _pCurrent->QueryInterface(IID_ISegment, (void **)pISegment);
    }

    RRETURN(hr);        
}

//+-------------------------------------------------------------------------
//
//  Method:     CSegmentListIterator::IsDone
//
//  Synopsis:   Returns whether or not we have iterated past the end of our
//              list.
//
//  Arguments:  VOID
//
//  Returns:    S_OK    = There are no more elements
//              S_FALSE = There are more elements
//
//--------------------------------------------------------------------------
HRESULT
CSegmentListIterator::IsDone(void)
{
    return (_pCurrent == NULL) ? S_OK : S_FALSE;
}

//+-------------------------------------------------------------------------
//
//  Method:     CSegmentListIterator::Advance
//
//  Synopsis:   Advances the iterator by one element.
//
//  Arguments:  VOID
//
//  Returns:    S_OK    = The iterator was advanced successfully
//              S_FALSE = The advance operation failed
//
//--------------------------------------------------------------------------
HRESULT
CSegmentListIterator::Advance(void)
{
    HRESULT hr = S_FALSE;

    if( IsDone() == S_FALSE )
    {
        _pCurrent = _pCurrent->GetNext();
        hr = S_OK;
    }

    RRETURN1(hr, S_FALSE);
}

//+-------------------------------------------------------------------------
//
//  Method:     CSegmentListIterator::QueryInterface
//
//  Synopsis:   IUnknown QueryInterface implementation
//--------------------------------------------------------------------------
STDMETHODIMP
CSegmentListIterator::QueryInterface(
    REFIID              iid, 
    LPVOID *            ppvObj )
{
    if(!ppvObj)
        RRETURN(E_INVALIDARG);
  
    if( iid == IID_IUnknown || iid == IID_ISegmentListIterator )
    {
        *ppvObj = (ISegmentListIterator *)this;
    }
    else
    {
        *ppvObj = NULL;
        RRETURN_NOTRACE(E_NOINTERFACE);
    }

    ((IUnknown *)(*ppvObj))->AddRef();

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\text\tpointer.cxx ===
#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_TPOINTER_HXX_
#define X_TPOINTER_HXX_
#include "tpointer.hxx"
#endif

#ifndef X_TREEPOS_HXX_
#define X_TREEPOS_HXX_
#include "treepos.hxx"
#endif

#ifndef X_WCHDEFS_H_
#define X_WCHDEFS_H_
#include "wchdefs.h"
#endif

#ifndef X_QI_IMPL_H_
#define X_QI_IMPL_H_
#include "qi_impl.h"
#endif

#ifndef X_FLOWLYT_HXX_
#define X_FLOWLYT_HXX_
#include "flowlyt.hxx"
#endif

#ifndef X_TOMCONST_H_
#define X_TOMCONST_H_
#include "tomconst.h"
#endif

#ifndef X_BREAKER_HXX_
#define X_BREAKER_HXX_
#include "breaker.hxx"
#endif

#ifndef X_ROOTELEM_HXX_
#define X_ROOTELEM_HXX_
#include "rootelem.hxx"
#endif

#ifndef X__TEXT_H_
#define X__TEXT_H_
#include "_text.h"
#endif

DeclareTagOther(tagMarkupPointerAlwaysEmbed, "MarkupPointer", "Force embedding of all markup pointers");

MtDefine(CMarkupPointer, Tree, "CMarkupPointer");

#if DBG == 1 || defined(DUMPTREE)
int CMarkupPointer::s_NextSerialNumber = 1;
#endif

#if DBG == 1

void
SetDebugName ( IMarkupPointer * pIPointer, LPCTSTR strDbgName )
{
    CMarkupPointer * pPointer;

    IGNORE_HR( pIPointer->QueryInterface( CLSID_CMarkupPointer, (void **) & pPointer ) );

    pPointer->SetDebugName( strDbgName );
}

#endif


inline BOOL
IsValidGravity ( POINTER_GRAVITY eGravity )
{
    return eGravity == POINTER_GRAVITY_Left || eGravity == POINTER_GRAVITY_Right;
}

inline BOOL
IsValidAdjacency ( ELEMENT_ADJACENCY eAdj )
{
    return
        eAdj == ELEM_ADJ_BeforeBegin || eAdj == ELEM_ADJ_AfterBegin ||
        eAdj == ELEM_ADJ_BeforeEnd   || eAdj == ELEM_ADJ_AfterEnd;
}

void
EnsureLogicalOrder ( CMarkupPointer * & pStart, CMarkupPointer * & pFinish )
{
    Assert( pStart && pFinish );
    Assert( pStart->IsPositioned() && pFinish->IsPositioned() );
    Assert( pStart->Markup() == pFinish->Markup() );

    if (pStart->IsRightOf( pFinish ) )
    {
        CMarkupPointer * pTemp = pStart;
        pStart = pFinish;
        pFinish = pTemp;
    }
}

void
EnsureTotalOrder ( CTreePosGap * & ptpgStart, CTreePosGap * & ptpgFinish )
{
    CTreePos * ptpStart = ptpgStart->AdjacentTreePos( TPG_RIGHT );
    CTreePos * ptpFinish = ptpgFinish->AdjacentTreePos( TPG_RIGHT );
    
    Assert( ptpStart->GetCp() <= ptpFinish->GetCp() );

    if (ptpStart == ptpFinish)
        return;

    //
    // Move the finish as far to the right as possible without going over any content,
    // looking for the start.  If we find the start, then they are not ordered properly.
    //

    while ( ptpFinish->IsPointer() || ptpFinish->IsText() && ptpFinish->Cch() == 0 )
    {
        ptpFinish = ptpFinish->NextTreePos();

        if (ptpFinish == ptpStart)
        {
            CTreePosGap * ptpgTemp = ptpgStart;
            ptpgStart = ptpgFinish;
            ptpgFinish = ptpgTemp;

            return;
        }
    }
}

#if DBG == 1

CMarkupPointer::CMarkupPointer ( CDoc * pDoc )
  : _pDoc( pDoc ), _pMarkup( NULL ),
    _pmpNext( NULL ), _pmpPrev( NULL ),
    _fRightGravity( FALSE ), _fCling( FALSE ),
    _fEmbedded( FALSE ),
    _fKeepMarkupAlive( FALSE ), _fAlwaysEmbed( FALSE ),
    _ptpRef( NULL ), _ichRef( 0 ),
    _verCp( 0 ), _cpCache( -1 ),
    _nSerialNumber( s_NextSerialNumber++ )
{
}

void
CMarkupPointer::Validate ( ) const
{
    static BOOL fValidating = FALSE;

    if (fValidating)
        return;
            
    if (!IsPositioned())
    {
        Assert( _pmpNext == NULL );
        Assert( _pmpPrev == NULL );
        Assert( ! _fEmbedded );
        Assert( _cpCache == -1 );
        Assert( _verCp == 0 );
        Assert( _ptp == NULL );
        Assert( _ichRef == 0 );

        return;
    }

    Assert( ! _fAlwaysEmbed || _fEmbedded );

    static BOOL fValidatingAll = FALSE;
        
    if (IsPositioned() && !fValidatingAll)
    {
        fValidatingAll = TRUE;
        
        for ( CMarkupPointer * pmp = Markup()->_pmpFirst ; pmp ; pmp = pmp->_pmpNext )
        {
            if (pmp != this)
                pmp->Validate();
        }
        
        fValidatingAll = FALSE;
    }

    AssertSz(
        ! _fEmbedded || _ptpEmbeddedPointer->IsPointer(),
        "Embedded pointer does not point to pointer pos" );

    if (!_fEmbedded)
    {
        AssertSz( _ptpRef && ! _ptpRef->IsPointer(), "Bad position reference" );

        Assert( ! _ptpRef->IsText() || (_ichRef >= 0 && _ichRef <= _ptpRef->Cch()) );

        //
        // The only time it is ok for the ich to be 0 when on a zero length text
        // pos is when that text pos has a non zero text id.  This is so because
        // being after a zero sized id'ed chunk of text is accomplished by pointing
        // at the text pos and setting cch to zero.  Otherwise, if you want to be
        // before the text pos, point to the previous text pos.
        //

        if (_ptpRef->IsText() && _ichRef == 0 && _ptpRef->Cch() == 0)
            AssertSz( _ptpRef->TextID() != 0, "Ambiguous unembedded pointer position" );
    }
    else
    {
        Assert( _ptpEmbeddedPointer->IsPointer() );
        
        Assert( _ptpRef->MarkupPointer() == this );
        Assert( _ptpRef->Gravity() == Gravity() );
        Assert( _ptpRef->Cling() == Cling() );
        
        Assert( ! _pmpNext && ! _pmpNext );

        //
        // Make sure this pointer is NOT in it's markups list
        //

        for ( CMarkupPointer * p = Markup()->_pmpFirst ; p ; p = p->_pmpNext )
            AssertSz( p != this, "Embedded pointer is in unembedded list" );
    }

    //
    // Make sure the pointer is not in an inclusion
    //

    {
        CTreePos * ptp;
        long       ich;

        fValidating = TRUE;

        ptp = GetNormalizedReference( ich );

        fValidating = FALSE;
        
        if (ptp->IsNode() && !ptp->IsEdgeScope() && ptp->IsEndNode())
            AssertSz( 0, "Pointer in the middle of an inclusion" );

        ptp = ptp->NextTreePos();
        
        if (ptp->IsNode() && !ptp->IsEdgeScope() && ptp->IsBeginNode())
            AssertSz( 0, "Pointer in the middle of an inclusion" );
    }

    //
    // If we are caching a cp, compute it manually and make sure it is ok
    //
    
    AssertSz( ! CpIsCached() || GetCpSlow() == _cpCache, "Cached cp is not valid" );
}

#endif

inline void
CMarkupPointer::AddMeToList ( )
{
    Assert( Markup() );
    Assert( ! _pmpNext && ! _pmpPrev );
    
    CMarkupPointer * & pmpFirst = Markup()->_pmpFirst;

    _pmpNext = pmpFirst;
    
    if (pmpFirst)
        pmpFirst->_pmpPrev = this;
    
    pmpFirst = this;
}

inline void
CMarkupPointer::RemoveMeFromList ( )
{
    Assert( Markup() );

#if DBG == 1
    
    for ( CMarkupPointer * pmp = Markup()->_pmpFirst ; pmp ; pmp = pmp->_pmpNext )
    {
        if (pmp == this)
            break;
    }

    Assert( pmp );
    
#endif

    CMarkupPointer * & pmpFirst = Markup()->_pmpFirst;
    
    if (pmpFirst == this)
        pmpFirst = _pmpNext;

    if (_pmpPrev)
        _pmpPrev->_pmpNext = _pmpNext;

    if (_pmpNext)
        _pmpNext->_pmpPrev = _pmpPrev;

    _pmpNext = _pmpPrev = NULL;
}

//+----------------------------------------------------------------------------
//
//  Member:     GetNormalizedReference
//
//  Synopsis:   Returns a ptp/ich pair as far left as possible.  Basically,
//              skips past pointers and empty 0-textid text pos/
//
//-----------------------------------------------------------------------------

#if DBG!=1
#pragma optimize(SPEED_OPTIMIZE_FLAGS, on)
#endif

CTreePos *
CMarkupPointer::GetNormalizedReference ( long & ichOut ) const
{
    Assert( IsPositioned() );

    Validate();

    //
    // Unembedded pointers are already normalized!
    //

    if (!_fEmbedded)
    {
        ichOut = _ichRef;
        return _ptpRef;
    }
    
    for ( CTreePos * ptp = _ptpEmbeddedPointer ; ; )
    {
        ptp = ptp->PreviousTreePos();

        if (ptp->IsPointer())
            continue;

        if (ptp->IsText())
        {
            long cch = ptp->Cch();

            if (cch > 0)
            {
                ichOut = cch;
                return ptp;
            }

            //
            // Special case for text id, can have ich == 0 and cch = 0
            // when text has non zero ID.
            //
            
            if (ptp->TextID() != 0)
            {
                ichOut = 0;
                return ptp;
            }

            //
            // Skip past empty non-text id text pos
            //

            continue;
        }

        ichOut = 0;
        return ptp;
    }
}

HRESULT
CMarkupPointer::UnEmbed ( CTreePos * * pptpUpdate, long * pichUpdate )
{
    HRESULT    hr = S_OK;
    CTreePos * ptpSave;

    //
    // If we are already not embedded, then do nothing.
    //
    
    if (!IsPositioned() || !_fEmbedded)
        goto Cleanup;
    
    ptpSave = _ptpEmbeddedPointer;

    _ptpRef = GetNormalizedReference( _ichRef );
    
    
    AddMeToList();

    _fEmbedded = FALSE;

    //
    // Clear the CMarkupPointer pointer in the pos so that OnPositionReleased
    // isn't called, so we don't assume that the pointer is still embedded
    // and someone is taking it out of the tree (other than here).
    //
    
    ptpSave->SetMarkupPointer( NULL );
    
    hr = THR( Markup()->RemovePointerPos( ptpSave, pptpUpdate, pichUpdate ) );

    if (hr)
        goto Cleanup;

Cleanup:

    RRETURN( hr );
}

#if DBG!=1
#pragma optimize("", on)
#endif

///////////////////////////////////////////
//  CBase methods

const CMarkupPointer::CLASSDESC CMarkupPointer::s_classdesc =
{
    NULL,                               // _pclsid
    0,                                  // _idrBase
#ifndef NO_PROPERTY_PAGE
    0,                                  // _apClsidPages
#endif // NO_PROPERTY_PAGE
    NULL,                               // _pcpi
};

const CBase::CLASSDESC *
CMarkupPointer::GetClassDesc () const
{
    return &s_classdesc;
}

HRESULT
CMarkupPointer::PrivateQueryInterface ( REFIID iid, void ** ppv )
{
    if (ppv == NULL)
        return E_INVALIDARG;

    *ppv = NULL;

    switch (iid.Data1)
    {
        QI_INHERITS(this, IUnknown)
        QI_INHERITS(this, IMarkupPointer)
        QI_INHERITS(this, IMarkupPointer2)

    default:
        if (iid == CLSID_CMarkupPointer)
        {
            *ppv = this;
            return S_OK;
        }
        break;
    }

    if (!*ppv)
        RRETURN( E_NOINTERFACE );

    ((IUnknown *)*ppv)->AddRef();

    return S_OK;
}


///////////////////////////////////////////
//  IMarkupPointer methods

STDMETHODIMP
CMarkupPointer::OwningDoc ( IHTMLDocument2 ** ppDoc )
{
    HRESULT hr;
    CMarkup * pMarkup = Markup();

    if (!pMarkup)
        pMarkup = _pDoc->PrimaryMarkup();

    //
    // Ensure we have the primary markup or frame
    //
    pMarkup = pMarkup->GetFrameOrPrimaryMarkup();
    Assert( pMarkup );
       
    hr = pMarkup->EnsureDocument();
    if (hr)
        goto Cleanup;

    hr = pMarkup->Document()->QueryInterface(IID_IHTMLDocument2, (void **) ppDoc);

Cleanup:
    RRETURN(hr);
}


STDMETHODIMP
CMarkupPointer::Gravity ( POINTER_GRAVITY *peGravity )
{
    HRESULT hr = S_OK;

    if (!peGravity)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    *peGravity = Gravity() ? POINTER_GRAVITY_Right : POINTER_GRAVITY_Left;

Cleanup:

    RRETURN( hr );
}


STDMETHODIMP
CMarkupPointer::SetGravity ( POINTER_GRAVITY eGravity )
{
    HRESULT hr = S_OK;

    Assert( IsValidGravity( eGravity ) );

    if (!IsValidGravity( eGravity ))
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    _fRightGravity = eGravity == POINTER_GRAVITY_Right;

    //
    // Push the gravity to the pos if we are embedded
    //

    if (_fEmbedded)
        GetEmbeddedTreePos()->SetGravity( _fRightGravity );
    
Cleanup:

    RRETURN( hr );
}

STDMETHODIMP
CMarkupPointer::Cling ( BOOL * pfCling )
{
    HRESULT hr = S_OK;

    if (!pfCling)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    *pfCling = Cling();

Cleanup:

    RRETURN( hr );
}


STDMETHODIMP
CMarkupPointer::SetCling ( BOOL fCling )
{
    HRESULT hr = S_OK;

    _fCling = fCling;
    
    //
    // Push the cling to the pos if we are embedded
    //

    if (_fEmbedded)
        GetEmbeddedTreePos()->SetCling( _fCling );
    
    RRETURN( hr );
}

STDMETHODIMP
CMarkupPointer::MoveAdjacentToElement ( IHTMLElement *pIElement, ELEMENT_ADJACENCY eAdj )
{
    HRESULT hr;
    CElement * pElement;

    if (!IsValidAdjacency( eAdj ) || !pIElement || !_pDoc->IsOwnerOf( pIElement ))
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    hr = THR( pIElement->QueryInterface( CLSID_CElement, (void **) & pElement ) );

    if (hr)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    if (!pElement->IsInMarkup())
    {
        hr = CTL_E_UNPOSITIONEDELEMENT;
        goto Cleanup;
    }

    //
    // TODO (JHarding): can't get the root, we should assert here
    //
    if( pElement->Tag() == ETAG_ROOT && 
        ( eAdj == ELEM_ADJ_BeforeBegin || eAdj == ELEM_ADJ_AfterEnd ) )
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    hr = THR( MoveAdjacentToElement( pElement, eAdj ) );

    if (hr)
        goto Cleanup;

Cleanup:
    
    RRETURN( hr );
}


STDMETHODIMP
CMarkupPointer::MoveToPointer ( IMarkupPointer * pIPointer )
{
    HRESULT hr = S_OK;
    CMarkupPointer *pPointer;

    if (!pIPointer || !_pDoc->IsOwnerOf( pIPointer ))
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    hr = THR( pIPointer->QueryInterface( CLSID_CMarkupPointer, (void**) & pPointer) );

    if (hr)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    if (!pPointer->IsPositioned())
    {
        hr = THR( Unposition() );
        if( hr )
            goto Cleanup;
    }
    else
    {
        hr = THR( MoveToPointer( pPointer ) );
        if( hr )
            goto Cleanup;
    }

Cleanup:
    
    RRETURN( hr );
}

STDMETHODIMP
CMarkupPointer::MoveToContainer ( IMarkupContainer * pContainer, BOOL fAtStart )
{
    HRESULT     hr = S_OK;
    CMarkup *   pMarkup;

    if (!pContainer || !_pDoc->IsOwnerOf( pContainer ))
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    hr = THR( pContainer->QueryInterface( CLSID_CMarkup, (void **) & pMarkup ) );
    
    if (hr)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    hr = THR( MoveToContainer( pMarkup, fAtStart ) );

Cleanup:
    
    RRETURN( hr );
}


STDMETHODIMP
CMarkupPointer::IsPositioned ( BOOL * pfPositioned )
{
    HRESULT hr = S_OK;

    if (!pfPositioned)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    *pfPositioned = IsPositioned();

Cleanup:

    RRETURN( hr );
}

STDMETHODIMP
CMarkupPointer::GetContainer ( IMarkupContainer * * ppContainer )
{
    HRESULT   hr = S_OK;
    CMarkup * pMarkup;

    if (!ppContainer)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    *ppContainer = NULL;

    pMarkup = Markup();

    if (pMarkup)
    {
        hr = THR(
            pMarkup->QueryInterface(
                IID_IMarkupContainer, (void **) ppContainer ) );

        if (hr)
            goto Cleanup;
    }

Cleanup:

    RRETURN( hr );
}

#if DBG!=1
#pragma optimize(SPEED_OPTIMIZE_FLAGS, on)
#endif

STDMETHODIMP
CMarkupPointer::Unposition ( )
{
    HRESULT hr = S_OK;
    
    if (!IsPositioned())
        goto Cleanup;

    hr = THR( UnEmbed( NULL, NULL ) );

    if (hr)
        goto Cleanup;

    //
    // Remove from the unembeded list.  Remember, it can be
    // anywhere in the list.
    //

    RemoveMeFromList();

    //
    // Now, setting the markup to NULL will finally unposition it
    //
    
    SetMarkup(NULL);
    _ptpRef = NULL;
    _ichRef = 0;
    
    //
    // We have changed the position of the pointer, invalidate the
    // cp cache
    //
    
    _verCp = 0;
    _cpCache = -1;

    Validate();
    
Cleanup:
    
    RRETURN( hr );
}

#if DBG!=1
#pragma optimize("", on)
#endif


STDMETHODIMP
CMarkupPointer::Left (
    BOOL                  fMove,
    MARKUP_CONTEXT_TYPE * pContext,
    IHTMLElement * *      ppElement,
    long *                pcch,
    OLECHAR *             pchtext )
{
    return THR( There( TRUE, fMove, pContext, ppElement, pcch, pchtext, 0 ) );
}

STDMETHODIMP
CMarkupPointer::Right (
    BOOL                  fMove,
    MARKUP_CONTEXT_TYPE * pContext,
    IHTMLElement * *      ppElement,
    long *                pcch,
    OLECHAR *             pchText )
{
    return THR( There( FALSE, fMove, pContext, ppElement, pcch, pchText, 0 ) );
}

HRESULT
CMarkupPointer::There (
    BOOL                  fLeft,
    BOOL                  fMove,
    MARKUP_CONTEXT_TYPE * pContext,
    IHTMLElement * *      ppElement,
    long *                pcch,
    OLECHAR *             pchText,
    DWORD *               pdwFlags)
{
    HRESULT     hr;
    CTreeNode * pNode;

    pNode = NULL;

    hr = THR(
        There(
            fLeft, fMove, pContext,
            ppElement ? & pNode : NULL,
            pcch, pchText, NULL, pdwFlags ) );

    if (hr)
        goto Cleanup;

    if (ppElement)
    {
        *ppElement = NULL;

        if (pNode)
        {
            hr = THR( pNode->GetElementInterface( IID_IHTMLElement, (void * *) ppElement ) );
    
            if (hr)
                goto Cleanup;
        }
    }

Cleanup:

    RRETURN( hr );
}

#if DBG!=1
#pragma optimize(SPEED_OPTIMIZE_FLAGS, on)
#endif

HRESULT
CMarkupPointer::There (
    BOOL                  fLeft,
    BOOL                  fMove,
    MARKUP_CONTEXT_TYPE * pContext,
    CTreeNode * *         ppNode,
    long *                pcch,
    OLECHAR *             pchText,
    long *                plTextID,
    DWORD *               pdwFlags )
{
    HRESULT    hr = S_OK;
    long       cchIn = 0;
    CTreePos * ptp;
    long       ich;
    long       dcch;
    BOOL       fHitNode;

    Validate();
    
    //
    // We must assign something to all output params, even if they are
    // meaningless in the current context.
    //

    if (ppNode)
        *ppNode = NULL;

    if (pcch)
    {
        cchIn = *pcch;
        *pcch = 0;
    }

    if (plTextID)
        *plTextID = 0;

    if (pContext)
        *pContext = CONTEXT_TYPE_None;
    
    //
    // If we are unpositioned, then we have done all we have to do.
    //

    if (!IsPositioned())
        goto Cleanup;

    //
    // Get the current reference
    //

    if (_fEmbedded)
    {
        ptp = _ptpEmbeddedPointer;
        ich = 0;
    }
    else
    {
        ptp = _ptpRef;
        ich = _ichRef;
    }

    //
    // Compute the delta of characters moved, useful for updating cached cp.
    //

    dcch = 0;

    //
    // If the content we are adjacent to is a node, then set this var.
    //

    fHitNode = FALSE;

    //
    // The following will set ptp to either point to the edge we are to cross,
    // or set the ptp/ich pair to a significant text node.
    //

    if (fLeft)
    {
        for ( ; ; )
        {
            if (!ptp->IsPointer())
            {
                if (ptp->IsNode())
                {
                    fHitNode = TRUE;
                    break;
                }

                Assert( ptp->IsText() );

                if (ich > 0)
                    break;

                //
                // Check for an empty text pos with ID.  This is a empty
                // DOM text node.
                //

                Assert( ptp->Cch() == 0 );

                if (plTextID && ptp->TextID() != 0)
                    break;
            }

            ptp = ptp->PreviousTreePos();
            ich = ptp->IsText() ? ptp->Cch() : 0;
        }
    }
    else
    {
        for ( ; ; )
        {
            if (ptp->IsText() && ich < ptp->Cch())
                break;
            
            CTreePos * ptpNext = ptp->NextTreePos();

            if (!ptpNext->IsPointer())
            {
                if (ptpNext->IsNode())
                {
                    fHitNode = TRUE;
                    break;
                }

                Assert( ptpNext->IsText() );

                if (ptpNext->Cch())
                    break;

                if (plTextID && ptpNext->TextID() != 0)
                    break;
            }

            //
            // We should never attempt to cross over an empty dom text node.  We
            // should have broken out of hte loop by now in this case.
            //

            ptp = ptpNext;
            
            Assert( !plTextID || !ptp->IsText() || ptp->Cch() != 0 || ptp->TextID() != 0 );
            
            ich = 0;
        }
    }

    //
    // See if we stopped on a node
    //

    if (fHitNode)
    {
        long nIncl = 0;
        
        ptp = fLeft ? ptp : (dcch++, ptp->NextTreePos());

        Assert( ptp->IsNode() );
        
        //
        // Find the kernel of the inclusion
        //

        for ( nIncl = 0 ; ! ptp->IsEdgeScope() ; nIncl++ )
        {
            if (fLeft)
            {
                ptp = ptp->PreviousTreePos();
            }
            else
            {
                ptp = ptp->NextTreePos();
            }
        }

        //
        // Have we butted up against the edge of the container?
        //

        if (ptp->Branch()->Tag() == ETAG_ROOT)
            goto Cleanup;

        //
        // Return the node crossed
        //

        if (ppNode)
            *ppNode = ptp->Branch();

        //
        // If we are traveling left and encounter a begin node, or we are
        // traveling right and encounter an end node, then we have left the
        // scope of an element.  Otherwise we have entered the scope of an
        // element (the else clause)
        //

        if (fLeft && ptp->IsBeginNode() || !fLeft && ptp->IsEndNode())
        {
            //
            // We better not have left the scope of a no scope element, for
            // we never must ever get into one.
            //

            Assert( ! ptp->Branch()->Element()->IsNoScope() );

            //
            // When moving out of a slave, behave as if we're moving off
            // the edge of the tree (dbau): report no context, don't move the
            // pointer, and report no element.
            //
            
            if ((!pdwFlags || !(*pdwFlags & MPTR_SHOWSLAVE)) && ptp->Branch()->Element()->HasMasterPtr())
	    {
		if (ppNode)
		    *ppNode = NULL;

                goto Cleanup;
	    }

            if (pContext)
                *pContext = CONTEXT_TYPE_ExitScope;
        }
        else
        {
            //
            // If we have moved into the scope of a no scope element, then break
            // out to the other side.
            //

            if (ptp->Branch()->Element()->IsNoScope())
            {
                if (pContext)
                    *pContext = CONTEXT_TYPE_NoScope;

                Assert( nIncl == 0 );

                Assert(
                    ptp->Branch() ==
                        ptp->Branch()->Element()->GetFirstBranch() );

                if (fMove)
                {
                    //
                    // Skip over to the other side of the no scope element
                    //

                    if (fLeft)
                    {
                        dcch -= 1;
                        ptp->Branch()->Element()->GetTreeExtent( & ptp, NULL );
                    }
                    else
                    {
                        dcch += 1;
                        ptp->Branch()->Element()->GetTreeExtent( NULL, & ptp );
                    }
                }
            }
            else
            {
                if (pContext)
                    *pContext = CONTEXT_TYPE_EnterScope;
            }
        }

        //
        // Get out of the inclusion and position properly.
        //

        if (fLeft)
        {
            while ( nIncl-- )
                ptp = ptp->PreviousTreePos();

            Assert( ptp->IsNode() );
            
            ptp = ptp->PreviousTreePos();
            dcch--;

            ich = ptp->IsText() ? ptp->Cch() : 0;
        }
        else
        {
            while ( nIncl-- )
                ptp = ptp->NextTreePos();
            
            ich = 0;
        }
    }
    else
    {
        if (pContext)
            *pContext = CONTEXT_TYPE_Text;
        
#if DBG == 1
        if (fLeft)
            Assert( ptp->IsText() );
        else
            Assert( ptp->IsText() && ich < ptp->Cch() || ptp->NextTreePos()->IsText() );
#endif
        
        if (plTextID)
        {
            if (fLeft)
                *plTextID = ptp->TextID();
            else
            {
                if (ptp->IsText() && ich < ptp->Cch())
                    *plTextID = ptp->TextID();
                else
                    *plTextID = ptp->NextTreePos()->TextID();
            }
        }
            
        long cchWant = (pcch && cchIn >= 0) ? cchIn : INT_MAX;
        long cchLook = cchWant;

        //
        // Here we move accross up to cchLook text or until we hit a node or
        // text with a different ID.
        //

        if (fLeft)
        {
            for ( ; ; )
            {
                if (ich > 0)
                {
                    if (plTextID && ptp->TextID() != * plTextID)
                        break;

                    long dcch2 = min( cchLook, ich );
                    cchLook -= dcch2;
                    ich -= dcch2;
                    dcch -= dcch2;

                    if (ich == 0)
                    {
                        ptp = ptp->PreviousTreePos();
                        ich = ptp->IsText() ? ptp->Cch() : 0;
                    }

                    if (cchLook == 0)
                        break;
                }
                else
                {
                    if (ptp->IsText())
                    {
                        if (plTextID)
                        {
                            long textID = ptp->TextID();

                            if (textID != 0 && textID != * plTextID)
                                break;
                        }
                    }
                    else if (!ptp->IsPointer())
                    {
                        Assert( ptp->IsNode() );
                        break;
                    }

                    ptp = ptp->PreviousTreePos();
                    ich = ptp->IsText() ? ptp->Cch() : 0;
                }
            }
        }
        else
        {
            for ( ; ; )
            {
                long cch;
                
                if (ptp->IsText() && ich < (cch = ptp->Cch()))
                {
                    if (plTextID && ptp->TextID() != * plTextID)
                        break;

                    long dcch2 = min( cchLook, cch - ich );
#if 0
                    //
                    // Special flag to stop at CR or LF in text.  Only works
                    // when going to the right.
                    //
                    
                    if (pdwFlags && (*pdwFlags & MPTR_STOPATCRLF))
                    {
                        long cp = GetCp() + dcch;
                        CTxtPtr txtPtr( Markup(), cp );
                        
                        if (txtPtr.FindCrOrLf( dcch2 ) )
                        {
                            *pdwFlags |= MPTR_FOUNDCRLF;
                            
                            Assert( long( txtPtr.GetCp() ) >= cp );
                            
                            dcch2 = txtPtr.GetCp() - cp + 1;
                            
                            cchLook -= dcch2;
                            ich += dcch2;
                            dcch += dcch2;

                            break;
                        }
                    }
#endif

                    cchLook -= dcch2;
                    ich += dcch2;
                    dcch += dcch2;

                    if (cchLook == 0)
                        break;
                }
                else
                {
                    CTreePos * ptpNext = ptp->NextTreePos();

                    if (ptpNext->IsText())
                    {
                        if (plTextID)
                        {
                            long textID = ptpNext->TextID();

                            if (textID != 0 && *plTextID != textID)
                                break;
                        }
                    }
                    else if (!ptpNext->IsPointer())
                    {
                        Assert( ptpNext->IsNode() );
                        break;
                    }

                    ptp = ptpNext;
                    ich = 0;
                }
            }

            //
            // Might be on a text node with ich == 0 which is only allowed if it is
            // an empty text id'ed node.
            //

            if (ich == 0 && ptp->IsText() && ptp->Cch())
            {
                ptp = ptp->PreviousTreePos();
                ich = ptp->IsText() ? ptp->Cch() : 0;
            }
        }

        long cchFound = cchWant - cchLook;

        //
        // Return the number of chars found
        //
        
        if (pcch)
            *pcch = cchFound;

        //
        // Return the text moved over
        //

        if (pchText && cchFound > 0 && pcch && cchIn > 0)
        {
            long cp = GetCp();

            if (fLeft)
                cp -= cchFound;

            Verify( CTxtPtr( Markup(), cp ).GetRawText( cchFound, pchText ) );
        }
    }

    //
    // The ptp/ich pair should now indicate where we should move
    //

    if (fMove)
    {
        hr = THR(
            MoveToReference(
                ptp, ich, Markup(), CpIsCached() ? _cpCache + dcch : -1 ) );

        if (hr)
            goto Cleanup;
    }

Cleanup:

    RRETURN( hr );
}

#if DBG!=1
#pragma optimize("", on)
#endif

STDMETHODIMP
CMarkupPointer::MoveUnit( MOVEUNIT_ACTION muAction )
{
    RRETURN1( MoveUnitInternal( muAction, -1 ), S_FALSE );
}

STDMETHODIMP
CMarkupPointer::MoveUnitBounded( MOVEUNIT_ACTION muAction, IMarkupPointer * pmpBound )
{
    HRESULT          hr = S_OK;
    CMarkupPointer * pmpBoundary;

    if( !pmpBound || 
        !_pDoc->IsOwnerOf( pmpBound ) )
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    hr = THR( pmpBound->QueryInterface( CLSID_CMarkupPointer, (void **)&pmpBoundary ) );
    if( hr || !pmpBoundary->IsPositioned() )
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    hr = THR( MoveUnitInternal( muAction, pmpBoundary->GetCp() ) );

Cleanup:
    RRETURN1( hr, S_FALSE );
}

HRESULT
CMarkupPointer::MoveUnitInternal ( MOVEUNIT_ACTION muAction, long cpBoundary )
{
    HRESULT   hr = S_OK;
    long      cp;
    long      newcp;
    CTxtPtr   tp;
    long      action;
    BOOL      fForward = TRUE;

    Validate();
            
    if (!IsPositioned())
    {
        hr = CTL_E_UNPOSITIONEDPOINTER;
        goto Cleanup;
    }

    cp = GetCp();
    
    tp.Reinit( Markup(), cp );
    
    action = 0;
    
    switch( muAction )
    {
    case MOVEUNIT_PREVCHAR:
    case MOVEUNIT_NEXTCHAR:
        fForward = ( muAction == MOVEUNIT_NEXTCHAR );
        tp.MoveChar( fForward );
        break;
        
    case MOVEUNIT_PREVCLUSTERBEGIN:
    case MOVEUNIT_NEXTCLUSTERBEGIN:
        fForward = ( muAction == MOVEUNIT_NEXTCLUSTERBEGIN );
        tp.MoveCluster( fForward );
        break;
        
    case MOVEUNIT_PREVCLUSTEREND:
    case MOVEUNIT_NEXTCLUSTEREND:
        fForward = ( muAction == MOVEUNIT_NEXTCLUSTEREND );
        tp.MoveClusterEnd( fForward );
        break;
        
    case MOVEUNIT_PREVWORDBEGIN:
    case MOVEUNIT_NEXTWORDBEGIN:
    case MOVEUNIT_PREVWORDEND:
    case MOVEUNIT_NEXTWORDEND:
    case MOVEUNIT_PREVPROOFWORD:
    case MOVEUNIT_NEXTPROOFWORD:
        switch( muAction )
        {
            case MOVEUNIT_PREVWORDBEGIN:
                action = WB_MOVEWORDLEFT;
                break;
            case MOVEUNIT_NEXTWORDBEGIN:
                action = WB_MOVEWORDRIGHT;
                break;
            case MOVEUNIT_PREVWORDEND:
                action = WB_LEFTBREAK;
                break;
            case MOVEUNIT_NEXTWORDEND:
                action = WB_RIGHTBREAK;
                break;
            case MOVEUNIT_PREVPROOFWORD:
                action = WB_LEFT;
                break;
            case MOVEUNIT_NEXTPROOFWORD:
                action = WB_RIGHT;
                break;
        }
        // All of the forward word actions are defined as odd numbers,
        // so we can do this a little easier
        fForward = muAction & 1;
        tp.FindWordBreak( action );
        break;
        
    case MOVEUNIT_PREVURLBEGIN:
        fForward = FALSE;
        if( !tp.FindUrl( FALSE, TRUE, cpBoundary ) )
            tp.SetCp( cp );
        break;
        
    case MOVEUNIT_NEXTURLBEGIN:
        fForward = TRUE;
        if( !tp.FindUrl( TRUE, TRUE, cpBoundary ) )
            tp.SetCp( cp );
        break;
        
    case MOVEUNIT_PREVURLEND:
        fForward = FALSE;
        if( !tp.FindUrl( FALSE, FALSE, cpBoundary ) )
            tp.SetCp( cp );
        break;
        
    case MOVEUNIT_NEXTURLEND:
        fForward = TRUE;
        if( !tp.FindUrl( TRUE, FALSE, cpBoundary ) )
            tp.SetCp( cp );
        break;
        
    case MOVEUNIT_PREVSENTENCE:
    case MOVEUNIT_NEXTSENTENCE:
        fForward = ( muAction == MOVEUNIT_NEXTSENTENCE );
        tp.FindBOSentence( fForward );
        break;
        
    case MOVEUNIT_PREVBLOCK:
    case MOVEUNIT_NEXTBLOCK:
        fForward = ( muAction == MOVEUNIT_NEXTBLOCK );
        tp.FindBlockBreak( fForward );
        break;
        
#if DBG==1
    default:
        AssertSz( FALSE, "Invalid action" );
#endif
    }

    // If the tp moved somewhere, position us wherever it went
    newcp = tp.GetCp();

    // NOTE (johnbed) Due to a problem with moveunit, it is possible that
    // we will be compute a cp that is outside the document here. Fix it up
    // instead of asserting for now. This is raided bug assigned to TomFakes.
    // When it is fixed, this should be removed

    if( newcp < 1 )
        newcp = 1;
    
    if( newcp >= Markup()->Cch() )
        newcp = Markup()->Cch() -1;

    // Only move if we're within the boundary, or no boundary was given
    if( newcp != cp && ( cpBoundary == -1 || 
                       ( fForward && newcp <= cpBoundary ) ||
                       (!fForward && newcp >= cpBoundary ) ) )
        hr = THR( MoveToCp( newcp, Markup() ) );
    else
        hr = S_FALSE;

Cleanup:

    RRETURN1( hr, S_FALSE );
}


STDMETHODIMP
CMarkupPointer::CurrentScope ( IHTMLElement ** ppElemCurrent )
{
    HRESULT hr = S_OK;
    CTreeNode * pNode;

    if (!ppElemCurrent)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    *ppElemCurrent = NULL;
    
    pNode = CurrentScope();
    
    if (pNode)
    {
        hr = THR(
            pNode->GetElementInterface(
                IID_IHTMLElement, (void **) ppElemCurrent ) );

        if (hr)
            goto Cleanup;
    }

Cleanup:

    RRETURN( hr );
}

STDMETHODIMP
CMarkupPointer::FindText (
    OLECHAR *        pchFindText, 
    DWORD            dwFlags,
    IMarkupPointer * pIEndMatch, /* =NULL */
    IMarkupPointer * pIEndSearch /* =NULL */)
{
    HRESULT hr;
    CMarkupPointer *pEndMatch  = NULL;
    CMarkupPointer *pEndSearch = NULL;

    if (!IsPositioned())
    {
        hr = CTL_E_UNPOSITIONEDPOINTER;
        goto Cleanup;
    }
    
    //
    // Convert arguments, if necessary.
    //

    // Move this pointer to the end of the match
    
    if (pIEndMatch)
    {
        Assert( _pDoc->IsOwnerOf( pIEndMatch ) );

        hr = THR( pIEndMatch->QueryInterface( CLSID_CMarkupPointer, (void **) & pEndMatch) );
        if( hr )
        {
            hr = E_INVALIDARG;
            goto Cleanup;
        }
    }

    // Limit our search to this pointer.
    
    if (pIEndSearch)
    {
        hr = THR( pIEndSearch->QueryInterface( CLSID_CMarkupPointer, (void **) & pEndSearch ) );
        
        if (hr)
        {
            hr = E_INVALIDARG;
            goto Cleanup;
        }
    }

    hr = FindText( pchFindText, dwFlags, pEndMatch, pEndSearch ) ? S_OK : S_FALSE;

Cleanup:
    
    RRETURN1( hr, S_FALSE );
}

HRESULT
CMarkupPointer::SetTextIdentity ( CMarkupPointer * pPointerFinish, long * plTextID )
{
    HRESULT          hr = S_OK;
    CMarkupPointer * pPointerStart = this;
    CTreePosGap      tpgBegin, tpgEnd;

    Assert(
        IsPositioned() && pPointerFinish->IsPositioned() &&
        Markup() == pPointerFinish->Markup() );

#if DBG == 1
    Validate();
    if (pPointerFinish)
        pPointerFinish->Validate();
#endif

    hr = THR( Markup()->EmbedPointers() );

    if (hr)
        goto Cleanup;

    EnsureLogicalOrder( pPointerStart, pPointerFinish );

    Verify( ! tpgBegin.MoveTo( pPointerStart->GetEmbeddedTreePos(), TPG_LEFT ) );
    Verify( ! tpgEnd.MoveTo( pPointerFinish->GetEmbeddedTreePos(), TPG_LEFT ) );

    hr = THR( Markup()->SetTextID( & tpgBegin, & tpgEnd, plTextID ) );
    
    if (hr)
        goto Cleanup;

Cleanup:
    
    RRETURN( hr );
}

HRESULT
CMarkupPointer::FindTextIdentity ( long textID, CMarkupPointer * pPointerOtherEnd )
{
    HRESULT     hr = S_OK;
    CTreePosGap tpgBegin ( TPG_RIGHT );
    CTreePosGap tpgEnd ( TPG_LEFT );

#if DBG == 1
    Validate();
    if (pPointerOtherEnd)
        pPointerOtherEnd->Validate();
#endif

    if (!IsPositioned())
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    //
    // TODO (EricVas): This needs to be rewritten to not assume pointer pos's
    //

    hr = THR( Markup()->EmbedPointers() );

    if (hr)
        goto Cleanup;

    Verify( ! tpgBegin.MoveTo( GetEmbeddedTreePos(), TPG_LEFT ) );

    hr = THR( Markup()->FindTextID( textID, & tpgBegin, & tpgEnd ) );
    
    if (hr == S_FALSE)
        goto Cleanup;
    
    if (hr)
        goto Cleanup;

    hr = THR( MoveToGap( & tpgBegin, Markup() ) );

    if (hr)
        goto Cleanup;

    if (pPointerOtherEnd)
    {
        hr = THR( pPointerOtherEnd->MoveToGap( & tpgEnd, Markup() ) );
        
        if (hr)
            goto Cleanup;
    }

Cleanup:
    
    RRETURN1( hr, S_FALSE );
}


STDMETHODIMP
CMarkupPointer::IsInsideURL( IMarkupPointer * pIRight, BOOL * pfResult )
{
    HRESULT          hr = S_OK;
    CTxtPtr          tpThis, tpRight;
    BOOL             fFound  = FALSE;
    long             cpStart;
    long             cpEnd;

    if (!IsPositioned() || !pfResult || !pIRight || !_pDoc->IsOwnerOf( pIRight ))
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    tpThis.Reinit( Markup(), GetCp() );
    tpRight.Reinit( Markup(), GetCp() );
    
    if (tpThis.IsInsideUrl( & cpStart, & cpEnd ))
    {
        long cchOffset;
        CMarkupPointer * pRight;
        CTreePos * ptp;
        
        hr = THR( pIRight->QueryInterface( CLSID_CMarkupPointer, (void **) & pRight ) );

        if (hr)
        {
            hr = E_INVALIDARG;
            goto Cleanup;
        }

#if DBG==1
        SetDebugName(_T("Start Url"));
        pRight->SetDebugName(_T("End Url"));
#endif
        ptp = Markup()->TreePosAtCp( cpEnd, & cchOffset );

        hr = THR( MoveToCp( cpStart, Markup() ) );

        if (hr)
            goto Cleanup;

        if (ptp->IsNode())
        {
            CTreePosGap tpg ( ptp, TPG_LEFT );
        
            tpg.Move( TPG_LEFT, TPG_VALIDGAP | TPG_OKNOTTOMOVE );
        
            pRight->MoveToGap( & tpg, Markup() );
        }
        else
        {  
            pRight->MoveToCp( cpEnd, Markup() );
        }
        
        fFound = TRUE;
    }

Cleanup:
    
    *pfResult = fFound;
    
    RRETURN( hr );
}

long
CMarkupPointer::GetCpSlow ( ) const
{
    if (!IsPositioned())
        return -1;
    
    if (_fEmbedded)
        return _ptpEmbeddedPointer->GetCp();
    
    if (_ptpRef->IsText())
    {
        Assert( _ichRef >= 0 && _ichRef <= _ptpRef->Cch() );
        return _ptpRef->GetCp() + _ichRef;
    }
    
    Assert( _ichRef == 0 );
    
    return _ptpRef->GetCp() + _ptpRef->GetCch();
}

#define COMPARE(TYPE)                                                                      \
HRESULT                                                                                    \
CMarkupPointer::TYPE ( IMarkupPointer * pIPointerThat, BOOL * pfResult )                   \
{                                                                                          \
    HRESULT          hr;                                                                   \
    CMarkupPointer * pPointerThat;                                                         \
                                                                                           \
    if (!pIPointerThat || !pfResult)                                                       \
    {                                                                                      \
        hr = E_INVALIDARG;                                                                 \
        goto Cleanup;                                                                      \
    }                                                                                      \
                                                                                           \
    hr = pIPointerThat->QueryInterface( CLSID_CMarkupPointer, (void * *) & pPointerThat ); \
                                                                                           \
    if (hr)                                                                                \
    {                                                                                      \
        hr = E_INVALIDARG;                                                                 \
        goto Cleanup;                                                                      \
    }                                                                                      \
                                                                                           \
    if (!IsPositioned() || !pPointerThat->IsPositioned())                                  \
    {                                                                                      \
        hr = CTL_E_UNPOSITIONEDPOINTER;                                                    \
        goto Cleanup;                                                                      \
    }                                                                                      \
                                                                                           \
    if (Markup() != pPointerThat->Markup())                                                \
    {                                                                                      \
        hr = CTL_E_INCOMPATIBLEPOINTERS;                                                   \
        goto Cleanup;                                                                      \
    }                                                                                      \
                                                                                           \
    *pfResult = TYPE( pPointerThat );                                                      \
                                                                                           \
Cleanup:                                                                                   \
                                                                                           \
    RRETURN( hr );                                                                         \
}

COMPARE( IsLeftOf )
COMPARE( IsLeftOfOrEqualTo )
COMPARE( IsRightOf )
COMPARE( IsRightOfOrEqualTo )

#undef COMPARE

//
// IsEqualTo is different from the others because it is capable of
// dealing with unpositioned or incompatible markup pointers.
//

HRESULT
CMarkupPointer::IsEqualTo ( IMarkupPointer * pIPointerThat, BOOL * pfResult )
{
    HRESULT          hr;
    CMarkupPointer * pPointerThat;

    if (!pIPointerThat || !pfResult)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    hr = pIPointerThat->QueryInterface( CLSID_CMarkupPointer, (void * *) & pPointerThat );

    if (hr)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    if (!IsPositioned() || !pPointerThat->IsPositioned() || Markup() != pPointerThat->Markup())
    {
        *pfResult = FALSE;
        goto Cleanup;
    }
    
    *pfResult = IsEqualTo( pPointerThat );

Cleanup:

    RRETURN( hr );
}

HRESULT
OldCompare ( IMarkupPointer * p1, IMarkupPointer * p2, int * piResult )
{
    HRESULT hr = S_OK;
    BOOL    fResult;

    Assert( piResult );

    hr = THR( p1->IsEqualTo( p2, & fResult ) );

    if (hr)
        goto Cleanup;

    if (fResult)
    {
        *piResult = 0;
        goto Cleanup;
    }

    hr = THR( p1->IsLeftOf( p2, & fResult ) );

    if (hr)
        goto Cleanup;

    *piResult = fResult ? -1 : 1;

Cleanup:

    RRETURN( hr );
}

int
OldCompare ( CMarkupPointer * p1, CMarkupPointer * p2 )
{
    if (p1->IsEqualTo( p2))
        return 0;

    return p1->IsLeftOf( p2 ) ? -1 : 1;
}

void
CMarkupPointer::SetKeepMarkupAlive ( BOOL fKeepAlive )
{
    if (!!fKeepAlive == !!_fKeepMarkupAlive)
        return;

    _fKeepMarkupAlive = !!fKeepAlive;

    if (Markup())
    {
        if (_fKeepMarkupAlive)
            Markup()->PrivateAddRef();
        else
            Markup()->PrivateRelease();
    }
}

void
CMarkupPointer::SetAlwaysEmbed ( BOOL fAlwaysEmbed )
{
    if (!!fAlwaysEmbed == !!_fAlwaysEmbed)
        return;

    _fAlwaysEmbed = !!fAlwaysEmbed;

    if (IsPositioned() && !_fEmbedded && _fAlwaysEmbed)
        IGNORE_HR( Embed( Markup(), _ptpRef, _ichRef, CpIsCached() ? _cpCache : -1 ) );
}

HRESULT
CMarkupPointer::MoveAdjacentToElement ( CElement * pElement, ELEMENT_ADJACENCY adj )
{
    HRESULT hr = S_OK;
    CTreePos * ptp = NULL;
    BOOL fBefore = adj == ELEM_ADJ_BeforeBegin || adj == ELEM_ADJ_BeforeEnd;
    BOOL fBegin  = adj == ELEM_ADJ_BeforeBegin || adj == ELEM_ADJ_AfterBegin;
    TPG_DIRECTION eDir = fBefore ? TPG_LEFT : TPG_RIGHT;
    CTreePosGap tpg;

    Assert( pElement && IsValidAdjacency( adj ) );
    Assert( pElement->IsInMarkup() );
    Assert( ! ( pElement->Tag() == ETAG_ROOT &&
                ( adj == ELEM_ADJ_BeforeBegin || adj == ELEM_ADJ_AfterEnd ) ) );
    
    if (pElement->IsNoScope() &&
        (adj == ELEM_ADJ_AfterBegin || adj == ELEM_ADJ_BeforeEnd))
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    // find the TreePos where we're supposed to start looking
    
    pElement->GetTreeExtent(
        fBegin ? & ptp : NULL, fBegin ? NULL : & ptp );

    Assert( ptp );
    
    // move to the nearest legal position
    
    tpg.SetMoveDirection( eDir );
    
    hr = THR( tpg.MoveTo( ptp, eDir ) );

    if (hr)
        goto Cleanup;
    
    hr = THR( tpg.Move( TPG_VALIDGAP | TPG_OKNOTTOMOVE ) );

    if (hr)
        goto Cleanup;
    
    hr = THR( MoveToGap( & tpg, pElement->GetMarkup() ) );

Cleanup:

    RRETURN( hr );
}

HRESULT
CMarkupPointer::MoveToContainer ( CMarkup * pMarkup, BOOL fBegin, DWORD dwFlags )
{
    HRESULT     hr;
    CTreePos *  ptp = NULL;
    CTreePosGap tpg;
    CTreeNode * pNode;
    MARKUP_CONTEXT_TYPE context;

    Assert( pMarkup );
    Assert( pMarkup->Root() && pMarkup->Root()->Tag() == ETAG_ROOT );

    pMarkup->Root()->GetTreeExtent( fBegin ? & ptp : NULL, fBegin ? NULL : & ptp );

    Assert( ptp );

    hr = THR( tpg.MoveTo( ptp, fBegin ? TPG_RIGHT : TPG_LEFT ) );
    
    if (hr)
        goto Cleanup;

    hr = THR( MoveToGap( & tpg, pMarkup ) );

    {
        //
        // move inside TEXTSLAVE if present (as if the TEXTSLAVE element were not present - dbau)
        //
        
        hr = THR( There( ! fBegin, FALSE, &context, &pNode, NULL, NULL, NULL, 0 ) );
        
        if (hr)
            goto Cleanup;

        if (context == CONTEXT_TYPE_EnterScope && pNode && pNode->Element()->HasMasterPtr())
        {
            hr = THR( There( ! fBegin, TRUE, NULL, NULL, NULL, NULL, NULL, 0 ) );
            
            if (hr)
                goto Cleanup;
        }
    }

Cleanup:

    RRETURN( hr );
}


HRESULT
CMarkupPointer::MoveToPointer ( CMarkupPointer * pPointerThat )
{
    HRESULT    hr;
    CTreePos * ptp;
    long       ich;

    Validate();
            
    Assert( pPointerThat );
    Assert( pPointerThat->IsPositioned() );

    ptp = pPointerThat->GetNormalizedReference( ich );

    hr = THR(
        MoveToReference(
            ptp, ich, pPointerThat->Markup(),
            pPointerThat->CpIsCached() ? pPointerThat->_cpCache : -1 ) );

    if (hr)
        goto Cleanup;

Cleanup:

    RRETURN( hr );
}

void
CMarkupPointer::OnPositionReleased ( )
{
    Assert( _fEmbedded );
    Assert( ! _pmpNext && ! _pmpPrev );
    Assert( Markup() );
    Assert( _ptpEmbeddedPointer );
    Assert( _ichRef == 0 );

    _ptpEmbeddedPointer = NULL;
    _ichRef = 0;
    _fEmbedded = FALSE;
    SetMarkup(NULL);
    WHEN_DBG( _verCp = 0; )
    WHEN_DBG( _cpCache = -1; )
}

void 
CMarkupPointer::SetMarkup( CMarkup * pMarkup )
{
    if (_fKeepMarkupAlive)
    {
        CMarkup * pMarkupOld = _pMarkup;

        _pMarkup = pMarkup;

        if (_pMarkup)
            _pMarkup->PrivateAddRef();

        if (pMarkupOld)
            pMarkupOld->PrivateRelease();
    }
    else
    {
        _pMarkup = pMarkup;
    }
}

CTreeNode *
CMarkupPointer::CurrentScope ( DWORD dwFlags )
{
    CTreeNode * pNode;

    Validate();
    
    if (!IsPositioned())
        return NULL;

    pNode = Branch();

    if (pNode)
    {
        if (   pNode->Tag() == ETAG_ROOT
            && !pNode->_pElement->GetMasterPtr())
            return NULL;

        if (!(dwFlags & MPTR_SHOWSLAVE) && pNode->Element()->HasMasterPtr())
            return NULL;
    }

    return pNode;
}


BOOL
CMarkupPointer::FindText(
    TCHAR *          pchFindText, 
    DWORD            dwFlags, 
    CMarkupPointer * pEndMatch,
    CMarkupPointer * pEndSearch )
{
    long       cp;
    long       cpLimit = -1;
    CTxtPtr    tp;
    HRESULT    hr;

    Validate();
            
    Assert( IsPositioned() );
    
    cp = GetCp();
    
    tp.Reinit( Markup(), cp );

    if (pEndSearch)
    {
        Assert( pEndSearch->Markup() == Markup() );

        cpLimit = pEndSearch->GetCp();

        // Set direction based on the pointer, overriding flags
        // passed in, if necessary.
        
        if(cpLimit < cp)
            dwFlags |= FINDTEXT_BACKWARDS;
        else
            dwFlags &= ~FINDTEXT_BACKWARDS;
    }

    // ask the TP to find the text
    
    cp = tp.FindText( cpLimit, dwFlags, pchFindText, _tcslen( pchFindText ) );

    // if it succeeded, move myself accordingly

    if (cp < 0)
    {
        hr = S_FALSE;
        goto Cleanup;
    }

    hr = THR( MoveToCp( tp._cp, Markup() ) );

    if (hr)
        goto Cleanup;

    // Set end pointer, if requested

    if (pEndMatch)
    {
        hr = THR( pEndMatch->MoveToCp( cp, Markup() ) );

        if (hr)
            goto Cleanup;
    }

Cleanup:
    
    return hr == S_OK;
}

HRESULT 
CMarkupPointer::QueryBreaks ( DWORD * pdwBreaks )
{
    HRESULT          hr = S_OK;
    CTreePos *       ptp;
    long             ich;
    CTreePosGap      tpg;
    CLineBreakCompat breaker;

    Validate();
            
    Assert( pdwBreaks );

    *pdwBreaks = BREAK_NONE;

    if (!IsPositioned())
        goto Cleanup;

    ptp = GetNormalizedReference( ich );

    //
    // No breaks inside a text pos.  Also, we can't
    // position a gap inside a text pos.
    //

    if (ich > 0 && ich < ptp->Cch())
        goto Cleanup;
    
    hr = THR(
        tpg.MoveTo(
            ptp,
            ptp->IsText()
                ? (ich == 0 ? TPG_LEFT : TPG_RIGHT)
                : TPG_RIGHT ) );

    if (hr)
        goto Cleanup;

    hr = THR( breaker.QueryBreaks( & tpg, pdwBreaks ) );

    if (hr)
        goto Cleanup;

Cleanup:

    RRETURN( hr );
}

HRESULT
CMarkupPointer::MoveToOrphan ( CTreePos * ptp )
{
    HRESULT hr;
    
    Assert( ptp && ptp->IsPointer() && !ptp->MarkupPointer() );

    // if the pointer was already active, delete its old position

    hr = THR( Unposition() );

    if (hr)
        goto Cleanup;

    //
    // remember the new position
    //

    ptp->SetMarkupPointer( this );

    SetMarkup( ptp->GetMarkup() );
    _ptpEmbeddedPointer = ptp;
    _fEmbedded = TRUE;

    _cpCache = -1;
    _verCp = 0;
    
    _fRightGravity = ptp->Gravity();
    _fCling = ptp->Cling();

Cleanup:

    RRETURN( hr );
}

#if DBG!=1
#pragma optimize(SPEED_OPTIMIZE_FLAGS, on)
#endif

HRESULT
CMarkupPointer::MoveToReference (
    CTreePos * ptp, long ich, CMarkup * pMarkup, long cpNew )
{
    HRESULT hr;

    Assert( ptp && (ich == 0 || ich <= ptp->Cch()) );
    Assert( pMarkup && pMarkup == ptp->GetMarkup() );

    //
    // Make sure the ptp/ich are properly adjusted
    //

    while ( ptp->IsPointer() || (ich == 0 && ptp->IsText() && ptp->TextID() == 0) )
    {
        ptp = ptp->PreviousTreePos();
        ich = ptp->IsText() ? ptp->Cch() : 0;
    }

    Assert( !ptp->IsText() || ich != 0 || ptp->Cch() == 0 );

    hr = THR( UnEmbed( & ptp, & ich ) );

    if (hr)
        goto Cleanup;

    Assert( ! _fEmbedded );

    if (Markup() && Markup() != pMarkup)
    {
        RemoveMeFromList();
        SetMarkup( NULL );
    }

#if DBG == 1
    if (_fAlwaysEmbed || IsTagEnabled( tagMarkupPointerAlwaysEmbed ))
#else
    if (_fAlwaysEmbed)
#endif
    {
        if (Markup())
        {
            RemoveMeFromList();
            SetMarkup( NULL );
        }
        
        hr = THR( Embed( pMarkup, ptp, ich, cpNew ) );

        if (hr)
            goto Cleanup;
    }
    else
    {
        if (!Markup())
        {
            SetMarkup( pMarkup );
            AddMeToList();
        }

        _ptpRef = ptp;
        _ichRef = ich;

        if (cpNew == -1)
        {
            _verCp = 0;
            _cpCache = -1;
        }
        else
        {
            _cpCache = cpNew;
            _verCp = Markup()->GetMarkupContentsVersion();
            Assert( _cpCache == GetCpSlow() );
        }

        Assert( !_fEmbedded );
    }

    Validate();

Cleanup:

    RRETURN( hr );
}


HRESULT
CMarkupPointer::MoveToGap (
    CTreePosGap * ptpg, CMarkup * pMarkup, BOOL fForceEmbedding )
{
    HRESULT    hr = S_OK;
    CTreePos * ptp;
    long       ich;

    Validate();
            
    Assert( ptpg && pMarkup );
    Assert( ptpg->GetAttachedMarkup() );
    Assert( ptpg->GetAttachedMarkup() == pMarkup );

    //
    // pull the position out of the gap, then unposition the gap
    // because an embedding may be removed, one inserted or both.
    // All uses of MoveToGap must expect the gap to be unpositioned
    // upon return.
    //

    ptp = ptpg->AdjacentTreePos( TPG_LEFT );
    ich = ptp->IsText() ? ptp->Cch() : 0;

    ptpg->UnPosition();

    //
    // Make sure the ptp/ich are properly adjusted.  Only do this
    // if not forcing an embedding.  Forcing an embedding is used
    // to place an embedded pointer exactly at the place requested.
    //

    if (!fForceEmbedding && !_fAlwaysEmbed)
    {
        while ( ptp->IsPointer() || (ich == 0 && ptp->IsText() && ptp->TextID() == 0) )
        {
            ptp = ptp->PreviousTreePos();
            ich = ptp->IsText() ? ptp->Cch() : 0;
        }
        
        Assert( ! ptp->IsText() || ich != 0 || 0 == ptp->Cch() );

        hr = THR( MoveToReference( ptp, ich, pMarkup, -1 ) );

        if (hr)
            goto Cleanup;

        goto Cleanup;
    }

    if (IsPositioned())
    {
        if (_fEmbedded)
        {
            //
            // If this pointer is already embedded at the correct
            // location, then there is nothing to do!
            //
            
            if (ptp == _ptpEmbeddedPointer)
                goto Cleanup;
            
            //
            // Remove any existing embedding, making sure to update the
            // target ptp/ich.
            //

            hr = THR( UnEmbed( & ptp, & ich ) );

            if (hr)
                goto Cleanup;
        }

        RemoveMeFromList();
        SetMarkup(NULL);
    }

    hr = THR( Embed( pMarkup, ptp, ich, -1 ) );

    if (hr)
        goto Cleanup;
    
Cleanup:

    Validate();
    
    RRETURN( hr );
}

HRESULT
CMarkupPointer::Embed ( CMarkup * pMarkup, CTreePos * ptp, long ich, long cpNew )
{
    HRESULT hr = S_OK;
    CTreePos * ptpNew;
    
    Assert( ! IsPositioned() );
    Assert( ! _fEmbedded );

    Assert( pMarkup && ptp->GetMarkup() == pMarkup );

    //
    // See if we need to split a text pos
    //

    if (ich > 0 && ich < ptp->Cch())
    {
        CMarkupPointer * pmp;

        hr = THR( pMarkup->Split( ptp, ich ) );

        if (hr)
            goto Cleanup;

        //
        // See if other unembedded pointers were pointing at this text pos
        // after where we split it.  Update those where were.
        //

        for ( pmp = pMarkup->_pmpFirst ; pmp ; pmp = pmp->_pmpNext )
        {
            if (pmp->_ptpRef == ptp && pmp->_ichRef > ich)
            {
                pmp->_ichRef -= ich;
                pmp->_ptpRef = ptp->NextTreePos();
            }
        }

#if DBG == 1
        for ( pmp = pMarkup->_pmpFirst ; pmp ; pmp = pmp->_pmpNext )
            pmp->Validate();
#endif
    }

    //
    // Make a pointer pos and put it in the right place
    //

    ptpNew = pMarkup->NewPointerPos( this, Gravity(), Cling() );

    if (!ptpNew)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    hr = THR( pMarkup->Insert( ptpNew, ptp, FALSE ) );

    if (hr)
        goto Cleanup;

    SetMarkup( pMarkup );
    _ptpEmbeddedPointer = ptpNew;
    _ichRef = 0;
    _fEmbedded = TRUE;

    _cpCache = 0;
    _verCp = -1;

    Validate();

Cleanup:

    RRETURN( hr );
}

#if DBG!=1
#pragma optimize("", on)
#endif


HRESULT
CMarkupPointer::MoveToCp ( long cp, CMarkup * pMarkup )
{
    HRESULT    hr = S_OK;
    CTreePos * ptp;
    long       ich;

    Validate();
            
    ptp = pMarkup->TreePosAtCp( cp, & ich );

    if(!ptp)
        return E_FAIL;

    //
    // TreePosAtCp gives a ptp before the given cp.  Markup pointers refer to
    // a ptp as to pointing after.
    //

    if (!ptp->IsText() || ich == 0)
    {
        ptp = ptp->PreviousTreePos();

        while ( ptp->IsPointer() )
            ptp = ptp->PreviousTreePos();

        ich = ptp->IsText() ? ptp->Cch() : 0;
    }
    
    //
    // make sure the ptp is not in an inclusion
    //

    if (ptp->IsNode() && !ptp->IsEdgeScope() && ptp->IsEndNode())
    {
        while (ptp->IsNode() && !ptp->IsEdgeScope() && ptp->IsEndNode())
            ptp = ptp->PreviousTreePos();

        if (ptp->IsText())
            ich = ptp->Cch();
    }
    else if (ptp->IsNode())
    {
        CTreePos * ptpNext = ptp->NextTreePos();
        
        if (ptpNext->IsNode() && !ptpNext->IsEdgeScope() && ptpNext->IsBeginNode())
        {
            while (ptpNext->IsNode() && !ptpNext->IsEdgeScope() && ptpNext->IsBeginNode())
            {
                ptp = ptpNext;
                ptpNext = ptp->NextTreePos();
            }
        }
    }

    //
    // Make sure we're not positioned after a pointer
    //

    if (ptp->IsPointer())
    {
        while ( ptp->IsPointer() )
            ptp = ptp->PreviousTreePos();

        ich = ptp->IsText() ? ptp->Cch() : 0;
    }
    
    //
    // Make sure were no in the middle of a noscope
    //

    if (ptp->IsNode() && ptp->IsBeginElementScope() &&
        ptp->Branch()->Element()->IsNoScope())
    {
        ptp = ptp->Branch()->GetEndPos();
    }

    //
    //
    //
    
    Assert( ptp->IsNode() || ptp->IsText() );
    Assert( ich >= 0 && ich <= ptp->GetCch() );
    Assert( pMarkup == ptp->GetMarkup() );

    hr = THR( MoveToReference( ptp, ich, pMarkup, -1 ) );

    if (hr)
        goto Cleanup;

Cleanup:

    RRETURN( hr );
}

//
// GetBookmark/MoveToBookmark stuff - these are mainly pass-thrus to 
//  functions on CTxtPtr.
//

HRESULT
CMarkupPointer::MoveToBookmark ( BSTR bstrBookmark, CMarkupPointer * pEnd )
{
    HRESULT   hr = S_OK;
    CMarkup * pMarkup;

    Validate();
            
    Assert( pEnd );
    Assert( IsPositioned() );

    pMarkup = Markup();

    {
        CTxtPtr tpLeft ( pMarkup );
        CTxtPtr tpRight ( tpLeft );
        
        hr = THR( tpLeft.MoveToBookmark( bstrBookmark, & tpRight ) );

        if (hr)
            goto Cleanup;

        hr = THR( MoveToCp( tpLeft._cp, pMarkup ) );

        if (hr)
            goto Cleanup;
    
        hr = THR( pEnd->MoveToCp( tpRight._cp, pMarkup ) );

        if (hr)
            goto Cleanup;
    }

Cleanup:
    
    RRETURN1( hr, S_FALSE );
}


HRESULT
CMarkupPointer::GetBookmark ( BSTR * pbstrBookmark, CMarkupPointer * pEnd )
{
    HRESULT   hr      = S_OK;
    CMarkup * pMarkup = Markup();
    long      cp      = GetCp();

    Validate();
            
    Assert( pEnd );
    Assert( IsPositioned() && pEnd->IsPositioned() );
    Assert( Markup() == pEnd->Markup() );
    Assert( pbstrBookmark );

    {
        CTxtPtr tpThis ( pMarkup, cp );
        CTxtPtr tpEnd ( tpThis );
        
        tpEnd.SetCp( pEnd->GetCp() );

        hr = THR( tpThis.GetBookmark( pbstrBookmark, & tpEnd ) );

        if (hr)
            goto Cleanup;
    }

Cleanup:
    
    RRETURN( hr );
}

HRESULT
CMarkupPointer::IsAtWordBreak( BOOL * pfAtBreak )
{
    HRESULT     hr       = S_OK;

    Assert( pfAtBreak );
    Assert( IsPositioned() );

    if( !pfAtBreak || !IsPositioned() )
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    {
        CTxtPtr tp( Markup(), GetCp() );

        *pfAtBreak = tp.IsAtWordBreak();
    }

Cleanup:
    RRETURN( hr );
}

STDMETHODIMP
CMarkupPointer::GetMarkupPosition( long * plMP )
{
    HRESULT hr  = S_OK;

    Assert( plMP );

    if( !plMP )
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    if( !IsPositioned() )
    {
        *plMP = -1;
    }
    else
    {
        *plMP = GetCp();
    }

Cleanup:
    RRETURN( hr );
}

STDMETHODIMP
CMarkupPointer::MoveToMarkupPosition( IMarkupContainer * pContainer, long lMP )
{
    HRESULT     hr;
    CMarkup *   pMarkup = NULL;

    // If they didn't give us a container, we need to be positioned.
    // Otherwise, the container had better be valid.
    if( ( !pContainer && !IsPositioned() ) || ( pContainer && !_pDoc->IsOwnerOf( pContainer ) ) )
    {
        AssertSz( FALSE, "Bogus arguments for MoveToMarkupPosition" );

        hr = E_INVALIDARG;
        goto Cleanup;
    }

    if( pContainer )
    {
        hr = THR( pContainer->QueryInterface( CLSID_CMarkup, (void **)&pMarkup ) );
        if( hr )
        {
            AssertSz( FALSE, "Non-Markup passed to MoveToMarkupPosition" );

            hr = E_INVALIDARG;
            goto Cleanup;
        }
    }
    else
    {
        pMarkup = Markup();
    }

    // If they gave us -1, unposition the pointer
    if( lMP == -1 )
    {
        hr = THR( Unposition() );
        if( hr )
            goto Cleanup;
    }
    else
    {
        if( lMP < 1 || lMP >= pMarkup->Cch() )
        {
            AssertSz( FALSE, "Bogus MP for MoveToMarkupPosition" );

            hr = E_INVALIDARG;
            goto Cleanup;
        }


        hr = THR( MoveToCp( lMP, pMarkup ) );
        if( hr )
            goto Cleanup;
    }

Cleanup:
    
    RRETURN( hr );
}

HRESULT
CMarkupPointer::MoveToContent( IHTMLElement* pIElement, BOOL fAtStart )
{
    HRESULT hr ;
    CElement* pContentElement = NULL;
    
    Assert( pIElement );

    if ( ! pIElement )
    {   
        hr = E_INVALIDARG;
        goto Cleanup;
    }   
    hr = THR( pIElement->QueryInterface( CLSID_CElement, (void**) & pContentElement ));
    if (hr)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    if (!pContentElement->IsInMarkup())
    {
        hr = CTL_E_UNPOSITIONEDELEMENT;
        goto Cleanup;
    }
    

    if ( pContentElement->HasSlavePtr())
    {
        pContentElement = pContentElement->GetSlavePtr();
    }
    
    Assert( pContentElement );

    hr = THR( MoveAdjacentToElement( pContentElement, 
                                     fAtStart ? ELEM_ADJ_AfterBegin : ELEM_ADJ_BeforeEnd ));

    
Cleanup:
    RRETURN( hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\text\treepos.cxx ===
#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_TREEPOS_HXX_
#define X_TREEPOS_HXX_
#include "treepos.hxx"
#endif

#ifndef X_TPOINTER_HXX_
#define X_TPOINTER_HXX_
#include "tpointer.hxx"
#endif

#ifndef X_TXTSITE_HXX_
#define X_TXTSITE_HXX_
#include "txtsite.hxx"
#endif

#ifndef X_NOTIFY_HXX_
#define X_NOTIFY_HXX_
#include "notify.hxx"
#endif

#ifndef X_FLOWLYT_HXX_
#define X_FLOWLYT_HXX_
#include "flowlyt.hxx"
#endif

#ifndef X__TEXT_H_
#define X__TEXT_H_
#include "_text.h"
#endif

#ifndef X_CGLYPH_HXX_
#define X_CGLYPH_HXX_
#include "cglyph.hxx"
#endif

#ifndef X_MARKUPUNDO_HXX_
#define X_MARKUPUNDO_HXX_
#include "markupundo.hxx"
#endif

#ifndef X_ELIST_HXX_
#define X_ELIST_HXX_
#include "elist.hxx"
#endif

#ifndef X_ROOTELEM_HXX_
#define X_ROOTELEM_HXX_
#include "rootelem.hxx"
#endif

DeclareTag(tagTreePosOps,"TreePos","TreePos operations");
DeclareTag(tagTreePosAccess, "TreePos", "TreePos access");
DeclareTag(tagTreePosSplay, "TreePos", "Rebalancing");
DeclareTag(tagTreePosValidate, "TreePos", "Aggressive validation");
DeclareTag(tagTreePosNoCount, "TreePos", "Don't validate counts");
DeclareTag(tagDontSplay, "TreePos", "Don't splay tree");

DeclareTag(tagNotify,     "Notify",     "Trace notifications");
DeclareTag(tagNotifyPath, "NotifyPath", "Trace notification send");

MtDefine(CTreePos, Tree, "CTreePos");
MtDefine(CTreeDataPos, Tree, "CTreeDataPos");
MtDefine(CMarkup_pvPool, CMarkup, "CMarkup::_pvPool")
MtDefine(CChildIterator, Tree, "CChildIterator");

#pragma warning(disable:4706) /* assignment within conditional expression */

MtDefine(CDocExtra, Mem, "CDocExtra")
MtDefine(CAryNotify_aryANotification_pv, CDocExtra, "CDocExtra::_aryANotification::_pv")

// allocate this many CTreePos objects at a time
static const size_t s_cTreePosPoolSize = 64;

// splay when accessing something deeper than this
static const long s_cSplayDepth = 10;

// The tree pos SN pool
#if DBG == 1 || defined(DUMPTREE)
int CTreePos::s_NextSerialNumber = 0;
#endif

inline BOOL
CMarkup::ShouldSplay(long cDepth) const
{
    WHEN_DBG( if( IsTagEnabled( tagDontSplay ) ) return FALSE; );
    return cDepth > 4 && (cDepth > 30 || (0x1<<cDepth) > NumElems());
}

/////////////////////////////////////////////////////////////////////////
//          CTreePos
/////////////////////////////////////////////////////////////////////////

inline void
CTreePos::ClearCounts()
{
    SetElemLeft( 0 );
    _cchLeft = 0;
}

inline void
CTreePos::IncreaseCounts(const CTreePos *ptp, unsigned fFlags)
{
    if (fFlags & TP_LEFT)
    {
        AdjElemLeft(ptp->GetElemLeft());
        _cchLeft += ptp->_cchLeft;
    }
    if (fFlags & TP_DIRECT)
    {
        if (ptp->IsNode())
        {
            if( ptp->IsEdgeScope() )
            {
                _cchLeft += 1;
                if( ptp->IsBeginNode() )
                {
                    AdjElemLeft(1);
                }
            }
        }
        else if (ptp->IsText())
        {
            _cchLeft += ptp->Cch();
        }
    }
}

inline void
CTreePos::IncreaseCounts(const SCounts *pCounts )
{
    AdjElemLeft( pCounts->_cElem );
    _cchLeft += pCounts->_cch;
}

inline void
CTreePos::DecreaseCounts(const CTreePos *ptp, unsigned fFlags)
{
    if (fFlags & TP_LEFT)
    {
        AdjElemLeft(-ptp->GetElemLeft());
        _cchLeft -= ptp->_cchLeft;
    }
    if (fFlags & TP_DIRECT)
    {
        if (ptp->IsNode())
        {
            if( ptp->IsEdgeScope() )
            {
                _cchLeft -= 1;
                if( ptp->IsBeginNode() )
                {
                    AdjElemLeft( -1 );
                }
            }
        }
        else if (ptp->IsText())
        {
            _cchLeft -= ptp->Cch();
        }
    }
}


// functions for CTreePos::SCounts
inline void
CTreePos::SCounts::Clear()
{
    _cch = 0;
    _cElem = 0;
}


inline void
CTreePos::SCounts::Increase( const CTreePos * ptp )
{
    if (ptp->IsNode())
    {
        if( ptp->IsEdgeScope() )
        {
            _cch++;
            if( ptp->IsBeginNode() )
            {
                _cElem++;
            }
        }
    }
    else if (ptp->IsText())
    {
        _cch += ptp->Cch();
    }
}

inline BOOL
CTreePos::SCounts::IsNonzero()
{
    return _cElem  || _cch;
}


void
CTreePos::InitSublist()
{
    SetFirstChild(NULL);
    SetNext(NULL);
    MarkLast();
    MarkRight();        // this distinguishes a sublist from a splay tree root
    ClearCounts();
#if defined(MAINTAIN_SPLAYTREE_THREADS)
    SetLeftThread(NULL);
    SetRightThread(NULL);
#endif
}


inline void
CTreePos::ReplaceOrRemoveChild(CTreePos *pOld, CTreePos *pNew)
{
    if (pNew)
        ReplaceChild(pOld, pNew);
    else
        RemoveChild(pOld);
}


BOOL
CTreePos::HasNonzeroCounts(unsigned fFlags)
{
    BOOL result = FALSE;

    if (fFlags & TP_DIRECT)
    {
        Assert( !IsUninit() );
        result = result || !IsPointer();
    }

    if (fFlags & TP_LEFT)
    {
        result = result || GetElemLeft() > 0 || _cchLeft > 0;
    }

    return result;
}


#if DBG==1

inline BOOL
CTreePos::EqualCounts(const CTreePos *ptp) const
{
    return  GetElemLeft() == ptp->GetElemLeft() &&
            _cchLeft == ptp->_cchLeft;
}


BOOL
CTreePos::IsSplayValid(CTreePos *ptpTotal) const
{
    BOOL fIsValid = TRUE;
    CTreePos *ptpLeft, *ptpRight;
    const CTreePos *ptpFail = NULL;   // marks where we ran out of stack or memory
    const CTreePos *ptpCurr = this;
    enum { VISIT_FIRST, VISIT_MIDDLE, VISIT_LAST} state = VISIT_FIRST;
    CStackPtrAry<CTreePos*, 32> aryTreePosStack(Mt(Mem));
#define PUSH(stack, item)   stack.Append(item)
#define POP(stack)          stack[stack.Size()-1]; stack.Delete(stack.Size()-1)

    if( !IsTagEnabled( tagTreePosNoCount ) )
        ptpTotal->ClearCounts();

    while (fIsValid && ptpCurr)
    {
        switch (state)
        {
        case VISIT_FIRST:
            ptpCurr->GetChildren(&ptpLeft, &ptpRight);

            // verify structure
            if (ptpLeft)
            {
                
                fIsValid = fIsValid && ptpLeft->IsLeftChild() &&
                                    ptpLeft->Parent() == ptpCurr;
                Assert(fIsValid);
            }
            if (ptpRight)
            {
                fIsValid = fIsValid && !ptpRight->IsLeftChild() &&
                                    ptpRight->IsLastChild() &&
                                    ptpRight->Parent() == ptpCurr;
                Assert(fIsValid);
            }

            if( !IsTagEnabled( tagTreePosNoCount ) )
            {
                // push accumulated total onto the stack
                if (ptpFail == NULL)
                {
                    if (S_OK == PUSH(aryTreePosStack, ptpTotal))
                    {
                        ptpTotal = new CTreePos(TRUE);
                        if (ptpTotal == NULL)
                        {
                            ptpTotal = POP(aryTreePosStack);
                            ptpFail = ptpCurr;
                        }
                    }
                    else
                    {
                        ptpFail = ptpCurr;
                    }
                }
            }

            // advance into left subtree
            if (ptpLeft)
                ptpCurr = ptpLeft;
            else
                state = VISIT_MIDDLE;
            break;

        case VISIT_MIDDLE:

            if( !IsTagEnabled( tagTreePosNoCount ) )
            {
                // compare true count from left subtree with count in current node,
                // then pop the stack
                if (ptpFail == NULL)
                {
                    fIsValid = fIsValid && ptpCurr->EqualCounts(ptpTotal);
                    Assert(fIsValid);
                    delete ptpTotal;
                    ptpTotal = POP(aryTreePosStack);
                }

                // accumulate counts
                ptpTotal->IncreaseCounts(ptpCurr, ptpFail ? TP_DIRECT : TP_BOTH);
            }

#if defined(MAINTAIN_SPLAYTREE_THREADS)
            // check the threads
            fIsValid = fIsValid &&
                        (ptpCurr->LeftThread() == NULL ||
                         ptpCurr->LeftThread()->RightThread() == ptpCurr);
            fIsValid = fIsValid &&
                        (ptpCurr->RightThread() == NULL ||
                         ptpCurr->RightThread()->LeftThread() == ptpCurr);
            Assert(fIsValid);
#endif

            // advance into right subtree
            ptpRight = ptpCurr->RightChild();
            if (ptpRight)
                ptpCurr = ptpRight, state = VISIT_FIRST;
            else
                state = VISIT_LAST;
            break;

        case VISIT_LAST:
            // advance to parent
            if (ptpCurr == ptpFail)
            {
                ptpFail = NULL;
            }
            state = ptpCurr->IsLeftChild() ? VISIT_MIDDLE : VISIT_LAST;
            ptpCurr = (ptpCurr == this) ? NULL : ptpCurr->Parent();
            break;
        }
    }

    Assert(!fIsValid || aryTreePosStack.Size() == 0);
    fIsValid = fIsValid && aryTreePosStack.Size() == 0;

    aryTreePosStack.DeleteAll();

    return fIsValid;
}

#endif


#if DBG!=1
#pragma optimize(SPEED_OPTIMIZE_FLAGS, on)
#endif

void
CTreePos::GetChildren(CTreePos **ppLeft, CTreePos **ppRight) const
{
    if (FirstChild())
    {
        if (FirstChild()->IsLeftChild())
        {
            Assert(     (   FirstChild()->IsLastChild()     // Either just a left child, 
                         && FirstChild()->Next() == this )  // who's parent is me, or
                    ||  (   FirstChild()->Next()->IsLastChild()         // His next is the last child
                         &&!FirstChild()->Next()->IsLeftChild()         // NOT a left child
                         && FirstChild()->Next()->Next() == this ) );   // and his parent is me.
            *ppLeft = FirstChild();
            *ppRight = (FirstChild()->IsLastChild()) ? NULL : FirstChild()->Next();
        }
        else
        {
            Assert(     FirstChild()->IsLastChild() 
                    &&  FirstChild()->Next() == this );

            *ppLeft = NULL;
            *ppRight = FirstChild();
        }
    }
    else
    {
        *ppLeft = *ppRight = NULL;
    }
}


HRESULT
CTreePos::Remove()
{
    Assert(!HasNonzeroCounts(TP_DIRECT));    // otherwise we need to adjust counts to the root
    CTreePos *pLeft, *pRight, *pParent=Parent();

    GetChildren(&pLeft, &pRight);

    if (pLeft == NULL)
    {
        pParent->ReplaceOrRemoveChild(this, pRight);
    }
    else
    {
        while (pRight)
        {
            Assert( pParent == Parent() );

            pRight->RotateUp(this, pParent);
            pParent = pRight;       // Old right child is now parent
            pRight = RightChild();
        }
        Assert( pParent == Parent() );
        pParent->ReplaceChild(this, pLeft);
    }

#if defined(MAINTAIN_SPLAYTREE_THREADS)
    // adjust threads
    if (LeftThread())
        LeftThread()->SetRightThread(RightThread());
    if (RightThread())
        RightThread()->SetLeftThread(LeftThread());
    SetLeftThread(NULL);
    SetRightThread(NULL);
#endif

    return S_OK;
}


CTreePos *
CTreePos::LeftmostDescendant() const
{
    const CTreePos *ptp = this;
    const CTreePos *ptpLeft = FirstChild();

    while (ptpLeft && ptpLeft->IsLeftChild())
    {
        ptp = ptpLeft;
        ptpLeft = ptp->FirstChild();
    }

    return const_cast<CTreePos *>(ptp);
}


CTreePos *
CTreePos::RightmostDescendant() const
{
    CTreePos *ptp = const_cast<CTreePos*>(this);
    CTreePos *ptpRight = RightChild();

    while (ptpRight)
    {
        ptp = ptpRight;
        ptpRight = ptp->RightChild();
    }

    return ptp;
}


#if DBG==1
long
CTreePos::Depth() const
{
    long cDepth=0;
    const CTreePos *ptp;

    for (ptp=this; ptp; ptp=ptp->Parent())
    {
        ++ cDepth;
    }

    return cDepth-2;
}
#endif


CMarkup *
CTreePos::GetMarkup()
{
    CTreePos *ptp=this, *ptpParent=Parent();

    while (ptpParent)
    {
        ptp = ptpParent;
        ptpParent = ptp->Parent();
    }

    AssertSz(!ptp->IsLeftChild(), "GetList called when not in a CMarkup");
    return ptp->IsLeftChild() ? NULL
                              : CONTAINING_RECORD(ptp, CMarkup, _tpRoot);
}

CTreePos *
CTreePos::PreviousTreePos()
{
    CTreePos *ptp = this;
    
    // Do we have a left child?
    if (ptp->FirstChild() && ptp->FirstChild()->IsLeftChild())
    {
        // Rightmost descendent for ptp->LeftChild()
    Loop:
        ptp = ptp->FirstChild();
        
        while (ptp->FirstChild())
        {
            if (!ptp->FirstChild()->IsLeftChild())
                goto Loop;
            
            if (ptp->FirstChild()->IsLastChild())
            {
                Assert(ptp == _ptpThreadLeft); // MAINTAIN_SPLAYTREE_THREADS
                return ptp;
            }
                
            ptp = ptp->FirstChild()->Next();
        }

        Assert(ptp == _ptpThreadLeft); // MAINTAIN_SPLAYTREE_THREADS
        return ptp;
    }
    
    // No left child
    while (ptp->IsLeftChild())
    {
        // ptp = ptp->Parent() -- inlined here
        if (ptp->IsLastChild())
            ptp = ptp->Next();
        else
            ptp = ptp->Next()->Next();

        // Root pos (marked as right child) protects us from NULL
    }
            
    // ptp = ptp->Parent() (we know ptp is a right (and last) child)
    ptp = ptp->Next();

    Assert(ptp == _ptpThreadLeft); // MAINTAIN_SPLAYTREE_THREADS
    return ptp;
}

CTreePos *
CTreePos::NextTreePos()
{
    CTreePos *ptp;
    
    if (!FirstChild())
        goto Up;

    if (!FirstChild()->IsLeftChild())
    {
        ptp = FirstChild();
        goto Right;
    }

    if (FirstChild()->IsLastChild())
        goto Up;
    
    ptp = FirstChild()->Next();

Right:

    // Leftmost descendent

    while (ptp->FirstChild() && ptp->FirstChild()->IsLeftChild())
        ptp = ptp->FirstChild();

    Assert(ptp == _ptpThreadRight); // MAINTAIN_SPLAYTREE_THREADS
    return ptp;
    
Up:

    for (ptp = this; !ptp->IsLeftChild(); ptp = ptp->Next());

    ptp = ptp->Parent();
    
    if (ptp->Next() == NULL)
    {
        Assert(NULL == _ptpThreadRight); // MAINTAIN_SPLAYTREE_THREADS
        return NULL;
    }

    Assert(ptp == _ptpThreadRight); // MAINTAIN_SPLAYTREE_THREADS
    return ptp;
}
        

CTreePos *
CTreePos::NextValidNonPtrInterLPos()
{
    CTreePos *ptp = this;

    do
    {
        ptp = ptp->NextValidInterLPos();
    }
    while (ptp && ptp->IsPointer());

    return ptp;
}

CTreePos *
CTreePos::PreviousValidNonPtrInterLPos()
{
    CTreePos *ptp = this;

    do
    {
        ptp = ptp->PreviousValidInterLPos();
    }
    while (ptp && ptp->IsPointer());

    return ptp;
}

CTreePos *
CTreePos::NextNonPtrTreePos()
{
    CTreePos * ptp = this;

    do
    {
        ptp = ptp->NextTreePos();
    }
    while ( ptp && ptp->IsPointer() );

    return ptp;
}

CTreePos *
CTreePos::PreviousNonPtrTreePos()
{
    CTreePos * ptp = this;

    do
    {
        ptp = ptp->PreviousTreePos();
    }
    while ( ptp && ptp->IsPointer() );

    return ptp;
}

// NOTE (SamBent): deprecated.  use CTreePosGap::IsValid()
BOOL
CTreePos::IsLegalPosition(CTreePos *ptpLeft, CTreePos *ptpRight)
{
    // use the marks to determine if content is allowed between the inputs
    return (!ptpLeft->IsNode() || !ptpRight->IsNode() ||
             !( (ptpLeft->IsEndNode() && !ptpLeft->IsEdgeScope()) ||
                (ptpRight->IsBeginNode() && !ptpRight->IsEdgeScope()) ) );
}

CTreePos *
CTreePos::FindLegalPosition(BOOL fBefore)
{
    CTreePos *ptpCur, *ptpAdvance;
    CTreePos * (CTreePos::*pAdvanceFn)(void);

    // select the member function we use to advance
    pAdvanceFn = fBefore ? &CTreePos::PreviousTreePos : &CTreePos::NextTreePos;

    // advance to a legal position, or the end of the list
    ptpAdvance = this;
    do
    {
        ptpCur = ptpAdvance;
        ptpAdvance = (ptpAdvance->*pAdvanceFn)();
    }
    while (ptpAdvance &&
            ( fBefore ? !IsLegalPosition(ptpAdvance, ptpCur)
                      : !IsLegalPosition(ptpCur, ptpAdvance) ));

    return ptpAdvance ? ptpCur : NULL;
}

BOOL
CTreePos::ShowTreePos(CGlyphRenderInfoType *pRenderInfo)
{
    BOOL fRet;

    // 1) We can only show edge scopes
    // 2) We can only show explicit end tags
    if (   IsEdgeScope()
        &&  (  !IsEndNode()
             || Branch()->Element()->_fExplicitEndTag
            )
       )
    {
        CGlyphRenderInfoType renderInfo;
        if (pRenderInfo == NULL)
            pRenderInfo = &renderInfo;
        pRenderInfo->pImageContext = NULL;
        fRet = Branch()->GetMarkup()->GetTagInfo(this, GAT_COMPUTE, GPT_COMPUTE, GOT_COMPUTE, NULL, pRenderInfo) == S_OK;
        fRet = fRet && pRenderInfo->HasInfo();
    }
    else
        fRet = FALSE;
    return fRet;
}

CTreeNode *
CTreePos::SearchBranchForElement(CElement *pElement, BOOL fLeft)
{
    Assert(pElement);
    CTreePos *ptpLeft, *ptpRight;
    CTreeNode *pNode;

    // start at the requested gap
    if (fLeft)
    {
        ptpLeft = PreviousTreePos(),  ptpRight = this;
    }
    else
    {
        ptpLeft = this,  ptpRight = NextTreePos();
    }

    // move right to a valid gap (invalid gaps may give too high a scope)
    while (!IsLegalPosition(ptpLeft, ptpRight))
    {
        // but stop if we stumble across the element we're looking for
        if (ptpRight->IsNode() && ptpRight->Branch()->Element() == pElement)
        {
            return ptpRight->Branch();
        }

        ptpLeft = ptpRight;
        ptpRight = ptpLeft->NextTreePos();
    }

    // now search for a nearby node
    if (ptpLeft->IsNode())
    {
        pNode = ptpLeft->IsBeginNode() ? ptpLeft->Branch()
                                       : ptpLeft->Branch()->Parent();
    }
    else
    {
        while (!ptpRight->IsNode())
        {
            ptpRight = ptpRight->NextTreePos();
        }
        pNode = ptpRight->IsBeginNode() ? ptpRight->Branch()->Parent()
                                        : ptpRight->Branch();
    }

    // finally, look for the element along this node's branch
    for ( ; pNode; pNode = pNode->Parent())
    {
        if (pNode->Element() == pElement)
        {
            return pNode;
        }
    }

    return NULL;
}


long
CTreePos::SourceIndex()
{
    CTreePos *ptp;
    long cSourceIndex = GetElemLeft();
    BOOL fLeftChild = IsLeftChild();
    long cDepth = -1;
    CMarkup *pMarkup;
    CTreePos *pRoot = NULL;

    for (ptp = Parent();  ptp;  ptp = ptp->Parent())
    {
        if (!fLeftChild)
        {
            cSourceIndex += ptp->GetElemLeft() + (ptp->IsBeginElementScope()? 1: 0);
        }
        fLeftChild = ptp->IsLeftChild();

        ++cDepth;
        pRoot = ptp;
    }

    pMarkup = CONTAINING_RECORD(pRoot, CMarkup, _tpRoot);

    TraceTag((tagTreePosAccess, "%p: SourceIndex %ld  depth %ld",
            pMarkup, cSourceIndex, cDepth));

    if (pMarkup->ShouldSplay(cDepth))
    {
        Splay();
    }

    return cSourceIndex;
}

//
// Retunrs TRUE if this and ptpRight are separated only by
// pointers or empty text positions.  ptpRight must already
// be to the right of this.
//

BOOL
CTreePos::LogicallyEqual ( CTreePos * ptpRight )
{
    Assert( InternalCompare( ptpRight ) <= 0 );

    for ( CTreePos * ptp = this ;
          ptp->IsPointer() || (ptp->IsText() && ptp->Cch() == 0) ;
          ptp = ptp->NextTreePos() )
    {
        if (ptp == ptpRight)
            return TRUE;
    }

    return FALSE;
}
            
//
// Returns (not logically)
//
//   -1: this <  that
//    0: this == that
//   +1: this >  that
//

int
CTreePos::InternalCompare ( CTreePos * ptpThat )
{
    Assert( GetMarkup() && ptpThat->GetMarkup() == GetMarkup() );

    if (this == ptpThat)
        return 0;

    static long cSplayThis = 0;
    
    if (cSplayThis++ & 1)
    {
        CTreePos * ptpThis = this;

        ptpThis->Splay();

        for ( ; ; )
        {
            CTreePos * ptpChild = ptpThat;

            ptpThat = ptpThat->Parent();

            if (ptpThat == ptpThis)
                return ptpChild->IsLeftChild() ? +1 : -1;
        }
    }
    else
    {
        CTreePos * ptpThis = this;

        ptpThat->Splay();

        for ( ; ; )
        {
            CTreePos * ptpChild = ptpThis;

            ptpThis = ptpThis->Parent();

            if (ptpThis == ptpThat)
                return ptpChild->IsLeftChild() ? -1 : +1;
        }
    }
}

CTreeNode *
CTreePos::GetBranch ( ) const
{
    CTreePos * ptp = const_cast < CTreePos * > ( this );

    if (ptp->IsNode())
        return ptp->Branch();

    while ( ! ptp->IsNode() )
    {
        if (ptp->IsPointer() && ptp->GetWhitespaceParent())
        {
#if DBG==1
            CTreeNode *pWhitespaceParent = ptp->GetWhitespaceParent();

            while (!ptp->IsNode())
                ptp = ptp->PreviousTreePos();

            if (ptp->IsBeginNode())
            {
                Assert(ptp->Branch() == pWhitespaceParent );
            }
            else
            {
                Assert(ptp->Branch()->Parent() == pWhitespaceParent );
            }
            return pWhitespaceParent;
#else
            return ptp->GetWhitespaceParent();
#endif
        }
        ptp = ptp->PreviousTreePos();
    }

    Assert( ptp && (ptp->IsBeginNode() || ptp->IsEndNode()) );

    return ptp->IsBeginNode() ? ptp->Branch() : ptp->Branch()->Parent();
}

CTreeNode *
CTreePos::GetInterNode ( ) const
{
    CTreePos * ptp = const_cast < CTreePos * > ( this );

    while ( ! ptp->IsNode() )
        ptp = ptp->PreviousTreePos();

    Assert( ptp && (ptp->IsBeginNode() || ptp->IsEndNode()) );

    return ptp->IsBeginNode() ? ptp->Branch() : ptp->Branch()->Parent();
}

long
CTreePos::GetCp( WHEN_DBG(BOOL fNoTrace) )
{
    CTreePos *ptp;
    long cch = _cchLeft;
    BOOL fLeftChild = IsLeftChild();
    long cDepth = -1;
    CMarkup *pMarkup;
    CTreePos *pRoot = NULL;

    for (ptp = Parent();  ptp;  ptp = ptp->Parent())
    {
        if (!fLeftChild)
            cch += ptp->_cchLeft + ptp->GetCch();
        
        fLeftChild = ptp->IsLeftChild();

        ++cDepth;
        pRoot = ptp;
    }

    pMarkup = CONTAINING_RECORD(pRoot, CMarkup, _tpRoot);
    
#if DBG==1
    if (!fNoTrace)
    {
        TraceTag((tagTreePosAccess, "%p: GetCp cp %ld  depth %ld",
                pMarkup, cch, cDepth));
    }
#endif

    if ( WHEN_DBG( !fNoTrace && ) pMarkup->ShouldSplay(cDepth))
        Splay();

    return cch;
}

int
CTreePos::Gravity() const
{
    Assert( IsPointer() );
    return DataThis()->p._dwPointerAndGravityAndCling & 0x1;
}

void
CTreePos::SetGravity ( BOOL fRight )
{
    Assert( IsPointer() );

    DataThis()->p._dwPointerAndGravityAndCling =
        (DataThis()->p._dwPointerAndGravityAndCling & ~1) | (!!fRight);
}

int
CTreePos::Cling() const
{
    Assert( IsPointer() );
    return !!(DataThis()->p._dwPointerAndGravityAndCling & 0x2);
}

void
CTreePos::SetCling ( BOOL fStick )
{
    Assert( IsPointer() );

    DataThis()->p._dwPointerAndGravityAndCling =
        (DataThis()->p._dwPointerAndGravityAndCling & ~2) | (fStick ? 2 : 0);
}

void
CTreePos::SetScopeFlags(BOOL fEdge)
{
    long cElemDelta = IsBeginElementScope()? -1 : 0;
    long cchDelta = IsEdgeScope()? -1 : 0;

    SetFlags((GetFlags() & ~TPF_EDGE) | BOOLFLAG(fEdge, TPF_EDGE));

    if (IsBeginElementScope())
    {
        cElemDelta += 1;
    }

    if (IsEdgeScope())
    {
        cchDelta += 1;
    }

    if (cElemDelta != 0 || cchDelta != 0)
    {
        CTreePos *ptp;
        BOOL fLeftChild = IsLeftChild();

        for (ptp=Parent(); ptp; ptp = ptp->Parent())
        {
            if (fLeftChild)
            {
                ptp->AdjElemLeft(cElemDelta);
                ptp->_cchLeft += cchDelta;
            }
            fLeftChild = ptp->IsLeftChild();
        }
    }
}


void
CTreePos::ChangeCch(long cchDelta)
{
    BOOL fLeftChild = IsLeftChild();
    CTreePos *ptp;
#if DBG==1
    CTreePos *pRoot = NULL;
    CMarkup *pMarkup;
    long cDepth = -1;
#endif

    Assert( IsText() );

    DataThis()->t._cch += cchDelta;

    for (ptp=Parent(); ptp; ptp = ptp->Parent())
    {
        if (fLeftChild)
            ptp->_cchLeft += cchDelta;
        
        fLeftChild = ptp->IsLeftChild();

        WHEN_DBG( ++cDepth; )
        WHEN_DBG( pRoot = ptp; )
    }

    WHEN_DBG( pMarkup = CONTAINING_RECORD(pRoot, CMarkup, _tpRoot); )
    TraceTag((tagTreePosOps, "%p: ChangeCch by %ld to %ld", pMarkup, cchDelta, Cch()));
    TraceTag((tagTreePosAccess, "%p: ChangeCch depth %ld", pMarkup, cDepth));
}

//+----------------------------------------------------------------+
//
//  Method: MakeNonEdge
//
//  Synopsis: Turns an end node pos into a non-edge end node
//      pos, while updating all the statistics in the splay tree.
//      Can be called on a non-edge node pos, in which case it's a
//      no-op
//
//+----------------------------------------------------------------+

void
CTreePos::MakeNonEdge()
{
    Assert( IsEndNode() );

    // Already non-edge, so we're done.
    if( !IsEdgeScope() )
        return;

    SetScopeFlags( FALSE );
}


void
CTreePos::Splay()
{
    CTreePos *p=Parent(), *g=p->Parent(), *gg;   // parent, grandparent, great-grandparent
#if DBG==1
    long nZigZig=0, nZigZag=0, nZig=0;
    CMarkup *pMarkup;
#endif

    for (; g; p=Parent(), g=p->Parent())
    {
        gg = g->Parent();

        if (gg)
        {
            if (IsLeftChild() == p->IsLeftChild())      // zig-zig
            {
                p->RotateUp(g, gg);
                RotateUp(p, gg);
                WHEN_DBG( ++ nZigZig; )
            }
            else                                    // zig-zag
            {
                RotateUp(p, g);
                RotateUp(g, gg);
                WHEN_DBG( ++ nZigZag; )
            }
        }
        else                                        // zig
        {
            RotateUp(p, g);
            WHEN_DBG( ++ nZig; )
        }
    }

    WHEN_DBG( pMarkup = CONTAINING_RECORD(p, CMarkup, _tpRoot); )
    TraceTag((tagTreePosSplay, "%p: Splay  depth=%ld (%ld, %ld, %ld)",
                pMarkup, 2*(nZigZig+nZigZag) + nZig, nZigZig, nZigZag, nZig));

#if DBG==1
    if (IsTagEnabled(tagTreePosValidate))
    {
        CTreePos tpValid(TRUE);
        Assert(IsSplayValid(&tpValid));
    }
#endif
}


void
CTreePos::RotateUp(CTreePos *p, CTreePos *g)
{
    CTreePos *ptp1, *ptp2, *ptp3;

    Assert( Parent() == p && Parent()->Parent() == g );

    if (IsLeftChild())                    // rotate right
    {
        GetChildren(&ptp1, &ptp2);
        ptp3 = p->RightChild();
        g->ReplaceChild(p, this);

        // recreate my family
        if (ptp1)
        {
            ptp1->MarkFirst();
            ptp1->SetNext(p);
        }
        else
        {
            SetFirstChild(p);
        }

        // recreate p's family
        if (ptp2)
        {
            p->SetFirstChild(ptp2);
            ptp2->MarkLeft();
            if (ptp3)
            {
                ptp2->MarkFirst();
                ptp2->SetNext(ptp3);
            }
            else
            {
                ptp2->MarkLast();
                ptp2->SetNext(p);
            }
        }
        else
        {
            p->SetFirstChild(ptp3);
        }
        p->MarkRight();
        p->MarkLast();
        p->SetNext(this);

        // adjust cumulative counts
        p->DecreaseCounts(this, TP_BOTH);
    }

    else                                    // rotate left
    {
        ptp1 = p->LeftChild();
        GetChildren(&ptp2, &ptp3);
        g->ReplaceChild(p, this);

        // recreate my family
        SetFirstChild(p);
        p->MarkLeft();
        if (ptp3)
        {
            p->MarkFirst();
            p->SetNext(ptp3);
        }
        else
        {
            p->MarkLast();
            p->SetNext(this);
        }

        // recreate p's family
        if (ptp1)
        {
            if (ptp2)
            {
                ptp1->MarkFirst();  // CONSIDER (SamBent): not needed?
                ptp1->SetNext(ptp2);
            }
            else
            {
                ptp1->MarkLast();
                ptp1->SetNext(p);
            }
        }
        else
        {
            p->SetFirstChild(ptp2);
        }
        if (ptp2)
        {
            ptp2->MarkRight();
            ptp2->MarkLast();
            ptp2->SetNext(p);
        }

        // adjust cumulative counts
        IncreaseCounts(p, TP_BOTH);
    }

#if DBG==1
    if (IsTagEnabled(tagTreePosValidate))
    {
        CTreePos tpValid(TRUE);
        Assert(g->IsSplayValid(&tpValid));
    }
#endif
}


void
CTreePos::ReplaceChild(CTreePos *pOld, CTreePos *pNew)
{
    Assert( pOld->Parent() == this );

    pNew->MarkLeft(pOld->IsLeftChild());
    pNew->MarkLast(pOld->IsLastChild());
    pNew->SetNext(pOld->Next());

    if (FirstChild() == pOld)
        SetFirstChild(pNew);
    else
        FirstChild()->SetNext(pNew);
}


void
CTreePos::RemoveChild(CTreePos *pOld)
{
    Assert( pOld->Parent() == this );

    if (FirstChild() == pOld)
    {
        SetFirstChild(pOld->IsLastChild() ? NULL : pOld->Next());
    }
    else
    {
        FirstChild()->MarkLast();
        FirstChild()->SetNext(this);
    }
}


/////////////////////////////////////////////////////////////////////////
//          CMarkup stuff
/////////////////////////////////////////////////////////////////////////

HRESULT
CMarkup::DestroySplayTree( BOOL fReinit )
{
    HRESULT     hr = S_OK;
    CTreePos *  ptp, *ptpNext;
    CTreeNode * pDelayReleaseList = NULL;
    CTreeNode * pExitTreeScList = NULL;
    CNotification   nfExit;
    CRootElement * pElementRoot = Root();
    BOOL        fIsConnectedToPrimary = pElementRoot ? pElementRoot->IsConnectedToPrimaryMarkup() : FALSE;

    // Prime the exittree notification
    nfExit.ElementExittree1(NULL);
    Assert( nfExit.IsSecondChanceAvailable() );

    //
    // Unposition any unembedded markup pointers.  Because there is
    // no pointer pos for these pointers, they will not get notified.
    //

    while ( _pmpFirst )
    {
        hr = THR( _pmpFirst->Unposition() );

        if (hr)
            goto Cleanup;
    }
            
    //
    // The walk used here is destructive.  This is needed
    // because once a CTreePos is released (via ReleaseContents)
    // we can't use it any more.  So before we release a pos,
    // we short circuit other pointers in the tree to not point
    // to it any more.  This way, we only visit (and release) each
    // node only once.
    //

    // set a sentinel value to make the traversal end properly
    if (_tpRoot.FirstChild())
    {
        _tpRoot.FirstChild()->SetNext( NULL );
    }

    // release the tree
    for (ptp=_tpRoot.FirstChild(); ptp; )
    {
        // figure out the next to be deleted
        if (ptp->FirstChild())
        {
            ptpNext = ptp->FirstChild();

            // this is the short circuit
            if( ptpNext->IsLastChild() )
            {
                ptpNext->SetNext( ptp->Next() );
            }
            else
            {
                Assert( ptpNext->Next()->IsLastChild() );
                ptpNext->Next()->SetNext( ptp->Next() );
            }
        }
        else
        {
            ptpNext = ptp->Next();
        }

        if( ptp->IsNode() )
        {
            CTreeNode *     pNode = ptp->Branch();

            ReleaseTreePos( ptp, TRUE );

            if (!pNode->_fInMarkupDestruction)
            {
                pNode->_fInMarkupDestruction = TRUE;
            }
            else
            {
                BOOL    fDelayRelease = FALSE;
                BOOL    fExitTreeSc = FALSE;

                if (pNode->IsFirstBranch())
                {
                    // Prepare and send the exit tree notification
                    CElement *      pElement = pNode->Element();
                    DWORD           dwData = EXITTREE_DESTROY ;
                    WHEN_DBG( BOOL fPassivatePending = FALSE );

                    if (fIsConnectedToPrimary)
                    {
                        dwData |= EXITTREE_DOSURFACECOUNT;
                    }

                    if( pElement->GetObjectRefs() == 1 )
                    {
                        dwData |= EXITTREE_PASSIVATEPENDING;
                        Assert( !pElement->_fPassivatePending );
                        WHEN_DBG( pElement->_fPassivatePending = TRUE );
                        WHEN_DBG( fPassivatePending = TRUE );
                    }

                    pElement->_fExittreePending = TRUE;

                    // NOTE: we may want to bump up the notification SN here
                    nfExit.SetNode( NULL );
                    nfExit.SetElement(pElement);
                    nfExit.SetData( dwData );
                    pElement->Notify(&nfExit);

                    pElement->_fExittreePending = FALSE;

                    // Check to see if we have to delay release
                    fDelayRelease = nfExit.DataAsDWORD() & EXITTREE_DELAYRELEASENEEDED;

                    // Check to see if we have to send ElementExittreeSc
                    fExitTreeSc = nfExit.IsSecondChanceRequested();

                    if (!fDelayRelease && !fExitTreeSc)
                    {
                        // The node is now no longer in the tree so release
                        // the tree's ref on the node
                        pNode->PrivateExitTree();
                    }
                    else
                    {
                        // We will use the node as an item on our delay release
                        // linked list.  Make it dead and use useless fields
                        pNode->PrivateMakeDead();
                        pNode->GetBeginPos()->_pNext = (CTreePos*)pDelayReleaseList;
                        pDelayReleaseList = pNode;
                        pElement->AddRef();

                        WHEN_DBG( pElement->_fDelayRelease = TRUE );
                        WHEN_DBG( pElement->_fPassivatePending = FALSE );
                        WHEN_DBG( fPassivatePending = FALSE );

                        // If we need an exit tree second chance, link it into that list.
                        if( fExitTreeSc )
                        {
                            pNode->GetBeginPos()->_pFirstChild = (CTreePos*)pExitTreeScList;
                            pExitTreeScList = pNode;

                            nfExit.ClearSecondChanceRequested();
                        }
                    }

                    // Remove the element from the tree
                    pElement->__pNodeFirstBranch = NULL;
                    pElement->DelMarkupPtr();
                    pElement->PrivateExitTree(this);

#if DBG==1
                    if (fDelayRelease)
                    {
                        pElement->_fPassivatePending = fPassivatePending;
                    }
#endif

                }
                else
                {
                    // The node is now no longer in the tree so release
                    // the tree's ref on the node
                    pNode->PrivateExitTree();
                }
            }
        }
        else
        {
            ReleaseTreePos( ptp, TRUE );
        }

        ptp = ptpNext;
    }

    // release all the TreePos pools
    while (_pvPool)
    {
        void *pvNextPool = *((void **)_pvPool);

        if (_pvPool != & (_abPoolInitial[0]))
        {
            MemFree(_pvPool);
        }
        _pvPool = pvNextPool;
    }

    memset( & _tpRoot, 0, sizeof( CTreePos ) );
    _ptpFirst = NULL;
    Assert( _pvPool == NULL );
    _ptdpFree = NULL;
    memset( &_abPoolInitial, 0, sizeof( _abPoolInitial ) );

    _tpRoot.MarkLast();
    _tpRoot.MarkRight();

    WHEN_DBG( _cchTotalDbg = 0 );
    WHEN_DBG( _cElementsTotalDbg = 0 );

    if (fReinit)
    {
        hr = CreateInitialMarkup( pElementRoot );
        if (hr)
        {
            goto Cleanup;
        }
    }

    // Release and delete the text frag context
    delete DelTextFragContext();
    delete DelTopElemCache();

    UpdateMarkupTreeVersion();

    // Send all of the exit tree second chance notifications that we need to
    if (pExitTreeScList)
    {
        nfExit.ElementExittree2( NULL );
    }

    while( pExitTreeScList )
    {
        CElement *      pElement = pExitTreeScList->Element();

        // Get the next link in the list
        pExitTreeScList = (CTreeNode*)pExitTreeScList->GetBeginPos()->_pFirstChild;

        // Send the after exit tree notifications
        // NOTE: we may want to bump up the notification SN here
        nfExit.SetNode( NULL );
        nfExit.SetElement( pElement );
        pElement->Notify(&nfExit);
    }

    // Release all of the elements (and nodes) on our delay release list
    while( pDelayReleaseList )
    {
        CElement * pElement = pDelayReleaseList->Element();
        CTreeNode *pNode = pDelayReleaseList;

        // Get the next link in the list
        pDelayReleaseList = (CTreeNode*)pDelayReleaseList->GetBeginPos()->_pNext;

        // Release the element
        Assert( pElement->_fDelayRelease );
        WHEN_DBG( pElement->_fDelayRelease = FALSE );
        Assert( !pElement->_fPassivatePending || pElement->GetObjectRefs() == 1 );
        pElement->Release();

        // Release any hold the markup has on the node
        pNode->PrivateMarkupRelease();
    }


Cleanup:
    RRETURN(hr);
}

#pragma optimize("", on)

#if DBG==1

BOOL
CMarkup::IsSplayValid() const
{
    CTreePos tpValid(TRUE);
    BOOL result = _tpRoot.IsSplayValid(&tpValid);

    if (result)
    {
        Assert(result = (_ptpFirst == _tpRoot.LeftmostDescendant()));
    }

    return result;
}

#endif

//-----------------------------------------------------------------------------
//
//  Notification Methods
//
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
//
//  Member:     Notify
//
//  Synopsis:   Send a notification through the tree
//
//  Arguments:  pnf - The notification to send
//
//-----------------------------------------------------------------------------
void
CMarkup::Notify(
    CNotification * pnf )
{
    Assert(pnf);

    CDoc *pDoc = Doc();
    Assert( pDoc );

#if DBG == 1
    {
        BOOL    fQueue = ( pDoc->_fInSendAncestor && pnf->SendTo(NFLAGS_ANCESTORS));

        TraceTagEx((tagNotify, TAG_NONAME,
               "Notify    : (%d, %S) Element(0x%x,%S) Node(0x%x) cp(%d) cch(%d) %S",
               pnf->_sn,
               pnf->Name(),
               pnf->_pElement,
               (pnf->_pElement
                    ? pnf->_pElement->TagName()
                    : _T("")),
               pnf->_pNode,
               pnf->_cp,
               pnf->_cch,
               (fQueue
                    ? _T("QUEUED")
                    : _T(""))));
    }
#endif

    //
    //  If the branch was not supplied, infer it from the affected element
    //

    if (    !pnf->_pNode
        &&  pnf->_pElement)
    {
        pnf->_pNode = pnf->_pElement->GetFirstBranch();
    }

    Assert( pnf->_pNode
        ||  pnf->_pElement
        ||  pnf->IsTreeChange()
        ||  (   pnf->SendTo(NFLAGS_DESCENDENTS)
            &&  pnf->IsRangeValid()));
/*
    TODO (brendand, IE6 bug 56): These asserts fire when clearing the undo-stack. We need to fix that and
        enable these asserts. (brendand)
    Assert( !pnf->Node()
        ||  pnf->Node()->IsInMarkup());
    Assert( !pnf->Node()
        ||  pnf->Node()->GetMarkup() == this);
    Assert( !pnf->Element()
        ||  pnf->Element()->IsInMarkup());
    Assert( !pnf->Element()
        ||  pnf->Element()->GetMarkup() == this);
*/
    Assert( !pnf->SendTo(NFLAGS_ANCESTORS)
        ||  !pnf->SendTo(NFLAGS_DESCENDENTS));

    //
    //  Mark the document as dirty is requested
    //

    if (!pnf->IsFlagSet(NFLAGS_CLEANCHANGE))
    {
        SetModified();
    }

#if DBG==1
    //
    // Need to validate the change synchronously when the change is fired
    // (That is, the check cannot be queued since ValidateChange code can only handle
    //  one change at a time)
    //
    
    if (    pnf->IsTextChange()
        ||  pnf->IsTreeChange())
    {
        ValidateChange(pnf);
    }
#endif

    //
    //  If a notification is blocking the ancestor direction, queue the incoming notification
    //

    if (pDoc->_fInSendAncestor && pnf->SendTo(NFLAGS_ANCESTORS))
    {
        if (!pnf->IsFlagSet(NFLAGS_SYNCHRONOUSONLY))
        {
            if (pnf->Element())
            {
                pnf->Element()->AddRef();
                pnf->SetFlag(NFLAGS_NEEDS_RELEASE);
            }

            pDoc->_aryANotification.AppendIndirect(pnf);
        }
    }
    else
    {
        CDataAry<CNotification> *   paryNotification = pnf->SendTo(NFLAGS_ANCESTORS)
                                                            ? (CDataAry<CNotification> *)(&(pDoc->_aryANotification))
                                                            : NULL;

        if (!pnf->IsFlagSet(NFLAGS_DONOTBLOCK))
        {
            if (pnf->SendTo(NFLAGS_ANCESTORS))
            {
                pDoc->_fInSendAncestor = TRUE;
                pDoc->_pANotifyRootMarkup = this;
            }
        }

        SendNotification(pnf, paryNotification);

        Assert( !pDoc->_fInSendAncestor   || (pDoc->_pANotifyRootMarkup != this));
    }
    return;
}

//-----------------------------------------------------------------------------
//
//  Member:     ElementWantsNotification
//
//  Synopsis:   Check if an element may want to receive a notification
//
//  Arguments:  pElement - Element to notify
//              pnf      - Notification to send
//
//-----------------------------------------------------------------------------
#if DBG==1
BOOL
#else
inline BOOL
#endif
ElementWantsNotification(
    CElement *      pElement,
    CNotification * pnf)
{
    return  !pElement->_fExittreePending
        &&  (   pnf->IsForAllElements()
            ||  (   pElement->CurrentlyHasAnyLayout()
                &&  (   pnf->IsTextChange()
                    ||  pnf->IsTreeChange()
                    ||  pnf->IsLayoutChange()
                    ||  pnf->IsForLayouts()
                    ||  (   pnf->IsForPositioned()
                        &&  (   pElement->IsZParent()
                            ||  pElement->LayoutContainsRelative() ))
                    )
                )
            ||  (   (   IsPositionNotification(pnf)
// TODO (brendand, IE6 bug 59): Rework the categories to include the following:
//         1) text change
//         2) tree change
//         3) layout change
//         4) display change
//         Then, instead of testing for NTYPE_VISIBILITY_CHANGE etc., test for
//         display changes
                    ||  pnf->IsType(NTYPE_VISIBILITY_CHANGE))
                &&  !pElement->IsPositionStatic())
            ||  (   pnf->IsForActiveX()
                &&  pElement->TestClassFlag(CElement::ELEMENTDESC_OLESITE))
            ||  (   pnf->IsForFrameSites()
                    &&  ( pElement->Tag() == ETAG_IFRAME || pElement->Tag() == ETAG_FRAME )));
}


//-----------------------------------------------------------------------------
//
//  Member:     NotifyElement
//
//  Synopsis:   Notify a element of a notification
//
//  Arguments:  pElement - Element to notify
//              pnf      - Notification to send
//
//-----------------------------------------------------------------------------
#if DBG==1
void
#else
inline void
#endif
NotifyElement(
    CElement *      pElement,
    CNotification * pnf)
{
    Assert(pElement);
    Assert(ElementWantsNotification(pElement, pnf));
    Assert(!pnf->IsFlagSet(NFLAGS_SENDENDED));

    //  If element has layout(s), pass all notifications to all layouts except those meant
    //  for ActiveX elements
    //  NOTE: Notifications passed to a layout may not also sent to the element

    // Note that Notify() is now a virtual on CLayoutInfo.

    if ( !pnf->IsForActiveX())
    {
        // Send the notifcation to the layout, unless it is a text-change coming
        // from non-slave content (#90138). NotifyAncestors would already have
        // blocked such notifications coming from children, so we only need to
        // bother here about notification from self

        Assert(!(   pnf->IsTextChange()
                &&  pElement->HasSlavePtr()
                &&  pElement->GetFirstBranch()
                &&  pElement->GetFirstBranch()->AmIAncestorOf(pnf->Node())
            ));

        if (!(      pnf->IsTextChange()
                &&  pElement->HasSlavePtr()
                &&  pnf->Node()->Element() == pElement)
                &&  pElement->CurrentlyHasAnyLayout() )
        {
                TraceTagEx((tagNotifyPath, TAG_NONAME,
                           "NotifyPath: (%d) sent to pLayoutInfo(0x%x, %S)",
                           pnf->_sn,
                           pElement->GetLayoutInfo(),
                           pElement->TagName()));

                pElement->GetLayoutInfo()->Notify(pnf);

                if (    pnf->IsFlagSet(NFLAGS_SENDUNTILHANDLED)
                    &&  pnf->IsHandled())
                {
                    pnf->SetFlag(NFLAGS_SENDENDED);
                }
        }
    }

    //
    //  If not handled, hand appropriate notifications to the element
    //
    // (KTam) These look like the same conditions that ElementWantsNotification()
    // checks.  Why are we checking them again when we've already asserted that
    // ElementWantsNotification is true?

    if (    !pnf->IsFlagSet(NFLAGS_SENDENDED)
        &&  (   pnf->IsForAllElements()
            ||  (   pnf->IsForActiveX()
                &&  pElement->TestClassFlag(CElement::ELEMENTDESC_OLESITE))
            ||  (   (   IsPositionNotification(pnf)
// TODO (brendand, IE6 bug 59): Rework the categories to include the following:
//         1) text change
//         2) tree change
//         3) layout change
//         4) display change
//         Then, instead of testing for NTYPE_VISIBILITY_CHANGE etc., test for
//         display changes
                    ||  (   pnf->IsType(NTYPE_VISIBILITY_CHANGE)
                        &&  !pElement->ShouldHaveLayout()))
                &&  !pElement->IsPositionStatic())
            ||  (   pnf->IsForFrameSites()
                    &&  ( pElement->Tag() == ETAG_IFRAME || pElement->Tag() == ETAG_FRAME ))
            )
       )
    {
        TraceTagEx((tagNotifyPath, TAG_NONAME,
                   "NotifyPath: (%d) sent to pElement(0x%x, %S)",
                   pnf->_sn,
                   pElement,
                   pElement->TagName()));

        pElement->Notify(pnf);

        if (    pnf->IsFlagSet(NFLAGS_SENDUNTILHANDLED)
            &&  pnf->IsHandled())
        {
            pnf->SetFlag(NFLAGS_SENDENDED);
        }
    }
}


#if DBG==1
BOOL
#else
inline BOOL
#endif
NotifyTreeNode( CNotification *     pnf,
                CTreeNode *         pNode,
                BOOL                fBubbleUpViewTree,
                BOOL                fFromSlave)
{
    Assert(pnf);
    Assert(!!pnf->ShouldBubbleUpViewTree() == !!fBubbleUpViewTree);
    Assert(!pnf->IsFlagSet(NFLAGS_SENDENDED));
    Assert(pnf->Node());
    Assert(pNode);
    Assert(!(fBubbleUpViewTree && pNode->Element()->HasMasterPtr()));
    Assert(     pNode == pnf->Node()
            ||  pNode->AmIAncestorOf(pnf->Node())
            ||      fBubbleUpViewTree
                &&  pNode->Element()->HasSlavePtr()
                &&  pNode->Element()->GetSlaveIfMaster()->GetFirstBranch()
                &&  (   pNode->Element()->GetSlaveIfMaster()->GetFirstBranch() == pnf->Node()
                     || pNode->Element()->GetSlaveIfMaster()->GetFirstBranch()->AmIAncestorOf(pnf->Node())
                    )
          );
    Assert(!!fFromSlave == !!(fBubbleUpViewTree && pNode->Element()->HasSlavePtr()));

    CElement *  pElement    =   pNode->Element();

    if (fFromSlave && pnf->IsFlagSet(NFLAGS_LAZYRANGE))
    {
        long cp, cch;
        cch = pnf->Node()->Element()->GetFirstAndLastCp(&cp, NULL);
        pnf->SetTextRange(cp, cch);
    }

    if (ElementWantsNotification(pElement, pnf))
    {
        pElement->AddRef();

        NotifyElement(pElement, pnf);

        if (!pElement->IsInMarkup())
        {
            pNode = NULL;
        }
    
        pElement->Release();
    }

    if (!pNode || !pNode->Parent() || pnf->IsFlagSet(NFLAGS_SENDENDED))
        return FALSE;

    if (fFromSlave)
    {
        // Hack for INPUT
        // We know that INPUT's size is not affected by its content, so
        // none of the slave notifications need to beyond the INPUT.
        if (pElement->Tag() == ETAG_INPUT)
        {
            return FALSE;
        }

        pnf->SetNode(pNode);
        pnf->SetElement(pElement);
    }

    return TRUE; // TRUE => continue to bubble up the notification

}


//-----------------------------------------------------------------------------
//
//  Member:     NotifyAncestors
//
//  Synopsis:   Notify all ancestors of a CTreeNode
//
//  Arguments:  pnf - The notification to send
//
//-----------------------------------------------------------------------------
#if DBG==1
void
#else
inline void
#endif
NotifyAncestors(
    CNotification * pnf)
{
    Assert(pnf);
    Assert(pnf->Node());
    Assert(!pnf->IsFlagSet(NFLAGS_SENDENDED));

    if (pnf->IsTextChange())
    {
        // Text-change notifications are special. They walk up the source tree,
        // but also fire off laterally to master layouts. 
        CTreeNode *     pNode = pnf->Node();
        CElement *      pElemTarget;

        pNode = pnf->Node();

        for (;;)
        {
            if (pNode->Element()->HasMasterPtr())
            {
                // Fire off a separate notify on the master's layout
                pElemTarget = pNode->Element()->GetMasterIfSlave();
                if (    pElemTarget->CurrentlyHasAnyLayout() 
                    &&  pElemTarget->IsInMarkup())
                {
                    pElemTarget->GetLayoutInfo()->Notify(pnf);
                    Assert(pElemTarget->IsInMarkup());
                }
            }

            pNode = pNode->Parent();
            if (!pNode)
                break;

            if (pNode->Element()->CurrentlyHasAnyLayout() && !pNode->Element()->HasSlavePtr())
            {
                pNode->Element()->GetLayoutInfo()->Notify(pnf);
                Assert(pNode->IsInMarkup());
                Assert(pNode->Element()->IsInMarkup());
            }
            Assert(!pnf->IsFlagSet(NFLAGS_SENDENDED));
        }
    }
    else
    {
        // All other notifications (other than the text-change ones) fall into two two categories:
        // Those that bubble up the source tree (using the parent branch to walk up) and those that
        // bubble up the view tree (using the master branch if there is one and otherwise using the
        // parent branch).

        BOOL            fBubbleUpViewTree   = pnf->ShouldBubbleUpViewTree();
        CTreeNode *     pNode;
        CNotification   nfNew(*pnf);

        pNode = nfNew.Node();
        Assert(pNode);
        if (!(fBubbleUpViewTree && pNode->Element()->HasMasterPtr()))
        {
            pNode = pNode->Parent();
        }

        while (pNode)
        {
            BOOL fFromSlave = FALSE;

            if (fBubbleUpViewTree)
            {
                // Donm't want to bubble view notifications to parent
                // if parent has a slave (#101910)
                if (pNode->Element()->HasSlavePtr())
                    break;

                if (pNode->Element()->HasMasterPtr())
                {
                    fFromSlave = TRUE;
                    pNode = pNode->Element()->GetMasterIfSlave()->GetFirstBranch();
                    if (!pNode)
                        break;
                }
            }

            if (!NotifyTreeNode(&nfNew, pNode, fBubbleUpViewTree, fFromSlave))
                break;

            pNode = pNode->Parent();
        }

        if (nfNew.IsFlagSet(NFLAGS_SENDENDED))
        {
            pnf->SetFlag(NFLAGS_SENDENDED);
        }
    }
}



//-----------------------------------------------------------------------------
//
//  Member:     NotifyDescendents
//
//  Synopsis:   Notify decendents of a CTreeNode or range
//
//  Arguments:  pnf - The notification to send
//
//-----------------------------------------------------------------------------

MtDefine(BroadcastNotify, Metrics, "Full Tree Notifications");

#if DBG != 1
#pragma optimize(SPEED_OPTIMIZE_FLAGS, on)
#endif

void
CMarkup::NotifyDescendents( CNotification * pnf )
{
    CStackPtrAry < CElement *, 32 > aryElements( Mt( Mem ) );

    Assert( pnf->SendTo(NFLAGS_DESCENDENTS) );

#if DBG==1
    // Descendent notifications are order exempt so set their sn to 0xFFFFFFFF
    DWORD   snBefore = pnf->SerialNumber();
    pnf->_sn = (DWORD)-1;
#endif

    BOOL        fSCAvail = pnf->IsSecondChanceAvailable();

    Assert(pnf);
    Assert(  pnf->Element() || pnf->IsRangeValid() );
    Assert( !pnf->Element() || pnf->Element()->IsInMarkup() );
    Assert( !pnf->Element() || pnf->Element()->GetMarkup() == this );

    //
    // Build the list of descendent elements
    //

    BuildDescendentsList( &aryElements, pnf->Element(), pnf, TRUE /* exclude pnf->Element() */ );

    //
    //  Deliver the notification
    //

    if (aryElements.Size())
    {
        CElement **     ppElement;
        int             c;
        CNotification   nfSc;
        CNotification * pnfSend;

        if (fSCAvail)
        {
            nfSc.InitializeSc( pnf );
#if DBG==1
            //(dmitryt, IE6 28623)
            //see comment above about descendent notifications being exempt from SN counting.
            nfSc._sn = (DWORD)-1;
#endif
            pnfSend = &nfSc;
        }
        else
        {
            pnfSend = pnf;
        }

        for (   c = aryElements.Size(), ppElement = & (aryElements[0] );
                c > 0;
                c--, ppElement++ )
        {
            Assert( ppElement && *ppElement );

            if (!pnf->IsFlagSet( NFLAGS_SENDENDED ))
                NotifyElement(*ppElement, pnfSend);

            (*ppElement)->Release();
        }
    }

#if DBG==1
    // Reset the serial number on the notification
    pnf->_sn = snBefore;
#endif

#ifdef PERFMETER
    if (pnf->Element() == Root())
        MtAdd( Mt(BroadcastNotify), 1, aryElements.Size() );
#endif

}

#if DBG==1
void
#else
inline void
#endif
CMarkup::BuildDescendentsList( CStackPtrAry<CElement*,32> *paryElements,
                               CElement *pElement,
                               CNotification *pnf,
                               BOOL fExcludePassedElement // TRUE if pElement shouldn't be processed and potentially added to descendents list; FALSE for recursive calls only
                             )
{
    Assert(pnf);

    HRESULT     hr;

    CTreePos *  ptp;
    CTreePos *  ptpEnd;

    BOOL        fZParentsOnly = pnf->IsFlagSet( NFLAGS_ZPARENTSONLY );
    BOOL        fSCAvail = pnf->IsSecondChanceAvailable();
    BOOL        fBubbleDownViewTree = pnf->ShouldBubbleUpViewTree();

#if DBG
    CTreeNode * pNodeEnd;

    _cBuildDescListCallDepth++;
#endif

    //
    //  Determine the range
    //

    if ( pElement )
    {
        Assert( pElement->IsInMarkup() );
        Assert( pElement->GetMarkup() == this );

        pElement->GetTreeExtent( & ptp, & ptpEnd );

        Assert( ptp );
        
        // Generally fExcludePassedElement is TRUE, since we're interested
        // in "descendents", not "self + descendents".  We want it to be FALSE
        // for recursive calls however (since in those cases, "self" is
        // actually a descendant of the top-level pElement).
        if ( fExcludePassedElement )
            ptp = ptp->NextTreePos();  // start processing with the ptp _after_ the one beginning pElement

        if (pElement == Root() && !fSCAvail)
            paryElements->EnsureSize( paryElements->Size() + NumElems() );

        //
        // Recursively add elements from view slaves if the
        // notification is marked as "bubble through view tree"
        //

        if (fBubbleDownViewTree && (pElement->HasSlavePtr() && pElement->Tag() != ETAG_INPUT) )
        {
            // (dmitryt) don't let layoutChange notifications down into layoutRects
            // this will crash our non-incremental calc of layoutRects. (IE6 14804)
            if(!(pnf->IsLayoutChange() && pElement->IsLinkedContentElement()))
            {
                CElement *pSlaveElem = pElement->GetSlavePtr();
                pSlaveElem->GetMarkup()->BuildDescendentsList( paryElements, pSlaveElem, pnf, FALSE /* make sure pSlaveElem is processed! */ );
            }
        }
    }
    else
    {
        long cpStart, cpEnd, ich;

        AssertSz( _cBuildDescListCallDepth == 1, "Shouldn't have nested calls w/o an element!" );
        Assert( pnf->IsRangeValid() );

        cpStart = pnf->Cp(0);
        cpEnd   = cpStart + pnf->Cch(LONG_MAX);

        ptp     = TreePosAtCp( cpStart, & ich );
        ptpEnd  = TreePosAtCp( cpEnd, & ich );
    }

    if(!ptp || !ptpEnd)
        return;

    Assert( ptp );
    Assert( ptpEnd );
    Assert( ptp->InternalCompare( ptpEnd ) <= 0 );

    WHEN_DBG( pNodeEnd = CTreePosGap( ptpEnd, TPG_LEFT ).Branch(); )

    //
    //  Build a list of target elements
    //  (This allows the tree to change shape as the notification is delivered to each target)
    //

    while ( ptp && 
            ptp != ptpEnd )
    {
        if (ptp->IsBeginElementScope())
        {
            CTreeNode * pNode    = ptp->Branch();
            CElement *  pElement = pNode->Element();

            //
            //  Remember the element if it may want the notification
            //

            if (ElementWantsNotification( pElement, pnf ))
            {
                if (fSCAvail)
                {
                    if (!pnf->IsFlagSet( NFLAGS_SENDENDED ))
                        NotifyElement(pElement, pnf);

                    if (pnf->IsSecondChanceRequested())
                    {
                        hr = paryElements->Append( pElement );
                        if (hr)
                            goto Cleanup;

                        pElement->AddRef();
                        pnf->ClearSecondChanceRequested();
                    }
                }
                else
                {
                    hr = paryElements->Append( pElement );
                    if (hr)
                        goto Cleanup;

                    pElement->AddRef();
                }

                //
                // Recursively add elements from view slaves if the
                // notification is marked as "bubble through view tree"
                //

                if ( fBubbleDownViewTree && (pElement->HasSlavePtr() && pElement->Tag() != ETAG_INPUT) )
                {
                    // (dmitryt) don't let layoutChange notifications down into layoutRects
                    // this will crash our non-incremental calc of layoutRects. (IE6 14804)
                    if(!(pnf->IsLayoutChange() && pElement->IsLinkedContentElement()))
                    {
                        CElement *pSlaveElem = pElement->GetSlavePtr();
                        pSlaveElem->GetMarkup()->BuildDescendentsList( paryElements, pSlaveElem, pnf, FALSE /* make sure pSlaveElem is processed! */ );
                    }
                }
            }

            //
            //  Skip over z-parents (if requested)
            //

            if (fZParentsOnly)
            {
                BOOL fSkipElement;

                fSkipElement =  pNode->IsZParent()
                            ||  (   pnf->IsFlagSet(NFLAGS_AUTOONLY)
                                &&  pElement->ShouldHaveLayout()
                                &&  !pElement->GetUpdatedLayout()->_fAutoBelow);

                //
                // If the element should be skipped, then advance past it
                // (If the element has layout that overlaps with another layout that was not
                //  skipped, then this routine will only skip the portion contained in the
                //  non-skipped layout)
                //

                if (fSkipElement)
                {
                    Assert( !pNodeEnd->SearchBranchToRootForScope( pElement ) );

                    for ( ; ; )
                    {
                        CElement * pElementInner;

                        //
                        //  Get the ending treepos,
                        //  stop if it is for the end of the element
                        //

                        ptp = pNode->GetEndPos();
                        
                        Assert( ptp->IsEndNode() );

                        if (ptp->IsEdgeScope())
                            break;

                        //
                        //  There is overlap, locate the beginning of the next section
                        //  (Tunnel through the inclusions stopping at either the next begin
                        //   node for the current element, the end of the range, or if an
                        //   element with layout ends)
                        //

                        do
                        {
                            ptp           = ptp->NextTreePos();
                            pElementInner = ptp->Branch()->Element();
                            Assert(!ptp->IsEdgeScope()
                                ||  ptp->IsEndNode());
                        }
                        while ( pElementInner != pElement
                            &&  ptp != ptpEnd
                            &&  !(  ptp->IsEdgeScope()
                                &&  pElementInner->ShouldHaveLayout()));

                        //
                        //  If range ended, stop all searching
                        //

                        if (ptp == ptpEnd)
                            goto Cleanup;

                        //
                        //  If the end of an element with layout was encountered,
                        //  treat that as the end of the skipped over element
                        //

                        Assert( !ptp->IsEdgeScope()
                            ||  (   ptp->IsEndNode()
                                &&  pElementInner->ShouldHaveLayout()));

                        if (ptp->IsEdgeScope())
                            break;

                        //
                        //  Otherwise, reset the treenode and skip over the section of the element
                        //

                        Assert( ptp->IsBeginNode() && !ptp->IsEdgeScope() );

                        pNode = ptp->Branch();

                        Assert( pNode->Element() == pElement );
                    }
                }
            }
        }

        ptp = ptp->NextTreePos();
    }

Cleanup:
    WHEN_DBG( _cBuildDescListCallDepth-- );
}


#if DBG != 1
#pragma optimize("", on)
#endif


//-----------------------------------------------------------------------------
//
//  Member:     NotifyTreeLevel
//
//  Synopsis:   Notify objects listening at the tree level
//
//  Arguments:  pnf - Text change notification
//
//-----------------------------------------------------------------------------
void
CMarkup::NotifyTreeLevel(
    CNotification * pnf)
{
    Assert(!pnf->IsFlagSet(NFLAGS_SENDENDED));

    if (pnf->Type() == NTYPE_MARKUP_RENDER_STYLE)
    {
        if( _pHighlightRenSvcProvider )
        {
            _pHighlightRenSvcProvider->OnRenderStyleChange( pnf );
        }
    }
    
    if (pnf->Type() == NTYPE_DISPLAY_CHANGE)
    {
        CTreeNode *pNode = pnf->Node();
        //
        //  Notify the view of the change so that it will rehook the body/frameset display node
        //  when transitioning from display:none back to something visible.
        //  It might be best to instead move the view notifying block from the else below outside
        //  and before this if.  This fix is lower risk, but probably less correct. (greglett)
        //  Fixes #72530.
        //
        if (    pNode->Tag() == ETAG_BODY
            ||  pNode->Tag() == ETAG_FRAMESET)            
        {
            Doc()->GetView()->Notify(pnf);
        }

        while (pNode)
        {
            CElement *pElement = pNode->Element();
            if (pElement->HasFlag(TAGDESC_LIST))
            {
                DYNCAST(CListElement, pElement)->UpdateVersion();
                break;
            }
            pNode = pNode->Parent();
        }
    }
    else
    {
        //
        //  Notify the view of all layout changes
        //

        if (    !pnf->IsTextChange()
            &&  (   pnf->IsLayoutChange()
                ||  pnf->IsForLayouts()))
        {
            Doc()->GetView()->Notify(pnf);
        }
    }
    //
    //  Update the dirty range for any listeners
    //

    if (    pnf->IsTextChange()
        &&  HasChangeNotificationContext())
    {
        CMarkupChangeNotificationContext * pcnc = GetChangeNotificationContext();
        MarkupDirtyRange *          pdr  = pcnc->_aryMarkupDirtyRange;
        int                         cdr  = pcnc->_aryMarkupDirtyRange.Size();
        
        if (cdr && !pcnc->_fOnDirtyRangeChangePosted )
        {
            pcnc->_fOnDirtyRangeChangePosted = TRUE;
            IGNORE_HR(GWPostMethodCall(this, ONCALL_METHOD(CMarkup, OnDirtyRangeChange, ondirtyrangechange), 0, TRUE, "CMarkup::OnDirtyRangeChange"));
        }

        for( ; cdr; cdr--, pdr++)
        {
            pdr->_dtr.Accumulate(pnf, 0, Cch(), FALSE);
        }
    }
}


//-----------------------------------------------------------------------------
//
//  Member:     SendNotification
//
//  Synopsis:   Send the current notification and any subsequent notifications
//              which might result
//
//  Arguments:  pnf              - The notification to send
//              paryNotification - Queue of pending notifications (may be NULL)
//
//-----------------------------------------------------------------------------
void
CMarkup::SendNotification(
    CNotification *             pnf,
    CDataAry<CNotification> *   paryNotification)
{
    CNotification   nf;
    int             iRequest = 0;

    for (;;)
    {
        Assert(pnf);

        BOOL        fNeedsRelease = pnf->IsFlagSet(NFLAGS_NEEDS_RELEASE);
        CElement *  pElement      = pnf->_pElement;

        //
        //  Send the notification to "self"
        //

        if (pnf->SendTo(NFLAGS_SELF))
        {
            CElement *  pElementSelf = pElement
                                            ? pElement
                                            : pnf->_pNode->Element();

            Assert(pElementSelf);
            if (ElementWantsNotification(pElementSelf, pnf))
            {
                NotifyElement(pElementSelf, pnf);
            }
        }

        //
        //  If sending to ancestors or descendents and a starting node or range exists,
        //  Send the notification to "ancestors" and "descendents"
        //

        if (    !pnf->IsFlagSet(NFLAGS_SENDENDED)
            &&  (   pnf->_pNode
                ||  pnf->IsRangeValid()))
        {
            if (pnf->SendTo(NFLAGS_ANCESTORS))
            {
                Assert(pnf->_pNode);
                NotifyAncestors(pnf);
            }
            else if (pnf->SendTo(NFLAGS_DESCENDENTS))
            {
                NotifyDescendents(pnf);
            }
        }

        //
        //  Send the notification to listeners at the "tree" level
        //

        if (    !pnf->IsFlagSet(NFLAGS_SENDENDED)
            &&  pnf->SendTo(NFLAGS_TREELEVEL))
        {
            NotifyTreeLevel(pnf);
        }

        //
        //  Release the element (if necessary)
        //  (Elements are AddRef'd only when the associated notification is delayed)
        //

        if (fNeedsRelease)
        {
            Assert(pElement);
            Assert(paryNotification);
            Assert(iRequest <= (*paryNotification).Size());
            WHEN_DBG((*paryNotification)[iRequest-1].ClearFlag(NFLAGS_NEEDS_RELEASE));
            pElement->Release();
        }

        //
        //  Leave or fetch the next notification to send
        //  (Copy the notification into a local in case others should arrive
        //   and cause re-allocation of the array)
        //

        if (    !paryNotification
            ||  iRequest >= (*paryNotification).Size())
            goto Cleanup;

        nf  = (*paryNotification)[iRequest++];
        pnf = &nf;

        //
        //  Ensure notifications no longer part of this markup are sent only to self
        //  (Previously sent notifications can initiate changes such that the elements
        //   of pending notifications are no longer part of this markup)
        //

        if (pnf->Element())
        {
            CMarkup *   pMarkup = pnf->Element()->GetMarkupPtr();

//          Unfortunately, notifications forwarded from nested markups contain the element
//          from the nested markup, hence the more complex check. What should be is, when
//          a notification from a nested markup is forwarded (by CMarkup::NotifyTreeLevel)
//          the contained element et. al. should be changed to the "master" element.
//          This change cannot be made right now because it is potentially de-stabilizing. (brendand)

            if (!pMarkup || pMarkup != this)
            {
                pnf->_grfFlags &= ~NFLAGS_TARGETMASK | NFLAGS_SELF;
            }
        }
    }

Cleanup:
    if (paryNotification)
    {
#if DBG==1
        for (int i=0; i < (*paryNotification).Size(); i++)
            Assert(!(*paryNotification)[i].IsFlagSet(NFLAGS_NEEDS_RELEASE));
#endif

        (*paryNotification).DeleteAll();

        if ( this == Doc()->_pANotifyRootMarkup )
        {
            Doc()->_fInSendAncestor = FALSE;
            Doc()->_pANotifyRootMarkup = NULL;
        }
    }
}

HRESULT
CMarkup::SetTextPosID( CTreePos ** pptpText, long lTextID )
{
    HRESULT     hr = S_OK;

    Assert( pptpText && *pptpText );

    if( ! (*pptpText)->IsData2Pos() )
    {
        CTreePos *  ptpRet;

        ptpRet = AllocData2Pos();
        if( !ptpRet )
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }

        ptpRet->SetType( CTreePos::Text );
        *(LONG *)&ptpRet->DataThis()->t = *(LONG *)&(*pptpText)->DataThis()->t;

        hr = THR( ReplaceTreePos( *pptpText, ptpRet ) );
        if (hr)
            goto Cleanup;

        *pptpText = ptpRet;
    }

    (*pptpText)->DataThis()->t._lTextID = lTextID;

Cleanup:
    RRETURN( hr );
}

CTreePos *
CMarkup::AllocData1Pos()
{
    CTreeDataPos *ptdpNew;

#ifdef SLOWALLOC
    ptdpNew = (CTreeDataPos*)MemAllocClear( Mt(CTreeDataPos), TREEDATA1SIZE );
    ptdpNew->SetFlag(CTreePos::TPF_DATA_POS);
#else
    if (!_ptdpFree)
    {
        void *          pvPoolNew;
        size_t          cPoolSize;

        if (!_pvPool)
        {
            pvPoolNew = (void*)(_abPoolInitial);
            cPoolSize = INITIAL_TREEPOS_POOL_SIZE;
        }
        else
        {
            cPoolSize = s_cTreePosPoolSize;
            pvPoolNew = MemAllocClear(
                            Mt(CMarkup_pvPool), 
                            sizeof(void*) + TREEDATA1SIZE * s_cTreePosPoolSize);
        }

        if (pvPoolNew)
        {
            CTreeDataPos *ptdp;
            int i;

            for (ptdp = (CTreeDataPos*)((void**)pvPoolNew + 1), i = cPoolSize - 1; 
                 i > 0; 
                 ptdp = (CTreeDataPos*)((BYTE*)ptdp + TREEDATA1SIZE), --i)
            {
                ptdp->SetFlag(CTreePos::TPF_DATA_POS);
                ptdp->SetNext((CTreeDataPos*)((BYTE*)ptdp + TREEDATA1SIZE));
            }

            ptdp->SetFlag(CTreePos::TPF_DATA_POS);

            _ptdpFree = (CTreeDataPos*)((void**)pvPoolNew + 1);
            *((void**)pvPoolNew) = _pvPool;
            _pvPool = pvPoolNew;
        }
    }
    ptdpNew = _ptdpFree;
#endif

    if (ptdpNew)
    {
        _ptdpFree = (CTreeDataPos*)(ptdpNew->Next());
        ptdpNew->SetNext(NULL);
    }

#if DBG == 1 || defined(DUMPTREE)
    ptdpNew->SetSN();
#endif

    return ptdpNew;
}

CTreePos *
CMarkup::AllocData2Pos()
{
    CTreeDataPos *ptdpNew;
    ptdpNew = (CTreeDataPos*)MemAllocClear( Mt(CTreeDataPos), TREEDATA2SIZE );

    if( ptdpNew )
    {
        ptdpNew->SetFlag(CTreePos::TPF_DATA_POS|CTreePos::TPF_DATA2_POS);
#if DBG == 1 || defined(DUMPTREE)
        ptdpNew->SetSN();
#endif
    }

    return ptdpNew;
}

#if _WIN64

CTreePos *
CMarkup::AllocData3Pos()
{
    CTreeDataPos *ptdpNew;
    ptdpNew = (CTreeDataPos*)MemAllocClear( Mt(CTreeDataPos), TREEDATA3SIZE );

    if( ptdpNew )
    {
        ptdpNew->SetFlag(CTreePos::TPF_DATA2_POS|CTreePos::TPF_DATA3_POS);
#if DBG == 1 || defined(DUMPTREE)
        ptdpNew->SetSN();
#endif
    }

    return ptdpNew;
}

#endif

inline void
CMarkup::ReleaseTreePos(CTreePos *ptp, BOOL fLastRelease /*= FALSE*/ )
{
    AssertSz(ptp->_cGapsAttached==0, "Destroying a TreePos with TreePosGaps attached");

    switch (ptp->Type())
    {
    case CTreePos::Pointer:
        if (ptp->GetCollapsedWhitespace())
        {
            delete [] ptp->GetCollapsedWhitespace();
        }
        if (ptp->MarkupPointer())
        {
            ptp->MarkupPointer()->OnPositionReleased();
            ptp->DataThis()->p._dwPointerAndGravityAndCling = 0;
        }

    // fall through
    case CTreePos::Text:
        Assert( ptp->IsDataPos() );

#ifdef SLOWALLOC
        MemFree( ptp );
#else
#if _WIN64
        if( ptp->IsData3Pos() )
#else
        if( ptp->IsData2Pos() )
#endif
        {
            MemFree( ptp );
        }
        else if( ! fLastRelease )
        {
            memset( ptp, 0, TREEDATA1SIZE );

            ptp->SetFlag( CTreePos::TPF_DATA_POS );
            ptp->SetNext( _ptdpFree );
            _ptdpFree = ptp->DataThis();
        }
#endif
        break;

    case CTreePos::NodeBeg:
    case CTreePos::NodeEnd:
        // Make sure that we crash if someone
        // tries to use a dead node pos...
        ptp->_pFirstChild = NULL;
        ptp->_pNext = NULL;
        break;
    }
}


void
CMarkup::FreeTreePos(CTreePos *ptp)
{
    Assert(ptp);

    // set a sentinel to make the traversal terminate
    ptp->MarkFirst();
    ptp->SetNext(NULL);

    // release the subtree, adding its nodes to the free list
    while (ptp)
    {
        if (ptp->FirstChild())
        {
            ptp = ptp->FirstChild();
        }
        else
        {
            CTreePos *ptpNext;
            BOOL fRelease = TRUE;
            while (fRelease)
            {
                fRelease = ptp->IsLastChild();
                ptpNext = ptp->Next();
                ReleaseTreePos(ptp);
                ptp = ptpNext;
            }
        }
    }
}


CTreePos *
CMarkup::FirstTreePos() const
{
    return _ptpFirst;
}


CTreePos *
CMarkup::LastTreePos() const
{
    CTreePos *ptpLeft = _tpRoot.FirstChild();

    return (ptpLeft) ? ptpLeft->RightmostDescendant() : NULL;
}



#if DBG!=1
#pragma optimize(SPEED_OPTIMIZE_FLAGS, on)
#endif

CTreePos *
CMarkup::TreePosAtSourceIndex(long iSourceIndex)
{
    Assert(0<=iSourceIndex);
    WHEN_DBG( long iSIOrig = iSourceIndex; )
    long cElemLeft;
    long cDepth=0;

    CTreePos *ptp = _tpRoot.FirstChild();

    for (;; ++cDepth )
    {
        cElemLeft = ptp->GetElemLeft();

        if (iSourceIndex < cElemLeft)
        {
            ptp = ptp->FirstChild();
            Assert(ptp->IsLeftChild());
        }
        else if (iSourceIndex > cElemLeft || !ptp->IsBeginElementScope())
        {
            iSourceIndex -= cElemLeft + (ptp->IsBeginElementScope()? 1 : 0);
            ptp = ptp->RightChild();
        }
        else
        {
            break;
        }
    }

    TraceTag((tagTreePosAccess, "%p: TreePos at sourceindex %ld  depth %ld",
                this, iSIOrig, cDepth));

    if (ShouldSplay(cDepth))
    {
        ptp->Splay();
    }

    return ptp;
}

CTreePos *
CMarkup::TreePosAtCp ( long cp, long * pcchOffset, BOOL fAdjustForward ) const
{
    long cDepth=0;
    WHEN_DBG( long cpOrig=cp; )

    // Make sure we got a valid cp.
            
    AssertSz( cp >= 1 && cp < Cch(), "Invalid cp - out of document" );

    CTreePos * ptp = _tpRoot.FirstChild();

    for ( ; ptp; ++cDepth )
    {
        if (cp < long( ptp->_cchLeft ))
        {
            ptp = ptp->FirstChild();

            if (!ptp || !ptp->IsLeftChild())
            {
                ptp = FirstTreePos();
                break;          // we fell off the left end
            }
        }
        else
        {
            cp -= ptp->_cchLeft;
            
            if (ptp->IsPointer() || cp && (!ptp->IsText() || cp >= ptp->Cch()))
            {
                cp -= ptp->GetCch();
                ptp = ptp->RightChild();
            }
            else
                break;
        }
    }

    if(!ptp)
        return NULL;

    if (pcchOffset)
        *pcchOffset = cp;

    TraceTag(
        (tagTreePosAccess,
         "%p: TreePos at cp %ld offset %ld depth %ld",
         this, cpOrig, cp, cDepth));

    if (ptp && ShouldSplay(cDepth))
        ptp->Splay();

    // If we are adjusting forward and we are not in the middle of a ptp
    // the go forward past all the empty ptps.
    if (fAdjustForward && cp == 0)
    {
        while(ptp)
        {
            if (   ptp->IsNode()
                && !ptp->IsEdgeScope()
               )
            {
                Assert(ptp->GetCch() == 0);
                ptp = ptp->NextTreePos();
            }
            else
            {
                break;
            }
        }
    }
    
    return ptp;
}

#pragma optimize("", on)

HRESULT
CMarkup::Append(CTreePos *ptpNew)
{
    HRESULT hr = (ptpNew)? S_OK : E_OUTOFMEMORY;
    CTreePos *ptpOldRoot = _tpRoot.FirstChild();

    if (hr)
        goto Cleanup;
    Assert(!ptpNew->Owner() || ptpNew->Owner() == this);

    ptpNew->SetFirstChild(ptpOldRoot);
    ptpNew->MarkLeft();
    ptpNew->MarkLast();
    ptpNew->SetNext(&_tpRoot);

    ptpNew->ClearCounts();
    ptpNew->IncreaseCounts(&_tpRoot, CTreePos::TP_LEFT);

    _tpRoot.SetFirstChild(ptpNew);
    _tpRoot.IncreaseCounts(ptpNew, CTreePos::TP_DIRECT);

    if (ptpOldRoot)
    {
        Assert(ptpOldRoot->IsLastChild());
#if defined(MAINTAIN_SPLAYTREE_THREADS)
        // adjust threads
        CTreePos *ptpRightmost = ptpOldRoot->RightmostDescendant();
        Assert(ptpRightmost->RightThread() == NULL);
        ptpRightmost->SetRightThread(ptpNew);
        ptpNew->SetLeftThread(ptpRightmost);
        ptpNew->SetRightThread(NULL);
#endif
        ptpOldRoot->SetNext(ptpNew);
    }
    else
    {
        _ptpFirst = ptpNew;
    }

#if DBG==1
    if (IsTagEnabled(tagTreePosValidate))
        Assert(IsSplayValid());
#endif

    TraceTag((tagTreePosOps, "%p: Append TreePos cch=%ld",
        this, ptpNew->GetCch()));

Cleanup:
    RRETURN(hr);
}

HRESULT
CMarkup::Insert(CTreePos *ptpNew, CTreePosGap *ptpgInsert)
{
    Assert( ptpgInsert->IsPositioned() );

    return Insert( ptpNew,
                   ptpgInsert->AttachedTreePos(),
                   ptpgInsert->AttachDirection() == TPG_RIGHT );
}

HRESULT
CMarkup::Insert(CTreePos *ptpNew, CTreePos *ptpInsert, BOOL fBefore)
{
    CTreePos *pLeftChild, *pRightChild;
    CTreePos *ptp;
    BOOL fLeftChild;
    HRESULT hr = (ptpNew)? S_OK : E_OUTOFMEMORY;

    if (hr)
        goto Cleanup;

    Assert(!ptpNew->Owner() || ptpNew->Owner() == this);
    Assert(ptpInsert);

    if (!fBefore)
    {
        CTreePos *ptpInsertBefore = ptpInsert->NextTreePos();

        if( ptpInsertBefore )
        {
            ptpInsert = ptpInsertBefore;
        }
        else
        {
            hr = Append( ptpNew );
            goto Cleanup;
        }
    }

    ptpNew->ClearCounts();
    ptpNew->IncreaseCounts(ptpInsert, CTreePos::TP_LEFT);

    ptpInsert->GetChildren(&pLeftChild, &pRightChild);

    ptpInsert->SetFirstChild(ptpNew);

    ptpNew->SetFirstChild(pLeftChild);
    ptpNew->MarkLeft();

    if (pLeftChild)
    {
        ptpNew->MarkLast(pLeftChild->IsLastChild());
        ptpNew->SetNext(pLeftChild->Next());
        pLeftChild->MarkLast();
        pLeftChild->SetNext(ptpNew);
    }
    else if (pRightChild)
    {
        ptpNew->MarkFirst();
        ptpNew->SetNext(pRightChild);
    }
    else
    {
        ptpNew->MarkLast();
        ptpNew->SetNext(ptpInsert);
    }

#if defined(MAINTAIN_SPLAYTREE_THREADS)
    // adjust threads
    ptpNew->SetLeftThread(ptpInsert->LeftThread());
    ptpNew->SetRightThread(ptpInsert);
    if (ptpNew->LeftThread())
        ptpNew->LeftThread()->SetRightThread(ptpNew);
    ptpInsert->SetLeftThread(ptpNew);
#endif

    if (ptpNew->HasNonzeroCounts(CTreePos::TP_DIRECT))
    {
        fLeftChild = TRUE;
        for (ptp = ptpInsert; ptp; ptp = ptp->Parent())
        {
            if (fLeftChild)
            {
                ptp->IncreaseCounts(ptpNew, CTreePos::TP_DIRECT);
            }
            fLeftChild = ptp->IsLeftChild();
        }
    }

    if (ptpInsert == _ptpFirst)
    {
        _ptpFirst = ptpNew;
    }

    TraceTag((tagTreePosOps, "%p: Insert TreePos cch=%ld",
        this, ptpNew->GetCch() ));

Cleanup:
#if DBG==1
    if (IsTagEnabled(tagTreePosValidate))
        Assert(IsSplayValid());
#endif

    RRETURN(hr);
}

HRESULT 
CMarkup::Move(CTreePos *ptpNew, CTreePosGap *ptpgDest)
{
    Assert( ptpgDest->IsPositioned() );

    return Move( ptpNew,
                 ptpgDest->AttachedTreePos(),
                 ptpgDest->AttachDirection() == TPG_RIGHT );
}

HRESULT
CMarkup::Move(CTreePos *ptpMove, CTreePos *ptpDest, BOOL fBefore)
{
    Assert(ptpMove != ptpDest);
    SUBLIST sublist;
    HRESULT hr;

    hr = SpliceOut(ptpMove, ptpMove, &sublist);
    if (!hr)
    {
        Assert(sublist.FirstChild() == ptpMove);
        hr = Insert(ptpMove, ptpDest, fBefore);
    }

    return hr;
}


HRESULT
CMarkup::Split(CTreePos *ptpSplit, long cchLeft, SCRIPT_ID sidNew /*= sidNil */)
{
    WHEN_DBG( CTreePos tpValid(TRUE); )
    CTreePos * ptpNew;
    CTreePos * pLeftChild, * pRightChild;
    HRESULT    hr = S_OK;
    
    Assert( ptpSplit->IsText() && ptpSplit->Cch() >= cchLeft );

    if (sidNew == sidNil)
        sidNew = ptpSplit->Sid();

    ptpNew = NewTextPos( ptpSplit->Cch() - cchLeft, sidNew, ptpSplit->TextID() );

    if (!ptpNew)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    ptpSplit->GetChildren(&pLeftChild, &pRightChild);

    ptpNew->MarkLast();
    ptpNew->SetNext(ptpSplit);
    ptpNew->SetFirstChild(pRightChild);
    if (pRightChild)
    {
        pRightChild->SetNext(ptpNew);
    }

    ptpSplit->DataThis()->t._cch = cchLeft;
    if (pLeftChild)
    {
        pLeftChild->MarkFirst();
        pLeftChild->SetNext(ptpNew);
    }
    else
    {
        ptpSplit->SetFirstChild(ptpNew);
    }

#if defined(MAINTAIN_SPLAYTREE_THREADS)
    // adjust threads
    ptpNew->SetLeftThread(ptpSplit);
    ptpNew->SetRightThread(ptpSplit->RightThread());
    ptpSplit->SetRightThread(ptpNew);
    if (ptpNew->RightThread())
        ptpNew->RightThread()->SetLeftThread(ptpNew);
#endif

#if DBG==1
    if (IsTagEnabled(tagTreePosValidate))
        Assert( IsSplayValid() );
#endif

    TraceTag((tagTreePosOps, "%p: Split TreePos into cch %ld/%ld",
                this, ptpSplit->Cch(), ptpNew->Cch()));

Cleanup:
    RRETURN(hr);
}


HRESULT
CMarkup::Join(CTreePos *ptpJoin)
{
    WHEN_DBG( CTreePos tpValid(TRUE); )
    CTreePos *ptpNext, *ptpParent;
    CTreePos *pLeftChild;

    // put the two TreePos together at the top of the tree, next TreePos on top
    ptpJoin->Splay();
    ptpNext = ptpJoin->NextTreePos();

    // We're joining two text nodes, so we BETTER have a next node.
    Assert( ptpNext);

    ptpNext->Splay();

    Assert( ptpJoin->IsText() && ptpNext->IsText() );

    // take over the next TreePos (my right subtree is empty)
    ptpJoin->DataThis()->t._cch += ptpNext->Cch();
    if (!ptpJoin->IsLastChild())
    {
        ptpJoin->Next()->SetNext(ptpJoin);
        pLeftChild = ptpJoin->LeftChild();
        if (pLeftChild)
        {
            pLeftChild->MarkFirst();
            pLeftChild->SetNext(ptpJoin->Next());
        }
        else
        {
            ptpJoin->SetFirstChild(ptpJoin->Next());
        }
    }

#if defined(MAINTAIN_SPLAYTREE_THREADS)
    // adjust threads
    ptpJoin->SetRightThread(ptpNext->RightThread());
    if (ptpNext->RightThread())
        ptpNext->RightThread()->SetLeftThread(ptpJoin);
#endif

    // discard the next TreePos
    ptpParent = ptpNext->Parent();
    Assert(ptpParent->Next() == NULL);
    ptpParent->ReplaceChild(ptpNext, ptpJoin);
    ptpNext->SetFirstChild(NULL);
    FreeTreePos(ptpNext);

#if DBG==1
    if (IsTagEnabled(tagTreePosValidate))
        Assert( IsSplayValid() );
#endif

    TraceTag((tagTreePosOps, "%p: Join cch=%ld", this, ptpJoin->Cch()));

    return S_OK;
}

HRESULT 
CMarkup::ReplaceTreePos(CTreePos * ptpOld, CTreePos * ptpNew)
{
    HRESULT hr = S_OK;

    Assert( ! HasUnembeddedPointers() );

    Assert( ptpOld && ptpNew );

    hr = THR( Insert( ptpNew, ptpOld, TRUE ) );
    if (hr)
        goto Cleanup;

    hr = THR( Remove( ptpOld ) );
    if (hr)
        goto Cleanup;

Cleanup:
    RRETURN( hr );
}

//
// This MergeText cannot be used for merging text after pointer pos removal
//

HRESULT
CMarkup::MergeText( CTreePos * ptpMerge )
{
    HRESULT hr = S_OK;
    CTreePos * ptp;

    Assert( ! HasUnembeddedPointers() );

    if (!ptpMerge->IsText())
        goto Cleanup;

    ptp = ptpMerge->PreviousTreePos();

    if (    ptp->IsText() 
        &&  ptp->Sid() == ptpMerge->Sid()
        &&  ptp->TextID() == ptpMerge->TextID() )
    {
        hr = THR( MergeTextHelper( ptp ) );

        if (hr)
            goto Cleanup;

        ptpMerge = ptp;
    }

    ptp = ptpMerge->NextTreePos();

    if (    ptp->IsText() 
        &&  ptp->Sid() == ptpMerge->Sid()
        &&  ptp->TextID() == ptpMerge->TextID() )
    {
        hr = THR( MergeTextHelper( ptpMerge ) );

        if (hr)
            goto Cleanup;
    }

Cleanup:

    RRETURN( hr );
}

HRESULT
CMarkup::MergeTextHelper ( CTreePos * ptpMerge )
{
    HRESULT  hr = S_OK;

    Assert( ptpMerge->IsText() );
    Assert( ptpMerge->NextTreePos()->IsText() );

    hr = THR( Join( ptpMerge ) );

    if (hr)
        goto Cleanup;
Cleanup:

    RRETURN( hr );
}

///////////////////////////////////////////////////////////////////////////////
//
// RemovePointerPos
//
// Removes a pointer pos, making sure unembedded pointers are updated
// properly.  Once can also pass in a ptp/ich pair to make sure it gets
// updated as well.
//
///////////////////////////////////////////////////////////////////////////////

HRESULT
CMarkup::RemovePointerPos ( CTreePos * ptp, CTreePos * * pptpUpdate, long * pichUpdate )
{
    HRESULT    hr = S_OK;
    CTreePos * ptpBefore;
    CTreePos * ptpAfter;

    Assert( ptp->IsPointer() );
    Assert( ! pptpUpdate || *pptpUpdate != ptp );

    //
    // Remove the pos from the list, making sure to record the pos before the one
    // being removed
    //

    ptpBefore = ptp->PreviousTreePos();

    hr = THR( Remove( ptp ) );

    if (hr)
        goto Cleanup;

    //
    // Now, see if there are two adjacent text pos's we can merge
    //

    if (ptpBefore->IsText() && (ptpAfter = ptpBefore->NextTreePos())->IsText() &&
        ptpBefore->Sid() == ptpAfter->Sid() && ptpBefore->TextID() == ptpAfter->TextID())
    {
        CMarkupPointer * pmp;

        //
        // Update the incomming ref and unembedded markup pointers
        //
        
        if (pptpUpdate && *pptpUpdate == ptpAfter)
        {
            *pptpUpdate = ptpBefore;
            *pichUpdate += ptpBefore->Cch();
        }

        for ( pmp = _pmpFirst ; pmp ; pmp = pmp->_pmpNext )
        {
            Assert( ! pmp->_fEmbedded );

            if (pmp->_ptpRef == ptpAfter)
            {
                pmp->_ptpRef = ptpBefore;
                
                Assert( ! pmp->_ptpRef->IsPointer() );
                
                Assert(
                    ! pmp->_ptpRef->IsBeginElementScope() ||
                        ! pmp->_ptpRef->Branch()->Element()->IsNoScope() );
                
                pmp->_ichRef += ptpBefore->Cch();
            }
        }

        //
        // Then joing the adjacent text pos's
        //

        hr = THR( Join( ptpBefore ) );

        if (hr)
            goto Cleanup;
    }

Cleanup:

    RRETURN( hr );
}

HRESULT
CMarkup::Remove(CTreePos *ptpStart, CTreePos *ptpFinish)
{
    HRESULT hr;
    SUBLIST sublist;

    hr = SpliceOut(ptpStart, ptpFinish, &sublist);
    if (!hr && sublist.FirstChild())
    {
        FreeTreePos(sublist.FirstChild());

        TraceTag((tagTreePosOps, "%p: Remove cch=%ld", this, sublist._cchLeft));
    }

    RRETURN(hr);
}


HRESULT
CMarkup::SpliceOut(CTreePos *ptpStart, CTreePos *ptpFinish,
                        SUBLIST *pSublistSplice)
{
    CTreePos *ptpSplice;
    CTreePos *ptp;
    BOOL fLeftChild;
    CTreePos *ptpLeftEdge = ptpStart->PreviousTreePos();
    CTreePos *ptpRightEdge = ptpFinish->NextTreePos();
//    CTreePos *ptpPointerHead=NULL, *ptpPointerTail=NULL;
#if defined(MAINTAIN_SPLAYTREE_THREADS)
    CTreePos *ptpLeftmost, *ptpRightmost;
#endif

    pSublistSplice->InitSublist();

    // isolate the splice region near the top of the tree
    if (ptpRightEdge)
    {
        ptpRightEdge->Splay();
    }
    if (ptpLeftEdge)
    {
        ptpLeftEdge->Splay();
    }

    // locate the splice region
    ptpSplice = _tpRoot.FirstChild();
    Assert(ptpSplice);  // _tpRoot.FirstChild() should always return a valid pointer
    if (ptpLeftEdge)
    {
        ptpSplice = ptpLeftEdge->RightChild();

        // call RotateUp to isolate if last step was zig-zig
        if (ptpRightEdge && ptpRightEdge->Parent() == ptpSplice)
        {
            // Assert to make PreFIX happy. If ptpRightEdge is non-null then its
            // parent won't be null and so ptpSplice isn't null.
            Assert(ptpSplice); 

            ptpRightEdge->RotateUp(ptpSplice, ptpSplice->Parent());
        }
    }
    if (ptpRightEdge)
    {
        ptpSplice = ptpRightEdge->LeftChild();
    }

    ptp = ptpSplice->Parent();
    fLeftChild = ptpSplice->IsLeftChild();

    // splice it out
    if (fLeftChild)
    {
        pSublistSplice->IncreaseCounts(ptp, CTreePos::TP_LEFT);
    }
    else
    {
        Assert(ptp->Parent() == &_tpRoot);
        pSublistSplice->IncreaseCounts(&_tpRoot, CTreePos::TP_LEFT);
        pSublistSplice->DecreaseCounts(ptp, CTreePos::TP_BOTH);
    }
    ptp->RemoveChild(ptpSplice);
    pSublistSplice->SetFirstChild(ptpSplice);
    ptpSplice->SetNext(pSublistSplice);
    ptpSplice->MarkLast();
    ptpSplice->MarkLeft();

#if defined(MAINTAIN_SPLAYTREE_THREADS)
    // adjust threads
    ptpLeftmost = ptpSplice->LeftmostDescendant();
    ptpRightmost = ptpSplice->RightmostDescendant();
    if (ptpLeftmost->LeftThread())
        ptpLeftmost->LeftThread()->SetRightThread(ptpRightmost->RightThread());
    if (ptpRightmost->RightThread())
        ptpRightmost->RightThread()->SetLeftThread(ptpLeftmost->LeftThread());
    ptpLeftmost->SetLeftThread(NULL);
    ptpRightmost->SetRightThread(NULL);
#endif

#if 0 // Don't need this right now
    if (fIgnorePointers)
    {
        CTreePos *ptpSource;

        // find any pointers in the splice region
        for (ptpSource = pSublistSplice->LeftmostDescendant();
             ptpSource;
             /* advance done in body */ )
        {
            CTreePos *ptpNext = ptpSource->NextTreePos();

            if (ptpSource->IsPointer())
            {
                ptpSource->Remove();
                if (ptpPointerTail)
                {
                    ptpPointerTail->SetFirstChild(ptpSource);
                    ptpSource->MarkRight();
                    ptpSource->MarkLast();
                    ptpSource->SetNext(ptpPointerTail);
#if defined(MAINTAIN_SPLAYTREE_THREADS)
                    ptpPointerTail->SetRightThread(ptpSource);
                    ptpSource->SetLeftThread(ptpPointerTail);
#endif
                }
                else
                {
                    ptpPointerHead = ptpSource;
                }
                ptpSource->SetFirstChild(NULL);
                ptpPointerTail = ptpSource;
            }

            ptpSource = ptpNext;
        }

        // restore them to the main list
        if (ptpPointerHead)
        {
            if (fLeftChild)
            {
                ptpPointerHead->MarkLeft();
                if (ptp->FirstChild())
                {
                    ptpPointerHead->MarkFirst();
                    ptpPointerHead->SetNext(ptp->FirstChild());
                }
                else
                {
                    ptpPointerHead->MarkLast();
                    ptpPointerHead->SetNext(ptp);
                }
                ptp->SetFirstChild(ptpPointerHead);
#if defined(MAINTAIN_SPLAYTREE_THREADS)
                // adjust threads
                if (ptp->LeftThread())
                {
                    ptp->LeftThread()->SetRightThread(ptpPointerHead);
                    ptpPointerHead->SetLeftThread(ptp->LeftThread());
                }
                ptpPointerTail->SetRightThread(ptp);
                ptp->SetLeftThread(ptpPointerTail);
#endif
            }
            else
            {
                CTreePos *ptpLeft = ptp->FirstChild();

                ptpPointerHead->MarkRight();
                ptpPointerHead->MarkLast();
                ptpPointerHead->SetNext(ptp);
                if (ptpLeft)
                {
                    ptpLeft->SetNext(ptpPointerHead);
                    ptpLeft->MarkFirst();
                }
                else
                {
                    ptp->SetFirstChild(ptpPointerHead);
                }
#if defined(MAINTAIN_SPLAYTREE_THREADS)
                // adjust threads
                if (ptp->RightThread())
                {
                    ptp->RightThread()->SetLeftThread(ptpPointerTail);
                    ptpPointerTail->SetRightThread(ptp->RightThread());
                }
                ptpPointerHead->SetLeftThread(ptp);
                ptp->SetRightThread(ptpPointerHead);
#endif
            }
        }
    }
#endif // Don't need this right now

    // adjust cumulative counts
    if( pSublistSplice->HasNonzeroCounts( CTreePos::TP_LEFT ) )
    {
        for (; ptp; ptp=ptp->Parent())
        {
            if (fLeftChild)
            {
                ptp->DecreaseCounts(pSublistSplice, CTreePos::TP_LEFT);
            }
            fLeftChild = ptp->IsLeftChild();
        }
    }

    // return answers
    TraceTag((tagTreePosOps, "%p: SpliceOut cch=%ld", this, pSublistSplice->_cchLeft));

    if (ptpLeftEdge == NULL)
    {
        _ptpFirst = _tpRoot.LeftmostDescendant();
        if (_ptpFirst == &_tpRoot)
        {
            _ptpFirst = NULL;
        }
    }

#if DBG==1
    if (IsTagEnabled(tagTreePosValidate))
        Assert(IsSplayValid());
#endif

    return S_OK;
}

HRESULT
CMarkup::SpliceIn(SUBLIST *pSublistSplice, CTreePos *ptp)
{
    CTreePos *ptpSplice = pSublistSplice->FirstChild();
    CTreePos *pRightChild;
    CTreePos *ptpPrev;
    BOOL fLeftChild;
    BOOL fNewFirst = (ptp == _ptpFirst);

    Assert(ptpSplice);
    Assert(!ptpSplice->Owner() || ptpSplice->Owner() == this);

#if defined(MAINTAIN_SPLAYTREE_THREADS)
    CTreePos *ptpLeftmost = ptpSplice->LeftmostDescendant();
    CTreePos *ptpRightmost = ptpSplice->RightmostDescendant();
#endif

    if (ptp)
    {
        ptp->Splay();

        ptpPrev = ptp->PreviousTreePos();
        if (ptpPrev)
        {
            ptpPrev->Splay();
        }

        pRightChild = ptp->RightChild();
        if (pRightChild)
        {
            ptpSplice->MarkFirst();
            ptpSplice->SetNext(pRightChild);
        }
        else
        {
            ptpSplice->MarkLast();
            ptpSplice->SetNext(ptp);
        }

        ptp->SetFirstChild(ptpSplice);
        ptpSplice->MarkLeft();

        fLeftChild = TRUE;

#if defined(MAINTAIN_SPLAYTREE_THREADS)
        // adjust threads
        if (ptp->LeftThread())
        {
            ptp->LeftThread()->SetRightThread(ptpLeftmost);
            ptpLeftmost->SetLeftThread(ptp->LeftThread());
        }
        ptpRightmost->SetRightThread(ptp);
        ptp->SetLeftThread(ptpRightmost);
#endif
    }
    else
    {
        ptp = LastTreePos();
        Assert(ptp);
        CTreePos *ptpLeft = ptp->LeftChild();

        if (ptpLeft)
        {
            ptpLeft->MarkFirst();
            ptpLeft->SetNext(ptpSplice);
        }
        else
        {
            ptp->SetFirstChild(ptpSplice);
        }
        ptpSplice->MarkLast();
        ptpSplice->MarkRight();
        ptpSplice->SetNext(ptp);

        fLeftChild = FALSE;

#if defined(MAINTAIN_SPLAYTREE_THREADS)
        // adjust threads
        ptp->SetRightThread(ptpLeftmost);
        ptpLeftmost->SetLeftThread(ptp);
#endif
    }

    for (; ptp; ptp=ptp->Parent())
    {
        if (fLeftChild)
        {
            ptp->IncreaseCounts(pSublistSplice, CTreePos::TP_LEFT);
        }
        fLeftChild = ptp->IsLeftChild();
    }

    if (fNewFirst)
    {
        _ptpFirst = _ptpFirst->LeftmostDescendant();
    }

#if DBG==1
    if (IsTagEnabled(tagTreePosValidate))
        Assert(IsSplayValid());
#endif
    TraceTag((tagTreePosOps, "%p: SpliceIn cch=%ld", this, pSublistSplice->_cchLeft));
    return S_OK;
}

//
// CMarkup::InsertPosChain
//
// This method inserts a chain of CTreePoses into the tree.  The
// poses should be chained together in an appropriate way to make
// insertion very cheap.
//
// The first child pointer of every pos should point to the previous
// pos in the chain.  The next pointer should point to the next
// pos in the chain.  The ends should point to NULL.  The last child
// and left child bits should be set on every element.
//
// Eventually, the counts should probably be set to something also so
// that this method doesn't have to run the chain, but I haven't figured
// that out yet.
//

HRESULT
CMarkup::InsertPosChain( 
                CTreePos * ptpChainHead, CTreePos * ptpChainTail, 
                CTreePos * ptpInsertBefore )
{
    CTreePos *pLeftChild, *pRightChild;

    // We can't insert at the beginning or end of the splay tree
    Assert( ptpInsertBefore != _ptpFirst );
    Assert( ptpInsertBefore );

    ptpInsertBefore->GetChildren(&pLeftChild, &pRightChild);

    ptpInsertBefore->SetFirstChild(ptpChainTail);
    ptpChainTail->MarkLeft();

    ptpChainHead->SetFirstChild(pLeftChild);

    if (pLeftChild)
    {
        ptpChainTail->MarkLast(pLeftChild->IsLastChild());
        ptpChainTail->SetNext(pLeftChild->Next());

        pLeftChild->MarkLast();
        pLeftChild->SetNext(ptpChainHead);
    }
    else if (pRightChild)
    {
        ptpChainTail->MarkFirst();
        ptpChainTail->SetNext(pRightChild);
    }
    else
    {
        ptpChainTail->MarkLast();
        ptpChainTail->SetNext(ptpInsertBefore);
    }

#if defined(MAINTAIN_SPLAYTREE_THREADS)
    // adjust threads
    ptpChainHead->SetLeftThread(ptpInsertBefore->LeftThread());
    ptpChainTail->SetRightThread(ptpInsertBefore);
    if (ptpChainHead->LeftThread())
        ptpChainHead->LeftThread()->SetRightThread(ptpChainHead);
    ptpInsertBefore->SetLeftThread(ptpChainTail);
#endif

    // update the order statistics
    {
        CTreePos *  ptp, *ptpPrev = NULL;
        BOOL        fLeftChild = TRUE;
        CTreePos::SCounts   counts;
#if DBG==1
        BOOL fCheckCounts = FALSE;
#endif

        // accumulate/set the chain just inserted
        ptpChainHead->ClearCounts();
        ptpChainHead->IncreaseCounts( ptpInsertBefore, CTreePos::TP_LEFT );
        
        counts.Clear();
        counts.Increase( ptpChainHead );

        for ( ptpPrev = ptpChainHead, ptp = ptpChainHead->Parent(); 
              ptpPrev != ptpChainTail; 
              ptpPrev = ptp, ptp = ptp->Parent() )
        {
            Assert( ptp );

            ptp->ClearCounts();
            ptp->IncreaseCounts( ptpPrev, CTreePos::TP_BOTH );

#if DBG==1
            fCheckCounts = fCheckCounts || !ptp->IsPointer();
#endif

            counts.Increase( ptp );
        }

        // This method isn't used to insert pointers so
        // we must have some sort of count
        Assert( !fCheckCounts || counts.IsNonzero() );
        
        fLeftChild = TRUE;
        for (ptp = ptpInsertBefore; ptp; ptp = ptp->Parent())
        {
            if (fLeftChild)
            {
                ptp->IncreaseCounts( &counts );
            }
            fLeftChild = ptp->IsLeftChild();
        }
    }

#if DBG==1
    if (IsTagEnabled(tagTreePosValidate))
        Assert(IsSplayValid());
#endif

    RRETURN(S_OK);
}


//+----------------------------------------------------------------------------
//
//  Member:     FastElemTextSet
//
//  Synopsis:   Fast way to set the entire text of an element (e.g. INPUT).
//              Assumes that there is no overlapping.
//
//-----------------------------------------------------------------------------

HRESULT
CMarkup::FastElemTextSet(CElement * pElem, const TCHAR * psz, int c, BOOL fAsciiOnly)
{
    HRESULT         hr = S_OK;
    CTreePos *      ptpBegin;
    CTreePos *      ptpEnd;
    long            cpBegin, cpEnd;

    // make sure pointers are embedded

    hr = THR( EmbedPointers() );
    if (hr)
        goto Cleanup;
    
    // Assert that there is no overlapping into this element
    Assert( ! pElem->GetFirstBranch()->NextBranch() );

    pElem->GetTreeExtent( &ptpBegin, &ptpEnd );
    Assert( ptpBegin && ptpEnd );

    cpBegin = ptpBegin->GetCp() + 1;
    cpEnd = ptpEnd->GetCp();

    if( cpBegin != cpEnd || !fAsciiOnly)
    {
        CTreePosGap tpgBegin( TPG_LEFT ), tpgEnd( TPG_RIGHT );
        Verify( ! tpgBegin.MoveTo( ptpBegin, TPG_RIGHT ) );
        Verify( ! tpgEnd.MoveTo( ptpEnd, TPG_LEFT ) );

        hr = THR( SpliceTreeInternal( & tpgBegin, & tpgEnd ) );
        if (hr)
            goto Cleanup;

    #if DBG == 1
        {
            CTreePos * ptpEndAfter;
            pElem->GetTreeExtent( NULL, &ptpEndAfter );
            Assert( ptpEndAfter == ptpEnd );
        }
    #endif

        hr = THR( InsertTextInternal( ptpEnd, psz, c, NULL ) );
        if (hr)
            goto Cleanup;
    }
    else if (c)
    {
        CTreePos *      ptpText = ptpEnd;
        CTreePosGap     tpgPP(TPG_RIGHT);
        CNotification   nf;
        CInsertSpliceUndo Undo( Doc() );

        Verify( !tpgPP.MoveTo( ptpBegin, TPG_RIGHT ) );
        tpgPP.PartitionPointers( this, FALSE );

        Undo.Init( this, NULL );

        UpdateMarkupContentsVersion();

        Undo.SetData( cpBegin, cpBegin + c );

        // Build a notification (do we HAVE to do this?!?)
        nf.CharsAdded( cpBegin, c, pElem->GetFirstBranch() );

        ptpText = NewTextPos( c );
        hr = THR( Insert( ptpText, tpgPP.AttachedTreePos(), TRUE ) );
        if (hr)
            goto Cleanup;

        // Insert the text
        Verify(
            CTxtPtr( this, cpBegin ).
                InsertRange( c, psz ) == c );

        Notify( &nf );

        Undo.CreateAndSubmit();
    }

Cleanup:
    RRETURN(hr);
}


/////////////////////////////////////////////////////////////////////////////////
//      CTreePosGap
/////////////////////////////////////////////////////////////////////////////////

CTreePos *
CTreePosGap::AdjacentTreePos(TPG_DIRECTION eDir) const
{
    Assert(eDir==TPG_LEFT || eDir==TPG_RIGHT);
    AssertSz(_ptpAttach, "Gap is not positioned");
    BOOL fLeft = (eDir == TPG_LEFT);

    return (fLeft==!!_fLeft) ? _ptpAttach
                             : _fLeft ? _ptpAttach->NextTreePos()
                                      : _ptpAttach->PreviousTreePos();
}

#if DBG != 1
#pragma optimize(SPEED_OPTIMIZE_FLAGS, on)
#endif

CTreeNode *
CTreePosGap::Branch() const
{
    AssertSz(_ptpAttach, "Gap is not positioned");
    BOOL fLeft = _fLeft;
    CTreePos *ptp= _ptpAttach;

    if( !_ptpAttach->IsNode() ) 
    {
        fLeft = FALSE;
        do 
            ptp = ptp->NextTreePos();
        while ( !ptp->IsNode() );  
    }

    return (fLeft == ptp->IsEndNode()) ? ptp->Branch()->Parent()
                                       : ptp->Branch();
}

#if DBG != 1
#pragma optimize("", on)
#endif

BOOL
CTreePosGap::IsValid() const
{
    AssertSz(_ptpAttach, "Gap is not positioned");

    BOOL result = !_ptpAttach->IsNode();

    if (!result)
    {
        CTreePos *ptpLeft = _fLeft ? _ptpAttach : _ptpAttach->PreviousTreePos();
        CTreePos *ptpRight = _fLeft ? _ptpAttach->NextTreePos() : _ptpAttach;

        result = !(
            (ptpLeft->IsEndNode() && !ptpLeft->IsEdgeScope())
         || (ptpRight->IsBeginNode() && !ptpRight->IsEdgeScope())
            );
    }

    return result;
}


void
CTreePosGap::SetAttachPreference(TPG_DIRECTION eDir)
{
    _eAttach = eDir;

    if (eDir!=TPG_EITHER && (eDir==TPG_LEFT)!=!!_fLeft && _ptpAttach)
    {
        if (_fLeft)
        {
            MoveTo(_ptpAttach->NextTreePos(), TPG_LEFT);
        }
        else
        {
            MoveTo(_ptpAttach->PreviousTreePos(), TPG_RIGHT);
        }
    }
}


HRESULT
CTreePosGap::MoveTo(CTreePos *ptp, TPG_DIRECTION eDir)
{
    Assert(ptp && (eDir==TPG_LEFT || eDir==TPG_RIGHT));
    BOOL fLeft = (eDir != TPG_LEFT);        // now from the gap's point of view
    HRESULT hr;

    // adjust for my attach preference
    if (_eAttach!=TPG_EITHER && fLeft!=(_eAttach==TPG_LEFT))
    {
        ptp = fLeft ? ptp->NextTreePos() : ptp->PreviousTreePos();
        fLeft = !fLeft;
    }

    // make sure the requested gap is in the scope of the restricting element
    if (_pElemRestrict)
    {
        if (ptp->SearchBranchForElement(_pElemRestrict, !fLeft) == NULL)
        {
            hr = E_UNEXPECTED;
            goto Cleanup;
        }
    }

    UnPosition();
    _ptpAttach = ptp;
    _fLeft = fLeft;
    WHEN_DBG( _ptpAttach->AttachGap(); )
    hr = S_OK;

Cleanup:
    return hr;
}

HRESULT
CTreePosGap::MoveToCp(CMarkup * pMarkup, long cp)
{
    HRESULT     hr;
    long        ich;
    CTreePos *  ptp;

    ptp = pMarkup->TreePosAtCp( cp, &ich );
    if(!ptp)
        return E_FAIL;
    
    if (ich)
    {
        Assert( ptp->IsText() );

        hr = THR( pMarkup->Split( ptp, ich ) );
        if (hr)
            goto Cleanup;

        hr = THR( MoveTo( ptp, TPG_RIGHT ) );
        if (hr)
            goto Cleanup;
    }
    else
    {
        hr = THR( MoveTo( ptp, TPG_LEFT ) );
        if (hr)
            goto Cleanup;
    }

Cleanup:
    RRETURN( hr );
}

HRESULT
CTreePosGap::MoveImpl(BOOL fLeft,
                      DWORD dwMoveFlags,
                      CTreePos **pptpEdgeCrossed
                      )
{
    HRESULT hr;
    BOOL fFirstTime = TRUE;
    const BOOL fAttachToCurr = (fLeft == !_fLeft);
    CTreePos *ptpCurr = fAttachToCurr ? _ptpAttach :
            _fLeft ? _ptpAttach->NextTreePos() : _ptpAttach->PreviousTreePos();
    CTreePos *ptpAdv;
    CTreePos *ptpAttach = NULL;

    Assert(_eAttach!=TPG_EITHER ||
            0 == (dwMoveFlags & (TPG_SKIPPOINTERS | TPG_FINDTEXT | TPG_FINDEDGESCOPE)) );

    if (pptpEdgeCrossed)
        *pptpEdgeCrossed = NULL;

    for (ptpAdv = fLeft ? ptpCurr->PreviousTreePos() : ptpCurr->NextTreePos();
         ptpAdv;
         ptpCurr = ptpAdv,  ptpAdv = fLeft ? ptpCurr->PreviousTreePos() : ptpCurr->NextTreePos() )
    {
        ptpAttach = fAttachToCurr ? ptpCurr : ptpAdv;

        if (!fFirstTime)
        {
            // if we've left the scope of the restricting element, fail
            if (_pElemRestrict)
            {
                if (ptpCurr->IsNode() && ptpCurr->IsEdgeScope() &&
                    ptpCurr->Branch()->Element() == _pElemRestrict)
                {
                    ptpAdv = NULL;
                    break;
                }
            }

            // track any begin-scope or end-scope nodes that we cross over
            if (pptpEdgeCrossed && ptpCurr->IsNode() && ptpCurr->IsEdgeScope() )
            {
                AssertSz(*pptpEdgeCrossed == NULL, "Crossed multiple begin or endscope TreePos");
                *pptpEdgeCrossed = ptpCurr;
            }
        }
        else
        {
            // if it's not OK to stay still, force the first advance
            fFirstTime = FALSE;
            if (!(dwMoveFlags & TPG_OKNOTTOMOVE))
                continue;
        }

        // if caller wants a valid gap, advance if we're not in one
        if ((dwMoveFlags & TPG_VALIDGAP))
        {
            CTreePos *ptpLeft = fLeft ? ptpAdv : ptpCurr;
            CTreePos *ptpRight = fLeft ? ptpCurr : ptpAdv;
            if (!CTreePos::IsLegalPosition(ptpLeft, ptpRight))
                continue;
        }

        // if caller wants to skip pointers, advance if we're at one
        if (ptpAttach->IsPointer() && (dwMoveFlags & TPG_SKIPPOINTERS))
            continue;

        // if caller wants a text position, advance if we're not at one
        if (!ptpAttach->IsText() && (dwMoveFlags & TPG_FINDTEXT))
            continue;

        // if caller wants an edge-scope position, advance if we're not at one
        if ((dwMoveFlags & TPG_FINDEDGESCOPE) &&
            !(ptpAttach->IsNode() && ptpAttach->IsEdgeScope()) )
            continue;

        // if we've survived the gauntlet above, we're in a good gap
        break;
    }

    // if we found a good gap, move there
    if (ptpAdv)
    {
        UnPosition();
        _ptpAttach = ptpAttach;
        WHEN_DBG( _ptpAttach->AttachGap(); )
        hr = S_OK;
    }
    else
    {
        hr = E_UNEXPECTED;
    }

    return hr;
}


/////////////////////////////////////////////////////////
// Method:      PartitionPointers
//
// Synopsis:    Permute any Pointer treepos around this gap so that the
//              ones with left-gravity come before the ones with right-
//              gravity, and the gap is positioned between the two groups.
//              Within each group, the pointers should be stable - i.e. they
//              maintain their relative positions.
//
//              Normal operation treats empty text poses as pointers
//              with right gravity.  However, if fDOMPartition is TRUE,
//              then empty text poses are treated as content.

// NOTE:        this might be faster if we didn't use gaps internally

void
CTreePosGap::PartitionPointers(CMarkup * pMarkup, BOOL fDOMPartition)
{
    TPG_DIRECTION eSaveAttach = (TPG_DIRECTION)_eAttach;
    CTreePosGap tpgMiddle( TPG_RIGHT );

    Assert( ! AttachedTreePos()->GetMarkup()->HasUnembeddedPointers() );
    Assert( pMarkup );

    // move left to the beginning of the block of pointers
    SetAttachPreference(TPG_LEFT);
    while ( AttachedTreePos()->IsPointer()
        ||      AttachedTreePos()->IsText() && AttachedTreePos()->Cch() == 0 
            &&  (!fDOMPartition || AttachedTreePos()->TextID() == 0 ) )
    {
        MoveLeft();
    }

    // now move right, looking for left-gravity pointers
    SetAttachPreference(TPG_RIGHT);
    tpgMiddle.MoveTo( this );
    while ( AttachedTreePos()->IsPointer()
        ||      AttachedTreePos()->IsText() && AttachedTreePos()->Cch() == 0 
            &&  (!fDOMPartition || AttachedTreePos()->TextID() == 0 ) )
    {
        if (    AttachedTreePos()->IsPointer() 
            &&  AttachedTreePos()->Gravity() == POINTER_GRAVITY_Left)
        {
            // If tpg is in the same place, no need to move the pointer.
            if(AttachedTreePos() != tpgMiddle.AttachedTreePos())
            {
                CTreePos * ptpToMove = AttachedTreePos();

                // Don't move us along with the pointer.
                SetAttachPreference(TPG_LEFT);

                Verify( ! pMarkup->Move(ptpToMove, &tpgMiddle) );

                // So now we're attached to the next pointer.
                SetAttachPreference(TPG_RIGHT);
            }
            else
            {
                // Nothing changed, so move on ahead.
                MoveRight();
                tpgMiddle.MoveTo( this );
            }
        }
        else
        {
            MoveRight();
        }
    }

    // Position myself in the middle
    MoveTo( &tpgMiddle );

    // restore my state
    SetAttachPreference(eSaveAttach);
}

/////////////////////////////////////////////////////////
// Method:      CleanCling
//
// Synopsis:    Assuming that the current gap is in 
//              the middle of a group of pointers that
//              has been positioned

void    
CTreePosGap::CleanCling( CMarkup *pMarkup, TPG_DIRECTION eDir, BOOL fDOMPartition )
{
    Assert( eDir == TPG_LEFT || eDir == TPG_RIGHT );
    BOOL fLeft = eDir == TPG_LEFT;
    CTreePos * ptp = AdjacentTreePos( eDir );
    CTreePos * ptpNext;

    while ( ptp->IsPointer()
        ||      ptp->IsText() && ptp->Cch() == 0 
            &&  (!fDOMPartition || ptp->TextID() == 0 ) )
    {
        ptpNext = fLeft ? ptp->PreviousTreePos() : ptp->NextTreePos();

        if (    ptp->IsPointer() && ptp->Cling()
            ||      ptp->IsText() && ptp->Cch() == 0 
                &&  (!fDOMPartition || ptp->TextID() == 0 ) )
        {
            if (AttachedTreePos() == ptp)
            {
                Assert( AttachDirection() == eDir );
                Move( eDir );
            }

            Verify( ! pMarkup->Remove( ptp ) );
        }

        ptp = ptpNext;
    }
}

///////////////////////////////////////////////////////////////////////////////
//
//  Class:      CChildIterator
//
///////////////////////////////////////////////////////////////////////////////

CChildIterator::CChildIterator( 
    CElement * pElementParent,
    CElement * pElementChild,
    DWORD dwFlags,
    ELEMENT_TAG *pStopTags,
    long cStopTags,
    ELEMENT_TAG *pChildTags,
    long cChildTags)
{
    AssertSz( !(dwFlags & ~CHILDITERATOR_PUBLICMASK), "Invalid flags passed to CChildIterator constructor" );
    _dwFlags = dwFlags;

#ifndef V4FRAMEWORK // CTreeIterator initializes safetly with NULL Parent
    Assert( pElementParent );
#endif V4FRAMEWORK

    if( pElementChild )
    {
        _pNodeChild = pElementChild->GetFirstBranch();

        Assert( _pNodeChild );

        _pNodeParent = _pNodeChild->SearchBranchToRootForScope( pElementParent );
        Assert( _pNodeParent );
    }
    else
    {
        SetBeforeBeginBit();
        _pNodeChild = NULL;
        _pNodeParent = pElementParent->GetFirstBranch();
    }

    AssertSz( _pNodeParent, "CChildIterator used with parent not in tree -- not a tree bug");

    if (UseTags())
    {
        _pStopTags = pStopTags;
        _cStopTags = cStopTags;

        _pChildTags = pChildTags;
        _cChildTags = cChildTags;
    }
    
#if DBG == 1
    if(_pNodeParent && _pNodeParent->GetMarkup())
        _lTreeVersion = _pNodeParent->GetMarkup()->GetMarkupTreeVersion();
#endif
}


void
CChildIterator::SetChild( CElement * pElementChild )
{
    WHEN_DBG( Invariant() );

    Assert( pElementChild && pElementChild->GetFirstBranch() );

    _pNodeChild = pElementChild->GetFirstBranch();
    _pNodeParent = _pNodeChild->SearchBranchToRootForScope( _pNodeParent->Element() );

    Assert( _pNodeParent );
}

void
CChildIterator::SetBeforeBegin( )
{
    WHEN_DBG( Invariant() );

    _pNodeChild = NULL;
    _pNodeParent = _pNodeParent->Element()->GetFirstBranch();

    Assert( _pNodeParent );

    SetBeforeBeginBit();
    ClearAfterEndBit();
}

void
CChildIterator::SetAfterEnd( )
{
    WHEN_DBG( Invariant() );

    _pNodeChild = NULL;
    _pNodeParent = _pNodeParent->Element()->GetFirstBranch();

    while (_pNodeParent->NextBranch())
        _pNodeParent = _pNodeParent->NextBranch();

    Assert( _pNodeParent );

    ClearBeforeBeginBit();
    SetAfterEndBit();
}

BOOL 
CChildIterator::ReInitWithCurrentChild()
{
    WHEN_DBG( Invariant() );

    // If we are after the end of the child list,
    // we can't go any further
    if( IsAfterEnd() || IsBeforeBegin() )
        return FALSE;

    Assert( _pNodeChild );

    _pNodeParent = _pNodeChild;
    _pNodeChild = NULL;
    SetBeforeBeginBit();

    return TRUE;
}

BOOL 
CChildIterator::ReInitWithParent()
{
    WHEN_DBG( Invariant() );

    Assert( _pNodeParent );

    if ( !_pNodeParent->Parent() )
        return FALSE;

    _pNodeChild = _pNodeParent;
    _pNodeParent = _pNodeParent->Parent();

    ClearBeforeBeginBit();
    ClearAfterEndBit();

    return TRUE;
}

CTreeNode * 
CChildIterator::NextChild()
{
    WHEN_DBG( Invariant() );

    // If we are after the end of the child list,
    // we can't go any further
    if( IsAfterEnd() )
        return NULL;

    CTreePos * ptpCurr;
    CTreeNode *pNodeParentCurr = _pNodeParent;
    BOOL       fFirst = TRUE;

    //
    // Decide where to start.  
    // * If we already have a child either start after that 
    //   child or just inside of it, dependent on the virtual 
    //   IsRecursionStopChildNode call.
    // * If we are before begin, start just inside of the
    //   parent node.
    //
    if( _pNodeChild )
    {
        ptpCurr = IsRecursionStopChildNode( _pNodeChild )
            ? _pNodeChild->GetEndPos()
            : _pNodeChild->GetBeginPos();
    }
    else
    {
        Assert( IsBeforeBeginBit() );
        ClearBeforeBeginBit();

        ptpCurr = _pNodeParent->GetBeginPos();
    }

    Assert( ptpCurr && !ptpCurr->IsUninit() );

    //
    // Do this loop while we have a parent that we are interested in
    //
    while (pNodeParentCurr)
    {
        CTreePos *  ptpParentEnd = pNodeParentCurr->GetEndPos();

        fFirst = FALSE;

        // Since this is a good parent, set the member variable
        _pNodeParent = pNodeParentCurr;

        //
        // Loop through everything under this parent.
        //
        for( ptpCurr = ptpCurr->NextTreePos();
             ptpCurr != ptpParentEnd;
             ptpCurr = ptpCurr->NextTreePos() )
        {
            // If this is a begin node, investigate further
            if( ptpCurr->IsBeginNode() )
            {
                CTreeNode * pNodeChild = ptpCurr->Branch();

                // return this node if we have an edge scope and
                // the child is interesting.
                if( ptpCurr->IsEdgeScope() && 
                    IsInterestingChildNode( pNodeChild ) )
                {
                    _pNodeChild = pNodeChild;
                    return _pNodeChild;
                }
                
                // Decide if we want to skip over this node's
                // subtree
                if( IsRecursionStopChildNode( pNodeChild ) )
                {
                    ptpCurr = pNodeChild->GetEndPos();
                }
            }
        }

        // Move on to the next parent node
        pNodeParentCurr = pNodeParentCurr->NextBranch();
        if( pNodeParentCurr )
        {
            ptpCurr = pNodeParentCurr->GetBeginPos();
        }
    }

    // If we got here, we ran out of parent nodes, so we must be
    // after the end.
    SetAfterEndBit();
    _pNodeChild = NULL;
    return NULL;
}

CTreeNode * 
CChildIterator::PreviousChild()
{
    WHEN_DBG( Invariant() );

    // If we are after the end of the child list,
    // we can't go any further
    if( IsBeforeBegin() )
        return NULL;

    CTreePos * ptpCurr;
    CTreeNode *pNodeParentCurr = _pNodeParent;

    //
    // Decide where to start.  
    // * If we already have a child either start before that 
    //   child or just inside of it, dependent on the virtual 
    //   IsRecursionStopChildNode call.
    // * If we are after end, start just inside of the
    //   parent node.
    //
    if( _pNodeChild )
    {
        ptpCurr = IsRecursionStopChildNode( _pNodeChild )
            ? _pNodeChild->GetBeginPos()
            : _pNodeChild->GetEndPos();
    }
    else
    {
        Assert( IsAfterEndBit() );
        ClearAfterEndBit();

        ptpCurr = _pNodeParent->GetEndPos();
    }

    while( pNodeParentCurr )
    {
        CTreePos * ptpStop = pNodeParentCurr->GetBeginPos();

        // Since this is a good parent, set the member variable
        _pNodeParent = pNodeParentCurr;

        //
        // Loop through everything under this parent.
        //
        for( ptpCurr = ptpCurr->PreviousTreePos();
             ptpCurr != ptpStop;
             ptpCurr = ptpCurr->PreviousTreePos() )
        {
            Assert(     ! ptpCurr->IsNode() 
                    ||  ptpCurr->Branch()->SearchBranchToRootForNode( pNodeParentCurr ) );

            // If this is a begin node, investigate further
            if( ptpCurr->IsEndNode() )
            {
                CTreeNode * pNodeChild = ptpCurr->Branch();
                CTreePos * ptpBegin = pNodeChild->GetBeginPos();

                // return this node if we have an edge scope and
                // the child is interesting.
                if( ptpBegin->IsEdgeScope() && 
                    IsInterestingChildNode( pNodeChild ) )
                {
                    _pNodeChild = pNodeChild;
                    return _pNodeChild;
                }
                
                // Decide if we want to skip over this nodes
                // subtree
                if( IsRecursionStopChildNode( pNodeChild ) )
                {
                    ptpCurr = ptpBegin;
                }
            }
        }

        // Find the previous node in the context chain
        if( pNodeParentCurr == pNodeParentCurr->Element()->GetFirstBranch() )
        {
            pNodeParentCurr = NULL;
        }
        else
        {
            CTreeNode * pNodeTemp = pNodeParentCurr->Element()->GetFirstBranch();
            while( pNodeTemp->NextBranch() != pNodeParentCurr )
            {
                pNodeTemp = pNodeTemp->NextBranch();
            }
            Assert( pNodeTemp );
            pNodeParentCurr = pNodeTemp;
        }

        if( pNodeParentCurr )
        {
            ptpCurr = pNodeParentCurr->GetEndPos();
        }
    }

    // If we got here, we ran out of parent nodes, so we must be
    // before begin.
    SetBeforeBeginBit();
    _pNodeChild = NULL;
    return NULL;
}

#if DBG==1
void
CChildIterator::Invariant()
{
    CMarkup *pMarkup = _pNodeParent->GetMarkup();
    Assert (pMarkup);
    AssertSz( pMarkup->GetMarkupTreeVersion() == _lTreeVersion,
              "CChildIterator used while tree is changing" );
    Assert( !!IsBeforeBeginBit() + !!IsAfterEndBit() + !!_pNodeChild == 1 );
}
#endif


BOOL
CChildIterator::IsInterestingNode(ELEMENT_TAG * pary, long c, CTreeNode * pNode)
{
    if (UseLayout())
    {
        return pNode->ShouldHaveLayout();
    }

    if (UseTags() && c > 0)
    {
        long   i;

        for (i = 0; i < c; i++, pary++)
        {
            if (*pary == pNode->Tag())
                return TRUE;
        }

        return FALSE;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\text\tinfo.cxx ===
/*
 *  @doc    INTERNAL
 *
 *  @module TINFO.CXX -- tree info related stuff
 *
 *
 *  Owner: <nl>
 *      Sujal Parikh <nl>
 *
 *  History: <nl>
 *      5/6/98     sujalp created
 *
 *  Copyright (c) 1997-1998 Microsoft Corporation. All rights reserved.
 */

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_LINESRV_HXX_
#define X_LINESRV_HXX_
#include "linesrv.hxx"
#endif

#ifndef X_ONERUN_HXX_
#define X_ONERUN_HXX_
#include "onerun.hxx"
#endif

//-----------------------------------------------------------------------------
//
//  Function:   InitializeTreeInfo
//
//  Synopsis:   Initializes the tree info structure at the current cp/irun
//
//  Returns:    HR
//
//-----------------------------------------------------------------------------
HRESULT
CTreeInfo::InitializeTreeInfo(CFlowLayout *pFlowLayout, BOOL fIsEditable, LONG cp, CTreePos *ptp)
{
    HRESULT hr = S_FALSE;
    CTreeNode *pNode;
    
    //
    // Setup the easy stuff first
    //
    Assert(pFlowLayout);
    _pFlowLayout = pFlowLayout;
    _fIsEditable = fIsEditable;
    Assert(!!_fIsEditable == !!_pFlowLayout->IsEditable());
    _pMarkup = pFlowLayout->GetContentMarkup();
    _lscpFrontier = cp;
    _cpFrontier = cp;
    _chSynthsBefore = 0;
    _fHasNestedElement = _fHasNestedLayout = _fHasNestedRunOwner = FALSE;
    
    //
    // If a ptp was specified, use it, or find one from basice principles
    //
    if (ptp == NULL)
    {
        LONG cchOffset;
        
        _ptpFrontier = _pMarkup->TreePosAtCp(cp, &cchOffset, TRUE);
        if (_ptpFrontier == NULL)
            goto Cleanup;
    }
    else
    {
        _ptpFrontier = ptp;
    }
    Assert(_ptpFrontier);
    Assert(   _ptpFrontier->GetCp() <= cp
           && _ptpFrontier->GetCp() + _ptpFrontier->GetCch() >= cp
          );
    
    //
    // Figure out if we are positioned at a layout/nested run owner
    //
    if (_ptpFrontier->IsBeginElementScope())
    {
        pNode = _ptpFrontier->Branch();

        if (pNode->ShouldHaveLayout())
        {
            _fHasNestedElement = TRUE;
            _fHasNestedLayout = TRUE;
            if (pNode->Element()->IsRunOwner())
            {
                Assert(pNode->Element() != _pFlowLayout->ElementContent());
                _fHasNestedRunOwner = TRUE;
            }
        }
    }
    
    //
    // How many characters in this tree node?
    //
    if (_ptpFrontier->IsText() && _ptpFrontier->Cch() != 0)
    {
        WHEN_DBG(LONG ichTemp);
        LONG ich = cp - _ptpFrontier->GetCp();
        
        SetCchRemainingInTreePos(_ptpFrontier->Cch() - ich);

#if DBG==1
        if (GetCchRemainingInTreePosReally())
        {
            CTreePos *ptpDbg = _pMarkup->TreePosAtCp(cp, &ichTemp, TRUE);
            while(ptpDbg && ptpDbg->IsPointer())
                ptpDbg = ptpDbg->NextTreePos();
            Assert(_ptpFrontier == ptpDbg);
            Assert(ich == ichTemp);
        }
#endif        
    }
    else if (_ptpFrontier->IsNode() && !_fHasNestedElement)
    {
        if (_ptpFrontier->IsEdgeScope())
            SetCchRemainingInTreePos(1);
        else
            SetCchRemainingInTreePos(0, TRUE);
    }
    else
        SetCchRemainingInTreePos(0);
    
    //
    // Setup the text related state variables
    //
    _tpFrontier.SetCp(cp);
    _pchFrontier = _tpFrontier.GetPch(_cchValid);
    if (_pchFrontier == NULL)
        goto Cleanup;
    _tpFrontier.AdvanceCp(_cchValid);
    
    //
    // Decide the CF's and PF's
    //
    pNode = _ptpFrontier->GetBranch();
    SetupCFPF(TRUE, pNode FCCOMMA LC_TO_FC(pFlowLayout->LayoutContext()));

    if (   !_fHasNestedElement
        && !_fIsEditable
        && _ptpFrontier->IsNode()
        && _pCF->IsDisplayNone()
       )
    {
        _fHasNestedElement = TRUE;
        SetCchRemainingInTreePos(0);
    }

    _fInited = TRUE;

    hr = S_OK;

Cleanup:
    RRETURN(hr);
}

//-----------------------------------------------------------------------------
//
//  Function:   SetupCFPF
//
//  Synopsis:   Sets up the CF and PF in the tree info including the 'inner' flags
//
//  Returns:    Nothing
//
//-----------------------------------------------------------------------------
void
CTreeInfo::SetupCFPF(BOOL fIniting, CTreeNode *pNode FCCOMMA FORMAT_CONTEXT FCPARAM)
{
    // Get the CF
    _pCF = pNode->GetCharFormat(FCPARAM);
    _fInnerPF = _fInnerCF = SameScope(pNode, _pFlowLayout->ElementContent());

    if (fIniting)
    {
        _pPF = pNode->GetParaFormat(FCPARAM);
        _iPF = pNode->GetParaFormatIndex(FCPARAM);
        _pFF = pNode->GetFancyFormat(FCPARAM);
        _iFF = pNode->GetFancyFormatIndex(FCPARAM);
    }
    else
    {
        LONG iPF = pNode->GetParaFormatIndex(FCPARAM);
        LONG iFF = pNode->GetFancyFormatIndex(FCPARAM);

        if (iPF != _iPF)
        {
            extern CParaFormat g_pfStock;

            _iPF = iPF;
            _pPF = iPF >= 0 ? GetParaFormatEx(_iPF) : &g_pfStock;
            
        }

        if (iFF != _iFF)
        {
            extern CFancyFormat g_ffStock;

            _iFF = iFF;
            _pFF = iFF >= 0 ? GetFancyFormatEx(_iFF) : &g_ffStock;
        }

        Assert(_pFF == pNode->GetFancyFormat(FCPARAM));
        Assert(_pPF == pNode->GetParaFormat(FCPARAM));
    }
}

//-----------------------------------------------------------------------------
//
//  Function:   AdvanceTreePos
//
//  Synopsis:   Advances the frontier to the next tree position
//
//  Returns:    Was advance sucessful?
//
//-----------------------------------------------------------------------------
BOOL
CTreeInfo::AdvanceTreePos(FORMAT_CONTEXT FCPARAM)
{
    CTreePos  *ptp  = _ptpFrontier;
    BOOL       fRet = FALSE;
    CTreeNode *pNode;
    BOOL       fCallSetupCFPF;
    
    Assert(GetCchRemainingInTreePos() == 0);
    Assert(_fHasNestedElement == FALSE);

    //
    // If this is the end node then do not go any further.
    //
    if (ptp == _ptpLayoutLast)
    {
        fRet = TRUE;
        goto Cleanup;
    }

    //
    // If we were at an end-ptp, and the ptp after us were a text ptp
    // then we will want to setup the cfpf with the end-ptp's parent node
    // If the next ptp were a node ptp, then the pNode will be overwritten
    //
    pNode = ptp->IsEndNode() ? ptp->Branch()->Parent() : NULL;
    
    // Find a desireable pos to be in
    //
    for(ptp = ptp->NextTreePos(); ; ptp = ptp->NextTreePos())
    {
        Assert(ptp);
        if(!ptp)
        {
            fRet = FALSE;
            goto Cleanup;
        }

        if (   ptp->IsNode()
            || (ptp->IsText() && ptp->Cch())
           )
            break;

        // Since _ptpLayoutLast is a Node above check should have succeeded
        Assert(ptp != _ptpLayoutLast);
    }

    if (ptp->IsNode())
    {
        pNode = ptp->Branch();
        //
        // TODO (SujalP, IE6 bug 62): Might have a problem with overlapping layout-scopes here
        //
        if (   ptp->IsBeginElementScope()
            && pNode->ShouldHaveLayout(FCPARAM)
           )
        {
            CElement *pElement = pNode->Element();
            if (pElement->IsRunOwner())
            {
                Assert(pElement != _pFlowLayout->ElementContent());

#if DBG==1
// There's some issue here with how we get layouts.  Disable debug
// checks for now
#ifndef MULTI_LAYOUT

                CLayout *pLayout1, *pLayout2;

                pLayout1 = _pMarkup->GetRunOwner(pNode, _pFlowLayout);
                Assert( pElement->ShouldHaveLayout() && "Should have confirmed node needs layout!");
                pLayout2 = pElement->GetUpdatedLayout();
                CElement *pElementOwner1 = pLayout1->ElementOwner();

                //
                // NOTE(SujalP): This assert is invalid when we have nested layouts.
                // See bug 54648.
                //
                if (   pElementOwner1
                    && pElementOwner1->IsOverlapped()
                   )
                {
                    pLayout1 = pLayout2;
                }
                    
                Assert(pLayout1 == pLayout2);
#endif // MULTI_LAYOUT
#endif // DBG
                _fHasNestedRunOwner = TRUE;
            }
            _fHasNestedElement = TRUE;
            _fHasNestedLayout = TRUE;
            SetCchRemainingInTreePos(0);
        }
        else if (ptp->IsEdgeScope())
            SetCchRemainingInTreePos(1);
        else
            SetCchRemainingInTreePos(0, TRUE);

        fCallSetupCFPF = (ptp == _ptpLayoutLast) ? FALSE : TRUE;
    }
    else
    {
        fCallSetupCFPF = pNode ? TRUE : FALSE;
        SetCchRemainingInTreePos(ptp->Cch());
    }

    if (fCallSetupCFPF)
    {
        Assert(pNode);
        SetupCFPF(FALSE, pNode FCCOMMA FCPARAM);
        if (   _pCF->IsDisplayNone()
            && !_fHasNestedElement
            && !_fIsEditable
            && ptp->IsBeginElementScope()
           )
        {
            AssertSz(ptp->IsNode(), "Cannot have a hidden text run here!");
            _fHasNestedElement = TRUE;
            SetCchRemainingInTreePos(0);
        }
    }
    
    _ptpFrontier = ptp;
    fRet = TRUE;
    
Cleanup:
    Assert(fRet);
    return fRet;
}

//-----------------------------------------------------------------------------
//
//  Function:   AdvanceTxtPtr
//
//  Synopsis:   Advances the text pointer further into the text.
//
//  Returns:    BOOL
//
//-----------------------------------------------------------------------------
BOOL
CTreeInfo::AdvanceTxtPtr()
{
    Assert(_cchValid == 0);

    _pchFrontier = _tpFrontier.GetPch(_cchValid);
    _tpFrontier.AdvanceCp(_cchValid);
    return !!_pchFrontier;
}

//-----------------------------------------------------------------------------
//
//  Function:   AdvanceFrontier.
//
//  Synopsis:   Advances the frontier based on the onerun. Called at the tail end
//              of advance one run.
//
//  Returns:    Nothing
//
//-----------------------------------------------------------------------------
void
CTreeInfo::AdvanceFrontier(COneRun *por)
{
    if (por->_lscch == 0 && !por->_fIsNonEdgePos)
    {
        Assert(por->_ptp == _ptpLayoutLast);
        goto Cleanup;
    }

    Assert(!por->IsSyntheticRun());
    if (_fHasNestedElement)
    {
        Assert(_ptpFrontier->IsNode());

        CTreePos  * ptpStart, *ptpStop;
        CElement  * pElement    = _ptpFrontier->Branch()->Element();
        long        cpElemLast  = pElement->GetLastCp();

        pElement->GetTreeExtent(&ptpStart, &ptpStop);
        Assert(ptpStart == _ptpFrontier);
        Assert(ptpStop);

        // for elements overlapping with our layout, advance the frontier to the
        // end of the current layout owner
        if(cpElemLast > _cpLayoutLast)
        {
            ptpStop = _ptpLayoutLast->PreviousTreePos();
        }

        _ptpFrontier = ptpStop;
        _fHasNestedElement  = FALSE;
        _fHasNestedLayout   = FALSE;
        _fHasNestedRunOwner = FALSE;

        //
        // Now advance the cp values past this one run
        //
        Assert(     por->_lscch == pElement->GetElementCch() + 2
                ||  (   cpElemLast > _cpLayoutLast
                    &&  _cpLayoutLast == _cpFrontier + por->_lscch));

        SetCchRemainingInTreePos(0);
        _lscpFrontier += por->_lscch;
        _cpFrontier += por->_lscch;
        
        //
        // Take care of the text related state vars
        //
        if (por->_lscch > _cchValid)
        {
            // The text run ended inside the table
            _tpFrontier.SetCp(_cpFrontier);
            _cchValid = 0;
        }
        else
        {
            _cchValid -= por->_lscch;
            _pchFrontier += por->_lscch;
        }
    }
    else
    {
        Assert(GetCchRemainingInTreePosReally() >= por->_lscch);

        if (_fIsNonEdgePos)
        {
            Assert(por->_lscch == 0);
            Assert(GetCchRemainingInTreePosReally() == 0);
            SetCchRemainingInTreePos(0);
        }
        else
        {
            SetCchRemainingInTreePos(GetCchRemainingInTreePosReally() - por->_lscch);
        }
        _lscpFrontier += por->_lscch;
        _cpFrontier += por->_lscch;
        
        Assert(_cchValid >= por->_lscch);
        _cchValid -= por->_lscch;
        _pchFrontier += por->_lscch;
    }
Cleanup:
    return;
}

//-----------------------------------------------------------------------------
//
//  Function:   FigureNextPtp.
//
//  Synopsis:   Figures the ptp at the cp
//
//  Returns:    CTreePos *
//
//-----------------------------------------------------------------------------
CTreePos *
CLineServices::FigureNextPtp(LONG cp)
{
    COneRun *por = _listCurrent._pTail;
    CTreePos *ptp = NULL;
    LONG cpAtEndOfOneRun;

    Assert(_treeInfo._fInited);
    
    if (!por)
        goto Cleanup;

    ptp = por->_ptp;
    if (ptp->IsBeginElementScope() && ptp->Branch()->ShouldHaveLayout())
    {
        GetNestedElementCch(ptp->Branch()->Element(), &ptp);
    }
    cpAtEndOfOneRun = por->Cp() + (por->IsSyntheticRun() ? 0 : por->_lscch);

    if (cpAtEndOfOneRun <= cp)
    {
        LONG cpAtEndOfPtp;

        if (   !por->IsSyntheticRun()
            && cpAtEndOfOneRun == cp
            && por->_lscch == ptp->GetCch()
           )
            cpAtEndOfPtp = cpAtEndOfOneRun;
        else
            cpAtEndOfPtp = ptp->GetCp() + ptp->GetCch();

        while (cpAtEndOfPtp <= cp)
        {
            Assert(ptp != _treeInfo._ptpLayoutLast);
            if (ptp->IsBeginElementScope() && ptp->Branch()->ShouldHaveLayout())
            {
                GetNestedElementCch(ptp->Branch()->Element(), &ptp);
            }
            else
            {
                ptp = ptp->NextTreePos();
            }
	    if(!ptp)
            {
		ptp = NULL;
                goto Cleanup;
            }
            cpAtEndOfPtp = ptp->GetCp() + ptp->GetCch();
        }
    }
    else
    {
        while (por)
        {
            if (   por->Cp() <= cp
                && por->Cp() + por->_lscch > cp
               )
            {
                break;
            }
            por = por->_pPrev;
        }
        Assert(por);

        //
        // Note(SujalP): Bug63941 shows us the problem that if we ended up on an
        // antisynthetic run, then the cp could anywhere within that run and hence
        // the ptp could be anything -- not necessarily the ptp of the first cp of
        // the run. Hence, if the cp is not the first cp of the anitsynth run then
        // we will derive the ptp from basic principles.
        //
        if (   !por
            || (   por->IsAntiSyntheticRun()
                && por->Cp() != cp
               )
           )
        {
            long junk;
            ptp = _treeInfo._pMarkup->TreePosAtCp(cp, &junk, TRUE);
        }
        else
            ptp = por->_ptp;
    }

#if DBG==1
    {
        long junk;
        CTreePos *ptpDbg = _treeInfo._pMarkup->TreePosAtCp(cp, &junk, TRUE);
        while (ptpDbg 
               && (ptpDbg->IsPointer() 
                   || (ptpDbg->IsNode() && !ptpDbg->IsEdgeScope())))
        {
            ptpDbg = ptpDbg->NextTreePos();
        }
        Assert(ptpDbg == ptp);
    }
#endif
    
    Assert(cp >= ptp->GetCp() && cp < ptp->GetCp() + ptp->GetCch());

Cleanup:
    return ptp;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\text\txtelems.cxx ===
//+---------------------------------------------------------------------
//
//   File:      txtelems.cxx
//
//  Contents:   Element class
//
//  Classes:    CElement
//
//------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_FORMKRNL_HXX_
#define X_FORMKRNL_HXX_
#include "formkrnl.hxx"
#endif

#ifndef X_MSHTMLRC_H_
#define X_MSHTMLRC_H_
#include "mshtmlrc.h"
#endif

#ifndef X_TXTELEMS_HXX_
#define X_TXTELEMS_HXX_
#include "txtelems.hxx"
#endif

#ifndef X_HTMLDLG_HXX_
#define X_HTMLDLG_HXX_
#include "htmldlg.hxx"
#endif

#define _cxx_
#include "textelem.hdl"

MtDefine(CTextElement, Elements, "CTextElement")

const CElement::CLASSDESC CTextElement::s_classdesc =
{
    {
        &CLSID_HTMLTextElement,             // _pclsid
        0,                                  // _idrBase
#ifndef NO_PROPERTY_PAGE
        s_apclsidPages,                     // _apClsidPages
#endif // NO_PROPERTY_PAGE
        s_acpi,                             // _pcpi
        ELEMENTDESC_NOLAYOUT,               // _dwFlags
        &IID_IHTMLTextElement,              // _piidDispinterface
        &s_apHdlDescs,                      // _apHdlDesc
    },
    (void *)s_apfnIHTMLTextElement,         // _pfnTearOff

    NULL                                    // _pAccelsRun
};


HRESULT CTextElement::CreateElement(CHtmTag *pht,
                              CDoc *pDoc, CElement **ppElementResult)
{
    Assert(ppElementResult);
    *ppElementResult = new CTextElement(pht->GetTag(), pDoc);
    return *ppElementResult ? S_OK : E_OUTOFMEMORY;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\text\txtparse.cxx ===
//+----------------------------------------------------------------------------
//
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1994-1995
//
//  File:       txtparse.cxx
//
//  Contents:   CHtmTextContext class
//
//-----------------------------------------------------------------------------


#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

//+----------------------------------------------------------------------------
//
//  Function:   InPre
//
//  Synopsis:   This computes the pre status of a branch after an element goes
//              out of scope.  The branch before the element goes out of scope
//              is passed in, as well as the element going out of scope.
//
//-----------------------------------------------------------------------------

CTreeNode *
InPre ( CTreeNode * pNodeCur, CTreeNode * pNodeEnd )
{
    CTreeNode *pNode;

    for ( pNode = pNodeCur ; pNode ; pNode = pNode->Parent() )
    {
        if (!pNodeEnd || DifferentScope( pNode, pNodeEnd ))
        {
            switch ( TagPreservationType( pNode->Tag()) )
            {
            case WSPT_PRESERVE : return pNode;
            case WSPT_COLLAPSE : return NULL;
            case WSPT_NEITHER  : break;
            default            : Assert( 0 );
            }
        }
    }

    return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\text\txtdefs.h ===
#ifndef I_TXTDEFS_H_
#define I_TXTDEFS_H_
#pragma INCMSG("--- Beg 'txtdefs.h'")

#ifndef X_UNIPROP_H_
#define X_UNIPROP_H_
#include "uniprop.h"
#endif

#define SYS_ALTERNATE		0x20000000
#define SYS_PREVKEYSTATE	0x40000000

#ifdef UNICODE
#define CbOfCch(_x) (DWORD)((_x) * sizeof(WCHAR))
#define CchOfCb(_x) (DWORD)((_x) / sizeof(WCHAR))
#else
#define CbOfCch(_x) (_x)
#define CchOfCb(_x) (_x)
#endif

// Logical unit definition
#define LX_PER_INCH 1440
#define LY_PER_INCH 1440

// Use explicit ASCII values for LF and CR, since MAC compilers
// interchange values of '\r' and '\n'
#define LF          10
#define CR          13
#define FF          TEXT('\f')
#define TAB         TEXT('\t')
#define VT          TEXT('\v')
#define PS          0x2029

inline BOOL IsASCIIEOP(TCHAR ch)
{
    return InRange( ch, LF, CR );
}

    //
    // This builds an HGLOBAL from a unicode html string
    //

HRESULT HtmlStringToSignaturedHGlobal (
    HGLOBAL * phglobal, const TCHAR * pStr, long cch );

HGLOBAL DuplicateHGlobal   (HGLOBAL hglobal);
HGLOBAL TextHGlobalAtoW    (HGLOBAL hglobal);
HGLOBAL TextHGlobalWtoA    (HGLOBAL hglobal);
INT     CountMatchingBits  (const DWORD *a, const DWORD *b, INT total);

//
// Unicode support
//

typedef BYTE CHAR_CLASS;
typedef BYTE SCRIPT_ID;
typedef BYTE DIRCLS;

// TODO (cthrash) Need to fix to reflect new partition table
// Selected Partition ids (used by FHangingPunct)
// Partitions are normally NOT named as they are used as transient index into the
// XXXXFromQPid arrays only. These 6 are an exception to avoid a largely redundant table.

#define qpidCommaN  18
#define qpidCommaH  19
#define qpidCommaW  20
#define qpidQuestN  32
#define qpidCenteredN   37
#define qpidPeriodN 41
#define qpidPeriodH 42
#define qpidPeriodW 43

extern const DIRCLS s_aDirClassFromCharClass[];
extern const UNIPROP s_aPropBitsFromCharClass[];

BOOL AreDifferentScriptIDs(SCRIPT_ID * psidFirst, SCRIPT_ID sidSecond);

inline DIRCLS
DirClassFromCh(WCHAR ch)
{
    return s_aDirClassFromCharClass[CharClassFromChSlow(ch)];
}

inline BOOL
IsGlyphableChar(WCHAR ch)
{
    // Temporary hack for Hangul Jamo range (Old Hangul characters)
    // They should by assigned to a different partition and have
    // similar properties to Surrogates
    if (InRange(ch, 0x1100, 0x11FF))
        return TRUE;
    return s_aPropBitsFromCharClass[CharClassFromChSlow(ch)].fNeedsGlyphing;
}

inline BOOL
IsCombiningMark(WCHAR ch)
{
    return s_aPropBitsFromCharClass[CharClassFromChSlow(ch)].fCombiningMark;
}

inline BOOL
IsZeroWidthChar(WCHAR ch)
{
    return s_aPropBitsFromCharClass[CharClassFromChSlow(ch)].fZeroWidth;
}

inline BOOL
HasWhiteBetweenWords(WCHAR ch)
{
    return s_aPropBitsFromCharClass[CharClassFromChSlow(ch)].fWhiteBetweenWords;
}

inline BOOL 
NoWhiteBetweenWords(WCHAR ch)
{
    return !HasWhiteBetweenWords(ch);
}

inline BOOL
IsMoveByClusterChar(WCHAR ch)
{
    return s_aPropBitsFromCharClass[CharClassFromChSlow(ch)].fMoveByCluster;
}


inline BOOL IsBiDiDiacritic(WCHAR ch)
{
    return (InRange(ch, 0x0591, 0x06ED) && IsCombiningMark(ch));
}

#define WCH_CP1252_MIN WCHAR(0x0152)
#define WCH_CP1252_MAX WCHAR(0x2122)

BYTE InWindows1252ButNotInLatin1Helper(WCHAR ch);

inline BYTE InWindows1252ButNotInLatin1(WCHAR ch)
{
    return InRange(ch, WCH_CP1252_MIN, WCH_CP1252_MAX) ? InWindows1252ButNotInLatin1Helper(ch) : 0;
}
    
#pragma INCMSG("--- End 'txtdefs.h'")
#else
#pragma INCMSG("*** Dup 'txtdefs.h'")
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\text\txtsaver.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1996.
//
//  File:       txtsaver.cpp
//
//  Contents:   Objects used for saving textedit object to stream
//
//  Classes:    CTextSaver
//              CRangeSaver
//
//----------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X__TXTSAVE_H_
#define X__TXTSAVE_H_
#include "_txtsave.h"
#endif

#ifndef X_TREEPOS_HXX_
#define X_TREEPOS_HXX_
#include "treepos.hxx"
#endif

#ifndef X_STRBUF_HXX_
#define X_STRBUF_HXX_
#include "strbuf.hxx"
#endif

#ifndef X_INTL_HXX_
#define X_INTL_HXX_
#include "intl.hxx"
#endif

#ifndef X_FLOWLYT_HXX_
#define X_FLOWLYT_HXX_
#include "flowlyt.hxx"
#endif

#ifndef X_EBODY_HXX_
#define X_EBODY_HXX_
#include "ebody.hxx"
#endif

#ifndef X_HEDELEMS_HXX_
#define X_HEDELEMS_HXX_
#include "hedelems.hxx"
#endif

#ifndef X_TPOINTER_HXX_
#define X_TPOINTER_HXX_
#include "tpointer.hxx"
#endif


DeclareTag(tagSaveShowSelection, "Save", "Save: Show CF_HTML selection");

MtDefine(CRangeSaver_local_aryElements_pv, Locals, "CRangeSaver local func aryElements::_pv")


//+---------------------------------------------------------------------------
//
//  Member:     CRangeSaver constructor
//
//  Synopsis:   Set up a range saver object.
//
//----------------------------------------------------------------------------

CRangeSaver::CRangeSaver(
    CMarkupPointer *    pLeft,
    CMarkupPointer *    pRight,
    DWORD               dwFlags,
    CStreamWriteBuff *  pswb,
    CMarkup *           pMarkup,
    CElement *          pelContainer )
    : CTreeSaver( pMarkup )
{
    Initialize( pLeft, pRight, dwFlags, pswb, pMarkup, pelContainer );
}


void
CRangeSaver::Initialize(
    CMarkupPointer *    pLeft,
    CMarkupPointer *    pRight,
    DWORD               dwFlags,
    CStreamWriteBuff *  pswb,
    CMarkup *           pMarkup,
    CElement *          pelContainer )
{
    Assert( pLeft && pRight && pswb && pMarkup );
    Assert( pLeft->IsPositioned() && pRight->IsPositioned() );
    Assert( pLeft->Markup() == pMarkup );
    Assert( pRight->Markup() == pMarkup );

    IGNORE_HR( pMarkup->EmbedPointers () );

    // Set CTreeSaver data
    _pswb            = pswb;
    _pMarkup         = pMarkup;
    _pelContainer    = pelContainer;
    _fSymmetrical    = TRUE;

    Verify( ! _tpgStart.MoveTo( pLeft->GetEmbeddedTreePos(), TPG_RIGHT ) );
    _tpgStart.SetAttachPreference( TPG_RIGHT );
    Verify( ! _tpgStart.MoveRight( TPG_OKNOTTOMOVE | TPG_SKIPPOINTERS ) );
    _fLBStartLeft = FALSE;
        
    Verify( ! _tpgEnd.MoveTo( pRight->GetEmbeddedTreePos(), TPG_RIGHT ) );
    _tpgEnd.SetAttachPreference( TPG_RIGHT );
    Verify( ! _tpgEnd.MoveRight( TPG_OKNOTTOMOVE | TPG_SKIPPOINTERS ) );
    _fLBEndLeft = FALSE;    

    Assert( !_pelContainer 
        ||  (   _tpgStart.Branch()->SearchBranchToRootForScope( pelContainer )
            &&  _tpgEnd.Branch()->SearchBranchToRootForScope( pelContainer ) ) );

    // Set CRangeSaver data
    _dwFlags         = dwFlags;
    memset(&_header, 0, sizeof(_header));

    if( ! (_dwFlags & RSF_NO_IE4_COMPAT_SEL) )
    {
        DoIE4SelectionCollapse();
    }

    // Compute fragment element
    if( _dwFlags & RSF_NO_IE4_COMPAT_FRAG )
    {
        CTreeNode * pNodeLeft = _tpgStart.Branch();
        CTreeNode * pNodeRight = _tpgEnd.Branch();
        CTreeNode * pNodeCommon;

        pNodeCommon = pNodeLeft->GetFirstCommonAncestor( pNodeRight, NULL );
        Assert( pNodeCommon );

        _pelFragment = pNodeCommon->Element();
    }
    else
    {
        ComputeIE4Fragment();
    }

    if(     !(_dwFlags & RSF_NO_IE4_COMPAT_SEL) 
        &&  _dwFlags & RSF_SELECTION )
    {
        ComputeIE4Selection();
    }
}

#if 0
//+---------------------------------------------------------------------------
//
//  Member:     CRangeSaver::IE4CompatRangeContext
//
//  Synopsis:   Tries to figure out the same context element
//              that IE4 would have.
//
//----------------------------------------------------------------------------

CTreeNode *
CRangeSaver::IE4CompatRangeContext(CTreePos *ptpStart, CTreePos *ptpEnd)
{

    CTreeNode * pNodeReturn;
    CTreePos * ptpTry;
    CDoc     * pDoc = _pMarkup->Doc();
    CBodyElement *pBody;

    Assert(pDoc);

    pDoc->GetBodyElement(&pBody);

    Assert(pBody);

    //
    // Move our ptp's out to get to Node pos's
    //

    while( !ptpStart->IsNode() || !ptpStart->IsBeginNode() )
    {
        ptpStart = ptpStart->PreviousTreePos();
        Assert( ptpStart );
    }

    while( !ptpEnd->IsNode() || !ptpEnd->IsEndNode() )
    {
        ptpEnd = ptpEnd->NextTreePos();
        Assert( ptpEnd );
    }

    //
    // Move them out further to include nodes that influence us but not the adjacent run.
    //

    ptpTry = ptpStart;
    do
    {
        ptpStart = ptpTry;
        ptpTry = ptpStart->PreviousNonPtrTreePos();
        Assert( ptpTry );
    } while( ptpTry->IsNode() && ptpTry->IsBeginNode()
         && !pBody->GetFlowLayout()->IsElementBlockInContext( ptpTry->Branch()->Element() )
        );

    ptpTry = ptpEnd;
    do
    {
        ptpEnd = ptpTry;
        ptpTry = ptpEnd->NextNonPtrTreePos();
        Assert( ptpTry );
    } while( ptpTry->IsNode() && ptpTry->IsEndNode()
         && !pBody->GetFlowLayout()->IsElementBlockInContext( ptpTry->Branch()->Element() )
        );

    pNodeReturn= ptpStart->Branch()->GetFirstCommonAncestor( ptpEnd->Branch(), NULL );

    return pNodeReturn;
}
#endif

//+---------------------------------------------------------------------------
//
//  Member:     CRangeSaver::SaveSelection
//
//  Synopsis:   Called by CTreeSaver::Save to signify where the selection
//              begins and ends
//
//----------------------------------------------------------------------------
HRESULT 
CRangeSaver::SaveSelection( BOOL fEnd )
{
    HRESULT hr = S_OK;

    if (_dwFlags & RSF_CFHTML_HEADER)
    {
        if (fEnd)
        {
            //
            // Record the offset for the selection end
            //
            hr = GetStmOffset(&_header.iSelectionEnd);
            if (hr)
                goto Cleanup;

#if DBG == 1
            if (IsTagEnabled(tagSaveShowSelection))
            {
                _pswb->Write(_T("[SELEND]"));
            }
#endif
        }
        else        
        {
            //
            // Record the offset for the selection beginning
            //
#if DBG == 1
            if (IsTagEnabled(tagSaveShowSelection))
            {
                _pswb->Write(_T("[SELSTART]"));
            }
#endif
            
            hr = GetStmOffset(&_header.iSelectionStart);
            if (hr)
                goto Cleanup;
        }
    }
Cleanup:
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CRangeSaver::DoIE4SelectionCollapse
//
//  Synopsis:   Moves the gaps in to simulate the range that
//              IE4 started with when doing a range save
//
//----------------------------------------------------------------------------
void
CRangeSaver::DoIE4SelectionCollapse()
{
    // TODO (JBeda): handle a range with no content under it!

    // Move the start gap in until we hit real content
    _tpgStart.SetAttachPreference( TPG_RIGHT );

    while(  !(  _tpgStart.AttachedTreePos()->IsText() 
            &&  _tpgStart.AttachedTreePos()->Cch() ) )
    {
        // never cross container boundries
        if(     _tpgStart.AttachedTreePos()->IsNode()
            &&  _tpgStart.AttachedTreePos()->IsEdgeScope()
            &&  _tpgStart.AttachedTreePos()->Branch()->IsContainer() )
            break;

        // If we hit a LB char and we don't have it marked
        // on our left, break
        if(     !_fLBStartLeft 
            &&  LineBreakChar( &_tpgStart ) )
            break;

        _fLBStartLeft = FALSE;

        if( _tpgStart == _tpgEnd )
            break;

        Verify( ! _tpgStart.MoveRight() );
    }

    Verify( !_tpgStart.MoveLeft( TPG_VALIDGAP | TPG_OKNOTTOMOVE ) );

    // Move the end gap in until we hit real content
    _tpgEnd.SetAttachPreference( TPG_LEFT );

    while(  !(  _tpgEnd.AttachedTreePos()->IsText() 
            &&  _tpgEnd.AttachedTreePos()->Cch() ) 
        &&  ! _fLBEndLeft )
    {
        // never cross container boundries
        if(     _tpgEnd.AttachedTreePos()->IsNode()
            &&  _tpgEnd.AttachedTreePos()->IsEdgeScope()
            &&  _tpgEnd.AttachedTreePos()->Branch()->IsContainer() )
            break;

        if( _tpgStart == _tpgEnd )
            break;

        Verify( ! _tpgEnd.MoveLeft() );

        if (LineBreakChar( &_tpgEnd ))
        {
            _fLBEndLeft = TRUE;
            break;
        }
    }

    Verify( !_tpgEnd.MoveRight( TPG_VALIDGAP | TPG_OKNOTTOMOVE ) );
}


//+---------------------------------------------------------------------------
//
//  Member:     CRangeSaver::ComputeIE4Fragment
//
//  Synopsis:   Tries to figure out the same fragment element
//              that IE4 would have.
//
//----------------------------------------------------------------------------

void    
CRangeSaver::ComputeIE4Fragment()
{
    CTreeNode * pNodeLeft = _tpgStart.Branch();
    CTreeNode * pNodeRight = _tpgEnd.Branch();
    CTreePosGap tpgLeft, tpgRight;

    // Compute the first common element ancestor for the range
    pNodeLeft = pNodeLeft->GetFirstCommonAncestor( pNodeRight, NULL );
    Assert( pNodeLeft );

    pNodeRight = pNodeRight->SearchBranchToRootForScope( pNodeLeft->Element() );
    Assert( pNodeRight );

    _pelFragment = pNodeRight->Element();

    // Include any phrase element which starts at this "run"
    while(  ! IsElementBlockInContainer( _pelFragment )
        &&  ! ScopesLeftOfStart( _pelFragment )
        &&  _pelFragment != _pelContainer )
    {
        // move to the next parent that covers the entire range
        pNodeLeft = pNodeLeft->Parent();
        pNodeRight = pNodeRight->Parent();

        pNodeLeft = pNodeLeft->GetFirstCommonAncestor( pNodeRight, NULL );
        Assert( pNodeLeft );

        pNodeRight = pNodeRight->SearchBranchToRootForScope( pNodeLeft->Element() );
        Assert( pNodeRight );

        _pelFragment = pNodeRight->Element();
    }

    // If the fragment is selected completely, move up an element
    if (    ! ScopesLeftOfStart( _pelFragment )
        &&  ! ScopesRightOfEnd( _pelFragment )
        &&  !(  _pelFragment->HasFlowLayout()
            &&  _pelFragment->GetFlowLayout()->GetContentMarkup() == _pMarkup )
        &&  _pelFragment != _pelContainer 
        &&  ! _pelFragment->IsRoot() )
    {
        // move to the next parent that covers the entire range
        pNodeLeft = pNodeLeft->Parent();
        pNodeRight = pNodeRight->Parent();

        pNodeLeft = pNodeLeft->GetFirstCommonAncestor( pNodeRight, NULL );
        Assert( pNodeLeft );

        pNodeRight = pNodeRight->SearchBranchToRootForScope( pNodeLeft->Element() );
        Assert( pNodeRight );

        _pelFragment = pNodeRight->Element();
    }

    Assert( _tpgStart.Branch()->SearchBranchToRootForScope( _pelFragment ) );
    Assert( _tpgEnd.Branch()->SearchBranchToRootForScope( _pelFragment ) );
}

//+---------------------------------------------------------------------------
//
//  Member:     CRangeSaver::ComputeIE4Selection
//
//  Synopsis:   Tries to figure out the same selection
//              that IE4 would have.
//
//----------------------------------------------------------------------------
void    
CRangeSaver::ComputeIE4Selection()
{
    CTreePosGap tpgTemp( TPG_LEFT );
    BOOL        fLBLeft;
    CTreeNode * pNodeAbove;

    // Move the start gap in until we hit real content
    Verify( !tpgTemp.MoveTo( &_tpgStart ) );
    fLBLeft = _fLBStartLeft;

    pNodeAbove = tpgTemp.Branch();

    while(  !(  tpgTemp.AttachedTreePos()->IsText() 
            &&  tpgTemp.AttachedTreePos()->Cch() ) 
        &&  ! fLBLeft )
    {
        // Never cross container boundries
        if (    tpgTemp.AttachedTreePos()->IsNode()
            &&  tpgTemp.AttachedTreePos()->IsEdgeScope()
            &&  tpgTemp.AttachedTreePos()->Branch()->IsContainer() )
            break;

        if( tpgTemp.AttachedTreePos()->IsBeginElementScope()
           &&   pNodeAbove->SearchBranchToRootForScope(tpgTemp.Branch()->Element()) )
        {
            if (tpgTemp.AttachedTreePos()->Branch()->Element() == _pelFragment )
                break;

            Verify( ! _tpgStart.MoveTo( tpgTemp.AttachedTreePos(), TPG_LEFT ) );
            _fLBStartLeft = LineBreakChar( &_tpgStart );
        }

        Verify( ! tpgTemp.MoveLeft() );

        if (LineBreakChar( &tpgTemp ))
            fLBLeft = TRUE;
    }

    Verify( !_tpgStart.MoveLeft( TPG_VALIDGAP | TPG_OKNOTTOMOVE ) );

    // Move the end gap in until we hit real content
    Verify( !tpgTemp.MoveTo( &_tpgEnd ) );
    fLBLeft = _fLBEndLeft;

    pNodeAbove = tpgTemp.Branch();

    tpgTemp.SetAttachPreference( TPG_RIGHT );

    while(  !(  tpgTemp.AttachedTreePos()->IsText() 
            &&  tpgTemp.AttachedTreePos()->Cch() ) )
    {
        // If we hit a LB char and we don't have it marked
        // on our left, break
        if (    !fLBLeft 
            &&  LineBreakChar( &tpgTemp ) )
            break;

        // Never cross container boundries
        if (    tpgTemp.AttachedTreePos()->IsNode()
            &&  tpgTemp.AttachedTreePos()->IsEdgeScope()
            &&  tpgTemp.AttachedTreePos()->Branch()->IsContainer() )
            break;

        if(     tpgTemp.AttachedTreePos()->IsEndElementScope() 
           &&   pNodeAbove->SearchBranchToRootForScope(tpgTemp.Branch()->Element()) )
        {
            if (tpgTemp.AttachedTreePos()->Branch()->Element() == _pelFragment )
                break;

            Verify( ! _tpgEnd.MoveTo( tpgTemp.AttachedTreePos(), TPG_RIGHT ) );
            _fLBEndLeft = FALSE;
        }

        fLBLeft = FALSE;
        Verify( ! tpgTemp.MoveRight() );
    }

    Verify( !_tpgEnd.MoveRight( TPG_VALIDGAP | TPG_OKNOTTOMOVE ) );
}


//+---------------------------------------------------------------------------
//
//  Member:     CRangeSaver::GetStmOffset
//
//  Synopsis:   Returns the current offset in the output stream.
//
//----------------------------------------------------------------------------

HRESULT
CRangeSaver::GetStmOffset(LONG * plOffset)
{
    HRESULT        hr;
    ULARGE_INTEGER ulRet;
    LARGE_INTEGER  lSeekZero  = {0,0};

    hr = _pswb->Seek(lSeekZero, STREAM_SEEK_CUR, &ulRet);
    if (hr)
        goto Cleanup;

#ifdef UNIX
    *plOffset = U_QUAD_PART(ulRet);
#else
    *plOffset = ulRet.QuadPart;
#endif

Cleanup:
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CRangeSaver::SetStmOffset
//
//  Synopsis:   Sets the offset in the output stream.
//
//----------------------------------------------------------------------------

HRESULT
CRangeSaver::SetStmOffset(LONG lOffset)
{
    LARGE_INTEGER l;

#ifdef UNIX
    QUAD_PART(l) = lOffset;
#else
    l.QuadPart = lOffset;
#endif

    RRETURN(_pswb->Seek(l, STREAM_SEEK_SET, NULL));
}


//+---------------------------------------------------------------------------
//
//  Member:     CRangeSaver::Save
//
//  Synopsis:   Save the range to the stream _pswb.
//
//----------------------------------------------------------------------------

HRESULT
CRangeSaver::Save()
{
    HRESULT    hr = S_OK;
    if (_dwFlags & RSF_NO_ENTITIZE_UNKNOWN)
    {
        // Do not entitize unknown characters if asked not to
        _pswb->SetEntitizeUnknownChars(FALSE);
    }

    if (_dwFlags & RSF_FOR_RTF_CONV)
    {
        // The rtf converter requires pampered html
        _pswb->SetFlags(WBF_FOR_RTF_CONV);
    }

    if (_dwFlags & RSF_CFHTML_HEADER)
    {
        //
        // Write an empty cfhtml header.  We will go back later and fill
        // it out properly once we have the correct offsets.
        //
        hr = WriteCFHTMLHeader();
        if (hr)
            goto Cleanup;

        hr = GetStmOffset(&_header.iHTMLStart);
        if (hr)
            goto Cleanup;
    }

    //
    // Open up the context, starting with the doc header.
    //
    {
        if ( !(_dwFlags & RSF_CONTEXT) )
            _pswb->BeginSuppress();

        _pMarkup->WriteDocHeader(_pswb);

        hr = WriteOpenContext();
        if (hr)
            goto Cleanup;

        if ( !(_dwFlags & RSF_CONTEXT) )
            _pswb->EndSuppress();
    }

    if (_dwFlags & RSF_FOR_RTF_CONV)
    {
        //
        // Save any html header information needed for the rtf converter.
        // For now this is <HTML> and a charset <META> tag.
        //
        TCHAR achCharset[MAX_MIMECSET_NAME];

        if (GetMlangStringFromCodePage(_pswb->GetCodePage(), achCharset,
            ARRAY_SIZE(achCharset)) == S_OK)
        {
            DWORD dwOldFlags = _pswb->ClearFlags(WBF_ENTITYREF);

            _pswb->Write(_T("<HTML><META HTTP-EQUIV=\"content-type\" ")
                                 _T("CONTENT=\"text/html;charset="));
            _pswb->Write(achCharset);
            _pswb->Write(_T("\">"));
            _pswb->NewLine();

            _pswb->RestoreFlags(dwOldFlags);
        }
    }

    //
    // The real meat -- where we call the superclass.
    //
    if ( (_dwFlags & RSF_FRAGMENT) || (_dwFlags & RSF_SELECTION) )
    {

        //
        // Call the superclass to save the body 
        //
 
        hr = CTreeSaver::Save();
        if (hr)
            goto Cleanup;

    }

    {
        if ( !(_dwFlags & RSF_CONTEXT) )
            _pswb->BeginSuppress();

        hr = WriteCloseContext();
        if( hr )
            goto Cleanup;

        if ( !(_dwFlags & RSF_CONTEXT) )
            _pswb->EndSuppress();
    }

    if (_dwFlags & RSF_CFHTML_HEADER)
    {
        //
        // Save the current position as the end of html, and go back
        // to the beginning to write the header with the offsets we
        // now know.
        //
        hr = GetStmOffset(&_header.iHTMLEnd);
        if (hr)
            goto Cleanup;

        hr = SetStmOffset(0);
        if (hr)
            goto Cleanup;

        hr = WriteCFHTMLHeader();
        if (hr)
            goto Cleanup;

        hr = SetStmOffset(_header.iHTMLEnd);
        if (hr)
            goto Cleanup;

    }

Cleanup:

    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CRangeSaver::SaveSegmentList
//
//  Synopsis:   Save the range to the stream _pswb.
//
//----------------------------------------------------------------------------

HRESULT
CRangeSaver::SaveSegmentList(ISegmentList* pSegmentList, CMarkup* pMarkup)
{
    HRESULT                 hr = S_OK;
    ISegmentListIterator    *pIter = NULL;
    ISegment                *pSegment = NULL;

    
    if (_dwFlags & RSF_NO_ENTITIZE_UNKNOWN)
    {
        // Do not entitize unknown characters if asked not to
        _pswb->SetEntitizeUnknownChars(FALSE);
    }

    if (_dwFlags & RSF_FOR_RTF_CONV)
    {
        // The rtf converter requires pampered html
        _pswb->SetFlags(WBF_FOR_RTF_CONV);
    }

    if (_dwFlags & RSF_CFHTML_HEADER)
    {
        //
        // Write an empty cfhtml header.  We will go back later and fill
        // it out properly once we have the correct offsets.
        //
        hr = WriteCFHTMLHeader();
        if (hr)
            goto Cleanup;

        hr = GetStmOffset(&_header.iHTMLStart);
        if (hr)
            goto Cleanup;
    }

    //
    // Open up the context, starting with the doc header.
    //
    {
        if ( !(_dwFlags & RSF_CONTEXT) )
            _pswb->BeginSuppress();

        _pMarkup->WriteDocHeader(_pswb);

        hr = WriteOpenContext();
        if (hr)
            goto Cleanup;

        if ( !(_dwFlags & RSF_CONTEXT) )
            _pswb->EndSuppress();
    }

    if (_dwFlags & RSF_FOR_RTF_CONV)
    {
        //
        // Save any html header information needed for the rtf converter.
        // For now this is <HTML> and a charset <META> tag.
        //
        TCHAR achCharset[MAX_MIMECSET_NAME];

        if (GetMlangStringFromCodePage(_pswb->GetCodePage(), achCharset,
            ARRAY_SIZE(achCharset)) == S_OK)
        {
            DWORD dwOldFlags = _pswb->ClearFlags(WBF_ENTITYREF);

            _pswb->Write(_T("<HTML><META HTTP-EQUIV=\"content-type\" ")
                                 _T("CONTENT=\"text/html;charset="));
            _pswb->Write(achCharset);
            _pswb->Write(_T("\">"));
            _pswb->NewLine();

            _pswb->RestoreFlags(dwOldFlags);
        }
    }

    //
    // The real meat -- where we call the superclass.
    //
    if ( (_dwFlags & RSF_FRAGMENT) || (_dwFlags & RSF_SELECTION) )
    {

        //
        // Call the superclass to save the body 
        //
        CDoc                    *pDoc = pMarkup->Doc();
        CMarkupPointer          mpStart( pDoc );
        CMarkupPointer          mpEnd( pDoc );
        BOOL                    fFirst = TRUE;
        LONG                    iHTMLStart      = _header.iHTMLStart;
        LONG                    iFragmentStart  = _header.iFragmentStart;
        LONG                    iSelectionStart = _header.iSelectionStart;

        hr = THR( pSegmentList->CreateIterator( &pIter ) );
        if( hr )
            goto Cleanup;

        while( pIter->IsDone() == S_FALSE )
        {
            hr = THR( pIter->Current( &pSegment ) );
            if( hr )
                goto Cleanup;
                
            hr = THR( pSegment->GetPointers( &mpStart, &mpEnd) );        
            if( hr )
                goto Cleanup;

            Initialize(&mpStart, &mpEnd, _dwFlags, _pswb, mpStart.Markup(), NULL);

            hr = CTreeSaver::Save();
            if (hr)
                goto Cleanup;

            if( fFirst )
            {
                fFirst = FALSE;
                if( _header.iSelectionStart > iSelectionStart )
                {
                    iSelectionStart = _header.iSelectionStart;
                }
            }

            hr = THR( pIter->Advance() );
            if( hr )
                goto Cleanup;

            ClearInterface(&pSegment);
        }

        _header.iHTMLStart      = iHTMLStart;
        _header.iFragmentStart  = iFragmentStart;
        _header.iSelectionStart = iSelectionStart;
    }

    {
        if ( !(_dwFlags & RSF_CONTEXT) )
            _pswb->BeginSuppress();

        hr = WriteCloseContext();
        if( hr )
            goto Cleanup;

        if ( !(_dwFlags & RSF_CONTEXT) )
            _pswb->EndSuppress();
    }

    if (_dwFlags & RSF_CFHTML_HEADER)
    {
        //
        // Save the current position as the end of html, and go back
        // to the beginning to write the header with the offsets we
        // now know.
        //
        hr = GetStmOffset(&_header.iHTMLEnd);
        if (hr)
            goto Cleanup;

        hr = SetStmOffset(0);
        if (hr)
            goto Cleanup;

        hr = WriteCFHTMLHeader();
        if (hr)
            goto Cleanup;

        hr = SetStmOffset(_header.iHTMLEnd);
        if (hr)
            goto Cleanup;

    }

Cleanup:

    ReleaseInterface(pIter);
    ReleaseInterface(pSegment);
    
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CRangeSaver::WriteCFHTMLHeader
//
//  Synopsis:   Writes the CF-HTML header to _pswb.
//
//----------------------------------------------------------------------------

HRESULT
CRangeSaver::WriteCFHTMLHeader()
{
    HRESULT     hr;
    TCHAR *     pchOut = NULL;
    DWORD       dwOldFlags = _pswb->ClearFlags( WBF_ENTITYREF  );

    Assert(_dwFlags & RSF_CFHTML_HEADER);

    _pswb->SetFlags(WBF_NO_WRAP);

    static TCHAR szCfHtmlHeaderFormat[] =
        _T("Version:<0s>\r\n")
        _T("StartHTML:<1d9>\r\n")
        _T("EndHTML:<2d9>\r\n")
        _T("StartFragment:<3d9>\r\n")
        _T("EndFragment:<4d9>\r\n")
        _T("StartSelection:<5d9>\r\n")
        _T("EndSelection:<6d9>\r\n")
        _T("SourceURL:<7s>\r\n");

    Format(
        FMT_OUT_ALLOC,
        & pchOut, 512,
        szCfHtmlHeaderFormat,
        _T("1.0"),
        (long)_header.iHTMLStart, (long)_header.iHTMLEnd, (long)_header.iFragmentStart,
        (long)_header.iFragmentEnd, (long)_header.iSelectionStart, (long)_header.iSelectionEnd,
#if defined(UNIX) || defined(_MAC)
        (LPCTSTR)
#endif
        CMarkup::GetUrl(_pMarkup->GetWindowedMarkupContext()));

    
    // Do not let _pswb mess with forced cr/lfs in this string

    _pswb->BeginPre();

    hr = _pswb->Write(pchOut);
    
    if (hr)
        goto Cleanup;

    _pswb->EndPre();

Cleanup:
    delete [] pchOut;
    
    _pswb->RestoreFlags(dwOldFlags);

    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Members:    CRangeSaver::WriteOpenContext
//
//  Synopsis:   Writes out all tags that come into of scope between
//              _pelFragment and the root.
//
//----------------------------------------------------------------------------
HRESULT
CRangeSaver::WriteOpenContext()
{
    HRESULT hr = S_OK;
    CStackPtrAry<CElement *, 32> aryElements(Mt(CRangeSaver_local_aryElements_pv));
    CTreeNode * pNodeCur;

    // First find the context of _pelFragment that is above the start.
    pNodeCur = _tpgStart.Branch();
    Assert( pNodeCur );

    pNodeCur = pNodeCur->SearchBranchToRootForScope( _pelFragment );
    Assert( pNodeCur );

    // build an array of all of the elements that we want to write out
    for( ; pNodeCur ; pNodeCur = pNodeCur->Parent() )
    {
        aryElements.Append( pNodeCur->Element() );
    }

    // Write out our array of elements
    {
        CElement **ppElement;
        int        iElement;

        for( iElement = aryElements.Size(), ppElement = &(aryElements[iElement-1]);
             iElement > 0;
             iElement--, ppElement-- )
        {
            if (! *ppElement)
                continue;

            if( (*ppElement)->Tag() != ETAG_ROOT )
            {
                hr = THR( SaveElement( *ppElement, FALSE ) );
                if (hr)
                    goto Cleanup;
            }

            if (*ppElement == _pelFragment)
            {
                DWORD dwFlags = _pswb->ClearFlags(WBF_ENTITYREF);
        
                hr = _pswb->Write(_T("<!--StartFragment-->"));
                if( hr )
                    goto Cleanup;

                _pswb->RestoreFlags(dwFlags);

                hr = GetStmOffset(&_header.iFragmentStart);
                if (hr)
                    goto Cleanup;

                if (_header.iSelectionStart == 0)
                    _header.iSelectionStart = _header.iFragmentStart;
            }

            if ( (*ppElement)->Tag() == ETAG_HTML && (_dwFlags & RSF_CONTEXT) )
            {
                // Make sure not to save out elements we do not want in cfhtml,
                // such as meta charset tags and styles.
                CElement * pHead = _pMarkup->GetHeadElement();

                if( pHead )
                {
                    DWORD dwFlags = _pswb->SetFlags( WBF_NO_CHARSET_META | WBF_NO_OBJECTS );

                    hr = THR( pHead->Save(_pswb, FALSE) );
                    if (hr)
                        goto Cleanup;

                    CTreeSaver ts( pHead, _pswb );
                    hr = ts.Save();
                    if (hr)
                        goto Cleanup;

                    hr = THR( pHead->Save(_pswb, TRUE) );
                    if (hr)
                        goto Cleanup;

                    _pswb->RestoreFlags(dwFlags);

                    // There may be elements that start in the head and overlap
                    // over our current stack.  We don't want to write out the
                    // start for these elements twice so zero them out here
                    {
                        CTreePos * ptpCur;

                        pHead->GetTreeExtent( NULL, &ptpCur );
                        Assert( ptpCur );

                        ptpCur = ptpCur->NextTreePos();

                        while( ptpCur->IsBeginNode() && ! ptpCur->IsEdgeScope() )
                        {
                            int iIndex = aryElements.Find( ptpCur->Branch()->Element() );
                            if( iIndex != -1 )
                                aryElements[iIndex] = NULL;

                            ptpCur = ptpCur->NextTreePos();
                        }
                    } // no duplicates
                } // pHead
            } // ETAG_HTML

            if (*ppElement && *ppElement != _pelFragment)
            {
                hr = _pswb->NewLine();
                if (hr)
                    goto Cleanup;
            }

        } // for loop
    } // write out array

Cleanup:
    RRETURN(hr);
}
//+---------------------------------------------------------------------------
//
//  Members:    CRangeSaver::WriteCloseContext
//
//  Synopsis:   Writes out all tags that go out of scope between
//              _pelFragment and the root.
//
//----------------------------------------------------------------------------
HRESULT
CRangeSaver::WriteCloseContext()
{
    HRESULT hr = S_OK;
    CTreeNode * pNodeCur;

    pNodeCur = _tpgEnd.Branch();
    Assert( pNodeCur );

    pNodeCur = pNodeCur->SearchBranchToRootForScope( _pelFragment );
    Assert( pNodeCur );

    // build an array of all of the elements that we want to write out
    for( ; pNodeCur; pNodeCur = pNodeCur->Parent() )
    {
        CElement * pElementCur = pNodeCur->Element();

        if( pElementCur == _pelFragment )
        {
            DWORD dwFlags = _pswb->ClearFlags(WBF_ENTITYREF);

            hr = GetStmOffset(&_header.iFragmentEnd);
            if (hr)
                goto Cleanup;

            if (_header.iSelectionEnd == 0)
                _header.iSelectionEnd = _header.iFragmentEnd;

            hr = _pswb->Write(_T("<!--EndFragment-->"));
            if (hr)
                goto Cleanup;

            _pswb->RestoreFlags(dwFlags);
        }

        if (pElementCur->Tag() != ETAG_ROOT)
        {
            hr = THR( SaveElement( pElementCur, TRUE ) );
            if (hr)
                goto Cleanup;

            hr = THR( ForceClose( pElementCur ) );
            if (hr)
                goto Cleanup;

            hr = _pswb->NewLine();
            if (hr)
                goto Cleanup;
        }
    }

Cleanup:
    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\text\util.cxx ===
/*
 *  UTIL.C
 *
 *  Purpose:
 *      Implementation of various useful utility functions
 *
 *  Author:
 *      alexgo (4/25/95)
 */

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_UNICWRAP_HXX_
#define X_UNICWRAP_HXX_
#include "unicwrap.hxx" // for cstrinw
#endif

#ifndef X_ENCODE_HXX_
#define X_ENCODE_HXX_
#include "encode.hxx"
#endif

#ifndef X_TXTDEFS_H_
#define X_TXTDEFS_H_
#include "txtdefs.h"
#endif

/*
 *  DuplicateHGlobal
 *
 *  Purpose:
 *      duplicates the passed in hglobal
 */

HGLOBAL DuplicateHGlobal( HGLOBAL hglobal )
{
    UINT    flags;
    DWORD   size;
    HGLOBAL hNew;
    BYTE *  pSrc;
    BYTE *  pDest;

    if( hglobal == NULL )
    {
        return NULL;
    }

    flags = GlobalFlags(hglobal);

    size = GlobalSize(hglobal);
    if (size == 0)
    {
    	return NULL;
    }

    hNew = GlobalAlloc(flags, size);

    if( hNew )
    {
        pDest = (BYTE *)GlobalLock(hNew);
        pSrc = (BYTE *)GlobalLock(hglobal);

        if( pDest == NULL || pSrc == NULL )
        {
            GlobalUnlock(hNew);
            GlobalUnlock(hglobal);
            GlobalFree(hNew);

            return NULL;
        }

        memcpy(pDest, pSrc, size);

        GlobalUnlock(hNew);
        GlobalUnlock(hglobal);
    }

    return hNew;
}

/*
 *  TextHGlobalAtoW (hglobalA)
 *
 *  Purpose:
 *      translates a unicode string contained in an hglobal and
 *      wraps the ansi version in another hglobal
 *
 *  Notes: 
 *      does *not* free the incoming hglobal
 */

HGLOBAL TextHGlobalAtoW( HGLOBAL hglobalA )
{
    LPSTR   pstr;
    HGLOBAL hnew = NULL;
    DWORD   cbSize;

    if( !hglobalA )
    {
        return NULL;
    }

    pstr = (LPSTR)GlobalLock(hglobalA);
    if (pstr == NULL)
    {
    	return NULL;
    }

    CStrInW  strinw(pstr);

    cbSize = (strinw.strlen() + 1) * sizeof(WCHAR);
    hnew = GlobalAlloc(GMEM_MOVEABLE, cbSize);

    if( hnew )
    {
        LPWSTR pwstr = (LPWSTR)GlobalLock(hnew);
        
        if( pwstr )
        {
            memcpy(pwstr, (WCHAR *)strinw, cbSize);
        
            GlobalUnlock(hnew);
        }
    }

    GlobalUnlock(hglobalA);
    
    return hnew;
}

/*
 *  TextHGlobalAtoW
 *
 *  Purpose:
 *      converts a unicode text hglobal into a newly allocated
 *      allocated hglobal with ANSI data
 *
 *  Notes:
 *      does *NOT* free the incoming hglobal 
 */
    
HGLOBAL TextHGlobalWtoA( HGLOBAL hglobalW )
{
    LPCWSTR  pwstr;
    HGLOBAL hnew = NULL;
    DWORD   cbSize;

    if( !hglobalW )
    {
        return NULL;
    }

    pwstr = (LPCWSTR)GlobalLock(hglobalW);
    if (pwstr == NULL)
    {
    	return NULL;
    }

    CStrIn  strin(pwstr);

    cbSize = (strin.strlen() + 1) * sizeof(CHAR);
    hnew = GlobalAlloc(GMEM_MOVEABLE, cbSize);

    if( hnew )
    {
        LPSTR pstr = (LPSTR)GlobalLock(hnew);
        
        if( pstr )
        {
            memcpy(pstr, (CHAR *)strin, cbSize);
        
            GlobalUnlock(hnew);
        }
    }

    GlobalUnlock(hglobalW);
    
    return hnew;
}   

/*
 *  CountMatchingBits ( const DWORD *a, const DWORD *b, INT total )
 *
 *  @mfunc
 *      Count matching bit fields.
 *  @comm
 *      This is used to help decide how good the match is between
 *      code page bit fields. Mainly for KB/font switching support.
 *  Author:
 *      Jon Matousek
 */
INT CountMatchingBits(const DWORD *a, const DWORD *b, INT total)
{
    static INT  bitCount[] = {0, 1, 1, 2, 1, 2, 2, 3, 1, 2, 2, 3, 2, 3, 3, 4 };
    INT         i, c, matchBits;

    c = 0;
    for (i = 0; i < total; i++ )
    {
        //matchBits = ~(*a++ ^ *b++);   // 1 and 0's
        matchBits = *a++ & *b++;        // 1 only.
        c += bitCount [ (matchBits >> 0)    & 15];
        c += bitCount [ (matchBits >> 4)    & 15];
        c += bitCount [ (matchBits >> 8)    & 15];
        c += bitCount [ (matchBits >> 12)   & 15];
        c += bitCount [ (matchBits >> 16)   & 15];
        c += bitCount [ (matchBits >> 20)   & 15];
        c += bitCount [ (matchBits >> 24)   & 15];
        c += bitCount [ (matchBits >> 28)   & 15];
    }

    return c;
}

//+----------------------------------------------------------------------------
//
//  Function:   HtmlStringToHGlobal
//
//  Synopsis:   Build an HGLOBAL from a unicode html string.  Specifivally, it
//              places the correct signature at the beginning of the HGLOBAL so
//              paste code knows what it is.
//
//-----------------------------------------------------------------------------

HRESULT
HtmlStringToSignaturedHGlobal (
    HGLOBAL * phglobal, const TCHAR * pStr, long cch )
{
    HRESULT hr = S_OK;
    char *  pStrHtmlText = NULL;
    long    cbStr;
    long    lGlobalSize;
    DWORD   lHGSize;

    Assert( cch >= -1 );
    Assert( phglobal );

    //
    // Allocate enough for the string, unicode signature and zero terminator
    //
    
    cbStr = (cch < 0 ? _tcslen( pStr ) : cch) * sizeof( TCHAR );
    
    lGlobalSize = cbStr + sizeof( WCHAR ) + sizeof( TCHAR );

    *phglobal = GlobalAlloc( GMEM_MOVEABLE, lGlobalSize );
    if (!*phglobal)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    lHGSize = GlobalSize(*phglobal);
    if (lHGSize == 0)
    {
        hr = E_OUTOFMEMORY;
        goto Error;
    }

    pStrHtmlText = (char *) GlobalLock( *phglobal );
    if (!pStrHtmlText)
    {
        hr = E_OUTOFMEMORY;
        goto Error;
    }

    //
    // Put the unicaode signature at the beginning, followed by the raw string,
    // a zero terminator and then finally followed by any zeros needed to fill
    // in the rest of the hglobal (if we got one bigger than we asked for).
    //

    * (WCHAR *) pStrHtmlText = NATIVE_UNICODE_SIGNATURE;
    
    memcpy( pStrHtmlText + sizeof( WCHAR ), pStr, cbStr );
    
    memset(
        pStrHtmlText + cbStr + sizeof( WCHAR ),
        0, lHGSize - cbStr - sizeof( WCHAR ) );

    GlobalUnlock(*phglobal);

Cleanup:

    RRETURN( hr );
    
Error:

    if (*phglobal)
        GlobalFree( *phglobal );
    
    *phglobal = 0;

    goto Cleanup;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\text\txtsite.cxx ===
//+---------------------------------------------------------------------
//
//   File:      txtsite.cxx
//
//  Contents:   Text site class
//
//  Classes:    CTxtSite
//
//------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_CGUID_H_
#define X_CGUID_H_
#include <cguid.h>
#endif

#ifndef X_TXTSITE_HXX_
#define X_TXTSITE_HXX_
#include "txtsite.hxx"
#endif

#ifndef X__DISP_H_
#define X__DISP_H_
#include "_disp.h"
#endif

#ifndef X__TEXT_H_
#define X__TEXT_H_
#include "_text.h"
#endif

#ifndef X__DXFROBJ_H_
#define X__DXFROBJ_H_
#include "_dxfrobj.h"
#endif

#ifndef X__RUNPTR_H_
#define X__RUNPTR_H_
#include "_runptr.h"
#endif

#ifndef X__FONT_H_
#define X__FONT_H_
#include "_font.h"
#endif

#ifndef X_TREEPOS_HXX_
#define X_TREEPOS_HXX_
#include "treepos.hxx"
#endif

#ifndef X__IME_H_
#define X__IME_H_
#include "_ime.h"
#endif

#ifndef X_MISCPROT_H_
#define X_MISCPROT_H_
#include "miscprot.h"
#endif

#ifndef X_MSHTMLRC_H_
#define X_MSHTMLRC_H_
#include "mshtmlrc.h"
#endif

#ifndef X__TXTSAVE_H_
#define X__TXTSAVE_H_
#include "_txtsave.h"
#endif

#ifndef X_IRANGE_HXX_
#define X_IRANGE_HXX_
#include "irange.hxx"
#endif

#ifndef X_HYPLNK_HXX_
#define X_HYPLNK_HXX_
#include "hyplnk.hxx"
#endif

#ifndef X_EANCHOR_HXX_
#define X_EANCHOR_HXX_
#include "eanchor.hxx"
#endif

#ifndef X_WINDOW_HXX_
#define X_WINDOW_HXX_
#include "window.hxx"
#endif

#ifndef X_CUTIL_HXX_
#define X_CUTIL_HXX_
#include "cutil.hxx"
#endif

#ifndef X_DOWNLOAD_HXX_
#define X_DOWNLOAD_HXX_
#include "download.hxx"
#endif

#ifndef X_DOCPRINT_HXX_
#define X_DOCPRINT_HXX_
#include "docprint.hxx"
#endif

#ifndef X_COLLECT_HXX_
#define X_COLLECT_HXX_
#include "collect.hxx"
#endif

#ifndef X_EAREA_HXX_
#define X_EAREA_HXX_
#include "earea.hxx"
#endif

#ifndef X_PEER_HXX_
#define X_PEER_HXX_
#include "peer.hxx"
#endif

#ifndef X_LTCELL_HXX_
#define X_LTCELL_HXX_
#include "ltcell.hxx"
#endif

#ifndef X_FLOWLYT_HXX_
#define X_FLOWLYT_HXX_
#include "flowlyt.hxx"
#endif

#ifndef X_WCHDEFS_H_
#define X_WCHDEFS_H_
#include "wchdefs.h"
#endif

#define _cxx_
#include "txtedit.hdl"

DeclareTag(tagPaginate, "Print", "Pagination output");

// force functions to load through dynamic wrappers
#ifndef X_COMCTRLP_H_
#define X_COMCTRLP_H_
#ifdef WINCOMMCTRLAPI
#undef WINCOMMCTRLAPI
#define WINCOMMCTRLAPI
#endif
#include "comctrlp.h"
#endif

ExternTag(tagMsoCommandTarget);
ExternTag(tagFormatCaches);
ExternTag(tagLayout);

MtDefine(CTxtSite, Elements, "CTxtSite")
MtDefine(CTxtSite_pDropTargetSelInfo, CTxtSite, "CTxtSite::_pDropTargetSelInfo")
MtDefine(CTxtSiteScrollRangeIntoView_aryRects_pv, Locals, "CTxtSite::ScrollRangeIntoView aryRects::_pv")
MtDefine(CTxtSiteBranchFromPointEx_aryRects_pv, Locals, "CTxtSite::SiteBranchFromPointEx aryRects::_pv")
MtDefine(CTxtSiteDrop_arySites_pv, Locals, "CTxtSite::Drop arySites::_pv")
MtDefine(CTxtSiteGetChildElementTopLeft_aryRects_pv, Locals, "CTxtSite::GetChildElementTopLeft aryRects::_pv")
MtDefine(CTxtSitePaginate_aryValues_pv, Locals, "CTxtSite::Paginate aryValues::_pv")


#if DBG==1
extern void TestMarkupServices(CElement *);
#endif

// Commented out the following 4 lines because unused due to #ifdef NEVER in code:
// #pragma BEGIN_CODESPACE_DATA
// TCHAR szCRLF[]  = TEXT("\r\n");
// TCHAR szCR[]    = TEXT("\r");
// #pragma END_CODESPACE_DATA

WORD  ConvVKey (WORD vKey);
WORD        wConvScroll(WORD wparam);


#ifdef NEVER
// not used
#ifndef NO_PROPERTY_PAGE
const CLSID * const CTxtSite::s_apclsidPages[] =
{
    // Browse-time pages
    NULL,
    // Edit-time pages
#if DBG==1    
    &CLSID_CCDGenericPropertyPage,
#endif // DBG==1    
    NULL
};
#endif // NO_PROPERTY_PAGE
#endif // NEVER

CElement::ACCELS CTxtSite::s_AccelsTxtSiteRun    = CElement::ACCELS (&CElement::s_AccelsElementRun,    IDR_ACCELS_TXTSITE_RUN);

//+------------------------------------------------------------------------
//
//  Member:     CTxtSite, ~CTxtSite
//
//  Synopsis:   Constructor/Destructor
//
//-------------------------------------------------------------------------

CTxtSite::CTxtSite (ELEMENT_TAG etag, CDoc *pDoc)
  : super(etag, pDoc)
{
    _fOwnsRuns = TRUE;
}

//+------------------------------------------------------------------------
//
//  Member:     CTxtSite::PrivateQueryInterface, IUnknown
//
//  Synopsis:   Private unknown QI.
//
//-------------------------------------------------------------------------

HRESULT
CTxtSite::PrivateQueryInterface(REFIID iid, void ** ppv)
{
    HRESULT     hr;

    *ppv = NULL;

    if (iid == CLSID_CTextSite)
    {
        *ppv = this;        // weak ref.
        return S_OK;
    }
    else if IID_TEAROFF(this, IHTMLTextContainer, NULL)
    else
    {
        RRETURN(THR_NOTRACE(super::PrivateQueryInterface(iid, ppv)));
    }

    (*(IUnknown **)ppv)->AddRef();
    return hr;
}


/*
 *  CTxtSite::Init ()
 *
 *  @mfunc
 *      Initializes this CTxtSite. Called by CreateTextServices()
 */

#ifndef X_TXTELEMS_HXX_
#define X_TXTELEMS_HXX_
#include "txtelems.hxx"
#endif

//+-------------------------------------------------------------------------
//
//  Method:     CTxtSite::Detach
//
//--------------------------------------------------------------------------


BOOL PointInRectAry(POINT pt, CStackDataAry<RECT, 1> &aryRects)
{
    for (int i = 0; i < aryRects.Size(); i++)
    {
        RECT rc = aryRects[i];
        if (PtInRect(&rc, pt))
            return TRUE;
    }
    return FALSE;
}

//+------------------------------------------------------------------------
//
//  Member:     wConvScroll
//
//  Synopsis:   Interchange horizontal and vertical commands for vertical
//              text site.
//
//-------------------------------------------------------------------------

//
WORD wConvScroll(WORD wparam)
{
    switch(wparam)
    {
        case SB_BOTTOM:
            return SB_TOP;

        case SB_LINEDOWN:
            return SB_LINEUP;

        case SB_LINEUP:
            return SB_LINEDOWN;

        case SB_PAGEDOWN:
            return SB_PAGEUP;

        case SB_PAGEUP:
            return SB_PAGEDOWN;

        case SB_TOP:
            return SB_BOTTOM;

        default:
            return wparam;
    }
}


WORD ConvVKey (WORD vKey)
{
    switch(vKey)
    {
        case VK_LEFT:
            return VK_DOWN;

        case VK_RIGHT:
            return VK_UP;

        case VK_UP:
            return VK_LEFT;

        case VK_DOWN:
            return VK_RIGHT;

        default:
            return vKey;
    }
}

//+------------------------------------------------------------------
//
//  Members: [get/put]_scroll[top/left] and get_scroll[height/width]
//
//  Synopsis : IHTMLTextContainer members. _dp is in pixels.
//
//------------------------------------------------------------------

HRESULT
CTxtSite::get_scrollHeight(long *plValue)
{
    RRETURN(super::get_scrollHeight(plValue));
}

HRESULT
CTxtSite::get_scrollWidth(long *plValue)
{
    RRETURN(super::get_scrollWidth(plValue));
}

HRESULT
CTxtSite::get_scrollTop(long *plValue)
{
    RRETURN(super::get_scrollTop(plValue));
}

HRESULT
CTxtSite::get_scrollLeft(long *plValue)
{
    RRETURN(super::get_scrollLeft(plValue));
}

HRESULT
CTxtSite::put_scrollTop(long lPixels)
{
    RRETURN(super::put_scrollTop(lPixels));
}


HRESULT
CTxtSite::put_scrollLeft(long lPixels)
{
    RRETURN(super::put_scrollLeft(lPixels));
}


//+-----------------------------------------------------------------
//
//  member [put_|get_]onscroll
//
//  synopsis - just delegate to CElement. these are here because this
//      property migrated from here to elemetn.
//+-----------------------------------------------------------------
STDMETHODIMP
CTxtSite::put_onscroll(VARIANT v)
{
    RRETURN(super::put_onscroll(v));
}
STDMETHODIMP
CTxtSite::get_onscroll(VARIANT * p)
{
    RRETURN(super::get_onscroll(p));
}

//+-------------------------------------------------------------------------------
//
//  Member:     createControlRange
//
//  Synopsis:   Implementation of the automation interface method.
//              This creates a default structure range (CAutoTxtSiteRange) and
//              passes it back.
//
//+-------------------------------------------------------------------------------
HRESULT
CTxtSite::createControlRange(IDispatch ** ppDisp)
{
    RRETURN(SetErrorInfo(THR(CElement::createControlRange(ppDisp))));
}

//////////////////////////////  Line Dump  ///////////////////////////////////////

#if DBG == 1 || defined(DUMPTREE)


// Use this inside asserts checking to see that the document is inplace.
// This code is DBG==1 only, so if you obviously can't use it anywhere
// in the ship build.  The key here is the CPrintDoc's lie.


// Made this static so I would not have to declare FILE in _edit.h
HANDLE g_f;

void WriteFileAnsi (
    HANDLE hFile, LPCVOID lpBuffer,
    DWORD nNumberOfBytesToWrite )
{
    char buffer [ 1024 ];
    long _cchLen;
    DWORD nbw;

    _cchLen = WideCharToMultiByte(
        CP_ACP, 0, LPWSTR( lpBuffer ), nNumberOfBytesToWrite,
        buffer, ARRAY_SIZE(buffer), NULL, NULL );

    WriteFile( hFile, buffer, _cchLen, & nbw, NULL );
}

void WriteString ( HANDLE hFile, TCHAR * pszStr )
{
    WriteFileAnsi( hFile, pszStr, _tcslen(pszStr) );
}

void WriteChar ( HANDLE hFile, TCHAR ch, int nRepeat )
{
    Assert( nRepeat >= 0 );

    while (nRepeat--)
        WriteFileAnsi( hFile, & ch, 1 );
}

void __cdecl WriteHelp ( HANDLE hFile, TCHAR * format, ... )
{
    va_list arg;

    va_start( arg, format );

    WriteHelpV( hFile, format, &arg );
}

void WriteHelpV( HANDLE hFile, TCHAR * format, va_list * parg )
{
    TCHAR achBuf [ 1024 ];

    VFormat( 0, achBuf, ARRAY_SIZE(achBuf), format, parg );

    WriteFileAnsi( hFile, achBuf, _tcslen(achBuf) );
}

void WriteFormattedString( HANDLE hFile, TCHAR * pch, long cch )
{
    if (!pch)
        return;

    for ( int i = 0 ; i < cch ; i++ )
    {
        TCHAR ch = pch[i];

        if (ch >= 1 && ch <= 26)
        {
            if (ch == _T('\r'))
                WriteString( hFile,  _T("\\r"));
            else if (ch == _T('\n'))
                WriteString( hFile, _T("\\n"));
            else
            {
                WriteHelp( hFile, _T("[<0d>]"), (long)int(ch) );
            }
        }
        else
        {
            switch ( ch )
            {
            case 0 :
                WriteString( hFile, _T("[NULL]"));
                break;

            case WCH_NODE:
                WriteString( hFile, _T("[Node]"));
                break;

            case WCH_NBSP :
                WriteString( hFile, _T("[NBSP]"));
                break;

            default :
                if (ch < 256 && _istprint(ch))
                {
                    WriteChar(hFile, ch);
                }
                else
                {
                    TCHAR achHex[9];

                    Format( 0, achHex, ARRAY_SIZE(achHex), _T("<0x>"), ch);

                    StrCpy( achHex, TEXT("[U+") );
                    StrCpy( achHex + 3, achHex + 4 );
                    StrCpy( achHex + 7, TEXT("]") );

                    WriteString( hFile, achHex );
                }

                break;
            }
        }
    }
}

BOOL InitDumpFile ( BOOL fOverwrite /* = FALSE */ )
{
    Assert( g_f == 0 );

    g_f = CreateFile(
#ifdef UNIX
            _T("tree.dump"),
#else
            fOverwrite ? _T("c:\\ff.txt") : _T("c:\\ee."),
#endif
            GENERIC_WRITE | GENERIC_READ,
            FILE_SHARE_WRITE | FILE_SHARE_READ,
            NULL,
            fOverwrite ? CREATE_ALWAYS : OPEN_ALWAYS,
            FILE_ATTRIBUTE_NORMAL,
            NULL);

    if (g_f == INVALID_HANDLE_VALUE)
    {
        g_f = 0;
        return FALSE;
    }

    SetFilePointer( g_f, GetFileSize( g_f, 0 ), 0, 0 );

    static int cDumps = 0;

    WriteHelp( g_f,
        _T("------------- Dump <0d> ------------------------------- \r\n\r\n" ),
        (long)cDumps++ );

    return TRUE;
}

void CloseDumpFile ( )
{
    CloseHandle( g_f );

    g_f = 0;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\text\uuid.cxx ===
/*  
 *  UUID.C
 *
 *  Purpose:
 *      provide definitions for locally used GUID's
 *
 *  Copyright (c) 1995-1996, Microsoft Corporation. All rights reserved.
 */

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#undef DEFINE_GUID
#undef DEFINE_OLEGUID

#define DEFINE_GUID(name, l, w1, w2, b1, b2, b3, b4, b5, b6, b7, b8) \
    const IID name \
        = { l, w1, w2, { b1, b2,  b3,  b4,  b5,  b6,  b7,  b8 } }
#define DEFINE_OLEGUID(name, l, w1, w2) \
    DEFINE_GUID(name, l, w1, w2, 0xC0,0,0,0,0,0,0,0x46)

// REMARK: presumably TOM should have official MS GUIDs
// To make pre-compiled headers work better, we just copy the
// guid definitions here.  Make sure they don't change!

DEFINE_GUID(LIBID_TOM,          0x8CC497C9, 0xA1DF,0x11ce,0x80,0x98,0x00,0xAA,
                                            0x00,0x47,0xBE,0x5D);
DEFINE_GUID(IID_ITextDocument,  0x8CC497C0, 0xA1DF,0x11CE,0x80,0x98,0x00,0xAA,
                                            0x00,0x47,0xBE,0x5D);
DEFINE_GUID(IID_ITextSelection, 0x8CC497C1, 0xA1DF,0x11CE,0x80,0x98,0x00,0xAA,
                                            0x00,0x47,0xBE,0x5D);
DEFINE_GUID(IID_ITextRange,     0x8CC497C2, 0xA1DF,0x11CE,0x80,0x98,0x00,0xAA,
                                            0x00,0x47,0xBE,0x5D);
DEFINE_GUID(IID_ITextFont,      0x8CC497C3, 0xA1DF,0x11CE,0x80,0x98,0x00,0xAA,
                                            0x00,0x47,0xBE,0x5D);
DEFINE_GUID(IID_ITextPara,      0x8CC497C4, 0xA1DF,0x11CE,0x80,0x98,0x00,0xAA,
                                            0x00,0x47,0xBE,0x5D);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\text\_disp.h ===
/*
 *  _DISP.H
 *
 *  Purpose:
 *      DISP class
 *
 *  Authors:
 *      Original RichEdit code: David R. Fulmer
 *      Christian Fortini
 *      Murray Sargent
 */

#ifndef I_DISP_H_
#define I_DISP_H_
#pragma INCMSG("--- Beg '_disp.h'")

#ifndef X__LINE_H_
#define X__LINE_H_
#include "_line.h"
#endif

ExternTag(tagDebugRTL);

class CFlowLayout;
class CBgRecalcInfo;

class CDispNode;
class CLed;
class CLineFull;
class CLineCore;
class CLineOtherInfo;
class CLinePtr;
class CMeasurer;
class CLSMeasurer;
class CTxtSite;
class CRecalcLinePtr;
class CRecalcTask;
class CLSRenderer;
class CNotification;
class COneRun;

class CShape;
class CWigglyShape;
enum NAVIGATE_DIRECTION;

class CDrawInfoRE;
class CSelection;

// Helper
long ComputeLineShift(htmlAlign  atAlign,
                      BOOL       fRTLDisplay,
                      BOOL       fRTLLine,
                      BOOL       fMinMax,
                      long       xWidthMax,
                      long       xWidth,
                      UINT *     puJustified,
                      long *     pdxRemainder = NULL);

// ============================  CLed  ====================================
// Line Edit Descriptor - describes impact of an edit on line breaks

MtExtern(CLed);
MtExtern(CRelDispNodeCache);

class CLed
{
public:
    LONG _cpFirst;          // cp of first affected line
    LONG _iliFirst;         // index of first affected line
    LONG _yFirst;           // y offset of first affected line

    LONG _cpMatchOld;       // pre-edit cp of first matched line
    LONG _iliMatchOld;      // pre-edit index of first matched line
    LONG _yMatchOld;        // pre-edit y offset of first matched line

    LONG _cpMatchNew;       // post-edit cp of first matched line
    LONG _iliMatchNew;      // post-edit index of first matched line
    LONG _yMatchNew;        // post-edit y offset of bottom of first matched line

    LONG _yExtentAdjust;    // the pixel amount by which any line in the changed lines
                            // draws outside its line height
public:
    CLed();

    DECLARE_MEMCLEAR_NEW_DELETE(Mt(CLed))

    VOID    SetNoMatch();
};

class CAlignedLine
{
public:
    CLineCore * _pLine;
    LONG    _yLine;
};

class CRelDispNode
{
public:

    CRelDispNode() 
    { 
        _pElement = NULL;
        _pDispNode = NULL;
    };

    ~CRelDispNode() 
        {  ClearContents();  };

    // Helper Functions
    //----------------------------

    void ClearContents ()
    {
        if (_pElement)
        {
            _pElement->SubRelease();
            _pElement = NULL;
        }

        if (_pDispNode)
        {
            DestroyDispNode();
        }
    }

    void DestroyDispNode();
    
    CElement * GetElement () { return _pElement; }

    void SetElement( CElement * pNewElement )
    {
        if (_pElement)
            _pElement->SubRelease();

        _pElement = pNewElement;

        if (_pElement)
            _pElement->SubAddRef();
    }

    // Data Members 
    //----------------------------
    long        _ili;
    long        _yli;
    long        _cLines;
    CPoint      _ptOffset;
    LONG        _xAnchor;   // x-coordinate for anchoring children disp nodes
    CDispNode * _pDispNode;

private:
    CElement  * _pElement;
};

class CRelDispNodeCache : public CDispClient
{
public:

    CRelDispNodeCache(CDisplay * pdp) : _aryRelDispNodes(Mt(CRelDispNodeCache))
    {
        _pdp = pdp;
    }

    virtual void            GetOwner(
                                CDispNode const* pDispNode,
                                void ** ppv);

    virtual void            DrawClient(
                                const RECT* prcBounds,
                                const RECT* prcRedraw,
                                CDispSurface *pSurface,
                                CDispNode *pDispNode,
                                void *cookie,
                                void *pClientData,
                                DWORD dwFlags);

    virtual void            DrawClientBackground(
                                const RECT* prcBounds,
                                const RECT* prcRedraw,
                                CDispSurface *pSurface,
                                CDispNode *pDispNode,
                                void *pClientData,
                                DWORD dwFlags);

    virtual void            DrawClientBorder(
                                const RECT* prcBounds,
                                const RECT* prcRedraw,
                                CDispSurface *pSurface,
                                CDispNode *pDispNode,
                                void *pClientData,
                                DWORD dwFlags)
    {
    }

    virtual void            DrawClientScrollbar(
                                int whichScrollbar,
                                const RECT* prcBounds,
                                const RECT* prcRedraw,
                                LONG contentSize,
                                LONG containerSize,
                                LONG scrollAmount,
                                CDispSurface *pSurface,
                                CDispNode *pDispNode,
                                void *pClientData,
                                DWORD dwFlags)
    {
    }

    virtual void            DrawClientScrollbarFiller(
                                const RECT* prcBounds,
                                const RECT* prcRedraw,
                                CDispSurface *pSurface,
                                CDispNode *pDispNode,
                                void *pClientData,
                                DWORD dwFlags)
    {
    }

    virtual BOOL            HitTestContent(
                                const POINT *pptHit,
                                CDispNode *pDispNode,
                                void *pClientData,
                                BOOL fDeclinedByPeer);

    virtual BOOL            HitTestFuzzy(
                                const POINT *pptHitInParentCoords,
                                CDispNode *pDispNode,
                                void *pClientData);

    virtual BOOL            HitTestScrollbar(
                                int whichScrollbar,
                                const POINT *pptHit,
                                CDispNode *pDispNode,
                                void *pClientData)
    {
        return FALSE;
    }

    virtual BOOL            HitTestScrollbarFiller(
                                const POINT *pptHit,
                                CDispNode *pDispNode,
                                void *pClientData)
    {
        return FALSE;
    }

    virtual BOOL            HitTestBorder(
                                const POINT *pptHit,
                                CDispNode *pDispNode,
                                void *pClientData)
    {
        return FALSE;
    }

    virtual BOOL            ProcessDisplayTreeTraversal(
                                void *pClientData)
    {
        return TRUE;
    }
                                          
    
    // called only for z ordered items
    virtual LONG            GetZOrderForSelf(CDispNode const* pDispNode);

    virtual LONG            CompareZOrder(
                                CDispNode const* pDispNode1,
                                CDispNode const* pDispNode2);

    virtual BOOL            ReparentedZOrder()
    {
        return FALSE;
    }
    
    virtual void            HandleViewChange(
                                DWORD          flags,
                                const RECT *   prcClient,
                                const RECT *   prcClip,
                                CDispNode *    pDispNode)
    {
    }


    // provide opportunity for client to fire_onscroll event
    virtual void            NotifyScrollEvent(
                                RECT *  prcScroll,
                                SIZE *  psizeScrollDelta)
    {
    }

    virtual DWORD           GetClientPainterInfo(
                                CDispNode *pDispNodeFor,
                                CAryDispClientInfo *pAryClientInfo)
    {
        return 0;
    }

    virtual void            DrawClientLayers(
                                const RECT* prcBounds,
                                const RECT* prcRedraw,
                                CDispSurface *pSurface,
                                CDispNode *pDispNode,
                                void *cookie,
                                void *pClientData,
                                DWORD dwFlags)
    {
    }

#if DBG==1
    virtual void            DumpDebugInfo(
                                HANDLE hFile,
                                long level,
                                long childNumber,
                                CDispNode const* pDispNode,
                                void* cookie) {}
#endif
    CRelDispNode *  operator [] (long i) { return &_aryRelDispNodes[i]; }
    long            Size()               { return _aryRelDispNodes.Size(); }
    void            DestroyDispNodes();
    CDispNode *     FindElementDispNode(CElement * pElement);
    void            SetElementDispNode(CElement * pElement, CDispNode * pDispNode);
    void            EnsureDispNodeVisibility(CElement * pElement = NULL);
    void            HandleDisplayChange();
    void            Delete(long iPosFrom, long iPosTo);

    // To handle invalidate notifications on relative elements:
    // See CFlowLayout::Notify() handling of invalidation.
    void            Invalidate( CElement *pElement, const RECT * prc = NULL, int nRects = 1 );

    void InsertAt(long iPos, CRelDispNode & rdn)
    {
        _aryRelDispNodes.InsertIndirect(iPos, &rdn);
    }
    CDisplay    * GetDisplay() const { return _pdp; }

    virtual BOOL            GetAnchorPoint(CDispNode*, CPoint*);

private:
    CDataAry <CRelDispNode> _aryRelDispNodes;
    CDisplay *              _pdp;
};

inline CLed::CLed()
{
}

typedef enum
{
    FNFL_NONE = 0x0,
    FNFL_STOPATGLYPH = 0x1,
} FNFL_FLAGS;

// ==========================  CDisplay  ====================================
// display - keeps track of line breaks for a device
// all measurements are in pixels on rendering device,
// EXCEPT xWidthMax and yHeightMax which are in twips

MtExtern(CDisplay)
;

class CDisplay : public CLineArray
{
    friend class CFlowLayout;
    friend class CLinePtr;
    friend class CLed;
    friend class CRecalcLinePtr;
    friend class CLSMeasurer;

protected:

    DWORD _fInBkgndRecalc          :1; //  0 - avoid reentrant background recalc
    DWORD _fLineRecalcErr          :1; //  1 - error occured during background recalc
    DWORD _fNoUpdateView           :1; //  2 - don't update visible view
    DWORD _fWordWrap               :1; //  3 - word wrap text
    DWORD _fWrapLongLines          :1; //  4 - true if we want to wrap long lines
    DWORD _fRecalcDone             :1; //  5 - is line recalc done ?
    DWORD _fNoContent              :1; //  6 - if there is no real content, table cell's compute
                                       //      width differently.
    DWORD _dxCaret                 :2; //  7-8 - caret width, 1 for edit 0 for browse
    DWORD _fMinMaxCalced           :1; //  9 - Min/max size is valid and cached
    DWORD _fRecalcMost             :1; // 11 - Do we recalc the most neg/pos lines?
    DWORD _fRTLDisplay             :1; // 12 - TRUE if outer flow is right-to-left
    DWORD _fHasRelDispNodeCache    :1; // 13 - TRUE if we have a relative disp node cache
    DWORD _fHasMultipleTextNodes   :1; // 14 - TRUE if we have more than one disp node for text flow
    DWORD _fNavHackPossible        :1; // 15 - TRUE if we can have the NAV BR hack
    DWORD _fContainsHorzPercentAttr :1;// 16 - TRUE if we've handled an element that has horizontal percentage attributes (e.g. indents, padding)
    DWORD _fContainsVertPercentAttr :1;// 17 - TRUE if we've handled an element that has vertical percentage attributes (e.g. indents, padding)
    DWORD _fDefPaddingSet          :1; // 18 - TRUE if one of the _defPadding* variables below has been set
    DWORD _fHasLongLine            :1; // 19 - TRUE if has a long line that might overflow on Win9x platform
    DWORD _fHasNegBlockMargins     :1; // 20 - TRUE if any one line has negative block margins
    DWORD _fLastLineAligned        :1; // 21 - TRUE if there is line(s) with last line alignment 
    
    LONG  _dcpCalcMax;                 // - last cp for which line breaks have been calc'd + 1
    LONG  _yCalcMax;                   // - height of calculated lines
    LONG  _yHeightMax;                 // - max height of this display (-1 for infinite)
    LONG  _xWidth;                     // - width of longest calculated line
    LONG  _yHeight;                    // - sum of heights of calculated lines
    LONG  _yMostNeg;                   // - Largest negative offset that a line or its contents
                                       // extend from the actual y offset of any given line
    LONG  _yMostPos;
    LONG  _xWidthView;                 // - view rect width
    LONG  _yHeightView;                // - view rect height

public:
    LONG    _xMinWidth;             // min possible width with word break
    LONG    _xMaxWidth;             // max possible width without word break
    LONG    _yBottomMargin;         // bottom margin is not taken into account
                                    // in lines. Left, Right margins of the
                                    // TxtSite are accumulated in _xLeft & _xRight
                                    // of each line respectively

protected:
    LONG  _defPaddingTop;              // top default padding
    LONG  _defPaddingBottom;           // bottom default padding

#if (DBG==1)
    CFlowLayout * _pFL;                // flow layout associated with this line array
public:    
    CStr          _cstrFonts;          // Used to return the fonts used on a line in debug mode
    BOOL          _fBuildFontList;     // Do we build a font list?
protected:
#endif

private:
    CHtPvPv _htStoredRFEs;          //Hash table to store results of RFE for block elements
                                    //without layout while rendering. Otherwise nested block
                                    //elements can be computed too many times, each time 
                                    //walking all lines covered by block element.
public:
    void ClearStoredRFEs();

private:

    // Layout
    BOOL    RecalcPlainTextSingleLine(CCalcInfo * pci);
    BOOL    RecalcLines(CCalcInfo * pci);
    BOOL    RecalcLinesWithMeasurer(CCalcInfo * pci, CLSMeasurer * pme);
    BOOL    RecalcLines(CCalcInfo * pci,
                        long cpFirst,
                        LONG cchOld,
                        LONG cchNew,
                        BOOL fBackground,
                        CLed *pled,
                        BOOL fHack = FALSE);
    BOOL    AllowBackgroundRecalc(CCalcInfo * pci, BOOL fBackground = FALSE);

    LONG    CalcDisplayWidth();

    void    NoteMost(CLineFull *pli);
    void    RecalcMost();

    // Helpers
    BOOL    CreateEmptyLine(CLSMeasurer * pMe,
                            CRecalcLinePtr * pRecalcLinePtr,
                            LONG * pyHeight, BOOL fHasEOP );

    void    DrawBackgroundAndBorder(CFormDrawInfo * pDI,
                                    long            cpIn,
                                    LONG            ili,
                                    LONG            lCount,
                                    LONG          * piliDrawn,
                                    LONG            yLi,
                                    const RECT    * rcView,
                                    const RECT    * rcClip,
                                    const CPoint  * ptOffset);

    void    DrawBackgroundForFirstLine(CFormDrawInfo * pDI,
                                       long            cpIn,
                                       LONG            ili,
                                       const RECT    * prcView,
                                       const RECT    * prcClip,
                                       const CPoint  * pptOffset);
    
    void    DrawElementBackground(CTreeNode *,
                                    CDataAry <RECT> * paryRects,  RECT * prcBound,
                                    const RECT * prcView, const RECT * prcClip,
                                    CFormDrawInfo * pDI, BOOL fPseudo);

    void    DrawElementBorder(CTreeNode *,
                                    CDataAry <RECT> * paryRects, RECT * prcBound,
                                    const RECT * prcView, const RECT * prcClip,
                                    CFormDrawInfo * pDI);
    
    // Computes the indent for a given Node and a left and/or
    // right aligned site that a current line is aligned to.
    void    ComputeIndentsFromParentNode(CCalcInfo * pci, CTreeNode * pNode, DWORD dwFlags,
                                         LONG * pxLeftIndent, LONG * pxRightIndent);                                    

public:
    void    SetNavHackPossible()  { _fNavHackPossible = TRUE; }
    BOOL    GetNavHackPossible()  { return _fNavHackPossible; }

    void    SetLastLineAligned()  { _fLastLineAligned = TRUE; }
    BOOL    GetLastLineAligned()  { return _fLastLineAligned; }
    
    void    RecalcLineShift(CCalcInfo * pci, DWORD grfLayout);
    void    RecalcLineShiftForNestedLayouts();

    void    DrawRelElemBgAndBorder(
                     long            cp,
                     CTreePos      * ptp,
                     CRelDispNode  * prdn,
                     const RECT    * prcView,
                     const RECT    * prcClip,
                     CFormDrawInfo * pDI);

    void    DrawElemBgAndBorder(
                     CElement        *   pElementRelative,
                     CDataAry <RECT> *   paryRects,
                     const RECT      *   prcView,
                     const RECT      *   prcClip,
                     CFormDrawInfo   *   pDI,
                     const CPoint    *   pptOffset,
                     BOOL                fDrawBackground,
                     BOOL                fDrawBorder,
                     LONG                cpStart,
                     LONG                cpFinish,
                     BOOL                fClipToCPs,
                     BOOL                fNonRelative = FALSE,
                     BOOL                fPseudo = FALSE);

    void GetExtraClipValues(LONG *plLeftV, LONG *plRightV);
    
protected:

    void    InitLinePtr ( CLinePtr & );

    // Helper to retrieve the layout context of the flowlayout that owns us
    CLayoutContext *LayoutContext() const;

    // Helper to undo the effects of measuring a line
    void UndoMeasure( CLayoutContext *pLayoutContext, long cpStart, long cpEnd );

public:
    CTreeNode *FormattingNodeForLine(DWORD        dwFlags,      // IN
                                     LONG         cpForLine,    // IN
                                     CTreePos    *ptp,          // IN
                                     LONG         cchLine,      // IN
                                     LONG        *pcch,         // OUT
                                     CTreePos   **pptp,         // OUT
                                     BOOL        *pfMeasureFromStart) const;  // OUT

    CTreeNode* EndNodeForLine(LONG         cpEndForLine,               // IN
                              CTreePos    *ptp,                        // IN
                              CCalcInfo   *pci,                        // IN
                              LONG        *pcch,                       // OUT
                              CTreePos   **pptp,                       // OUT
                              CTreeNode  **ppNodeForAfterSpace) const; // OUT

    DECLARE_MEMCLEAR_NEW_DELETE(Mt(CDisplay))

    CDisplay ();
    ~CDisplay();

    BOOL    Init();

    CFlowLayout *   GetFlowLayout() const;
    CElement *      GetFlowLayoutElement() const;
    CMarkup *       GetMarkup() const;

    void    Detach();

    // Getting properties

    BOOL    GetWordWrap() const             { return _fWordWrap; }
    void    SetWordWrap(BOOL fWrap)         { _fWordWrap = fWrap; }

    BOOL    GetWrapLongLines() const        { return _fWrapLongLines; }
    void    SetWrapLongLines(BOOL fWrapLongLines)
                                            { _fWrapLongLines = fWrapLongLines; }
    BOOL    NoContent() const               { return _fNoContent; }
    BOOL    HasLongLine() const             { return _fHasLongLine; }

    // maximum height and width
    LONG    GetMaxWidth() const             { return max(long(_xWidthView), GetWidth()); }
    LONG    GetMaxHeight() const            { return max(long(_yHeightView), GetHeight()); }

    LONG    GetCaret() const                { return _dxCaret; }

    BOOL    IsRTLDisplay() const            { return _fRTLDisplay; }
    void    SetRTLDisplay(BOOL fRTL)        { _fRTLDisplay = fRTL; }

    // Width, height and line count (all text)
    LONG    GetWidth() const                { return (_xWidth + _dxCaret); }
    LONG    GetHeight() const               { return (_yHeightMax + _yBottomMargin); }
    void    GetSize(CSize * psize) const
            {
                psize->cx = GetWidth();
                psize->cy = GetHeight();
            }
    void    GetSize(SIZE * psize) const
            {
                GetSize((CSize *)psize);
            }
    LONG    LineCount() const               { return CLineArray::Count(); }

    // View rectangle
    LONG    GetViewWidth() const            { return _xWidthView; }
    LONG    GetViewHeight() const           { return _yHeightView; }
    void    SetViewSize(const RECT &rcView);

    int     GetRTLOverflow() const
            {
                if (IsRTLDisplay() && _xWidth > _xWidthView)
                {
                    return _xWidth - _xWidthView;
                }
                return 0;
            }

    void    GetViewWidthAndHeightForChild(
                CParentInfo * ppri,
                long        * pxWidth,
                long        * pyHeight,
                BOOL fMinMax = FALSE);

    void    GetPadding(CParentInfo * ppri, long lPadding[], BOOL fMinMax = FALSE);

    LONG    GetFirstCp() const;
    LONG    GetLastCp() const;
    inline LONG GetFirstVisibleCp() const;
    inline LONG GetFirstVisibleLine() const;
    LONG    GetMaxCpCalced() const;

    // Line info
    LONG    CpFromLine(LONG ili, LONG *pyLine = NULL) const;
    void    Notify(CNotification * pnf);

    LONG    YposFromLine(CCalcInfo * pci, LONG ili, LONG *pyHeight_IgnoreNeg);

    void    RcFromLine(RECT *prc, LONG top, LONG ili, CLineCore *pli, CLineOtherInfo *ploi);

    BOOL    IsLogicalFirstFrag(LONG ili);
    
    enum LFP_FLAGS
    {
        LFP_ZORDERSEARCH    = 0x00000001,   // Hit lines on a z-order basis (default is source order)
        LFP_IGNOREALIGNED   = 0x00000002,   // Ignore frame lines (those for aligned content)
        LFP_IGNORERELATIVE  = 0x00000004,   // Ignore relative lines
        LFP_INTERSECTBOTTOM = 0x00000008,   // Intersect at the bottom (instead of the top)
        LFP_EXACTLINEHIT    = 0x00000010,   // find the exact line hit, do not return the
                                            // closest line hit.
    };

    LONG    LineFromPos(
                    const CRect &   rc,
                    DWORD           grfFlags = 0) const
            {
                return LineFromPos(rc, NULL, NULL, grfFlags);
            }
    LONG    LineFromPos (
                    const CRect &   rc,
                    LONG *          pyLine,
                    LONG *          pcpLine,
                    DWORD           grfFlags = 0,
                    LONG            iliStart = -1,
                    LONG            iliFinish = -1) const;

    enum CFP_FLAGS
    {
        CFP_ALLOWEOL                = 0x0001,
        CFP_EXACTFIT                = 0x0002,
        CFP_IGNOREBEFOREAFTERSPACE  = 0x0004,
        CFP_NOPSEUDOHIT                 = 0x0008
    };

    // Point <-> cp conversion
    LONG    CpFromPointReally(
         POINT            pt,                   // Point to compute cp at (client coords)
         CLinePtr * const prp,                  // Returns line pointer at cp (may be NULL)
         CMarkup **       ppMarkup,             // Markup which cp belongs to (in case of viewlinking)
         DWORD            dwFlags,              
         BOOL *           pfRightOfCp = NULL,
         LONG *           pcchPreChars = NULL,
         BOOL *           pfHitGlyph = NULL);

    LONG    CpFromPoint(POINT       pt,
                        CLinePtr * const prp,
                        CTreePos ** pptp,             // tree pos corresponding to the cp returned
                        CLayout **  ppLayout,
                        DWORD       dwFlags,
                        BOOL *      pfRightOfCp = NULL,
                        BOOL *      pfPseudoHit = NULL,
                        LONG *      pcchPreChars = NULL,
                        CCalcInfo * pci = NULL);

    LONG    CpFromPointEx(LONG      ili,
                        LONG        yLine,
                        LONG        cp,
                        POINT       pt,
                        CLinePtr * const prp,
                        CTreePos ** pptp,             // tree pos corresponding to the cp returned
                        CLayout **  ppLayout,
                        DWORD       dwFlags,
                        BOOL *      pfRightOfCp,
                        BOOL *      pfPseudoHit,
                        LONG *      pcchPreChars,
                        BOOL *      pfGlyphHit,
                        BOOL *      pfBulletHit,
                        CCalcInfo * pci);

    LONG    PointFromTp (
                    LONG cp,
                    CTreePos * ptp,
                    BOOL fAtEnd,
                    BOOL fAfterPrevCp,
                    POINT &pt,
                    CLinePtr * const prp,
                    UINT taMode,
                    CCalcInfo * pci = NULL,
                    BOOL *pfComplexLine = NULL,
                    BOOL *pfRTLFlow = NULL);

    LONG    RenderedPointFromTp (
                    LONG cp,
                    CTreePos * ptp,
                    BOOL fAtEnd,
                    POINT &pt,
                    CLinePtr * const prp,
                    UINT taMode,
                    CCalcInfo * pci,
                    BOOL *pfRTLFlow);

    void    RegionFromElement(
                        CElement       * pElement,
                        CDataAry<RECT> * paryRects,
                        CPoint         * pptOffset = NULL,
                        CFormDrawInfo  * pDI = NULL,
                        DWORD            dwFlags  = 0,
                        long             cpStart  = -1,
                        long             cpFinish = -1,
                        RECT *           prcBoundingRect = NULL
                        );
    void    RegionFromRange(
                    CDataAry<RECT> *    paryRects,
                    long                cp,
                    long                cch);

    CFlowLayout *MoveLineUpOrDown(NAVIGATE_DIRECTION iDir, BOOL fVertical, CLinePtr& rp, POINT ptCaret, LONG *pcp, BOOL *pfCaretNotAtBOL, BOOL *pfAtLogicalBOL);
    CFlowLayout *NavigateToLine  (NAVIGATE_DIRECTION iDir, CLinePtr& rp, POINT pt,    LONG *pcp, BOOL *pfCaretNotAtBOL, BOOL *pfAtLogicalBOL);
    BOOL      IsTopLine(CLinePtr& rp);
    BOOL      IsBottomLine(CLinePtr& rp);

    // Line break recalc.
    void    FlushRecalc();
    BOOL    RecalcView(CCalcInfo * pci, BOOL fFullRecalc);
    BOOL    UpdateView(CCalcInfo * pci, long cpFirst, LONG cchOld, LONG cchNew);
    BOOL    UpdateViewForLists(RECT *prcView, long cpFirst,
                               long  iliFirst, long  yPos,  RECT *prcInval);

    // Background recalc
    VOID    StartBackgroundRecalc(DWORD grfLayout);
    VOID    StepBackgroundRecalc(DWORD dwTimeOut, DWORD grfLayout);
    VOID    StopBackgroundRecalc();
    BOOL    WaitForRecalc(LONG cpMax, LONG yMax, CCalcInfo * pci = NULL);
    BOOL    WaitForRecalcIli(LONG ili, CCalcInfo * pci = NULL);
    BOOL    WaitForRecalcView(CCalcInfo * pci = NULL);
    inline CBgRecalcInfo * BgRecalcInfo();
    inline HRESULT EnsureBgRecalcInfo();
    inline void DeleteBgRecalcInfo();
    inline BOOL HasBgRecalcInfo() const;
    inline BOOL CanHaveBgRecalcInfo() const;
    //inline LONG DCpCalcMax() const;
    //inline LONG YCalcMax() const;
    inline LONG YWait() const;
    inline LONG CPWait() const;
    inline CRecalcTask * RecalcTask() const;
    inline DWORD BgndTickMax() const;

    // Selection
    void ShowSelected(CTreePos* ptpStart, CTreePos* ptpEnd, BOOL fSelected);

    HRESULT GetWigglyFromRange(CDocInfo * pdci, long cp, long cch, CShape ** ppShape);

    //
    // Text change notification stuff
    //

#if DBG==1
    void    CheckLineArray();
    void    CheckView();
    BOOL    VerifyFirstVisible();
    HRESULT GetFonts(long iLine, BSTR* pbstrFonts);
#endif
#if DBG==1 || defined(DUMPTREE)
    void DumpLines ( );
    void DumpLineText(HANDLE hFile, CTxtPtr* ptp, long iLine);
#endif

    // Misc helpers

    void    GetRectForChar(CCalcInfo   *pci,
                           LONG        *pTop,
                           LONG        *pBottom,
                           LONG         yTop,
                           LONG         yProposed,
                           CLineFull   *pli,
                           CTreePos    *ptp);

    void    GetTopBottomForCharEx(CCalcInfo  *pci, LONG      *pTop, LONG  *pBottom,
                                  LONG       yTop, CLineFull *pli,  LONG  xPos,
                                  LONG  yProposed, CTreePos  *ptp,  BOOL *pfBulletHit);

    void    GetClipRectForLine(RECT *prcClip, LONG top, LONG xOrigin, CLineCore *pli, CLineOtherInfo *ploi) const;

    // Rendering
    void    Render( CFormDrawInfo * pDI,
                    const RECT    & rcView,
                    const RECT    & rcRender,
                    CDispNode     * pDispNode);

    BOOL IsLastTextLine(LONG ili);
    void SetCaretWidth(int dx) { Assert (dx >=0); _dxCaret = dx; }

    void    DestroyFlowDispNodes();

    CDispNode * AddLayoutDispNode(
                    CParentInfo *   ppi,
                    CTreeNode *     pTreeNode,
                    long            dx,
                    long            dy,
                    CDispNode *     pDispSibling
                    );
    CDispNode * AddLayoutDispNode(
                    CParentInfo *   ppi,
                    CLayout *       pLayout,
                    long            dx,
                    long            dy,
                    CDispNode *     pDispSibling
                    );
    CDispNode * GetPreviousDispNode(LONG cp, LONG iliStart);
    void        AdjustDispNodes(CDispNode * pdnLastUnchanged, 
                                CDispNode * pdnLastChanged, 
                                CLed * pled
        );

    HRESULT HandleNegativelyPositionedContent(CLineFull   * pliNew,
                                              CLSMeasurer * pme,
                                              CDispNode   * pDNBefore,
                                              long          iLinePrev,
                                              long          yHeight);

    HRESULT InsertNewContentDispNode(CDispNode *  pDNBefore,
                                     CDispNode ** ppDispContent,
                                     long         iLine,
                                     long         yHeight);

    inline BOOL          HasRelDispNodeCache() const;
    HRESULT              SetRelDispNodeCache(void * pv);
    CRelDispNodeCache *  GetRelDispNodeCache() const;
    CRelDispNodeCache *  DelRelDispNodeCache();

    void SetVertPercentAttrInfo(BOOL fPercent) { _fContainsVertPercentAttr = fPercent; }
    void SetHorzPercentAttrInfo(BOOL fPercent) { _fContainsHorzPercentAttr = fPercent; }
    void ElementResize(CFlowLayout * pFlowLayout, BOOL fForceResize);


    // CRelDispNodeCache wants access to GetRelNodeFlowOffset()
    void GetRelNodeFlowOffset(CDispNode * pDispNode, CPoint * ppt);

    // Fontlinking support
    BOOL GetAveCharSize(CCalcInfo * pci, SIZE * psizeChar);
    BOOL GetCcs(CCcs * pccs, COneRun * por, XHDC hdc, CDocInfo * pdi, BOOL fFontLink = TRUE);

protected:
    // Rel line support
    CRelDispNodeCache * EnsureRelDispNodeCache();

    void    UpdateRelDispNodeCache(CLed * pled);

    void    AddRelNodesToCache( long cpStart, LONG yPos,
                                LONG iliStart, LONG iliFinish,
                                CDataAry<CRelDispNode> * prdnc);

    void    VoidRelDispNodeCache();
#if DBG==1
    CRelDispNodeCache * _pRelDispNodeCache;
#endif
    CDispNode *     FindElementDispNode(CElement * pElement) const
    {
        return HasRelDispNodeCache()
                ? GetRelDispNodeCache()->FindElementDispNode(pElement)
                : NULL;
    }
    void SetElementDispNode(CElement * pElement, CDispNode * pDispNode)
    {
        if (HasRelDispNodeCache())
            GetRelDispNodeCache()->SetElementDispNode(pElement, pDispNode);
    }
    void EnsureDispNodeVisibility(CElement * pElement = NULL)
    {
        if (HasRelDispNodeCache())
            GetRelDispNodeCache()->EnsureDispNodeVisibility(pElement);
    }
    void HandleDisplayChange()
    {
        if (HasRelDispNodeCache())
            GetRelDispNodeCache()->HandleDisplayChange();
    }
    void GetRelElementFlowOffset(CElement * pElement, CPoint * ppt);
    void TranslateRelDispNodes(const CSize & size, long lStart);
    void ZChangeRelDispNodes();
    void RegionFromElementCore(
                              CElement       * pElement,
                              CDataAry<RECT> * paryRects,
                              CPoint         * pptOffset = NULL,
                              CFormDrawInfo  * pDI = NULL,
                              DWORD            dwFlags  = 0,
                              long             cpStart  = -1,
                              long             cpFinish = -1,
                              RECT *           prcBoundingRect = NULL
        );
    void SetRelDispNodeContentOrigin(CDispNode *pDispNode);
};

#define ALIGNEDFEEDBACKWIDTH    4

inline CDispNode *
CDisplay::AddLayoutDispNode(
    CParentInfo *   ppi,
    CTreeNode *     pTreeNode,
    long            dx,
    long            dy,
    CDispNode *     pDispSibling
    )
{
    Assert(pTreeNode);
    Assert(pTreeNode->Element());
    Assert(pTreeNode->Element()->ShouldHaveLayout());

    return AddLayoutDispNode(ppi, pTreeNode->Element()->GetUpdatedLayout( ppi->GetLayoutContext() ),
        dx, dy, pDispSibling
        );
}

/*
 *  CDisplayL::InitLinePtr ( CLinePtr & plp )
 *
 *  @mfunc
 *      Initialize a CLinePtr properly
 */
inline
void CDisplay::InitLinePtr (
    CLinePtr & plp )        //@parm Ptr to line to initialize
{
    plp.Init( * this );
}

inline BOOL
CDisplay::HasRelDispNodeCache() const
{
    return _fHasRelDispNodeCache;
}

#if DBG!=1
#define CheckView()
#define CheckLineArray()
#endif

//+----------------------------------------------------------------------------
//
//  Class:  CFlowLayoutBreak (flow layout break)
//
//  Note:   Implementation of flow layout break.
//
//-----------------------------------------------------------------------------
MtExtern(CFlowLayoutBreak_pv); 
MtExtern(CFlowLayoutBreak_arySiteTask_pv); 

class CFlowLayoutBreak 
    : public CLayoutBreak
{
public:
    struct CSiteTask
    {
        CTreeNode * _pTreeNode;     // task is for this node 
        LONG        _xMargin;       // for left aligned objects left margin, 
                                    // for right aligned objects right margin 
    };
    DECLARE_CDataAry(CArySiteTask, CSiteTask, Mt(Mem), Mt(CFlowLayoutBreak_arySiteTask_pv));

    DECLARE_MEMALLOC_NEW_DELETE(Mt(CFlowLayoutBreak_pv));

    CFlowLayoutBreak() 
    {
        _pElementPBB    = NULL;
        _pMarkupPointer = NULL;

        _xLeftMargin    = 
        _xRightMargin   = 0;

        _xPadLeft       = 
        _xPadRight      = 0;

        _grfFlags       = 0;
    }

    virtual ~CFlowLayoutBreak();

    void SetFlowLayoutBreak(
        CMarkupPointer *pMarkupPointer, 
        LONG xLeftMargin, 
        LONG xRightMargin, 
        LONG xPadLeft, 
        LONG xPadRight) 
    {
        Assert(pMarkupPointer); 
        _pMarkupPointer = pMarkupPointer; 
        _xLeftMargin    = xLeftMargin; 
        _xRightMargin   = xRightMargin; 
        _xPadLeft       = xPadLeft; 
        _xPadRight      = xPadRight; 
    }

    CMarkupPointer *GetMarkupPointer() 
    { 
        Assert(_pMarkupPointer);
        return _pMarkupPointer; 
    }

    LONG GetLeftMargin()
    {
        return (_xLeftMargin);
    }

    LONG GetRightMargin()
    {
        return (_xRightMargin);
    }

    LONG GetPadLeft()
    {
        return (_xPadLeft);
    }

    LONG GetPadRight()
    {
        return (_xPadRight);
    }

    BOOL HasSiteTasks() const 
    {
        return (_arySiteTask.Size() != 0);
    }

    CArySiteTask *GetSiteTasks()
    {
        return (&_arySiteTask);
    }

public: 
    union 
    {
        DWORD   _grfFlags;

        struct 
        {
            DWORD   _fClearLeft     : 1;    //  0
            DWORD   _fClearRight    : 1;    //  1
            DWORD   _fAutoClear     : 1;    //  2

            DWORD   _fUnused        : 29;   //  3 - 31
        };
    };

    CElement       *    _pElementPBB;           // an element caused page-break-before on a line.

private:
    CMarkupPointer *    _pMarkupPointer;        // markup point indicating start position in the CDisplay. 
    LONG                _xLeftMargin;           // left margin layout finished 
    LONG                _xRightMargin;          // right margin layout finished 
    LONG                _xPadLeft;              // left padding 
    LONG                _xPadRight;             // right padding 
    CArySiteTask        _arySiteTask;           // array with site tasks
};

#pragma INCMSG("--- End '_disp.h'")
#else
#pragma INCMSG("*** Dup '_disp.h'")
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\text\_font.h ===
/*
 *  @doc    INTERNAL
 *
 *  @module _FONT.H -- Declaration of classes comprising font caching |
 *
 *  Purpose:
 *      Font cache
 *
 *  Owner: <nl>
 *      David R. Fulmer <nl>
 *      Christian Fortini <nl>
 *      Jon Matousek <nl>
 *
 *  History: <nl>
 *      8/6/95      jonmat Devised dynamic expanding cache for widths.
 *
 *  Copyright (c) 1995-1996 Microsoft Corporation. All rights reserved.
 */

#ifndef I__FONT_H_
#define I__FONT_H_
#pragma INCMSG("--- Beg '_font.h'")

#ifndef X_USP_HXX_
#define X_USP_HXX_
#include "usp.hxx"
#endif

#ifndef X_ATOMTBL_HXX_
#define X_ATOMTBL_HXX_
#include "atomtbl.hxx"
#endif

#ifndef X_FONTINFO_HXX_
#define X_FONTINFO_HXX_
#include "fontinfo.hxx"
#endif

#ifndef X_FONTCACHE_HXX_
#define X_FONTCACHE_HXX_
#include "fontcache.hxx"
#endif

enum CONVERTMODE
{
    CM_UNINITED = -1,
    CM_NONE,            // Use Unicode (W) CharWidth/TextOut APIs
    CM_MULTIBYTE,       // Convert to MBCS using WCTMB and _wCodePage
    CM_SYMBOL,          // Use low byte of 16-bit chars (for SYMBOL_CHARSET
                        //  and when code page isn't installed)
    CM_FEONNONFE,       // FE on non-FE if on Win95
};

// Forwards
class CFontCache;
class CCcs;
class CBaseCcs;

extern const INT maxCacheSize[];

//----------------------------------------------------------------------------
// Font selection wrappers
//----------------------------------------------------------------------------
#if DBG==1
    #define FONTIDX HFONT
    #define HFONT_INVALID NULL
//    #define FONTIDX size_t
//    #define HFONT_INVALID 0

    HFONT   SelectFontEx(XHDC hdc, HFONT hfont);
    BOOL    DeleteFontEx(HFONT hfont);
#else
    #define FONTIDX HFONT
    #define HFONT_INVALID NULL

    inline  HFONT SelectFontEx(XHDC _hdc_, HFONT hfont) { return SelectFont(_hdc_.GetFontInfoDC(), hfont) ; }
    #define DeleteFontEx(hfont)         DeleteObject(hfont)
#endif
//----------------------------------------------------------------------------

BOOL GetCharWidthHelper(XHDC hdc, UINT c, LPINT piWidth);

//----------------------------------------------------------------------------
// CWidthCache - lightweight Unicode width cache
//
// We have a separate, optimized cache for the lowest 128
// characters.  This cache just has the width, and not the character
// since we know the cache is big enough to hold all the widths
// in that range.  For all the higher characters, we have caches with
// both the width and the character whose width is stored, since
// there could be collisions.
//----------------------------------------------------------------------------
#define FAST_WIDTH_CACHE_SIZE    128
// TOTALCACHES is the number of caches not counting the "fast" one.
#define TOTALCACHES         3

MtExtern(CWidthCache);
class CWidthCache
{
public:
    typedef LONG CharWidth;

    typedef struct {
        TCHAR   ch;
        CharWidth width;
    } CacheEntry;

    static BOOL  IsCharFast(TCHAR ch)       { return ch < FAST_WIDTH_CACHE_SIZE; }

    BOOL   FastWidthCacheExists() const     { return _pFastWidthCache != NULL; }

    // Doesn't check if this will work.  Just does it.
    CharWidth  BlindGetWidthFast(const TCHAR ch) const;

    BOOL    PopulateFastWidthCache(XHDC hdc, CBaseCcs* pBaseCcs, CDocInfo * pdci);  // Third param is HACK for Generic TextOnly Printer

    // Use this one if we run out of memory in GetEntry;
    CacheEntry ceLastResort;

    //@cmember  Called before GetWidth
    BOOL    CheckWidth ( const TCHAR ch, LONG &rlWidth );

    //@cmember  Fetch width if CheckWidth ret FALSE.
    BOOL    FillWidth ( XHDC hdc,
                        CBaseCcs * pBaseCcs,
                        const TCHAR ch,
                        LONG &rlWidth );

    void    SetCacheEntry( TCHAR ch, CharWidth width );

    //@cmember  Fetch the width.
    INT     GetWidth ( const TCHAR ch );

    //@cmember  Free dynamic mem.
    ~CWidthCache();

    DECLARE_MEMCLEAR_NEW_DELETE(Mt(CWidthCache))

private:
    void ThreadSafeCacheAlloc(void** ppCache, size_t iSize);
    CacheEntry * GetEntry(const TCHAR ch);

private:
    CharWidth  * _pFastWidthCache;
    CacheEntry * (_pWidthCache[TOTALCACHES]);

};

inline CWidthCache::CharWidth 
CWidthCache::BlindGetWidthFast(const TCHAR ch) const
{
    Assert(FastWidthCacheExists());
    Assert(IsCharFast(ch));
    return _pFastWidthCache[ch];
}

inline void
CWidthCache::SetCacheEntry(TCHAR ch, CharWidth width)
{
    if (!IsCharFast(ch))
    {
        CacheEntry* pce= GetEntry(ch);
        pce->ch= ch;
        pce->width= width;
    }
    else
    {
        Assert( _pFastWidthCache );
        _pFastWidthCache[ch]= width;
    }
}

inline int
CACHE_SWITCH(const TCHAR ch)
{
    if (ch < 0x4E00)
    {
        Assert( !CWidthCache::IsCharFast(ch) );
        return 0;
    }
    else if (ch < 0xAC00)
        return 1;
    else
        return 2;
}

inline CWidthCache::CacheEntry *
CWidthCache::GetEntry(const TCHAR ch)
{
    // Figure out which cache we're in.
    Assert( !IsCharFast(ch) );

    int i= CACHE_SWITCH( ch );
    Assert( i>=0 && i < TOTALCACHES );

    CacheEntry ** ppEntry = &_pWidthCache[i];

    if (!*ppEntry)
    {
        ThreadSafeCacheAlloc( (void **)ppEntry, sizeof(CacheEntry) * (maxCacheSize[i] + 1) );

        // Assert that maxCacheSize[i] is of the form 2^n-1
        Assert( ((maxCacheSize[i] + 1) & maxCacheSize[i]) == 0 );

        // Failed, need to return a pointer to something,
        // just to avoid crashing. Layout will look bad.
        if (!*ppEntry)
            return &ceLastResort;
    }

    // logical & is really a MOD, as all of the bits
    // of cacheSize are turned on; the value of cacheSize is
    // required to be of the form 2^n-1.
    return &(*ppEntry)[ ch & maxCacheSize[i] ];
}

//----------------------------------------------------------------------------
// class CBaseCcs
//----------------------------------------------------------------------------

// Win2k, NT and Win9x can not reliably return measurement info for fonts bigger then ~30K
// So we use smaller fonts and scale measurements. See CBaseCcs::GetFontWithMetrics()
const int MAX_SAFE_FONT_SIZE = 16000;

MtExtern(CBaseCcs);
class CBaseCcs
{
    friend class CFontCache;
    friend class CCcs;
    friend CWidthCache::FillWidth( XHDC hdc, class CBaseCcs *, const TCHAR, LONG & );
    friend CWidthCache::PopulateFastWidthCache( XHDC hdc, CBaseCcs *, CDocInfo * );

private:
    SCRIPT_CACHE _sc;           // handle for Uniscribe (USP.DLL) script cache
    CWidthCache  _widths;

    DWORD   _dwRefCount;        // ref. count
    DWORD   _dwAge;             // for LRU algorithm

    FONTIDX _hfont;             // Windows font index/handle

    BYTE    _bCrc;              // check sum for quick comparison with charformats
    BYTE    _bPitchAndFamily;   // For CBaseCcs::Compare; identical to _lf.lfPitchAndFamily except in PRC hack

    SHORT   _sAdjustFor95Hack;  // Compute discrepancy between GetCharWidthA and W once.

    BYTE    _fConvertNBSPsSet             : 1; // _fConvertNBSPs and _fConvertNBSPsIfA have been set
    BYTE    _fConvertNBSPs                : 1; // Font requires us to convert NBSPs to spaces
    BYTE    _fLatin1CoverageSuspicious    : 1; // font probably does not adequately cover Latin1
    BYTE    _fUnused                      : 6; //
    
public:
    BYTE    _fHasInterestingData          : 1; // TRUE if the font has something interesting (like monospaced, overhang etc)
    BYTE    _fTTFont                      : 1; // TRUE if TrueType font
    BYTE    _fFixPitchFont                : 1; // font with fix character width
    BYTE    _fFEFontOnNonFEWin95          : 1;

    BYTE    _fHeightAdjustedForFontlinking: 1;
    BYTE    _fPrinting                    : 1;
    BYTE    _fScalingRequired             : 1; // TRUE if font is big so we create smaller font
                                               // and use scaling to obtain measurements
                                               // (workaround for W2K, NT and W9x bug)

    LONG    _yCfHeight;     // Height of font in TWIPs.
    LONG    _yHeight;       // total height of the character cell in logical units.
    LONG    _yDescent;      // distance from baseline to bottom of character cell in logical units.
    LONG    _xAveCharWidth; // average character width in logical units.
    LONG    _xMaxCharWidth; // max character width in logical units.
    USHORT  _sCodePage;     // code page for font.
    SHORT   _xOverhangAdjust;// overhang for synthesized fonts in logical units.
    SHORT   _xOverhang;     // font's overhang.
    SHORT   _xUnderhang;    // font's underhang.
    SHORT   _sPitchAndFamily;    // For getting the right widths.
    BYTE    _bCharSet;
    BYTE    _bConvertMode;  // CONVERTMODE casted down to a byte
    LONG    _xDefDBCWidth;  // default width for DB Character
    SCRIPT_IDS _sids;       // Font script ids.  Cached value from CFontInfo.
    DWORD   _dwLangBits;    // For old-style fontlinking.  TODO (cthrash, IE5 bug 112152) retire this.

    // NOTE (paulpark): The LOGFONT structure includes a font name.  We keep _latmLFFaceName in sync with
    // this font name.  It always points into the atom table in the global font-cache to the same thing.
    // For this reason you must never directly change _latmLFFaceName or _lf.lfFaceName without changing
    // the other.  In fact you should just use the two mutator methods: SetLFFaceName and SetLFFaceNameAtm.
    LOGFONT _lf;                // the log font as returned from GetObject().
    LONG    _latmLFFaceName;    // For faster string-name comparisons.  The atom table is in the FontCache.
    LONG    _latmBaseFaceName;  // base facename -- for fontlinking
    LONG    _latmRealFaceName;  // What font did GDI actually give us when we selected it?  Aka, the "Rendering Font."
    LONG    _yOriginalHeight;   // pre-adjusted height -- for fontlinking

    float   _flScaleFactor;     // used if _fScalingRequired is TRUE

#if DBG == 1
    static LONG s_cTotalCccs;
    static LONG s_cMaxCccs;
#endif

public:
    DECLARE_MEMCLEAR_NEW_DELETE(Mt(CBaseCcs))

    CBaseCcs ()
    {
        _hfont = HFONT_INVALID;
        _dwRefCount = 1;
#if DBG == 1
        s_cMaxCccs = max(s_cMaxCccs, ++s_cTotalCccs);
#endif
    }
    ~CBaseCcs ()
    {
        if (_hfont != HFONT_INVALID)
            DestroyFont();

        // make sure script cache is freed
        ReleaseScriptCache();

        WHEN_DBG(s_cTotalCccs--);

    }

    BOOL    Init(XHDC hdc, const CCharFormat * const pcf, CDocInfo * pdci, LONG latmBaseFaceName, BOOL fForceTTFont);
    void    AddRef()    { InterlockedIncrement((LONG *)&_dwRefCount); }
    void    Release()   { PrivateRelease(); }
    void    ReleaseScriptCache();

    typedef struct tagCompareArgs
    {
        CCharFormat * pcf;
        LONG lfHeight;
        LONG latmBaseFaceName;
        BOOL fTTFont;
    } CompareArgs;

    BOOL Compare( CompareArgs * pCompareArgs );
    BOOL CompareForFontLink( CompareArgs * pCompareArgs );

    void GetAscentDescent(LONG *pyAscent, LONG *pyDescent) const;
    CONVERTMODE GetConvertMode(BOOL fEnhancedMetafile, BOOL fMetafile) const;

    //
    // Width Cache Functions Exposed
    //
    BOOL    Include( XHDC hdc, TCHAR ch, LONG &rlWidth );  // Slow, reliable.
    // Assumes ascii.  No checking.  Will crash if > 128.
    BOOL    EnsureFastCacheExists(XHDC hdc, CDocInfo * pdci);   // HACK - Second parameter not needed.  Hack for Generic/TextOnly Printer

    // Mutators for _lf.szFaceName
    void SetLFFaceNameAtm(LONG latmFaceName);
    void SetLFFaceName(const TCHAR * szFaceName);
    void VerifyLFAtom();

    void EnsureLangBits(XHDC hdc);

    void FixupForFontLink(XHDC hdc, const CBaseCcs * const pBaseBaseCcs, BOOL fFEFont);

    BOOL    HasFont() const { return (_hfont != HFONT_INVALID); }
    FONTIDX PushFont(XHDC hdc);
    void    PopFont(XHDC hdc, FONTIDX hfontOld);

    BOOL    GetLogFont(LOGFONT * plf) const;

private:
    BOOL    MakeFont(XHDC hdc, const CCharFormat * const pcf, CDocInfo * pdci, BOOL fForceTTFont);
    void    DestroyFont();
    BOOL    GetTextMetrics(XHDC hdc, CODEPAGE codepage, LCID lcid);
    BOOL    GetFontWithMetrics(XHDC hdc, TCHAR* szNewFaceName, CODEPAGE codepage, LCID lcid);

    BOOL    FillWidths ( XHDC hdc, TCHAR ch, LONG &rlWidth );
    void    PrivateRelease();

    BOOL    NeedConvertNBSPs(XHDC hdc, CDoc *pDoc);  // Set _fConvertNBSPs/_fConvertNBSPsIfA flags
    BOOL    ConvertNBSPs(XHDC hdc, CDoc * pDoc);

#if DBG==1
    HFONT   GetHFont() const;
#else
    HFONT   GetHFont() const { return _hfont; }
#endif
};

inline void 
CBaseCcs::GetAscentDescent(LONG *pyAscent, LONG *pyDescent) const
{
    *pyAscent  = _yHeight - _yDescent;
    *pyDescent = _yDescent;
}

inline BOOL 
CBaseCcs::ConvertNBSPs(XHDC hdc, CDoc *pDoc)
{
    return ((_fConvertNBSPsSet || NeedConvertNBSPs(hdc, pDoc)) && _fConvertNBSPs);
}

inline BOOL 
CBaseCcs::EnsureFastCacheExists(XHDC hdc, CDocInfo * pdci)
{
    if (!_widths.FastWidthCacheExists())
    {
        _widths.PopulateFastWidthCache(hdc, this, pdci);
    }
    return _widths.FastWidthCacheExists();
}

#if DBG!=1
inline FONTIDX
CBaseCcs::PushFont(XHDC hdc)
{
    FONTIDX hfontOld = (HFONT)GetCurrentObject(hdc, OBJ_FONT);

    if (hfontOld != _hfont)
    {
        hdc.SetBaseCcsPtr( this );
        SelectFontEx(hdc, _hfont);
    }
    
    return hfontOld;
}

inline void
CBaseCcs::PopFont(XHDC hdc, FONTIDX hfontOld)
{
    if (hfontOld != _hfont)
    {
        hdc.SetBaseCcsPtr(NULL);
        SelectFontEx(hdc, hfontOld);
    }        
}
#endif

//----------------------------------------------------------------------------
// CCcs - caches font metrics and character size for one font
//----------------------------------------------------------------------------
MtExtern(CCcs);
class CCcs
{
    friend class CFontCache;
public:
    DECLARE_MEMCLEAR_NEW_DELETE(Mt(CCcs))

    CCcs()                              { _hdc = NULL; _pBaseCcs = NULL; _fForceTTFont = FALSE; }
    CCcs(const CCcs& ccs)               { memcpy(this, &ccs, sizeof(ccs)); }

    XHDC GetHDC()                       { return _hdc; }
    const CBaseCcs * GetBaseCcs() const { return _pBaseCcs; }
    BOOL GetForceTTFont() const         { return _fForceTTFont; }
    void SetForceTTFont(BOOL fTT)       { _fForceTTFont = !!fTT; }

    void Release();
    BOOL Include(TCHAR ch, LONG &rlWidth);
    void EnsureLangBits();
    BOOL ConvertNBSPs(XHDC hdc, CDoc *pDoc);
    SCRIPT_CACHE * GetUniscribeCache();
    void SetConvertMode(CONVERTMODE cm);
    void MergeSIDs(SCRIPT_IDS sids);
    void MergeLangBits(DWORD dwLangBits);

    FONTIDX PushFont(XHDC hdc);
    void    PopFont(XHDC hdc, FONTIDX hfontOld);

private:
    void SetHDC(XHDC hdc)               { _hdc = hdc; }
    void SetBaseCcs(CBaseCcs *pBaseCcs) { _pBaseCcs = pBaseCcs; }

private:
    XHDC       _hdc;
    CBaseCcs *_pBaseCcs;
    BYTE      _fForceTTFont : 1;
};

inline void 
CCcs::Release()
{
    if (_pBaseCcs)
    {
        _pBaseCcs->PrivateRelease(); 
        _pBaseCcs = NULL;
    }
}

inline BOOL 
CCcs::Include(TCHAR ch, LONG &rlWidth)
{
    Assert(_pBaseCcs);
    return _pBaseCcs->Include(_hdc, ch, rlWidth);
}

inline void 
CCcs::EnsureLangBits()
{
    Assert(_pBaseCcs);
    _pBaseCcs->EnsureLangBits(_hdc);
}

inline BOOL 
CCcs::ConvertNBSPs(XHDC hdc, CDoc *pDoc)
{
    Assert(_pBaseCcs);
    return _pBaseCcs->ConvertNBSPs(hdc, pDoc);
}

inline SCRIPT_CACHE * 
CCcs::GetUniscribeCache()
{
    Assert(_pBaseCcs);
    return &_pBaseCcs->_sc;
}

inline void 
CCcs::SetConvertMode(CONVERTMODE cm)
{
    Assert(_pBaseCcs);
    _pBaseCcs->_bConvertMode = cm;
}

inline void 
CCcs::MergeSIDs(SCRIPT_IDS sids)
{
    Assert(_pBaseCcs);
    _pBaseCcs->_sids |= sids;
}

inline void 
CCcs::MergeLangBits(DWORD dwLangBits)
{
    Assert(_pBaseCcs);
    _pBaseCcs->_dwLangBits |= dwLangBits;
}

inline FONTIDX 
CCcs::PushFont(XHDC hdc)
{
    Assert(_pBaseCcs);
    return _pBaseCcs->PushFont(hdc);
}

inline void 
CCcs::PopFont(XHDC hdc, FONTIDX hfontOld)
{
    Assert(_pBaseCcs);
    _pBaseCcs->PopFont(hdc, hfontOld);
}


// This function tries to get the width of this character,
// returning TRUE if it can.
// It's called "Include" just to confuse people.
// GetCharWidth would be a better name.
#if DBG != 1
#pragma optimize(SPEED_OPTIMIZE_FLAGS, on)
#endif

inline
BOOL
CBaseCcs::Include ( XHDC hdc, TCHAR ch, LONG &rlWidth )
{
    if (_widths.IsCharFast(ch))
    {
        Assert(_widths.FastWidthCacheExists());
        // ASCII case -- really optimized.
        rlWidth= _widths.BlindGetWidthFast(ch);
        return TRUE;
    }
    else if (_widths.CheckWidth( ch, rlWidth ))
    {
        return TRUE;
    }
    else
    {
        return FillWidths( hdc, ch, rlWidth );
    }
}

/*
 *  CWidthCache::CheckWidth(ch, rlWidth)
 *
 *  @mfunc
 *      check to see if we have a width for a TCHAR character.
 *
 *  @comm
 *      Used prior to calling FillWidth(). Since FillWidth
 *      may require selecting the map mode and font in the HDC,
 *      checking here first saves time.
 *
 *  @rdesc
 *      returns TRUE if we have the width of the given TCHAR.
 *
 *  Note: This should not be called for ascii characters --
 *    a faster codepath should be taken.  This asserts against it.
 */
inline BOOL
CWidthCache::CheckWidth (
    const TCHAR ch,  //@parm char, can be Unicode, to check width for.
    LONG &rlWidth ) //@parm the width of the character
{
    Assert( !IsCharFast(ch) );

    CacheEntry widthData = *GetEntry ( ch );

    if( ch == widthData.ch )
    {
        rlWidth = widthData.width;
        return TRUE;
    }
    else
    {
        return FALSE;
    }
}

inline void
CBaseCcs::VerifyLFAtom()
{
#if DBG==1
    const TCHAR * szFaceName = fc().GetFaceNameFromAtom(_latmLFFaceName);
        // If this assert fires that means somebody is directly modifying either _latmLFFaceName
        // or _lf.lffacename.  You should never modify these directly, but instead use the
        // SetLFFaceName or SetLFFaceNameAtm mutator methods, as these are sure to keep the
        // actual string and the atomized value in sync.
#ifdef UNIX
    Assert( !StrCmpC( _lf.lfFaceName, szFaceName ) );
#else
    Assert( !StrCmpIC( _lf.lfFaceName, szFaceName ) );
#endif
#endif
}

#if DBG != 1
#pragma optimize("", on)
#endif

#pragma INCMSG("--- End '_font.h'")
#else
#pragma INCMSG("*** Dup '_font.h'")
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\text\_doc.h ===
/*
 *  @doc INTERNAL
 *
 *  @module _DOC.H  CTxtStory declaration |
 *
 *  Purpose:
 *      Encapsulate the plain-text document data (text blocks, cchText)
 *
 *  Original Authors: <nl>
 *      Christian Fortini <nl>
 *      Murray Sargent <nl>
 *
 *  History: <nl>
 *      6/25/95 alexgo  commented and cleaned up
 *
 */

#ifndef I__DOC_H_
#define I__DOC_H_
#pragma INCMSG("--- Beg '_doc.h'")

#ifndef X_ARRAY_HXX_
#define X_ARRAY_HXX_
#include "array.hxx"
#endif

class CTreeNode;

MtExtern(CTxtArray)

#define cbBlockCombine  CbOfCch(3072)
#define cbBlockMost     CbOfCch(49152)
#define cbBlockInitial  CbOfCch(4096)
#define cchGapInitial   128
#define cchBlkCombmGapI (CchOfCb(cbBlockCombine) - cchGapInitial)
#define cchBlkInitmGapI (CchOfCb(cbBlockInitial) - cchGapInitial)

#define cchBlkInsertmGapI   (CchOfCb(cbBlockInitial)*5 - cchGapInitial)

// Switch the return value to flip between before/after space

class CElement;
class CTxtPtr;
class CTxtArray;
class CTable;
class CTreePos;
struct CTextChange;
enum  ELEMENT_TAG;

/*
 *  CTxtRun
 *
 *  @class  Formalizes a run of text. A range of text with same attribute,
 * (see CFmtDesc) or within the same line (see CLine), etc. Runs are kept
 * in arrays (see CArray) and are pointed to by CRunPtr's of various kinds.
 * In general the character position of a run is computed by summing the
 * length of all preceding runs, altho it may be possible to start from
 * some other cp, e.g., for CLines, from CDisplay::_cpFirstVisible.
 */

class CTxtRun
{
public:

    CTxtRun ( ) { _cch = 0; }

    long _cch;
};

/*
 *  CTxtBlk
 *
 *  @class  A text block; a chunk of UNICODE text with a buffer gap to allow
 *  for easy insertions and deletions.
 *
 *  @base   protected | CTxtRun
 *
 *  @devnote    A text block may have four states: <nl>
 *      NULL:   No data allocated for the block <nl>
 *              <md CTxtBlk::_pch> == NULL  <nl>
 *              <md CTxtRun::_cch> == 0     <nl>
 *              <md CTxtBlk::_ibGap> == 0   <nl>
 *              <md CTxtBlk::_cbBlock> == 0 <nl>
 *
 *      empty:  All of the available space is a buffer gap <nl>
 *              <md CTxtBlk::_pch> != NULL  <nl>
 *              <md CTxtRun::_cch> == 0     <nl>
 *              <md CTxtBlk::_ibGap> == 0   <nl>
 *              <md CTxtBlk::_cbBlock> <gt>= 0  <nl>
 *
 *      normal: There is both data and a buffer gap <nl>
 *              <md CTxtBlk::_pch> != NULL  <nl>
 *              <md CTxtRun::_cch> != 0     <nl>
 *              <md CTxtBlk::_ibGap> != 0   <nl>
 *              <md CTxtBlk::_cbBlock> <gt>= 0  <nl>
 *
 *      full:   The buffer gap is of zero size <nl>
 *              <md CTxtBlk::_pch> != NULL  <nl>
 *              <md CTxtRun::_cch> <gt>= 0  <nl>
 *              <md CTxtBlk::_ibGap> <gt> 0 <nl>
 *              <md CTxtBlk::_cbBlock> == _cch * sizeof(WCHAR) <nl>
 *
 *  The position of the buffer gap is given by _ibGap.  With _cch and _cbBlock,
 *  it's possible to figure out the *size* of the gap by simply calculating:
 *  <nl>
 *      size = _cbBlock - (_cch * sizeof(character))
 *
 */

class CTxtBlk : public CTxtRun
{
    friend class CTxtPtr;
    friend class CTxtArray;

protected:

    CTxtBlk ( ) { InitBlock( 0 ); }

  ~ CTxtBlk ( ) { FreeBlock(); }

                                    //@cmember  Initializes the block to the
                                    //# of bytes given by <p cb>
    BOOL    InitBlock(DWORD cb);
                                    //@cmember  Sets a block to the NULL state
    VOID    FreeBlock();
                                    //@cmember  Moves the buffer gap in a
                                    //block
    VOID    MoveGap(DWORD ichGap);
                                    //@cmember  Resizes a block to <p cbNew>
                                    //bytes
    BOOL    ResizeBlock(DWORD cbNew);

private:

    TCHAR   *_pch;          // Pointer to the text data
    DWORD   _ibGap;         // BYTE offset of the gap
    DWORD   _cbBlock;       // Size of the block in bytes
};


/*
 *  CTxtArray
 *
 *  @class  A dynamic array of <c CTxtBlk> classes
 *
 *  @base public | CArray<lt>CTxtBlk<gt>
 */
class CTxtArray : public CArray<CTxtBlk>
{
    friend class CTxtPtr;
    friend class CMarkup;

public:

    DECLARE_MEMALLOC_NEW_DELETE(Mt(CTxtArray))

#if DBG==1
                                    //@cmember  Invariant support
    BOOL Invariant( void ) const;
#endif
                                    //@cmember  Constructor
    CTxtArray();
                                    //@cmember  Destructor
    ~CTxtArray();
                                    //@cmember  Gets the total number of
                                    //characters in the array.
    long    GetCch () const;

                                    //@cmember Removes all data from the array
    VOID    RemoveAll();

private:
    BOOL    AddBlock(DWORD itbNew, LONG cb);
                                    //@cmember  Removes the given number of
                                    //blocks
    VOID    RemoveBlocks(DWORD itbFirst, DWORD ctbDel);
                                    //@cmember  Combines blocks adjacent to itb
    BOOL    CombineBlocks(DWORD itb);
                                    //@cmember  Splits a block
    BOOL    SplitBlock(DWORD itb, DWORD ichSplit, DWORD cchFirst,
                DWORD cchLast, BOOL fStreaming);
                                    //@cmember  Shrinks all blocks to their minimal
                                    //size
    VOID    ShrinkBlocks();
                                    //@cmember  Copies a chunk of text into the
                                    //given location
    LONG    GetChunk(TCHAR **ppch, DWORD cch, TCHAR *pchChunk, DWORD cchCopy) const;
                                    //@cmember  The total number of characters in the
                                    //this text array.
    DWORD   _cchText;
};

#pragma INCMSG("--- End '_doc.h'")
#else
#pragma INCMSG("*** Dup '_doc.h'")
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\text\_dxfrobj.h ===
/*
 *  _DXFROBJ.H
 *
 *  Purpose:
 *      Class declaration for an OLE data transfer object (for use in
 *      drag drop and clipboard operations)
 *
 *  Author:
 *      alexgo (4/25/95)
 */

#ifndef I__DXFEROBJ_H_
#define I__DXFEROBJ_H_
#pragma INCMSG("--- Beg '_dxfrobj.h'")

class CFlowLayout;

#ifndef X_XBAG_HXX_
#define X_XBAG_HXX_
#include "xbag.hxx"
#endif

/*
 *  CTextXBag
 *
 *  Purpose:
 *      holds a "snapshot" of some text data that can be used
 *      for drag drop or clipboard operations
 *
 *  Notes:
 *      TODO (alexgo): add in support for TOM<-->TOM optimized data
 *      transfers
 */

MtExtern(CTextXBag)

class CSelDragDropSrcInfo;

typedef enum tagDataObjectInfo
{
    DOI_NONE            = 0,
    DOI_CANUSETOM       = 1,    // TOM<-->TOM optimized data transfers
    DOI_CANPASTEPLAIN   = 2,    // plain text pasting available
    DOI_CANPASTERICH    = 4,    // rich text pasting available  (TODO: alexgo)
    DOI_CANPASTEOLE     = 8     // object may be pasted as an OLE embedding
                                // (note that this flag may be combined with
                                // others). (TODO: alexgo)
    //TODO (alexgo): more possibilites:  CANPASTELINK, CANPASTESTATICOLE
} DataObjectInfo;

typedef enum CREATE_FLAGS
{
    CREATE_FLAGS_NoIE4SelCompat = 0x00001,  // Disable IE 4 selection compat
    CREATE_FLAGS_ExternalMask   = 0x0FFFF,  // Mask of external flags
    CREATE_FLAGS_SupportsHtml   = 0x10000,  // Supports HTML
};

class CTextXBag : public CBaseBag
{
    typedef CBaseBag super;
public:

    STDMETHODIMP QueryInterface(REFIID iid, LPVOID * ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    STDMETHOD(EnumFormatEtc)( DWORD dwDirection,
            IEnumFORMATETC **ppenumFormatEtc);
    STDMETHOD(GetData)( LPFORMATETC pformatetcIn, STGMEDIUM *pmedium );
    STDMETHOD(QueryGetData)( LPFORMATETC pformatetc );
    STDMETHOD(SetData) (LPFORMATETC pformatetc, STGMEDIUM FAR * pmedium, BOOL fRelease);

    static HRESULT  Create(CMarkup *             pMarkup,
                           DWORD                 dwFlags,
                           ISegmentList *        pSegmentList, 
                           BOOL                  fDragDrop,
                           CTextXBag **          ppTextXBag,
                           CSelDragDropSrcInfo * pSelDragDropSrcInfo = NULL);

    static HRESULT  GetDataObjectInfo(IDataObject *   pdo,      
                                      DWORD *         pDOIFlags);

    //
    // Others
    //

private:
    // NOTE: private cons/destructor, may not be allocated on the stack as
    // this would break OLE's current object liveness rules
    CTextXBag();
    virtual ~CTextXBag();

    HRESULT     SetKeyState();
    HRESULT     FillWithFormats(CMarkup *       pMarkup,
                                DWORD           dwFlags,
                                ISegmentList *  pSegmentList );

    HRESULT     SetTextHelper(CMarkup *     pMarkup,
                              ISegmentList *pSegmentList,
                              DWORD         dwSaveHtmlFlags,
                              CODEPAGE      cp,
                              DWORD         dwStmWrBuffFlags,
                              HGLOBAL *     phGlobalText,
                              int           iFETCIndex,
                              BOOL          fSetToNull = TRUE );

    HRESULT     SetText         (CMarkup *      pMarkup,
                                 DWORD          dwFlags,
                                 ISegmentList * pSegmentList );

    HRESULT     SetUnicodeText  (CMarkup *      pMarkup,
                                 DWORD          dwFlags,
                                 ISegmentList * pSegmentList );

    HRESULT     SetCFHTMLText   (CMarkup *      pMarkup,
                                 DWORD          dwFlags,
                                 ISegmentList * pSegmentList );

    HRESULT     SetLazyRTFText  (CMarkup *      pMarkup,
                                 DWORD          dwFlags,
                                 ISegmentList * pSegmentList );
                                 
    HRESULT     ConvertHTMLToRTF(HGLOBAL hHTMLText, 
                                 HGLOBAL *phRTFText);

    HRESULT     GetHTMLText    (HGLOBAL      *  phGlobal, 
                                ISegmentList *  pSegmentList,
                                CMarkup      *  pMarkup, 
                                DWORD           dwSaveHtmlMode,
                                CODEPAGE        codepage, 
                                DWORD           dwStrWrBuffFlags);

    DECLARE_MEMCLEAR_NEW_DELETE(Mt(CTextXBag))

    long        _cFormatMax;    // maximum formats the array can store
    long        _cTotal;        // total number of formats in the array
    FORMATETC * _prgFormats;    // the array of supported formats
    CSelDragDropSrcInfo * _pSelDragDropSrcInfo;

public:
    HGLOBAL     _hText;             // handle to the ansi plain text
    HGLOBAL     _hUnicodeText;      // handle to the plain UNICODE text
    HGLOBAL     _hRTFText;          // handle to the RTF text
    HGLOBAL     _hCFHTMLText;       // handle to the CFHTML (in utf-8)

    CGenDataObject*  _pGenDO;          // Generic Data Transfer Object
    UINT        _fRtfConverted : 1; // RTF converted
};


//
//  Some globally useful FORMATETCs

extern FORMATETC g_rgFETC[];
extern const DWORD g_rgDOI[];
extern const int CFETC;

enum FETCINDEX                          // Keep in sync with g_rgFETC[]
{
    iHTML,                              // HTML (in ANSI)
    iRtfFETC,                           // RTF
    iUnicodeFETC,                       // Unicode plain text
    iAnsiFETC,                          // ANSI plain text
//    iFilename,                          // Filename
    iRtfAsTextFETC,                     // Pastes RTF as text
    iFileDescA,                         // FileGroupDescriptor
    iFileDescW,                         // FileGroupDescriptorW
    iFileContents,                      // FileContents
    iShellIdList,                       // Shell IDList Array
    iUniformResourceLocator             // UniformResourceLocator
//    iEmbObj,                            // Embedded Object
//    iEmbSrc,                            // Embed Source
//    iObtDesc,                           // Object Descriptor
//    iLnkSrc,                            // Link Source
//    iMfPict,                            // Metafile
//    iDIB,                               // DIB
//    iBitmap,                            // Bitmap
//    iRtfNoObjs,                         // RTF with no objects
//    iTxtObj,                            // Richedit Text
//    iRichEdit                           // RichEdit Text w/formatting
};

#define cf_HTML                     g_rgFETC[iHTML].cfFormat
//#define cf_RICHEDIT               g_rgFETC[iRichEdit].cfFormat
//#define cf_EMBEDDEDOBJECT         g_rgFETC[iEmbObj].cfFormat
//#define cf_EMBEDSOURCE            g_rgFETC[iEmbSrc].cfFormat
//#define cf_OBJECTDESCRIPTOR       g_rgFETC[iObtDesc].cfFormat
//#define cf_LINKSOURCE             g_rgFETC[iLnkSrc].cfFormat
#define cf_RTF                      g_rgFETC[iRtfFETC].cfFormat
//#define cf_RTFNOOBJS              g_rgFETC[iRtfNoObjs].cfFormat
//#define cf_TEXTOBJECT             g_rgFETC[iTxtObj].cfFormat
#define cf_RTFASTEXT                g_rgFETC[iRtfAsTextFETC].cfFormat
//#define cf_FILENAME               g_rgFETC[iFilename].cfFormat
#define cf_FILEDESCA                g_rgFETC[iFileDescA].cfFormat
#define cf_FILEDESCW                g_rgFETC[iFileDescW].cfFormat
#define cf_FILECONTENTS             g_rgFETC[iFileContents].cfFormat
#define cf_SHELLIDLIST              g_rgFETC[iShellIdList].cfFormat
#define cf_UNIFORMRESOURCELOCATOR   g_rgFETC[iUniformResourceLocator].cfFormat

#pragma INCMSG("--- End '_dxfrobj.h'")
#else
#pragma INCMSG("*** Dup '_dxfrobj.h'")
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\text\_fontlnk.h ===
#ifndef I__FONTLNK_H_
#define I__FONTLNK_H_
#pragma INCMSG("--- Beg '_fontlnk.h'")

class CCcs;
class COneRun;
class CBaseCcs;

// HACK (cthrash) We do not ever font link for SYMBOL_CHARSET fonts.  This
// makes the FS_SYMBOL bit useless for us.  What we'd like to do, is to
// distinguish the ASCII portion from FS_LATIN1, since basically all fonts
// claim to have FS_LATIN1 when in reality many of them only contain the
// ASCII portion of Latin-1.  So here's the hack - all fonts have SBITS_ASCII
// set.  This simplifies the loop in CRenderer.

#define SBITS_LATIN1               FS_LATIN1
#define SBITS_LATIN2               FS_LATIN2
#define SBITS_CYRILLIC             FS_CYRILLIC
#define SBITS_GREEK                FS_GREEK
#define SBITS_TURKISH              FS_TURKISH
#define SBITS_HEBREW               FS_HEBREW
#define SBITS_ARABIC               FS_ARABIC
#define SBITS_BALTIC               FS_BALTIC
#define SBITS_JISJAPAN             FS_JISJAPAN
#define SBITS_CHINESESIMP          FS_CHINESESIMP
#define SBITS_WANSUNG              FS_WANSUNG
#define SBITS_CHINESETRAD          FS_CHINESETRAD
#define SBITS_ASCII                FS_SYMBOL       // <- see comment above
#define SBITS_SURROGATE_A          0x20000000L
#define SBITS_SURROGATE_B          0x40000000L

// For symbol fonts we want to assume they can handle everything.
#define SBITS_ALLLANGS DWORD(-1)

// FontLinkTextOut uMode values
#define FLTO_BOTH           0
#define FLTO_TEXTEXTONLY    1
#define FLTO_TEXTOUTONLY    2

DWORD GetFontScriptBits(XHDC hdc, const TCHAR *szFaceName, LOGFONT *plf);
DWORD GetLangBits(WCHAR wc);

BOOL NeedsFontLinking(XHDC hdc, CCcs * pccs, LPCTSTR pch, int cch, CDoc *pDoc);
void DrawUnderlineStrikeOut(int x, int y, int iLength, XHDC hDC, HFONT hFont, const GDIRECT *prc);
void VanillaTextOut(CCcs *pccs, XHDC hdc, int x, int y, UINT fuOptions, const GDIRECT *prc, LPCTSTR pString, UINT cch, UINT uCodePage, int *piDx);
int FontLinkTextOut(XHDC hdc, int x, int y, UINT fuOptions, const GDIRECT *prc, LPCTSTR pString, UINT cch, CDocInfo *pdci, const CCharFormat *pCF, UINT uMode);

BOOL SelectScriptAppropriateFont( SCRIPT_ID sid, BYTE bCharSet, CDoc * pDoc, CMarkup * pMarkup, CCharFormat * pcf );
BOOL ScriptAppropriateFaceNameAtom( SCRIPT_ID sid, CDoc * pDoc, BOOL fFixed, const CCharFormat * const pcf, CMarkup * pMarkup, LONG * platmFontFace );

// Fontlinking support functions
BOOL      ShouldSwitchFontsForPUA(XHDC hdc, UINT uiFamilyCodePage, const CBaseCcs * pBaseCcs, const CCharFormat * pcf, SCRIPT_ID * psid);

#pragma INCMSG("--- End '_fontlnk.h'")
#else
#pragma INCMSG("*** Dup '_fontlnk.h'")
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\text\_line.h ===
/*
 *  _LINE.H
 *
 *  Purpose:
 *      CLine* classes
 *
 *  Authors:
 *      Original RichEdit code: David R. Fulmer
 *      Christian Fortini
 *      Murray Sargent
 *
 *  Copyright (c) 1995-1996 Microsoft Corporation. All rights reserved.
 */

#ifndef I__LINE_H_
#define I__LINE_H_
#pragma INCMSG("--- Beg '_line.h'")

#ifndef X__RUNPTR_H_
#define X__RUNPTR_H_
#include "_runptr.h"
#endif

#ifndef X_LOI_HXX_
#define X_LOI_HXX_
#include <loi.hxx>
#endif

class CLineFull;
class CDisplay;
class CLSMeasurer;
class CLayoutContext;

enum JUSTIFY
{
    JUSTIFY_LEAD,
    JUSTIFY_CENTER,
    JUSTIFY_TRAIL,
    JUSTIFY_FULL
};

// ============================  CLine*  =====================================
// line - keeps track of a line of text
// All metrics are in rendering device units

MtExtern(CLineCore)

class CLineCore : public CTxtRun
{
public:
    LONG    _iLOI;          // index into the other line information
    LONG    _xWidth;        // text line width - does not include line left and
                            // trailing whitespace
    LONG    _yHeight;       // line height (amount y coord is advanced for this line).
    LONG    _xRight;        // Right indent (for blockquotes).
    LONG    _xLineWidth;    // width of line from margin to margin (possibly > view width)

#if !defined(MW_MSCOMPATIBLE_STRUCT)

    // Line flags.
    union
    {
        DWORD _dwFlagsVar;   // To access them all at once.
        struct
        {
#endif
            //
            unsigned int _fCanBlastToScreen : 1;
            unsigned int _fHasBulletOrNum : 1;    // Set if the line has a bullet
            unsigned int _fFirstInPara : 1;
            unsigned int _fForceNewLine : 1;      // line forces a new line (adds vertical space)

            //
            unsigned int _fLeftAligned : 1;       // line is left aligned
            unsigned int _fRightAligned : 1;      // line is right aligned
            unsigned int _fClearBefore : 1;       // clear line created by a line after the cur line(clear on a p)
            unsigned int _fClearAfter : 1;        // clear line created by a line after the cur line(clear on a br)

            //
            unsigned int _fHasAligned : 1;        // line contains a embeded char's for
            unsigned int _fHasBreak : 1;          // Specifies that the line ends in a break character.
            unsigned int _fHasEOP : 1;            // set if ends in paragraph mark
            unsigned int _fHasEmbedOrWbr : 1;     // has embedding or wbr char

            //
            unsigned int _fHasBackground : 1;     // has bg color or bg image
            unsigned int _fHasNBSPs : 1;          // has nbsp (might need help rendering)
            unsigned int _fHasNestedRunOwner : 1; // has runs owned by a nested element (e.g., a CTable)
            unsigned int _fHidden:1;              // Is this line hidden?

            //
            unsigned int _fEatMargin : 1;         // Line should act as bottom margin.
            unsigned int _fPartOfRelChunk : 1;    // Part of a relative line chunk
            unsigned int _fFrameBeforeText : 1;   // this means this frame belongs to the
                                                  // next line of text.
            unsigned int _fDummyLine : 1;         // dummy line

            //
            unsigned int _fHasTransmittedLI : 1;  // Did this line transfer the bullet to a line after it?
            unsigned int _fAddsFrameMargin : 1;   // line adds frame margin space to adjoining lines
            unsigned int _fSingleSite : 1;        // Set if the line contains one of our
                                                  // sites that always lives on its own line,
                                                  // but still in the text stream.(like tables and HR's)
            unsigned int _fHasParaBorder : 1;     // TRUE if this line has a paragraph border around it.

            //
            unsigned int _fRelative : 1;          // relatively positioned line
            unsigned int _fFirstFragInLine : 1;   // first fragment or chunk of one screen line
            unsigned int _fRTLLn : 1;             // TRUE if the line has RTL direction orientation.
            unsigned int _fPageBreakBefore : 1;   // TRUE if this line has an element w/ page-break-before attribute

            //
            unsigned int _fPageBreakAfter   : 1;  // TRUE if this line has an element w/ page-break-after attribute
            unsigned int _fJustified        : 2;  // current line is justified.
                                                  // 00 - left/notset       -   01 - center justified
                                                  // 10 - right justified   -   11 - full justified

            unsigned int _fLookaheadForGlyphing : 1;  // We need to look beyond the current
                                                        // run to determine if glyphing is needed.

#if !defined(MW_MSCOMPATIBLE_STRUCT)
        };
    };

    DWORD& _dwFlags() { return _dwFlagsVar; }
#else

    DWORD& _dwFlags() { return *(DWORD*)(&_xRight + 1); }

#endif

public:
    DECLARE_MEMCLEAR_NEW_DELETE(Mt(CLineCore))

    CLineOtherInfo *oi() const { Assert(_iLOI != -1); return (CLineOtherInfo *)GetLineOtherInfoEx(_iLOI); }
    CLineOtherInfo *oi(CLineInfoCache *pLineInfoCache) const
            { Assert(_iLOI != -1); return (CLineOtherInfo *)GetLineOtherInfoEx(_iLOI, pLineInfoCache); }
    void operator =(const CLineFull& lif);

    inline LONG CchFromXpos(CLSMeasurer& me, LONG x, LONG y, LONG *pdx,
                     BOOL fExactfit=FALSE, LONG *pyHeightRubyBase = NULL,
                     BOOL *pfGlyphHit = NULL, LONG *pyProposed = NULL) const;
    
    BOOL IsLeftAligned() const  { return _fLeftAligned; }
    BOOL IsRightAligned() const { return _fRightAligned; }
    BOOL HasMargins(CLineOtherInfo *ploi) const     { return ploi->HasMargins(); }
    BOOL HasAligned() const     { return _fHasAligned; }
    BOOL IsFrame() const        { return _fRightAligned || _fLeftAligned; }
    BOOL IsClear() const        { return _fClearBefore  || _fClearAfter; }
    BOOL IsBlankLine() const    { return IsClear() || IsFrame(); }
    BOOL IsTextLine() const     { return !IsBlankLine(); }
    BOOL IsNextLineFirstInPara(){ return (_fHasEOP || (!_fForceNewLine && _fFirstInPara)); }
    BOOL IsRTLLine() const      { return _fRTLLn; }

    void ClearAlignment() { _fRightAligned = _fLeftAligned = FALSE; }
    void SetLeftAligned() { _fLeftAligned = TRUE; }
    void SetRightAligned() { _fRightAligned = TRUE; }

    LONG GetTextRight(CLineOtherInfo *ploi, BOOL fLastLine=FALSE) const { return (long(_fJustified) == JUSTIFY_FULL && !_fHasEOP && !_fHasBreak && !fLastLine
                                        ? ploi->_xLeftMargin + _xLineWidth - _xRight
                                        : ploi->_xLeftMargin + ploi->_xLeft + _xWidth + ploi->_xLineOverhang); }
    LONG GetRTLTextRight(CLineOtherInfo *ploi) const { return ploi->_xRightMargin + _xRight; }
    LONG GetRTLTextLeft(CLineOtherInfo *ploi) const { return (long(_fJustified) == JUSTIFY_FULL && !_fHasEOP && !_fHasBreak
                                        ? ploi->_xRightMargin + _xLineWidth - ploi->_xLeft
                                        : ploi->_xRightMargin + _xRight + _xWidth + ploi->_xLineOverhang); }

    void AdjustChunkForRtlAndEnsurePositiveWidth(CLineOtherInfo const *ploi, 
                                                 LONG xStartChunk, LONG xEndChunk, 
                                                 LONG *pxLeft, LONG *pxRight);

    // Amount to advance the y coordinate for this line.
    LONG GetYHeight() const
    {
        return _yHeight;
    }

    // Offset to add to top of line for hit testing.
    // This takes into account line heights smaller than natural.
    LONG GetYHeightTopOff(CLineOtherInfo *ploi) const
    {
        return ploi->_yHeightTopOff;
    }

    // Offset to add to bottom of line for hit testing.
    LONG GetYHeightBottomOff(CLineOtherInfo *ploi) const
    {
        return (ploi->_yExtent - (_yHeight - ploi->_yBeforeSpace)) + GetYHeightTopOff(ploi);
    }

    // Total to add to the top of the line space to get the actual
    // top of the display part of the line.
    LONG GetYTop(CLineOtherInfo *ploi) const
    {
        return GetYHeightTopOff(ploi) + ploi->_yBeforeSpace;
    }

    LONG GetYBottom(CLineOtherInfo *ploi) const
    {
        return GetYHeight() + GetYHeightBottomOff(ploi);
    }

    LONG GetYMostTop(CLineOtherInfo *ploi) const
    {
        return min(GetYTop(ploi), GetYHeight());
    }

    LONG GetYLineTop(CLineOtherInfo *ploi) const
    {
        return min(0L, GetYMostTop(ploi));
    }

    LONG GetYLineBottom(CLineOtherInfo *ploi) const
    {
        return max(GetYBottom(ploi), GetYHeight());
    }
    
    void RcFromLine(CLineOtherInfo *ploi, RECT & rcLine, LONG yTop)
    {
        rcLine.top      = yTop + GetYTop(ploi);
        rcLine.bottom   = yTop + GetYBottom(ploi);
        rcLine.left     = ploi->_xLeftMargin;
        rcLine.right    = ploi->_xLeftMargin + _xLineWidth;
    }

    void AddRefOtherInfo()
    {
        Assert(_iLOI != -1);
        AddRefLineOtherInfoEx(_iLOI);
    }
    void ReleaseOtherInfo()
    {
        Assert(_iLOI != -1);
        ReleaseLineOtherInfoEx(_iLOI);
        _iLOI = -1;
    }
    void CacheOtherInfo(const CLineOtherInfo& loi)
    {
        _iLOI = CacheLineOtherInfoEx(loi);
        Assert(_iLOI >= 0);
    }
    inline void AssignLine(CLineFull& lif);

    // Methods to access values for aligned object lines   
    CElement *AO_Element(CLineOtherInfo *ploi);
    // TODO (KTam, IE6 bug 52): Fix other AO_* callers of AO_GetUpdatedLayout, remove default context param.
    CLayout *AO_GetUpdatedLayout(CLineOtherInfo *ploi, CLayoutContext *pLayoutContext = NULL);
    LONG AO_GetFirstCp(CLineOtherInfo *ploi, LONG cpLine);
    LONG AO_GetLastCp(CLineOtherInfo *ploi, LONG cpLine);
    void AO_GetSize(CLineOtherInfo *ploi, CSize *pSize);
    const CFancyFormat * AO_GetFancyFormat(CLineOtherInfo *ploi);
    LONG AO_GetXProposed(CLineOtherInfo *ploi);
    LONG AO_GetYProposed(CLineOtherInfo *ploi);
};

class CLineFull : public CLineCore, public CLineOtherInfo
{
public:
    CLineFull()
    {
        Init();
    }
    
    void Init()
    {
        ZeroMemory(this, sizeof(CLineFull));
        _iLOI = -1;
    }
    
    CLineFull(const CLineCore& li)
    {
        memcpy((CLineCore*)this, &li, sizeof(CLineCore));
        if(_iLOI >= 0)
        {
            *((CLineOtherInfo*)this) = *li.oi();
        }
        else
        {
            ZeroMemory((CLineOtherInfo*)this, sizeof(CLineOtherInfo));
        }
    }

    CLineFull(const CLineFull& lif)
    {
        memcpy(this, &lif, sizeof(CLineFull));
    }

    BOOL operator ==(const CLineFull& li) const
    {
#ifdef _WIN64
	BOOL fRet = (!memcmp((CLineCore*)this, (CLineCore*)(&li), sizeof(CLineCore)))
			&& (!memcmp((CLineOtherInfo*)this, (CLineOtherInfo*)(&li), sizeof(CLineOtherInfo)));
#else
        BOOL fRet = !memcmp(this, &li, sizeof(CLineFull));
#endif
        return fRet;
    }

#if DBG==1
    BOOL operator ==(const CLineCore& li)
    {
        CLineFull lif = li;
        return (*this == lif);
    }

    BOOL operator ==(const CLineOtherInfo& li)
    {
        BOOL fRet = memcmp((CLineOtherInfo*)this, &li, sizeof(CLineOtherInfo));
        return !fRet;
    }
#endif

    LONG CchFromXpos(CLSMeasurer& me, LONG x, LONG y, LONG *pdx,
                     BOOL fExactfit=FALSE, LONG *pyHeightRubyBase = NULL,
                     BOOL *pfGlyphHit = NULL, LONG *pyProposed = NULL) const;
    LONG GetTextRight(BOOL fLastLine=FALSE) const
            { return CLineCore::GetTextRight((CLineOtherInfo*)this, fLastLine);}
    LONG GetRTLTextRight() const
            { return CLineCore::GetRTLTextRight((CLineOtherInfo*)this);}
    LONG GetRTLTextLeft() const
            { return CLineCore::GetRTLTextLeft((CLineOtherInfo*)this);}
    LONG GetYHeightTopOff() const
            { return CLineCore::GetYHeightTopOff((CLineOtherInfo*)this);}
    LONG GetYHeightBottomOff() const
            { return CLineCore::GetYHeightBottomOff((CLineOtherInfo*)this);}
    LONG GetYTop() const
            { return CLineCore::GetYTop((CLineOtherInfo*)this);}
    LONG GetYBottom() const
            { return CLineCore::GetYBottom((CLineOtherInfo*)this);}
    LONG GetYMostTop() const
            { return CLineCore::GetYMostTop((CLineOtherInfo*)this);}
    LONG GetYLineTop() const
            { return CLineCore::GetYLineTop((CLineOtherInfo*)this);}
    LONG GetYLineBottom() const
            { return CLineCore::GetYLineBottom((CLineOtherInfo*)this);}
    void RcFromLine(RECT & rcLine, LONG yTop)
            { CLineCore::RcFromLine((CLineOtherInfo*)this, rcLine, yTop);}

    // helpers
    static LONG CalcLineWidth(CLineCore const * pli, CLineOtherInfo const * ploi)
            {
                return         ploi->_xLeft
                             + pli->_xWidth 
                             + ploi->_xLineOverhang 
                             + pli->_xRight
                             - ploi->_xNegativeShiftRTL; 
            }
    LONG CalcLineWidth() const
            { return CalcLineWidth(this, this); }
};

// ==========================  CLineArray  ===================================
// Array of lines

MtExtern(CLineArray)
MtExtern(CLineArray_pv)

class CLineArray : public CArray<CLineCore>
{
public:
    typedef CArray<CLineCore> super;
    
    DECLARE_MEMALLOC_NEW_DELETE(Mt(CLineArray))
    CLineArray() : CArray<CLineCore>(Mt(CLineArray_pv)) {};

#if DBG==1
    virtual void Remove(DWORD ielFirst, LONG celFree, ArrayFlag flag);
    virtual void Clear (ArrayFlag flag);
    virtual BOOL Replace(DWORD iel, LONG cel, CArrayBase *par);
#endif
    
    void Forget(DWORD iel, LONG cel);
    void Forget() { Forget(0, Count()); }
};

// ==========================  CLinePtr  ===================================
// Maintains position in a array of lines

MtExtern(CLinePtr)

class CLinePtr : public CRunPtr<CLineCore>
{
protected:
    CDisplay   *_pdp;

public:
    DECLARE_MEMALLOC_NEW_DELETE(Mt(CLinePtr))
    CLinePtr (CDisplay *pdp) {Hijack(pdp);}
    CLinePtr (CLinePtr& rp) : CRunPtr<CLineCore> (rp)   {}

    void Init ( CLineArray & );

    CDisplay *GetPdp() { return _pdp;}

    // The new display hijack's this line ptr
    void    Hijack(CDisplay *pdp);

    // Alternate initializer
    void    RpSet(LONG iRun, LONG ich)  { CRunPtr<CLineCore>::SetRun(iRun, ich); }

    // Direct cast to a run index
    operator LONG() const { return GetIRun(); }

    // Get the run index (line number)
    LONG GetLineIndex () { return GetIRun(); }
    LONG GetAdjustedLineLength();

    CLineOtherInfo *oi();
    
    CLineCore * operator -> ( ) const
    {
        return CurLine();
    }

    CLineCore * CurLine() const
    {
        return (CLineCore *)_prgRun->Elem( GetIRun() );
    }

    CLineCore & operator * ( ) const
    {
        return *((CLineCore *)_prgRun->Elem( GetIRun() ));
    }

    CLineCore & operator [ ] ( long dRun );

    BOOL    NextLine(BOOL fSkipFrame, BOOL fSkipEmptyLines); // skip frames
    BOOL    PrevLine(BOOL fSkipFrame, BOOL fSkipEmptyLines); // skip frames

    // Character position control
    LONG    RpGetIch ( ) const { return GetIch(); }
    BOOL    RpAdvanceCp(LONG cch, BOOL fSkipFrame = TRUE);
    BOOL    RpSetCp(LONG cp, BOOL fAtEnd, BOOL fSkipFrame = TRUE, BOOL fSupportBrokenLayout = FALSE);
    LONG    RpBeginLine(void);
    LONG    RpEndLine(void);

    void RemoveRel (LONG cRun, ArrayFlag flag)
    {
        CRunPtr<CLineCore>::RemoveRel(cRun, flag);
    }

    BOOL Replace(LONG cRun, CLineArray *parLine);

    // Assignment from a run index
    CRunPtrBase& operator =(LONG iRun) {SetRun(iRun, 0); return *this;}

    LONG    FindParagraph(BOOL fForward);

    // returns TRUE if the ptr is *after* the *last* character in the line
    BOOL IsAfterEOL() { return GetIch() == CurLine()->_cch; }

    BOOL IsLastTextLine();

private:
    CLineOtherInfo *_pLOI;
    LONG _iLOI;
};

inline LONG
CLineCore::CchFromXpos(CLSMeasurer& me, LONG x, LONG y, LONG *pdx,
                       BOOL fExactfit, LONG *pyHeightRubyBase,
                       BOOL *pfGlyphHit, LONG *pyProposed) const
{
    CLineFull lif = *this;
    return lif.CchFromXpos(me, x, y, pdx, fExactfit, pyHeightRubyBase, pfGlyphHit, pyProposed);
}

inline BOOL CLineOtherInfo::operator ==(const CLineFull& li)
{
    return Compare((CLineOtherInfo *)&li);
}

inline void CLineOtherInfo::operator =(const CLineFull& li)
{
    memcpy(this, (CLineOtherInfo*)&li, sizeof(CLineOtherInfo));
}

inline void CLineCore::operator =(const CLineFull& lif)
{
    memcpy(this, (CLineCore*)&lif, sizeof(CLineCore));
    //this is a good assert, it prevents break of refcounting
    //for cached CLineOtherInfo. Use CLineCore::AssignLine for
    //deep copy if CLineOtherInfo is there.
    AssertSz(_iLOI == -1, "It should never happen, use AssignLine if there is CLineOtherInfo");
}

inline void CLineCore::AssignLine(CLineFull& lif)
{
    Assert(this);
        // The cast below to CLineOtherInfo is not strictly necessary
        // Its there just to make the line of code more clearer.
    lif.CacheOtherInfo((CLineOtherInfo)lif);
    memcpy(this, (CLineCore*)&lif, sizeof(CLineCore));
}

#pragma INCMSG("--- End '_line.h'")
#else
#pragma INCMSG("*** Dup '_line.h'")
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\text\_ime.h ===
/*
 *  @doc    INTERNAL
 *
 *  @module _ime.h -- support for IME APIs |
 *
 *  Purpose:
 *      Most everything to do with FE composition string editing passes
 *      through here.
 *
 *  Authors: <nl>
 *      Jon Matousek  <nl>
 *      Justin Voskuhl  <nl>
 *      Hon Wah Chan  <nl>
 *
 *  History: <nl>
 *      10/18/1995      jonmat  Cleaned up level 2 code and converted it into
 *                              a class hierarchy supporting level 3.
 *
 *  Copyright (c) 1995-1996 Microsoft Corporation. All rights reserved.
 *
 */

#ifndef I__IME_H_
#define I__IME_H_
#pragma INCMSG("--- Beg '_ime.h'")

#ifndef NO_IME
class CFlowLayout;

// defines for some FE Codepages
#define _JAPAN_CP           932
#define _KOREAN_CP          949
#define _CHINESE_TRAD_CP    950
#define _CHINESE_SIM_CP     936

// special virtual keys copied from Japan MSVC ime.h
#define VK_KANA         0x15
#define VK_KANJI        0x19

// defines for IME Level 2 and 3
#define IME_LEVEL_2     2
#define IME_LEVEL_3     3
#define IME_PROTECTED   4


extern BOOL forceLevel2;    // Force level 2 composition processing if TRUE.

MtExtern(CIme)

/*
 *  IME
 *
 *  @class  base class for IME support.
 *
 *  @devnote
 *      For level 2, at caret IMEs, the IME will draw a window directly over the text giving the
 *      impression that the text is being processed by the application--this is called pseudo inline.
 *      All UI is handled by the IME. This mode is currenlty bypassed in favor of level 3 true inline (TI);
 *      however, it would be trivial to allow a user preference to select this mode. Some IMEs may have
 *      a "special" UI, in which case level 3 TI is *NOT* used, necessitating level 2.
 *
 *      For level 2, near caret IMEs, the IME will draw a very small and obvious window near the current
 *      caret position in the document. This currently occurs for PRC(?) and Taiwan.
 *      All UI is handled by the IME.
 *
 *      For level 3, at caret IMEs, the composition string is drawn by the application, which is called
 *      true inline, bypassing the level 2 "composition window".
 *      Currently, we allow the IME to support all remaining UI *except* drawing of the composition string.
 */
class CIme
{
    friend LRESULT OnGetIMECompositionMode ( CFlowLayout &ts );
    friend BOOL IMECheckGetInvertRange(CFlowLayout *ts, LONG *, LONG *);
    friend HRESULT CompositionStringGlue ( const LPARAM lparam, CFlowLayout &ts );
    friend HRESULT EndCompositionGlue ( CFlowLayout &ts );
    friend void CheckDestroyIME ( CFlowLayout &ts );


    //@access   Protected data
    protected:
    INT       _imeLevel;                            //@cmember IME Level 2 or 3
    BOOL      _fKorean;                             //@cmember In Hangeul mode?

    LONG      _iFormatSave;                         //@cmember  format before we started IME composition mode.

    BOOL      _fHoldNotify;                         //@cmember hold notify until we have result string

    INT       _dxCaret;                             //@cmember current IME caret width
    BOOL      _fIgnoreIMEChar;                      //@cmember Level 2 IME use to eat WM_IME_CHAR message

    public:
#ifdef MERGEFUN
    CTxtRange *_prgUncommitted;                     //Current uncommitted range, for the CRenderer
    CTxtRange *_prgInverted;                        //Current inverted range, for the CRenderer
#endif

    //@access   Public methods
    public:
    BOOL    _fDestroy;                              //@cmember set when object wishes to be deleted.
    INT     _compMessageRefCount;                   //@cmember so as not to delete if recursed.
    BOOL    _fUnderLineMode;                        //@cmember save original Underline mode

    DECLARE_MEMCLEAR_NEW_DELETE(Mt(CIme))

                                                    //@cmember  Handle WM_IME_STARTCOMPOSITION
    virtual HRESULT StartComposition ( CFlowLayout &ts ) = 0;
                                                    //@cmember  Handle WM_IME_COMPOSITION and WM_IME_ENDCOMPOSITION
    virtual HRESULT CompositionString ( const LPARAM lparam, CFlowLayout &ts ) = 0;
                                                    //@cmember  Handle post WM_IME_CHAR to update comp window.
    virtual void PostIMEChar( CFlowLayout &ts ) = 0;

                                                    //@cmember  Handle WM_IME_NOTIFY
    virtual HRESULT IMENotify (const WPARAM wparam, const LPARAM lparam, CFlowLayout &ts ) = 0;

    enum TerminateMode
    {
            TERMINATE_NORMAL = 1,
            TERMINATE_FORCECANCEL = 2
    };

    void    TerminateIMEComposition(CFlowLayout &ts,
                CIme::TerminateMode mode);          //@cmember  Terminate current IME composition session.

    BOOL    IsKoreanMode() { return _fKorean; }     //@cmember  check for Korean mode

    BOOL    HoldNotify() { return _fHoldNotify; }   //@cmember  check if we want to hold sending change notification
                                                    //@cmember  check if we need to ignore WM_IME_CHAR messages
    BOOL    IgnoreIMECharMsg() { return _fIgnoreIMEChar; }

    INT     GetIMECaretWidth() { return _dxCaret; } //@cmember  return current caret width
    void    SetIMECaretWidth(INT dxCaretWidth)
    {
        _dxCaret = dxCaretWidth;                    //@cmember  setup current caret width
    }
    static  void    CheckKeyboardFontMatching ( UINT cp, CFlowLayout &ts, LONG *iFormat ); //@cmember  Check current font/keyboard matching.

    INT     GetIMELevel ()                          //@cmember  Return the current IME level.
    {
        return _imeLevel;
    }

    BOOL    IsProtected()
    {
        return _imeLevel == IME_PROTECTED;
    }

    //@access   Protected methods
    protected:                                      //@cmember  Get composition string, convert to unicode.

    static INT GetCompositionStringInfo( HIMC hIMC, DWORD dwIndex, WCHAR *uniCompStr, INT cchUniCompStr, BYTE *attrib, INT cbAttrib, LONG *cursorCP, LONG *cchAttrib );
    HRESULT CheckInsertResultString ( const LPARAM lparam, CFlowLayout &ts );


    void    SetCompositionFont ( CFlowLayout &ts, BOOL *pbUnderLineMode ); //@cmember  Setup for level 2 and 3 composition and candidate window's font.
    void    SetCompositionForm ( CFlowLayout &ts );    //@cmember  Setup for level 2 IME composition window's position.

public:
    CIme( CFlowLayout &ts );
    CIme(); // for CIme_Protected;
    ~CIme();
};

/*
 *  IME_Lev2
 *
 *  @class  Level 2 IME support.
 *
 */
class CIme_Lev2 : public CIme
{

    //@access   Public methods
    public:                                         //@cmember  Handle level 2 WM_IME_STARTCOMPOSITION
    virtual HRESULT StartComposition ( CFlowLayout &ts );
                                                    //@cmember  Handle level 2 WM_IME_COMPOSITION
    virtual HRESULT CompositionString ( const LPARAM lparam, CFlowLayout &ts );
                                                    //@cmember  Handle post WM_IME_CHAR to update comp window.
    virtual void PostIMEChar( CFlowLayout &ts );
                                                    //@cmember  Handle level 2 WM_IME_NOTIFY
    virtual HRESULT IMENotify (const WPARAM wparam, const LPARAM lparam, CFlowLayout &ts );

    CIme_Lev2( CFlowLayout &ts );
    ~CIme_Lev2();
};

/*
 *  IME_PROTECTED
 *
 *  @class  IME_PROTECTED
 *
 */
class CIme_Protected : public CIme
{
    //@access   Public methods
    public:                                         //@cmember  Handle level 2 WM_IME_STARTCOMPOSITION
    virtual HRESULT StartComposition ( CFlowLayout &ts )
        {_imeLevel  = IME_PROTECTED; return S_OK;}
                                                    //@cmember  Handle level 2 WM_IME_COMPOSITION
    virtual HRESULT CompositionString ( const LPARAM lparam, CFlowLayout &ts );
                                                    //@cmember  Handle post WM_IME_CHAR to update comp window.
    virtual void PostIMEChar( CFlowLayout &ts )
        {}
                                                    //@cmember  Handle level 2 WM_IME_NOTIFY
    virtual HRESULT IMENotify (const WPARAM wparam, const LPARAM lparam, CFlowLayout &ts )
        {return S_FALSE;}
};

/*
 *  IME_Lev3
 *
 *  @class  Level 3 IME support.
 *
 */
class CIme_Lev3 : public CIme_Lev2
{
    //@access   Private data
    private:

    //@access   Protected data
    protected:

    //@access   Public methods
    public:                                         //@cmember  Handle level 3 WM_IME_STARTCOMPOSITION
    virtual HRESULT StartComposition ( CFlowLayout &ts );
                                                    //@cmember  Handle level 3 WM_IME_COMPOSITION
    virtual HRESULT CompositionString ( const LPARAM lparam, CFlowLayout &ts );
                                                    //@cmember  Handle level 3 WM_IME_NOTIFY
    virtual HRESULT IMENotify (const WPARAM wparam, const LPARAM lparam, CFlowLayout &ts );

    BOOL            SetCompositionStyle (   CFlowLayout &ts, CCharFormat &CF, UINT attribute );

    CIme_Lev3( CFlowLayout &ts ) : CIme_Lev2 ( ts ) {};

};

/*
 *  Special IME_Lev3 for Korean Hangeul -> Hanja conversion
 *
 *  @class  Hangual IME support.
 *
 */
class CIme_HangeulToHanja : public CIme_Lev3
{
    //@access   Private data
    private:
    LONG    _xWidth;                                //@cmember width of Korean Hangeul char

    public:
    CIme_HangeulToHanja( CFlowLayout &ts, LONG xWdith );
                                                    //@cmember  Handle Hangeul WM_IME_STARTCOMPOSITION
    virtual HRESULT StartComposition ( CFlowLayout &ts );
                                                    //@cmember  Handle Hangeul WM_IME_COMPOSITION
    virtual HRESULT CompositionString ( const LPARAM lparam, CFlowLayout &ts );
};

// CImeDummy class, exists solely to handle the case where we get a compsition string
// and we have no CIme-derived class instantiated.

class CImeDummy : public CIme
{
public:
    virtual HRESULT StartComposition( CFlowLayout &ts ) { RRETURN(E_FAIL); }
    virtual HRESULT CompositionString( const LPARAM lparam,
                                       CFlowLayout &ts ) { RRETURN(E_FAIL); }
    virtual void    PostIMEChar( CFlowLayout &ts ) {};
    virtual HRESULT IMENotify (const WPARAM wparam,
                               const LPARAM lparam,
                               CFlowLayout &ts ) { RRETURN(E_FAIL); }

    CImeDummy( CFlowLayout &ts ) : CIme( ts ) {};
};

// Glue functions to call the respective methods of an IME object stored in the ts.
HRESULT StartCompositionGlue ( CFlowLayout &ts, BOOL IsProtected );
HRESULT CompositionStringGlue ( const LPARAM lparam, CFlowLayout &ts );
HRESULT EndCompositionGlue ( CFlowLayout &ts );
void    PostIMECharGlue ( CFlowLayout &ts );
HRESULT IMENotifyGlue ( const WPARAM wparam, const LPARAM lparam, CFlowLayout &ts ); // @parm the containing text edit.

// IME helper functions.
void    IMECompositionFull ( CFlowLayout &ts );
LRESULT OnGetIMECompositionMode ( CFlowLayout &ts );
BOOL    IMECheckGetInvertRange(CFlowLayout *ts, LONG *, LONG *, LONG *, LONG *);
void    CheckDestroyIME ( CFlowLayout &ts );
BOOL    IMEHangeulToHanja ( CFlowLayout &ts );

/*
 *  IgnoreIMEInput()
 *
 *  @devnote
 *      This is to ignore the IME character.  By translating
 *      message with result from pImmGetVirtualKey, we
 *      will not receive START_COMPOSITION message.  However,
 *      if the host has already called TranslateMessage, then,
 *      we will let START_COMPOSITION message to come in and
 *      let IME_PROTECTED class to do the work.
 */
HRESULT IgnoreIMEInput( HWND hwnd, CFlowLayout &ts, DWORD lParam );
#endif // !NO_IME

#pragma INCMSG("--- End '_ime.h'")
#else
#pragma INCMSG("*** Dup '_ime.h'")
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\text\_text.h ===
/*
 *  @doc    INTERNAL
 *
 *  @module _TEXT.H -- Declaration for a CTxtRun pointer |
 *
 *  CTxtRun pointers point at the plain text runs (CTxtArray) of the
 *  backing store and derive from CRunPtrBase via the CRunPtr template.
 *
 *  Copyright (c) 1995-1996, Microsoft Corporation. All rights reserved.
 */

#ifndef I__TEXT_H_
#define I__TEXT_H_
#pragma INCMSG("--- Beg '_text.h'")

#ifndef X__RUNPTR_H_
#define X__RUNPTR_H_
#include "_runptr.h"
#endif

#ifndef X_USP_HXX_
#define X_USP_HXX_
#include "usp.hxx"
#endif

MtExtern(CTxtPtr)

/*
 *  CTxtPtr
 *
 *  @class
 *      provides access to the array of characters in the backing store
 *      (i.e. <c CTxtArray>)
 *
 *  @base   public | CRunPtr<lt>CTxtArray<gt>
 *
 *  @devnote
 *      The state transitions for this object are the same as those for
 *      <c CRunPtrBase>.  <md CTxtPtr::_cp> simply caches the current
 *      cp (even though it can be derived from _iRun and _ich).  _cp is
 *      used frequently enough (and computing may be expensive) that
 *      caching the value is worthwhile.
 *
 *      CTxtPtr's *may* be put on the stack, but do so with extreme
 *      caution.  These objects do *not* float; if a change is made to
 *      the backing store while a CTxtPtr is active, it will be out
 *      of sync and may lead to a crash.  If such a situation may
 *      exist, use a <c CTxtRange> instead (as these float and keep
 *      their internal text && format run pointers up-to-date).
 *
 *      Otherwise, a CTxtPtr is a useful, very lightweight plain
 *      text scanner.
 */
class CTxtPtr : public CRunPtr<CTxtBlk>
{
public:
    DECLARE_MEMALLOC_NEW_DELETE(Mt(CTxtPtr))

    inline CTxtPtr(CMarkup * pMarkup);
    CTxtPtr(CMarkup * pMarkup, DWORD cp);   //@cmember  Constructor
    CTxtPtr(const CTxtPtr &tp);         //@cmember  Copy Constructor
    CTxtPtr() { }

    void    Reinit(CMarkup * pMarkup, DWORD cp);
    long    GetRawText( long cch, TCHAR *pch ); //@cmember  Fetch <p cch> characters
    long    GetPlainText(  long cch, TCHAR *pch ); // Fetch pch chars cnvrt crlf
    long    GetPlainTextLength ( long cch );
    TCHAR   NextChar();             //@cmember Advance to & return next char
    TCHAR   PrevChar();             //@cmember Backup to & return previous char
    TCHAR   GetChar();              //@cmember Fetch char at current cp
    TCHAR   GetPrevChar();          //@cmember Fetch char at previous cp
    long    GetTextLength() const   //@cmember Get total cch for this document
    {
        return ((CTxtArray *)_prgRun)->_cchText;
    }
    const TCHAR* GetPch(long & cchValid);//@cmember Get ptr to block of chars

                            //@cmember  Get ptr to a reverse block of chars
    const TCHAR* GetPchReverse(long & cchValidReverse, long * cchvalid = NULL);

    // The text array has its own versions of these methods (overuling
    // those in runptr base so that <md CTxtPtr::_cp> can be correctly
    // maintained.

    DWORD   BindToCp(DWORD cp); //@cmember  Rebinds text pointer to cp
    DWORD   SetCp(DWORD cp);    //@cmember  Sets the cp for the run ptr
    DWORD   GetCp() const       //@cmember  Gets the current cp
    {
        // NB!  we do not do invariant checking here so the floating
        // range mechanism can work OK
        return _cp;
    };
    LONG    AdvanceCp(LONG cch);    //@cmember  Advance cp by cch chars

    // Advance/backup/adjust safe over CRLF and UTF-16 word pairs
    LONG    AdjustCpCRLF();     //@cmember  Backup to start of DWORD char
    BOOL    IsAtEOP();          //@cmember  Is current cp at an EOP marker?
    BOOL    IsAtBOWord();       //@cmember  At beginning of word?
    BOOL    IsAtEOWord();       //@cmember  At end of word?
    BOOL    IsAtWordBreak();    //@cmember  Is at a word break?


    // Search

    LONG FindComplexHelper (
        LONG cpMost, DWORD dwFlags, TCHAR const *, long cchToFind );

    LONG FindText (
        LONG cpMost, DWORD dwFlags, TCHAR const *, long cchToFind );

    // Word break & MoveUnit support
    long    MoveChar(BOOL fForward);
    long    MoveCluster(BOOL fForward);
    long    MoveClusterEnd(BOOL fForward);
    LONG    FindWordBreak(INT action, BOOL fAutoURL=FALSE);//@cmember  Find next word break
    LONG    FindBOSentence(BOOL fForward);   //@cmember  Find beginning of sentence
    long    FindBlockBreak(BOOL fForward);

    HRESULT AutoUrl_ScanForPrefix( int iDir, BOOL *pfFound, long *pcpStart, TCHAR *pchQuoted = NULL );
    HRESULT AutoUrl_EmailWildcard( BOOL *pfFound );
    HRESULT AutoUrl_FindAndVerifyBoundaries( BOOL *pfValid, long cpStart, long *pcpEnd );
    BOOL    IsInsideUrl( long *pcpStart, long *pcpEnd );
    BOOL    FindUrl( BOOL fForward, BOOL fBegin, long cpBoundary );
    BOOL    IsPasswordChar();

    // Bookmark support
    HRESULT MoveToBookmark( BSTR bstrBookmark, CTxtPtr *pTxtPtrEnd );
    HRESULT GetBookmark( BSTR *pbstrBookmark, CTxtPtr *pTxtPtrEnd );
    
                            //@cmember  Insert ch into the text stream cch times
    long    InsertRepeatingChar( LONG cch, TCHAR ch );

                                    //@cmember  Insert a range of text helper
                                    // for ReplaceRange
    long    InsertRange(DWORD cch, TCHAR const *pch);
    void    DeleteRange(DWORD cch); //@cmember  Delete range of text helper
                                    // for ReplaceRange
    DWORD       _cp;        //@cmember  character position in text stream

    CMarkup *   _pMarkup;       //@cmember  pointer to the overall text edit class;
                            //needed for things like the word break proc and
                            // used a lot by derived classes

    // We will protect any specific Thai related functions from the outside world
    // Keep the entry point to these through MoveCluster and FindWordBreak
private:
    LONG    FindThaiTypeWordBreak(INT action);
    BOOL    PrepThaiTextForBreak(BOOL fWordBreak,
                                 BOOL fForward,
                                 BOOL fCurrentIsNode,
                                 long cchText,
                                 CDataAry<TCHAR> *paryNodePos,
                                 TCHAR *paryItemize,
                                 long *pcchBefore,
                                 long *pcchAfter,
                                 long *pcchMove,
                                 long *plHoldNode=NULL);
    long    ItemizeAndBreakRun(TCHAR* aryItemize, long* pcchBefore, long* pcchAfter, SCRIPT_LOGATTR* arySLA);
};


// =======================   Misc. routines  ====================================================

void     TxCopyText(TCHAR const *pchSrc, TCHAR *pchDst, LONG cch);
LONG     TxFindEOP(const TCHAR *pchBuff, LONG cch);
INT      CALLBACK TxWordBreakProc(TCHAR const *pch, INT ich, INT cb, INT action);

inline
CTxtPtr::CTxtPtr ( CMarkup * pMarkup )
  : CRunPtr < CTxtBlk > ( (CRunArray *) & pMarkup->_TxtArray )
{
    _pMarkup = pMarkup;
    _cp = 0;
}

#pragma INCMSG("--- End '_text.h'")
#else
#pragma INCMSG("*** Dup '_text.h'")
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\text\_runptr.h ===
/*
 *  @doc INTERNAL
 *
 *  @module _RUNPTR.H -- Text run and run pointer class defintion |
 *  
 *  Original Author:    <nl>
 *      Christian Fortini
 *
 *  History: <nl>
 *      6/25/95 alexgo  Commenting and Cleanup
 */

#ifndef I__RUNPTR_H_
#define I__RUNPTR_H_
#pragma INCMSG("--- Beg '_runptr.h'")

#ifndef X_ARRAY_HXX_
#define X_ARRAY_HXX_
#include "array.hxx"
#endif

#ifndef X__DOC_H_
#define X__DOC_H_
#include "_doc.h"
#endif

MtExtern(CRunArray)
MtExtern(CRunArray_pv)

class CRunArray : public CArray<CTxtRun>
{
public:
    DECLARE_MEMALLOC_NEW_DELETE(Mt(CRunArray))
    CRunArray() : CArray<CTxtRun>(Mt(CRunArray_pv)) {};
};

/*
 *  CRunPtrBase
 *
 *  @class  Base run pointer functionality.  Keeps a position within an array
 *      of text runs.
 *
 *  @devnote    Run pointers go through three different possible states :
 *
 *  NULL:   there is no data and no array (frequently a startup condition) <nl>
 *          <mf CRunPtrBsae::SetRunArray> will transition from this state to 
 *          to the Empty state.  It is typically the derived class'
 *          to define when that method should be called.
 *
 *          <md CRunPtrBase::_prgRun> == NULL <nl>
 *          <md CRunPtrBase::_iRun> == 0 <nl>
 *          <md CRunPtrBase::_ich> == 0 <nl>
 *
 *  Empty:  an array class exists, but there is no data (can happen if all 
 *          of the elements in the array are deleted). <nl>
 *          <md CRunPtrBase::_prgRun> != NULL <nl>
 *          <md CRunPtrBase::_iRun> == 0 <nl>
 *          <md CRunPtrBase::_ich> <gt>= 0 <nl>
 *          <md CRunPtrBase::_prgRun>-<gt>Elem[0] == NULL <nl>
 *
 *  Normal: the array class exists and has data <nl>
 *          <md CRunPtrBase::_prgRun> != NULL <nl>
 *          <md CRunPtrBase::_iRun> >= 0 <nl>
 *          <md CRunPtrBase::_ich> >= 0 <nl>
 *          <md CRunPtrBase::_prgRun>-<gt>Elem[<md CRunPtrBase::_iRun>] 
 *                  != NULL <nl>        
 *  
 *  Note that in order to support the empty and normal states, the actual 
 *  array element at <md CRunPtrBase::_iRun> must be explicitly fetched in
 *  any method that may need it.
 *
 *  Currently, there is no way to transition to the NULL state from any of
 *  the other states.  If we needed to, we could support that by explicitly 
 *  fetching the array from the document on demand.
 *
 *  Note that only <md CRunPtrBase::_iRun> is kept.  We could also keep 
 *  a pointer to the actual run (i.e. _pRun).  Earlier versions of this
 *  engine did in fact do this.  I've opted to not do this for several
 *  reasons: <nl>
 *      1. _pRun is *always* available by calling Elem(_iRun).
 *      Therefore, there is nominally no need to keep both _iRun and _pRun.<nl>
 *      2. Run pointers are typically used to either just move around
 *      and then fetch data or move and fetch data every time (like during 
 *      a measuring loop).  In the former case, there is no need to always
 *      bind _pRun; you can just do it on demand.  In the latter case, the
 *      two models are equivalent.  
 *
 */

class CRunPtrBase
{
private:

    DECLARE_MEMALLOC_NEW_DELETE(Mt(Mem))

public:
    
    WHEN_DBG( BOOL Invariant ( ) const; )
    WHEN_DBG( long GetTotalCch ( ) const; )

    CRunPtrBase ( CRunArray * prgRun )
    {
        _prgRun = prgRun; 
        __iRun = 0; 
        __ich = 0; 
    }
    
    CRunPtrBase ( CRunPtrBase & rp )
    {
        *this = rp;
    }

    void SetRunArray ( CRunArray * prgRun )
    {
        _prgRun = prgRun;
    }
                                    
    BOOL SetRun( long iRun, long ich );

    BOOL NextRun ( );
    BOOL PrevRun ( );
    
    CTxtRun * GetRunRel ( long cRun ) const
    {
        Assert( _prgRun );
        
        return _prgRun->Elem( GetIRun() + cRun );
    }
    
    long NumRuns ( ) const
    {
        return _prgRun->Count();
    }

    BOOL OnLastRun ( )
    {
        Assert( GetIRun() < NumRuns() );
        
        return NumRuns() == 0 || GetIRun() == NumRuns() - 1;
    }

    BOOL OnFirstRun ( )
    {
        Assert( GetIRun() < NumRuns() );
        
        return GetIRun() == 0;
    }

    DWORD   BindToCp ( DWORD cp );
    
    DWORD   GetCp ( ) const;
    
    long    AdvanceCp ( long cch );
    
    BOOL    AdjustBackward ( );

    BOOL    AdjustForward ( );

    long    GetCchRemaining ( ) const { return GetRunRel( 0 )->_cch - GetIch(); }

    long    GetCchRun() { return GetRunRel( 0 )->_cch; }

    long GetIRun ( ) const { return __iRun; }
    
    void SetIRun ( long iRunNew )
    {
        __iRun = iRunNew;
    }

    long GetIch ( ) const { return __ich; }
    
    void SetIch ( long ichNew )
    {
        __ich = ichNew;
    }

    BOOL IsValid() const
    {
        return __iRun < long( _prgRun->Count() );
    }

protected:
    
    CRunArray * _prgRun;

private:
    
    //
    // WARNING: Do NOT access these members directly. Use accessors.
    //
    
    long __iRun;
    long __ich;
};


/*
 *  CRunPtr (template)
 *
 *  @class  a template over CRunPtrBase allowing for type-safe versions of
 *      run pointers
 * 
 *  @tcarg  class   | CElem | run array class to be used
 *
 *  @base   public | CRunPtrBase
 */
template <class CRunElem>
class CRunPtr : public CRunPtrBase
{
private:

    DECLARE_MEMALLOC_NEW_DELETE(Mt(Mem))

public:
    
    CRunPtr() : CRunPtrBase( 0 ) { }
    
    CRunPtr ( CRunArray * prgRun ) : CRunPtrBase ( prgRun ) { }
    
    CRunPtr ( CRunPtrBase & rp ) : CRunPtrBase ( rp ) { }

    // Array management 
                                        
    CRunElem * Add (DWORD cRun, DWORD *pielIns)    //@cmember Add <p cRun>     
    {                                           // elements at end of array
        Assert(_prgRun != NULL);
        return (CRunElem *)_prgRun->Add(cRun, pielIns);
    }
                                        
    CRunElem * Insert (DWORD cRun)                 //@cmember Insert <p cRun>
    {                                           // elements at current pos
        Assert(_prgRun != NULL);
        return (CRunElem *)_prgRun->Insert(GetIRun(), cRun);
    }
                                        
    CRunElem * InsertAtRel (long dRun, DWORD cRun)
    {                                           // elements at current pos
        Assert(_prgRun != NULL);
        return (CRunElem *)_prgRun->Insert(GetIRun() + dRun, cRun);
    }

    void RemoveRel (LONG cRun, ArrayFlag flag)  //@cmember Remove <p cRun>
    {                                           // elements at current pos
         Assert(_prgRun != NULL);
         _prgRun->Remove (GetIRun(), cRun, flag);
    }
    
    void RemoveAbs ( long iRun, LONG cRun, ArrayFlag flag )
    {
         Assert(_prgRun != NULL);
         _prgRun->Remove( iRun, cRun, flag );
    } 
                                        //@cmember  Replace <p cRun> elements
                                        // at current position with those
                                        // from <p parRun>
    BOOL Replace (LONG cRun, CRunArray *parRun)
    {
        Assert(_prgRun != NULL);
        return _prgRun->Replace(GetIRun(), cRun, parRun);
    }

    CRunElem * GetRunAbs ( LONG iRun ) const
    {
        Assert( _prgRun != NULL );
        return (CRunElem *) _prgRun->Elem( iRun );
    }

    CRunElem * GetRunRel ( LONG dRun ) const
    {
        return (CRunElem *) CRunPtrBase::GetRunRel( dRun );
    }

    CRunElem * GetCurrRun ( void ) const
    {
        return GetRunAbs( GetIRun() );
    }
    
    CRunElem * GetPrevRun ( )
    {
        Assert( GetIRun() == 0 || (GetIRun() >= 0 && GetIRun() < NumRuns()) );

        if (GetIRun() == 0)
            return NULL;

        return GetRunAbs(GetIRun() - 1);
    }
    
    CRunElem * GetNextRun ( )
    {
        long nRuns = NumRuns();
        long iRun = GetIRun() + 1;

        Assert( GetIRun() == 0 || (GetIRun() >= 0 && GetIRun() < nRuns) );

        if (nRuns == 0 || iRun == nRuns)
            return NULL;

        return GetRunAbs( iRun );
    }
};

#pragma INCMSG("--- End '_runptr.h'")
#else
#pragma INCMSG("*** Dup '_runptr.h'")
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\text\_txtsave.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1996.
//
//  File:       _txtsave.h
//
//  Contents:   Objects used for saving forms to the stream
//
//  Classes:    CTextSaver
//              CRangeSaver
//
//----------------------------------------------------------------------------

#ifndef I__TXTSAVE_H_
#define I__TXTSAVE_H_
#pragma INCMSG("--- Beg '_txtsave.h'")

#ifndef X_SAVER_HXX_
#define X_SAVER_HXX_
#include "saver.hxx"
#endif

class CStreamWriteBuff;
class CElement;

//
//  Flags for use with the range saver
//
enum
{
    RSF_CFHTML_HEADER =         0x1,    // include CF-HTML header
    RSF_FRAGMENT =              0x2,    // include the fragment
    RSF_CONTEXT =               0x4,    // include the context
    RSF_FOR_RTF_CONV =          0x8,    // mode friendly to the RTF converter
    RSF_SELECTION =             0x10,   // include the selection
    RSF_NO_ENTITIZE_UNKNOWN =   0x20,   // do not entitize unknown characters
    RSF_NO_IE4_COMPAT_SEL =     0x40,   // don't compute selection according to IE4 rules
    RSF_NO_IE4_COMPAT_FRAG =    0x80    // don't compute fragment according to IE4 rules
};

#define RSF_CFHTML (RSF_CFHTML_HEADER | RSF_FRAGMENT | RSF_SELECTION | RSF_CONTEXT)
#define RSF_HTML   (RSF_FRAGMENT | RSF_SELECTION | RSF_CONTEXT)

//+---------------------------------------------------------------------------
//
//  Class:      CRangeSaver
//
//  Synopsis:   This class is designed to write a given range to a stream
//              with various formatting options.
//
//----------------------------------------------------------------------------

class CRangeSaver : public CTreeSaver
{
public:
    CRangeSaver(
        CMarkupPointer *    pLeft,
        CMarkupPointer *    pRight,
        DWORD               dwFlags,
        CStreamWriteBuff *  pswb,
        CMarkup *           pMarkup,
        CElement *          pelContainer = NULL );

    HRESULT Save();

    HRESULT SaveSegmentList(ISegmentList*  pSegmentList, CMarkup*  pMarkup);

private:

    void Initialize(
        CMarkupPointer *    pLeft,
        CMarkupPointer *    pRight,
        DWORD               dwFlags,
        CStreamWriteBuff *  pswb,
        CMarkup *           pMarkup,
        CElement *          pelContainer );

protected:
    //
    // CF-HTML header offset information
    //
    struct tagCFHTMLHeader
    {
        LONG iHTMLStart, iHTMLEnd;
        LONG iFragmentStart, iFragmentEnd;
        LONG iSelectionStart, iSelectionEnd;
    }
    _header;

    HRESULT SaveSelection( BOOL fEnd );

    //
    // Internal helpers
    //
    HRESULT GetStmOffset(LONG * plOffset);
    HRESULT SetStmOffset(LONG lOffset);
    HRESULT WriteCFHTMLHeader();
    HRESULT WriteOpenContext();
    HRESULT WriteCloseContext();

    void    DoIE4SelectionCollapse();
    void    ComputeIE4Fragment();
    void    ComputeIE4Selection();

    DWORD       _dwFlags;
};

#pragma INCMSG("--- End '_txtsave.h'")
#else
#pragma INCMSG("*** Dup '_txtsave.h'")
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\util\array.cpp ===
/*
 *  @doc INTERNAL
 *
 *  @module ARRAY.C -- Generic Array Implementation |
 *
 *  Original Author: <nl>
 *      Christian Fortini
 *
 *  History: <nl>
 *      6/25/95  alexgo  Cleanup and Commented
 *
 *
 */


#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_ARRAY_HXX_
#define X_ARRAY_HXX_
#include "array.hxx"
#endif


#define celGrow 8

//
//  Invariant support
//
#define DEBUG_CLASSNAME CArrayBase
#include "_invar.h"


// =============================  Utility routines  =========================

/*
 *  PTRUNION
 *
 *  @struct PTRUNION | A union of the different types of pointers.  Useful for copying
 *  memory around
 */
typedef union tagPointerUnion
{
    BYTE *pb;   //@field A byte pointer
    WORD *pw;   //@field A word pointer
    DWORD *pd;  //@field A dword pointer
} PTRUNION;


// ===================================  CArrayBase  ================================================

#if DBG == 1
/*
 *  CArrayBase::Invariant
 *
 *  @mfunc  Tests the array state to make sure it is valid.  DEBUG only
 *
 *  @rdesc  TRUE if the tests succeed, FALSE otherwise
 */
BOOL CArrayBase::Invariant(void) const
{
    Assert(_cbElem > 0 );

    if( _prgel == NULL )
    {
        Assert(_cel == 0);
        Assert(_celMax == 0);

        // we go ahead and return a value here so that
        // this function can be executed in the "watch"
        // window of various debuggers
        if( _cel != 0 || _celMax != 0 )
            return FALSE;
    }
    else
    {
        Assert(_celMax > 0 );
        Assert(_cel <= _celMax);

        if( _celMax == 0 || _cel > _celMax )
            return FALSE;
    }

    return TRUE;
}
#endif

/*
 *  CArrayBase::ArAdd
 *
 *  @mfunc  Adds <p celAdd> elements to the end of the array.
 *
 *  @rdesc  A pointer to the start of the new elements added.  If non-NULL,
 *  <p pielIns> will be set to the index at which elements were added.
 */

void *
CArrayBase::ArAdd (
    DWORD celAdd,     // the number of elements to add
    DWORD * pielIns ) // where to store the index of the first element added
{
    char *  pel;
    DWORD   celNew;

    _TEST_INVARIANT_

    if (_cel + celAdd > _celMax)                 // need to grow
    {
        HRESULT hr;

        //
        // When we grow the array we grow it in units of celGrow.  However,
        // to make sure we don't grow small arrays too large, and get too much
        // unused space, we allocate only as much space as needed up to
        // celGrow.
        //

        if (_cel + celAdd <= celGrow)
            celNew = _cel + celAdd - _celMax;
        else
            celNew = max( DWORD( celGrow ), celAdd + celGrow - celAdd % celGrow );

        pel = _prgel;

        hr = MemRealloc(_mt, (void **) & pel, (_celMax + celNew) * _cbElem);

        MemSetName((pel, "CArrayBase data - %d elements", celNew));

        if(hr)
            return NULL;

        _prgel = pel;

        pel += _cel * _cbElem;

        _celMax += celNew;
    }
    else
    {
        pel = _prgel + _cel * _cbElem;
    }

    ZeroMemory( pel, celAdd * _cbElem );

    if (pielIns)
        *pielIns = _cel;

    _cel += celAdd;

    return pel;
}

/*
 *  CArrayBase::ArInsert
 *
 *  @mfunc Inserts <p celIns> new elements at index <p iel>
 *
 *  @rdesc A pointer to the newly inserted elements.  Will be NULL on
 *  failure.
 */
void* CArrayBase::ArInsert(
    DWORD iel,      //@parm the index at which to insert
    DWORD celIns    //@parm the number of elements to insert
)
{
    char *pel;
    DWORD celNew;
    HRESULT hr;

    _TEST_INVARIANT_

    AssertSz(iel <= _cel, "CArrayBase::Insert() - Insert out of range");

    if(iel >= _cel)
        return ArAdd(celIns, NULL);

    if(_cel + celIns > _celMax)             // need to grow
    {
        AssertSz(_prgel, "CArrayBase::Insert() - Growing a non existent array !");

        celNew = max (DWORD(celGrow), celIns + celGrow - celIns % celGrow);
        pel = _prgel;
        hr = MemRealloc(_mt, (void **) & pel, (_celMax + celNew)*_cbElem);
        if(hr)
        {
            AssertSz(FALSE, "CArrayBase::Insert() - Couldn't realloc line array");
            return NULL;
        }
        MemSetName((pel, "CArrayBase data - %d elements", celNew));

        _prgel = pel;
        _celMax += celNew;
    }
    pel = _prgel + iel * _cbElem;
    if(iel < _cel)              // Nove Elems up to make room for new ones
    {
        MoveMemory(pel + celIns*_cbElem, pel, (_cel - iel)*_cbElem);
        ZeroMemory(pel, celIns * _cbElem);
    }

    _cel += celIns;


    return pel;
}

/*
 *  CArrayBase::Remove
 *
 *  @mfunc  Removes the <p celFree> elements from the array starting at index
 *  <p ielFirst>.  If <p celFree> is negative, then all elements after
 *  <p ielFirst> are removed.
 *
 *  @rdesc nothing
 */
void CArrayBase::Remove(
    DWORD ielFirst,     //@parm the index at which elements should be removed
    LONG celFree,       //@parm the number of elements to remove.
    ArrayFlag flag      //@parm what to do with the left over memory (delete or leave
                        //alone.
)
{
    char *pel;

    _TEST_INVARIANT_

    if (celFree < 0)
        celFree = _cel - ielFirst;

    AssertSz(ielFirst + celFree <= _cel, "CArrayBase::Free() - Freeing out of range");

    if (_cel > ielFirst + celFree)
    {
        pel = _prgel + ielFirst * _cbElem;
        MoveMemory(pel, pel + celFree * _cbElem,
            (_cel - ielFirst - celFree) * _cbElem);
    }

    _cel -= celFree;

    if((flag == AF_DELETEMEM) && _cel < _celMax - celGrow)
    {
        HRESULT hr;

        // shrink array
        _celMax = _cel + celGrow - _cel % celGrow;
        pel = _prgel;
        hr = MemRealloc(_mt, (void **) & pel, _celMax * _cbElem);
        // we don't care if it fails since we're shrinking
        if (!hr)
            _prgel = pel;
    }
}

/*
 *  CArrayBase::Clear
 *
 *  @mfunc  Clears the entire array, potentially deleting all of the memory
 *  as well.
 *
 *  @rdesc  nothing
 */
void CArrayBase::Clear(
    ArrayFlag flag  //@parm Indicates what should be done with the memory
                    //in the array.  One of AF_DELETEMEM or AF_KEEPMEM
)
{
    _TEST_INVARIANT_

    if( flag == AF_DELETEMEM )
    {
        MemFree(_prgel);
        _prgel = NULL;
        _celMax = 0;
    }
    _cel = 0;
}

/*
 *  CArrayBase::Replace
 *
 *  @mfunc  Replaces the <p celRepl> elements at index <p ielRepl> with the
 *  contents of the array specified by <p par>.  If <p celRepl> is negative,
 *  then the entire contents of <p this> array starting at <p ielRepl> should
 *  be replaced.
 *
 *  @rdesc  Returns TRUE on success, FALSE otherwise.
 */
BOOL CArrayBase::Replace(
    DWORD ielRepl,      //@parm the index at which replacement should occur
    LONG celRepl,       //@parm the number of elements to replace (may be
                        //negative, indicating that all
    CArrayBase *par     //@parm the array to use as the replacement source
)
{
    _TEST_INVARIANT_

    DWORD celMove = 0;
    DWORD celIns = par->Count();

    if (celRepl < 0)
        celRepl = _cel - ielRepl;

    AssertSz(ielRepl + celRepl <= _cel, "CArrayBase::ArReplace() - Replacing out of range");

    celMove = min(celRepl, (LONG)celIns);

    if (celMove > 0)
    {
        MoveMemory(Elem(ielRepl), par->Elem(0), celMove * _cbElem);
        celIns -= celMove;
        celRepl -= celMove;
        ielRepl += celMove;
    }

    Assert(celRepl >= 0);
    Assert(celIns + celMove == par->Count());

    if(celIns > 0)
    {
        Assert(celRepl == 0);
        void *pelIns = ArInsert (ielRepl, celIns);
        if (!pelIns)
            return FALSE;
        MoveMemory(pelIns, par->Elem(celMove), celIns * _cbElem);
    }
    else if(celRepl > 0)
        Remove (ielRepl, celRepl, AF_DELETEMEM);

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\util\collbase.cxx ===
//=================================================================
//
//   File:      collbase.cxx
//
//  Contents:   CCollectionBase class
//
//  Classes:    CCollectionBase
//
//=================================================================

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_COLLBASE_HXX_
#define X_COLLBASE_HXX_
#include "collbase.hxx"
#endif



//+---------------------------------------------------------------
// CCollectionBase::InvokeEx, IDispatch
// Provides access to properties and members of the object
//
// Arguments:   [dispidMember] - Member id to invoke
//              [riid]         - Interface ID being accessed
//              [wFlags]       - Flags describing context of call
//              [pdispparams]  - Structure containing arguments
//              [pvarResult]   - Place to put result
//              [pexcepinfo]   - Pointer to exception information struct
//              [puArgErr]     - Indicates which argument is incorrect
//
// We override this to support ordinal and named member access to the
// elements of the collection.
//----------------------------------------------------------------

STDMETHODIMP
CCollectionBase::InvokeEx(DISPID    dispidMember,
               LCID                 lcid,
               WORD                 wFlags,
               DISPPARAMS          *pdispparams,
               VARIANT             *pvarResult,
               EXCEPINFO           *pexcepinfo,
               IServiceProvider    *pSrvProvider)
{
    HRESULT hr = DISP_E_MEMBERNOTFOUND;

    // Is the dispid an ordinal index? (array access)
    if (IsCollectionDispID(dispidMember))
    {
        if (wFlags & DISPATCH_PROPERTYPUT) 
        {
            goto Cleanup;       // collection is RO return DISP_E_MEMBERNOTFOUND
        }
        else if (wFlags & DISPATCH_PROPERTYGET)
        {
            if (pvarResult)
            {
                hr = GetItem(dispidMember - DISPID_COLLECTION_MIN, pvarResult);
            }
        }
    }
    else
    {
        // CBase knows how to handle expando
        hr = THR_NOTRACE(super::InvokeEx(dispidMember,
                         lcid,
                         wFlags,
                         pdispparams,
                         pvarResult,
                         pexcepinfo,
                         pSrvProvider));
    }

Cleanup:
    RRETURN(hr);
}


//+---------------------------------------------------------------
//  CCollectionBase::GetDispID, IDispatchEx
//
//  Overridden to output a particular dispid range collection accessing.
//----------------------------------------------------------------

STDMETHODIMP
CCollectionBase::GetDispID(BSTR bstrName, DWORD grfdex, DISPID *pid)
{
    HRESULT     hr;
    long        lIdx;

    if (!pid)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    // Could be an ordinal access
    hr = ttol_with_error(bstrName, &lIdx);
    if (hr)
    {
    // Not ordinal access; could be named 
        lIdx = FindByName(bstrName, !!(grfdex & fdexNameCaseSensitive));
    }

    *pid = DISPID_COLLECTION_MIN + lIdx;

    hr =  S_OK;

    if (lIdx == -1 || !IsLegalIndex(lIdx) || !IsCollectionDispID(*pid))
    {
        // Otherwise delegate to CBase impl for expando support etc.
        hr = THR_NOTRACE(super::GetDispID(bstrName, grfdex, pid));
    }


Cleanup:
    RRETURN(hr);
}



//+---------------------------------------------------------------
//  CCollectionBase::GetNextDispID, IDispatchEx
//
//  Supports enumerating our collection indices in addition to the
//  collection's own properties.
//----------------------------------------------------------------

STDMETHODIMP
CCollectionBase::GetNextDispID(DWORD grfdex, DISPID id, DISPID *prgid)
{
    HRESULT     hr = S_OK;
    long        lIdx;

    if (!prgid)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    // Are we enumerating?
    if (!IsCollectionDispID(id))
    {
        // No, so delegate to CBase for normal properties
        hr = super::GetNextDispID(grfdex, id, prgid);
        if (hr)
        {
            // Start drilling into the collection.
            if (IsLegalIndex(0))
            {
                *prgid = DISPID_COLLECTION_MIN;
                hr = S_OK;
            }
        }
    }
    else
    {
        // Drill into the collection
        lIdx = id - DISPID_COLLECTION_MIN + 1;

        // Yes we're enumerating indices, so return string of current DISPID, and DISPID for next index,
        // or DISPID_UNKNOWN if we're out of bounds.
        if (!IsCollectionDispID(id+1) || !IsLegalIndex(lIdx))
        {
            *prgid = DISPID_UNKNOWN;
            hr = S_FALSE;
            goto Cleanup;
        }

        ++id;
        *prgid = id;
    }

Cleanup:
    RRETURN1(hr, S_FALSE);
}

STDMETHODIMP
CCollectionBase::GetMemberName(DISPID id, BSTR *pbstrName)
{
    HRESULT hr;

    if (!pbstrName)
        return E_INVALIDARG;
    
    *pbstrName = NULL;

    // Are we enumerating?
    if (!IsCollectionDispID(id))
    {
        // No, so delegate to CBase for normal properties
        super::GetMemberName(id, pbstrName);
    }
    else
    {
        // Drill into the collection
        long lIdx;
        LPCTSTR szName;
        TCHAR ach[20];

        lIdx = id - DISPID_COLLECTION_MIN;

        // Yes we're enumerating indices, so return string of current DISPID, and DISPID for next index,
        // or DISPID_UNKNOWN if we're out of bounds.
        if (!IsCollectionDispID(id) || !IsLegalIndex(lIdx))
            goto Cleanup;

        szName = GetName(lIdx);
        if ( !szName )
        {
            // No name return index
            hr = Format(0, ach, ARRAY_SIZE(ach), _T("<0d>"), lIdx);
            if (hr)
                return hr;
            szName = ach;
        }
        hr = THR(FormsAllocString(szName, pbstrName));
        if ( hr )
            return hr;
    }

Cleanup:
    return *pbstrName ? S_OK : DISP_E_MEMBERNOTFOUND;
}

//+---------------------------------------------------------------
//  CCollectionBase::IsLegalIndex
//
//  Returns TRUE if given number is in the range of collection
//  indexes.
//----------------------------------------------------------------

BOOL 
CCollectionBase::IsLegalIndex(long lIdx)
{
    HRESULT    hr;
    
    // GetItem with NULL pointer means we want to cheeck the 
    // index only
    hr = THR(GetItem(lIdx, NULL));
    if(!hr)
        return TRUE;

    return FALSE;
}


//+---------------------------------------------------------------
//  CCollectionBase::GetIDsOfNames, IDispatch
//
// We need our IDispatch methods because if we don't provide them CBase
//  implementaion will be called (they are not virtual)
//----------------------------------------------------------------

HRESULT STDMETHODCALLTYPE 
CCollectionBase::GetIDsOfNames(REFIID riid, LPTSTR *rgszNames, UINT cNames,
         LCID lcid, DISPID *rgdispid)
{
    if (!IsEqualIID(riid, IID_NULL)) 
        RRETURN(E_INVALIDARG);
    return GetDispID(rgszNames[0], fdexFromGetIdsOfNames, rgdispid);
}


//+---------------------------------------------------------------
//  CCollectionBase::Invoke, IDispatch
//
// We need our IDispatch methods because if we don't provide them CBase
//  implementaion will be called (they are not virtual)
//----------------------------------------------------------------

HRESULT STDMETHODCALLTYPE 
CCollectionBase::Invoke(DISPID dispidMember, REFIID riid, LCID lcid, WORD wFlags,
         DISPPARAMS FAR* pdispparams, VARIANT FAR* pvarResult, EXCEPINFO FAR* pexcepinfo,
         UINT FAR* puArgErr)
{
    if (!IsEqualIID(riid, IID_NULL)) 
        RRETURN(E_INVALIDARG);
    return InvokeEx(dispidMember, lcid, wFlags, pdispparams, pvarResult, pexcepinfo, NULL);
}

//+------------------------------------------------------------------------
//
//  Member:     CCollectionBase::item
//
//-------------------------------------------------------------------------

HRESULT
CCollectionBase::GetItemHelper(VARIANT * pvarIndex, VARIANT * pvarRet)
{
    HRESULT     hr = S_OK;
    CVariant    varArg;
    long        idx;

    if (!pvarRet)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    // ECMA rule - return empty for access beyond array bounds
    V_VT(pvarRet) = VT_EMPTY;

    switch (V_VT(pvarIndex))
    {
    case VT_BSTR:
    case VT_LPWSTR:

        idx = FindByName(V_BSTR(pvarIndex), /* fCaseSensitive = */TRUE);

        break;

    default:

        hr = THR(varArg.CoerceVariantArg(pvarIndex, VT_I4));
        if (hr)
        {
            hr = E_INVALIDARG;
            goto Cleanup;
        }

        idx = V_I4(&varArg);

        break;
    }

    if (idx < 0)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    hr = THR(GetItem(idx, pvarRet));
    if(hr)
    {
        if(hr == S_FALSE)
            hr = E_INVALIDARG;
        goto Cleanup;
    }

Cleanup:
    RRETURN(SetErrorInfo(hr));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\util\collect.cxx ===
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996.
//
//  File:       collect.cxx
//
//  Contents:   CCollectionCache, CElementCollectionBase and CElementCollection
//
//----------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_COLLECT_HXX_
#define X_COLLECT_HXX_
#include "collect.hxx"
#endif

#ifndef X_ATOMTBL_HXX_
#define X_ATOMTBL_HXX_
#include "atomtbl.hxx"
#endif

#ifndef X_FORMKRNL_HXX_
#define X_FORMKRNL_HXX_
#include "formkrnl.hxx"
#endif

#ifndef X_QI_IMPL_H_
#define X_QI_IMPL_H_
#include "qi_impl.h"
#endif

#ifndef X_DISPEX_H_
#define X_DISPEX_H_
#include <dispex.h>
#endif

#ifndef X_TCELL_HXX_
#define X_TCELL_HXX_
#include "tcell.hxx"
#endif

#ifndef X_EVENTOBJ_HXX_
#define X_EVENTOBJ_HXX_
#include "eventobj.hxx"
#endif

#ifndef X_CLRNGPRS_HXX_
#define X_CLRNGPRS_HXX_
#include <clrngprs.hxx>
#endif

#ifndef X_FRAME_HXX_
#define X_FRAME_HXX_
#include <frame.hxx>
#endif

#ifndef X_WINDOW_HXX_
#define X_WIDNOW_HXX_
#include <window.hxx>
#endif

#ifndef X_EOBJECT_HXX_
#define X_EOBJECT_HXX_
#include "eobject.hxx"
#endif

#define _cxx_
#include "collect.hdl"

MtDefine(CElementCollection, Tree, "CElementCollection")
MtDefine(CCollectionCache, Tree, "CCollectionCache")

MtDefine(CElementAryCacheItem, CCollectionCache, "CElementAryCacheItem")
MtDefine(CElementAryCacheItem_aryElements_pv, CElementAryCacheItem, "CElementAryCacheItem::_aryElements._pv")

MtDefine(CCollectionCacheItem, XCollectionCacheItem, "CCollectionCacheItem")
MtDefine(CCollectionCache_aryItems_pv, CCollectionCache, "CCollectionCache::_aryItems::_pv")
MtDefine(CCollectionCache_aryItems_pary, CCollectionCache, "CCollectionCache::_aryItems[i].pary")
MtDefine(CCollectionCache_aryItems_pary_pv, CCollectionCache, "CCollectionCache::_aryItems[i].pary->_pv")
MtDefine(CCollectionCacheGetNewEnum_pary, Tree, "CCollectionCache::GetNewEnum pary")
MtDefine(CCollectionCacheGetNewEnum_pary_pv, Tree, "CCollectionCache::GetNewEnum pary->_pv")

//====================================================================
//
//  Class CElementCollectionBase, CElementCollection methods
//
//===================================================================

//+------------------------------------------------------------------------
//
//  Member:     s_classdesc
//
//  Synopsis:   class descriptor
//
//-------------------------------------------------------------------------

const CBase::CLASSDESC CElementCollectionBase::s_classdesc =
{
    0,                              // _pclsid
    0,                              // _idrBase
#ifndef NO_PROPERTY_PAGE
    NULL,                           // _apClsidPages
#endif // NO_PROPERTY_PAGE
    NULL,                           // _pcpi
    0,                              // _dwFlags
    NULL,                           // _piidDispinterface
    &s_apHdlDescs,                  // _apHdlDesc
};

//+------------------------------------------------------------------------
//
//  Member:     s_classdesc
//
//  Synopsis:   class descriptor
//
//-------------------------------------------------------------------------

const CBase::CLASSDESC CElementCollection::s_classdesc =
{
    0,                              // _pclsid
    0,                              // _idrBase
#ifndef NO_PROPERTY_PAGE
    NULL,                           // _apClsidPages
#endif // NO_PROPERTY_PAGE
    NULL,                           // _pcpi
    0,                              // _dwFlags
    &IID_IHTMLElementCollection,    // _piidDispinterface
    &s_apHdlDescs,                  // _apHdlDesc
};

CElementCollection::CElementCollection(CCollectionCache *pCollectionCache, long lIndex)
    : super(pCollectionCache, lIndex)
{
    if (lIndex == CMarkup::ELEMENT_COLLECTION && pCollectionCache->GetReservedSize() == CMarkup::NUM_DOCUMENT_COLLECTIONS)
    {
        IDispatch *pDispDocument;
        CMarkup *pMarkup = DYNCAST(CMarkup, pCollectionCache->GetBase());
        Assert(pMarkup->Document());
        IGNORE_HR(pMarkup->Document()->QueryInterface(IID_IDispatch, (void **)&pDispDocument));
        Assert(pDispDocument);
        DYNCAST(CAllCollectionCacheItem, pCollectionCache->GetCacheItem(lIndex))->SetDispDocument(pDispDocument);
    }
}

//+------------------------------------------------------------------------
//
//  Member:     CElementCollectionBase
//
//  Synopsis:   constructor
//
//-------------------------------------------------------------------------

CElementCollectionBase::CElementCollectionBase(
        CCollectionCache *pCollectionCache,
        long lIndex)
    : super(), _pCollectionCache(pCollectionCache), _lIndex(lIndex)
{
    // Tell the base to live longer than us
    _pCollectionCache->GetBase()->SubAddRef();
}

//+------------------------------------------------------------------------
//
//  Member:     ~CElementCollectionBase
//
//  Synopsis:   destructor
//
//-------------------------------------------------------------------------

CElementCollectionBase::~CElementCollectionBase()
{
    // release subobject count
    _pCollectionCache->GetBase()->SubRelease();
}

//+------------------------------------------------------------------------
//
//  Member:     ~CElementCollection
//
//  Synopsis:   destructor
//
//-------------------------------------------------------------------------

CElementCollection::~CElementCollection()
{
    _pCollectionCache->ClearDisp(_lIndex);
    if (_lIndex == CMarkup::ELEMENT_COLLECTION && _pCollectionCache->GetReservedSize() == CMarkup::NUM_DOCUMENT_COLLECTIONS)
    {
        CAllCollectionCacheItem *pCItem = DYNCAST(CAllCollectionCacheItem, _pCollectionCache->GetCacheItem(_lIndex));
        Assert(pCItem);
        ClearInterface(&(pCItem->_pDispDocument));
    }
}

//+------------------------------------------------------------------------
//
//  Member:     PrivateQueryInterface
//
//  Synopsis:   vanilla implementation
//
//-------------------------------------------------------------------------

HRESULT
CElementCollection::PrivateQueryInterface(REFIID iid, void ** ppv)
{
    *ppv = NULL;
    switch (iid.Data1)
    {
        QI_INHERITS((IHTMLElementCollection *)this, IUnknown)
        QI_INHERITS((IHTMLElementCollection *)this, IDispatch)
        QI_INHERITS(this, IDispatchEx)
        QI_TEAROFF(this, IHTMLElementCollection2, NULL)
        QI_TEAROFF(this, IHTMLElementCollection3, NULL)

        default:
            if (iid == CLSID_CElementCollection)
            {
                *ppv = this;
                return S_OK;
            }

            if (iid == IID_IHTMLElementCollection)
                *ppv = (IHTMLElementCollection *)this;
    }

    if (!*ppv)
        RRETURN(E_NOINTERFACE);

    ((IUnknown *) *ppv)->AddRef();

    return S_OK;
}


//+---------------------------------------------------------------------------
//
//  Member:     CElementCollectionBase::GetTypeInfoCount, IDispatch
//
//----------------------------------------------------------------------------

STDMETHODIMP
CElementCollectionBase::GetTypeInfoCount (UINT FAR* pctinfo)
{
    return super::GetTypeInfoCount(pctinfo);
}


//+---------------------------------------------------------------------------
//
//  Member:     CElementCollectionBase::GetTypeInfo, IDispatch
//
//----------------------------------------------------------------------------

STDMETHODIMP
CElementCollectionBase::GetTypeInfo(
                UINT itinfo,
                LCID lcid,
                ITypeInfo ** pptinfo)
{
    return super::GetTypeInfo(itinfo, lcid, pptinfo);
}


//+---------------------------------------------------------------------------
//
//  Member:     CElementCollection::GetIDsOfNames, IDispatch
//
//----------------------------------------------------------------------------

STDMETHODIMP
CElementCollectionBase::GetIDsOfNames(
                REFIID                riid,
                LPOLESTR *            rgszNames,
                UINT                  cNames,
                LCID                  lcid,
                DISPID FAR*           rgdispid)
{
    RRETURN(THR_NOTRACE(GetDispID(rgszNames[0], fdexFromGetIdsOfNames, rgdispid)));
}


HRESULT
CElementCollectionBase::Invoke(
    DISPID          dispidMember,
    REFIID,
    LCID            lcid,
    WORD            wFlags,
    DISPPARAMS *    pdispparams,
    VARIANT *       pvarResult,
    EXCEPINFO *     pexcepinfo,
    UINT *)
{
    return InvokeEx(dispidMember,
                    lcid,
                    wFlags,
                    pdispparams,
                    pvarResult,
                    pexcepinfo,
                    NULL);
}
//+---------------------------------------------------------------------------
//
//  Member:     CElementCollectionBase::Invoke, IDispatch
//
//  Synopsis:   Return the value of the property.
//
//  Note:       If the dispidMember passed to Invoke is DISPID_UNKNOWN we'll
//              return VT_EMPTY.  This allow VBScript/JavaScript to test
//              isnull( ) or comparision to null.
//----------------------------------------------------------------------------
HRESULT
CElementCollectionBase::InvokeEx(
                DISPID          dispidMember,
                LCID            lcid,
                WORD            wFlags,
                DISPPARAMS *    pdispparams,
                VARIANT *       pvarResult,
                EXCEPINFO *     pexcepinfo,
                IServiceProvider *pSrvProvider)
{
    HRESULT             hr;

    hr = THR(_pCollectionCache->EnsureAry(_lIndex));
    if (hr)
        goto Cleanup;

    hr = DispatchInvokeCollection(this,
                                  &super::InvokeEx,
                                  _pCollectionCache,
                                  _lIndex,
                                  dispidMember,
                                  IID_NULL,
                                  lcid,
                                  wFlags,
                                  pdispparams,
                                  pvarResult,
                                  pexcepinfo,
                                  NULL,
                                  pSrvProvider);

Cleanup:
    RRETURN(SetErrorInfo(hr));
}

//+---------------------------------------------------------------------------
//
//  Member:     CElementCollectionBase::GetDispID, IDispatchEx
//
//  Synopsis:   defer to cache
//
//----------------------------------------------------------------------------

STDMETHODIMP
CElementCollectionBase::GetDispID(BSTR bstrName, DWORD grfdex, DISPID *pid)
{
    HRESULT     hr;

    hr = THR(_pCollectionCache->EnsureAry(_lIndex));
    if (hr)
        goto Cleanup;

    hr = DispatchGetDispIDCollection(this,
                                     &super::GetDispID,
                                     _pCollectionCache,
                                     _lIndex,
                                     bstrName,
                                     grfdex,
                                     pid);

Cleanup:
    RRETURN(hr);
}


//+-------------------------------------------------------------------------
//
//  Method:     CElementCollection::DeleteMember, IDispatchEx
//
//--------------------------------------------------------------------------

HRESULT CElementCollectionBase::DeleteMemberByName(BSTR bstr,DWORD grfdex)
{
    return E_NOTIMPL;
}

HRESULT CElementCollectionBase::DeleteMemberByDispID(DISPID id)
{
    return E_NOTIMPL;
}



//+-------------------------------------------------------------------------
//
//  Method:     CElementCollection::GetMemberProperties, IDispatchEx
//
//--------------------------------------------------------------------------

HRESULT
CElementCollectionBase::GetMemberProperties(
                DISPID id,
                DWORD grfdexFetch,
                DWORD *pgrfdex)
{
    return E_NOTIMPL;
}


//+---------------------------------------------------------------------------
//
//  Member:     CElementCollectionBase::GetNextDispID, IDispatchEx
//
//----------------------------------------------------------------------------
STDMETHODIMP
CElementCollectionBase::GetNextDispID(
                DWORD grfdex,
                DISPID id,
                DISPID *prgid)
{
    HRESULT     hr;

    hr = THR(_pCollectionCache->EnsureAry(_lIndex));
    if (hr)
        goto Cleanup;

    hr = DispatchGetNextDispIDCollection(this,
                                         &super::GetNextDispID,
                                         _pCollectionCache,
                                         _lIndex,
                                         grfdex,
                                         id,
                                         prgid);

Cleanup:
    RRETURN1(hr, S_FALSE);
}

STDMETHODIMP
CElementCollectionBase::GetMemberName(
                DISPID id,
                BSTR *pbstrName)
{
    HRESULT     hr;

    hr = THR(_pCollectionCache->EnsureAry(_lIndex));
    if (hr)
        goto Cleanup;

    hr = DispatchGetMemberNameCollection(this,
                                         &super::GetMemberName,
                                         _pCollectionCache,
                                         _lIndex,
                                         id,
                                         pbstrName);

Cleanup:
    RRETURN(hr);
}

HRESULT
CElementCollectionBase::GetNameSpaceParent(IUnknown **ppunk)
{
    HRESULT     hr;

    if (!ppunk)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *ppunk = NULL;

    hr = S_OK;

Cleanup:
    RRETURN(hr);
}


//+------------------------------------------------------------------------
//
//  Member:     CloseErrorInfo
//
//  Synopsis:   defer to the collection cache
//
//-------------------------------------------------------------------------

HRESULT
CElementCollectionBase::CloseErrorInfo(HRESULT hr)
{
    return _pCollectionCache->CloseErrorInfo(hr);
}


//+------------------------------------------------------------------------
//
//  Member:     get_length
//
//  Synopsis:   collection object model, defers to Cache Helper
//
//-------------------------------------------------------------------------

HRESULT
CElementCollection::get_length(long * plSize)
{
    RRETURN(SetErrorInfo(_pCollectionCache->GetLength(_lIndex, plSize)));
}

//+------------------------------------------------------------------------
//
//  Member:     put_length
//
//  Synopsis:   collection object model, defers to Cache Helper
//
//-------------------------------------------------------------------------

HRESULT
CElementCollection::put_length(long lSize)
{
    RRETURN(SetErrorInfo(E_NOTIMPL));
}


//+------------------------------------------------------------------------
//
//  Member:     item
//
//  Synopsis:   collection object model
//
//-------------------------------------------------------------------------

HRESULT
CElementCollection::item(VARIANTARG var1, VARIANTARG var2, IDispatch** ppResult)
{
    RRETURN(SetErrorInfo(_pCollectionCache->Item(_lIndex, var1, var2, ppResult)));
}

//+------------------------------------------------------------------------
//
//  Member:     namedItem
//
//  Synopsis:   collection object model
//
//-------------------------------------------------------------------------

HRESULT
CElementCollection::namedItem(BSTR bstrName, IDispatch** ppResult)
{
    HRESULT hr;

    if (!bstrName || !*bstrName)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    VARIANT var1, var2;

    var1.vt = VT_BSTR;
    var1.bstrVal = bstrName;
    var2.vt = VT_EMPTY;

    hr = THR(_pCollectionCache->Item(_lIndex, var1, var2, ppResult));

Cleanup:
    RRETURN(SetErrorInfo( hr));
}

//+------------------------------------------------------------------------
//
//  Member:     tags
//
//  Synopsis:   collection object model, this always returns a collection
//              and is named based on the tag, and searched based on tagname
//
//-------------------------------------------------------------------------

HRESULT
CElementCollection::tags(VARIANT var1, IDispatch ** ppdisp)
{
    RRETURN(SetErrorInfo(_pCollectionCache->Tags(_lIndex, var1, ppdisp)));
}

HRESULT
CElementCollection::Tags(LPCTSTR szTagName, IDispatch ** ppdisp)
{
    RRETURN(_pCollectionCache->Tags(_lIndex, szTagName, ppdisp));
}

//+------------------------------------------------------------------------
//
//  Member:     urns
//
//  Synopsis:   collection object model, this always returns a collection
//              and is named based on the urn, and searched based on urn
//
//-------------------------------------------------------------------------

HRESULT
CElementCollection::urns(VARIANT var1, IDispatch ** ppdisp)
{
    RRETURN(SetErrorInfo(_pCollectionCache->Urns(_lIndex, var1, ppdisp)));
}

//+------------------------------------------------------------------------
//
//  Member:     Get_newEnum
//
//  Synopsis:   collection object model
//
//-------------------------------------------------------------------------

HRESULT
CElementCollection::get__newEnum(IUnknown ** ppEnum)
{
    RRETURN(SetErrorInfo(_pCollectionCache->GetNewEnum(_lIndex, ppEnum)));
}


//+------------------------------------------------------------------------
//
//  Member:     toString
//
//  Synopsis:   This is impplemented on all objects
//
//-------------------------------------------------------------------------

HRESULT
CElementCollection::toString(BSTR* String)
{
    RRETURN(super::toString(String));
};



//====================================================================
//
//  Class CCollectionCache Methods:
//
//====================================================================

//+------------------------------------------------------------------------
//
//  Member:     ~CCollectionCache
//
//  Synopsis:   Constructor
//
//-------------------------------------------------------------------------

CCollectionCache::CCollectionCache(
        CBase * pBase,
        CMarkup * pMarkup,
        PFN_CVOID_ENSURE pfnEnsure /* = NULL */,
        PFN_CVOID_CREATECOL pfnCreation /* = NULL */,
        PFN_CVOID_REMOVEOBJECT pfnRemove /* = NULL */,    
        PFN_CVOID_ADDNEWOBJECT pfnAddNewObject /* = NULL */ )
        :   _pBase(pBase), 
            _pfnEnsure(pfnEnsure),     
            _pfnRemoveObject(pfnRemove), 
            _lReservedSize(0),
            _pfnAddNewObject(pfnAddNewObject),
            _pMarkup(pMarkup),   
            _pfnCreateCollection(pfnCreation),
            _aryItems(Mt(CCollectionCache_aryItems_pv))
{
    Assert(pBase);  // Required.
}

//+------------------------------------------------------------------------
//
//  Member:     ~CCollectionCache
//
//  Synopsis:   Destructor
//
//-------------------------------------------------------------------------

CCollectionCache::~CCollectionCache()
{
    CacheItem * pce = _aryItems;
    UINT cSize = _aryItems.Size();

    for (; cSize--; ++pce)
    {
        delete pce->_pCacheItem;
    }
}


//+------------------------------------------------------------------------
//
//  Member:     Init
//
//  Synopsis:   Setup the cache.  This call is required if part of the
//              cache is to be reserved.
//
//-------------------------------------------------------------------------

HRESULT
CCollectionCache::InitReservedCacheItems(long lReservedSize, long lFromIndex /*= 0*/,
                       long lIdentityIndex  /*= -1*/)
{
    HRESULT hr = E_INVALIDARG;
    CacheItem * pce = NULL;
    long l = 0;
    long i;

    Assert ( lReservedSize > 0 );
    Assert ( lFromIndex <= lReservedSize && lFromIndex >= 0 );
    Assert ( lIdentityIndex == -1 || (lIdentityIndex >= 0 && lIdentityIndex < _lReservedSize ));

    // Clear the reserved part of the cache.

    hr = THR(_aryItems.EnsureSize(lReservedSize));
    if (hr)
        goto Cleanup;

    pce = _aryItems;

    memset(_aryItems, 0, lReservedSize * sizeof(CacheItem));
    _aryItems.SetSize(lReservedSize);

    // Reserved items always use the CCollectionCacheItem
    for ( l = lFromIndex, pce = _aryItems+lFromIndex  ; l < lReservedSize ; l++, ++pce)
    {
        pce->Init();
        pce->_pCacheItem = new CElementAryCacheItem ();
        if (pce->_pCacheItem == NULL)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }
        MemSetName((pce->_pCacheItem, "CacheItem"));
    }
    
    if (lIdentityIndex != -1 ) 
        _aryItems[lIdentityIndex].fIdentity = TRUE;

Cleanup:
    if (hr)
    {
        for (i=l-1, --pce ;i >= lFromIndex; i--, --pce)
        {
            delete pce->_pCacheItem;
        }
        _aryItems.SetSize(0);
    }
    else
    {
        _lReservedSize = lReservedSize;
    }
    RRETURN(hr);
}

HRESULT
CCollectionCache::InitCacheItem(long lCacheIndex, CCollectionCacheItem *pCacheItem)
{
    Assert ( pCacheItem );
    Assert ( lCacheIndex >= 0 && lCacheIndex < _aryItems.Size() );
    Assert ( !_aryItems [ lCacheIndex ]._pCacheItem ); // better not be initialized all ready

    _aryItems [ lCacheIndex ].Init();
    _aryItems [ lCacheIndex ]._pCacheItem = pCacheItem;

    return S_OK;
}

//+------------------------------------------------------------------------
//
//  Member:     UnloadContents
//
//  Synopsis : called when the contents of the cache need to be freed up
//      but the cache itself needs to stick around
//
//+------------------------------------------------------------------------
HRESULT
CCollectionCache::UnloadContents()
{
    long l;

    for (l = _aryItems.Size()-1; l>=0; l--)
    {
        _aryItems[l]._lCollectionVersion = 0;

        if (_aryItems[l]._pCacheItem)
            _aryItems[l]._pCacheItem->DeleteContents();
    }

    return S_OK;
}

//+------------------------------------------------------------------------
//
//  Member:     CreateCollectionHelper
//
//  Synopsis:   Wrapper for private member, if no CreateCollection function is
//      provided, default to creating a CElementCollectionBase. If a create function
//      IS provided, then the base object has a derived collection that it wants
//
//      This returns IDispatch because that is the form that the callers need
//---------------------------------------------------------------------------
HRESULT
CCollectionCache::CreateCollectionHelper(IDispatch ** ppIEC, long lIndex)
{
    HRESULT hr = S_OK;

    *ppIEC = NULL;

    if (_pfnCreateCollection)
    {
        hr = THR( CALL_METHOD( (CVoid *)(void *)_pBase, _pfnCreateCollection, (ppIEC, lIndex)));
    }
    else
    {
        CElementCollection *    pobj;

        pobj = new CElementCollection(this, lIndex);
        if (!pobj)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }

        hr = THR(pobj->QueryInterface(IID_IDispatch, (void **) ppIEC));
        pobj->Release();
        if (hr)
            goto Cleanup;
    }

Cleanup:
    RRETURN(hr);
}

//+------------------------------------------------------------------------
//
//  Member:     GetIntoAry
//
//  Synopsis:   Return the element at the specified index.
//
//-------------------------------------------------------------------------

HRESULT
CCollectionCache::GetIntoAry(
        long lIndex,
        long lIndexElement,
        CElement ** ppElem)
{
    if (lIndexElement >= _aryItems[lIndex]._pCacheItem->Length())
        RRETURN(DISP_E_MEMBERNOTFOUND);

    if (lIndexElement < 0)
        RRETURN(E_INVALIDARG);

    *ppElem = _aryItems[lIndex]._pCacheItem->GetAt (lIndexElement);

    return S_OK;
}

//+------------------------------------------------------------------------
//
//  Member:     GetIntoAry
//
//  Synopsis:   Return the index of the specified element.
//
//-------------------------------------------------------------------------

HRESULT
CCollectionCache::GetIntoAry(
        long lIndex,
        CElement * pElement,
        long * plIndexElement)
{
    CCollectionCacheItem    *pCacheItem = _aryItems[lIndex]._pCacheItem;
    CElement                *pElem;
    long                    lElemIndex = 0;
 
    Assert ( plIndexElement );

    *plIndexElement = -1;

    // Using GetNext() should be more efficient than using GetAt();
    pCacheItem->MoveTo( 0 );
    do
    {
        pElem = pCacheItem->GetNext();
        if ( pElem && pElem == pElement )
        {
            *plIndexElement = lElemIndex;
            break;
        }
        lElemIndex++;
    } while ( pElem );


    RRETURN(*plIndexElement == -1 ? DISP_E_MEMBERNOTFOUND : S_OK);
}

//+------------------------------------------------------------------------
//
//  Member:     GetIntoAry
//
//  Synopsis:   Return the element with a given name
//
//  Returns:    S_OK, if it found the element.  *ppNode is set
//              S_FALSE, if multiple elements w/ name were found.
//                  *ppNode is set to the first element in list.
//              Other errors.
//-------------------------------------------------------------------------

HRESULT
CCollectionCache::GetIntoAry(
        long lCollectionIndex,
        LPCTSTR Name,
        BOOL fTagName,
        CElement ** ppElem,
        long iStartFrom /* = 0*/,
        BOOL fCaseSensitive /* = FALSE */)
{
    HRESULT                 hr = S_OK;
    CElement *              pElemFirstMatched = NULL;
    CElement *              pElemLastMatched = NULL;
    CElement *              pElem;
    CCollectionCacheItem *  pCacheItem = _aryItems[lCollectionIndex]._pCacheItem;
    BOOL                    fLastOne = FALSE;

    Assert(ppElem);
    *ppElem = NULL;

    if (iStartFrom == -1)
    {
        iStartFrom = 0;
        fLastOne = TRUE;
    }

    for(pCacheItem->MoveTo( iStartFrom );;)
    {
        pElem = pCacheItem->GetNext();
        if ( !pElem )
            break;

        if ( CompareName( pElem, Name, fTagName, fCaseSensitive) )
        {
            if ( !pElemFirstMatched )
                pElemFirstMatched = pElem;
            pElemLastMatched = pElem;
        }
        
        if (pElem->Tag() == ETAG_OBJECT || pElem->Tag() == ETAG_APPLET)
        {
            CObjectElement *pObj = DYNCAST(CObjectElement, pElem);
            int l = pObj->_aryParams.Size();
            for (int i = 0;i < l; i++)
            {
                if (CompareName(pObj->_aryParams[i], Name, fTagName, fCaseSensitive))
                {
                    if (!pElemFirstMatched)
                        pElemFirstMatched = pObj->_aryParams[i];
                    pElemLastMatched = pObj->_aryParams[i];
                }
            }
        }
    }

    if ( !pElemLastMatched )
    {
        hr = DISP_E_MEMBERNOTFOUND;

        if (pCacheItem->IsRangeSyntaxSupported())
        {
            CCellRangeParser    cellRangeParser(Name);
            if(!cellRangeParser.Failed())
            {
                hr = S_FALSE;   // for allowing expando and properties/methods on the collection (TABLE_CELL_COLLECTION)
            }
        }

        goto Cleanup;
    }

    // A collection can be marked to always return the last matching name,
    // rather than the default first matching name.
    if ( DoGetLastMatchedName ( lCollectionIndex ) )
    {
        *ppElem = pElemLastMatched;
    }
    else
    {
        // The iStartFrom has higher precedence on which element we really
        // return first or last in the collection.
        *ppElem = fLastOne ? pElemLastMatched : pElemFirstMatched;
    }

    // return S_FALSE if we have more than one element that matced
    hr = (pElemFirstMatched == pElemLastMatched ) ? S_OK : S_FALSE;

Cleanup:
    RRETURN1(hr, S_FALSE);
}

// Invalid smart collections - one using the _fIsValid technique
void 
CCollectionCache::InvalidateAllSmartCollections(void)
{
    long l;
    for ( l = _aryItems.Size()-1 ; l >= 0 ; l-- )
    {
		_aryItems[l]._fIsValid = FALSE;
    }
}


// Invalidate "dump" collections - ones using old-style version management
void 
CCollectionCache::Invalidate(void)
{
    long l;
    for ( l = _aryItems.Size()-1 ; l >= 0 ; l-- )
    {
        _aryItems[l]._lCollectionVersion  = 0;
    }
}

//+------------------------------------------------------------------------
//
//  Member:     EnsureAry
//
//  Synopsis:   Make sure this index is ready for access.
//
//-------------------------------------------------------------------------

HRESULT
CCollectionCache::EnsureAry(long lIndex)
{
    HRESULT hr = S_OK;

    if (_pfnEnsure && lIndex < _lReservedSize)
    {
        // Ensure the reserved part of the collection
        hr = THR( CALL_METHOD( (CVoid *)(void *)_pBase, 
            _pfnEnsure, 
            (lIndex,&_aryItems[lIndex]._lCollectionVersion)));
        if (hr)
            goto Cleanup;
    }


    // Ensuring a dynamic collection, need to make sure all its dependent collections
    // are ensured
    if (lIndex >= _lReservedSize)
    {
        // Ensure the collection we're based upon
        // note that this is a recursove call
        hr = THR(EnsureAry(_aryItems[lIndex].sIndex));
        if (hr)
            goto Cleanup;

        // If we're a different version than the collection we're based upon, rebuild ourselves now
        if ( _aryItems[lIndex]._lCollectionVersion != 
            _aryItems[_aryItems[lIndex].sIndex]._lCollectionVersion )
        {
            switch (  _aryItems[lIndex].Type )
            {
            case CacheType_Tag:
                // Rebuild based on name
                hr = THR(BuildNamedArray(
                    _aryItems[lIndex].sIndex,
                    _aryItems[lIndex].cstrName,
                    TRUE,
                    _aryItems[lIndex]._pCacheItem,
                    0,
                    _aryItems[lIndex].fIsCaseSensitive));
                break;

            case CacheType_Named:
                // Rebuild based on tag name
                hr = THR(BuildNamedArray(
                    _aryItems[lIndex].sIndex,
                    _aryItems[lIndex].cstrName,
                    FALSE,
                    _aryItems[lIndex]._pCacheItem,
                    0,
                    _aryItems[lIndex].fIsCaseSensitive));
                break;

            case CacheType_Children:
            case CacheType_DOMChildNodes:
                // Rebuild all children
                hr = THR(BuildChildArray(
                    _aryItems[lIndex].sIndex,
                    _aryItems[lIndex].pElementBase,
                    _aryItems[lIndex]._pCacheItem,
                    FALSE));
                break;

            case CacheType_AllChildren:
                // Rebuild all children
                hr = THR(BuildChildArray(
                    _aryItems[lIndex].sIndex,
                    _aryItems[lIndex].pElementBase,
                    _aryItems[lIndex]._pCacheItem,
                    TRUE));
                break;

            case CacheType_CellRange:
                // Rebuild cells acollection
                hr = THR(BuildCellRangeArray(
                    _aryItems[lIndex].sIndex,
                    _aryItems[lIndex].cstrName,
                    &(_aryItems[lIndex].rectCellRange),
                    _aryItems[lIndex]._pCacheItem));
                break;

            case CacheType_FreeEntry:
                // Free collection waiting to be reused
                break;

            case CacheType_Urn:
                hr = THR(BuildNamedArray(
                    _aryItems[lIndex].sIndex,
                    _aryItems[lIndex].cstrName,
                    TRUE,
                    _aryItems[lIndex]._pCacheItem,
                    0,
                    _aryItems[lIndex].fIsCaseSensitive,
                    TRUE));
                break;

            default:
                Assert(0);
                break;
            }
        }
        _aryItems[lIndex]._lCollectionVersion = 
            _aryItems[_aryItems[lIndex].sIndex]._lCollectionVersion;
    }

Cleanup:
    RRETURN(hr);
}


//+------------------------------------------------------------------------
//
//  Member:     ClearDisp
//
//  Synopsis:   Clear the reference to this dispatch ptr out of the cache.
//
//              At this point,  any reference that the disp (collection)
//                may have (due to being a named collection) on other collections
//
//-------------------------------------------------------------------------

HRESULT
CCollectionCache::ClearDisp(long lIndex)
{
    Assert ( lIndex >= 0 && lIndex <_aryItems.Size() );

    // Find the collection in the cache & clear it down
    _aryItems[lIndex].pdisp = NULL;
    // Mark it as free
    _aryItems[lIndex].Type = CacheType_FreeEntry;

    if ( lIndex >= _lReservedSize )
    {
        if (_aryItems[lIndex]._pCacheItem)
        {
            short sDepend;

            delete _aryItems[lIndex]._pCacheItem;
            _aryItems[lIndex]._pCacheItem = NULL;

            sDepend = _aryItems[lIndex].sIndex;
            if (sDepend >= _lReservedSize)
            {
                _aryItems[sDepend].pdisp->Release();
            }
        }
        _aryItems[lIndex].cstrName.Free();
    }
    return S_OK;
}

///////////////////////////////////////////////////////////////////////////}


//+------------------------------------------------------------------------
//
//  Member:     GetDisp
//
//  Synopsis:   Get a dispatch ptr from the RESERVED part of the cache.
//              If fIdentity is not set, then everything works as planned.
//              If set, then we QI the base Object and return that
//
//-------------------------------------------------------------------------

HRESULT
CCollectionCache::GetDisp(long lIndex, IDispatch ** ppdisp)
{
    CacheItem * pce;

    Assert((lIndex >= 0) && (lIndex < _aryItems.Size()));

    HRESULT hr = S_OK;

    *ppdisp = NULL;

    pce = &_aryItems[lIndex];

    // if not identity and there is a colllection, addref and return it
    if (!pce->fIdentity)
    {
        if (pce->pdisp)
            pce->pdisp->AddRef();
        else
        {
            IDispatch * pdisp;

            hr = THR(CreateCollectionHelper(&pdisp, lIndex));
            if (hr)
                goto Cleanup;

            //We're not dependant on any other collection
            pce = &_aryItems[lIndex];
            pce->pdisp = pdisp;
            pce->sIndex = -1;
        }

        *ppdisp = pce->pdisp;
    }
    else
        hr = THR_NOTRACE(DYNCAST(CElement, _pBase)->QueryInterface(
                    IID_IDispatch,
                    (void**) ppdisp));

Cleanup:
    RRETURN(hr);
}

// Find pElement in the lIndex base Collection
HRESULT 
CCollectionCache::CreateChildrenCollection(long lCollectionIndex, 
    CElement *pElement, 
    IDispatch **ppDisp,
    BOOL fAllChildren,
    BOOL fDOMCollection)
{
    CacheItem *             pce;
    long                    lSize = _aryItems.Size(),l;
    HRESULT                 hr = S_OK;
    CollCacheType Type = fAllChildren ? 
            CacheType_AllChildren :
            (fDOMCollection) ? CacheType_DOMChildNodes
                             : CacheType_Children;

    Assert (ppDisp);
    *ppDisp = NULL;

    hr = THR(EnsureAry(lCollectionIndex));
    if (hr)
        goto Cleanup;

    // Try and locate an exiting collection
    pce = &_aryItems[_lReservedSize];

    // Return this named collection if it already exists.
    for (l = _lReservedSize; l < lSize; ++l, ++pce)
    {
        if ( pce->Type == Type && 
             pElement == pce->pElementBase )
        {
            pce->pdisp->AddRef();
            *ppDisp = pce->pdisp;
            goto Cleanup;
        }
    }

    // Didn't find it, create a new collection

    hr = THR(GetFreeIndex(&l));  // always returns Idx from non-reserved part of cache
    if (hr)
        goto Cleanup;

    hr = THR(CreateCollectionHelper(ppDisp, l));
    if (hr)
        goto Cleanup;

    pce = &_aryItems[l];
    pce->Init();

    Assert (!pce->_pCacheItem);
    pce->_pCacheItem = new CElementAryCacheItem();
    if ( !pce->_pCacheItem )
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    hr = THR(BuildChildArray (lCollectionIndex, pElement, pce->_pCacheItem, fAllChildren ));
    if ( hr )
        goto Cleanup;

    pce->pElementBase = pElement;
    pce->pdisp = *ppDisp;

    pce->sIndex = lCollectionIndex;       // Remember the index we depend on.
    pce->Type = Type;
    
Cleanup:
    RRETURN(hr);
}



//+------------------------------------------------------------------------
//
//  Member:     GetDisp
//
//  Synopsis:   Get a dispatch ptr from the NON-RESERVED part of the cache.
//              N.B. non-reserved can never be identity collecitons,
//
//-------------------------------------------------------------------------

HRESULT
CCollectionCache::GetDisp(
        long lIndex,
        LPCTSTR Name,
        CollCacheType  CacheType,
        IDispatch ** ppdisp,
        BOOL fCaseSensitive /*= FALSE */,
        RECT *pRect /* = NULL */,
        BOOL fAlwaysCollection /* = FALSE */)
{
    CPtrAry<CElement *> *   paryNamed = NULL;
    long                    lSize = _aryItems.Size();
    long                    l;
    HRESULT                 hr = S_OK;
    CacheItem             * pce;
    CRect                   rectCellRange(CRect::CRECT_EMPTY);

    // named arrays are always built into an AryCacheItem
    CElementAryCacheItem           aryItem;

    Assert(CacheType == CacheType_Tag || 
           CacheType == CacheType_Named || 
           CacheType == CacheType_CellRange ||
           CacheType == CacheType_Urn);

    typedef int ( *COMPAREFN)( LPCTSTR, LPCTSTR );
    COMPAREFN CompareFn = fCaseSensitive ? FormsStringCmp : FormsStringICmp;

    *ppdisp = NULL;

    pce = &_aryItems[_lReservedSize];

    // Return this named collection if it already exists.
    for (l = _lReservedSize; l < lSize; ++l, ++pce)
    {
        if(pce->Type == CacheType && lIndex == pce->sIndex && 
             pce->fIsCaseSensitive == (unsigned)fCaseSensitive &&
                            !CompareFn(Name, (BSTR) pce->cstrName))
        {
            pce->pdisp->AddRef();
            *ppdisp = pce->pdisp;
            goto Cleanup;
        }
    }

    // Build the list
    if(CacheType != CacheType_CellRange)
        hr = THR(BuildNamedArray(lIndex, Name, CacheType == CacheType_Tag, 
            &aryItem, 0, fCaseSensitive, CacheType == CacheType_Urn ));
    else
    {           
        if(!pRect)
            // Mark the rect as empty
            rectCellRange.right = -1;
        else
            // Use the passed in rect
            rectCellRange = *pRect;
        hr = THR(BuildCellRangeArray(lIndex, Name, &rectCellRange, &aryItem));
    }

    if (hr)
        goto Cleanup;

    // Return based on what the list of named elements looks like.
    if (!aryItem.Length() && !((CacheType == CacheType_Tag) || (CacheType == CacheType_Urn) || fAlwaysCollection))
    {
        hr = DISP_E_MEMBERNOTFOUND;
        goto Error;
    }
    // The tags method ALWAYS should return a collection (else case)
    else if (aryItem.Length() == 1 && !((CacheType == CacheType_Tag) || (CacheType == CacheType_Urn) || fAlwaysCollection))
    {
        CElement *pElem = aryItem.GetAt ( 0 );
        hr = THR(pElem->QueryInterface(IID_IDispatch, (void **) ppdisp));
        // Keep the ppdisp around we'll return that and just release the array.
        goto Cleanup2;
    }
    else
    {
        CElementAryCacheItem *pAryItem;

        hr = THR(GetFreeIndex(&l));  // always returns Idx from non-reserved part of cache
        if (hr)
            goto Error;

        hr = THR(CreateCollectionHelper(ppdisp, l ));
        if (hr)
            goto Error;

        pce = &_aryItems[l];
        pce->Init();

        hr = THR(pce->cstrName.Set(Name));
        if (hr)
            goto Error;

        Assert (!pce->_pCacheItem);
        pce->_pCacheItem = new CElementAryCacheItem();
        if ( !pce->_pCacheItem )
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }

        // Copy the array. 
        // For perf reasons assume that the destination collection is a 
        // ary cache - which it is for now, by design
        //
        pAryItem = DYNCAST(CElementAryCacheItem, pce->_pCacheItem);
        pAryItem->CopyAry ( &aryItem ); // this just copies the ptrarray _pv across

        pce->pdisp = *ppdisp;
        pce->sIndex = lIndex;       // Remember the index we depend on.
        pce->Type = CacheType;
        pce->fIsCaseSensitive = fCaseSensitive;

        // Save the range for the cell range type cache so we do not need to parse
        //  the name later
        if(CacheType == CacheType_CellRange)
            pce->rectCellRange = rectCellRange;

        // The collection this named collection was built from is now
        // used to rebuild (ensure) this collection. so we need to
        // put a reference on it so that it will not go away and its
        // location re-assigned by another call to GetFreeIndex.
        // The matching Release() will be done in the dtor
        // although it is not necessary to addref the reserved collections
        //  it is done anyhow, simply for consistency.  This addref
        // only needs to be done for non-reserved collections

        if (lIndex >= _lReservedSize)
        {
            _aryItems[lIndex].pdisp->AddRef();
        }
    }

Cleanup:
    RRETURN(hr);

Error:
    ClearInterface(ppdisp);

Cleanup2:
    delete paryNamed;
    goto Cleanup;
}


//+------------------------------------------------------------------------
//
//  Member:     GetDisp
//
//  Synopsis:   Get a dispatch ptr on an element from the cache.
//
//-------------------------------------------------------------------------

HRESULT
CCollectionCache::GetDisp(long lIndex, long lIndexElement, IDispatch ** ppdisp)
{
    CElement *pElem;

    Assert((lIndex >= 0) && (lIndex < _aryItems.Size()));

    *ppdisp = NULL;

    if (lIndexElement >= _aryItems[lIndex]._pCacheItem->Length())
        RRETURN(DISP_E_MEMBERNOTFOUND);

    if (lIndexElement<0)
        RRETURN(E_INVALIDARG);

    pElem = _aryItems [ lIndex ]._pCacheItem->GetAt( lIndexElement );
    Assert(pElem );

    RRETURN(THR(pElem->QueryInterface(IID_IDispatch, (void **)ppdisp)));
}


//+------------------------------------------------------------------------
//
//  Member:     GetDisp
//
//  Synopsis:   Get a dispatch ptr on an element from the cache.
//      Return the nth element that mathces the name
//
//-------------------------------------------------------------------------

HRESULT
CCollectionCache::GetDisp(
        long lIndex,
        LPCTSTR Name,
        long lNthElement,
        IDispatch ** ppdisp,
        BOOL fCaseSensitive )
{
    long                    lSize,l;
    HRESULT                 hr = DISP_E_MEMBERNOTFOUND;
    CCollectionCacheItem *  pItem;
    CElement *              pElem;

    Assert((lIndex >= 0) && (lIndex < _aryItems.Size()));
    Assert(ppdisp);

    pItem = _aryItems[lIndex]._pCacheItem;

    *ppdisp = NULL;

    // if lIndexElement is too large, just pretend we
    //  didn't find it rather then erroring out
    if (lNthElement < 0 )
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    lSize = pItem->Length();

    if (lNthElement >= lSize)
        goto Cleanup;

    for (l = 0; l < lSize; ++l)
    {
        pElem = pItem->GetAt(l);
        Assert(pElem);
        if (CompareName(pElem, Name, FALSE, fCaseSensitive) && !lNthElement--)
            RRETURN(THR(pElem->QueryInterface(IID_IDispatch, (void **) ppdisp)));
    }

Cleanup:
    RRETURN(hr);
}


//+------------------------------------------------------------------------
//
//  Member:     GetFreeIndex
//
//  Synopsis:   Get a free slot from the NON-RESERVED part of the cache.
//
//-------------------------------------------------------------------------

HRESULT
CCollectionCache::GetFreeIndex(long * plIndex)
{
    CacheItem * pce;
    long    lSize = _aryItems.Size();
    long    l;
    HRESULT hr = S_OK;

    pce = &_aryItems[_lReservedSize];

    // Look for a free slot in the non-reserved part of the cache.
    for (l = _lReservedSize; l < lSize; ++l, ++pce)
    {
        if (pce->Type == CacheType_FreeEntry)
        {
            Assert (!pce->pdisp);
            *plIndex = l;
            goto Cleanup;
        }
    }

    // If we failed to find a free slot then grow the cache by one.
    hr = THR(_aryItems.EnsureSize(l + 1));
    if (hr)
        goto Cleanup;
    _aryItems.SetSize(l + 1);

    pce = &_aryItems[l];

    memset(pce, 0, sizeof(CacheItem));
    pce->fOKToDelete = TRUE;

    *plIndex = lSize;

Cleanup:
    RRETURN(hr);
}


//+------------------------------------------------------------------------
//
//  Member:     CompareName
//
//  Synopsis:   Compares a bstr with an element, either by name rules or
//              as a tagname.
//
//-------------------------------------------------------------------------


BOOL
CCollectionCache::CompareName(CElement * pElement, LPCTSTR Name, 
                              BOOL fTagName, 
                              BOOL fCaseSensitive /* = FALSE */ )
{
    BOOL    fCompare;
    typedef int ( *COMPAREFN)( LPCTSTR, LPCTSTR );
    COMPAREFN CompareFn = fCaseSensitive ? FormsStringCmp : FormsStringICmp;

    if (fTagName)
    {
        fCompare = !CompareFn(Name, pElement->TagName());
    }
    else if ( pElement->IsNamed() )
    {
        BOOL fHasName;
        LPCTSTR pchId = pElement->GetAAname();

        // do we have a name
        fHasName = !!(pchId);

        fCompare = pchId ? !CompareFn(Name, pchId) : FALSE;
        if (!fCompare)
        {
            pchId = pElement->GetAAid();
            fCompare = pchId ? !CompareFn(Name, pchId) : FALSE;
        }

        if (!fCompare)
        {
            pchId = pElement->GetAAuniqueName();
            fCompare = pchId ? !CompareFn(Name, pchId) : FALSE;
        }
    }
	else
		fCompare = FALSE;

    return fCompare;
}

HRESULT 
CCollectionCache::BuildChildArray( 
    long lCollectionIndex, // Index of collection on which this child collection is based
    CElement* pRootElement,
    CCollectionCacheItem *pIntoCacheItem,
    BOOL fAll )
{
    long                    lSize;
    HRESULT                 hr = S_OK;
    long                    lSourceIndex;
    CCollectionCacheItem *  pFromCacheItem;
    CElement *              pElem;
    CTreeNode *             pNode;

    Assert(lCollectionIndex >=0 && lCollectionIndex < _aryItems.Size());
    Assert(pIntoCacheItem );
    Assert(pRootElement);

    pFromCacheItem = _aryItems[lCollectionIndex]._pCacheItem;

    // 
    // NOTE rgardner - about this fn & the "assert(lCollectionIndex==0)"
    // As a result this fn is not very generic. This assert also assumes that
    // we're item 0 in the all collection. However, this is currently the only situation
    // this fn is called, and making the assumption optimizes the code
    //

    Assert(lCollectionIndex==0); 

    pIntoCacheItem->ResetContents();

    // Didn't find it, create a new collection
    lSourceIndex = pRootElement->GetSourceIndex();
    // If we are outside the tree return
    if(lSourceIndex < 0)
        goto Cleanup;

    lSize = pFromCacheItem->Length();

    if (lSourceIndex >= lSize)
    {
        // This should never happen
        // No match - Return error 
        Assert(0);
        hr = E_UNEXPECTED;
        goto Cleanup;
    }
    
   
    // Now locate all the immediate children of the element and add them to the array
    for (;;)
    {
        pElem = pFromCacheItem->GetAt(++lSourceIndex) ;
        if ( !pElem )
            break;
        pNode = pElem->GetFirstBranch();
        Assert(pNode);
        // optimize search to spot when we go outside scope of element
        if (!pNode->SearchBranchToRootForScope ( pRootElement ))
        {
            // outside scope of element
            break;
        }
        // If the fall flag is on it means all direct descendants
        // Otherwise it means only immediate children
        if ( fAll || ( pNode->Parent() && 
            pNode->Parent()->Element() == pRootElement ))
        {
            pIntoCacheItem->AppendElement(pElem);
        }
    }
Cleanup:
    RRETURN(hr);
}


//+------------------------------------------------------------------------
//
//  Member:     BuildNamedArray
//
//  Synopsis:   Fills in an array based on names found in the array of the
//              given index.
//              If we are building a named array on the ELEMENT_COLLECTION
//              we check if we have already created a collection of all
//              named elements, if not, we build it, if yes, we use this
//              collection to access all named elements
//
//  Result:     S_OK
//              E_OUTOFMEMORY
//
//  Note: It is now the semantics of this function to always return a
//        named array (albeit with a size of 0) instead of returning
//        DISPID_MEMBERNOTFOUND.  This allows for Tags to return an empty
//        collection.
//-------------------------------------------------------------------------

HRESULT
CCollectionCache::BuildNamedArray(
        long lCollectionIndex,
        LPCTSTR Name,
        BOOL fTagName,
        CCollectionCacheItem *pIntoCacheItem,
        long iStartFrom,
        BOOL fCaseSensitive,
        BOOL fUrn /* = FALSE */)
{
    HRESULT                 hr = S_OK;
    CElement *              pElem;
    CCollectionCacheItem *  pFromCacheItem;
    BOOL                    fAddElement;

    Assert ( lCollectionIndex >=0 && lCollectionIndex < _aryItems.Size() );
    Assert ( pIntoCacheItem );

    pFromCacheItem = _aryItems[lCollectionIndex]._pCacheItem;
    pIntoCacheItem->ResetContents(); 


    for ( pFromCacheItem->MoveTo( iStartFrom ) ;; ) 
    {
        pElem = pFromCacheItem->GetNext();
        if ( !pElem )
            break;

        if (fTagName && (pElem->Tag() == ETAG_OBJECT || pElem->Tag() == ETAG_APPLET))
        {
            CObjectElement *pObj = DYNCAST(CObjectElement, pElem);
            int l = pObj->_aryParams.Size();
            if (l && !FormsStringICmp(Name, _T("PARAM")))
            {
                for (int i = 0;i < l; i++)
                {
                    hr = THR(pIntoCacheItem->AppendElement(pObj->_aryParams[i]));
                    if (hr)
                        goto Cleanup;
                }
                continue;
            }
        }

        if (fUrn)
        {
            // 'Name' is the Urn we are looking for.  Check if this element has the requested Urn
            fAddElement = pElem->HasPeerWithUrn(Name);
        }
        else if ( CompareName( pElem, Name, fTagName, fCaseSensitive) )
        {
            fAddElement = TRUE;
        }
        else
            fAddElement = FALSE;

        if (fAddElement)
        {
            hr = THR(pIntoCacheItem->AppendElement(pElem));
            if (hr)
                goto Cleanup;
        }
    } 

Cleanup:
    RRETURN(hr);
}


//+------------------------------------------------------------------------
//
//  Member:     BuildCellRangeArray
//
//  Synopsis:   Fills in an array based on range of cells found in the array of the
//              given index.
//              We first check if we have already created a collection of all
//              cells, if not, we build it, if yes, we use this collection to access 
//              all cells
//
//  Result:     S_OK
//              E_OUTOFMEMORY
//
//  Note: It is now the semantics of this function to always return a
//        named array (albeit with a size of 0) instead of returning
//        DISPID_MEMBERNOTFOUND.  This allows us to return an empty
//        collection.
//-------------------------------------------------------------------------

HRESULT
CCollectionCache::BuildCellRangeArray(long lCollectionIndex, LPCTSTR szRange, 
                             RECT *pRect,  CCollectionCacheItem *pIntoCacheItem )
{
    CCollectionCacheItem *  pFromCacheItem;
    HRESULT                 hr = S_OK;
    CTableCell            * pCell;
    CElement *              pElem;

    Assert(pRect);
    Assert(lCollectionIndex >=0 && lCollectionIndex < _aryItems.Size());
    Assert(pIntoCacheItem );

    pFromCacheItem = _aryItems[lCollectionIndex]._pCacheItem;

    if(pRect->right == -1)
    {
        // The rect is empty, parse it from the string
        CCellRangeParser        cellRangeParser(szRange);
        if(cellRangeParser.Failed())
        {
            hr = E_INVALIDARG;
            goto Cleanup;
        }
        cellRangeParser.GetRangeRect(pRect);
    }

    pIntoCacheItem->ResetContents();

    // Build a list of cells in the specified range
    for ( pFromCacheItem->MoveTo(0);; )
    {
        pElem = pFromCacheItem->GetNext();
        if ( !pElem )
            break;
        if (pElem->Tag() != ETAG_TD && pElem->Tag() != ETAG_TH)
            break;
        pCell = DYNCAST(CTableCell, pElem);
        if (pCell->IsInRange(pRect))
        {
            hr = THR(pIntoCacheItem->AppendElement(pElem));
            if (hr)
                goto Cleanup;
        }
    }
Cleanup:
    RRETURN(hr);
}


//+---------------------------------------------------------------------------
//
//  Member:     CCollectionCache::GetIDsOfNames
//
//  Synopsis:   Helper to support the following syntax
//
//                  Document.TextBox1.Text = "abc"
//
//----------------------------------------------------------------------------

HRESULT
CCollectionCache::GetIDsOfNames(
        long        lCollectionIndex,
        REFIID      iid,
        TCHAR **    rgszNames,
        UINT        cNames,
        LCID        lcid,
        DISPID *    rgdispid)
{
    // Call GetDispID with CaseSensitive flag set to 0
    RRETURN(GetDispID(lCollectionIndex,
                      rgszNames[0], 
                      fdexFromGetIdsOfNames,
                      rgdispid));
}

//+---------------------------------------------------------------------------
//
//  Member:     CCollectionCache::Invoke
//
//  Synopsis:   Helper to support the following syntax
//
//                  Document.TextBox1.Text = "abc"
//
//----------------------------------------------------------------------------

HRESULT
CCollectionCache::Invoke(
        long            lCollectionIndex,
        DISPID          dispid,
        REFIID          iid,
        LCID            lcid,
        WORD            wFlags,
        DISPPARAMS *    pdispparams,
        VARIANT *       pvarResult,
        EXCEPINFO *     pexcepinfo,
        UINT *          puArgErr,
        RETCOLLECT_KIND returnCollection /* = RETCOLLECT_ALL */  )
{
    HRESULT     hr=E_FAIL;
    IDispatch * pDisp = NULL;
    LPCTSTR pch = NULL;

    hr = THR(EnsureAry(lCollectionIndex));
    if (hr)
        goto Cleanup;


    // Is the dispid a collection ordinal index?
    if (IsOrdinalCollectionMember ( lCollectionIndex, dispid ))
    {
        if ( wFlags & DISPATCH_PROPERTYPUT )
        {
            if ( !_pfnAddNewObject )
            {
                hr = E_INVALIDARG;
                goto Cleanup;
            }
            if ( ! (pdispparams && pdispparams->cArgs == 1) )
            {
                // No result type we need one for the get to return.
                hr = DISP_E_MEMBERNOTFOUND;
                goto Cleanup;
            }
            // Only allow VARIANT of type IDispatch to be put
            if ( pdispparams->rgvarg[0].vt == VT_NULL )
            {
                // the options collection is special. it allows
                // options[n] = NULL to be specified. in this case
                // map the invoke to a delete on that appropriate index
                if (_aryItems[lCollectionIndex].fSettableNULL)
                {
                    hr = THR(Remove(lCollectionIndex, 
                                    dispid - GetOrdinalMemberMin(lCollectionIndex)));
                    // Like Nav - silently ignore the put if its's outside the current range
                    if ( hr == E_INVALIDARG )
                        hr = S_OK;
                }
                else
                {
                    hr = E_INVALIDARG;
                }

                goto Cleanup;
            }
            else if ( pdispparams->rgvarg[0].vt != VT_DISPATCH )
            {
                hr = E_INVALIDARG;
                goto Cleanup;
            }
            // All OK, let the collection cache validate the Put
            hr = THR ( CALL_METHOD( (CVoid *)(void *)_pBase, _pfnAddNewObject, ( 
                    lCollectionIndex, 
                    V_DISPATCH ( pdispparams->rgvarg ), 
                    dispid - GetOrdinalMemberMin(lCollectionIndex) )));

            if ( hr )
                goto Cleanup;
        }
        else if ( wFlags & DISPATCH_PROPERTYGET )
        {
            VARIANTARG      v1, v2;
            long lIdx = dispid - GetOrdinalMemberMin(lCollectionIndex);

            if ( ! ( (lIdx >= 0) && (lIdx < SizeAry(lCollectionIndex)) ) )
            {
                hr = S_OK;
                if ( pvarResult )
                {
                    VariantClear(pvarResult);
                    pvarResult->vt = VT_NULL;
                    hr = S_OK;
                    goto Cleanup;
                }
            }

            v1.vt = VT_I4;
            v1.lVal = lIdx;

            // Always get the item by index.
            v2.vt = VT_ERROR;

            if (pvarResult)
            {
                hr = Item(lCollectionIndex, v1, v2, &(pvarResult->pdispVal));
                if (!hr)
                {
                    if (!(pvarResult->pdispVal))
                    {
                        hr = E_FAIL;        // use super::Invoke
                    }
                    else
                    {
                        pvarResult->vt = VT_DISPATCH;
                    }
                }
            }
        }
    }
    else if(IsNamedCollectionMember(lCollectionIndex, dispid))
    {
        BOOL        fCaseSensitive;
        long        lOffset;

        lOffset = GetNamedMemberOffset(lCollectionIndex, dispid, &fCaseSensitive);

        hr = THR(GetAtomTable()->GetNameFromAtom(dispid - lOffset, &pch));
        if (hr)
            goto Cleanup;

        if ( returnCollection == RETCOLLECT_ALL && !DoGetLastMatchedName(lCollectionIndex))
        {
            // GetDisp can return a disp ptr to a collection if name matches more than one item
            hr = THR_NOTRACE(GetDisp(
                lCollectionIndex,
                pch,
                CacheType_Named,
                &pDisp,
                fCaseSensitive));
            if (FAILED(hr))
            {
                hr = THR_NOTRACE(GetDisp(
                    lCollectionIndex,
                    pch,
                    CacheType_CellRange,
                    &pDisp,
                    fCaseSensitive));
            }
        }
        else 
        {
            CElement * pElementTemp;
            long lIndex = (returnCollection == RETCOLLECT_LASTITEM) ? -1 : 0;

            // Here GetIntoAry will only return the first/last item that matches the name
            hr = THR_NOTRACE(GetIntoAry(
                    lCollectionIndex,
                    pch,
                    FALSE,
                    &pElementTemp,
                    lIndex,
                    fCaseSensitive));
            if (hr && hr != S_FALSE)
                goto Cleanup;

            hr = THR(pElementTemp->QueryInterface(IID_IDispatch, (void **)&pDisp));
            if (hr)
                goto Cleanup;
        }

        if(hr)
            goto Cleanup;
        //
        //  Special handling for controls accessed as members
        //

        if (wFlags == DISPATCH_PROPERTYGET ||
            wFlags == (DISPATCH_METHOD | DISPATCH_PROPERTYGET))
        {
            if (!pvarResult)
            {
                hr = E_POINTER;
                goto Cleanup;
            }

            // cArgs==1 when Doc.foo(0) is used and =0 when Doc.foo.count
            //  this is only an issue when there are multiple occurances
            //  of foo, and a collection is supposed to be returned by
            //  document.foo
            if (pdispparams->cArgs > 1)
            {
                hr = DISP_E_BADPARAMCOUNT;
                goto Cleanup;
            }
            else  if (pdispparams->cArgs == 1)
            {
                hr = THR(pDisp->Invoke(
                        DISPID_VALUE,
                        iid,
                        lcid,
                        wFlags,
                        pdispparams,
                        pvarResult,
                        pexcepinfo,
                        puArgErr));
            }
            else
            {
                V_VT(pvarResult) = VT_DISPATCH;
                V_DISPATCH(pvarResult) = pDisp;
                pDisp->AddRef();
            }
        }
        else if (wFlags == DISPATCH_PROPERTYPUT ||
            wFlags == DISPATCH_PROPERTYPUTREF)
        {
            if (pdispparams->cArgs != 1)
            {
                hr = DISP_E_BADPARAMCOUNT;
                goto Cleanup;
            }

            hr = THR(pDisp->Invoke(
                    DISPID_VALUE,
                    iid,
                    lcid,
                    wFlags,
                    pdispparams,
                    pvarResult,
                    pexcepinfo,
                    puArgErr));
        }
        else
        {
            // Any other kind of invocation is not valid.
            hr = DISP_E_MEMBERNOTFOUND;
        }
    }
    else
    {
        Assert(FALSE);
    }
Cleanup:
    ReleaseInterface(pDisp);
    RRETURN_NOTRACE(hr);
}


//+---------------------------------------------------------------------------
//
//  Member:     CCollectionCache::GetDispID, IDispatchEx
//
//  Synopsis:   Support insuring if the name is an index into the collection
//              or passing off to property/expando support.
//
//  Note:       If the name is not known index, property or expando in the
//              collection the returned dispid is DISPID_UNKNOWN with a result
//              of S_OK.  Then on the invoke if DISPID_UNKNOWN is encountered
//              we'll return VT_EMPTY.  This allow VBScript/JavaScript to test
//              isnull( ) or comparision to null.
//
//----------------------------------------------------------------------------

HRESULT
CCollectionCache::GetDispID(long lIndex, BSTR bstrName, DWORD grfdex, DISPID *pid)
{
    HRESULT     hr = E_FAIL;
    long        lIdx = 0;
    long        lAtom;
    CElement * pNode;

    // Could the name be an index.  We check for index first, index for a
    // collection object takes precidence over expando.  As a result if an
    // expando "5" exist then the collection grows to have an item 5 we'll find
    // item and not the expando "5".  If the collection item 5 is removed then
    // we'd find the expando 5.  In addtion we'll allow [""] to index item 0 of
    // the collection.

    // Insure the string is really a number.
    hr = ttol_with_error(bstrName, &lIdx);
    if (!hr)
    {
        // Try to map name to a named element in the collection.
        // Ignore it if we're not promoting ordinals
        if ( !CanPromoteOrdinals (lIndex ) )
        {
            hr = DISP_E_UNKNOWNNAME;
            goto Cleanup;
        }

        if ( _pfnAddNewObject )
        {
            // The presence of _pfnAddNewObject indicates that the collection
            // allows setting to arbitrary indices. Expando on the collection
            // is not allowed.
            *pid = GetOrdinalMemberMin(lIndex)+lIdx;
            if (*pid > GetOrdinalMemberMax(lIndex) )
            {
                hr = DISP_E_UNKNOWNNAME;
            }
            goto Cleanup;
        }
        else
        {
            // Without a _pfnAddNewObject, the collection only supports
            // access to ordinals in the current range. Other accesses
            // become expando.
            hr = THR(EnsureAry(lIndex));
            if (hr)
                goto Cleanup;

            if ( (lIdx >= 0) && (lIdx < SizeAry(lIndex)) )
            {
                *pid = GetOrdinalMemberMin(lIndex)+lIdx;
                if (*pid > GetOrdinalMemberMax(lIndex) )
                {
                    hr = DISP_E_UNKNOWNNAME;
                }
            }
            else
            {
                hr = DISP_E_UNKNOWNNAME;
            }
        }
    }
    else
    {
        long        lMax;
        BOOL        fCaseSensitive;

        // If we don't promote named items - nothing more to do
        if ( !CanPromoteNames(lIndex)  )
        {
            hr = DISP_E_UNKNOWNNAME;
            goto Cleanup;
        }

        hr = THR(EnsureAry(lIndex));
        if (hr)
            goto Cleanup;

        Assert ( _aryItems[lIndex].dispidMin != 0 );
        Assert ( _aryItems[lIndex].dispidMax != 0 );

        fCaseSensitive = ( grfdex & fdexNameCaseSensitive ) != 0;
        //
        // Search the collection for the given name
        //

        hr = THR_NOTRACE(GetIntoAry(
                lIndex,
                bstrName,
                FALSE,
                &pNode, 
                0,
                fCaseSensitive));
        if (FAILED(hr))
        {
            hr = DISP_E_UNKNOWNNAME;
            goto Cleanup;
        }

        //
        // Since we found the element in the elements collection,
        // update atom table.
        //
        Assert(bstrName);
        hr = THR(GetAtomTable()->AddNameToAtomTable(bstrName, &lAtom));
        if (hr)
            goto Cleanup;
        //
        // lAtom is the index into the atom table.  Offset this by
        // base.
        //
        if(fCaseSensitive)
        {
            lAtom += GetSensitiveNamedMemberMin(lIndex);
            lMax = GetSensitiveNamedMemberMax(lIndex);
        }
        else
        {
            lAtom += GetNotSensitiveNamedMemberMin(lIndex);
            lMax = GetNotSensitiveNamedMemberMax(lIndex);
        }

        *pid = lAtom;
        if (*pid > lMax)
        {
            hr = DISP_E_UNKNOWNNAME;
        }
    }

Cleanup:
    RRETURN(hr);
}


//+---------------------------------------------------------------------------
//
//  Member:     CCollectionCache::GetNextDispID, IDispatchEx
//
//  Synopsis:   Supports enumerating through all properties, attributes,
//              expandos, and indexes (numbers and names) of a collection.
//
//----------------------------------------------------------------------------
HRESULT
CCollectionCache::GetNextDispID(
                long lIndex,
                DWORD grfdex,
                DISPID id,
                DISPID *prgid)
{
    HRESULT     hr = S_FALSE;
    long        lItmIndex;

    // Enumerating the indexes then enumerate each index of the collection.

    if (IsOrdinalCollectionMember (lIndex, id))
    {
        lItmIndex = id - GetOrdinalMemberMin(lIndex) + 1;

        // Make sure our collection is up-to-date.
        hr = THR(EnsureAry(lIndex));
        if (hr)
            goto Error;

        // Is the number within range for an item in the collection?
        if (lItmIndex < 0 || (lItmIndex >= SizeAry(lIndex)))
            goto Error;

        *prgid = GetOrdinalMemberMin(lIndex) + lItmIndex;

        // Is the index too large?
        if (*prgid > GetOrdinalMemberMax(lIndex) )
            goto Error;
    }

Cleanup:
    RRETURN1(hr, S_FALSE);

Error:
    hr = S_FALSE;
    *prgid = DISPID_UNKNOWN;
    goto Cleanup;
}

HRESULT
CCollectionCache::GetMemberName(
                long lIndex,
                DISPID id,
                BSTR *pbstrName)
{
    HRESULT     hr = S_FALSE;
    long        lItmIndex;
    TCHAR       ach[20];
    CElement *  pElem;
    LPCTSTR     peName;

    if (IsOrdinalCollectionMember (lIndex, id))
    {
        lItmIndex = id - GetOrdinalMemberMin(lIndex);

        // Make sure our collection is up-to-date.
        hr = THR(EnsureAry(lIndex));
        if (hr)
            goto Error;

        // Is the number within range for an item in the collection?
        if (lItmIndex < 0 || (lItmIndex >= SizeAry(lIndex)))
            goto Error;

        // If this fails then we've got real problems the collection
        // size and elements it points to is VERY BAD.

        if ( !_aryItems[lIndex].fDontPromoteNames )
        {
            THR(GetIntoAry(lIndex, lItmIndex, &pElem));
            Assert(pElem);
            peName = pElem->GetIdentifier();
        }
        else
        {
            peName = NULL;
        }
        // If the element doesn't have name associated with it then
        // return the index number.
        if (!peName || !_tcslen(peName))
        {
            // Make a string out of the index.
            hr = Format(0, ach, ARRAY_SIZE(ach), _T("<0d>"), lItmIndex);
            if (hr)
                goto Cleanup;

            peName = ach;
        }

        hr = FormsAllocString(peName, pbstrName);
    }

Cleanup:
    return hr;

Error:
    hr = S_FALSE;
    goto Cleanup;
}

//+------------------------------------------------------------------------
//
//  Member:     GetLength
//
//  Synopsis:   collection object model helper
//
//-------------------------------------------------------------------------

HRESULT
CCollectionCache::GetLength(long lCollection, long * plSize)
{
    HRESULT hr;

    // Make sure our collection is up-to-date.
    hr = THR(EnsureAry(lCollection));
    if (hr)
        goto Cleanup;

    // Get its current size.
    *plSize = SizeAry(lCollection);

Cleanup:
    RRETURN(hr);
}


//+------------------------------------------------------------------------
//
//  Member:     Item
//
//  Synopsis:   collection object model
//
//              we handle the following parameter cases:
//                  0 params            : by index = 0
//                  1 params bstr       : by name, index = 0
//                  1 params #          : by index
//                  2 params bstr, #    : by name, index
//                  2 params #, bstr    : by index, ignoring bstr
//
//-------------------------------------------------------------------------

HRESULT
CCollectionCache::Item(long lCollection, VARIANTARG var1, VARIANTARG var2, IDispatch** ppResult)
{
    VARIANT *   pvarName = NULL;
    VARIANT *   pvarOne  = NULL;
    VARIANT *   pvarIndex = NULL;
    long        lIndex = 0;
    HRESULT     hr=E_INVALIDARG;

    if (!ppResult)
        goto Cleanup;

    *ppResult = NULL;

    pvarOne = (V_VT(&var1) == (VT_BYREF | VT_VARIANT)) ?
            V_VARIANTREF(&var1) : &var1;

    if ((V_VT(pvarOne)==VT_BSTR) || V_VT(pvarOne)==(VT_BYREF|VT_BSTR))
    {
        pvarName = (V_VT(pvarOne) & VT_BYREF) ?
            V_VARIANTREF(pvarOne) : pvarOne;

        if ((V_VT(&var2) != VT_ERROR ) &&
            (V_VT(&var2) != VT_EMPTY ))
        {
            pvarIndex = &var2;
        }
    }
    else if ((V_VT(&var1) != VT_ERROR )&&
             (V_VT(&var1) != VT_EMPTY ))
    {
        pvarIndex = &var1;
    }

    if (pvarIndex)
    {
        VARIANT varNum;

         VariantInit(&varNum);
         hr = THR(VariantChangeTypeSpecial(&varNum,pvarIndex,VT_I4));
         if (hr)
            goto Cleanup;

         lIndex = V_I4(&varNum);
    }

    // Make sure our collection is up-to-date.
    hr = THR(EnsureAry(lCollection));
    if (hr)
        goto Cleanup;

    // Get a collection or element of the specified object.
    if (pvarName)
    {
        BSTR    Name = V_BSTR(pvarName);

        if (pvarIndex)
        {
            hr = THR(GetDisp(lCollection,
                             Name,
                             lIndex,
                             ppResult,
                             FALSE));   // BUBUG rgardner - shouldn't ignore case
            if (hr)
                goto Cleanup;
        }
        else
        {
            hr = THR(GetDisp(lCollection,
                             Name,
                             CacheType_Named,
                             ppResult,
                             FALSE));   // BUBUG rgardner - shouldn't ignore case
            if (FAILED(hr))
            {
                HRESULT hrSave = hr;    // save error code, and see if it a cell range
                hr = THR_NOTRACE(GetDisp(
                    lCollection,
                    Name,
                    CacheType_CellRange,
                    ppResult,
                    FALSE));            // BUBUG rgardner - shouldn't ignore case
                if (hr)
                {
                    hr = hrSave;        // restore error code
                    goto Cleanup;
                }
            }
        }
    }
    else
    {
        hr = THR(GetDisp(lCollection,
                         lIndex,
                         ppResult));
        if (hr)
            goto Cleanup;
    }

Cleanup:
    // If we didn't find anything, make sure to just return NULL.
    if (hr == DISP_E_MEMBERNOTFOUND)
    {
        hr = S_OK;
    }

    RRETURN(hr);
}

HRESULT
CCollectionCache::GetElemAt(long lCollection, long *plCurrIndex, IDispatch **ppCurrNode)
{
    HRESULT hr;

    // Make sure our collection is up-to-date.
    hr = THR(EnsureAry(lCollection));
    if (hr)
        goto Cleanup;

    *ppCurrNode = NULL;

    if (*plCurrIndex < 0)
    {
        *plCurrIndex = 0;
        goto Cleanup;
    }
    else if (*plCurrIndex > SizeAry(lCollection) - 1)
    {
        *plCurrIndex = SizeAry(lCollection) - 1;
        goto Cleanup;
    }

    hr = THR(GetDisp(lCollection, *plCurrIndex, ppCurrNode));

Cleanup:
    RRETURN(hr);
}

//+------------------------------------------------------------------------
//
//  Member:     Tags
//
//  Synopsis:   collection object model, this always returns a collection
//              and is named based on the tag, and searched based on tagname
//
//-------------------------------------------------------------------------

HRESULT
CCollectionCache::Tags(long lCollection, VARIANT var1, IDispatch ** ppdisp)
{
    VARIANT *   pvarName = NULL;
    HRESULT     hr=E_INVALIDARG;

    if (!ppdisp)
        goto Cleanup;

    *ppdisp = NULL;

    pvarName = (V_VT(&var1) == (VT_BYREF | VT_VARIANT)) ?
        V_VARIANTREF(&var1) : &var1;

    if ((V_VT(pvarName)==VT_BSTR) || V_VT(pvarName)==(VT_BYREF|VT_BSTR))
    {
        pvarName = (V_VT(pvarName)&VT_BYREF) ?
            V_VARIANTREF(pvarName) : pvarName;
    }
    else
    {
        hr = DISP_E_MEMBERNOTFOUND;
        goto Cleanup;
    }

    hr = THR(Tags(lCollection, V_BSTR(pvarName), ppdisp));

Cleanup:
    RRETURN(hr);
}

HRESULT
CCollectionCache::Tags(long lCollection, LPCTSTR szTagName, IDispatch ** ppdisp)
{
    HRESULT hr;

    // Make sure our collection is up-to-date.
    hr = THR(EnsureAry(lCollection));
    if (hr)
        goto Cleanup;

    // Get a collection of the specified tags.
    hr = THR(GetDisp( lCollection,
                      szTagName,
                      CacheType_Tag,
                      (IDispatch**)ppdisp,
                      FALSE)); // Case sensitivity ignored for TagName
    if (hr)
        goto Cleanup;

Cleanup:
    RRETURN(hr);
}



//+------------------------------------------------------------------------
//
//  Member:     Urns
//
//  Synopsis:   collection object model, this always returns a collection
//              and is named based on the urn, and searched based on urn
//
//-------------------------------------------------------------------------

HRESULT
CCollectionCache::Urns(long lCollection, VARIANT var1, IDispatch ** ppdisp)
{
    VARIANT *   pvarName = NULL;
    HRESULT     hr=E_INVALIDARG;

    if (!ppdisp)
        goto Cleanup;

    *ppdisp = NULL;

    pvarName = (V_VT(&var1) == (VT_BYREF | VT_VARIANT)) ?
        V_VARIANTREF(&var1) : &var1;

    if ((V_VT(pvarName)==VT_BSTR) || V_VT(pvarName)==(VT_BYREF|VT_BSTR))
    {
        pvarName = (V_VT(pvarName)&VT_BYREF) ?
            V_VARIANTREF(pvarName) : pvarName;
    }
    else
    {
        hr = DISP_E_MEMBERNOTFOUND;
        goto Cleanup;
    }

    // Make sure our collection is up-to-date.
    hr = THR(EnsureAry(lCollection));
    if (hr)
        goto Cleanup;

    // Get a collection of the elements with the specified urn
    hr = THR(GetDisp( lCollection,
                      V_BSTR(pvarName),
                      CacheType_Urn,
                      (IDispatch**)ppdisp,
                      FALSE)); // Case sensitivity ignored for Urn
    if (hr)
        goto Cleanup;

Cleanup:
    RRETURN(hr);
}


//+------------------------------------------------------------------------
//
//  Member:     GetNewEnum
//
//  Synopsis:   collection object model
//
//-------------------------------------------------------------------------

HRESULT
CCollectionCache::GetNewEnum(long lCollection, IUnknown ** ppEnum)
{
    CPtrAry<LPUNKNOWN> *    pary = NULL;
    long                    lSize;
    long                    l;
    HRESULT                 hr=E_INVALIDARG;

    if (!ppEnum)
        goto Cleanup;

    *ppEnum = NULL;

    // Make sure our collection is up-to-date.
    hr = THR(EnsureAry(lCollection));
    if (hr)
        goto Cleanup;

    pary = new(Mt(CCollectionCacheGetNewEnum_pary)) CPtrAry<LPUNKNOWN>(Mt(CCollectionCacheGetNewEnum_pary_pv));
    if (!pary)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    lSize = SizeAry(lCollection);

    hr = THR(pary->EnsureSize(lSize));
    if (hr)
        goto Error;

    // Now make a snapshot of our collection.
    for (l = 0; l < lSize; ++l)
    {
        IDispatch * pdisp;

        hr = THR(GetDisp(lCollection, l, &pdisp));
        if (hr)
            goto Error;

        Verify(!pary->Append(pdisp));
    }

    // Turn the snapshot into an enumerator.
    hr = THR(pary->EnumVARIANT(VT_DISPATCH, (IEnumVARIANT **) ppEnum, FALSE, TRUE));
    if (hr)
        goto Error;

Cleanup:
    RRETURN(hr);

Error:
    pary->ReleaseAll();
    goto Cleanup;
}

//+------------------------------------------------------------------------
//
//  Member:     Remove
//
//  Synopsis:   remove the item in the collection at the given index
//
//-------------------------------------------------------------------------

HRESULT
CCollectionCache::Remove(long lCollection, long lItemIndex)
{
    HRESULT hr;

    if ((lItemIndex < 0) || (lItemIndex >= SizeAry(lCollection)))
        hr = E_INVALIDARG;
    else
    {
        if (_pfnRemoveObject)
            hr = THR ( CALL_METHOD( (CVoid *)(void *)_pBase, _pfnRemoveObject, 
                                    (lCollection, lItemIndex)));
        else
            hr = CTL_E_METHODNOTAPPLICABLE;
    }

    RRETURN( hr);
}

////////////////////////////////////////////////////////////////////////////////
//
//  Automation helper routines used by collection classes.
//
////////////////////////////////////////////////////////////////////////////////

HRESULT
DispatchInvokeCollection(CBase *             pThis,
                         InvokeExPROC        SuperInvokeFunction,
                         CCollectionCache *  pCollectionCache,
                         long                lCollectionIdx,
                         DISPID              dispidMember,
                         REFIID              riid,
                         LCID                lcid,
                         WORD                wFlags,
                         DISPPARAMS *        pdispparams,
                         VARIANT *           pvarResult,
                         EXCEPINFO *         pexcepinfo,
                         UINT *              puArgErr,
                         IServiceProvider *  pSrvProvider,
                         RETCOLLECT_KIND     returnCollection /* = RETCOLLECT_ALL */)
{
    HRESULT hr = DISP_E_MEMBERNOTFOUND;
    IHTMLWindow2   *pOmWindow = NULL;

    if (pCollectionCache && pCollectionCache->IsDISPIDInCollection ( lCollectionIdx, dispidMember ) )
    {
        // Note that CCollectionCache::Invokedoesn't need a punkCaller
        hr = pCollectionCache->Invoke(lCollectionIdx,
                                      dispidMember,
                                      riid,
                                      lcid,
                                      wFlags,
                                      pdispparams,
                                      pvarResult,
                                      pexcepinfo,
                                      puArgErr,
                                      returnCollection );
    }

    // for IE3 compat, name access of IFrames should return the om window
    if (lCollectionIdx == CMarkup::NAVDOCUMENT_COLLECTION &&
        !hr &&
        pvarResult &&
        V_VT(pvarResult) == VT_DISPATCH &&
        V_DISPATCH(pvarResult))
    {
        CElement       * pElem     = NULL;

        hr = THR_NOTRACE(V_DISPATCH(pvarResult)->QueryInterface(CLSID_CElement, (void**)&pElem));
        if (hr)
        {
            // what we have may be a collection pointer, so just mask the error
            // and return like we used to.
            hr = S_OK;
            goto Cleanup;
        }

        // For IE3.0 compatibility return named IFRAMEs as elements from the
        // document.  The window IDispatch'd object returned must be a 
        // security object (WindowProxy).
        if (pElem->Tag() == ETAG_IFRAME)
        {
            // the above QI does NOT addref. so we need to do it here before
            // the release in the variantClear
            CElement::CLock lock(pElem);

            VariantClear(pvarResult);

            // If the element is in a markup and has a window, then secure the
            // object we return in the context of that window.
            Assert(pElem->GetNearestMarkupForScriptCollection());

            COmWindowProxy *    pProxyContaining = pElem->GetNearestMarkupForScriptCollection()->Window();
            VARIANTARG          varIn;

            V_VT(&varIn) = VT_DISPATCH;
            V_DISPATCH(&varIn) = (IHTMLWindow2*)DYNCAST(CFrameSite, pElem)->_pWindow;

            Assert(pProxyContaining);

            // secure the window object in the context of the caller 
            hr = THR(pProxyContaining->SecureObject(&varIn, 
                                                    pvarResult, 
                                                    pSrvProvider, 
                                                    NULL, 
                                                    TRUE));

        }
    }

    // If above didn't work then try to get the property/expando.
    if (hr && pThis)
    {
        hr = THR_NOTRACE(CALL_METHOD( pThis, SuperInvokeFunction, (dispidMember,
                                                       lcid,
                                                       wFlags,
                                                       pdispparams,
                                                       pvarResult,
                                                       pexcepinfo,
                                                       pSrvProvider)));
    }

Cleanup:
    ReleaseInterface(pOmWindow);
    RRETURN(hr);
}



HRESULT
DispatchGetDispIDCollection(CBase *             pThis,
                            GetDispIDPROC       SuperGetDispIDFunction,
                            CCollectionCache *  pCollectionCache,
                            long                lCollectionIdx,
                            BSTR                bstrName,
                            DWORD               grfdex,
                            DISPID    *         pid)
{
    HRESULT     hr;

    Assert(pThis);
    Assert(pCollectionCache);

    hr = THR_NOTRACE(pCollectionCache->GetDispID(lCollectionIdx,
                                                 bstrName,
                                                 grfdex,
                                                 pid));

    // The collectionCache GetIDsOfNamesEx will return S_OK w/ DISPID_UNKNOW
    // if the name isn't found, catastrophic errors are of course returned.
    if (hr || (!hr && *pid == DISPID_UNKNOWN))
    {
        hr = THR_NOTRACE(CALL_METHOD( pThis, SuperGetDispIDFunction, (bstrName, grfdex, pid)));
    }

    RRETURN(hr);
}


HRESULT
DispatchGetNextDispIDCollection(CBase *             pThis,
                                GetNextDispIDPROC   SuperGetNextDispIDFunction,
                                CCollectionCache *  pCollectionCache,
                                long                lCollectionIdx,
                                DWORD               grfdex,
                                DISPID              id,
                                DISPID *            pid)
{
    HRESULT hr = S_FALSE;

    Assert(pThis);
    Assert(pCollectionCache);

    // Are we enumerating the collection indexes?
    if ( !pCollectionCache->IsOrdinalCollectionMember ( lCollectionIdx, id ) )
    {
        // No, so continue enumerating regular attributes, properties, and
        // expandos.
        hr = THR(CALL_METHOD( pThis, SuperGetNextDispIDFunction, (grfdex,
                                                      id,
                                                      pid)));

        // Have we reached the end of the properties, attributes and expandos
        // for the collection?
        if (hr)
        {
            // Yes, so only return a DISPID_UNKNOWN if the collection has no
            // items otherwise return the index 0 of the collection.
            if (pCollectionCache->SizeAry(lCollectionIdx) > 0)
            {
                *pid = pCollectionCache->GetOrdinalMemberMin ( lCollectionIdx );
                hr = S_OK;
            }
        }
    }
    // If we didn't or we're enumerating in the collection index range then go
    // right to the collection cache.
    else
    {
        hr = THR(pCollectionCache->GetNextDispID(lCollectionIdx,
                                                 grfdex,
                                                 id,
                                                 pid));
    }

    RRETURN1(hr, S_FALSE);
}

HRESULT
DispatchGetMemberNameCollection(CBase *                 pThis,
                                GetGetMemberNamePROC    SuperGetMemberNameFunction,
                                CCollectionCache *      pCollectionCache,
                                long                    lCollectionIdx,
                                DISPID                  id,
                                BSTR *                  pbstrName)
{
    if (!pbstrName)
        return E_INVALIDARG;

    *pbstrName = NULL;

    Assert(pThis);
    Assert(pCollectionCache);

    // Are we enumerating the collection indexes?
    if ( !pCollectionCache->IsOrdinalCollectionMember ( lCollectionIdx, id ) )
    {
        // No, so continue enumerating regular attributes, properties, and
        // expandos.
        CALL_METHOD( pThis, SuperGetMemberNameFunction, (id, pbstrName));
    }
    // If we didn't or we're enumerating in the collection index range then go
    // right to the collection cache.
    else
    {
        pCollectionCache->GetMemberName(lCollectionIdx,
                                        id,
                                        pbstrName);
    }

    return *pbstrName ? S_OK : DISP_E_MEMBERNOTFOUND;
}

// returns the correct offset of given dispid in given collection and the 
// case sensetivity flag (if requested)


long
CCollectionCache::GetNamedMemberOffset(long lCollectionIndex, DISPID dispid, 
                             BOOL *pfCaseSensitive /* =  NULL */)
{
    LONG        lOffset;
    BOOL        fSensitive;

    Assert(IsNamedCollectionMember(lCollectionIndex, dispid));

    // Check to see wich half of the dispid space the value goes
    if(IsSensitiveNamedCollectionMember(lCollectionIndex, dispid))
    {
        lOffset = GetSensitiveNamedMemberMin(lCollectionIndex);
        fSensitive = TRUE;
    }
    else
    {
        lOffset = GetNotSensitiveNamedMemberMin(lCollectionIndex);
        fSensitive = FALSE;
    }

    // return the sensitivity flag if required
    if(pfCaseSensitive != NULL)
        *pfCaseSensitive = fSensitive;

    return lOffset;
}


CAtomTable * 
CCollectionCache::GetAtomTable (BOOL *pfExpando)
{   
    if (pfExpando) 
        *pfExpando = Markup() ? Markup()->_fExpando : TRUE; 

    if (Markup())
        return &(Markup()->Doc()->_AtomTable);
    else
        return DYNCAST(CEventObj, _pBase)->GetAtomTable(); 
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\util\cfpf.cxx ===
/*
 *  @doc    INTERNAL
 *
 *  @module CFPF.C -- -- RichEdit CCharFormat and CParaFormat Classes |
 *
 *  Created: <nl>
 *      9/1995 -- Murray Sargent <nl>
 *
 *  @devnote
 *      The this ptr for all methods points to an internal format class, i.e.,
 *      either a CCharFormat or a CParaFormat, which uses the cbSize field as
 *      a reference count.  The pCF or pPF argument points at an external
 *      CCharFormat or CParaFormat class, that is, pCF->cbSize and pPF->cbSize
 *      give the size of their structure.  The code still assumes that both
 *      internal and external forms are derived from the CHARFORMAT(2) and
 *      PARAFORMAT(2) API structures, so some redesign would be necessary to
 *      obtain a more space-efficient internal form.
 *
 *  Copyright (c) 1995-1996, Microsoft Corporation. All rights reserved.
 */

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_CFPF_HXX_
#define X_CFPF_HXX_
#include "cfpf.hxx"
#endif

#ifndef X_MSHTMLRC_H_
#define X_MSHTMLRC_H_
#include "mshtmlrc.h"
#endif

#ifndef X_DOCGLBS_HXX_
#define X_DOCGLBS_HXX_
#include "docglbs.hxx"
#endif

#ifndef X_ELEMENT_HXX_
#define X_ELEMENT_HXX_
#include "element.hxx"
#endif

#ifndef X_FCACHE_HXX_
#define X_FCACHE_HXX_
#include "fcache.hxx"
#endif

#ifndef X_EFONT_HXX_
#define X_EFONT_HXX_
#include "efont.hxx"
#endif

#ifndef X_TABLE_H_
#define X_TABLE_H_
#include "table.h"
#endif

#ifndef X_CAPTION_H_
#define X_CAPTION_H_
#include "caption.h"
#endif

#ifndef X_TXTSITE_HXX_
#define X_TXTSITE_HXX_
#include "txtsite.hxx"
#endif

#ifndef X_INTL_HXX_
#define X_INTL_HXX_
#include "intl.hxx"
#endif

#ifndef X__FONTLNK_H_
#define X__FONTLNK_H_
#include "_fontlnk.h"
#endif

#ifndef X_TOMCONST_H_
#define X_TOMCONST_H_
#include "tomconst.h"
#endif

#ifndef X_PROPS_HXX_
#define X_PROPS_HXX_
#include "props.hxx"
#endif

#ifndef X_STYLE_HXX_
#define X_STYLE_HXX_
#include "style.hxx"
#endif

#ifndef X_SHEETS_HXX_
#define X_SHEETS_HXX_
#include "sheets.hxx"
#endif

#ifndef X_FONTFACE_HXX_
#define X_FONTFACE_HXX_
#include "fontface.hxx"
#endif

#ifndef X_TXTDEFS_H_
#define X_TXTDEFS_H_
#include "txtdefs.h"
#endif

#ifndef X_MSHTMHST_H_
#define X_MSHTMHST_H_
#include <mshtmhst.h>
#endif

#ifndef X_INPUTTXT_HXX_
#define X_INPUTTXT_HXX_
#include "inputtxt.hxx"
#endif

#ifndef X_SHEETS_HXX_
#define X_SHEETS_HXX_
#include "sheets.hxx"
#endif

#ifndef X_FLOAT2INT_HXX_
#define X_FLOAT2INT_HXX_
#include "float2int.hxx"
#endif

MtExtern(CFancyFormat_pszFilters);

DeclareTag(tagRecalcStyle, "Recalc Style", "Recalc Style trace")

extern DWORD g_dwPlatformID;
extern BOOL g_fInWin98Discover;



struct
{
    const TCHAR* szGenericFamily;
    DWORD        dwWindowsFamily;
}
const s_fontFamilyMap[] =
{
    { _T("sans-serif"), FF_SWISS },
    { _T("serif"),      FF_ROMAN },
    { _T("monospace"),  FF_MODERN },
    { _T("cursive"),    FF_SCRIPT },
    { _T("fantasy"),    FF_DECORATIVE }
};


/*
 *  CCharFormat::Compare(pCF)
 *
 *  @mfunc
 *      Compare this CCharFormat to *<p pCF>
 *
 *  @rdesc
 *      TRUE if they are the same
 *
 *  @devnote
 *      Compare simple types in memcmp.  If equal, compare complex ones
 */
BOOL CCharFormat::Compare (const CCharFormat *pCF) const
{
    BOOL fRet;

    Assert( _bCrcFont      == ComputeFontCrc() );
    Assert( pCF->_bCrcFont == pCF->ComputeFontCrc() );

    fRet = memcmp(this, pCF, offsetof(CCharFormat, _bCrcFont));

    // If the return value is TRUE then the CRC's should be the same.
    // That is, either the return value is FALSE, or the CRC's are the same.
    Assert( (!!fRet) || (_bCrcFont == pCF->_bCrcFont) );

    return (!fRet);
}


/*
 *  CCharFormat::CompareForLayout(pCF)
 *
 *  @mfunc
 *      Compare this CCharFormat to *<p pCF> and return FALSE if any
 *      attribute generally requiring a re-layout is different.
 *
 *  @rdesc
 *      TRUE if charformats are closed enough to not require relayout
 */
BOOL CCharFormat::CompareForLayout (const CCharFormat *pCF) const
{
    BYTE * pb1, * pb2;

    Assert( _bCrcFont      == ComputeFontCrc() );
    Assert( pCF->_bCrcFont == pCF->ComputeFontCrc() );

    if (_fNoBreak          != pCF->_fNoBreak          ||
        _fNoBreakInner     != pCF->_fNoBreakInner     ||
        _fVisibilityHidden != pCF->_fVisibilityHidden ||
        _fRelative         != pCF->_fRelative)
        return FALSE;

    pb1 = (BYTE*) &((CCharFormat*)this)->_wFontSpecificFlags();
    pb2 = (BYTE*) &((CCharFormat*)pCF)->_wFontSpecificFlags();

    if(memcmp(pb1, pb2, offsetof(CCharFormat, _ccvTextColor) -
                        offsetof(CCharFormat,
                                 _wFontSpecificFlags())))
        return FALSE;

    if( _latmFaceName != pCF->_latmFaceName )
        return FALSE;

    return TRUE;
}


/*
 *  CCharFormat::CompareForLikeFormat(pCF)
 *
 *  @mfunc
 *      Compare this CCharFormat to *<p pCF> and return FALSE if any
 *      attribute generally requiring a different Cccs is found.
 *
 *  @rdesc
 *      TRUE if charformats are close enough to not require a different Cccs.
 *      This is generally used in scripts like Arabic that have connecting
 *      characters
 */
BOOL CCharFormat::CompareForLikeFormat(const CCharFormat *pCF) const
{
    BYTE * pb1, * pb2;

    Assert(pCF != NULL);
    Assert(_bCrcFont == ComputeFontCrc());
    Assert(pCF->_bCrcFont == pCF->ComputeFontCrc());

    // 86212: superscript does not cause a different crc to be made. Check
    // font specific flags to make sure we interrupt shaping
    if (_bCrcFont == pCF->_bCrcFont)
    {
        pb1 = (BYTE*) &((CCharFormat*)this)->_wFontSpecificFlags();
        pb2 = (BYTE*) &((CCharFormat*)pCF)->_wFontSpecificFlags();

        if(memcmp(pb1, pb2, offsetof(CCharFormat, _ccvTextColor) -
                            offsetof(CCharFormat,
                                     _wFontSpecificFlags())))
        {
            return FALSE;
        }
        return TRUE;
    }

    return FALSE;
}


/*
 *  CCharFormat::InitDefault(hfont)
 *
 *  @mfunc
 *      Returns the font family name
 *
 *
 *  @rdesc
 *      HRESULT = (if success) ? string : NULL
 */

const TCHAR *  CCharFormat::GetFamilyName() const
{
    int     n;

    for( n = 0; n < ARRAY_SIZE( s_fontFamilyMap ); ++n )
    {
        if(_bPitchAndFamily == s_fontFamilyMap[ n ].dwWindowsFamily)
            return s_fontFamilyMap[ n ].szGenericFamily;
    }

    return NULL;
}


/*
 *  CCharFormat::InitDefault(hfont)
 *
 *  @mfunc
 *      Initialize this CCharFormat with information coming from the font
 *      <p hfont>
 *
 *  @rdesc
 *      HRESULT = (if success) ? NOERROR : E_FAIL
 */
HRESULT CCharFormat::InitDefault (
    HFONT hfont)        //@parm Handle to font info to use
{
    LONG twips;
    LOGFONT lf;

    memset((LPBYTE)this, 0, sizeof(CCharFormat));

    // 0 enum value means normal
    _cuvLetterSpacing.SetRawValue(MAKEUNITVALUE(0,UNIT_ENUM));
    _cuvWordSpacing.SetRawValue(MAKEUNITVALUE(0,UNIT_ENUM));

    // If hfont isn't defined, get LOGFONT for default font
    if (!hfont)
        hfont = (HFONT)GetStockObject(SYSTEM_FONT);

    // Get LOGFONT for passed hfont
    if (!GetObject(hfont, sizeof(LOGFONT), &lf))
        return E_FAIL;

    /* COMPATIBILITY ISSUE:
     * RichEdit 1.0 selects hfont into a screen DC, gets the TEXTMETRIC,
     * and uses tm.tmHeight - tm.tmInternalLeading instead of lf.lfHeight
     * in the following. The following is simpler and since we have broken
     * backward compatibility on line/page breaks, I've left it (murrays).
     */

    //// NOTE (cthrash) g_sizePixelsPerInch is only valid for the screen.
    // twips = MulDivQuick( lf.lfHeight, TWIPS_PER_INCH, g_sizePixelsPerInch.cy );
    // NOTE (mikhaill) -- changed MulDivQuick to TwipsFromDeviceY() during
    // CDocScaleInfo cleanup. Kept comments above, because "g_uiDisplay is only
    // valid for the screen" would sound strange.

    twips = g_uiDisplay.TwipsFromDeviceY(lf.lfHeight);

    if(twips < 0)
        twips = - twips;

    SetHeightInTwips( twips );

    _fBold = lf.lfWeight >= FW_BOLD;
    _fItalic = lf.lfItalic;
    _fUnderline = lf.lfUnderline;
    _fStrikeOut = lf.lfStrikeOut;

    _wWeight = (WORD)lf.lfWeight;

    _bCharSet = lf.lfCharSet;
    _fNarrow = IsNarrowCharSet(lf.lfCharSet);
    _bPitchAndFamily = lf.lfPitchAndFamily;

    SetFaceName(lf.lfFaceName);

    // 0 enum value means 'below'
    _bTextUnderlinePosition = styleTextUnderlinePositionAuto;

    return NOERROR;
}

TCHAR g_achFaceName[LF_FACESIZE];
LONG g_latmFaceName = 0;

/*
 *  CCharFormat::InitDefault( OPTIONSETTINGS *pOS, BOOL fKeepFaceIntact )
 *
 *  @mfunc
 *      Initialize this CCharFormat with given typeface and size
 *
 *  @rdesc
 *      HRESULT = (if success) ? NOERROR : E_FAIL
 */
HRESULT
CCharFormat::InitDefault (
    OPTIONSETTINGS * pOS,
    CODEPAGESETTINGS * pCS,
    BOOL fKeepFaceIntact )
{
    if (fKeepFaceIntact)
    {
        LONG latmOldFaceName= _latmFaceName;
        BYTE bOldCharSet = _bCharSet;
        BYTE bPitchAndFamily = _bPitchAndFamily;
        BOOL fNarrow = _fNarrow;
        BOOL fExplicitFace = _fExplicitFace;

        // Zero out structure

        memset((LPBYTE)this, 0, sizeof(CCharFormat));

        // restore cached values
        
        SetFaceNameAtom(latmOldFaceName);
        _bCharSet = bOldCharSet;
        _bPitchAndFamily = bPitchAndFamily;
        _fNarrow = fNarrow;
        _fExplicitFace = fExplicitFace;
    }
    else
    {
        // Zero out structure

        memset((LPBYTE)this, 0, sizeof(CCharFormat));

        if (pCS)
        {
            SetFaceNameAtom(pCS->latmPropFontFace);
            _bCharSet = pCS->bCharSet;
            _fNarrow = IsNarrowCharSet(_bCharSet);
        }
        else
        {
            if (g_latmFaceName == 0)
            {
                Verify(LoadString(GetResourceHInst(), IDS_HTMLDEFAULTFONT, g_achFaceName, LF_FACESIZE));
                g_latmFaceName = fc().GetAtomFromFaceName(g_achFaceName);
            }

            SetFaceNameAtom(g_latmFaceName);
            _bCharSet = DEFAULT_CHARSET;
        }

        // These are values are all zero.
        // _bPitchAndFamily = DEFAULT_PITCH;
        // _fExplicitFace = FALSE;
    }

    _cuvLetterSpacing.SetRawValue(MAKEUNITVALUE(0,UNIT_ENUM));
    _cuvWordSpacing.SetRawValue(MAKEUNITVALUE(0,UNIT_ENUM));

    SetHeightInTwips( ConvertHtmlSizeToTwips(3) );

    _ccvTextColor.SetValue( pOS ? pOS->crText()
                                : GetSysColorQuick(COLOR_BTNTEXT),
                           FALSE);

    _wWeight = 400;

    // 0 enum value means 'below'
    _bTextUnderlinePosition = styleTextUnderlinePositionAuto;

    return NOERROR;
}

/*
 *  CCharFormat::ComputeCrc()
 *
 *  @mfunc
 *      For fast font cache lookup, calculate CRC.
 *
 *  @devnote
 *      The font cache stores anything that has to
 *      do with measurement of metrics. Any font attribute
 *      that does not affect this should NOT be counted
 *      in the CRC; things like underline and color are not counted.
 */

WORD
CCharFormat::ComputeCrc() const
{
    BYTE    bCrc = 0;
    BYTE*   pb;
    BYTE *  pend = (BYTE*)&_bCrcFont;

    for (pb = (BYTE*)&((CCharFormat*)this)->_wFlags(); pb < pend; pb++)
        bCrc ^= *pb;

    return (WORD)bCrc;
}


//+----------------------------------------------------------------------------
// CCharFormat::ComuteFontCrc
//
// Synopsis:    Compute the font specific crc, assumes all the members that
//              effect the font are grouped together and are between
//              _wFontSpecificFlags and _bCursorIdx.
//              It is important the we do not have non specific
//              members in between to avoid creating fonts unnecessarily.
//
//-----------------------------------------------------------------------------

BYTE
CCharFormat::ComputeFontCrc() const
{
    BYTE bCrc, * pb, * pbend;

    Assert( & ((CCharFormat*)this)->_wFlags() < & ((CCharFormat*)this)->_wFontSpecificFlags() );

    bCrc = 0;

    pb    = (BYTE*) & ((CCharFormat*)this)->_wFontSpecificFlags();
    pbend = (BYTE*) & _bCursorIdx;

    for ( ; pb < pbend ; pb++ )
        bCrc ^= *pb;

    return bCrc;
}

void
CCharFormat::SetHeightInTwips(LONG twips)
{
    _fSizeDontScale = FALSE;
    _yHeight = twips;
}

void
CCharFormat::SetHeightInNonscalingTwips(LONG twips)
{
    _fSizeDontScale = TRUE;
    _yHeight = twips;
}

void
CCharFormat::ChangeHeightRelative(int diff)
{
    // This is a crude approximation.

    _yHeight = ConvertHtmlSizeToTwips( ConvertTwipsToHtmlSize( _yHeight ) + diff );
}

static TwipsFromHtmlSize[9][7] =
{
// scale fonts up for TV
#ifndef NTSC
  { 120, 160, 180, 200, 240, 320, 480 },
#endif
  { 140, 180, 200, 240, 320, 400, 600 },
  { 151, 200, 240, 271, 360, 480, 720 },
  { 200, 240, 280, 320, 400, 560, 840 },
  { 240, 280, 320, 360, 480, 640, 960 }
// scale fonts up for TV
#ifdef NTSC
  ,
  { 280, 320, 360, 400, 560, 720, 1080 }
#endif
  ,
  { 320, 360, 400, 440, 600, 760, 1120 }
  ,
  { 360, 400, 440, 480, 640, 800, 1160 }
  ,
  { 400, 440, 480, 520, 680, 840, 1200 }
  ,
  { 440, 480, 520, 560, 720, 880, 1240 }
};

static
LONG ScaleTwips( LONG iTwips, LONG iBaseLine, LONG iBumpDown )
{
    // iTwips:    the initial (unscaled) size in twips
    // iBaseLine: the baseline to use to scale (should be between 0-4)
    // iBumpDown: how many units to bump down (should be betweem 0-2)

    // If we are in the default baseline font and do not want to bump down, we do not
    //  need to scale.
    if( iBaseLine == BASELINEFONTDEFAULT && !iBumpDown )
        return iTwips;

    LONG lHtmlSize = ConvertTwipsToHtmlSize( iTwips );

    if( lHtmlSize > 7 || lHtmlSize <= iBumpDown ||
            TwipsFromHtmlSize[2][lHtmlSize - 1] != iTwips )
        // If we are out of range or do not match a table entry, scale manually
        return MulDivQuick( iTwips, iBaseLine + 4 - iBumpDown, 6 );
    else
    {
        // Scale according to IE table above.
        // the ratio is roughly as follows (from the IE table):
        //
        //   smallest small medium large largest
        //       1     5/4   6/4    7/4    8/4
        //
        // so if we scale that to medium, we have
        //
        //   smallest small medium large largest
        //      4/6    5/6     1    7/6    8/6

        lHtmlSize = max( 1L, lHtmlSize - iBumpDown );
        return TwipsFromHtmlSize[iBaseLine][lHtmlSize-1];
    }
}

LONG
CCharFormat::GetHeightInTwipsEx(LONG yHeight, BOOL fSubSuperSized, CDoc * pDoc) const
{
    if (!pDoc)
        return 0;

    LONG twips;
    LONG iBaseline;
    LONG iBumpDown = 0;

    // If we want super or subscript, we want to bump the font size down one notch
    if (fSubSuperSized)
        ++iBumpDown;

    if (_fSCBumpSizeDown)
        ++iBumpDown;

    if (_fSizeDontScale)
    {
        // For intrinsics, we don't want to change the pitch size
        // regardless of the z1oom factor (lBaseline).  We may want
        // to bump down if we get super or subscript, however.
        iBaseline = BASELINEFONTDEFAULT;
    }
    else
    {
        if (_fBumpSizeDown)
            ++iBumpDown;

        // If CDoc is a HTML dialog, use default font size.
        // NOTE (greglett)
        // With print preview, we want this info to be switchable per markup.
        // The baseline font info is still global information - one value per instance.
        // However, whether or not to apply that default is a per-markup thing (template vs. content document).
        // We could solve by putting a _sFontScale on CMarkup or such, or maybe use _fSizeDontScale above.
        // That also allows us to remove the below check in this ubercommonly called funcion - yay!
        if (    (pDoc->_dwFlagsHostInfo & DOCHOSTUIFLAG_DIALOG)
            &&  !pDoc->IsPrintDialog() )
        {
            iBaseline = BASELINEFONTDEFAULT;
        }
        else
        {
            iBaseline = pDoc->GetBaselineFont();
            Assert(pDoc->GetBaselineFont() >= 0 && pDoc->GetBaselineFont() <= 4);
        }
    }

    twips = ScaleTwips(yHeight, iBaseline * (g_fHighContrastMode ? 2 : 1), iBumpDown);
    Assert(twips >=0 && "twips height is negative");

    return twips;
}

LONG
CCharFormat::GetHeightInPixels(XHDC xhdc, CDocInfo * pdci) const
{
    int heightTwips = GetHeightInTwips(pdci->_pDoc);
    return pdci->DeviceFromTwipsY(heightTwips);
}

LONG
CCharFormat::GetHeightInPixelsEx(LONG yHeight, CDocInfo * pdci) const
{
    // Convert yHeight from device pixels to twips
    LONG lTwips = pdci->TwipsFromDeviceY(yHeight);

    // Scale twips
    lTwips = GetHeightInTwipsEx(lTwips, _fSubSuperSized, pdci->_pDoc);

    // Convert twips back to initial units
    return pdci->DeviceFromTwipsY(lTwips);

}


//------------------------- CParaFormat Class -----------------------------------

/*
 *  CParaFormat::AddTab(tbPos, tbAln, tbLdr)
 *
 *  @mfunc
 *      Add tabstop at position <p tbPos>, alignment type <p tbAln>, and
 *      leader style <p tbLdr>
 *
 *  @rdesc
 *      (success) ? NOERROR : S_FALSE
 *
 *  @devnote
 *      Tab struct that overlays LONG in internal rgxTabs is
 *
 *          DWORD   tabPos : 24;
 *          DWORD   tabType : 4;
 *          DWORD   tabLeader : 4;
 */
HRESULT CParaFormat::AddTab (
    LONG    tbPos,      //@parm New tab position
    LONG    tbAln,      //@parm New tab alignment type
    LONG    tbLdr)      //@parm New tab leader style
{
    LONG    Count   = _cTabCount;
    LONG    iTab;
    LONG    tbPosCurrent;

    if ((DWORD)tbAln > tomAlignBar ||               // Validate arguments
        (DWORD)tbLdr > tomLines ||                  // Comparing DWORDs causes
        (DWORD)tbPos > 0xffffff || !tbPos)          //  negative values to be
    {                                               //  treated as invalid
        return E_INVALIDARG;
    }

    LONG tbValue = tbPos + (tbAln << 24) + (tbLdr << 28);

    for(iTab = 0; iTab < Count &&                   // Determine where to insert
        tbPos > GetTabPos(_rgxTabs[iTab]);           //  insert new tabstop
        iTab++) ;

    if(iTab < MAX_TAB_STOPS)
    {
        tbPosCurrent = GetTabPos(_rgxTabs[iTab]);
        if(iTab == Count || tbPosCurrent != tbPos)
        {
            MoveMemory(&_rgxTabs[iTab + 1],          // Shift array up
                &_rgxTabs[iTab],                     //  (unless iTab = Count)
                (Count - iTab)*sizeof(LONG));

            if(Count < MAX_TAB_STOPS)               // If there's room,
            {
                _rgxTabs[iTab] = tbValue;            //  store new tab stop,
                _cTabCount++;                        //  increment tab count,
                return NOERROR;                     //  signal no error
            }
        }
        else if(tbPos == tbPosCurrent)              // Update tab since leader
        {                                           //  style or alignment may
            _rgxTabs[iTab] = tbValue;                //  have changed
            return NOERROR;
        }
    }
    return S_FALSE;
}

/*
 *  CParaFormat::Compare(pPF)
 *
 *  @mfunc
 *      Compare this CParaFormat to *<p pPF>
 *
 *  @rdesc
 *      TRUE if they are the same
 *
 *  @devnote
 *      First compare all of CParaFormat except rgxTabs
 *      If they are identical, compare the _cTabCount elemets of rgxTabs.
 *      If still identical, compare _cstrBkUrl
 *      Return TRUE only if all comparisons succeed.
 */
BOOL CParaFormat::Compare (const CParaFormat *pPF) const
{
    BOOL fRet;
    Assert(pPF);

    fRet = memcmp(this, pPF, offsetof(CParaFormat, _rgxTabs));
    if (!fRet)
    {
        fRet = memcmp(&_rgxTabs, &pPF->_rgxTabs, _cTabCount*sizeof(LONG));
    }
    return (!fRet);
}

/*
 *  CParaFormat::DeleteTab(tbPos)
 *
 *  @mfunc
 *      Delete tabstop at position <p tbPos>
 *
 *  @rdesc
 *      (success) ? NOERROR : S_FALSE
 */
HRESULT CParaFormat::DeleteTab (
    LONG     tbPos)         //@parm Tab position to delete
{
    LONG    Count   = _cTabCount;
    LONG    iTab;

    if(tbPos <= 0)
        return E_INVALIDARG;

    for(iTab = 0; iTab < Count; iTab++)         // Find tabstop for position
    {
        if (GetTabPos(_rgxTabs[iTab]) == tbPos)
        {
            MoveMemory(&_rgxTabs[iTab],          // Shift array down
                &_rgxTabs[iTab + 1],             //  (unless iTab is last tab)
                (Count - iTab - 1)*sizeof(LONG));
            _cTabCount--;                        // Decrement tab count and
            return NOERROR;                     //  signal no error
        }
    }
    return S_FALSE;
}

/*
 *  CParaFormat::GetTab (iTab, ptbPos, ptbAln, ptbLdr)
 *
 *  @mfunc
 *      Get tab parameters for the <p iTab> th tab, that is, set *<p ptbPos>,
 *      *<p ptbAln>, and *<p ptbLdr> equal to the <p iTab> th tab's
 *      displacement, alignment type, and leader style, respectively.  The
 *      displacement is given in twips.
 *
 *  @rdesc
 *      HRESULT = (no <p iTab> tab) ? E_INVALIDARG : NOERROR
 */
HRESULT CParaFormat::GetTab (
    long    iTab,           //@parm Index of tab to retrieve info for
    long *  ptbPos,         //@parm Out parm to receive tab displacement
    long *  ptbAln,         //@parm Out parm to receive tab alignment type
    long *  ptbLdr) const   //@parm Out parm to receive tab leader style
{
    AssertSz(ptbPos && ptbAln && ptbLdr,
        "CParaFormat::GetTab: illegal arguments");

    if(iTab < 0)                                    // Get tab previous to, at,
    {                                               //  or subsequent to the
        if(iTab < tomTabBack)                       //  position *ptbPos
            return E_INVALIDARG;

        LONG i;
        LONG tbPos = *ptbPos;
        LONG tbPosi;

        *ptbPos = 0;                                // Default tab not found
        for(i = 0; i < _cTabCount &&                 // Find *ptbPos
            tbPos > GetTabPos(_rgxTabs[i]);
            i++) ;

        tbPosi = GetTabPos(_rgxTabs[i]);             // tbPos <= tbPosi
        if(iTab == tomTabBack)                      // Get tab info for tab
            i--;                                    //  previous to tbPos
        else if(iTab == tomTabNext)                 // Get tab info for tab
        {                                           //  following tbPos
            if(tbPos == tbPosi)
                i++;
        }
        else if(tbPos != tbPosi)                    // tomTabHere
            return S_FALSE;

        iTab = i;
    }
    if((DWORD)iTab >= (DWORD)_cTabCount)             // DWORD cast also
        return E_INVALIDARG;                        //  catches values < 0

    iTab = _rgxTabs[iTab];
    *ptbPos = iTab & 0xffffff;
    *ptbAln = (iTab >> 24) & 0xf;
    *ptbLdr = iTab >> 28;
    return NOERROR;
}

/*
 *  CParaFormat::InitDefault()
 *
 *  @mfunc
 *      Initialize this CParaFormat with default paragraph formatting
 *
 *  @rdesc
 *      HRESULT = (if success) ? NOERROR : E_FAIL
 */
HRESULT CParaFormat::InitDefault()
{
    memset((LPBYTE)this, 0, sizeof(CParaFormat));

    _fTabStops = TRUE;

    _bBlockAlign   = htmlBlockAlignNotSet;

#if lDefaultTab <= 0
#error "default tab (lDefaultTab) must be > 0"
#endif

    _cTabCount = 1;
    _rgxTabs[0] = lDefaultTab;

    // Note that we don't use the inline method here because we want to
    // allow anyone to override.
    _cuvLeftIndentPoints.SetValue(0, CUnitValue::UNIT_POINT);
    _cuvRightIndentPoints.SetValue(0, CUnitValue::UNIT_POINT);
    _cuvNonBulletIndentPoints.SetValue(0, CUnitValue::UNIT_POINT);
    _cuvOffsetPoints.SetValue(0, CUnitValue::UNIT_POINT);

   _fHasScrollbarColors = FALSE;

   // default bullet position is outside
   _bListPosition = styleListStylePositionOutSide;

    return NOERROR;
}


/*
 *  CParaFormat::ComputeCrc()
 *
 *  @mfunc
 *      For fast font cache lookup, calculate CRC.
 *
 *  @devnote
 *      Compute items that deal with measurement of the element.
 *      Items which are purely stylistic should not be counted.
 */
WORD
CParaFormat::ComputeCrc() const
{
    DWORD dwCrc = 0, *pdw;

    for (pdw = (DWORD*)this; pdw < (DWORD*)(this+1); pdw++)
        dwCrc ^= *pdw;

    return HIWORD(dwCrc)^LOWORD(dwCrc);
}

// Font height conversion data.  Valid HTML font sizes ares [1..7]
// NB (cthrash) These are in twips, and are in the 'smallest' font
// size.  The scaling takes place in CFontCache::GetCcs().

// TODO (IE6 track bug 20)
// TODO (cthrash) We will need to get these values from the registry
// when we internationalize this product, so as to get sizing appropriate
// for the target locale.
// NOTE (johnv): Where did these old numbers come from?  The new ones now correspond to
// TwipsFromHtmlSize[2] defined above.
// static const int aiSizesInTwips[7] = { 100, 130, 160, 200, 240, 320, 480 };

// scale fonts up for TV
#ifdef NTSC
static const int aiSizesInTwips[7] = { 200, 240, 280, 320, 400, 560, 840 };
#elif defined(UNIX) // Default font size could be 13 (13*20=260)
static const int aiSizesInTwips[7] = { 151, 200, 260, 271, 360, 480, 720 };
#else
static const int aiSizesInTwips[7] = { 151, 200, 240, 271, 360, 480, 720 };
#endif

int
ConvertHtmlSizeToTwips(int nHtmlSize)
{
    // If the size is out of our conversion range do correction
    // Valid HTML font sizes ares [1..7]
    nHtmlSize = max( 1, min( 7, nHtmlSize ) );

    return aiSizesInTwips[ nHtmlSize - 1 ];
}

// ConvertFontSizeToTwipsInStrictCSS
//
// Synopsis:
//   In non-strict css mode the enums XX-LARGE, X-LARGE, LARGE, MEDIUM, SMALL, X-SMALL, XX-SMALL
//   are mapped to html sizes 7, ..., 1. NORMAL is mapped to 3 and therefore is the same size like
//   SMALL. In strict mode we want to have NORMAL same size as MEDIUM.
int
ConvertFontSizeToTwips(int nFontSize, BOOL fIsStrictCSS)
{
    int lFontSize = 0;
    // If the size is out of our conversion range do correction
    // Valid HTML font sizes ares [0..6]
    nFontSize = max( 0, min( 6, nFontSize) );

    if (fIsStrictCSS)
    {
        // In strict mode we take 2/3 of the smallest size for XX-SMALL; Everything else is moved one
        // down.
        lFontSize = (nFontSize == 0) ? /* XX-SMALL */ (aiSizesInTwips[1] * 2 / 3) : aiSizesInTwips[nFontSize-1];
    }
    else
    {
        // In compatible mode the mapping is XX-SMALL:1, X-SMALL:0..., XX-LARGE:5, 
        lFontSize = aiSizesInTwips[nFontSize];
    }
    return lFontSize;
}


int
ConvertTwipsToHtmlSize(int nFontSize)
{
    int nNumElem = ARRAY_SIZE(aiSizesInTwips);

    // Now convert the point size to size units used by HTML
    // Valid HTML font sizes ares [1..7]
    int i;
    for(i = 0; i < nNumElem; i++)
    {
        if(nFontSize <= aiSizesInTwips[i])
            break;
    }

    return i + 1;
}

// ===================================  CFancyFormat  =========================

//-----------------------------------------------------------------------------
//
//  Function:   CFancyFormat
//
//-----------------------------------------------------------------------------

CFancyFormat::CFancyFormat()
{
    _pszFilters = NULL;
    _iExpandos = -1;
    _iCustomCursor = -1;
    _iPEI = -1;
}

//-----------------------------------------------------------------------------
//
//  Function:   CFancyFormat
//
//-----------------------------------------------------------------------------

CFancyFormat::CFancyFormat(const CFancyFormat &ff)
{
    _pszFilters = NULL;
    _iExpandos = -1;
    _iCustomCursor = - 1;
    _iPEI = -1;
    *this = ff;
}

//-----------------------------------------------------------------------------
//
//  Function:   ~CFancyFormat
//
//-----------------------------------------------------------------------------

CFancyFormat::~CFancyFormat()
{
    if (_pszFilters)
    {
        MemFree(_pszFilters);
        _pszFilters = NULL;
    }
    if(_iExpandos >= 0)
    {
        TLS(_pStyleExpandoCache)->ReleaseData(_iExpandos);
        _iExpandos = -1;
    }
    if(_iPEI >= 0)
    {
        TLS(_pPseudoElementInfoCache)->ReleaseData(_iPEI);
        _iPEI = -1;
    }
    if(_iCustomCursor >= 0)
    {
        TLS(_pCustomCursorCache)->ReleaseData(_iCustomCursor);
        _iCustomCursor = -1;
    }
}

//+----------------------------------------------------------------------------
//
//  Function:   InitDefault
//
//  Synopsis:   
//
//-----------------------------------------------------------------------------

void 
CFancyFormat::InitDefault()
{
    int  iOrigiExpandos, iOrigiPEI, iOrigCC;
    BYTE i;

    if (_pszFilters)
        MemFree(_pszFilters);

    // We want expandos to be inherited
    iOrigiExpandos = _iExpandos;
    iOrigiPEI = _iPEI;
    iOrigCC = _iCustomCursor;
    
    memset((LPBYTE)this, 0, sizeof(CFancyFormat));
    _bd._ccvBorderColorLight.Undefine();
    _bd._ccvBorderColorDark.Undefine();
    _bd._ccvBorderColorHilight.Undefine();
    _bd._ccvBorderColorShadow.Undefine();
    _cuvSpaceBefore.SetValue(0, CUnitValue::UNIT_POINT);
    _cuvSpaceAfter.SetValue(0, CUnitValue::UNIT_POINT);

    // We are setting all border sides to the same value, so it doesn't matter
    // if we set logical or physical values.
    CColorValue ccvUndefine;
    CUnitValue cuvNull;
    ccvUndefine.Undefine();
    cuvNull.SetNull();
    for (i = 0; i < SIDE_MAX; i++)
    {
        _bd.SetBorderColor(i, ccvUndefine);
        _bd.SetBorderWidth(i, cuvNull);
        _bd.SetBorderStyle(i, (BYTE)-1);
    }

    _ccvBackColor.Undefine();
    ClearBgPosX();
    ClearBgPosY();
    SetBgRepeatX(TRUE);
    SetBgRepeatY(TRUE);

    // Restore the orignial value
    _iExpandos = (SHORT)iOrigiExpandos;
    _iPEI      = (SHORT)iOrigiPEI;
    _iCustomCursor = (SHORT) iOrigCC;
}

//+----------------------------------------------------------------------------
//
//  Function:   CFancyFormat::operator=
//
//  Synopsis:   Replace members of this struct by another
//
//-----------------------------------------------------------------------------

CFancyFormat&
CFancyFormat::operator=(const CFancyFormat &ff)
{
    if(_iExpandos >= 0)
        TLS(_pStyleExpandoCache)->ReleaseData(_iExpandos);
    if (_pszFilters)
       MemFree(_pszFilters);
    if(_iCustomCursor >= 0 )
        TLS( _pCustomCursorCache)->ReleaseData(_iCustomCursor );
        
    memcpy(this, &ff, sizeof(*this));

    if (_pszFilters)
    {
        // Handle OOM here?
        MemAllocString(Mt(CFancyFormat_pszFilters), _pszFilters, &_pszFilters);
    }

    // Addref the new expando table
    if(_iExpandos >= 0)
        TLS(_pStyleExpandoCache)->AddRefData(_iExpandos);
    if(_iPEI >= 0)
        TLS(_pPseudoElemen