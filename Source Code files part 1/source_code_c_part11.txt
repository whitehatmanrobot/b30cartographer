VECTOR"
	INT	21H			;Output: ES:BX = the address in the vector
	POP	AX
	ENDM

SET	MACRO	REG,VALUE		;SET REG TO VALUE. DON'T SPECIFY AX FOR REG

	PUSH	AX
	MOV	AX,VALUE
	MOV	REG,AX
	POP	AX

ENDM

SET_INT_VECT MACRO INT_NO		;Input: "INT_NO" - the interrupt to be set
	PUSH	AX			;	DS:DX = CS:IP value to set the interrupt to
	MOV	AL,INT_NO		;Output: the vector "INT_NO" contains DS:DX
	MOV	AH,25H			;function call "SET VECTOR"
	INT	21H
	POP	AX
	ENDM

store_vector MACRO dword_holder 	;Input: "dword_holder" - where to store it
					;	ES:BX - the address (vector) to be stored
   MOV	WORD PTR dword_holder,BX	;Output: "dword_holder"=the value passed in ES:BX
   MOV	WORD PTR dword_holder[2],ES

ENDM

;											  
;  M A C R O S  Í¼


;  E Q U A T E S  Í»
;											    

ADJUSTMENT EQU	(entpt - move_destination)	;# of bytes the resident code is moved
adjustment_in_paragraphs  EQU  (adjustment / 10H)	;# paragraphs the code moved
COM_status	EQU	03		  ;BIOS input for com status request	;AN001;
E		EQU	1		  ;value of "res_com_retry_type" for E retry requested	 ;AN001;
false		EQU	0
framing_error	EQU	0000100000000000B ;bit returned in AX from com status			 ;AN001;
holding_empty	EQU	0010000000000000B ;bit returned in AX from com status			 ;AN001;
INT14		EQU	014H
INT17		EQU	017H
LPT_status	EQU	02		  ;value of AH for printer status checks					   ;AN000;
not_busy	EQU	80H		  ;just the not busy bit on
overrun_error	EQU	0000001000000000B ;bit returned in AX from com status			 ;AN001;
parity_error	EQU	0000010000000000B ;bit returned in AX from com status			 ;AN001;
P14_model_byte	EQU	0F9H		  ;P14's have a F9 at F000:FFFE
R		EQU	3		  ;value of "res_com_retry_type" for R retry requested	 ;AN001;
shift_empty	EQU	0100000000000000B ;bit returned in AX from com status			 ;AN001;
time_out	EQU	1000000000000000B ;time out bit returned in AX from com status		 ;AN001;
TO_SCREEN	EQU	9		  ;REQUEST OUTPUT TO SCREEN
TRUE		EQU	0FFH
USER_ABORT	EQU	00H

;											    
;  E Q U A T E S  Í¼


;  S T R U C T U R E S  Í»
;											  


;											  
;  S T R U C T U R E S  Í¼


ROM	SEGMENT AT 0F000H
	ORG	0E739H
RS232	LABEL	FAR
	ORG	0EFD2H
PRINTER_IO LABEL FAR
;NOTE: THE VALUES REPRESENTED BY THIS SEGMENT ARE NOT NECESSARILY
; THE ONES USED BY THE SUBSEQUENT PROCEDURES.  THESE HERE MERELY
; SERVE AS SAMPLES.  THE ACTUAL VALUES IN THE INSTRUCTIONS:
;	JMP	RS232
;	JMP	PRINTER_IO
; WILL BE MOVED INTO THESE INSTRUCTIONS FROM THE VECTOR TABLE USING
; THE THEN CURRENT VALUES OF INT 14H FOR RS232 AND OF INT 17H FOR
; THE PRINTER_IO JUMP TARGETS.	THIS IS TO ALLOW FOR SOME USER
; TO HAVE INTERCEPTED THESE VECTORS AND DIRECTED THEIR REQUESTS TO
; HIMSELF INSTEAD OF TO THE ROM.

	ORG	0FFFEH
;model_byte	 LABEL	 BYTE
ROM	ENDS

VECT	SEGMENT AT 0
	ORG	50H
VECT14H LABEL	DWORD			;RS232 CALL
	ORG	5CH
VECT17H LABEL	DWORD			;PRINTER I/O CALL
	ORG	471H
BREAK_FLAG LABEL BYTE			;BREAK FLAG
BREAK_BIT EQU	80H			;ON=BREAK
	ORG	530H
RESSEG	LABEL	DWORD			;VECTOR OF MODETO, INIT TO ZERO
VECT	ENDS


;****************************************************************
PRINTF_CODE SEGMENT PUBLIC
	ASSUME	CS:PRINTF_CODE,DS:PRINTF_CODE


;  E X T R N S	Í»
;											  

EXTRN	 device_type:BYTE	 ;see parse.asm
EXTRN	 COMX:ABS		 ;see parse.asm
EXTRN	 LPTX:ABS		 ;see parse.asm
EXTRN	MAIN:NEAR
EXTRN	MOVED_MSG:WORD	    ;CR,LF,"Resident portion of MODE loaded",CR,LF,"$"
EXTRN	busy_status:ABS      ;value of lpt1_retry_type[BX] when user wants actual status, see modeprin
EXTRN	PRINTF:NEAR		;interface to message retriever, see display.asm
EXTRN	 reroute_requested:BYTE    ;see parse.asm
EXTRN	 retry_requested:BYTE	 ;see parse.asm

;											  
;  E X T R N S	Í¼



;  P U B L I C S  Í»
;											  

PUBLIC	 first_char_in_command_line	     ;location of the command line parameters
PUBLIC	FIXUP
PUBLIC	 lpt1_retry_type	 ;filled in and used to get at other two lpt retry masks in modeprin
PUBLIC	rescode_length		;REFERENCED IN MAIN PROCEDURE
PUBLIC	MODETO
PUBLIC	move_destination	;location of the resident code after it has been moved
PUBLIC	NEW_PTSFLAG		;RESIDENT THE FLAG WILL BE ACCESSABLE TO
PUBLIC	NEW_SCRNTABL		;MODESCRN NEEDS TO KNOW WHERE IT WENT
PUBLIC	OFFPTS			;USED IN MODEECHO TO ADDRESS MODEPTS
PUBLIC	OFFRETRY
PUBLIC	 ptsflag1		 ;make available to display_printer_reroute_status
PUBLIC	P14_model_byte
PUBLIC	res_com_retry_type
;PUBLIC  res_lpt_retry_type
PUBLIC	 resflag2		 ;make available to display_printer_reroute_status
PUBLIC	RES_MODEFLAG		; RESIDENT THE FLAG WILL BE ACCESSABLE
PUBLIC	RESSEG			;SCRNTABL NEEDS TO FOLLOW THIS VECTOR TO ADDRESS VIDEO PARMS
PUBLIC	SCRNTABL
PUBLIC	submodel_byte		 ;holder for machine's secondary model byte
PUBLIC	VECTOR14
PUBLIC	VECTOR17

;											  
;  P U B L I C S  Í¼

	ORG	2CH
environ_seg    DW    ?			  ;segment address of the environment, used as the block of memory to free so	   ;AN000;
					  ;environment is not part of resident code.

	ORG	60H			  ;first usable byte of PSP. If you change this check the
					  ;calculation of paragraphs in 'main'

move_destination   LABEL   WORD    ;where the resident will be moved to

;    THIS STRUCTURE DEFINES THE PROGRAM SEGMENT PREFIX AREA
;     POINTED TO BY THE ES REGISTER.  THIS MUST BE DEFINED HERE, IT REPLACES THE
;     'ORG 100'

	ORG	80H
command_line_length  DB    ?			;not used, just place holder to allign next field
first_char_in_command_line  LABEL   BYTE		;location of the command line parameters
;command_line		     DB      7FH DUP(?) 	 ;PARM AREA

	ORG	100H
ENTPT:	JMP	MAIN			;ENTRY POINT, START AT THE MAIN PROCEDURE
	SUBTTL	SERIAL RETRY
	PAGE
;THIS PROC WILL BE POINTED TO BY INT VECTOR 14H


MODETO	PROC	NEAR




PUSH  CX
MOV   CL,DL		   ;CL=DL=0,1,2 or 3
SHL   CL,1		   ;CL= 0, 2, 4 or 6 for COM 1,2,3 or 4 respectively						   ;AC000;
XOR   CH,CH		   ;CH=0 ready for ANDing in the mask								   ;AC000;
OR    CH,00000011B	   ;CH=00000011, mask for any type of retry, to be shifted into proper position 		   ;AC000;
SHL   CH,CL		   ;CH=00000011, 00001100, 00110000 or 11000000 for COM 1,2,3 or 4 respectively
AND   CH,BYTE PTR CS:res_modeflag	  ;see if any bit is on for this COM port ;AC001;
MOV   CS:retry_type,CX	   ;AC001; save for check after call to old INT 14		 ;AN001;
POP   CX
JNZ   pushax





VECTOR14 LABEL	WORD			;THE NEXT JMP INSTRUCTION HAS 5 BYTES,
;		    THE LAST 4 ARE THE CONTENTS OF INT 14H,
;		    WHICH NORMALLY POINTS TO THE ROM RS232
;		    HANDLER.  THE CODE GENERATED HERE BY THE
;		    ASSEMBLER IS REPLACED BY THE ACTUAL
;		    CONTENTS OF INT 14H.

TOROM:
	JMP	RS232			;NO RETRY, GO DIRECTLY TO ROM ENTRY IRET from there
PUSHAX:
	MOV	CS:request,AH		;save request type
	PUSH	AX			;SAVE ENTRY PARAMETERS FOR LATER RETRY
	PUSH	DS			;SAVE REGS
	PUSH	AX			;SAVE REGS
	SUB	AX,AX			;POINT TO
	MOV	DS,AX			; PAGE ZERO
	AND	DS:BREAK_FLAG,0FFH-BREAK_BIT ;RESET BREAK FLAG
	POP	AX			;RESTORE
	POP	DS			; REGS
	PUSHF				;SAVE FLAGS TO SIMULATE INT INSTRUCTION

VEC	EQU	(VECTOR14 +1)  ;OFFSET TO IMMEDIATE FIELD OF PREVIOUSLY SET
;				FAR JMP INSTRUCTION, FILLED WITH THE
;				ORIGINAL CONTENTS OF THE INTERRUPT VECTOR
	CALL	DWORD PTR CS:VEC       ;CALL PREVIOUS RS232 HANDLER
	.IF <CS:request EQ COM_status> THEN		;IF a status request THEN			      ;AN001;
	   PUSH    CX			  ;need CX for shift count in CL				      ;AN001;
	   MOV	   CX,CS:retry_type	  ;AC001; get back retry type for this port				     ;AN001;
	   SHR	   CH,CL		  ;put back in first two bits for retry type check below	      ;AN001;
	   .IF <CH EQ E> THEN										      ;AN001;
	      MOV  AX,time_out+framing_error+parity_error+overrun_error     ;indicate the port is on fire     ;AN001;
	   .ELSEIF <CH EQ R> THEN									      ;AN001;
	      MOV  AX,shift_empty+holding_empty+clear_to_send+data_set_ready  ;indicate the port is ready     ;AN001;
	   .ENDIF					;otherwise assume B retry and pass actual status      ;AN001;
	   POP	   CX			  ;restore reg							      ;AN001;
	.ELSE				  ;continue as if a send request				      ;AN001;
	   PUSH    AX			   ;SAVE REGS
	   PUSH    DS			   ; REGS
	   SUB	   AX,AX		   ;POINT TO
	   MOV	   DS,AX		   ; PAGE ZERO
	   TEST    DS:BREAK_FLAG,BREAK_BIT ;TEST BREAK FLAG
	   POP	   DS			   ;RESTORE
	   POP	   AX			   ; REGS
	   JZ	   TESTER		   ;BRANCH IF NO BREAK
	   OR	   AH,80H		   ;SIMULATE TIMEOUT ERROR ON BREAK
	.ENDIF				   ;ENDIF status request					      ;AN001;
FLUSH:
	INC	SP			;FLUSH THE
	INC	SP			; STACK
	IRET				;RETURN
;
TESTER:
	TEST	AH,80H			;TEST IF A REAL TIMEOUT
	JZ	FLUSH			;IF NOT, RETURN
	POP	AX			;RETRIEVE ORIGINAL ENTRY PARAMETERS
	JMP	PUSHAX			;DO RETRY
;**********************************************************************
RES_MODEFLAG EQU $			;WHEN THIS CODE IS RESIDENT THE FLAG WILL BE
					; ACCESSABLE BY MODECOM AS AN OFFSET FROM ADDRESS
					; POINTED TO BY VECT14H AND RESSEG
res_com_retry_type equ $

	    DB	  0			;AN665;no retry of any type active for any port
;
;	    bits comx		00=>no retry for any port
;	    ---- ----		01=>E for COM1, no retry for 2, 3 and 4
;	    0-1  com1		02=>B for COM1, no retry for 2, 3 and 4
;	    2-3  com2		03=>R for COM1, no retry for 2, 3 and 4
;	    4-5  com3		04=>E for COM2, no retry for 1, 3 and 4
;	    6-7  com4		05=>E for COM2, E for COM1, none for 3 and 4
;				06=>E for COM2, B for COM1, none for 3 and 4
;	    bit 		07=>E for COM2, R for COM1, none for 3 and 4
;	   pair 		08=>B for COM2, none for 1, 3 and 4
;	  value  active 	09=>B for COM2, E for COM1, none for 3 and 4
;	  -----  ------ 	0A=>B for COM2, B for COM1, none for 3 and 4
;	      0  unknown	0B=>B for COM2, R for COM1, none for 3 and 4
;	      1  E		0C=>R for COM2, no retry for 1, 3 and 4
;	      2  B		0D=>R for COM2, E for COM1, none for 3 and 4
;	      3  R		0E=>R for COM2, B for COM1, none for 3 and 4
;				0F=>R for COM2, R for COM1, none for 3 and 4
;				10=>E for COM3, none for 1, 2 and 4
;					  etc.
MODETO	ENDP
;**************************************************************
	SUBTTL	DETERMINE PARALLEL TO SERIAL, OR PARALLEL TIMEOUT
	PAGE
;THIS PROC MAY BE POINTED TO BY INT VECTOR 17H
MODEPTS PROC	NEAR
OFFPTS	EQU	MODEPTS - MODETO
	TEST	DL,1			;DETERMINE IF REDIRECTION APPLIES
;		NOTE: THIS IMMEDIATE FIELD IS Revised BY MODE
;
;THIS NEXT JUMP INSTRUCTION IS Revised BY MODEECHO TO REFLECT WHICH
;LPTN IS TO BE REDIRECTED TO WHICH COMM.
	JNZ	CK			;THIS JNZ IS Revised BY MODE
;
	ORG	$-2
	JZ	CK			;IT MAY BE CHANGED TO THIS
;
	ORG	$-2
	JMP	SHORT NOREDIRECT	;  OR THIS...
;
NOREDIRECT:
OFFRETRY EQU	$		;disp into resident code of retry flgs
;THIS NEXT SECTION WILL TEST FOR THE OPTIONAL RETRY ON PARALLEL TIMEOUT.
	TEST	DL,1			;TEST TO SEE IF PARALLEL RETRY IS ACTIVE
;THIS NEXT JUMP INSTRUCTION IS Revised BY MODEPRIN TO REFLECT WHICH
;LPT1n DEFICE IS TO BE RETRIED.  IT WILL APPEAR IN SEVERAL FORMS:
	JNZ	PAR_RETRY		;THIS INSTRUCTION MAY BE Revised
;
	ORG	$-2
	JZ	PAR_RETRY
;
	ORG	$-2
	JMP	SHORT ASIS
;
VECTOR17 LABEL	WORD
ASIS:	JMP	PRINTER_IO		;NO REDIRECTION, GO DIRECTLY TO PREVIOUS INT 17H
;**************************************************************
	SUBTTL	RETRY PARALLEL ON TIMEOUT.
	PAGE
PAR_RETRY:
RT:
      MOV   CS:request,AH	       ;save the function requested for check after return from call to INT 17		  ;AN000;
      PUSH  AX			    ;SAVE ENTRY PARAMETERS FOR LATER USE
      PUSH  DS			    ;SAVE CALLER'S REGS
      PUSH  AX			    ;SAVE REGS
;
      SUB   AX,AX		    ;POINT TO PAGE ZERO
      MOV   DS,AX		    ; USING THE DATA SEG REG
;
      AND   DS:BREAK_FLAG,0FFH-BREAK_BIT ;RESET BREAK FLAG
;
      POP   AX			    ;RESTORE CALLER'S REGS
      POP   DS			    ;RESTORE REGS
      PUSHF			    ;SAVE FLAGS TO SIMULATE INT INSTRUCTION
PVEC  EQU   VECTOR17+1		    ;OFFSET TO IMMEDIATE FIELD OF PREVIOUSLY SET
;		    FAR JUMP INSTRUCTION, FILLED WITH THE
;		    ORIGINAL CONTENTS OF THE INT 17H VECTOR.
      CALL  DWORD PTR CS:PVEC	    ;CALL PREVIOUS PARALLEL PORT HANDLER
      CMP   CS:request,LPT_status											   ;AN000;
      JNE   ptest		    ; M001 					   ;AN000;
	 TEST  AH,not_busy	    ;see if the printer was busy (not busy bit off)					   ;AN000;
	 JNZ   pflush		    ;IF busy dork the status byte							   ;AN000;
	    PUSH  BX													   ;AN000;
	    MOV   BX,DX 	       ;BX=zero based printer number							   ;AN000;
	    CMP   BYTE PTR CS:lpt1_retry_type[BX],busy_status  ;IF status should be changed THEN		     ;AN000;
	    JZ	  dont_modify					     ;busy setting means user wants actual status	   ;AN000;
	       MOV   AH,BYTE PTR CS:lpt1_retry_type[BX]  ;change to status set by prior retry setting request for this LPT ;AN000;
	    dont_modify:												   ;AN000;
	    POP   BX													   ;AN000;
;C00  JMP   pflush		    ;return to caller									   ;AN000;
; M001    JMP   SHORT pflush	    ;return to caller			;C00						   ;AN000;
PFLUSH:
      INC   SP			    ;FLUSH THE
      INC   SP			    ;  STACK
      IRET			    ;RETURN TO CALLER
;
PTEST:
      TEST  AH,01H		    ;TEST IF A REAL PARALLEL TIMEOUT
      JZ    PFLUSH		    ;IF NOT, RETURN

      PUSH  AX			    ;SAVE RETURN CODE IN AH
      PUSH  DS			    ;SAVE DATA SEGMENT REG
;
      SUB   AX,AX		    ;POINT TO
      MOV   DS,AX		    ;  SEGMENT AT ZERO
;
      TEST  DS:BREAK_FLAG,BREAK_BIT ;TEST BREAK FLAG BIT
      POP   DS			    ;RESTORE SEG REG
      POP   AX			    ;RESTORE RETURN CODE TO AH
      JZ    @f		    ;BRANCH IF NO BREAK REQUESTED
;
;     OR    AH,USER_ABORT	    ;SIMULATE TIMEOUT
      mov   ah, 0ffh		    ; ask BIOS not to retry M001
      jmp   short pflush	    ;			    M001
@@:
      POP   AX			    ;RETRIEVE ORIGINAL ENTRY PARAMETERS
      JMP   RT			    ;DO RETRY
;**************************************************************
	SUBTTL	REDIRECT PARALLEL I/O TO SERIAL
	PAGE
CK:
FIXUP	EQU	CK - NOREDIRECT
	CMP	AH,1			;CHECK FOR 'INITIALIZE' CODE
;			AH=0, PRINT THE CHAR IN AL
;			AH=1, INITIALIZE
;			AH=2, READ STATUS
	JNZ	PTCHR			;IT IS PRINT CHARACTER OR READ STATUS
;			SINCE IT IS 'INITIALIZE'
	MOV	AH,80H			;PASS BACK 'NOT BUSY' RETURN CODE FROM
;			AH=1, (INITIALIZE)
	IRET
;
PTCHR:
;			IT IS PRINT CHARACTER OR READ STATUS
	PUSH	BX			;SAVE THE
	PUSH	AX			; REGS
	PUSH	DX			;SAVE MORE REGS
	MOV	BX,OFFSET RESFLAG2	       ;POINT AT PARALLEL TO SERIAL
;				     CORRESPONDENCE TABLE IN RESIDENT CODE
	ADD	BX,DX			;INDEX USING PRINTER SELECTION (0,1,OR 2)
	MOV	DL,CS:[BX]		;GET CORRESPONDING SERIAL PORT SELECT
	CMP	AH,0			;CHECK FOR 'PRINT CHAR' CODE
	JZ	SENDCHAR		; YES, PRINT CHAR
;				  NO, MUST BE READ STATUS
	MOV	AH,3			;SET TO INT 14 'READ STAT' ENTRY PT
	INT	14H			;GO RS232 AND READ STATUS INTO AX
;
;			AH HAS LINE STATUS:
;			IF TRANSFER HOLDING REG EMPTY, AND
;			IF TRANSMIT SHIFT REGISTER READY, THEN SERIAL PORT
;			NOT BUSY
CLEAR_TO_SEND	EQU	10H
DATA_SET_READY	EQU	20H		;DATA SET READY LINE HIGH

; M007 - BEGIN
	mov	ah, 10h			; assume that the printer is not ready
	test	al, CLEAR_TO_SEND+DATA_SET_READY
	jz	$$EN1
	mov	ah, 90h			; printer is ready
; M007 - END

COMMENT ^++++++++++++++++++++++++++++++++++++++++++ M007

;C03	AND	AL,CLEAR_TO_SEND+DATA_SET_READY 	;SEE IF PRINTER HAS A CHANCE

	AND	AL,DATA_SET_READY	  ;SEE IF PRINTER HAS A CHANCE	;C03
;	$IF	Z			;DSR and CTS low, so probably off or out of paper
	JNZ $$IF1
	   MOV	   AH,29H		;PAR 'BUSY' 'OUT OF PAPER' 'I/O ERROR' 'TIME OUT'
;	$ELSE
	JMP SHORT $$EN1
$$IF1:
;C03	   CMP	   AL,CLEAR_TO_SEND+DATA_SET_READY
	   CMP	   AL,DATA_SET_READY					;C03
;	   $IF	   E			;IF clear to send and dsta set ready THEN
	   JNE $$IF3
	      MOV     AH,90H		;'NOT BUSY' 'SELECTED'
;	   $ELSE			;ELSE clear to send high OR data set ready high
	   JMP SHORT $$EN3
$$IF3:
	      MOV     AH,10H		   ;SET TO PARALLEL 'BUSY' 'SELECTED'
;	   $ENDIF
$$EN3:
;	$ENDIF

ENDCOMMENT++++++++++++++++++++++++++++++++++++++++++ M007 ^

$$EN1:
	POP	DX			;RESTORE REG
	JMP	SHORT POPPER		;RESTORE REGS AND EXIT
;
SENDCHAR:
	MOV	AH,1			;SET TO INT 14 'SEND CHAR' ENTRY PT
	INT	14H			;GO RS232 SEND CHAR
;
	POP	DX			;RESTORE REG
	TEST	AH,80H			;TEST IF TIMEOUT RS232 ERROR
	MOV	AH,90H			;SET UP NORMAL RETURN AS IF FROM PRINTER
;			THAT IS: PARALLEL 'NOT BUSY' 'SELECTED'
	JZ	POPPER			;IF NO ERROR
	MOV	AH,09H			;RESET AH TO PARALLEL TIMEOUT ERROR CODE
;		    RET CODE='BUSY', 'I/O ERROR', 'TIMEOUT'
;		    THE USUAL RETURN FROM A WRITE DATA
;		    TO A PARALLEL PRINTER THAT IS OFFLINE
POPPER:
	POP	BX			;RETRIEVE ORIGINAL AX
	MOV	AL,BL			;RESTORE ORIGINAL AL VALUE LEAVING NEW AH
	POP	BX			;RESTORE BX
	IRET				;RETURN

;**********************************************************************
PAGE

PTSFLAG1 DB	0			;FLAG FOR MODE COMMAND:

NEW_PTSFLAG EQU PTSFLAG1 - MODETO	;WHEN THIS CODE IS
					; RESIDENT THE FLAG WILL BE ACCESSABLE TO
					; MODEECHO AS AN OFFSET FROM ADDRESS
					; POINTED TO BY VECT14H AND RESSEG
;		0=NO INTERCEPT
;		1=INTERCEPT LPT1
;		2=INTERCEPT LPT2
;		3=INTERCEPT LPT1 AND LPT2
;		4=INTERCEPT LPT3
;		5=INTERCEPT LPT1 AND LPT3
;		6=INTERCEPT LPT2 AND LPT3
;		7=INTERCEPT LPT1, LPT2, AND LPT3
RESFLAG2 EQU	$			;WHERE PTSFLAG2 IS IN THE RESIDENT CODE
PTSFLAG2 DB	0			;FLAG FOR MODE COMMAND:
;		    LPT1 CORRESPONDENCE VALUE:
;		0=COM1
;		1=COM2
;		2=COM3
;		3=COM4
;RESFLAG2 EQU	 (PTSFLAG2 - MODETO)+BASE ;WHERE PTSFLAG2
					; IS IN THE RESIDENT CODE
PTSFLAG3 DB	0			;FLAG FOR MODE COMMAND:
;		    LPT2 CORRESPONDENCE VALUE:
;		0=COM1
;		1=COM2
;		2=COM3
;		3=COM4
PTSFLAG4 DB	0			;FLAG FORMODE COMMAND:
;		    LPT3 CORRESPONDENCE VALUE:
;		0=COM1
;		1=COM2
;		2=COM3
;		3=COM4


lpt1_retry_type   DB	0	 ;holder of mask for status return byte 					;AN000;
lpt2_retry_type   DB	0	 ;can be one of no_retry_flag, error_status,					;AN000;
lpt3_retry_type   DB	0	 ;busy_status or ready_status, see MODEPRIN				       ;AN000;

PUBLIC lpt1_retry_type


;THE FOLLOWING AREA IS USED BY MODESCRN TO STORE THE VIDEO PARMS THAT
;ALLOW FOR THE SHIFTING RIGHT OR LEFT OF THE SCREEN IMAGE.
SCRNTABL DB	16 DUP("PARM")		;64 BYTES OF SPACE
NEW_SCRNTABL EQU SCRNTABL - MODETO	;OFFSET INTO RESIDENT
;			CODE OF THE 64 BYTE SCREEN TABLE

request     DB	  0	      ;holder for INT 14 or INT 17 request passed in AH
retry_type  DW	  0	      ;holder for INT 14 retry type and shift count

MODEPTS ENDP

rescode_length	  equ	(($ - entpt) / 16) + 1	  ;length of resident code in paragraphs

MOVELEN EQU	$ - entpt   ;length of resident code in bytes


;*******************************************************************************

	SUBTTL	LOAD THE RESIDENT PORTION OF MODE

	PAGE


MODELOAD PROC	NEAR
	PUBLIC	MODELOAD
;		    GET THE CONTENTS OF INT VECTOR 14H
;		    TO SEE IF THE RESIDENT CODE IS
;		    ALREADY LOADED
;		    SET UP REGS TO MOVE IT INTO PLACE
   PUSH    DS			   ;SAVE SEG REG
   PUSH    ES			   ;SAVE SEG REG
   PUSH    DI
   PUSH    SI			   ;SAVE FOR CALLING PROCEDURE
   PUSH    DX			   ;SAVE FOR CALLING PROCEDURE
   PUSH    AX			   ;SAVE FOR CALLING PROCEDURE
   PUSH    BX
   MOV	   AX,0 		   ;GET THE PARAGRAPH NUMBER OF DESTINATION
   MOV	   ES,AX		   ; TO THE EXTRA SEGMENT BASE
   LES	   DI,ES:RESSEG 	   ;GET POINTER TO RETRY CODE
;  IF THE CODE IS NOT ALREADY MOVED,
   .IF <DI EQ 0> THEN NEAR	   ;AC000;IF nothing at 50:30 THEN code is not loaded
;
;		    SINCE CODE HAS NOT YET BEEN MOVED,
;		    PATCH PROPER ADDRESSES INTO IT

;     .IF <retry_requested EQ true> AND      ;AN000;
;     .IF <device_type EQ COMX> THEN	     ;AN000;
;
;	 XOR	 AX,AX
;	 MOV	 ES,AX		     ;BACK TO THE VECTOR AT ZERO
;	 MOV	 AX,WORD PTR ES:VECT14H ;GET THE VECTOR OF INT 14H
;	 MOV	 VECTOR14+1,AX	     ; INTO CODE TO BE MOVED
;
;	 MOV	 AX,WORD PTR ES:VECT14H[2] ;MOVE REST OF VECTOR
;	 MOV	 VECTOR14+3,AX
;
;     .ENDIF				     ;AN000;
;
;     .IF <device_type EQ LPTX> AND	     ;AN000;
;     .IF <retry_requested EQ true> OR	     ;AN000;
;     .IF <reroute_requested EQ true> THEN   ;AN000;
;
;	 MOV	 AX,WORD PTR ES:VECT17H ;GET VECTOR OF INT 17H
;	 MOV	 VECTOR17+1,AX	     ; INTO CODE TO BE MOVED
;
;	 MOV	 AX,WORD PTR ES:VECT17H[2] ;MOVE REST OF VECTOR
;	 MOV	 VECTOR17+3,AX
;
;     .ENDIF				     ;AN000;


      PUSH    ES		  ;SAVE POINTER TO VECTOR ZERO

;Get and save previous interrupt handlers

      get_int_vect 14H		    ;get vector of INT 17H, ES:BX=vector
      MOV     VECTOR14+1,BX	  ;put offset INTO CODE TO BE MOVED
      MOV     VECTOR14+3,ES	  ;save segment

      get_int_vect 17H		    ;get vector of INT 17H, ES:BX=vector
      MOV     VECTOR17+1,BX	  ;put offset INTO CODE TO BE MOVED
      MOV     VECTOR17+3,ES	  ;save segment


      MOV     SI,OFFSET entpt	  ;WILL BE MOVED FROM HERE
      MOV     DI,OFFSET move_destination	;WILL BE MOVED TO HERE
      MOV     CX,MOVELEN	  ;NUMBER OF BYTES TO BE MOVED
      PUSH    CS		  ;GET SEGMENT OF PROGRAM HEADER
      POP     ES		  ; INTO ES, THE DESTINATION SEGMENT
      CLD			  ;INCREMENT SI AND DI AFTER EACH BYTE IS MOVED
      REP     MOVSB		  ;MOVE CX BYTES FROM DS:SI TO ES:DI
      POP     ES


;Put a pointer to the resident code 50:30 (0:530)

      CLI			  ;DISABLE UNTIL VECTOR SET

      MOV   ES:WORD PTR resseg,OFFSET modeto	   ;offset of "modeto" in res code pointer
      MOV   AX,CS
;C00  SUB   AX,adjustment_in_paragraphs 	   ;adjust res CS by amount the code moved
      SUB   AX,word ptr adjustment_in_paragraphs   ;adjust res CS by amount the code moved ;C00
      MOV   ES:WORD PTR resseg[2],AX		   ;store segment of res code in pointer

      STI			   ;allow some interrupts

;Set interrupts 14 and 17 to point to their respective handlers.  AX has correct segment.

      MOV   DS,AX				   ;DS=resident code segment
      MOV   DX,OFFSET modeto			   ;DS:DX=> INT14 handler "modeto"
      set_int_vect  INT14

      MOV   DX,OFFSET modepts			   ;DS:DX=> INT17 handler "modepts"
      set_int_vect  INT17

      MOV   ES,CS:environ_seg	 ;ES=segment of the block to be returned
      MOV   AH,49H		 ;49 is the Free Allocated Memory function call
      INT   21H 		 ;free the environment

      MOV     BYTE PTR CS:1,27H   ;SET EXIT TO REMAIN RESIDENT by dorking opcode in the PSP
;
      PUSH  CS
      POP   DS		;"PRINTF" requires that DS be the segment containing the messages

      DISPLAY MOVED_MSG 	  ;"Resident portion of MODE loaded"
      MOV     BYTE PTR CS:LOADED_YET,1 ;SET FLAG TO INDICATE ABOVE MSG
;				   HAS BEEN DISPLAYED
;				   MODESCRN MAY NEED TO REPEAT MESSAGE
;C00  MOV     stay_resident,true
      MOV     byte ptr stay_resident,byte ptr true			;C00
   .ENDIF			   ;AC000;END IS CODE ALREADY LOADED? TEST

	POP	BX
	POP	AX			;RESTORE FOR CALLING PROCEDURE
	POP	DX			;RESTORE FOR CALLING PROCEDURE
	POP	SI			;RESTORE FOR CALLING PROCEDURE
	POP	DI
	POP	ES			;RESTORE SEG REG
	POP	DS			;RESTORE SEG REG
	RET
MODELOAD ENDP

;************************************************************
	SUBTTL	COMMON PARMAMETER LIST AND WORKAREA
	PAGE
; THE FOLLOWING AREA IS USED TO STORE PARSED PARAMETER LIST, AND WORK STORAGE
; USED BY OTHER MODULES

;  N O N	 R E S I D E N T   D A T A  Í»
;											  

CTRL_ST DB	5 DUP(24)		;PRINTER CONFIGURATION CONTROL STRING
PARM1	DB	10 DUP(0)
PARM2	DB	-1			;-1 INDICATES TO SERVER THAT THIS PARM IS UNCHANGED
PARM3	DB	0
MODE	DB	0
FLAG	DB	0
INDEX	DW	00			;REDIRECTED PRINTER NETWORK REDIRECTION LIST INDEX
IS_LOCAL DB	TRUE			;INITIALIZE for MODEPRIN
LOADED_YET DB	false
LOCAL_NAME DB	16 DUP(0)		;HOLDING AREA FOR GET ASSIGN LIST ENTRY CALL USE
machine_type  DB 0FFH			;holder for the machine type
NOERROR DB	TRUE			;INDICATE NO ERROR MESSAGES HAVE BEEN ISSUED YET
NEW_VIDEO_PARMS_OFFSET DW 090H		;OFFSET OF INIT TABLE FOR SCREEN SHIFTING
NEW_VIDEO_PARMS_SEGMENT DW 040H 	;SEGMENT OF INIT TABLE FOR SCREEN SHIFTING
REMOTE_DEV DB	50 DUP(0)		;HOLDING AREA FOR GET ASSIGN LIST ENTRY CALL USE
stay_resident	  DB	false		;boolean indicating should stay resident when terminate
submodel_byte	  DB	0FFH		;secondary model byte


;											  
;  N O N	 R E S I D E N T   D A T A  Í¼


;  P U B L I C S  Í»
;											  

PUBLIC	PARM1,PARM2,PARM3,MODE,FLAG,CTRL_ST,INDEX,LOCAL_NAME,REMOTE_DEV       ;AC000;
PUBLIC	IS_LOCAL
PUBLIC	LOADED_YET
PUBLIC	machine_type		;holder for machine type, found in "main"
PUBLIC	NOERROR
PUBLIC	NEW_VIDEO_PARMS_OFFSET
PUBLIC	NEW_VIDEO_PARMS_SEGMENT
PUBLIC	stay_resident

;											  
;  P U B L I C S  Í¼

PRINTF_CODE ENDS
	END	ENTPT

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\mode\scrntab.asm ===
.SALL
	PAGE	,132			;
	TITLE	SCRNTABL.ASM - SCREEN SHIFT TABLE CONTROL FOR MODE COMMAND

;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

;  M A C R O S  Í»
;											  

SET	MACRO	REG,VALUE		;SET REG TO VALUE. DON'T SPECIFY AX FOR REG

	PUSH	AX
	MOV	AX,VALUE
	MOV	REG,AX
	POP	AX

ENDM

;											  
;  M A C R O S  Í¼


;  E Q U A T E S  Í»
;											  

ROM_BIOS_SEG EQU 0F000H 		;USED TO ADDRESS INIT TABLE IN ROM
VIDEO_VECTOR EQU 74H			;OFFSET INTO VECTOR TABLE (SEG=0)
					;TO DOUBLE WORD POINTER TO VIDEO PARMS
VIDEO_PARMS_WORD_LEN EQU 32		;NO. WORDS IN VIDEO PARM AREA

;											  
;  E Q U A T E S  Í¼


PRINTF_CODE SEGMENT PUBLIC
	ASSUME	DS:NOTHING, CS:PRINTF_CODE


;  E X T R N S	Í»
;											  

EXTRN	MODELOAD:NEAR
EXTRN	RESSEG:DWORD			;ADD OF POINTER TO RESIDENT CODE
EXTRN	NEW_SCRNTABL:ABS		;OFFSET OF INIT TABLE WITHIN THE RESIDENT CODE
EXTRN	NEW_VIDEO_PARMS_OFFSET:WORD
EXTRN	NEW_VIDEO_PARMS_SEGMENT:WORD

;											  
;  E X T R N S	Í¼


;  P U B L I C S  Í»
;											  
;											  
;  P U B L I C S  Í¼



ROM_BIOS SEGMENT AT 0F000H

	ORG	0FFFEH

	MACHINE_TYPE LABEL   BYTE	;MACHINE TYPE BURNED IN ROM

ROM_BIOS ENDS

PAGE
;*********************************************************************************************

SCRNTAB PROC	NEAR
PUBLIC	SCRNTAB
;	 GO TO THE 64 BYTES POINTED TO BY THE VECTOR AT 0:74H AND MOVE A COPY
;	 OF THESE BYTES TO THE MODE COMMAND RESIDENT AREA LEAVING DS POINTING TO
;	 THE SEGMENT OF THE TABLE, AND BX CONTAINING THE OFFSET OF THE TABLE.
;	 BIGTOP BIOS OVERWRITES AREA AT 40:90, AS DO OTHER APPS SO MUST LOAD THE
;	 TABLE INTO MODE'S RESIDENT CODE.

 PUSH	 ES			 ;SAVE ADDR OF PROGRAM HEADER PREFIX AREA
 MOV	 AX,0			 ;ADDR OF VECTOR TABLE
 MOV	 DS,AX			 ;SET DATA SEGMENT TO 0 MEMORY
 MOV	 BX,DS:VIDEO_VECTOR+2	 ;SEGMENT OF VIDEO PARMS
 CMP	 BX,ROM_BIOS_SEG
;$IF	 E			 ;IF haven't moved the table THEN
 JNE $$IF1
			    ;load the resident code
    PUSH    DS
    SET     DS,CS	    ;MODELOAD DEPENDS ON DS BEING SEG OF TO BE RES CODE
    CALL    MODELOAD	    ;LOAD RESIDENT CODE OVERLAYING PSP
    POP     DS		    ;RESTORE TO SEGMENT 0
			    ;Save address of resident code
    SET     CS:NEW_VIDEO_PARMS_SEGMENT,< WORD PTR DS:RESSEG+2 >
    MOV     AX,WORD PTR DS:RESSEG	;AX=offset of MODETO within resident code
    ADD     AX,NEW_SCRNTABL		;AX=OFFSET OF VIDEO PARMS FROM RES CODE SEG
    MOV     WORD PTR CS:NEW_VIDEO_PARMS_OFFSET,AX ;SEE "RESCODE"

    MOV     DI,AX	;DI=NEW_VIDEO_PARMS_OFFSET, SET UP ES:DI FOR MOVSW INSTRUCTION
    MOV     AX,CS:NEW_VIDEO_PARMS_SEGMENT
    MOV     ES,AX		;ES=RESIDENT CODE SEGMENT
    MOV     SI,DS:VIDEO_VECTOR	;GET SEGMENT OF VIDEO PARMS
    MOV     DS:VIDEO_VECTOR,DI	;CHANGE VIDEO OFFSET
    MOV     DS:VIDEO_VECTOR+2,ES ;CHANGE VIDEO SEGMENT
    MOV     DS,BX		;CHANGE DS TO ROM SEGMENT
    MOV     CX,VIDEO_PARMS_WORD_LEN ;COUNT TO MOVE 32 WORDS
    CLD 			;INCREMENT SI AND DI WHILE MOVING THE TABLE
    REP     MOVSW		;MOVE 64 BYTES VIDEO PARMS TO RES AREA

;$ENDIF 			 ;I HAVE MOVED IT YET
$$IF1:

 SET	 DS,0
 LDS	 BX,DS:RESSEG	     ;DS:BX POINTS TO RESIDENT CODE
 ADD	 BX,NEW_SCRNTABL     ;DS:BX POINTS TO NEW VIDEO TABLE

 POP	 ES			 ;RESTORE ADDR OF PROGRAM HEADER PREFIX
 RET				 ;RETURN TO MODESCRN PROC

SCRNTAB ENDP


PRINTF_CODE ENDS
	END

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\nlsfunc\doesmac.inc ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

CallInstall MACRO   name,mpx,fn,save,restore
BREAK	MACRO	subtitle
	SUBTTL	subtitle
	PAGE
ENDM
.xcref	break
IF Installed
    IFNB    <save>
	SaveReg <save>
    ENDIF
	MOV	AX,(mpx SHL 8) + fn
	INT	2Fh
    IFNB    <restore>
	RestoreReg  <restore>
    ENDIF
ELSE
	Invoke	name
ENDIF
ENDM

BREAK <SaveReg - save a set of registers>

SaveReg MACRO	reglist 		;; push those registers
IRP reg,<reglist>
	?stackdepth = ?stackdepth + 1
	PUSH	reg
ENDM
ENDM
.xcref	SaveReg

BREAK <RestoreReg - unsave some registers>

RestoreReg  MACRO   reglist		;; pop those registers
IRP reg,<reglist>
	?stackdepth = ?stackdepth - 1
	POP	reg
ENDM
ENDM
.xcref	RestoreReg

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\more\more.inc ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	      ;AN000;
;								      ;AN000;
; MORE STRUC AND EQUATES					      ;AN000;
;								      ;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	      ;AN000;
;								      ;AN000;
ANSI_GET	EQU    440CH					      ;AN000;
GET_SUBFUNC	EQU    037FH					      ;AN000;
EXTENDED	EQU    0					      ;AN000;
TEXT_MODE	EQU    1					      ;AN000;
MORE_MSG	EQU    2					      ;AN000;
FILE_TYPE_MSG	EQU    4					      ;AN001;
DATA_LENGTH	EQU    14					      ;AN000;
LINESPERPAGE	EQU    24		; default screen size

ifdef JAPAN
LINELENGTH	EQU	80		; default line length
endif

;								      ;AN000;
ANSI_STR    STRUC						      ;AN000;
	    DB	  0						      ;AN000;
	    DB	  0						      ;AN000;
	    DW	  DATA_LENGTH					      ;AN000;
	    DW	  ?						      ;AN000;
D_MODE	    DB	  ?						      ;AN000;
	    DB	  ?						      ;AN000;
	    DW	  ?						      ;AN000;
	    DW	  ?						      ;AN000;
	    DW	  ?						      ;AN000;
SCR_COLS    DW	  ?						      ;AN000;
SCR_ROWS    DW	  ?						      ;AN000;
ANSI_STR    ENDS						      ;AN000;


; Command tail equates

CommandTail		equ	0080h
SWITCHAR		equ	'/'
OPTNCHAR		equ	'?'
SPACE			equ	' '


; Message equates for options help messages

MSG_OPTIONS_FIRST	equ	300
MSG_OPTIONS_LAST        equ     304
MSG_INV_ARG		equ	3

; end of more.inc
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\nlsfunc\funcdbcs.inc ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

;; generic ioctl call data "packet" pointed to by DS:DX    =E
PACKET		STRUC	   ;USED BY MINOR CODES: 6AH,4AH,4DH (SELECT, QUERY SELECTED, PREPARE END)  =E
PACKLEN 	DW   0	     ;LENGTH OF PACKET IN BYTES =E	  2/16/KK
PACKCPID	DW   0	   ;CODE PAGE ID	      =E
DBCS_EV 	DB   0,0   ; 2/16/KK
		DB   0,0   ; 2/16/KK
		DB   0,0   ; 2/16/KK
		DB   0,0   ; 2/16/KK
		DB   0,0   ; 2/16/KK
		DB   0,0   ; 2/16/KK
		DB   0,0   ; 2/16/KK
		DB   0,0   ; 2/16/KK
PACKET		ENDS


STD_CPLENGTH  equ	2
PK	      PACKET <>  ;CNS

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\mode\typamat.asm ===
.XLIST
INCLUDE STRUC.INC
.LIST
.SALL
	PAGE	,132			;
	TITLE	TYPAMAT.SAL - TYPAMATIC RATE AND DELAY CONTROL FOR MODE COMMAND

;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */


;
;
; SET_TYPAMATIC
; -------------
; Translate the input parameters into BIOS digestable values and make the
; required calls.  Typamatic support in BIOS exists only in machines with
; BIOS dated 11/15/85 or later, XT286 and all PS/2 products.
;
;
;; INPUT:	 A binary value from 1 to 32 indicating the typamatic rate
;		 desired and a binary value from 1 to 4 indicating the delay.
;		 Status is not supported on machines known today.
;		 The translation of the typamatic value to BIOS
;		 input is 32 - r where 'r' is the input value.  The translation
;		 from 'd' the input delay value to the BIOS is d - 1.  'r'
;		 is passed in BL, 'd' is passed in BH.
;
;  RETURN:	 none
;
;
;  MESSAGES:	 none
;
;
;
;  REGISTER
;  USAGE AND
;  COMVENTIONS: BX is used to pass parameters to BIOS
;		 The names used to represent the valid machines are: AT3, XT286,
;		 PS2Model30, PS2Model50, PS2Model60 and PS2Model80.
;
;  ASSUMPTIONS: Input values are valid.
;
;
;  SIDE EFFECT:
;
;
;   
;
; BEGIN
;
; IF (machine_type>AT) OR ((machine_type=AT) AND (BIOS_date >= 11/15/85)) OR
;    (machine_type=XT286) THEN
;    IF typamatic_rate <> 0 THEN						   
;	 MOV	 BL,32-BL	    ;translate typamatic rate			   
;    ELSE									   
;	 MOV	 BL,previous_typamatic_rate	    ;not specified so no change    
;    ENDIF									   
;    IF delay <> 0 THEN							   
;	 SUB	 BH,1		    ;translate delay				   
;    ELSE									   
;	 MOV	 BH,previous_delay_rate 					   
;    ENDIF									   
;    MOV	 AH,set_typamatic_rate_and_delay    ;INT 16 set typamatic function 
;    MOV	 AL,typamatic_function		    ;set typamatic subfunction	   
;    INT	 16H								   
; ELSE 									
;    queue Function_not_supported						
; ENDIF									
;										
; END										
;
;




;  M A C R O S  Í»
;											  



DISPLAY MACRO	MESSAGE
	MOV	DX,OFFSET MESSAGE
	CALL	PRINTF
ENDM

SET	MACRO	REG,VALUE		;SET REG TO VALUE. DON'T SPECIFY AX FOR REG

	PUSH	AX
	MOV	AX,VALUE
	MOV	REG,AX
	POP	AX

ENDM

;											  
;  M A C R O S  Í¼


;  E Q U A T E S  Í»
;											  

get_installed_state  EQU   0	  ;function of MODE INT 2FH handler
get_typamatic_delay  EQU   04	  ;function of MODE INT 2FH handler
get_typamatic_rate   EQU   03	  ;function of MODE INT 2FH handler
installed	     EQU   0FFH   ;return from MODE INT 2FH handler
no_previous_setting  EQU   0FFH   ;return from MODE INT 2FH handler get setting call
one_half_second      EQU   01	  ;value for BIOS INT 16H
resident_MODE	     EQU   0AFH   ;INT 2F multiplex number for resident part of MODE
save_typamatic_delay EQU   02	  ;function of MODE INT 2FH handler
save_typamatic_rate  EQU   01	  ;function of MODE INT 2FH handler
set_typamatic_rate_and_delay  EQU   3
typamatic_function   EQU   5
ten_chars_per_second EQU   0CH	  ;value for BIOS INT 16H

INCLUDE modequat.inc		 ;definitions of machine types
include version.inc		; defines version of DOS to be built

;											  
;  E Q U A T E S  Í¼


PRINTF_CODE SEGMENT PUBLIC
	ASSUME	DS:NOTHING, CS:PRINTF_CODE


;  E X T R N S	Í»
;											  

EXTRN	 PRINTF:NEAR
EXTRN	 MACHINE_TYPE:BYTE		     ;MACHINE TYPE as determined by "modeleng"
;EXTRN	  typamatic_rate_set_to:WORD
;EXTRN	  chars_per_second:WORD
EXTRN	 noerror:BYTE
;EXTRN	  no_previous_typamatic_rate:WORD
EXTRN	 Function_not_supported:BYTE		      ;see modedefs.inc
;EXTRN	  delay_set_to:WORD
;EXTRN	  second:WORD
;EXTRN	  no_previous_delay_setting:WORD
;EXTRN	  delay_set_to_one_half_second:WORD

;											  
;  E X T R N S	Í¼


; D A T A Í»
;											  

thirty_two  DB	  20H			    ;adjustment and work area for typamatic rate

;											  
; D A T A Í¼


;  P U B L I C S  Í»
;											  
;											  
;  P U B L I C S  Í¼




PAGE
;*********************************************************************************************

TYPAMAT PROC	NEAR
PUBLIC	TYPAMAT

if IBMCOPYRIGHT
.IF <machine_type EQ AT4> OR
.IF <machine_type EQ XT286> OR
;.IF <machine_type EQ AT> OR
.IF <machine_type EQ PS2Model30> OR
.IF <machine_type EQ PS2Model50> OR
.IF <machine_type EQ PS2Model60> OR
.IF <machine_type EQ PS2Model80> THEN
endif
;  MOV	   AH,resident_MODE
;  MOV	   AL,get_installed_state
;  INT	   2FH
;  CMP	   AL,installed
;  .IF	   NE					    ;IF the code is not resident THEN
;     CALL    modeload				       ;make it resident
;  .ENDIF					    ;ENDIF
;  CMP	   BL,0 				    ;CASE typamatic_rate OF
;  .IF	   GT						greater than zero:
      SUB     thirty_two,BL			    ;	   MOV	   BL,32-BL	      ;translate typamatic rate
      MOV     BL,thirty_two

;     DISPLAY	typamatic_rate_set_to,BL
;     DISPLAY	chars_per_second

;  .ELSEIF EQ					    ;	zero:
;     MOV     AH,resident_MODE
;     MOV     AL,get_typamatic_rate		    ;	   MOV	   BL,previous_typamatic_rate	      ;not specified so no change
;     INT     2FH
;     CMP     BL,no_previous_setting
;     .IF     E
;	 DISPLAY   no_previous_typamatic_rate
;	 DISPLAY   typamatic_set_to_ten_chars_per_second
;	 MOV	 BL,ten_chars_per_second
;     .ENDIF
;  .ELSE					    ;	less than zero:
;     MOV     AH,resident_MODE
;     MOV     AL,get_typamatic_rate		    ;	   return setting in BL
;     INT     2FH
;     .IF     <BL EQ no_previous_setting> THEN
;	 DISPLAY    no_previous_typamatic_rate
;     .ELSE
;	 SUB	 thirty_two,BL
;	 MOV	 BL,thirty_two			    ;	   translate to humanese
;     .ENDIF
;  .ENDIF					    ;ENDCASE
;  CMP	   BH,0 				    ;CASE delay OF
;  .IF	   GT						>zero:
      DEC     BH				    ;	   SUB	   BH,1 	      ;translate delay


;     DISPLAY	delay_set_to_?_second


;  .ELSEIF EQ					    ;	zero:
;     MOV     AH,resident_MODE
;     MOV     AL,get_typamatic_delay		    ;	   MOV	   BH,previous_delay_rate
;     INT     2FH
;     CMP     BH,no_previous_setting
;     .IF     E
;	 DISPLAY   no_previous_delay_setting
;	 DISPLAY   delay_set_to_one_half_second
;	 MOV	 BH,one_half_second
;     .ENDIF
;  .ELSE					    ;	<zero:
;     MOV     AH,resident_MODE
;     MOV     AL,get_typamatic_rate		    ;	   return setting in BH
;     INT     2FH
;     .IF     <BH EQ no_previous_setting> THEN
;	 DISPLAY    no_previous_delay_setting
;     .ELSE
;	 INC   BH
;     .ENDIF
;  .ENDIF					    ;ENDCASE
;  MOV	   AH,resident_MODE
;  MOV	   AL,save_typamatic_rate
;  INT	   2FH
;  MOV	   AH,resident_MODE
;  MOV	   AL,save_typamatic_delay
;  INT	   2FH
   MOV	   AH,set_typamatic_rate_and_delay	    ;MOV	AH,set_typamatic_rate_and_delay    ;INT 16 set typamatic function
   MOV	   AL,typamatic_function		    ;MOV	AL,typamatic_function		   ;set typamatic subfunction
   INT	   16H					    ;INT	16H
if IBMCOPYRIGHT
.ELSE
   DISPLAY Function_not_supported
   MOV	 noerror,false
.ENDIF
endif

RET

TYPAMAT ENDP


PRINTF_CODE ENDS
	END

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\more\more.asm ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

;******************************************************************************
;
; MODULE:   more.asm
;
; Modification History:
;
;  Version    Author	       date	   comment
;  -------    ------	       ----	   -------
;  V4.0       RussW			   ;AN000; initial extended attr. support
;
;  V4.0       Bill L	      9/17/87	   ;AN001; DCR 201 - extended attr. enhancement
;					   ;AN002; DCR 191
;					   ;AN003; PTM 3860 - add CR-LF to make DOS3.3 compat.
;******************************************************************************

FALSE	EQU	0
TRUE	EQU	NOT FALSE

IBMJAPVER   EQU FALSE

STDOUT	EQU	1			 ;AN003;

BREAK	MACRO	subtitle
	SUBTTL	subtitle
	PAGE
ENDM

	include	version.inc
	INCLUDE SYSCALL.INC

	INCLUDE MORE.INC		 ;MORE strucs and equates
	.XLIST				 ;
	INCLUDE STRUC.INC		 ;Structured macros
	INCLUDE SYSMSG.INC		 ;Message retriever code
	include rombios.inc		 ;ROM BIOS data definition
	.LIST				 ;

MSG_UTILNAME <MORE>			 ;

CODE	SEGMENT PUBLIC
	ORG	100H
ASSUME	CS:CODE,DS:CODE,ES:CODE,SS:CODE


START:
	CALL	SYSLOADMSG
	jnc	chk_opt
	CALL	SYSDISPMSG
	MOV	AH,EXIT
	INT	21H

	; Check for /? on the command line.
chk_opt:
	CALL	CHECK_OPTIONS
	jnc	get_dev_char
	MOV	AH,EXIT
	INT	21H

	; get number of lines on the screen
get_dev_char:

ifdef JAPAN

	mov	MAXROW,LINESPERPAGE 	; assume 24 rows
	mov	MAXCOL,LINELENGTH	; assume 80 columns

else

	push	ds
	mov	ax,ROMBIOS_DATA 	  ;Get ROM Data segment
	mov	ds,ax
	Assume	DS:ROMBIOS_DATA

	mov	al,CRT_Rows		  ;Get max rows
	pop	ds
	Assume	DS:Code

	or	al,al			  ;If zero specified
	jnz	@F
	mov	al,LINESPERPAGE 	  ;assume 24 rows

@@:
	mov	maxrow,al		  ;set lines per page from ROM BIOS
endif

;
; Check if ANSI is loaded, and if so, use it to find screen dimensions
;

	MOV	AX,ANSI_GET		  ;prepare for device characteristics..
	MOV	BX,STDERR		  ;request.
	MOV	CX,GET_SUBFUNC		  ;get subfunction..
	LEA	DX,ANSI_BUF		  ;point to buffer.
	INT	21H
	jc	no_ansi

;
; ANSI is around and get tell us the screen dimensions
;

	LEA	DI,ANSI_BUF
	cmp	[di].d_mode, TEXT_MODE	  ;if we are in a text mode then..
	jne	no_ansi 		  ;default already initialized
	MOV	AX,[DI].SCR_ROWS	  ;store the screen length...else..
	MOV	MAXROW,AL		  ;default (25) is assumed.

ifdef JAPAN
	mov	ax,[di].SCR_COLS
	mov	MAXCOL,al
no_ansi:

else

no_ansi:
	MOV	AH,0FH
	INT	10H
	MOV	MAXCOL,AH

endif

	XOR	BX,BX			; DUP FILE HANDLE 0
	MOV	AH,XDUP
	INT	21H
	MOV	BP,AX			; Place new handle in BP

	MOV	AH,CLOSE		; CLOSE STANDARD IN
	INT	21H

	MOV	BX,2			; DUP STD ERR TO STANDARD IN
	MOV	AH,XDUP
	INT	21H

	MOV	CX,CRLF_LEN		;AN003; ;display a newline
	MOV	DX,OFFSET CRLF		;AN003;
	MOV	BX,STDOUT		;AN003;
	MOV	AH,WRITE		;AN003;
	INT	21H			;AN003;
ALOOP:
	CLD
	MOV	DX,OFFSET BUFFER
	MOV	CX,4096
	MOV	BX,BP
	MOV	AH,READ
	INT	21H
	OR	AX,AX
	JNZ	SETCX
DONE:	INT	20H
SETCX:	MOV	CX,AX
	MOV	SI,DX

TLOOP:
	LODSB
	CMP	AL,1AH
	JZ	DONE

ifdef DBCS
	cmp	dbcs_flag,1
	jz	set_dbcs		; if last char was lead byte
	cmp	dbcs_flag,2
	jnz	@f			; if last char was not tail byte
	mov	dbcs_flag,0
@@:
	call	IsDBCSLeadByte
	jnz	not_lead		; if this is not lead byte
@@:
	mov	ah,CURCOL
	inc	ah
	cmp	ah,MAXCOL
	jbe	set_dbcs		; if this is not at last column
	dec	si			; put back
	inc	cx
	inc	CURROW			; go to next row
	mov	CURCOL,1
	mov	al,' '
	jmp	short ISCNTRL
set_dbcs:
	inc	dbcs_flag
not_lead:
endif

	CMP	AL,13
	JNZ	NOTCR
	MOV	BYTE PTR CURCOL,1
	JMP	SHORT ISCNTRL

NOTCR:	CMP	AL,10
	JNZ	NOTLF
	INC	BYTE PTR CURROW
	JMP	SHORT ISCNTRL

NOTLF:	CMP	AL,8
	JNZ	NOTBP
	CMP	BYTE PTR CURCOL,1
	JZ	ISCNTRL
	DEC	BYTE PTR CURCOL
	JMP	SHORT ISCNTRL

NOTBP:	CMP	AL,9
	JNZ	NOTTB
	MOV	AH,CURCOL
	ADD	AH,7
	AND	AH,11111000B
	INC	AH
	MOV	CURCOL,AH
	JMP	SHORT ISCNTRL

NOTTB:
	CMP	AL,7
	JZ	ISCNTRL

	INC	BYTE PTR CURCOL
	MOV	AH,CURCOL
	CMP	AH,MAXCOL
	JBE	ISCNTRL
	INC	BYTE PTR CURROW
	MOV	BYTE PTR CURCOL,1

ISCNTRL:
	MOV	DL,AL
	MOV	AH,STD_CON_OUTPUT
	INT	21H
	MOV	AH,CURROW
	CMP	AH,MAXROW
	JB	CHARLOOP

ASKMORE:
	PUSH	BP			;AN000; ;save file handle
	PUSH	SI			;AN000; ;save pointer
	PUSH	CX			;AN000; ;save count
	MOV	AX,MORE_MSG		;AN000; ;use message retriever..
	MOV	BX,STDERR		;AN000; ;to issue..
	XOR	CX,CX			;AN000; ;-- More --
	MOV	DL,NO_INPUT		;AN000;
	MOV	DH,UTILITY_MSG_CLASS	;AN000;
	CALL	SYSDISPMSG		;AN000;

	MOV	AH,STD_CON_INPUT_FLUSH	 ;WAIT FOR A KEY, NO ECHO
	MOV	AL,STD_CON_INPUT_NO_ECHO ;AC000; ;no echo
	INT	21H

	CMP	AL,EXTENDED		;AN000; ;Check for extended key?
	JNE	NOT_EXTENDED		;AN000; ;continue
	MOV	AH,STD_CON_INPUT_NO_ECHO ;AN000; ;clear extended key
	INT	21H			;AN000; ;

NOT_EXTENDED:
	MOV	CX,CRLF2_LEN		;AC003; ;place cursor..
	MOV	DX,OFFSET CRLF2 	;AC003; ;..on new line.
	MOV	BX,STDERR		;AN000;
	MOV	AH,WRITE		;AN000;
	INT	21H			;AN000;
	POP	CX			;AN000; ;restore count
	POP	SI			;AN000; ;restore pointer
	POP	BP			;AN000; ;restore file handle

	MOV	BYTE PTR CURCOL,1
	MOV	BYTE PTR CURROW,1

CHARLOOP:
	DEC	CX
	JZ	GOBIG
	JMP	TLOOP
GOBIG:	JMP	ALOOP


;----------------------------------------------------------------
;
; CHECK_OPTIONS
;
; on entry:
;   no value passed
;   DS:80 has the command tail
;
; on exit:
;   if /? option found:
;     options help message displayed
;     carry set
;   else
;     nothing displayed
;     carry clear
;   all non-segment registers used.
;
; function:
;   Check the command tail to see if the user specified /?.
;   If so, display the options help message, and set the
;   carry flag so the program will end and they can try again.
;
;----------------------------------------------------------------

	PUBLIC	CHECK_OPTIONS
CHECK_OPTIONS	PROC	NEAR

	; Pick up a pointer to the command tail.

	mov	si, CommandTail		; len and tail

	; See if the user put "/?" on the command line somewhere.
	; If so, that's our cue to display the options help.

	mov	cl, [si]		; get the command tail length
	xor	ch, ch			;  as a word
	jcxz	CO_Done			; done if no tail
	inc	si			; point to start of tail
	xor	ax,ax			; ah = 0 -> no error
CO_FindSwitchLoop:
	lodsb				; get next char
	cmp	al, SWITCHAR		; is it '/?'?
	je	CO_Switch		; yes, look for ?
	cmp	al,SPACE		
	je 	CO_ForNxtChar
	inc	ah			; some redundant arg given
CO_ForNxtChar:	
	loop	CO_FindSwitchLoop
	jmp	short CO_invcmdline

	; Switch found.
	; See if it's one we know about.

CO_Switch:
	jcxz	CO_dsperr		; if no switch after switch char,error
	cmp	byte ptr[si], OPTNCHAR	; is it '?'?
	je	CO_Display		;  jump if so
CO_SwitchInvalid:
	inc	si			; pass it by
	inc	ah			; invalid switch error
	loop	CO_FindSwitchLoop	; go for next char

; some arg has been given ; since more does not have any args except /?,
; display error message and quit

CO_invcmdline:
	or	ah,ah			; was there an error ?
	jz	CO_Done			; no, just quit
CO_dsperr:
	mov	ax, MSG_INV_ARG		; message number
	mov	bx, STDERR		; stderr handle
	xor	cx, cx			; substitution count
	mov	dl, NO_INPUT		; no input needed
	mov	dh, UTILITY_MSG_CLASS	; message class
	call	SYSDISPMSG		; display it
	mov	ax,1			; error code
	stc
	jmp	short CO_Exit


	; Display each line of the options help message.
	; Assumes that AX, BX, CX, and DX are not modified
	; by SYSDISPMSG.

CO_Display:
	mov	ax, MSG_OPTIONS_FIRST	; message number
	mov	bx, STDOUT		; output handle
	xor	cx, cx			; substitution count
	mov	dl, NO_INPUT		; no input needed
	mov	dh, UTILITY_MSG_CLASS	; message class
CO_Display_Loop:
	call	SYSDISPMSG		; display it
	cmp	ax, MSG_OPTIONS_LAST	; see if last message
	je	CO_Display_Done		;  done if so
	inc	ax			; else bump message number
	jmp	short CO_Display_Loop	;  and go do next one

	; Exits

CO_Display_Done:
	xor	al, al			; return code
	stc				; flag to exit program
	jmp	short CO_Exit		;  and leave
CO_Done:
	clc				; flag no /? found
CO_Exit:
	ret


CHECK_OPTIONS	ENDP

ifdef DBCS
;
;	Test if the character is DBCS Lead Byte
;
;	input:	AL = character to check
;	outpit:	ZF = 1 if DBCS Lead Byte
;

DBCSLeadByteTable	dd	0

IsDBCSLeadByte		proc	near
	push	ax
	push	si
	push	ds
	lds	si,cs:DBCSLeadByteTable
	cmp	word ptr cs:DBCSLeadByteTable+2,0
	jnz	idlb_check		; if table is already set
	push	ax
	mov	ax,6300h
	int	21h			; get DBCS lead byte table
	pop	ax
	mov	word ptr cs:DBCSLeadByteTable,si
	mov	word ptr cs:DBCSLeadByteTable+2,ds
idlb_check:
	cmp	word ptr [si],0
	jz	idlb_not		; if end of table
	cmp	al,[si]
	jb	idlb_next		; if below low value
	cmp	al,[si+1]
	jbe	idlb_yes		; if below high value
idlb_next:
	add	si,2			; do next
	jmp	short idlb_check
idlb_not:
	or	al,1			; reset ZF
	jmp	short idlb_end
idlb_yes:
	and	al,0			; set ZF
idlb_end:
	pop	ds
	pop	si
	pop	ax
	ret
IsDBCSLeadByte		endp
endif


MAXROW	DB	25
MAXCOL	DB	80
CURROW	DB	1
CURCOL	DB	1
ifdef DBCS
dbcs_flag	db	0		; 0=single, 1=lead byte, 2=tail byte
endif

ANSI_BUF ANSI_STR <>			;AN000; ;buffer for IOCTL call

.XLIST					;AN000;
MSG_SERVICES <MSGDATA>			;AN000; ;message retriever code
MSG_SERVICES <LOADmsg,DISPLAYmsg,NOCHECKSTDIN>	;AN002;
MSG_SERVICES <MORE.CL1> 		;AN000;
MSG_SERVICES <MORE.CL2> 		;AN000;
MSG_SERVICES <MORE.CLA> 		;AN000;
.LIST					;AN000;

CRLF	    DB	   13,10		   ;AC000;
CRLF_LEN    DW	   $ - CRLF		   ;AC000;
CRLF2	    DB	   13,10,13,10		   ;AN003;
CRLF2_LEN   DW	   $ - CRLF2		   ;AN003;

BUFFER	LABEL BYTE

CODE	ENDS
	END	START

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\nlsfunc\nlsfunc.asm ===
PAGE	,132  ;
	TITLE	NLSFUNC - GET/SET CP & COUNTRY INFO   CHCP SUPPORT

;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

;**************************************************************************
;This is the NLSFUNC int2f command that supports the INT21h functions
;Get_Extended Country Information and the Set_codepage...
;NLSFUNC will read the COUNTRY.SYS information from disk , store the
;data in a buffer , then move the information into a buffer
;area specified by DOS.
;d:NLSFUNC {path}
;									 *
;CHECKINSTALL:								 *
;CheckRequest proc							 *
;	  If installed previously					 *
;	     report back error already installed and exit		 *
;	  otherwise  goto install					 *
;Checkrequest endp							 *
;*************************************************************************
;				NEW CODE				 *
;*************************************************************************
subttl get extended country data
page
;
;***************************************
;*  Process_Path Procedure	       *
;***************************************
;*  CALL SYSLOADMSG		       *
;*  Do DOS Version check	       *
;*  If ne X.X then (carry set)		*
;*   CALL SYSDISPLAY_MSG	       *
;*   DISPLAY_MSG(Message number 001)   *
;*    (001 - Incorrect DOS Version)    *
;*    (Class 3 - Utility Msg)	       *
;*   exit			       *
;*  else			       *
;*   Establish addressability	       *
;*   to command line parms (DS:SI)     *
;*   Establish addressability to PARM  *
;*   control block	   (ES:DI)     *
;*				       *
;*     Call SYSPARSE for filename      *
;*     GET Parse Block results	       *
;*     IF PARSE_ERROR		       *
;*	  CALL SYSDISPLAY_MSG (Class 2)*
;*	  DISPLAY_MSG = PARSE_NUM      *
;*     ELSE			       *
;*	  SUCCESSFUL_PARSE (0 or -1)   *
;*     ENDIFELSE		       *
;*     GET_PARSE_RESULTS Path_Spec     *
;*     IF No path exist then	       *
;*	  assume current directory     *
;*	  assume default filename      *
;*     ENDIF			       *
;*     IF No Drive exist then	       *
;*	  Use Current Drive	       *
;*     ENDIF			       *
;*     IF No filename exist then       *
;*	  assume default filename      *
;*	  and concatenate with drive   *
;*     ENDIF			       *
;*     CHECK_PATH		       *
;*     IF PATH EXIST THAN	       *
;*	  INSTALL_NLS	(NLS_RESCODE)  *
;*     ENDIF			       *
;*     ELSE NOT PATH_EXIST THAN        *
;*	  GET_PARSE_RESULTS (Class 3)  *
;*	  PASS_TO_MSGTXT (Message 003) *
;*	  (File not found %1)	       *
;*	  ERR_CODE SET TO 2	       *
;*	  EXIT			       *
;*     ENDIFELSE		       *
;*				       *
;*  INSTALL_NLS 		       *
;*	  CHECK INSTALL FLAG	       *
;*	  IF INSTALLED		       *
;*	     (Class 3)		       *
;*	     PASS_TO_MGSTXT (Msg 002)  *
;*	     %1 already installed      *
;*	  ELSE			       *
;*	     HOOK IN CODE	       *
;*	     TERMINATE & STAY RESIDENT *
;*	  ENDIFELSE		       *
;*				       *
;*				       *
;*   EXIT			       *
;*	 CHECK FOR ERRORCODE	       *
;*	 exit to DOS		       *
;***************************************
;
;INSTALL:
;	  Get the current 2f handler in the chain
;	  make it the next install my handler in the
;	  beginning of the the chain using get interrupt (25)
;	  and set interrupt (35); Once in the chain
;	  terminate and stay resident.
;
;DOS NEEDS ME.......
;
;Install Dos Interface Logic
;     Dos issues Call Install
;	     Establish residency
;	  If Mult Id is mine	(* NLSFUNC*)
;	     CheckInstall Status to see if installed or not
;	  otherwise
;	     jump to the next 2f handler
;CheckInstall
;	  If not installed returns
;	  If installed program is executed  (*NLSFUNC resident portion *)
;*******************************************************************************
;
;Program Logic
;
;     Check to make sure not reserved DOS number in the al
;
;     Go establish which function is to be performed
;
;Sel_Func proc
;	  mov FUNC_CODE,al
;	  case
;	     function code = 0
;	     function code = 1
;	     function code = 2
;	     function code = 3
;	     function code = 4
;	  otherwise error_routine
;	  return
;Sel_Func endp


;funcode0 proc
;INSTALL     NLSFUNC must be installed in mem
;	     return 0FFh that I am installed
;funcode0 endp

;funcode1 proc
;	    (* Means Set codepage and "select" device drivers*)
;	    same at funcode 3 plus device drivers are invoked with the
;	    specified code page.
;funcode1 endp

;funcode2 proc
;	   (* Get_extended_country info issued by DOS not in buffer*)
;	    BP = info_type
;	    call trans_Cty_Data Proc
;	    return
;funcode2 endp

;funcode3 proc
;	    (* Means Set codepage *)
;	    On entry DOS gives me the CODEP in BX & the CC in DX,SIZE in CX
;	     Search for Country.sys file on disk
;	    if file is found	  }BUFFER will exist in code 320 (can be altered)
;		the control buffer = 64 bytes of the buffer
;		the data buffer = 256 bytes of the buffer
;	     call Trans_Cty_Data Proc
;	    otherwise return an error flag
;	     return
;funcode3 endp


;funcode4 proc
;	   (* Get_extended_country info - old 38 call*)
;	    set flag and same as funcode 2
;	    data returned slightly Revised
;funcode4 endp

;	   ****************************
;	    if selected is FUNCTION 1, 3
;	       PassDOS_Data(*ES:DI*)
;	    otherwise FUNCTION 2, 4
;	       Get the INFO ID
;	       Flag that it is function 2
;	       PassUserData(*ES:DI*)
;	    mov NO_ERRORS to ERROR_FLAG
;	    ****************************
;Trans_Cty_Data Proc
;	     Open file(Dos call back 38)
;	     Do an LSEEK to move CTY_INFO into NLSFUNC control buffer 39
;	     Do an LSEEK to move tables into NLSFUNC data buffer 39
;	    if R/W pointer ok on Disk
;	     Read the file(Dos call back 38)
;	     Check to see if it is FUNCTION 1 or FUNCTION 2
;	       Flag if FUNCTION 2
;	       if FUNCTION 2
;		Search for user specified INFO ID
;		until found or report back error to DOS & exit
;		if INFO ID is found
;		   godo move the data and set the counter to zero (entry value)
;
;
;
;
;MOVE_DATA:    Manage transfer from disk to buffer
;	       Check to see if entire entry can fit in to the data
;	       buffer if not read the maximum allowed into buffer
;	       Check to see what is left to read; read until no more
;	       Search for appropriate field in the DOS INFO
;		if found move in info until complete
;		   get the next entry until number of entries is 0
;		otherwise
;		   report to DOS error and exit
;	     loop back to read file until (all entries are Obtained) or (EOF)
;	     Close file handle (Dos call back 40)
;	    otherwise mov 05h to error_flag & jump to error_routine
;
;	    return
;Trans ENDP
;
;
;Error_routine	proc
;	     mov al,error_flag
;	     return
;error_routine	endp
;*******************************************************************************
;**********************************INTRO****************************************
subttl	Revision History
page
;****************************** Revision History *************************** ;
;
; =A  7/29/86  RG   PTM P64
;     Prevent overwrite of DOS monocase routine entry point during
;     transfer of SetCountryInfo.
;     For Get Ext Cty Info, put DOS monocase routine entry point into
;     user buffer.
;
; =B  7/29/86  RG	 PTM P67
;     Correct jump condition in ERROR_ROUTINE of NLSRES_CODE.
;     This prevents exit without COUNTRY.SYS file close.
;
; =C  7/30/86  RG	 PTM P85
;     Preserve ES register in NLSFUNC for IBMDOS.
;
; =D  7/31/86  RG	 PTM P86
;     Corrects information put into user buffer for Get Extended
;     Country Information.
;
; =E  7/31/85  RG	 DCR 18
;     CHCP support.
;
; =F  8/4/86   RG
;     Get Country Info - Revised info from Get Extended Country Info
;
; =G  8/5/86   RG
;     Correct carry set for good exit.
;
; =H  8/5/86   RG
;     Start extended info at length instead of signature.
;
; =FC 8/14/86  FChen
;     Insert code for control buff management and actual length retunred
;
; =I  8/20/86  RG
;     Improve path parameter parsing.
;
; =J  8/22/86  RG
;     Change error codes
;
; =K  8/28/86  RG
;     65 call-get ext cty info	put final csize (# bytes returned)
;     in cx on iret ;
;
; =L  11/7/86  RG
;     Set error to INVALID DATA (13) on no cp/cty match.
;
; =M  05/20/87 CNS
;     Additional re-design for structured code using STRUC
;     PARSER implementation
;     Message Retriever implementation
;     DBCS Support for Environmental Vector recognition (Walk Devices& IOCTL call)
;     Enable the Interrupt when NLSFUNC is loaded PTM ???
;
;AN001; P2685 NLSFUNC should not visit the same device repeatedly. 01/15/88 J.K.
;AN002; P3934 Bad write on sacred DOS area - segmentation incorrect  03/22/88 CNS
;*******************************************************************************
subttl macros
page
PUSHALL       macro  reg1,reg2,reg3			;used to save all
		push reg1				;registers needed
		push reg2				;for DOS interactions
		push reg3
	      endm

POPALL	     macro   reg1,reg2,reg3			;used to restore all
		pop reg3				;for DOS interactions
		pop reg2
		pop reg1
	      endm

;SHOWERR       macro   msg,len_msg
;		 mov	 ah,40h
;		 mov	 bx,2
;		 lea	 dx,msg 			 ;displays error msgs
;		 mov	 cx,len_msg
;		 int	 21h
;		endm


EXTRN		SYSPARSE:NEAR

subttl NLSFUNC data
page
NLS_DATA	SEGMENT byte PUBLIC 'DATA'

;Copyright 1988 Microsoft
;***************************** MSG DATA ************************************
UTILITY 	db	"NLSFUNC",0           ;AC000;
;***************************** MSG DATA ************************************

.xlist
include copyrigh.inc			;AN000;
include struc.inc
include DOESMAC.INC
include MULT.INC
include sf.inc				;AN001;
include DOSCNTRY.INC
include DEVSYM.INC
include SYSMSG.INC			;AN000;
include FUNCDBCS.INC			;AN000;
include MSG2NLS.INC
include FUNCPARM.INC			;AN000;
include version.inc			; MSKK02 07/18/89
MSG_UTILNAME <NLSFUNC>			;AN000;

.list

MSG_OPTIONS_FIRST	equ	300	; first options message line
MSG_OPTIONS_LAST        equ     302     ; last options message line

MULT_NLSFUNC	equ	14h
INSTALLED	equ	0ffh
; nlsfunc function codes
CHG_CODEPAGE	 equ	1
GET_EXT_CTY_INFO equ	2
SET_CODEPAGE	 equ	3
GET_CTY_INFO	 equ	4

INVALID_FUNCTION equ	1		     ;=J
INVALID_DATA	 equ	13		     ;=L
;FILE_NOT_FOUND  equ	2		     ;=J(=L no longer explicitly used)
;TAB		  equ	 9
;CR		  equ	 13
PAD_CHAR	 equ	' '                  ;AN000;
BAD_INVOKE	 equ	65		     ;=E
UPCASE_A	 equ	'A'
BUFFSIZE	 equ	512 ;	      ;AC000;REDUCTION OF ORIGINAL (128 BYTES) TO STORE
LOCATE_INFOTYPE  equ	18	      ;THE DEVICE LIST & THE OLD COUNTRY INFO
CTL_BUFF	 equ	256 ;	      ;AC000;
ID_TAG		 equ	8
DATA_BUFF_LENG	 equ	(BUFFSIZE - CTL_BUFF)
MAXBUFF_FIT	 equ	(BUFFSIZE - (CTL_BUFF + ID_TAG))
DATA_N_ID	 equ	(CTL_BUFF + ID_TAG)
SETCTY_LENG	 equ	38
;SPACE		  equ	 ' '
BACKSLASH	 equ	'\'
PERIOD		 equ	'.'
;COLON		  equ	 ':'
;
;**************** NEW VARIABLE	****************
subttl NLSFUNC data
page
IN_DEX		  equ	 bp			       ;AN000;
FILESPEC_PTR	  equ	 byte ptr ds:[in_dex]	       ;AN000;
FILEVAL 	 equ	0100h	;convert data block after checking for the
				;AN000;
				;drive only to look for the filespec
CL_NUM		 equ	81h	;command line at the PSP
				;AN000;
;**************** NEW VARIABLE	****************
;interrupts
SET_INT 	 equ	25h
GET_INT 	 equ	35h
;
;dos call backs
;dosopen	 equ	38
;dosclose	 equ	39
;lseek		 equ	40
;dosread	 equ	41
;
;NO_ERRORS	 equ	0FFh

;variable definition area
;initialization area

MSG_SERVICES <MSGDATA>
; Replace a bunch of bytes that are storing one byte (0 or 1) for one
; byte where I control each bit.

ID_CHECK_F      equ     00000001b
GET_EXT_F       equ     00000010b
GOOD_PAR_F      equ     00000100b
PARSE_ERR_F     equ     00001000b
EXIT_STAY_F     equ     00010000b
NO_PARMS_F      equ     00100000b
GOOD_PATH_F     equ     01000000b
OPTIONS_SENT_F  equ     10000000b

INFO_FLAG       db      ID_CHECK_F      ;Only ID_CHECK_F set, the rest 0




;ID_CHECK        db      1               ;resident variable re-initialize
ALL_DONE	db	0		;resident variable re-initialize
;GET_EXT         db      0               ;resident variable re-initialize
INFO_ID 	db	0		;resident variable re-initialize
DONT_CLOSE	db	0		;if open or close error,this is set

RES_PARASIZE	dw	0		;adjusted size for terminate & stay func.
ERROR_CODE	db	0		;contains extended error code val
FUNC_CODE	db	0		;save function number
;GOOD_PAR        db      0
;PARSE_ERR       db      0

SI_DOSLOCATE	dw	0
DS_DOSLOCATE	dw	0
SAVEDX		dw	0		;=FC  file offset
SAVECX		dw	0		;=FC
NOFFSET 	dw	2		;=FC
CSIZE		dw	0
CCODE		dw	0
CPAGE		dw	0
;VALID_FUNC      db      0               ;Flag to check for valid function #
;EXIT_STAY       db      0
FILENAME	db     "COUNTRY.SYS",0
PATH_SPEC	db	64 dup(0)	;used to build path parameter
USER_PATH	db	0		;=I
PAR_RETC	dw     0
;NO_PARMS        db     0
;GOOD_PATH       db     0
;OPTIONS_SENT    db      0               ; non-zero if options msg displayed
PATHSEG 	DW     0
SW_SPEC 	dW     0
;LENGTH_HOLD     db     0                  ;dead code
;***CNS
CUR_PTR        DW	0		   ;AN003;; keeps track of parameter position	   ;AN000
OLD_PTR        DW	0		   ;AN003;; keeps track of parameter position	   ;AN000
;***CNS
;********************************************************************************
NLS_BUFFER	db	BUFFSIZE dup (?)  ;NLS BUFFER to transfer data


DATASIZE	equ	$-NLS_DATA

NLS_DATA ENDS

NLS_INIT_CODE	SEGMENT BYTE PUBLIC 'CODE'

		ASSUME CS:NLS_INIT_CODE,DS:NOTHING,ES:NOTHING,SS:NOTHING



INT_2f_NEXT	DD	?	;Chain location.
subttl resident code
page
;**************************** resident portion ********************************

NLSRES_CODE	PROC	NEAR
		cmp	ah,MULT_NLSFUNC 	;Check the mutliplex value
		je	IS_NLSFUNC		;the # is mine
		jmp	dword ptr INT_2F_NEXT	;Chain to* the next handler

IS_NLSFUNC:


		cmp	al,0f8h 	;Make sure AL does not have reserved
					;DOS value 0F8 - 0FFH
		jb	SEL_FUNC	;Select the function code between 0,
					;1,2,3,4

		iret			;return on reserved functions

SEL_FUNC:


		push	es		;=C
		push	ds		;save the user's data segment
		push	si
		push	ds
		push	ax		;save the function value


		mov	ax,NLS_DATA	;so it won't be hosed
		mov	ds,ax		;set the data segment to mine

		ASSUME DS:NLS_DATA

		pop	ax
		pop	DS_DOSLOCATE
		pop	SI_DOSLOCATE

                mov     INFO_FLAG,ID_CHECK_F    ;re-initalize flags
                mov     ALL_DONE,0              ;from resident portion
                mov     DONT_CLOSE,0            ;no open or close error yet

		pushall bx,cx,dx	;save all DOS registers
		pushall bp,si,di	;save all DOS registers
; *************************** CNS **********************************************
		sti			;;AN000;the interrupt for external devices
					;AN000;
; *************************** CNS **********************************************
		mov	FUNC_CODE,al	;save function #
;               or      al,al
;               jnz     FUNCODE_DOSTATE ;state is not 0
                dec     al              ;Tell DOS I am installed (dec 0 = ff)
                js      RES_EXIT        ;state is 0
;               jmp     short RES_EXIT  ;exit


FUNCODE_DOSTATE:
;               dec     al                              ;cmp     al,CHG_CODEPAGE
                jz      FUNCODE3_1                      ;je      FUNCODE3_1
                dec     al                              ;cmp     al,GET_EXT_CTY_INFO
                jz      FUNCODE2                        ;je      FUNCODE2
                dec     al                              ;cmp     al,SET_CODEPAGE
                jz      FUNCODE3_1                      ;je      FUNCODE3_1
                                                        ; If al >= 4 then do 4


FUNCODE4:     ;Get Country Data - old 38 call =F
		mov	bp,1		;set info_id to 1 =F
;               jmp     short FUNCODE2  ;                 =F


FUNCODE2:      ;Get Extended Country Information
		mov	ax,bp		;information requested by the user
		mov	INFO_ID,al
                or      INFO_FLAG,GET_EXT_F ;get extended cty into user buffer
		call	RES_MAIN
		jc	ERROR_ROUTINE

		jmp	short CLOSE_FILE	  ;=E



FUNCODE3_1:    ;Set Codepage/Get Country Information =E
		les	di,dword ptr SI_DOSLOCATE
;		cmp	es:[di].ccDosCodePage,bx	;=E
;		jne	fc3_1_10			;=E
;		cmp	es:[di].ccDosCountry,dx 	;=E
;		jne	fc3_1_10			;=E
;		mov	CPAGE,bx	     ;get the codepage value =E
;		jmp	short fc3_1_20			;=E
;
;fc3_1_10:
		call	RES_MAIN
		jc	ERROR_ROUTINE
		CallInstall Dosclose,multdos,39,<ax,bx,cx,dx,ds,es>,<es,ds,dx,cx,bx,ax> ;close the file
		jc	NO_CLOSE

fc3_1_20:
		cmp	FUNC_CODE,1	       ;=E
		je	FUNCODE1	       ;=E
		mov	al,ALL_DONE	       ;=E
		jmp	short RES_EXIT	       ;=E


FUNCODE1:      ;CHCP - Change Code Page    =E
		call	WALK_DEVICES	    ;=E
		mov	al,ALL_DONE	    ;=E
		jmp	short RES_EXIT	    ;=E

NO_CLOSE:
		mov	ALL_DONE,al	;=J
		inc	DONT_CLOSE

;if an error was detected

ERROR_ROUTINE:
		mov	al,ALL_DONE
		cmp	DONT_CLOSE,1
		je	RES_EXIT
;               jmp     CLOSE_FILE



CLOSE_FILE:				     ;DOS  3eh function close COUNTRY.SYS
		mov	al,ALL_DONE

		CallInstall Dosclose,multdos,39,<ax,bx,cx,dx,ds,es>,<es,ds,dx,cx,bx,ax> ;close the file
		jc	NO_CLOSE
						;clear to let DOS know ok


RES_EXIT:
		popall	bp,si,di	;restore all DOS registers
		popall	bx,cx,dx	;restore all DOS registers

		cmp	FUNC_CODE,GET_EXT_CTY_INFO ;			  =K
		jne	NC_IRET 	;				  =K
                or      al,al           ;if successful 65 call, put size  =K
                jnz     NC_IRET         ;of info returned in CX           =K
		mov	cx,CSIZE	;				  =K

NC_IRET:				;				  =K
		pop	ds		;restore user's data segment  =K moved
		pop	es		;=C			      =K moved
		iret			;Return to DOS


NLSRES_CODE	ENDP
;*******************************END OF NLSRES_CODE******************************
subttl resident main routine
page
;*******************************RES_MAIN****************************************
RES_MAIN	PROC	NEAR

;               mov    VALID_FUNC,1     ;function exist   ; dead code?
		mov    CPAGE,bx 	;get the codepage value
		mov    CCODE,dx 	;get the country code
		mov    CSIZE,cx 	;size of the buffer
;               call   CHK_OPEN         ;go open file if possible

; instead of calling the procedure, I include the procedure here
; Begining of procedure CHK_OPEN

                xor     cx,cx                           ;zero cx for open
                cmp     USER_PATH,1                     ;either user supplied=I
                je      co_user                         ;or default DOS

co_dos:         push    ds                              ;save current ds value
                push    si                              ;save current si value
                lds     si,dword ptr SI_DOSLOCATE       ;old dos ds si value
                lea     dx,ds:[si].ccPATH_COUNTRYSYS
                CallInstall Dosopen,Multdos,38,<BX,DS,ES,SI,DI>,<DI,SI,ES,DS,BX>
                pop     si                              ;restore current si
                pop     ds                              ;restore current ds
                jmp     short co_10

co_user:        lea     dx,PATH_SPEC
                CallInstall Dosopen,Multdos,38,<BX,DS,ES,SI,DI>,<DI,SI,ES,DS,BX>

co_10:          jc      BADREP_FILE                     ;bx contains the
                mov     bx,ax                           ;file handle
                jmp     short END_OPEN

BADREP_FILE:
                mov     ALL_DONE,al                     ;=J
                inc     DONT_CLOSE

END_OPEN:
; End of procedure CHK_OPEN

		jc     END_RES		;scan and read country info

		mov	ax,CCODE
		mov	dx,CPAGE
		mov	si,offset NLS_BUFFER
		call	Trans_Cty_Data
					;into my buffer & the dos buffer
  END_RES:
		ret

RES_MAIN	ENDP
;*******************************END RES_MAIN************************************
subttl	check open procedure
page
;******************************CHECK OPEN PROCEDURE****************************
;CHK_OPEN        PROC    NEAR
;
;
;                xor     cx,cx                           ;zero cx for open
;                cmp     USER_PATH,1                     ;either user supplied=I
;                je      co_user                         ;or default DOS
;
;co_dos:         push    ds                              ;save current ds value
;                push    si                              ;save current si value
;                lds     si,dword ptr SI_DOSLOCATE       ;old dos ds si value
;                lea     dx,ds:[si].ccPATH_COUNTRYSYS
;                CallInstall Dosopen,Multdos,38,<BX,DS,ES,SI,DI>,<DI,SI,ES,DS,BX>
;                pop     si                              ;restore current si
;                pop     ds                              ;restore current ds
;                jmp     short co_10
;
;co_user:        lea     dx,PATH_SPEC
;                CallInstall Dosopen,Multdos,38,<BX,DS,ES,SI,DI>,<DI,SI,ES,DS,BX>
;
;co_10:          jc      BADREP_FILE                     ;bx contains the
;                mov     bx,ax                           ;file handle
;                jmp     short END_OPEN
;
;BADREP_FILE:
;                mov     ALL_DONE,al                     ;=J
;                inc     DONT_CLOSE
;
;END_OPEN:
;                ret
;
;   CHK_OPEN     ENDP
;******************************END OF CHKOPEN**********************************
subttl transfer country data
page
;******************************TRANS_CTY__DATA ********************************
TRANS_CTY_DATA	PROC	NEAR

TRANSTART:
		push	di			;save start of CTY/CP INFO
						;get the size of the file
		xor	cx,cx			;clear cx to start at
		xor	dx,dx			;at the beginning of the
						;file
		call	READ_CTLBUFF		;Read in the file header
                jnc     CHK_INFOTYPE
                jmp     END_TRANS               ;=G

CHK_INFOTYPE:
		add	si,LOCATE_INFOTYPE	;si > Country info type
		cmp	byte ptr ds:[si],1	;only 1 type exist currently
		je	GET_INFOIDS
		jmp	BAD_FILE
GET_INFOIDS:
		inc	si			;si > set to file offset
		mov	dx,word ptr ds:[si]	;Get the Info file offset
		mov	cx,word ptr ds:[si+2]	;Doubleword

		mov	SAVEDX,dx		;=FC save offset
		mov	SAVECX,cx		;=FC for more than 1 buffer
		mov	NOFFSET,2		;=FC start from beginning

		call	READ_CTLBUFF		;Read Info
                jc      Bridge_END_TRANS
;               jmp     END_TRANS               ;=G

COUNT_ENTRIES:

		mov	cx,word ptr ds:[si]	;Get count of entries
						;in info
		inc	si			;next word
		inc	si			;si >  Entry info packet

FIND_CTY:					;Search for CTY/CP combo

		mov	ax,word ptr ds:[si]	;=FC get size of entry
                inc     ax                      ;=FC include length filed
                inc     ax
		add	NOFFSET,ax		;=FC look ahead
		cmp	NOFFSET,CTL_BUFF-4	;=FC < (256 - 4)
		jb	IN_BUFF 		;=FC
		sub	NOFFSET,ax		;=FC restore to old offset
		push	cx			;=FC save number of cntries
		mov	cx,SAVECX		;=FC get file offset
		mov	dx,SAVEDX		;=FC
		add	dx,NOFFSET		;=FC update to the entry
		adc	cx,0			;=FC beginning
		mov	SAVECX,cx		;=FC save them for next use
		mov	SAVEDX,dx		;=FC
		call	READ_CTLBUFF		;=FC read next buffer in
		jc	READERROR		;=FC read error occurs
		pop	cx			;=FC restore number of cntries
		mov	NOFFSET,0		;=FC a new beginning
IN_BUFF:

		mov	dx,CPAGE
		mov	ax,CCODE
		cmp	ax,word ptr ds:[si+2]	 ;compare country id
		jne	NEXT_CTY
		cmp	dx, word ptr ds:[si+4]	;compare code page id
		je	FOUND_CTY
                or      dx,dx             ;=FC    if default pick the
		jz	FOUND_CTY2	  ;=FC	  1st country

NEXT_CTY:
		add	si, word ptr ds:[si]	;next entry
		inc	si
		inc	si			;take a word for size of entry itself
		loop	FIND_CTY

		mov	ALL_DONE,INVALID_DATA	;if it exits the loop	=J =L
		jmp	FINDCTY_FAIL		;then no cp/cty match

READERROR:	pop	cx			;=FC
Bridge_END_TRANS:
                jmp     END_TRANS               ;=FC

FOUND_CTY2:	mov	dx,word ptr ds:[si+4]	;=FC from now on,this is
		mov	CPAGE,dx		;=FC the code page

FOUND_CTY:		       ;found the matching entry
		mov	dx, word ptr ds:[si+10] ;get the file offset of country data
		mov	cx, word ptr ds:[si+12]
		call	READ_CTLBUFF
                jc      Bridge_END_TRANS
;               jmp     END_TRANS               ;=G
NUM_ENTRY:
		mov	cx, word ptr ds:[si]	;get the number of entries to handle.
		inc	si
		inc	si			;SI -> first entry

SETDOSCTY_DATA:
.REPEAT
		 push	 di			 ;ES:DI -> DOS_COUNTRY_CDPG_INFO
		 push	 si			 ;si -> current entry in Control buffer
		 push	 cx			 ;save # of entry left

		mov	al, byte ptr ds:[si+2]	;get data entry id
		xor	ah,ah			;clear out for comparison with
						;info-id in case id is > 256



                test    INFO_FLAG,GET_EXT_F     ;check to see if function 2
						;get_extended info was needed
                jz      TRANSALL                ;if not assume function code 1
						;set codepage

		cmp	INFO_ID,-1		;Minus 1 means return all of the
		jne	CHK_ID			;country info to the user
						;otherwise get the specific
						;info id and return only that info


		pop	cx			;error can not return all
		pop	si			;info accept for currently
		pop	di			;loaded control info in DOS
		jmp	BAD_SETID		;area

CHK_ID: 	cmp	al,INFO_ID		;check to see if the selected
						;id is the same as the id in the
						;ctrl buffer area

		jne	SETDOSCTY_NEXT		;if not equal go search for the
						;next information id

		pop	cx			;Bingo!! Found it set counter
		mov	cx,1			;to zero to exit loop
		push	cx

                and     INFO_FLAG,NOT ID_CHECK_F    ;Turn bit off.  found a valid id
                test    INFO_FLAG,GET_EXT_F         ;after transferring data to USER
                jnz     GET_ADDR                    ;area

						;set cx image in stack to force
						;exit loop
TRANSALL:



		call	GetDOSCTY_Dest		   ;get the address of destination in ES:DI
		jc	SetDOSCTY_NEXT		   ;No matching data entry id in DOS

GET_ADDR:

		mov	dx, word ptr ds:[si+4]	   ;get offset of data
		mov	cx, word ptr ds:[si+6]



SEEK_READ:

		push	ax			   ;=A	save data id.
		xor	bp,bp						;DOS 4200h function
		CallInstall Lseek,multdos,40,<bx,cx,ds,es,di,si>,<si,di,es,ds,cx,bx>		 ;move ptr
		pop	ax			   ;=A
		jc	DATASEEKNREAD
										     ;when ptr moved
		mov	dx,offset NLS_BUFFER +CTL_BUFF							;set the buffer to the beginning of the
										     ;data buffer area

		mov	cx,DATA_BUFF_LENG					     ;set to number of bytes in the
										     ;data buffer area
		push	ax			   ;=A
								       ;DOS 3fh
		CallInstall Dosread,Multdos,41,<bx,cx,ds,es,di,si>,<si,di,es,ds,cx,bx>		 ;Read cx many bytes into the buffer
		pop	ax			   ;=A
		jc    DATASEEKNREAD

IS_EXTENDED:
                test    INFO_FLAG,GET_EXT_F
                jz      CHK_OVERWRITE
		call	GETEXT_CTY
		jmp	short SETDOSCTY_NEXT


CHK_OVERWRITE:					   ;=A
						   ; If SetCountryInfo, then
						   ; put DOS monocase routine
						   ; entry point into
						   ; NLS_BUFFER so don't
						   ; write over.  =A

						   ; MSKK02 07/18/89
		call	SetDBCS_before_clear	   ; check DBCS vector set


		cmp	al,SetCountryInfo	   ;=A
		jne	DOS_MOVE		   ;=A
		mov	ax,word ptr es:[di+24]	   ;=A
		mov	word ptr ds:[NLS_BUFFER+CTL_BUFF + 32],ax  ;=A
		mov	ax,word ptr es:[di+26]	   ;=A
		mov	word ptr ds:[NLS_BUFFER+CTL_BUFF + 34],ax  ;=A

		mov	ax,CPAGE		   ;=FC, CPAGE is right
		mov	word ptr ds:[NLS_BUFFER+CTL_BUFF + 12],ax  ;=FC

DOS_MOVE:
		call	CHK_ADJUST						     ;now check to see if the entire
										     ;table fits

SETDOSCTY_NEXT:

		pop	cx
		pop	si
		pop	di
		add	si, word ptr ds:[si]
		inc	si
		inc	si
		dec	cx
		.UNTIL <cx eq 0>    NEAR		     ;loop    SETDOSCTY_DATA

		;Check for an invalid id
                test    INFO_FLAG,GET_EXT_F     ;Check to see if a get_ext func 2 was issued
                jz      CTLSEEKnREAD            ;if not move on
                test    INFO_FLAG,ID_CHECK_F    ;if so check to see if an id was found
                jnz     BAD_SETID               ;if none was found report an error
                                                ;otherwise continue



CTLSEEKnREAD:
		clc				;=G
		jmp	short END_TRANS 	;exit



DATASEEKnREAD:
		mov    ALL_DONE,al		;=J
		pop	cx
		pop	si
		pop	di
		jmp    short END_TRANS

BAD_SETID:
;               mov     ALL_DONE,INVALID_FUNCTION  ;=J
;               jmp    short FINDCTY_FAIL          ;=J

BAD_FILE:
		mov	ALL_DONE,INVALID_FUNCTION  ;=J

FINDCTY_FAIL:
		stc

END_TRANS:
		pop	di			;Restore header start
		ret



TRANS_CTY_DATA	ENDP

						; MSKK02 07/18/89
SetDBCS_before_clear:
		cmp	al,SetDBCS		; DBCS vector set?
		jnz	@F			; jump if not
		cmp	word ptr es:[di], 0	; zero byte data block?
		jz	@F			; jump if so
		push	di			;
		push	ax			;
		push	cx			;
		mov	cx,es:[di]		; load block length
		add	di,2			; points actual data
		xor	al,al			; fill bytes
		rep	stosb			; clear data block
		pop	cx			;
		pop	ax			;
		pop	di			;
@@:
		ret				;

;******************************END TRANS_CTY_DATA ******************************
subttl get DOS country destination
page
;****************************GETCTY_DEST***********************************************
GetDOSCty_Dest	 proc	 near
;Get the destination address in the DOS country info table.
;Input: AL - Data ID
;	ES:DI -> DOS_COUNTRY_CDPG_INFO
;On return:
;	ES:DI -> Destination address of the matching data id
;	carry set if no matching data id found in DOS.

	push	cx
	add	di, ccNumber_of_entries ;skip the reserved area, syscodepage etc.
	mov	cx, word ptr es:[di]	;get the number of entries
	inc	di
	inc	di			;SI -> the first start entry id
GetCntryDest:
	cmp	byte ptr es:[di], al
	je	GetCntryDest_OK
	cmp	byte ptr es:[di], SetCountryInfo ;was it SetCountryInfo entry?
	je	GetCntryDest_1
	add	di, 5			;next data id
	jmp	short GetCntryDest_loop

GetCntryDest_1:
	add	di, NEW_COUNTRY_SIZE + 1 ;next data id

GetCntryDest_loop:
	loop	GetCntryDest
	stc
	jmp	short	GetCntryDest_exit

GetCntryDest_OK:

	cmp	al, SetCountryInfo	;select country info?
	jne	GetCntryDest_OK1
	inc	di			;now DI -> ccCountryInfoLen
	clc				;clear the carry
	jmp	short	GetCntryDest_exit

GetCntryDest_OK1:

	les	di, dword ptr es:[di+1] ;get the destination in ES:DI
	clc

GetCntryDest_Exit:
	pop	cx
	ret

GetDOSCty_Dest	 endp
;****************************GETDOSCTY_DEST*************************************
subttl get extended country data
page
;****************************GETEXT_CTY*****************************************
GETEXT_CTY	proc

JUSTONE_ID:
		mov	ah,func_code	;=F
		cmp	ah,GET_CTY_INFO ;=F
		je	id_ctyinfo1	;=F

		mov	al,INFO_ID
		mov	byte ptr es:[di],al

		cmp	INFO_ID,SetCountryInfo ;SETCTY_INFO  =D moved.
		je	ID_CTYINFO	       ;=D don't want ptr if 1.

		mov	word ptr es:[di+1],offset nls_buffer + ctl_buff+8  ;=H
		mov	word ptr es:[di+3],ds	     ;my current ds value
		mov	CSIZE,5 		     ;=K

		jmp	short GET_EXT_END

ID_CTYINFO:
		inc	di		;=D  (old code - add di,5) =F(moved).
id_ctyinfo1:				;=F
		mov	cx,CSIZE
					;next line used to be "add si,5"
					;si needs to point to cty info. =D
		mov	si,offset nls_buffer + ctl_buff + 8  ;=D

		push	es		;=A  put DOS Monocase Routine
		push	di		;=A  entry point in user buffer.
		push	ax		;=A
		les	di,dword ptr si_doslocate ;=A
		mov	ax,word ptr es:[di].ccMono_Ptr	  ;=A
		mov	word ptr ds:[si+24],ax		  ;=A
		mov	ax,word ptr es:[di].ccMono_Ptr+2  ;=A
		mov	word ptr ds:[si+26],ax		  ;=A

		mov	ax,CPAGE			  ;=FC trust CPAGE
		mov	word ptr ds:[si+4],ax		  ;=FC

		pop	ax		;=A
		pop	di		;=A
		pop	es		;=A

		push	bx		;=F
		cmp	ah,GET_CTY_INFO ;=F if get cty info(38) slide info
		jne	id_ctyinfo2	;=F ptr up to date.
		add	si,6		;=F
		mov	cx,old_country_size ;=FC
		jmp	short MOVE_CTY	 ;=FC

id_ctyinfo2:	mov	bx,word ptr ds:[si]	;=FC get table size


		sub	CSIZE,3 	;=FC  size begins after length field
		mov	cx,CSIZE	;=FC

		cmp	cx,bx			;=D was cmped to SETCTR_LENG
		ja	TRUNC_SIZE	;=FC  used to be jg
		jmp	short  MOV_SIZE
TRUNC_SIZE:
		mov	cx,bx		;=F
MOV_SIZE:
		mov	es:[di],cx	;=FC  move actual length to user's buff
                inc     di              ;=FC  update index
                inc     di
                inc     si              ;=FC  skip length field
                inc     si

MOVE_CTY:	pop	bx		;=F
		mov	CSIZE,cx	;=K
		add	CSIZE,3 	;=K
		rep	movsb

GET_EXT_END:
		ret

GETEXT_CTY	endp
;*****************************END GETEXT_CTY*************************************
subttl read into control buffer
page
;**************************READ_CTLBUFF*****************************************
;
READ_CTLBUFF		proc	near
;Move file pointer to CX:DX
;Read 64 bytes into the control buffer.  Assume that the necessary data
;is within that limit.
;SI will be set to beginning of the offset my NLS_BUFFER hence DS:SI points to the control buffer.
;Entry:  CX,DX offset from the start of the file where the read/write pointer
;	 be moved.
;	 BX - file handle
;	 DS - buffer seg.
;Return: The control data information is read into DS:0 - DS:0200.
;	 CX,DX value destroyed.
;	 Carry set if error in Reading file.
;
								    ;Function 4200h
		xor	bp,bp
		CallInstall Lseek,multdos,40,<bx,cx,ds,es,di,si>,<si,di,es,ds,cx,bx>	;move pointer
		jc	NO_SEEK1

		mov	dx,offset NLS_BUFFER	  ;ds:dx -> control buffer
		mov	si,dx			  ;index for the entire buffer
						  ;read into the buffer function 3fh
		mov	cx, CTL_BUFF		  ;XXX bytes. Size of the information
		CallInstall Dosread,multdos,41,<bx,cx,dx,ds,es,di,si>,<si,di,es,ds,dx,cx,bx>	;should be less than XXX bytes.
		jc	NO_READ1
		jmp	short RICB_exit


NO_SEEK1:
;                mov    ALL_DONE,al               ;=J
;                jmp    short RICB_exit

NO_READ1:
		 mov	ALL_DONE,al		  ;=J

RICB_exit:				  ;In this case 64 bytes
		  ret

READ_CTLBUFF	  endp
;****************************END READ_CTLBUFF***********************************
subttl check / adjust / move data into DOS buffer
page
;****************************CHK_ADJUST*****************************************
CHK_ADJUST	PROC  NEAR

		push	ax			;save info id
		mov	si,offset NLS_BUFFER+DATA_N_ID		  ;start of buffer + tag id
		mov	cx, word ptr ds:[si]	;get the length of the structure

		inc	cx
		inc	cx

		cmp	cx,MAXBUFF_FIT
		jbe	MOVE_DATA
		push	cx
		mov	cx,MAXBUFF_FIT
		rep	movsb
		pop	cx
		sub	cx,MAXBUFF_FIT

NEED_ADJUST:
		mov	dx,offset NLS_BUFFER+CTL_BUFF		  ;reset to the beginning of the data buffer
		mov	si,dx			;reset to the beginning of the data buffer
		cmp	cx,DATA_BUFF_LENG	;check to see if it fits for the nth read
		jbe	LAST_READ		;last portion fits
		push	cx			;save how much is left to read
		mov	cx,DATA_BUFF_LENG	;set to how much you read at one time

		;read again					      ;function 3fh
						      ;read into the data buffer
		CallInstall Dosread,multdos,41,<bx,cx,dx,ds,es,di,si>,<si,di,es,ds,dx,cx,bx>  ;save the file handle
		jc	ADJUST_END

		rep	movsb			      ;move data into DOS area
		pop	cx			      ;restore size remaining to
		sub	cx,DATA_BUFF_LENG	      ;be read get new size
		jmp	NEED_ADJUST			  ;must read agian

LAST_READ:
						      ;one more read 3f
		 CallInstall Dosread,multdos,41,<bx,cx,dx,ds,es,di,si>,<si,di,es,ds,dx,cx,bx>
		 jc	ADJUST_END

MOVE_DATA:
		rep	movsb			      ;move data into DOS area

ADJUST_END:
		pop	ax
		ret
CHK_ADJUST	ENDP
;*******************************END CHK_ADJUST *********************************
subttl walk through device drivers and invoke
page
;************************ WALK DEVICE DRIVERS **********************************
;=E=E=E=E=E=E=E=E=E=E=E=E=E=E=E=E=E=E=E=E=E=E=E=E=E=E=E=E=E=E=E=E=E=E=E=E=E=E=E=

WALK_DEVICES	PROC  NEAR

		mov	si,offset NLS_BUFFER ;Prepare to hold device name
		push	es			;AN001; Clear out NLS_BUFFER to 0
		push	ds			;AN001;
		pop	es			;AN001;
		mov	di, si			;AN001; ES:DI-> NLS_BUFFER
		xor	ax, ax			;AN001; AX=0
		mov	cx, BUFFSIZE		;AN001;
		shr	cx, 1			;AN001; /2 to make a # of words
		rep	stosw			;AN001;
		pop	es			;AN001; Restore es
						;Get ptr to hdr of 1st device.
		push	si			;AN001;
		CallInstall GetDevLst,Multdos,44,<DS>,<DS>
		pop	si			;AN001;
		mov	es,bx		    ;bx:ax -> hdr.
		mov	di,ax
char_test:
		test	es:[di].sdevatt,devtyp ;check attribute word for
                je      BR_GET_NEXT_DEVICE
;               jmp     GET_NEXT_DEVICE        ;character device.

OPEN_DEVICE:
		push	si
		push	di		    ;set up asciiz filename
		add	di,10		    ;for DOS file open
		mov	cx,8

set_asciiz:	mov	al,es:[di]
		cmp	al,20h
		je	done_set_asciiz
		mov	ds:[si],al
		inc	di
		inc	si
		loop	set_asciiz

done_set_asciiz:xor	al,al
		mov	ds:[si],al

		pop	di
		pop	si

		mov	cx,1		    ;open for write
		mov	dx,si
		CallInstall Dosopen,Multdos,38,<DS,SI,ES,DI>,<DI,ES,SI,DS>
		jnc	end_open_device

BR_GET_NEXT_DEVICE:
		jmp	GET_NEXT_DEVICE     ; ignore this =FC

end_open_device:
		mov	bx,ax		    ;put handle in bx
		call	Chk_Revisit	    ;AN001; Have been here already?
                jc      BR_CLOSE_DEVICE     ;AN001; No, a new one.
;               jmp     short CLOSE_DEVICE    ;AN001; Yes. Close and ignore this.

INVOKE_DEVICE:
		push	ds		    ;Check print queue first.
		push	si		    ;Set up for 2f print call.
		clc
		mov	ax,0106h	    ;2f call to command.com.
		int	2fh		    ;If print active: carry set,
		jnc	invoke_it	    ;DS:SI -> hdr of printing device.
		cmp	si,di		    ;Check if printing device is this
		jne	invoke_it	    ;device.  Match on ptr to device.
		mov	ax,ds
		mov	cx,es
		cmp	ax,cx
		jne	invoke_it

		pop	si
		pop	ds
		mov	ALL_DONE,BAD_INVOKE ;Match.  Set invoke error.

BR_CLOSE_DEVICE:
		jmp	short CLOSE_DEVICE

invoke_it:	pop	si			     ;save the current
		pop	ds				;environment

;*************** CNS *********** Start of DBCS Support
;  PUSH    DS			   ;ICE
;  push    bx			   ;ICE
;  push    ax			   ;ICE
;  mov	   bx,0140H		   ;ICE
;  xor	   ax,ax		   ;ICE
;  mov	   ds,ax		   ;ICE
;  mov	   ax,word ptr ds:[bx]	   ;ICE
;  mov	   word ptr ds:[bx],ax	   ;ICE
;  POP	   ax			   ;ICE
;  pop	   bx			   ;ICE
;  pop	   ds			   ;ICE
	       push    di
	       push    bx
	       push    cx
	       push    es
	       les     di,dword ptr SI_DOSLOCATE     ;get the environmental
;*************** CNS ******************
;	       mov     bx,es:[di].ccDBCS_ptr	     ;values to allow
;	       mov     es,es:[di].ccDBCS_ptr+2	     ;recognition and
;*************** CNS ******************
	       les     bx,es:[di].ccDBCS_ptr
	       mov     cx,es:[bx]		     ;invocation of data
               inc     cx
               inc     cx
               inc     bx                            ;and ID for start
               inc     bx
	       mov     di,offset pk.DBCS_EV	     ;and stop values for
						     ;otherwise it is a DBCS
;****CHANGE					     ;or custom designed codepage

	       mov     PK.PACKLEN,cx		     ;if packet length is zero

NODBCS_CP:
	       add     cx,-2			     ;AN002; reset counter before CP addition

;****CHANGE

DB_EVECS:
               or      cx,cx                         ;AN002;no need to alter packet
               jz      NO_LOAD                       ;An002;initialized to zero


	 .REPEAT				      ;;AN000;DBCS transmission
						     ;AN000;
	       mov     al,es:[bx]		     ;;AN000;get the the contents
;***CNS 						;AN000;
	       mov     ds:[di],al			;;AN002;of where the DBCS Points
;***CNS 						;AN000;
	       inc     di			     ;;AN000;data packet for ioctl
						     ;AN000;
	       inc     bx			     ;AN000;;call--- get the start
						     ;stop values to load
						     ;AN000;
		dec	cx			     ;AN000;

	  .UNTIL <CX EQ 0 >			     ;AN000;
						      ;invocation of 1 codepage
						     ;standard codepage selection


NO_LOAD:

		 pop	 es			       ;AN000;;accordingly & restore
						       ;AN000;
		 pop	 cx			       ;AN000;;values
						       ;AN000;
		 pop	 bx			       ;AN000;
						       ;AN000;
		 pop	 di			       ;AN000;
						       ;AN000;;invoke codepage
;************************ CNS*** End of DBCS

					    ;Set up data packet for generic
		mov	ax,cpage	    ;ioctl call.
		mov	pk.packcpid,ax
		lea	dx,pk

		mov	cx,004ah
		mov	bp,0ch		    ;generic ioctl
		CallInstall IOCTL,multdos,43,<DS,SI,ES,DI,BX>,<BX,DI,ES,SI,DS>
		jc	device_error


CLOSE_DEVICE:
		CallInstall Dosclose,multdos,39,<DS,SI,ES,DI>,<DI,ES,SI,DS>
		jc	dev_open_close_error  ; ignore this =FC

GET_NEXT_DEVICE:
		cmp	word ptr es:[di],0FFFFH
		je	END_WALK_DEVICES
		les	di,dword ptr es:[di]
		jmp	char_test

DEVICE_ERROR:
		cmp	ax,1
		je	CLOSE_DEVICE
		CallInstall GetExtErr,multdos,45,<DS,SI,ES,DI,BX>,<BX,DI,ES,SI,DS>
		cmp	ax,22
		je	CLOSE_DEVICE
		mov	ALL_DONE,BAD_INVOKE
		jmp	CLOSE_DEVICE

dev_open_close_error:
		mov	ALL_DONE,BAD_INVOKE
		jmp	GET_NEXT_DEVICE

END_WALK_DEVICES:


		ret

WALK_DEVICES	endp
;*********************** END WALK DEVICE DRIVERS *******************************
;************************ Chk_Revisit******************************************
;This routine will check if we are opening the same device driver again.
;If it is, then carry bit will set.
;This routine will use the NLS_BUFFER to keep the history of already
;visited device driver address (OFFSET,SEGMENT).  NLS_BUFFER will be
;used from the end of the buffer towards to the front of the buffer.
;For 512 byte length and considering the front part used for OPEN device
;driver name string, this will handle appr. 126 devices maximum. which is
;sufficient enough. - J.K. 1/15/88
;IN: BX = file handle
;    DS = NLS_BUFFER segment
;OUT: carry set = visited
;     carry not set = new one.
;     Other registers saved.

Chk_Revisit	proc	near
	push	ax				;AN001;
	push	bx				;AN001;
	push	es				;AN001;
	push	di				;AN001;
	mov	ax, 1220h			;AN001; Get the spot of SFT
	int	2fh				;AN001;
	jc	Chk_Rvst_Ret			;AN001; This won't happen
	xor	bx, bx				;AN001;
	mov	bl, byte ptr es:[di]		;AN001;
	mov	ax, 1216h			;AN001; Get the SFT pointer
	int	2fh				;AN001; es:di-> SFT table
	jc	Chk_Rvst_Ret			;AN001; This won't happen
	mov	ax, word ptr es:[di].SF_DEVPTR	;AN001; offset of device
	mov	bx, word ptr es:[di].SF_DEVPTR+2;AN001; Segment of device
	mov	di, offset NLS_BUFFER		;AN001;
	add	di, BUFFSIZE-2			;AN001; ds:di-> last word of the buffer
Chk_Rvst_While: 				;AN001;
	cmp	word ptr ds:[di], 0		;AN001; di-> segment value
	jne	Chk_Rvst_Cont			;AN001;
	cmp	word ptr ds:[di-2], 0		;AN001; offset
	jne	Chk_Rvst_Cont			;AN001;
	jmp	short Chk_Rvst_New		;AN001; Encountered a blank entry in the buffer
Chk_Rvst_Cont:					;AN001;
	cmp	word ptr ds:[di], bx		;AN001;
	jne	Chk_Rvst_Next			;AN001;
	cmp	word ptr ds:[di-2], ax		;AN001;
	jne	Chk_Rvst_Next			;AN001;
	stc					;AN001; found a match
	jmp	short Chk_Rvst_Ret		;AN001;
Chk_Rvst_Next:					;AN001;
	sub	di, 4				;AN001; move the pointer to the next entry
	jmp	Chk_Rvst_While			;AN001;
Chk_Rvst_New:					;AN001;
	mov	word ptr ds:[di],bx		;AN001; Keep the current open device segment
	mov	word ptr ds:[di-2], ax		;AN001; and offset
	clc					;AN001; New device
Chk_Rvst_Ret:					;AN001;
	pop	di				;AN001;
	pop	es				;AN001;
	pop	bx				;AN001;
	pop	ax				;AN001;
	ret					;AN001;
Chk_Revisit	endp

subttl end nlsfunc resident code
page
 NLSRES_LENG	equ	$-NLSRES_CODE+DATASIZE
subttl initialization
page
;***************************** NLSFUNC Initialization **************************


	ASSUME	CS:NLS_INIT_CODE,SS:STACK
	PUBLIC	MAIN
MAIN	PROC	FAR

	mov	ax,NLS_DATA		;set up data segment
	mov	ds,ax
	assume	ds:NLS_DATA

	mov	PATHSEG,ax

	call	 SYSLOADMSG		 ;does DOS version check

	.IF <NC>

	   mov	dx,NLSRES_LENG		;calculate paragraph
	   add	dx,15			;add 15
	   shr	dx,1			;divide by 16 to get conversion from
	   shr	dx,1			;bytes to paragraphs
	   shr	dx,1
	   shr	dx,1
	   add	dx,11h			;size based on the byte size of
	   mov	RES_PARASIZE,dx 	;the resident procedure
	   call	PROCESS_PATH

	.ELSE

	   call	SYSDISPMSG

	.ENDIF

	; See if we should install and set
	; the TSR flag.

;       .IF <OPTIONS_SENT eq 0>

            test    INFO_FLAG,OPTIONS_SENT_F
            jnz     JJOPSOUT


;          .IF <NO_PARMS eq 1> or
;             .IF <GOOD_PATH eq 1>

            test    INFO_FLAG,NO_PARMS_F OR GOOD_PATH_F
            jz      JJOPSOUT

OPSEOK:
	      call INSTALL_NLS		;let's install NLSFUNC

;             .IF <NC>

            jc      JJOPSOUT
            or      INFO_FLAG,EXIT_STAY_F     ;if nothing wrong occured


;             .ENDIF    ; <NC>
;          .ENDIF       ; <NO_PARMS eq 1> or <GOOD_PATH eq 1>
;       .ENDIF          ; <OPTIONS_SENT eq 0>
JJOPSOUT:
								;determine path of exit
								;error or residency

;****************************** EXIT PROG *********************************************

	push	ax			  ;AN004;save existing values
	push	es			  ;
	xor	ax,ax
	mov	ax,es:[2ch]
        or      ax,ax
        jz      NO_FREEDOM
	mov	es,ax
	mov	ax,4900H		    ;AN004;make the free allocate mem func
	int	21h

NO_FREEDOM:
	pop	es			  ;AN004;restore existing values
	pop	ax			  ;

;       .IF <EXIT_STAY eq 1>            ;Terminate and stay resident

            test    INFO_FLAG,EXIT_STAY_F
            jz      JJEXSY

	   mov     bx,4			;1st close file handles

	   .REPEAT
	      mov  ah,3eh
	      int  21h
	      dec  bx
	   .UNTIL <BX eq 0>

            mov     ah,031h
            mov     dx,RES_PARASIZE      ;paragraphs allocated
            jmp     short JJEXOUT

;       .ELSE
JJEXSY:
	   clc
	   mov     ah,04ch		;value passed to ERRORLEVEL

;       .ENDIF
JJEXOUT:

	mov	al, ERROR_CODE		;check for an error
	int	21H

MAIN	ENDP

;****************************** EXIT PROG *********************************************
subttl parse
page
; On entry: ES points at the PSP
;	    DS points at NLS_DATA
;	    DX was used to calculate paragraph size
;
;	    PARSER EFFECTS  ES & DS wil be swapped
;
; Changes : ES:DI seg:off containing PARM Input Block
; to	    DS:SI seg:off containing command line
; segments
;
;
;
;
;
;
;****************************** PROCESS PATH ***********************************
;=I=I=I=I=I=I=I=I=I=I=I=I=I=I=I=I=I=I=I=I=I=I=I=I=I=I=I=I=I=I=I=I=I=I=I=I=I=I=I=

PROCESS_PATH	PROC	NEAR

					;to command line parms


		push	es		;;AC000;e original es (nothing)
					;AC000;
		push	ds		;AC000;he original ds (Nls_data)
					;AC002;
		push	ds		;save for both es & ds to point at data

		push	es		;AC000;hat's in my es the PSP value
					;AN000;
		push	ds		;AN000;he segment id that points to my
					;es now points to data
		pop	es		;AC000;
					;input parameter control block (NLS_DATA)
					;AN000;

		pop	ds		;AN000; points to the segment for
					;the command line string
					;AN000;

		ASSUME	DS:NOTHING,ES:NLS_DATA

		xor	dx,dx
		xor	cx,cx

;***CNS
RE_START:
		mov	si,80h		;get the command line length

		mov	cl,byte ptr ds:[si]	;get the length for the counter
;
;               mov     LENGTH_HOLD,cl          ;save the length of the command line
;



;		.IF <dx eq 0>

		     mov     di,OFFSET NLS_BUFFER    ;
 ;		     mov     dx,1
 ;		.ELSE
 ;		     mov     di,OFFSET PATH_SPEC    ;
 ;		     mov     dx,-1
 ;		.ENDIF

		mov	si,CL_NUM	;AN000; points to the offset command
					;line input string at value 81h
					;AN000;

		rep	movsb			;transfer command line to NLS_BUFFER

;		.IF <dx eq 1>
;		    jmp RE_START
;		.ENDIF

;***CNS




		mov	di,OFFSET NLS_PARMS    ;AN000; into ES of the PARMS INPUT
					;BLOCK
					;AN000;
		pop	ds		       ; ds also point at NLS_DATA


		ASSUME	DS:NLS_DATA


		mov	si,OFFSET NLS_BUFFER	;si now points to the offset command
;***CNS

                xchg    ax,CUR_PTR              ;AN003;Save environment
                                                ;AN003;Set advancing ptr to end of argument
                xchg    ax,OLD_PTR              ;AN003;after saving the beginning the string
                                                ;AN003;
                xchg    ax,CUR_PTR              ;AN003;Restore the environment
                mov     CUR_PTR,si

;***CNS



		xor	cx,cx			;AN000;l value should be atleast 1
		xor	dx,dx			;AN000;ut dx for input into the PARSER
						;AN000;

	.WHILE <PAR_RETC eq 0> 			;AN000;

	   call	SYSPARSE			;AN000;empt to parse
;***CNS

                xchg    ax,CUR_PTR              ;AN003;Save environment
                                                ;AN003;Set advancing ptr to end of argument
                xchg    ax,OLD_PTR              ;AN003;after saving the beginning the string
                                                ;AN003;
                xchg    ax,CUR_PTR              ;AN003;Restore the environment
                mov     CUR_PTR,si

;***CNS

	   .IF <RES_SYN EQ <OFFSET OPT_SYN>>

	      ; Display the user options help message

	      call	DISPLAY_OPTIONS

	      ; Flag that the options message has been displayed,
	      ; and now we want out of this program so the user
	      ; can try again.

              or        INFO_FLAG,OPTIONS_SENT_F  ; to get out of program
              and       INFO_FLAG,NOT EXIT_STAY_F ;  and not TSR
              mov       ERROR_CODE, 0             ;  and no error for help
              mov       ax, 1                     ; to get out of WHILE loop

	   .ELSEIF <Res_type eq 5>		;AN000;ound
						;AN000;
	      mov	USER_PATH,1		;AN000;;path specified
						;AC000;
	   .ENDIF				;AN000;

	   mov	PAR_RETC, AX			;AN000;;keep parsing until eoln
						;AN000;
	.ENDWHILE				;AN000;

	; If we didn't display the option help message,
	; then continue on with normal processing.

;       .IF <OPTIONS_SENT EQ 0> NEAR

            test    INFO_FLAG,OPTIONS_SENT_F
            jz      JJBR1
            jmp     JJOUT1

;          .IF <PAR_RETC gt 0>                  ;AN000;;parse error
JJBR1:
            cmp     PAR_RETC,0
            jnge    JJRETC


	      LEA   DI,PATH_SPEC		;AN003;Set PTR to look at the STRING
	      PUSH  SI				;AN003;Save current SI index
	      PUSH  AX
	      MOV   AX,OLD_PTR			;AN003;Last locale of the end of a PARAM
	      SUB   CUR_PTR,AX			;AN003;Get the length via the PSP
	      MOV   SI,CUR_PTR
	      MOV   CX,SI			;AN003;Save it in CX to move in the chars
	      POP   AX				;AN003;Restore the PTR to the command line position

	      MOV   SI,OLD_PTR			;AN003;Last locale of the end of a PARAM
	      REP   MOVSB			;AN003;Move in the chars until no more

	      LEA   DI,PATH_SPEC		;AN003;Set PTR to look at the STRING

	      POP   SI				;AN003;Restore the PTR to the command line position

	      mov   cx,1			;AN003;;
	      mov   bx,STDERR			;AN003;
	      mov   dl,no_input			;AN003;
	      mov   dh,PARSE_ERR_CLASS		;AN003;
	      mov   ds,PATHSEG			;AN003;
	      mov   si,OFFSET PARMLIST3		;AN003;
	      call  SYSDISPMSG			;AN003;
              or    INFO_FLAG,PARSE_ERR_F       ;AN003;;PARSE ERROR OCCURED

            jmp     short JJOUTRETC

;          .ELSEIF <CX eq 1>                    ;AN000;ordinal check
JJRETC:

                cmp cx,1
                jne JJCX
						;AN000;
              or    INFO_FLAG,GOOD_PAR_F        ;AN000;you are at the end of the line

            jmp     short JJOUTRETC             ;AN000;

JJCX:
;          .ELSE

            or      INFO_FLAG,NO_PARMS_F        ;AN000;there is no argument go install

;          .ENDIF               ; <PAR_RETC gt 0>
JJOUTRETC:


;         .IF <PARSE_ERR eq 0> NEAR             ;AN000;if not true you encountered a parse error

                test INFO_FLAG,PARSE_ERR_F
                jnz JJOUT1

;            .IF <GOOD_PAR eq 1> NEAR           ;AN000;there is a parameter line available
						;to parse
                test    INFO_FLAG,GOOD_PAR_F    ;AN000;
                jz      JJOUT1                  ;Check the flags to see what
						;was returned in the return block

	        lea     di,path_spec		;AC000;es:di > final path_spec
						;that will be used after fixup

;               .IF <USER_PATH gt 0>            ;AC000;drive has been solved need
                                                ;to check the filespec now
                cmp USER_PATH,0
                jnge USPA1

	           xor   in_dex,in_dex		;AN000;clear ctr
		   mov   bx,Res_POFF 		;AN000;get file spec ptr to text
		   push  ds			;AN000;prepare for entry
		   mov   ds,Res_PSEG 		;AN000;
		   mov   in_dex,bx		;AN000;string seg value if filename

;               .ENDIF        ;user path        ;AN000;
USPA1:

	        .WHILE <Filespec_PTR ne NULL>	;load chars until no more
						;AN000;
						;AN000;
		   mov	al,FILESPEC_PTR 	;AN000;
		   mov	byte ptr es:[di],al	;move value into pathspec and
		   inc	in_dex			;increment to next char position
		   inc	di			;AN000;

	        .ENDWHILE

;************************** CNS **********************************************
;The new method of checking for a "bogus" file will be to attempt an
;open on the path_spec if pathspec exist close path and continue if
;carry set stuff error code with 02 and exit.....
;*****************************************************************************
;	        push	es			;AN000;

	        pop	ds			;into find first
	        mov	si,di			;AN000;
	        xor	cx,cx			;AN000;

	        ASSUME	DS:NLS_DATA

	        mov	byte ptr ds:[si],NULL	;add asciiz value
						;AN000;
	        lea	dx,PATH_SPEC		;check full pathname
	        mov	ah,4eh
	        int	21h
						;set up addressability
;               .IF <NC>

                jc      JJC1

		   clc				;ok-clear carry/exit
                   or   INFO_FLAG,GOOD_PATH_F

                jmp     short JJOUT1

;               .ELSE
JJC1:
	           mov	ax,FNF			;AN000;
	           mov	cx,1			; ;AN000;
	           mov	bx,STDERR		;AN000;
	           mov	dl,no_input		;AN000;
	           mov	dh,UTILITY_MSG_CLASS 	;AN000;
	           mov	ds,PATHSEG		;AN000;
	           mov	si,OFFSET PARMLIST1	;AN000;
		   call	SYSDISPMSG		;AN000;
		   mov	ERROR_CODE,02		;
		   stc

;               .ENDIF  ; <NC>

;            .ENDIF     ; <GOOD_PAR eq 1>

;          .ENDIF       ; <PARSE_ERR eq 0>

;       .ENDIF          ; <OPTIONS_SENT EQ 0>

JJOUT1:


	pop	ds				;AN000;;restore original ds (NLS_DATA)
						;AN000;
	pop	es				;AN000;;restore original es (nothing)
						;AN000;
						;AN000;;after munging around with the PARSER

	ASSUME	DS:NLS_DATA,ES:NOTHING

	ret

PROCESS_PATH	ENDP


subttl display_options
page
;**************************** DISPLAY OPTIONS *******************************
;
; 04/26/90 c-PaulB
;
; on entry:
;   No value passed
;
; on exit:
;   No value returned
;   AX, BX, CX, DX, SI modified
;
; function:
;   Displays all lines of the options help message to standard
;   output.
;
;**************************** DISPLAY OPTIONS *******************************

	PUBLIC	DISPLAY_OPTIONS
DISPLAY_OPTIONS	PROC NEAR

	push	ds
	mov	ax, MSG_OPTIONS_FIRST		; message to display
	mov	bx, STDOUT			; output handle
	mov	cx, 0				; no substitutions
	mov	dh, UTILITY_MSG_CLASS		; message class
	mov	dl, no_input			; no input wanted
	mov	si, 0				; no substitution list
	mov	ds, PATHSEG
DO_LOOP:
	call	SYSDISPMSG			; send this message line
	cmp	ax, MSG_OPTIONS_LAST		; last message?
	je	DO_DONE				;  we're done if so
	inc	ax				; else get next msg
	jmp	short DO_LOOP			;  and go do it
DO_DONE:
	pop	ds
	ret

DISPLAY_OPTIONS ENDP


;****************************** CNS *******************************************
subttl install NLSFUNC
page
;******************************** INSTALL NLSFUNC *****************************

INSTALL_NLS	PROC	NEAR

		push	es

		xor	ax,ax			  ;clear the ax
		mov	ah,MULT_NLSFUNC 	  ;load in my multiplex
		INT	2fh			  ;id value 14
		or	al,al			  ;check to see if
;		jz	DO_INSTALL		  ;hooked in the chain
; *********************** CNS *************************************************

	   .IF <Z>				  ;AN000

						  ;Install NLSFUNC
		mov	al,2fh			  ;Get interrupt
		mov	ah,GET_INT		  ;2f in the chain
		int	21h
		mov	word ptr INT_2f_NEXT+2,ES ;store the address
		mov	word ptr INT_2f_NEXT,BX   ;to make the current
		push	ds			  ;2f handler next in
		push	cs			  ;the chain
		pop	ds			  ;set Dataseg to the Code
		mov	dx,offset NLSRES_CODE	  ;give start address
		mov	al,2fh			  ;of resident logic
		mov	ah,SET_INT		  ;set the 2f in the
		int	21h			  ;chain
		pop	ds			  ;restore original ds
						  ;terminate &
		CLC				  ; Let main know everything OK 	 ;BN001;
						  ;stay
;FREE THE ENVIRONMENT				  ;no then install

;		  push	  ax			  ;AN004;save existing values
;		  push	  es			  ;
;		  mov	  ah,49H		  ;AN004;make the free allocate mem func
;		  mov	  es,es:[2ch]		    ;AN004;get the segment address
;		  int	  21h			  ;
;		  pop	  es			  ;AN004;restore existing values
;		  pop	  ax			  ;

	   .ELSE				   ;AN000;
;TBR Message retriever				  ;otherwise
		   mov	   ax,ALLINS		     ;
		   mov	   cx,1 		     ;
		   mov	   bx,STDERR		       ;AN000;
		   mov	   dl,no_input		       ;AN000;
		   mov	   dh,UTILITY_MSG_CLASS 	 ;AN000;
		   mov	   ds,PATHSEG
		   mov	   si,OFFSET PARMLIST2
		   call    SYSDISPMSG		      ;AN000;
		   mov	   ERROR_CODE,80	      ;UTILITY ERROR CODE
		   stc

.ENDIF

		pop	es

		ret

INSTALL_NLS	ENDP

msg_services <LOADmsg>				      ;AN000;
msg_services <DISPLAYmsg,CHARmsg>		      ;AN000;
msg_services <nlsfunc.cl1,nlsfunc.cl2,nlsfunc.cla>    ;AN000;

;******************************** END OF NLS_INIT_CODE **************************
NLS_INIT_CODE	 ENDS
subttl stack
page

STACK	SEGMENT   PARA	STACK 'STACK'
	DB	  512 DUP (?)
STACK	ENDS

	END	MAIN

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\nlsfunc\msg2nls.inc ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

BADDOS equ 1
ALLINS equ 2
FNF    equ 3
FLAG1  equ LEFT_ALIGN+CHAR_FIELD_ASCIIZ

;*****************************************************************************
;******************************************************************************
;		VALUES FOR THE MSG_DESC CONTROL BLOCK
ONE_SUBS       EQU   1		   ;ONE VARIABLE FIELD IN MESSAGE
TWO_SUBS       EQU   2		   ;TWO VARIABLE FIELDS IN MESSAGE
THREE_SUBS     EQU   3		   ;THREE VARIABLE FIELDS IN MESSAGE
CLASS_1        EQU   EXT_ERR_CLASS ;CLASS 1 (DOS EXTENDED ERRORS)
CLASS_2        EQU   PARSE_ERR_CLASS ;CLASS 2 (PARSE ERRORS)
CLASS_A        EQU   UTILITY_MSG_CLASS ;CLASS A TYPE MESSAGE

;THIS MESSAGE DESCRIPTOR CONTROL BLOCK IS GENERATED, ONE PER MESSAGE,
;TO DEFINE THE SEVERAL PARAMETERS THAT ARE EXPECTED TO BE PASSED IN
;CERTAIN REGISTERS WHEN THE SYSDISPMSG FUNCTION IS TO BE INVOKED.

;MSG_DESC	   STRUC
;MSG_NUM	   DW	 0	    ;MESSAGE NUMBER (TO AX)
;MSG_HAND	   DW	 0	     ;HANDLE OF OUTPUT DEVICE (TO BX)
;MSG_SUBLIST	   Dd	 0	    ;POINTER TO SUBLIST (TO SI)
;MSG_COUNT	   DW	 0	    ;SUBSTITUTION COUNT (TO CX)
;MSG_CLASS	   DB	 0	    ;MESSAGE CLASS (IN HIGH BYTE, TO DH)
;				    ; LOW BYTE HAS 0 (FUNCTION "NO INPUT", TO DL)
;MSG_DESC	   ENDS
;		VALUES FOR THE SUBLIST CONTROL BLOCK
PC_ID_0        EQU   0		   ;ID OF " - " TRAILER TO MESSAGE
PC_ID_1        EQU   1		   ;ID OF PERCENT VARIABLE FIELD
PC_ID_2        EQU   2		   ;ID OF PERCENT VARIABLE FIELD
PC_ID_3        EQU   3		   ;ID OF PERCENT VARIABLE FIELD
MAX_0	       EQU   0		   ;MAXIMUM WIDTH OF STRING FIELD (0=NO LIMIT)
MIN_1	       EQU   1		   ;MINIMUM WIDTH OF STRING FIELD
ID_0	       EQU   0

;Message PARM LIST Structure
  PARMLIST1 LABEL   BYTE  ;PARM LIST
       ;(File not found - 'PATH_SPEC')
       DB  11	      ;PARMLIST size
       DB  0	      ;reserved
       DD  PATH_SPEC
       DB  id_0       ;; n of %n
       DB  FLAG1      ;; data type
       DB  max_0      ;;max width
       DB  min_1      ;;min width
       DB  PAD_CHAR   ;;char defined to be space


  PARMLIST2 LABEL   BYTE  ;PARM LIST
       ;(NLSFUNC already installed)
       DB  11	      ;PARMLIST size
       DB  0	      ;reserved
       DD  UTILITY    ;; ptr to data
       DB  1	      ;; n of %n
       DB  FLAG1      ;; data type
       DB  0	      ;;max width
       DB  1	      ;;min width
       DB  PAD_CHAR   ;;char defined

  PARMLIST3 LABEL   BYTE  ;PARM LIST
       ;(Invalid parameter 'PATH_SPEC')
       DB  11	      ;PARMLIST size
       DB  0	      ;reserved
       DD  PATH_SPEC   ;; ptr to data
       DB  id_0       ;; n of %n
       DB  FLAG1      ;; data type
       DB  0	      ;;max width
       DB  1	      ;;min width
       DB  PAD_CHAR   ;;char defined

;		THE NEXT GROUP ARE ALL CLASS "1" MESSAGES

;		PUBLIC MSGNUM_EXTERR
;MSGNUeM_EXTERR  MSG_DESC <FNF,STDERR,,,CLASS_1> ;ALL EXTENDED DOS ERRORS
				   ;File not found - %0

;		THE NEXT GROUP ARE ALL CLASS "2" MESSAGES

;		PUBLIC MSGNUM_PARSE ;SO PARSE DRIVER CAN FIND IT
;MSGNUM_PARSE	MSG_DESC <,STDERR,,,CLASS_2> ;ALL PARSING ERRORS BUT INVALID
						;SYNTAX
				   ;ERROR NUMBER WILL NEED TO BE FILLED IN

;		THE NEXT GROUP ARE ALL CLASS "A" MESSAGES
;		THESE ARE THE "CANNED" MESSAGES ALWAYS PRESENT

;		PUBLIC MSGNUM_VER
;MSGNUM_VER	MSG_DESC <1,STDERR> ;"Incorrect DOS Version"

;		PUBLIC MSGNUM_INST
;MSGNUM_INST	MSG_DESC <ALLINS,STDERR> ;"%1 - already installed"
;end of MSGHAN.INC
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\print\print_rm.asm ===
page	60,132

;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

;			$SALUT (4,25,30,41)
			INCLUDE pridefs.INC

BREAK			<Resident Portion Messages>

;
;	DOS PRINT
;
;	Resident Portion Messages
;
;	02/15/84	MAU	Created as a separate link module
;				from the include file. should
;				always be linked first!!
;
;	05/20/87	FJG	Change format to new Message Service
;				Routines
;

CodeR			Segment public para

			ASSUME CS:CodeR,DS:nothing,ES:nothing,SS:nothing

			public R_MES_BUFF
					;--------------------------------------
					;INT 24 messages A La COMMAND
					;--------------------------------------

R_MES_BUFF		LABEL WORD	; Room is generated for:

			db   512 dup(?) ;  ERR0
					;  ERR1
					;  ERR2
					;  ERR3
					;  ERR4
					;  ERR5
					;  ERR6
					;  ERR7
					;  ERR8
					;  ERR9
					;  ERR10
					;  ERR11
					;  ERR12
					;

CodeR			EndS

			End

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\nlsfunc\funcparm.inc ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

;Parser INPUT PARM LIST Structure

	PUBLIC	NLS_PARMS
 NLS_PARMS	label  word
      dw	NLS_PARMSX
      db	0	  ;no extra delimiters

	PUBLIC	NLS_PARMSX
 NLS_PARMSX	label  word
      db	0,1	  ;Min 0 - no path
			  ;Max 1 - path
      dw	NLS_POS1
      db	1         ; 1 switch supported
      dw	NLS_OPTS  ; its addr

	PUBLIC	NLS_POS1
 NLS_POS1	label  word
      dw	0201h	 ;File spec (optional)
      dw	0001h	 ;Cap result by file
      dw	Res_Valptr   ;tbl
      dw	NoVal	     ;no value list
      db	0	     ;no switch or
			     ;keyword synonyms

	PUBLIC	NLS_OPTS, OPT_SYN
NLS_OPTS	label word
	dw	0000		; Match Mask
	dw	0000		; Function Mask
	dw	RES_VALPTR	; ptr to results
	dw	NOVAL		; ptr to values
	db	1		; count of synonyms
OPT_SYN	db	"/?", 0

NOVAL label word
	db	0

	PUBLIC	RES_VALPTR, RES_SYN
    RES_VALPTR	label word

      RES_TYPE	 db	?	;Result_type
      RES_ITAG	 db	0	;Matched item tag
      RES_SYN	 dw	0	;synonym returned
      RES_POFF	 dw	0	;drive type or beginning of string
      RES_PSEG	 dw	0	;may be string
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\nlsfunc\nlsparm.asm ===
PAGE	,132			;
	TITLE	NLSPARM.SAL - NLSFUNC  SYSTEM COMMAND LINE PARSER

;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

;****************** START OF SPECIFICATIONS *****************************
; MODULE NAME: NLSPARM.SAL
;
; DESCRIPTIVE NAME: Include the DOS system PARSER in the SEGMENT
;		    configuration expected by the modules of NLSFUNC.
;
;FUNCTION: The common code of the DOS command line PARSER is optimized by
;	   the setting of certain switches that cause the conditional
;	   assembly of only the required portions of the common PARSER.
;	   The segment registers are ASSUMED according to the type .EXE.
;
; ENTRY POINT: SYSPARSE, near
;
; INPUT:
;	ES - has seg id of the SEGMENT
;	     that contains the input control blocks,
;	     defined below.
;
;	DI - offset into ES of the PARMS INPUT BLOCK
;
;	DS - has seg id of the SEGMENT
;	     that contains the DOS input COMMAND
;	     string, which is originally presented at 81h
;	     in the PSP.
;
;	SI - offset into DS of the text of the DOS input COMMAND string
;	     as originally presented at 81H in the PSP.
;
;	DX - zero
;
;	CX - ordinal value, intially zero, updated on each subsequent call
;	     to the value returned in CX on the previous call.
;
;	CS - points to the segment containing the
;	     INCLUDE PARSE.SAL statement
;
;	DS - also points to the segment containing the INCLUDE
;	     PARSE.SAL statement.
;
; EXIT-NORMAL:	Output registers:
;	 AX - return code:
;	    RC_No_Error     equ     0	 ; No error
;	    RC_EOL	    equ     -1	 ; End of command line
;
;	 DX - Offset into ES of the selected RESULT BLOCK.
;	 BL - terminated delimiter code
;	 CX - new operand ordinal
;	 SI - set past scanned operand
;
; EXIT-ERROR: Output registers:
;	 AX - return code:
;	    RC_Too_Many     equ     1	 ; Too many operands
;	    RC_Op_Missing   equ     2	 ; Required operand missing
;	    RC_Not_In_SW    equ     3	 ; Not in switch list provided
;	    RC_Not_In_Key   equ     4	 ; Not in keyword list provided
;	    RC_Out_Of_Range equ     6	 ; Out of range specified
;	    RC_Not_In_Val   equ     7	 ; Not in value list provided
;	    RC_Not_In_Str   equ     8	 ; Not in string list provided
;	    RC_Syntax	    equ     9	 ; Syntax error
;
; INTERNAL REFERENCES:
;    ROUTINES: SYSPARSE:near (INCLUDEd in PARSE.SAL)
;
;    DATA AREAS: none
;
; EXTERNAL REFERENCES:
;    ROUTINES: none
;
;    DATA AREAS: control blocks pointed to by input registers.
;
; NOTES:
;	 This module should be processed with the ASMUT preprocessor
;	 with the re-alignment not requested, as:
;
;		SALUT  NLSPARM,NUL;
;
;	 To assemble these modules, the sequential
;	 ordering of segments may be used.
;
;	 For LINK instructions, refer to the PROLOG of the main module,
;	 NLSFUNC.SAL
;
; REVISION HISTORY: A000 Version 4.00: add PARSER, System Message Handler,
;
; COPYRIGHT: "The DOS NLSFUNC Utility"
;	     "Version 4.00 (C)Copyright 1988 Microsoft
;	     "Licensed Material - Program Property of Microsoft "
;
;****************** END OF SPECIFICATIONS *****************************
	IF1
	    %OUT    COMPONENT=NLSFUNC, MODULE=NLSPARM.SAL...
	ENDIF
; =  =	=  =  =  =  =  =  =  =	=  =
	HEADER	<MACRO DEFINITION>
; =  =	=  =  =  =  =  =  =  =	=  =

HEADER	MACRO	TEXT
.XLIST
	SUBTTL	TEXT
.LIST
	PAGE
	ENDM

; =  =	=  =  =  =  =  =  =  =	=  =
	HEADER	<SYSPARSE - SYSTEM COMMAND LINE PARSER>
NLS_DATA SEGMENT BYTE PUBLIC  'DATA'

CAPSW   EQU	1			;SUPPORT FILENAME TBL CAPS
FARSW	EQU	0			;PARSER CALL FAR
FILESW  EQU	1			;CHECK FOR FILESPEC
SWSW	EQU	1			;SUPPORT CHECKING FOR SWITCHES
DATESW	EQU	0			;SUPPRESS DATE CHECKING
TIMESW	EQU	0			;SUPPRESS TIME CHECKING
CMPXSW	EQU	0			;SUPPRESS CHECKING COMPLEX LIST
NUMSW	EQU	0			;SUPPRESS CHECKING NUMERIC VALUE
KEYSW	EQU	0			;SUPPRESS KEYWORD SUPPORT
VAL1SW	EQU	0			;SUPPRESS SUPPORT OF VALUE DEFINITION 1
VAL2SW	EQU	0			;SUPPRESS SUPPORT OF VALUE DEFINITION 2
VAL3SW	EQU	0			;SUPPRESS SUPPORT OF VALUE DEFINITION 3
DRVSW	EQU	0			;SUPPORT OF DRIVE ONLY FORMAT
QUSSW	EQU	0			;SUPPRESS SUPPORT OF QUOTED STRING FORMAT

;	 INCLUDE PSDATA.INC		 ;PARSE WORK AREA & EQUATES

NLS_DATA ENDS

NLS_INIT_CODE SEGMENT BYTE PUBLIC 'CODE'

;	 ASSUME  CS:NLS_INIT_CODE,DS:NLS_DATA
	 ASSUME  CS:NLS_INIT_CODE,DS:nothing ; tsuneo

;	 mov	 ax,NLS_DATA
;	 mov	 ds,ax

;INCSW	 equ	 0



	include version.inc
	INCLUDE PARSE.ASM
       PUBLIC  SYSPARSE

NLS_INIT_CODE ENDS
;NLS_DATA ENDS
	END
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\print\print_r.asm ===
page	80,132
	TITLE	DOS - PRINT - RESIDENT

;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */
;
;       Revision History
;       ================
;       M001    5/31/91 MD      Added spooling on INT 2F idle calls
;
;               8/5/91  MD      Spooling on INT 2F idle calls backed
;                               out for DOS 5.0.  Should be reinstated
;                               for a future version.
;
;			$SALUT (4,25,30,41)
			INCLUDE pridefs.inc


			BREAK <Resident Portion>
;
;	DOS PRINT
;
;	Resident Portion
;

Code			Segment public para
			extrn TransRet:WORD,TransSize:WORD,NameBuf:WORD
			extrn GoDispMsg:FAR
Code			EndS

			BREAK <Resident Data>

CodeR			Segment public para

			public SliceCnt, BusyTick, MaxTick, TimeSlice
			public EndRes, BlkSiz, QueueLen, PChar
			public ListName, FileQueue, EndQueue, Buffer
			public EndPtr, NxtChr, MoveTrans
			public TO_DOS

			public MESBAS


			ASSUME CS:CodeR

			db   " - PRINT utility - "

			include copyrigh.inc

			db   01Ah	; fake end of file for 'TYPE'
			DB   (361 - 80h) + 310 DUP (?) ; (362 - 80h) is IBM's New
					; recommended Stack Size -
					; Old recommended Stack Size
					; == New stack growth
ISTACK			LABEL WORD	;Stack starts here and grows down the

IFDEF ROMDOS                            ; M001
IDLE_2F = 1680h                         ; INT 2F function code for idle
ENDIF

;Resident data

;
; Due to flagrant bogosity by file servers, BUSY is *ALWAYS* relevant.
;
BUSY			DB   0		;Internal ME flag

;
; WARNING!!! The *&^%(*&^ 286 chip hangs if you access a word that will wrap
; at the segment boundary.  Make the initial INDOS point somewhere reasonable.
;
INDOS			DD   TimeSlice	;DOS buisy flag
NEXTINT 		DD   ?		;Chain for int
NEXT_REBOOT		DD   ?		;Chain for ROM bootstrap

fFake			db   0		; TRUE => do not diddle I/O ports
SOFINT			DB   0		;Internal ME flag
TICKCNT 		DB   0		;Tick counter
TICKSUB 		DB   0		;Tick miss counter
SLICECNT		DB   DefTimeSlice ;Time slice counter, init to same val
					; as TIMESLICE

TIMESLICE		DB   DefTimeSlice ;The PRINT scheduling time slice. PRINT
					; lets this many "ticks" go by before
					; using a time slice to pump out characters.
					; Setting this to 3 for instance means PRINT
					; Will skip 3 slices, then take the fourth.
					; Thus using up 1/4 of the CPU. Setting it
					; to one gives PRINT 1/2 of the CPU.
					; The above examples assume MAXTICK is
					; 1. The actual PRINT CPU percentage is
					; (MAXTICK/(1+TIMESLICE))*100

MAXTICK 		DB   DefMaxTick ;The PRINT in timeslice. PRINT will pump
					; out characters for this many clock ticks
					; and then exit. The selection of a value
					; for this is dependent on the timer rate.

BUSYTICK		DB   DefBusyTick ;If PRINT sits in a wait loop waiting for
					; output device to come ready for this
					; many ticks, it gives up its time slice.
					; Setting it greater than or equal to
					; MAXTICK causes it to be ignored.

;User gets TIMESLICE ticks and then PRINT takes MAXTICK ticks unless BUSYTICK
;	ticks go by without getting a character out.

QueueLen		db   DefQueueLen ; Actual length of print queue
			even
EndQueue		dw   ?		; pointer to end of print queue
QueueTail		dw   offset CodeR:FileQueue ; pointer to next free entry
					;  in the print queue
buffer			dw   ?		; pointer to data buffer

I24_ERR 		DW   ?		;Save location for INT 24H error code
Ctrlc			DB   ?		; saved ^C trapping state
SPNEXT			DD   ?		;Chain location for INT 28
COMNEXT 		DD   ?		;Chain location for INT 2F
SSsave			DW   ?		;Stack save area for INT 24
SPsave			DW   ?
HERRINT 		DD   ?		;Place to save Hard error interrupt
LISTDEV 		DD   ?		;Pointer to Device
COLPOS			DB   0		;Column position for TAB processing
CURRFIL 		DB   0
CURRCP			DW   -1 	; Current file's CP in binary           ;AN000;
NXTCHR			DW   ?
CURRHAND		DW   -1
PrinterNum		DW   no_lptx	; index for printer
no_lptx 		equ  -1 	; no valid LPTx
QueueLock		db   0		; queue lock, 0=unlocked


PChar			db   ?		; path character
AmbCan			db   ?		; = 1 ambigous cancel
CanFlg			db   ?		; = 1 Current was already canceled
ACanOcrd		db   ?		; = 1 a file was found during an
					;  ambigous cancel

;--- Warning: this is a FCB!!

ACBuf			db   ?
ACName			db   8 dup(?)
ACExt			db   3 dup(?)
			db   4 dup(?)	; how big is an unopened fcb???


CONTXTFLAG		DB   0		;0 means his context, NZ means me
HISPDB			DW   ?
PABORT			DB   0		;Abort flag
BLKSIZ			DW   DefBufferLen ;Size of the PRINT I/O block in bytes
ENDPTR			DW   ?

COMDISP 		LABEL WORD	; Communications dispatch table

			DW   OFFSET CodeR:INST_REQ
			DW   OFFSET CodeR:ADDFIL
			DW   OFFSET CodeR:CANFIL
			DW   OFFSET CodeR:CanAll
			DW   OFFSET CodeR:QSTAT
			DW   OFFSET CodeR:EndStat
			DW   OFFSET CodeR:QSTATDEV

code_page		dw   0		; CP initialized to 0

					;--------------------------------------
					; Resident Message Buffer - Data area
					;--------------------------------------

ERRMES			DB   13,10,13,10
			DB   "**********"
			DB   13,10,"$"

BELMES			DB   13,0CH,7,"$"

CRLF			DB   13,10,0

					;--------------------------------------
					; Resident Message Pointer Control Block
					;--------------------------------------

MESBAS			DW   ?		; OFFSET CodeR:ERR0	   This list is order sensitive
			DW   ?		; OFFSET CodeR:ERR1	   and must not be changed without
			DW   ?		; OFFSET CodeR:ERR2	   considering the logic in
			DW   ?		; OFFSET CodeR:ERR3	   Load_R_Msg
			DW   ?		; OFFSET CodeR:ERR4
			DW   ?		; OFFSET CodeR:ERR5
			DW   ?		; OFFSET CodeR:ERR6
			DW   ?		; OFFSET CodeR:ERR7
			DW   ?		; OFFSET CodeR:ERR8
			DW   ?		; OFFSET CodeR:ERR9
			DW   ?		; OFFSET CodeR:ERR10
			DW   ?		; OFFSET CodeR:ERR11
			DW   ?		; OFFSET CodeR:ERR12
ERRMEST_PTR		DW   ?		; OFFSET CodeR:ERRMEST
ErrMesT2_PTR		DW   ?		; OFFSET CodeR:ErrMesT2
CANMES_PTR		DW   ?		; OFFSET CodeR:CANMES
CanFilNam_PTR		DW   ?		; OFFSET CodeR:CanFilNam
AllCan_PTR		DW   ?		; OFFSET CodeR:AllCan
FATMES_PTR		DW   ?		; OFFSET CodeR:FATMES
BADDRVM_PTR		DW   ?		; OFFSET CodeR:BADDRVM

ENDRES			DW   ?		; filled in at initialization time

PRTDPL			DPL  <>

CodeR			EndS

BREAK			<Resident Code>

CodeR			Segment public para

Break			<Server critical section routines>

;  $SALUT (4,4,9,41)

TestSetServer:

   clc
   push ax
   mov	ax,8700h			; Can I run?
   int	2Ah
   pop	ax

   ret

LeaveServer:

   push ax
   mov	ax,8701h
   int	2Ah
   pop	ax

   ret
					;---------------------------------------
					; Interrupt routines
					;---------------------------------------

ASSUME CS:CodeR,DS:nothing,ES:nothing,SS:nothing

					;---------------------------------------
					;
					; PRINT is stimulated by a hardware
					;	interrupt.
					;
					;
					; The Server may also stimulate us
					; during timer ticks (if we handled
					; the ticks ourselves, it would be
					; disasterous).  Therefore, we have a
					; substitute entry here that simulates
					; the timer stuff but does NOT muck
					; with the ports.
					;
					;---------------------------------------
FakeINT1C:

   mov	fFake,-1
   jmp	SHORT InnerHardInt

HDSPINT:				;Hardware interrupt entry point

   mov	fFake,0

InnerHardInt:

   call TestSetServer

;  $if	nc				;				       ;AC000;
   JC $$IF1

       inc  [TICKCNT]			;Tick
       inc  [TICKSUB]			;Tick
       cmp  [SLICECNT],0

;      $if  nz				;				       ;AC000;
       JZ $$IF2

	   dec	[SLICECNT]		;Count down

;      $else				;				       ;AC000;
       JMP SHORT $$EN2
$$IF2:

	   cmp	BUSY,0			; interrupting ourself ?

;	   $if	z,and			; if NOT interupting ourselves and ... ;AC000;
	   JNZ $$IF4

	   push ax			; check for nested interrupts
	   mov	al,00001011b		; select ISR in 8259
	   out	20h,al
	   jmp	x

x:
	   in	al,20H			; get ISR register
	   and	al,0FEH 		; mask timer int
	   pop	ax

;	   $if	z,and			; if there are no other ints to service;AC000;
	   JNZ $$IF4

	   push ds
	   push si
	   lds	si,[INDOS]		;Check for making DOS calls

					;---------------------------------------
					;
					; WARNING!!! Due to INT 24 clearing the
					; INDOS flag, we must test both INDOS
					; and ERRORMODE at once!
					;
					; These must be contiguous in MSDATA.
					;
					;---------------------------------------
	   cmp	WORD PTR [SI-1],0
	   pop	SI
	   pop	DS

;	   $if	z			; if no errors			       ;AC000;
	   JNZ $$IF4

	       inc  [BUSY]		;Exclude furthur interrupts
	       mov  [TICKCNT],0 	;Reset tick counter
	       mov  [TICKSUB],0 	;Reset tick counter
	       sti			;Keep things rolling
	       test fFake,-1

;	       $if  z			;if needed			       ;AC000;
	       JNZ $$IF5

		   push ax
		   mov	al,EOI		;Acknowledge interrupt
		   out	AKPORT,al
		   pop	ax

;	       $endif			; endif 			       ;AC000;
$$IF5:

	       call DOINT
	       cli
	       push ax
	       mov  al,[TIMESLICE]
	       mov  [SLICECNT],al	;Either soft or hard int resets time slice
	       pop  ax
	       dec  Busy		;Done, let others in

;	   $endif			;				       ;AC000;
$$IF4:

;      $endif				;				       ;AC000;
$$EN2:

       Call LeaveServer

;  $endif				;				       ;AC000;
$$IF1:

   test fFake,-1

;  $if	z				;				       ;AC000;
   JNZ $$IF10

       jmp  [NEXTINT]			; chain to next clock routine

;  $endif				;				       ;AC000;
$$IF10:

   iret

					;---------------------------------------
					; PRINT is stimulated by a
					;  spooler idle interrupt
					;---------------------------------------

SPINT:					; INT 28H entry point

   call TestSetServer

;  $if	nc				; if no server			       ;AC000;
   JC $$IF12

       cmp  [BUSY],0

;      $if  z				; if not busy			       ;AC000;
       JNZ $$IF13

	   inc	[BUSY]			; exclude hardware interrupt
	   inc	[SOFINT]		; indicate a software int in progress
	   sti				; hardware interrupts ok on INT 28H entry
	   call DOINT
	   cli
	   mov	[SOFINT],0		;Indicate INT done
	   push ax
	   mov	al,[TIMESLICE]
	   mov	[SLICECNT],al		;Either soft or hard int resets time slice
	   pop	ax
	   dec	Busy

;      $endif				;				       ;AC000;
$$IF13:

       call LeaveServer

;  $endif				;				       ;AC000;
$$IF12:

   jmp	[SPNEXT]			;Chain to next INT 28

					;---------------------------------------
					; Since we may be entering at arbitrary
					; times, we need to get/set the extended
					; error as we may end up blowing it away.
					; We do not do this on spooler ints.
					;---------------------------------------

SaveState DPL <>			; empty DPL

   public enterprint

EnterPRINT:

   test SofInt,-1

;  $if	z				;if not soft int		       ;AC000;
   JNZ $$IF16

       mov  ah,GetExtendedError
       call DO_21
       mov  SaveState.DPL_AX,AX
       mov  SaveState.DPL_BX,BX
       mov  SaveState.DPL_CX,CX
       mov  SaveState.DPL_DX,DX
       mov  SaveState.DPL_SI,SI
       mov  SaveState.DPL_DI,DI
       mov  SaveState.DPL_DS,DS
       mov  SaveState.DPL_ES,ES

;  $endif				;				       ;AC000;
$$IF16:

   ret

   public leaveprint

LeavePRINT:

   test SofInt,-1

;  $if	z				; if soft int			       ;AC000;
   JNZ $$IF18

       mov  ax,(ServerCall SHL 8) + 10
       push cs
       pop  ds
       mov  dx,OFFSET CodeR:SaveState
       call Do_21

;  $endif				;				       ;AC000;
$$IF18:

   ret

   public doint

DOINT:

   ASSUME CS:CodeR,DS:nothing,ES:nothing,SS:nothing

   cmp	[CURRFIL],0
   jnz	GOAHEAD

SPRET:

   ret					;Nothing to do

GOAHEAD:

   cmp	[QueueLock],1
   je	spret				; queue locked, do nothing...
   push ax				;Need a working register
   mov	[SSsave],ss
   mov	[SPsave],sp
   mov	ax,cs
   cli
					;---------------------------------------
					; Go to internal stack to prevent
					; INT 24 overflowing system stack
					;---------------------------------------
   mov	ss,ax
   mov	sp,OFFSET CodeR:ISTACK
   sti
   push es
   push ds
   push bp
   push bx
   push cx
   push dx
   push si
   push di
   push cs
   pop	ds

   ASSUME DS:CodeR

   call EnterPRINT
   mov	bx,[NXTCHR]
   cmp	bx,[ENDPTR]
   jb	PLOOP
   jmp	READBUFF			;Buffer empty

DONEJMPJP:

   popf 				;				       ;AC000;

DONEJMPJ:

   jmp	DONEJMP

FILEOFJ:

   ASSUME DS:CodeR

   jmp	FILEOF

PLOOP:

   mov	bx,[NXTCHR]
   cmp	bx,[ENDPTR]
   jae	DONEJMPJ			;Buffer has become empty
   cmp	[SOFINT],0
   jnz	STATCHK
   push ax
   mov	al,[MAXTICK]
   cmp	[TICKCNT],al			;Check our time slice
   pop	ax
   jae	DONEJMPJ

STATCHK:

   call PSTAT
   pushf
   cmp	[CURRFIL],0
   jz	DONEJMPJP			;File got cancelled by error
   popf 				;				       ;AC000;
   jz	DOCHAR				;Printer ready
   cmp	[SOFINT],0
   jnz	DONEJMP 			;If soft int give up
   push ax
   mov	al,[BUSYTICK]
   cmp	[TICKSUB],al			;Check our busy timeout
   pop	ax
   jae	DONEJMP
   jmp	PLOOP

DOCHAR:

   mov	al,BYTE PTR [BX]
   cmp	al,1Ah				;^Z?
   jz	FILEOFJ 			;CPM EOF
   cmp	al,0Dh				;CR?

;  $if	z				; if CR 			       ;AC000;
   JNZ $$IF20

       mov  [COLPOS],0

;  $endif				;				       ;AC000;
$$IF20:

   cmp	al,9				;TAB?
   jnz	NOTABDO
   mov	cl,[COLPOS]			;expand tab to # spaces
   or	cl,0F8h
   neg	cl
   xor	ch,ch
   jcxz TABDONE 			;CX contains # spaces to print

;G	TABLP:

   mov	al," "
   inc	[COLPOS]
   push cx
   call POUT
   pop	cx
   dec	cx				;G
   jz	TABDONE 			;G We're done - get next char
   jmp	PLOOP				;G Keep processing tab

;G	LOOP	TABLP
;G	JMP	TABDONE

NOTABDO:

   cmp	al,8				;Back space?
   jnz	NOTBACK
   dec	[COLPOS]

NOTBACK:

   cmp	al,20h				;Non Printing char?

;  $if	ae				; if not printable
   JNAE $$IF22

       inc  [COLPOS]			;Printing char

;  $endif				;
$$IF22:

   call POUT				;Print it

TABDONE:

   inc	[NXTCHR]			;Next char
   mov	[TICKSUB],0			;Got a character out, Reset counter
   cmp	[SOFINT],0			;Soft int does one char at a time
   jnz	DONEJMP
   jmp	PLOOP

DONEJMP:

   call CONTEXT_BACK
   call LeavePRINT
   pop	di
   pop	si
   pop	dx
   pop	cx
   pop	bx
   pop	bp
   pop	ds
   pop	es

   ASSUME DS:nothing,ES:nothing

   cli
   mov	ss,[SSsave]			;Restore Entry Stack
   mov	sp,[SPsave]
   sti
   pop	ax

   ret

CONTEXT_BACK:

   ASSUME DS:nothing,ES:nothing,SS:nothing

   cmp	[CONTXTFLAG],0

;  $if	nz				; if not in context		       ;AC000;
   JZ $$IF24

       SaveReg <AX,BX>
       mov  bx,[HISPDB]
       mov  ah,SET_CURRENT_PDB
       call do_21
       RestoreReg <BX,AX>
       mov  [CONTXTFLAG],0

;  $endif				;				       ;AC000;
$$IF24:

   ret

CONTEXT_SWITCH:

   ASSUME DS:nothing,ES:nothing,SS:nothing

   cmp	[CONTXTFLAG],0

;  $if	z				; if context off		       ;AC000;
   JNZ $$IF26

       SaveReg <BX,AX>
       mov  ah,GET_CURRENT_PDB
       call do_21
       mov  [HISPDB],bx
       mov  bx,cs
       sub  bx,10h			; The 2.5 print is an exe program
       mov  ah,SET_CURRENT_PDB
       call do_21
       RestoreReg <AX,BX>
       mov  [CONTXTFLAG],1

;  $endif				;				       ;AC000;
$$IF26:

   ret
					;---------------------------------------
					;--- Refill the print buffer ---
					;---------------------------------------
READBUFF:

   ASSUME DS:CodeR,ES:NOTHING,SS:NOTHING

   call Set24				; switch Int24 vector
   mov	[PABORT],0			;No abort
   mov	BX,[CURRHAND]
   mov	CX,[BLKSIZ]
   mov	DX,[BUFFER]
   mov	AH,READ
   call My21
   pushf
   call Res24				; reset Int 24 vector
   cmp	[PABORT],0
   jz	NOHERR
   pop	ax				;Flags from read
   jmp	short FilClose			;Barf on this file, got INT 24

NOHERR:

   popf 				;				       ;AC000;
   jc	FILEOF
   cmp	ax,0
   jz	FILEOF				;Read EOF?
   mov	bx,[BUFFER]			;Buffer full
   mov	di,bx
   add	di,ax
   mov	[NXTCHR],bx
   mov	cx,[BLKSIZ]
   sub	cx,ax

;  $if	ncxz				; if buffer is not completely full     ;AC000;
   JCXZ $$IF28

       push cs
       pop  es
       mov  al,1Ah
       cld
       rep  stosb			; pad the buffer

;  $endif				; endif 			       ;AC000;
$$IF28:

   jmp	DONEJMP

FILEOF:

   mov	al,0Ch				;Form feed
   call POUT
					;---------------------------------------
					;--- Close file
					;
					;      note: we came here from an i24
					;	     then PAbort is already = 1
					;---------------------------------------
FilClose:

   call Set24
   mov	pAbort,-1
   mov	bx,[CURRHAND]
   call CloseFile			;				       ;AC000;
   call Res24
   mov	[CURRFIL],0			; No file
   mov	[CURRHAND],-1			; Invalid handle
   mov	ax,[ENDPTR]
   mov	[NXTCHR],ax			; Buffer empty

					;---------------------------------------
					;--- Send close on output device
					;---------------------------------------
   call Close_Dev

					;---------------------------------------
					;--- compact the print queue
					;---------------------------------------

CompQAgn:

   call CompQ

					;---------------------------------------
					;--- Check if there are any more
					;	    files to print
					;---------------------------------------
   mov	si,OFFSET CodeR:FileQueue
   cmp	byte ptr [si],0 		; no more left if name starts with nul
   je	NoFilesLeft
   call Set24
   mov	[PABORT],0			;No abort
   mov	dx,si				; DS:DX points to file name
   call OpenFile			; try opening new file		       ;AC000;
   pushf
   call Res24
   cmp	[PAbort],0
   je	NoI24a
   popf 				;				       ;AC000;
   jmp	short CompQAgn			; try next file

NoI24a:

   popf 				;				       ;AC000;
   jnc	GotNewFile
   call PrtOpErr
   jmp	short CompQAgn

GotNewFile:				; buffer was already marked as empty

   mov	[CurrHand],ax
   mov	[CurrFil],1

					;---------------------------------------
					;--- Send Open on output device
					;---------------------------------------
   call Open_Dev

NoFilesLeft:

   jmp	DONEJMP

					;---------------------------------------
					;--- Print open error ---
					;	 - preserves DS
					;---------------------------------------

PrtOpErr:

   ASSUME DS:CodeR,ES:nothing

					;---------------------------------------
					; This stuff constitutes a "file" so it
					; is bracketed by an open/close
					; on the output device.
					;---------------------------------------

					;---------------------------------------
					;--- Send Open on output device
					;---------------------------------------
   call Open_Dev

   push cs
   pop	es

   ASSUME ES:CodeR

   mov	si,OFFSET CodeR:ErrMes
   call ListMes
   mov	si,ErrMesT2_ptr 		;				       ;AC000;
   call ListMes
   mov	si,OFFSET CodeR:FileQueue
   call ListMes2
   mov	si,OFFSET CodeR:BelMes
   call ListMes

					;---------------------------------------
					;--- Send close on output device
					;---------------------------------------

   call Close_Dev

   ret


					;---------------------------------------
					;--- Compact File Queue ---
					;      - modifies: AX,CX,SI,DI,ES
					;---------------------------------------

CompQ:

   ASSUME DS:CodeR,ES:nothing,SS:nothing

   push cs
   pop	es

   ASSUME ES:CodeR

   mov	di,OFFSET CodeR:FileQueue	; ES:DI points to top of queue
   mov	si,(OFFSET CodeR:FileQueue + MaxFileLen) ; DS:SI points to next entry
   mov	cx,[EndQueue]
   sub	cx,si				; length in bytes of the queue
   cld
   rep	movsb				; compact the queue
   mov	ax,[QueueTail]			; normalize tail pointer as we
   sub	ax,MaxFileLen			;  know have a new "next empty slot"
   mov	[QueueTail],ax
   mov	si,ax
   mov	byte ptr [si],0 		; nul first byte of last entry

   ret


   BREAK <Resident Code: DSKERR>

					;---------------------------------------
					;--- Set Local Int 24 vector ---
					;	 -  modifies: AX,DX
					;---------------------------------------

Set24:

   ASSUME DS:nothing,ES:nothing,SS:nothing

   push es
   push bx
   push dx
   mov	al,24h
   mov	ah,GET_INTERRUPT_VECTOR
   call do_21
   mov	WORD PTR [HERRINT+2],es 	; Save current vector
   mov	WORD PTR [HERRINT],bx
   mov	dx,OFFSET CodeR:DSKERR
   mov	al,24h
   mov	ah,SET_INTERRUPT_VECTOR 	; Install our own
   call do_21				; Spooler must catch its errors
   pop	dx
   pop	bx
   pop	es

   ret
					;---------------------------------------
					;--- Reset Old Int 24 vector ---
					;	  -  modifies: none
					;---------------------------------------
Res24:

   ASSUME DS:nothing,ES:nothing,SS:nothing

   push ds
   push ax
   push dx
   lds	dx,[HERRINT]

   ASSUME DS:nothing

   mov	al,24h
   mov	ah,SET_INTERRUPT_VECTOR
   call do_21				;Restore Error INT
   pop	dx
   pop	ax
   pop	ds

   ret
					;---------------------------------------
					;--- INT 24 handler ---
					;---------------------------------------
DSKERR:

   ASSUME DS:nothing,ES:nothing,SS:nothing

   cmp	[PABORT],0

;  $if	z				; if not to ignore		       ;AC000;
   JNZ $$IF30

       sti
       push bx
       push cx
       push dx
       push di
       push si
       push bp
       push es
       push ds
       push cs
       pop  ds
       push cs
       pop  es

       ASSUME DS:CodeR,ES:CodeR

       mov  si,BADDRVM_PTR		; Fix up Drive ID for FATMES	       ;AC000;
       add  ds:[si],al			;				       ;AC000;
       mov  si,OFFSET CodeR:ERRMES
       call LISTMES
       test AH,080H

;      $if  z				; if not fat error		       ;AC000;
       JNZ $$IF31

	   and	di,0FFh
	   cmp	di,12

;	   $if	a			; if greater - force it to 12	       ;AC000;
	   JNA $$IF32

	       mov  di,12

;	   $endif			;				       ;AC000;
$$IF32:

	   mov	[I24_ERR],di
	   shl	di,1
	   mov	di,WORD PTR [di+MESBAS] ; Get pointer to error message
	   mov	si,di
	   call LISTMES 		; Print error type
	   mov	si,ERRMEST_PTR		;				       ;AC000;
	   call LISTMES
	   mov	si,OFFSET CodeR:FileQueue ; print filename
	   call ListMes2		; print name
	   mov	si,OFFSET CodeR:BelMes
	   call ListMes

;      $else				;				       ;AC000;
       JMP SHORT $$EN31
$$IF31:

	   mov	[I24_ERR],0FFh
	   mov	si,FATMES_PTR		;				       ;AC000;
	   call LISTMES

;      $endif				;				       ;AC000;
$$EN31:

       inc  [PABORT]			;Indicate abort
       pop  ds
       pop  es
       pop  bp
       pop  si
       pop  di
       pop  dx
       pop  cx
       pop  bx

;  $endif				;				       ;AC000;
$$IF30:

   xor	al,al				;Ignore

   iret

   BREAK <Resident Code: SPCOMINT>

					;---------------------------------------
					;--- Communications interrupt ---
					;---------------------------------------

   SPCOMINT proc far

   ASSUME DS:nothing,ES:nothing,SS:nothing

   cmp	ah,1
   jbe	mine

IF      0                               ; M001 change backed out for now
IFDEF ROMDOS                            ;M001

   cmp  ax,IDLE_2F                      ; check for external idle event
   jne  not_idle

;       Following code taken from INT 28 handler

   call TestSetServer                   ; Note: must preserve AX
   JC   not_idle                        ; if no server

   cmp  [BUSY],0
   JNZ  exit_idle                       ; if not busy			       

   inc	[BUSY]	        		; exclude hardware interrupt
   inc	[SOFINT]	        	; indicate a software int in progress
   sti				        ; hardware interrupts ok on INT 28H entry
   call DOINT
   cli
   dec	[SOFINT]        	        ;Indicate INT done
   mov	al,[TIMESLICE]
   mov	[SLICECNT],al		        ;Either soft or hard int resets time slice
   dec	Busy
   mov  ax,IDLE_2F                      ;Reset idle call

exit_idle:
   call LeaveServer                     ; Note: must preserve AX

not_idle:

ENDIF                                   ; M001 end
ENDIF                                   ; IF 0 

   jmp	[COMNEXT]

MINE:

   cmp	al,0F8h
   jae	RESERVED_RET
   cmp	ax,0080h
   jnz	CheckPSP
   jmp	FakeINT1C

CheckPSP:

   or	ah,ah
   jne	PSPDO
   mov	al,1				; Tell PSPRINT to go away (AH = 1)

RESERVED_RET:

   iret

PSPDO:

   or	al,al
   jne	PSPDISP

INST_REQ:

   mov	al,0FFh

   iret

PSPDISP:

   cmp	[BUSY],0
   jz	SETCBUSY

ErrBusy:

   mov	ax,error_busy

setcret:

   push bp
   mov	bp,sp
   or	word ptr [bp+6],f_Carry
   pop	bp

   iret

SETCBUSY:

   XOR	AH,AH
   CMP	AX,6				; check function within valid range
   Jbe	GoForIt
   mov	ax,error_invalid_function
   jmp	setcret

GoForIt:

   inc	[BUSY]				;Exclude
   sti					;Turn ints back on
   push di				;G
   push es
   push ds
   push cs
   pop	ds

   ASSUME DS:CodeR

   mov	[QueueLock],0			; unlock the print queue
   shl	ax,1				;Turn into word index
   mov	di,ax
   call ComDisp[DI]

   ASSUME DS:nothing

;  $if	nc				; if no error			       ;AC000;
   JC $$IF37

       ASSUME DS:CodeR,ES:nothing

       push ds
       push cs
       pop  ds

       ASSUME DS:CodeR,ES:nothing

       call PSTAT			; Tweek error counter
       pop  ds

       ASSUME DS:nothing

;  $endif				;				       ;AC000;
$$IF37:

   pushf
   call Context_Back
   popf 				;				       ;AC000;
   cli
   dec	BUSY				; leaves carry alone!
   pop	ds

   ASSUME DS:nothing

   pop	es
   pop	di				;G
   jc	setcret
   push bp
   mov	bp,sp
   and	word ptr [bp+6],NOT f_Carry
   pop	bp

   iret

SpComInt Endp

   BREAK <Get queue status>

					;---------------------------------------
					;--- Return pointer to file queue ---
					;---------------------------------------

QSTAT:

   ASSUME DS:CodeR,ES:nothing

   mov	[QueueLock],1			; lock the print queue
   call PSTAT				; Tweek error counter
   push bp
   mov	bp,sp				;  0	2    4
   mov	[bp+ 2 + 2],cs			; <BP> <RET> <DS>
   pop	bp
   mov	si,OFFSET CodeR:FileQueue
   mov	dx,[ErrCnt]			; return error count
   clc

   ret
					;---------------------------------------
					;--- Return pointer to device ---
					;     --- driver if active ---
					;---------------------------------------
QSTATDEV:

   ASSUME DS:CodeR,ES:nothing

   xor	ax,ax				;g assume not busy
   mov	[QueueLock],1			;g lock the print queue
   call PSTAT				;g Tweek error counter
   cmp	byte ptr FileQueue,0		;g is there anything in the queue?
   clc					;g
   jz	qstatdev_end			;g no - just exit
   mov	ax,error_queue_full		;g yes - set error queue full
   mov	si,word ptr [listdev+2] 	;g get segment of list device
   push bp				;g
   mov	bp,sp				;g  0	 2   4
   mov	[bp+2+2],si			;g <BP><RET><DS> seg of device to DS
   pop	bp				;g
   mov	si,word ptr [listdev]		;g offset of device to SI
   stc					;g

qstatdev_end:				;g

   mov	[QueueLock],0			;g unlock the print queue
   ret					;g

   BREAK <Resident Code: EndStat>

					;---------------------------------------
					;--- Unlock the print queue ---
					;---------------------------------------

EndStat:

   ASSUME DS:CodeR,ES:nothing

   mov	[QueueLock],0
   clc

   ret

   BREAK <Cancel all available files in the queue>

					;---------------------------------------
					; Note: Loop until the background is free
					;---------------------------------------

CanAll:

   ASSUME DS:CodeR,ES:nothing

   cmp	[CurrFil],0			; are we currently printing?

;  $if	nz				;
   JZ $$IF39

					;---------------------------------------
					;--- Cancel active file
					;---------------------------------------

       mov  bx,[CurrHand]		; close the current file
       call Set24
       mov  [PAbort],1			; no Int24's
       call CloseFile			; close the file		       ;AC000;
       call Res24
       mov  [CurrFil],0 		; no files to print
       mov  [CurrHand],-1		; invalidate handle
       mov  ax,[EndPtr] 		; buffer empty
       mov  [NxtChr],ax

					;---------------------------------------
					;--- Cancel rest of files
					;---------------------------------------

       mov  si,OFFSET CodeR:FileQueue
       mov  [QueueTail],si		; next free entry is the first
       mov  byte ptr [si],0		; nul first byte of firts entry
       mov  si,AllCan_PTR		;				       ;AC000;
       call ListMes			; print cancelation message
       mov  si,OFFSET CodeR:BelMes
       call ListMes			; ring!!

					;---------------------------------------
					;--- Send close on output device
					;---------------------------------------

       call Close_Dev
       clc

;  $endif				;				       ;AC000;
$$IF39:

   ret

   BREAK <Cancel a file in progress>

CANFIL:

   ASSUME DS:CodeR,ES:nothing

   cmp	[CURRFIL],0
   jnz	DOCAN

   ret					;  carry is clear

DOCAN:
					;---------------------------------------
					;--- find which file to cancel
					;---------------------------------------
   push bp
   mov	bp,sp				;  0	2    4
   mov	ds,[bp+ 2 + 2]			; <BP> <RET> <DS>
   pop	bp

   ASSUME DS:nothing

   push cs
   pop	es

   ASSUME ES:CodeR

   mov	[CanFlg],0			; reset message flag
   mov	[ACanOcrd],0			; no cancelation has ocured yet
   mov	bx,OFFSET CodeR:FileQueue	; ES:BX points to 1st entry in queue
   call AmbChk

AnotherTry:

   mov	di,bx				; ES:DI points to 1st entry in queue
   mov	si,dx				; DS:SI points to filename to cancel

MatchLoop:

   lodsb
   cmp	al,byte ptr es:[di]		; names in queue are all in upper case
   je	CharMatch
   jmp	short AnotherName			; a mismatch, try another name

CharMatch:

   cmp	es:byte ptr es:[di],0		; was this the terminating nul?
   je	NameFound			; yes we got our file...
   inc	di
   jmp	MatchLoop

AnotherName:

   cmp	[AmbCan],1			; ambigous file name specified?
   jne	AnName				; if not then no more work to do
   cmp	al,"?"
   jne	AnName
   cmp	byte ptr es:[di],"."
   je	FindPeriod
   cmp	byte ptr es:[di],0		; if nul then file names match
   jne	CharMatch			;  only if only ?'s are left...

FindNul:

   lodsb
   cmp	al,"?"
   je	FindNul
   cmp	al,"."
   je	FindNul
   or	al,al
   jne	AnName				; found something else, no match
   jmp	short NameFound

FindPeriod:				; ambigous files always have 8 chars

   lodsb				;  in name so we can not look for the
   or	al,al				;  period twice (smart uh?)
   je	AnName				; no period found, files do not match
   cmp	al,"."
   jne	FindPeriod
   jmp	short CharMatch

AnName:

   add	bx,MaxFileLen
   cmp	byte ptr es:[bx],0		; end of queue?
   jne	AnotherTry			; no, continue...
   cmp	[ACanOcrd],1			; yes, was there a file found?
   jne	sk2
   push cs
   pop	ds

   ASSUME DS:CodeR			; StartAnFil likes it this way...

   jmp	StartAnFil			; restart printing

sk2:

   ASSUME DS:nothing

   mov	ax,error_file_not_found
   stc

   ret
					;---------------------------------------
					;--- Name found, check if current file
					;---------------------------------------
NameFound:

   push cs
   pop	ds

   ASSUME DS:CodeR

   mov	[ACanOcrd],1			; remember we found a file
   cmp	bx,OFFSET CodeR:FileQueue	; is the file being printed?

;  $if	e,and				; if it is and ..................      ;AC000;
   JNE $$IF41

   cmp	[CanFlg],0			;				:

;  $if	e				; if not in cancel mode ........:      ;AC000;
   JNE $$IF41

					;---------------------------------------
					;--- Cancel current file
					;---------------------------------------

       mov  [CanFlg],1			; remeber we already canceled current
       push bx
       mov  bx,[CurrHand]		; close the current file
       call Set24
       mov  [PAbort],1			; no Int24's
       call CloseFile			; close the file		       ;AC000;
       call Res24
       mov  [CurrFil],0 		; no files to print
       mov  [CurrHand],-1		; invalidate handle
       mov  ax,[EndPtr] 		; buffer empty
       mov  [NxtChr],ax
       pop  bx
					;---------------------------------------
					;--- print cancelation message
					;---------------------------------------
       push bx
       mov  si,CanMes_PTR		;				       ;AC000;
       call ListMes			; print cancelation message
       mov  si,bx			; points to filename
       call ListMes2			; print filename
       mov  si,CanFilNam_PTR		;				       ;AC000;
       call ListMes
       mov  si,OFFSET CodeR:BelMes
       call ListMes			; ring!!
       pop  bx
					;---------------------------------------
					;--- Send close on output device
					;---------------------------------------
       call Close_Dev

;  $endif				;				       ;AC000;
$$IF41:

   mov	di,bx				; DI points to entry to cancel
   mov	si,bx
   add	si,MaxFileLen			; SI points to next entry
   cmp	si,[QueueTail]			; is the entry being canceled the last?

;  $if	e				; if it is			       ;AC000;
   JNE $$IF43

       mov  byte ptr [di],0		; yes, just nul the first byte

;  $else				;				       ;AC000;
   JMP SHORT $$EN43
$$IF43:

       mov  cx,[EndQueue]		; CX points to the end of the queue
       sub  cx,si			; length of the remainning of the queue
       cld
       rep  movsb			; compact the queue

;  $endif				;				       ;AC000;
$$EN43:

   mov	ax,[QueueTail]			; remember new end of queue
   sub	ax,MaxFileLen
   mov	[QueueTail],ax
   mov	si,ax
   mov	byte ptr [si],0 		; nul first byte of last entry

   cmp	byte ptr [bx],0 		; is there another file to consider?
   je	StartAnFil
   push bp
   mov	bp,sp				;  0	2    4
   mov	ds,[bp+ 2 + 2]			; <BP> <RET> <DS>
   pop	bp

   ASSUME DS:nothing

   jmp	AnotherTry			; yes do it again...

					;---------------------------------------
					;--- Start new file...
					;---------------------------------------
StartAnFil:

   ASSUME DS:CodeR

   cmp	[CurrHand],-1			; was the canceled name the current?
   jne	NoneLeft			; no, just quit

StartAnFil2:

   mov	si,OFFSET CodeR:FileQueue	; points to new current file
   cmp	byte ptr[si],0			; is there one there?
   je	NoneLeft			; no, we canceled current and are none left
   call Set24
   mov	[PAbort],0
   mov	dx,si
   call OpenFile			; try to open the file		       ;AC000;
   pushf
   call Res24
   cmp	[PAbort],0
   je	NoI24b
   popf 				;				       ;AC000;
   call CompQ				; compact file queue
   jmp	short StartAnFil2

NoI24b:

   popf 				;				       ;AC000;
   jnc	GoodNewCurr
   call PrtOpErr			; print open error
   call CompQ				; compact file queue
   jmp	short StartAnFil2

GoodNewCurr:

   mov	[CurrHand],ax			; save handle
   mov	[CurrFil],1			; signal active (buffer is already empty)

					;---------------------------------------
					;--- Send Open on output device
					;---------------------------------------
   call Open_Dev

NoneLeft:

   clc

   ret
					;---------------------------------------
					;--- Ambigous file name check ---
					;     entry:	 ds:dx points to filename
					;    preserves ds:dx and es
					;---------------------------------------
   ASSUME DS:nothing,ES:CodeR

AmbChk:

   mov	[AmbCan],0			; assume not ambigous
   mov	si,dx
   cld

;  $do					;				       ;AC000;
$$DO46:

       lodsb
       or   al,al			; the nul?

;  $enddo e				;				       ;AC000;
   JNE $$DO46

   dec	si				; points to nul
   std					; scan backwards

;  $do					;				       ;AC000;
$$DO48:

       lodsb
       cmp  al,"*"

;      $if  e				; if a *			       ;AC000;
       JNE $$IF49

	   mov	[AmbCan],1

;      $endif				;				       ;AC000;
$$IF49:

       cmp  al,"?"

;      $if  e				; if a ?			       ;AC000;
       JNE $$IF51

	   mov	[AmbCan],1

;      $endif				;				       ;AC000;
$$IF51:

       cmp  al,[PChar]

;  $enddo e				;				       ;AC000;
   JNE $$DO48

   cld					; be safe
   cmp	[AmbCan],1			; an ambigous cancel?

;  $if	e				; if its an ambiguous cancel	       ;AC000;
   JNE $$IF54

					;---------------------------------------
					;--- transform * to ?'s
					;---------------------------------------
       inc  si
       inc  si				; points to actual name (past path char)
       mov  di,OFFSET CodeR:ACBuf
       push di
       mov  cx,12
       mov  al,20h
       cld
       rep  stosb			; fill fcb with blanks
       pop  di
       push si
       mov  ax,(Parse_file_descriptor shl 8) and 0FF00h
       call My21
       pop  si

					;---------------------------------------
					;--- Copy name to expanded name
					;---------------------------------------

       push ds
       pop  es

       ASSUME DS:nothing

       push cs
       pop  ds

       ASSUME DS:CodeR

       push es
       mov  di,si
       mov  si,OFFSET CodeR:ACName
       mov  cx,8

;      $do				;				       ;AC000;
$$DO55:

	   lodsb			; move name
	   cmp	al,20h

;      $leave e 			;				       ;AC000;
       JE $$EN55

	   stosb

;      $enddo loop			;				       ;AC000;
       LOOP $$DO55
$$EN55:

       mov  si,OFFSET CodeR:ACExt
       cmp  byte ptr [si],20h		; extension starts with blank ?

;      $if  ne				; if it does not		       ;AC000;
       JE $$IF58

	   mov	al,"."
	   stosb
	   mov	cx,3

;	   $do				;				       ;AC000;
$$DO59:

	       lodsb			; move name
	       cmp  al,20h

;	   $leave e			;				       ;AC000;
	   JE $$EN59

	       stosb

;	   $enddo loop			;				       ;AC000;
	   LOOP $$DO59
$$EN59:

;      $endif				;				       ;AC000;
$$IF58:

       mov  byte ptr es:[di],0		; nul terminate
       pop  ds

       ASSUME DS:nothing

       push cs
       pop  es

;  $endif				;				       ;AC000;
$$IF54:

   ASSUME ES:CodeR

   ret

   BREAK <Add a file to the queue>

ADDFIL:

   ASSUME DS:CodeR,ES:nothing

					;---------------------------------------
					;--- Check that queue is not full
					;---------------------------------------

   mov	di,[QueueTail]			; load pointer to next empty entry
   cmp	di,[EndQueue]			; queue full?
   jb	OkToQueue			; no, place in queue...
   mov	ax,error_queue_full
   stc

   ret
					;---------------------------------------
					;--- Copy name to empty slot in queue
					;---------------------------------------
OkToQueue:

					;
					; Retrieve old DS
					;
   push bp
   mov	bp,sp				;  0	2    4
   mov	ds,[bp+ 2 + 2]			; <BP> <RET> <DS>
   pop	bp

   ASSUME DS:nothing

   push cs
   pop	es				; ES:DI points to empty slot

   ASSUME ES:CodeR

   mov	si,dx				; DS:SI points to submit packet
   cmp	byte ptr ds:[si],0
   jnz	IncorrectLevel
   lds	si,dword ptr ds:[si+1]		; DS:SI points to filename
   mov	cx,MaxFileLen			; maximum length of file name

CopyLop:

   lodsb
   stosb
   or	al,al				; nul?
   je	CopyDone			; yes, done with move...
   loop CopyLop
   push cs
   pop	ds

   ASSUME DS:CodeR

   mov	ax,error_name_too_long		; if normal exit from the loop then
   stc

   ret

IncorrectLevel:

   mov	ax,error_invalid_function
   stc

   ret

   ASSUME DS:nothing,ES:nothing 	; es:nothing = not true but lets

CopyDone:				;   avoid possible problems...

   push cs
   pop	ds

   ASSUME DS:CodeR

					;---------------------------------------
					;--- advance queue pointer
					;---------------------------------------

   mov	si,[QueueTail]			; pointer to slot just used
   push si				; save for test open later
   add	si,MaxFileLen
   mov	[QueueTail],si			; store for next round
   mov	byte ptr [si],0 		; nul next entry (maybe the EndQueue)

					;---------------------------------------
					;--- Check that file exists
					;---------------------------------------

   call Set24
   mov	[PAbort],0
   pop	dx				; get pointer to filename
   call OpenFile			;				       ;AC000;
   pushf
   push dx
   call Res24
   pop	dx
;;;popff				;; dcl removed for p1020	       ;AC000;
   popf 				;; dcl to fix p1020
   jnc	GOTFIL
					;---------------------------------------
					; See if brain damaged user entered
					;    an invalid drive
					;---------------------------------------
   push ax
   mov	si,dx
   cmp	BYTE PTR CS:[SI+1],':'
   jz	GotDrive
   pop	ax
   jmp	SHORT	i24bf

GotDrive:

   mov	ah,Get_default_drive		; get current
   call My21
   push ax
   mov	dl,CS:[SI]			; get drive letter to test
   or	dl,20h
   sub	dl,'a'
   mov	ah,Set_Default_Drive		; set it
   call My21
   mov	ah,Get_default_drive		; get it back
   call My21
   cmp	al,dl				; same? 		;; dcl change al,al to al,dl
   jnz	BadDrive			; no, bad drive
   pop	dx				; get original back
   mov	ah,Set_Default_Drive		; set original
   call My21
   pop	ax
   mov	dx,si
   jmp	SHORT i24bf

BadDrive:

   pop	dx				; get original back
   mov	ah,Set_Default_Drive		; set original
   call My21
   pop	ax
   mov	ax,error_invalid_drive
   mov	dx,si

I24BF:

   mov	si,[QueueTail]			; take bad name out of queue
   sub	si,MaxFileLen			; SI points to the slot with bad name
   mov	[QueueTail],si
   mov	byte ptr [si],0 		; nul the first byte
   stc

   ret


					;---------------------------------------
					;--- Check if print currently busy
					;---------------------------------------

GotFil:

   cmp	[CURRFIL],0			; currently printing?

;  $if	nz				; if currently printing 	       ;AC000;
   JZ $$IF64

       mov  bx,ax			; busy, close handle
       call Set24
       mov  [PAbort],1			; no Int24's
       call CloseFile			; close the file		       ;AC000;
       call Res24

;  $else				;				       ;AC000;
   JMP SHORT $$EN64
$$IF64:
					;---------------------------------------
					;--- Save file data
					;---------------------------------------

       mov  [CURRHAND],ax		; Valid handle
       mov  ax,[ENDPTR]
       mov  [NXTCHR],ax 		; Buffer empty
       mov  [CURRFIL],1
					;---------------------------------------
					;--- Send Open on output device
					;---------------------------------------
       call Open_Dev

;  $endif				;				       ;AC000;
$$EN64:

   clc

   ret

   BREAK <Fake int 21H>

					;---------------------------------------
					; perform a  system call as myself
					;---------------------------------------

My21:

   call Context_switch
   call Do_21

   ret

   Public do_21

DO_21:

   ASSUME DS:nothing,ES:nothing

   CMP	BYTE PTR CS:[INT15FLAG],0

;  $if	nz				; if for PRINT			       ;AC000;
   JZ $$IF67

       push ds
       push bx
       lds  bx,cs:[INT15PTR]
       inc  BYTE PTR [bx]
       pop  bx
       pop  ds
       call OffSave
       int  21h
       call OnSave
       push ds
       push bx
       pushf				; Flags from system call
       lds  bx,CS:[INT15PTR]
       dec  BYTE PTR [BX]
       popf				;
       pop  bx				;AC000;
       pop  ds

;  $else				;				       ;AC000;
   JMP SHORT $$EN67
$$IF67:

       call OffSave
       int  21h
       call OnSave

;  $endif				;				       ;AC000;
$$EN67:

   ret

OffSave:

   ASSUME DS:nothing,ES:nothing,SS:nothing

   push ax
   push dx
   mov	ax,Set_CTRL_C_Trapping SHL 8 + 2
   xor	dl,dl
   int	21h
   mov	CtrlC,dl
   pop	dx
   pop	ax

   ret

OnSave:

   ASSUME DS:nothing,ES:nothing,SS:nothing

   push ax
   push dx
   mov	ax,Set_CTRL_C_Trapping SHL 8 + 2
   mov	dl,CtrlC
   int	21h
   pop	dx
   pop	ax

   ret

   BREAK <Priter Support>

ListMes2:

   ASSUME DS:CodeR,ES:nothing

   lodsb
   cmp	al,0
   jz	LMesDone
   call LOUT
   jmp	SHORT LISTMES2


LISTMES:

   ASSUME DS:CodeR,ES:nothing

   lodsb
   cmp	al,"$"
   jz	LMESDONE
   call LOUT
   jmp	SHORT LISTMES

LMESDONE:

   ret

LOUT:

   push bx

LWAIT:

   call PSTAT
   jz	PREADY
   cmp	[ERRCNT],ERRCNT2
   ja	POPRET				;Don't get stuck
   jmp	SHORT LWAIT

PREADY:

   call POUT

POPRET:

   pop	bx

   ret


   BREAK <TO_DOS>
;******************* START OF SPECIFICATIONS ***********************************
;
;  NAME:	TO_DOS
;
;  FUNCTION:	Make a SERVER DOS call
;
;  INPUT:
;
;  OUTPUT:
;
;  NOTE:
;
;  REGISTERS USED: T.B.D.
;  (NOT RESTORED)
;
;  LINKAGE:
;
;  NORMAL
;  EXIT:
;
;  ERROR
;  EXIT:
;
;  CHANGE	12/16/87 - Add SERVER DOS call - F. G
;  LOG:
;
;******************* END OF SPECIFICATIONS *************************************
;******************** START - PSEUDOCODE ***************************************
;
;	START TO_DOS
;
;	ret
;
;	END TO_DOS
;
;******************** END   - PSEUDOCODE ***************************************

   TO_DOS PROC FAR

   ASSUME DS:NOTHING,ES:NOTHING

;  Call the dos via server dos call using a DPL.  The currentPDB *must* be
;  properly set before this call!
;  INPUT: Regs set for INT 21
;  OUTPUT: Of INT 21



   MOV	[PRTDPL.DPL_DS],DS		;				       ;AN010;
   PUSH CS				;				       ;AN010;
   POP	DS				;				       ;AN010;

   MOV	[PRTDPL.DPL_BX],BX		;				       ;AN010;
   MOV	BL,AL				; set up DRIVE ID		       ;AN010;
   SUB	BL,40h				; convert to number		       ;AN010;
   XOR	AL,AL				; remove file ID		       ;AN010;
   MOV	[PRTDPL.DPL_AX],AX		;				       ;AN010;
   MOV	[PRTDPL.DPL_CX],CX		;				       ;AN010;
   MOV	[PRTDPL.DPL_DX],DX		;				       ;AN010;
   MOV	[PRTDPL.DPL_SI],SI		;				       ;AN010;
   MOV	[PRTDPL.DPL_DI],DI		;				       ;AN010;
   MOV	[PRTDPL.DPL_ES],ES		;				       ;AN010;
   XOR	AX,AX				;				       ;AN010;
   MOV	[PRTDPL.DPL_reserved],AX	;				       ;AN010;
   MOV	[PRTDPL.DPL_UID],AX		;				       ;AN010;
   MOV	AX,CS				;				       ;AN010;
   SUB	AX,10h				;				       ;AN010;
   MOV	[PRTDPL.DPL_PID],AX		;				       ;AN010; ;				      ;AN010;
					; IOCtl call to see if target drive is local
					;   x = IOCTL (getdrive, Drive+1)      ;AN010;
   mov	ax,(IOCTL SHL 8) + 9		;				       ;AN010;
   INT	21h				; IOCtl + dev_local  <4409>	       ;AN010;

   MOV	BX,[PRTDPL.DPL_BX]		; restore register		       ;AN010;

;  $if	nc,and				; target drive local and	       ;AN010;
   JC $$IF70

   test dx,1200H			; check if (x & 0x1000) 	       ;AN010;
					;      (redirected or shared)
;  $if	z				; if RC indicates NOT a network drive  ;AN010;
   JNZ $$IF70

       MOV  DX,OFFSET CODER:PRTDPL	;				       ;AN010;
       MOV  AX,(ServerCall SHL 8)	; make a SERVER DOS call	       ;AN010;

;  $else				;				       ;AN010;
   JMP SHORT $$EN70
$$IF70:

       MOV  DX,[PRTDPL.DPL_DX]		; fix up reg			       ;AN010;
       MOV  AX,[PRTDPL.DPL_AX]		; make a normal DOS call	       ;AN010;
       PUSH [PRTDPL.DPL_DS]		; fix up segment reg		       ;AN010;
       POP  DS				;				       ;AN010;

;  $endif				;				       ;AN010;
$$EN70:

   CALL My21				;				       ;AN010;

   RET					;				       ;AN010;

   TO_DOS ENDP

   BREAK <Open_Device>
					;---------------------------------------
					; Stuff for BIOS interface
					;---------------------------------------

;			$SALUT (4,25,30,41)

IOBUSY			EQU  0200H
IOERROR 		EQU  8000H

BYTEBUF 		DB   ?

CALLAD			DD   ?

IOCALL			DB   22
			DB   0
IOREQ			DB   ?
IOSTAT			DW   0
			DB   8 DUP(?)
			DB   0
			DW   OFFSET CodeR:BYTEBUF
INTSEG			DW   ?
IOCNT			DW   1
			DW   0

;  $SALUT (4,4,9,41)

					;---------------------------------------
					; Following two routines perform device
					; open and close on output device.
					; NO REGISTERS (including flags) are
					;  Revised. No errors generated.
					;---------------------------------------

   public open_dev

Open_Dev:

   ASSUME DS:nothing,ES:nothing

					;---------------------------------------
					; We are now going to use the printer...
					; We must lock down the printer so that
					; the network does not intersperse output
					; on us...
					; We must also signal the REDIRector for
					; stream open.	We must ask DOS to set
					; the Printer Flag to busy
					;---------------------------------------

   push bx
   pushf
   push ax
   push dx
   mov	dx,PrinterNum
   cmp	dx,-1

;  $if	nz				;				       ;AC000;
   JZ $$IF73

       mov  ax,0203h			; redirector lock
       int  2Fh
       mov  ax,0201H			; Redirector OPEN
       int  2Fh

;  $endif				;
$$IF73:

   mov	ax,(SET_PRINTER_FLAG SHL 8) + 01
   int	21h
   pop	dx
   pop	ax
   mov	bl,DEVOPN			; Device OPEN
   call OP_CL_OP
   popf 				;				       ;AC000;
   pop	bx

   ret

OP_CL_OP:

   push ds
   push si
   lds	si,[LISTDEV]

   ASSUME DS:nothing

   test [SI.SDEVATT],DEVOPCL

;  $if	nz				;				       ;AC000;
   JZ $$IF75

       push cs
       pop  ds

       ASSUME DS:CodeR

       mov  [IOCALL],DOPCLHL
       call DOCALL

;  $endif				;				       ;AC000;
$$IF75:

   pop	si
   pop	ds

   ASSUME DS:nothing

   ret

   public close_dev

Close_Dev:

   ASSUME DS:nothing,ES:nothing

					;---------------------------------------
					; At this point, we release the ownership
					; of the printer... and do a redirector
					; CLOSE.
					; Also tell DOS to reset the Printer Flag
					;---------------------------------------

   push bx
   pushf
   mov	bl,DEVCLS
   call OP_CL_OP			; Device CLOSE
   push ax
   push dx
   mov	dx,PrinterNum
   cmp	dx,-1

;  $if	nz				;				       ;AC000;
   JZ $$IF77

       mov  ax,0202h			; redirector CLOSE
       int  2Fh
       mov  ax,0204h			; redirector clear
       int  2Fh

;  $endif				;				       ;AC000;
$$IF77:

   mov	ax,(SET_PRINTER_FLAG SHL 8) +00
   int	21h
   pop	dx
   pop	ax
   popf 				;				       ;AC000;
   pop	bx

   ret

PSTAT:

   ASSUME DS:CodeR

   push bx
   inc	[ERRCNT]
   mov	BL,DEVOST
   mov	[IOCALL],DSTATHL
   call DOCALL
   test [IOSTAT],IOERROR

;  $if	nz				;				       ;AC000;
   JZ $$IF79

       or   [IOSTAT],IOBUSY		;If error, show buisy

;  $endif				;				       ;AC000;
$$IF79:

   test [IOSTAT],IOBUSY

;  $if	z				; if				       ;AC000;
   JNZ $$IF81

       mov  [ERRCNT],0

;  $endif				;				       ;AC000;
$$IF81:

   pop	bx

   ret

POUT:

   ASSUME DS:CodeR

   mov	[BYTEBUF],al
   mov	bx,DEVWRT
   mov	[IOCALL],DRDWRHL

DOCALL:

   push es
   mov	[IOREQ],bl
   mov	bx,cs
   mov	es,bx
   mov	[IOSTAT],0
   mov	[IOCNT],1
   push ds
   push si
   push ax
   call Context_Switch
   mov	bx,OFFSET CodeR:IOCALL
   lds	si,[LISTDEV]

   ASSUME DS:nothing

   mov	ax,[SI+SDEVSTRAT]
   mov	WORD PTR [CALLAD],ax
   call [CALLAD]
   mov	AX,[SI+SDEVINT]
   mov	WORD PTR [CALLAD],ax
   call [CALLAD]
   pop	ax
   pop	si
   pop	ds

   ASSUME DS:CodeR

   pop	es

   ret

;			$SALUT (4,25,30,41)

REAL_INT_13		DD   ?

INT_13_RETADDR		DW   OFFSET CodeR:INT_13_BACK

;  $SALUT (4,4,9,41)

   INT_13 PROC FAR

   ASSUME DS:nothing,ES:nothing,SS:nothing

   pushf
   inc	[BUSY]				;Exclude if dumb program call ROM
   push cs
   push [INT_13_RETADDR]
   push WORD PTR [REAL_INT_13+2]
   push WORD PTR [REAL_INT_13]

   ret

   INT_13 ENDP

   INT_13_BACK PROC FAR

   pushf
   dec	[BUSY]
   popf 				;				       ;AC000;

   ret	2				;Chuck saved flags

   INT_13_BACK ENDP

;			$SALUT (4,25,30,41)

REAL_INT_15		DD   ?
INT15FLAG		DB   0		; Init to off
INT15PTR		DD   ?

;  $SALUT (4,4,9,41)

   INT_15 PROC FAR

   ASSUME DS:nothing,ES:nothing,SS:nothing

   cmp	ah,20h
   jnz	REAL_15 			; Not my function
   cmp	AL,1
   ja	REAL_15 			; I only know 0 and 1
   je	FUNC1
   inc	[INT15FLAG]			; Turn ON
   mov	WORD PTR [INT15PTR],bx		; Save counter loc
   mov	WORD PTR [INT15PTR+2],es

   iret

FUNC1:

   mov	[INT15FLAG],0			; Turn OFF

   iret

REAL_15:

   jmp	[REAL_INT_15]

   INT_15 ENDP

;			$SALUT (4,25,30,41)

FLAG17_14		DB   0		; Flags state of AUX/PRN redir
REAL_INT_5		DD   ?
REAL_INT_17		DD   ?
INT_17_NUM		DW   0

;  $SALUT (4,4,9,41)

INT_17:

   ASSUME DS:nothing,ES:nothing,SS:nothing

   cmp	[FLAG17_14],1
   jnz	DO_INT_17			;The PRN device is not used
   cmp	[CURRFIL],0
   jz	DO_INT_17			;Nothing pending, so OK
   cmp	dx,[INT_17_NUM]
   jnz	DO_INT_17			;Not my unit
   cmp	[BUSY],0
   jnz	DO_INT_17			;You are me
   sti
   mov	ah,0A1h 			;You are bad, get time out

   iret

DO_INT_17:

   jmp	[REAL_INT_17]			;Do a 17

;			$SALUT (4,25,30,41)

REAL_INT_14		DD   ?
INT_14_NUM		DW   0

;  $SALUT (4,4,9,41)

INT_14:

   ASSUME DS:nothing,ES:nothing,SS:nothing

   cmp	[FLAG17_14],2
   jnz	DO_INT_14			;The AUX device is not used
   cmp	[CURRFIL],0
   jz	DO_INT_14			;Nothing pending, so OK
   cmp	DX,[INT_14_NUM]
   jnz	DO_INT_14			;Not my unit
   cmp	[BUSY],0
   jnz	DO_INT_14			;You are me
   sti
   or	ah,ah
   jz	SET14_AX
   cmp	ah,2
   jbe	SET14_AH

SET14_AX:

   mov	al,0

SET14_AH:

   mov	ah,80h				;Time out

   iret

DO_INT_14:

   jmp	[REAL_INT_14]			;Do a 14

INT_5:

   ASSUME DS:nothing,ES:nothing,SS:nothing

   cmp	[FLAG17_14],1
   jnz	DO_INT_5			;The PRN device is not used
   cmp	[CURRFIL],0
   jz	DO_INT_5			;Nothing pending, so OK
   cmp	[INT_17_NUM],0
   jnz	DO_INT_5			;Only care about unit 0

   iret 				;Pretend it worked

DO_INT_5:

   jmp	[REAL_INT_5]			;Do a 5

;			$SALUT (4,25,30,41)

ERRCNT			DW   0

;  $SALUT (4,4,9,41)

   BREAK <Bootstrap Cleanup Code>

ReBtINT:

   ASSUME CS:CodeR,DS:nothing,ES:nothing,SS:nothing

   cli
   push cs
   pop	ds

IntWhileBusy:

   int	ComInt
   jnc	NotBusy
   jmp	IntWhileBusy

NotBusy:

   inc	[BUSY]				; Exclude hardware interrupts
   inc	[SOFINT]			; Exclude software interrupts

   call CanAll				; Purge the Queue

   lds	dx,CodeR:COMNEXT
   mov	ax,(set_interrupt_vector shl 8) or comint
   int	21h				;Set int 2f vector

   lds	dx,CodeR:NEXTINT
   mov	ax,(set_interrupt_vector shl 8) or intloc
   int	21h				;Set hardware interrupt

   mov	ax,(set_interrupt_vector shl 8) or 15h
   lds	dx,CodeR:Real_Int_15		; Reset the wait on event on ATs
   int	21h

   mov	ax,(set_interrupt_vector shl 8) or 17h
   lds	dx,CodeR:Real_Int_17
   int	21h				;Set printer   interrupt

   mov	ax,(set_interrupt_vector shl 8) or 5h
   lds	dx,CodeR:Real_Int_5
   int	21h				;Set print screen   interrupt

   mov	ax,(set_interrupt_vector shl 8) or 14h
   lds	dx,CodeR:Real_Int_14
   int	21h				;Set printer   interrupt

   mov	ax,(set_interrupt_vector shl 8) or 24h
   lds	dx,CodeR:HERRINT
   int	21h				;Set printer   interrupt

   mov	ax,(set_interrupt_vector shl 8) or reboot
   lds	dx,CodeR:NEXT_REBOOT
   int	21h				;Set bootstrap interrupt

   sti
   int	19h

   BREAK <OpenFile>
;******************* START OF SPECIFICATIONS ***********************************
;
;  NAME:	OpenFile    - PRINT Open a File for printing
;
;  FUNCTION:	This subroutine will manage all environment changes required
;		for Code Page switching support. This is accomplished as set
;		out in the pseudocode below.
;
;  INPUT:	(DS:DX) = ASCIIZ of file to print
;
;  OUTPUT:	(AX) = handle of file
;		No CPSW     - File opened using INT 21 - 3D
;		CPSW active - no CP on print file
;				    - Print file opened using INT 21 - 3D
;			    - valid CP on print file
;				    - PRINTER.SYS locked from CP change
;				    - Print file opened using INT 21 - 6C
;				    - Print file CP in CURRCP
;				    - Printer set to CURRCP
;
;  NOTE:	PRINT - PRINTER.SYS  2F Interface
;
;		(AX) =	AD40h	 - ADh is the function id
;				 - 40h is the sub-function id
;		(BX) =	n	 - change to this code page (binary value)
;				     and save current CP or any further
;				     change requested
;		       -1	 - restore saved CP and unlock
;		(DX)	m	 - LPTm #
;
;
;  REGISTERS USED:  T.B.D.
;  (NOT RESTORED)
;
;  LINKAGE:	Called by FILEOF, CANFIL and ADDFIL
;
;  EXTERNAL	Calls to: My21
;   ROUTINES:
;
;  NORMAL	CF = 0
;  EXIT:
;
;  ERROR	CF = 1
;  EXIT:
;
;  CHANGE	03/11/87 - First release      - F. Gnuechtel
;  LOG:
;
;******************* END OF SPECIFICATIONS *************************************
;******************** START - PSEUDOCODE ***************************************
;
;	START OpenFile
;
;	set up for INT 21 - 33 to see if CPSW is active
;	call MY_21
;	if CPSW is active and
;		set up for  INT 21 - 6C Extended Open
;		call MY_21 to open file
;	if no error and
;	if valid CP
;		if valid LPTx
;			update CURRCP
;			call INT 2F to lock and set PRINTER.SYS to CURRCP
;		endif
;	else
;		set up for INT 21 - 3D Open
;		call MY_21 to open file
;	endif
;	return
;
;	END OpenFile
;
;******************** END   - PSEUDOCODE ***************************************

   OpenFile PROC NEAR

nop
;int 3
nop

   mov	bx,dx				; save pointer for later	       ;AN000;
   mov	ax,(Set_CTRL_C_Trapping shl 8) + get_CPSW ; set up for INT 21 - 33     ;AN000;
					;	      to see if CPSW is active
   call My21				; call MY_21			       ;AN000;
   xchg dx,bx				; recover pointer		       ;AN000;
   cmp	bl,CPSW_on			; is CPSW active ?		       ;AN000;			;AN000;

;  $if	e				; if CPSW is active		       ;AC006;
   JNE $$IF83

       mov  ax,(ExtOpen shl 8) + 0	; set for INT 21-6C		       ;AN000;
       xor  cx,cx			;		   Extended Open       ;AN000;
       mov  bx,open_mode		;				       ;AN000;
       mov  si,dx			; set DS:SI to name		       ;AC006;
       mov  dx,(ignore_cp shl 8) + (failopen shl 4) + openit ; open if exists  ;AC001;
       mov  di,cx			;				       ;AC001;
       dec  di				;				       ;AC001;
       mov  al,ds:[si]			; recover drive - TO_DOS needs it
       call TO_DOS			; call TO_DOS to open file (SERVER DOS);AC010;

;      $if  nc,and			; if no error and		       ;AN000;
       JC $$IF84

       mov  bx,[code_page]		; is there a valid CP ? 	       ;AC006;

       cmp  bx,0			; is there a valid CP ? 	       ;AC006;

;      $if  g				; if valid CP ie: 0 < CP < -1	       ;AN000;
       JNG $$IF84

	   cmp	[PrinterNum],no_lptx	; is there a valid LPTx ?	       ;AN000;			;AN000;

;	   $if	ne			; if valid LPTx available	       ;AN000;
	   JE $$IF85

	       mov  cx,ax		; save file handle		       ;AN008;
	       mov  [CURRCP],bx 	; update CURRCP 		       ;AN000;
	       mov  dx,[PrinterNum]	;				       ;AN000;
	       mov  ax,(major_code shl 8) + minor_code ; semophore PRINTER.SYS ;AN000;
	       int  2Fh 		; call INT 2F to lock and set	       ;AN000;
					;     PRINTER.SYS to CURRCP
	       mov  ax,cx		; restore file handle		       ;AN008;
;	   $endif			; endif 			       ;AN000;
$$IF85:
;      $endif				; endif 			       ;AN006;
$$IF84:

;  $else				; else				       ;AN000;
   JMP SHORT $$EN83
$$IF83:

       mov  si,dx
       mov  al,ds:[si]			; recover drive - TO_DOS needs it
       mov  ah,(open)			; set up for INT 21 - 3D Open	       ;AN000;
       mov  cx,016h			; set up search attribute for Server   ;AN011;
					;			    DOS Open
       call TO_DOS			; call TO_DOS to open file (SERVER DOS);AC010;

;  $endif				; endif 			       ;AN000;
$$EN83:

   ret					; return			       ;AN000;

   OpenFile ENDP

   BREAK <CloseFile>
;******************* START OF SPECIFICATIONS ***********************************
;
;  NAME:	CloseFile    - PRINT Close a File for printing
;
;  FUNCTION:	This subroutine will manage all environment changes required
;		for Code Page switching support. This is accomplished by:
;
;		       (see pseudocode)
;
;  INPUT:	(BX) = handle of file to close
;		(DS) = CodeR
;
;  OUTPUT:	File closed
;		CPSW active - PRINTER.SYS unlocked
;			    - CHECKCP is reset
;
;  REGISTERS USED:  T.B.D.
;  (NOT RESTORED)
;
;  LINKAGE:	Called by FILEOF, CANALL, CANFIL and ADDFIL
;
;  EXTERNAL	Calls to: My21
;   ROUTINES:
;
;  NORMAL	CF = 0
;  EXIT:
;
;  ERROR	CF = 1
;  EXIT:
;
;  CHANGE	03/11/87 - First release      - F. G
;  LOG:
;
;******************* END OF SPECIFICATIONS *************************************
;******************** START - PSEUDOCODE ***************************************
;
;	START CloseFile
;
;	if CHECKCP != 0 then
;		call INT 2F to unlock PRINTER.SYS
;		reset CHECKCP
;	endif
;	set up for My21
;	call My21 to close file
;
;	return
;
;	END CloseFile
;
;******************** END   - PSEUDOCODE ***************************************

   CloseFile PROC NEAR

   cmp	[CURRCP],0			; is 0 < CHECKCP < -1 ? 	       ;AN000;

;  $if	g				; if CHECKCP is valid		       ;AN000;
   JNG $$IF90

       push bx				; save file handle		       ;AN000;
       xor  bx,bx			; set CP to unlock		       ;AN000;
       dec  bx				;				       ;AN000;
       mov  dx,[PrinterNum]		; set which LPTx		       ;AN000;
       mov  ax,(major_code shl 8) + minor_code ; semophore to PRINTER.SYS      ;AN000;
       int  2Fh 			; call INT 2F to unlock PRINTER.SYS    ;AN000;
       mov  [CURRCP],0			; reset CHECKCP 		       ;AN000;
       pop  bx				; recover file handle		       ;AN000;

;  $endif				; endif 			       ;AN000;
$$IF90:

   mov	ax,(close shl 8)		; set up for INT 21 - close	       ;AN000;
   call My21				; call My21 to close file	       ;AC010;

   ret					; return			       ;AN000;

   CloseFile ENDP

   BREAK <QUeue & Buffer Space>

;			$SALUT (4,25,30,41)

					;---------------------------------------
					;
					; NOTE: FileQueue is the actuall end of
					;	the RESIDENT PRINT code. The
					;	code that follows this is still
					;	initialization code - and is NOT
					;	left resident.
					;
					; --- File name Queue and data buffer
					;	follows here
					;
					;---------------------------------------

FileQueue		Label byte

			db   0		; the file queue starts empty


			BREAK <SETDEV>
;******************* START OF SPECIFICATIONS ***********************************
;
;  NAME:	SETDEV
;
;  FUNCTION:
;
;  INPUT:	LISTNAME has the 8 char device name IN UPPER CASE
;
;  OUTPUT:
;
;  NOTE:
;
;  REGISTERS USED: Only DS preserved
;  (NOT RESTORED)
;
;  LINKAGE:	Called by: MoveTrans
;
;  NORMAL	CF = 0
;  EXIT:
;
;  ERROR	CF = 1 - Bad Device name
;  EXIT:
;
;  CHANGE	05/20/87 - Header added       - F. G
;  LOG:
;
;******************* END OF SPECIFICATIONS *************************************
;******************** START - PSEUDOCODE ***************************************
;
;	START SETDEV
;
;	ret
;
;	END SETDEV
;
;******************** END   - PSEUDOCODE ***************************************

					;---------------------------------------
					; Reserved names for parallel card
					;---------------------------------------
INT_17_HITLIST		LABEL BYTE

			DB   8,"PRN     ",0
			DB   8,"LPT1    ",0
			DB   8,"LPT2    ",1
			DB   8,"LPT3    ",2
			DB   0

					;---------------------------------------
					; Reserved names for Async adaptor
					;---------------------------------------
INT_14_HITLIST		LABEL BYTE

			DB   8,"AUX     ",0
			DB   8,"COM1    ",0
			DB   8,"COM2    ",1
			DB   0
					;---------------------------------------
					; Default  Device Name
					;---------------------------------------

LISTNAME		DB   "PRN     " ;Device name

;  $SALUT (4,4,9,41)

   SETDEV PROC NEAR

   ASSUME CS:CodeR,DS:CodeR,ES:nothing,SS:nothing


   mov	ah,GET_IN_VARS
   call My21
   push es
   pop	ds
   lea	si,es:[bx.SYSI_DEV]

   ASSUME DS:nothing

   push cs
   pop	es

   ASSUME ES:CodeR

   mov	di,OFFSET CodeR:LISTNAME

;  $search				;				       ;AN000;
$$DO92:

       test [si.SDEVATT],DEVTYP 	;

;      $if  nz,and			; if type is character		       ;AN000;
       JZ $$IF93

       push si				;
       push di				;
       add  si,SDEVNAME 		; Point at name
       mov  cx,8			;
       repe cmpsb			;
       pop  di				;
       pop  si				;

;      $if  z				; if the end was reached with a match  ;AN000;
       JNZ $$IF93

	   stc				; signal end			       ;AN000;

;      $else
       JMP SHORT $$EN93
$$IF93:

	   clc				; keep looking

;      $endif				;				       ;AN000;
$$EN93:

;  $exitif c				;				       ;AN000;
   JNC $$IF92

       mov  WORD PTR [CALLAD+2],ds	;Get I/O routines
       mov  WORD PTR [LISTDEV+2],ds	;Get I/O routines
       mov  WORD PTR [LISTDEV],si
       push cs
       pop  ds

       ASSUME DS:CodeR

       mov  PrinterNum,-1		; Assume not an INT 17 device
       push cs
       pop  es

       ASSUME ES:CodeR

       mov  bp,OFFSET CodeR:LISTNAME
       mov  si,bp
       mov  di,OFFSET CodeR:INT_17_HITLIST

       call chk_int17_dev

;  $orelse				;				       ;AN000;
   JMP SHORT $$SR92
$$IF92:

       lds  si,[si.SDEVNEXT]		;
       cmp  si,-1			;

;  $endloop z				;				       ;AN000;
   JNZ $$DO92

       push cs
       pop  ds
       stc

;  $endsrch				;				       ;AN000;
$$SR92:

   ret

   SETDEV ENDP

   BREAK <chk_int17_dev>
;******************* START OF SPECIFICATIONS ***********************************
;
;  NAME:	chk_int17_dev
;
;  FUNCTION:
;
;  INPUT:	(DS) = CodeR
;		(ES) = CodeR
;
;  OUTPUT:
;
;  NOTE:
;
;  REGISTERS USED: T.B.D.
;  (NOT RESTORED)
;
;  LINKAGE:
;
;  NORMAL
;  EXIT:
;
;  ERROR
;  EXIT:
;
;  CHANGE	05/20/87 - Header added       - F. G
;  LOG:
;
;******************* END OF SPECIFICATIONS *************************************
;******************** START - PSEUDOCODE ***************************************
;
;	START chk_int17_dev
;
;	ret
;
;	END chk_int17_dev
;
;******************** END   - PSEUDOCODE ***************************************

   chk_int17_dev PROC NEAR

;  $search				;				       ;AC000;
$$DO100:
       mov  si,bp
       mov  cl,[di]
       inc  di

;      $if  ncxz			;				       ;AC000;
       JCXZ $$IF101

	   clc				;				       ;AC000;

;      $else				;				       ;AC000;
       JMP SHORT $$EN101
$$IF101:

	   stc				;				       ;AC000;

;      $endif				;				       ;AC000;
$$EN101:

;  $exitif c				;				       ;AC000;
   JNC $$IF100

       mov  di,OFFSET CodeR:INT_14_HITLIST

       call chk_int14_dev		;				       ;AC000;

;  $orelse				;				       ;AC000;
   JMP SHORT $$SR100
$$IF100:

       repe cmpsb
       lahf
       add  di,cx			;Bump to next position without affecting flags
       mov  bl,[di]			;Get device number
       inc  di
       sahf

;  $endloop z				;				       ;AC000;
   JNZ $$DO100

       xor  bh,bh
       mov  [INT_17_NUM],bx
       mov  PrinterNum,bx		; Set this as well to the INT 17 device
       mov  [FLAG17_14],1
       clc
					;
;  $endsrch				;				       ;AC000;
$$SR100:

   ret

   chk_int17_dev ENDP

   BREAK <chk_int14_dev>
;******************* START OF SPECIFICATIONS ***********************************
;
;  NAME:	chk_int14_dev
;
;  FUNCTION:
;
;  INPUT:	(DS) = CodeR
;		(ES) = CodeR
;
;  OUTPUT:
;
;  NOTE:
;
;  REGISTERS USED: T.B.D.
;  (NOT RESTORED)
;
;  LINKAGE:
;
;  NORMAL
;  EXIT:
;
;  ERROR
;  EXIT:
;
;  CHANGE	05/20/87 - Header added       - F. G
;  LOG:
;
;******************* END OF SPECIFICATIONS *************************************
;******************** START - PSEUDOCODE ***************************************
;
;	START chk_int14_dev
;
;	ret
;
;	END chk_int14_dev
;
;******************** END   - PSEUDOCODE ***************************************

   chk_int14_dev PROC NEAR

;  $search				;				       ;AC000;
$$DO108:

       mov  si,bp
       mov  cl,[di]
       inc  di

;      $if  ncxz			;				       ;AC000;
       JCXZ $$IF109

	   clc				;				       ;AC000;

;      $else				;				       ;AC000;
       JMP SHORT $$EN109
$$IF109:

	   stc				;				       ;AC000;

;      $endif				;				       ;AC000;
$$EN109:

;  $exitif c				;				       ;AC000;
   JNC $$IF108

       mov  [FLAG17_14],0

;  $orelse				;				       ;AC000;
   JMP SHORT $$SR108
$$IF108:

       repe cmpsb
       lahf
       add  di,cx			;Bump to next position without affecting flags
       mov  bl,[di]			;Get device number
       inc  di
       sahf

;  $endloop z				;				       ;AC000;
   JNZ $$DO108

       xor  bh,bh
       mov  [INT_14_NUM],bx
       mov  [FLAG17_14],2

;  $endsrch				;				       ;AC000;
$$SR108:

   clc					;				       ;AC015;

   ret

   chk_int14_dev ENDP

   BREAK <BADSPOOL>
;******************* START OF SPECIFICATIONS ***********************************
;
;  NAME:	BADSPOOL
;
;  FUNCTION:
;
;  INPUT:
;
;  OUTPUT:
;
;  NOTE:
;
;  REGISTERS USED: T.B.D.
;  (NOT RESTORED)
;
;  LINKAGE:
;
;  NORMAL
;  EXIT:
;
;  ERROR
;  EXIT:
;
;  CHANGE	05/20/87 - Header added       - F. G
;  LOG:
;
;******************* END OF SPECIFICATIONS *************************************
;******************** START - PSEUDOCODE ***************************************
;
;	START BADSPOOL
;
;	ret
;
;	END BADSPOOL
;
;******************** END   - PSEUDOCODE ***************************************

   BADSPOOL PROC NEAR

   ASSUME CS:CodeR,DS:CodeR,ES:nothing,SS:nothing

   mov	ax,(CLASS_B shl 8) + BADMES	;				       ;AC000;
   call GoDispMsg			;				       ;AC002;
;*********************************************************************
   mov	ax,(SET_PRINTER_FLAG SHL 8)	; Set flag to Idle
   int	21h
;*********************************************************************
   mov	ax,(EXIT SHL 8) OR 0FFH
   int	21h

   BADSPOOL ENDP

   BREAK <MoveTrans>
;******************* START OF SPECIFICATIONS ***********************************
;
;  NAME:	MoveTrans
;
;  FUNCTION:	Move the transient out of the way of the Buffer space
;
;  INPUT:
;
;  OUTPUT:
;
;  NOTE:
;
;  REGISTERS USED: T.B.D.
;  (NOT RESTORED)
;
;  LINKAGE:
;
;  NORMAL
;  EXIT:
;
;  ERROR
;  EXIT:
;
;  CHANGE	05/20/87 - Header added       - F. G
;  LOG:
;
;******************* END OF SPECIFICATIONS *************************************
;******************** START - PSEUDOCODE ***************************************
;
;	START MoveTrans
;
;	ret
;
;	END MoveTrans
;
;******************** END   - PSEUDOCODE ***************************************

ContTrans dd ?				; transient continuation address after move

MoveTrans label far

   ASSUME CS:CodeR,DS:CodeR,ES:CodeR,SS:nothing

   cli
   cld
   mov	[INTSEG],cs
   call SETDEV				;

   ASSUME ES:nothing

   jc	BADSPOOL
   mov	dx,OFFSET CodeR:SPINT
   mov	al,SOFTINT
   mov	ah,GET_INTERRUPT_VECTOR
   int	21h				;Get soft vector
   mov	WORD PTR [SPNEXT+2],es
   mov	WORD PTR [SPNEXT],bx
   mov	al,SOFTINT
   mov	ah,SET_INTERRUPT_VECTOR
   int	21h				;Set soft vector
   mov	dx,OFFSET CodeR:SPCOMINT
   mov	al,ComInt
   mov	ah,GET_INTERRUPT_VECTOR
   int	21h				;Get communication vector
   mov	WORD PTR [COMNEXT+2],es
   mov	WORD PTR [COMNEXT],bx
   mov	al,ComInt
   mov	ah,SET_INTERRUPT_VECTOR 	;Set communication vector
   int	21h
   mov	al,13h
   mov	AH,GET_INTERRUPT_VECTOR
   int	21h
   mov	WORD PTR [REAL_INT_13+2],es
   mov	WORD PTR [REAL_INT_13],bx
   mov	DX,OFFSET CodeR:INT_13
   mov	al,13h
   mov	ah,SET_INTERRUPT_VECTOR
   int	21h				;Set diskI/O interrupt

   mov	al,15h
   mov	ah,GET_INTERRUPT_VECTOR
   int	21h
   mov	WORD PTR [REAL_INT_15+2],es
   mov	WORD PTR [REAL_INT_15],bx
   mov	dx,OFFSET CodeR:INT_15
   mov	al,15h
   mov	ah,SET_INTERRUPT_VECTOR
   int	21h				;Set INT 15 vector
   mov	al,17h
   mov	ah,GET_INTERRUPT_VECTOR
   int	21h
   mov	WORD PTR [REAL_INT_17+2],es
   mov	WORD PTR [REAL_INT_17],bx
   mov	dx,OFFSET CodeR:INT_17
   mov	al,17H
   mov	ah,SET_INTERRUPT_VECTOR
   int	21h				;Set printer interrupt
   mov	al,14h
   mov	ah,GET_INTERRUPT_VECTOR
   int	21h
   mov	WORD PTR [REAL_INT_14+2],es
   mov	WORD PTR [REAL_INT_14],bx
   mov	dx,OFFSET CodeR:INT_14
   mov	al,14h
   mov	ah,SET_INTERRUPT_VECTOR
   int	21h				;Set RS232 port interrupt
   mov	al,5
   mov	ah,GET_INTERRUPT_VECTOR
   int	21h
   mov	WORD PTR [REAL_INT_5+2],es
   mov	WORD PTR [REAL_INT_5],bx
   mov	DX,OFFSET CodeR:INT_5
   mov	al,5
   mov	ah,SET_INTERRUPT_VECTOR
   int	21h				;Set print screen interrupt
   mov	ah,GET_INDOS_FLAG
   int	21h

   ASSUME ES:nothing

   mov	WORD PTR [INDOS+2],es		;Get indos flag location
   mov	WORD PTR [INDOS],bx
   mov	al,INTLOC
   mov	ah,GET_INTERRUPT_VECTOR
   int	21h
   mov	WORD PTR [NEXTINT+2],es
   mov	WORD PTR [NEXTINT],bx

   mov	al,REBOOT			; We also need to chain
   mov	ah,GET_INTERRUPT_VECTOR 	; Into the INT 19 sequence
   int	21h				; To properly "unhook"
   mov	WORD PTR [NEXT_REBOOT+2],es	; ourselves from the TimerTick
   mov	WORD PTR [NEXT_REBOOT],bx	; sequence
   mov	ax,0B800h
   int	2Fh
   cmp	al,0
   je	SET_HDSPINT			; No NETWORK, set hardware int
   test bx,0000000011000100B
   jnz	NO_HDSPINT			; DO NOT set HDSPINT if RCV|MSG|SRV

SET_HDSPINT:

   mov	dx,OFFSET CodeR:HDSPINT
   mov	al,INTLOC
   mov	ah,SET_INTERRUPT_VECTOR
   int	21h				;Set hardware interrupt

   mov	dx,OFFSET CodeR:ReBtINT
   mov	al,REBOOT
   mov	ah,SET_INTERRUPT_VECTOR
   int	21h				;Set bootstrap interrupt

NO_HDSPINT:

   mov	ax,(CLASS_B shl 8) + GOODMES	;				       ;AC000;
   call GoDispMsg			;				       ;AC002;

					;---------------------------------------
					;--- Move transient
					;      Note: do not use stack, it may
					;	     get trashed in move!
					;---------------------------------------

   public RealMove

RealMove:

   mov	ax,OFFSET dg:TransRet
   mov	WORD PTR [ContTrans],ax 	; store return offset
   mov	cx,DG
   mov	WORD PTR [ContTrans+2],cx	; return segment
   mov	ax,CodeR
   add	ax,[endres]			; get start of moved transient, actually
					;  this is 100 bytes more than need be
					;  because of lack of pdb, but who cares?

					; NOTE: The following $IF was added for
					;	 DOS 4.0.  For earlier versions,
					;	 the transient would even be moved
					;	 IN if required < available
					;	 - this would now clobber the
					;	    message code.

   cmp	ax,cx				; is required size > available size ?

;  $if	a				; if it is - move transient out
   JNA $$IF116

       mov  WORD PTR [ContTrans+2],ax	; return segment
       mov  es,ax			; new location for dg group

       ASSUME ES:nothing

       mov  ax,dg
       mov  ds,ax

       ASSUME DS:nothing

       mov  cx,OFFSET dg:TransSize
       mov  si,cx			; start from the bottom and move up
       mov  di,cx
       std
       rep  movsb			; move all code, data and stack
       cld				; restore to expected setting...

					;---------------------------------------
					;--- normalize transient segment regs
					;---------------------------------------
       mov  ax,es
       mov  ds,ax
       sub  ax,dg			; displacement
       mov  dx,ss
       add  dx,ax			; displace stack segemnt
       mov  ss,dx

;  $endif
$$IF116:

   ASSUME DS:nothing,ES:nothing,SS:nothing

   jmp	ContTrans			; back to the transient...

   CodeR EndS

   End

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\print\pridefs.asm ===
;	SCCSID = @(#)pridefs.asm	4.4 85/07/17
title	DOS Print Utility

;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

;MS-DOS PSPRINT/PRINT program for background printing of text files
;	to the list device.
;
;  IBM SERVER VERSION
;
;	 INT 28H is a software interrupt generated by the  DOS
;	 in  its  I/O  wait  loops.   This spooler can be assembled for
;	 operation using only this interrupt  which  is  portable  from
;	 system to  system.  It may also be assembled to use a hardware
;	 timer interrupt in addition to  the  software	INT  28H.   The
;	 purpose  of  using hardware interrupts is to allow printing to
;	 continue during programs which do not	enter  the  system  and
;	 therefore causes the INT 28H to go away.  A timer interrupt is
;	 chosen in preference to a  "printer  buffer  empty"  interrupt
;	 because  PRINT  in the timer form is generic.	It can be given
;	 the name of any currently installed character	device	as  the
;	 "printer",  this  makes  it  portable  to  devices  which  are
;	 installed by the user even in the hardware case.  It could  be
;	 Revised to use a buffer empty interrupt (no code is given for
;	 this case), if this is done the PROMPT and BADMES messages and
;	 their associated  code should be removed as PRINT will then be
;	 device specific.
;
;	V1.00	07/03/82
;	V2.00	07/05/83	A.R.
;		New INT 2FH interface, Pathnames, context switch.
;	V2.50	09/14/83	M.A.U
;		Turned it back to a print
;		11/21/83	M.A.U
;		Repaired bug in file cancel code
;		11/28/83	M.A.U
;		Added int 23 and 24 handlers to transient.
;		01/27/84	M.A.U
;		Allways checks for valid drive.
;	V3.00	02/03/84	M.A.U
;		Partitioned so as to assemble on a PC
;		By the by, it is V3.00 now.
;		05/23/85	K.G.S
;		Chains into INT19 (bootstrap) to unhook
;		INT_1C (timer) and INT_15 (AT's Wait On Event)
;


;	Aaron's rambling:
;
; BEWARE ALL YEE WHO ENTER HERE.
;    PRINT is an amazingly complex program.  MS-DOS versions below 3.00 are
;    NOT re-entrant, this means that this utility is basically not a
;    possibility.  It gets by on the fact that it is written by the same
;    person who wrote the OS.  Since you are not that person, you must be very
;    careful about making any modification to this utility.  There are a
;    number of things which may seem to be unnecessary on first examination.
;    BEWARE, almost every line of code is there for a very good reason.  The
;    order of things is very carefully chosen.	PRINT is full of potential
;    windows, make sure that you do not open one by careless modification.  Do
;    not look for a lot of help from the comments, a complete explanation
;    would probably fill a book.  A succesful modifier will have an in-depth
;    knowledge of the internal function of MS-DOS, and of the PRINT utility
;    itself through in depth study of the comments AND the code.


subttl	General Definition
page


FALSE	EQU	0
TRUE	EQU	NOT FALSE

	IF	MSVER
HARDINT EQU	FALSE			;No hardware ints
AINT	EQU	FALSE			;No need to do interrupt acknowledge
	ENDIF

	IF	IBM
HARDINT EQU	TRUE
INTLOC	EQU	1CH			;Hardware interrupt location (Timer)
REBOOT	EQU	19H			;ROM BIOS "Bootstrap"
AINT	EQU	TRUE			;Acknowledge interrupts
EOI	EQU	20H			;End Of Interrupt "instruction"
AKPORT	EQU	20H			;Interrupt Acknowledge port
	ENDIF

;  The following values have to do with the ERRCNT variable and the CNTMES
;  message.  The values define levels at wich it is assumed an off-line error
;  exists.  ERRCNT1 defines the value of ERRCNT above which the CNTMES message
;  is printed by the transient.  ERRCNT2 defines the value of ERRCNT above
;  which the resident will give up trying to print messages on the printer, it
;  is much greater than ERRCNT1 because a much tighter loop is involved.  The
;  bounding event which determines the correct value is the time required to
;  do a form feed.

	IF	IBM
ERRCNT1 EQU	1500
ERRCNT2 EQU	20000
	ELSE
ERRCNT1 EQU	1500
ERRCNT2 EQU	20000
	ENDIF


;WARNING DANGER WARNING:
;   PRINT is a systems utility. It is clearly understood that it may have
;   to be entirely re-written for future versions of MS-DOS. The following
;   TWO vectors are version specific, they may not exist at all in future
;   versions. If they do exist, they may function differently.
; ANY PROGRAM WHICH IMITATES PRINTS USE OF THESE VECTORS IS ALSO A SYSTEMS
; UTILITY AND IS THEREFORE NOT VERSION PORTABLE IN ANY WAY SHAPE OR FORM.
; YOU HAVE BEEN WARNED, "I DID IT THE SAME WAY PRINT DID" IS NOT AN REASON
; TO EXPECT A PROGRAM TO WORK ON FUTURE VERSIONS OF MS-DOS.

SOFTINT EQU	28H			;Software interrupt generated by DOS
ComInt	EQU	2FH			;Communications interrupt used by PSPRINT
					;    Multiplex number 0 and 1

;----- Default (and Minimal) Print queue length
DefQueueLen equ 10			; 10 files worth
MinQueueLen equ 4			; 4 files worth min
MaxQueueLen equ 32			; 32 files worth max.

;----- Maximum length of a file name (incl nul)
MaxFileLen equ	64

; **************** Bogosity Warning *****************
;  Below is the equate that MaxFile SHOULD be.	Since the 3.0/3.1 documentation
;  documents each queue entry as being 64 chars long.  Yes it is known that
;  that causes Print to misbehave on files deep in trees.  But for
;  compatibilities sake, IBM insisted that we change the code back to the
;  way it was.
;MaxFileLen equ  63 + 2 + 12		 ; 63 characters as Command.com's
					;	  max. path length
					; 2  character for the Drive ext.
					; 12 characters for the max. valid
					;    DOS filename


.xlist
.xcref
BREAK	MACRO	subtitle
	SUBTTL	subtitle
	PAGE
ENDM

stdin	    EQU     0
stdout	    EQU     1
stderr	    EQU     2
stdaux	    EQU     3
stdprn	    EQU     4

	INCLUDE DEVSYM.INC
	INCLUDE SYSCALL.INC
	INCLUDE ERROR.INC
	INCLUDE SYSVAR.INC
	INCLUDE FIND.INC
	include dpl.asm
	INCLUDE PDB.INC
	INCLUDE SYSCALL.INC
	INCLUDE MI.INC
	include versiona.inc
.list
.cref


error_busy		EQU	9
error_queue_full	EQU	8
error_name_too_long	EQU	12

IF1
	IF	IBM
;	%out	IBM VERSION
	ELSE
	%out	MS-DOS VERSION
	ENDIF
ENDIF

BREAK	<Segment Definitions>


CodeR	Segment public para
CodeR	EndS

Code	Segment public para
Code	EndS

Data	Segment public byte
Data	EndS

Stack	Segment Stack
Stack	Ends

DG	group	Code,Data,Stack

SaveReg MACRO	reglist 		;; push those registers
IRP reg,<reglist>
	PUSH	reg
ENDM
ENDM
.xcref	SaveReg

RestoreReg  MACRO   reglist		;; pop those registers
IRP reg,<reglist>
	POP	reg
ENDM
ENDM
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\print\pridefs.inc ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

;                       $SALUT (4,25,30,41)
;******************* START OF SPECIFICATIONS ***********************************
;
; MODULE NAME:          PRINT.COM
;
; DESCRIPTIVE NAME:     DOS PRINT program for background printing of
;                       text files to the list device.
;
; FUNCTION:             DOS PRINT program for background printing of
;                       text files to the list device.  The utility is
;                       constructed of 3 .SAL files. They are:
;
;                               PRINT_R.SAL  - The resident portion of PRINT
;                               PRINT_T.SAL  - The transient portion of PRINT
;                               PRINT_SR.SAL - The service routines of PRINT
;
;                       NOTE:   The Link order is VERY important for this module.
;                               This is due to the Resident/Transient nature of
;                               PRINT.
;
;                               INT 28H is a software interrupt generated by the
;                               DOS in  its  I/O  wait  loops.   This spooler
;                               can be assembled for operation using only this
;                               interrupt  which  is  portable  from system to
;                               system.  It may also be assembled to use a
;                               hardware timer interrupt in addition to the
;                               software  INT  28H.   The purpose  of  using
;                               hardware interrupts is to allow printing to
;                               continue during programs which do not  enter
;                               the system and therefore causes the INT 28H to
;                               go away.  A timer interrupt is chosen in
;                               preference to a "printer buffer empty" interrupt
;                               because PRINT in the timer form is generic.  It
;                               can be given the name of any currently installed
;                               character device as the "printer", this makes it
;                               portable to devices which are installed by the
;                               user even in the hardware case.  It could be
;                               Revised to use a buffer empty interrupt (no
;                               code is given for this case), if this is done
;                               the PROMPT and BADMES messages and their
;                               associated  code should be removed as PRINT will
;                               then be device specific.
;
;       NOTE From Aaron Reynolds
;
; BEWARE ALL YEE WHO ENTER HERE.
;    PRINT is an amazingly complex program.  MS-DOS versions below 3.00 are
;    NOT re-entrant, this means that this utility is basically not a
;    possibility.  It gets by on the fact that it is written by the same
;    person who wrote the OS.  Since you are not that person, you must be very
;    careful about making any modification to this utility.  There are a
;    number of things which may seem to be unnecessary on first examination.
;    BEWARE, almost every line of code is there for a very good reason.  The
;    order of things is very carefully chosen.  PRINT is full of potential
;    windows, make sure that you do not open one by careless modification.  Do
;    not look for a lot of help from the comments, a complete explanation
;    would probably fill a book.  A succesful modifier will have an in-depth
;    knowledge of the internal function of MS-DOS, and of the PRINT utility
;    itself through in depth study of the comments AND the code.
;
; ENTRY POINT:
;
; INPUT:
;
; EXIT NORMAL:
;
; EXIT ERROR:
;
; INTERNAL REFERENCES:
;
;       ROUTINES:
;
;       DATA AREAS:
;
; EXTERNAL REFERENCES:
;
;       ROUTINES:
;
;       DATA AREAS:
;
; NOTES:
;
; REVISION HISTORY: Ax000  Version 4.0  05/01/87 - first release              FG
;                   Ax001  DCR D201              - Extended Atrib change      FG
;                   Ax002  P 1175                - move msgs back to TRANS    FG
;                   Ax003  P 1487                - PARSE error message problemFG
;                   Ax004  P 1546                - PARSE error trailing :     FG
;                   Ax005  P 1717                - multiples of same switch   FG
;                   Ax006  P 1996                - Extended open error        FG
;                   Ax007  P 2052                - [PRN] prompt lpt1 error    FG
;                   Ax008  P 2053                - CPSW prints empty file     FG
;                   Ax009  P 2229                - filename truncation        FG
;                   Ax010  D  389                - use transname /server DOS  FG
;                   Ax011  P 3122                - attrib missing /server DOS FG
;                   Ax012  P 3949                - Error in opening an open   FG
;                   Ax013  P 3949                - open mode - second attempt FG
;                   Ax014  P 4396                - some messages need STDOUT  FG
;                   Ax015  P 4880                - DRIVERS not recognized     FG
;
; PRE-VERSION 4.0 HISTORY:
;
;       V1.00   07/03/82
;       V2.00   07/05/83        A.R
;               New INT 2FH interface, Pathnames, context switch.
;       V2.50   09/14/83        M.A.U
;               Turned it back to a print
;               11/21/83        M.A.U
;               Repaired bug in file cancel code
;               11/28/83        M.A.U
;               Added int 23 and 24 handlers to transient.
;               01/27/84        M.A.U
;               Allways checks for valid drive.
;       V3.00   02/03/84        M.A.U
;               Partitioned so as to assemble on a PC
;               By the by, it is V3.00 now.
;               05/23/85        K.G.S
;               Chains into INT19 (bootstrap) to unhook
;               INT_1C (timer) and INT_15 (AT's Wait On Event)
;
; COPYRIGHT: "The DOS PRINT Utility"
;            "Version 4.00 (C) Copyright 1988 Microsoft
;            "Licenced Material - Program Property of Microsoft"
;
;
;******************* END OF SPECIFICATIONS *************************************
                        subttl PRINT - Program Organization
                        page
;******************* START PROGRAM ORGANIZATION *******************************
;
;
;Group / Label        Contents              File
;              ZDDDDDDDDDDDDDDDDD? D?
;CODER         3  Data buffer    3  C PRINT_RM
;              CMMMMMMMMMMMMMMMMM4 DY
;              3                 3 D?
;              3  Resident       3  3
;              3    Code         3  3
;              3                 3  3
;filequeue --- CDDDDDDDDDDDDDDDDD4  3
;              3  Resident       3  3
;              3    Initalization3  CD  PRINT_R
;              3      Code       3  3
;              CDDDDDDDDDDDDDDDDD4  3
;              CMMMMMMMMMMMMMMMMM4 DY
;              3  CL1 data       3  3
;              CDDDDDDDDDDDDDDDDD4  3
;              3  CL2 data       3
;              CDDDDDDDDDDDDDDDDD4  3
;              3  CLB data       3  3
;              CDDDDDDDDDDDDDDDDD4  CD  PRINT_TM
;              3  CLC data       3  3
;              CDDDDDDDDDDDDDDDDD4  3
;              3  CLD data       3  3
;              CMMMMMMMMMMMMMMMMM4 DY
;DG            3  Transient      3 D?
;              3    code         3  3
;              CDDDDDDDDDDDDDDDDD4  3
;              3  DispMsg        3  3
;              CDDDDDDDDDDDDDDDDD4  3
;              3  SYSMSG         3  3
;              3    Code         3  3
;              3  Parser         3  3
;              CDDDDDDDDDDDDDDDDD4  3
;              3  Transient      3  CD  PRINT_T
;              3    data         3  3
;              CDDDDDDDDDDDDDDDDD4  3
;              3  Stack          3  3
;transsize --- @DDDDDDDDDDDDDDDDDY DY
;
;
;*******************  END  ROGRAM ORGANIZATION  ********************************

                        subttl PRINT - Data Space
                        page
INCLUDE VERSION.INC
INCLUDE SYSVAR.INC

FALSE                   EQU  0
TRUE                    EQU  NOT FALSE

                        IF   MSVER
HARDINT                     EQU  FALSE  ;No hardware ints
AINT                        EQU  FALSE  ;No need to do interrupt acknowledge
                        ENDIF

                        IF   IBM
HARDINT                     EQU  TRUE
INTLOC                      EQU  1CH    ;Hardware interrupt location (Timer)
REBOOT                      EQU  19H    ;ROM BIOS "Bootstrap"
AINT                        EQU  TRUE   ;Acknowledge interrupts
EOI                         EQU  20H    ;End Of Interrupt "instruction"
AKPORT                      EQU  20H    ;Interrupt Acknowledge port
                        ENDIF

;  The following values have to do with the ERRCNT variable and the CNTMES
;  message.  The values define levels at wich it is assumed an off-line error
;  exists.  ERRCNT1 defines the value of ERRCNT above which the CNTMES message
;  is printed by the transient.  ERRCNT2 defines the value of ERRCNT above
;  which the resident will give up trying to print messages on the printer, it
;  is much greater than ERRCNT1 because a much tighter loop is involved.  The
;  bounding event which determines the correct value is the time required to
;  do a form feed.

                        IF   IBM
ERRCNT1                     EQU  1500
ERRCNT2                     EQU  20000
                        ELSE
ERRCNT1                     EQU  1500
ERRCNT2                     EQU  20000
                        ENDIF


;WARNING DANGER WARNING:
;   PRINT is a systems utility. It is clearly understood that it may have
;   to be entirely re-written for future versions of MS-DOS. The following
;   TWO vectors are version specific, they may not exist at all in future
;   versions. If they do exist, they may function differently.
; ANY PROGRAM WHICH IMITATES PRINTS USE OF THESE VECTORS IS ALSO A SYSTEMS
; UTILITY AND IS THEREFORE NOT VERSION PORTABLE IN ANY WAY SHAPE OR FORM.
; YOU HAVE BEEN WARNED, "I DID IT THE SAME WAY PRINT DID" IS NOT AN REASON
; TO EXPECT A PROGRAM TO WORK ON FUTURE VERSIONS OF MS-DOS.

SOFTINT                 EQU  28H        ;Software interrupt generated by DOS
ComInt                  EQU  2FH        ;Communications interrupt used by PSPRINT
                                        ;    Multiplex number 0 and 1

;----- Default (and Maximal / Minimal) Print queue length
MinQueueLen             equ  4          ; 4 files worth min
MaxQueueLen             equ  32         ; 32 files worth max.
DefQueueLen             equ  10         ; 10 files worth

;----- Default (and Maximal / Minimal) Print buffer length
MinBufferLen            equ  512        ; set minimum to 512 bytes
MaxBufferLen            equ  1024 * 16  ; maximum is 16 K bytes
DefBufferLen            equ  MinBufferLen ; set default to minimum

;----- Default (and Maximal / Minimal) Time Slice
MinTimeSlice            equ  1          ; set minimum to 1
MaxTimeSlice            equ  255        ; maximum is 255
DefTimeSlice            equ  10         ; set default to 10

;----- Default (and Maximal / Minimal) Busy Tick
MinBusyTick             equ  1          ; set minimum to 1
MaxBusyTick             equ  255        ; maximum is 255
DefBusyTick             equ  MinBusyTick ; set default to minimum

;----- Default (and Maximal / Minimal) Max Tick
MinMaxTick             equ  1          ; set minimum to 1
MaxMaxTick             equ  255        ; maximum is 255
DefMaxTick             equ  2          ; set default to 2

;----- Maximum length of a file name (incl nul)
MaxFileLen              equ  64

; **************** Bogosity Warning *****************
;  Below is the equate that MaxFile SHOULD be.  Since the 3.0/3.1 documentation
;  documents each queue entry as being 64 chars long.  Yes it is known that
;  that causes Print to misbehave on files deep in trees.  But for
;  compatibilities sake, IBM insisted that we change the code back to the
;  way it was.
;MaxFileLen equ  63 + 2 + 12             ; 63 characters as Command.com's
                                        ;         max. path length
                                        ; 2  character for the Drive ext.
                                        ; 12 characters for the max. valid
                                        ;    DOS filename

                                        ;----------------------------------------
                                        ;  definition of the MODE bits
                                        ;     for an extended open
                                        ;----------------------------------------

;                 BITS DEFINED FOR THE MODE WORD
;                       FORMAT = 0WF00000ISSS0AAA
;              Write   DDDDDDDDDDDY3     33   @DDD Access code
;                0 = no commit     3     33             0 = read
;                1 = auto commit   3     33             1 = write
;                                  3     33             2 = read/write
;          Fail action DDDDDDDDDDDDY     33             3 = execute
;            0 = INT 24h                 33             4 = FCB
;            1 = return error            33
;                                        3@DDD  Sharing mode
;                                        3         0 = compatability
;                                        3         1 = deny read/write
;                                        3         2 = deny write
;                                        3         3 = deny read
;                                        3         4 = deny none
;                                      Inherit
;                                        0 = pass handle to child
;                                        1 = no inherit
;
MODE_COM                equ  0100000000000000b ; Auto Commit
MODE_NO24               equ  0010000000000000b ; No 24 - return error
MODE_NOINH              equ  0000000010000000b ; No child procees access
;                                            Sharing mode
MODE_SH_COMP            equ  0000000000000000b ;    0 = compatability
MODE_SH_D_RW            equ  0000000000010000b ;    1 = deny read/write
MODE_SH_D_W             equ  0000000000100000b ;    2 = deny write
MODE_SH_D_R             equ  0000000000110000b ;    3 = deny read
MODE_SH_D_NONE          equ  0000000001000000b ;    4 = deny none
;                                            Access code
MODE_AC_R               equ  0000000000000000b ;    0 = read
MODE_AC_W               equ  0000000000000001b ;    1 = write
MODE_AC_RW              equ  0000000000000010b ;    2 = read/write
MODE_AC_EXE             equ  0000000000000011b ;    3 = execute
MODE_AC_FCB             equ  0000000000000100b ;    4 = FCB

GET_CPSW                equ  3          ; Get state of CPSW
CPSW_on                 equ  1          ; CPSW is active
major_code              equ  0ADh       ; INT 2F PRINT semaphore
minor_code              equ  040h       ; INT 2F PRINTER set and lock CP
                                        ;
                                        ; The Extended Open mode is set as:
                                        ;    Shareing Mode - Compatability
                                        ;    Access        - Read
                                        ;    Inharitance   - yes
                                        ;  -- WARNING ----
                                        ;        These MUST be set this way
                                        ;        in order to do a second open
                                        ;        of a file accross the network

open_mode               equ  MODE_NO24+MODE_SH_COMP+MODE_AC_R                  ;AC013;


ignore_cp               equ  1          ; dont validate CP - it may be different
                                        ;  than CON

openit                  equ  1          ; extended open 'exsists' action
failopen                equ  0          ; extended open 'does not exsist' action

Cap_ASCIIZ              equ  22h        ; Capitalize ASCIIZ string (INT 21 - 65)

;----- Message  related information

 ;================================================
 ; PRINT Message Skeleton File
 ;================================================

;util   PRINT

;class  1

;use   EXTEND19
;use   EXTEND20
;use   EXTEND21
;use   EXTEND22
;use   EXTEND23
;use   EXTEND24
;use   EXTEND25
;use   EXTEND26
;use   EXTEND27
;use   EXTEND28
;use   EXTEND29
;use   EXTEND30
;use   EXTEND31

;class  2
                                         ;1 - Too many operands
                                         ;2 - Required operand missing
;use   PARSE3                            ;3 - Not in switch list provided
                                         ;4 - Not in keyword list provided
;use   PARSE6                            ;6 - Out of range specified
                                         ;7 - Not in value list provided
                                         ;8 - Not in string list provided
;use   PARSE9                            ;9 - Invalid Parameter

;class  A

;def 6  " error reading file",CR,LF,"$"
;def 7  "File not found",CR,LF,"$"
;def 8  CR,LF,LF,"File $"
;def 9  " canceled by operator$"
;def 10 CR,LF,LF,"All files canceled by operator$"
;def 11 "File allocation table bad drive "
;def 12 "A.",CR,LF,"$"
;def 13 "List output is not assigned to a device",CR,LF
;def 14 "Resident part of PRINT installed",CR,LF

;class  B

;use 1  COMMON1
;def 2  CR,LF
;def 15 "Cannot use PRINT - Use NET PRINT",CR,LF
;def 17 "PRINT queue is full",CR,LF
;def 18 "PRINT queue is empty",CR,LF
;def 19 "Access denied",CR,LF
;def 20 "Invalid drive specification",CR,LF
;def 21 "Errors on list device indicate that it",CR,LF
;       "may be off-line. Please check it.",CR,LF

;class  C

;def 22 CR,LF,LF,"  %1 is currently being printed",CR,LF
;def 23 "  %1 is in queue",CR,LF
;use 24 EXTEND2
;def 25 "Pathname too long",CR,LF
;def 26 "File not in PRINT queue",CR,LF

;class  D

;def 27 "Name of list device [PRN]: "

;end
                                        ;--------------------------------------
                                        ; PRINT Equates
                                        ;--------------------------------------

MesSerCLASS equ 0                       ; Message Service class
DOS_error equ 1                         ; DOS extended error
Parse_error equ 2                       ; Parse error
CLASS_A equ 0Ah                         ; PRINT_R message
CLASS_B equ 0Bh                         ; PRINT_T message
CLASS_C equ 0Ch                         ; PRINT_T message with insert
CLASS_D equ 0Dh                         ; PRINT_T message with input buffer where:
CLASS_Util equ 0FFh                     ; PRINT utility message (Class A - D)
buffered_input equ 0Ah                  ; Buffered keyboard input

; CLASS 1

ERR0 equ 19
ERR12 equ 31

; CLASS 2

INVPARM                 equ  9         ; Invalid parameter   (PARSE)

; CLASS A

ERRMEST                 equ  6          ;  error reading file
ErrMesT2                equ  7          ; File not found
CanMes                  equ  8          ; File
CanFilNam               equ  9          ;  canceled by operator
AllCan                  equ  10         ; All files canceled by operator
FATMES                  equ  11         ; File allocation table bad drive
BADDRVM                 equ  12         ; A.
BADMES                  equ  13         ; List output is not assigned to a device
GOODMES                 equ  14         ; Resident part of PRINT installed

MSG_OPTIONS_FIRST	equ	300	; first options help msg nbr
MSG_OPTIONS_LAST        equ     312     ;  and last

; CLASS B

NEXT_LINE               equ   2         ; advance to next line
CONFLICTMES             equ  15         ; Cannot use PRINT - Use NET PRINT
FULLMES                 equ  17         ; PRINT queue is full
NoFils                  equ  18         ; PRINT queue is empty
AccDen                  equ  19         ; Access denied
InvDrvMes               equ  20         ; Invalid drive specification
CNTMES                  equ  21         ; Errors on list device indicate that it
                                        ; may be off-line. Please check it.

; CLASS C

FstMes                  equ  22         ; %1 is currently being printed
SecMes                  equ  23         ; %1 is in queue
BadNameMes              equ  24         ; %1 File not found
NamTMes                 equ  25         ; %1 Pathname too long
BadCanMes               equ  26         ; %1 File not in PRINT queue

; CLASS D

PROMPT                  equ  27         ; Name of list device [PRN]:

DOLLAR                  equ  "$"
Std_Out_Dev             equ  1

;                                       $SALUT (0,41,46,52)

.xlist
.xcref
BREAK                                   MACRO subtitle
                                        SUBTTL subtitle
                                        PAGE
ENDM

SaveReg                                 MACRO reglist ;; push those registers
IRP                                     reg,<reglist>
                                        PUSH reg
ENDM
ENDM
.xcref                                  SaveReg

RestoreReg                              MACRO reglist ;; pop those registers
IRP                                     reg,<reglist>
                                        POP  reg
ENDM
ENDM
;                       $SALUT (4,25,30,41)

                        INCLUDE DEVSYM.INC
                        INCLUDE SYSCALL.INC
                        INCLUDE ERROR.INC
                        INCLUDE FIND.INC
                        include dpl.asm
                        INCLUDE PDB.INC
                        INCLUDE SYSCALL.INC
                        INCLUDE MI.INC
                        INCLUDE SYSMSG.INC
                        include versiona.inc
.list
.cref


                        MSG_UTILNAME <PRINT>


error_busy              EQU  9
error_queue_full        EQU  8
error_name_too_long     EQU  12
get_ea_by_handle equ 2

IF1
                        IF   IBM
;                            %out IBM VERSION
                        ELSE
                            %out MS-DOS VERSION
                        ENDIF
ENDIF

BREAK                   <Segment Definitions>


CodeR                   Segment public para
CodeR                   EndS

Code                    Segment public para
Code                    EndS

Data                    Segment public byte
Data                    EndS

Stack                   Segment Stack
Stack                   Ends

DG                      group Code,Data,Stack


GetDevInfo	equ	4400H
IsDevice?	equ	80H
ACCESS_DENIED 	equ	13H

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\printfix\printfix.inc ===
message db 0DH, 0AH
	db 'The PRINTFIX command prevents MS-DOS from checking', 0DH, 0AH
	db 'the status of your printer. Use this command' , 0Dh, 0Ah
	db 'only if you have had problems printing since', 0DH, 0AH
	db 'you installed MS-DOS 6.', 0DH, 0AH, '$'




=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\print\print_tm.asm ===
page	60,132

;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

;			$SALUT (4,25,30,41)

			INCLUDE pridefs.inc

BREAK			<Transient Messages>

;
;	DOS PRINT
;
;	Transient Service code
;
;	02/13/84	MAU	Fixed bug with BadCanMes
;
;	05/20/87	FJG	Change format to new Message Service
;				Routines/Parse code
;


addr			macro sym,name
			public name
			ifidn <name>,<>

			    dw	 offset dg:sym
			else

name			    dw	 offset dg:sym
			endif
			endm


			Code Segment public para

			PUBLIC SYSGETMSG, SYSLOADMSG, SYSDISPMSG

			ASSUME CS:DG,DS:nothing,ES:nothing,SS:Stack

; include msgserv.asm

			.xlist
			.xcref
			MSG_SERVICES <MSGDATA>
			MSG_SERVICES <NEARmsg,LOADmsg,GETmsg,DISPLAYmsg,INPUTmsg,CHARmsg>
			.cref
			.list

; include message class 1, 2, A, B, C, and D

			.xlist
			.xcref
			MSG_SERVICES <NEARmsg,PRINT.CL1,PRINT.CL2>
			MSG_SERVICES <NEARmsg,PRINT.CLA,PRINT.CLB,PRINT.CLC,PRINT.CLD>
			.cref
			.list
;  $SALUT (4,4,9,41)


;			$SALUT (4,25,30,41)
false			=    0

DateSW			equ  false
TimeSW			equ  false
CmpxSW			equ  false
KeySW			equ  false
QusSW			equ  false
Val2SW			equ  false
Val3SW			equ  false

;  $SALUT (4,4,9,41)

   PUBLIC SYSPARSE

					; include parse.asm

					;xlist
					;xcref
   include parse.asm
					;cref
					;list

   CODE ENDS

   end

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\recover\pathmac.inc ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */


;***********************************************************************
; NAME: pathlabl
; DESC: creates a public label at the spot it is placed, using the name
;       given.
; INPUT: either module name or procedure name
; OUTPUT: public label
; LOGIC: if masm is in pass1 (pass2 will gen dup labels)
;           if this label has not been gen before
;              then create the label
;                   - $$A to place at begin of map
;                   - start means first occurence
;                   - use module/proc name last
;                   define this label for creation of 'stop' label
;              else create stop label
;                   - same as start except name
;***********************************************************************
.LALL
pathlabl MACRO pnam
IF1                                     ;if pass 1
    IFNDEF LBL_&pnam                    ;switch not defined if first creation
        $$A_START_&pnam:                ;create label
        PUBLIC $$A_START_&pnam          ;make it public
        LBL_&pnam = 1                   ;set switch
    ELSE                                ;start label already created
        $$A_STOP_&pnam:                 ;create stop label
        PUBLIC $$A_STOP_&pnam           ;make it public
    ENDIF
ENDIF
ENDM


=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\recover\recdisp.asm ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

;
page	,132				; ;AN000;bgb
;;*****************************************************************************
; Include files
;*****************************************************************************
;
.xlist
	include pathmac.inc							;an028;bgb
	include recseg.inc		;AN000;bgb
	include dossym.inc
	INCLUDE SYSMSG.INC
	INCLUDE RECEQU.INC
	INCLUDE RECMSG.INC
.list
;
;*****************************************************************************
; external data
;*****************************************************************************
data	segment public para 'DATA'      ;AC000;bgb
	EXTRN	command_line_buffer:byte					;an031;bgb
	extrn	DrvLet1:Byte		;AN000;bgb
	extrn	DrvLet:Byte	       ;AN000;bgb
	extrn	rec_num:word	       ;AN000;bgb
	Extrn	Drive_Letter_Msg:Byte	;AN000;BGB
	extrn	fname_buffer:byte	;AN000;BGB
	EXTRN	x_value_lo:WORD 	;AN000;bgb	   ; AC000;SM
	EXTRN	x_value_hi:WORD 	;AN000;bgb	   ; AC000;SM
	EXTRN	y_value_lo:WORD 	;AN000;bgb	   ; AC000;SM
	EXTRN	y_value_hi:WORD 	;AN000;bgb	   ; AC000;SM
	extrn	DriveLetter:Byte

	inflag		db	0
;*****************************************************************************
; Message Services
;*****************************************************************************
.xlist
MSG_UTILNAME  <RECOVER>
Msg_Services	<MSGDATA>
Msg_Services	<INPUTmsg>
data	ends


;
;***************************************************************************
; Message Structures
;***************************************************************************
;
code	segment PUBLIC para 'CODE'
Message_Table struc				;				;AN000;
						;
Entry1	dw	0				;				;AN000;
Entry2	dw	0				;				;AN000;
Entry3	dw	0				;				;AN000;
Entry4	dw	0				;				;AN000;
Entry5	db	0				;				;AN000;
Entry6	db	0				;				;AN000;
Entry7	dw	0				;				;AN000;
Message_Table ends				;				;AN000;

pathlabl	msgret								;an028;bgb
Msg_Services	<NEARmsg>
Msg_Services	<LOADmsg>
Msg_Services	<DISPLAYmsg,CHARmsg,NUMmsg>					;an029;bgb
pathlabl	msgret								;an028;bgb
Msg_Services	<RECOVER.CLA,RECOVER.CL1,RECOVER.CL2,RECOVER.CTL>
.list
;
;*****************************************************************************
; Public Routines
;*****************************************************************************
	Public	SysDispMsg
	Public	SysLoadMsg
	Public	Display_Interface

;*****************************************************************************
;Routine name&gml Display_Interface
;*****************************************************************************
;
;DescriptioN&gml Save all registers, set up registers required for SysDispMsg
;	      routine. This information is contained in a message description
;	      table pointed to by the DX register. Call SysDispMsg, then
;	      restore registers. This routine assumes that the only time an
;	      error will be returned is if an extended error message was
;	      requested, so it will ignore error returns
;
;Called Procedures: Message (macro)
;
;Change History&gml Created	   4/22/87	   MT
;
; More change history:  this routine, until 6/90, had no means of displaying
; messages which would generate & need to return a response.  (E.g. the one
; I added, in case the user specifies *.*, which says "are you sure" and wants
; a y/n response.)  Since I can't find the code for the macro which builds the
; data structures which get passed to sysdispmsg, I can't verify that a word
; actually gets reserved and pointed by di for those msgs which expect no
; responses.  Thus it might be harmful to assume that upon return from
; sysdispmsg, you can always put the value from AX into [di] (which would be
; the thing to do if you actually expected a response, and would also be
; harmless to do if not but if we knew di pointed at some unimportant place).
; Since we don't, the system I use is to check the message number - if it
; is greater than MIN_INPUT_VAL (currently 400), put ax into [di] when you
; come back from sysdispmsg.  THIS MEANS THAT ANY NEW INPUT MESSAGES SHOULD
; BE NUMBERED GREATER THAN 400 IN THE .SKL FILES AND IN USA_MS.MSG AND NO
; NON-INPUT MSGS SHOULD BE !!!!!    LeaF, June 1990
;
;Input&gml ES&gmlDX = pointer to message description
;
;Output&gml None
;
;Psuedocode
;----------
;
;	Save all registers
;	Setup registers for SysDispMsg from Message Description Tables
;	CALL SysDispMsg
;	Restore registers
;	ret
;*****************************************************************************

Display_Interface   proc			;				;AN000;

	 push	 ds				 ;				 ;AN000;
	 push	 ax				 ;Save registers		 ;AN000;
	 push	 bx				 ; "  "    "  "                  ;AN000;
	 push	 cx				 ; "  "    "  "                  ;AN000;
	 push	 dx				 ; "  "    "  "                  ;AN000;
	 push	 si				 ; "  "    "  "                  ;AN000;
	 push	 di				 ; "  "    "  "                  ;AN000;
	 mov	 di,dx				 ;Change pointer to table	 ;AN000;
	 mov	 dx,DG				 ;Point to data segment
	 mov	 ds,dx				 ;
	 mov	 ax,[di].Entry1 		 ;Message number		 ;AN000;
	 cmp	 ax, MIN_INPUT_VAL
	 jl	 skip
	 mov	 inflag, 1
skip:	 mov	 bx,[di].Entry2 		 ;Handle			 ;AN000;
	 mov	 si,[di].Entry3 		 ;Sublist			 ;AN000;
	 mov	 cx,[di].Entry4 		 ;Count 			 ;AN000;
	 mov	 dh,[di].Entry5 		 ;Class 			 ;AN000;
	 mov	 dl,[di].Entry6 		 ;Function			 ;AN000;
	 mov	 di,[di].Entry7 		 ;Input 			 ;AN000;
	 call	 SysDispMsg			 ;Display the message		 ;AN000;
	 cmp	 inflag, 1
	 jne 	 skip2
	 mov	 word ptr [di], ax               ; SAVE RETURN VALUE !  leaf
skip2:	 pop	 di				 ;Restore registers		 ;AN000;
	 pop	 si				 ; "  "    "  "                  ;AN000;
	 pop	 dx				 ; "  "    "  "                  ;AN000;
	 pop	 cx				 ; "  "    "  "                  ;AN000;
	 pop	 bx				 ; "  "    "  "                  ;AN000;
	 pop	 ax				 ; "  "    "  "                  ;AN000;
	 pop	 ds				 ;				 ;AN000;
	 ret					 ;All done			 ;AN000;
Display_Interface      endp			;				;AN000;

include msgdcl.inc

code	ends
	end


;code	 segment public PARA 'CODE'      ;AC000;bgb
;code	 ends
;
;const	 segment public para		 ;AC000;bgb
;const	 ends
;
;cstack  segment stack word 'stack'
;cstack  ends
;
;
;data	 segment public para 'DATA'      ;AC000;bgb
;data	 ends
;
;dg	 group	 code,const,data,cstack
;
;code	 segment public para 'code'      ;AC000;bgb
;code	 ends
;	 assume  cs:dg,ds:dg,es:dg,ss:cstack
;
;
;;;;;;;;;;code	  segment PUBLIC para 'CODE'
;;;;;;;;;;;;;code    ends
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\printfix\printfix.asm ===
;=============================================================================
;
; Program: PRINTFIX.COM 
;  Author: Doug Olson (DougO)
;    Date: 08/30/91
;
; Purpose: This TSR hooks BIOS interrupt 17h and installs an ISR that resets
;          bit 3 of the status byte returned in register AH from the BIOS
;          int 17 handler.  When bit 3 of the status byte is set, this 
;          indicates an I/O error on the parallel printer interface port.
;          The purpose of resetting bit 3 is to avoid MS-DOS 5.x from
;          reporting a write fault error.
;
; History: MS-DOS 5 checks the status bit 3 when printing to a parallel port.
;          Some systems, for uncertain reasons, return this bit set indicating
;          an I/O error when in fact there is nothing wrong that prevents
;          printing.  When these systems were upgraded to MS-DOS 5, printing
;          to the parallel device resulted in write faults.
;
;   Usage: This TSR should only be installed on systems that exhibit the
;          I/O error problem.  
;
;=============================================================================

code_seg        segment                 ; begin segment
        assume  cs:code_seg
begin:
        org     100h                    ; start at offset 100h

start:  jmp     short init_code         ; jump to initialization code

old_int_17      label   word            ; address of the old interrupt 
old_int_17_addr dd      ?               ; 17h handler

patch   proc    near                    ; ISR entry point
        pushf                           ; push flags
        cmp     ah,02h                  ; is it the Get Printer Status func?
        jne     call_old                ; branch if not
        mov     ah,90h                  ; set bit 4 (printer selected) and
        popf                            ;     bit 7 (printer not busy)
        iret
call_old:
        popf                            ; get the old flags back
        pushf                           ; push flags for interrupt
        call    [old_int_17_addr]       ; call old interrupt 17 handler
        iret                            ; return from interrupt
patch   endp                            ; end of resident portion

init_code       proc    near            ; begin initialization code
        mov     ah,09h                  ; display string function
        mov     dx, offset message      ; get offset of message
        int     21h                     ; print the message
        mov     ax,3517h                ; get interrupt vector (17h)
        int     21h                     ; call DOS service
        mov     old_int_17,bx           ; save address of old interrupt
        mov     old_int_17[2],es        ; 17 handler at old_int_17  
        mov     ax,2517h                ; set interrupt vector
        lea     dx,patch                ; offset of ISR
        int     21h                     ; call DOS service
        mov     dx, (((offset init_code-offset begin)+15)/16) ; Get size
        mov     ah,31h                  ; terminate and stay resident
        int     21h                     ; call DOS service
init_code       endp

        include printfix.inc

        code_seg        ends            ; end segment

        end     start                   ; the end



=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\recover\recchng.inc ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

.xlist
;
;
;REV 1.0
;	
;REV 1.5
;	Added header message ARR
;REV	EKE  9/8/83
;	added code for 2.X, it now quits if trying to recover over a net
;REV	EKE  10/13/83
;	Fixed current directory saving.
;REV	NP   10/17/83
;	Use printf for messages.
;	And now it's an .EXE file.
;REV 2.0
;	MZ  11/1/83
;	Commented the source
;	Used symbols from DOSSYM
;	Fixed for 16-bit fats.
;
;*****************************************************************************
;*									     *
;* Change list to RECOVER modules					     *
;*									     *
;* Lines are tagged ANxxx for new, ACxxx for changed			     *
;* --------------------------------------------------------------------------*
;*  000 - DOS 4.00 Spec additions and DCR's thru unit/function test           *
;*	   Date: 8/3/87    
;* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *
;*  001 - DOS 4.00 PTM P265 - Give 'Can't chkdsk subst drive" when running    *
;*	  hardfile. Using 1 based drive insted of 0			     *
;*	  Date: 8/17/87    
;* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *
;*  002 - DOS 4.00 PTM P251 - Hang when chkdsk default drive. Not setting up  *
;*	  drive fields correctly on default drive			     *
;*	  Date: 8/14/87    
;* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *
;*									     *
;*									     *
;*									     *
;* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *
;*									     *
;* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *
;* 005 - DOS 4.00 DCR D166 - Enable 128k FAT				     *
;*	 Date: 8/21/87	   
;* procedures changed - calc_fat_addr, readft, wrtft, getfat, setfat, fillfat*
;*	read_disk, read_once, write_disk, write_once, read_file, drive_spec  *
;* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *
;* 006 - DOS 4.00 ptm p??? - msg when disk full				     *
;*	 Date: 8/21/87	   
;* procedures changed - main_loop1					     *
;* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *
;* 007 - DOS 4.00 ptm p1682- redirection to file not working		     *
;*	 Date: 10/14/87    
;* procedures changed - recmsg.inc					     *
;* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *
;* 008 - DOS 4.00 ptm p1845- changes current drive			     *
;*	 Date: 10/20/87    
;* procedures changed - recover.sal					     *
;* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *
;* 009 - DOS 4.00 ptm p1850- a:recover c: --> 'insert diskette for drive b'   *
;*	 Date: 10/21/87    
;* procedures changed - recinit.sal					     *
;* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *
;* 010 - DOS 4.00 ptm p1934- no msg displayed for 'recover a:'                *
;*	 Date: 10/22/87    
;* procedures changed - recover.sal, recproc.sal			     *
;* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *
;* 011 - DOS 4.00 ptm p2020- recover doesnt exec 			     *
;*	 Date: 10/25/87    
;* procedures changed - recexec.sal					     *
;* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *
;* 012 - DOS 4.00 ptm p2224 & p2230 - dbcs handling			     *
;*	 Date: 11/02/87    
;* procedures changed - recover.sal, recdbcs.sal			     *
;* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *
;* 013 - DOS 4.00 ptm p2264  -  no low memory error checking		     *
;*	 Date: 11/04/87    
;* procedures changed - recover.sal					     *
;* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *
;* 014 - DOS 4.00 ptm p2650  -  doesnt handle c:\file.nam		     *
;*	 Date: 11/24/87    
;* procedures changed - recover.sal					     *
;* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *
;* 015 - DOS 4.00 ptm p2702,2730  -  doesnt report not writing to fat	     *
;*	 Date: 11/30/87    
;* procedures changed - recover.sal					     *
;* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *
;* 016 - DOS 4.00 ptm p2868 - recover files gone 			     *
;*	 Date: 12/10/87    
;* procedures changed - none - recproc.sal was not exported on 10-22-87      *
;* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *
;* 017 - DOS 4.00 ptm p3013 - ADD CHECK for carry after name translate	     *
;*	 Date: 12/29/87    
;* procedures changed - recinit.sal					     *
;* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *
;* 018 - DOS 4.00 ptm p2991 - problem with space after drive letter	     *
;*	 Date: 12/29/87    
;* procedures changed - recover.sal					     *
;* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *
;* 019 - DOS 4.00 ptm p3029 - doesn't handle subdirs                          *
;*	 Date:	1/05/88    
;* procedures changed - recover.sal					     *
;* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *
;* 020 - DOS 4.00 ptm p3042 -						     *
;*	 Date:	1/06/88    
;* procedures changed - recover.sal					     *
;* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *
;* 021 - DOS 4.00 ptm p3138 - file not found if a:\filename		     *
;*	 Date:	1/22/88    
;* procedures changed - recover.sal					     *
;* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *
;* 022 - DOS 4.00 ptm p3130 - remove AFS 				     *
;*	 Date:	1/25/88    
;* procedures changed - recexec.sal, recover.mak, recover.arf, recover.skl   *
;*		      - recmsg.inc, recequ.inc, recdata.inc, recinit.sal     *
;* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *
;* 023 - DOS 4.00 ptm p3136 - cannot write fat on hard file		     *
;*	 Date:	1/25/88    
;* procedures changed - recproc.sal					     *
;* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *
;* 024 - DOS 4.00 ptm p3160 - cannot handle '\' as dbcs second  byte          *
;*	 Date:	1/25/88    
;* procedures changed - recover.sal, recdata.inc			     *
;* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *
;* 025 - DOS 4.00 ptm p3280 - include basesw for parser			     *
;*	 Date:	1/29/88    
;* procedures changed - recparse.inc					     *
;* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *
;* 026 - DOS 4.00 ptm p3360 - handle control-break			     *
;*	 Date:	2/04/88    
;* procedures changed - recover.sal					     *
;* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *
;* 027 - DOS 4.00 ptm p3471 - recover drive on >32M			     *
;*	 Date:	2/17/88    
;* procedures changed - recover.sal					     *
;* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *
;* 028 - DOS 4.00 ptm p3573 - make changes for pathgen of parser and msg ret  *
;*	 Date:	2/19/88    
;* procedures changed - recparse.inc, recdisp.asm			     *
;* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *
;* 029 - DOS 4.00 ptm p3631 - correct changes made for pathgen of msg ret     *
;*	 Date:	2/26/88    
;* procedures changed - recdisp.asm					     *
;* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *
;* 030 - DOS 4.00 dcr d490  - make get/set media id same as os/2 1.0	     *
;*	 Date:	2/26/88    
;* procedures changed - recinit.sal					     *
;* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *
;* 031 - DOS 4.00 PTM P3923 - DISPLAY INVALID PARMS			     *
;*	 Date:	3/23/88    
;* procedures changed - recinit.sal, recmsg.inc 			     *
;* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *
;* 032 - DOS 4.00 PTM P4387 - remove sf_extclus from source		     *
;*	 Date:	4/18/88    
;* procedures changed - recover.sal					     *
;* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *
;*									     *
;*****************************************************************************
;* Note: This is file CHKCHNG.INC for updating purposes 		     *
;*****************************************************************************
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\print\print_t.asm ===
page   80,132
	TITLE 4.00 PRINT  TRANSIENT

;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

;                       $SALUT (4,25,30,41)
			INCLUDE pridefs.inc

SaveReg                 MACRO reglist   ;; push those registers
IRP                     reg,<reglist>
			PUSH reg
ENDM
ENDM

RestoreReg              MACRO reglist   ;; pop those registers
IRP                     reg,<reglist>
			POP  reg
ENDM
ENDM

BREAK                   <Transient Portion>
;******************* START OF SPECIFICATIONS ***********************************
;
; MODULE NAME:          PRINT_T.SAL
;
; DESCRIPTIVE NAME:     TRANSIENT  -  Print Initialization and Instalation
;                       Routine.   DOS PRINT program for background printing
;                       of   text files to the list device - Transient Portion.
;
;  FUNCTION:    - Call the DOS PARSE Service Routines to process the command
;                 line. Search for valid input:
;                        - filenames (may be more than one
;                        - switches: /D:device
;                                    /B:buffsize  512 to 16k - 512 default
;                                    /Q:quesiz      4 to 32  -  10 default
;                                    /S:timeslice   1 to 255 -   8 default
;                                    /U:busytick    1 to 255 -   1 default
;                                    /M:maxtick     1 to 255 -   2 default
;                                    /T    terminate
;                                    /C    cancel
;                                    /P    print
;                                    /?    print out help message
;               - Install the resident component if not already installed
;               - Submit files for printing to the resident component
;
;  INPUT:       Parameter string from command line in the PSP
;
;  OUTPUT:      All parameters specified are updated. Files are submitted to
;               the resident component for printing.
;
;  REGISTERS USED: T.B.D.
;  (NOT RESTORED)
;
;  LINKAGE:     LINK - TRANSIENT
;
;  NORMAL       -
;  EXIT:
;
;  ERROR        -
;  EXIT:
;
;  EXTERNAL     -
;  REFERENCES:
;
;  CHANGE       03/11/87 - Major restructureing of TRANSIENT - F. G.
;  LOG:
;
;******************* END OF SPECIFICATIONS *************************************
;******************** START - PSEUDOCODE ***************************************
;
;       START  TRANSIENT
;
;       If pdb_environ != 0
;               deallocate memory
;       endif
;       call SYSLOADMSG
;       if no error (if there is - SYSLOADMSG is already set to
;                               display it - ie DOS ver error
;               if not installed
;                       call Load_R_Msg
;                       if no error
;                               get all interupt values
;                       else
;                               load error message #
;                               set error flag
;                       endif
;               else
;                       if PSPRINT conflict
;                               load error message #
;                               set error flag
;                       endif
;               endif
;       endif
;       if no error and
;       get and set INT 24 handler
;       update path character
;       Set up for Parse_Input call
;       Do
;       Leave if end of command line
;       Leave if error flag set
;               call parse_input
;               if carry set
;                       set up for Invalid_parm message
;               endif
;       Leave if error flag set
;               update Parse_C_B
;               if file_name
;                       call Submit_Name
;               endif
;               if switch
;                       Do_case switch
;                               Bgncase_/D
;                                       if valid value and not installed
;                                               move device name to LISTNAME
;                                               reset carry
;                                       else
;                                               set carry
;                                       endif
;                               Endcase_/D
;                               Bgncase_/B
;                                       if valid value and not installed
;                                               update BLKSIZ
;                                               reset carry
;                                       else
;                                               set carry
;                                       endif
;                               Endcase_/B
;                               Bgncase_/Q
;                                       if valid value and not installed
;                                               update BLKSIZ
;                                               reset carry
;                                       else
;                                               set carry
;                                       endif
;                               Endcase_/Q
;                               Bgncase_/S
;                                       if valid value and not installed
;                                               update TIMESLICE, SLICECNT
;                                               reset carry
;                                       else
;                                               set carry
;                                       endif
;                               Endcase_/S
;                               Bgncase_/U
;                                       if valid value and not installed
;                                               update BUSYTICK
;                                               reset carry
;                                       else
;                                               set carry
;                                       endif
;                               Endcase_/U
;                               Bgncase_/M
;                                       if valid value and not installed
;                                               update MAXTICK
;                                               reset carry
;                                       else
;                                               set carry
;                                       endif
;                               Endcase_/M
;                               Bgncase_/T
;                                       if installed
;                                               set up for cancel
;                                               call IntWhileBusy
;                                       endif
;                                       call Set_Buffer
;                                       reset carry
;                               Endcase_/T
;                               Bgncase_/C
;                                       if installed
;                                               set CanFlag
;                                       else
;                                               call Set_Buffer
;                                       endif
;                                       reset carry
;                               Endcase_/C
;                               Bgncase_/P
;                                       if installed
;                                               reset CanFlag
;                                       else
;                                               call Set_Buffer
;                                       endif
;                                       reset carry
;                               Endcase_/P
;                       end_case
;                       if carry set
;                               set up for Invalid_parm message
;                       endif
;               endif
;       enddo
;       if no error
;               if not installed
;                       call Set_Buffer
;               else
;                       get queue pointer
;                       check for off line
;                       display queue
;               endif
;       else
;               call DispMsg  (display the fatal error)
;       endif
;
;       return
;
;       END  TRANSIENT
;
;==================== END - PSEUDOCODE =========================================

CodeR                   Segment public para

			extrn SliceCnt:BYTE, BusyTick:BYTE, MaxTick:BYTE, TimeSlice:BYTE
			extrn EndRes:WORD, BlkSiz:WORD, QueueLen:BYTE, PChar:BYTE
			extrn ListName:BYTE, FileQueue:BYTE, EndQueue:WORD, Buffer:WORD
			extrn EndPtr:WORD, NxtChr:WORD, MoveTrans:FAR, TO_DOS:FAR

			extrn MESBAS:WORD, R_MES_BUFF:WORD

CodeR                   EndS


			BREAK <Transient Data>

;----------------------------------------
; Transient data
;----------------------------------------

DATA                    SEGMENT public BYTE



			public namebuf

			ORG  0

SWITCHAR                DB   ?
PathChar                db   "\"

SubPack                 db   0          ; Level
			dd   ?          ; pointer to filename

;--- Ints used by print. These ints are loaded here before the
; resident is installed, just in case an error before print
; is installed cases it to be never installed and the ints
; have to be restored.

i28vec                  dd   ?          ; SOFTINT
i2fvec                  dd   ?          ; COMINT
i05vec                  dd   ?
i13vec                  dd   ?
i14vec                  dd   ?
i15vec                  dd   ?
i17vec                  dd   ?
i1cvec                  dd   ?          ; INTLOC

;--- Temp stack for use durint int 23 and 24 processing
			db   278 + 80H dup (?) ; 278 == IBM's ROM requirements
intStk                  dw   ?


;--- Print installed flag:
; 0 = Not installed yet: process only configuration parameters
;       during the command line parse
; 1 = Partially installed: process only print commands AND flag
;       configuration parameters as errors AND finish by executing
;       the keep process
; 2 = Already installed: process only print commands AND flag
;       configuration parameters as errors
PInst                   db   0          ; defaults to not installed
CanFlag                 db   0          ; cancel mode flag (0= no cancel)
Ambig                   db   ?          ; =1 if a filename is ambigous
DevSpec                 db   0          ; =1 a device was specified with the
					;  /d option, do not prompt
QFullMes                db   0          ; =1 queue full message issued already
HARDCH                  DD   ?          ;Pointer to real INT 24 handler

TokBuf                  DB   (MaxFileLen+16) dup(?) ; token buffer for input

NulPtr                  dw   ?          ; pointer to the nul in NameBuf
FNamPtr                 dw   ?          ; pointer to name portion of file name
NameBuf                 db   (MaxFileLen+16) dup(?) ; full name buffer for file
					;  plus room for ambigous expansion

whichmsg                dw   (CLASS_C shl 8)+FstMes ; initial message for
					;               file queue loop

SearchBuf               find_buf <>     ; search buffer

appbuf                  db      64  dup (0)
nxtdir                  dw      0
appseg                  dw      0
datseg                  dw      0
triedappend             db      0
dsklet                  db      0

semicolon               equ     ';'
endofline                       equ     0

					;--------------------------------------
					; PARSE Equates
					;--------------------------------------

EOL                     equ  -1         ; Indicator for End-Of-Line
NOERROR                 equ  0          ; Return Indicator for No Errors

DEVICE                  equ  0          ; device
BUFFSIZ                 equ  1          ; buffsiz
QUESIZ                  equ  2          ; quesiz
TIME                    equ  3          ; timeslice
BUSYT                   equ  4          ; busytick
MAXT                    equ  5          ; maxtick
TERM                    equ  6          ; Terminate
CANC                    equ  7          ; Cancel
PRINT                   equ  8          ; Print

file_spec               equ  5          ; Parse Type for file spec found

					;--------------------------------------
					; PARSE Control Block
					;--------------------------------------

ORDINAL                 DW   0          ; Current Parse ordinal value
SCAN_PTR                DW   81h        ; Current Parse location Pointer
MSG_PTR                 DW   81h        ; Last Parse location Pointer

					;--------------------------------------
					;  STRUCTURE TO DEFINE ADDITIONAL
					;       COMMAND LINE PARAMETERS
					;--------------------------------------
PARMS                   LABEL WORD
			DW   OFFSET DG:PARMSX ; POINTER TO PARMS STRUCTURE
			DB   0          ; NO DELIMITER LIST FOLLOWS

					;--------------------------------------
					;  STRUCTURE TO DEFINE SYNTAX
					;--------------------------------------
PARMSX                  LABEL BYTE
			DB   0,1        ; A POSITIONAL PARAMETER IS VALID
			DW   OFFSET DG:POS1 ; POINTER TO POSITIONAL DEFINITION
			DB   10         ; THERE ARE 9 TYPES OF SWITCHES
			DW   OFFSET DG:SW1 ; POINTER TO THE /D:device SWITCH DEFINITION AREA
			DW   OFFSET DG:SW2 ; POINTER TO THE /B:buffsiz SWITCH DEFINITION AREA
			DW   OFFSET DG:SW3 ; POINTER TO THE /Q:quesiz SWITCH DEFINITION AREA
			DW   OFFSET DG:SW4 ; POINTER TO THE /S:timeslice SWITCH DEFINITION AREA
			DW   OFFSET DG:SW5 ; POINTER TO THE /U:busytick SWITCH DEFINITION AREA
			DW   OFFSET DG:SW6 ; POINTER TO THE /M:maxval SWITCH DEFINITION AREA
			DW   OFFSET DG:SW7 ; POINTER TO THE /T  TERMINATE SWITCH DEFINITION AREA
			DW   OFFSET DG:SW8 ; POINTER TO THE /C CANCEL SWITCH DEFINITION AREA
			DW   OFFSET DG:SW9 ; POINTER TO THE /P PRINT SWITCH DEFINITION AREA
			DW   OFFSET DG:SW10 ; POINTER TO /? PRINT SWITCH DEFINITION AREA
			DW   0          ; THERE ARE NO KEYWORDS IN PRINT SYNTAX

					;--------------------------------------
					;
					; NOTE: Do NOT change the layout or size
					;       of the following entries:
					;        --- SW1 through SW9  ---
					;       Their size and position are used
					;       to calculate an index for a
					;       DO_CASE (jump table). This is
					;       possible ONLY if the size of all
					;       9 entries are exactly the same,
					;       congruent, and in this exact
					;       order. Any changes here MUST be
					;       matched in the Process_A_Switch
					;       PROC.
					;
					;       The following formula is used:
					;
					;       Index = (offset P_SYN - offset
					;               SW1) / SW_SIZE
					;
					;--------------------------------------


					;--------------------------------------
					;  STRUCTURE TO DEFINE THE POSITIONAL
					;           PARAMETER (File Name)
					;--------------------------------------
POS1                    LABEL WORD
			DW   0203H      ; OPTIONAL, REPEATABLE FILE SPEC
			DW   0001H      ; CAPS BY FILE TABLE
			DW   OFFSET DG:PARSE_BUFF ; PLACE RESULT IN BUFFER
			DW   OFFSET DG:NOVALS ; NO VALUES LIST REQUIRED
			DB   0          ; NO KEYWORDS

					;--------------------------------------
					; STRUCTURE TO DEFINE /D:device SWITCH
					;--------------------------------------
SW1                     LABEL WORD
			DW   2001H      ; MUST BE PRINT OUTPUT DEVICE
					; (optional simple string)
			DW   1h         ; Caps by file table
			DW   OFFSET DG:PARSE_BUFF ; PLACE RESULT IN BUFFER
			DW   OFFSET DG:NOVALS ; VALUE LIST NOT NECESSARY
			DB   1          ; ONE SWITCH IN FOLLOWING LIST
SW_PTR                  DB   "/D",0     ; /D: INDICATES DEVICE SPECIFIED

SW_SIZE                 equ  $ - SW1
					;--------------------------------------
					; STRUCTURE TO DEFINE /B:buffsiz SWITCH
					;--------------------------------------
SW2                     LABEL WORD
			DW   8001H      ; MUST BE NUMERIC (optional)
			DW   0          ; NO FUNCTION FLAGS
			DW   OFFSET DG:PARSE_BUFF ; PLACE RESULT IN BUFFER
			DW   OFFSET DG:VALUE_BUF ; NEED VALUE LIST FOR buffsiz
			DB   1          ; ONE SWITCH IN FOLLOWING LIST
B_SWITCH                DB   "/B",0     ; /B: INDICATES buffsiz REQUESTED

					;--------------------------------------
					; STRUCTURE TO DEFINE /Q:quesiz SWITCH
					;--------------------------------------
SW3                     LABEL WORD
			DW   8001H      ; MUST BE NUMERIC (optional)
			DW   0          ; NO FUNCTION FLAGS
			DW   OFFSET DG:PARSE_BUFF ; PLACE RESULT IN BUFFER
			DW   OFFSET DG:VALUE_QUE ; NEED VALUE LIST FOR quesiz
			DB   1          ; ONE SWITCH IN FOLLOWING LIST
Q_SWITCH                DB   "/Q",0     ; /Q: INDICATES quesiz REQUESTED

					;--------------------------------------
					; STRUCTURE TO DEFINE /S:timeslice SWITCH
					;--------------------------------------
SW4                     LABEL WORD
			DW   8001H      ; MUST BE NUMERIC (optional)
			DW   0          ; NO FUNCTION FLAGS
			DW   OFFSET DG:PARSE_BUFF ; PLACE RESULT IN BUFFER
			DW   OFFSET DG:VALUE_TIME ; NEED VALUE LIST FOR timeslice
			DB   1          ; ONE SWITCH IN FOLLOWING LIST
S_SWITCH                DB   "/S",0     ; /S: INDICATES timeslice REQUESTED

					;--------------------------------------
					; STRUCTURE TO DEFINE /U:busytick SWITCH
					;--------------------------------------
SW5                     LABEL WORD
			DW   8001H      ; MUST BE NUMERIC (optional)
			DW   0          ; NO FUNCTION FLAGS
			DW   OFFSET DG:PARSE_BUFF ; PLACE RESULT IN BUFFER
			DW   OFFSET DG:VALUE_BUSY ; NEED VALUE LIST FOR busytick
			DB   1          ; ONE SWITCH IN FOLLOWING LIST
U_SWITCH                DB   "/U",0     ; /U: INDICATES busytick REQUESTED

					;--------------------------------------
					; STRUCTURE TO DEFINE /M:maxtick SWITCH
					;--------------------------------------
SW6                     LABEL WORD
			DW   8001H      ; MUST BE NUMERIC (optional)
			DW   0          ; NO FUNCTION FLAGS
			DW   OFFSET DG:PARSE_BUFF ; PLACE RESULT IN BUFFER
			DW   OFFSET DG:VALUE_MAXT ; NEED VALUE LIST FOR maxtick
			DB   1          ; ONE SWITCH IN FOLLOWING LIST
M_SWITCH                DB   "/M",0     ; /M: INDICATES maxtick REQUESTED

					;--------------------------------------
					;  STRUCTURE TO DEFINE /T Terminate SWITCH
					;--------------------------------------
SW7                     LABEL WORD
			DW   8001H      ; SWITCH ONLY
					; (optional simple string)
			DW   0          ; NO FUNCTION FLAGS
			DW   OFFSET DG:PARSE_BUFF ; PLACE RESULT IN BUFFER
			DW   OFFSET DG:NOVALS ; VALUE LIST NOT NECESSARY
			DB   1          ; ONE SWITCH IN FOLLOWING LIST
			DB   "/T",0     ; /T: INDICATES Terminate REQUESTED

					;--------------------------------------
					;  STRUCTURE TO DEFINE /C Cancel SWITCH
					;--------------------------------------
SW8                     LABEL WORD
			DW   8003H      ; SWITCH ONLY
					; (optional, repeatable simple string)
			DW   0          ; NO FUNCTION FLAGS
			DW   OFFSET DG:PARSE_BUFF ; PLACE RESULT IN BUFFER
			DW   OFFSET DG:NOVALS ; VALUE LIST NOT NECESSARY
			DB   1          ; ONE SWITCH IN FOLLOWING LIST
C_SW_ptr                DB   "/C",0     ; /C: INDICATES Cancel REQUESTED

					;--------------------------------------
					;  STRUCTURE TO DEFINE /P Print SWITCH
					;--------------------------------------
SW9                     LABEL WORD
			DW   8003H      ; SWITCH ONLY
					; (optional, repeatable simple string)
			DW   0          ; NO FUNCTION FLAGS
			DW   OFFSET DG:PARSE_BUFF ; PLACE RESULT IN BUFFER
			DW   OFFSET DG:NOVALS ; VALUE LIST NOT NECESSARY
			DB   1          ; ONE SWITCH IN FOLLOWING LIST
P_SW_ptr                DB   "/P",0     ; /P: INDICATES Print REQUESTED


					;--------------------------------------
					;  STRUCTURE TO DEFINE /? Print SWITCH
					;--------------------------------------
SW10                    LABEL WORD
			DW   0
			DW   0          ; NO FUNCTION FLAGS
			DW   OFFSET DG:PARSE_BUFF ; PLACE RESULT IN BUFFER
			DW   OFFSET DG:NOVALS ; VALUE LIST NOT NECESSARY
			DB   1          ; ONE SWITCH IN FOLLOWING LIST
?_SW_ptr                DB   "/?",0     ; /?: INDICATES HELP REQUESTED


					;--------------------------------------
					;  VALUE LIST FOR FILE NAMES
					;--------------------------------------
NOVALS                  LABEL WORD
			DB   0          ; NO VALUES

					;--------------------------------------
					;  VALUE LIST DEFINITION FOR buffsiz
					;--------------------------------------
VALUE_BUF               LABEL BYTE
			DB   1          ; ONE VALUE ALLOWED
			DB   1          ; ONLY ONE RANGE
			DB   BUFFSIZ    ; IDENTIFY IT AS buffsiz
					; USER CAN SPECIFY /+512 THROUGH /+16K
			DD   MinBufferLen,MaxBufferLen

					;--------------------------------------
					;  VALUE LIST DEFINITION FOR quesiz
					;--------------------------------------
VALUE_QUE               LABEL BYTE
			DB   1          ; ONE VALUE ALLOWED
			DB   1          ; ONLY ONE RANGE
			DB   QUESIZ     ; IDENTIFY IT AS quesiz
					; USER CAN SPECIFY /+4 THROUGH /+32
			DD   MinQueueLen,MaxQueueLen

					;--------------------------------------
					;  VALUE LIST DEFINITION FOR timeslice
					;--------------------------------------
VALUE_TIME              LABEL BYTE
			DB   1          ; ONE VALUE ALLOWED
			DB   1          ; ONLY ONE RANGE
			DB   TIME       ; IDENTIFY IT AS timeslice
					; USER CAN SPECIFY /+1 THROUGH /+255
			DD   MinTimeSlice,MaxTimeSlice

					;--------------------------------------
					;  VALUE LIST DEFINITION FOR busytick
					;--------------------------------------
VALUE_BUSY              LABEL BYTE
			DB   1          ; ONE VALUE ALLOWED
			DB   1          ; ONLY ONE RANGE
			DB   BUSYT      ; IDENTIFY IT AS busytick
					; USER CAN SPECIFY /+1 THROUGH /+255
			DD   MinBusyTick,MaxBusyTick

					;--------------------------------------
					;  VALUE LIST DEFINITION FOR maxtick
					;--------------------------------------
VALUE_MAXT              LABEL BYTE
			DB   1          ; ONE VALUE ALLOWED
			DB   1          ; ONLY ONE RANGE
			DB   MAXT       ; IDENTIFY IT AS maxtick
					; USER CAN SPECIFY /+1 THROUGH /+255
			DD   MinMaxTick,MaxMaxTick

					;--------------------------------------
					;  RETURN BUFFER FOR PARSE INFORMATION
					;--------------------------------------
PARSE_BUFF              LABEL BYTE
P_TYPE                  DB   ?          ; TYPE RETURNED
P_ITEM_TAG              DB   ?          ; SPACE FOR ITEM TAG
P_SYN                   DW   ?          ; POINTER TO LIST ENTRY
P_PTR_L                 DW   ?          ; SPACE FOR POINTER / VALUE - LOW
P_PTR_H                 DW   ?          ; SPACE FOR POINTER / VALUE - HIGH

					;----------------------------------------
					; SUBLIST for Message call
					;----------------------------------------

SUBLIST                 LABEL WORD

			DB   sub_size   ; size of sublist
			DB   0          ; reserved
insert_ptr_off          DW   0          ; pointer to insert - offset
insert_ptr_seg          DW   DG         ; pointer to insert - segment
insert_num              DB   0          ; number of insert
			DB   Char_Field_ASCIIZ ; data type flag - ASCII Z string
			DB   MaxFileLen ; maximum field size
			DB   1          ; minimum field size
			DB   " "        ; pad character

sub_size                equ  $ - SUBLIST ; size of sublist


OPEN_FILE               label dword

			dw   offset DG:NameBuf ; name pointer offset
open_seg                dw   ?          ; name pointer segment

DATA                    ENDS

			BREAK <Transient Code>

Code                    Segment public para
Code                    EndS

Code                    Segment public para

			public TransRet,TransSize,GoDispMsg

			extrn SYSLOADMSG:NEAR, SYSGETMSG:NEAR, SYSDISPMSG:NEAR
			extrn SYSPARSE:NEAR

			ASSUME CS:DG,DS:nothing,ES:nothing,SS:Stack

;  $SALUT (4,4,9,41)


TRANSIENT:
					;-------------------------------------
					; Install Print
					;-------------------------------------

   cld
   mov  ax,ds:[pdb_environ]
   or   ax,ax

;  $if  nz                              ; if pdb_environ != 0                  ;AC000;
   JZ $$IF1

       push es                          ; deallocate memory
       mov  es,ax
       mov  ah,dealloc
       int  21h
       pop  es

;  $endif                               ;                                      ;AC000;
$$IF1:

   call SYSLOADMSG                      ; Initialize the Message Service code  ;AN000;

;  $if  c                               ; if error                             ;AC000;
   JNC $$IF3

       mov  ah,dh                       ; set up class for DispMsg

;  $else                                ; else - no error - keep going
   JMP SHORT $$EN3
$$IF3:

       push cs
       pop  ax
       mov  ds,ax
       mov  es,ax

       ASSUME DS:DG,ES:DG
					; NOTE: es must ALWAYS point to DG

       mov  ax,0100h                    ; Ask if already installed
       int  ComInt
       or   al,al

;      $if  z                           ; if not installed                     ;AC000;
       JNZ $$IF5

	   call Load_R_Msg              ;                                      ;AC000;

;          $if  nc                      ; if no error                          ;AC000;
	   JC $$IF6

	       call Save_Vectors        ;                                      ;AC000;

;          $endif                       ; endif - NB: - If carry IS set,       ;AC000;
$$IF6:
					; Load_R_Msg will have loaded the
					; error message #

;      $else                            ;  else - we are installed             ;AC000;
       JMP SHORT $$EN5
$$IF5:

	   cmp  al,1

;          $if  z                       ; if PSPRINT conflict                  ;AC000;
	   JNZ $$IF9

	       mov  ax,(CLASS_B shl 8) + CONFLICTMES ; load error message #    ;AC000;

	       stc                      ; set the error flag                   ;AC000;

;          $else                        ;                                      ;AC000;
	   JMP SHORT $$EN9
$$IF9:

	       mov  [PInst],2           ; remember print already installed
					;          and that we only do one pass
	       mov  al," "              ; invalidate install switches          ;AN005;
	       mov  SW_PTR,al           ; /D                                   ;AN005;
	       mov  B_SWITCH,al         ; /B                                   ;AN005;
	       mov  Q_SWITCH,al         ; /Q                                   ;AN005;
	       mov  S_SWITCH,al         ; /S                                   ;AN005;
	       mov  U_SWITCH,al         ; /U                                   ;AN005;
	       mov  M_SWITCH,al         ; /M                                   ;AN005;
	       clc                      ; reset the error flag                 ;AC000;

;          $endif                       ;                                      ;AC000;
$$EN9:
;      $endif                           ;                                      ;AC000;
$$EN5:
;  $endif                               ;                                      ;AC000;
$$EN3:

;  $if  nc,and                          ; if no errors so far and..............;AC000;
   JC $$IF14

   call GetHInt                         ; save current int 24 vector
   call SetInts                         ; set int 23 and 24 vectors
   mov  ax,CHAR_OPER shl 8
   int  21h
   mov  [SWITCHAR],dl                   ; Get user switch character
   cmp  dl,"-"

;  $if  e                               ; if "-"                               ;AC000;
   JNE $$IF14
       mov  [PathChar],"/"              ; alternate path character
;  $endif                               ;                                      ;AC000;
$$IF14:

					; Set up for Parse_Input call

;  $do                                  ; Do_until end of command line         ;AC000;
$$DO16:

;  $leave c                             ;  quit if an error occured            ;AC000;
   JC $$EN16

       call parse_input                 ;                                      ;AC000;

       mov  [ordinal],cx                ;  update Parse_C_B                    ;AC000;
       mov  [scan_ptr],si               ;                                      ;AC000;

       cmp  al,EOL                      ;  are we at the end?                  ;AC000;

;  $leave e                             ; leave if end of line                 ;AC000;
   JE $$EN16

       cmp  al,noerror                  ;                                      ;AC000;

;      $if  ne                          ;  if error                            ;AC000;
       JE $$IF19

	   mov  ah,Parse_error          ;   set class to Parse error           ;AC000;


	   stc                          ;    set the error flag                ;AC000;

;      $endif                           ;  endif                               ;AC000;
$$IF19:

;  $leave c                             ; leave the loop if error ocurred      ;AC000;
   JC $$EN16

       cmp  [p_type],File_Spec          ;  is it a file spec?                  ;AC000;

;      $if  e                           ;  if it is a file spec                ;AC000;
       JNE $$IF22

	   call Submit_File             ;                                      ;AC000;

;      $else                            ;  else - we must now have a           ;AC000;
       JMP SHORT $$EN22
$$IF22:
					;       valid switch!


					;  Do_case switch

	   push cs                      ;   set up for CASE                    ;AC000;
	   pop  ds                      ;                                      ;AC000;
	   mov  ax,[p_syn]              ;                                      ;AC000;
	   sub  ax,OFFSET DG:SW_PTR     ;                                      ;AC000;
	   mov  dl,SW_SIZE              ;                                      ;AC000;
	   div  dl                      ;                                      ;AC000;
	   cmp  ah,noerror              ;                                      ;AC000;
	   mov  di,ax                   ;                                      ;AC000;
	   mov  ax,(CLASS_B shl 8) + invparm ; set message in case of error    ;AC000;

	   JNE $$IF24
	   call Process_A_Switch        ;                                      ;AC000;
	   JMP SHORT $$EN24
$$IF24:
	   stc                          ; set the error flag                   ;AC000;

$$EN24:

$$EN22:
	   JC $$EN16

;  $enddo                               ; enddo                                ;AC000;
   JMP SHORT $$DO16
$$EN16:

   JNC $$XL1
   JMP short $$IF30
$$XL1:

       cmp  [PInst],0                   ; is print already installed?

;      $if  e                           ; if not installed                     ;AC000;
       JNE $$IF31

	   call Set_Buffer              ; NOTE from now on the TRANSIENT could ;AC000;
					; be in a SEGMENT that is different
					; than the one set up by the loader!
					; *** MOV xx,DG will no longer work ***
					; (use PUSH CS , POP xx instead)

;      $endif                           ; endif  - installed                   ;AC000;
$$IF31:

					; Grab the pointer to the queue and
					;  lock it down.  Remember that since
					;  there are threads in the background,
					;  we may get a busy return.  We sit
					;  here in a spin loop until we can
					;  actually lock the queue.

       mov  ax,0104h                    ; get status
       call IntWhileBusy                ; on return DS:SI points to queue

       ASSUME DS:nothing
					;------------------------------------
					;    check for off-line
					;------------------------------------

       cmp  dx,ErrCnt1                  ; check count

;      $if  ae                          ; if count too high                    ;AC000;
       JNAE $$IF33

	   mov  ax,(CLASS_B shl 8) + CntMes ; printer might be off-line        ;AC000;
	   call DispMsg                 ;                                      ;AC000;

;      $endif                           ; endif - count Too high               ;AC000;
$$IF33:

;                                       ;------------------------------------
;                                       ;    display current queue
;                                       ;        ds:si points to print queue
;                                       ;        ds:di must point to display
;                                       ;                         buffer
;                                       ; xNameTrans will copy the name into
;                                       ;   the name buffer.  It will do
;                                       ;   any name truncation if needed
;                                       ;   (including any DBSC characters)
;                                       ;
;                                       ;------------------------------------
;      mov  di,offset dg:NameBuf        ;                                      ;AN009;
;      mov  ax,(xNameTrans SHL 8)       ; check for name translation           ;AN009;
;      int  21h                         ; get real path and name               ;AN009;

;;;;;;;;;;;;;xxxxxxxxxxxxxxxxx
       call copy_to_arg_buf
;;;;;;;;;;;;;xxxxxxxxxxxxxxxxx

       mov  ax,[whichmsg]               ;                                      ;AN000;
       mov  [whichmsg],(CLASS_C shl 8) + SecMes ; set up in queue msg          ;AC000;
       cmp  byte ptr ds:[si],0          ; is the queue empty?

;      $if  ne                          ; if queue not empty                   ;AC000;
       JE $$IF35

;          $do                          ;                                      ;AC000;
$$DO36:

	       push ds
	       call DispMsg             ;                                      ;AC000;
	       pop  ds
	       add  si,MaxFileLen       ; point to next entry in queue

;;;;;;;;;;;;;xxxxxxxxxxxxxxxxx
	       call copy_to_arg_buf
;;;;;;;;;;;;;xxxxxxxxxxxxxxxxx

;               mov  di,offset dg:NameBuf ;                                     ;AN009;
;               mov  ax,(xNameTrans SHL 8) ; check for name translation         ;AN009;
;               int  21h                 ; get real path and name               ;AN009;
	       mov  ax,[whichmsg]       ;                                      ;AC009;
	       cmp  byte ptr ds:[si],0  ; end of queue?

;          $enddo e                     ;                                      ;AC000;
	   JNE $$DO36

;      $else                            ; else - queue is empty                ;AC000;
       JMP SHORT $$EN35
$$IF35:

	   mov  ax,(CLASS_B shl 8) + NoFils ;                                  ;AC000;
	   call DispMsg                 ;                                      ;AC000;

;      $endif                           ; endif - queue not empty              ;AC000;
$$EN35:

					;------------------------------------
					;    exit transient
					;------------------------------------

       mov  ax,0105H                    ; unlock the print queue
       call IntWhileBusy                ; on return DS:SI points to queue
       cmp  [PInst],1                   ; are we partially installed ?

;      $if  e                           ; if so...  complete the process       ;AC000;
       JNE $$IF40

	   mov  ax,CodeR                ; close Std Devices
	   mov  ds,ax

	   ASSUME DS:CodeR

	   xor  bx,bx
	   mov  cx,5                    ; StdIN,StdOUT,StdERR,StdAUX,StdPRN

;          $do                          ; Close STD handles before keep process;AC000;
$$DO41:

	       mov  ah,CLOSE
	       int  21h
	       inc  bx

;          $enddo loop                  ;                                      ;AC000;
	   LOOP $$DO41


	   mov  dx,[ENDRES]             ; install print...
	   mov  ax,KEEP_PROCESS shl 8   ; Exit code 0

;      $else                            ; else -                               ;AC000;
       JMP SHORT $$EN40
$$IF40:

	   mov  ax,(EXIT shl 8)         ; quit with no error

;      $endif                           ; endif -                              ;AC000;
$$EN40:

;  $else                                ; else - a fatal error occured         ;AC000;
   JMP SHORT $$EN30
$$IF30:
       call DispMsg                     ; display the error message            ;AC000;
       mov  ax,(EXIT shl 8)             ; quit with error
$$EN30:
       int      21h                             ; either EXIT or KEEP_PROCESS

   push es
   xor  ax,ax
   push ax

   foo  proc    far
   ret                                  ; Must use this method, version may be < 2.00
   foo  endp

   BREAK <Process_A_Switch>
;******************* START OF SPECIFICATIONS ***********************************
;
;  NAME:     Process_A_Switch
;
;  FUNCTION: This routine is a DO Case that processes all valid switched for
;            PRINT.
;
;  INPUT:    Jump table offset calculated in the main routine.
;
;  OUTPUT:   Proper processing for the switch
;
;  REGISTERS USED: T.B.D.
;  (NOT RESTORED)
;
;  LINKAGE:     Call from: TRANSIENT
;
;  NORMAL       -
;  EXIT:
;
;  ERROR        -
;  EXIT:
;
;  EXTERNAL     Call to:   DispMsg        Parse_Input       GetAbsN
;  REFERENCES:             IntWhileBusy   GetAbsN2
;
;  CHANGE       04/01/87 - make SWITCH processing a PROC - FJG
;  LOG:
;
;******************* END OF SPECIFICATIONS *************************************
;******************** START - PSEUDOCODE ***************************************
;
;        START Process_A_Switch
;        END Process_A_Switch
;
;******************** END   - PSEUDOCODE ***************************************

   Process_A_Switch PROC NEAR

   shl  di,1                            ;                                      ;AC000;

   jmp  cs:JMPTABLE[di]                 ;                                      ;AC000;

JMPTABLE LABEL WORD                     ;                                      ;AC000;

   DW   CASE_D                          ;                                      ;AN000;
   DW   CASE_B                          ;                                      ;AN000;
   DW   CASE_Q                          ;                                      ;AN000;
   DW   CASE_S                          ;                                      ;AN000;
   DW   CASE_U                          ;                                      ;AN000;
   DW   CASE_M                          ;                                      ;AN000;
   DW   CASE_T                          ;                                      ;AN000;
   DW   CASE_C                          ;                                      ;AN000;
   DW   CASE_P                          ;                                      ;AN000;
   DW   CASE_?

   ASSUME ds:DG,es:DG

CASE_?:
	mov     ax, MSG_OPTIONS_FIRST   ; starting msg nbr
	mov     bx, stdout              ; output handle
	mov     cx, 0                   ; no substitutions
	mov     dh, CLASS_Util          ; message class
	mov     dl, 0                   ; no input wanted
	mov     si, 0                   ; substitution ptr
@@:
	call    SYSDISPMSG
	cmp     ax, MSG_OPTIONS_LAST    ; last msg?
	je      @F                      ;  done if so
	inc     ax                      ; else bump msg nbr
	jmp     short @B                ;  and go do it
@@:

	   mov  ah,EXIT                 ; quit with error
	   xor  al, al
	   int  21h

CASE_D:                                 ; Bgncase_/D                           ;AN000;

   cmp  [PInst],0                       ;                                      ;AC000;

;  $if  e,and                           ;  if not installed                    ;AC000;
   JNE $$IF47

					;   move device name to LISTNAME
   mov  bp,[P_PTR_L]                    ;                                      ;AC000;
   mov  di,bp                           ;  save start address                  ;AC000;
   mov  ax,[P_PTR_H]                    ;                                      ;AC000;
   mov  es,ax                           ;

   ASSUME es:nothing

   xor  al,al                           ; find the length of input name        ;AN000;
   mov  cx,9                            ; it can not be longer than 8 + :      ;AN000;

   ASSUME es:DG                         ; this is a bogus assume to keep the
					;      assembler happy
   repne scas NameBuf                   ; (use NameBuf to tell assembler its   ;AN000;
					; a byte search)
   ASSUME es:nothing                    ; this puts it back right

   dec  di                              ; back up to first null                ;AN000;
   mov  ax,di                           ; pointer to end                       ;AN000;
   sub  ax,bp                           ; subtract start pointer               ;AN000;
   mov  cx,ax                           ; difference is the length             ;AN000;
   or   cx,cx                           ; is it non zero?                      ;AN000;

;  $if  ne                              ; if we have a name                    ;AN000;
   JE $$IF47

       mov  si,di                       ; set DS:SI up to source (Parse Buffer);AN000;
       mov  ax,es                       ; set ES:DI up to LISTNAME (in CodeR)  ;AN000;
       mov  ds,ax                       ;                                      ;AN000;
       mov  ax,CodeR                    ;
       mov  es,ax                       ;

       ASSUME DS:nothing,ES:CodeR

       mov  WORD PTR [LISTNAME],2020h   ; Nul out default
       mov  [LISTNAME+2]," "            ;
       mov  di,OFFSET CodeR:LISTNAME    ;
       dec  si                          ; back up to last character            ;AN004;
       cmp  BYTE PTR [si],':'           ; is there a ':' at the end of the name?

;      $if  e                           ; if it is                             ;AC000;
       JNE $$IF48
	   dec  cx                      ; Chuck the trailing ':'
;      $endif                           ;                                      ;AC000;
$$IF48:

       cmp  cx,8                        ; is the name still longer than 8?

;      $if  a                           ; if it is                             ;AC000;
       JNA $$IF50
	   mov  cx,8                    ; Limit to 8 chars for device
;      $endif                           ;                                      ;AC000;
$$IF50:

       mov  si,bp                       ;                                      ;AC000;
       rep  movsb                       ; move the device name into LISTNAME                                     ;AC000;
       mov  si,bp                       ;
       mov  [DevSpec],1                 ; remember that a device was specified
       clc                              ;   reset carry                        ;AC000;

;  $else                                ;  else                                ;AC000;
   JMP SHORT $$EN47
$$IF47:

       stc                              ;   set carry                          ;AC000;

;  $endif                               ;  endif                               ;AC000;
$$EN47:

   push cs                              ;
   pop  cx                              ;
   mov  ds,cx                           ;
   mov  es,cx                           ;
   mov  al," "                          ; invalidate this switch               ;AN005;
   mov  SW_PTR,al                       ; /D                                   ;AN005;


   JMP  CASE_END                        ; Endcase_/D                           ;AN000;

CASE_B:                                 ; Bgncase_/B                           ;AN000;

   ASSUME ds:DG,es:DG

   cmp  [PInst],0                       ;

;  $if  e                               ;  if not installed                    ;AC000;
   JNE $$IF54

       mov  ax,[P_PTR_L]                ;   get the value                      ;AC000;
       push ds                          ;   update BLKSIZ
       mov  dx,CodeR                    ;
       mov  ds,dx                       ;

       ASSUME DS:CodeR

       mov  [BLKSIZ],ax                 ;
       pop  ds                          ;

       ASSUME DS:DG

       clc                              ;   reset carry                        ;AC000;

;  $else                                ;  else                                ;AC000;
   JMP SHORT $$EN54
$$IF54:

       stc                              ;   set carry                          ;AC000;

;  $endif                               ;  endif                               ;AC000;
$$EN54:

   mov  al," "                          ; invalidate this switch               ;AN005;
   mov  B_SWITCH,al                     ; /B                                   ;AN005;

   JMP  CASE_END                        ; Endcase_/B                           ;AN000;

CASE_Q:                                 ; Bgncase_/Q                           ;AN000;

   cmp  [PInst],0                       ;

;  $if  e                               ;  if not installed                    ;AC000;
   JNE $$IF57

       mov  ax,[P_PTR_L]                ;   get the value                      ;AC000;
       push ds                          ;   update BLKSIZ
       mov  dx,CodeR                    ;
       mov  ds,dx                       ;

       ASSUME DS:CodeR

       mov  [QueueLen],al               ;
       pop  ds                          ;

       ASSUME DS:DG

       clc                              ;   reset carry                        ;AC000;

;  $else                                ;  else                                ;AC000;
   JMP SHORT $$EN57
$$IF57:

       stc                              ;   set carry                          ;AC000;

;  $endif                               ;  endif                               ;AC000;
$$EN57:

   mov  al," "                          ; invalidate this switch               ;AN005;
   mov  Q_SWITCH,al                     ; /Q                                   ;AN005;

   JMP  CASE_END                        ; Endcase_/Q                           ;AN000;

CASE_S:                                 ; Bgncase_/S                           ;AN000;

   cmp  [PInst],0                       ;

;  $if  e                               ;  if not installed                    ;AC000;
   JNE $$IF60

       mov  ax,[P_PTR_L]                ;   get the value                      ;AC000;
       push ds                          ;   update TIMESLICE, SLICECNT
       mov  dx,CodeR                    ;
       mov  ds,dx                       ;

       ASSUME ds:CodeR

       mov  [TIMESLICE],al              ;
       mov  [SLICECNT],al               ;
       pop  ds                          ;

       ASSUME ds:DG

       clc                              ;   reset carry                        ;AC000;

;  $else                                ;  else                                ;AC000;
   JMP SHORT $$EN60
$$IF60:

       stc                              ;   set carry                          ;AC000;

;  $endif                               ;  endif                               ;AC000;
$$EN60:

   mov  al," "                          ; invalidate this switch               ;AN005;
   mov  S_SWITCH,al                     ; /S                                   ;AN005;

   JMP  short CASE_END                  ; Endcase_/S                           ;AN000;

CASE_U:                                 ; Bgncase_/U                           ;AN000;

   cmp  [PInst],0                       ;

;  $if  e                               ;  if not installed                    ;AC000;
   JNE $$IF63

       mov  ax,[P_PTR_L]                ;   get the value                      ;AC000;
       push ds                          ;   update BUSYTICK
       mov  dx,CodeR                    ;
       mov  ds,dx                       ;

       ASSUME ds:CodeR

       mov  [BUSYTICK],al               ;
       pop  ds                          ;

       ASSUME ds:DG

       clc                              ;   reset carry                        ;AC000;

;  $else                                ;  else                                ;AC000;
   JMP SHORT $$EN63
$$IF63:

       stc                              ;   set carry                          ;AC000;

;  $endif                               ;  endif                               ;AC000;
$$EN63:

   mov  al," "                          ; invalidate this switch               ;AN005;
   mov  U_SWITCH,al                     ; /U                                   ;AN005;

   JMP  short CASE_END                  ; Endcase_/U                           ;AN000;

CASE_M:                                 ; Bgncase_/M                           ;AN000;

   cmp  [PInst],0                       ;

;  $if  e                               ;  if not installed                    ;AC000;
   JNE $$IF66

       mov  ax,[P_PTR_L]                ;   get the value                      ;AC000;
       push ds                          ;   update MAXTICK
       mov  dx,CodeR                    ;
       mov  ds,dx                       ;

       ASSUME ds:CodeR

       mov  [MAXTICK],al                ;
       pop  ds                          ;

       ASSUME ds:DG

       clc                              ;   reset carry                        ;AC000;

;  $else                                ;  else                                ;AC000;
   JMP SHORT $$EN66
$$IF66:

       stc                              ;   set carry                          ;AC000;

;  $endif                               ;  endif                               ;AC000;
$$EN66:

   mov  al," "                          ; invalidate this switch               ;AN005;
   mov  M_SWITCH,al                     ; /M                                   ;AN005;

   JMP  short CASE_END                  ; Endcase_/M                           ;AN000;

CASE_T:                                 ; Bgncase_/T                           ;AN000;

   push si                              ;   save parse pointer

   cmp  [PInst],0                       ;  has print been installed?

;  $if  e                               ;  if not installed                    ;AC000;
   JNE $$IF69

       call Set_Buffer                  ;  do it now                           ;AC000;

;  $endif                               ;  endif                               ;AC000;
$$IF69:
					;   set up for cancel
   mov  ax,0103H                        ;   cancel command

   call IntWhileBusy                    ;

   pop  si                              ;   restore parse pointer

   clc                                  ;  reset carry                         ;AC000;

   JMP  short CASE_END                  ; Endcase_/T                           ;AN000;

CASE_C:                                 ; Bgncase_/C                           ;AN000;

   cmp  [PInst],0                       ;  has print been installed?

;  $if  ne                              ;  if installed                        ;AC000;
   JE $$IF71

       mov  [CanFlag],1                 ;   set CanFlag

;  $else                                ;  else                                ;AC000;
   JMP SHORT $$EN71
$$IF71:

       call Set_Buffer                  ;                                      ;AC000;

;  $endif                               ;  endif                               ;AC000;
$$EN71:

   clc                                  ;  reset carry                         ;AC000;

   JMP  short CASE_END                  ; Endcase_/C                           ;AN000;

CASE_P:                                 ; Bgncase_/P                           ;AN000;

   cmp  [PInst],0                       ;  has print been installed?

;  $if  ne                              ;  if installed                        ;AC000;
   JE $$IF74

       mov  [CanFlag],0                 ;   reset CanFlag

;  $else                                ;  else                                ;AC000;
   JMP SHORT $$EN74
$$IF74:

       call Set_Buffer                  ;                                      ;AC000;

;  $endif                               ;  endif                               ;AC000;
$$EN74:

   clc                                  ;  reset carry                         ;AC000;

					; Endcase_/P

CASE_END:                               ; End_case                             ;AN000;

;  $if  c                               ; if carry set                         ;AC000;
   JNC $$IF77

       mov  ax,(Parse_error shl 8) + INVPARM ; set up for Invalid_parm message ;AN000:

       cmp  [PInst],0                   ;  has print been installed?

;      $if  ne                          ;  if installed                        ;AN005;
       JE $$IF78

	   call DispMsg                 ;  display the message and keep going  ;AN005;

;      $endif                           ;  endif                               ;AN005;
$$IF78:

;  $endif                               ; endif                                ;AC000;
$$IF77:

   ret

   Process_A_Switch ENDP

   BREAK <Submit_File>
;******************* START OF SPECIFICATIONS ***********************************
;
;  NAME:        Submit_File -  PRINT TRANSIENT to Resident Interface Routine
;
;  FUNCTION:    Resolved ambiguous file names (containing ? and *) and submits
;               the file to the Resident component of PRINT for printing.
;
;  INPUT:       File name in Parse buffer
;
;  OUTPUT:      None.
;
;  NOTE:        This code is primarily old code, but it has been completely
;               restructured and SALUTed.
;
;  REGISTERS USED: T.B.D.
;  (NOT RESTORED)
;
;  LINKAGE:     Call from: TRANSIENT
;
;  NORMAL       -
;  EXIT:
;
;  ERROR        -
;  EXIT:
;
;  EXTERNAL     Call to:   DispMsg        Parse_Input       GetAbsN
;  REFERENCES:             IntWhileBusy   GetAbsN2
;
;  CHANGE       04/01/87 - change PaFile to Submit_File   - F. G.
;  LOG:
;
;******************* END OF SPECIFICATIONS *************************************
;******************** START - PSEUDOCODE ***************************************
;
;        START
;        .
;        .
;        .
;        .
;        .
;
; INPUT: CanFlag and Ambig set appropriately
;
;       if CanFlag
;               set up cancel
;               call IntWhileBusy
;               if error
;                       process the error
;               endif
;       else
;               if Ambig and
;
;               call getabsn
;
;               if error
;                       load error message
;                       call DispMsg
;               else
;                       do (until not Ambig)
;                               call open_file
;                               if error
;                                       do error handling
;                               else
;                                       close file
;                                       submit packet
;                                       if error
;                                               set up message
;                                       endif
;                               endif
;                               if error
;                                       call Dispmsg
;                               endif
;                       leave if error
;                               if Ambig
;                                       call Absn2 (will set fail if at end)
;                               else
;                                       set fail
;                               endif
;                       enddo on fail
;                       if no message
;                               reset fail
;                       endif
;               endif
;       endif
;       .
;       .
;       .
;       if error message
;               call DispMsg
;       endif
;
;       ret
;
;       END
;
;******************** END   - PSEUDOCODE ***************************************

   Submit_File PROC NEAR

   ASSUME ds:DG,es:DG

   nop                                  ; for production - uncomment this line and comment the next
   nop

   cmp  [PInst],0                       ; has print been installed?
   JNE $$IF81

   call Set_Buffer                      ; if not, better do it now                     ;AC000;

$$IF81:
   cld                                  ; just in case...
   mov  [Ambig],0                       ; assume not an ambigous file
					;------------------------------------
					;    Check for drive specifier
					;------------------------------------
   mov  si,P_PTR_L                      ;                                      ;AC000;
   mov  ax,P_PTR_H                      ;                                      ;AC000;
   mov  ds,ax

   ASSUME ds:nothing

   mov  di,offset dg:NameBuf            ; buffer for full file name
   cmp  byte ptr [si+1],":"             ; check if there is a drive designator
   je   $$if83

   mov  ah,Get_Default_Drive            ; get it...
   int  21h
   mov  dl,al                           ; save for later (used in DoPath)
   inc  dl                              ; adjust to proper code (A=1,B=2,...)
   add  al,"A"                          ; convert to letter code
   stosb                                ; store letter code
   mov  al,":"
   stosb
   clc                                  ; clear error flag                     ;AC000;
   jmp  short  $$en83

$$IF83:
   mov  al,byte ptr [si]                ; get drive letter
   sub  al,"@"                          ; conver to proper code...
   jna  $$if85                          ; if not a valid drive, go fix

   mov  dl,al                           ; save for later (used in DoPath)
   movsb                                ; move the drive letter
   movsb                                ; move the ":"
   clc                                  ;                                      ;AC000;
   jmp  short  $$en85

$$IF85:
   mov  ax,(CLASS_B shl 8) + InvDrvMes ; set up error message          ;AC000;
   stc                                  ; set error flag                       ;AC000;

$$EN85:
$$EN83:
					;------------------------------------
					; could have CF & message # here
					;------------------------------------
   jc  $$if89
					;------------------------------------
					;    Check for full path
					;------------------------------------
   mov  al,[PathChar]
   cmp  byte ptr [si],al                ; does it start from the root?
   je   $$if90
					; if not get the current path          ;AC000;
   stosb                                ; store path character
   push si
   mov  si,di                           ; buffer for current directory
   mov  ah,Current_Dir                  ; get current directory
   int  21h
   jnc  $$if91

   pop  si                              ; clear the stack
   mov  ax,(CLASS_B shl 8) + InvDrvMes ; set up error message      ;AC000;
   jmp  short  $$en91

$$IF91:
$$DO93:
					; find terminating nul                 ;AC000;
   lodsb
   or   al,al
   jnz  $$do93

   dec  si                              ; adjust to point to nul
   mov  ax,di                           ; save pointer to beg. of path
   mov  di,si                           ; here is were the file name goes
   pop  si                              ; points to file name
   cmp  ax,di                           ; if equal then file is in the root
   je   $$if95
					; if not, add a path char              ;AC000;
   mov  al,[PathChar]
   stosb                                ; put path separator before file name

$$IF95:
					;------------------------------------
					;    Check for valid drive.
					;------------------------------------
					; Done by getting current dir of
					; the drive in question (already in
					; DL) into NameBuf. If no error the
					; valid drive and we throw away the
					; current dir stuf by overwriting it
					; with the filename.

   clc                                  ; reset error flag                     ;AC000;

$$EN91:
					; else - it starts from the root       ;AC000;
   jmp  short  $$en90

$$IF90:
					; DL has drive number (from DrvFound)
   push si
   mov  si,di                           ; buffer for current directory
   mov  ah,Current_Dir                  ; get current directory
   int  21h
   pop  si
   jnc  $$if99

   mov  ax,(CLASS_B shl 8) + InvDrvMes ;                               ;AC000;

$$IF99:
$$EN90:
$$IF89:
					;------------------------------------
					; could have CF & message # here
					;------------------------------------
   jc  $$if103

   mov  cx,MaxFileLen                   ; let's not overflow file name buffer
   mov  ax,di                           ; CX := MaxFileLen -
					;       long(&NameBuf - &PtrLastchar)
   sub  ax,offset dg:NameBuf            ; size of the filename so far
   sub  cx,ax                           ; size left for the filename
   jnc  $$if104

   mov  cx,1                            ; Set cx to fall through to FNTooLong

$$IF104:
					; WHILE (Length(FileName) <= MaxFileLen)
					;       DO copy in the file name       ;AC000;
$$DO106:
   lodsb
   stosb
   cmp  al,"*"
					; if it's ambigous - *, or......       ;AC000;
   je  $$ll107

   cmp  al,"?"                          ;                              :
					; if it's ambigous - ?, .......:       ;AC000;
   jne  $$if107

$$LL107:
   mov  [Ambig],1                       ;       ambigous filename found

$$IF107:
   or   al,al                           ;       end of name?
   clc                                  ;                                      ;AC000;
   jnz  $$if106

   jmp  short  $$sr106

$$IF106:
   loop  $$do106

   dec  di                              ; the name was too long !
   mov  [NulPtr],di
   mov  ax,(CLASS_C shl 8) + NamTMes    ;                                      ;AC000;
   stc                                  ;                                      ;AN010;
					; we have the full absolute name...    ;AC000;
$$SR106:
$$IF103:
   push cs                              ; restore ds to DG
   pop  ds

   ASSUME ds:DG
					;------------------------------------
					; could have CF & message #
					;------------------------------------
   jnc  $$xl2
   jmp  $$if114

$$XL2:
   dec  di
   mov  [NulPtr],di                     ; save pointer to terminating nul
					;------------------------------------
					;    check for an option following name
					;------------------------------------
   call Parse_Input                     ;                                      ;AC000;
   cmp  ax,noerror                      ;  a parse error?                      ;AC000;
   jne  $$if115

   cmp  [P_SYN],offset DG:C_SW_ptr      ;  is it the cancel switch /C       ;AC000;
   jne  $$if116

   mov  [CanFlag],1                     ; set cancel flag
   jmp  short  $$en116

$$IF116:
   cmp  [P_SYN],offset DG:P_SW_ptr      ;  is it the print switch /P    ;AC000;
   jne  $$if118

   mov  [CanFlag],0                     ; reset cancel flag

$$IF118:
$$EN116:
					; if /C or /P found                    ;AC000;
   jne  $$if121

   mov  [ordinal],cx                    ;                                      ;AC000;
   mov  [scan_ptr],si                   ;                                      ;AC000;

$$IF121:
$$IF115:
					;------------------------------------
					;    check file exists
					;------------------------------------
   cmp  [CanFlag],1                     ; are we in cancel mode
   jne  $$if124
					;------------------------------------
					;     Issue a cancel command
					;------------------------------------
					; NOTE: ds:dx MUST point to NameFuf !!!
					; set up cancel
   mov  dx,offset dg:NameBuf            ; filename
   mov  ax,0102H
   call IntWhileBusy
   jnc  $$if125

   cmp  ax,2
					; Original Print Code timing jump      ;AC000;
   je   $$if126
					;------------------------------------
					;***** PROCESS CANCEL ERROR
					;------------------------------------
$$IF126:
   mov  ax,(CLASS_C shl 8) + BadCanMes ;                               ;AC000;
   stc                                  ;                                      ;AC000;

$$IF125:
					; submit mode active                   ;AC000;
   jmp  $$en124

$$IF124:
   cmp  [Ambig],1                       ; is this an ambiguous name?
   jne  $$if130

					; do another ambiguous name
   call GetAbsN                         ; get abs name into NameBuf
; M00 - I commented out the next 4 statements
;   jnc  $$if130
;   mov  ax,(CLASS_C shl 8) + BadNameMes ;                             ;AC000;
;   call DispMsg                                ; call DispMsg                         ;AN000;
					; there is at least 1 name             ;AC000;
;   jmp  $$en130

$$IF130:
$$DO132:
					; do until all names processed         ;AC000;
					; Check if this is a local drive -
					;    If it is, convert the filename
					;    to its physical name.

   lea  si,NameBuf                      ; DS:SI = NameBuf containing name      ;AN010;
   mov  bl,ds:[si]                      ; get DRIVE ID                         ;AN010;
   sub  bl,40h                          ; convert to a number                  ;AN010;
					; IOCtl call to see if target drive is local
   mov  ax,(IOCTL SHL 8) + 9 ;AN010;
   int  21h                             ; IOCtl + dev_local  <4409>            ;AN010;
					; target drive local and               ;AN010;
   jc   $$if133

   test dx,1200H                        ; check if (x & 0x1000)                ;AN010;
					;      (redirected or shared)
					; if RC indicates NO network drive     ;AN010;
   jnz  $$if133
					; Translate the file name into an
					; absolute path name - note that
					; from this point on only SERVER DOS
					; calls will work with this name!

   lea  di,TokBuf                       ; DS:DI = output buffer                ;AN010;
   mov  ax,(xNameTrans SHL 8)           ; check for name translation     ;AN010;
   int  21h                             ; get real path and name               ;AN010;
   jc   $$if133

   xchg di,si                           ; switch source and destination        ;AN010;
   mov  cx,((MaxFileLen+16)/2)          ; move Max buffer              ;AN010;
   cld                                  ;AN010;
   rep  movsw                           ; move name back into NameBuf          ;AN010;

; Reset FnamPtr to the last \ + 1 in NameBuf, which may well have changed
; if the absolute pathname being substituted for *.* is a partial pathname
; which includes directories, e.g.  e:\print\print_t.asm becomes c:\dos500\
; cmd\print\print_t.asm, because e: was subst'd for c:\dos500\cmd
   mov  cl, PathChar
back: dec  di
   cmp  byte ptr [di], cl
   jne  back
   inc  di
   mov  FnamPtr, di

; Looking for new file, so reset APPEND flag.
   mov  triedappend, 0

$$IF133:
					; set up to open file
   xor  cx,cx                           ; zero attribute type                  ;AC000;
   mov  di,cx                           ;                                      ;AC001;
   dec  di                              ; no list supplied                     ;AC001;
   mov  dx,(ignore_cp shl 8) + (failopen shl 4) + openit ;     ;AC001;
   mov  open_seg,es                     ; segment fix up for OPEN_FILE         ;AC000;
   lds  si,OPEN_FILE                    ;                                      ;AC001;
   mov  bx,open_mode                    ; set open mode                        ;AC000;
   mov  ah,ExtOpen                      ; open for reading exist.              ;AN010;
   mov  al,ds:[si]                      ; recover drive ID                     ;AN010;
   call TO_DOS                          ; make a SERVER DOS call               ;AC010;

; Start Fix  M00
   jc   s1                              ; if open failed, search APPENDed dirs
   jmp  $$if135

s1:
   cmp  triedappend, 1                 ;   but only if we haven't, yet
   jne  s2
   jmp   exterr

s2:
   push  ds
   push  es
   cld

; set the DTA space we will be using
   cmp  ambig, 1
   je   noset                           ; if ambig is set, dta was already set
   mov  ah, 01ah
   mov  dx, OFFSET dg:SearchBuf
   int  21h

; see if APPEND is installed
noset:
   mov  ax, 0b700h
   int  2fh
   or   al, al
   jnz  s3
   jmp  nopath                          ; append not installed
   ; Don't just give up here -- try to open the file again so the
   ; GetExtendedError call gets the right value.

; get the current disk
s3:
   mov  ah, 19h
   int  21h
   add  al, 'A'
   mov  dsklet, al

; get the pointer to the APPEND directory string
   mov  ax, 0b704h
   int  2fh
   mov  nxtdir, di
   mov  ax, es
   mov  appseg, ax

top:
   mov          si, nxtdir                      ; do FIRST while DS-> data !
   push ds                                      ; put ds on stack.  es will retrieve unless error
   mov ax, appseg
   mov  ds, ax
   mov  al, semicolon                           ; terminator char is ';'
   call string_len                              ; returns length in CX
   or   cx, cx                                  ; if ';' didn't work, try 0
   jne  cntnue
   mov  al, endofline
   call string_len
   or   cx, cx                          ; string empty, no more dirs to try ?
   jnz  cntnue

   pop  ds    ;restore data segment saved on stack 
   stc                                  ; if we got to here, nothing was found
   jmp  short nopath

; save location of the next directory in the path
cntnue:
   mov  ax, cx
   add  ax, si
; We need to do the following check to make sure we stop looking for APPENDed
; directories as soon as the APPEND string ends in a null.
   mov   di, ax
   cmp   byte ptr [di], endofline
   je    empty_string
   inc   ax

empty_string:
   pop  es                                      ; get data segment
   mov  es:nxtdir,  ax

; now copy the directory into appbuf
   mov  di,  OFFSET es:appbuf
   cmp  byte ptr ds:[si + 1], ':'               ; is drive specified ?
   je   skipdl                                  ;  then skip adding drive letter
   mov  al, es:dsklet
   stosb
   mov  al, ':'
   stosb

skipdl:
   rep  movsb
   cmp  byte ptr es:[di - 1], '\'
   je   ns                                      ; no slash - don't add slash
   mov  byte ptr es:[di], '\'
   inc  di

;
; add the file name to the path being constructed in appbuf
;
; N.b., this should NOT be the name pointed to by p_ptr_h:p_ptr_l, since
; ParseInput has been called to advance this to the next command-line
; argument past the filename we are currently processing.  Instead, we want
; the filename pointed to by fnamptr.
;
ns:
;   mov  ax, es:p_ptr_h

   mov   ax, es
   mov  ds, ax

;   mov  si, p_ptr_l
   mov   si, fnamptr

   mov  al, endofline                           ; Endofline equ 0
   call string_len
   rep  movsb

; see if we can "find" the file
   mov  ah, 4eh
   xor  cx, cx
   mov  dx, OFFSET ds:appbuf
   int  21h
   jc   clearout

; findfirst succeeded, so copy the full pathname into NameBuf
   mov  si,  OFFSET ds:appbuf
   mov  di,  OFFSET ds:NameBuf
   call string_len
   rep  movsb                                   ; get correct directory first

   mov  si,  OFFSET dg:SearchBuf
   add  si,  1eh                                ; get filename from DTA

reverse:
   cmp  byte ptr es:[di], '\'
   je   catenate
   dec  di
   jmp  short  reverse

catenate:
   inc  di
   mov  es:FNamPtr, di                          ; save for Copy_Name
   call string_len
   inc  cx                                      ; copy the null byte, too
   rep  movsb
   jmp  short  nopath

; zero out buffer
clearout:
   mov  di,  OFFSET ds:appbuf
   xor  al, al
   mov  cx, 64
   rep  stosb
   jmp  top

nopath:
   pop  es
   pop  ds
   mov  triedappend, 1
   jmp  $$if133
; End Fix M00

exterr:                                 ; do error handling
   SaveReg <SI,DI,BP,ES,DS>
   mov  ah,GetExtendedError
   int  21h
   mov  ah,DOS_error
   RestoreReg <DS,ES,BP,DI,SI>
   stc                                  ;                                      ;AC000;
   jmp  short  $$en135

$$IF135:
; make sure the file name does not designate a device
   SaveReg <SI,DI,BP,ES,DS,AX,BX,DX>
   mov  bx,  ax                         ; bx = file handle
   mov  ax,  GetDevInfo                 ; 4400H
   int  21h
   and  dx,  IsDevice?                  ; bit 7 set ?
   pushf
					; close file
;M000
; Bx already contains the handle. This gives an invalid handle and so
;the file never gets closed and this leads to sharing violations on other
;operations on this file. Also, Print soon runs out of handles.
;M000;   mov  bx,ax                           ; copy handle

   mov  ah,close
   int  21h                             ;

   popf
   RestoreReg <DX,BX,AX,DS,ES,BP,DI,SI>
   jz Continue

   mov  AX, (CLASS_B shl 8) + ACCESS_DENIED
   stc
   jmp  short $$en135

Continue:
   clc
					; submit packet
   mov  dx,offset dg:NameBuf            ;
   mov  word ptr [SubPack+1],dx         ; store pointer to name in
   mov  word ptr [SubPack+3],ds         ;  submit packet
   mov  dx,offset dg:SubPack            ; DS:DX address of packet
   mov  ax,0101H                        ; submit a file to resident
   call IntWhileBusy
   jc   $$if137

   cmp  ax,error_queue_full
   je   $$if137

   mov  [QFullMes],0                    ; queue is not full
   clc                                  ; reset the error flag                 ;AC000;
   jmp short $$en137

$$IF137:
   cmp  [QFullMes],1                    ; has the message already been issued?
   je   $$if139
					; if the message has not been posted   ;AC000;
   mov  [QFullMes],1                    ; set the 'message posted' flag
   mov  ax,(CLASS_B shl 8) + FullMes    ; load msg #  ;AC000;
   stc                                  ; display the message                  ;AC000;
   jmp short $$en139

$$IF139:
    clc                                 ; make sure carry clear
					; message processed                    ;AC000;
$$EN139:
					; queue errors                         ;AC000;
$$EN137:
					; OPENing errors                       ;AC000;
$$EN135:
   jnc $$if144

   call DispMsg                         ; display the error with this file     ;AC000;

$$IF144:
					; quit if error in displaying message  ;AC000;
   jc $$en132

   cmp  [Ambig],1                       ; are we processing an ambigous name?
   jne  $$if147
					; call Absn2 (will set fail if at end)
   call GetAbsN2                        ; get another file name
   jmp short $$en147

$$IF147:
   mov  ax,0                            ; set fail                             ;AC000;
   stc                                  ;                                      ;AC000;

$$EN147:
   jc  $$xl3
   jmp $$do132

$$XL3:
$$EN132:
   cmp  ax,0                            ; is there a message?                  ;AC000;
   jne  $$if151
					; if no message                        ;AC000;
   clc                                  ; reset fail                           ;AC000;
					; no message to display                ;AC000;
$$IF151:
					; any submission errors                ;AC000;
$$EN130:
					; submit or cancel                     ;AC000;
$$EN124:
					; any errors so far                    ;AC000;
$$IF114:
   jnc $$if156

   call DispMsg                         ; display the submit error             ;AC000;
$$IF156:
GetOut: ret                                  ; finished submission                  ;AC000;

   Submit_File ENDP



;***************************************************************************
; string_len expects ds:si to point to the desired string, and al to contain
; the desired terminator character
;***************************************************************************
string_len      proc    near

; save es:di because we  trash them
	push    es
	push    di

; set es:di = ds:si
	push    ds
	pop     es
	mov     di, si

; find the terminator character somewhere in the first 64 bytes of the string
	mov     cx, 64                  ; pathname can't be longer anyhow
	repne   scasb
	jne     finis

; set CX equal to string length
	sub     cx, 64
	neg     cx
	dec     cx                      ; don't count the ';' in the length

finis:  pop     di
	pop     es
	ret

string_len      endp



   BREAK <Set_Buffer>
;******************* START OF SPECIFICATIONS ***********************************
;
;  NAME:        Set_Buffer  -  PRINT Build Resident Buffer routine.
;
;  FUNCTION:    Calculate the buffer size required by the resident component and
;               move the transient portion accordingly
;
;  NOTE:        This code is primarily old code, but it has been partly
;               restructured in order to SALUT it.
;
;  INPUT:       None.
;
;  OUTPUT:      Resident Buffer established, and TRANSIENT moved accordingly.
;
;  REGISTERS USED: T.B.D.
;  (NOT RESTORED)
;
;  LINKAGE:     Called from: TRANSIENT
;
;  NORMAL       -
;  EXIT:
;
;  ERROR        -
;  EXIT:
;
;  EXTERNAL     Calls to:  DispMsg,  Parse_Input
;  REFERENCES:
;
;  CHANGE       03/11/87 - Change SETBUF to Set_Buffer   - F. G.
;  LOG:
;
;******************* END OF SPECIFICATIONS *************************************
;******************** START - PSEUDOCODE ***************************************
;
;        START
;        END
;
;******************** END   - PSEUDOCODE ***************************************

   Set_Buffer PROC NEAR

   push cs
   pop  ds
   assume ds:DG
   mov  dl,[PathChar]                   ; transfer PathChar (in PRINT_T)
   mov  ax,CodeR
   mov  es,ax
   assume es:CodeR
   mov  [PChar],dl                      ; to PChar (in PRINT_R)


					;------------------------------------
					;    check device
					;------------------------------------

   cmp  [DevSpec],1                     ; was it already specified?

;  $if  ne,and                          ; if not specified ...........         ;AC000;
   JE $$IF158

   lea  di,TokBuf                       ; ES:DI point to TokBuf      :         ;AC000;
   mov  [TokBuf],9                      ; max of 9 chars             :
   mov  [TokBuf+1],0                    ; assume zero in             :

   push es                              ;                                      ;AC000;
   mov  ax,ds                           ;                                      ;AC000;
   mov  es,ax                           ;                                      ;AC000;

   assume es:DG                         ;                                      ;AC000;

   mov  ax,(CLASS_D shl 8) + prompt     ; DispMsg treats 'prompt' as :         ;AC000;
					;       a special case       :
   call DispMsg                         ;                            :         ;AC000;

   mov  ax,(CLASS_B shl 8) + NEXT_LINE  ; advance to next line after :         ;AC000;
					;       "buffered input" call:
   call DispMsg                         ;                            :         ;AC000;

   pop  es                              ;                                      ;AC000;

   assume es:CodeR

   mov  cl,[TokBuf+1]                   ; check how many read in     :
   or   cl,cl                           ;                            :

;  $if  nz                              ; if a CR was typed..........:         ;AC000;
   JZ $$IF158

       xor  ch,ch
       mov  si,offset dg:TokBuf+2
       mov  di,offset CodeR:ListName
       push si
       mov  dx,si                       ; get ready to capitalize              ;AN007;
       add  si,cx
       mov  byte ptr [si],0             ; turn it into an ascii z string       ;AN007;
       mov  ax,(GetExtCntry SHL 8) + Cap_ASCIIZ ; let DOS capitalize the string ;AN007;
       INT  21h                         ; call DOS to do it                   ;AN007;
       dec  si
       cmp  byte ptr [si],':'

;      $if  e                           ; if a :                               ;AC000;
       JNE $$IF159
	   dec  cx                      ; get rid of trailing ':'
;      $endif                           ; endif - a :                          ;AC000;
$$IF159:

       cmp  cx,8                        ; is it greater than 8 ?               ;AN000;

;      $if  a                           ; if greater - force it to 8.:         ;AC000;
       JNA $$IF161

	   mov  cx,8                    ;                                      ;AN000;

;      $endif                           ;                                      ;AC000;
$$IF161:

       pop  si

       rep  movsb                       ;                                      ;AC000;

;  $endif                               ;                                      ;AC000;
$$IF158:
					;------------------------------------
					;    queue size
					;------------------------------------
   push es
   pop  ds

   ASSUME ds:CodeR

   mov  ax,MaxFileLen                   ; maximum length of a file name
   mul  [QueueLen]                      ; AX = result
   add  ax,offset CodeR:FileQueue
   mov  [EndQueue],ax                   ; save pointer to last nul
   inc  ax
   mov  [buffer],ax                     ; beggining of buffer

					;------------------------------------
					;--- buffer size
					;------------------------------------

   add  ax,[BlkSiz]
   mov  [ENDPTR],AX                     ; Set end of buffer pointer
   mov  [NXTCHR],AX                     ; Buffer empty
   add  ax,100h                         ; allow for header
   add  ax,16                           ; Convert to para
   shr  ax,1
   shr  ax,1
   shr  ax,1
   shr  ax,1
   mov  [EndRes],ax                     ; Add size of buffer to term res size

					; Now JUMP into PRINT_R - the resident
   jmp  MoveTrans                       ;   code to initialize the buffer space

TransRet:                               ; after moving the transient we come
					;  here.
   sti                                  ; Ints were off during initialization
   push cs                              ; CAUTION !!!! from here on in DG is
   pop  ax                              ;  not the ASSEMBLED DG - its bogus -
   mov  ds,ax                           ;  after the move! Only PUSH/POP will
   mov  es,ax                           ;  work.
   mov  WORD PTR [insert_ptr_seg],ax    ; fix up segment in SUBLIST for msgs!  ;AC002;
   mov  WORD PTR [P_PTR_H],ax           ; fix up segment for PARSE             ;AC002;

   ASSUME ds:DG,es:DG


   call SYSLOADMSG                      ; RE-Initialize the Message Services   ;AN016;
					;  - WARNING!!! the Message retriver
					;    keeps track of offset and SEGMENT
					;    for extended and parse errors
					;    EVEN THOUGH WE ARE NEAR!!!  since
					;    the location could now have been
					;    moved - it must now be reset

					;------------------------------------
					;   normalize int handlers for new location of dg
					;------------------------------------

   mov  ax,(SET_INTERRUPT_VECTOR shl 8) or 23h
   mov  dx,OFFSET DG:INT_23
   int  21h
   mov  ax,(SET_INTERRUPT_VECTOR shl 8) or 24h
   mov  dx,OFFSET DG:INT_24
   int  21h

   mov  [PInst],1                       ; remember we just installed resident part

   ret                                  ; finished                             ;AC000;

   Set_Buffer ENDP

   BREAK <copy_to_arg_buf>
;******************* START OF SPECIFICATIONS ***********************************
;
;  NAME:     copy_to_arg_buf
;
;  FUNCTION: Copies the names of the files in the print queue into NameBuf
;               - one name copied per invocation
;
;  INPUT:
;
;  OUTPUT:
;
;
;  REGISTERS USED: T.B.D.
;
;  LINKAGE:     Called from:
;
;
;  CHANGE       05/20/87 - Header added       - F. G.
;  LOG:
;
;******************* END OF SPECIFICATIONS *************************************
;******************** START - PSEUDOCODE ***************************************
;
;       START copy_to_arg_buf
;
;       ret
;
;       END copy_to_arg_buf
;
;******************** END   - PSEUDOCODE ***************************************

   copy_to_arg_buf PROC NEAR

   push di
   push si
   push ax                              ; must preserve AX (could be message #);AN000;
   mov  di,offset dg:NameBuf

;  $do                                  ;                                      ;AC000;
$$DO164:

       lodsb
       or   al,al

;  $leave z                             ;                                      ;AC000;
   JZ $$EN164

       stosb

;  $enddo                               ;                                      ;AC000;
   JMP SHORT $$DO164
$$EN164:

   stosb
   pop  ax                              ; must preserve AX (could be message #);AN000;
   pop  si
   pop  di

   ret

   copy_to_arg_buf ENDP

   BREAK <IntWhileBusy>
;******************* START OF SPECIFICATIONS ***********************************
;
;  NAME:        IntWhileBusy
;
;  FUNCTION:
;
;  INPUT:
;
;  OUTPUT:
;
;
;  REGISTERS USED: T.B.D.
;
;  LINKAGE:     Called from:
;
;
;  CHANGE       05/20/87 - Header added       - F. G.
;  LOG:
;
;******************* END OF SPECIFICATIONS *************************************
;******************** START - PSEUDOCODE ***************************************
;
;       START IntWhileBusy
;
;       ret
;
;       END IntWhileBusy
;
;******************** END   - PSEUDOCODE ***************************************

   IntWhileBusy PROC NEAR

;  $search complex                      ;                                      ;AC000;
   JMP SHORT $$SS167
$$DO167:

       pop  ax

;  $strtsrch                            ;                                      ;AC000;
$$SS167:

       push ax
       int  ComInt

;  $exitif nc                           ;                                      ;AC000;
   JC $$IF167

       add  sp,2                        ; clear off AX and clear carry

;  $orelse                              ;                                      ;AC000;
   JMP SHORT $$SR167
$$IF167:

       cmp  ax,error_busy

;  $leave nz                            ;                                      ;AC000;
   JNZ $$EN167

;  $endloop                             ;                                      ;AC000;
   JMP SHORT $$DO167
$$EN167:

       add  sp,2                        ; clear off AX
       stc                              ;                                      ;AC000;

;  $endsrch                             ;                                      ;AC000;
$$SR167:

   ret

   IntWhileBusy ENDP

   BREAK <GetAbsN>
;******************* START OF SPECIFICATIONS ***********************************
;
;  NAME:        GetAbsN
;
;  FUNCTION:    Return first absolute name from ambigous name
;
;  INPUT:       NameBuf has the ambigous File Name
;
;  OUTPUT:      Carry Set if no files match
;               else NameBuf has the absolute name
;
;  REGISTERS USED: T.B.D.
;
;  LINKAGE:     Called from:
;
;
;  CHANGE       05/20/87 - Header added       - F. G.
;  LOG:
;
;******************* END OF SPECIFICATIONS *************************************
;******************** START - PSEUDOCODE ***************************************
;
;       START GetAbsN
;
;       ret
;
;       END GetAbsN
;
;******************** END   - PSEUDOCODE ***************************************

   GetAbsN PROC NEAR

public GetAbsN

   ASSUME ds:DG,es:DG

   mov  ah,Set_DMA                      ; buffer for ffirst / fnext
   mov  dx,offset dg:SearchBuf
   int  21h
					;------------------------------------
					;    look for a match
					;------------------------------------
   mov  dx,offset dg:NameBuf
   mov  cx,0                            ; no attributes
   mov  ah,Find_First
   int  21h

;  $if  nc                              ; if no error                          ;AC000;
   JC $$IF174

					;------------------------------------
					;    Place new name in NameBuf
					;------------------------------------
       mov  si,[NulPtr]
       std                              ; scan back

;      $do                              ;                                      ;AC000;
$$DO175:

	   lodsb
	   cmp  al,PathChar

;      $enddo e                         ;                                      ;AC000;
       JNE $$DO175

       cld                              ; just in case...
       inc  si
       inc  si
       mov  [FnamPtr],si
       call CopyName
       clc                              ;                                      ;AC000;

;  $endif                               ; endif -no error                      ;AC000;
$$IF174:

   ret

   GetAbsN ENDP

   BREAK <GetAbsN2>
;******************* START OF SPECIFICATIONS ***********************************
;
;  NAME:        GetAbsN2
;
;  FUNCTION:    Return next absolute name from ambigous
;
;  INPUT:
;
;  OUTPUT:
;
;  REGISTERS USED: T.B.D.
;
;  LINKAGE:     Called from:
;
;
;  CHANGE       05/20/87 - Header added       - F. G.
;  LOG:
;
;******************* END OF SPECIFICATIONS *************************************
;******************** START - PSEUDOCODE ***************************************
;
;       START GetAbsN2
;
;       ret
;
;       END GetAbsN2
;
;******************** END   - PSEUDOCODE ***************************************

   GetAbsN2 PROC NEAR

   mov  ah,Set_DMA                      ; buffer for ffirst / fnext
   mov  dx,offset dg:SearchBuf
   int  21h
   mov  ah,Find_Next
   int  21h

;  $if  nc                              ; if no error                          ;AC000;
   JC $$IF178

       call CopyName                    ; we found one
       clc                              ;                                      ;AC000;

;  $endif                               ; endif - no error                     ;AC000;
$$IF178:

   mov  ax,0                            ; signal no message available

   ret                                  ; return

   GetAbsN2 ENDP

   BREAK <CopyName>
;******************* START OF SPECIFICATIONS ***********************************
;
;  NAME:        CopyName
;
;  FUNCTION:    Copy name from search buf to NameBuf
;
;  INPUT:
;
;  OUTPUT:
;
;  REGISTERS USED: T.B.D.
;
;  LINKAGE:     Called from:
;
;
;  CHANGE       05/20/87 - Header added       - F. G.
;  LOG:
;
;******************* END OF SPECIFICATIONS *************************************
;******************** START - PSEUDOCODE ***************************************
;
;       START CopyName
;
;       ret
;
;       END CopyName
;
;******************** END   - PSEUDOCODE ***************************************

   CopyName PROC NEAR

   mov  di,[FNamPtr]
   mov  si,offset dg:SearchBuf.find_buf_pname
   cld

;  $do                                  ; until null is found                  ;AC000;
$$DO180:

       lodsb                            ; move the name
       stosb
       or   al,al                       ; nul found?

;  $enddo e                             ;                                      ;AC000;
   JNE $$DO180

   ret

   CopyName ENDP

   BREAK <Save_Vectors>
;******************* START OF SPECIFICATIONS ***********************************
;
;  NAME:         Save_Vectors
;
;  FUNCTION:     save int vectors in case of error
;
;  INPUT:
;
;  OUTPUT:
;
;  REGISTERS USED: T.B.D.
;
;  LINKAGE:     Called from:
;
;
;  CHANGE       05/20/87 - Header added       - F. G.
;  LOG:
;
;******************* END OF SPECIFICATIONS *************************************
;******************** START - PSEUDOCODE ***************************************
;
;       START Save_Vectors
;
;       ret
;
;       END Save_Vectors
;
;******************** END   - PSEUDOCODE ***************************************

   Save_Vectors PROC NEAR

   mov  ax,(get_interrupt_vector shl 8) or SOFTINT ; (SOFTINT)
   int  21h

   ASSUME es:nothing

   mov  word ptr [i28vec+2],es
   mov  word ptr [i28vec],bx

   mov  ax,(get_interrupt_vector shl 8) or COMINT ; (COMINT)
   int  21h
   mov  word ptr [i2fvec+2],es
   mov  word ptr [i2fvec],bx

   mov  ax,(get_interrupt_vector shl 8) or 13h
   int  21h
   mov  word ptr [i13vec+2],es
   mov  word ptr [i13vec],bx

   mov  ax,(get_interrupt_vector shl 8) or 15h
   int  21h
   mov  word ptr [i15vec+2],es
   mov  word ptr [i15vec],bx

   mov  ax,(get_interrupt_vector shl 8) or 17h
   int  21h
   mov  word ptr [i17vec+2],es
   mov  word ptr [i17vec],bx

   mov  ax,(get_interrupt_vector shl 8) or 14h
   int  21h
   mov  word ptr [i14vec+2],es
   mov  word ptr [i14vec],bx

   mov  ax,(get_interrupt_vector shl 8) or 05h
   int  21h
   mov  word ptr [i05vec+2],es
   mov  word ptr [i05vec],bx

   mov  ax,(get_interrupt_vector shl 8) or INTLOC ; (INTLOC)
   int  21h
   mov  word ptr [i1cvec+2],es
   mov  word ptr [i1cvec],bx

   push cs
   pop  es

   ASSUME es:DG

   Save_Vectors ENDP

   BREAK <GetHInt>
;******************* START OF SPECIFICATIONS ***********************************
;
;  NAME:        GetHInt
;
;  FUNCTION:    Install PRINT Interupt Handler routines
;
;  INPUT:
;
;  OUTPUT:
;
;  REGISTERS USED: T.B.D.
;
;  LINKAGE:     Called from: TRANSIENT,
;
;
;  CHANGE       05/20/87 - Header added       - F. G.
;  LOG:
;
;******************* END OF SPECIFICATIONS *************************************
;******************** START - PSEUDOCODE ***************************************
;
;       START GetHInt
;
;       ret
;
;       END GetHInt
;
;******************** END   - PSEUDOCODE ***************************************

   GetHInt PROC NEAR

   ASSUME ds:DG,es:DG

   push es
   mov  ax,(GET_INTERRUPT_VECTOR shl 8) OR 24h
   int  21h

   ASSUME es:nothing

   mov  WORD PTR [HARDCH],bx
   mov  WORD PTR [HARDCH+2],es
   pop  es

   ASSUME es:DG

   ret

   GetHInt ENDP

   BREAK <SetInts>
;******************* START OF SPECIFICATIONS ***********************************
;
;  NAME:        SetInts
;
;  FUNCTION:    Install PRINT Interupt Handler routines
;
;  INPUT:
;
;  OUTPUT:
;
;  REGISTERS USED: T.B.D.
;  (NOT RESTORED)
;
;  LINKAGE:     Called from: TRANSIENT,
;
;  NORMAL
;  EXIT:
;
;  ERROR
;  EXIT:
;
;  EXTERNAL
;  REFERENCES:
;
;  CHANGE       05/20/87 - Header added       - F. G.
;  LOG:
;
;******************* END OF SPECIFICATIONS *************************************
;******************** START - PSEUDOCODE ***************************************
;
;       START SetInts
;
;       ret
;
;       END SetInts
;
;******************** END   - PSEUDOCODE ***************************************

   SetInts PROC NEAR

   ASSUME ds:DG,es:DG

   mov  AX,(SET_INTERRUPT_VECTOR shl 8) OR 23h
   mov  DX,OFFSET DG:INT_23
   int  21h

   mov  ax,(SET_INTERRUPT_VECTOR shl 8) OR 24h
   mov  dx,OFFSET DG:INT_24
   int  21h

   ret

   SetInts ENDP

   BREAK <Int_24>
;******************* START OF SPECIFICATIONS ***********************************
;
;  NAME:        Int_24
;
;  FUNCTION:    INT 24 handler
;
;  INPUT:
;
;  OUTPUT:
;
;  NOTE:        This is coded as a PROC but is never called
;
;  REGISTERS USED: T.B.D.
;  (NOT RESTORED)
;
;  LINKAGE:     INTerupt 24
;
;  NORMAL
;  EXIT:
;
;  ERROR
;  EXIT:
;
;  CHANGE       05/20/87 - Header added       - F. G.
;  LOG:
;
;******************* END OF SPECIFICATIONS *************************************
;******************** START - PSEUDOCODE ***************************************
;
;       START Int_24
;
;       ret
;
;       END Int_24
;
;******************** END   - PSEUDOCODE ***************************************


INT_24_RETADDR DW OFFSET DG:INT_24_BACK

in_int_23 db 0                          ; reentrancy flag


   INT_24 PROC FAR

   ASSUME ds:nothing,es:nothing,ss:nothing

   pushf
   push cs
   push [INT_24_RETADDR]
   push WORD PTR [HARDCH+2]
   push WORD PTR [HARDCH]

   ret

   INT_24 ENDP

   BREAK <INT_24_BACK>
;******************* START OF SPECIFICATIONS ***********************************
;
;  NAME:        INT_24_BACK
;
;  FUNCTION:    INT 24 post processor
;
;  INPUT:
;
;  OUTPUT:
;
;  NOTE:        This is NOT a PROC
;
;  REGISTERS USED: T.B.D.
;  (NOT RESTORED)
;
;  LINKAGE:     INTerupt 24
;
;  NORMAL
;  EXIT:
;
;  ERROR
;  EXIT:
;
;  CHANGE       05/20/87 - Header added       - F. G.
;  LOG:
;
;******************* END OF SPECIFICATIONS *************************************
;******************** START - PSEUDOCODE ***************************************
;
;       START INT_24_BACK
;
;       ret
;
;       END INT_24_BACK
;
;******************** END   - PSEUDOCODE ***************************************

INT_24_BACK:

   cmp  al,2                            ; Abort?

;  $if  z                               ; if abort                             ;AC000;
   JNZ $$IF182

       inc  [in_int_23]                 ; no int 23's allowed
       push cs
       pop  ds

       ASSUME ds:DG

       push cs
       pop  ss

       ASSUME ss:DG

       mov  sp, offset dg:intStk        ; setup local int stack
       cmp  [PInst],2

;      $if  ne                          ; if not installed                     ;AC000;
       JE $$IF183

	   call Restore_ints

;      $endif                           ; endif - not installed                ;AC000;
$$IF183:

       mov  ah,EXIT
       mov  al,0FFH
       int  21h

;  $endif                               ; endif - abort
$$IF182:

   IRET

   BREAK <Int_23>
;******************* START OF SPECIFICATIONS ***********************************
;
;  NAME:        Int_23
;
;  FUNCTION:    INT 23 handler
;
;  INPUT:
;
;  OUTPUT:
;
;  NOTE:        This is NOT a PROC
;
;  REGISTERS USED: T.B.D.
;  (NOT RESTORED)
;
;  LINKAGE:     INTerupt 23
;
;  NORMAL
;  EXIT:
;
;  ERROR
;  EXIT:
;
;  CHANGE       05/20/87 - Header added       - F. G.
;  LOG:
;
;******************* END OF SPECIFICATIONS *************************************
;******************** START - PSEUDOCODE ***************************************
;
;       START Int_23
;
;       ret
;
;       END Int_23
;
;******************** END   - PSEUDOCODE ***************************************

INT_23:

   ASSUME ds:nothing,es:nothing,ss:nothing

   cmp  [in_int_23],0                   ; check for a re-entrant call

;  $if  e                               ; If its OK                            ;AC000;
   JNE $$IF186

       inc  [in_int_23]                 ; make sure no more int 23's
       push cs
       pop  ds

       ASSUME ds:DG

       push cs
       pop  ss

       ASSUME ss:DG

       mov  sp, offset dg:intStk        ; setup local int stack
       cmp  [PInst],2

;      $if  ne                          ; if not installed - undo              ;AC000;
       JE $$IF187

	   call Restore_ints            ;                                      ;AC000;

;      $else                            ; else - dont undo                     ;AC000;
       JMP SHORT $$EN187
$$IF187:

	   mov  ax,0105H
	   call IntWhileBusy            ; unlock print queue (just in case)

;      $endif                           ; endif - undo                         ;AC000;
$$EN187:

       mov  ah,EXIT
       mov  al,0FFH
       int  21h

;  $endif                               ; endif - its OK                       ;AC000;
$$IF186:

   iret                                 ;

   BREAK <Restore_ints>
;******************* START OF SPECIFICATIONS ***********************************
;
;  NAME:        Restore_ints
;
;  FUNCTION:    Restore all ints used by print to original values
;
;  INPUT:
;
;  OUTPUT:
;
;  REGISTERS USED: T.B.D.
;  (NOT RESTORED)
;
;  LINKAGE:     Called from: TRANSIENT,
;
;  NORMAL
;  EXIT:
;
;  ERROR
;  EXIT:
;
;  EXTERNAL
;  REFERENCES:
;
;  CHANGE       05/20/87 - Header added       - F. G.
;  LOG:
;
;******************* END OF SPECIFICATIONS *************************************
;******************** START - PSEUDOCODE ***************************************
;
;       START Restore_ints
;
;       ret
;
;       END Restore_ints
;
;******************** END   - PSEUDOCODE ***************************************

   Restore_ints PROC NEAR

   ASSUME ds:DG,es:nothing,ss:DG

   cli
   mov  ax,(set_interrupt_vector shl 8) or SOFTINT ; (SOFTINT)
   push ds
   lds  dx,[i28vec]
   int  21h
   pop  ds

   mov  ax,(set_interrupt_vector shl 8) or COMINT ; (COMINT)
   push ds
   lds  dx,[i2fvec]
   int  21h
   pop  ds

   mov  ax,(set_interrupt_vector shl 8) or 13h
   push ds
   lds  dx,[i13vec]
   int  21h
   pop  ds

   mov  ax,(set_interrupt_vector shl 8) or 15h
   push ds
   lds  dx,[i15vec]
   int  21h
   pop  ds

   mov  ax,(set_interrupt_vector shl 8) or 17h
   push ds
   lds  dx,[i17vec]
   int  21h
   pop  ds

   mov  ax,(set_interrupt_vector shl 8) or 14h
   push ds
   lds  dx,[i14vec]
   int  21h
   pop  ds

   mov  ax,(set_interrupt_vector shl 8) or 05h
   push ds
   lds  dx,[i05vec]
   int  21h
   pop  ds

   mov  ax,(set_interrupt_vector shl 8) or INTLOC ; (INTLOC)
   push ds
   lds  dx,[i1cvec]
   int  21h
   pop  ds
   sti

   ret

   Restore_ints ENDP


   BREAK <Parse_Input>
;******************* START OF SPECIFICATIONS ***********************************
;
;  NAME:        Parse_Input  -  PRINT Command Line Parser
;
;  FUNCTION:    Call the DOS PARSE Service Routines to process the command
;               line. Search for valid input:
;                        - filenames (may be more than one)
;                        - switches: /D:device
;                                    /B:buffsize  512 to 16k - 512 default
;                                    /Q:quesiz      4 to 32  -  10 default
;                                    /S:timeslice   1 to 255 -   8 default
;                                    /U:busytick    1 to 255 -   1 default
;                                    /M:maxtick     1 to 255 -   2 default
;                                    /T    terminate
;                                    /C    cancel
;                                    /P    print
;
;  INPUT:       Current Parse parameters in the Parse_C_B
;                     [ORDINAL]  -  CURRENT ORDINAL VALUE
;                     [SCAN_PTR] -  CURRENT SCAN POINT
;                                -  DS:[SCAN_PTR] - Pionter to Parse string
;               ES:DI - Pointer to PARMS block
;
;  OUTPUT:      PARSE_BUFF filled in:
;
;                    P_TYPE       - TYPE RETURNED
;                    P_ITEM_TAG   - SPACE FOR ITEM TAG
;                    P_SYN        - POINTER TO LIST ENTRY
;                    P_PTR_L      - SPACE FOR POINTER / VALUE - LOW
;                    P_PTR_H      - SPACE FOR POINTER / VALUE - HIGH
;
;  REGISTERS USED: T.B.D.
;  (NOT RESTORED)
;
;  LINKAGE:     Called from: TRANSIENT, Set_Buffer and Submit_File
;
;  NORMAL       CF = 0
;  EXIT:
;
;  ERROR        CF = 1 If user enters:
;  EXIT:                   - any invalid parameter or switch
;                          - an invalid value for a valid switch
;               AX = Parse error number
;
;  EXTERNAL     - System parse service routines
;  REFERENCES:
;
;  CHANGE       03/11/87 - First release      - F. G.
;  LOG:
;
;******************* END OF SPECIFICATIONS *************************************
;******************** START - PSEUDOCODE ***************************************
;
;        START
;        END
;
;******************** END   - PSEUDOCODE ***************************************

   Parse_Input PROC NEAR

Syntax_Error equ 9                      ; Parse syntax error
Parse_EOL equ 0FFh                      ; Parse End Of Line
					;--------------------------------------
					;  Load appropriate registers
					;     from the Parse_Control_Block
					;--------------------------------------
   ASSUME ds:DG,es:DG,ss:nothing

   mov  cx,[ORDINAL]                    ; CURRENT ORDINAL VALUE                ;AN000;
   mov  si,[SCAN_PTR]                   ; CURRENT SCAN POINT                   ;AN000;
   mov  [MSG_PTR],si                    ; Save start in case of error          ;AN000;
   lea  di,PARMS                        ;                                      ;AN000;
   mov  dx,0                            ; RESERVED                             ;AN000;
   push ds                              ;                                      ;AN000;
   mov  ax,CodeR                        ;                                      ;AN000;
   sub  ax,10h                          ; back up 100h to start of psp         ;AN000;
   mov  ds,ax                           ; DS:SI  = command string in PSP       ;AN000;

					;--------------------------------------
   ASSUME ds:nothing                    ;  Call the Parse service routines
					;--------------------------------------

					; CX    - Ordinal value
					; DX    - zero (reserved)
					; DS:SI - Pionter to Parse string
					; ES:DI - Pointer to PARMS block

   call SYSPARSE                        ; PARSE IT!                            ;AN000;

   pop  ds                              ;                                      ;AN000;

   ASSUME ds:DG

   cmp  ax,NOERROR                      ; no errors?                           ;AN000;

;  $if  e                               ; if no errors                         ;AN000;
   JNE $$IF191

       clc                              ; WE'RE DONE                           ;AN000;

;  $else                                ; else - there was an error            ;AN000;
   JMP SHORT $$EN191
$$IF191:

       cmp  al,Parse_EOL                ; error FFh  ?                         ;AN000;

;      $if  ne                          ; if not EOL                           ;AN000;
       JE $$IF193

	   cmp  al,Syntax_Error         ; error 1 to 9 ?                       ;AN000;

;          $if  a                       ; if parse error                       ;AN000;
	   JNA $$IF194

	       mov  al,Syntax_Error     ; Parse syntax error

;          $endif                       ; endif errors                         ;AN000;
$$IF194:

	   lea  bx,Parse_Ret_Code
	   xlat cs:[bx]

;      $endif                           ; endif errors                         ;AN000;
$$IF193:

       stc                              ; SET ERROR FLAG                       ;AN000;

;  $endif                               ; endif - no error                     ;AN000;
$$EN191:

   ret                                  ; NORMAL RETURN TO CALLER              ;AN000;

Parse_Ret_Code label byte

   db   0                               ; Ret Code 0 -                         ;AC003;
   db   9                               ; Ret Code 1 - Too many parameters     ;AC003;
   db   9                               ; Ret Code 2 - Required parameter msg  ;AC003;
   db   3                               ; Ret Code 3 - Invalid switch          ;AC003;
   db   9                               ; Ret Code 4 - Invalid keyword         ;AC003;
   db   9                               ; Ret Code 5 - (reserved)              ;AC003;
   db   6                               ; Ret Code 6 - Parm val out of range   ;AC003;
   db   9                               ; Ret Code 7 - Parameter val not allow ;AC003;
   db   9                               ; Ret Code 8 - Parm format not correct ;AC003;
   db   9                               ; Ret Code 9 - Invalid Parameter       ;AC003;

   Parse_Input ENDP



   BREAK <DispMsg>
;******************* START OF SPECIFICATIONS ***********************************
;
;  NAME:        DispMsg  -  PRINT Display Transient Message Routine
;
;  FUNCTION:    Display the transient messages for PRINT
;
;  INPUT:       Al = message number
;               Ah = class  - 0 - Message Service class
;                             1 - DOS extended error
;                             2 - Parse error
;                             A - PRINT_R message
;                             B - PRINT_T message
;                             C - PRINT_T message with insert
;                                                       DS:SI = sublist
;                             D - PRINT_T message with input buffer where:
;                                                       ES:DI = input buffer
;  OUTPUT:      - Messages output to Output Device
;
;  REGISTERS USED:  CX DX
;  (NOT RESTORED)
;
;  LINKAGE:     Call from  PRINT_R, TRANSIENT
;
;  NORMAL       -
;  EXIT:
;
;  ERROR        -
;  EXIT:
;
;  CHANGE       03/11/87 - First release      - F. G.
;  LOG:         09/28/87 - move back to tranient - make 'NEAR'
;
;******************* END OF SPECIFICATIONS *************************************
;******************** START - PSEUDOCODE ***************************************
;
;       START DispMsg
;
;       point to SUBLIST
;       reset response  (DL)
;       set class to utility (DH)
;       reset insert  (CX)
;       set output handle (BX)
;       if CLASS requires insert
;               load insert required
;       endif
;       if CLASS requires response
;               flush keystroke buffer
;               load response required (Dir CON in no echo)
;       endif
;       if CLASS is not Utility
;               set CLASS
;       endif
;       call SysDispMsg to display message
;       if error
;               set class to DOS_error
;               set error flag
;       endif
;
;       ret
;
;       END DispMsg
;
;******************** END   - PSEUDOCODE ***************************************

   DispMsg PROC NEAR

   ASSUME CS:DG,DS:nothing,ES:nothing,SS:nothing

   push ds                              ;                                      ;AN000;
   push si                              ;                                      ;AN000;
   push cs                              ; called before and after relocation   ;AC002;
   pop  ds                              ;  - don't use DG                      ;AC002;

   ASSUME CS:DG,DS:DG,ES:nothing,SS:nothing

   lea  si,SUBLIST                      ; point to sublist                     ;AN000;
   xor  dx,dx                           ; reset response  (DL)                 ;AN000;
   dec  dh                              ;                                      ;AN000;
   xor  cx,cx                           ; reset insert  (CX)                   ;AN000;
   mov  bx,STDOUT                       ; set output handle (BX)               ;AC014;

   cmp  ah,CLASS_C                      ; is it CLASS C                        ;AN000;

;  $if  e,or                            ; CLASS C requires insert              ;AC012;
   JE $$LL198

   cmp  ah,DOS_Error                    ; is it a DOS error?                   ;AN012;

;  $if  e                               ; DOS requires insert                  ;AN012;
   JNE $$IF198
$$LL198:

       mov  cx,offset DG:NameBuf        ; set up insert pointer to NameBuf     ;AN005;
       mov  insert_ptr_off,cx           ;                                      ;AN005;
       push cs                          ;                                      ;AN005;
       pop  [insert_ptr_seg]            ;                                      ;AN005;
       cmp  ah,CLASS_C                  ;                                      ;AC012;
;      $if  e,and                       ;                                      ;AC012;
       JNE $$IF199
       cmp  al,BadNameMes               ;                                      ;AN010;
;      $if  b                           ;                                      ;AN010;
       JNB $$IF199
	   mov  [insert_num],1          ;                                      ;AN005;
;      $else                            ;                                      ;AN010;
       JMP SHORT $$EN199
$$IF199:
	   mov  [insert_num],0          ;                                      ;AN010;
;      $endif                           ;                                      ;AN010;
$$EN199:
       mov  cx,1                        ; 1 parameter to replace               ;AN005;

;  $endif                               ;                                      ;AN000;
$$IF198:

   cmp  ah,CLASS_D                      ; is it CLASS D                        ;AN000;

;  $if  e                               ; CLASS D requires response            ;AN000;
   JNE $$IF203

					; flush keystroke buffer?
       mov  dl,buffered_input           ; load response required (INT 21h 0A)  ;AN000;

;  $endif                               ;                                      ;AN000;
$$IF203:

   cmp  ah,Parse_error

;  $if  be                              ; if Parse or DOS error
   JNBE $$IF205

       mov  dh,ah
       mov  bx,STDERR                   ; set output handle (BX)               ;AN014;

;  $endif                               ;
$$IF205:

;  $if  e                               ; if it is a parse error - show them
   JNE $$IF207
					; what is wrong
       mov  cx,[MSG_PTR]                ;  set up sublist offset               ;AN005;
       mov  [insert_ptr_off],cx         ;                                      ;AN005;
       mov  cx,CodeR                    ;  set up sublist segment (PSP)        ;AN005;
       sub  cx,10h                      ;                                      ;AN005;
       mov  [insert_ptr_seg],cx         ;                                      ;AN005;
       push si                          ;  save current pointer                ;AN005;
       push ds                          ;                                      ;AN005;
       mov  si,[SCAN_PTR]               ; point to end of bad parm             ;AN005;
       mov  ds,cx                       ;                                      ;AN005;
       mov  BYTE PTR ds:[si],0          ; terminate the parameter              ;AN005;
       pop  ds                          ;   restore current pointer            ;AN005;
       pop  si                          ;                                      ;AN005;
       mov  [insert_num],0              ;                                      ;AN005;
       mov  cx,1                        ; 1 parameter to replace               ;AN005;

;  $endif
$$IF207:

   xor  ah,ah                           ;                                      ;AN000;

   call SysDispMsg                      ; to display message                   ;AN002;

;  $if  c                               ; error ..................             ;AN000;
   JNC $$IF209

       mov  ah,DOS_error                ; load error exit code                 ;AN000;
       stc                              ; indicate failure                     ;AN000;

;  $endif                               ;                                      ;AN000;
$$IF209:

   pop  si                              ;                                      ;AN000;
   pop  ds                              ;                                      ;AN000;

   ret                                  ;                                      ;AN000;

   DispMsg ENDP

   GoDispMsg PROC FAR

   call DispMsg                         ; This allows long calls form CODER    ;AN000;

   ret                                  ;                                      ;AN000;

   GoDispMsg ENDP

   BREAK <Load_R_Msg>
;******************* START OF SPECIFICATIONS ***********************************
;
;  NAME:        Load_R_Msg  -  PRINT Load  Resident Message Routine
;
;  FUNCTION:    Load the PRINT resident messages into their
;               current message buffer.  Note that PRINT 'pumps' the
;               error text out as part of the data stream.  For this reason
;               the message service code is NOT used to display RESIDENT messages.
;
;  INPUT:       Messages in PRINT_RM, and Message Retriver code in PRINT_TM.
;
;  OUTPUT:      Resident messages loaded into the resident message buffer
;               and Message Sevices code initalized
;
;  NOTE:        Messages ERRO through ERR12, ERRMEST through AllCan, FATMES
;               BADDDRVM, GOODMES and BADMES are used in place - whereever
;               the Message retriever points to them. BADDRVM is moved directly behind
;               FATMES.
;
;  REGISTERS USED:  DS:SI - points to message text
;  (NOT RESTORED)  (   AX - message # - not destroyed)
;                  (   DH - Class - not destroyed)
;
;  LINKAGE:     Call from TRANSIENT
;
;  NORMAL       CF = 0
;  EXIT:
;
;  ERROR        CF = 1
;  EXIT:        AX = error number
;
;  CHANGE       03/11/87 - First release      - F. G.
;  LOG:         09/28/87 - P1175 - all resident messages must be moved
;
;******************* END OF SPECIFICATIONS *************************************
;******************** START - PSEUDOCODE ***************************************
;
;        START
;        END
;
;******************** END   - PSEUDOCODE ***************************************

   Load_R_Msg PROC NEAR

					;--------------------------------------
					; Load the Resident Messages
					;--------------------------------------
   mov  ax,CodeR                        ;                                      ;AN000;
   mov  es,ax                           ;                                      ;AN000;

   ASSUME DS:nothing,ES:CodeR

   lea  di,R_MES_BUFF                   ; set destination to resident buffer   ;AN000;
   mov  bx,OFFSET CodeR:MESBAS          ; use BX as an index to MESBAS (CodeR) ;AN000;

					;--------------------------------------
					; Move messages ERR0 thru ERR12
					;--------------------------------------

   mov  ax,ERR0                         ; message # 19 to start                ;AN000;
   mov  dx,(DOS_error shl 8)            ; Class is DOS error                   ;AN000;

;  $do                                  ;                                      ;AN000;
$$DO211:

       call MoveMes                     ; LOAD the message                     ;AN000;
;  $leave c                             ; leave loop if ERROR                  ;AN000;
   JC $$EN211
       mov  byte ptr es:[di],DOLLAR     ; append a delimiter
       inc  di                          ; move to next message                 ;AN000;
       inc  al                          ; advance message #                    ;AN000;
       cmp  al,ERR12                    ; are we past ERR12 ?                  ;AN000;

;  $enddo a                             ; if not, do it again                  ;AN000;
   JNA $$DO211
$$EN211:

;  $if  nc                              ; if no ERROR                          ;AN000;
   JC $$IF214
					;--------------------------------------
					; Do rocessing for ERRMEST through
					;      BADDRVM
					;--------------------------------------

       mov  ax, errmest                 ; message # 3 to start                 ;AN000;
       mov  dx,(CLASS_Util shl 8)       ; Class is Utility                     ;AN000;

;      $do                              ; now we are past ERR12                ;AN000;
$$DO215:

	   call MoveMes                 ; LOAD the message                     ;AC002;
;      $leave c                         ; leave loop if ERROR                  ;AC002;
       JC $$EN215
	   inc  al                      ; advance message #                    ;AC002;
	   cmp  al,BADDRVM              ; are we past BADDRVM                  ;AC002;

;      $enddo a                         ;                                      ;AN000;
       JNA $$DO215
$$EN215:

;  $endif                               ; endif - no error                     ;AN000;
$$IF214:

   push cs                              ;                                      ;AN000;
   pop  es                              ;                                      ;AN000;
   push cs                              ;                                      ;AN000;
   pop  ds                              ;                                      ;AN000;

   ASSUME DS:DG,ES:DG

   ret                                  ;                                      ;AN000;

   Load_R_Msg ENDP
					;--------------------------------------
					; Move the Messages into their
					;       final resting place
					;--------------------------------------
MoveMes PROC NEAR

   mov  es:[bx],di                      ; save the pointer to this message     ;AN000;
   call SYSGETMSG                       ; line up the pointer on the message   ;AN000;
;  $if  nc                              ; if no error                          ;AN000;
   JC $$IF219
					; all being well --- WE NOW HAVE---
					; DS:SI - aimed at the message file
					; ES:DI - aimed at the Resident Buffer
					; CX        - # of characters
       cld                              ; go ahead                             ;AN000;
       rep  movsb                       ; and copy it!                         ;AN000;
       inc  bx                          ; set up for next pointer              ;AN000;
       inc  bx                          ;                                      ;AN000;

;  $endif                               ; endif - no error                     ;AN000;
$$IF219:

   ret                                  ;                                      ;AN000;

   MoveMes ENDP


CODE ENDS


STACK SEGMENT STACK

   dw   100 dup(0)

TransSize LABEL BYTE                    ; end of transient
					;  only because code is para algned
STACK ENDS

   END  Transient

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\recover\recdata.inc ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */


 data	 segment PUBLIC para 'DATA'      ;AC000;bgb
;*****************************************************************************
; Data Area
;*****************************************************************************
;
lastchar      dw 0								;an024;bgb
lastbs	      dw 0								;an024;bgb
fndback       dw 0	    ;point to where backslash found
old_subdir    db 64 dup(0) ;current sub directory
new_subdir    db 64 dup(0) ;new     sub directory
paras_per_64k dw 0
paras_per_fat dw 0
secs_per_64k  dw 0
sec_count     dw 0
sixteen     dw	   16			; mul ax for 32 bytes / fat entry
exit_sw     dw	    ?			; loop exit switch			;AN000;bgb
exit_sw2    dw	    ?			; loop exit switch			;AN000;bgb
old_drive     db 0			;original drive to restore to		;an008;bgb
drvlet	    db	    'A: ',13,10,13,10,0         ;                               ;AN000;
rec_num     dw	    ?				;				;AN000;
x_value_lo  dw	?				;				;AN000;
x_value_hi  dw	?				;				;AN000;
y_value_lo  dw	?				;				;AN000;
y_value_hi  dw	?				;				;AN000;
DRVLET1     db	    "A",0
;
 HEADER  DB	 "Vers 2.00"
;-----------------------------------------------------------------------;
 Prompted db	 0			 ; TRUE => prompt has already been done
 hardch  dd	 ?			 ; saved int 24 vector
 the_root db	 0			 ; root directory flag
 fudge	 db	 0			 ; directory changed flag
 user_drive db	 0
 drive	 db	 0
 dirchar db	 "/",0
 userdir db	 "/",0
	 db	 (dirstrlen) dup(0)
 fname_buffer db 128 dup(0)
fbptr	dd	fname_buffer

found	db	no
done	db	no
PSP_Segment dw	0
ExitStatus db	0			;Errorlevel code		;AN000;

					;
BPB_Buffer A_DeviceParameters <>	;				;AN000;

TranSrc db	"A:\",0                 ;                               ;AN000;

Data_Start_Low dw ?			;				;AN000;
Data_Start_High dw ?			;				;AN000;

INT_23_Old_Off dw ?			;				;AN000;
INT_23_Old_Seg dw ?			;				;AN000;
INT_24_Old_Off dw ?			;				;AN000;
INT_24_Old_Seg dw ?			;				;AN000;


Command_Line_Buffer db 128 dup(0)	;				;AN000;
Fatal_Error db	0			;				;AN000;

Command_Line db NO			;				;AN000;

;These should stay together			;				;an022;bgb
; ---------------------------------------	;  ;				;an022;bgb
ifdef fsexec									;an022;bgb
 FS_String_Buffer db 13 dup(" ")         ;                            ;AN000;    ;an022;bgb
 FS_String_End db "REC.EXE",0            ;                            ;AN000;    ;an022;bgb
;----------------------------------------	;				;an022;bgb
 FS_Not_Fat db	 0			 ;				 ;AN000;;an022;bgb
FAT12_String db "FAT12   "              ;
FAT16_String db "FAT16   "              ;

Media_ID_Buffer Media_ID <>		;				;AN000;
endif										;an022;bgb

Append	db	0			;


dirent	db	'FILE0000REC'
	db	21 dup (00)

fcb_copy db	32 dup (?)

filcnt	dw	0000
fatcnt	db	00
fatnum	db	00
fatsiz	dw	0000
firfat	dw	0000
fatptr	dw	0000
secall	dw	0000			; sectors per cluster
target	dw	0000
maxent	dw	0000
firrec	dw	0000
firdir	dw	0000
bytes_per_sector  dw	  0000
secsiz	dw	0000
siztmp	dw	0000
	dw	0000
filsiz	dw	0000
	dw	0000 ;carry noted here - 2 bytes after filsiz
MaxClus DW	0
lastfat dw	0000
;
dbcs_sw 	    db	    0 ;zero if not dbcs - one if dbcs found	       ;an024;bgb
DBCS_Vector	    db	    0
DBCS_Vector_Off     dw	    0
DBCS_Vector_Seg     dw	    0
Read_Write_Relative Relative_Sector_Buffer  <>
Drive_Letter_Msg db "A:",0                      ;Drive for exec fail message

ifdef fsexec									;an022;bgb
;Exec_Block	 Exec_Block_Parms <>						;an022;bgb
;EXEC_Path	 db    66 dup(0)						;an022;bgb
;These next two should stay together
; ---------------------------------------
;Path_String db  "PATH="                         ;                               ;an022;bgb
;Len_Path_String equ 5			 ; length of path= string   ;AN000;bgb	 ;an022;bgb
endif										;an022;bgb
						;
;----------------------------------------
driveLetter db	"X",":",0


						;				;     ;
;----------------------------------------

;Path_SI dw	 0
;Env_DS  dw	 0
table	dw	offset dg:fattbl	  ;AC000;bgb
data	ends


;*****************************************************************************
; LAST DATA AREA
; this data area writes over ram, so leave it at the very end of the pgm.
;*****************************************************************************
lastseg  segment PUBLIC para 'last_s'      ;AC000;bgb
	assume	ds:dg
fattbl	db	0			  ;AC000;bgb
lastseg ends			  ;AN000;bgb

;
data	segment public para 'DATA'      ;AC000;bgb
;******************************************************************************
; Public Data
;******************************************************************************
 public header, prompted, hardch, the_root, fudge, user_drive, drive, dirchar	;AN000;bgb
 public userdir, fname_buffer, found, done, driveletter, psp_segment, exitstatus ;AN000;bgb
 public drvlet, bpb_buffer, transrc, data_start_low, data_start_high,		;AN000;bgb
 public int_23_old_off, int_23_old_seg, int_24_old_off, int_24_old_seg, append	;AN000;bgb
 public command_line_buffer, command_line_length, fatal_error, command_line,	;AN000;bgb
ifdef fsexec									;an022;bgb
 public fs_string_buffer, fs_string_end, len_fs_string_end, fs_not_fat, 	;an022;bgb;AN000;bgb
 public fat12_string, fat16_string, len_fs_id_string, media_id_buffer,		;an022;bgb;AN000;bgb
 public exec_block, exec_path, path_string ;AN000;bgb				;an022;bgb
 public len_path_string 							;an022;bgb;AN011;bgb
 endif										;an022;bgb
 public dirent, fcb_copy, filcnt, fatcnt, fatnum, fatsiz, firfat, fatptr ;AN000;bgb
 public secall, target, maxent, firrec, firdir, secsiz, siztmp, filsiz, maxclus ;AN000;bgb
 public lastfat, table, fattbl, dbcs_vector, dbcs_vector_off, dbcs_vector_seg	;AN000;bgb
 public read_write_relative, drive_letter_msg ;AN000;bgb			;an022;bgb
 public drvlet1, rec_num, x_value_lo, x_value_hi, y_value_lo, y_value_hi
 public bytes_per_sector, exit_sw, exit_sw2, paras_per_fat, secs_per_64k
 public sec_count, paras_per_64k
data	ends ;put this 1st so that the recmsg works
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\recover\recequ.inc ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

include version.inc

const	segment public para 'const'     ;AC000;bgb
Len_FS_ID_String equ 8			; length of fat_12 and fat_16 strings ;AN000;bgb
Command_Line_Length equ 128		; length of command line area  ;AN000;bgb
Len_FS_String_End equ 8 		; length of rec.exe + 0H   ;AN000;bgb
FALSE	EQU	0
;TRUE	 EQU	 -1

bdos	equ	21h
boot	equ	20h
aread	equ	25h
awrite	equ	26h


tab	equ	09h
aread	equ	25h
awrite	equ	26h
fcb	equ	5ch
FCB1	equ	5Ch
FCB2	equ	6Ch
FCB_Filename_Length	equ	11

NO			equ	0						;AN000;
YES			equ	not NO						;AN000;


Not_Include		equ	0
Do_Include		equ	1

No_Ext_Attrib		equ	0						;AN000;
No_Entry		equ	0


FAT12_File_System	equ 01h 						;AN000;
FAT16_File_System	equ 04h 						;AN000;
New_File_System 	equ 06h 						;AN000;

Bad_Exit		equ	0FFh			;Errorlevel = 0FFh	;AN000;

Net_Check		equ   1200h						;AN000;
Assign_Check		equ 8000h						;AN000;

DBCS_Lead		equ  DB_SP_HI
DBCS_Blank		equ  DB_SP_LO
DBCS_Vector_Size	equ 2
End_Of_Vector		equ 0
Blank			equ	" "                                             ;AN000;

Found_Yes		equ   1 						;AN000;
Found_No		equ    0						;AN000;

Asciiz_End		equ  0							;AN000;

Dir_Attribute		equ	10h
Vol_Attribute		equ	08h

Dir_Entries_Per_Sector	equ	512/32


Critical_Error_Fail	equ	3
Write_Protect		equ	0
Drive_Not_Ready 	equ	2


Len_FS_String_Buffer	equ	13

;Limits
BIG_FAT_THRESHOLD	equ 4086						;AN000;

; equates from recinit
;***********************************************
Multiplex		equ   2Fh			      ; 		;AN000;
Set_Append_X		equ 0B707h			   ;			;AN000;;
Append_X		equ    0B706h			       ;		;AN000;;
Append_X_Set		equ 1				   ;			;AN000;
Append_Off		equ  0				     ;			;AN000;
Append_ON		equ   1 			      ; 		;AN000;
fcb1			equ	05ch		;				;AN000;bgb

String_Done equ 0
No_Error equ	0
rec_error   equ     1
Stderr	equ	2
Len_FS_String_Buffer equ 13



;-------------------------------------------------------------------------------
; DATA STRUCTURES
;-------------------------------------------------------------------------------

Exec_Block_Parms struc
Segment_Env	dw  0
Offset_Command	dw  0
Segment_Command dw  0
Offset_FCB1	dw  0
Segment_FCB1	dw  0
Offset_FCB2	dw  0
Segment_FCB2	dw  0

Exec_Block_Parms ends



;-------------------------------------------------------------------------------
; media id
;-------------------------------------------------------------------------------
Media_ID struc									;AN000;
Media_ID_Info_Level dw 0							;AN000;
Media_ID_Serial_Number dd 0							;AN000;
Media_ID_Volume_Label db 11 dup(" ")                                            ;AN000;
Media_ID_File_System db 8  dup(" ")                                             ;AN000;
Media_ID ends									;AN000;

;-------------------------------------------------------------------------------
; device parameters
;-------------------------------------------------------------------------------
A_DeviceParameters	struc

SpecialFunctions	db	?
DeviceType		db	?
DeviceAttributes	dw	?
NumberOfCylinders	dw	?
MediaType		db	?
BytePerSector		dw	?
SectorsPerCluster	db	?
ReservedSectors 	dw	?
NumberOfFATs		db	?
RootEntries		dw	?
TotalSectors		dw	?
MediaDescriptor 	db	?
SectorsPerFAT		dw	?
SectorsPerTrack 	dw	?
Heads			dw	?
HiddenSectors		dd	?
Ext_Total_Sectors	dd	?
Reserved_Area		db	6 dup(?)

A_DeviceParameters	ends




;-------------------------------------------------------------------------------
; relative sector buffer
;-------------------------------------------------------------------------------
Relative_Sector_Buffer	struc			;				;AN000;

Start_Sector_Low	dw	?		;Low word of RBA sector 	;AN000;
Start_Sector_High	dw	?		;High word of RBA sector	;AN000;
Number_Sectors		dw	?		;Number of sectors		;AN000;
Buffer_Offset		dw	?		;Address of data buffer 	;AN000;
Buffer_Segment		dw	?		;				;AN000;

Relative_Sector_Buffer ends			;				;AN000;


;-------------------------------------------------------------------------------
; xal ????
;-------------------------------------------------------------------------------
XAL	struc									;AN000;

XAL_Tsize	dw	?							;AN000;
XAL_TCount	dw	?							;AN000;
XAL_LSize	dw	?							;AN000;
XAL_LCount	dw	?							;AN000;
XAL_Data	db	512-8 dup(?)						;AN000;

XAL	ends									;AN000;

;-------------------------------------------------------------------------------
const	ends
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\recover\recinit.asm ===
;AN000;bgb
page	,132				;
TITLE	RECINIT.ASM - MS-DOS File/Disk Recovery Utility

;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

;*****************************************************************************
;*****************************************************************************
; Include files
;*****************************************************************************
;
 .xlist
	include pathmac.inc
 INCLUDE RECSEG.INC			;AN000;bgb
	INCLUDE DOSSYM.INC		;AN000;BGB
INCLUDE SYSCALL.INC			;AN000;BGB
INCLUDE RECEQU.INC			;AN000;BGB
INCLUDE RECMACRO.INC			;AN000;BGB
INCLUDE RECPARSE.INC			;AN000;BGB
 .list

;
;*****************************************************************************
; External Data Declarations
;*****************************************************************************
data	segment public para 'Data'	 ;an000;bgb
	EXTRN	movsi:word  ;move si pointer here for display of invalid parm	;an031;bgb
	extrn	command_line_buffer:byte ;AN000;bgb
	extrn	ExitStatus:Byte 	;AN000;bgb
	Extrn	FATTbl:byte
	Extrn	SubstErr:Byte
	Extrn	NotNetM:Byte
	Extrn	User_Drive:Byte 	;AN000;BGB
	Extrn	Baddrv:Byte
	Extrn	Drive_Letter_Msg:Byte	;AN000;BGB
	Extrn	Parse_Error_Msg:Byte
	extrn	options_msg:Byte
	extrn	MSG_OPTIONS_FIRST: ABS
	extrn	MSG_OPTIONS_LAST : ABS
	extrn	all_files_msg : byte
	extrn   whole_dsk_msg : byte
	extrn	bad_ver_msg : byte
	extrn	DO_ALL_FILES : ABS
	extrn	DO_WHOLE_DISK : ABS
	extrn	fname_buffer:byte	;AN000;BGB
	extrn	PSP_Segment:word	;AN000;bgb
	extrn	fatal_error:byte	;AN000;bgb
	extrn	found:byte		;AN000;bgb
	extrn	done:byte	       ;AN000;bgb
	extrn	bpb_buffer:byte        ;AN000;bgb
	extrn	data_start_low:word	;AN000;bgb
	extrn	data_start_high:word	 ;AN000;bgb
	extrn	driveletter:byte	      ;AN000;bgb
	extrn	drive:byte		;AN000;bgb
	extrn	transrc:byte		  ;AN000;bgb
	extrn	int_23_old_off:word	;AN000;bgb
	extrn	int_23_old_seg:word	;AN000;bgb
	extrn	int_24_old_off:word	;AN000;bgb
	extrn	int_24_old_seg:word	;AN000;bgb
	extrn	append:byte		 ;AN000;bgb
	extrn   display_interface: near
ifdef fsexec
	extrn	fat12_string:byte	;AN000;bgb
	extrn	fat16_string:byte	;AN000;bgb
	extrn	media_id_buffer:byte	;AN000;bgb
	extrn	fs_not_fat:byte 	;AN000;bgb				;an022;bgb
	extrn	FS_String_Buffer:Byte	;AN011;bgb				;an022;bgb
	extrn	FS_String_end:Byte   ;AN011;bgb 				;an022;bgb
endif
data	ends ;an000;bgb


code	segment public para 'CODE'	 ;an000;bgb
	pathlabl recinit
;*****************************************************************************
; recinit procedures
;*****************************************************************************
public	Main_Init, Init_Io, Preload_Messages, Parse_recover
public	Parse_good, Parse_err, Validate_Target_Drive
public	 Check_Target_Drive, Check_For_Network, Check_Translate_Drive
public	 Hook_interrupts, Clear_Append_X, RECOVER_IFS, Reset_Append_X
public	exitpgm 								;an026;bgb
;*****************************************************************************
; External Routine Declarations
;*****************************************************************************
;	Extrn	EXEC_FS_Recover:Near						;an022;bgb
	 Extrn	 SysLoadMsg:Near
	Extrn	SysDispMsg:Near
	Extrn	Main_Routine:Near
	Extrn	INT_23:Near
	Extrn	INT_24:Near

;*****************************************************************************
;Routine name:	MAIN_INIT
;*****************************************************************************
;
;description: Main routine for recover program
;
;Called Procedures: get_psp
;		    Init_IO
;		    Validate_Target_Drive
;		    Hook_Interrupts
;		    RECOVER_IFS (goes to main-routine)
;
;Input: None
;
;Output: None
;
;Change History: Created	5/8/87	       MT
;
;Psuedocode
;----------
;	get info from psp
;	Parse input and load messages (CALL Init_Input_Output)
;	IF no error
;	   Check target drive letter (CALL Validate_Target_Drive)
;	   IF no error
;	      Set up Control Break (CALL Hook_Interrupts)
;	      IF no error
;		 CALL RECOVER_IFS (goes to main routine)
;	      ENDIF
;	   ENDIF
;	ENDIF
;	Exit program
;*****************************************************************************
procedure Main_Init			;;AN000;
	xor	bp,bp
	Set_Data_Segment		;Set DS,ES to Data segment	;AN000;bgb
	call	get_psp
	mov	Fatal_Error,No		;Init the error flag		;AN000;
	call	Init_Io 		;Setup messages and parse	;AN000;
	cmp	Fatal_Error,Yes 	;Error occur?			;AN000;
;	$IF	NE			;Nope, keep going		;AN000;
	JE $$IF1
	    call    Validate_Target_Drive ;Check drive letter		  ;AN000;
	    cmp     Fatal_Error,Yes	;Error occur?			;AN000;
;	    $IF     NE			;Nope, keep going		;AN000;
	    JE $$IF2
		call	Hook_Interrupts ;Set CNTRL -Break hook		;AN000;
		cmp	Fatal_Error,Yes ;Error occur?			;AN000;
;		$IF	NE		;Nope, keep going		;AN000;
		JE $$IF3
		    call    RECOVER_IFS ;RECOVER correct file system	 ;AN000;
;		$ENDIF			;				;AN000;
$$IF3:
;	    $ENDIF			;				;AN000;
$$IF2:
;	$ENDIF				;				;AN000;
$$IF1:
exitpgm: mov	 al,ExitStatus		 ;Get Errorlevel		 ;AN000;
	DOS_Call Exit			;Exit program			;AN000;
	int	20h			;If other exit fails		;AN000;

Main_Init endp				;				;AN000;

;*****************************************************************************
;Routine name: get_psp
;*****************************************************************************
;Description: get info from the psp area
;
;Called Procedures: get_drive
;
;Change History: Created	8/7/87	       bgb
;
;Input: none
;
;Output: psp_segment
;	 command_line_buffer
;
;Psuedocode
;----------
;	get addr of psp
;	move command line into data seg
;	get drive number of target
;	get addr of data seg
;	call get_drive
;	ret
;*****************************************************************************
Procedure get_psp			;;AN000;
	DOS_Call GetCurrentPSP		;Get PSP segment address	:AN000;bgb
	mov	PSP_Segment,bx		;Save it for later		;AN000;bgb
; get command line from psp							;AN000;bgb
	mov	cx,PSP_Segment		;point ds to data seg			;AN000;bgb
	mov	ds,cx			;  "   "   "   "    "                   ;AN000;bgb
	assume	ds:NOTHING,es:dg	;  "   "   "   "    "                   ;AN000;bgb
	mov	si,Command_Line_Parms	;ds:si --> old area in psp		;AN000;bgb
	LEA	di,command_line_buffer ; es:di -> new area in data
	mov	cx,128			; do for 128 bytes
	rep	movsb			; mov 1 byte until cx=0
; get the drive number of the target from the psp (0=default, a=1, b=2, c=3) ;AN000;bgb
	mov	bl,ds:[FCB1]	    ;Get target drive from FCB -74	    ;AN000;
	Set_Data_Segment	    ;Set DS,ES to Data segment		    ;AN000;bgb
	call	get_drive
	ret
get_psp   endp				;				;AN000;


;*****************************************************************************
;Routine name: get_drive
;*****************************************************************************
;Description: get drive letter from reg bl
;
;Change History: Created	8/7/87	       bgb
;
;Input: bl = drive num (default=0)
;
;Output: driveletter
;	 drive_letter_msg
;	 user_drive
;
;Psuedocode
;----------
;	IF drive-num = default
;	   get default drive number (a=1)
;	   convert to letter
;	ELSE
;	   convert to letter
;	ENDIF
;	move letter into data areas
;	ret
;*****************************************************************************
Procedure get_drive			;;AN000;
; convert drive number to drive letter
	    cmp     bl,0  ;a=1 b=2 c=3	;Is it default drive? 0=default ;AN000;
;	    $IF     E			;Yes, turn it into drive letter ;AN000;
	    JNE $$IF7
; get default drive number
		DOS_Call Get_Default_Drive ;Get default drive num in al    ;AN000;
					;a=0, b=1, c=2
		mov	drive,al	;					;AN000;bgb
;	    $ELSE			;Not default, A=1		;AN000;
	    JMP SHORT $$EN7
$$IF7:
; bl already contains the correct drive number - save it
		dec	bl		;a=0 b=1 c=2
		mov	drive,bl	;					;AN000;bgb
		mov	al,bl
;	    $ENDIF			; 74+40=b4
$$EN7:
	    add     al,"A"		;convert it to letter		;AN000;
	    mov     driveletter,al	;set up prompt msg			;AN000;bgb
	    mov     Drive_Letter_Msg,al ;Save it in message		;AN000;
	    mov     User_Drive,al	;Put it into path strings	;     ;
	ret
get_drive endp				;				;AN000;

;*****************************************************************************
;Routine name: Init_Io
;*****************************************************************************
;description: Initialize messages, Parse command line if FAT file system
;
;Called Procedures: Preload_Messages
;		   Parse_Recover
;
;Change History: Created	5/10/87 	MT
;
;Input: PSP command line at 81h and length at 80h
;
;Output: FS_Not_FAT = YES/NO
;	 Drive_Letter_Msg set up for any future messages that need it
;
;Psuedocode
;----------
;	Load messages (CALL Preload_Messages)
;	IF no fatal error
;	   Get file system type (12-bit fat, 16-bit fat, big fat, ifs)
;	   IF old-type-diskette, or
;	      dos4.00 12-bit fat, or
;	      dos4.00 16-bit fat, then
;	      Go handle FAT based Recover syntax's (Call Parse_Recover)
;	   ELSE
;	      FS_Not_FAT = YES
;	   ENDIF
;	ENDIF
;	ret
;*****************************************************************************
Procedure Init_IO			;;AN000;
; load the error messages from the system					;an022;bgb
	call	Preload_Messages	;Load up message retriever	;AN000;
ifdef fsexec									;an022;bgb
	mov	FS_Not_FAT,No							;an022;bgb
	cmp	Fatal_Error,YES 	;Quit?				;AN000; ;an022;bgb
;	$IF	NE			;Nope, keep going		;AN000; ;an022;bgb
	JE $$IF10
; get file system type from ioctl						;an022;bgb
	    mov     al,generic_ioctl	 ;al=0d (get media id)			;AN000;;an030;bgb
	    xor     bx,bx		;use default drive		;AN009;b;an022;bgbgb
	    mov     ch,Rawio		;8 = disk io				;an030;bgb;an022;bgb
	    mov     cl,Get_Media_Id	;66h					;an030;bgb
	    lea     dx,Media_ID_Buffer ;Point at buffer 	       ;AN000;	;an022;bgb
	    DOS_Call IOCtl		;Do function call ah=44 	;AN000; ;an022;bgb
; is it DOS 3.3 or below?			;carry flag means old dos	;an022;bgb
;	    $IF     C,OR		;Old style diskette, OR 	;AN000; ;an022;bgb
	    JC $$LL11
; is it a new-12 bit fat?							;an022;bgb
	       lea     si,FAT12_String ;Check for FAT_12 string        ;AN000;	;an022;bgb
	       lea     di,Media_ID_Buffer.Media_ID_File_System ;	    ;AN0;an022;bgb00;
	       mov     cx,Len_FS_ID_String ;Length of compare		   ;AN00;an022;bgb0;
	       repe    cmpsb		   ;Find it?			   ;AN00;an022;bgb0;
;	    $IF     E,OR		;Nope, keep going		;AN000; ;an022;bgb
	    JE $$LL11
; is it a new 16-bit fat?							;an022;bgb
	       lea     si,FAT16_String ;Check for FAT_16 string        ;AN000;	;an022;bgb
	       lea     di,Media_ID_Buffer.Media_ID_File_System ;	    ;AN0;an022;bgb00;
	       mov     cx,Len_FS_ID_String ;Length of compare		   ;AN00;an022;bgb0;
	       repe    cmpsb		   ;Do compare			   ;AN00;an022;bgb0;
;	    $IF     E			; is it new 16-bit fat? 	;AN000; ;an022;bgb
	    JNE $$IF11
$$LL11:
endif										;an022;bgb
; file system is fat based, continue (old or new)				;an022;bgb
		call	Parse_Recover	;Yes, go sort out syntax		;an022;bgb
;										;an022;bgb
; non-fat based system								;an022;bgb
ifdef fsexec									;an022;bgb
;	    $ELSE			;We got FS other than FAT	;AN000; ;an022;bgb
	    JMP SHORT $$EN11
$$IF11:
		mov	FS_Not_FAT,Yes	;Indicate exec file system	;AN000; ;an022;bgb
		mov	cx,8							;an022;bgb;an011;bgb
		lea	si,Media_ID_Buffer.Media_ID_File_System ;get file system;an022;bgb ;an011;bgb
		lea	di,fs_string_buffer ;put it here			;an022;bgb;an011;bgb
		rep	movsb							;an022;bgb;an011;bgb
		lea	di,fs_string_buffer ;point to beginning again		;an022;bgb;an011;bgb
;		$DO	COMPLEX 	;search th string until eol found	;an022;bgb;an011;bgb
		JMP SHORT $$SD13
$$DO13:
		    inc     di		;next char				;an022;bgb;an011;bgb
;		$STRTDO 		;start loop here			;an022;bgb;an011;bgb
$$SD13:
		    cmp     byte ptr [di],' '	 ;end of string ?		;an022;bgb	   ;an011;bgb
;		$ENDDO	E		;end loop when eol found		;an022;bgb;an011;bgb
		JNE $$DO13
		lea	si,fs_string_end ;get end of string - rec.exe		;an022;bgb;an011;bgb
		mov	cx,8		; 8 more chars				;an022;bgb;an011;bgb
		rep	movsb		;move it in				;an022;bgb;an011;bgb
;	    $ENDIF			; fat based file system 	;AN000; ;an022;bgb
$$EN11:
;	$ENDIF				; no error from msg retreiver	   ;AN00;an022;bgb0;
$$IF10:
endif										;an022;bgb
	ret				;				;AN000;
Init_Io 	  endp			;				;AN000;

;*****************************************************************************
;Routine name: Preload_Messages
;*****************************************************************************
;Description: Preload messages using common message retriever routines.
;
;Called Procedures: SysLoadMsg
;
;Change History: Created	5/1/87	       MT
;
;Input: Fatal_Error = NO
;
;Output: Fatal_Error = YES/NO
;
;Psuedocode
;----------
;	Preload All messages (Call SysLoadMsg)
;	IF error
;	   Display SysLoadMsg error message
;	   Fatal_Error = YES
;	ENDIF
;	ret
;*****************************************************************************
Procedure Preload_Messages		;;AN000;						 ;
	call	SysLoadMsg		;Preload the messages		;AN000;
;	$IF	C			;Error? 			;AN000;
	JNC $$IF18
	    lea	    dx, bad_ver_msg
	    call    display_interface
;	    call    SysDispMsg		;Display preload msg		;AN000;
	    mov     Fatal_Error, YES	;Indicate error exit		;AN000;
;	$ENDIF				;				;AN000;
$$IF18:
	ret				;				;AN000;

Preload_Messages endp			;				;AN000;

;*****************************************************************************
;Routine name: Parse_Command_Line
;*****************************************************************************
;Description: Parse the command line. Check for errors, and display error and
;		 exit program if found. Use parse error messages except in case
;		 of no parameters, which has its own message
;
;Called Procedures: Message (macro)
;		    SysParse
;		    parse_good
;		    parse_err
;
;Change History: Created	5/1/87	       MT
;
;Input: Fatal_Error = NO
;
;Output: Fatal_Error = YES/NO
;	 PARSE-ADDR
;	 DRIVELETTER
;	 PARSE-ADDR
;
;Psuedocode
;----------
;    set up regs to call sysparse
;DO UNTIL error=yes or return(ax)=finish(-1)
;    call sysparse
;    IF ax=good return(0)
;	   call parse-good
;    ELSE
;	   call parse-err
;    ENDIF
;ENDLOOP
;ret
;
;A. normal proc ==  1- ax=good 0
;		    2- ax=done -1
;B. no parm	==  1- ax=error 2
;
;C. too many	==  1- ax=good 0
;		    2- ax=error 1
;D. syntax	==  1- ax=error 9
;*****************************************************************************
Procedure Parse_recover 		;					;AN000;bgb
	push	ds			; save ds				;AN000;bgb
; set up to call sysparse							;AN000;bgb
	set_data_segment		;ds,es point to data seg
	LEA	si,command_line_buffer ;ds:si -> cmd line
	LEA	di,parms_input_block   ;es:di--> parms input block	   ;AN000;bgb
	xor	cx,cx			;cx = 0 				;AN000;bgb
	xor	dx,dx			;dx = 0 				;AN000;bgb
	mov	done,no
; call sysparse until error or end of cmd line					;AN000;bgb
;	$DO				;AN000;bgb
$$DO20:
	    call    SysParse		;go parse				;AN000;bgb
	    cmp     ax,$p_rc_eol	; -1 end of command line?		   ;AN000;bgb
;	    $LEAVE  E			; yes - done				    ;AN000;bgb
	    JE $$EN20
	    cmp     ax,$p_no_error	; good return code ??? (0)		;AN000;bgb
;	    $IF     E			; yes					;AN000;bgb
	    JNE $$IF22
		call	parse_good	; go get it				;AN000;bgb
;	    $ELSE			; ax not= good				;AN000;bgb
	    JMP SHORT $$EN22
$$IF22:
		call	parse_err	; check for error			;AN000;bgb
;	    $ENDIF			; eol					;AN000;bgb
$$EN22:
	    cmp     Fatal_Error,YES	;Can we continue?			    ;AN000;bgb
;	    $LEAVE  E			    ;NO 				    ;AN000;bgb
	    JE $$EN20
;	$ENDDO				;					;AN000;bgb
	JMP SHORT $$DO20
$$EN20:
	pop	ds			;					;AN000;bgb
	ret				;					;AN000;bgb
					;					;AN000;bgb
Parse_recover endp			;					;AN000;bgb
					;					;AN000;bgb
					;AN000;bgb
;*****************************************************************************
;Routine name: parse_good
;*****************************************************************************
;
;Description: when the ax register returned by sysparse indicates and error,
;	      this procedure is called.  it then determines which error
;	      occurred, and calls parse_message to display the msg.
;
;Called Procedures: parse_message (macro)
;
;Change History: Created	7/23/87 	bgb
;
;Input:
;
;Output: Fatal_Error = YES/NO
;
;Psuedocode
;----------
;
;	  found=yes
;	  IF data=drive
;	       save drive number and letter
;	  ELSE
;	       IF data=filespec
;		    save filespec
;	       ELSE
;		    call parse-msg
;	       ENDIF
;	  ENDIF
;*****************************************************************************
;
Procedure Parse_good			;				;AN000;bgb

	; See if the /? options help switch was given.
	; If so, display the options help message,
	; and set up for a quick exit.

PG_Check_?:
	cmp	[PARSE_SYN], offset SwOptions_Syn
	jne	PG_Check_?_done
	call	Display_options		; display the options hlp msg
	mov	[Fatal_Error], YES	; flag that we are done
	mov	[ExitStatus], 0		; no error to return
	jmp	short Parse_good_exit	; bail out now
PG_Check_?_done:

	cmp	parse_type,$p_drive  ; 6 if data=drive ;AN000;bgb
;	$IF	E			; not eol, good syntax, drive entered ;AN000;bgb
	JNE $$IF27
	    mov     bl,byte ptr parse_addr ;AN000;bgb
	    dec     bl			;Make drive 0 based		;AN000;bgb
	    mov     drive,bl		;AN000;bgb
	    add     bl,'A'		;make it character		;AN000;bgb
	    mov     driveletter,bl	;save into drive letter 	;AN000;bgb
;	$ELSE				; no - filespec entered 	;AN000;bgb
	JMP SHORT $$EN27
$$IF27:
	    cmp     parse_type,$p_file_spec ; 5 if data = filespec ;AN000;bgb
;	    $IF     E			; was file spec entered       ;AN000;bgb
	    JNE $$IF29
;		    push    si		; save input offset reg 		;AN000;bgb
;		    push    ds		; save input seg reg			;AN000;bgb
;		    push    cx		; save count				;AN000;bgb
;		    push    es		; save other seg reg			;AN000;bgb
;		    mov     cx,ds	;es points to data			;AN000;bgb
;		    mov     es,cx	;es points to data			;AN000;bgb
;		    mov     si,word ptr parse_addr ;get offset to filespec   ;AN000;bgb
;		    mov     ds,word ptr parse_addr+2 ;get segment to filespec	;AN000;bgb
;		    mov     cx,128	; mov 128 bytes 			;AN000;bgb
;		    rep     movs es:fname_buffer,ds:[si] ;move it		    ;AN000;bgb
;		    pop     es		; save other seg reg			;AN000;bgb
;		    pop     cx		; save other seg reg			;AN000;bgb
;		    pop     ds		; save other seg reg			;AN000;bgb
;		    pop     si		; save other seg reg			;AN000;bgb
;	    $ELSE			; no, no drive or filespec    ;AN000;bgb
	    JMP SHORT $$EN29
$$IF29:
		mov	ax,$p_syntax	;tell user bad syntax	   ;AN000;bgb
		parse_message		;display msg		   ;AN000;bgb
		mov Fatal_Error,YES ;Indicate death!  ;AN000;bgb
;	    $ENDIF			; was drive entered ?		;AN000;bgb
$$EN29:
;	$ENDIF				;if data=drive		      ;AN000;bgb
$$EN27:
Parse_good_exit:
	ret				;					;aN000;bgb
					;AN000;bgb
parse_good endp 			;				;AN000;bgb

					;AN000;bgb
;*****************************************************************************
;Routine name: parse_err
;*****************************************************************************
;
;Description: when the ax register returned by sysparse indicates and error,
;	      this procedure is called.  it then determines which error
;	      occurred, and calls parse_message to display the msg.
;
;Called Procedures: parse_message (macro)
;
;Change History: Created	7/23/87 	bgb
;
;Input:
;
;Output: Fatal_Error = YES/NO
;
;Psuedocode
;----------
;
;	  IF ax=done	   (end of cmd line?) -1
;	       IF found=no (eol, but no parameters listed)
;		    call parse-msg
;	       ENDIF
;	  ELSE		   (error other than eol)
;	       call parse-msg
;	  ENDIF
;*****************************************************************************
;
Procedure Parse_err			;					;AN000;bgb
	mov Fatal_Error,YES ;Indicate death!  ;AN000;bgb			;AN000;bgb
	cmp ax,$P_Op_Missing		; 2 = no parameters ?			;AN000;bgb
;	$IF E				;					;AN000;bgb
	JNE $$IF33
	    message baddrv		; yes (invalid drive or filename)	;AN000;bgb
;	$ELSE									;AN000;bgb
	JMP SHORT $$EN33
$$IF33:
	   mov	   byte ptr [si],00	;zero terminate display string	;an031;bgb
	   dec	   si			;look at previous char			;an031;bgb
nextsi:
public nextsi
	   dec	   si			;look at previous char			;an031;bgb
	   cmp	   byte ptr [si],' '	;find parm separator			;an031;bgb
	   jnz	   nextsi		;loop until begin of parm found
	   mov	   movsi,si		;mov si into display parms		;an031;bgb
	    parse_message		;no- display parse message ;AN000;bgb	;AN000;bgb
;	$ENDIF									;AN000;bgb
$$EN33:
	ret				;					;AN000;bgb
parse_err endp				;					;AN000;bgb


;*****************************************************************************
;Routine name: Display_options
;*****************************************************************************
;
;Description: Display the options help message on standard output.
;
;Called Procedures: 
;
;Change History: Created	4/26/90 	c-PaulB
;
;Input:  No value passed.
;
;Output: No value returned.
;        Options help message is output.
;
;Psuedocode
;----------
;
;	  IF ax=done	   (end of cmd line?) -1
;	       IF found=no (eol, but no parameters listed)
;		    call parse-msg
;	       ENDIF
;	  ELSE		   (error other than eol)
;	       call parse-msg
;	  ENDIF
;*****************************************************************************
;
Procedure Display_options

DO_loop:
	Message	options_msg
	cmp	word ptr[options_msg], MSG_OPTIONS_LAST	; last line of msg?
	je	DO_done			; done if so
	inc	word ptr[options_msg]	;  else bump message number
	jmp	short DO_loop		;  and keep going
DO_done:
	ret

Display_options endp


;*****************************************************************************
;Routine name: Validate_Target_Drive
;*****************************************************************************
;
;Description: Control routine for validating the specified format target drive.
;	      If any of the called routines find an error, they will print
;	      message and terminate program, without returning to this routine
;
;Called Procedures: Check_Target_Drive
;		    Check_For_Network
;		    Check_Translate_Drive
;
;Change History: Created	5/1/87	       MT
;
;Input: Fatal_Error = NO
;
;Output: Fatal_Error = YES/NO
;
;Psuedocode
;----------
;
;	CALL Check_Target_Drive
;	IF !Fatal_Error
;	   CALL Check_For_Network
;	   IF !Fatal_Error
;	      CALL Check_Translate_Drive
;	   ENDIF
;	ENDIF
;	ret
;*****************************************************************************
;
Procedure Validate_Target_Drive 	;				;AN000;
	call	Check_For_Network	;See if Network drive letter	;AN000;
	cmp	Fatal_Error,YES 	;Can we continue?		;AN000;
;	$IF	NE			;Yep				;AN000;
	JE $$IF36
	    call    Check_Translate_Drive ;See if Subst, Assigned   ;AN000;
	    call    Check_Target_Drive	;See if valid drive letter	;AN000;
;	$ENDIF				;- Fatal_Error passed back	;AN000;
$$IF36:
	ret				;				;AN000;

Validate_Target_Drive endp		;				;AN000;

;*****************************************************************************
;Routine name: Check_Target_Drive
;*****************************************************************************
;
;Description: Check to see if valid DOS drive by checking if drive is
;	      removable. If error, the drive is invalid. Save default
;	      drive info. Also get target drive BPB information, and compute
;	      the start of the data area
;
;Called Procedures: Message (macro)
;
;Change History: Created	5/1/87	       MT
;
;Input: Fatal_Error = NO
;
;Output: Fatal_Error = YES/NO
;	 User_Drive = default drive
;
;Psuedocode
;----------
;
;	Get default drive
;	See if drive LOCAL     (INT 21h, AX=4409h IOCtl)
;	IF error - drive invalid
;	   Display Invalid drive message
;	   Fatal_Error= YES
;	ENDIF
;	Get BPB of target drive (Generic IOCtl Get Device parameters)
;	Compute start of data area
;	ret
;*****************************************************************************
;
Procedure Check_Target_Drive		;				;AN000;
	mov	al,0Dh			;Get BPB information		;AN000;
	mov	cx,0860h		; "  "	 "  "			;AN000;
;;;;;;;;mov	bl,byte ptr parse_addr	; "  "	 "  " ;AN000;
	mov	bl,drive		;drive number	 ;A=0,B=1		;AN000;bgb
	inc	bl			;a=1					;AN000;bgb
	lea	dx,BPB_Buffer	 ; "  "   "  "			 ;AN000;
	DOS_Call IOCtl			; "  "	 "  "			;AN000;
	xor	cx,cx			;Find # sectors used by FAT's   ;AN000;
	mov	cl,BPB_Buffer.NumberOfFATs ; "  "   "  "		   ;AN000;
	mov	ax,BPB_Buffer.SectorsPerFAT ; "  "   "  "		    ;AN000;
	mul	cx			; "  "	 "  "			;AN000;
	push	dx			;Save results			;AN000;
	push	ax			;     "  "			;AN000;
	mov	ax,BPB_Buffer.RootEntries ;Find number of sectors in root ;AN000;
	mov	cl,Dir_Entries_Per_Sector ; by dividing RootEntries	  ;AN000;
	div	cl			; by (512/32)			;AN000;
	pop	bx			;Get low sectors per FAT back	;AN000;
	pop	dx			;Get high part			;AN000;
	add	ax,bx			;Add to get FAT+Dir sectors	;AN000;
	adc	dx,bp ;zero		;High part			;AN000;
	add	ax,ReservedSectors	;Add in Boot record sectors	;AN000;
	adc	dx,bp ;zero		;to get start of data (DX:AX)	;AN000;
	mov	Data_Start_Low,ax	;Save it			;AN000;
	mov	Data_Start_High,dx	;				;AN000;
	ret				;And we're outa here            ;AN000;
Check_Target_Drive endp 		;				;AN000;

;*****************************************************************************
;Routine name: Check_For_Network
;*****************************************************************************
;
;Description: See if target drive isn't local, or if it is a shared drive. If
;	      so, exit with error message. The IOCtl call is not checked for
;	      an error because it is called previously in another routine, and
;	      invalid drive is the only error it can generate. That condition
;	      would not get this far
;
;Called Procedures: Message (macro)
;
;Change History: Created	5/1/87	       MT
;
;Input: Drive
;	   Fatal_Error = NO
;
;Output: Fatal_Error = YES/NO
;
;Psuedocode
;----------
;	See if drive is local (INT 21h, AX=4409 IOCtl)
;	IF not local
;	   Display network message
;	   Fatal_ERROR = YES
;	ELSE
;	   IF  8000h bit set on return
;	      Display assign message
;	      Fatal_Error = YES
;	   ENDIF
;	ENDIF
;	ret
;*****************************************************************************
;
Procedure Check_For_Network		;				;AN000;
; is device local?  int 21, ah=44, al=9
	mov	bl,drive		;drive number	 ;A=0,B=1		;AN000;bgb
	inc	bl			;drive number	 ;A=1,B=2 for IOCtl call;AN000;bgb
	mov	al,09h			;See if drive is local			;AC000;bgb
	DOS_Call IOCtl			;-this will fail if bad drive	;AC000;
;	$IF	C			;CarrY means invalid drive	   ;AC000;
	JNC $$IF38
	    Message BadDrv		;Print message			;AC000;
	    mov     Fatal_Error,Yes	;Indicate error 		;AN000;
;	$ELSE
	JMP SHORT $$EN38
$$IF38:
	    test    dx,Net_Check	;if (x & 1200H)(redir or shared);     ;
;	    $IF     NZ			;Found a net drive		;AC000;
	    JZ $$IF40
		Message NotNetM 	;Tell 'em                       ;AC000;
		mov	Fatal_Error,Yes ;Indicate bad stuff		;AN000;
;	    $ELSE			;Local drive, now check assign	;AN000;
	    JMP SHORT $$EN40
$$IF40:
		test	dx,Assign_Check ;8000h bit is bad news		;     ;
;		$IF	NZ		;Found it			;AC000;
		JZ $$IF42
		    Message SubstErr	;Tell error			;AC000;
		    mov     Fatal_Error,Yes ;Indicate bad stuff 	    ;AN000;
;		$ENDIF			;				;AN000;
$$IF42:
;	    $ENDIF			;				;AN000;
$$EN40:
;	$ENDIF				;				;AN000;
$$EN38:
	ret				;				;AN000;

Check_For_Network endp			;				;AN000;

;*****************************************************************************
;Routine name: Check_Translate_Drive
;*****************************************************************************
;
;Description: Do a name translate call on the drive letter to see if it is
;	      assigned by SUBST or ASSIGN
;
;Called Procedures: Message (macro)
;
;Change History: Created	5/1/87	       MT
;
;Input: Drive_Letter_Msg has drive string
;	   Fatal_Error = NO
;
;Output: Fatal_Error = YES/NO
;
;Psuedocode
;----------
;	Put drive letter in ASCIIZ string "d:\",0
;	Do name translate call (INT 21)
;	IF drive not same
;	   Display assigned message
;	   Fatal_Error = YES
;	ENDIF
;	ret
;*****************************************************************************
;
Procedure Check_Translate_Drive 	;				;AN000;
	mov	al,Drive_Letter_Msg	;Get target drive letter into	;AN000;
	mov	TranSrc,al		; "d:\",0 string		;AN000;
	lea	si,TranSrc	 ;Point to translate string	 ;AN000;
	push	ds			;Set ES=DS (Data segment)	;     ;
	pop	es			;     "  "	"  "		;     ;
	lea	di,FatTbl	 ;Point at output buffer	 ;     ;
	DOS_Call xNameTrans		;Get real path			;AC000;
;	$IF	NC								;an017;bgb
	JC $$IF46
	    mov     bl,byte ptr [TranSrc]   ;Get drive letter from path     ;	  ;
	    cmp     bl,byte ptr [Fattbl]    ;Did drive letter change?	    ;	  ;
;	    $IF     NE			    ;If not the same, it be bad     ;AC000;
	    JE $$IF47
		Message SubstErr	    ;Tell user			    ;AC000;
		mov	Fatal_Error,Yes     ;Setup error flag		    ;AN000;
;	    $ENDIF			    ;				    ;AN000;
$$IF47:
;	$ELSE									;an017;bgb
	JMP SHORT $$EN46
$$IF46:
	    mov     Fatal_Error,Yes	;Setup error flag		;AN000; ;an017;bgb
	    mov     bx,1							;an017;bgb
	    mov     cx,bp ;zero 						;an017;bgb
	    mov     dx,0100h							;an017;bgb
	    call    sysdispmsg							;an017;bgb
;	$ENDIF				;				;AN000; ;an017;bgb
$$EN46:
	ret				;				;AN000;

Check_Translate_Drive endp		;				;AN000;

;*****************************************************************************
;Routine name: Hook_Interrupts
;*****************************************************************************
;
;Description: Change the interrupt handler for INT 13h to point to the
;	      ControlC_Handler routine
;
;Called Procedures: None
;
;Change History: Created	4/21/87 	MT
;
;Input: None
;
;Output: None
;
;Psuedocode
;----------
;
;	Point at ControlC_Handler routine
;	Set interrupt handler (INT 21h, AX=2523h)
;	ret
;*****************************************************************************
;
 Procedure Hook_Interrupts		 ;				 ;AN000;
	mov	al,23h
	DOS_Call Get_Interrupt_Vector	;Get the INT 23h handler	;AC000;
	mov	word ptr INT_23_Old_Off,bx ;
	mov	bx,es			;				;AN000;
	mov	word ptr INT_23_Old_Seg,bx ;				   ;AN000;
	mov	al,23h			;Specify CNTRL handler		;     ;
	lea	dx, INT_23	 ;Point at it			 ;     ;
	push	ds			;Save data seg			;     ;
	push	cs			;Point to code segment		;     ;
	pop	ds			;				;     ;
	DOS_Call Set_Interrupt_Vector	;Set the INT 23h handler	;AC000;
	pop	ds			;Get Data degment back		;     ;
	mov	al,24h			;
	DOS_Call Get_Interrupt_Vector	;Get the INT 24h handler	;AC000;
	mov	word ptr INT_24_Old_Off,bx ;Save it
	mov	bx,es			;				;AN000;
	mov	word ptr INT_24_Old_Seg,bx ;
	mov	al,24h			;Specify handler		 ;     ;
	lea	dx, INT_24	 ;Point at it			 ;     ;
	push	ds			;Save data seg			;     ;
	push	cs			;Point to code segment		;     ;
	pop	ds			;				;     ;
	DOS_Call Set_Interrupt_Vector	;Set the INT 23h handler	;AC000;
	pop	ds			;Get Data degment back		;     ;
	ret				;				;AN000;

 Hook_Interrupts endp			 ;				 ;AN000;

;*****************************************************************************
;Routine name: Hook_CNTRL_C
;*****************************************************************************
;
;Description: Change the interrupt handler for INT 13h to point to the
;	      ControlC_Handler routine
;
;Called Procedures: None
;
;Change History: Created	4/21/87 	MT
;
;Input: None
;
;Output: None
;
;Psuedocode
;----------
;
;	Point at ControlC_Handler routine
;	Set interrupt handler (INT 21h, AX=2523h)
;	ret
;*****************************************************************************
;
;rocedure Hook_CNTRL_C				;				;AN000;
;	mov	al,23H				;Specify CNTRL handler		;     ;
;	mov	dx, offset ControlC_Handler	;Point at it			;     ;
;	push	ds				;Save data seg			;     ;
;	push	cs				;Point to code segment		;     ;
;	pop	ds				;				;     ;
;	DOS_Call Set_Interrupt_Vector		;Set the INT 23h handler	;AC000;
;	pop	ds				;Get Data degment back		;     ;
;	ret					;				;AN000;
;ook_CNTRL_C endp				;				;AN000;
;
;ontrolC_Handler:
;	set_data_segment
;;;;;;; Message msgInterrupt			;				;AC000;
;;;;;;;;mov	ExitStatus, ExitCtrlC
;	jmp	ExitPgm
;*****************************************************************************
;Routine name: Clear_Append_X
;*****************************************************************************
;
;Description: Determine if Append /XA is turned on thru INT 2Fh, and shut
;	      off for life of RECOVER if it is.
;
;Called Procedures: None
;
;
;Change History: Created	5/13/87 	MT
;
;Input: None
;
;Output: APPEND = YES/NO
;
;Psuedocode
;----------
;
;	Append = NO
;	See if APPEND /X is present (INT 2Fh, AX=0B706h)
;	IF present
;	   Turn append /X off (INT 2Fh, AX=B707h, BX = 0)
;	   Append = YES
;	ENDIF
;	ret
;*****************************************************************************
;
Procedure Clear_Append_X		;				 ;AN000;
	mov	Append,NO		;Init the Append /X flag	;AN000;
	mov	ax,Append_X		;Is Append /X there?		;AN000;
	int	Multiplex		; "  "	   "  " 		;AN000;
	cmp	bx,Append_X_Set 	;Was it turned on?		;AN000;
;	$IF	E			;Yep				;AN000;
	JNE $$IF51
	    mov     Append,YES		;Indicate that it was on	;AN000;
	    mov     ax,Set_Append_X	;Turn Append /X off		;AN000;
	    xor     bx,bx ;Append_Off	    ; "  "    "  "		    ;AN000;
	    int     Multiplex		; "  "	  "  "			;AN000;
;	$ENDIF				;				;AN000;
$$IF51:
	ret				;				;AN000;

Clear_Append_X endp			;				;AN000;


;*****************************************************************************
;Routine name: RECOVER_IFS
;*****************************************************************************
;
;description:
;
;Called Procedures: Main_Routine
;		   EXEC_FS_RECOVER
;
;Change History: Created	5/8/87	       MT
;
;Input: FS_Not_FAT = Yes/No
;
;Output: None
;
;Psuedocode
;----------
;
;	IF File system other than FAT
;	   Go call file system specific RECOVER (CALL EXEC_FS_RECOVER)
;	ELSE
;	   Do FAT based RECOVER (CALL Main_Routine)
;	ENDIF
;	ret
;*****************************************************************************
;
Procedure RECOVER_IFS			;				;AN000;
ifdef fsexec									;an022;bgb
;	cmp	FS_Not_Fat,YES		;Is the target FS a FAT?	;AN000; ;an022;bgb
;	$IF	E			;No, so need to exec the	;AN000; ;an022;bgb
;	    call    EXEC_FS_RECOVER	; file system specific prog.	;AN000; ;an022;bgb
;	$ELSE				;It's a FAT                     ;AN000; ;an022;bgb
endif										;an022;bgb
	    call    clear_append_x	;BGB
	    call    Main_Routine	;Use canned code!		;AN000;
	    call    reset_append_x	;BGB
ifdef fsexec									;an022;bgb
;	$ENDIF				;				;AN000; ;an022;bgb
endif										;an022;bgb
	ret				;				;AN000;

RECOVER_IFS endp			;				;AN000;

;*****************************************************************************
;Routine name: Reset_Append_X
;*****************************************************************************
;
;description: If APPEND /XA was on originally, turn it back on
;
;Called Procedures: None
;
;
;Change History: Created	5/13/87 	MT
;
;Input: None
;
;Output: APPEND = YES/NO
;
;Psuedocode
;----------
;
;	IF APPEND = YES
;	   Turn append /X on (INT 2Fh, AX=B707h, BX = 1)
;	ENDIF
;	ret
;*****************************************************************************
;
Procedure Reset_Append_X		;				;AN000;
	cmp	Append,Yes		;Was Append /X on to start with?;AN000;
;	$IF	E			;Yep				;AN000;
	JNE $$IF53
	    mov     ax,Set_Append_X	;Turn Append /X off		;AN000;
	    mov     bx,Append_On	; "  "	  "  "			;AN000;
	    int     Multiplex		; "  "	  "  "			;AN000;
;	$ENDIF				;				;AN000;
$$IF53:
	ret				;				;AN000;

Reset_Append_X endp			;				;AN000;

	pathlabl recinit
code	ends
	end main_init ;AC000;bgb
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\recover\recmacro.inc ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

;
;******************************************************************************
; Message Macro Definitions
;******************************************************************************
;

      EXTRN Display_Interface:near


;-----------------------------------------------------------------------------

Message macro	Message_Name			;				;AN000;
						;
	mov	dx,offset dg:Message_Name     ; 			      ;AN000;
	call	Display_Interface		;				;AN000;
	endm					;				;AN000;

;-----------------------------------------------------------------------------

Parse_Message macro				;				;AN000;

						;
	push	ds				;				;AN000;bgb
	mov	dx,dg				;				;AN000;bgb
	mov	ds,dx				;				;AN000;bgb
	mov	word ptr Parse_Error_Msg,ax	;				;AN000;
	mov	dx,offset dg:Parse_Error_Msg	   ;				   ;AN000;
	call	Display_Interface		;				;AN000;
	pop	ds				;				;AN000;bgb
	endm					;				;AN000;

;-----------------------------------------------------------------------------

Extended_Message macro				;				;AN000;
						;

	push	ds				;				;AN000;bgb
	mov	dx,dg				;				;AN000;bgb
	mov	ds,dx				;				;AN000;bgb
	mov	word ptr Ext_Error_Msg,ax	;				;AN000;
	mov	dx,offset dg:Ext_Error_Msg    ; 			      ;AN000;
	call	Display_Interface		;				;AN000;
	pop	ds				;				;AN000;bgb
	endm					;				;AN000;

;
;*****************************************************************************
; General Macro's
;*****************************************************************************
;

Procedure	macro	Proc_Name		;				;AN000;
						;
Public	Proc_Name				;				;AN000;
Proc_Name    proc				;				;AN000;
						;
	endm					;				;AN000;
;-----------------------------------------------------------------------------

DOS_Call	macro	Function		;				;AN000;
						;
	mov	ah,Function			;				;AN000;
	int	21h				;				;AN000;
						;
	endm					;				;AN000;
;-----------------------------------------------------------------------------

Popff	macro

	jmp	$+3
	iret
	push	cs
	call	$-2

	endm


;-----------------------------------------------------------------------------

Set_Data_Segment     macro

	push	ax
	mov	ax,dg				;Point to data segment
	mov	ds,ax				;
assume	ds:dg,es:dg
	push	ds
	pop	es
	pop	ax


	endm




=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\recover\recproc.asm ===
page	,132					;
TITLE	RECPROC.ASM

;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

;*****************************************************************************
; Include files
;*****************************************************************************
.xlist
	include recseg.inc		;AN000;bgb
 include dossym.inc	;AN000;bgb
 INCLUDE SYSCALL.INC	;AN000;bgb
 INCLUDE RECMACRO.INC	;AN000;bgb
 include recequ.inc	;AN000;bgb
	include pathmac.inc
.xcref
BREAK	MACRO	subtitle
	SUBTTL	subtitle
	PAGE
ENDM
.cref
;
;*****************************************************************************
; Extrn Declarations
;*****************************************************************************
data	segment PUBLIC para 'DATA'	;AC000;bgb
	EXTRN	secs_per_64k:word
	EXTRN	paras_per_fat:word
	EXTRN	paras_per_64k:word
	EXTRN	bytes_per_sector:word
	EXTRN	sec_count:word
	EXTRN	OFMSG_PTR:WORD
	EXTRN	y_value_lo:WORD 	;AN000;bgb
	EXTRN	y_value_hi:WORD 	;AN000;bgb	   ; AC000;SM
	EXTRN	x_value_lo:WORD 	;AN000;bgb	   ; AC000;SM
	EXTRN	x_value_hi:WORD 	;AN000;bgb	   ; AC000;SM
	EXTRN	dbcs_vector:byte	 ;AN000;bgb	    ; AC000;SM
	EXTRN	dbcs_vector_off:word	 ;AN000;bgb	    ; AC000;SM
	EXTRN	dbcs_vector_seg:word	 ;AN000;bgb	    ; AC000;SM
	EXTRN	filsiz:WORD		;AN000;bgb
	EXTRN	read_write_relative:byte ;AN000;bgb
data	ends				;AC000;bgb

;*****************************************************************************
; recproc procedures
;*****************************************************************************
code	segment public para 'CODE'  ;AC000;bgb
	pathlabl recproc
public report				       ;AN000;bgb
public Read_Disk			;AN000;bgb
public Write_Disk			;AN000;bgb
public Build_String			;AN000;bgb
public ChANge_BlANks			;AN000;bgb
public Check_DBCS_CharACter		;AN000;bgb
.list

;******************************************
; Prints the XXX of YYY bytes recovered message.
; The XXX value is a dword at di+16 on entry.
; The YYY value is a dword (declared as a word) at filsiz.
;*************************************************************
Procedure report,near				;				;AN000;bgb
	lea	dx,ofmsg_ptr
	mov	si,[di+16]			;Get the XXX value
	mov	x_value_lo,si
	mov	di,[di+18]
	mov	x_value_hi,di
	mov	si,filsiz			;Get the YYY value
	mov	y_value_lo,si
	mov	di,filsiz+2
	mov	y_value_hi,di
	call	display_interface		; AC000;SM
	ret
report endp

;=========================================================================	;an005;bgb
; READ_DISK	:	This routine reads the logical sector count requested.	;an005;bgb
;			It will read a maximum of 64k in one read.  If more	;an005;bgb
;			than 64k exists it will continue looping until		;an005;bgb
;			all sectors have been read.				;an005;bgb
;										;an005;bgb
;	Inputs	:	AL - Drive letter					;an005;bgb
;			ES:BX - Segment:offset of transfer address		;an005;bgb
;			CX - Sector count					;an005;bgb
;			DX - 1st  sector					;an005;bgb
;										;an005;bgb
;	Outputs :	Logical sectors read					;an005;bgb
; LOGIC 									;an005;bgb
; ***** 									;an005;bgb
;    adjust es:bx to es:00							;an005;bgb
;    calcluate sectors-per-64k (how many sectors are there that can fit within a 64k segment?)
;    DO while there are more sectors to read than sectors-per-64k		;an005;bgb
;	set sector-count to sectors-per-64k					;an005;bgb
;	perform the disk read							;an005;bgb
;	bump the seg addr to the new addr					;an005;bgb
;	dec  the number of sectors to read by sectors-per-64k			;an005;bgb
;	bump the starting sector number by the sectors-per-64k			;an005;bgb
;    ENDDO									;an005;bgb
;    perform a disk read for less than sectors-per-64k				;an005;bgb
;=========================================================================	;an005;bgb
procedure	read_disk							;an005;bgb
	savereg <ax,bx,cx,dx,es>
	call	seg_adj 			;an000;calc new seg:off 	;an005;bgb
	call	calc_sp64k			;an000;secs/64k 		;an005;bgb
;	$DO				; do while more than 64k		;an005;bgb
$$DO1:
	    cmp     cx,secs_per_64k	    ;an000;exceed 64k			;an005;bgb
;	$LEAVE	LE			    ;an000;yes				;an005;bgb
	JLE $$EN1
	    mov     sec_count,cx	;an000;save cx				;an005;bgb
	    mov     cx,secs_per_64k	;an000;get maximum read 		;an005;bgb
	    call    read_once		;an000;read it				;an005;bgb
;	$LEAVE	C								;an005;bgb
	JC $$EN1
	    mov     cx,es							;an005;bgb
	    add     cx,paras_per_64k	; adjust transfer area			;an005;bgb
	    mov     es,cx							;an005;bgb
	    mov     cx,sec_count	; restore sector count			;an005;bgb
	    sub     cx,secs_per_64k	;an000;get sectors remaining		;an005;bgb
	    add     dx,secs_per_64k	;an000;adjust starting sector		;an005;bgb
;	$ENDDO									;an005;bgb
	JMP SHORT $$DO1
$$EN1:
	call	read_once	    ;an000;read it				;an005;bgb
	restorereg <es,dx,cx,bx,ax>
	ret									;an005;bgb
read_disk	endp								 ;an005;bgb
										;an005;bgb
										;an005;bgb
;*****************************************************************************	;an005;bgb
;Routine name: Read_once							;an005;bgb
;*****************************************************************************	;an005;bgb
;										;an005;bgb
;description: Read in data using Generic IOCtl					;an005;bgb
;										;an005;bgb
;Called Procedures: None							;an005;bgb
;										;an005;bgb
;										;an005;bgb
;Change History: Created	5/13/87 	MT				;an005;bgb
;										;an005;bgb
;Input: AL = Drive number (0=A) 						;an005;bgb
;	DS:BX = Transfer address						;an005;bgb
;	CX = Number of sectors							;an005;bgb
;	Read_Write_Relative.Start_Sector_High = Number of sectors high		;an005;bgb
;	DX = logical sector number low						;an005;bgb
;										;an005;bgb
;Output: CY if error								;an005;bgb
;	 AH = INT 25h error code						;an005;bgb
;										;an005;bgb
;Psuedocode									;an005;bgb
;----------									;an005;bgb
;	Save registers								;an005;bgb
;	Setup structure for function call					;an005;bgb
;	Read the disk (AX=440Dh, CL = 6Fh)					;an005;bgb
;	Restore registers							;an005;bgb
;	ret									;an005;bgb
;*****************************************************************************	;an005;bgb
Procedure Read_once				;				;an005;bgb
	savereg  <ax,bx,cx,dx,si,di,bp,es,ds>	;Change it to Read relative sect;an005;bgb
	mov	Read_Write_Relative.Buffer_Offset,bx ;Get transfer buffer add	 ;an005;bgb
	mov	bx,es				;				;AN005;bgb
	mov	Read_Write_Relative.Buffer_Segment,bx ;Get segment		;an005;bgb
	mov	Read_Write_Relative.Number_Sectors,cx ;Number of sec to read	;an005;bgb
	mov	Read_Write_Relative.Start_Sector_Low,dx ;Start sector		;an005;bgb
	mov	bx,offset Read_Write_Relative	;				;an005;bgb
	mov	cx,0FFFFh			;Read relative sector		;an005;bgb
	INT	25h				;Do the read			;an005;bgb
	pop dx					;Throw away flags on stack	;an005;bgb
	restorereg <ds,es,bp,di,si,dx,cx,bx,ax> 				;an005;bgb
	return									;an005;bgb
 Read_once endp 								;an005;bgb
										;an005;bgb
										;an005;bgb
;=========================================================================	;an005;bgb
; WRITE-DISK	:	This routine reads the logical sector count requested.	;an005;bgb
;			It will read a maximum of 64k in one read.  If more	;an005;bgb
;			than 64k exists it will continue looping until		;an005;bgb
;			all sectors have been read.				;an005;bgb
;										;an005;bgb
;	Inputs	:	AL - Drive letter					;an005;bgb
;			ES:BX - Segment:offset of transfer address		;an005;bgb
;			CX - Sector count					;an005;bgb
;			DX - 1st  sector					;an005;bgb
;										;an005;bgb
;	Outputs :	Logical sectors read					;an005;bgb
; LOGIC 									;an005;bgb
; ***** 									;an005;bgb
;    adjust es:bx to es:00							;an005;bgb
;    calcluate sectors-per-64k (how many sectors are there that can fit within a 64k segment?)
;    DO while there are more sectors to read than sectors-per-64k		;an005;bgb
;	set sector-count to sectors-per-64k					;an005;bgb
;	perform the disk read							;an005;bgb
;	bump the seg addr to the new addr					;an005;bgb
;	dec  the number of sectors to read by sectors-per-64k			;an005;bgb
;	bump the starting sector number by the sectors-per-64k			;an005;bgb
;    ENDDO									;an005;bgb
;    perform a disk read for less than sectors-per-64k				;an005;bgb
;=========================================================================	;an005;bgb
procedure      write_disk							;an005;bgb
	mov	Read_Write_Relative.Start_Sector_High,bp;		       ;;an027;bgb;an023;bgb
	call	seg_adj 		;an000;calc new seg:off 		;an005;bgb
;	$DO				; do while more than 64k		;an005;bgb
$$DO5:
	    cmp     cx,secs_per_64k	;an000;exceed 64k			;an005;bgb
;	$LEAVE	LE			;an000;yes				;an005;bgb
	JLE $$EN5
	    mov     sec_count,cx	;an000;save cx				;an005;bgb
	    mov     cx,secs_per_64k	;an000;get maximum read 		;an005;bgb
	    call   write_once		;an000;read it				;an005;bgb
;	$LEAVE	C								;an005;bgb
	JC $$EN5
	    mov     cx,es							;an005;bgb
	    add     cx,paras_per_64k	; adjust transfer area			;an005;bgb
	    mov     es,cx							;an005;bgb
	    mov     cx,sec_count	; restore sector count			;an005;bgb
	    sub     cx,secs_per_64k	;an000;get sectors remaining		;an005;bgb
	    add     dx,secs_per_64k	;an000;adjust starting sector		;an005;bgb
;	$ENDDO									;an005;bgb
	JMP SHORT $$DO5
$$EN5:
	call	write_once		;an000;read it				;an005;bgb
	ret									;an005;bgb
write_disk	endp								;an005;bgb
										;an005;bgb
;*****************************************************************************
;Routine name: Write_Once
;*****************************************************************************
;
;description: Write Data using int 26
;
;Called Procedures: None
;
;
;Change History: Created	5/13/87 	MT
;
;Input: AL = Drive number (0=A)
;	DS:BX = Transfer address
;	CX = Number of sectors
;	Read_Write_Relative.Start_Sector_High = Number of sectors high
;	DX = logical sector number low
;
;Output: CY if error
;	 AH = INT 26h error code
;
;Psuedocode
;----------
;	Save registers
;	Setup structure for function call
;	Write to disk (AX=440Dh, CL = 4Fh)
;	Restore registers
;	ret
;*****************************************************************************
Procedure Write_once				 ;				;AN000;bgb
    savereg <ax,bx,cx,dx,di,si,bp,es,ds>	 ;This is setup for INT 26h right;AN000;bgb
    mov  Read_Write_Relative.Buffer_Offset,bx	 ;Get transfer buffer add	;AN000;bgb
    mov  bx,es					 ;				;AN005;bgb
    mov  Read_Write_Relative.Buffer_Segment,bx	 ;Get segment			;AN000;bgb
    mov  Read_Write_Relative.Number_Sectors,cx	 ;Number of sec to write	;AN000;bgb
    mov  Read_Write_Relative.Start_Sector_Low,dx ;Start sector			;AN000;bgb
    mov  cx,0FFFFh				 ;Write relative sector 	;AN000;bgb
    lea  bx,read_write_relative 		 ;
    INT  026h					 ;Do the write			;AN000;bgb
    pop  dx					 ;flags is returned on the stack;AN000;bgb
    restorereg <ds,es,bp,si,di,dx,cx,bx,ax>	 ;				;AN000;bgb
	ret					 ;				;AN000;bgb
Write_once endp 				 ;				;AN000;bgb

;=========================================================================	;an005;bgb
; SEG_ADJ	:	This routine adjusts the segment:offset to prevent	;an005;bgb
;			address wrap.						;an005;bgb
;										;an005;bgb
;	Inputs	:	bx - Offset to adjust segment with			;an005;bgb
;			es - Segment to be adjusted				;an005;bgb
;										;an005;bgb
;	Outputs :	bx - New offset 					;an005;bgb
;			es - Adjusted segment					;an005;bgb
;=========================================================================	;an005;bgb
procedure	seg_adj 							;an005;bgb
	savereg <ax,cx,dx>							;an005;bgb
	mov	ax,bx				;an000;get offset		;an005;bgb
	mov	bx,0010h			;divide by 16			;an005;bgb
	xor	dx,dx				;an000;clear dx 		;an005;bgb
	div	bx				;an000;get para count		;an005;bgb
	mov	bx,es				;an000;get seg			;an005;bgb
	add	bx,ax				;an000;adjust for paras 	;an005;bgb
	mov	es,bx				;an000;save new seg		;an005;bgb
	mov	bx,dx				;an000;new offset		;an005;bgb
	restorereg <dx,cx,ax>							;an005;bgb
	ret									;an005;bgb
seg_adj 	endp								;an005;bgb
										;an005;bgb
										;an005;bgb
;=========================================================================	;an005;bgb
; SECS_PER_64K	:	This routine calculates how many sectors, for this	;an005;bgb
;			particular media, will fit into 64k.			;an005;bgb
;										;an005;bgb
;	Inputs	:	DPB_SECTOR_SIZE - bytes/sector				;an005;bgb
;										;an005;bgb
;	Outputs :	SECS_PER_64K	- Sectors / 64k 			;an005;bgb
;			PARAS_PER_64K	- paragraphs per 64k			;an005;bgb
;=========================================================================	;an005;bgb
procedure	calc_sp64k							;an005;bgb
	savereg <ax,bx,cx,dx>							;an005;bgb
	mov	ax,0ffffh			;an000;64k			;an005;bgb
	mov	bx,bytes_per_sector		;an000;get bytes/sector 	;an005;bgb
	xor	dx,dx				;an000;clear dx 		;an005;bgb
	div	bx				;an000;sector count		;an005;bgb
	mov	secs_per_64k,ax 		;an000;save sector count	;an005;bgb
	mov	ax,bytes_per_sector		;an000;get bytes/sector 	;an005;bgb
	mov	bx,010h 			; divide by paras		;an005;bgb
	xor	dx,dx				;an000;clear dx 		;an005;bgb
	div	bx				; paras per sector		;an005;bgb
	mul	secs_per_64k			; times sectors 		;an005;bgb
	mov	paras_per_64k,ax		; = paras per 64k		;an005;bgb
	restorereg <dx,cx,bx,ax>		;an000;restore dx		;an005;bgb
	ret					;an000; 			;an005;bgb
calc_sp64k	endp				;an000; 			;an005;bgb


;*****************************************************************************
;Routine name: Build_String
;*****************************************************************************
;
;Description: Build AN ASCIIZ string from the FCB filename input.
;
;Called Procedures: None
;
;ChANge History: Created	6/29/87 	MT
;
;Input: DS:SI = String containing FCB input
;	ES:DI = Where to build string
;
;Output: ES:DI = Input string starting at first non-blANk charACter
;
;Psuedocode
;----------
;
;	Save regs
;	DO
;	LEAVE Next charACter is 0,OR
;	LEAVE 12th charACter,OR
;	   Get charACter
;	LEAVE BlANk
;	   Inc counter
;	ENDDO
;	Set next charACter to 0
;	Restore regs
;
;*****************************************************************************

Procedure Build_String				;				;AN000;
	cld					;Set string ops to up		;AN000;
	push	ax				;Save registers 		;AN000;
	push	cx				;  "  "    "  " 		;AN000;
	push	si				;Save pointer reg		;AN000;
	xor	cx,cx				;Init the counter		;AN000;
;	$DO					;Loop until entire string found ;AN000;
$$DO9:
	   cmp	   byte ptr [si],ASCIIZ_END	;Is next charACter 0?		;AN000;
;	$LEAVE	E,OR				;Yes, end loop			;AN000;
	JE $$EN9
	   cmp	   cx,FCB_Filename_Length	;Looked at 11 chars?		;AN000;
;	$LEAVE	E,OR				;Yes, end of string		;AN000;
	JE $$EN9
	   lodsb				;Nope, get charACter		;AN000;
	   cmp	   al,BlANk			;Find end of filename?		;AN000;
;	$LEAVE	E				;Yes, quit looping		;AN000;
	JE $$EN9
	   stosb				;Move the char
	   inc	   cx				;No, inc counter ANd try next	;AN000;
;	$ENDDO					;				;AN000;
	JMP SHORT $$DO9
$$EN9:
	mov	byte ptr [di],ASCIIZ_END	;Make ASCIIZ string		;AN000;
	pop	si				;Get bACk pointer to string	;AN000;
	pop	cx				;Restore regsisters		;AN000;
	pop	ax				; "  "	  "  "			;AN000;
	ret					;				;AN000;
Build_String endp				;				;AN000;

;*****************************************************************************
;Routine name: ChANge_BlANks
;*****************************************************************************
;
;Description: ReplACe all DBCS blANks with SBCS blANks
;
;Called Procedures: Check_DBCS_CharACter
;
;ChANge History: Created	6/12/87 	MT
;
;Input: DS:SI = ASCIIZ string containing volume label input
;
;Output: DS:SI = ASCIIZ string with all DBCS blANks replACed with 2 SBCS blANks
;
;
;Psuedocode
;----------
;
;	Save pointer to string
;	DO
;	LEAVE End of string (0)
;	   See if DBCS charACter (Check_DBCS_CharACter)
;	   IF CY (DBCS char found)
;	      IF first byte DBCS blANk, AND
;	      IF second byte DBCS blANk
;		 Convert to SBCS blANks
;	      ENDIF
;	      Point to next byte to compensate for DBCS charACter
;	   ENDIF
;	ENDDO
;	Restore pointer to string
;
;*****************************************************************************
Procedure ChANge_BlANks 			;				;AN000;
;	$DO					;Do while not CR		;AN000;
$$DO12:
	   cmp	   byte ptr [si],Asciiz_End	;Is it end of string?		;AN000;
;	$LEAVE	E				;All done if so 		;AN000;
	JE $$EN12
	   call    Check_DBCS_CharACter 	;Test for dbcs lead byte	;AN000;
;	   $IF	   C				;We have a lead byte		;AN000;
	   JNC $$IF14
	      cmp     byte ptr [si],DBCS_Lead	;Is it a lead blANk?		;AN000;
;	      $IF     E,AND			;If a dbcs char 		;AN000;
	      JNE $$IF15
	      cmp     byte ptr [si+1],DBCS_BlANk ;Is it AN AsiAN blANk?    ;AN000;
;	      $IF     E 			;If AN AsiAN blANk		     ;AN000;
	      JNE $$IF15
		 mov	 byte ptr [si+1],BlANk	;set up moves		      ;AN000;
		 mov	 byte ptr [si],BlANk	;  to replACe			;AN000;
;	      $ENDIF				;				     ;AN000;
$$IF15:
	      inc     si			;Point to dbcs char		;AN000;
;	   $ENDIF				;End lead byte test		;AN000;
$$IF14:
	   inc	   si				;Point to si+1			;AN000;
;	$ENDDO					;End do while			;AN000;
	JMP SHORT $$DO12
$$EN12:
	ret					;return to caller		;AN000;
ChANge_BlANks endp				;				;AN000;


;*****************************************************************************
;Routine name: Check_DBCS_CharACter
;*****************************************************************************
;
;Description: Check if specified byte is in rANges of DBCS vectors
;
;Called Procedures: None
;
;ChANge History: Created	6/12/87 	MT
;
;Input: AL = CharACter to check for DBCS lead charACter
;	DBCS_Vector = YES/NO
;
;Output: CY set if DBCS charACter
;	 DBCS_VECTOR = YES
;
;
;Psuedocode
;----------
;	Save registers
;	IF DBCS vector not found
;	   Get DBCS environmental vector (INT 21h
;	   Point at first set of vectors
;	ENDIF
;	SEARCH
;	LEAVE End of DBCS vectors
;	EXITIF CharACter > X1,AND  (X1,Y1) are environment vectors
;	EXITIF CharACter < Y1
;	  STC (DBCS charACter)
;	ORELSE
;	   Inc pointer to next set of vectors
;	ENDLOOP
;	   CLC (Not DBCS charACter)
;	ENDSRCH
;	Restore registers
;	ret
;*****************************************************************************
Procedure	Check_DBCS_CharACter		      ; 			      ;AN000;
	push	ds				;Save registers 		;AN000;
	push	si				; "  "	  "  "			;AN000;
	push	ax				; "  "	  "  "			;AN000;
	push	ds				; "  "	  "  "			;AN000;
	pop	es				;Establish addressability	;AN000;
	cmp	byte ptr es:DBCS_VECTOR,Yes	;Have we set this yet?		;AN000;
	push	ax				;Save input charACter		;AN000;
;	$IF	NE				;Nope				;AN000;
	JE $$IF19
	   mov	   al,0 			;Get DBCS environment vectors	;AN000;
	   DOS_Call Hongeul			;  "  "    "  " 		;AN000;
	   mov	   byte ptr es:DBCS_VECTOR,YES	;Indicate we've got vector      ;AN000;
	   mov	   es:DBCS_Vector_Off,si	;Save the vector		;AN000;
	   mov	   ax,ds			;				;AN000;
	   mov	   es:DBCS_Vector_Seg,ax	;				;AN000;
;	$ENDIF					; for next time in		;AN000;
$$IF19:
	pop	ax				;Restore input charACter	;AN000;
	mov	si,es:DBCS_Vector_Seg		;Get saved vector pointer	;AN000;
	mov	ds,si				;				;AN000;
	mov	si,es:DBCS_Vector_Off		;				;AN000;
;	$SEARCH 				;Check all the vectors		;AN000;
$$DO21:
	   cmp	   word ptr ds:[si],End_Of_Vector ;End of vector table? 	  ;AN000;
;	$LEAVE	E				;Yes, done			;AN000;
	JE $$EN21
	   cmp	   al,ds:[si]			;See if char is in vector	;AN000;
;	$EXITIF AE,AND				;If >= to lower, ANd		;AN000;
	JNAE $$IF21
	   cmp	   al,ds:[si+1] 		; =< thAN higher rANge		;AN000;
;	$EXITIF BE				; then DBCS charACter		;AN000;
	JNBE $$IF21
	   stc					;Set CY to indicate DBCS	;AN000;
;	$ORELSE 				;Not in rANge, check next	;AN000;
	JMP SHORT $$SR21
$$IF21:
	   add	   si,DBCS_Vector_Size	     ;Get next DBCS vector	     ;AN000;
;	$ENDLOOP				;We didn't find DBCS char       ;AN000;
	JMP SHORT $$DO21
$$EN21:
	   clc					;Clear CY for exit		;AN000;
;	$ENDSRCH				;				;AN000;
$$SR21:
	pop	ax				;Restore registers		;AN000;
	pop	si				; "  "	  "  "			;AN000;
	pop	ds				;Restore data segment		;AN000;
	ret					;				;AN000;
Check_DBCS_CharACter endp			;				;AN000;

	pathlabl recproc
code	ends
	end

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\recover\recpub.inc ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

;
data	segment public para 'DATA'      ;AC000;bgb
;******************************************************************************
; Public Data
;******************************************************************************
 public header, prompted, hardch, the_root, fudge, user_drive, drive, dirchar	;AN000;bgb
 public userdir, fname_buffer, found, done, driveletter, psp_segment, exitstatus ;AN000;bgb
 public drvlet, bpb_buffer, transrc, data_start_low, data_start_high,		;AN000;bgb
 public int_23_old_off, int_23_old_seg, int_24_old_off, int_24_old_seg, append	;AN000;bgb
 public command_line_buffer, command_line_length, fatal_error, command_line,	;AN000;bgb
 public fs_string_buffer, fs_string_end, len_fs_string_end, fs_not_fat, 	;AN000;bgb
 public fat12_string, fat16_string, len_fs_id_string, media_id_buffer,		;AN000;bgb
 public dirent, fcb_copy, filcnt, fatcnt, fatnum, fatsiz, firfat, fatptr ;AN000;bgb
 public secall, target, maxent, firrec, firdir, secsiz, siztmp, filsiz, maxclus ;AN000;bgb
 public lastfat, table, fattbl, dbcs_vector, dbcs_vector_off, dbcs_vector_seg	;AN000;bgb
 public read_write_relative, exec_block, exec_path, drive_letter_msg, path_string ;AN000;bgb
 public len_path_string, search_recover, len_search_recover, search_recover_end ;AN000;bgb
 public drvlet1, rec_num, x_value_lo, x_value_hi, y_value_lo, y_value_hi
 public bytes_per_sector, exit_sw, exit_sw2, paras_per_fat
data	ends ;put this 1st so that the recmsg works
;
;
;*****************************************************************************
; Public Data
;*****************************************************************************
;	Public	drvlet
;	Public	rec_num
;	Public	x_value_lo
;	Public	x_value_hi
;	Public	y_value_lo
;	Public	y_value_hi
;	Public	DrvLet1
;public drive_sublist ;AN000;bgb
;public path_si, env_ds
;	Public	FS_String_Buffer
;	Public	Fatal_Error
;	Public	ExitStatus
;	public	call_pars
;	PUBLIC	INT_23,std_printf,	; AC000;SM
;	Public	Read_Write_Relative
;	PUBLIC	filsiz
;	PUBLIC	FATTbl
;	Public	User_Drive
;	Public	Fname_Buffer
;	PUBLIC	Write_Disk,Read_Disk,report
;	Public Drive_Letter_Msg

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\recover\recparse.inc ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */


const	segment public para 'const' ;AC000;bgb
;***************************************************************************
; Equates
;***************************************************************************
;
;Match Flags
Numeric_Value		equ	8000h		; AN000
Signed_Numeric_Value	equ	4000h		; AN000
Simple_String		equ	2000h		; AN000
Date_String		equ	1000h		; AN000
Time_String		equ	0800h		; AN000
Complex_List		equ	0400h		; AN000
Filespec		equ	0200h		; AN000
Drive_Only		equ	0100h		; AN000
Quoted_String		equ	0080h		; AN000
Ignore_Colon		equ	0010h		; AN000
Repeats_Allowed 	equ	0002h		; AN000
Optional		equ	0001h		; AN000

;Function_Flags

File_Table_Capitalize	equ	1		; AN000
Char_Table_Capitalize	equ	2		; AN000
Remove_Colon		equ	10h		; AN000

;Extra delimeters and EOL

No_Extra_Delimiters	equ	00h		; AN000;SM
Delimiters_Only 	equ	1		; AN000
EOL_Or_Delimiters	equ	2		; AN000

Semi_Colon		equ	";"             ; AN000
Tab			equ	09h		; AN000
Colon			equ	":"             ; AN000


;Parse Errors

No_Error		equ	0		; AN000
Too_Many_Operands	equ	1		; AN000
Operand_Missing 	equ	2		; AN000
Not_In_Switch_List	equ	3		; AN000
Not_In_Keyword_List	equ	4		; AN000
Out_Of_Range		equ	6		; AN000
Not_In_Value_List	equ	7		; AN000
Not_In_String_List	equ	8		; AN000
Syntax_Error		equ	9		; AN000
End_Of_Parse		equ	-1		; AN000

;Return types

Type_Reserved		equ	0		;				;AN000;
Type_Number		equ	1		;				;AN000;
Type_List_Index 	equ	2		;				;AN000;
Type_String		equ	3		;				;AN000;
Type_Complex		equ	4		;				;AN000;
Type_Filespec		equ	5		;				;AN000;
Type_Drive		equ	6		;				;AN000;
Type_Date		equ	7		;				;AN000;
Type_Time		equ	8		;				;AN000;
Type_Quoted_String	equ	9		;				;AN000;


;Other

None			equ	0		; AN000
No_Error		equ	0		; AN000
Switch_Found		equ	0FFFFh		; AN000
Range_Ok		equ	1		; AN000
Command_Line_Parms	equ	81h		; AN000
const	ends  ;AC000;bgb

data	segment public para 'DATA'  ;AC000;bgb
;***************************************************************************** ;AN000;bgb
;***************************************************************************** ;AN000;bgb
; Parse Tables								       ;AN000;bgb
;***************************************************************************** ;AN000;bgb
;***************************************************************************** ;AN000;bgb
;									       ;AN000;bgb
;The following parse control block can be used for any command which	       ;AN000;bgb
;needs only one optional file specification an operand.  Returns a	       ;AN000;bgb
;pointer to the unverified string in PARSE1_OUTPUT.  Currently used	       ;AN000;bgb
;for the RECOVER command.						       ;AN000;bgb
;***************************************************************************** ;AN000;bgb
;;;;db 'PARSE TABLE AREA'                                                      ;AN000;bgb
 public parms_input_block, parms_ext_block, control_block, value_list_block
 public results_block, parse_type, parse_code, parse_addr,
									       ;AN000;bgb
;***************************************************************************** ;AN000;bgb
; This is the parms input block pointed to by es:di before calling sysparse.   ;AN000;bgb
; it is the top level table.						       ;AN000;bgb
parms_input_block LABEL   BYTE						       ;AN000;bgb
		DW	dg:parms_ext_block	  ; addr of parms extension block ;AN000;bgb
		DB	0			; no delimiters or eol chars   ;AN000;bgb
									       ;AN000;bgb
;***************************************************************************** ;AN000;bgb
; This is the parms extension block pointed to by the parms input block.       ;AN000;bgb
; it defines the number and type of parameters allowed in the command line.    ;AN000;bgb
parms_ext_block LABEL	BYTE						       ;AN000;bgb
		DB	1,1			; only one positional parm     ;AN000;bgb
		DW	dg:control_block       ; addr of positional control block ;AN000;bgb
		DB	1			; 1 switch
		DW	dg:Switch_options	; ptr to switch block
		DB	0			;	 no keywords	       ;AN000;bgb
;									       ;AN000;bgb
;PARSE control block for an optional file specification (upper cased)	       ;AN000;bgb
;or drive number							       ;AN000;bgb
;									       ;AN000;bgb
;***************************************************************************** ;AN000;bgb
; This is the control block for either drive letter "c:", or filename.ext, or  ;AN000;bgb
; both "c:filename.ext" entered in the command line. it is pointed to by the   ;AN000;bgb
; parms extension block.						       ;AN000;bgb
control_block	LABEL	BYTE						       ;AN000;bgb
		Dw	$p_file_spc+$p_drv_only ; allowable return values	;AN000;bgb
						; 0200 = filespec	       ;AN000;bgb
						; 0100 = drive only	       ;AN000;bgb
		DW	1			; capitalize - file table	;AN000;bgb
		DW	dg:results_block	   ; points to reults block	   ;AN000;bgb
		DW	dg:value_list_block	   ; point to valu list block	   ;AN000;bgb
		DB	0			; no keyword synonyms		;AN000;bgb


;***************************************************************************** ;AN000;bgb
; This is the switch block for the /? options switch.  The user enters this
; switch when they want help with the command syntax.

	PUBLIC	Switch_options, SwOptions_Syn
Switch_options	LABEL	BYTE
		DW	0000h			; Match Mask
		DW	0000h			; Function Mask
		DW	dg:results_block	; ptr to Result block
		DW	dg:value_list_block	; ptr to Value block
		DB	1			; count of synonyms
SwOptions_Syn	DB	"/?", 0			; text to match

;										;AN000;bgb
;Indicates no value list for PARSE.						;AN000;bgb
;*****************************************************************************	;AN000;bgb
; This is the value list block pointed to by the control block.  This table is	;AN000;bgb
; used to define the type of numeric or string parameters expected.  Since no	;AN000;bgb
; parameters with numerics or strings are used, this block is set to zero.	;AN000;bgb
value_list_block DW	 0			 ;AN000;  no values		;AN000;bgb
										;AN000;bgb
;										;AN000;bgb
;Common output blocks for PARSE number, complex, or string values.		;AN000;bgb
;*****************************************************************************	;AN000;bgb
; This is the results block pointed to by the control block.			;AN000;bgb
; both "c:filename.ext" entered in the command line. it is pointed to by the    ;AN000;bgb
; parms extension block.							;AN000;bgb

	PUBLIC	results_block, PARSE_SYN
results_block	LABEL	BYTE			;AN000; 			;AN000;bgb
PARSE_TYPE     DB      0		       ; type of parm returned		;AN000;bgb
PARSE_CODE     DB      0		       ; matched item tag / return valu ;AN000;bgb
PARSE_SYN      DW      0		       ;	es offset of synonym	;AN000;bgb
PARSE_ADDR     DD      0		       ; either a numeric value, or	;AN000;bgb
	       dd      0 ;parser puts in too many;the offset of string value	;AN000;bgb

;;;;DB 'PARSE AREA ENDS'
data	ends									;AN000;bgb
										;AN000;bgb
;										;AN000;
code	segment PUBLIC para 'CODE'   ;AC000;bgb                                 ;AN000;
;*****************************************************************************	;AN000;
; SysParse Routines								;AN000;
;*****************************************************************************	;AN000;
FarSW	equ	Not_Include			;				;AN000;
DateSW	equ	Not_Include			;				;AN000;
TimeSW	equ	Not_Include			;				;AN000;
FileSW	equ	Do_Include			;				;AN000;
CAPSW	equ	Not_Include			;				;AN000;
CmpxSW	equ	Not_Include			;				;AN000;
NumSW	equ	Not_Include			;				;AN000;
KeySW	equ	Not_Include			;				;AN000;
SwSW	equ	Do_Include			;				;AN000;
Val1SW	equ	Not_Include			;				;AN000;
Val2SW	equ	Not_Include			;				;AN000;
Val3SW	equ	Not_Include			;				;AN000;
DrvSW	equ	Do_Include			;				;AN000;
QusSW	equ	Not_Include			;
basesw	equ	1 ;use ds as the default register				;an040;bgb
incsw	equ	0 ;include psdata myself					;an040;bgb
code	ends									;an040;bgb
										;an040;bgb
										;an040;bgb
data	segment PUBLIC para 'DATA'                                              ;an040;bgb
include psdata.inc								;an040;bgb
data	ends									;an040;bgb
										;an040;bgb
code	segment PUBLIC para 'CODE'                                              ;an040;bgb
pathlabl parser 								;an040;bgb
INCLUDE PARSE.ASM				;AN000; 			;an040;bgb
pathlabl parser 								;an040;bgb
code	ends									;an040;bgb
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\recover\recmsg.inc ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

data	segment PUBLIC para 'DATA'              ; AN000;bgb
;
;*****************************************************************************
; Macro's
;*****************************************************************************
Define_Msg macro Message_Name			;				;AN000;
						;
Create_Msg Message_Name,Message_Number,Handle,Sublist,Count,Class,Function,Input;AN000;
						;
	endm					;				;AN000;

;-----------------------------------------------------------------------------

Create_Msg macro Parm1,Parm2,Parm3,Parm4,Parm5,Parm6,Parm7,Parm8;		;AN000;

Public	Parm1
Parm1	label	word				;				;AN000;
	dw	Parm2				;				;AN000;
	dw	Parm3				;				;AN000;
	dw	Parm4				;				;AN000;
	dw	Parm5				;				;AN000;
	db	Parm6				;				;AN000;
	db	Parm7				;				;AN000;
	dw	Parm8				;				;AN000;
	endm					;				;AN000;

;
;*****************************************************************************
; Message Retriever equates
;*****************************************************************************

Format_Msg		equ	'C'

N_A			equ	0
Sublist_Length		equ	11
None			equ	0

Blank			equ	" "
No_Function		equ	0
No_Replace		equ	0

Msg_Ser_Class		equ	0
Ext_Err_Class		equ	1
Parse_Err_Class 	equ	2
Utility_Msg_Class	equ	0FFh

MIN_INPUT_VAL		equ	400

Reserved		equ	0

	PUBLIC MSG_OPTIONS_FIRST, MSG_OPTIONS_LAST, DO_ALL_FILES, BAD_VER, DO_WHOLE_DISK
MSG_OPTIONS_FIRST	equ	300		; numbers of 1st and
MSG_OPTIONS_LAST        equ     303             ;  last options help msgs
DO_ALL_FILES		equ	400             ; the "are you sure" msg for
                                                ; a *.* filespec
BAD_VER			equ	15
DO_WHOLE_DISK		equ	401		; an entire drive filespec


val		db	0
PUBLIC	val
;
;*****************************************************************************
; Message Sublist Tables
;*****************************************************************************
;
;The  following  control  blocks  are	used   for   messages  with
;replaceable  paramters.  These  control  blocks  are  used by	the
;SysDispMsg routine.
;

;---------------------------			;
Sublist_opnerr		label	byte		; AN000;SM
						;
	db		Sublist_Length		; AN000;SM
	db		Reserved		; AN000;SM
	dw		dg:fname_buffer 	   ; AN000;bgb
	dw		Dg			; AN000;SM
	db		0			; AN000;SM
	db		Left_Align+Char_Field_ASCIIZ ; AN000;SM
	db		14			; AN000;SM
	db		1			; AN000;SM
	db		Blank			; AN000;SM
;---------------------------			;
Sublist_Baddrv		label	byte		; AN000;SM
						;
	db		Sublist_Length		; AN000;SM
	db		Reserved		; AN000;SM
	dw		dg:Drive_Letter_Msg	   ; AN000;bgb
	dw		Dg			; AN000;SM
	db		0			; AN000;SM
	db		Left_Align+Char_Field_ASCIIZ ; AN000;SM
	db		4			; AN000;SM
	db		4			; AN000;SM
	db		Blank			; AN000;SM
;---------------------------			;
ifdef	fsexec									;an022;bgb
Sublist_msg_EXECFailure label	byte		; AN000;SM			;an022;bgb
	db		Sublist_Length		; AN000;SM			;an022;bgb
	db		Reserved		; AN000;SM			;an022;bgb
	dw		dg:Drive_Letter_Msg	   ; AN000;bgb			;an022;bgb
	dw		Dg		      ; AN000;SM			;an022;bgb
	db		1			; AN000;SM			;an022;bgb
	db		Left_Align+Char_Field_ASCIIZ ; AN000;SM 		;an022;bgb
	db		2			; AN000;SM			;an022;bgb
	db		2			; AN000;SM			;an022;bgb
	db		Blank			; AN000;SM			;an022;bgb
endif										;an022;bgb
;---------------------------			;
Sublist_msg_recmsg	label	byte		; AN000;SM
						;
	db		Sublist_Length		; AN000;SM
	db		Reserved		; AN000;SM
	dw		dg:rec_num		   ; AN000;bgb
	dw		Dg		      ; AN000;SM
	db		1			; AN000;SM
	db		Left_Align+Unsgn_Bin_Word ; AN000;SM
	db		5			; AN000;SM
	db		1			; AN000;SM
	db		Blank			; AN000;SM
;---------------------------			;
Sublist_msg_ofmsg	label	byte		; AN000;SM
						;
	db		Sublist_Length		; AN000;SM
	db		Reserved		; AN000;SM
	dw		dg:x_value_lo		   ; AN000;bgb
	dw		Dg		      ; AN000;SM
	db		1			; AN000;SM
	db		Left_Align+Unsgn_Bin_DWord ; AN000;SM
	db		10			; AN000;SM
	db		1			; AN000;SM
	db		Blank			; AN000;SM
	db		Sublist_Length		; AN000;bgb
	db		Reserved		; AN000;SM
	dw		y_value_lo		; AN000;SM
	dw		Dg		      ; AN000;SM
	db		2			; AN000;SM
	db		Left_Align+Unsgn_Bin_DWord ; AN000;SM
	db		10			; AN000;SM
	db		1			; AN000;SM
	db		Blank			; AN000;SM
;-----------------------------------------------------------------------
Drive_sublist label byte	;AN000;bgb

    db	11		   ; sublist size      ;AN000;bgb
    db	0		   ;reserved	       ;AN000;bgb
    dw	dg:driveletter ;offset of data	  ;AN000;bgb
    dw	dg		   ;seg of data  ;AN000;bgb
    db	1		   ; 1st replaceable parm  ;AN000;bgb
    db	char_field_asciiz  ; type = char       ;AN000;bgb
    db	2		   ; max field width   ;AN000;bgb
    db	2		   ; min field width   ;AN000;bgb
    db	' '                ; pad char (unused) ;AN000;bgb
;---------------------------			;				;an031;bgb
Sublist_msg_parserr	label	dword		;				;an031;bgb
										;an031;bgb
	db		Sublist_Length		;11				;an031;bgb
	db		Reserved		;0				;an031;bgb
public movsi
movsi	dw		dg:command_line_buffer	;off				;an031;bgb
	dw		dg			;seg				;an031;bgb
	db		0			;USE PERCENT ZERO		;an031;bgb
	db		Left_Align+Char_Field_ASCIIZ ;type of data		;an031;bgb
	db		128			;max width			;an031;bgb
	db		1			;min width			;an031;bgb
	db		Blank			;pad char			;an031;bgb
;---------------------------			;				;an031;bgb
;										;an000;bgb



;
;*****************************************************************************
; Message Description Tables
;*****************************************************************************
;

;---------------------- 			;
Message_Number	= 2				; AN000;SM
Handle		= STDERR			; AN000;SM
Sublist 	= Sublist_Opnerr		; AN000;SM
Count		= N_A				; AN000;SM
Class		= EXT_ERR_CLASS 		; AN000;SM
Function	= NO_INPUT			; AN000;SM
Input		= N_A				; AN000;SM
	Define_Msg   opnerr			; AN000;SM File not found - xxxxxx
;---------------------- 			;
Message_Number	= 3				; AN000;SM
Handle		= STDERR			; AN000;SM
Sublist 	= None				; AN000;SM
Count		= N_A				; AN000;SM
Class		= Utility_Msg_Class		; AN000;SM
Function	= NO_INPUT			; AN000;SM
Input		= N_A				; AN000;SM
	Define_Msg   Substerr			; AN000;SM Can not recover SUBST or ASSIGNED drive
;---------------------- 			;
Message_Number	= 4				; AN000;SM
Handle		= STDERR			; AN000;SM
Sublist 	= sublist_baddrv		; AN000;SM
Count		= N_A				; AN000;SM
Class		= UTILITY_MSG_CLASS		; AN000;SM
Function	= NO_INPUT			; AN000;SM
Input		= N_A				; AN000;SM
	Define_Msg   baddrv			; AN000;SM Invalid drive or file name	  ;AN000;
;---------------------- 			;
Message_Number	= 5				; AN000;SM
Handle		= STDERR			; AN000;SM
Sublist 	= None				; AN000;SM
Count		= N_A				; AN000;SM
Class		= UTILITY_MSG_CLASS		; AN000;SM
Function	= NO_INPUT			; AN000;SM
Input		= N_A				; AN000;SM
	Define_Msg   dirmsg			; AN000;SM Warning - directory full	  ;AN000;
;---------------------- 			;
Message_Number	= 6				; AN000;SM
Handle		= STDERR			; AN000;SM
Sublist 	= None				; AN000;SM
Count		= N_A				; AN000;SM
Class		= UTILITY_MSG_CLASS		; AN000;SM
Function	= NO_INPUT			; AN000;SM
Input		= N_A				; AN000;SM
	Define_Msg   NotNetM			; AN000;SM Cannot recover a Network drive      ;AN000;
;---------------------- 			;
ifdef fsexec									;an022;bgb
 Message_Number  = 7				 ;			;an022;bgb
 Handle 	 = STDERR			 ;			;an022;bgb
 Sublist	 = Sublist_msg_EXECFailure	 ;			;an022;bgb
 Count		 = 1				 ;			;an022;bgb
 Class		 = UTILITY_MSG_CLASS		 ;			;an022;bgb
 Function	 = NO_INPUT			 ;			;an022;bgb
 Input		 = N_A				 ;			;an022;bgb
	 Define_Msg   MsgEXECFailure		 ;RECOVER not avail. on drive %1 ;AN022;bgb
endif								       ;an022;bgb
;---------------------- 			;
Message_Number	= 8				; AN000;SM
Handle		= STDout			; AN007;bgb
Sublist 	= Sublist_msg_recmsg		; AN000;SM
Count		= 1				; AN000;SM
Class		= UTILITY_MSG_CLASS		; AN000;SM
Function	= NO_INPUT			; AN000;SM
Input		= N_A				; AN000;SM
	Define_Msg   recmsg			; AN000;SM %1 file(s) recovered 	  ;AN000;
;---------------------- 			;
Message_Number	= 9				; AN000;SM
Handle		= STDout			; AN007;bgb
Sublist 	= Sublist_msg_ofmsg		; AN000;SM
Count		= 2				; AN000;SM
Class		= UTILITY_MSG_CLASS		; AN000;SM
Function	= NO_INPUT			; AN000;SM
Input		= N_A				; AN000;SM
	Define_Msg   ofmsg_ptr			; AN000;SM %1 of %2 bytes recovered	  ;AN000;
;---------------------- 			;
Message_Number	=  10				; AN000;bgb
Handle		= STDout			; AN007;bgb
Sublist 	= drive_sublist 		; AN000;bgb
Count		= 1				; AN000;SM
Class		= UTILITY_MSG_CLASS		; AN000;SM
Function	= NO_INPUT			; AN000;SM
Input		= N_A				; AN000;SM
	Define_Msg   askmsg			; AN000;SM Press any key...		  ;AN000;
;---------------------- 			;
Message_Number	= 11				; AN000;SM
Handle		= STDERR			; AN000;SM
Sublist 	= None				; AN000;SM
Count		= N_A				; AN000;SM
Class		= Utility_Msg_Class		; AN000;SM
Function	= NO_INPUT			; AN000;SM
Input		= N_A				; AN000;SM
	Define_Msg   FATerrRead 		; AN000;SM Can not read File allocation table(s)
;---------------------- 			;
Message_Number	= 12				; AN000;SM
Handle		= STDERR			; AN000;SM
Sublist 	= None				; AN000;SM
Count		= N_A				; AN000;SM
Class		= Utility_Msg_Class		; AN000;SM
Function	= NO_INPUT			; AN000;SM
Input		= N_A				; AN000;SM
	Define_Msg   FATerrWrite		; AN000;SM Can not write file allocation table(s)
;---------------------- 			;
Message_Number	= 13				; AN000;MT
Handle		= STDout			; AN000;MT
Sublist 	= None				; AN000;MT
Count		= N_A				; AN000;MT
Class		= Utility_Msg_Class		; AN000;MT
Function	= NO_INPUT			; AN000;MT
Input		= N_A				; AN000;MT
	Define_Msg   CRLF_Ptr			; AN000;MT CR,LF
;---------------------------			;
Message_Number	= 0				;				;AN000;
Handle		= STDERR			;				;AN000;
Sublist 	= None				;				;AN000;
Count		= N_A				;				;AN000;
Class		= Ext_Err_Class 		;				;AN000;
Function	= No_Input			;				;AN000;
Input		=N_A				;				;AN000;
	Define_Msg  Extended_Error_Msg		;				;AN000;
;---------------------------			;
;-----------------------							;an000;bgb
Message_Number	= 0				;				;an000;bgb
Handle		= STDERR			;				;an000;bgb;AN000;
Sublist 	= dg:sublist_msg_parserr	;				;an031;bgbbgb000;
Count		= 1				;				;an031;bgb;AN000;
Class		= Parse_Err_Class		;				;an000;bgb;AN000;
Function	= No_Function			;				;an000;bgb;AN000;
Input		= N_A				;				;an000;bgb;AN000;
	Define_Msg	Parse_Error_Msg 	;				;an000;bgb;AN000;
;---------------------- 			;
Message_Number	= 14				; AN013;bgb
Handle		= STDERR			; AN013;bgb
Sublist 	= None				; AN013;bgb
Count		= None				; AN013;bgb
Class		= utility_msg_class		; AN013;bgb
Function	= NO_INPUT			; AN013;bgb
Input		= N_A				; AN013;bgb
	Define_Msg   no_mem_arg 		; AN013;bgb insufficient memory
;---------------------- 			;
Message_Number	= MSG_OPTIONS_FIRST
Handle		= STDOUT
Sublist 	= None
Count		= None
Class		= utility_msg_class
Function	= NO_INPUT
Input		= N_A
	Define_Msg   options_msg

;---------------------- 			;
Message_Number	= DO_ALL_FILES
Handle		= STDOUT
Sublist 	= None
Count		= None
Class		= utility_msg_class
Function	= DOS_KEYB_INP
Input		= val
	Define_Msg   all_files_msg

;---------------------- 			;
Message_Number	= DO_WHOLE_DISK
Handle		= STDOUT
Sublist 	= None
Count		= None
Class		= utility_msg_class
Function	= DOS_KEYB_INP
Input		= val
	Define_Msg   whole_dsk_msg

;---------------------- 			;
Message_Number	= BAD_VER
Handle		= STDOUT
Sublist 	= None
Count		= None
Class		= utility_msg_class
Function	= NO_INPUT
Input		= N_A
	Define_Msg   bad_ver_msg

Data ends
;	extrn	Drive_Letter_Msg:Byte
;	extrn	FName_Buffer:Byte

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\recover\recover.asm ===
page	,132				;
TITLE	RECOVER.ASM - MS-DOS File/Disk Recovery Utility

;----------------------------------------------------------
;
; Recover - Program to rebuild an ms.dos directory
;
;	Microsoft Confidential
;	Copyright (C) Microsoft Corporation 1991
;	All Rights Reserved.
;
; HISTORY:
;	20-Aug-91 M001	Recover was using reserved field of FCB to get pointer
;			to SFT; the meaning of this field changed in DOS 5
;			when SHARE.EXE is not loaded. In DOS 5, there is no
;			need to update SFT when SHARE is not loaded; the SFT
;			is re-generated from the FCB for local non-shared
;			files.
;
;	20-Aug-91 M002	Fix problem adjusting size of recovered files.
;
;	20-Aug-91 M003	Fix 12-bit FAT trashing bug; when marking an even
;			cluster # as bad, Recover was corrupting the lowest
;			nibble of next cluster.
;
;-----------------------------------------------------------
.xlist
	include recchng.inc
	include recseg.inc
	INCLUDE DOSSYM.INC
	INCLUDE RECEQU.INC
	include curdir.inc		; recdata needs DIRSTRLEN def
	INCLUDE RECdata.INC
	INCLUDE recmacro.inc
	INCLUDE sysmsg.INC
	include pathmac.inc
	include version.inc
	include cpmfcb.inc
	include sf.inc
	include syscall.inc
	include dpb.inc
	include sysvar.inc
	msg_utilname<recover>
;										
;*****************************************************************************
; Extrn Declarations
;*****************************************************************************
data	segment public para 'DATA'
	extrn	Askmsg:Byte
	extrn   all_files_msg : byte
	extrn	whole_dsk_msg : byte
	extrn	val : byte
	extrn	Baddrv:Byte
	extrn	FatErrRead:Byte
	extrn	FATErrWrite:Byte
	extrn	Dirmsg:Byte
	extrn	RecMsg:Byte
	extrn	OpnErr:Byte
	extrn	no_mem_arg:word

	COLON	equ	':'
	SLASH	equ	'\'
        STAR	equ	'*'
        QMARK	equ	'?'

IFDEF WILDCARDS
  allfiles	db	"*.*"
ENDIF

chosexit	db	0
data	ends


;******************************************************************************
; Public entries
;******************************************************************************
code	segment public para 'code'
	pathlabl recover
public	GetFat, getsmall, getfat1, getret, SetFat, setsmall, f_exists		
public nofspec, kill_bl, endl, next_char
Public	Main_Routine

IFDEF DBCS
   public islead
   PUBLIC	notlead
   PUBLIC	dbcsmore
   PUBLIC	TESTKANJ
ENDIF


;PUBLIC  stop
public	setfat2, setfat1, setRet, GetKeystroke, Prompt, Load, ReadFt, WrtFat	
public	wrtit,	wrtok, fEOF, EOFok, printerr, SFFromFCB, Main_Routine
public	slashok, kill_bl, next_char, name_copied, sja, sjb, not_root		
public	same_drive, sj1, no_errors, same_dir, noname, drvok, See_If_File	
public	step2,	step3, step4, direrr, fill_dir, file_spec			
public	RecFil, recfil0, rexit1, int_23, rabort, rest_dir, no_fudge		
public	int_24, int_24_back, ireti, Read_File, Bad_File_Read, read_fats 	
public	fill_fat, rexit2, stop_read, calc_fat_addr	;M001: delete sfsize.
	EXTRN	Write_Disk:NEAR,Read_Disk:NEAR,report:NEAR			
	Extrn	Main_Init:Near
	Extrn	Change_Blanks:Near						
	Extrn	Build_String:Near
	extrn	seg_adj:near
	extrn	exitpgm:near						        
.list

;*****************************************************************************	
;   calc_fat_addr - calculate the seg/off of the fat cell from the cell number	
;										
;   Inputs:	AX the fat cell number						
;		BX the fat table offset
;		ES the fat table segment (same as program seg)			
;   Outputs:	BX contains the offset of the fat cell				
;		ES contains the segment of the fat cell 			
;										
; LARGE FAT SUPPORT								
;*******************								
; the offset into the fat table is cluster number times 2 (2 bytes per fat entry)
; This will result not only in the segment boundary being passed, but also in	
; a single-word math overflow.	  So, we calculate the the address as follows:	
; 0. start with cluster number (1-65535)					
; 1. divide by 8 to get the number of paragraphs per fat-cell  (0-8191) 	
;    remainder =					       (0-7)		
; 2. multiply the remainder by 2 to get offset in bytes        (0-15)		
; You now have a paragraph-offset number that you can use to calc the addr into 
; the fat table.  To get the physical addr you must add it to the offset of the 
; table in memory.								
; 3. add the paras to the segment register					
; 4. add the offset to the offset register					
;****************************************************************************** 
Procedure calc_fat_addr,near
    	savereg <ax,dx>		    	; ax already has cluster number
    	lea     bx,fattbl		; point to fat table in memory
    	call    seg_adj		    	; es:bx = es:00
    	mov     bx,0008h		; set up div by para (* 2 bytes per clus)
    	xor     dx,dx		    	; zero dx for word divide
    	div     bx			; do it
    	mov     bx,es		    	; get fat table segment
    	add     bx,ax		    	; add number of paras to the cluster
    	mov     es,bx		    	; move it back
    	shl     dx,1		    	; remainder times 2
	mov     bx,dx		    	; offset = 00 + remainder
	restorereg <dx,ax>
	return
EndProc calc_fat_addr



	break	<GetFat - return the contents of a fat entry>
;*****************************************************************************
;   GetFat - return the contents of a fat cell
;
;   Inputs:	AX the fat cell number
;   Outputs:	BX contains the contents of the fat cell AX
;		CX contains the number of bytes per sector
;   Registers Revised: SI
;
; pseudocode:
; ----------
;    if large-fat, then
;	double fat-number			 1, 2, 3, 4, 5, 6, 7, 8, 9, 10
;	fat-table offset = fat-num * 2		 2  4  6  8  10 12 14 16 18 20
;    else
;	fat-table offset = fat-num + (fat-num/2)
;
; LARGE FAT SUPPORT  - if this is a 16-bit fat, use the new calc algorithm
; *****************
;******************************************************************************
Procedure GetFat,NEAR
	set_data_segment
	lea	bx,fattbl		; point to fat table in memory		
	cmp	MaxClus,4086		; if (MaxClus >= 4086) {
	jnae 	getsmall
					; can now be 'FFFF'hex			
	call	calc_fat_addr		; set up div by para		
	mov	bx,word ptr es:[bx]	; get contents of fat		
	jmp 	short getret
getsmall:
	push    ax			; save fat-num   i = clus + clus/2
	mov     si,ax		    	; save fat-num
	sar     ax,1		    	; div by 2	 
	pushf			    	; save low bit
	add     si,ax		    	; clus + clus/2
	mov     bx,word ptr [bx][si]    ; b = b[i];
	popf			    	; get low bit
	jnc 	getfat1
	mov	cl,4			; b >>= 4;
	shr	bx,cl
getfat1:
	and 	bh,0fh	     		; even fat-num     b &= 0xFFF
	pop     ax
getret: mov	cx,secsiz		; c = SecSize
	return
EndProc GetFat


	break	<SetFat - change the contents of a fat element>
;*****************************************************************************
;   SetFat - given a fat index and a value, change the contents of the fat
;   cell to be the new value.
;
;   Inputs:	AX contains the fat cell to change
;		DX contains the new value to put into the fat cell
;   Outputs:	FAT [AX] = DX
;   Registers Revised: CX, SI
;
; LARGE FAT SUPPORT  - if this is a 16-bit fat, use the new calc algorithm
; *****************
;*****************************************************************************
Procedure SetFat,NEAR
	set_data_segment
	lea	bx,fattbl		; b = &Table; 		    
	cmp	MaxClus,4086 		; 12 bit fat?   if (MaxClus >= 4086)
	jnae 	setsmall
	call    calc_fat_addr	    	; calc the fat cell addr	    
	mov     word ptr es:[bx],dx     ; get the contents		    
	jmp 	short setret
setsmall:
	SaveReg <ax,dx>  		; yes, 12 bit fat
	mov     si,ax    		; fat cell num => i = clus + clus / 2
	sar     ax,1     		; fat cell num /2
	pushf	     			; save result if ax was odd
	add     si,ax    		; offset = 1 1/2 bytes * fat cell num
	mov     ax,word ptr [bx][si]    ; get contents of fat cell
	popf    			; get results from div  
	jnc	setfat2                 ; if ((clus&1) != 0)
	and	ax,000fh   		; yes,    keep unchanged part
	mov	cl,4			; d <<= 4;
	shl	dx,cl
	jmp 	short setfat1
setfat2:
	and	ax,0f000h		; no, even    keep unchanged part
	and	dx,0fffh		; M003: don't change high nibble.
setfat1:
	or 	ax,dx		   	; move new value into ax
	mov     word ptr [bx][si],ax    ; b[i] = a
	RestoreReg <dx,ax>
setret:
	return
EndProc SetFat


	Break	<GetKeystroke - await a single keystroke and flush all remaining>
;*****************************************************************************
;   GetKeystroke - let the user hit a key and flush the input buffer.  Kanji/
;   Taiwanese force this
;
;   Inputs:	None.
;   Outputs:	None.
;   Registers Revised: AX
;*****************************************************************************
Procedure GetKeystroke,NEAR
	mov	ax,(Std_CON_Input_Flush SHL 8) + Std_CON_Input_No_Echo
	int	21h
	mov	ax,(Std_CON_Input_Flush SHL 8) + 0
	int	21h
	return
EndProc GetKeystroke


;*****************************************************************************
;PROMPT
;*****************************************************************************
Procedure Prompt,NEAR
	cmp	Prompted,0
	retnz
	mov	Prompted,1
	push	ds
	push	cs
; move drive letter in message
	lea	dx,askmsg	 
; display msg
	call	display_interface
	pop	ax		 
	pop	ds
; wait for user
	call	GetKeystroke

	mov     al,cs:DRIVE 		; This is for ibm's single drive sys
	cmp     al,1
	ja	NOSET			; Values other than 0,1 not appropriate.
	push    ds
	mov     bx,50h
	mov     ds,bx
	mov     ds:(byte ptr 4),al	; Indicate drive changed
	pop     ds
NOSET:
	return
EndProc Prompt


	Break	<Load	- set up registers for abs sector read/write>
;******************************************************************************
;   Load - load up all registers for absolute sector read/write of FAT
;
; called by: readft, writeft
;
;   Inputs:	none.
;   Outputs:	AL    - drive number (a=0)
;		ES:BX - point to FAT table				    
;		CX    - number of sectors in FAT
;		DX    - sector number of the first FAT sector
;		FatCnt - is set to the number of fats
;   Registers Revised: ax, dx, cx, bx
;******************************************************************************
Procedure Load,NEAR
	set_data_segment						    
	mov	dx,firfat		; sector number of first fat 1-65535
	mov	al,fatnum		; number of fats 	     2	    
	mov	fatcnt,al		; FatCnt = FatNum 	     1-65535 
	mov	al,drive		; drive number		     a=0 b=1 
	mov	cx,fatsiz		; sectors in the fat	     1-65535
	lea	bx,fattbl		; es:bx --> fat table		    
	return
EndProc Load


	Break	<ReadFT - read in the entire fat>
;******************************************************************************
;   ReadFt - attempt to read in the fat.  If there are errors, step to
;   successive fats until no more.
;
;   Inputs:	none.
;   Outputs:	Fats are read until one succeeds.
;		Carry set indicates no Fat could be read.
;   Registers Revised: all
; LOGIC
; *****
;  DO for each of the fats on the disk:
;     read - all the sectors in the fat
;     increase the starting sector by the number of sectors in each fat
;
; LARGE FAT SUPPORT - the big change here is in read disk.  since the fat must
;     be within the first 32M, then the starting sector number of 65535 is ok,
;     as is a larger number of sectors to read/write.
;******************************************************************************
Procedure ReadFt,NEAR
	set_data_segment							
	mov	dx,firfat		; sector number of first fat 1-65535	
	mov	al,fatnum		; number of fats 	     2		
	mov	fatcnt,al		; FatCnt = FatNum;	     1-65535	
	mov	al,drive		; drive number		     a=0 b=1	
	mov	cx,fatsiz		; sectors in the fat	     1-65535	
	lea	bx,fattbl		; es:bx --> fat table			
	clc				; clear carry flag
	mov	Read_Write_Relative.Start_Sector_High,bp  ; set hi word to zero
	call	Read_Disk		; read in fat #1		
	jnc 	$$IF12
	add     dx,cx			; point to 2nd fat
	call    Read_Disk		; read in 2nd fat		
$$IF12:
	ret									
EndProc ReadFt



	Break	<WrtFat - write out the fat>
;*****************************************************************************
;   WrtFat - using the results of a ReadFt, attempt to write out the fat
;   until successful.
;
;   Inputs:	none.
;   Outputs:	A write of the fat is attempted in each fat position until
;		one succeeds.
;   Registers Revised: all
; LOGIC
; *****
;    DO for each fat on the disk
;	write the fat to disk
;	increase the starting sector number by the number of sectors per fat
;
; LARGE FAT SUPPORT - the big change here is in read disk.  since the fat must	
;     be within the first 32M, then the starting sector number of 65535 is ok,	
;     as is a larger number of sectors to read/write.				
;****************************************************************************
Procedure WrtFat,NEAR
	call	load			; load ();				
					; do
wrtit:	call    Write_Disk		;   Write_Disk ();		
	jc 	$$EN14
wrtok:	add     dx,cx		    	;   fatStart += fatsize;        
	dec     byte ptr fatcnt	    	; } while (--fatcnt);		
	jnz 	wrtit
$$EN14:
	return
EndProc WrtFat



	Break	<fEOF	- check to see if the argument is EOF>
;*****************************************************************************
;   fEOF - test BX to see if it indicates EOF
;
;   Inputs:	BX - contains cluster
;   Outputs:	Carry is set if BX indicates EOF
;   Registers Revised: none
;*****************************************************************************
Procedure fEOF,NEAR
	cmp     bx,MaxClus
	jbe	EOFok
	cmp	bl,0f7h 		; bad sector indicator
	jz	EOFok
	stc
	return
EOFok:	clc
	return
EndProc fEOF


;*****************************************************************************
;*****************************************************************************


	Break	<SFFromFCB - take an FCB and convert it to a sf pointer>
;*****************************************************************************
; SFFromFCB - index into System File tables for SFN.
;
;   Input:	ES:DI has FCB pointer
;   Output:	ES:DI points to Sys-File-table entry
;   Registers Revised: ES:DI, BX only
;
;*****************************************************************************
procedure SFFromFCB,NEAR
	mov	bl,es:[di].FCB_SFN 	; fcb+18 = system file table 00
	xor	bh,bh		   	; 00
	SaveReg <ax,bx>
	mov	ah,Get_IN_Vars		; 52h
	int	21h			; p = DOSBASE();
					; bx = 0026, ax=5200 es=0257
	les	di,dword ptr es:[bx].SYSI_FCB  ; load es:di w/ ptr to sf table
					; es:di = 0b37:0000
	lea	di,[di].sfTable 	; di=6
	RestoreReg <bx>
	SaveReg <dx>
	mov	ax,size SF_Entry	; 42
	mul	bx			; 0
	add	di,ax			; 6
	RestoreReg <dx,ax>
	return				; return p
EndProc SFFromFCB

;*****************************************************************************
;*****************************************************************************
Procedure get_dpb_info,Near
; get dpb for drive indicated
	push	ds			; save ds seg reg
	mov	dl,drive		; get drive number a=0 b=1 c=2		
	inc	dl			; a=1, b=2, c=3
	mov	ah,GET_DPB		; hidden system call (032h)
	int	21h			; call dos
; note: ds is now changed !!!!
	cmp	al,0FFH 		; -1 = bad return code
	jz	$$IF17
; get sector size
	mov     ax,word ptr [bx].dpb_sector_size  ; get physical sector size
	mov     es:bytes_per_sector,ax 	; save bytes per sector 200		
; get sectors per cluster
	xor     ch,ch			; zero out high byte
	mov     cl,byte ptr [bx].dpb_cluster_mask ; get sectors/cluster - 1
	inc     cx			; 1+1=2	; get sectors / cluster
	mov     es:secall,cx		; 2	; save sectors per cluster		
; get bytes per cluster
	mul     cx			; ax = bytes per cluster
	mov     eS:secsiz,ax		; 400	; save bytes per cluster		
; first sector record
	mov     ax,[bx].dpb_first_sector ; get record of first sector
	mov     es:firrec,ax		; c
; first dir entry
	mov     dx,[bx].dpb_dir_sector 	; get record of first directory entry
	mov     es:firdir,dx		; 5
; first fat record
	mov     si,[bx].dpb_first_fat 	; get record of first fat
	mov     es:firfat,si		; 1    	; sector number of first fat		
; records in fat
	mov     cX,[bx].dpb_fat_size 	; get size of fat (num of rcds)
	mov     es:fatsiz,cX		; 2	; SIZE OF FAT FROM DPB 
; number of cluster
	mov     di,[bx].dpb_max_cluster ; get number of clusters
	mov     es:lastfat,di		; 163	; number of fat entries		
	mov     es:MaxClus,di		; 163	; number of fat entries		
; number of fats (1 or 2)
	mov     ch,[bx].dpb_fat_count 	; get number of fats on drive
	mov     byte ptr es:fatnum,ch 	; 2	; save number of fats on disk	    
; max dir entries
	mov     bx,[bx].dpb_root_entries ; get max number of dir entries
	mov     es:maxent,bx		; 70
	pop     ds			; restore ds register to group		  
	jmp 	short $$EN17
$$IF17:
	pop     ds			; restore ds register to group		   
	jmp     noname			; bad return = display error msg
$$EN17:
	ret
endproc get_dpb_info



;*****************************************************************************
; assemble this part if doing japanese version
;
;INPUTS:  es:di - points to last char in filename
;	  ds:dx - point to beginning of filename
;
;*****************************************************************************
Procedure check_kanji,Near		
IFDEF	DBCS
	lea     dx,[fname_buffer]	; point to filename 
	PUSH    DX			; save regs
	PUSH    DI			; save regs
	MOV     BX,DI			; bx and di now point to last char in filename
	MOV     DI,DX			; di now points to filename

;do for entrire filename
delloop:
	CMP     DI,BX			; at the beginning of the filename?
	JAE     GOTDELE			; yes, and we are finished
	MOV     AL,[DI]			; get next char in filename
	INC     DI			; point one past it
	CALL    TESTKANJ		; see if it is dbcs
	JZ	NOTKANJ11
	INC     DI			; bump to past 2nd of dbcs pair
	JMP     DELLOOP			; check next char in file name

notkanj11:
	cmp     al,[dirchar]		; is it '\' ?
	JNZ     DELLOOP			; no, check next char
	MOV     DX,DI			; Point to char after '/'
	DEC     DX
	DEC     DX			; Point to char before '/'
	JMP     DELLOOP

;completed filename
gotdele:
	MOV     DI,DX ;point to?
	POP     AX			; Initial DI
	POP     DX	  		; re-point to beginning of filename
	SUB     AX,DI			; Distance moved
	SUB     CX,AX			; Set correct CX
	MOV     AX,[DI]							
	CALL    TESTKANJ							
	JNZ     same_dirjk							
    	XCHG    AH,AL							
same_dirjk:
	ret 						
ENDIF
	ret
check_kanji endp


;****************************************************************************
;****************************************************************************
	break
IFDEF	DBCS
TESTKANJ:
	push    ds		 	; get dbcs vector
	push    si
	push    ax
	mov     ax,6300h	 	; get dbcs vector				
	int     21h 							
	pop     ax								
	sub     si,2	 		; prep for loop 				
dbcsmore:									
	add     si,2			; point to next dbcs vector		
	cmp     word ptr ds:[SI],bp 	; do until 00 found in dbcs vector table 
	je	notlead			; 00 found, quit 			
	CMP     AL,byte ptr ds:[si] 	; look at lead byte of dbcs char 	
	jb	dbcsmore		; al < lead byte means not dbcs		
	CMP     al,byte ptr ds:[si+1] 	; look at 2nd byte of dbcs		
	JBE     ISLEAD  		; if it's between the 2 chars, it's dbcs		
	jmp     dbcsmore	 	; go get the next dbcs vector			

NOTLEAD:
	PUSH    AX
	XOR     AX,AX			; Set zero
	POP     AX
	pop     si
	pop     ds
	RET
ISLEAD:
	mov     es:dbcs_sw,1						
	PUSH    AX
	XOR     AX,AX			; Set zero
	INC     AX			; Reset zero
	POP     AX
	pop     si
	pop     ds
	RET
ENDIF


;*****************************************************************************
; copy the filename from the fcb to the data segment			      
;*****************************************************************************
Procedure copy_fname,Near
;get fcb1 from the psp
slashok:
	mov	 cx,PSP_Segment 	; Get addressability of psp 	
	mov	ds,cx			;  "       "          "  "		
	assume	ds:dg,es:dg		;  "       "          "  "		
	call	get_fcb

; remove leading blanks and tabs from filename
nofspec:
	mov	si,81h 		 	; point to command line	
	lea	di,fname_buffer 	; point to filename		
	xor	cx,cx			; zero pathname length
; get source chars until neither tabs or blanks found
kill_bl:
	lodsb				; get next char 		
	cmp     al,tab			; leading tabs? (hex 9) 	
	je 	$$LL21
	cmp     al,' '			; leading blanks? (hex 20)	
	jne 	$$EN20
$$LL21:
	jmp 	short kill_bl
$$EN20:

;was any parameter entered at all?
endl:	cmp	al,13			; no name found if the 1st char is CR
	jne	next_char		; file name or drive entered
	jmp	noname			; no parameter entered


;copy filename from cmd line to fname buffer
next_char:
	stosb				; move byte in al to fname_buffer
	inc	cx			; inc fname counter
	lodsb				; get next byte
	cmp	al,' '			; terminated by blank?
	je	name_copied		; yes
	cmp	al,9			; terminated by tab?
	je	name_copied		; yes
	cmp	al,13			; terminated by CR?
	jne	next_char		; yes


;reset ds to data segment
name_copied:				; got file name
	push	es
	pop	ds			; ds now points to data seg
	assume	ds:dg

	push	ax
	push	bx
	push	cx
	push	dx
	push	si
	push	di
	push	es

IFDEF WILDCARD
; set es:di -> end of file name
        cld
	mov  	cx,  128		; fname_buffer is 128 byte max
	les	di,  fbptr
	mov	al,  0			; look for end of string
	repne	scasb   

	dec	di
	dec	di
	mov	si,  OFFSET  allfiles	; allfiles = "*.*"
	add	si,  2
	std
	mov	cx, 3
	repe	cmpsb
	cld				; reset direction flag
	jnz	checkdrive		; filename didn't end in *.*

; if we reached the start of string, it WAS *.*
	cmp	di, OFFSET fname_buffer - 1  ; di will have gone 1 too far
	je	doask

; else, as long as the byte preceding *.* is not ':' or '\', we are still ok
 	cmp	byte ptr [di], COLON
	je	doask
	cmp	byte ptr [di], SLASH
	jne	checkdrive

; otherwise print out message "are you sure you want to do this ?"
doask:	lea	dx, all_files_msg
	call	display_interface
	jmp	short getans

ELSE
; check for wildcards in filename - if found, print message and exit.
	lea	di, fname_buffer	; point at filename buffer

wcloop: cmp	byte ptr [di], STAR	; look for '*' wildcard
        je	wcfnd
        cmp	byte ptr [di], QMARK	; look for '?' wildcard
        je	wcfnd
        cmp	byte ptr [di], 0	; see if end of name marker
        je 	checkdrive              ; if yes, then move on
        inc	di                      ; else, increment pointer and
        jmp	wcloop			; loop

; display error message and exit
wcfnd:
	lea     di,fname_buffer		; point at buffer
	lea	dx, opnerr		; display file open error
        call	display_interface
        jmp	short setxit            ; exit
ENDIF

checkdrive:
	mov	di,  OFFSET es:fname_buffer
	cmp	byte  ptr [di + 1], COLON
	jne	resto
	cmp	byte  ptr [di + 2], 0
	jne	resto
	lea	dx, whole_dsk_msg
	call	display_interface

; if we got a Yes, keep going.  otherwise get out
getans:	lea	dx, val
	mov	di, dx
	mov	dl, byte ptr [di]
	mov	ax, 6523h
	int	21h
        cmp 	ax, 1
	je	resto

setxit: mov	chosexit, 1

resto:	pop	es
	pop	di
	pop	si
	pop	dx
	pop	cx
	pop	bx
	pop	ax

	mov	byte ptr [di],0 	; nul terminate the pathname
	dec	di			; adjust to the end of the pathname
	ret 							
copy_fname  endp


;*****************************************************************************
; get a copy of the fcb 						      
;*****************************************************************************
Procedure get_fcb,Near
	mov	si,fcb			; ds:si point to fcb in the psp       
	lea	di,fcb_copy		; es:di point to the copy in the data seg
	mov	cx,32			; move 32 bytes 		
	rep	movsb			; from ds:si (fcb) to es:di (fcb-copy)	 
;now get the filename from the command line					
; step 1 - point to end of cmd line						
	mov     si,081h			; point to beginning of command line	
	mov     cl,byte ptr ds:[80h] 	; get length of cmd line		
	xor     ch,ch			; zero out hi byte for word arith	
	add     si,cx			; begin plus length of cmd line = end	
	dec     si			; point to last char, not CR		
;step 2 - find the first backslash						
	mov     exit_sw,bp 		; false						
$$DO23:
	cmp	byte ptr ds:[si],'\'	; look for back slash		
	jne 	$$IF24
	mov     al,[si-1]		; get possible leading byte		
IFDEF DBCS
	call    testkanj		; is it a leading byte of DBCS?		
ENDIF
	jnz 	$$IF25
	mov 	exit_sw,true   		; so exit the search loop		
	jmp	short $$IF24
$$IF25:
	dec	si			; so skip the leading byte		
$$IF24:
	cmp	exit_sw,true						
	je 	$$EN23
	cmp	byte ptr ds:[si],0	; look for 00 (not a filespec)	
	jne 	$$IF30
	ret 							
$$IF30:
	dec	si			; no , next char 			
	jmp 	short $$DO23
$$EN23:
; found backslash, move it into fcb
	inc     si			; point to 1st char of filename		
	lea     di,fcb_copy+1	    	; move addr of fcb_copy into di	
; do until eol - CR found		
$$DO33:
	lodsb				; get one byte of filename from cmd line 
	cmp	al,0dh			; end of line?				
	je 	$$EN33
	cmp	al,'.'			; is it extension indicator?		
	jne 	$$IF35
	lea     di,fcb_copy 		; point to extension in fcb		
	add     di,9			; point to extension in fcb		
	jmp 	short $$EN35
$$IF35:
	stosb				; move char into fcb			
$$EN35:
	jmp 	short $$DO33
$$EN33:
	ret 								
get_fcb  endp
										
										

	Break	<Main	code of recover - Version check and exit if incorrect>
;*****************************************************************************
;Routine name:	Main_routine
;*****************************************************************************
;
;description: Main routine for recovering a file from a bad sector
;
;Called from:	recover_ifs in RECINIT.SAL
;
;
;Called Procedures: prompt
;		    readft
;		    read_file
;		    getfat (sic)
;		    feof
;			 SFFromFCB
;		    bad-file-read
;		    report
;		    wrtfat
;		    stdprintf
;		    RECPROC.SAL
;
;Input: ????
;
;Output: FAT is changed if a bad sector is found.
;	 The file is complete except for the data in the bad sector.
;
;*****************************************************************************
Main_Routine:

;get system switch character
	xor	bp,bp
	set_data_segment		; set es,ds to data			
	mov	ax,(char_oper shl 8)	; get switch character
	int	21h			; put into dl
	cmp	dl,"/"			; is it / ?
	jz 	$$IF39
	jmp     slashok		    	; if not / , then not PC
$$IF39:
	mov	[dirchar],"\"	     	; in PC, dir separator = \
	mov	[userdir],"\"

	call	copy_fname
	cmp	chosexit, 1          	; are we getting out ?
	jne	skip3
	jmp	int_23 		     	; yes, just reset int vectors

;check for dbcs double byte chars
skip3:	push	di								
	push	cx								
	call	check_kanji
same_dirj:
	pop	cx							  
	pop	di							  
	mov	lastchar,di


;see if there are any '\' in filename parameter - means filespec		
;do until a \ is found or end-of-string 					
;	  if a \ is found							
;	     then test for dbcs leading byte					
;		  if it is not dbcs leading byte				
;		     then exit loop						
;		     else continue loop 					
$$DO41:
	dec	cx
	and	cx,cx			; compare cx to zero
	je 	$$EN41
	mov	al,[dirchar]	    	; 05ch   get directory separator char
	cmp	al,byte ptr [di]    	; (cx has the pathname length)		
	jne 	$$IF43
	mov     al,[di-1]	    	; get possible leading byte			
IFDEF DBCS
	call    testkanj     		; see if it is leading byte			
ENDIF
	jnz 	$$IF43
	mov 	lastbs,di							
	mov 	di,lastchar 						
	jmp 	short sja     		; zero = not a leading byte			
$$IF43:
	dec	di								
    	jmp	short $$DO41
$$EN41:
;save current disk								
	mov	ah,19h								
	int	21h								
	mov	old_drive,al							
	jmp	short same_dir		; no dir separator char. found, the
					; file is in the current directory
					; of the corresponding drive. Ergo,
					; the FCB contains the data already.

;handle filespec here
;at least one '\' found in filename
sja:
	jcxz	sjb			; no more chars left, it refers to root
	push	di								
	mov	di,lastbs							
	cmp	byte ptr [di-1],':'	; is the prvious character a disk def?
	pop	di								
	jne	not_root
sjb:
	mov	[the_root],01h		; file is in the root
not_root:
	inc	di			; point to dir separator char.
	mov	ax,bp 			; set to zero
	stosb				; nul terminate directory name
	mov	[fudge],01h		; remember that the current directory
					; has been changed.
;save current disk								
	mov	ah,19h								
	int	21h								
	mov	old_drive,al							
;----- Save current directory for exit ---------------------------------;
	mov	dl, drive		; get specified drive if any
	mov	ah,set_default_drive	; change disks
	int	21h

same_drive:
	call	prompt
	mov	ah,Current_Dir		; userdir = current directory string
	mov	dx,bp 			; set to zero
	lea	si,userdir+1
	int	21h

;----- Change directories ----------------------------------------------;
	cmp	[the_root],01h
	lea	dx,[dirchar]		; assume the root			
	je	sj1
	lea	dx,[fname_buffer]
sj1:
	push	di								
	mov	di,lastbs							
	mov	byte ptr [di],0 					
	mov	ah,chdir		; change directory
	int	21h
	mov	byte ptr [di],'\'						
	pop	di								
	mov	al,Drive		; Get drive number		
	add	al,"A"-1		; Make it drive letter		
	mov	Drive_Letter_Msg,al	; Put in message 		
	lea	dx,baddrv
	jnc	no_errors
	call	printerr
	jmp	rabort

no_errors:

	Break	<Set	up exception handlers>

;----- Parse filename to FCB -------------------------------------------;
	mov	si,lastbs							
	inc	si								
	lea	di,fcb_copy
	mov	ax,(parse_file_descriptor shl 8) or 1
	int	21h
;-----------------------------------------------------------------------;
same_dir:
	lea	bx,fcb_copy		; point to 1st byte of fcb (drive num)  
	cmp	byte ptr [bx+1],' '	; must specify file name
	jnz	drvok
	cmp	byte ptr [bx],0 	; or drive specifier
	jnz	drvok
	cmp	dbcs_sw,1		; or dbcs				
	jz	drvok								
noname:
	push	es
	pop	ds
	lea	dx,baddrv 
	call	display_interface
	pop	ax		 	; reset stack					
	pop	ax		 	; reset stack					
	jmp	short int_23
;****************************************************************************
; we're finished with parsing here, do the main function of recover.
drvok:
	call	Prompt			; wait for user keystroke to begin
	call	get_dpb_info		; get device info		 
	call	fill_fat		; fill fat table w/ null	 
	jnc	$$IF48
	lea     dx,no_mem_arg
	call    printerr							
	jmp     short rabort						
$$IF48:
	call	readft			; readft ();			  
	jnc	See_If_File
	lea     dx,FATErrRead
	call    printerr
	jmp     short rabort

See_If_File:
	lea	bx,fname_buffer
	cmp	byte ptr [bx+1],':'	; if fname = 'a:' and.....		
	jne	$$IF52
	cmp	word ptr [bx+2],bp 	; set to zero; all zeros following that,
	jne	$$IF52
	call    drive_spec		; then only drive specified
	jmp	short int_23
$$IF52:
	call    file_spec 		; file can be 'f' or 'a:,0,file' or
        				; 'a:file' or 'file.ext' 

int_23: sti				; allow interrupts    
	lds	dx,cs:dword ptr [int_24_old_off]     ; point to old vector	
	mov	al,24h			; which interrupt to set?		
	DOS_Call Set_Interrupt_Vector	; set vector to old			

	lds	dx,cs:dword ptr [int_23_old_off]     ; point to old vector	
	mov	al,23h			; which interrupt to set?		
	DOS_Call Set_Interrupt_Vector	; set vector to old			

	push	cs			; reset ds				
	pop	ds								
	assume	ds:dg
	cmp	chosexit, 1
	je	getout
	call	rest_dir
										
getout:	mov	cs:ExitStatus,0 	; good return			
	jmp	[exitpgm]						        
rabort:
	ret				; Return to RECINIT for exit		


;*************************************************************************
; DO until either
;*************************************************************************
procedure file_spec,near
; try to open the file
recfil: lea	dx,fcb_copy		; if (FCBOpen (FCB) == -1) {		
	mov	ah,FCB_OPEN   		; function ofh = open
	int	21h			; returns -1 in al if bad open
	cmp	al,0ffh 		; was file opened ok?
	jne	f_exists
; display error msg
	lea     si,FCB_Copy.fcb_name 	; Point at filename in FCB
	lea     di,Fname_Buffer		; Point at buffer
	mov     cx,FCB_Filename_Length 	; Length of filename		  
	call    Change_Blanks	 	; Convert DBCS blanks to SBCS	
	call    Build_String		; Build ASCIIZ string ending	
	lea     dx,opnerr		; printf (Can't open);    
	call    display_interface
recfil0:
	jmp	short $$EN55
f_exists:
	call    process_file		; file was opend ok
rexit1: mov     ah,DISK_RESET
	int     21h
	call    wrtfat			; save the fat
	jnc	$$IF57
	lea	dx,FATErrWrite		; Just tell user he is in deep!		
	call	display_interface
	jmp	short $$EN55
$$IF57:
	call	report		        ; report ();              
$$EN55:
	ret	  
endproc file_spec 

;*************************************************************************
; DO until either
;*************************************************************************
Procedure process_file,Near
recfile0:
    	mov     lastfat,1		; set to 1 : means 1st fat read in
    	lea     di,fcb_copy 		; d = &FCB				
    	mov     ax,[di].FCB_FilSiz	; 55    siztmp = filsiz = d->filsiz;
    	mov     filsiz,ax
    	mov     siztmp,ax
    	mov     ax,[di].FCB_FilSiz+2	; 00
    	mov     filsiz+2,ax
	mov	siztmp+2,ax
						;M001 begin.
	test	es:[di].fcb_nsl_drive,FCBMASK	; Local, non-shared file?
	jnz	rf20				;  No, jump.

	mov	ax,es:[di].fcb_nsl_firclus	; AX = first file cluster.
	jmp	short rf40

rf20:	SaveReg <ES,DI>
	call	SFFromFCB			; ES:DI -> SFT
	mov	ax,ES:[DI].sf_firclus		; AX = first file cluster
	RestoreReg <DI,ES>

rf40:	mov	fatptr,ax			;M001 end.
   	or	ax,ax			; if (fatptr == 0)
    	jz	$$EN62
; read each fat in the file
; Loop until entire file read in 
$$DO62:
	mov     bx,fatptr		; Get current cluster
	call    fEOF			; Got to the end of the file?
	jc	$$EN62
STOP_read:
	call	Read_File		; Go read in the cluster
	jnc	$$IF64
	call    Bad_File_Read   	; Go play in the FAT
	jmp	short $$EN64
$$IF64:
	mov	ax,secsiz		; Get bytes/cluster
	sub	siztmp,ax		; Is size left < 1 cluster?
	sbb	siztmp+2,bp ;zero
	jnc	$$IF66
	xor     ax,ax			; Set our running count to 0
	mov     siztmp,ax
	mov     siztmp+2,ax
$$IF66:
	mov	ax,fatptr		; The previous cluster is now
	mov	lastfat,ax		; the current cluster
$$EN64:
	call    getfat			; Get the next cluster
	mov     fatptr,bx		; Save it
	jmp	short $$DO62
$$EN62:
	lea     dx,fcb_copy 		; close (FCB);		
	mov     ah,FCB_CLOSE
	int     21h 			
	return				
endproc process_file			

;*************************************************************************
;***************************************************************************
	break
;----- Restore INT 24 vector and old current directory -----------------;
Procedure Rest_dir,Near
	cmp	cs:[fudge],0
	je	no_fudge
	mov     ax,(set_interrupt_vector shl 8) or 24h
	lds     dx,cs:[hardch]
	int     21h
	push    cs
	pop     ds
	lea     dx,userdir		; restore directory
	mov     ah,chdir
	int     21h
no_fudge:
	mov	dl,old_drive		; restore old current drive    
	mov	ah,set_default_drive
	int	21h
	ret
endproc rest_dir

;;----- INT 24 Processing -----------------------------------------------;
;*************************************************************************
	int_24_retaddr dw int_24_back

	int_24	proc	far
	assume	ds:nothing,es:nothing,ss:nothing
	pushf				; ** MAKE CHANGES **
	push	cs
	push	[int_24_retaddr]
	push	word ptr [hardch+2]
	push	word ptr [hardch]
	assume	ds:dg,es:dg,ss:dg
	ret
endproc int_24
;*************************************************************************
int_24_back:
	cmp	al,2			; abort?
	jnz	ireti
	push	cs
	pop	ds
	assume	ds:dg,es:dg,ss:dg
	call	rest_dir
	ret				; Ret for common exit
ireti:
	iret

	break	< read in a cluster of the file>
;****************************************************************************
; READ_FILE
;Read in cluster of file.
;
; Input: Secall = sectors/cluster
;	 FatPtr = cluster to read
;	 Firrec = Start of data area - always in first 32mb of partition
;	 dx	= offset of fcb_copy ???
;
; Output: CY set if error on read on ret
;	  ES:DI = pointer to FCB (fcb_copy)
;*****************************************************************************
Procedure Read_File,Near
	mov	cx,secall   ; 2		; if (aread((fatptr-2)*secall+firrec) == -1) {
	mov	ax,fatptr   ; 84 	; cluster number to read
	sub	ax,2	    ; ax=82	; -1 
	mul	cx	    ; ax=104	; sectors/clus * (clus-2)
	add	ax,firrec   ; ax=110	; plus beg of data area
	adc	dx,bp	    ; 0		; Handle high word of sector
	mov	Read_Write_Relative.Start_Sector_High,dx   ; Start sector
	mov	dx,ax	    ; 110	; clus-2
	mov	es,table    ; 2b62	; segment of area past fat table
	xor	bx,bx			; es:bx --> dir/file area       
	mov	al,drive    ; 0		; drive num
	call	Read_Disk		
	lea	di,fcb_copy		
	ret				
endproc Read_File			


	break	< found a bad cluster in the file >
;*************************************************************************
;Play around with the FAT cluster chain, by marking the cluster that failed
;to read as bad. Then point the preceding cluster at the one following it.
;Special case if there is only one cluster, than file gets set to zero
;length with no space allocated.
;
; Input: FatPtr = Cluster that failed to read
;	 LastFat = Previous cluster, equals 1 if first cluster
;	 ES:DI -> fcb_copy
;
; Output: AX = previous cluster
;	  File size = file size - cluster size ( = 0 if cluster size > file)
;***************************************************************************
Procedure Bad_File_Read,Near
	mov	ax,fatptr		; Get current cluster
	call	getfat			; Get the next cluster in BX
	cmp	lastfat,1		; Is this the first entry?
	jne	$$IF73
	call    fEOF			; Is the next the last cluster?
	jnc	$$IF74
	xor	bx,bx			; Need to zero out first cluster

						;M001 begin.
$$IF74:	test	es:[di].fcb_nsl_drive,FCBMASK	; Local, non-shared file?
	jnz	bfr20				;  No, jump.

	mov	es:[di].fcb_nsl_firclus,bx	; Make next cluster the first.
	jmp	short $$EN73

bfr20:	SaveReg	<ES,DI,BX>			;M001 end.
	call	SFFromFCB			; ES:DI -> SFT
	RestoreReg <BX>				; BX = cluster
	mov	ES:[DI].sf_firclus,BX		; Make next cluster the first.
	RestoreReg <DI,ES>
	mov	es:[di].fcb_l_firclus,bx	;M001: Make next cluster the first.
	jmp	short $$EN73

$$IF73:
	mov     dx,bx			; DX = next cluster
	mov     ax,lastfat		; AX = Previous cluster
	call    setfat			; prev fat points to next fat
					; offending cluster
$$EN73:
	mov	ax,fatptr		; Get the offending cluster
	mov	dx,0fff7h		; Mark it bad
	call	setfat			; Never use it again!
	mov	ax,secsiz		; Get bytes/sector
	cmp	siztmp+2,bp		; M002: Is file size > 64 KB?
	jne	$$IF78			; M002:  Yes, jump.
	cmp	siztmp,ax		; Shorter than cluster size?
	jnbe	$$IF78
	mov	  ax,siztmp		; File size = smaller of the two

						;M001 begin.
$$IF78:	test	es:[di].fcb_nsl_drive,FCBMASK	; Local, non-shared file?
	jnz	bfr40				;  No, jump.

	and	byte ptr es:[di].fcb_nsl_bits,NOT devid_file_clean ; Mark file dirty
	jmp	short bfr60

bfr40:	SaveReg <ES,DI>
	call	SFFromFCB			; ES:[DI] -> SFT
	sub	word ptr ES:[di].sf_size,ax	; Adjust file size in SFT
	sbb	word ptr ES:[di].sf_size+2,bp
	and	ES:[di].sf_flags,NOT devid_file_clean ; Mark file dirty
	RestoreReg <DI,ES>
bfr60:	sub	word ptr es:[di].fcb_filsiz,ax	 ; Adjust file size in FCB
	sbb	word ptr es:[di].fcb_filsiz+2,bp ;M001 end.
	sub	siztmp,ax		; Keep track of how much done
	sbb	siztmp+2,bp		; M002: Borrow from most sig. word
	mov	ax,lastfat		; AX = previous cluster
	ret
endproc Bad_File_Read


;*****************************************************************************	
; description: fill the fat table in memory with the 'E5' character		
;										
; called from: main-routine							
;										
;Input: bytes-per-sector							
;	fatsiz									
;	maxent									
;										
;Output: ram-based fat table							
;										
; LOGIC 									
;----------									
;	calc number of para in fat table					
;	    = bytes-per-sector / 16 * sectors-per-fat				
;	calc segment of directory area in memory				
;	    = fat-table offset + length of fat-table				
;	calc number of para in directory					
;	    = entries-per-directory * bytes-per-entry / 16			
;	do for each para							
;	   move 16 bytes into memory						
;*****************************************************************************	
	  even
Procedure fill_fat,Near
; calc fat table length 							
	set_data_segment							
	mov	ax,bytes_per_sector	; bytes per sector			
	xor	dx,dx								
	mov	bx,16								
	div	bx			; paras per sector			
	mov	cx,fatsiz		; 2     get sectors per fat	
	xor	dx,dx								
	mul	cx			; paras per fat 			
	mov	paras_per_fat,ax	; length of fat in paragraphs		
; calc dir area addr								
	mov	bx,es
	add	ax,bx			; seg of dir area			
	mov	es,ax
	lea	bx,fattbl		; off					
	call	seg_adj 		; seg:off = seg:0000			
	mov	table,es		; segment of beginning of fat table	
; calc dir area length								
	mov	ax,maxent		; ax= max dir entries			
	mov	bx,32			; 32 bytes per dir entry		
	xor	dx,dx								
	mul	bx			; bytes per dir 			
	xor	dx,dx			; zero out for divide			
	mov	bx,16			; divide by bytes per para		
	div	bx			; paras per dir				
; calc total length to fill							
	add	ax,paras_per_fat 	; paras/fat + paras/dir = total paras		
; see if we have enough memory							
    	push    ax									
    	push    ds			; save ds reg				
    	mov     bx,es
    	add     ax,bx			; add in starting seg of fat table	
    	inc     ax			; one more to go past our area		
    	DOS_Call GetCurrentPSP		; Get PSP segment address		
    	mov     ds,bx			; ds points to the psp			
    	assume  ds:Nothing		; point to psp				
    	mov	dx,ds:[2]		; get the last para of memory		
    	pop     ds									
    	assume  ds:dg
    	cmp     dx,ax			; last-para must be greater or equal	
    	jnae	$$IF80
	pop	ax								
;fill each para 								
	push	ds
	pop	es
	lea	bx,fattbl		; es:di = point to beg of fat table	
	call	seg_adj
	mov	di,bx
	mov	bx,ax			; total number of paras to do		
	mov	ax,0e5e5h		; fill characters  Fill (d, 16*dirent, 0xe5e5)
$$DO81:
	mov	cx,8			; number of times to repeat		
	xor	di,di			; bump addr pointers by 16 bytes -
	rep	stosw			; mov 2 bytes, 1 ea for 16 * num-of-entries	
	dec	bx			; loop counter				
	jz	$$EN81
	mov	dx,es			; since we move more than 64k total, we
	inc	dx			; have to bump es by 1 para, keeping
	mov	es,dx			; di at zero
	jmp	short $$DO81
$$EN81:
	jmp	short $$EN80
$$IF80:
	pop ax									
	stc				; set carry flag indicating badddd!!!	
$$EN80:
	return
endproc fill_fat



;*****************************************************************************
;*****************************************************************************
Procedure printerr,Near
	push	cs
	pop	ds
	push	dx			; Save message pointer
	mov	dl,[user_drive] 	; restore old current drive
	mov	ah,set_default_drive
	int	21h
	pop	dx
	call	display_interface
	mov	al,0ffh 		; erc = 0xFF;
	ret			 
endproc printerr		 


;*************************************************************************
; CHK_FAT:
;
; inputs:  AX - last fat number for a file
;	   CX - bytes per cluster
;*************************************************************************
Procedure chk_fat,Near
	push es
step1a: mov	filsiz,bp		; start the file size at 0
	mov	word ptr filsiz+2,bp	; start the file size at 0
	mov	dx,MaxClus		; dx = MaxClus;
	mov	target,ax		; target = last fat in this file
	mov	exit_sw2,bp 		; false, set exit switch to no
	jmp	short step2
$$DO86: mov     target,ax		; do this 2+ times around
step2:	add     filsiz,cx		; add in cluster size
	adc     word ptr filsiz+2,bp	; inc 2nd word if there was a carry
	mov     ax,2			; start at first cluster
Step3:	call	getfat			; bx= contents of fat cell
	cmp	bx,target		; reached the end of file yet?
	je	endloop2
step4:	inc	ax			; no - inc target
	cmp	ax,dx			; target > max-clusters?
	jbe	$$IF90
	mov     exit_sw2,true 		; request exit both loops
$$IF90:
	cmp	exit_sw2,true		; exit requested?
	jne	Step3
endloop2:
	cmp     exit_sw2,true		; outer loop test- exit requested?
	jne	$$DO86
	pop es				; else- go do mov target,ax
	ret							      
endproc chk_fat 						    


;*****************************************************************************
;*****************************************************************************
	  even
Procedure main_loop1,Near		
$$DO94:
	call    read_fats		; inner loop
	cmp     exit_sw,true		; 1st way out of loop - fatptr>maxclus
	je	endloop1
	call    chk_fat			; ended read_fats on carry from feof
; at this point target = head of list, filsiz = file size
step4a: inc     filcnt			; filcnt++;
	mov     ax,maxent		; if (filcnt > maxent)
	cmp     filcnt,ax		; more files than possible dir entries?
	jna	nodirerr
direrr: dec	filcnt
	lea	dx,dirmsg
	call	display_interface
	mov	exit_sw,true
nodirerr:
	cmp     exit_sw,true
	je	endloop1
	call    fill_dir
	mov     ax,fatptr
	cmp     ax,MaxClus
	ja	endloop1
	jmp	short $$DO94
endloop1:
	ret				
endproc main_loop1			


;*****************************************************************************
; purpose: this procedure looks at all the fats for a particular file, until
;	   the end of file marker is reached. then returns
; inputs:  AX = fat cell number 2
; outputs: if any of the
;*****************************************************************************
Procedure read_fats,Near	       
	push es
	mov	filsiz,bp		; start the file size at 0
	mov	word ptr filsiz+2,bp	; start the file size at 0
step1:	call    getfat			; if (fEOF (GetFat (a)) {
	add     filsiz,cx		; add in cluster size	  
	adc     word ptr filsiz+2,bp 	; inc 2nd word if there was a carry
	call    fEOF
	jc	$$EN101
step6:	inc     fatptr			; if (++fatptr <= MaxClus)
	mov     ax,fatptr
	cmp     ax,MaxClus
	jna	$$IF103
	mov	exit_sw,true
$$IF103:
	cmp     exit_sw,true		; time to end?		  
	jne	step1
$$EN101:
	pop es
	ret 
endproc read_fats

;*****************************************************************************
;*****************************************************************************
	even
Procedure fill_dir,Near
	lea	si,dirent+7		; s = &dirent[7];
nam0:	inc     byte ptr [si]		; while (++*s > '9')
	cmp     byte ptr [si],'9'
	jle	nam1
	mov     byte ptr [si],'0'	; *s-- = '0';
	dec     si
	jmp	short nam0
nam1:	mov	ah,GET_DATE		; dirent.dir_date = GetDate ();
	int	21h
	sub	cx,1980 		; cx = 87
	add	dh,dh			; dh = 1-12
	add	dh,dh
	add	dh,dh
	add	dh,dh
	add	dh,dh			; dh = dh * 32 (32-384)
	rcl	cl,1
	or	dh,dl
	mov	byte ptr dirent+24,dh
	mov	byte ptr dirent+25,cl
	mov	ah,GET_TIME		; dirent.dir_time = GetTime ();
	int	21h
	shr	dh,1			; seconds/2
	add	cl,cl			; minutes
	add	cl,cl
	add	cl,cl			; mins * 8
	rcl	ch,1
	add	cl,cl
	rcl	ch,1
	add	cl,cl
	rcl	ch,1
	or	dh,cl
	mov	byte ptr dirent+22,dh
	mov	byte ptr dirent+23,ch
	mov	ax,filsiz		; dirent.dir_fsize = filsiz;
	mov	word ptr dirent+28,ax
	mov	ax,word ptr filsiz+2
	mov	word ptr dirent+30,ax
	mov	ax,target		; dirent.dir_firclus = target;
	mov	word ptr dirent+26,ax
	lea	si,dirent		; di:si --> directory entry		
	mov	cx,32			; move 32 bytes - 1 dir entry		
	rep	movsb			; move ds:si to es:di, then		
					; inc di and inc si			
	inc	fatptr			; if (++fatptr <= MaxClus)
	ret	
endproc fill_dir


;*****************************************************************************
; DRIVE_SPEC -	this procedure is executed if the user only specifies a drive
;		letter to recover.
;*****************************************************************************
Procedure drive_spec,Near
recdsk: xor	di,di			; init addr of dir/file area		
	mov	es,table		; es:di --> area 			
; this addr is incremented by the  rep movsb in fill_dir 
	mov	fatptr,2		; INIT FATPTR     a = fatPtr = 2
	mov	ax,fatptr
	MOV	exit_sw,bp 		; false, default to continue looping
	call	main_loop1		;    until true
step7:	mov	al,drive 
	mov	dx,firdir		; write out constructed directory
	mov	cx,firrec
	sub	cx,dx
	xor	bx,bx			; addr of dir area
	mov	es,table		; seg of dir area
	call	Write_Disk
	jc	rexit2
	lea     dx,recmsg	     
	mov     si,filcnt
	mov     rec_num,si
	call    display_interface
rexit2: mov	ah,DISK_RESET
	int	21h
	call	wrtfat			; save the fat
	jnc	$$IF111                       
	lea     dx,FATErrWrite		; Just tell user he is in deep!
	call    display_interface
$$IF111:
	ret							      
endproc drive_spec

	pathlabl recover

include msgdcl.inc

code	ends
	end				; recover 


=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\recover\recseg.inc ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

; define the segment ordering						       ;AN000;bgb
									       ;AN000;bgb
data	segment public para 'DATA'                                             ;AN000;bgb
data	ends ;put this 1st so that the recmsg works			       ;AN000;bgb
									       ;AN000;bgb
code	segment public PARA 'CODE'                                             ;AN000;bgb
code	ends								       ;AN000;bgb
									       ;AN000;bgb
const	segment public para 'const'                                            ;AN000;bgb
const	ends								       ;AN000;bgb
									       ;AN000;bgb
cstack	segment stack word 'stack'                                             ;AN000;bgb
	db	(362 - 80h) + 256 dup (?) ; (362 - 80h) == IBM's ROM requirements ;AN000;bgb
cstack	ends	; (New - Old) == size of growth 				;AN005;bgb
										;AN005;bgb
lastseg segment public para 'last_s'                                              ;AN005;bgb
lastseg ends			 ;put last because 'table' writes over memory   ;AN005;bgb
										;AN000;bgb
dg	group	data,const,code,cstack,lastseg					;AN000;bgb
	assume	cs:dg,ds:dg,es:dg,ss:CSTACK					;AN000;bgb
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\replace\replacep.h ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

/*  */
/*----------------------------------------------------------------------+
|                                                                       |
| This file contains the structures and defines that are needed to use  |
| the parser from a C program.                                          |
|   ** customized for the REPLACE utility **                            |
|                                                                       |
|                                                                       |
| Date:         5-21-87                                                 |
|                                                                       |
+----------------------------------------------------------------------*/


struct p_parms
        {
        struct p_parmsx *p_parmsx_address;      /* address of p_parmsx */
        unsigned char   p_num_extra;            /* number of extra stuff */
        };

struct p_parmsx
        {
        unsigned char   p_minp;                 /* Minimum positional number */
        unsigned char   p_maxp;                 /* Maximum positional number  */
        struct p_control_blk *p_control1;       /* Address of the 1st CONTROL block */
        struct p_control_blk *p_control2;       /* Address of the 2nd CONTROL block */
        unsigned char   p_maxs;                 /* Maximun switches */
        struct p_switch_blk *p_switch;          /* Address of the SWITCH block */
        unsigned char   p_maxk;                 /* Maximum keywords */
        };


struct p_control_blk
        {
        unsigned int    p_match_flag;           /* Controls type matched */
        unsigned int    p_function_flag;        /* Function should be taken */
        unsigned int    p_result_buf;           /* Result buffer address */
        unsigned int    p_value_list;           /* Value list address */
        unsigned char   p_nid;                  /* # of keyword/SW synonyms */
        };

struct p_switch_blk
        {
        unsigned int    sp_match_flag;          /* Controls type matched */
        unsigned int    sp_function_flag;       /* Function should be taken */
        unsigned int    sp_result_buf;          /* Result buffer address */
        unsigned int    sp_value_list;          /* Value list address */
        unsigned char   sp_nid;                 /* # of keyword/SW synonyms */
        unsigned char   sp_keyorsw1[3];         /* keyword or sw */
        unsigned char   sp_keyorsw2[3];         /* keyword or sw */
        unsigned char   sp_keyorsw3[3];         /* keyword or sw */
        unsigned char   sp_keyorsw4[3];         /* keyword or sw */
        unsigned char   sp_keyorsw5[3];         /* keyword or sw */
        unsigned char   sp_keyorsw6[3];         /* keyword or sw */
        unsigned char   sp_keyorsw7[3];         /* keyword or sw */
        };

/* Match_Flags */

#define P_Num_Val               0x8000          /* Numeric Value */
#define P_SNum_Val              0x4000          /* Signed numeric value */
#define P_Simple_S              0x2000          /* Simple string */
#define P_Date_S                0x1000          /* Date string */
#define P_Time_S                0x0800          /* Time string */
#define P_Cmpx_S                0x0400          /* Complex string */
#define P_File_Spc              0x0200          /* File Spec */
#define P_Drv_Only              0x0100          /* Drive Only */
#define P_Qu_String             0x0080          /* Quoted string */
#define P_Ig_Colon              0x0010          /* Ignore colon at end in match */
#define P_Repeat                0x0002          /* Repeat allowed */
#define P_Optional              0x0001          /* Optional */

/*----------------------------------------------------------------------+
|                                                                       |
|  Function flags                                                       |
|                                                                       |
+----------------------------------------------------------------------*/

#define P_CAP_File              0x0001          /* CAP result by file table */
#define P_CAP_Char              0x0002          /* CAP result by character table */
#define P_Rm_Colon              0x0010          /* Remove ":" at the end */



#define P_nval_None             0               /* no value list ID */
#define P_nval_Range            1               /* range list ID */
#define P_nval_Value            2               /* value list ID */
#define P_nval_String           3               /* string list ID */
#define P_Len_Range             9               /* Length of a range choice(two DD plus one DB) */
#define P_Len_Value             5               /* Length of a value choice(one DD plus one DB) */
#define P_Len_String            3               /* Length of a string choice(one DW plus one DB) */


/*----------------------------------------------------------------------+
|                                                                       |
|  Result block structure                                               |
|                                                                       |
+----------------------------------------------------------------------*/

struct p_result_blk
        {
        unsigned char   P_Type;                 /* Type returned */
        unsigned char   P_Item_Tag;             /* Matched item tag */
        unsigned int    P_SYNONYM_Ptr;          /* pointer to Synonym list returned */
        unsigned int    p_result_buff[2];       /* result value */
        };

struct p_fresult_blk
        {
        unsigned char  fP_Type;                 /* Type returned */
        unsigned char  fP_Item_Tag;             /* Matched item tag */
        unsigned int   fP_SYNONYM_Ptr;          /* pointer to Synonym list returned */
        char far *     fp_result_buff;          /* result value */
        };

/*----------------------------------------------------------------------+
|                                                                       |
|  type                                                                 |
|                                                                       |
+----------------------------------------------------------------------*/

#define P_EOL                   0               /* End of line */
#define P_Number                1               /* Number */
#define P_List_Idx              2               /* List Index */
#define P_String                3               /* String */
#define P_Complex               4               /* Complex */
#define P_File_Spec             5               /* File Spec */
#define P_Drive                 6               /* Drive */
#define P_Date_F                7               /* Date */
#define P_Time_F                8               /* Time */
#define P_Quoted_String         9               /* Quoted String */

#define P_No_Tag                0x0FF           /* No ITEM_TAG found */

/*----------------------------------------------------------------------+
|                                                                       |
|  Value list structure                                                 |
|                                                                       |
+----------------------------------------------------------------------*/

struct noval
        {
        unsigned char   null;
        };

/*----------------------------------------------------------------------+
|                                                                       |
|  following return code will be returned in the AX register.           |
|                                                                       |
+----------------------------------------------------------------------*/

#define P_No_Error              0               /* No error */
#define P_Too_Many              1               /* Too many operands */
#define P_Op_Missing            2               /* Required operand missing */
#define P_Not_In_SW             3               /* Not in switch list provided */
#define P_Not_In_Key            4               /* Not in keyword list provided */
#define P_Out_Of_Range          6               /* Out of range specified */
#define P_Not_In_Val            7               /* Not in value list provided */
#define P_Not_In_Str            8               /* Not in string list provided */
#define P_Syntax                9               /* Syntax error */
#define P_RC_EOL                0x0ffff         /* End of command line */

#define NULLARG			0


=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\replace\replace.c ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

/**************************************************************************/
/*                                                                        */
/*  UTILITY NAME:      Replace                                            */
/*                                                                        */
/*  SOURCE FILE NAME:  Replace.C                                          */
/*                                                                        */
/*  STATUS:            Replace Utility, DOS Version 5.00                  */
/*                                                                        */
/*  FUNCTIONAL DESCRIPTION:  REPLACE is an external DOS utility that      */
/*                           allows a user to selectively replace         */
/*                           files on the target with files of the        */
/*                           same name from the source.  The user can     */
/*                           also selectively add files from the source   */
/*                           to the target.                               */
/*                                                                        */
/*  SYNTAX:            [d:][path]REPLACE[d:][path]filename[.ext]          */
/*                     [d:][path] [/A][/P][/R][/S][/U][/W]                */
/*            where:                                                      */
/*                     [d:][path] before REPLACE specifies the drive      */
/*                     and path that contains the REPLACE command file,   */
/*                     if it is not the current directory of the          */
/*                     default drive.                                     */
/*                                                                        */
/*                     [d:][path]filename[.ext] specifies the names of    */
/*                     the files on the source that are to be replaced    */
/*                     on the target or added to the target.  The file    */
/*                     name can contain global file name characters.      */
/*                                                                        */
/*                     [d:][path] specifies the target drive and          */
/*                     directory.  The files in this directory are        */
/*                     the ones that are to be replaced, if /A is         */
/*                     specified the source files are copied to this      */
/*                     directory.  The default is the directory on the    */
/*                     current drive.                                     */
/*                                                                        */
/*                     /A copies all files specified by the source that   */
/*                        do not exist on the target.                     */
/*                                                                        */
/*                     /P prompts as each file is encountered on the tar- */
/*                        get, allowing selective replacing or adding.    */
/*                                                                        */
/*                     /R replaces files that are read-only on the target.*/
/*                                                                        */
/*                     /S searches all directories of the target for      */
/*                        files matching the source file name.            */
/*                                                                        */
/*                     /U replaces updated date/time attribute source     */
/*                        files to the target.                            */
/*                                                                        */
/*                     /W waits for you to insert a diskette before be-   */
/*                        ginning to search for source files.             */
/*                                                                        */
/*         ** NOTE **  /A + /S and A/ + /U cannot be used together.       */
/*                                                                        */
/*  LINKS:                                                                */
/*    COMSUBS.LIB - DOS DBCS function calls                               */
/*    MAPPER.LIB  - DOS function calls                                    */
/*    SLIBC3.LIB  - C library functions                                   */
/*    _MSGRET.SAL - Assembler interface for common DOS message services   */
/*    _PARSE.SAL  - Assembler interface for common DOS parser             */
/*    _REPLACE.SAL- Assembler control break and critical error handlers   */
/*                                                                        */
/*  ERROR HANDLING:    Error message is displayed and utility is          */
/*                     then terminated (with appropriate error level).    */
/*                                                                        */
/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *  */

#define LINT_ARGS
#include <process.h>
#include <string.h>
#include <stdlib.h>
#include <stdio.h>

#include "comsub.h"                    /* DBCS functions */
#include "dos.h"                       /* Used for the REGS union */
#include "replacep.h"                  /* Parser structures */
#include "io.h"
#include "sys\types.h"
#include "sys\stat.h"
#include "fcntl.h"
#include "io.h"
#include "replace.h"


/**************************************************************************/
/*                                                                        */
/*  SUBROUTINE NAME:   main                                               */
/*                                                                        */
/*  SUBROUTINE FUNCTION:  Get addressability to msgs through SYSLOADMSG   */
/*                        Parse the command line by calling SYSPARSE      */
/*                        Allocate the data buffer to be used for copy    */
/*                        Make a fully qualified source path              */
/*                        Append current directory string                 */
/*                        Create a list of files to be replaced           */
/*                        Read and write files                            */
/*                        De-allocate data buffer                         */
/*                        Print messages by calling SYSDISPMSG            */
/*                                                                        */
/*  INPUT:             Command line arguments                             */
/*                                                                        */
/*  EXIT-NORMAL:       Information message displayed.                     */
/*                                                                        */
/*  EXIT-ERROR:        Error message displayed, appendx restored,         */
/*                     errorlevel set.                                    */
/*                                                                        */
/*  EXTERNAL ROUTINES:    SYSLOADMSG                                      */
/*                        SYSDISPMSG                                      */
/*                        SYSPARSE                                        */
/*                        crit_err_handler                                */
/*                        ctl_brk_handler                                 */
/*                                                                        */
/**************************************************************************/

void main(argc, argv)
int  argc ;
char *argv[] ;
{
  /*  Forward declarations */
  char *com_strchr();                       /* To search for DBCS "\\" */
  unsigned char *com_strrchr();             /* To search for DBCS "\\" */
  
  /*  Local variables */
  int index;                                /* Forming string for parser */


  /* Begin Here */
  load_msg();                               /* Point to msgs & chk DOS ver */
  for (index = 1; index <= argc; index++)   /* Form string for parser */
  {
    strcat(source,argv[index]);             /* Add the argument */
    strcat(source," ");                     /* Separate with a space */
  }
  parser_prep(source);                      /* Initialization for parser */

  ParseIt();                                /* Parse the command line */

  /*
   *  Allocate the data buffer to be used during the copy operations
   */
  length = 0x1000;
  rstatus = dallocate(length);                   /* Allocate buffer */
  if (rstatus == INSUFFMEM)                      /* Not enough mem? */
  {                                              /* then alloc what's available */
    length = outregs.x.bx;                       
    rstatus = dallocate(length);
  }

  if (rstatus != 0)                              /* If can't alloc at all */
  {
    display_msg(MSG_NOMEM, NULLARG);             /* no space for copies */
    dexit(ERRLEVEL8);                            
  }

  segment = outregs.x.ax;
  length  = (length << 4);                       /* Convert to bytes */
  if (length == 0) length = 0xffff;

  /*
   *  If the wait switch was on the command line, wait to continue
   */
  if (waiting)
  {
    display_msg(MSG_START, NULLARG);             /* Press any key... */
    inregs.x.ax = 0x0C08;
    intdos(&inregs,&outregs);
    rstatus = (outregs.x.cflag & CARRY);
    if ( (rstatus == NOERROR) && ((outregs.x.ax & 0x00ff) == 0) )
    {
      inregs.x.ax = 0x0100;
      intdos(&inregs,&outregs);
      rstatus = (outregs.x.cflag & CARRY);
    }
  }
  
  GetFQPathNames(source,target);

  dfree(segment);

  switch(rstatus)
  {
    case 0  : break;
    case 2  : display_msg(MSG_ERRFNF,errfname);       /* file not found */
	      break;
    case 3  : display_msg(MSG_ERRPNF,errfname);       /* path not found */
	      break;
    case 5  : display_msg(MSG_ERRACCD,errfname);      /* access denied */
	      break;
    case 15 : display_msg(MSG_ERRDRV,errfname);       /* invalid drive */
	      break;
    default : dexit(ERRLEVEL1);                       
	      break;
  }

  if (add)
    if (counted == 0)
      display_msg(MSG_NONEADDE, NULLARG);             /* no files added */
    else
      display_msg(MSG_SOMEADDE,(char *)&counted);     /* %1 files added */
  else
    if (counted == 0)
      display_msg(MSG_NONEREPL, NULLARG);             /* no files replaced */
    else
      display_msg(MSG_SOMEREPL,(char *)&counted);     /* %1 files replaced */

  restore();                                          /* Cleanup before exit */
  dexit(rstatus);
}


/**************************************************************************/
/*                                                                        */
/*  SUBROUTINE NAME:   ParseIt                                            */
/*                                                                        */
/*  SUBROUTINE FUNCTION:  Parse the command line entered by the user.     */
/*                                                                        */
/*  INPUT:             none                                               */
/*                                                                        */
/*  OUTPUT:            command line is parsed                             */
/*                                                                        */
/**************************************************************************/

void ParseIt()
{
  char switch_buffer[3];               /* Gets switch from parser */
  char far * fptr;                     /* Pts to parser's buf for flspc */
  int fchar            = 0;            /* Index into p_sfilespec */
  int index;                           /* Forming string for parser */
  int i;                               /* Loop counter */
  int more_to_parse    = TRUE;         /* While parsing cmdline */
  unsigned have_source = FALSE;        /* Flag */
  unsigned have_target = FALSE;        /* Flag */

  
  while (more_to_parse)                          /* Test loop flag */
  {
    index = 0;                                   /* Init array index */
    parse(&inregs,&outregs);                     /* Call the parser */
    if (outregs.x.ax == P_No_Error)              /* If no error */
    {
      /* if result is filespec & we don't have the source */
      if ((outregs.x.dx == (unsigned short)&rslt1) && !(have_source))
      {
	/* get the filespec from parser */
	for (fptr = rslt1.fp_result_buff; (char)*fptr != NULL; fptr++)
	{
	  p_sfilespec[fchar] = (char)*fptr;      /* get the character */
	  fchar++;                               /* Move the char ptr */
	}
	strcpy(fix_es_reg,NULL);                 /* (Set es reg correct) */
	have_source = TRUE;                      /* Set the flag */
	fchar       = 0;                         /* Reset char ptr */
      }
      else
      {
	/* if result is filespec & we do have the source */
	if ((outregs.x.dx == (unsigned short)&rslt1) && (have_source))
	{
	 /* get the filespec from parser */
	  for (fptr = rslt1.fp_result_buff; (char)*fptr != NULL; fptr++)
	  {
	    p_path[fchar] = (char)*fptr;         /* get the character */
	    fchar++;                             /* Move the char ptr */
	  }
	  strcpy(fix_es_reg,NULL);               /* (Set es reg correct) */
	  have_target = TRUE;                    /* Set the flag */
        }
	else
	{
	  /* Copy whatever parser just parsed */
	  for (inregs.x.si; inregs.x.si < outregs.x.si; inregs.x.si++)
	  {
	    cmdln_switch[index] = *(char *)inregs.x.si;
	    index++;
	  }
	  /* Copy switch into buf and verify which switch */
	  strcpy(switch_buffer,(char *) rslt2.P_SYNONYM_Ptr);
	  switch (switch_buffer[1])
	  {                                             
	    case '?' :
                for (i = MSG_OPTIONS_FIRST; i <= MSG_OPTIONS_LAST; i++)
                  display_msg(i, (char *)0);
                restore();
                dexit(ERRLEVEL0);                /* Terminate utility */
	    case 'A' :
                if (!add)                        /* /A switch */
                  add = TRUE;
                else                             /* It's a dup switch */
                  display_exit(MSG_BADSWTCH,cmdln_switch,ERRLEVEL11);
                break;
	    case 'P' :
                if (!prompt)                     /* /P switch */
		  prompt = TRUE;
		else                             /* It's a dup switch */
		  display_exit(MSG_BADSWTCH,cmdln_switch,ERRLEVEL11);
		break;                      
	    case 'R' :
                if (!readonly)                   /* /R switch */
		  readonly = TRUE;          
		else                             /* It's a dup switch */
		  display_exit(MSG_BADSWTCH,cmdln_switch,ERRLEVEL11);
		break;                      
	    case 'S' :
                if (!descending)                 /* /S switch */
		  descending = TRUE;        
		else                             /* It's a dup switch */
		  display_exit(MSG_BADSWTCH,cmdln_switch,ERRLEVEL11);
		break;                      
	    case 'U' :
                if (!update)                     /* /U switch */
		  update = TRUE;            
		else                             /* It's a dup switch */
		  display_exit(MSG_BADSWTCH,cmdln_switch,ERRLEVEL11);
		break;                      
	    case 'W' :
                if (!waiting)                    /* /W switch */
		  waiting = TRUE;
                else                             /* It's a dup switch */
		  display_exit(MSG_BADSWTCH,cmdln_switch,ERRLEVEL11);
		break;
	    default :
                display_exit(MSG_BADSWTCH,cmdln_switch,ERRLEVEL11); 
		break;
	  }
	}
      }
    }
    else
    {
      if (outregs.x.ax != P_RC_EOL)              /* Is the parser */
      {
        /* Copy whatever parser just parsed */
	for (inregs.x.si; inregs.x.si < outregs.x.si; inregs.x.si++)
	{
	  cmdln_invalid[index] = *(char *)inregs.x.si;
	  index++;
	}
	switch (outregs.x.ax)                    /* returning an error? */
	{
	  case P_Too_Many :
              /* Too many parms, more_to_parse = FALSE */
	      display_exit(MSG_XTRAPARM,cmdln_invalid,ERRLEVEL11);
	      break;
	  case P_Syntax :
              /* Bad syntax, more_to_parse = FALSE */
              display_exit(MSG_BADPARM,cmdln_invalid,ERRLEVEL11);
	      break;
	  case P_Not_In_SW :
              /* Invalid switch, more_to_parse = FALSE */
              display_exit(MSG_BADSWTCH,cmdln_invalid,ERRLEVEL11);
	      break;
	  case P_Op_Missing :
              /* Source required, more_to_parse = FALSE */
              display_msg(MSG_NOSOURCE, NULLARG);
	      dexit(ERRLEVEL11);
	      break;
	}
      }
      else
	more_to_parse = FALSE;              /* End of the cmdline */
    }
    inregs.x.cx = outregs.x.cx;             /* Move the count */
    inregs.x.si = outregs.x.si;             /* Move the pointer */
  }

  /*
   *  Verify the correctness of the parameters
   */
  if ((add && descending) || (add && update))    /* A+S or A+U */
  {
    display_msg(MSG_INCOMPAT, NULLARG);          /* Incompatible switches */
    dexit(ERRLEVEL11);
  }
}


/**************************************************************************/
/*                                                                        */
/*  SUBROUTINE NAME:   GetFQPathNames                                     */
/*                                                                        */
/*  SUBROUTINE FUNCTION:  Get fully qualified pathnames for the source    */
/*                        and the target.                                 */
/*                                                                        */
/*  INPUT:             target    (contains current directory)             */
/*                     save      (pathname to fix)                        */
/*                                                                        */
/*  OUTPUT:            target    (fully qualified pathname)               */
/*                                                                        */
/**************************************************************************/

void GetFQPathNames(source,target)
char *source;                               /* source buffer */
char *target;                               /* target buffer */
{
  char save[MAXMINUS1];                     /* temporary storage buffer */
  int first_time_thru_loop    = TRUE;       /* flag, skip code if > 256 files */
  int need_to_reset_filecount = FALSE;      /* flag, get to 0 element of array */
  int search_more_files       = TRUE;       /* flag, loop > 256 files */
  unsigned filecount          = 0;          /* number of files */
  struct filedata files[500];               /* 256 is true limit, but */
				            /* 500 to accomodate segment wrap */

  /*
   *  Make a fully qualified source path
   */
  strcpy(source,p_sfilespec);               /* Copy filespec recvd from parser */
  strcpy(save,source);
  strcpy(errfname,source);
  if (source[1] != ':')                     /* If no drive letter entered */
    GetCurrentDrive(source,rstatus,1,save);           /* macro call */

  /*
   *  Append current directory string
   */
  strcpy(errfname,source);
  if (source[2] != '\\')                    /* If not path from root */
  {
    strcpy(save,&source[2]);
    strcpy(&source[3],save);
    GetCurrentDirectory(source,rstatus);              /* macro call */
      
    /* If we got it, add it to user entered path */
    if (rstatus == NOERROR)
    {
      AppendBackslash(source);                        /* macro call */
      strcat(source,save);
    }
  }

  rstatus = check_appendx_install();             /* Check append/x install */
  if (rstatus != NOERROR)                        /* If append/x is installed */
  {
    append_installed = TRUE;
    x_status = check_appendx();                  /* Get the status */
    set_appendx(x_status & INACTIVE);            /* Set it inactive */
  }

  setup_ctl_brk();                               /* Ctl brk vec now pts here */
  setup_crit_err();                              /* Crit err vec now pts here */

  /*
   *  Create a list of the files that we might just replace
   */
#if SELECT_SUPPORT
  check_select();                                /* See if invoked by SELECT */
#endif

  /* Find the first file */
  strcpy(errfname,source);
  rstatus = dsearchf(source,&files[filecount],SATTRIB);

  while (search_more_files)                      /* Search & replace/add */
  {
    while ( (filecount < MAXMINUS1) && (rstatus == NOERROR) )
    {
      filecount++;
      /* Because of prev structure, only way to get to 0 element */
      if (need_to_reset_filecount)
      {
	filecount = 0;
	need_to_reset_filecount = FALSE;
      }
      rstatus = dsearchn(&files[filecount]);
    }

    if (rstatus == NOMOREFILES)
    {
      rstatus = NOERROR;
      search_more_files = FALSE;                 /* Set for loop test */
      if (filecount == 1)                        /* Find the true filecount */
        only_one_valid_file = TRUE;              
      if (filecount > 1)                         /* Last file is no good */
        filecount--;                             /* so back counter up */
    }

    /* Bypass this if done already */
    if ((first_time_thru_loop) && (rstatus == NOERROR) )
    {
      first_time_thru_loop = FALSE;              /* > 256 files to replace */
      if (filecount == 0)
	display_exit(MSG_NONFOUND,source,ERRLEVEL2);

      if (rstatus == NOERROR)
      {
	/*
         *  Fixup the source directory path so that it is useable.
         */
        FixSourcePath(source);
        
	/*
         *  Fixup the target path.
         */
        FixTargetPath(target);
      }
    }

    if (rstatus == NOERROR)
    {
      if (!add)
        rstatus = dodir(source,target,files,filecount);
      else
        rstatus = doadd(source,target,files,filecount);
    }

    filecount = 0;                               /* Reset for next loop */
    need_to_reset_filecount = TRUE;              /* Get to 0 element */

    if (rstatus != NOERROR)                      /* If there was an error */
      search_more_files = FALSE;                 /*   somewhere, drop out */
  }
}


/**************************************************************************/
/*                                                                        */
/*  SUBROUTINE NAME:   FixSourcePath                                      */
/*                                                                        */
/*  SUBROUTINE FUNCTION:  Fixes the source path so that it is useable.    */
/*                                                                        */
/*  INPUT:             source 	(contains pathname to fix)                */
/*                                                                        */
/*  OUTPUT:            source contains true pathname                      */
/*                                                                        */
/**************************************************************************/

void FixSourcePath(source)
char *source;
{
  int i;                              /* loop counter */
  int backslash_char = FALSE;         /* flag, DBCS backslash */

  
  for (i = strlen(source) - 1;
       (i >= 0) && (!backslash_char) && (source[i] != ':'); i--)
  {
    if ((source[i] == '\\') && (i != 0))
    {
      dbcs_search[0] = source[i-1];        /* Copy char to srch for DBCS */
      dbcs_search[1] = source[i];          /* Copy char to srch for DBCS */
      if (com_strchr(dbcs_search,'\\') != NULL)
      {
        /* If there is a pointer, then backslash exists */
        backslash_char = TRUE;
        i++;
      }
    }
    else
    {
      if ((source[i] == '\\') && (i == 0))
      {
        backslash_char = TRUE;
        i++;
      }
    }
  }
  if (i <= 0)
  {
    i = 0;
    source[0] = NULL;
  }
  dbcs_search[0] = source[i-1];
  dbcs_search[1] = source[i];
  if ( ((com_strchr(dbcs_search,'\\'))!= NULL) || (source[i] == ':') )
    source[i+1] = NULL;
}


/**************************************************************************/
/*                                                                        */
/*  SUBROUTINE NAME:   FixTargetPath                                      */
/*                                                                        */
/*  SUBROUTINE FUNCTION:  Fixes the target path so that it contains a     */
/*                        fully qualified pathname.                       */
/*                                                                        */
/*  INPUT:             target 	(contains pathname to fix)                */
/*                                                                        */
/*  OUTPUT:            target contains true pathname                      */
/*                                                                        */
/**************************************************************************/

void FixTargetPath(target)
char *target;                              /* target pathname */
{
  char save[MAXMINUS1];                     /* temporary storage buffer */


  strcpy(target,p_path);                   /* Copy path recvd from parser */
  if (target[0] == NULL)
    GetCurrentDrive(target,rstatus,0,NULL);     /* macro call */

  strcpy(errfname,target);
  if ( (strlen(target) == 2) && (target[1] == ':') && (rstatus == NOERROR) )
    GetCurrentDirectory(target,rstatus);        /* macro call */

  strcpy(save,target);
  strcpy(errfname,target);
  if (target[1] != ':')
    GetCurrentDrive(target,rstatus,1,save);     /* macro call */

  strcpy(errfname,target);
  if (target[2] != '\\')
  {
    strcpy(save,&target[2]);
    strcpy(&target[3],save);
    GetCurrentDirectory(target,rstatus);        /* macro call */
    if (rstatus == NOERROR)
    {
      AppendBackslash(target);                  /* macro call */
      /* If target is not cur dir, then append subdir to path */
      if (save[0] != '.')
        strcat(target,save);
      else
      {
        /* Handle .\ and ..\ pathnames */
        FixPath(target,save);
      }
    }
  }
  strcpy(errfname,target);
  /* Copy chars to search for DBCS */
  dbcs_search[0] = target[strlen(target)-2];
  dbcs_search[1] = target[strlen(target)-1];
  if ( ((com_strchr(dbcs_search,'\\')) != &dbcs_search[1]) &&
       (rstatus == NOERROR) )
    strcat(target,"\\");
}


/**************************************************************************/
/*                                                                        */
/*  SUBROUTINE NAME:   FixPath                                            */
/*                                                                        */
/*  SUBROUTINE FUNCTION:  Handle pathnames that contain .\ and ..\        */
/*                                                                        */
/*  INPUT:             target    (contains current directory)             */
/*                     save      (pathname to fix)                        */
/*                                                                        */
/*  OUTPUT:            target    (fully qualified pathname)               */
/*                                                                        */
/**************************************************************************/

void FixPath(target,save)
char *target;
char *save;

{
  int catlen;                          /* number of bytes to concatenate */
  char *posptr;                        /* pointer to current position */
  char *endptr;                        /* pointer to end of string */
  char *nextptr;                       /* pointer to next position in save */


  posptr = save;
  endptr = posptr + strlen(save);
  
  /* Loop until reach the end of the string */
  while (posptr < endptr)
  {
    if (*posptr == '.')                /* relative position */
    {
      if (*(posptr+1) == '.')          /* previous directory */
      {
        /*
         *  If target is parent dir, then delete end backslash and
         *  delete cur dir name from path
         */
        target[strlen(target) - 1] = NULL;
        *((unsigned char *)com_strrchr(target,'\\') + 1) = NULL;
        posptr += 3;
      }
      else                             /* current directory */
      {
        /* Target is current directory, so simply advance pointer */
        posptr += 2;
      }  
    }
    else                               /* directory name */
    {
      /* Have a directory name, so copy it over to target string */
      if ((nextptr = com_strchr(posptr,'.')) == NULL)
        nextptr = endptr;
      catlen = (int)nextptr - (int)posptr;
      strncat(target,posptr,catlen);
      posptr += catlen;
    }
  }
  AppendBackslash(target);                            /* macro call */
}


/**************************************************************************/
/*                                                                        */
/*  SUBROUTINE NAME:   dodir                                              */
/*                                                                        */
/**************************************************************************/

unsigned dodir(source,target,files,filecount)
char     *source;
char     *target;
struct   filedata *files;
unsigned filecount;
{
  char     dta_area[128];
  char     subdirectory[MAX];
  int      index;
  unsigned status;
  struct   filedata file;

  dta_save(dta_area,128);
  strcpy(subdirectory,target);
  strcat(subdirectory,"*.*");
  status = dsearchf(subdirectory,&file,TATTRIB);
  while (status == NOERROR)
  {
    if ( ((file.attribute & SUBDIR) != 0) &&
       (descending) && (file.name[0] != '.') )
    {
      strcpy(subdirectory,target);
      strcat(subdirectory,file.name);
      strcat(subdirectory,"\\");
      status = dodir(source,subdirectory,files,filecount);   /* Call self again */
      strcpy(subdirectory,target);
      strcat(subdirectory,"*.*");
    }
    else
    {
      /* If there is a file and it is not a subdirectory name */
      index = findfile(files,&file,filecount);
      if ( (index >= 0) && ((file.attribute & SUBDIR) == 0) )
      {
	/* If update switch set, check date & time */
	if (update)
        {
	  /*
	   *  If src.date < tgt.date OR Src.dt == tgt.dt AND
	   *     src.tm <= tgt.tm - do nothing
	   */
	  if ((files[index].date < file.date)  ||
	     ((files[index].date == file.date) &&
	     (files[index].time <= file.time)));
	  /* Else src is newer - do cpy */
	  else
	    status = docopy(source,target,&file,files[index].time,
			    files[index].date);
        }
	else                                /* Update switch was not set */
	  status = docopy(source,target,&file,files[index].time,files[index].date);
      }
    }
    if (status == NOERROR)
      status = dsearchn(&file);
  }

  dta_restore(dta_area,128);
  if (status == NOMOREFILES)
    status = NOERROR;
  return(status);
}


/**************************************************************************/
/*                                                                        */
/*  SUBROUTINE NAME:   doadd                                              */
/*                                                                        */
/**************************************************************************/

unsigned doadd(source,target,files,filecount) 
char     *source;
char     *target;
struct   filedata *files;
unsigned filecount;
{
  char     path[MAX];
  int      index;
  unsigned status = NOERROR;
  struct   filedata *f;
  struct   filedata dummy;

  if (only_one_valid_file)                  /* Eliminate extra loop */
    filecount--;                                                       

  for (index = 0; (index <= filecount) && (status == NOERROR); index++)
  {
    f = files+index;
    strcpy(path,target);
    strcat(path,f->name);
    status = dsearchf(path,&dummy,TATTRIB);
    
    /* Check for null filename or Process single file */
    if (((status == NOMOREFILES) && (f->name[0] != NULL)) ||
       ((index==filecount)&&(f->name[0]!=NULL)&&(status==NOMOREFILES)))
    {

#if SELECT_SUPPORT
      if (detect_select_flag)                    /* If SELECT invoked */
      {
	status = check_select_list(f);           /* Check SELECT filelist */
	
        /* If okay to add, call copy opertion */    
	if (status)
	  status = docopy(source,target,f,f->time,f->date);
      }
      else
#endif
	status = docopy(source,target,f,f->time,f->date);
    }
    else
      status = NOERROR;                          /* Skip this null file */
  }
  return(status);
}


/**************************************************************************/
/*                                                                        */
/*  SUBROUTINE NAME:   findfile                                           */
/*                                                                        */
/**************************************************************************/

unsigned findfile(files,file,filecount)
struct   filedata *files;
struct   filedata *file;
unsigned filecount;
{
  int i;
  unsigned status;

  if (only_one_valid_file)                  /* Eliminate extra loop */
    filecount--;

  for (i = 0; i <= filecount; i++)
  {
    if (same(files->name,file->name))
    {

#if SELECT_SUPPORT
      if (detect_select_flag)               /* If invoked by SELECT */
      {
	status = check_select_list(file);   /* Check SELECT filelist */
	if (status)                         /* If ok to copy */
	  return(i);                        /* Return index to filename */
      }
      else
#endif

        return(i);
    }
    files++;
  }
  return(ERRLEVELNEG1);                  
}


/**************************************************************************/
/*                                                                        */
/*  SUBROUTINE NAME:   docopy                                             */
/*                                                                        */
/**************************************************************************/

unsigned docopy(sdir,tdir,file,time,date)
char     *sdir;
char     *tdir;
struct   filedata *file;
unsigned time;
unsigned date;
{
  char     source[MAX];
  char     target[MAX];
  unsigned source_handle;
  unsigned status;
  unsigned target_handle;
  unsigned try;
  int      src, dest;                  /* file handles for size check */
  long     src_len, dest_len;          /* file lengths for size check */
  long     freespace;                  /* free space on disk */
  unsigned drive;                      /* target drive number */
  struct diskfree_t space;             /* structure for get disk free call */

  /* create the path names and check for equivalence */

  strcpy(source,sdir);
  strcat(source,file->name);
  strcpy(target,tdir);
  strcat(target,file->name);

  status = strcmp(source,target);
  if (status == NOERROR)
  {
    display_msg(MSG_WARNSAME,source);       /* File cannot be copied... */
    return(status);
  }

  /* We can replace!  if prompting, check to see */
  /* if this file is to be replaced or not       */

  while ( (prompt) && (not_valid_input) )   /* Flag set in dcompare */
  {
    if (add)
      display_msg(MSG_QADD,target);         /* Add? filename */
    else
      display_msg(MSG_QREPLACE,target);     /* Replace? filename */
    status = dcompare();                    
  }
  not_valid_input = TRUE;                   /* Prepare for next file in loop */
  if (status == 2)
    return(ERRLEVEL0);                      

  /* indicate what we are replacing */

  if (add)
    display_msg(MSG_ADDING,target);         /* Adding filename */
  else
  {
    display_msg(MSG_REPLACIN,target);       /* Replacing filename */

    /* check for available space if replacing */
    src = open(source,O_RDONLY);
    dest = open(target,O_RDONLY);
    if (src != -1 && dest != -1)       /* found both files, check sizes */
    {
      src_len = filelength(src);
      dest_len = filelength(dest);
      drive = target[0] - 'A' + 1;
      _dos_getdiskfree(drive, &space);

      /* compute free space on disk */
      freespace = space.bytes_per_sector * space.sectors_per_cluster *
                  (long)space.avail_clusters;

      /* check free space against space needed */
      if (src_len - dest_len > freespace)
      {
        /* print error and exit if not enough space */
        strcpy(errline,target);
        display_msg(MSG_ERRDSKF,errline);
        target_full = TRUE;
        close(src);
        close(dest);
        return(NOERROR);                /* return no error anyway */
      }
    }
    close(src);
    close(dest);
  }

  /* open the input file */

  status = dopen(source);                   /* Extended open */
  if (status != 0)
  {
    strcpy(errfname,source);
    return(status);
  }

  source_handle = outregs.x.ax; 

  /* create the output file */
  /* if we are to overwrite READONLY files, set the mode so we can */

  if (!add)
  {
    inregs.x.cx = 0;
    status = dchmod(target,0);
    if (status != 0)
    {
      strcpy(errfname,target);
      dclose(source_handle);
      return(status);
    }
    file->attribute = (char)outregs.x.cx; 
    if (readonly)
      outregs.x.cx = outregs.x.cx & 0xfffe;
    if (file->attribute != (char)outregs.x.cx)
    {
      status = dchmod(target,1);
      if (status != 0)
      {
	strcpy(errfname,target);
	dclose(source_handle);
	return(status);
      }
    }
  }

  status = dcreate(target,-1);              /* Create the target file */

  strcpy(filename,target);                  /* Note that existing file*/
  if (status != 0)                          /*  will be deleted       */
  {
    strcpy(errfname,target);
    dclose(source_handle);
    return(status);
  }

  target_handle = outregs.x.ax;

  /* now, copy all of the data from the in file to the out file */

  try = length;
  while ( (try == length) && (status == NOERROR) )
  {
    status = dread(source_handle,segment,0,try);
    if (status == NOERROR)
    {
      try    = outregs.x.ax;
      status = dwrite(target_handle,segment,0,try);
      if (disk_full)                        /* RW If the target disk fills up */
      {
	strcpy(errline,filename);           /* save target filename */
	dclose(target_handle);              /* RW Close target file */
	ddelete(filename);                  /* RW Then delete target file */
	display_msg(MSG_ERRDSKF,errline);   /* Error disk full */
	status = TARGETFULL;                /* RW Tell me too */
      }
    }
  }

  if (status == NOERROR)
  {
    inregs.x.ax = 0x5701;                   /* Set files date and time */
    inregs.x.bx = target_handle;            
    inregs.x.cx = time;                     
    inregs.x.dx = date;                     
    intdos(&inregs,&outregs);               
    if (outregs.x.cflag & CARRY)            /* If the carry flag is set */
      status = outregs.x.ax;                /*   get returned error */
    else                                    /* else                 */
      status = (outregs.x.cflag & CARRY);   /*   set status to NOERROR */
  }

  if (status == NOERROR)
  {
    status = dclose(target_handle);         /* Close target file */
    if (status != NOERROR)
      strcpy(errfname,target);
    else
    {
      if ((file->attribute & ARCHIVE) != ARCHIVE)
	file->attribute += ARCHIVE;         /* Set archive bit ON */
      inregs.x.cx = file->attribute;
      if (!add)
	status = dchmod(target,1);          /* Reset attributes on target */
      if (status != NOERROR)
	strcpy(errfname,target);
      counted++;                            /* Increment num files processed */
    }
  }

  if (disk_full)                            /* RW If the target disk got full */
  {
    status      = NOERROR;                  /* RW Then we've done all we can do */
    disk_full   = FALSE;                    /* RW So forget about it */
    target_full = TRUE;                     
  }

  dclose(source_handle);
  return(status);
}


/**************************************************************************/
/*                                                                        */
/*  SUBROUTINE NAME:   same                                               */
/*                                                                        */
/**************************************************************************/

int same(s,t)                               
char *s;
char *t;
{
  while ( (*s != NULL) && (*t != NULL) )    
  {                                         
    if ( *s != *t )                         
      return(FALSE);                        /* Removed "casemap" */
    s++;                                    
    t++;                                    
  }                                         
  if ( *s != *t )
    return(FALSE);                          /* Removed "casemap" */
  return(TRUE);
}


/**************************************************************************/
/*                                                                        */
/*  SUBROUTINE NAME:   dallocate                                          */
/*                                                                        */
/**************************************************************************/

unsigned dallocate(s)
unsigned s;
{
  unsigned status;

  inregs.x.bx = s;                          /* Num of paragraphs requested */
  inregs.x.ax = 0x4800;                     /* Int21 - allocate memory */
  intdos(&inregs,&outregs);
  if (outregs.x.cflag & CARRY)              /* If the carry flag is set */
    status = outregs.x.ax;                  /*   get returned error */
  else                                      /* else */
    status = (outregs.x.cflag & CARRY);     /*   set status to NOERROR */
  return(status);
}


/**************************************************************************/
/*                                                                        */
/*  SUBROUTINE NAME:   dfree                                              */
/*                                                                        */
/**************************************************************************/

unsigned dfree(s)
unsigned s;
{
  unsigned status;

  segregs.es  = s;                          
  inregs.x.ax = 0x4900;                     
  intdosx(&inregs,&outregs,&segregs);       
  if (outregs.x.cflag & CARRY)              /* If the carry flag is set */
    status = outregs.x.ax;                  /*   get returned error */
  else                                      /* else                 */
    status = (outregs.x.cflag & CARRY);     /*   set status to NOERROR */
  strcpy(fix_es_reg,NULL);
  return(status);
}


/**************************************************************************/
/*                                                                        */
/*  SUBROUTINE NAME:   dcreate                                            */
/*                                                                        */
/**************************************************************************/

unsigned dcreate(n,parm_value)
char     *n;
unsigned parm_value;
{
  unsigned status;

  inregs.x.ax = 0x6c00;                     /* Extended Create */
  inregs.x.bx = 8321;                       /* Mode */
  inregs.x.cx = 0;                          /* Create attribute */
  inregs.x.dx = 0x12;                       /* Function flag */
  inregs.x.di = parm_value;                 /* Parm list value */
  inregs.x.si = (unsigned)(n);              /* Target file to create */
  intdos(&inregs,&outregs);                 /* Int 21 */
  if (outregs.x.cflag & CARRY)              /* If the carry flag is set */
    status = outregs.x.ax;                  /*   get returned error */
  else                                      /* else                 */
    status = (outregs.x.cflag & CARRY);     /*   set status to NOERROR */
  return(status);
}


/**************************************************************************/
/*                                                                        */
/*  SUBROUTINE NAME:   dopen                                              */
/*                                                                        */
/**************************************************************************/

unsigned dopen(n)
char *n;
{
  unsigned status;

  inregs.x.ax = 0x6c00;                     /* Extended open */
  inregs.x.bx = 8320;                       /* Open mode (flags) */
  inregs.x.cx = 0;                          /* Create attr (ignore) */
  inregs.x.dx = 257;                        /* Function control (flags) */
  inregs.x.si = (unsigned)(n);              /* File name to open */
  inregs.x.di = -1;                         /* Parm list (null) */
  intdos(&inregs,&outregs);                 /* Int 21 */
  if (outregs.x.cflag & CARRY)              /* If the carry flag is set */
    status = outregs.x.ax;                  /*   get returned error */
  else                                      /* else                 */
    status = (outregs.x.cflag & CARRY);     /*   set status to NOERROR */
  return(status);
}


/**************************************************************************/
/*                                                                        */
/*  SUBROUTINE NAME:   ddelete                                            */
/*                                                                        */
/**************************************************************************/

unsigned ddelete(n)
char *n;                                    /* File to be deleted */
{
  unsigned status;

  inregs.x.ax = 0x4100;                     
  inregs.x.dx = (unsigned)(n);              
  intdos(&inregs,&outregs);                 
  if (outregs.x.cflag & CARRY)              /* If the carry flag is set */
    status = outregs.x.ax;                  /*   get returned error */
  else                                      /* else                 */
    status = (outregs.x.cflag & CARRY);     /*   set status to NOERROR */
  return(status);
}


/**************************************************************************/
/*                                                                        */
/*  SUBROUTINE NAME:   dread                                              */
/*                                                                        */
/**************************************************************************/

unsigned dread(h,s,o,l)
unsigned h;
unsigned s;
unsigned o;
unsigned l;
{
  unsigned status;

  inregs.x.ax = 0x3f00;                     /* Read from file or device */
  inregs.x.bx = h;                          /* File handle */
  segregs.ds  = s;                          /* Buffer segment */
  inregs.x.dx = o;                          /* Buffer offset */
  inregs.x.cx = l;                          /* Num of bytes to be read */
  intdosx(&inregs,&outregs,&segregs);
  if (outregs.x.cflag & CARRY)              /* If the carry flag is set */
    status = outregs.x.ax;                  /*   get returned error */
  else                                      /* else                 */
    status = (outregs.x.cflag & CARRY);     /*   set status to NOERROR */
  return(status);
}


/**************************************************************************/
/*                                                                        */
/*  SUBROUTINE NAME:   dwrite                                             */
/*                                                                        */
/**************************************************************************/

unsigned dwrite(handle,segment,offset,length)
unsigned handle;
unsigned segment;
unsigned offset;
unsigned length;
{
  unsigned status;
  unsigned write_len;                       /* Save area for num of bytes to write */

  inregs.x.ax = 0x4000;                     /* Write to file or device */
  inregs.x.bx = handle;                     
  segregs.ds  = segment;                    
  inregs.x.dx = offset;                     
  inregs.x.cx = length;                     
  write_len = length;                       
  intdosx(&inregs,&outregs,&segregs);
  if (outregs.x.cflag & CARRY)              /* If the carry flag is set */
    status = outregs.x.ax;                  /*   get returned error */
  else                                      /* else                 */
    status = (outregs.x.cflag & CARRY);     /*   set status to NOERROR */
  if (status == NOERROR)                    /* If there was not an error */
  {
    if (write_len != outregs.x.ax)          /* and didn't write reqtd num bytes */
      disk_full = TRUE;                     /* Then, disk is full. Ret error */
  }
  return(status);
}


/**************************************************************************/
/*                                                                        */
/*  SUBROUTINE NAME:   dclose                                             */
/*                                                                        */
/**************************************************************************/

unsigned dclose(h)
unsigned h;
{
  unsigned status;

  inregs.x.ax = 0x3e00;                     /* Close a file handle */
  inregs.x.bx = h;                          /* File han ret by open/create */
  intdos(&inregs,&outregs);
  if (outregs.x.cflag & CARRY)              /* If the carry flag is set */
    status = outregs.x.ax;                  /*   get returned error */
  else                                      /* else                 */
    status = (outregs.x.cflag & CARRY);     /*   set status to NOERROR */
  return(status);
}


/**************************************************************************/
/*                                                                        */
/*  SUBROUTINE NAME:   dchmod                                             */
/*                                                                        */
/**************************************************************************/

unsigned dchmod(n,a)
char     *n;
unsigned a;
{
  unsigned status;

  inregs.x.ax = 0x4300 | (a & 0x00ff);       /* Change file mode */
  inregs.x.dx = (unsigned)(n);               /* Ptr to asciiz path name */
  intdos(&inregs,&outregs);
  if (outregs.x.cflag & CARRY)               /* If the carry flag is set */
    status = outregs.x.ax;                   /*   get returned error */
  else                                       /* else */
    status = (outregs.x.cflag & CARRY);      /*   set status to NOERROR */
  return(status);
}


/**************************************************************************/
/*                                                                        */
/*  SUBROUTINE NAME:   dsearchf                                           */
/*                                                                        */
/**************************************************************************/

unsigned dsearchf(s,t,a)
char     *s;
struct   filedata *t;
unsigned a;
{
  unsigned i;
  unsigned status;

  inregs.x.ax = 0x4e00;                     /* Find first matching file */
  inregs.x.cx = a;                          /* Attrib used in search */
  inregs.x.dx = (unsigned)(s);              /* Asciiz string ptr */
  intdos(&inregs,&outregs);
  if (outregs.x.cflag & CARRY)              /* If the carry flag is set */
    status = outregs.x.ax;                  /*   get returned error */
  else                                      /* else */
    status = (outregs.x.cflag & CARRY);     /* set status to NOERROR */
  if (status == NOERROR)
  {
    t->attribute = getbyte(_psp,0x80+21);
    t->time      = getword(_psp,0x80+22);
    t->date      = getword(_psp,0x80+24);
    t->size      = getdword(_psp,0x80+26);
    for (i = 0; i < 15; i++)
      t->name[i] = getbyte(_psp,0x80+30+i);
    strcpy(fix_es_reg,NULL);
  }
  return(status);
}


/**************************************************************************/
/*                                                                        */
/*  SUBROUTINE NAME:   dsearchn                                           */
/*                                                                        */
/**************************************************************************/

unsigned dsearchn(t)
struct filedata *t;
{
  unsigned i;
  unsigned status;

  inregs.x.ax = 0x4f00;                     /* Find next matching file */
  intdos(&inregs,&outregs);                 /* DTA contains prev call info */
  if (outregs.x.cflag & CARRY)              /* If the carry flag is set */
    status = outregs.x.ax;                  /*   get returned error */
  else                                      /* else */
    status = (outregs.x.cflag & CARRY);     /*   set status to NOERROR */
  if (status == NOERROR)
  {
    t->attribute = getbyte(_psp,0x80+21);
    t->time      = getword(_psp,0x80+22);
    t->date      = getword(_psp,0x80+24);
    t->size      = getdword(_psp,0x80+26);
    for (i = 0; i < 15; i++)
      t->name[i] = getbyte(_psp,0x80+30+i);
    strcpy(fix_es_reg,NULL);
  }
  return(status);
}


/**************************************************************************/
/*                                                                        */
/*  SUBROUTINE NAME:   dexit                                              */
/*                                                                        */
/**************************************************************************/

unsigned dexit(s)
unsigned s;
{
  if (target_full)                     /* If unable to copy any files */
    s = ERRLEVEL8;                     /* Insufficient memory */
  exit(s);                             /* terminate program */
  return(NULLARG);           /* note that the return never happens */
}


/**************************************************************************/
/*                                                                        */
/*  SUBROUTINE NAME:   dta_save                                           */
/*                                                                        */
/**************************************************************************/

void dta_save(t,l)
char     *t;
unsigned l;
{
  unsigned i;

  for (i = 0; i < l; i++)
    *(t+i) = getbyte(_psp,0x80+i);
  strcpy(fix_es_reg,NULL);
  return;
}


/**************************************************************************/
/*                                                                        */
/*  SUBROUTINE NAME:   dta_restore                                        */
/*                                                                        */
/**************************************************************************/

void dta_restore(t,l)
char     *t;
unsigned l;
{
  unsigned i;

  for (i = 0; i < l; i++)
    putbyte(_psp,0x80+i,*(t+i));
    strcpy(fix_es_reg,NULL);
  return;
}


/**************************************************************************/
/*                                                                        */
/*  SUBROUTINE NAME:   getbyte                                            */
/*                                                                        */
/**************************************************************************/

char getbyte(msegment,moffset)
unsigned int msegment;
unsigned int moffset;
{
  char far * cPtr;

  FP_SEG(cPtr) = msegment;
  FP_OFF(cPtr) = moffset;
  strcpy(fix_es_reg,NULL);
  return(*cPtr);
}


/**************************************************************************/
/*                                                                        */
/*  SUBROUTINE NAME:   getword                                            */
/*                                                                        */
/**************************************************************************/

unsigned getword(msegment,moffset)
unsigned int msegment;
unsigned int moffset;
{
  unsigned far * uPtr;

  FP_SEG(uPtr) = msegment;
  FP_OFF(uPtr) = moffset;
  strcpy(fix_es_reg,NULL);
  return(*uPtr);
}


/**************************************************************************/
/*                                                                        */
/*  SUBROUTINE NAME:   getdword                                           */
/*                                                                        */
/**************************************************************************/

long getdword(msegment,moffset)
unsigned int msegment;
unsigned int moffset;
{
  long far * lPtr;

  FP_SEG(lPtr) = msegment;
  FP_OFF(lPtr) = moffset;
  strcpy(fix_es_reg,NULL);
  return(*lPtr);
}


/**************************************************************************/
/*                                                                        */
/*  SUBROUTINE NAME:   putbyte                                            */
/*                                                                        */
/**************************************************************************/

void putbyte(msegment,moffset,value)
unsigned int msegment;
unsigned int moffset;
char     value;
{
  char far * cPtr;

  FP_SEG(cPtr) = msegment;
  FP_OFF(cPtr) = moffset;
  *cPtr        = value;
  strcpy(fix_es_reg,NULL);
  return;
}


/**************************************************************************/
/*                                                                        */
/*  SUBROUTINE NAME:   putword                                            */
/*                                                                        */
/**************************************************************************/

void putword(msegment,moffset,value)
unsigned int msegment;
unsigned int moffset;
unsigned value;
{
  unsigned far * uPtr;

  FP_SEG(uPtr) = msegment;
  FP_OFF(uPtr) = moffset;
  *uPtr        = value;
  strcpy(fix_es_reg,NULL);
  return;
}


/**************************************************************************/
/*                                                                        */
/*  SUBROUTINE NAME:   putdword                                           */
/*                                                                        */
/**************************************************************************/

void putdword(msegment,moffset,value)
unsigned int msegment;
unsigned int moffset;
long     value;
{
  long far * lPtr;

  FP_SEG(lPtr) = msegment;
  FP_OFF(lPtr) = moffset;
  *lPtr        = value;
  strcpy(fix_es_reg,NULL);
  return;
}


/**************************************************************************/
/*                                                                        */
/*  SUBROUTINE NAME:   load_msg                                           */
/*                                                                        */
/*  SUBROUTINE FUNCTION:  Load the set of REPLACE Utility messages to     */
/*                        become available for display_msg call.          */
/*                                                                        */
/*  ERROR EXIT:        Utility will be terminated by sysloadmsg if        */
/*                     version check is incorrect.                        */
/*                                                                        */
/*  EXTERNAL REF:      SYSLOADMSG                                         */
/*                                                                        */
/**************************************************************************/

void load_msg()
{
  sysloadmsg(&inregs,&outregs);        /* Load utility messages */
  if (outregs.x.cflag & CARRY)
  {
    sysdispmsg(&outregs,&outregs);     /* If load error, display err msg */
    dexit(ERRLEVEL1);
  }
  return;                              /* Return with no error */
}


/**************************************************************************/
/*                                                                        */
/*  SUBROUTINE NAME:   dcompare                                           */
/*                                                                        */
/*  SUBROUTINE FUNCTION:  Check a Y/N response using an Int21 Get         */
/*                        Extended Country information.                   */
/*                                                                        */
/*  INPUT:             function  (character to check) (global)            */
/*                                                                        */
/*  OUTPUT:            status    (carry flag if set or response)          */
/*                                                                        */
/*  NORMAL EXIT:       AX=0=No  (status = 2)                              */
/*                     AX=1=Yes (status = 1)                              */
/*                                                                        */
/**************************************************************************/

unsigned dcompare()
{
  unsigned status;                     /* Receives error cond or Y/N */

  inregs.x.dx = outregs.x.ax;          /* Char rec'd by msg hndlr to be ckd */
  inregs.x.ax = 0x6523;                /* 65=Get-Ext-Cty 23=Y/N chk */
  intdos(&inregs,&outregs);            /* Int21 call */

  /* If carry flag is set or invalid return code, then input is not valid */
  if ((outregs.x.cflag & CARRY) || (outregs.x.ax > 1))
    not_valid_input = TRUE;            /* input is not valid */
  else
  {
    not_valid_input = FALSE;           /* input is valid */
    if (outregs.x.ax == 0)
      status = 2;                      /* 2 = No */
    else
      status = 1;                      /* 1 = Yes */
  }
  return(status);
}


/**************************************************************************/
/*                                                                        */
/*  SUBROUTINE NAME:   display_msg                                        */
/*                                                                        */
/*  SUBROUTINE FUNCTION:  The correct message called by main is displayed */
/*                        to standard out or standard error.              */
/*                                                                        */
/*  INPUT:             msg_num   (message number to display)              */
/*                     outline   (string for replacement parm)            */
/*                                                                        */
/*  OUTPUT:            none                                               */
/*                                                                        */
/*  NORMAL EXIT:       The correct message called will be displayed to    */
/*                     standard out or standard error.                    */
/*                                                                        */
/*  ERROR EXIT:        Display error message corresponding to number      */
/*                     returned in AX.                                    */
/*                                                                        */
/*  EXTERNAL REF:      SYSDISPMSG                                         */
/*                                                                        */
/**************************************************************************/

void display_msg(msg_num,outline)
int  msg_num;                          /* Message number #define'd */
char *outline;                         /* String for replacemnt parm */
{
  unsigned char function;              /* Y/N response or press key? */
  unsigned int message,                /* Message number to display */
	       msg_class,              /* Which class of messages? */
	       sub_cnt,                /* Number of substitutions? */
	       handle;                 /* Display where? */

  struct sublist
  {
    unsigned char size;                /* Points to next sublist */
    unsigned char reserved;            /* Required for syddispmsg */
    unsigned far  *value;              /* Data pointer */
    unsigned char id;                  /* Id of substitution parm (%1) */
    unsigned char flags;               /* Format of data - (a0sstttt) */
    unsigned char max_width;           /* Maximum field width */
    unsigned char min_width;           /* Minimum field width */
    unsigned char pad_char;            /* char to pad field */
  } sublist;

  switch (msg_num)                     /* Which msg to display? */
  {
    case MSG_NOMEM :
	function  = NO_INPUT;          /* Y/N response or press key? */
	message   = 8;                 /* Message number to display */
	msg_class = EXT_ERR_CLASS;     /* Which class of messages? */
	sub_cnt   = SUBCNT0;           /* Number of substitutions? */
	handle    = STDERR;            /* Display where? */
	break;
    case MSG_INCOMPAT :
	function  = NO_INPUT;          /* Y/N response or press key? */
	message   = 11;                /* Message number to display */
	msg_class = PARSE_ERR_CLASS;   /* Which class of messages? */
	sub_cnt   = SUBCNT0;           /* Number of substitutions? */
	handle    = STDERR;            /* Display where? */
	break;
    case MSG_NOSOURCE :
	function  = NO_INPUT;          /* Y/N response or press key? */
	message   = 2;                 /* Message number to display */
	msg_class = UTILITY_CLASS;     /* Which class of messages? */
	sub_cnt   = SUBCNT0;           /* Number of substitutions? */
	handle    = STDERR;            /* Display where? */
	break;
    case MSG_NONEREPL :
	function  = NO_INPUT;          /* Y/N response or press key? */
	message   = 3;                 /* Message number to display */
	msg_class = UTILITY_CLASS;     /* Which class of messages? */
	sub_cnt   = SUBCNT0;           /* Number of substitutions? */
	handle    = STDOUT;            /* Display where? */
	break;
    case MSG_NONEADDE :
	function  = NO_INPUT;          /* Y/N response or press key? */
	message   = 4;                 /* Message number to display */
	msg_class = UTILITY_CLASS;     /* Which class of messages? */
	sub_cnt   = SUBCNT0;           /* Number of substitutions? */
	handle    = STDOUT;            /* Display where? */
	break;
    case MSG_START :
	function  = NO_INPUT;          /* Y/N response or press key? */
	message   = 21;                /* Message number to display */
	msg_class = UTILITY_CLASS;     /* Which class of messages? */
	sub_cnt   = SUBCNT0;           /* Number of substitutions? */
	handle    = STDERR;            /* Display where? */
	break;
    case MSG_ERRFNF :
	function  = NO_INPUT;          /* Y/N response or press key? */
	message   = 2;                 /* Message number to display */
	msg_class = EXT_ERR_CLASS;     /* Which class of messages? */
	sub_cnt   = SUBCNT1;           /* Number of substitutions? */
	handle    = STDOUT;            /* Display where? */
	break;
    case MSG_ERRPNF :
	function  = NO_INPUT;          /* Y/N response or press key? */
	message   = 3;                 /* Message number to display */
	msg_class = EXT_ERR_CLASS;     /* Which class of messages? */
	sub_cnt   = SUBCNT1;           /* Number of substitutions? */
	handle    = STDOUT;            /* Display where? */
	break;
    case MSG_ERRACCD :
	function  = NO_INPUT;          /* Y/N response or press key? */
	message   = 5;                 /* Message number to display */
	msg_class = EXT_ERR_CLASS;     /* Which class of messages? */
	sub_cnt   = SUBCNT1;           /* Number of substitutions? */
	handle    = STDOUT;            /* Display where? */
	break;
    case MSG_ERRDRV :
	function  = NO_INPUT;          /* Y/N response or press key? */
	message   = 15;                /* Message number to display */
	msg_class = EXT_ERR_CLASS;     /* Which class of messages? */
	sub_cnt   = SUBCNT1;           /* Number of substitutions? */
	handle    = STDERR;            /* Display where? */
	break;
    case MSG_BADPARM :
	function  = NO_INPUT;          /* Y/N response or press key? */
	message   = 10;                /* Message number to display */
	msg_class = PARSE_ERR_CLASS;   /* Which class of messages? */
	sub_cnt   = SUBCNT1;           /* Number of substitutions? */
	handle    = STDERR;            /* Display where? */
	break;
    case MSG_WARNSAME :
	function  = NO_INPUT;          /* Y/N response or press key? */
	message   = 11;                /* Message number to display */
	msg_class = UTILITY_CLASS;     /* Which class of messages? */
	sub_cnt   = SUBCNT1;           /* Number of substitutions? */
	handle    = STDERR;            /* Display where? */
	break;
    case MSG_ERRDSKF :
	function  = NO_INPUT;          /* Y/N response or press key? */
	message   = 12;                /* Message number to display */
	msg_class = UTILITY_CLASS;     /* Which class of messages? */
	sub_cnt   = SUBCNT1;           /* Number of substitutions? */
	handle    = STDERR;            /* Display where? */
	break;
    case MSG_REPLACIN :
	function  = NO_INPUT;          /* Y/N response or press key? */
	message   = 13;                /* Message number to display */
	msg_class = UTILITY_CLASS;     /* Which class of messages? */
	sub_cnt   = SUBCNT1;           /* Number of substitutions? */
	handle    = STDOUT;            /* Display where? */
	break;
    case MSG_ADDING :
	function  = NO_INPUT;          /* Y/N response or press key? */
	message   = 14;                /* Message number to display */
	msg_class = UTILITY_CLASS;     /* Which class of messages? */
	sub_cnt   = SUBCNT1;           /* Number of substitutions? */
	handle    = STDOUT;            /* Display where? */
	break;
    case MSG_SOMEREPL :
	function  = NO_INPUT;          /* Y/N response or press key? */
	message   = 15;                /* Message number to display */
	msg_class = UTILITY_CLASS;     /* Which class of messages? */
	sub_cnt   = SUBCNT1;           /* Number of substitutions? */
	handle    = STDOUT;            /* Display where? */
	break;
    case MSG_SOMEADDE :
	function  = NO_INPUT;          /* Y/N response or press key? */
	message   = 16;                /* Message number to display */
	msg_class = UTILITY_CLASS;     /* Which class of messages? */
	sub_cnt   = SUBCNT1;           /* Number of substitutions? */
	handle    = STDOUT;            /* Display where? */
	break;
    case MSG_NONFOUND :
	function  = NO_INPUT;          /* Y/N response or press key? */
	message   = 17;                /* Message number to display */
	msg_class = UTILITY_CLASS;     /* Which class of messages? */
	sub_cnt   = SUBCNT1;           /* Number of substitutions? */
	handle    = STDOUT;            /* Display where? */
	break;
    case MSG_QREPLACE :
	function  = DOS_CON_INPUT;     /* Y/N response or press key? */
	message   = 22;                /* Message number to display */
	msg_class = UTILITY_CLASS;     /* Which class of messages? */
	sub_cnt   = SUBCNT1;           /* Number of substitutions? */
	handle    = STDERR;            /* Display where? */
	break;
    case MSG_QADD :
	function  = DOS_CON_INPUT;     /* Y/N response or press key? */
	message   = 23;                /* Message number to display */
	msg_class = UTILITY_CLASS;     /* Which class of messages? */
	sub_cnt   = SUBCNT1;           /* Number of substitutions? */
	handle    = STDERR;            /* Display where? */
	break;
    case MSG_XTRAPARM :
	function  = NO_INPUT;          /* Y/N response or press key? */
	message   = 1;                 /* Message number to display */
	msg_class = PARSE_ERR_CLASS;   /* Which class of messages? */
	sub_cnt   = SUBCNT1;           /* Number of substitutions? */
	handle    = STDERR;            /* Display where? */
	break;
    case MSG_BADSWTCH :
	function  = NO_INPUT;          /* Y/N response or press key? */
	message   = 3;                 /* Message number to display */
	msg_class = PARSE_ERR_CLASS;   /* Which class of messages? */
	sub_cnt   = SUBCNT1;           /* Number of substitutions? */
	handle    = STDERR;            /* Display where? */
	break;
    default :
      if (msg_num >= MSG_OPTIONS_FIRST && msg_num <= MSG_OPTIONS_LAST)
      {
	function  = NO_INPUT;                 
	message   = msg_num;           /* Message number to display */
	msg_class = UTILITY_CLASS;
	sub_cnt   = SUBCNT0;           /* Number of substitutions? */
	handle    = STDOUT;            /* Display where? */
	break;
      }
  }

  switch (msg_num)
  {
    case MSG_NOMEM    :                          /* Insufficient memory */
    case MSG_INCOMPAT :                          /* Invalid parameter combo */
    case MSG_NOSOURCE :                          /* Source path required */
    case MSG_NONEREPL :                          /* No files replaced */
    case MSG_NONEADDE :                          /* No files added */
    case MSG_START    :
	inregs.x.ax = message;                   /* Press any key... */
	inregs.x.bx = handle;                    /* STDERR or STDOUT */
	inregs.x.cx = sub_cnt;                   /* SUBCNT0 */
	inregs.h.dl = function;                  /* NO_INPUT */
	inregs.h.dh = (unsigned char)msg_class;  /* Extended, Parse or Utility */
	sysdispmsg(&inregs,&outregs);            /* Call common msg service */
	break;
    case MSG_BADPARM  :                          /* Invalid parameter */
    case MSG_XTRAPARM :                          /* Too many parameters */
    case MSG_BADSWTCH :                          /* Invalid switch */
    case MSG_ERRFNF   :                          /* File not found */
    case MSG_ERRPNF   :                          /* Path not found */
    case MSG_ERRACCD  :                          /* Access denied */
    case MSG_ERRDRV   :                          /* Invalid drive specification */
    case MSG_WARNSAME :                          /* File cannot be copied... */
    case MSG_ERRDSKF  :
	sublist.value     = (unsigned far *)outline;  /* Insufficient disk space */
	sublist.size      = SUBLIST_LENGTH;
	sublist.reserved  = RESERVED;
	sublist.id        = 0;
	sublist.flags     = STR_INPUT;
	sublist.max_width = 0;
	sublist.min_width = 1;
	sublist.pad_char  = BLNK;
	inregs.x.ax       = message;                  /* Which message? */
	inregs.x.bx       = handle;                   /* STDERR or STDOUT */
	inregs.x.si       = (unsigned int)&sublist;   /* SUBCNT0 */
	inregs.x.cx       = sub_cnt;                  /* NO_INPUT */
	inregs.h.dl       = function;                 /* Extended, Parse or Utility */
	inregs.h.dh       = (unsigned char)msg_class; /* Call common msg service */
	sysdispmsg(&inregs,&outregs);
	break;
    case MSG_SOMEREPL :                               /* %1 file(s) replaced */
    case MSG_SOMEADDE :
	sublist.value     = (unsigned far *)outline;  /* %1 file(s) added */
	sublist.size      = SUBLIST_LENGTH;
	sublist.reserved  = RESERVED;
	sublist.id        = 1;
	sublist.flags     = DEC_INPUT;
	sublist.max_width = 0;
	sublist.min_width = 1;
	sublist.pad_char  = BLNK;
	inregs.x.ax       = message;                  /* Which message? */
	inregs.x.bx       = handle;                   /* STDERR or STDOUT */
	inregs.x.si       = (unsigned int)&sublist;   /* SUBCNT1 */
	inregs.x.cx       = sub_cnt;                  /* NO_INPUT */
	inregs.h.dl       = function;                 /* Extended, Parse or Utility */
	inregs.h.dh       = (unsigned char)msg_class; /* Call common msg service */
	sysdispmsg(&inregs,&outregs);
	break;
    case MSG_REPLACIN :                               /* Replacing %1 */
    case MSG_ADDING   :                               /* Adding %1 */
    case MSG_NONFOUND :                               /* No files found */
    case MSG_QREPLACE :                               /* Replace %1? (Y/N) */
    case MSG_QADD     :
	sublist.value     = (unsigned far *)outline;  /* Add %1? (Y/N) */
	sublist.size      = SUBLIST_LENGTH;
	sublist.reserved  = RESERVED;
	sublist.id        = 1;
	sublist.flags     = STR_INPUT;
	sublist.max_width = 0;
	sublist.min_width = 1;
	sublist.pad_char  = BLNK;
	inregs.x.ax       = message;                  /* Which message? */
	inregs.x.bx       = handle;                   /* STDERR or STDOUT*/
	inregs.x.si       = (unsigned int)&sublist;   /* SUBCNT1 */
	inregs.x.cx       = sub_cnt;                  /* NO_INPUT or DOS_CON_INPUT */
	inregs.h.dl       = function;                 /* Extended, Parse or Utility */
	inregs.h.dh       = (unsigned char)msg_class; /* Call common msg service */
	sysdispmsg(&inregs,&outregs);
	break;
    default           :
      if (msg_num >= MSG_OPTIONS_FIRST && msg_num <= MSG_OPTIONS_LAST)
      {
	inregs.x.ax = message;
	inregs.x.bx = handle;
	inregs.x.cx = sub_cnt;
	inregs.h.dl = function;
	inregs.h.dh = (unsigned char)msg_class;
	sysdispmsg(&inregs,&outregs);
	break;
      }
      else
      {
	restore();
	dexit(ERRLEVEL1);
	break;
      }
  }

  strcpy(fix_es_reg,NULL);             /* (Set es reg correct) */
  if (outregs.x.cflag & CARRY)         /* Is the carry flag set? */
  {                                    /* Setup regs for extd-err */
    inregs.x.bx = STDERR;
    inregs.x.cx = SUBCNT0;
    inregs.h.dl = NO_INPUT;
    inregs.h.dh = EXT_ERR_CLASS;
    sysdispmsg(&inregs,&outregs);      /* Call to display ext_err msg */
    restore();
    dexit(ERRLEVEL1);
  }
  return;
}


/**************************************************************************/
/*                                                                        */
/*  SUBROUTINE NAME:   check_appendx_install                              */
/*                                                                        */
/*  SUBROUTINE FUNCTION:  Determine if append and correct version is      */
/*                        currently installed.                            */
/*                                                                        */
/*  INPUT:             none                                               */
/*                                                                        */
/*  OUTPUT:            status (TRUE or FALSE)                             */
/*                                                                        */
/**************************************************************************/

unsigned check_appendx_install()
{
  unsigned status = FALSE;

  inregs.x.ax = GETX_INSTALL;          /* Get Append /x status */
  int86(0x2f,&inregs,&outregs);        /* Make the call */
  if (outregs.h.al)
  {
    inregs.x.ax = GETX_VERSION;
    int86(0x2f,&inregs,&outregs);
    if (outregs.x.ax == X_INSTALLED)
      status = TRUE;
  }
  return(status);
}


/**************************************************************************/
/*                                                                        */
/*  SUBROUTINE NAME:   check_appendx                                      */
/*                                                                        */
/*  SUBROUTINE FUNCTION:  Get the append /x status.                       */
/*                                                                        */
/*  INPUT:             none                                               */
/*                                                                        */
/*  OUTPUT:            bx (contains append bits set)                      */
/*                                                                        */
/**************************************************************************/

unsigned check_appendx()
{
  inregs.x.ax = GETX_STATUS;           /* Get Append /x status */
  int86(0x2f,&inregs,&outregs);        /* Make the call */
  return(outregs.x.bx);
}


/**************************************************************************/
/*                                                                        */
/*  SUBROUTINE NAME:   set_appendx                                        */
/*                                                                        */
/*  SUBROUTINE FUNCTION:  Set the append /x status.                       */
/*                                                                        */
/*  INPUT:             set_state (turn appendx bit off or reset original) */
/*                                                                        */
/*  OUTPUT:            none                                               */
/*                                                                        */
/**************************************************************************/

void set_appendx(set_state)
unsigned set_state;
{
  inregs.x.ax = SETX_STATUS;           /* Set Append /x status */
  inregs.x.bx = set_state;
  int86(0x2f,&inregs,&outregs);
  return;
}


/**************************************************************************/
/*                                                                        */
/*  SUBROUTINE NAME:   parser_prep                                        */
/*                                                                        */
/*  SUBROUTINE FUNCTION:  Initialize all structures for the parser.       */
/*                                                                        */
/*  INPUT:             source (command line string)                       */
/*                                                                        */
/*  OUTPUT:            none                                               */
/*                                                                        */
/**************************************************************************/

void parser_prep(source)
char *source;                          /* Commandline */
{
  p_p.p_parmsx_address    = &p_px;               /* Address of extd parm list */
  p_p.p_num_extra         = 0;                   /* No extra declarations */

  p_px.p_minp             = MINPOSITION;         /* 1 required positional */
  p_px.p_maxp             = MAXPOSITION;         /* 2 maximum positionals */
  p_px.p_control1         = &p_con1;             /* pointer to next control blk */
  p_px.p_control2         = &p_con2;             /* pointer to next control blk */
  p_px.p_maxs             = 1;                   /* Specify # of switches */
  p_px.p_switch           = &p_swit;             /* Point to the switch blk */
  p_px.p_maxk             = 0;                   /* Specify # of keywords */

  p_con1.p_match_flag     = REQ_FILESPEC;        /* File spec required */
  p_con1.p_function_flag  = CAPRESULT;           /* Cap result by file table */
  p_con1.p_result_buf     = (unsigned int)&rslt1;
  p_con1.p_value_list     = (unsigned int)&novals;
  p_con1.p_nid            = 0;

  p_con2.p_match_flag     = OPT_FILESPEC;        /* File spec & optional */
  p_con2.p_function_flag  = CAPRESULT;           /* Cap result by file table */
  p_con2.p_result_buf     = (unsigned int)&rslt1;
  p_con2.p_value_list     = (unsigned int)&novals;
  p_con2.p_nid            = 0;

  p_swit.sp_match_flag    = OPT_SWITCH;          /* Optional (switch) */
  p_swit.sp_function_flag = NOCAPPING;           /* Cap result by file table */
  p_swit.sp_result_buf    = (unsigned int)&rslt2;
  p_swit.sp_value_list    = (unsigned int)&novals;
  p_swit.sp_nid           = 7;                   /* One switch allowed */
  strcpy(p_swit.sp_keyorsw1,A_SW);               /* Identify the switch */
  strcat(p_swit.sp_keyorsw2,P_SW);               /* Identify the switch */
  strcat(p_swit.sp_keyorsw3,R_SW);               /* Identify the switch */
  strcat(p_swit.sp_keyorsw4,S_SW);               /* Identify the switch */
  strcat(p_swit.sp_keyorsw5,U_SW);               /* Identify the switch */
  strcat(p_swit.sp_keyorsw6,W_SW);               /* Identify the switch */
  strcat(p_swit.sp_keyorsw7,Q_SW);

  inregs.x.si = (unsigned int)source;            /* Make DS:SI point to source */
  inregs.x.cx = 0;                               /* Operand ordinal */
  inregs.x.di = (unsigned int)&p_p;              /* Address of parm list */
  return;
}


/**************************************************************************/
/*                                                                        */
/*  SUBROUTINE NAME:   display_exit                                       */
/*                                                                        */
/*  SUBROUTINE FUNCTION:  Display the message, then terminate the utility.*/
/*                                                                        */
/*  INPUT:             msg_num     (#define'd message to display)         */
/*                     outline     (sublist substitution)                 */
/*                     error_code  (errorlevel return code)               */
/*                                                                        */
/*  OUTPUT:            none                                               */
/*                                                                        */
/**************************************************************************/

void display_exit(msg_num,outline,error_code)
int  msg_num;                          /* Message number #define'd */
char *outline;
int  error_code;
{
  display_msg(msg_num,outline);        /* First, display the msg */
  restore();
  dexit(error_code);                   /* Then, terminate utility */
}


/**************************************************************************/
/*                                                                        */
/*  SUBROUTINE NAME:   setup_ctl_brk                                      */
/*                                                                        */
/*  SUBROUTINE FUNCTION:  Change the CTL BRK vector to point to handler   */
/*                        routine.                                        */
/*                                                                        */
/*  INPUT:             none                                               */
/*                                                                        */
/*  OUTPUT:            none                                               */
/*                                                                        */
/**************************************************************************/

void setup_ctl_brk()
{
  /* set the ctl brk vector to point to us */
  segread(&segregs);
  inregs.x.ax = SETVEC_CTLBRK;                   /* Set vector,ctl brk */
  inregs.x.dx = (unsigned)ctl_brk_handler;       /* Offset points to us */
  segregs.ds  = segregs.cs;
  intdosx(&inregs,&outregs,&segregs);            /* Int 21 */
  return;
}


/**************************************************************************/
/*                                                                        */
/*  SUBROUTINE NAME:   setup_crit_err                                     */
/*                                                                        */
/*  SUBROUTINE FUNCTION:  Change the critical error vector to point to    */
/*                        the handler routine.                            */
/*                                                                        */
/*  INPUT:             none                                               */
/*                                                                        */
/*  OUTPUT:            none                                               */
/*                                                                        */
/**************************************************************************/

void setup_crit_err()
{
  /* get and save original vector pointers */
  inregs.x.ax = GETVEC_CRITERR;               /* Get vector,crit err */
  intdosx(&inregs,&outregs,&segregs);         /* Int 21 */
  oldint24 = outregs.x.bx;                    /* Save orig offset */
  *((unsigned *)(&oldint24)+1) = segregs.es;
  strcpy(fix_es_reg,NULL);

  /* set the crit err vector to point to us */
  segread(&segregs);
  inregs.x.ax = SETVEC_CRITERR;               /* Set vector,crit err */
  inregs.x.dx = (unsigned)crit_err_handler;   /* Offset points to us */
  segregs.ds  = segregs.cs;
  intdosx(&inregs,&outregs,&segregs);         /* Int 21 */
  strcpy(fix_es_reg,NULL);
  return;
}


/**************************************************************************/
/*                                                                        */
/*  SUBROUTINE NAME:   restore                                            */
/*                                                                        */
/*  SUBROUTINE FUNCTION:  Restore the original appendx before exiting.    */
/*                                                                        */
/*  INPUT:             none                                               */
/*                                                                        */
/*  OUTPUT:            none                                               */
/*                                                                        */
/**************************************************************************/

void restore()
{
  /* restore append/x status */
  if (append_installed)
    set_appendx(x_status);        /* Reset append/x status */
  return;
}


#if SELECT_SUPPORT

/**************************************************************************/
/*                                                                        */
/*  SUBROUTINE NAME:   check_select                                       */
/*                                                                        */
/*  SUBROUTINE FUNCTION:  Perform INT 2F function to detect if SELECT     */
/*                        invoked REPLACE utility.  If so, store          */
/*                        returned information (number of files,          */
/*                        inclusion/exclusion list, and filenames).       */
/*                                                                        */
/*  INPUT:             none                                               */
/*                                                                        */
/*  OUTPUT:            none                                               */
/*                                                                        */
/**************************************************************************/

void check_select()
{
  int i;
  int index;
  struct SREGS segsloc;                /* Structure to move data seg */


  inregs.x.ax =  (unsigned int) DETECT_SELECT;   /* 1C01 */
  int86x(0x2f,&inregs,&outregs,&segregs);
  if (outregs.h.al == SELECT_PRESENT)            /* 0FFH if present, else 1 */
  {
    detect_select_flag = TRUE;
    num_select_files   = outregs.x.cx;
    exclusion_list     = outregs.h.bl;           /* Returns 0 or 1 */

    /*
     *  Move the data from Select's data segment into Replace's
     */
    segread(&segsloc);                           /* Read from Select data seg */
    movedata(segregs.ds, outregs.x.si, segsloc.ds,
	     (unsigned int)select_files_temp, outregs.x.cx * 12);

    /* Get every filename */
    for (index = 0; index < num_select_files; index++)
    {
      for (i = 0; i < 12; i++)                   /* Filename length */
      {
	/* Replace blanks with nulls so names will be null terminated */
	if (select_files_temp[index].name[i] == BLANK)
	  select_files[index].name[i] = NULL;
	else
	  select_files[index].name[i] = select_files_temp[index].name[i];
      }
      select_files[index].name[13] == NULL;      /* Null terminate strings */
    }
  }
  strcpy(fix_es_reg,NULL);
}


/**************************************************************************/
/*                                                                        */
/*  SUBROUTINE NAME:   check_select_list                                  */
/*                                                                        */
/*  SUBROUTINE FUNCTION:  Compare SELECT list of filenames with possible  */
/*                        files to be added/replaced.  If match is        */
/*                        found, check inclusion/exclusion flag and       */
/*                        return decision to copy file or not.            */
/*                                                                        */
/*  INPUT:             Possible list of files to add/replace              */
/*                                                                        */
/*  OUTPUT:            True/False                                         */
/*                                                                        */
/**************************************************************************/

unsigned check_select_list(fl)
struct filedata *fl;
{
  int index;
  int samefile = FALSE;

  for (index = 0; ((index < num_select_files) && (!samefile)); index++)
  {
    /* For each possible file, check against SELECT list */
    samefile = same(fl->name,select_files[index].name);
  }

  /* Truth table */
  if ((exclusion_list) == (char)(samefile))
    return(FALSE);
  return(TRUE);
}

#endif  /* SELECT_SUPPORT */


=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\replace\_msgret.asm ===
page	60,132
name	_msgret
title	C	to Message Retriever

;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

;-------------------------------------------------------------------
;
;	MODULE: 	_msgret
;
;	PURPOSE:	Supplies an interface between C programs and
;			the DOS 3.3 message retriever
;
;	CALLING FORMAT:
;			sysloadmsg(&inregs,&outregs);
;			sysgetmsg(&inregs,&outregs);
;			sysdispmsg(&inregs,&outregs);
;
;
;	DATE:		5-21-87
;
;-------------------------------------------------------------------

	INCLUDE SYSMSG.INC		;PERMIT SYSTEM MESSAGE HANDLER DEFINITION ;AN000;

	MSG_UTILNAME <REPLACE>		;IDENTIFY THE COMPONENT 		;AN000;

	.8087									;AN000;
_TEXT	SEGMENT BYTE PUBLIC 'CODE'						;AN000;
_TEXT	ENDS									;AN000;
_DATA	SEGMENT WORD PUBLIC 'DATA'						;AN000;
_DATA	ENDS									;AN000;
CONST	SEGMENT WORD PUBLIC 'CONST'						;AN000;
CONST	ENDS									;AN000;
_BSS	SEGMENT WORD PUBLIC 'BSS'						;AN000;
_BSS	ENDS									;AN000;
DGROUP	GROUP	CONST, _BSS, _DATA						;AN000;
	ASSUME	CS: _TEXT, DS: _TEXT, SS: DGROUP, ES: DGROUP			;AN000;


	public	_sysloadmsg							;AN000;
	public	_sysgetmsg							;AN000;
	public	_sysdispmsg							;AN000;

;-------------------------------------------------------------------
;-------------------------------------------------------------------

_DATA	segment 								;AN000;
.XLIST										;AN000;
.XCREF										;AN000;
	MSG_SERVICES <MSGDATA>		;DATA AREA FOR THE MESSAGE HANDLER	;AN000;
.LIST										;AN000;
.CREF										;AN000;
_DATA	ends									;AN000;


_TEXT	segment 								;AN000;

;-------------------------------------------------------------------

; =  =	=  =  =  =  =  =  =  =	=  =

					;DEFAULT=CHECK DOS VERSION		;AN000;
					;DEFAULT=NEARmsg			;AN000;
					;DEFAULT=INPUTmsg			;AN000;
					;DEFAULT=NUMmsg 			;AN000;
					;DEFAULT=NO TIMEmsg			;AN000;
					;DEFAULT=NO DATEmsg			;AN000;
;	MSG_SERVICES <LOADmsg,GETmsg,DISPLAYmsg,CHARmsg,NUMmsg,TIMEmsg,DATEmsg,INPUTmsg,FARmsg>;AN000;
;	MSG_SERVICES <REPLACE.CLA,REPLACE.CL1,REPLACE.CL2>	   ;MSG TEXT	;AN000;
.XLIST										;AN000;
.XCREF										;AN000;
;	MSG_SERVICES <MSGDATA>		;DATA AREA FOR THE MESSAGE HANDLER	;AN000;
	MSG_SERVICES <LOADmsg,GETmsg,DISPLAYmsg,CHARmsg,NUMmsg,TIMEmsg,DATEmsg,INPUTmsg,FARmsg>;AN000;
	MSG_SERVICES <REPLACE.CLA,REPLACE.CL1,REPLACE.CL2> ;MSG TEXT		;AN000;
.LIST										;AN000;
.CREF										;AN000;
;-------------------------------------------------------------------		;AN000;

_sysloadmsg proc near								;AN000;

	push	bp			; save user's base pointer              ;AN000;
	mov	bp,sp			; set bp to current sp			;AN000;
	push	di			; save some registers			;AN000;
	push	si								;AN000;

;	copy C inregs into proper registers					;AN000;

	mov	di,[bp+4]		; fix di (arg 0)			;AN000;

;-------------------------------------------------------------------

	mov	ax,[di+0ah]		; load di				;AN000;
	push	ax			; the di value from inregs is now on stack;AN000;

	mov	ax,[di+00]		; get inregs.x.ax			;AN000;
	mov	bx,[di+02]		; get inregs.x.bx			;AN000;
	mov	cx,[di+04]		; get inregs.x.cx			;AN000;
	mov	dx,[di+06]		; get inregs.x.dx			;AN000;
	mov	si,[di+08]		; get inregs.x.si			;AN000;
	pop	di			; get inregs.x.di from stack		;AN000;

	push	bp			; save base pointer			;AN000;

;-------------------------------------------------------------------
	call	sysloadmsg		; call the message retriever		;AN000;
;-------------------------------------------------------------------

	pop	bp			; restore base pointer			;AN000;
	push	di			; the di value from call is now on stack;AN000;
	mov	di,[bp+6]		; fix di (arg 1)			;AN000;

	mov	[di+00],ax		; load outregs.x.ax			;AN000;
	mov	[di+02],bx		; load outregs.x.bx			;AN000;
	mov	[di+04],cx		; load outregs.x.cx			;AN000;
	mov	[di+06],dx		; load outregs.x.dx			;AN000;
	mov	[di+08],si		; load outregs.x.si			;AN000;

	lahf				; get flags into ax			;AN000;
	mov	al,ah			; move into low byte			;AN000;
	mov	[di+0ch],ax		; load outregs.x.cflag			;AN000;

	pop	ax			; get di from stack			;AN000;
	mov	[di+0ah],ax		; load outregs.x.di			;AN000;

;-------------------------------------------------------------------

	pop	si			; restore registers			;AN000;
	pop	di								;AN000;
	mov	sp,bp			; restore sp				;AN000;
	pop	bp			; restore user's bp                     ;AN000;
	ret									;AN000;

_sysloadmsg endp								;AN000;


_sysgetmsg proc near								;AN000;

	push	bp			; save user's base pointer              ;AN000;
	mov	bp,sp			; set bp to current sp			;AN000;
	push	di			; save some registers			;AN000;
	push	si								;AN000;

;	copy C inregs into proper registers					;AN000;

	mov	di,[bp+4]		; fix di (arg 0)			;AN000;

;-------------------------------------------------------------------

	mov	ax,[di+0ah]		; load di				;AN000;
	push	ax			; the di value from inregs is now on stack;AN000;

	mov	ax,[di+00]		; get inregs.x.ax			;AN000;
	mov	bx,[di+02]		; get inregs.x.bx			;AN000;
	mov	cx,[di+04]		; get inregs.x.cx			;AN000;
	mov	dx,[di+06]		; get inregs.x.dx			;AN000;
	mov	si,[di+08]		; get inregs.x.si			;AN000;
	pop	di			; get inregs.x.di from stack		;AN000;

	push	bp			; save base pointer			;AN000;

;-------------------------------------------------------------------
	call	sysgetmsg		; call the message retriever		;AN000;
;-------------------------------------------------------------------

	pop	bp			; restore base pointer			;AN000;
	push	di			; the di value from call is now on stack;AN000;
	mov	di,[bp+6]		; fix di (arg 1)			;AN000;

	mov	[di+00],ax		; load outregs.x.ax			;AN000;
	mov	[di+02],bx		; load outregs.x.bx			;AN000;
	mov	[di+04],cx		; load outregs.x.cx			;AN000;
	mov	[di+06],dx		; load outregs.x.dx			;AN000;
	mov	[di+08],si		; load outregs.x.si			;AN000;

	lahf				; get flags into ax			;AN000;
	mov	al,ah			; move into low byte			;AN000;
	mov	[di+0ch],ax		; load outregs.x.cflag			;AN000;

	pop	ax			; get di from stack			;AN000;
	mov	[di+0ah],ax		; load outregs.x.di			;AN000;

;-------------------------------------------------------------------

	pop	si			; restore registers			;AN000;
	pop	di								;AN000;
	mov	sp,bp			; restore sp				;AN000;
	pop	bp			; restore user's bp                     ;AN000;
	ret									;AN000;

_sysgetmsg endp 								;AN000;

_sysdispmsg proc near								;AN000;

	push	bp			; save user's base pointer              ;AN000;
	mov	bp,sp			; set bp to current sp			;AN000;
	push	di			; save some registers			;AN000;
	push	si								;AN000;

;	copy C inregs into proper registers					;AN000;

	mov	di,[bp+4]		; fix di (arg 0)			;AN000;

;-------------------------------------------------------------------

	mov	ax,[di+0ah]		; load di				;AN000;
	push	ax			; the di value from inregs is now on stack;AN000;

	mov	ax,[di+00]		; get inregs.x.ax			;AN000;
	mov	bx,[di+02]		; get inregs.x.bx			;AN000;
	mov	cx,[di+04]		; get inregs.x.cx			;AN000;
	mov	dx,[di+06]		; get inregs.x.dx			;AN000;
	mov	si,[di+08]		; get inregs.x.si			;AN000;
	pop	di			; get inregs.x.di from stack		;AN000;

	push	bp			; save base pointer			;AN000;

;-------------------------------------------------------------------
	call	sysdispmsg		; call the message retriever		;AN000;
;-------------------------------------------------------------------

	pop	bp			; restore base pointer			;AN000;
	push	di			; the di value from call is now on stack;AN000;
	mov	di,[bp+6]		; fix di (arg 1)			;AN000;

	mov	[di+00],ax		; load outregs.x.ax			;AN000;
	mov	[di+02],bx		; load outregs.x.bx			;AN000;
	mov	[di+04],cx		; load outregs.x.cx			;AN000;
	mov	[di+06],dx		; load outregs.x.dx			;AN000;
	mov	[di+08],si		; load outregs.x.si			;AN000;

	lahf				; get flags into ax			;AN000;
	mov	al,ah			; move into low byte			;AN000;
	mov	[di+0ch],ax		; load outregs.x.cflag			;AN000;

	pop	ax			; get di from stack			;AN000;
	mov	[di+0ah],ax		; load outregs.x.di			;AN000;

;-------------------------------------------------------------------

	pop	si			; restore registers			;AN000;
	pop	di								;AN000;
	mov	sp,bp			; restore sp				;AN000;
	pop	bp			; restore user's bp                     ;AN000;
	ret									;AN000;

_sysdispmsg endp								;AN000;

include msgdcl.inc

_TEXT	ends				; end code segment			;AN000;
	end									;AN000;


=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\replace\replace.h ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

/*
 *  This file contains the constants, globals, structure definitions,
 *  extern declarations, and macro definitions for the replace utility.
 *
 *  Date:       10-10-90
 */


#define  SELECT_SUPPORT 1      /* true to include special SELECT support code */


/*
 *  Errorlevel Codes
 */
#define ERRLEVELNEG1      -1
#define ERRLEVEL0          0           /* No error */
#define ERRLEVEL1          1           /* Invalid function number */
#define ERRLEVEL2          2           /* File not found */
#define ERRLEVEL3          3           /* Path not found */
#define ERRLEVEL8          8           /* Insufficient memory */
#define ERRLEVEL11        11           /* Invalid format */

/*
 *  Int 21h Functions 
 */
#define DETECT_SELECT     0x1C01       /* Int 2F, SELECT invoked? */
#define GETEXTERR         0x5900       /* Int 21, get extended err */

#define GETVEC_CRITERR    0x3524       /* Int 21,get vector,criterr */
#define GETVEC_CTLBRK     0x3523       /* Int 21,get vector,ctlbrk */
#define GETX_INSTALL      0xB700       /* Is Append/x installed? */
#define GETX_STATUS       0xB706       /* Get the Append/x status */
#define GETX_VERSION      0xB702       /* Is it the DOS Append/x? */
#define SETVEC_CRITERR    0x2524       /* Int 21,set vector,criterr */
#define SETVEC_CTLBRK     0x2523       /* Int 21,set vector,ctlbrk */
#define SETX_STATUS       0xB707       /* Set the Append/x status */

/*
 *  Int 21h Return Codes
 */
#define INSUFFMEM          8
#define NOERROR            0
#define NOMOREFILES       18
#define TARGETFULL        -1

/*
 *  Message Equates
 */
#define BLNK              ' '          /* For sublist.pad_char */
#define CARRY             0x0001
#define DEC_INPUT         161          /* Byte def for sublist.flags */
#define DOS_CON_INPUT     0xC1         /* Input for Y/N response */
#define EXT_ERR_CLASS     0x01         /* DOS Extended error class */
#define NO_INPUT          0x00         /* No input characters */
#define PARSE_ERR_CLASS   0x02         /* Parse error class */
#define RESERVED          0            /* Reserved byte field */
#define STDERR            0x0002       /* Standard error device handle */
#define STDOUT            0x0001       /* Std output device handle */
#define STR_INPUT         16           /* Byte def for sublist.flags */
#define SUBCNT0           0            /* 0 substitutions in message */
#define SUBCNT1           1            /* 1 substitution in message */
#define SUBLIST_LENGTH    11           /* Length of sublist structure */
#define UTILITY_CLASS     0x0ff        /* Utility message class */

/*
 *  Messages
 */
#define MSG_NOMEM         1            /* Insufficient memory */
#define MSG_INCOMPAT      2            /* Invalid parameter combo */
#define MSG_NOSOURCE      3            /* Source path required */
#define MSG_NONEREPL      4            /* No files replaced */
#define MSG_NONEADDE      5            /* No files added */
#define MSG_START         6            /* Press any key to continue */
#define MSG_ERRFNF        7            /* File not Found */
#define MSG_ERRPNF        8            /* Path not Found */
#define MSG_ERRACCD       9            /* Access denied */
#define MSG_ERRDRV        10           /* Invalid drive specification */
#define MSG_BADPARM       11           /* Invalid parameter */
#define MSG_WARNSAME      12           /* File cannot be copied...*/
#define MSG_ERRDSKF       13           /* Insufficient disk space */
#define MSG_REPLACIN      14           /* Replacing %1 */
#define MSG_ADDING        15           /* Adding %1 */
#define MSG_SOMEREPL      16           /* %1 file(s) replaced */
#define MSG_SOMEADDE      17           /* %1 file(s) added */
#define MSG_NONFOUND      18           /* No files found */
#define MSG_QREPLACE      19           /* Replace %1? (Y/N) */
#define MSG_QADD          20           /* Add %1? (Y/N) */
#define MSG_XTRAPARM      21           /* Too many parameters */
#define MSG_BADSWTCH      22           /* Invalid switch */

#define MSG_OPTIONS_FIRST 300
#define MSG_OPTIONS_LAST  309

/*
 *  Parse Equates
 */
#define A_SW              "/A"         /* For switch id /A */
#define P_SW              "/P"         /* For switch id /P */
#define R_SW              "/R"         /* For switch id /R */
#define S_SW              "/S"         /* For switch id /S */
#define U_SW              "/U"         /* For switch id /U */
#define W_SW              "/W"         /* For switch id /W */
#define Q_SW              "/?"
#define CAPRESULT         0x0001       /* Cap result by file table */
#define MAXPOSITION       2            /* Max positionals allowed */
#define MINPOSITION       1            /* Min positionals allowed */
#define NOCAPPING         0x0000       /* Do not capitalize */
#define OPT_FILESPEC      0x0201       /* Filespec & optional */
#define OPT_SWITCH        0x0001       /* Optional (switch) */
#define REQ_FILESPEC      0x0200       /* Filespec required */

/*
 *  Miscellaneous
 */
#define ARCHIVE           0x20         /* Archive bit file attribute */
#define BUF               512
#define FALSE             0
#define INACTIVE          0x0000       /* Append/x inactive status */
#define MAX               256
#define MAXMINUS1         255
#define NULL              0
#define SATTRIB           0
#define SUBDIR            0x10
#define TATTRIB           SUBDIR
#define TRUE              !FALSE
#define X_INSTALLED       0xffff       /* Set the Append/x status */


#if SELECT_SUPPORT                     /* Include only if SELECT calls REPLACE */

#define SELECT_PRESENT    MAXMINUS1    /* AL will = 0FFH after INT2F or 0 */
#define BLANK             32           /* Used to change Selects blanks */

struct selectfilestmp {
  char name[12];                       /* filename */
};

struct selectfiles {
  char name[13];                       /* filename */
};

struct selectfiles select_files[MAX] =
{
  0
};                                     /* array for SELECT list */

struct selectfilestmp select_files_temp[MAX] =
{
  0
};                                     /* array for SELECT list */

char          detect_select_flag  = 0;      /* T/F */
char          exclusion_list      = 0;      /* SELECT */
unsigned      num_select_files    = 0;

void          check_select(void);           /* global */
unsigned      check_select_list(struct filedata *);

#endif                  /* SELECT_SUPPORT */

struct filedata                        /* Files used in copy operations */
{
  char     attribute;
  unsigned time;
  unsigned date;
  long     size;
  char     name[15];
};

struct parm_list                       /* To be passed to Extd Create */
{                                      
  unsigned ea_list_offset;             /*  List structure (filled in) */
  unsigned ea_list_segment;
  unsigned number;                     /*  ID for iomode */
  char     format;                     /*  Format for iomode */
  unsigned iomode;                     /*  (Mainly sequential) */
} eaparm_list = { -1, -1, 1, 6, 2 };

/*
 *  Parse Structures
 */
struct p_parms  p_p;                   /* # of extras & pts to descrptn */
struct p_parmsx p_px;                  /* min/max parms & pts to controls */
struct p_control_blk p_con1;           /* 1st posit parm in cmd str */
struct p_control_blk p_con2;           /* 2nd posit parm in cmd str */
struct p_switch_blk  p_swit;           /* /A /P /R /S /U /W */
struct p_fresult_blk rslt1;            /* Result blk rtrnd from parser */
struct p_result_blk rslt2;             /* Result blk rtrnd from parser */
struct noval novals = {0};             /* Value list not used */


/*
 *  Global Variables
 */
union REGS inregs, outregs;            /* Define register variables */
struct SREGS segregs;                  /* Segment regs for Int21 */

char append_installed    = FALSE;
char attr_list[BUF]      = {0};        /* Buf for list of attributes */
char cmdln_invalid[64]   = {0};
char cmdln_switch[64]    = {0};        /* message, if needed     */
char disk_full           = FALSE;      /* RW Flag - Disk full on target */
char ea_flag             = FALSE;
char errfname[MAX]       = {0};
char errline[MAX]        = {0};        
char filename[MAX]       = {0};        /* RW Save area for filename being copied */
char fix_es_reg[2]       = {0};        /* Corrects es reg after type-"far" */
char not_valid_input     = TRUE;       /* Flag for Y/N message */
char only_one_valid_file = FALSE;      /* Flag indicating valid filecount */
char outline[MAX]        = {0};        
char p_path[64]          = {0};        /* Recvs path from parser */
char p_sfilespec[64]     = {0};        /* Recvs filespec from parser */
char source[MAXMINUS1]   = {0};
char target[MAXMINUS1]   = {0};
char target_full         = FALSE;      /* Check flag at exit */

unsigned char dbcs_search[3] = {0};

unsigned rstatus;                      /* return status of operations */
unsigned add        = FALSE;           /* /A switch */
unsigned counted    = 0;               /* Num replaced or added */
unsigned descending = FALSE;           /* /S switch */
unsigned length;
unsigned prompt     = FALSE;           /* /P switch */
unsigned readonly   = FALSE;           /* /R switch */
unsigned segment;
unsigned update     = FALSE;           /* /U switch */
unsigned waiting    = FALSE;           /* /W switch */
unsigned x_status   = 0;               /* Original append/x state */
unsigned _psp;

long oldint24;                         /* Rcv cntrl from, then ret to */


/*
 *  Extern Declarations
 */
extern  void main(int argc,char * *argv);
extern  void ParseIt(void);
extern  void GetFQPathNames(char *source, char*target);
extern  void FixSourcePath(char *source);
extern  void FixTargetPath(char *target);
extern  void FixPath(char *target, char *save);
extern  unsigned int dodir(char *source,char *target,struct filedata *files,unsigned int filecount);
extern  unsigned int doadd(char *source,char *target,struct filedata *files,unsigned int filecount);
extern  unsigned int findfile(struct filedata *files,struct filedata *file,unsigned int filecount);
extern  unsigned int docopy(char *sdir,char *tdir,struct filedata *file,unsigned int time,unsigned int date);
extern  int same(char *s,char *t);
extern  unsigned int dallocate(unsigned int s);
extern  unsigned int dfree(unsigned int s);
extern  unsigned int dcreate(char *n,unsigned int parm_value);
extern  unsigned int dopen(char *n);
extern  unsigned int ddelete(char *n);
extern  unsigned int dread(unsigned int h,unsigned int s,unsigned int o,unsigned int l);
extern  unsigned int dwrite(unsigned int handle,unsigned int segment,unsigned int offset,unsigned int length);
extern  unsigned int dclose(unsigned int h);
extern  unsigned int dchmod(char *n,unsigned int a);
extern  unsigned int dsearchf(char *s,struct filedata *t,unsigned int a);
extern  unsigned int dsearchn(struct filedata *t);
extern  unsigned int dexit(unsigned int s);
extern  void dta_save(char *t,unsigned int l);
extern  void dta_restore(char *t,unsigned int l);
extern  char getbyte(unsigned int msegment,unsigned int moffset);
extern  unsigned int getword(unsigned int msegment,unsigned int moffset);
extern  long getdword(unsigned int msegment,unsigned int moffset);
extern  void putbyte(unsigned int msegment,unsigned int moffset,char value);
extern  void putword(unsigned int msegment,unsigned int moffset,unsigned int value);
extern  void putdword(unsigned int msegment,unsigned int moffset,long value);
extern  void load_msg(void);
extern  unsigned int dcompare(void);
extern  void display_msg(int msg_num,char *outline);
extern  unsigned int check_appendx_install(void);
extern  unsigned int check_appendx(void);
extern  void set_appendx(unsigned int set_state);
extern  void parser_prep(char *source);
extern  void display_exit(int msg_num,char *outline,int error_code);
extern  void setup_ctl_brk(void);
extern  void setup_crit_err(void);
extern  void restore(void);
extern  void check_select(void);
extern  unsigned int check_select_list(struct filedata *fl);

extern  void crit_err_handler(void);            /* Assembler routine */
extern  void ctl_brk_handler(void);             /* Assembler routine */

extern  void parse(union REGS *, union REGS *);
extern  void sysdispmsg(union REGS *, union REGS *);
extern  void sysloadmsg(union REGS *, union REGS *);


/*
 *  Macro Definitions
 */

/***	GetCurrentDrive
 *
 *  	This macro gets the current drive and returns it in the
 *      location given if the status is NOERROR.
 *
 *	DEFINED AS A MACRO
 *
 * 	ENTRY	pszStore - pointer to location to store drive letter
 *              status   - status
 *              ifCat    - tells whether or not to concatenate string 2
 *              pszStr2  - pointer to string to concatenate
 *
 *	EXIT	pszStore - contains current drive 
 */

#define GetCurrentDrive(pszStore,status,ifCat,pszStr2)                       \
{                                                                            \
                                                                             \
    inregs.x.ax = 0x1900;                   /* Get current drive */          \
    intdos(&inregs,&outregs);               /* Int 21h */                    \
    if (status == NOERROR)                  /* If no error */                \
    {                                                                        \
      /* Insert current drive letter */                                      \
      pszStore[0] = (char)('A' + (outregs.x.ax & 0xff));                     \
      pszStore[1] = ':';                                                     \
      pszStore[2] = NULL;                                                    \
      if (ifCat)                                                             \
        strcat(pszStore,pszStr2);                                            \
    }                                                                        \
}


/***	GetCurrentDirectory
 *
 *  	This macro gets the current directory and returns it in the
 *      location given.  It also returns the status of the operation.
 *
 *	DEFINED AS A MACRO
 *
 * 	ENTRY	pszStore - pointer to location to store drive letter
 *              status   - status, to be returned
 *
 *	EXIT	pszStore contains current drive
 *		status contains result
 */

#define GetCurrentDirectory(pszStore,status)                                 \
{                                                                            \
    pszStore[2]   = '\\';                                                    \
    inregs.x.ax = 0x4700;                        /* get current dir */       \
    inregs.x.si = (unsigned)(&pszStore[3]);                                  \
    inregs.x.dx = pszStore[0] - 'A' + 1;                                     \
    intdos(&inregs,&outregs);                                                \
    if (status = (outregs.x.cflag & CARRY))      /* set status */            \
      status = outregs.x.ax;                     /* error case */            \
}


/***	AppendBackslash
 *
 *  	This macro appends a backslash character to the end of a string
 *      if one does not already exist.
 *
 *	DEFINED AS A MACRO
 *
 * 	ENTRY	pszStore - pointer to location to store drive letter
 *
 *	EXIT	pszStore has ending backslash
 */

#define AppendBackslash(pszStore)                                            \
{                                                                            \
    char *backptr;                       /* pointer to backslash */          \
                                                                             \
    /* If no backslash, then add backslash to end */                         \
    if ((backptr = com_strrchr(pszStore,'\\')) == NULL)                      \
      strcat(pszStore,"\\");                                                 \
    else                                                                     \
    {                                                                        \
      /* If backslash not last char, then add backslash to end */            \
      if (backptr != &pszStore[strlen(pszStore)-1])                          \
        strcat(pszStore,"\\");                                               \
    }                                                                        \
}


=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\replace\_parse.asm ===
page	60,132				;
name	_parse
title	C	to PARSER interface

;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

;-------------------------------------------------------------------
;
;	MODULE: 	_parse
;
;	PURPOSE:	Supplies an interface between C programs and
;			the DOS 3.3 parser
;
;	CALLING FORMAT:
;			parse(&inregs,&outregs);
;
;	DATE:		5-21-87
;
;-------------------------------------------------------------------

;	extrn	sysparse:far

	public	_parse			;AN000;

;-------------------------------------------------------------------

; SET FOR REPLACE
; -------------

FarSW	equ	0			; make sysparse be a NEAR proc		;AN000;
TimeSW	equ	0			; Check time format			;AN000;
FileSW	equ	1			; Check file specification		;AN000;
CAPSW	equ	1			; Perform CAPS if specified		;AN000;
CmpxSW	equ	0			; Check complex list			;AN000;
NumSW	equ	0			; Check numeric value			;AN000;
KeySW	equ	0			; Support keywords			;AN000;
SwSW	equ	1			; Support switches			;AN000;
Val1SW	equ	0			; Support value definition 1		;AN000;
Val2SW	equ	0			; Support value definition 2		;AN000;
Val3SW	equ	0			; Support value definition 3		;AN000;
DrvSW	equ	1			; Support drive only format		;AN000;
QusSW	equ	0			; Support quoted string format		;AN000;
;-------------------------------------------------------------------

DGROUP	GROUP	_DATA
PGROUP	GROUP	_TEXT

_DATA	segment byte public 'DATA'	;AN000;
BASESW	=	1			;SPECIFY, PSDATA POINTED TO BY "DS"
INCSW	=	0			;PSDATA.INC IS ALREADY INCLUDED
	include version.inc
	INCLUDE PSDATA.INC		;PARSER'S WORK SPACE
_DATA	ends				;AN000;

_TEXT	segment byte public 'CODE'	;AN000;

	ASSUME	CS: PGROUP		;AN000;
	ASSUME	DS: DGROUP		;AN000;

;-------------------------------------------------------------------
	include parse.asm		; include the parser			;AN000;
;-------------------------------------------------------------------

_parse	proc	near			;AN000;

	push	bp			; save user's base pointer              ;AN000;
	mov	bp,sp			; set bp to current sp			;AN000;
	push	di			; save some registers			;AN000;
	push	si			;AN000;

;	copy C inregs into proper registers

	mov	di,[bp+4]		; fix di (arg 0)			;AN000;

;-------------------------------------------------------------------

	mov	ax,[di+0ah]		; load di				;AN000;
	push	ax			; the di value from inregs is now on stack;AN000;

	mov	ax,[di+00]		; get inregs.x.ax			;AN000;
	mov	bx,[di+02]		; get inregs.x.bx			;AN000;
	mov	cx,[di+04]		; get inregs.x.cx			;AN000;
	mov	dx,[di+06]		; get inregs.x.dx			;AN000;
	mov	si,[di+08]		; get inregs.x.si			;AN000;
	pop	di			; get inregs.x.di from stack		;AN000;

	push	bp			; save base pointer			;AN000;

;-------------------------------------------------------------------
	call	sysparse		; call the parser			;AN000;
;-------------------------------------------------------------------

	pop	bp			; restore base pointer			;AN000;
	push	di			; the di value from call is now on stack;AN000;
	mov	di,[bp+6]		; fix di (arg 1)			;AN000;

	mov	[di+00],ax		; load outregs.x.ax			;AN000;
	mov	[di+02],bx		; load outregs.x.bx			;AN000;
	mov	[di+04],cx		; load outregs.x.cx			;AN000;
	mov	[di+06],dx		; load outregs.x.dx			;AN000;
	mov	[di+08],si		; load outregs.x.si			;AN000;

	lahf				; get flags into ax			;AN000;
	mov	al,ah			; move into low byte			;AN000;
	mov	[di+0ch],ax		; load outregs.x.cflag			;AN000;

	pop	ax			; get di from stack			;AN000;
	mov	[di+0ah],ax		; load outregs.x.di			;AN000;

;-------------------------------------------------------------------

	pop	si			; restore registers			;AN000;
	pop	di			;AN000;
	mov	sp,bp			; restore sp				;AN000;
	pop	bp			; restore user's bp                     ;AN000;
	ret				;AN000;

_parse	endp				;AN000;

_TEXT	ends				; end code segment			;AN000;
	end				;AN000;

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\replace\_replace.asm ===
page	60,132				;
name	_replace
title	Critical error or control break exit

;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

;-------------------------------------------------------------------
;
;	MODULE: 	_replace
;
;	PURPOSE:	Supplies assembler exit routines for
;			critical error or control break situations
;
;	CALLING FORMAT:
;			crit_err_handler;
;			ctl_brk_handler;
;
;	DATE:		10/87
;
;-------------------------------------------------------------------


	public	_crit_err_handler	;AN000;
	public	_ctl_brk_handler	;AN000;

;-------------------------------------------------------------------
RET_EXIT equ	4ch			; terminate				;AN000;
CTLBRK	equ	3			; errorlevel return in al		;AN000;
ABORT	equ	2			; if >=, retry				;AN000;
XABORT	equ	1			; errorlevel return in al		;AN000;
;-------------------------------------------------------------------


NULL	SEGMENT PARA PUBLIC 'BEGDATA'	;AN000;
NULL	ENDS				;AN000;
_DATA	SEGMENT PARA PUBLIC 'DATA'	;AN000;
	extrn	_oldint24:dword 	;AN000;
_DATA	ENDS				;AN000;
CONST	SEGMENT WORD PUBLIC 'CONST'	;AN000;
CONST	ENDS				;AN000;
_BSS	SEGMENT WORD PUBLIC 'BSS'	;AN000;
_BSS	ENDS				;AN000;
STACK	SEGMENT PARA STACK 'DATA'	;AN000;
STACK	ENDS				;AN000;

PGROUP	GROUP	_TEXT			;AN000;
DGROUP	GROUP	NULL, _DATA, CONST, _BSS, STACK ;AN000;



_TEXT	segment para public 'CODE'	;AN000;
	ASSUME	CS:PGROUP		;AN000;

	extrn	_restore:near		;AN000;

;-------------------------------------------------------------------
; CRITICAL ERROR HANDLER
;-------------------------------------------------------------------
vector	dd	0			;receives a copy of _oldint24		;AN000;

_crit_err_handler proc near		;AN000;

	pushf				; req by int24 handler			;AN000;
	push	ax			; will use ax				;AN000;
	push	ds			; will use ds				;AN000;

	mov	ax,dgroup		; setup 				;AN000;
	mov	ds,ax			;					;AN000;
	ASSUME	DS:DGROUP		;AN000;

	mov	ax,word ptr _oldint24	; load vector so we can use it		;AN000;
	mov	word ptr vector,ax	;					;AN000;
	mov	ax,word ptr _oldint24+2 ;					;AN000;
	mov	word ptr vector+2,ax	;					;AN000;

	pop	ds			; finished with ds			;AN000;
	ASSUME	DS:NOTHING

	pop	ax			; finished with ax			;AN000;

	call	dword ptr vector	; invoke DOS err hndlr			;AN000;

	cmp	al,ABORT		; what was the user's response          ;AN000;
	jnge	retry			;					;AN000;

	mov	ax,(RET_EXIT shl 8)+XABORT ; return to DOS w/criterr error	;AN000;
	call	call_restore		; restore user's orig append/x          ;AN000;
; =================== this call does not return ===============

retry:					;AN000;
	ASSUME	DS:NOTHING
	ASSUME	ES:NOTHING

	iret				; user response was "retry"		;AN000;

_crit_err_handler endp			;AN000;


;-------------------------------------------------------------------
; CONTROL BREAK HANDLER
;-------------------------------------------------------------------
_ctl_brk_handler proc near		;AN000;

	ASSUME	DS:NOTHING
	ASSUME	ES:NOTHING

	mov	ax,(RET_EXIT shl 8)+CTLBRK ; return to DOS w/ctlbrk error	;AN000;
;-------------------------------------------------------------------
	call	call_restore		; restore user's orig append/x          ;AN000;
;-------------------------------------------------------------------
; =================== this call does not return ===============

_ctl_brk_handler endp			;AN000;

call_restore proc near
;input: ah has the RETURN TO DOS WITH RET CODE function request
;	al has the ERRORLEVEL return code to be passed back to DOS
;output: this routine does NOT RETURN, but exits to DOS with ret code.

	push	ax			;save errorlevel return code
	push	ds
	push	es

	mov	ax,dgroup		; setup "c" code regs			;AN000;
	mov	ds,ax			;					;AN000;
	ASSUME	DS:DGROUP		;AN000;

	mov	es,ax			;					;AN000;
	ASSUME	ES:DGROUP		;AN000;

;-------------------------------------------------------------------
	call	_restore		; restore user's orig append/x          ;AN000;
;-------------------------------------------------------------------

	pop	es
	pop	ds
	pop	ax			;restore return code
	int	21h			;					;AN000;
	int	20h			; in case int21 fails			;AN000;

call_restore endp

_TEXT	ends				; end code segment			;AN000;
	end				;AN000;

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\restore\direct.h ===
/*
 * direct.h
 *
 * This include file contains the function declarations for the library
 * functions related to directory handling and creation.
 *
 *
 *   Microsoft Confidential
 *   Copyright (C) Microsoft Corporation 1991
 *   All Rights Reserved.
 *
 *
 */

/* function declarations for those who want strong type checking
 * on arguments to library function calls
 */

#ifdef LINT_ARGS		/* arg. checking enabled */

int chdir(char *);
char *getcwd(char *, int);
int mkdir(char *);
int rmdir(char *);

#else

extern char *getcwd();

#endif	/* LINT_ARGS */
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\restore\rt.h ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

/******************************************************************************
*
*  Change Log:
*
*    Date    Who   #                      Description
*  --------  ---  ---  ------------------------------------------------------
*  06/29/90  EGH  C01  Added support for doing a directory of backed up
*                      diskettes via the /D option.
*
******************************************************************************/
/*  0 */
/*---------------------------------------------------------
/*-
/*- RESTORE Utility include file RT.H
/*-
/*---------------------------------------------------------*/


/****************************************************************************/
/* This file contains equates for RESTORE utility			    */
/* The equates for messages can be found in rt2.h			    */
/****************************************************************************/

#define BYTE	unsigned char
#define WORD	unsigned short
#define DWORD	unsigned long

#define NOERROR 0
#define CARRY 0x0001				/*;AN000;*/


/*******************************************/
/*    Lengths of CONTROL.xxx structures    */
/*******************************************/
#define DHEADLEN	     139	/* length of new format disk header */
#define DIRBLKLEN	      70	/* length of new format dir block   */
#define FHEADLEN34	      38	/*;AN000;3 Length of new format file header */ /* !wrw */
#define FHEADLEN33	      34	/* length of DOS 3.3 file header */ /* !wrw */

/****************************************************************************/
/*  The following group of definitions are used to set and test the restore */
/*  switch flags.							    */
/****************************************************************************/

#define PROMPT		 1  /* Prompt user before restoring hidden and	     */
			    /* read-only files. 			     */
#define SUB		 2  /* Restore all subdirectories too		     */
#define BEFORE		 4  /* Only restore files written before a date      */
#define AFTER		 8  /* Only restore files written after a date	     */
#define EARLIER 	16  /* Only restore files written earlier then a time*/
#define LATER		32  /* Only restore files written later than a time  */
#define Revised	64  /* Only restore files that have changed	     */
#define NOTEXIST       128  /* Only restore files that no longer exist on    */
			    /* the destination drive.			     */
#define EXACT_DATE	 1  /* Restore file with exact date via /Z     MR001+*/
#define EXACT_TIME	 2  /* Restore file with exact time via /Y     MR001+*/
#define DIR              1  /* Just display directory of diskettes */   /*C01*/

/****************************************************************************/
/*  The following group of definitions are used to set and test the	    */
/*  restore control flags:control_flag. 				    */
/****************************************************************************/

#define WILDCARD	 1  /* Wildcards in input filespec		*/
#define OLDNEW		 2  /* indicate old format or new format	*/
#define CREATIT 	 4  /* Restore file does not exist on dest disk */
#define FOUND		 8  /* Found a file to restore			*/
#define SPLITFILE	16  /* File was backed up onto 2 or more disks	*/
#define SWITCHES	32  /* There are switches set			*/
#define SHARERROR	64  /* There is a file not restored due to	*/
			    /* sharing error				*/
#define PARTIAL        128  /* Set if file partially restored		*/

/****************************************************************************/
/*  The following group of definitions are used to set and test the restore */
/*   control flags:control_flag2					    */
/****************************************************************************/

#define SPLITCTL	 1  /* Indicate whether control.xxx is larger	*/
				/* then MAXCTRL 			    */
#define RTSYSTEM	 2  /* The file to be restore is system file	*/
				/* it has to be restored contiguously	    */
#define COUNTRY 	 4  /*when the bit is on, country info is available */
#define CPPC		 8  /* bit = 1 when CP/DOS, otherwise, PC/DOS	    */
#define SRC_HDISK	16  /* bit = 1 when the source disk is harddisk     */
#define TAR_HDISK	32  /* bit = 1 when the target disk is harddisk     */
#define OUTOF_SEQ	64  /* bit = 1 when the disk is out of sequence     */
/****************************************************************************/
/*  Miscelleneous definitions						    */
/****************************************************************************/
#define ON		 1	/* the tested bit is on*/
#define OFF		 0	/* the tested bit is off */

#define BACKUPID    "BACKUPID.@@@"  /* Used to reference that file           */
#define HEADLEN        128	/* Backup file header length		     */
#define MAXARGS 	11	/* Max # of arguments			     */
#define MINARGS 	 1	/* Minimum # of arguments		     */
#define MAXBUF	    0xffff	/* Max size of buf			     */
#define DOWNSIZE       512	/* Amount to decrement memory request size   */
				/* by when doing a series of mallocs.	     */
#define MAXPATH 	65	/* Length of space allocate for path names   */
#define MAXFNAME	 9	/* Max length of file name		     */
#define MAXFEXT 	 4	/* Max length of file extension 	     */
#define MAXFSPEC	13	/* Max length of file spec.		     */
#define MAXPATHF	78	/* Max length of path and file spec	     */
#define MAXYEARLEN	 4	/* Max length of string that represent year  */
#define MAXMONTHLEN	 2	/* Max length of string that represent month */
#define MAXDAYLEN	 2	/* Max length of string that represent day   */
#define MINYEAR       1980	/* Min value of input year		     */
#define MAXYEAR       2079	/* Max value of input year		     */
#define MAXMONTH	12	/* Max value of input year		     */
#define MAXDAY		31	/* Max value of input year		     */
#define MAXHOURLEN	 2	/* Max length of string that represent hour  */
#define MAXMINUTELEN	 2	/* Max length of string that represent minute*/
#define MAXSECONDLEN	 2	/* Max length of string that represent second*/
#define NUL		 0	/* The null character			     */
#define NULLC	    '\000'      /* The null character                        */
#define MAXCTRL       3072	/* size of buffer to contain control.xxx     */
#define BKIDLENG	 7	/* the lenght of old format disk header      */
#define NEWBKIDLENG    139	/* the length of new format disk header      */
#define NOTV	      0x16	/* all file attrs except vol id 	     */
#define ON		 1	/* the tested bit is on*/
#define OFF		 0	/* the tested bit is off */
#define TRUE		 0	/* return code, no error		     */
#define FALSE		 1	/* return code, there is an error	     */
#define TTRUE		 1	/* return code, no error		     */
#define FFALSE		 0	/* return code, there is an error	     */
#define LAST_PART     0x01	/* the flag in finfo->fflag		     */
				/* if on, the file is last part of a file    */
#define COMPLETE_BIT  0x02	/* the complete bit in fheadnew->flag	     */
				/* if on, the file was backed up sucessfully */
#define USA	0
#define EUR	1
#define JAP	2
#define INSTALL_SIGNAL	       2	/* active signal handler routine    */
#define DEACTIVE_SIGNAL        1	/* ignor signals		    */
#define CTRL_C		       1	/* control_c signal		    */
#define CTRL_BREAK	       4	/* control break signal 	    */

/****************************************************************************/
/*   Defines for common subroutines - comgetarg and computmsg		    */
/****************************************************************************/

#define  RESPDATA_SIZE	       1	/* size of the respdata */
#define  STND_IN_DEV	       0	/* standard out device		    */
#define  STND_OUT_DEV	       1	/* standard out device		    */
#define  STND_ERR_DEV	       2	/* standard error device	    */
#define  NO_RESPTYPE	       0	/*response type is no user	    */
					/*interaction			    */
#define  ANY_KEY_RESPTYPE      1	/*response type is ask user to enter*/
					/*any key.			    */
#define  ENTER_Y	       0	/*user enter yes as response	    */
#define  ENTER_N	       1	/*user enter no  as response	    */

/****************************************************************************/
/*   Defines for convert date format					    */
/****************************************************************************/

#define HRSHIFT   11	       /* shift 11 bits to get the value of hour    */
#define HRMASK	0x1F	       /* mask to get the value of hour 	    */
#define MNSHIFT    5	       /* shift 5  bits to get the value of minute  */
#define MNMASK	0x3F	       /* mask to get the value of minute	    */
#define SCMASK	0x1F	       /* mask to get the value of second	    */
#define MOSHIFT    5	       /* shift 5  bits to get the value of month   */
#define MOMASK	0x0F	       /* mask to get the value of month	    */
#define DYMASK	0x1F	       /* shift 9  bits to get the value of day     */
#define YRSHIFT    9	       /* mask to get the value of day		    */
#define YRMASK	0x7F	       /* mask to get the value of year 	    */
#define USA	   0
#define EUR	   1
#define JAP	   2
#define LOYR	1980

/****************************************************************************/
/*  Defines for subroutine set_reset_test_flag				    */
/****************************************************************************/
#define SET	   0
#define RESET	   1
#define TEST	   2

/****************************************************************************/
/*  Defines for file attribut byte					    */
/****************************************************************************/
#define READONLY   1	 /*the file is marked read only 	  */
#define HIDDEN	   2	 /*the file is marked hidden file	  */
#define SYSTEM	   4	 /*the file is marked system file	  */
#define VOLUME	   8	 /*the entry contains a volume label	  */
#define SUBDIR	  16	 /*the entry is a subdirectory name	  */
#define ARCHIVE   32	 /*the archieve bit of the file 	  */

/****************************************************************************/
/*  Defines for PCDOS return levels					    */
/****************************************************************************/

#define PC_NORMAL	  0
					/* Normal completion		  */
#define PC_NOFILES	  1
					/* no fl were found to restore	  */
#define PC_SHARERR	  2
			   /* Some file not restored due to sharing error */
#define PC_TUSER	  3
					/* Terminated by user		  */
#define PC_OTHER	  4
					/* Terminated by user		  */
/****************************************************************************/
/*  Defines for CPDOS return codes					    */
/****************************************************************************/

#define NORMAL	       NO_ERROR
					/* Normal completion */
#define NOFILES        ERROR_FILE_NOT_FOUND
					/* no fl were found to restore */
#define SHARERR        ERROR_SHARING_VIOLATION
			   /* Some file not restored due to sharing error */
#define TUSER	       1026
					/* Terminated by user */
#define INSUFMEM       ERROR_NOT_ENOUGH_MEMORY
					/* insufficient memory */
#define NOBACKUPFILE   1027
					/* source does not contain bk file*/
#define INVALIDPARM    ERROR_INVALID_PARAMETER
					/* invalid parmameter */
#define INVALIDDRIVE   ERROR_INVALID_DRIVE
					/* invalid drive */
#define FILESEQERROR   1028
					/* file seq error */
#define TARGETFULL     ERROR_DISK_FULL
					/* target disk is full */
#define UNEXPECTED	  999
					/* unexpected error */
#define CREATIONERROR  1029
					/* file creation error */
	/************************************************/
	/*    Substitution List for Message Retriever	*/
	/************************************************/
/*-----------------------
; SUBLIST Equates
;------------------------*/
#define SUBLIST_SIZE	11	     /*;AN000;6 */

#define LEFT_ALIGN	      0x0    /*;AN000;6 00xxxxxx  */
#define RIGHT_ALIGN	      0x80   /*;AN000;6 10xxxxxx  */

#define CHAR_FIELD_CHAR       0x0    /*;AN000;6 a0000000  */
#define CHAR_FIELD_ASCIIZ     0x10   /*;AN000;6 a0010000  */

#define UNSGN_BIN_BYTE	      0x11   /*;AN000;6 a0010001 - Unsigned BINary to Decimal CHARacter */
#define UNSGN_BIN_WORD	      0x21   /*;AN000;6 a0100001  */
#define UNSGN_BIN_DWORD       0x31   /*;AN000;6 a0110001  */

#define SGN_BIN_BYTE	      0x12   /*;AN000;6 a0010010 - Signed BINary to Decimal CHARacter */
#define SGN_BIN_WORD	      0x22   /*;AN000;6 a0100010  */
#define SGN_BIN_DWORD	      0x32   /*;AN000;6 a0110010  */

#define BIN_HEX_BYTE	      0x13   /*;AN000;6 a0010011 - Unsigned BINary to Hexidecimal CHARacter */
#define BIN_HEX_WORD	      0x23   /*;AN000;6 a0100011  */
#define BIN_HEX_DWORD	      0x33   /*;AN000;6 a0110011  */


#define DATE_MDY_4	     0x34    /*;AN000;6 MONTH,DAY AND YEAR (4 DIGITS)*/
/*------------------------------------*/
/*-	   MESSAGE CLASSES	     -*/
/*------------------------------------*/
#define EXTENDED	1	/*;AN000;6*/
#define PARSEERROR	2	/*;AN000;6*/
#define UTIL_MSG       -1	/*;AN000;6*/

#define CR		0x0d		/*;AN000;6*/
#define LF		0x0a		/*;AN000;6*/
/*-------------------------------
/*-	INT 21h
/*-------------------------------*/
#define SETLOGICALDRIVE  0x440f 			/*;AN000;8*/

#define INSTALL_CHECK	0xB700			/*;AN000;2*/
#define NOT_INSTALLED 0 			/*;AN000;2*/
#define GET_APPEND_VER	0xB702			/*;AN000;2*/
#define NET_APPEND    1 			/*;AN000;2*/
#define DOS_APPEND    2 			/*;AN000;2*/
#define GET_STATE	0xB706			/*;AN000;2*/
#define SET_STATE	0xB707			/*;AN000;2*/

#define APPEND_X_BIT	0x8000			/*;AN000;2*/
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\restore\restpars.c ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

/******************************************************************************
*
*  Change Log:
*
*    Date    Who   #                      Description
*  --------  ---  ---  ------------------------------------------------------
*  06/29/90  EGH  C01  Added support for doing a directory of backed up
*                      diskettes via the /D option.
*
******************************************************************************/

/*-------------------------------
/* SOURCE FILE NAME: restpars.c
/*-------------------------------
/*  0 */
#include "rt.h"
#include "rt1.h"
#include "rt2.h"
#include "restpars.h"                                                 /*;AN000;4*/
#include "direct.h"
#include "string.h"
#include "ctype.h"
#include "dos.h"                                                      /*;AN000;2*/
#include "comsub.h"             /* common subroutine def'n */
#include "doscalls.h"
#include "error.h"

/*=============================*/
extern	BYTE	srcd;						      /*;AN000;4*/
extern	BYTE	destd;						      /*;AN000;4*/
extern	BYTE	inpath	[MAXPATH];				      /*;AN000;*/
extern	BYTE	infname [MAXFNAME];				      /*;AN000;*/
extern	BYTE	infext	[MAXFEXT];				      /*;AN000;*/
extern	BYTE	infspec [MAXFSPEC];				      /*;AN000;*/
/*=============================*/

extern	BYTE destddir[MAXPATH+3];
extern	BYTE srcddir[MAXPATH+3];
extern	BYTE rtswitch;
extern	BYTE rtswitch7; 		   /*;MR001+ additional switch byte   */
extern  BYTE rtswitch2;                                                 /*C01*/
extern	BYTE control_flag;
extern	BYTE control_flag2;
extern	BYTE filename[12];
extern	unsigned control_file_handle;				      /* !wrw */
extern	struct	subst_list sublist;	   /*;AN000;6Message substitution list */

struct	p_parms 	parms;		   /*;AN000;4 Parser data structure */
struct	p_parmsx	parmsx; 	   /*;AN000;4 Parser data structure */
struct	p_pos_blk	pos1;		   /*;AN000;4 Parser data structure */
struct	p_pos_blk	pos2;		   /*;AN000;4 Parser data structure */
struct	p_sw_blk	sw1;		   /*;AN000;4 /S /P /M /N  data structure */
struct	p_sw_blk	sw2;		   /*;AN000;4 /E: /L:  parser data structure */
struct	p_sw_blk	sw3;		   /*;AN000;4 /B: /A:  parser data structure */
struct	p_sw_blk	sw90;		   /*:MR001+  /Z: /Y:  parser data structure */
struct	p_sw4_blk	sw4;		/* /? parser data structure */
struct	p_result_blk	pos_buff;	   /*;AN000;4 Parser data structure */
struct	switchbuff	sw_buff;	   /*;AN000;4 Parser data structure */
struct	timebuff	time_buff;	   /*;AN000;4 Parser data structure */
struct	datebuff	date_buff;	   /*;AN000;4 Parser data structure */
DWORD	noval;				   /*;AN000;4 Value list for PARSER */
int	parse_count = 1;		   /*;AN000;4*//*;AC002;*/
char	curr_parm[128]; 		   /*;AN004; Current parameter being parsed*/
extern	struct timedate td;

/*************************************************/
/*
/* SUBROUTINE NAME:	parse_command_line
/*
/* FUNCTION:
/*
/*	Parse the RESTORE command line
/*
/**************************************************/
void	parse_command_line(argc,argv)				      /*;AN000;4 */
int	argc;							      /*;AN000;4 */
char	*argv[];						      /*;AN000;4 */
{								      /*;AN000;4 */
#define EOL  -1 						      /*;AN000;4 */
	union REGS inregs, outregs;				      /*;AN000;4 */
	char	cmd_line[128];					      /*;AN000;4 */
	char	not_finished = TTRUE;				      /*;AN000;4 */
	int	x;						      /*;AN000;4 */

	/*
	 * See if the user entered /? on the command line.
	 * If so, display the options help message, and then
	 * exit so they can try again.
	 */

	check_options_help(argc, argv);

		/* Copy command line parameters to local area */
	cmd_line[0] = NUL;					      /*;AN000;4*/
	for (x=1; x<=argc; x++) 				      /*;AN000;4*/
	 {							      /*;AN000;4*/
	  strcat(cmd_line,argv[x]);				      /*;AN000;4*/
	  if (x!=argc) strcat(cmd_line," ");                          /*;AN000;4*/
	 }							      /*;AN000;4*/

	strcat(cmd_line,"\r");             /* Add CR, LF */           /*;AN004;*/

	if (argc-1 < 1) 					      /*;AN000;4*/
	 {							      /*;AC000;4*/
	  display_it(NO_SOURCE,STND_ERR_DEV,0,NO_RESPTYPE,(BYTE)UTIL_MSG);/*;AN000;6*/
	  usererror(INVALIDPARM);				      /*;AC000;4*/
	 }							      /*;AC000;4*/

	if (argc-1 < 2) 					      /*;AN000;4*/
	 {							      /*;AC000;4*/
	  display_it(NO_TARGET,STND_ERR_DEV,0,NO_RESPTYPE,(BYTE)UTIL_MSG);/*;AN000;6*/
	  usererror(INVALIDPARM);				      /*;AC000;4*/
	 }							      /*;AC000;4*/

		/* Check for same source and target drive */
	if (com_toupper(*argv[1]) == com_toupper(*argv[2])	      /*;AN000;4*/
	    && (BYTE)*(argv[1]+1) == ':'                              /*;AN000;4*/
	    && (BYTE)*(argv[1]+2) == NUL			      /*;AN000;4*/
	    && (BYTE)*(argv[2]+1) == ':'                              /*;AN000;4*/
	   )							      /*;AN000;4*/
	 {							      /*;AC000;4*/
	  display_it(SOURCE_TARGET_SAME,STND_ERR_DEV,0,NO_RESPTYPE,(BYTE)UTIL_MSG);/*;AN000;6*/
	  usererror(INVALIDPARM);				      /*;AC000;4*/
	 }							      /*;AC000;4*/

		/* Initialize parser data structures */
	parse_init();						      /*;AN000;4*/

	inregs.x.si = (WORD)&cmd_line[0];  /*DS:SI*/		      /*;AN000;4 make DS:SI point to source */
	inregs.x.cx = 0;					      /*;AN000;4*/

		/*********************/
		/* PARSE LOOP !!!!!! */
		/*********************/
	while (not_finished)					      /*;AN000;4 For all strings in command line */
	 {							      /*;AN000;4 */
	  inregs.x.dx = 0;					      /*;AN000;4 RESERVED */
	  inregs.x.di = (WORD)&parms;	/*ES:DI*/		      /*;AN000;4 address of parm list */
	  parse(&inregs,&outregs);				      /*;AN000;4 Call DOS PARSE service routines*/

	  x=0;			/* Save the parsed parameter */       /*;AN004;*/
	  for (inregs.x.si; inregs.x.si<outregs.x.si; inregs.x.si++)  /*;AN004;*/
	   {							      /*;AN004;*/
	     curr_parm[x] = *(char *)inregs.x.si;		      /*;AN004;*/
	     x++;						      /*;AN004;*/
	   }							      /*;AN004;*/

	  curr_parm[x] = NUL;					      /*;AN004;*/

	  inregs = outregs;		/* Reset registers */	      /*;AN000;4 Reset registers*/

					/* Check for PARSE ERROR*/
	  if (outregs.x.ax != (WORD)NOERROR)			      /*;AN000;4*/
	   {							      /*;AN000;4*/
	     if (outregs.x.ax==(WORD)EOL)   /* Was it End of line? */ /*;AN000;4*/
	       not_finished = FFALSE;				      /*;AN000;4*/
	      else
	       {			     /* It was an error */    /*;AN000;4*/
		 not_finished = FFALSE; 			      /*;AN000;4*/
		 parse_error(outregs.x.ax,(BYTE)PARSEERR);	      /*;AN000;4*//*;AC002;*/
	      } 						      /*;AN000;4*/
	   }							      /*;AN000;4*/

	  if (not_finished)	/* Parse was successful !*/	      /*;AN000;4*/
	   {							      /*;AN000;4*/
	     if ( outregs.x.dx == (WORD)&time_buff ||		      /*;AN000;4*/
		  outregs.x.dx == (WORD)&date_buff ||		      /*;AN000;4*/
		  outregs.x.dx == (WORD)&sw_buff		      /*;AN000;4*/
		)						      /*;AN000;4*/
	       process_switch(outregs.x.dx);	      /*;AN000;4*//*;AC002;*/
	   }							      /*;AN000;4*/

	  parse_count++;					      /*;AN000;4*//*;AC002;*/
	 }  /* End WHILE Parse loop */				      /*;AN000;4*/

		/*  Check source and target filespec */
	if (strlen(argv[2]) >= 5)				      /*;AN000;p2591*/
	 check_for_device_names(argv);				      /*;AN000;p2591*/

	check_source_drive(argv);				      /*;AN000;4*/
	check_target_filespec(argc,argv);			      /*;AN000;4*/

	return; 						      /*;AN000;4*/
}	/* end parser */					      /*;AN000;4*/

/*************************************************/
/*
/* SUBROUTINE NAME:	check_options_help
/*
/* FUNCTION:
/*
/*	Check the command line for /?.  The parser cannot
/* be relied on for this, because main() first calls
/* check_drive_validity, which will error out if two
/* valid drive letters are not found in argv[].
/*
/* If /? is found, call display_options_exit(), which
/* will display the options help message, and then
/* terminate the program.
/*
/**************************************************/
void
check_options_help(argc,argv)
int	argc;
char	*argv[];
{
	/*
	 * Check every argument (except the first, which
	 * is "backup", looking for "/?".  If found,
	 * call off to display_options_exit().
	 */

	for (argc--, argv++; argc; argc--, argv++)
		if (argv[0][0] == '/' && argv[0][1] == '?' && argv[0][2] == '\0')
			display_options_exit();
}

/*************************************************/
/*
/* SUBROUTINE NAME:	parse_error
/*
/* FUNCTION:
/*
/*	There was a parse error. Display message and die
/*
/**************************************************/
void	parse_error(msg_num,class)				      /*;AN000;4*//*;AC002;*/
WORD	msg_num;						      /*;AN000;4*/
BYTE	class;							      /*;AN000;4*/
{								      /*;AN000;4*/
      sublist.value1 = &curr_parm[0];				      /*;AN002;*/
      sublist.flags1 = LEFT_ALIGN + CHAR_FIELD_ASCIIZ;		      /*;AN002;*/
      sublist.one = 0;						      /*;AN002;*/
      sublist.max_width1 = (BYTE)strlen(curr_parm);		      /*;AN002;*/
      sublist.min_width1 = sublist.max_width1;			      /*;AN002;*/


      if (msg_num == NO_SOURCE	||  msg_num == NO_TARGET)	      /*;AN000;6*/
       display_it(msg_num,STND_ERR_DEV,0,NO_RESPTYPE,class);	      /*;AN000;6*/
      else							      /*;AN000;6*/
       display_it(msg_num,STND_ERR_DEV,1,NO_RESPTYPE,class);	      /*;AN000;6*/


      usererror(INVALIDPARM);					      /*;AN000;4*//*;AC002;*/
      return;							      /*;AN000;4*/
}								      /*;AN000;4*/

/*************************************************/
/*
/* SUBROUTINE NAME:	display_options_exit
/*
/* FUNCTION:
/*
/*	Display the options help message, and
/*	then exit so the user can retry the command.
/*
/***************************************************/

void
display_options_exit()
{
	int	MsgNbr;

	/*
	 * Display all the message lines in the
	 * options help message.
	 */

	for (MsgNbr = MSG_OPTIONS_FIRST;
		MsgNbr <= MSG_OPTIONS_LAST;
		MsgNbr++)
	{
		display_it(MsgNbr, STND_OUT_DEV, 0, NO_RESPTYPE, (BYTE)UTIL_MSG);
	}

	/*
	 * Set the return code to show no error,
	 * and exit so the user can retry the command.
	 */

	usererror(0);		/* does not return */
}

/*************************************************/
/*
/* SUBROUTINE NAME:	check_date
/*
/* FUNCTION:
/*
/*	A date parameter was entered. Validate it
/*
/**************************************************/
void	check_date(year,month,day)				      /*;AN000;4*//*;AC002;*/
WORD	year;							      /*;AN000;4*/
BYTE	month;							      /*;AN000;4*/
BYTE	day;							      /*;AN000;4*/
{								      /*;AN000;4*/
	if (year > 2099 || year < 1980) 			      /*;AC000;4*/
	  parse_error(INV_DATE,(BYTE)UTILMSG);			      /*;AC000;4*//*;AC002;*/

	if (month > 12 || month < 1)				      /*;AC000;4*/
	  parse_error(INV_DATE,(BYTE)UTILMSG);			      /*;AC000;4*//*;AC002;*/

	if (day > 31 || month < 1)				      /*;AC000;4*/
	  parse_error(INV_DATE,(BYTE)UTILMSG);			      /*;AC000;4*//*;AC002;*/

		/* Verify day not greater then 30 if Apr,Jun,Sep,Nov */
	if ((day>30) && (month==4 || month==6 || month==9 || month==11)) /*;AC000;4*/
	  parse_error(INV_DATE,(BYTE)UTILMSG);			      /*;AC000;4*//*;AC002;*/

	if (month == 2) 		/* Deal with February */      /*;AC000;4*/
	 {							      /*;AC000;4*/
	   if (day >  29)		/*  if Feb 30 or above */     /*;AC000;4*/
	    parse_error(INV_DATE,(BYTE)UTILMSG);		      /*;AC000;4*//*;AC002;*/

	   if ((year % 4) != 0) 	/* If not a leap year */      /*;AC000;4*/
	     if (day >	28)		/*  if Feb 29 or above */     /*;AC000;4*/
	      parse_error(INV_DATE,(BYTE)UTILMSG);		      /*;AC000;4*//*;AC002;*/
	 }							      /*;AC000;4*/

	return; 						      /*;AN000;4*/
}								      /*;AN000;4*/
/*************************************************/
/*
/* SUBROUTINE NAME:	check_time
/*
/* FUNCTION:
/*
/*	A time parameter was entered. Validate it
/*
/**************************************************/
void	check_time(hours,minutes,seconds)		      /*;AN000;4*//*;AC002;*/
BYTE	hours;							      /*;AN000;4*/
BYTE	minutes;						      /*;AN000;4*/
BYTE	seconds;						      /*;AN000;4*/
{								      /*;AN000;4*/

	if (hours > 23 || hours < 0)				      /*;AC000;4*/
	 parse_error(INV_TIME,(BYTE)UTILMSG);			      /*;AC000;4*//*;AC002;*/

	if (minutes >= 60 || minutes < 0)			      /*;AC000;4*/
	  parse_error(INV_TIME,(BYTE)UTILMSG);			      /*;AC000;4*//*;AC002;*/

	if (seconds >= 60 || seconds < 0)			      /*;AC000;4*/
	   parse_error(INV_TIME,(BYTE)UTILMSG); 		      /*;AC000;4*//*;AC002;*/

	return; 						      /*;AN000;4*/
}								      /*;AN000;4*/

/*************************************************/
/*
/* SUBROUTINE NAME:	parse_init
/*
/* FUNCTION:
/*
/*	Initialize the parser data structures
/*
/**************************************************/
#define SSTRING 0x2000			/*;AN000;4*/
#define FILESPEC 0x0200 		/*;AN000;4 */
#define CAP_FILETABLE 0x0001		/*;AN000;4 */
#define DRIVELETTER 0x100;		/*;AN000;4 */
#define DATESTRING 0x1000		/*;AN000;4 */
#define TIMESTRING 0x0800		/*;AN000;4 */

void	parse_init()					/*;AN000;4 */

{		/* Initialize PARMS data structure */	/*;AN000;4 */
	parms.parmsx_ptr = (WORD)&parmsx;		/*;AN000;4 */
	parms.p_num_extra = 1;				/*;AN000;4 */
	parms.p_len_extra_delim = 1;			/*;AN000;4 */
	parms.p_extra_delim[0] = ';';                   /*;AN000;4 */
	parms.p_extra_delim[1] = NUL;			/*;AN000;4 */

		/* Initialize PARMSX data structure */
	parmsx.p_minpos= 2;				/*;AN000;4 */
	parmsx.p_maxpos= 2;				/*;AN000;4 */
	parmsx.pos1_ptr= (WORD)&pos1;			/*;AN000;4 */
	parmsx.pos2_ptr= (WORD)&pos2;			/*;AN000;4 */
	parmsx.num_sw  = 4;				/*;AN000;4 */
	parmsx.sw1_ptr = (WORD)&sw1;			/*;AN000;4 */
	parmsx.sw2_ptr = (WORD)&sw2;			/*;AN000;4 */
	parmsx.sw3_ptr = (WORD)&sw3;			/*;AN000;4 */
	parmsx.sw4_ptr = (WORD)&sw4;
	parmsx.num_keywords = 0;			/*;AN000;4 */

		/* Initialize POS1 (Source Drive) data structure */
	pos1.match_flag = FILESPEC;			/*;AN000;4 */
	pos1.function_flag = 0; 			/*;AN000;4 */
	pos1.result_buf = (WORD)&pos_buff;		/*;AN000;4 */
	pos1.value_list = (WORD)&noval; 		/*;AN000;4 */
	pos1.nid = 0;					/*;AN000;4 */

		/* Initialize POS2 (Target FILESPEC) data structure */
	pos2.match_flag = SSTRING;			/*;AN000;4 */
	pos2.function_flag = 0; 			/*;AN000;4 */
	pos2.result_buf = (WORD)&pos_buff;		/*;AN000;4 */
	pos2.value_list = (WORD)&noval; 		/*;AN000;4 */
	pos2.nid = 0;					/*;AN000;4 */

		/* Initialize SW1 data structure */
	sw1.p_match_flag = DATESTRING;			/*;AN000;4 */
	sw1.p_function_flag = 0;			/*;AN000;4 */
	sw1.p_result_buf = (WORD)&date_buff;		/*;AN000;4 */
	sw1.p_value_list = (WORD)&noval;		/*;AN000;4 */
/*	sw1.p_nid = 2;					|* MR001-  *|	 */
	sw1.p_nid = 3;					/* MR001+  */
	strcpy(sw1.switch1,"/B");                       /*;AN000;4 */
	strcpy(sw1.switch2,"/A");                       /*;AN000;4 */
	strcpy(sw1.switch3,"/Z");                       /* MR001+  */

		/* Initialize SW2 data structure */
	sw2.p_match_flag = TIMESTRING;			/*;AN000;4 */
	sw2.p_function_flag = 0;			/*;AN000;4 */
	sw2.p_result_buf = (WORD)&time_buff;		/*;AN000;4 */
	sw2.p_value_list = (WORD)&noval;		/*;AN000;4 */
/*	sw2.p_nid = 2;					|* MR001-  *|	 */
	sw2.p_nid = 3;					/* MR001+  */
	strcpy(sw2.switch1,"/E");                       /*;AN000;4 */
	strcpy(sw2.switch2,"/L");                       /*;AN000;4 */
	strcpy(sw2.switch3,"/Y");                       /* MR001+  */


		/* Initialize SW3 data structure */
	sw3.p_match_flag = 0;				/*;AN000;4 */
	sw3.p_function_flag = 0;			/*;AN000;4 */
	sw3.p_result_buf = (WORD)&sw_buff;		/*;AN000;4 */
	sw3.p_value_list = (WORD)&noval;		/*;AN000;4 */
/*C01        sw3.p_nid = 4; */                               /*;AN000;4 */
        sw3.p_nid = 5;                                                  /*C01*/
	strcpy(sw3.switch1,"/S");                       /*;AN000;4 */
	strcpy(sw3.switch2,"/P");                       /*;AN000;4 */
	strcpy(sw3.switch3,"/M");                       /*;AN000;4 */
	strcpy(sw3.switch4,"/N");                       /*;AN000;4 */
        strcpy(sw3.switch5,"/D");                                       /*C01*/

		/* Initialize SW4 data structure */
	sw4.p_match_flag = 0;
	sw4.p_function_flag = 0;
	sw4.p_result_buf = (WORD)&sw_buff;
	sw4.p_value_list = (WORD)&noval;
	sw4.p_nid = 1;
	strcpy(sw4.switch4,"/?");

   /*********************************************/
   /* Also initialize all time and date values	*/
   /*********************************************/
	td.earlier_hour = 0;
	td.earlier_minute = 0;
	td.earlier_second = 0;
	td.later_hour = 0;
	td.later_minute = 0;
	td.later_second = 0;
	td.exact_hour = 0;				/* MR001+ */
	td.exact_minute = 0;				/* MR001+ */
	td.exact_second = 0;				/* MR001+ */
	td.before_year = 0;
	td.before_month = 0;
	td.before_day = 0;
	td.after_year = 0;
	td.after_month = 0;
	td.after_day = 0;
	td.exact_year = 0;				/* MR001+ */
	td.exact_month = 0;				/* MR001+ */
	td.exact_day = 0;				/* MR001+ */


   /**************************************************/
   /* Also initialize the message substitution list  */
   /**************************************************/
	sublist.sl_size1= SUBLIST_SIZE; 	/*;AN000;6*/
	sublist.sl_size2= SUBLIST_SIZE; 	/*;AN000;6*/
	sublist.one = 1;			/*;AN000;6*/
	sublist.two = 2;			/*;AN000;6*/
	sublist.zero1 = 0;			/*;AN000;6*/
	sublist.zero2 = 0;			/*;AN000;6*/
	sublist.pad_char1 = ' ';                /*;AN000;6*/
	sublist.pad_char2 = ' ';                /*;AN000;6*/

	return; 				/*;AN000;4 */
}						/*;AN000;4 */


/*************************************************/
/*
/* SUBROUTINE NAME:	check_for_device_names
/*
/* FUNCTION:
/*
/*	Make sure user not trying to restore a reserved device name
/*
/**************************************************/
void check_for_device_names(argv)				      /*;AN000;p2591*/
char	*argv[];						      /*;AN000;p2591*/
{								      /*;AN000;p2591*/
	union REGS qregs;					      /*;AN000;p2591*/
	char target[128];					      /*;AN000;p2591*/
	char *t;						      /*;AN000;p2591*/

#define CAPITALIZE_STRING 0x6521				      /*;AN000;p2591*/

	qregs.x.ax = CAPITALIZE_STRING; 			      /*;AN000;p2591*/
	qregs.x.dx = (WORD)argv[2];				      /*;AN000;p2591*/
	strcpy(target,argv[2]); 				      /*;AN000;p2591*/
	qregs.x.cx = strlen(target);				      /*;AN000;p2591*/
	intdos(&qregs,&qregs);					      /*;AN000;p2591*/
	strcpy(target,argv[2]); 				      /*;AN000;p2591*/

	for (t=&target[0]; *t!=NUL; t++)
	 if							      /*;AN000;p2591*/
	  ( strcmp(t,"LPT1")==0   ||                                  /*;AN000;p2591*/
	    strcmp(t,"LPT2")==0   ||                                  /*;AN000;p2591*/
	    strcmp(t,"PRN")==0    ||                                  /*;AN000;p2591*/
	    strcmp(t,"CON")==0    ||                                  /*;AN000;p2591*/
	    strcmp(t,"NUL")==0    ||                                  /*;AN000;p2591*/
	    strcmp(t,"AUX")==0    ||                                  /*;AN000;p2591*/
	    strcmp(t,"LPT1:")==0  ||                                  /*;AN000;p2591*/
	    strcmp(t,"LPT2:")==0  ||                                  /*;AN000;p2591*/
	    strcmp(t,"PRN:")==0   ||                                  /*;AN000;p2591*/
	    strcmp(t,"CON:")==0   ||                                  /*;AN000;p2591*/
	    strcmp(t,"NUL:")==0   ||                                  /*;AN000;p2591*/
	    strcmp(t,"AUX:")==0                                       /*;AN000;p2591*/
	  )							      /*;AN000;p2591*/
	 {							      /*;AN000;p2591*/
	   sublist.value1 = (char far *)t;			      /*;AN000;p2591*/
	   sublist.flags1 = LEFT_ALIGN + CHAR_FIELD_ASCIIZ;	      /*;AN000;p2591*/
	   sublist.one = 0;					      /*;AN000;p2591*/
	   sublist.max_width1 = (BYTE)strlen(t);		      /*;AN000;p2591*/
	   sublist.min_width1 = sublist.max_width1;		      /*;AN000;p2591*/

	   display_it(INVPARM,STND_ERR_DEV,1,NO_RESPTYPE,(BYTE)PARSEERROR);/*;AN000;p2591*/
	   usererror(INVALIDPARM);				      /*;AN000;p2591*/
	 }							      /*;AN000;p2591*/


	return; 						      /*;AN000;p2591*/
}								      /*;AN000;p2591*/

/*************************************************/
/*
/* SUBROUTINE NAME:	check_source_drive
/*
/* FUNCTION:
/*
/*	Verify drive letter and start building srcddir
/*
/**************************************************/
void check_source_drive(argv)		/*;AN000;4*/
char	*argv[];				/*;AN000;4*/
{						/*;AN000;4*/
	WORD  retcode;				/*;AC000;*/
	WORD  device_handle;
	WORD  action;
	BYTE  media_type;
	WORD  dnumwant = 1;
	BYTE  temp_array1[4];
	BYTE  temp_array2[4];
	union REGS qregs;					      /*;AN000;8*/
	union REGS reg;

	*argv[1]=(BYTE)com_toupper(*argv[1]);			      /*;AN000;4*/

	if (							      /*;AN000;4*/
	     *argv[1] < 'A'    ||                                     /*;AN000;4*/
	     *argv[1] > 'Z'    ||                                     /*;AN000;4*/
	     *(argv[1]+1)!=':' ||                                     /*;AN000;4*/
	     *(argv[1]+2)!=NUL					      /*;AN000;4*/
	   )							      /*;AN000;4*/
	  {							      /*;AN000;4*/
	   display_it(INVALID_DRIVE,STND_ERR_DEV,0,NO_RESPTYPE,(BYTE)UTIL_MSG);/*;AN000;6*/
	   usererror(INVALIDDRIVE);				      /*;AN000;4*/
	  }							      /*;AN000;4*/

	srcd = (BYTE)*argv[1];					      /*;AN000;4*/
	srcddir[0] = srcd;					      /*;AN000;4*/
	srcddir[1] = ':';                                             /*;AN000;4*/
	srcddir[2] = NUL;					      /*;AN000;4*/

   /***********************************************************************/
   /* dosopen to find out whether the src drive exist			  */
   /* and dosdevioctl to find out whether it is a removable drive	  */
   /***********************************************************************/
       retcode =						      /*;AC000;4*/
	 DOSOPEN						      /*;AC000;4*/
	  ( (char far *)&srcddir[0],				      /*;AC000;4*/
	    (unsigned far *)&device_handle,			      /*;AC000;4*/
	    (unsigned far *)&action,				      /*;AC000;4*/
	    (DWORD)0,			/*file size*/		      /*;AC000;4*/
	    0,				/*file attribute*/	      /*;AC000;4*/
	    0x01,			/*if file exist, open it*/    /*;AC000;4*/
					/*if file not exist, fail it*//*;AC000;4*/
	    0x80c2,			/*deny write, read only*/     /*;AC000;4*/
	    (DWORD)0			/*reserved*/		      /*;AC000;4*/
	  );							      /*;AC000;4*/

       if (retcode != NOERROR)					      /*;AC000;4*/
	{							      /*;AC000;4*/
	  display_it(INVALID_DRIVE,STND_ERR_DEV,0,NO_RESPTYPE,(BYTE)UTIL_MSG);/*;AN000;6*/
	  usererror(INVALIDDRIVE);				      /*;AC000;4*/
	}							      /*;AC000;4*/

     /************************************/			      /*;AC000;4*/
     /* See if source drive is removable */			      /*;AC000;4*/
     /************************************/			      /*;AC000;4*/

	if(device_handle > 0xffe4)  {
	    device_handle = -(int)device_handle;
	    device_handle--;
	  }
	reg.h.ah = 0x44;
	reg.h.al = 0x8;
	reg.x.bx = device_handle;
	intdos(&reg, &reg);
	if(reg.x.cflag)  {	/* possible only for network drives */
/* M001 Start - NSM - changes to detect net work drives */
	    reg.h.ah = 0x44;
	    reg.h.al = 0x9;
	    reg.x.bx = device_handle;
	    intdos(&reg,&reg);		/* get device drive attributes */
	    if (reg.x.cflag) {		/* impossible, since we must have */
		retcode = reg.x.ax;	/* checked the drive before this */
	    }
	    else {
		retcode = NOERROR;
		media_type = (reg.x.dx & 0x1000)?1:0;
	    }
 	  }
	else {
		media_type = reg.h.al;
		retcode = NOERROR;
	}
/* M001 End */

      if (retcode != NOERROR)					      /*;AC000;4*/
       { display_it(INVALID_DRIVE,STND_ERR_DEV,0,NO_RESPTYPE,(BYTE)UTIL_MSG);/*;AN000;6*/
	 usererror(INVALIDDRIVE);				      /*;AC000;4*/
       }							      /*;AC000;4*/

#define REMOVABLE 0						      /*;AC000;4*/
   if (media_type != REMOVABLE) 				      /*;AC000;4*/
      set_reset_test_flag(&control_flag2,SRC_HDISK,SET);	      /*;AC000;4*/

    else	/* Source disk is removable */			      /*;AC000;4*/
     {								      /*;AC000;4*/
	temp_array1[0] = (BYTE)((dnumwant / 10) + '0');               /*;AC000;4*/
	temp_array1[1] = (BYTE)((dnumwant % 10) + '0');               /*;AC000;4*/
	temp_array1[2] = NUL;					      /*;AC000;4*/
	temp_array2[0] = srcd;					      /*;AC000;4*/
	temp_array2[1] = NUL;					      /*;AC000;4*/

	sublist.value1 = (char far *)temp_array1;		      /*;AN000;6*/
	sublist.flags1 = LEFT_ALIGN + CHAR_FIELD_ASCIIZ;	      /*;AN000;6*/
	sublist.max_width1 = (BYTE)strlen(temp_array1); 	      /*;AN000;6*/
	sublist.min_width1 = sublist.max_width1;		      /*;AN000;6*/

	sublist.value2 = (char far *)temp_array2;		      /*;AN000;6*/
	sublist.flags2 = LEFT_ALIGN + CHAR_FIELD_ASCIIZ;	      /*;AN000;6*/
	sublist.max_width2 = (BYTE)strlen(temp_array2); 	      /*;AN000;6*/
	sublist.min_width2 = sublist.max_width2;		      /*;AN000;6*/

	display_it(INSERT_SOURCE_DISK,STND_ERR_DEV,2,NO_RESPTYPE,(BYTE)UTIL_MSG); /*;AN000;6*/
	display_it(PRESS_ANY_KEY,STND_ERR_DEV,0,ANY_KEY_RESPTYPE,(BYTE)UTIL_MSG); /*;AN000;6*/

				/* If single drive system, eliminates double prompting */
				/* for user to "Insert diskette for drive %1" */
	qregs.x.ax = SETLOGICALDRIVE;				      /*;AN000;8*/
	qregs.h.bl = srcddir[0] - 'A' + 1;                            /*;AN000;8*/
	intdos(&qregs,&qregs);					      /*;AN000;8*/

     }								      /*;AC000;4*/
	return; 						      /*;AN000;4*/
}								      /*;AN000;4*/

/*************************************************/
/*
/* SUBROUTINE NAME:	check_target_filespec
/*
/* FUNCTION:
/*
/*	Verify the target filespec.
/*	 1. Validate destination drive, or use default if none specified
/*	 2. Validate path, or use current dir if not specified
/*	 3. Validate the file name
/*
/**************************************************/
void check_target_filespec(argc,argv)				      /*;AN000;4*/
int	argc;							      /*;AN000;4*/
char	*argv[];						      /*;AN000;4*/
{								      /*;AN000;4*/
	WORD  retcode;						      /*;AC000;*/
	WORD  device_handle;
	WORD  action;
	BYTE  media_type;
	DWORD drive_map;
	BYTE  temp_destddir[MAXPATH+2];
	BYTE  temp_array1[4];
	WORD  default_drive_num;
	WORD  destd_num;
	WORD  dirlen = MAXPATH;
	BYTE  tdestddir[MAXPATH+3];
	BYTE  ttdestddir[MAXPATH+3];
	BYTE  srcf[MAXPATHF];
	BYTE  argv2_has_switch;
	BYTE  search_string[MAXPATHF+2];
	BYTE  tempp[MAXPATH];
	WORD  j,k,z;
	BYTE *c;
	BYTE  backdir;
	WORD  dnumwant = 1;
	union REGS qregs;					      /*;AN000;8*/
	union REGS reg;


	/**************************/
	/*  Uppercase the string  */
	/**************************/
#define CAPITALIZE_STRING 0x6521				      /*;AN000;p????*/

	qregs.x.ax = CAPITALIZE_STRING; 			      /*;AN000;p????*/
	qregs.x.dx = (WORD)argv[2];				      /*;AN000;p????*/
	strcpy(tempp,argv[2]);					      /*;AN000;p????*/
	qregs.x.cx = strlen(tempp);				      /*;AN000;p????*/
	intdos(&qregs,&qregs);					      /*;AN000;p????*/


	/***************************************************/
	/* If no drive letter specified, use current drive */
	/***************************************************/
	if (							      /*;AC000;4*/
	     *(argv[2]+1)!=':' ||                                     /*;AC000;4*/
	     *argv[2] < 'A'    ||                                     /*;AC000;4*/
	     *argv[2] > 'Z'                                           /*;AC000;4*/
	   )							      /*;AC000;4*/
	  {							      /*;AC000;4*/
	   DOSQCURDISK						      /*;AC000;4*/
	    ( (unsigned far *)&default_drive_num,		      /*;AC000;4*/
	      (DWORD far *) &drive_map				      /*;AC000;4*/
	    );							      /*;AC000;4*/
	   destd = (BYTE)(default_drive_num + 'A' - 1);               /*;AC000;4*/
	  }							      /*;AC000;4*/
	 else							      /*;AC000;4*/
	  {	       /* User specified the destination drive*/      /*;AC000;4*/
	    destd = (BYTE)*argv[2];				      /*;AC000;4*/
	    argv[2] = argv[2] + 2;				      /*;AC000;4*/
	  }							      /*;AC000;4*/

	destddir[0] = destd;					      /*;AC000;4*/
	destddir[1] = ':';                                            /*;AC000;4*/
	destddir[2] = NUL;					      /*;AC000;4*/

   /***********************************************************************/
   /* if source drive and destination drive are the same, output error msg*/
   /***********************************************************************/
   if (srcd == destd)						      /*;AC000;4*/
    {								      /*;AC000;4*/
     display_it(SOURCE_TARGET_SAME,STND_ERR_DEV,0,NO_RESPTYPE,(BYTE)UTIL_MSG);/*;AN000;6*/
     usererror(INVALIDPARM);					      /*;AC000;4*/
    }								      /*;AC000;4*/

   /***********************************************************************/
   /* dosopen to find out whether the destination drive is exist	  */
   /* and dosdevioctl to find out whether it is a removable drive	  */
   /***********************************************************************/

       retcode =						      /*;AC000;4*/
	DOSOPEN 						      /*;AC000;4*/
	 ( (char far *)&destddir[0],				      /*;AC000;4*/
	   (unsigned far *)&device_handle,			      /*;AC000;4*/
	   (unsigned far *)&action,				      /*;AC000;4*/
	   (DWORD)0,		/*file size*/			      /*;AC000;4*/
	   0,			/*file attribute*/		      /*;AC000;4*/
	   0x01,		/*if file exist, open it*/	      /*;AC000;4*/
				/*if file not exist, fail it*/	      /*;AC000;4*/
	   0x80c2,		/*deny write, read only*/	      /*;AC000;4*/
	   (DWORD)0		/*reserved*/			      /*;AC000;4*/
	 );							      /*;AC000;4*/

	  if (retcode != NOERROR)/*if open fail*/		      /*;AC000;4*/
	   {							      /*;AC000;4*/
	     display_it(INVALID_DRIVE,STND_ERR_DEV,0,NO_RESPTYPE,(BYTE)UTIL_MSG);/*;AN000;6*/
	     usererror(INVALIDDRIVE);				      /*;AC000;4*/
	   }							      /*;AC000;4*/

     /************************************/			      /*;AC000;4*/
     /* See if target drive is removable */			      /*;AC000;4*/
     /************************************/			      /*;AC000;4*/

	if(device_handle > 0xffe4)  {
	    device_handle = -(int)device_handle;
	    device_handle--;
	  }
	reg.h.ah = 0x44;
	reg.h.al = 0x8;
	reg.x.bx = device_handle;
	intdos(&reg, &reg);
	if(reg.x.cflag)  {
/* M001 Start - NSM changes to detect network drives */
	    reg.h.ah = 0x44;
	    reg.h.al = 0x9;
	    reg.x.bx = device_handle;
	    intdos(&reg,&reg);		/* get device drive attributes */
	    if (reg.x.cflag) {		/* impossible, since we must have */
		retcode = reg.x.ax;	/* checked the drive before this */
	    }
	    else {
		retcode = NOERROR;
		media_type = (reg.x.dx & 0x1000)?1:0;
	    }
 	  }
	else {
		media_type = reg.h.al;
		retcode = NOERROR;
	}
/* M001 End */

      if (retcode != NOERROR)					      /*;AC000;4*/
       { display_it(INVALID_DRIVE,STND_ERR_DEV,0,NO_RESPTYPE,(BYTE)UTIL_MSG);/*;AN000;6*/
	 usererror(INVALIDDRIVE);				      /*;AC000;4*/
       }							      /*;AC000;4*/

   if (media_type == REMOVABLE) 				      /*;AC000;4*/
    { temp_array1[0] = destd;					      /*;AC000;4*/
      temp_array1[1] = NUL;					      /*;AC000;4*/
      sublist.value1 = (char far *)temp_array1; 		      /*;AN000;6*/
      sublist.flags1 = LEFT_ALIGN + CHAR_FIELD_ASCIIZ;		      /*;AN000;6*/
      sublist.max_width1 = (BYTE)strlen(temp_array1);		      /*;AN000;6*/
      sublist.min_width1 = sublist.max_width1;			      /*;AN000;6*/

     display_it(INSERT_TARGET_DISK,STND_ERR_DEV,1,NO_RESPTYPE,(BYTE)UTIL_MSG); /*;AN000;6*/
     display_it(PRESS_ANY_KEY,STND_ERR_DEV,0,ANY_KEY_RESPTYPE,(BYTE)UTIL_MSG); /*;AN000;6*/
    }								      /*;AC000;4*/

				/* If single drive system, eliminates double prompting */
				/* for user to "Insert diskette for drive %1" */
   qregs.x.ax = SETLOGICALDRIVE;				      /*;AN000;8*/
   qregs.h.bl = destddir[0] - 'A' + 1;                                /*;AN000;8*/
   intdos(&qregs,&qregs);					      /*;AN000;8*/

   /**********************************************************************/
   /*  save current directory of destination disk to be reset back later */
   /**********************************************************************/

   destd_num = (WORD) (destd - 'A' +1);                               /*;AC000;4*/

   /*  get current directory of destd_num (DosQCurDir) */
   if ((retcode =						      /*;AC000;4*/
	DOSQCURDIR						      /*;AC000;4*/
	 ( destd_num,						      /*;AC000;4*/
	   (char far *) tdestddir,				      /*;AC000;4*/
	   (unsigned far *) &dirlen)				      /*;AC000;4*/
	 ) != 0)						      /*;AC000;4*/
    {								      /*;AC000;4*/
	display_it(INVALID_DRIVE,STND_ERR_DEV,0,NO_RESPTYPE,(BYTE)UTIL_MSG);/*;AN000;6*/
	usererror(INVALIDDRIVE);				      /*;AC000;4*/
    }								      /*;AC000;4*/

#define BACKSLASH 0x5c

   if (strlen(tdestddir) != 1)					      /*;AC000;4*/
    { strcpy(temp_destddir,"\\");                                     /*;AC000;4*/
      strcat(temp_destddir,tdestddir);				      /*;AC000;4*/
      strcpy(tdestddir,temp_destddir);				      /*;AC000;4*/
    }								      /*;AC000;4*/


   /**********************************************************************/
   /* The next parameter has to be a file name with or without path,	 */
   /* or a switch.  In the case of there is no path, the current path	 */
   /* is used.	In the case of there is no file name, the global file	 */
   /* name *.* is used							 */
   /**********************************************************************/
   /*	argv[2] is a drive spec*/				      /*;AC000;4*/
   if (*(argv[2]+1)==':' && *argv[2] >= 'A' && *argv[2] <= 'Z' && argc!=2)      /*;AC000;4*/
    {								      /*;AN000;6*/
      display_it(INVPARM,STND_ERR_DEV,0,NO_RESPTYPE,(BYTE)PARSEERROR);/*;AN000;6*/
      usererror(INVALIDPARM);					      /*;AC000;4*/
    }								      /*;AC000;4*/
   else 							      /*;AC000;4*/
    {  /*if argv[2] is not a drive spec */			      /*;AC000;4*/
       /*if argv[2] started with '/' (is a switch) or there is no argv[i]*/     /*;AC000;4*/
       if (*argv[2] == '/' ||  *argv[2] == NUL || argc ==2)           /*;AC000;4*/
	{  strcpy(srcf,tdestddir);				      /*;AC000;4*/
	   strcat(srcf,"\\*.*");                                      /*;AC000;4*/
	}							      /*;AC000;4*/
       else							      /*;AC000;4*/
	{ /*argv[2] does not started with / */			      /*;AC000;4*/
	   /* find out whether part of argv[2] is switch specification */	/*;AC000;4*/
	   for (k = 0; argv[2][k] != '/' && argv[2][k] != NUL;   ++k);/*;AC000;4*/
	   if (argv[2][k] == '/')                                     /*;AC000;4*/
	    {							      /*;AC000;4*/
	      argv[2][k] = NUL; 				      /*;AC000;4*/
	      argv2_has_switch = TRUE;				      /*;AC000;4*/
	    }							      /*;AC000;4*/

	   /*if argv[2] is \\, invalid parm */			      /*;AC000;4*/
	   if (argv[2][0] == '\\' && argv[2][1] == '\\' || argv[2][0] == ':')   /*;AC000;;4*/
	    {							      /*;AN000;6*/
	      display_it(INVPARM,STND_ERR_DEV,0,NO_RESPTYPE,(BYTE)PARSEERROR);/*;AN000;6*/
	      usererror(INVALIDPARM);				      /*;AC000;4*/
	    }							      /*;AC000;4*/

	   /*if argv[2] starts with '\' (it is a complete path)*/     /*;AC000;4*/
	   if (*argv[2] == '\\')                                      /*;AC000;4*/
	     strcpy(srcf,argv[2]);				      /*;AC000;4*/
	   else 						      /*;AC000;4*/
	      /* it is not a complete path, have to put current path in  */	/*;AC000;;4*/
	      /* front of the string to build a complete path */      /*;AC000;4*/
	    {  strcpy(srcf,tdestddir);				      /*;AC000;4*/
	       if (strlen(tdestddir) != 1)			      /*;AC000;4*/
		    strcat(srcf,"\\");                                /*;AC000;4*/
	       strcat(srcf,argv[2]);				      /*;AC000;4*/
	    } /*endif*/ 					      /*;AC000;4*/
	} /*end of argv[2] does not start with '/' */                 /*;AC000;4*/

       j = strlen(srcf);					      /*;AC000;4*/
       z = 0;							      /*;AC000;4*/
       do							      /*;AC000;4*/
	{  for (;srcf[z] != '.' && srcf[z] != NUL;   ++z);            /*;AC000;4*/
	   if (srcf[z] == '.' && srcf[z+1] == '.' &&                  /*;AC000;4*/
	       (srcf[z+2] == '\\' || srcf[z+2] == NUL))               /*;AC000;4*/
	    { backdir = TRUE;					      /*;AC000;4*/
	      break;						      /*;AC000;4*/
	    }							      /*;AC000;4*/
	   z = z+1;						      /*;AC000;4*/
	}							      /*;AC000;4*/
	while (z < j);						      /*;AC000;4*/

       /*validate the path*/					      /*;AC000;4*/
       for (z = j; srcf[z] != '\\'; --z);                             /*;AC000;4*/
       strcpy(tempp,srcf);					      /*;AC000;4*/
       tempp[z] = NUL;						      /*;AC000;4*/

       for (z = 0; tempp[z] != '*' && tempp[z] != NUL;   ++z);        /*;AC000;4*/
       if (tempp[z] == '*' )                                          /*;AC000;4*/
	{  display_it(PATH_NOT_FOUND,STND_ERR_DEV,1,NO_RESPTYPE,(BYTE)UTIL_MSG);     /*;AN000;6*/
	   usererror(INVALIDPARM);				      /*;AC000;4*/
	}							      /*;AC000;4*/

       if (backdir == TRUE)					      /*;AC000;4*/
	{  search_string[0] = destd;				      /*;AC000;4*/
	   search_string[1] = ':';                                    /*;AC000;4*/
	   search_string[2] = NUL;				      /*;AC000;4*/
	   if (srcf[0]	== NUL) 				      /*;AC000;4*/
	      strcat(search_string,"\\");                             /*;AC000;4*/
	   else 						      /*;AC000;4*/
	      strcat(search_string, tempp);			      /*;AC000;4*/

	   if(chdir(search_string)!=0)				      /*;AC000;4*/
	    { sublist.value1 = (char far *)argv[2];		      /*;AN000;6*/
	      sublist.flags1 = LEFT_ALIGN + CHAR_FIELD_ASCIIZ;	      /*;AN000;6*/
	      sublist.max_width1 = (BYTE)strlen(argv[2]);	      /*;AN000;6*/
	      sublist.min_width1 = sublist.max_width1;		      /*;AN000;6*/
	      display_it(PATH_NOT_FOUND,STND_ERR_DEV,1,NO_RESPTYPE,(BYTE)UTIL_MSG);  /*;AN000;6*/
	      usererror(INVALIDPARM);				      /*;AC000;4*/
	    }							      /*;AC000;4*/

	   dirlen = MAXPATH;					      /*;AC000;4*/
	   if ((retcode = DOSQCURDIR(destd_num, 		      /*;AC000;4*/
	       (char far *) ttdestddir, 			      /*;AC000;4*/
	       (unsigned far *) &dirlen)) != NOERROR)		      /*;AC000;4*/
	    {							      /*;AC000;4*/
	     com_msg(retcode);					      /*;AC000;4*/
	     usererror(retcode);				      /*;AC000;4*/
	    }							      /*;AC000;4*/
	   /* endif */						      /*;AC000;4*/

	   temp_destddir[0] = destd;				      /*;AC000;4*/
	   temp_destddir[1] = ':';                                    /*;AC000;4*/
	   temp_destddir[2] = NUL;				      /*;AC000;4*/
	   strcat(temp_destddir,tdestddir);			      /*;AC000;4*/
	   chdir(temp_destddir);				      /*;AC000;4*/

	   if (strlen(ttdestddir) != 1) 			      /*;AC000;4*/
	    { strcpy(temp_destddir,"\\");                             /*;AC000;4*/
	      strcat(temp_destddir,ttdestddir); 		      /*;AC000;4*/
	      strcpy(ttdestddir,temp_destddir); 		      /*;AC000;4*/
	    }							      /*;AC000;4*/

	   strcat(ttdestddir,"\\");                                   /*;AC000;4*/
	   strcat(ttdestddir,srcf+z+1); 			      /*;AC000;4*/
	   strcpy(srcf,ttdestddir);				      /*;AC000;4*/
	} /*end of if backdir is true */			      /*;AC000;4*/

       /* The documentation says if path is specified, file name has to */
       /* be specified also.  This logic actually allows user to specify*/
       /* path without specify filename, as long as the path end with	*/
       /* '\'.*/
       /*If *srcf ends with '\', add "*.*" to the end*/               /*;AC000;4*/
       j = strlen(srcf);					      /*;AC000;4*/
       if (srcf[j-1] == '\\')                                         /*;AC000;4*/
	   strcat(srcf,"*.*");                                        /*;AC000;4*/
       if (argv2_has_switch == TRUE)				      /*;AC000;4*/
	{  *(argv[2]+k) = '/';                                        /*;AC000;4*/
	   argv[2] = argv[2] + k;				      /*;AC000;4*/
	}   /* end of if argv[2] started with '/' */                  /*;AC000;4*/
   }  /* end of checking for argv[2] */ 			      /*;AC000;4*/

  /**********************************************************************/
  /* add '\' at the beginning of the current destination directory      */
  /**********************************************************************/
   temp_destddir[0] = destd;					      /*;AC000;4*/
   temp_destddir[1] = ':';                                            /*;AC000;4*/
   temp_destddir[2] = NUL;					      /*;AC000;4*/
   strcat(temp_destddir,tdestddir);				      /*;AC000;4*/
   strcpy(destddir,temp_destddir);				      /*;AC000;4*/

   /************************************************************************/
   /* separate the filename for search into prefix(inpath),		   */
   /* filename(infname), and file extension (infext)			   */
   /* Also take care of the situation that user enter '.' only             */
   /* for file spec.							   */
   /************************************************************************/
   separate(srcf,inpath,infname,infext,infspec);		      /*;AC000;4*/
   if (strlen(infname) > MAXFNAME-1 ||				      /*;AC000;4*/
       strlen(infext) > MAXFEXT-1   ||				      /*;AC000;4*/
       strlen(inpath) > MAXPATH-1  ||				      /*;AC000;4*/
       strcmp(infspec,"LPT1")==0   ||                                 /*;AC000;4*/
       strcmp(infspec,"LPT2")==0   ||                                 /*;AC000;4*/
       strcmp(infspec,"PRN")==0    ||                                 /*;AC000;4*/
       strcmp(infspec,"CON")==0    ||                                 /*;AC000;4*/
       strcmp(infspec,"NUL")==0    ||                                 /*;AC000;4*/
       strcmp(infspec,"AUX")==0    ||                                 /*;AC000;4*/
       strcmp(infspec,"LPT1:")==0  ||                                 /*;AC000;4*/
       strcmp(infspec,"LPT2:")==0  ||                                 /*;AC000;4*/
       strcmp(infspec,"PRN:")==0   ||                                 /*;AC000;4*/
       strcmp(infspec,"CON:")==0   ||                                 /*;AC000;4*/
       strcmp(infspec,"NUL:")==0   ||                                 /*;AC000;4*/
       strcmp(infspec,"AUX:")==0 )                                    /*;AC000;4*/
   {								      /*;AC000;4*/
       sublist.value1 = (char far *)&infspec[0];		      /*;AN000;6*/
       sublist.flags1 = LEFT_ALIGN + CHAR_FIELD_ASCIIZ; 	      /*;AN000;6*/
       sublist.one = 0; 	/* Yes, this is right */	      /*;AN000;6*/
       sublist.max_width1 = (BYTE)strlen(infspec);		      /*;AN000;6*/
       sublist.min_width1 = sublist.max_width1; 		      /*;AN000;6*/

       display_it(INVPARM,STND_ERR_DEV,1,NO_RESPTYPE,(BYTE)PARSEERROR);/*;AN000;6*/
       usererror(INVALIDPARM);	     /* invalid parm */ 	      /*;AC000;4*/
   }								      /*;AC000;4*/

   /************************************************************************/
   /* set wildcard flag according to whether there is '*' or/and  '?' in   */
   /* file specification						   */
   /************************************************************************/
   c = infspec; 						      /*;AC000;4*/
   while (*c)							      /*;AC000;4*/
    {								      /*;AC000;4*/
      if (*c == '*' || *c == '?')                                     /*;AC000;4*/
       { set_reset_test_flag(&control_flag,WILDCARD,SET);	      /*;AC000;4*/
	 break; 						      /*;AC000;4*/
       }							      /*;AC000;4*/
      else							      /*;AC000;4*/
	c = c+1;						      /*;AC000;4*/
    }								      /*;AC000;4*/


	return; 				/*;AN000;4*/
}						/*;AN000;4*/

/*************************************************/
/*
/* SUBROUTINE NAME:	process_switch
/*
/* FUNCTION:
/*
/*	Identify the switch (/S,/P,/M,/N,/B:,/A:,/E:,/L:)
/*	 entered and handle it
/*
/**************************************************/
void process_switch(buff_addr)				      /*;AN000;4*//*;AC002;*/
unsigned buff_addr;						      /*;AN000;4*/
{								      /*;AN000;4*/

	if (buff_addr == (unsigned)&sw_buff)			      /*;AN000;4*/
	 {							      /*;AN000;4*/

	 	/* /? - options help check */

	 	if (sw_buff.sw_synonym_ptr == (WORD)&sw4.switch4[0])
			display_options_exit();

	   if (sw_buff.sw_synonym_ptr == (WORD)&sw3.switch1[0])       /*;AN000;4   /S */
	   {
			set_reset_test_flag(&rtswitch, SUB, SET);		      /*;AN000;4*/
	   }

	   if (sw_buff.sw_synonym_ptr == (WORD)&sw3.switch2[0])       /*;AN000;4   /P */
	     {							      /*;AN000;4*/
	      set_reset_test_flag(&rtswitch, PROMPT, SET);	      /*;AN000;4*/
	      set_reset_test_flag(&control_flag, SWITCHES, SET);      /*;AN000;4*/
	     }							      /*;AN000;4*/

	   if (sw_buff.sw_synonym_ptr == (WORD)&sw3.switch3[0])       /*;AN000;4   /M */
	     {							      /*;AN000;4*/
	      set_reset_test_flag(&rtswitch, Revised, SET);	      /*;AN000;4*/
	      set_reset_test_flag(&control_flag, SWITCHES, SET);      /*;AN000;4*/
	     }							      /*;AN000;4*/

	   if (sw_buff.sw_synonym_ptr == (WORD)&sw3.switch4[0])       /*;AN000;4   /N */
	     {							      /*;AN000;4*/
	      set_reset_test_flag(&rtswitch, NOTEXIST, SET);	      /*;AN000;4*/
	      set_reset_test_flag(&control_flag, SWITCHES, SET);      /*;AN000;4*/
	     }							      /*;AN000;4*/
           if (sw_buff.sw_synonym_ptr == (WORD)&sw3.switch5[0])         /*C01*/
             {                                                          /*C01*/
              set_reset_test_flag(&rtswitch2, DIR, SET);                /*C01*/
             }                                                          /*C01*/
	 }							      /*;AN000;4*/


	if (buff_addr == (unsigned)&time_buff)			      /*;AN000;4*/
	 {							      /*;AN000;4*/
	   check_time(time_buff.hours,time_buff.minutes,time_buff.seconds);	  /*;AN000;4*//*;AC002;*/

	   if (time_buff.tb_synonym_ptr == (WORD)&sw2.switch1[0])     /*;AN000;4   /E */
	     {							      /*;AN000;4*/
	       td.earlier_hour =   time_buff.hours;		      /*;AN000;4*/
	       td.earlier_minute = time_buff.minutes;		      /*;AN000;4*/
	       td.earlier_second = time_buff.seconds;		      /*;AN000;4*/
	       set_reset_test_flag(&rtswitch, EARLIER, SET);	      /*;AN000;4*/
	       set_reset_test_flag(&control_flag, SWITCHES, SET);     /*;AN000;4*/
	     }							      /*;AN000;4*/

	   if (time_buff.tb_synonym_ptr == (WORD)&sw2.switch2[0])     /*;AN000;4   /L */
	     {							      /*;AN000;4*/
	       td.later_hour =	 time_buff.hours;		      /*;AN000;4*/
	       td.later_minute = time_buff.minutes;		      /*;AN000;4*/
	       td.later_second = time_buff.seconds;		      /*;AN000;4*/
	       set_reset_test_flag(&rtswitch, LATER, SET);	      /*;AN000;4*/
	       set_reset_test_flag(&control_flag, SWITCHES, SET);     /*;AN000;4*/
	     }							      /*;AN000;4*/

	   if (time_buff.tb_synonym_ptr == (WORD)&sw2.switch3[0])     /* MR001+    /Y */
	     {							      /* MR001+ */
	       td.exact_hour =	 time_buff.hours;		      /* MR001+ */
	       td.exact_minute = time_buff.minutes;		      /* MR001+ */
	       td.exact_second = time_buff.seconds;		      /* MR001+ */
	       set_reset_test_flag(&rtswitch7, EXACT_TIME, SET);      /* MR001+ */
	       set_reset_test_flag(&control_flag, SWITCHES, SET);     /* MR001+ */
	     }							      /* MR001+ */


	 }							      /*;AN000;4*/


	if (buff_addr == (unsigned)&date_buff)			      /*;AN000;4*/
	 {							      /*;AN000;4*/
	   check_date(date_buff.year,date_buff.month,date_buff.day);	  /*;AN000;4*//*;AC002;*/

	   if (date_buff.db_synonym_ptr == (WORD)&sw1.switch1[0])     /*;AN000;4  /B */
	     {							      /*;AN000;4*/
	       td.before_year =  date_buff.year;		      /*;AN000;4*/
	       td.before_month = date_buff.month;		      /*;AN000;4*/
	       td.before_day =	 date_buff.day; 		      /*;AN000;4*/
	       set_reset_test_flag(&rtswitch, BEFORE, SET);	      /*;AN000;4*/
	       set_reset_test_flag(&control_flag, SWITCHES, SET);     /*;AN000;4*/
	     }							      /*;AN000;4*/

	   if (date_buff.db_synonym_ptr == (WORD)&sw1.switch2[0])     /*;AN000;4  /A */
	     {							      /*;AN000;4*/
	       td.after_year =	date_buff.year; 		      /*;AN000;4*/
	       td.after_month = date_buff.month;		      /*;AN000;4*/
	       td.after_day =	date_buff.day;			      /*;AN000;4*/
	       set_reset_test_flag(&rtswitch, AFTER, SET);	      /*;AN000;4*/
	       set_reset_test_flag(&control_flag, SWITCHES, SET);     /*;AN000;4*/
	     }							      /*;AN000;4*/

	   if (date_buff.db_synonym_ptr == (WORD)&sw1.switch3[0])     /* MR001+   /Z */
	     {							      /* MR001+ */
	       td.exact_year =	date_buff.year; 		      /* MR001+ */
	       td.exact_month = date_buff.month;		      /* MR001+ */
	       td.exact_day =	date_buff.day;			      /* MR001+ */
	       set_reset_test_flag(&rtswitch7, EXACT_DATE, SET);      /* MR001+ */
	       set_reset_test_flag(&control_flag, SWITCHES, SET);     /* MR001+ */
	     }							      /* MR001+ */


	 }							      /*;AN000;4*/

	return; 						      /*;AN000;4*/
}								      /*;AN000;4*/
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\restore\restore.c ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

/******************************************************************************
*
*  Change Log:
*
*    Date    Who   #                      Description
*  --------  ---  ---  ------------------------------------------------------
*  06/29/90  EGH  C01  Added support for doing a directory of backed up
*                      diskettes via the /D option.
*
******************************************************************************/

/*  0 */

/**************************************************************************/
/*
/*  MODULE NAME :  RESTORE utility
/*
/*  SOURCE FILE NAME: RESTORE.C
/*
/*  DESCRIPTIVE NAME : Restore one or more backed-up files from a
/*		       disk to another disk
/*
/*  FUNCTION: Restore files saved by BACKUP utility to their
/*	      destination disk.  This utility will be able to identify
/*	      which of the two backup formats was used and to do the
/*	      restore accordingly.
/*
/*  NOTES:  This RESTORE utility recognize two data formats:
/*	    1. The data format used by BACKUP utility of 3.2 and before.
/*	    2. The data format used by BACKUP utility of 3.3 and above,
/*	       and also used by CP/DOS 1.0 and above.
/*
/*	    DEPENDENCY:
/*	    This utility has a dependency on the BACKUP utility to
/*	    perform file backup correctly using the data structure
/*	    agreed on.
/*
/*	    RESTRICTION:
/*	    This utility is able to restore the files which are previously
/*	    backup by the BACKUP utility only.
/*
/*  ENTRY POINT: Main
/*
/*  INPUT: (PARAMETERS)
/*
/*	COMMAND SYNTAX:
/*	      [d:][path]Restore d: [d:][path][filename][.ext]
/*	      [/S] [/P] [/B:date] [/A:date] [/E:time][/L:time][/M] [/N]
/*
/*	Parameters:
/*	      The first parameter you specify is the drive designator of
/*	      the disk containing the backed up files.	The second
/*	      parameter is the a filespec indicating which files you want
/*	      to restore.
/*	Switches:
/*	      /S - Restore subdirectories too.
/*	      /P - If any hidden or read-only files match the filespec,
/*		   prompt the user for permission to restore them.
/*	      /B - Only restore those files which were last Revised on or
/*		   before the given date.
/*	      /A - Only restore those files which were last Revised on or
/*		   after the given date.
/*	      /E - Only restore those files which were last Revised at or
/*		   earlier then the given time.
/*	      /L - Only restore those files which were last Revised at or
/*		   later then the given time.
/*	      /M - Only restore those files which have been Revised since
/*		   the last backup.
/*	      /N - Only restore those files which no longer exist on the
/*		   destination disk.
/*	      /Z - Only restore file whose original date is exact match  MR001+
/*	      /Y - Only restore file whose original time is exact match  MR001+
/*
/*  EXIT-ERROR:
/*	 The restore program sets the ERRORLEVEL in the following manner:
/*
/*	   0   Normal completion
/*	   1   No files were found to backup
/*	   2   Some files not restored due to sharing conflict
/*	   3   Terminated by user
/*	   4   Terminated due to error
/*
/*
/*   SOURCE HISTORY:
/*
/*	Modification History:
/*
/*	   Code added in DOS 3.3 to allow control file > 64k commented as:
/*	   /* !wrw */
/*
/*	 ;AN000; Code added in DOS 4.0
/*		;AN000;2  Support for APPEND /X deactivation
/*		;AN000;4  Support for PARSE service routines
/*		;AN000;5  Support for code page file tags
/*		;AN000;6  Support for MESSAGE retriever
/*		;AN000;8  Eliminate double prompting on single drive systems
/*		;AN000;9  Fix for termination on "Unable to MKDIR"
/*		;AN000;10 Fix for p1620
/*		;AN001;   Add CR, LF to end of command line
/*		;AN002;   Make parser errors display the offending parameter
/*		;AN003;   Only disallow restore of system files in ROOT !!
/*		;AN004;   Fix parser
/*		;AN005;   Replace COM_STRRCHR dbcs routine, fixes p5029
/*****************  END OF SPECIFICATION    *********************************/

#include "rt.h"
#include "rt1.h"
#include "rt2.h"
#include "restpars.h"                                                 /*;AN000;4*/
#include "dos.h"                                                      /*;AN000;2*/
#include "comsub.h"             /* common subroutine def'n */
#include "doscalls.h"
#include "error.h"


BYTE destddir[MAXPATH+3] = {'\0'};
BYTE srcddir[MAXPATH+3] = {'\0'};
BYTE rtswitch=0;
BYTE rtswitch7=0;						     /* MR001+*/
BYTE rtswitch2=0;                                                       /*C01*/
BYTE control_flag=0;
BYTE control_flag2=0;
BYTE *buf_pointer;

/*=============================*/
BYTE srcd;							      /*;AN000;4*/
BYTE destd;							      /*;AN000;4*/
BYTE inpath  [MAXPATH]; 					      /*;AN000;*/
BYTE infname [MAXFNAME];					      /*;AN000;*/
BYTE infext  [MAXFEXT]; 					      /*;AN000;*/
BYTE infspec [MAXFSPEC];					      /*;AN000;*/
/*=============================*/
/*---------------------------------------*/
/*-					 */
/*- Data structures for the PARSER	 */
/*-					 */
/*---------------------------------------*/

struct	subst_list sublist;		/*;AN000;6 Message substitution list */
char	response_buff[5];		/*;AN000;6 User response buffer *//*;AN000;6*/

BYTE append_indicator = 0xff;		/*;AN000;2 Indicates the support for APPEND /X is active */
WORD original_append_func;		/*;AN000;2 APPEND functions on program entry*/
struct timedate td;

/*****************  START OF SPECIFICATION  *********************************/
/*
/*  SUBROUTINE NAME :  Main
/*
/*  DESCRIPTIVE NAME : Main routine for RESTORE utility
/*
/*  FUNCTION: Main routine does the following:
/*	      1. Verifies the DOS version
/*	      2. Validate the input command line
/*	      3. Calls dorestore to do the file restore.
/*
/*  NOTES:
/*
/*  ENTRY POINT: Main
/*	Linkage: main((argc,argv)
/*
/*  INPUT: (PARAMETERS)
/*	   argc - number of arguments
/*	   argv - array of pointers to arguments
/*
/*  EFFECTS: rtswitch is changed to reflect the switches passed.
/*
/********************** END OF SPECIFICATIONS *******************************/
void main(argc,argv)  /* wrw! */
    int argc;
    char *argv[];
{
   WORD retcode;
   union REGS inregs,outregs;						/*AN000*/
   DWORD prev_address;
   WORD  prev_action;

/**********************************/
/**	PRELOAD MESSAGES	 **/
/**********************************/
   sysloadmsg(&inregs,&outregs);				      /*;AN000;6 Preload messages */
   if (outregs.x.cflag & CARRY) 				      /*;AN000;6 If there was an error */
    {								      /*;AN000;6*/
     sysdispmsg(&outregs,&outregs);				      /*;AN000;6 Display the error message */
     exit_routine(UNEXPECTED);					      /*;AN000;6 and terminate */
    }								      /*;AN000;6*/


/*********************************************/
/* Parse the drive and file name entered     */
/*********************************************/
   parse_command_line						      /*;AN000;4*/
     (								      /*;AN000;4*/
      argc,							      /*;AN000;4*/
      argv							      /*;AN000;4*/
     ); 							      /*;AN000;4*/

/*********************************************/
/*     Make sure APPEND /X is not active     */
/*********************************************/
    check_appendX();						      /*;AN000;2 */


/*********************************************/
/*   Take control of Control Break Interrupt */
/*********************************************/
   retcode = DOSSETSIGHANDLER
    (
      (void far *)signal_handler_routine,	/* Signal handler address */
      (DWORD far *)&prev_address,		/* Address of previous handler */
      (unsigned far *)&prev_action,		/* Address of previous action */
      (unsigned)INSTALL_SIGNAL, 		/* Indicate request type */
      (unsigned)CTRL_C				/* Signal number */
    );

   retcode = DOSSETSIGHANDLER
    (
	(void far *)signal_handler_routine,	/* Signal handler address */
	(DWORD far *)&prev_address,		/* Address of previous handler */
	(unsigned far *)&prev_action,		/* Address of previous action */
	(unsigned)INSTALL_SIGNAL,		/* Indicate request type */
	(unsigned)CTRL_BREAK			/* Signal number */
    );

/*********************************/
/*   Take control of Hard Errors */
/*********************************/
    set_int24_vector(); 			/*;AN000; Set Critical error vector (int 24h) */


   /************************************************************/
   /* call dorestore (RTDO.C) to actually do the restoring     */
   /************************************************************/
   dorestore(srcd,destd,inpath,infname,infext,infspec,&td);

   /************************************************************/
   /* output a msg in the following situations: 	       */
   /*	       if flag indicates no file found		       */
   /************************************************************/
   if (set_reset_test_flag(&control_flag,FOUND,TEST)==FALSE)
    {
		/*warning! No files were found to restore*/
      display_it(NO_FILE_TO_RESTORE,STND_ERR_DEV,0,NO_RESPTYPE,(BYTE)UTIL_MSG);      /*;AN000;6*/
      exit_routine(NOFILES);
    }

   exit_routine(NORMAL);

} /* end of main*/
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\restore\rt1.h ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

/*  0 */
/*---------------------------------------------------------
/*-
/*- RESTORE Utility include file RT1.H
/*-
/*---------------------------------------------------------*/

/****************************************************************************/
/* This file contains equates for structure definitions used in RESTORE     */
/* utility.								    */
/****************************************************************************/

/***************************************************************************/
/*    dheadnew - structure of disk header in CONTROL.xxx,		   */
/*		 used for new format only				   */
/***************************************************************************/
struct disk_header_new
 {
   BYTE  dhlength;	   /* length, in byte , of disk header*/
   BYTE  id[8]; 	   /* identifies disk as a backup     */
   BYTE  sequence;	   /* backup diskette sequence num    */
			   /*	 (binary 1-255) 	      */
   BYTE  command[128];	   /* save area for command line      */
			   /*	  parameters.		      */
   BYTE  lastdisk;	   /* 0ffh if last targert 0 otherwise*/
 };


/***************************************************************************/
/*    dirblk - structure of directory blocks in CONTROL.xxx,		   */
/*		 used for new format only				   */
/***************************************************************************/
struct dir_block
 {
   BYTE dblength;	  /* length, in bytes, of dir block */
   BYTE path[63];
			  /* ascii path of this directory,  */
			  /* drive letter omitted	    */
   WORD  numentry;	  /* num of filenames currently in list*/
   DWORD nextdb;	  /* offset of next directory block  */
 };			  /* =0xffff if last dir block	     */


/***************************************************************************/
/*    fheadnew - structure of file header in CONTROL.xxx,		   */
/*		 used for new format only				   */
/***************************************************************************/

struct file_header_new
 {
   BYTE   fhlength;	/* Length, in bytes, of file header */
   BYTE   fname[12];	/* ASCII file name (from directory)*/
   BYTE   flag; 	/* bit 0=1 if last part of file */
			/* bit 1=1 if it is backed  up successfully */
			/* ;AN000;3 bit 2=1 if Extended Attributes are backed up (New for DOS4.00) */
   DWORD  flength;	/* Total length of the file (from directory) */
   WORD   fsequenc;	/* Sequence #, for files that span */
   DWORD  offset;	/* Offset in BACKUP.xxx where this segment begins */
   DWORD  partsize;	/* Length of part of file on current target */
   WORD   attrib;	/* File attribute (from directory) */
   WORD   ftime;	/* Time when file was last Revised (from directory)*/
   WORD   fdate;	/* Date when file was last Revised (from directory)*/
 };


/**************************************************************************/
/*    Fheadold - structure of file header, used for old format only.	  */
/*		 There are 128 bytes totally in file header of the old	  */
/*		 format backup disk.  Only the first 85 bytes contains	  */
/*		 meaningful information.				  */
/*		This is the structure attached to the beginning of every  */
/*		file backed up with DOS 2.0 through 3.2 inclusive.	  */
/**************************************************************************/
struct file_header_old
 {
   BYTE headflg;	 /* 0FFh is last sequence of file, 00h if not last*/
   BYTE disknum[2];	 /* file sequence number */
   BYTE fill1[2];	 /* not used */
   BYTE wherefrom [78];  /* asciiz path and name without drive letter*/
   unsigned  pathlen;	 /* length of previous field, not used in this program*/
   char garbage[50];	 /* Filler     */
 };




/***************************************************************************/
/*    dheadold - structure of disk informtion, used by old format only.    */
/*		 There are 128 bytes totally in disk header of the old	   */
/*		 format backup disk.  Only the first 7 bytes contains	   */
/*		 meaningful information.				   */
/*		This is the BACKUPID.@@@ file				   */
/***************************************************************************/

struct disk_header_old
 {
   BYTE  diskflag;	/* 0FFh if last disk, 00h if not last disk. */
			/* initialize it to 0FFh when BACKUP.@@@ is created,*/
			/* and zero it out when the disk is full */
   BYTE  disknum[2];	/* Sequence number of the disk.  Least significant*/
			/* byte first. */
   BYTE  diskyear[2];	/* Year, LSB first. */
   BYTE  diskday;	/* Month (1 byte) and day (1 byte). */
   BYTE  diskmonth;	/* Month (1 byte) and day (1 byte). */
 };


/***************************************************************************/
/*    timedate- structure of buffer to hold time and date data		  */
/***************************************************************************/
struct timedate {
   unsigned int  earlier_hour;
   unsigned int  earlier_minute;
   unsigned int  earlier_second;
   unsigned int  exact_hour;					/* MR001+ */
   unsigned int  exact_minute;					/* MR001+ */
   unsigned int  exact_second;					/* MR001+ */
   unsigned int  later_hour;
   unsigned int  later_minute;
   unsigned int  later_second;
   unsigned int  before_year;
   unsigned int  before_month;
   unsigned int  before_day;
   unsigned int  after_year;
   unsigned int  after_month;
   unsigned int  after_day;
   unsigned int  exact_year;					/* MR001+ */
   unsigned int  exact_month;					/* MR001+ */
   unsigned int  exact_day;					/* MR001+ */
};
/***************************************************************************/
/*    fsinfo - structure of buffer returned from dosqsinfo		 */
/***************************************************************************/
struct fsinfo { 		     /* file system information 	   */
  unsigned long file_system_id;      /* file system ID			4  */
  unsigned long sectors_per_alloc_unit;  /* sectors per allocation unit 4  */
  unsigned long number_of_alloc_unit;	 /* number of allocation unit	4  */
  unsigned long available_alloc_unit;	 /* available allocatuib unit	4  */
  unsigned	bytes_per_sector;    /* number of bytes per sectors	2  */
};				     /*     total byte size = 18	 */

#define FSINFO_BYTES  sizeof(struct fsinfo)  /* total # of bytes for BPB */

/***************************************************************************/
/*  internat - structure of buffer returned from get country information   */
/***************************************************************************/
struct internat {
unsigned       country_code;	/* country code 	       */
unsigned       code_page;	/* country code page	       */
unsigned       dtformat;	/* time date format	       */
				/* 0-usa 1-eur 2-jap	       */
BYTE  currency_sym,    /* Currency Symbol 5 bytes     */
		r1,
		r2,
		r3;
BYTE   r4;		/* null terminated	       */
BYTE   thous_sep,	/* Thousands separator 2 bytes */
		r5;		 /* null terminated		*/
BYTE   decimal_sep,	/* Decimal separator 2 bytes   */
		r6;		 /* null terminated		*/
BYTE   datesep, 	/* Date separator 2 bytes      */
		r7;		 /* null terminated		*/
BYTE   timesep, 	/* Time separator 2 bytes      */
		r8;		 /* null terminated		*/
BYTE   bit_field;	/* Bit values		       */
				 /*  Bit 0 = 0 if currency symbol first */
				 /*	   = 1 if currency symbol last	*/
			   /* Bit 1= 0 if No space after currency symbol*/
			   /*	   = 1 if space after currency symbol	*/
BYTE currency_cents;  /* Number of places after currency dec point*/
BYTE tformat;	      /* 1 if 24 hour time, 0 if 12 hour time	  */
unsigned long map_call;        /* Address of case mapping call (DWORD)	   */
			       /* in real mode compatibility API	   */
BYTE data_sep,	      /* Data list separator character		  */
	      r9;	       /* null terminated	      */
unsigned      ra[ 5 ];	       /* reserved		      */
} ;


/***************************************************************************/
/*    Finfo  - structure of file information, used for both old format and */
/*	       new format.  It contains the information which is common    */
/*	       between new and old.					   */
/***************************************************************************/
struct file_info
  {
    BYTE  fname[MAXFSPEC+1];	/* ASCII, filename and file extension.*/
    BYTE  path[MAXPATH+1];	/* ASCII, file path, always started with \ */
				/* and not end with \ */
    BYTE  fflag;		/* last disk in case of file expanded */
				/* bit 0 = 1 if last part of file		   */
				/* In old format file header, its 0ffh if last.  */
				/* The old format has to be converted into bit0=1.*/
    unsigned dnum;		/* sequence number of the file.  For file that span */
    unsigned attrib;		/* file attribute */
    unsigned ftime;		/* time when the file was created  */
    unsigned fdate;		/* date when the file was created  */
    unsigned long  partsize;	/* part size of the file   */
    unsigned long  offset;	/* offset of the file in backup.xxx  */
    BYTE curdir[MAXPATH];	/* current directory of the destination disk.*/
				/* The current directory usually is maintained to be*/
				/* the directory that reside the file to be restored*/
};

/****************************************************************************/
/*    dfinfo  - destination file information, if the destination file	    */
/*		is exist. Structure of file information, used for both old  */
/*		format and new format.	It contains the information which is*/
/*		common between new and old.				    */
/****************************************************************************/
struct dfile_info {
BYTE fname[12]; 	 /* ASCII, filename and file extension.*/
BYTE path[64];		 /* ASCII, file path, always started with \ and */
			 /* not end with \ */
BYTE fflag;		 /* last disk in case of file expanded */
			 /* bit 0 = 1 if last part of file		    */
			 /* In old format file header, its 0ffh if last.  */
			 /* The old format has to be converted into bit0=1.*/
unsigned short dnum;	 /* sequence number of the file.  For file that span */
unsigned attrib;	 /* file attribute */
unsigned ftime; 	 /* time when the file was created  */
unsigned fdate; 	 /* date when the file was created  */
BYTE *curdir;		 /* current directory of the destination disk.	  */
		   /* The current directory usually is maintained to be */
		   /* the directory that reside the file to be restored */
};

/***************************************************************************/
/*    dinfo  - structure of disk information, used for both old format and */
/*	       new format.  It contains the information which is common    */
/*	       between new and old.					   */
/***************************************************************************/
struct disk_info {
BYTE dflag;	/* last backup disk or not */
			/* Its 0ffh if last.  00h otherwise */
BYTE disknum;  /* sequence number of the file.	For file that span */
};
 struct subst_list							/*;AN000;6 */
  {									/*;AN000;6 */
    BYTE	sl_size1;      /* Size of List */			/*;AN000;6 */
    BYTE	zero1;	       /* Reserved */				/*;AN000;6 */
    char far   *value1;        /* Time, date, or ptr to data item*/	/*;AN000;6 */
    BYTE	one;	       /* n of %n */				/*;AN000;6 */
    BYTE	flags1;        /* Data Type flags */			/*;AN000;6 */
    BYTE	max_width1;    /* Maximum FIELD width */		/*;AN000;6 */
    BYTE	min_width1;    /* Minimum FIELD width */		/*;AN000;6 */
    BYTE	pad_char1;     /* Character for pad FIELD */		/*;AN000;6 */

    BYTE	sl_size2;      /* Size of List */			/*;AN000;6 */
    BYTE	zero2;	       /* Reserved */				/*;AN000;6 */
    char far   *value2;        /* Time; date; or ptr to data item*/	/*;AN000;6 */
    BYTE	two;	       /* n of %n */				/*;AN000;6 */
    BYTE	flags2;        /* Data Type flags */			/*;AN000;6 */
    BYTE	max_width2;    /* Maximum FIELD width */		/*;AN000;6 */
    BYTE	min_width2;    /* Minimum FIELD width */		/*;AN000;6 */
    BYTE	pad_char2;     /* Character for pad FIELD */		/*;AN000;6 */
  };									/*;AN000;6 */
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\restore\rt2.h ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

/******************************************************************************
*
*  Change Log:
*
*    Date    Who   #                      Description
*  --------  ---  ---  ------------------------------------------------------
*  07/02/90  EGH  C01  Added support for doing a directory of backed up
*                      diskettes via the /D option.
*
******************************************************************************/
/*  0 */
/*---------------------------------------------------------
/*-
/*- RESTORE Utility include file RT2.H
/*-
/*---------------------------------------------------------*/



/*------------------------------------*/
/*	 MESSAGE DEFINITIONS	      */
/*------------------------------------*/
#define INVPARM 10				/* Parse class */     /*;AN000;6*/

#define  INVALID_DOS_VER		1	/*;AN000;6*/
#define  SOURCE_TARGET_SAME		2	/*;AN000;6*/
#define  INVALID_NUM_PARM		3	/*;AN000;6*/
#define  PATH_NOT_FOUND 		5	/*;AN000;6*/
#define  INVALID_DRIVE			6	/*;AN000;6*/
#define  NO_FILE_TO_RESTORE		7	/*;AN000;6*/
#define  INSERT_SOURCE_DISK		8	/*;AN000;6*/
#define  INSERT_TARGET_DISK		9	/*;AN000;6*/
#define  PRESS_ANY_KEY		       10	/*;AN000;6*/
#define  DISK_OUT_OF_SEQUENCE	       11	/*;AN000;6*/
#define  LAST_FILE_NOT_RESTORED        12	/*;AN000;6*/
#define  FILES_WERE_BACKUP_ON	       13	/*;AN000;6*/
#define  SOURCE_NO_BACKUP_FILE	       14	/*;AN000;6*/
#define  INSUFFICIENT_MEMORY	       15	/*;AN000;6*/
#define  FILE_IS_READONLY	       16	/*;AN000;6*/
#define  FILE_SEQUENCE_ERROR	       17	/*;AN000;6*/
#define  FILE_CREATION_ERROR	       18	/*;AN000;6*/
#define  TARGET_IS_FULL 	       19	/*;AN000;6*/
#define  NOT_ABLE_TO_RESTORE_FILE      20	/*;AN000;6*/
#define  RESTORE_FILE_FROM_DRIVE       21	/*;AN000;6*/
#define  FILE_WAS_CHANGED	       22	/*;AN000;6*/
#define  DISKETTE_NUM		       23	/*;AN000;6*/

#define  INV_DATE		       27	/*;AN000;6*/
#define  INV_TIME		       28	/*;AN000;6*/
#define  NO_SOURCE		       29	/*;AN000;6*/
#define  NO_TARGET		       30	/*;AN000;6*/
#define  CRLF			       31	/*;AN000;6*/
#define  LISTING_FILE_ON_DRIVE         32                               /*C01*/

#define  FILE_TO_BE_RESTORED	       99	/*;AN000;6*/

#define  MSG_OPTIONS_FIRST         300	/* first line of options msg */
#define MSG_OPTIONS_LAST	   314

/*------------------------------------*/
/*-	   MESSAGE CLASSES	     -*/
/*------------------------------------*/
#define EXTENDED	1					      /*;AN000;6*/
#define PARSEERR	2					      /*;AN000;6*/
#define UTILMSG        -1					      /*;AN000;6*/

/* 0*/
/*----------------------------------*/
/*-    SUBROUTINE DECLARATIONS	    */
/*----------------------------------*/
void   main(int ,char *[0]);
void   set_input_switches(WORD,BYTE * *,WORD *,struct timedate *);
void   verify_input_switches(BYTE *,struct timedate   *);
int    set_reset_test_flag(BYTE *,BYTE ,int );
void   separate(BYTE *,BYTE *,BYTE *,BYTE *,BYTE *);
void   initbuf(DWORD *);
void   init_control_buf(unsigned long ,unsigned int   *);
void   usererror(WORD );
void   unexperror(WORD );
void   exit_routine(WORD );
void   pascal far signal_handler_routine(void );
extern void far pascal set_int24_vector(unsigned);	      /*;AN000;*/
void   com_msg(WORD );
int    checkdosver(void );
void   dorestore(BYTE ,BYTE ,BYTE *,BYTE *,BYTE *,BYTE *,struct timedate *);
void   check_bkdisk_old(struct disk_header_old *,    struct disk_info *,BYTE,unsigned int *);
void   check_bkdisk_new(struct disk_header_new far *,struct disk_info *,BYTE,unsigned int *,unsigned int *);
void   print_info(int ,int ,int);
WORD   pathmatch(BYTE *,BYTE *);
WORD   switchmatch(struct file_info *,BYTE,BYTE,struct timedate *);

int    check_flheader_old(struct file_info *,unsigned char *,unsigned int ,
			  unsigned int ,unsigned int ,unsigned long ,unsigned int ,unsigned char ,
			  unsigned char ,unsigned char *,unsigned char *,unsigned int  *);

int    readonly_or_changed(unsigned int ,unsigned char ,unsigned char	*, unsigned char *);
int    fspecmatch(char *,char *);
WORD   open_dest_file(struct file_info	 *,BYTE );
void   build_path_create_file(BYTE *,BYTE,BYTE,DWORD);		      /*;AC000;3*/
int    set_attributes_and_close(struct file_info *, BYTE);
int    dos_write_error(DWORD ,BYTE );
int    findfile_new(struct file_info *,WORD *,unsigned int *,BYTE *,BYTE *,WORD far * *,WORD far * *,unsigned int *,BYTE *);
int    findnew_new(struct file_info *,WORD *,WORD *,BYTE *,BYTE *, WORD far * *,WORD far * *,WORD *,BYTE *);

 void  search_src_disk_old(struct disk_info *,struct file_info *,struct disk_header_old *,
	     struct disk_header_new far *,struct file_header_new far *,
	     unsigned char,unsigned char,unsigned long,unsigned int *,unsigned char *,unsigned char *,
	     unsigned char *,unsigned char *,struct timedate *);

 void	 search_src_disk_new(struct disk_info *,struct file_info *,struct disk_header_old *,
	     struct disk_header_new far *,struct file_header_new far *,
	     unsigned char,unsigned char,unsigned int *,unsigned long,unsigned char *,unsigned char *,
	     unsigned char *,unsigned int *,struct timedate *);

int    findfirst_new(struct file_info *,WORD *,unsigned int *,BYTE *,BYTE *,WORD far**,WORD far**,unsigned int *,BYTE *);
int    findnext_new (struct file_info *,WORD *,unsigned int *,BYTE *,BYTE *,WORD far**,WORD far**,unsigned int *,BYTE *);

void   restore_a_file(struct file_info *,struct disk_info *,unsigned long,unsigned int *,
	struct file_header_new far *,struct disk_header_old *,struct disk_header_new far *,unsigned char,unsigned char,
	unsigned char *,unsigned char *,unsigned char *,unsigned int *,unsigned int *);

/*----------------------------------------
/*-  ADDED FOR DOS 4.00
/*----------------------------------------*/
int  cdecl	sprintf(char *,const char *, ...);
int  cdecl	printf(const char *,...);
void check_time(BYTE,BYTE,BYTE);				      /*;AN000;4*//*;AC002;*/
void check_date(WORD,BYTE,BYTE);				      /*;AN000;4*//*;AC002;*/
void parse_error(WORD,BYTE);					      /*;AN000;4*//*;AC002;*/
void parse_init(void);						      /*;AN000;4*/
void process_switch(unsigned);				      /*;AN000;4*//*;AC002;*/
void check_source_drive(char * []); 			      /*;AN000;4*/
void check_target_filespec(int,char * []);			      /*;AN000;4*/
void display_it(WORD,WORD,WORD,WORD,BYTE);			      /*;AN000;6*/
void parse_command_line(int, char * []);			      /*;AN000;4*/
void    check_options_help(int, char **);
void    display_options_exit(void);
void check_appendX(void);					      /*;AN000;2*/
void	read_in_first_dirblock(void);			     /* !wrw */
void	read_in_a_fileheader(void);			     /* !wrw */
void	read_in_next_dirblock(void);			     /* !wrw */
void	get_fileheader_length(void);				      /*;AN000;3*/
WORD	create_the_file(BYTE);				      /*;AN000;3*/
void	check_for_device_names(char * []);			      /*;AN000;p2591*/
WORD chek_DBCS(char *,WORD,char);				      /*;AN005;*/
void Get_DBCS_vector(void);					      /*;AN005;*/

extern	void	sysloadmsg(union REGS *, union REGS *);   /*_msgret *//*;AN000;6 */
extern	void	sysdispmsg(union REGS *, union REGS *);   /*_msgret *//*;AN000;6 */
extern	void	parse	  (union REGS *, union REGS *);   /* _parse *//*;AN000;4 */

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\restore\restpars.h ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

/******************************************************************************
*
*  Change Log:
*
*    Date    Who   #                      Description
*  --------  ---  ---  ------------------------------------------------------
*  06/29/90  EGH  C01  Added support for doing a directory of backed up
*                      diskettes via the /D option.
*
******************************************************************************/
/* 0 */
/*-----------------------------------------------------------------------*/
/*-									-*/
/*-	FILE:	 PARSE.H						-*/
/*-									-*/
/*-	PURPOSE: Include file for RESTORE.C and other RESTORE source	-*/
/*-		 files. Defines structures and DEFINES for the DOS PARSE-*/
/*-		 service routines					-*/
/*-									-*/
/*-----------------------------------------------------------------------*/


/**********************************************************/
/* STRUCTURE TO DEFINE ADDITIONAL COMMAND LINE DELIMITERS */
/**********************************************************/
struct p_parms								/*;AN000;4*/
	{								/*;AN000;4*/
	 WORD	parmsx_ptr;		/* POINTER TO PARMS STRUCTURE *//*;AN000;4*/
	 BYTE	p_num_extra;		/* 1 SAYS THAT A DELIMITER LIST FOLLOWS */  /*;AN000;4*/
	 BYTE	p_len_extra_delim;	/* NUMBER OF ADDITIONAL DELIMITERS */	/*;AN000;4*/
	 BYTE	p_extra_delim[2];	/* ADDITIONAL DELIMITERS */	/*;AN000;4*/
	};								/*;AN000;4*/

/***************************************************/
/* STRUCTURE TO DEFINE RESTORE SYNTAX REQUIREMENTS */
/***************************************************/
struct	p_parmsx								/*;AN000;4*/
	{									/*;AN000;4*/
	 BYTE  p_minpos;       /* THERE ARE 2 REQUIRED POSITIONAL PARMS*/	/*;AN000;4*/
	 BYTE  p_maxpos;       /* THERE ARE 2 REQUIRED POSITIONAL PARMS*/	/*;AN000;4*/
	 WORD  pos1_ptr;       /* POINTER TO SOURCE FILESPEC DEF AREA*/ 	/*;AN000;4*/
	 WORD  pos2_ptr;       /* POINTER TO TARGET DRIVE DEF AREA*/		/*;AN000;4*/
	 BYTE  num_sw;	       /* THERE ARE 8 SWITCHES (/S, /P, /M, /N, /E:, /L:, /B:, /A:)  */ /*;AN000;4*/
	 WORD  sw1_ptr;        /* POINTER TO SWITCH DEFINITION AREA*/		/*;AN000;4*/
	 WORD  sw2_ptr;        /* POINTER TO SWITCH DEFINITION AREA*/		/*;AN000;4*/
	 WORD  sw3_ptr;        /* POINTER TO SWITCH DEFINITION AREA*/		/*;AN000;4*/
	 WORD  sw4_ptr;        /* POINTER TO SWITCH DEFINITION AREA*/
	 WORD  num_keywords;   /* NUMBER OF KEYWORDS IN RESTORE SYNTAX*/	/*;AN000;4*/
	};									/*;AN000;4*/

/****************************************/
/* STRUCTURE TO DEFINE POSITIONAL PARMS */
/****************************************/
struct p_pos_blk							/*;AN000;4*/
	{								/*;AN000;4*/
	 WORD	match_flag;		/* Controls type matched */	/*;AN000;4*/
	 WORD	function_flag;		/* Function to be included  */	/*;AN000;4*/
	 WORD	result_buf;		/* Result buffer address */	/*;AN000;4*/
	 WORD	value_list;		/* Value list address */	/*;AN000;4*/
	 BYTE	nid;			/* # of keyword/SW synonyms (0) *//*;AN000;4*/
	};								/*;AN000;4*/

/********************************/
/* STRUCTURE TO DEFINE SWITCHES */
/********************************/
struct p_sw_blk 							/*;AN000;4*/
	{								/*;AN000;4*/
	 WORD	p_match_flag;		/* Controls type matched */	/*;AN000;4*/
	 WORD	p_function_flag;	/* Function should be taken */	/*;AN000;4*/
	 WORD	p_result_buf;		/* Result buffer address */	/*;AN000;4*/
	 WORD	p_value_list;		/* Value list address */	/*;AN000;4*/
	 BYTE	p_nid;			/* # of switches */		/*;AN000;4*/
	 BYTE	switch1[3];		/* Save area for switches */	/*;AN000;4*/
	 BYTE	switch2[3];		/* Save area for switches */	/*;AN000;4*/
	 BYTE	switch3[3];		/* Save area for switches */	/*;AN000;4*/
	 BYTE	switch4[3];		/* Save area for switches */	/*;AN000;4*/
         BYTE   switch5[3];             /* Save area for switches */    /*C01*/
	};								/*;AN000;4*/
struct p_sw4_blk					/* for /? */
	{
	 WORD	p_match_flag;		/* Controls type matched */
	 WORD	p_function_flag;	/* Function should be taken */
	 WORD	p_result_buf;		/* Result buffer address */
	 WORD	p_value_list;		/* Value list address */
	 BYTE	p_nid;				/* # of switches */
	 BYTE	switch4[3];			/* Save area for switches */
	};
/**/
/*---------------------------------------------------------------------------*/

/**************************/
/* RETURN BUFFER FOR TIME */
/**************************/
struct timebuff 							/*;AN000;4*/
	{								/*;AN000;4*/
	 BYTE	tb_type;       /* TYPE RETURNED*/			/*;AN000;4*/
	 BYTE	tb_item_tag;   /* SPACE FOR ITEM TAG*/			/*;AN000;4*/
	 WORD	tb_synonym_ptr; 					/*;AN000;4*/
	 BYTE	hours;							/*;AN000;4*/
	 BYTE	minutes;						/*;AN000;4*/
	 BYTE	seconds;						/*;AN000;4*/
	 BYTE	hundreds;						/*;AN000;4*/
	};								/*;AN000;4*/

/**************************/
/* RETURN BUFFER FOR DATE */
/**************************/
struct datebuff 							/*;AN000;4*/
	{								/*;AN000;4*/
	 BYTE	db_type;       /* TYPE RETURNED*/			/*;AN000;4*/
	 BYTE	db_item_tag;   /* SPACE FOR ITEM TAG*/			/*;AN000;4*/
	 WORD	db_synonym_ptr; 					/*;AN000;4*/
	 WORD	year;							/*;AN000;4*/
	 BYTE	month;							/*;AN000;4*/
	 BYTE	day;							/*;AN000;4*/
	};								/*;AN000;4*/


/*******************************************/
/* RETURN BUFFER FOR POSITIONAL PARAMETERS */
/*******************************************/
struct p_result_blk							/*;AN000;4*/
	{								/*;AN000;4*/
	 BYTE	p_type; 		/* Type returned */		/*;AN000;4*/
	 BYTE	p_item_tag;		/* Matched item tag */		/*;AN000;4*/
	 WORD	p_synonym_ptr;		/* pointer to Synonym list returned *//*;AN000;4*/
	 DWORD	p_string_ptr;		/* Pointer to string */ 	/*;AN000;4*/
	};				/*  or drive number in 1st byte /*;AN000;4*/

/****************************************/
/* RETURN BUFFER FOR SWITCH INFORMATION */
/****************************************/
struct	switchbuff							/*;AN000;4*/
	{								/*;AN000;4*/
	 BYTE	sw_type;	 /* TYPE RETURNED*/			/*;AN000;4*/
	 BYTE	sw_item_tag;	 /* Matched item tag */ 		/*;AN000;4*/
	 WORD	sw_synonym_ptr;  /* pointer to switch entered */	/*;AN000;4*/
	 DWORD	sw_string_ptr;	 /* Pointer to string */		/*;AN000;4*/
	};								/*;AN000;4*/
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\restore\rtdo1.c ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

/******************************************************************************
*
*  Change Log:
*
*    Date    Who   #                      Description
*  --------  ---  ---  ------------------------------------------------------
*  07/02/90  EGH  C01  Added support for doing a directory of backed up
*                      diskettes via the /D option.
*
******************************************************************************/

/*-----------------------------
/* SOURCE FILE NAME:  RTDO1.C
/*-----------------------------
/*  0 */

#include "rt.h"
#include "rt1.h"
#include "rt2.h"
#include "restpars.h"                                                 /*;AN000;4*/
#include "string.h"
#include "dos.h"                                                      /*;AN000;2*/
#include "comsub.h"             /* common subroutine def'n */
#include "doscalls.h"
#include "error.h"

struct disk_header_new russ_disk_header;			     /* !wrw */
unsigned control_file_handle = 0xffff;				     /* !wrw */

extern BYTE rtswitch2;                                                  /*C01*/
extern BYTE control_flag2;
extern BYTE far *control_buf_pointer;
extern unsigned control_selector;
extern struct FileFindBuf filefindbuf;
extern struct internat ctry;		  /* data area for get country info */
extern struct  subst_list sublist;				      /*;AN000;6 Message substitution list */
/*****************  START OF SPECIFICATION  ********************************
/*
/*  SUBROUTINE NAME :  check_bkdisk_new
/*
/*  DESCRIPTIVE NAME : For new format only, check to see whether the disk
/*		       is a backup disk, and whether the disk is in right
/*		       sequence.
/*
/*  FUNCTION: The routine does the following:
/*	      1. Find the file CONTROL.xxx.  If the file is not there
/*		 the disk is not a backup disk.
/*	      2. validate the extension of control.xxx
/*	      3. Check the sequence number of the disk to make sure
/*		 its in sequence.
/*	      4. Open the file CONTROL.xxx.
/*	      5. Read the file CONTROL.xxx in.
/*	      6. Fill dinfo with correct information.
/*	      7. Output a message to the screen to confirm that
/*		 the disk is going to be restored.
/*
/*  NOTES:  This subroutine also take care of situation that user
/*	    insert a old format diskette while the RESTORE started with
/*	    new format diskettes.
/*
/*	    When the inserted disk does not contain the file CONTROL.xxx,
/*	    a message "source file does not contains backup files" is
/*	    output to the user.  If the user wants to change diskette
/*	    and try again, next diskette will be read.
/*
/*	    When disk is out of sequence, a 'warning' is given to user,
/*	    if the user still wants to proceed the restoring by doing
/*	    nothing but hit a key, the same diskette will be read again.
/*	    In case of expanded file, another check for dnum of the expand
/*	    file will guarantee the disk in sequence.
/*
/*
/********************** END OF SPECIFICATIONS *******************************/
void check_bkdisk_new(dheadnew, dinfo, srcd, dnumwant,control_bufsize) /* wrw! */

struct disk_header_new far *dheadnew;
struct disk_info *dinfo;
BYTE srcd;
unsigned int *dnumwant;
unsigned int *control_bufsize;
{
     WORD dnumok = FALSE;
     WORD disknum;  /*disk number carried by the file name backup.xxx*/
     BYTE fname_to_be_opened[13];
     BYTE temp_array1[4];
     BYTE temp_array2[4];
     WORD read_count;
     WORD action;


     /*declaration for dosfindfirst */
     unsigned	 dirhandle = 0xffff;
     unsigned	 attribute = NOTV;
     unsigned	 search_cnt = 1;
     unsigned	 buf_len = sizeof(struct FileFindBuf);
     BYTE search_string[MAXPATHF+2];
     WORD retcode;
     /*end decleration for ffirst and fnext*/
   /*****************************/
   /*search for control.xxx	*/
   /*****************************/
   for (;;)
    {
       /*DosFindFirst, using the filename CONTROL.???*/
	 search_string[0] = srcd;
	 search_string[1] = ':';
	 search_string[2] = NULLC;
	 strcat(search_string, "CONTROL.???");
	 dirhandle = 0xffff;
	 search_cnt = 1;

       retcode =			    /* Find the 1st filename that */
	 DOSFINDFIRST(			    /*	 matches specified fspec*/
	    (char far *)search_string,	    /* File path name*/
	    (unsigned far *)&dirhandle,     /* Directory search handle */
	    attribute,			    /* Search attribute */
	    (struct FileFindBuf far *)&filefindbuf,
	    buf_len,			    /* Result buffer length */
	    (unsigned far *)&search_cnt,    /* Number of entries to find */
	    (DWORD) 0
	 );

       if (retcode != NOERROR)
	 { display_it(SOURCE_NO_BACKUP_FILE,STND_ERR_DEV,0,NO_RESPTYPE,(BYTE)UTIL_MSG);/*;AN000;6*/
	   usererror(NOBACKUPFILE);
	 }
	else
	 {
	   /*if the directory found is a subdirectory, find next one*/
	   while((retcode = filefindbuf.attributes & SUBDIR) == SUBDIR)
	    {
	      search_cnt = 1;
	      retcode = DOSFINDNEXT(dirhandle,
		     (struct FileFindBuf far *)&filefindbuf,
		     buf_len,
		     (unsigned far *)&search_cnt);
	      if (retcode != 0)
	       { display_it(SOURCE_NO_BACKUP_FILE,STND_ERR_DEV,0,NO_RESPTYPE,(BYTE)UTIL_MSG);/*;AN000;6*/
		 usererror(NOBACKUPFILE);
	       }
	    } /*end while */
	 }   /*end of file control.xxx not found*/

       retcode = DOSFINDCLOSE(dirhandle);

   /********************************************************************/
   /* validate the file extension of control.xxx to make sure they are */
   /* three numeric characters					       */
   /********************************************************************/
      if ((filefindbuf.file_name[7] != '.') || (filefindbuf.file_name[8] < '0')  ||
	  (filefindbuf.file_name[8] >  '9') || (filefindbuf.file_name[9] < '0')  ||
	  (filefindbuf.file_name[9] >  '9') || (filefindbuf.file_name[10] < '0') ||
	  (filefindbuf.file_name[10] > '9') || (filefindbuf.file_name[11] != NULLC) )
       { display_it(SOURCE_NO_BACKUP_FILE,STND_ERR_DEV,0,NO_RESPTYPE,(BYTE)UTIL_MSG);/*;AN000;6*/
	 usererror(NOBACKUPFILE);
       }

   /********************************************************************/
   /* check the disk sequence number of the disk		       */
   /********************************************************************/
      if (dnumok == TRUE)
       {
	 if (disknum != *dnumwant)
	  set_reset_test_flag(&control_flag2,OUTOF_SEQ,SET);
	 dnumok = FALSE;
       }
      else
       {
	 disknum = (filefindbuf.file_name[8]-'0')*100 +
		   (filefindbuf.file_name[9]-'0')*10
		   +filefindbuf.file_name[10]-'0';
	 if (disknum != *dnumwant)
	  {
	    display_it(DISK_OUT_OF_SEQUENCE,STND_ERR_DEV,0,NO_RESPTYPE,(BYTE)UTIL_MSG);/*;AN000;6*/
	    display_it(PRESS_ANY_KEY,STND_ERR_DEV,0,ANY_KEY_RESPTYPE,(BYTE)UTIL_MSG); /*;AN000;6*/

	    /* When disk is out of sequence, a 'warning' is given to user. */
	    /* If the user still wants to proceed the restoring by doing   */
	    /* nothing but hit a key, the same diskette will be read again.*/
	    dnumok = TRUE;

	    continue;
	  } /*endif*/
       } /*endif of dnumok = FALSE*/

   /********************************************************************/
   /* open control.xxx						       */
   /********************************************************************/
      fname_to_be_opened[0] = srcd;
      fname_to_be_opened[1] = ':';
      fname_to_be_opened[2] = NULLC;
      strcat(fname_to_be_opened,filefindbuf.file_name);

      retcode =
       DOSOPEN
	( (char far *)&fname_to_be_opened[0],
	  (unsigned far *)&control_file_handle, 	 /* !wrw */
	  (unsigned far *)&action,
	  (DWORD)0,
	  0,
	  0x01,
	  0x00c0,
	  (DWORD)0
	);

      if (retcode != NOERROR)
       { display_it(SOURCE_NO_BACKUP_FILE,STND_ERR_DEV,0,NO_RESPTYPE,(BYTE)UTIL_MSG);/*;AN000;6*/
	 usererror(NOBACKUPFILE);
       }

   /********************************************************************/
   /* READ DISK_HEADER INTO STATIC DISKHEADER STRUCTURE    wrw	       */
   /********************************************************************/

      retcode = _dos_read(control_file_handle, (void far *)&russ_disk_header,
			  (unsigned short)DHEADLEN,
			  (unsigned *)&read_count);

      if (retcode != NOERROR || (DWORD)read_count != (DWORD)DHEADLEN)	  /* !wrw */
       { display_it(SOURCE_NO_BACKUP_FILE,STND_ERR_DEV,0,NO_RESPTYPE,(BYTE)UTIL_MSG);/*;AN000;6*/
	 unexperror(NOBACKUPFILE);
       }

   /********************************************************************/
   /* get and store dheadnew information into dinfo		       */
   /********************************************************************/
      dheadnew = (struct disk_header_new far *)&russ_disk_header;    /* !wrw */

      dinfo->disknum = dheadnew->sequence;
      dinfo->dflag = dheadnew->lastdisk;

      /* At this point, the diskette has passed all the checking, and */
      /* should be a ok diskette.   break out of the loop.*/
      break;

    } /*end of "for (;;)" loop */

   /********************************************************************/
   /* output confirm msg "restore file from drive d:"                  */
   /********************************************************************/
   temp_array1[0] = srcd;
   temp_array1[1] = NULLC;

   sublist.value1 = (char far *)temp_array1;			  /*;AN000;6 */
   sublist.flags1 = LEFT_ALIGN + CHAR_FIELD_ASCIIZ;		  /*;AN000;6 */
   sublist.max_width1 = (BYTE)strlen(temp_array1);		  /*;AN000;6 */
   sublist.min_width1 = sublist.max_width1;			  /*;AN000;6 */

   if (set_reset_test_flag(&rtswitch2,DIR,TEST) == TRUE)                           /*C01*/
       display_it(LISTING_FILE_ON_DRIVE,STND_OUT_DEV,1,NO_RESPTYPE,(BYTE)UTIL_MSG);/*C01*/
   else                                                                            /*C01*/
       display_it(RESTORE_FILE_FROM_DRIVE,STND_OUT_DEV,1,NO_RESPTYPE,(BYTE)UTIL_MSG);/*;AN000;6*/

   /********************************************************************/
   /* if the source disk is removable, output diskette number also     */
   /********************************************************************/
   if (set_reset_test_flag(&control_flag2,SRC_HDISK,TEST) == FALSE)
    {
     temp_array2[0] = (dinfo->disknum / 10) + '0';
     temp_array2[1] = (dinfo->disknum % 10) + '0';
     temp_array2[2] = NULLC;

     sublist.value1 = (char far *)temp_array2;			      /*;AN000;6*/
     sublist.flags1 = LEFT_ALIGN + CHAR_FIELD_ASCIIZ;		      /*;AN000;6*/
     sublist.max_width1 = (BYTE)strlen(temp_array2);		      /*;AN000;6*/
     sublist.min_width1 = sublist.max_width1;			      /*;AN000;6*/

     display_it(DISKETTE_NUM,STND_OUT_DEV,1,NO_RESPTYPE,(BYTE)UTIL_MSG);/*;AN000;6*/
    }

   *dnumwant = dinfo->disknum + 1;

   return;							      /*;AN000;*/
} /*end of subroutine */

/*****************  START OF SPECIFICATION  ********************************
/*
/*  SUBROUTINE NAME :  check_bkdisk_old
/*
/*  DESCRIPTIVE NAME : For old format only, check to see whether the disk
/*		       is a backup disk, and whether the disk is in right
/*		       sequence.
/*
/*  FUNCTION: The routine does the following:
/*	      1. Open the file BACKUPID.@@@.  If the file is not there,
/*		 the disk is not a backup disk.
/*	      3. Check the sequence number of the disk to make sure
/*		 its in sequence.
/*	      4. Fill dinfo with correct information.
/*	      5. Output a message to the screen to confirm that
/*		 the disk is going to be restored.
/*
/*  NOTES:  This subroutine also take care of situation that user
/*	    insert a new format diskette while the RESTORE started with
/*	    old format diskettes.
/*
/*	    When the inserted disk does not contain the file BACKUP.@@@,
/*	    a message "source file does not contains backup files" is
/*	    output to the user.  If the user wants to change diskette
/*	    and try again, next diskette will be read.
/*
/*	    When disk is out of sequence, a 'warning' is given to user,
/*	    if the user still wants to proceed the restoring by doing
/*	    nothing but hit a key, the same diskette will be read again.
/*	    In case of expanded file, another check for dnum of the expand
/*	    file will guarantee the disk in sequence.
/*
/*
/********************** END OF SPECIFICATIONS *******************************/
void check_bkdisk_old(dheadold, dinfo, srcd, dnumwant) /* wrw! */
     struct disk_header_old *dheadold;
     struct disk_info *dinfo;
     BYTE srcd;
     unsigned int *dnumwant;
{
   WORD retcode;
   WORD action;

     int dnumok = FALSE;
     unsigned file_pointer;
     char fname_to_be_opened[13];
     int numread;
     int dyear;
     char temp_array1[4];
     char temp_array2[4];

   /********************************************************************/
   /* open and read backupid.@@@.  Store information in backupid.@@@   */
   /* into dinfo						       */
   /********************************************************************/

   for (;;)
    {
      fname_to_be_opened[0] = srcd;
      fname_to_be_opened[1] = ':';
      fname_to_be_opened[2] = NULLC;
      strcat(fname_to_be_opened,BACKUPID);
      retcode =
       DOSOPEN(
	       (char far *)&fname_to_be_opened[0],(unsigned far *)&file_pointer,
	       (unsigned far *)&action,(DWORD)0,0,0x01,0x00c0,(DWORD)0
	      );

      if (retcode != NOERROR)
       { display_it(SOURCE_NO_BACKUP_FILE,STND_ERR_DEV,0,NO_RESPTYPE,(BYTE)UTIL_MSG);/*;AN000;6*/
	 usererror(NOBACKUPFILE);
       }

      /*read BKIDLENG (7) bytes from the file and store into dheadold*/
      retcode = _dos_read(file_pointer, (void far *)dheadold, BKIDLENG,
			  (unsigned *)&numread);

      /*if return code of read indicate less than 11 bytes been read*/
      if (retcode != 0 || numread < BKIDLENG) {
	 /*unexperror "source file does not contains backup files"*/
	 display_it(SOURCE_NO_BACKUP_FILE,STND_ERR_DEV,0,NO_RESPTYPE,(BYTE)UTIL_MSG);/*;AN000;6*/
	 unexperror(NOBACKUPFILE);
      } /*endif  */
      dinfo->disknum = dheadold->disknum[0] + dheadold->disknum[1] * 10;
      dyear = dheadold->diskyear[0] + dheadold->diskyear[1]*256;
      dinfo->dflag = dheadold->diskflag;

      /*close the file*/
      DOSCLOSE(file_pointer);

   /********************************************************************/
   /* check disk sequence number				       */
   /********************************************************************/
      if (dnumok == TRUE) {
	 if ((WORD)dinfo->disknum != *dnumwant) {
	    set_reset_test_flag(&control_flag2,OUTOF_SEQ,SET);
	 }
	 dnumok = FALSE;
      }
      else {
	 if ((WORD)dinfo->disknum != *dnumwant) {
	    /*When disk is out of sequence, a 'warning' is given to user,
	    if the user still wants to proceed the restoring by doing
	    nothing but hit a key, the same diskette will be read again.*/
	    display_it(DISK_OUT_OF_SEQUENCE,STND_ERR_DEV,0,NO_RESPTYPE,(BYTE)UTIL_MSG); /*;AN000;6*/
	    display_it(PRESS_ANY_KEY,STND_ERR_DEV,0,ANY_KEY_RESPTYPE,(BYTE)UTIL_MSG); /*;AN000;6*/
	    dnumok = TRUE;
	    continue;
	 } /*endif*/
      } /*endif*/

      /*at this point, the diskette has passed all the checking, and
      should be a ok diskette.	 break out of the loop.*/
      break;
   } /*end of loop*/

   /********************************************************************/
   /* output a confirm msg "restoring files from drive d:"             */
   /********************************************************************/
   temp_array1[0] = srcd;
   temp_array1[1] = NULLC;
   sublist.value1 = (char far *)temp_array1;                          /*;AN000;6 */
   sublist.flags1 = LEFT_ALIGN + CHAR_FIELD_ASCIIZ;                   /*;AN000;6 */
   sublist.max_width1 = (BYTE)strlen(temp_array1);                    /*;AN000;6 */
   sublist.min_width1 = sublist.max_width1;                           /*;AN000;6 */
   if (set_reset_test_flag(&rtswitch2,DIR,TEST) == TRUE)                           /*C01*/
       display_it(LISTING_FILE_ON_DRIVE,STND_OUT_DEV,1,NO_RESPTYPE,(BYTE)UTIL_MSG);/*C01*/
   else                                                                            /*C01*/
       display_it(RESTORE_FILE_FROM_DRIVE,STND_OUT_DEV,1,NO_RESPTYPE,(BYTE)UTIL_MSG);  /*;AN000;6*/

   /********************************************************************/
   /* if the source disk is removable, output msg "diskette xx"        */
   /********************************************************************/
   if (set_reset_test_flag(&control_flag2,SRC_HDISK,TEST) == FALSE)
   {
       temp_array2[0] = (dinfo->disknum / 10) + '0';
       temp_array2[1] = (dinfo->disknum % 10) + '0';
       temp_array2[2] = NULLC;

       sublist.value1 = (char far *)temp_array2;		      /*;AN000;6 */
       sublist.flags1 = LEFT_ALIGN + CHAR_FIELD_ASCIIZ; 	      /*;AN000;6 */
       sublist.max_width1 = (BYTE)strlen(temp_array2);		      /*;AN000;6 */
       sublist.min_width1 = sublist.max_width1; 		      /*;AN000;6 */
       display_it(DISKETTE_NUM,STND_OUT_DEV,1,NO_RESPTYPE,(BYTE)UTIL_MSG);  /*;AN000;6*/
   }

   *dnumwant = dinfo->disknum + 1;
   return;							      /*;AN000;*/
} /*end of subroutine */
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\restore\rtnew1.c ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */


/*------------------------------
/* SOURCE FILE NAME: RTNEW1.C
/*------------------------------
/*  0 */
#include "rt.h"
#include "rt1.h"
#include "rt2.h"
#include "restpars.h"                                                 /*;AN000;4*/
#include "string.h"
#include "dos.h"                                                      /*;AN000;2*/
#include "comsub.h"             /* common subroutine def'n */
#include "doscalls.h"
#include "error.h"


#define LAST_DIRBLOCK	0xffffffff			     /* !wrw */
BYTE	got_first_fh;					     /* !wrw */

struct dir_block russ_dir_block;	/* Current directory block   /* !wrw */
extern BYTE backup_level;      /* Tells which DOS version made the BACKUP*/  /*;AN000;3*/

struct file_header_new russ_file_header;/* Current file_header	     /* !wrw */
unsigned short tot_num_fh_read_in;	/* Num FH read in so far     /* !wrw */
unsigned short num_fh_in_buffer;	/* Num FH currently in buff  /* !wrw */
unsigned short num_fh_in_buf_processed; /* Number of FH in the buffer that have been processed	  /* !wrw */
struct file_header_new far *fheadnew;	/* Global pointer to FH      /* !wrw */


BYTE fileheader_length; 	/*;AN000;3 Length of a file header */

extern BYTE rtswitch;
extern BYTE control_flag;
extern BYTE control_flag2;
extern char far *control_buf_pointer;
extern unsigned control_file_handle;
extern WORD control_bufsize;				     /* !wrw */


/*   0 */
/*****************  START OF SPECIFICATION  ********************************
/*
/*  SUBROUTINE NAME :  findfile_new
/*
/*  DESCRIPTIVE NAME : Find a file with matching file name from
/*		       the file CONTROL.xxx.
/*
/*  FUNCTION: For new format only, search through all directory blocks
/*	      and all file headers until a file header with matched file
/*	      path, name and extension is found.   also store information
/*	      into  fhead and finfo if file is found which match the
/*	      filename and file extension specified in the command line.
/*
/*  NOTES: Path name for comparison has to started with \ and end with \.
/*
/********************** END OF SPECIFICATIONS *******************************/
int findfile_new( finfo, found, done_searching, inpath,
	     infspec, dirptr, flptr, numentry, dir_path)

struct file_info  *finfo;
WORD	 *found;
unsigned int *done_searching;
BYTE	 *inpath;
BYTE	 *infspec;
WORD	 far **dirptr;
WORD	 far **flptr;
unsigned int *numentry;
BYTE	 *dir_path;
{
	struct dir_block far *dirblk;
	char temp_path[MAXPATH];
	char temp_fname[MAXFSPEC];
	WORD i;
	WORD rc;


	dirblk = (struct dir_block far *)&russ_dir_block;		     /* !wrw */
	fheadnew = (struct file_header_new far *)&russ_file_header;	     /* !wrw */

	/******************************************************************/
	/* search the directory block for the one that has the right path  */
	/*******************************************************************/
	while ((*done_searching == FALSE) && (*found == FALSE))
	 {
	   temp_path[0] = '\\';
	   for (i = 0; i <= (MAXPATH-2); ++i)
	      temp_path[i+1] = dirblk->path[i];

	   temp_path[MAXPATH-1] = NULLC;

	     /*****************************/
	     /* While path does not match */
	     /*****************************/

	   while (pathmatch(inpath,temp_path) == FALSE)
	    {
	      if (dirblk->nextdb == LAST_DIRBLOCK)			     /* !wrw */
	       {
		 *found = FALSE;
		 *done_searching = TRUE;
		 break;
	       }
	      else
	       {
		 read_in_next_dirblock();				     /* !wrw */
		 temp_path[0] = '\\';
		 for (i = 0; i <= (MAXPATH-2); ++i)
		     temp_path[i+1] = dirblk->path[i];
		 temp_path[MAXPATH-1] = NULLC;
		 continue;
	       }
	      /*end of if not last dirblk*/

	    } /*end while loop, searching for the right path in directory block*/
	   /*if done searching, break out of the big loop to exit*/

	   if (*done_searching == TRUE)
	      break;

	   /***************************************************/
	   /* directory block with correct path has been found*/
	   /***************************************************/

	   /*get the total number of file headers in the directory block*/
	   *numentry = (unsigned int)russ_dir_block.numentry;		     /* !wrw */

	   if (got_first_fh == FALSE)					     /* !wrw */
	    read_in_a_fileheader();		/*####			     /* !wrw */

	   /****************************************************/
	   /* search all the file headers under this directory */
	   /* block to find the one with right file name       */
	   /****************************************************/
	   for (;;)
	    {

	      if ((rc = fheadnew->flag & COMPLETE_BIT) != COMPLETE_BIT)
	       {
		if (*numentry)
		 --(*numentry);
		 if (*numentry==0)
		  {
		    if (dirblk->nextdb == LAST_DIRBLOCK)		     /* !wrw */
		     {
		       *found = FALSE;
		       *done_searching = TRUE;
		       break;  /*exit FOR loop, go back to WHILE loop*/
		     }
		    else
		     {
		       read_in_next_dirblock(); 			     /* !wrw */
		       break;  /*exit FOR loop, go back to WHILE loop*/
		     }
		  }
		 else
		  {
		   read_in_a_fileheader();				     /* !wrw */
		   continue;
		  }
	       }

	      for (i = 0; i <= (MAXFSPEC-2); ++i)
		temp_fname[i] = fheadnew->fname[i];
	      temp_fname[MAXFSPEC-1] = NULLC;

	      if (fspecmatch(infspec,temp_fname)==TRUE)
	       {
		 *found = TRUE;
		 break;
	       }
	      else	 /* This file header is not the right one*/
	       {
		if (*numentry)
		  --(*numentry);
		 if (*numentry == 0)
		  {
		    if (dirblk->nextdb == LAST_DIRBLOCK)
		     {
		       *found = FALSE;
		       *done_searching = TRUE;
		       break;  /*exit FOR loop, go back to WHILE loop*/
		     }
		    else
		     {
		       read_in_next_dirblock(); 		     /* !wrw */
		       break;
		     } /*end of if not last dir block */
		  }
		 else	  /*point to the next file header and loop again*/
		   read_in_a_fileheader();				     /* !wrw */

	       }

	    }	/* end for (;;) loop to search all file headers in a directory block */

	 } /*end of while loop*/



	/*******************************************************************/
	/* if a file is found, save the information in the disk header and */
	/* file header							   */
	/*******************************************************************/
	if (*found == TRUE)
	 {
	      /* Store information from dir blk into finfo */
	      if (strcmp(dir_path,"no path from fnext") == 0)
		  strcpy(finfo->path,temp_path);
	      else
	       {
		 finfo->path[0] = '\\';
		 finfo->path[1] = NULLC;
		 strcat(finfo->path,dir_path);
	       }

	      /*store information from file header into finfo*/
	      for (i = 0; i <= (MAXFSPEC-2); ++i)
		  finfo->fname[i] = fheadnew->fname[i];
	      finfo->fname[MAXFSPEC-1] = NULLC;
	      finfo->fflag = fheadnew->flag;
	      finfo->dnum  = fheadnew->fsequenc;
	      finfo->ftime = fheadnew->ftime;
	      finfo->fdate = fheadnew->fdate;
	      finfo->attrib = fheadnew->attrib;
	      finfo->partsize = fheadnew->partsize;
	      finfo->offset = fheadnew->offset;

	      if (*numentry)
	       --(*numentry);

	      if (*numentry == 0)
	       {
		  if (dirblk->nextdb == LAST_DIRBLOCK)
		    *done_searching = TRUE;
		else
		 {
		  read_in_next_dirblock();				     /* !wrw */
		  read_in_a_fileheader();				     /* !wrw */
		  *numentry = dirblk->numentry;
		 }
	       }
	      else
		read_in_a_fileheader(); 				     /* !wrw */

	      *dirptr=(WORD far *)dirblk;
	      *flptr=(WORD far *)fheadnew;

	      return (TRUE);
	  } /*end of if found */
	else
	  return (FALSE);

	return(TRUE);		      /*;AN000;*/
} /*end of subroutine */

/*   0 */
/*****************  START OF SPECIFICATION  ********************************
/*
/*  SUBROUTINE NAME :  findnext_new
/*
/*  DESCRIPTIVE NAME : For new format only, continue at the point
/*		       findfirst_new or previous findnext_new exit, search
/*		       the entire file of CONTROL.xxx to find matching file
/*		       names.
/*
/*  FUNCTION: Continue at where findfirst_new or previous findnext_new
/*	      stop, search the current directory blocks for the matching
/*	      file path, if fail to find a file, then call findfile to
/*	      search all directory block.
/*
/*
/********************** END OF SPECIFICATIONS *******************************/
int findnext_new(finfo, found, done_searching, in_path,
	     infspec, dirptr, flptr, numentry, dir_path)

struct file_info *finfo;
WORD *found;
unsigned int  *done_searching;
BYTE *in_path;
BYTE *infspec;
WORD far **dirptr;
WORD far **flptr;
unsigned int *numentry;
BYTE *dir_path;
{
	struct dir_block far *dirblk;
	WORD retcode;
	WORD i;
	BYTE temp_fname[MAXFSPEC];
	WORD rc;
	char temp_path[MAXPATH];

	dirblk=(struct dir_block far *)*dirptr;
	fheadnew=(struct file_header_new far *)*flptr;
	strcpy(dir_path,"no path from fnext");

	temp_path[0] = '\\';
	for (i = 0; i <= (MAXPATH-2); ++i)
	    temp_path[i+1] = dirblk->path[i];

	temp_path[MAXPATH-1] = NULLC;

	/****************************************/
	/* Should we process this subdirectory ?*/
	/****************************************/
	if (pathmatch(in_path,temp_path) == TRUE)
	 {

	   /*************************************************/
	   /*complete the scanning current db to find a file*/
	   /*************************************************/
	   for (;;)
	   {
	      if ((rc = fheadnew->flag & COMPLETE_BIT) != COMPLETE_BIT)
	       {
		 if (*numentry)
		   --(*numentry);

		 if (*numentry==0)
		  {
		    if (dirblk->nextdb == LAST_DIRBLOCK)
		     {
		       *found = FALSE;
		       *done_searching = TRUE;
		       break;
		     }
		    else
		     {
		       read_in_next_dirblock(); 		     /* !wrw */
		       break;						     /* !wrw */
		     }
		  }							     /* !wrw */
		 else  /* There are more files from current dirblock. Get them */
		  {							     /* !wrw */
		    read_in_a_fileheader();				     /* !wrw */
		    continue;						     /* !wrw */
		  }
	       }
	      /*endif*/

	      /* If this file header is the right one)*/
	      for (i = 0; i <= (MAXFSPEC-2); ++i)
		  temp_fname[i] = fheadnew->fname[i];

	      temp_fname[MAXFSPEC-1] = NULLC;

	      if (fspecmatch(infspec,temp_fname)==TRUE)
	       {
		 *found = TRUE;
		 for (i = 0; i <= (MAXPATH-2); ++i)
		   dir_path[i] = dirblk->path[i];
		 dir_path[MAXPATH - 2] = NULLC;
		 break;
	       }
	      else	 /*if this file header is not the right one*/
	       {
		 if (*numentry)
		   --(*numentry);
		 if (*numentry == 0)	  /* If no more files in this directory block */
		  {
		    if (dirblk->nextdb == LAST_DIRBLOCK)    /* If this is the last dirblock on current source disk */
		     {
		       *found = FALSE;
		       *done_searching = TRUE;
		       break;
		     }
		    else
		     {
		       read_in_next_dirblock(); 			/* !wrw */
		       break;						/* !wrw */
		     } /*end of if not last dir block */		/* !wrw */
		  }							/* !wrw */
		 else							/* !wrw */
		   read_in_a_fileheader();				/* !wrw */
	       }
	   } /*end loop searching all file headers in dir block */
	 } /*end of if the path match inpath*/

	else
	  *found = FALSE;


	/********************************************************************/
	/* If fail to find a file in the current directory block, call	    */
	/* filefind_new to find next.					    */
	/* If already found or done searching, call findfile_new to store   */
	/* information in finfo and dinfo				    */
	/********************************************************************/

	 *dirptr=(WORD far *)dirblk;
	 *flptr=(WORD far *)fheadnew;

	retcode = findfile_new(finfo,found,done_searching,in_path,infspec,dirptr,
			       flptr,numentry, dir_path);

     return(retcode);
}

/*   0 */
/*****************  START OF SPECIFICATION  ********************************
/*
/*  SUBROUTINE NAME :  findfirst_new
/*
/*  DESCRIPTIVE NAME : For new format only, search the entire file
/*		       of CONTROL.xxx to find matching file names.
/*
/*  FUNCTION: search directory blocks one after the other to find the
/*	      directory block with the matching file path, then search
/*	      the entire directory block to find the file with matching
/*	      file name.
/*
/*
/********************** END OF SPECIFICATIONS *******************************/
int findfirst_new(finfo,found,done_searching,in_path,infspec,dirptr,flptr,numentry,dir_path)

struct file_info *finfo;
WORD	 *found;
unsigned int *done_searching;
BYTE	 *in_path;
BYTE	 *infspec;
WORD	 far **dirptr;
WORD	 far **flptr;
unsigned int *numentry;
BYTE	 *dir_path;
{
	struct dir_block far *dirblk;
	WORD retcode;

	strcpy(dir_path,"no path from fnext");
	dirblk = (struct dir_block far *)&russ_dir_block;		/* !wrw */
	read_in_first_dirblock();					/* !wrw */

	if (got_first_fh == FALSE)				     /* !wrw */
	  read_in_a_fileheader();	     /*###		     /* !wrw */

	*found = FALSE;
	*done_searching = FALSE;
	*dirptr=(WORD far *)dirblk;
	*flptr=(WORD far *)fheadnew;

	retcode = findfile_new(finfo,found,done_searching,in_path,
		  infspec,dirptr,flptr,numentry,dir_path);

	return(retcode);
}	/*end of findfirst_new */




/*   0 */
/*********************************************************************/
/*
/*	SUBROUTINE NAME: read_in_next_dirblock
/*
/*	FUNCTION:
/*		Reads in a directory block
/*		Figures out if it was put there by DOS 3.3 or 4.0
/*********************************************************************/
void read_in_next_dirblock()					     /* !wrw */
{

	WORD retcode;		/* return code save area */	     /* !wrw */
	WORD read_count;	/* num bytes read in	 */	     /* !wrw */
	DWORD file_pointer;	/* current file pointer, returned by lseek  !wrw */

	retcode =						     /* !wrw */
	  DOSCHGFILEPTR 					     /* !wrw */
	   (							     /* !wrw */
	    control_file_handle,	/* Handle */		     /* !wrw */
	    russ_dir_block.nextdb,	/* New location */	     /* !wrw */
	    (BYTE)0,			/* MOVE METHOD */	     /* !wrw */
	    (DWORD far *)&file_pointer				     /* !wrw */
	   );							     /* !wrw */

	retcode =   _dos_read(control_file_handle,				     /* !wrw */
	    (void far *)&russ_dir_block,			     /* !wrw */
	    (unsigned short)DIRBLKLEN,				     /* !wrw */
	    (unsigned *)&read_count     			     /* !wrw */
	   );							     /* !wrw */
								     /* !wrw */
	if (retcode != NOERROR) 				     /* !wrw */
	 {							     /* !wrw */
	  display_it(SOURCE_NO_BACKUP_FILE,STND_ERR_DEV,0,NO_RESPTYPE,(BYTE)UTIL_MSG); /*;AN000;6*/
	  unexperror(NOBACKUPFILE);				     /* !wrw */
	 }

	got_first_fh = FALSE;					     /* !wrw */
	get_fileheader_length();	/*;AN000;3*/

	return; 						     /* !wrw */
}								     /* !wrw */


/*********************************************************************/
/*
/*	SUBROUTINE NAME: read_in_first_dirblock
/*
/*	FUNCTION:
/*		Reads in the first directory block
/*		Figures out if it was put there by DOS 3.3 or 4.0
/*********************************************************************/

void read_in_first_dirblock()					     /* !wrw */
{

WORD retcode;		/* return code save area */	     /* !wrw */
WORD read_count;	/* num bytes read in	 */	     /* !wrw */

   /********************************************************************/
   /* READ DIRECTORY_BLOCK INTO STATIC DATA AREA		       */
   /********************************************************************/

      retcode = _dos_read(					     /* !wrw */
		  control_file_handle,				     /* !wrw */
		  (void far *)&russ_dir_block,			     /* !wrw */
		  (unsigned short)DIRBLKLEN,			     /* !wrw */
		  (unsigned *)&read_count			     /* !wrw */
		 );						     /* !wrw */

	if (retcode != 0)					     /* !wrw */
	 {							     /* !wrw */
	  display_it(SOURCE_NO_BACKUP_FILE,STND_ERR_DEV,0,NO_RESPTYPE,(BYTE)UTIL_MSG); /*;AN000;6*/
	  unexperror(NOBACKUPFILE);				     /* !wrw */
	 }

	got_first_fh = FALSE;					     /* !wrw */
	get_fileheader_length();	/*;AN000;3*/

 return;	/* end subroutine */				     /* !wrw */
}								     /* !wrw */

/**************************************************************/
/*
/*	SUBROUTINE: get_fileheader_length
/*
/*	FUNCTION:   Gets the length of a file header
/*		    Sets BACKUP_LEVEL to indicate which
/**************************************************************/
void get_fileheader_length()
{
	WORD retcode;			/*;AN000;3*/
	WORD read_count;		/*;AN000;3*/
	DWORD file_position;		/*;AN000;3*/

			/* Save current file pointer */
	retcode =					/*;AN000;3*/
	  DOSCHGFILEPTR 				/*;AN000;3*/
	   (						/*;AN000;3*/
	    control_file_handle,	/* Handle */	/*;AN000;3*/
	    (DWORD)0,			/* New location *//*;AN000;3*/
	    (BYTE)1,			/* MOVE METHOD *//*;AN000;3*/
	    (DWORD far *)&file_position 		/*;AN000;3*/
	   );						/*;AN000;3*/

	if (retcode != 0)				/*;AN000;3*/
	 {						/*;AN000;3*/
	  display_it(SOURCE_NO_BACKUP_FILE,STND_ERR_DEV,0,NO_RESPTYPE,(BYTE)UTIL_MSG); /*;AN000;6*/
	  unexperror(NOBACKUPFILE);			/*;AN000;3*/
	 }

			/* Read in file header length*/
      retcode = _dos_read				/*;AN000;3*/
	(  control_file_handle,				/*;AN000;3*/
	  (void far *)&fileheader_length,		/*;AN000;3*/
	  (unsigned short)2,				/*;AN000;3*/
	  (unsigned *)&read_count			/*;AN000;3*/
	 );						/*;AN000;3*/

	if (retcode != 0 || read_count != 2)		/*;AN000;3*/
	 {						/*;AN000;3*/
	  display_it(SOURCE_NO_BACKUP_FILE,STND_ERR_DEV,0,NO_RESPTYPE,(BYTE)UTIL_MSG); /*;AN000;6*/
	  unexperror(NOBACKUPFILE);			/*;AN000;3*/
	 }

			/* Reset file pointer */
	retcode =					/*;AN000;3*/
	  DOSCHGFILEPTR 				/*;AN000;3*/
	   (						/*;AN000;3*/
	    control_file_handle,	/* Handle */	/*;AN000;3*/
	    file_position,		/* New location *//*;AN000;3*/
	    (BYTE)0,			/* MOVE METHOD *//*;AN000;3*/
	    (DWORD far *)&file_position 		/*;AN000;3*/
	   );						/*;AN000;3*/

	return;
}	/* end get_fileheader_length() */


/*   0 */
/**************************************************************/
/*
/*	SUBROUTINE: read_in_a_fileheader
/*
/*	FUNCTION:   Reads in a file header
/*
/**************************************************************/
void read_in_a_fileheader()					     /* !wrw */
{								     /* !wrw */
WORD retcode;		/* return code save area */	     /* !wrw */
WORD read_count;	/* num bytes read in	 */	     /* !wrw */

   retcode = _dos_read(control_file_handle,
     (void far *)&russ_file_header,				     /* !wrw */
      fileheader_length,					     /* !wrw */
      (unsigned *)&read_count					     /* !wrw */
     ); 							     /* !wrw */

   if (retcode != NOERROR)					     /* !wrw */
    {								     /* !wrw */
      display_it(SOURCE_NO_BACKUP_FILE,STND_ERR_DEV,0,NO_RESPTYPE,(BYTE)UTIL_MSG);   /*;AN000;6*/
      unexperror(NOBACKUPFILE); 				     /* !wrw */
    }								     /* !wrw */

    got_first_fh = TRUE;					     /* !wrw */
    fheadnew = (struct file_header_new far *)&russ_file_header;      /* !wrw */

return; 							     /* !wrw */
}								     /* !wrw */
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\restore\rtdo.c ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */


/*------------------------------------
/* SOURCE FILE NAME: RTDO.C
/*------------------------------------
/*  0 */

#include "rt.h"
#include "rt1.h"
#include "rt2.h"
#include "restpars.h"                                                 /*;AN000;4*/
#include "direct.h"
#include "stdio.h"
#include "string.h"
#include "dos.h"                                                      /*;AN000;2*/
#include "comsub.h"             /* common subroutine def'n */
#include "doscalls.h"
#include "error.h"

BYTE		   *buf_pointer;
unsigned	   control_file_pointer;
unsigned	   src_file_handle;
struct FileFindBuf filefindbuf;
struct FileFindBuf dfilefindbuf;
BYTE	      far  *control_buf_pointer;
unsigned int	   control_bufsize;				       /* !wrw */

extern unsigned    char srcddir[MAXPATH+3];
extern unsigned    char rtswitch;
extern unsigned    char control_flag;
extern unsigned    char control_flag2;
extern unsigned    control_file_handle; 			       /* !wrw */
extern struct	   subst_list sublist;				      /*;AN000;6 Message substitution list */

/*****************  START OF SPECIFICATION  ********************************
/*
/*  SUBROUTINE NAME :  Dorestore
/*
/*  DESCRIPTIVE NAME : Searching all disks and restore the matching files.
/*
/*  FUNCTION: This routine does the following:
/*	      1. Initialize the buffer
/*	      2. Change directory to the one which will hold the first
/*		 files to be restored.
/*	      3. If the source drive is removable
/*		 Ouput the message to the screen for user to insert a
/*		 diskette and hit a key when ready.
/*	      4. If the target drive is removable
/*		 Ouput the message to the screen for user to insert a
/*		 diskette and hit a key when ready.
/*	      5. Check whether the diskette contains old or new data
/*		 format.
/*	      6. ouput "file were backup xx-xx-xx"
/*
/*	      For each diskette, do the following:
/*	      5. Call check_bkdisk_old or check_bkdisk_new to check whethe
/*		 it is a backup diskette and whether it is in correct
/*		 sequence number.
/*	      6. Call search_src_disk_old or search_src_disk_new to search
/*		 the entire diskette to find matching files and
/*		 restore them.
/*
/*
/********************** END OF SPECIFICATIONS *******************************/
void dorestore(srcd,destd,inpath,infname,infext,infspec,dt) /* wrw! */
BYTE srcd;
BYTE destd;
BYTE *inpath;
BYTE *infname;
BYTE *infext;
BYTE *infspec;
struct timedate *dt;
{
    BYTE string[MAXPATH+2];
    struct disk_header_old dheadold;
    struct disk_header_new dheadnew;
    struct file_header_new fheadnew;
    struct disk_info dinfo;
    struct file_info finfo;
    unsigned int  control_bufsize;
    unsigned dirlen = MAXPATH;
    WORD dyear;
    WORD dmonth;
    WORD dday;

    BYTE done;							      /*;AN000;p????*/
    BYTE path_to_be_chdir[MAXPATH];
    WORD srcd_num;
    BYTE temp_srcddir[MAXPATH];
    unsigned int dnumwant = 1;
    DWORD bufsize;
    BYTE temp_array1[4];  /*temparary array to build parameters for substitution list */
    BYTE temp_array2[4];

    /*declaration for dosfindfirst */
    unsigned	dirhandle = 1;
    unsigned	attribute = NOTV;
    unsigned	search_cnt = 1; 	    /* # of entries to find */
    unsigned	buf_len = sizeof(struct FileFindBuf);
    BYTE	search_string[MAXPATHF+2];
    WORD retcode;
    /*end decleration for ffirst and fnext*/

    union   REGS   qregs;					      /*;AN000;8*/
    DWORD	date;						      /*;AN000;6*/

   /****************************************************************/
   /* change dest drive directory to the one which will hold the   */
   /* first file to be restored 				   */
   /****************************************************************/
   string[0] = destd;
   string[1] = ':';
   string[2] = NULLC;
   strcat(string,inpath);
   /*if chdir sucessful, save the directory in finfo->curdir*/
   /*if fail, the path is not exist, and needs to be rebuild*/
   if(chdir(string)==0)
      strcpy(finfo.curdir,inpath);

   /*****************************************************************/
   /*if the source disk is hard disk get the current dir of the srcd*/
   /* chdir the source disk to be in \backup directory		    */
   /*****************************************************************/
   /**************************************/
   /* if the source disk is a hard disk  */
   /**************************************/
   /*  save current directory of source disk to be reset back later */
   /*  convert character srcd into integer form  */
   /**************************************/

   srcd_num = (WORD)(srcd - 'A' +1);

   /**************************************/
   /*  get current directory of srcd (DosQCurDir) */
   /**************************************/
   if ((retcode = DOSQCURDIR(srcd_num,(char far *) srcddir,(unsigned far *)&dirlen)) != 0)
     {
      display_it(INVALID_DRIVE,STND_ERR_DEV,0,NO_RESPTYPE,(BYTE)UTIL_MSG);/*;AN000;6*/
      usererror(INVALIDDRIVE);
     }

   temp_srcddir[0] = srcd;
   temp_srcddir[1] = ':';
   temp_srcddir[2] = NULLC;
   if (strlen(srcddir) != 1)
       strcat(temp_srcddir,"\\");
   strcat(temp_srcddir,srcddir);
   strcpy(srcddir,temp_srcddir);

   path_to_be_chdir[0] = srcd;
   path_to_be_chdir[1] = ':';
   path_to_be_chdir[2] = NULLC;
   if (set_reset_test_flag(&control_flag2,SRC_HDISK,TEST) == TRUE)
     strcat(path_to_be_chdir,"\\BACKUP");
   else
     strcat(path_to_be_chdir,"\\");

   if(chdir(path_to_be_chdir)!=0)
    { display_it(SOURCE_NO_BACKUP_FILE,STND_ERR_DEV,0,NO_RESPTYPE,(BYTE)UTIL_MSG); /*;AN000;6*/
      usererror(NOBACKUPFILE);
    }

   /*****************************************************************/
   /* Identify whether the inserted diskette is a old format backup */
   /* diskette or a new format backup diskette			    */
   /* BACKUP.@@@ or BACKUP.xxx with xxx numeric characters has	    */
   /* to be on the diskette					    */
   /*****************************************************************/
   search_string[0] = srcd;
   search_string[1] = ':';
   search_string[2] = NULLC;
   strcat(search_string, "BACKUP*.???");

		/***********************/
		/* Find the first file */
		/***********************/
	done = FFALSE;						      /*;AN000;p????*/

	retcode =						      /*;AN000;p????*/
	  DOSFINDFIRST						      /*;AN000;p????*/
	   (							      /*;AN000;p????*/
	     (char far *)search_string, 			      /*;AN000;p????*/
	     (unsigned far *)&dirhandle,			      /*;AN000;p????*/
	     attribute, 					      /*;AN000;p????*/
	     (struct FileFindBuf far *)&filefindbuf,		      /*;AN000;p????*/
	     buf_len,						      /*;AN000;p????*/
	     (unsigned far *)&search_cnt,			      /*;AN000;p????*/
	     (DWORD) 0						      /*;AN000;p????*/
	  );							      /*;AN000;p????*/

	if (retcode != NOERROR) 				      /*;AN000;p????*/
	 { display_it(SOURCE_NO_BACKUP_FILE,STND_ERR_DEV,0,NO_RESPTYPE,(BYTE)UTIL_MSG); /*;AN000;p????*/
	   usererror(NOBACKUPFILE);				      /*;AN000;p????*/
	 }							      /*;AN000;p????*/

		/*****************************/
		/*  Skip over subdirectories */
	while((retcode = filefindbuf.attributes & SUBDIR) == SUBDIR)  /*;AN000;p????*/
	 {							      /*;AN000;p????*/
	   search_cnt = 1;					      /*;AN000;p????*/

	   retcode =						      /*;AN000;p????*/
	     DOSFINDNEXT					      /*;AN000;p????*/
	      ( dirhandle,					      /*;AN000;p????*/
		(struct FileFindBuf far *)&filefindbuf, 	      /*;AN000;p????*/
		buf_len,					      /*;AN000;p????*/
		(unsigned far *)&search_cnt			      /*;AN000;p????*/
	      );						      /*;AN000;p????*/

	   if (retcode != NOERROR)				      /*;AN000;p????*/
	    { display_it(SOURCE_NO_BACKUP_FILE,STND_ERR_DEV,0,NO_RESPTYPE,(BYTE)UTIL_MSG);   /*;AN000;p????*/
	      usererror(NOBACKUPFILE);				      /*;AN000;p????*/
	    }							      /*;AN000;p????*/
	 }							      /*;AN000;p????*/

		/****************************************/
		/*  Loop through looking at file names	*/
		/****************************************/
	 do							       /*;AN000;p????*/
	  {		 /*  Is it old BACKUP ??? */		       /*;AN000;p????*/
	    if (strcmp(filefindbuf.file_name,BACKUPID)==0)	       /*;AN000;p????*/
	      { 						       /*;AN000;p????*/
	       set_reset_test_flag(&control_flag,OLDNEW,SET);	       /*;AN000;p????*/
	       done = TTRUE;					       /*;AN000;p????*/
	      } 						       /*;AN000;p????*/
	     else						       /*;AN000;p????*/
	      { 	 /*  Is it new BACKUP ??? */		       /*;AN000;p????*/
	       if ((filefindbuf.file_name[6] == '.') &&                /*;AN000;p????*/
		   (filefindbuf.file_name[7] >= '0') &&                /*;AN000;p????*/
		   (filefindbuf.file_name[7] <= '9') &&                /*;AN000;p????*/
		   (filefindbuf.file_name[8] >= '0') &&                /*;AN000;p????*/
		   (filefindbuf.file_name[8] <= '9') &&                /*;AN000;p????*/
		   (filefindbuf.file_name[9] >= '0') &&                /*;AN000;p????*/
		   (filefindbuf.file_name[9] <= '9') &&                /*;AN000;p????*/
		   (filefindbuf.file_name[10] == NULLC) )	       /*;AN000;p????*/
		 {						       /*;AN000;p????*/
		   set_reset_test_flag(&control_flag,OLDNEW,RESET);    /*;AN000;p????*/
		   init_control_buf((unsigned long)0,&control_bufsize);/*;AN000;p????*/
		   done = TTRUE;				       /*;AN000;p????*/
		 }						       /*;AN000;p????*/
	      }

	    if (!done)
	      do
	       {							 /*;AN000;p????*/
		 search_cnt = 1;					 /*;AN000;p????*/
		 retcode =						 /*;AN000;p????*/
		   DOSFINDNEXT						 /*;AN000;p????*/
		    ( dirhandle,					 /*;AN000;p????*/
		      (struct FileFindBuf far *)&filefindbuf,		 /*;AN000;p????*/
		      buf_len,						 /*;AN000;p????*/
		      (unsigned far *)&search_cnt			 /*;AN000;p????*/
		    );							 /*;AN000;p????*/

		 if (retcode != NOERROR)			      /*;AN000;p????*/
		  { display_it(SOURCE_NO_BACKUP_FILE,STND_ERR_DEV,0,NO_RESPTYPE,(BYTE)UTIL_MSG); /*;AN000;p????*/
		    usererror(NOBACKUPFILE);			      /*;AN000;p????*/
		  }						      /*;AN000;p????*/

	       } /* end while */				      /*;AN000;p????*/
	       while(filefindbuf.attributes & SUBDIR == SUBDIR);

	  } /* end DO loop */					      /*;AN000;p????*/
	  while (!done);					    /*;AN000;p????*/


   retcode = DOSFINDCLOSE(dirhandle);

   /***************************************/
   /* Display the date of the backup disk */
   /***************************************/
   dyear =  (filefindbuf.write_date >> YRSHIFT & YRMASK) + LOYR;
   dmonth =  filefindbuf.write_date >> MOSHIFT & MOMASK;
   dday =  filefindbuf.write_date & DYMASK;
   date = dyear + (dday*16777216) + (dmonth*65536);		      /*;AN000;6*/

   sublist.value1 = (char far *)date;				      /*;AN000;6*/
   sublist.flags1 = LEFT_ALIGN + DATE_MDY_4;			      /*;AN000;6*/
   sublist.max_width1 = (BYTE)10;				      /*;AN000;6*/
   sublist.min_width1 = sublist.max_width1;			      /*;AN000;6*/
   display_it(FILES_WERE_BACKUP_ON,STND_OUT_DEV,1,NO_RESPTYPE,(BYTE)UTIL_MSG);/*;AN000;6*/

   /*****************************************************************/
   /*start a loop to check and restore each diskette		    */
   /*****************************************************************/
   initbuf(&bufsize);						     /* !wrw */

   for (;;)
    {

     /*****************************************************************/
     /* check whether the inserted diskette is a backup diskette      */
     /*****************************************************************/
     /*if old, check_bkdisk_old else check_bkdisk_new*/

     if (set_reset_test_flag(&control_flag,OLDNEW,TEST) == TRUE)
       check_bkdisk_old(&dheadold, &dinfo, srcd, &dnumwant);
      else
       check_bkdisk_new((struct disk_header_new far *)&dheadnew, &dinfo, srcd, &dnumwant,&control_bufsize);

     /*****************************************************************/
     /* At this point a real backup diskette which is in correct sequence number */
     /* has been found.  In the case of new format, the file CONTROL.xxx is open.*/
     /*****************************************************************/
     /* restored the diskette					      */
     /*****************************************************************/

     /*if old*/
     if (set_reset_test_flag(&control_flag,OLDNEW,TEST) == TRUE)
	search_src_disk_old(&dinfo,&finfo,&dheadold,(struct disk_header_new far *)&dheadnew,
		(struct file_header_new far *)&fheadnew,srcd,destd,bufsize,&dnumwant,
		inpath,infname,infext,infspec,dt);
     else
	search_src_disk_new(&dinfo,&finfo,&dheadold,(struct disk_header_new far *)&dheadnew,
		(struct file_header_new far *)&fheadnew,srcd,destd,&dnumwant,bufsize,
		inpath,infname,infspec,&control_bufsize,dt);

     printf("\n");
     set_reset_test_flag(&control_flag2,OUTOF_SEQ,RESET);
     /************************************************************************/
     /*if ( bk disk is not the last one && (the file spec is WILDCARD or file*/
     /*not found yet or SUB flag in rtswitches is on)), then prompt for user */
     /*to insert another diskette and loop again.			     */
     /************************************************************************/
     if ((dinfo.dflag!=0xff) &&
	((set_reset_test_flag(&control_flag,WILDCARD,TEST) == TRUE) ||
	 (set_reset_test_flag(&control_flag,FOUND,TEST) == FALSE) ||
	 (set_reset_test_flag(&rtswitch,SUB,TEST) == TRUE)))
       {
	  /**********************************************************/
	  /* output message for user to insert another diskette and */
	  /*	      "strike any key when ready"                   */
	  /*	      with response type 4 (wait for a key to be hit)  */
	  /**********************************************************/

	  if (control_file_handle != 0xffff)			       /* !wrw */
	   {							       /* !wrw */
	    DOSCLOSE(control_file_handle);			       /* !wrw */
	    control_file_handle = 0xffff;			       /* !wrw */
	   }							       /* !wrw */

	  temp_array1[0] = (char)((dnumwant / 10) + '0');
	  temp_array1[1] = (char)((dnumwant % 10) + '0');
	  temp_array1[2] = NULLC;
	  temp_array2[0] = srcd;
	  temp_array2[1] = NULLC;

	  sublist.value1 = (char far *)temp_array1;		      /*;AN000;6 */
	  sublist.flags1 = LEFT_ALIGN + CHAR_FIELD_ASCIIZ;	      /*;AN000;6 */
	  sublist.max_width1 = (BYTE)strlen(temp_array1);	      /*;AN000;6 */
	  sublist.min_width1 = sublist.max_width1;		      /*;AN000;6 */

	  sublist.value2 = (char far *)temp_array2;		      /*;AN000;6 */
	  sublist.flags2 = LEFT_ALIGN + CHAR_FIELD_ASCIIZ;	      /*;AN000;6 */
	  sublist.max_width2 = (BYTE)strlen(temp_array2);	      /*;AN000;6 */
	  sublist.min_width2 = sublist.max_width2;		      /*;AN000;6 */

	  display_it(INSERT_SOURCE_DISK,STND_ERR_DEV,2,NO_RESPTYPE,(BYTE)UTIL_MSG); /*;AN000;6*/
	  display_it(PRESS_ANY_KEY,STND_ERR_DEV,0,ANY_KEY_RESPTYPE,(BYTE)UTIL_MSG); /*;AN000;6*/

				  /* If single drive system, eliminates double prompting */
				  /* for user to "Insert diskette for drive %1" */
	  qregs.x.ax = SETLOGICALDRIVE; 			      /*;AN000;8*/
	  qregs.h.bl = srcddir[0] - 'A' + 1;                          /*;AN000;8*/
	  intdos(&qregs,&qregs);				      /*;AN000;8*/

	  continue;
       }
      else
      break;

    } /*end of for loop*/


 return;
}								      /*;AN000;*/
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\restore\rtnew.c ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

/******************************************************************************
*
*  Change Log:
*
*    Date    Who   #                      Description
*  --------  ---  ---  ------------------------------------------------------
*  07/02/90  EGH  C01  Added support for doing a directory of backed up
*                      diskettes via the /D option.
*
******************************************************************************/

/*------------------------------
/* SOURCE FILE NAME:  RTNEW.C
/*------------------------------
/*  0 */

#include "rt.h"
#include "rt1.h"
#include "rt2.h"
#include "restpars.h"                                                 /*;AN000;4*/
#include "string.h"
#include "dos.h"                                                      /*;AN000;2*/
#include "comsub.h"             /* common subroutine def'n */
#include "doscalls.h"
#include "error.h"

extern BYTE rtswitch2;                                                  /*C01*/
extern BYTE control_flag;
extern BYTE control_flag2;
extern unsigned far *control_buf_pointer;
extern unsigned control_file_handle;				     /* !wrw */
extern unsigned src_file_handle;
unsigned int done_searching;					     /* !wrw */
unsigned int numentry;
extern struct  subst_list sublist;				      /*;AN000;6 Message substitution list */

/*****************  START OF SPECIFICATION  ********************************
/*
/*  SUBROUTINE NAME :  search_src_disk_new
/*
/*  DESCRIPTIVE NAME : For new format only, search the entire disk for
/*		       matching files.
/*
/*  FUNCTION: Call subroutine findfirst_new and fnext_new to find all the
/*	      files which match the filename and file extension specified
/*	      in the command line.
/*
/*	      Whenever there is a file found, subroutine filematch
/*	      is called to match the file path, and file extension.
/*	      If file path and file extension match the specification,
/*	      subroutine switchmatch is called to match the file
/*	      attributes, file modes, time, and date, then file sequence
/*	      is checked.
/*
/*	      If the file matches all the specification, subroutine
/*	      restore_a_file is called to actually restore the file.
/*
/*
/********************* END OF SPECIFICATIONS ********************************/
void search_src_disk_new(dinfo,finfo,dheadold,dheadnew,fheadnew, /* wrw! */
		    srcd,destd,dnumwant,buf_size,
		    inpath,infname,infspec,control_buf_size,td)

     struct disk_info *dinfo;
     struct file_info *finfo;
     struct disk_header_new far *dheadnew;
     struct file_header_new far *fheadnew;
     struct disk_header_old *dheadold;
     BYTE   srcd;
     BYTE   destd;
     unsigned int  *dnumwant;  /*num of next disk*/
     unsigned long buf_size;
     unsigned *control_buf_size;
     unsigned char *inpath;
     unsigned char *infname;
     unsigned char *infspec;
     struct timedate *td;

{
     BYTE outstring[MAXPATH+MAXFSPEC];
     WORD  file_seq_num = 1;
     WORD  first_file_on_diskette = TRUE;
     BYTE file_tobe_opened[MAXFSPEC+2];
     WORD dnum;
     WORD found = FALSE;
     WORD far *dirptr;
     WORD far *flptr;
     WORD retcode;
     WORD  action;
     BYTE dir_path[MAXPATH];
     unsigned int  my_own_little_dirhandle = 0; 		     /* !wrw */
     union REGS qregs;						      /*;AN000;8*/
     int    x;							      /*;AN000;8*/

     done_searching = FALSE;					     /* !wrw */

   /***********************************************************************/
   /*search the file control.xxx and try to find the file with match file */
   /*name and file path 						  */
   /***********************************************************************/

   retcode = findfirst_new(finfo,&found,&done_searching,inpath,
	     infspec,&dirptr,&flptr,&numentry,dir_path);

   if (retcode != TRUE)
	return;

   /***********************************************************************/
   /*open file backup.xxx						  */
   /***********************************************************************/
     /*the current disk is one less than the disk num wanted*/
     dnum = *dnumwant -1;
     /*make the file name to be opened*/
     file_tobe_opened[0] = srcd;
     file_tobe_opened[1] = ':';
     file_tobe_opened[2] = NULLC;
     strcat(file_tobe_opened,"BACKUP.");
     file_tobe_opened[9] = (char)((dnum / 100) + '0');
     dnum = dnum % 100;
     file_tobe_opened[10] = (char)((dnum / 10) + '0');
     dnum = dnum % 10;
     file_tobe_opened[11] = (char)(dnum + '0');
     file_tobe_opened[12] = NULLC;

     retcode =
       DOSOPEN
	((char far *)&file_tobe_opened[0],
	 (unsigned far *)&src_file_handle,
	 (unsigned far *)&action,
	 (DWORD)0,
	 0,
	 0x01,
	 0x00c0,
	 (DWORD)0
	);


     if (retcode != NOERROR)
      {
	display_it(NOT_ABLE_TO_RESTORE_FILE,STND_ERR_DEV,0,NO_RESPTYPE,(BYTE)UTIL_MSG);   /*;AN000;6*/
	unexperror(retcode);
      }

   /***********************************************************************/
   /*start loop to find next until no more file found			  */
   /***********************************************************************/
   do
    {
       /******************************************/
       /* if  it is system file, find next one	 */
       /******************************************/
       if
	 (
	   (strcmp(finfo->fname,"IBMBIO.COM")==0  ||
	    strcmp(finfo->fname,"IBMDOS.COM")==0  ||
	    strcmp(finfo->fname,"CMD.EXE")==0     ||
	    strcmp(finfo->fname,"COMMAND.COM")==0 ||
            strcmp(finfo->fname,"MSDOS.SYS") == 0 ||
            strcmp(finfo->fname,"IO.SYS") == 0
	   )						   /*;AN003;*/
	   && strcmp(finfo->path,"\\")==0                  /*;AN003;*/
	 )
	{	 /*  Do not RESTORE the file */
	}
       else
	{

       /***********************************************************************/
       /*if there are any switches set in the input line, call switch match.   */
       /* if switchmatch returns FALSE, then find next file		      */
       /***********************************************************************/
       if ((set_reset_test_flag(&control_flag,SWITCHES,TEST) == FALSE) ||
	  (set_reset_test_flag(&control_flag,SWITCHES,TEST) == TRUE &&
	  ((retcode = switchmatch(finfo, srcd, destd, td)) == TRUE) ))
	{

	  /***********************************************************************/
	  /* if the diskette is out of sequence, then do not check the sequence  */
	  /* number of the 1st file.  Otherwise, check sequence number		 */
	  /***********************************************************************/
	     if (set_reset_test_flag(&control_flag2,OUTOF_SEQ,TEST) == TRUE &&
		 first_file_on_diskette == TRUE && finfo->dnum != file_seq_num)
	      {
	      }
	     else
	      {
		if (finfo->dnum != file_seq_num)
		 {
		   display_it(FILE_SEQUENCE_ERROR,STND_ERR_DEV,0,NO_RESPTYPE,(BYTE)UTIL_MSG);	/*;AN000;6*/
		   unexperror(FILESEQERROR);
		 }

	     /***********************************************************************/
	     /*    msg: output one line of outstring on the screen		    */
	     /* 	     to confirm that a file has been restored sucessfully   */
	     /***********************************************************************/
		strcpy(outstring,finfo->path);
		if (strlen(finfo->path) != 1 )
		   strcat(outstring,"\\");

		strcat(outstring,finfo->fname);
		x = strlen(outstring);
		outstring[x] = CR;				      /*;AN000;6*/
		outstring[x+1] = LF;				      /*;AN000;6*/
		outstring[x+2] = NUL;				      /*;AN000;6*/
		qregs.x.ax = 0x4000;				      /*;AN000;6*/
		qregs.x.bx = 0x0001;				      /*;AN000;6*/
		qregs.x.cx = (WORD)strlen(outstring);		      /*;AN000;6*/
		qregs.x.dx = (unsigned int)&outstring[0];	      /*;AN000;6*/
		intdos(&qregs,&qregs);				      /*;AN000;6*/

	     /***********************************************************************/
	     /* restore the file						    */
	     /***********************************************************************/
                if (set_reset_test_flag(&rtswitch2,DIR,TEST) == TRUE)   /*C01*/
                    set_reset_test_flag(&control_flag,FOUND,SET);       /*C01*/
                else                                                    /*C01*/
                    restore_a_file(finfo,dinfo,buf_size,control_buf_size,
			    fheadnew,dheadold,dheadnew,
			    srcd,destd,inpath,infname,infspec,dnumwant,&my_own_little_dirhandle);      /* wrw! */

		first_file_on_diskette = FALSE;

		if (set_reset_test_flag(&control_flag,SPLITFILE,TEST)==TRUE)
		 {
		   set_reset_test_flag(&control_flag,SPLITFILE,RESET);
		   /*do findfirst, the file found should be the splitted file*/

	/*	   retcode=  findfirst_new( finfo, &found, &done_searching, inpath, */
	/*	       infspec, &dirptr, &flptr,&numentry,dir_path );		    */
		 }

	      } /*end of if disk and file out of sequence*/

       } /*end of if switch match is ok */

      } /*end of if root directory and DOS system files */

   /***********************************************************************/
   /* if has not search to the end of the diskette, find next file	  */
   /***********************************************************************/
     if (done_searching == FALSE)
      {
       found = FALSE;
       retcode=  findnext_new(finfo,&found,&done_searching,inpath,infspec,
		   &dirptr,&flptr,&numentry,dir_path );

       }
     else
      break;

    }	/* end do while loop */
   while( retcode == TRUE);

   DOSCLOSE(src_file_handle);

return; 							     /* !wrw */

} /*end of subroutine*/
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\restore\rtfile.c ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */


/*----------------------------
/* SOURCE FILE NAME: rtfile.c
/*----------------------------
/*  0 */

#include "rt.h"
#include "rt1.h"
#include "rt2.h"
#include "restpars.h"                                                 /*;AN000;4*/
#include "string.h"
#include "stdio.h"
#include "dos.h"                                                      /*;AN000;2*/
#include "comsub.h"             /* common subroutine def'n */
#include "doscalls.h"
#include "error.h"

extern BYTE rtswitch;
extern BYTE control_flag;
extern BYTE control_flag2;
extern BYTE filename[12];
extern BYTE far *buf_pointer;
extern char far *control_buf_pointer;
extern unsigned int  done_searching;				     /* !wrw */
extern unsigned int numentry;

unsigned dest_file_handle;
extern unsigned src_file_handle;
extern unsigned control_file_handle;				     /* !wrw */
BYTE dest_file_spec[MAXFSPEC+3];
extern struct FileFindBuf filefindbuf;
extern BYTE src_fname[MAXFSPEC];
extern struct  subst_list sublist;				      /*;AN000;6 Message substitution list */

/*****************  START OF SPECIFICATION  *********************************/
/*									    */
/*  SUBROUTINE NAME :  restore_a_file					    */
/*									    */
/*  DESCRIPTIVE NAME : restore a file found onto the destination disk.	    */
/*									    */
/*  FUNCTION: This subroutine call open_dest_file to open the destination   */
/*	      file under the proper path.  If the path is not found, build  */
/*	      the path. 						    */
/*	      It then enter a loop to do reading the source disk and	    */
/*	      writing the destination disk until end of file.  If the file  */
/*	      is so large that it is backed up on more than one disk,	    */
/*	      the user is prompt to insert next diskette.  In this	    */
/*	      situation, the disk is checked for correct sequence number,   */
/*	      and then searched for the file to be continue restoring.	    */
/*	      after the file is completely restored, the time, date, and    */
/*	      attributes of the restored file is set to be the same as	    */
/*	      its original value.					    */
/*									    */
/********************** END OF SPECIFICATIONS *******************************/

void restore_a_file(finfo,dinfo,bufsize,control_bufsize,	 /* wrw! */
	       fheadnew,dheadold,dheadnew,
	       srcd,destd,inpath,infname,infspec,dnumwant,dirhandle)

    struct file_info *finfo;
    struct disk_info *dinfo;
    unsigned long bufsize;
    unsigned int *control_bufsize;
    struct file_header_new far *fheadnew;
    struct disk_header_old *dheadold;
    struct disk_header_new far *dheadnew;
    BYTE   srcd;
    BYTE   destd;
    unsigned char *inpath;
    unsigned char *infname;
    unsigned char *infspec;
    unsigned int  *dnumwant;
    unsigned int *dirhandle;
{
    BYTE temp_array1[4];
    BYTE temp_array2[4];
    BYTE temp_fname[MAXFSPEC];
    WORD  action;
    WORD  first_time=TRUE;

 /*declaration for dosfindfirst */
    WORD temp_dirhandle;
    WORD next_dirhandle;
    unsigned	attribute = NOTV;	    /*				    */
    unsigned	search_cnt = 1; 	    /* # of entries to find	    */
    unsigned	buf_len = sizeof(struct FileFindBuf);
    BYTE search_string[MAXPATHF+2];
 /*end decleration for ffirst and fnext*/

    BYTE outstring[MAXPATHF+2];
    WORD   retcode;
    DWORD iterate_num;
    DWORD i;			/* wrw! */
    WORD numread;
    WORD numwrite;
    DWORD int remainder;
    DWORD part_size;
    WORD file_seq_num = 1;  /*when this routine is called, the first
			       part of the file already get check against the
			       file sequence number */
    BYTE   file_tobe_opened[MAXFSPEC+2];
    WORD   found = FALSE;
    WORD   *dirptr;
    WORD   *flptr;
    DWORD  newptr;
    unsigned int dnum;
    DWORD  temp_offset;

    BYTE   my_own_dirpath[MAXPATH];
    int    x;							      /*;AN000;8*/
    union REGS qregs;						      /*;AN000;8*/

	/*build a string of destination file specification*/
	dest_file_spec[0] = destd;
	dest_file_spec[1] = ':';
	dest_file_spec[2] = NULLC;
	strcat(dest_file_spec,finfo->fname);

	/*********************************************************************/
	/* Open destination file, and chdir the the path where the dest file */
	/* going to reside.  If the path is not there, then create the path. */
	/* If file sharing error, exit this routine			     */
	/*********************************************************************/
		/*open_dest_file*/
	retcode=open_dest_file(finfo,destd);

		/*if file sharring error, exit this subroutine*/
	if (retcode == FALSE)
	  display_it(FILE_CREATION_ERROR,STND_ERR_DEV,0,NO_RESPTYPE,(BYTE)UTIL_MSG); /*;AN000;6*/
	 else
	 {
	    /*setflag PARTIAL*/
	    set_reset_test_flag(&control_flag,PARTIAL,SET);

	    /*********************************************************************/
	    /* This loop will be processed once for each part of the source file */
	    /*********************************************************************/
	    for ( ; ; )
	     {

	       /*********************************************************************/
	       /* compare source file size and buf size to determine the	    */
	       /*	    iteration of reading and writing			    */
	       /*********************************************************************/
	       part_size = finfo->partsize;
	       /*if old*/
	       if (set_reset_test_flag(&control_flag,OLDNEW,TEST)==TRUE)
		part_size = part_size - HEADLEN;

	       iterate_num = part_size / bufsize;
	       /*if remain of of filesize/bufsize != 0, add 1 to iterate_num*/
		    remainder = part_size % bufsize;
		    if (remainder > 0)
		       ++iterate_num;

	       /*********************************************************************/
	       /*loop through each of the iteration				    */
	       /*********************************************************************/
	       for (i = 1; i <= iterate_num; ++i)
		{
		   /***************************************************************/
		   /* if old format, read from the beginning of the source file   */
		   /***************************************************************/
		   /*read source file (new and old have different pointer)*/
		   if (set_reset_test_flag(&control_flag,OLDNEW,TEST) == TRUE)
		    {
		      retcode = _dos_read(src_file_handle, 
				(void far *)&buf_pointer[0],
				(unsigned)bufsize,
				(unsigned *)&numread);

		      if (retcode != 0)
		       {
			com_msg(retcode);
			unexperror(retcode);
		       }
		    }
		   else
		    { /*new format*/
		   /***************************************************************/
		   /* if new format, search backup.xxx for the file to be restored*/
		   /* and read it.						  */
		   /***************************************************************/
		      temp_offset = finfo->offset + bufsize * (i - 1);
		      retcode =
			DOSCHGFILEPTR
			  (src_file_handle,
			   (DWORD) temp_offset,
			   (unsigned) 0,
			   (DWORD far *) &newptr
			  );

		      if (i == iterate_num)
			{
			  part_size = part_size - bufsize * (iterate_num -1);
			  retcode = _dos_read(src_file_handle,
			       (void far *)&buf_pointer[0],
			       (unsigned)part_size,
			       (unsigned *)&numread
			     );
			}
		       else
			{
			  retcode =  _dos_read(src_file_handle,
			      (void far *)&buf_pointer[0],
			      (unsigned)bufsize,
			      (unsigned *)&numread
			     );

			}  /*end of i == iterate_num */
		}  /*end of new format */

		   /*************************************************************/
		   /* write to dest file					*/
		   /*************************************************************/
		    retcode =
		     DOSWRITE
		       (dest_file_handle,
			(char far *)&buf_pointer[0],
			(unsigned) numread,
			(unsigned far *) &numwrite
		       );

		   /*************************************************************/
		   /*if the num of bytes read != num of bytes write		*/
		   /* call dos_write_error to find out why			*/
		   /*************************************************************/
		   if (numread != numwrite)
		    dos_write_error(bufsize,destd);
	       }
	       /*end iteration loop*/

	       /*****************************************************************/
	       /*if the file is system file, turn RTSYSTEM on			*/
	       /*****************************************************************/
	       if (strcmp(finfo->fname,"IBMBIO.COM")==0 ||
		   strcmp(finfo->fname,"IBMDOS.COM")==0 ||
		   strcmp(finfo->fname,"COMMAND.COM")==0 ||
                   strcmp(finfo->fname,"IO.SYS") == 0 ||
                   strcmp(finfo->fname,"MSDOS.SYS") == 0 ||
                   strcmp(finfo->fname,"CMD.EXE") == 0)
		   set_reset_test_flag(&control_flag2,RTSYSTEM,SET);


	       /*****************************************************************/
	       /*if the source file header indicate that this is the last disk, */
	       /* that is,it is completely copied, then exit the for loop	*/
	       /*****************************************************************/
	       if (set_reset_test_flag(&finfo->fflag,LAST_PART,TEST) == TRUE)
		 break;  /* exit the loop */

	       /*****************************************************************/
	       /*The logic flow come here when the file expanded into next disk.*/
	       /* if old format, close the file handle and find handle		*/
	       /* if new format, close src file 				*/
	       /*****************************************************************/
	       if (set_reset_test_flag(&control_flag,OLDNEW,TEST) == TRUE)
		{ /*close source file*/
		  DOSCLOSE(src_file_handle);

		  if (first_time == TRUE)
		   {  temp_dirhandle = *dirhandle;
		      first_time = FALSE;
		      retcode = DOSFINDCLOSE(temp_dirhandle);
		   }
		}
	       else
		{
		  DOSCLOSE(src_file_handle);
		  DOSCLOSE(control_file_handle);		      /* !wrw */
		  control_file_handle = 0xffff; 		      /* !wrw */
		}

	       /*****************************************************************/
	       /* output message for user to insert another diskette		*/
	       /*	   "strike any key when ready"                          */
	       /*	   with response type 4 (wait for a key to be hit)	*/
	       /*****************************************************************/

		 if (control_file_handle != 0xffff)			      /* !wrw */
		  {							      /* !wrw */
		   DOSCLOSE(control_file_handle);			      /* !wrw */
		   control_file_handle = 0xffff;			      /* !wrw */
		  }							      /* !wrw */

	       printf("\n");
	       temp_array1[0] = (char) (*dnumwant / 10) + '0';
	       temp_array1[1] = (char) (*dnumwant % 10) + '0';
	       temp_array1[2] = NULLC;
	       temp_array2[0] = srcd;
	       temp_array2[1] = NULLC;

	       sublist.value1 = (char far *)temp_array1;	      /*;AN000;6 */
	       sublist.flags1 = LEFT_ALIGN + CHAR_FIELD_ASCIIZ;       /*;AN000;6 */
	       sublist.max_width1 = (BYTE)strlen(temp_array1);	      /*;AN000;6 */
	       sublist.min_width1 = sublist.max_width1; 	      /*;AN000;6 */

	       sublist.value2 = (char far *)temp_array2;	      /*;AN000;6 */
	       sublist.flags2 = LEFT_ALIGN + CHAR_FIELD_ASCIIZ;       /*;AN000;6 */
	       sublist.max_width2 = (BYTE)strlen(temp_array2);	      /*;AN000;6 */
	       sublist.min_width2 = sublist.max_width2; 	      /*;AN000;6 */

	       display_it(INSERT_SOURCE_DISK,STND_ERR_DEV,2,NO_RESPTYPE,(BYTE)UTIL_MSG); /*;AN000;6*/
	       display_it(PRESS_ANY_KEY,STND_ERR_DEV,0,ANY_KEY_RESPTYPE,(BYTE)UTIL_MSG); /*;AN000;6*/

					 /* If single drive system, eliminates double prompting */
					 /* for user to "Insert diskette for drive %1" */
	       qregs.x.ax = SETLOGICALDRIVE;			      /*;AN000;8*/
	       qregs.h.bl = srcd;				      /*;AN000;8*/
	       intdos(&qregs,&qregs);				      /*;AN000;8*/

		/**************************************************/
		/**************************************************/
	       if (set_reset_test_flag(&control_flag,OLDNEW,TEST) == TRUE)
		 check_bkdisk_old(dheadold,dinfo,srcd,dnumwant);
		else
		 check_bkdisk_new(dheadnew,dinfo,srcd,dnumwant,control_bufsize);

	       /*at this point a real backup diskette which is in correct sequence
	       number has been found.  In the case of new format, the file
	       CONTROL.xxx is opened.*/

	       /*****************************************************************/
	       /*increament file sequence number				*/
	       /*****************************************************************/
	       file_seq_num = file_seq_num + 1;

	       /*****************************************************************/
	       /* search the new disk for next part of the file 		*/
	       /*****************************************************************/
	       if (set_reset_test_flag(&control_flag,OLDNEW,TEST) == TRUE)
		{    /**************************************************************/
		     /* if old format,						   */
		     /*DosFindFirst:find the first file on the diskette (non-vol id*/
		     /*entry)							   */
		     /**************************************************************/
		       search_string[0] = srcd;
		       search_string[1] = ':';
		       search_string[2] = NULLC;
		       strcat(search_string, src_fname);

		       next_dirhandle = 0xffff;   /* directory handle		  */

		     retcode =					/* Find the 1st filename that	*/
		       DOSFINDFIRST(				/*   matches specified file spec*/
			  (char far * ) search_string,		/* File path name	  */
			  (unsigned far * ) &next_dirhandle,	/* Directory search    */
			  attribute,				/* Search attribute	  */
			  (struct FileFindBuf far *) &filefindbuf,
			  buf_len,				/* Result buffer length   */
			  (unsigned far * ) &search_cnt,	/* Number of entries to find*/
			  (DWORD) 0
		       );

		     if (retcode != 0)
		      {
			display_it(NOT_ABLE_TO_RESTORE_FILE,STND_ERR_DEV,0,NO_RESPTYPE,(BYTE)UTIL_MSG); /*;AN000;6*/
			unexperror(retcode);
		      }


		     /*if the directory found is a subdirectory, find next one*/
		     while((retcode = filefindbuf.attributes & SUBDIR) == SUBDIR)
		     {
			search_cnt = 1;
			retcode = DOSFINDNEXT(next_dirhandle,
			     (struct FileFindBuf far *)&filefindbuf,
			     buf_len,
			     (unsigned far *)&search_cnt);

			if (retcode != 0)
			{
			  display_it(NOT_ABLE_TO_RESTORE_FILE,STND_ERR_DEV,0,NO_RESPTYPE,(BYTE)UTIL_MSG); /*;AN000;6*/
			  unexperror(retcode);
			}

		     } /*end while */

		  retcode = DOSFINDCLOSE(next_dirhandle);

		  /*****************************************************************/
		  /* check_flheader_old: open and read file header, check dnum	   */
		  /*	 of the file, and fill fheadold and finfo with correct info*/
		  /*****************************************************************/
		  strcpy(temp_fname,filefindbuf.file_name);
		  retcode =
		   check_flheader_old
		     ( finfo, temp_fname,
		       filefindbuf.write_date, filefindbuf.write_time,
		       filefindbuf.attributes, filefindbuf.file_size,
		       file_seq_num, srcd, destd, infspec, inpath, dnumwant
		     );

		  if (retcode != 0)
		   {
		     display_it(NOT_ABLE_TO_RESTORE_FILE,STND_ERR_DEV,0,NO_RESPTYPE,(BYTE)UTIL_MSG); /*;AN000;6*/
		     unexperror(retcode);
		   }

		  /*****************************************************************/
		  /* check file sequence number.				   */
		  /*****************************************************************/
		  if (finfo->dnum != file_seq_num)
		   { display_it(FILE_SEQUENCE_ERROR,STND_ERR_DEV,0,NO_RESPTYPE,(BYTE)UTIL_MSG); /*;AN000;6*/
		     unexperror(FILESEQERROR);
		   }

	       }
	       else
	       { /*new format*/
		  /**********************************************/
		  /*   Find the file on the CONTROL.xxx first	*/
		  /**********************************************/

		  /* findfirst_new on the new diskette using the filename.??? */
		  retcode =
		   findfirst_new
		    ( finfo, &found, &done_searching,
		      finfo->path, finfo->fname, (WORD far **) &dirptr,    /* wrw! */
		      (WORD far **) &flptr, &numentry, my_own_dirpath
		    );							   /* wrw! */

		  while (retcode != 0 )
		   {
		     display_it(NOT_ABLE_TO_RESTORE_FILE,STND_ERR_DEV,0,NO_RESPTYPE,(BYTE)UTIL_MSG); /*;AN000;6*/
		     unexperror(CREATIONERROR);
		   }

		  if (finfo->dnum != file_seq_num)
		   { display_it(FILE_SEQUENCE_ERROR,STND_ERR_DEV,0,NO_RESPTYPE,(BYTE)UTIL_MSG); /*;AN000;6*/
		     unexperror(FILESEQERROR);
		   }

		  /**************************************************************/
		  /* open file backup.xxx					*/
		  /**************************************************************/
		    /*the current disk is one less than the disk num wanted*/
		    dnum = *dnumwant -1;
		    /*make the file name to be opened*/
		    file_tobe_opened[0] = srcd;
		    file_tobe_opened[1] = ':';
		    file_tobe_opened[2] = NULLC;
		    strcat(file_tobe_opened,"BACKUP.");
		    file_tobe_opened[9] = (char)((dnum / 100) + '0');
		    dnum = dnum % 100;
		    file_tobe_opened[10] = (char)((dnum / 10) + '0');
		    dnum = dnum % 10;
		    file_tobe_opened[11] = (char)(dnum + '0');
		    file_tobe_opened[12] = NULLC;

		    retcode =
		      DOSOPEN
		       ( (char far *)&file_tobe_opened[0],
			 (unsigned far *)&src_file_handle,
			 (unsigned far *)&action,
			 (DWORD)0,		/*file size*/
			 0,			/*file attribute*/
			 0x01,			/*if file exist, open it*/
						/*if file not exist, fail it*/
			 0x00c0,		/*deny write, read only*/
			 (DWORD)0
		       );  /*reserved*/

		    if (retcode != 0)
		     { display_it(NOT_ABLE_TO_RESTORE_FILE,STND_ERR_DEV,0,NO_RESPTYPE,(BYTE)UTIL_MSG); /*;AN000;6*/
		       unexperror(retcode);
		     }

	       }
	       /*end of if new format*/

	       /*assume the file to be continue definatly will be found on the
		second diskette because the dnum of the file already gets checked
		in check_bkdisk_old or check_bkdisk_new*/

	       /*set flag to be SPLITFILE*/
	       set_reset_test_flag(&control_flag,SPLITFILE,SET);

	    /*******************************************/
	    /* Display name of file is to be restored  */
	    /*******************************************/
	     /*outstring = inpath\infspec*/
	     strcpy(outstring,finfo->path);
	     if (strlen(finfo->path) != 1 )
		strcat(outstring,"\\");

	     strcat(outstring,finfo->fname);
	     x = strlen(outstring);
	     outstring[x] = CR; 				      /*;AN000;6*/
	     outstring[x+1] = LF;				      /*;AN000;6*/
	     outstring[x+2] = NUL;				      /*;AN000;6*/
	     qregs.x.ax = 0x4000;				      /*;AN000;6*/
	     qregs.x.bx = 0x0001;				      /*;AN000;6*/
	     qregs.x.cx = (WORD)strlen(outstring);		      /*;AN000;6*/
	     qregs.x.dx = (unsigned int)&outstring[0];		      /*;AN000;6*/
	     intdos(&qregs,&qregs);				      /*;AN000;6*/

	     /*loop back to do the read source and write dest until finfo->fflag
	     indicate that this is the last part of file*/
	    }	 /*end of for loop*/

	    /************************************************************************/
	    /*set_attributes_and_close: set the attributes and last write date/time */
	    /*of the file just restore to be like those of the backup file	    */
	    /************************************************************************/
	    set_attributes_and_close(finfo,destd);

	    /************************************************************************/
	    /* If old format and the file split, then find next matching file	    */
	    /************************************************************************/
	    if (set_reset_test_flag(&control_flag,SPLITFILE,TEST)==TRUE &&
		set_reset_test_flag(&control_flag,OLDNEW,TEST) == TRUE)
	     {
	       /*search string used for DisFindFirst = srcd:infname.**/
	       /*DosFindFirst:find the first file on the diskette (non-vol id entry)
		      using the search string*/
		 search_string[0] = srcd;
		 search_string[1] = ':';
		 search_string[2] = NULLC;
		 strcat(search_string, infname);
		 strcat(search_string, ".*");

	       temp_dirhandle = 0xffff;
	       retcode =			       /* Find the 1st filename that */
		 DOSFINDFIRST(			       /*   matches specified file spec*/
		    ( char far * ) search_string,      /* File path name */
		    ( unsigned far * ) &temp_dirhandle, /* Directory search handle*/
		    (unsigned) NOTV,		      /* Search attribute  */
		    (struct FileFindBuf far *) &filefindbuf,
		    buf_len,			       /* Result buffer length	       */
		    ( unsigned far * ) &search_cnt,    /* Number of entries to find    */
		    ( DWORD) 0
		 );

	       /*if not found return*/
		 if (retcode != 0)
		    temp_dirhandle = 0xffff;
		  else
		   {

		     /*if the directory found is a subdirectory, find next one*/
		     while((retcode = filefindbuf.attributes & SUBDIR) == SUBDIR)
		      {
			search_cnt = 1;
			retcode = DOSFINDNEXT(temp_dirhandle,
			     (struct FileFindBuf far *)&filefindbuf,
			     buf_len,
			     (unsigned far *)&search_cnt);
			if (retcode != 0)
			  temp_dirhandle = 0xffff;
		      } /*end while */

		    if(strcmp(filefindbuf.file_name,BACKUPID)==0 ||
		       strcmp(filefindbuf.file_name,src_fname)==0 )
		     {
		       retcode =DOSFINDNEXT(temp_dirhandle,
			   (struct FileFindBuf far *)&filefindbuf,
			   buf_len,
			   (unsigned far *)&search_cnt);

		       if (retcode != 0)
			  temp_dirhandle = 0xffff;

		       else
			{
			  if(strcmp(filefindbuf.file_name,BACKUPID)==0 ||
			     strcmp(filefindbuf.file_name,src_fname)==0 )
			   {
			     retcode =DOSFINDNEXT(temp_dirhandle,
				      (struct FileFindBuf far *)&filefindbuf,
				      buf_len,
				      (unsigned far *)&search_cnt);

			     if (retcode != 0)
				temp_dirhandle = 0xffff;
			   }

			} /*end of the rc is 0 */
		     } /*end of if strcomp is sucessful*/

		   }
		 *dirhandle = temp_dirhandle;

	     }	/*end of if the file was splitted */


	    /****************************************************************/
	    /*set FOUNDFILE flag					    */
	    /****************************************************************/
	    set_reset_test_flag(&control_flag,FOUND,SET);
	 } /* end of if open destination file get file sharing error */

} /*end of restore_a_file subroutine*/
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\restore\rtfile1.c ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */


/*------------------------------
/* SOURCE FILE NAME: rtfile1.c
/*------------------------------
/*  0 */

#include "rt.h"
#include "rt1.h"
#include "rt2.h"
#include "restpars.h"                                                 /*;AN000;4*/
#include "direct.h"
#include "string.h"
#include "dos.h"                                                      /*;AN000;2*/
#include "comsub.h"             /* common subroutine def'n */
#include "doscalls.h"
#include "error.h"

char ext_attrib_buff[4086];					      /*;AN000;3*/

extern BYTE rtswitch;
extern BYTE control_flag;
extern BYTE control_flag2;
extern unsigned dest_file_handle;
extern unsigned src_file_handle;
extern BYTE far *buf_pointer;
extern BYTE dest_file_spec[MAXFSPEC+3];
extern struct FileFindBuf filefindbuf;

extern struct file_header_new far *fheadnew;   /*;AN000;3 */

/****************  START OF SPECIFICATION  ********************************
/*
/*  SUBROUTINE NAME :  open_dest_file
/*
/*  DESCRIPTIVE NAME : open the destination file and build a path to it
/*		       if necessary.
/*
/*  FUNCTION:  Try to change the current directory of the destination disk
/*	       to be the one the file is to be restored.  If not able to
/*	       do it because the directory does not exist, call
/*	       build_path_create_file subroutine to build path,
/*	       create the destination file and return a handle on it.
/*	       If file can not be created, find out whether it is caused
/*	       by file sharing error, or caused by disk full.
/*
/*
/********************** END OF SPECIFICATIONS ******************************/
WORD open_dest_file(finfo,destd)
struct file_info *finfo;
BYTE destd;
{
    BYTE  path_to_be_chdir[MAXPATH+2];
    WORD retcode;

    /*declaration for dosfindfirst */
    unsigned	dirhandle = 0xffff;
    unsigned	attribute = NOTV;
    unsigned	search_cnt = 1;
    unsigned	buf_len = sizeof(struct FileFindBuf);
    BYTE search_string[MAXPATHF+2];
    /*end decleration for ffirst and fnext*/

   /*************************************************************************
   /*if current directory is not where the file wants to be restored and
   /* (the file is not to be restored in root or the current directory is
   /* not root).  This is to avoid building path if the the current
   /* directory already got updated to be the right directory (in dorestore),
   /* or both current directory and the requested directory are root
   /* directory
   /**************************************************************************/

   if (strcmp(finfo->path,finfo->curdir)!=0)
    {
		/* Change to finfo->path. If error, create the directory */
      strcpy(finfo->curdir,finfo->path);
      path_to_be_chdir[0] = destd;
      path_to_be_chdir[1] = ':';
      path_to_be_chdir[2] = NULLC;
      strcat(path_to_be_chdir,finfo->curdir);
      if(chdir(path_to_be_chdir)!=0)
       {
	 build_path_create_file(finfo->path,destd,finfo->fflag);  /*;AC000;3*/
	 if (dest_file_handle != NULLC)
	  return(TRUE);
       }
    }

   /* Current directory is the one where files are to be restored to*/

      retcode = create_the_file(finfo->fflag);  /*;AN000;3*/

      if (retcode == NOERROR)
       return(TRUE);

	/*----------------------------------------*/
	/*-  There was an error creating target  -*/
	/*-  file. Reset attribute and try again -*/
	/*----------------------------------------*/
      retcode =
       DOSSETFILEMODE
	(
	  (char far *)&dest_file_spec[0],
	  (unsigned) 0x00,
	  (DWORD) 0
	);

      retcode = create_the_file(finfo->fflag);  /*;AN000;3*/

   if (retcode == NOERROR)
    return(TRUE);
   else
    return(FALSE);					/*;AC000;p1102*/


} /*end of subroutine*/
/****************  START OF SPECIFICATION  ********************************
/*
/*  SUBROUTINE NAME :  build_path_create_file
/*
/*  DESCRIPTIVE NAME : Build path for the destination file, and create
/*		       the file in the current direactory.
/*
/*  FUNCTION:  Rebuild the path of the file about to be restored by
/*	       recreating all subdirectories needed to complete the path.
/*	       Then chdir to the one which is to reside and create the
/*	       file.
/*
/********************* END OF SPECIFICATIONS ********************************/
void build_path_create_file(in_path,destd,fflag)
BYTE *in_path;
BYTE destd;
BYTE fflag;						/*;AN000;3*/
{
    WORD  array[20];
    int   i,j;
    BYTE  path[MAXPATH+2];
    WORD  retcode;
    BYTE cant_make = FFALSE;			/*;AN000;10*/

    path[0] = destd;
    path[1] = ':';
    path[2] = NULLC;
    strcat(path,in_path);
    i = strlen(path);
    j = -1;

    /* Create the path for destination file */
    /*Loop until mkdir(path) is successful*/

    while (mkdir(path) && !cant_make)				     /*;AC000;10*/
     {
	 /*scan path backward until find a \ */
	 for (; path[i] != '\\'; i--)
	 if (i < 0)
	   { display_it(FILE_CREATION_ERROR,STND_ERR_DEV,0,NO_RESPTYPE,(BYTE)UTIL_MSG);/*;AN000;6*/
	     display_it(PRESS_ANY_KEY,STND_ERR_DEV,0,ANY_KEY_RESPTYPE,(BYTE)UTIL_MSG); /*;AN000;9*/
	     cant_make = TTRUE; 				     /*;AN000;10*/
	     break;						     /*;AN000;10*/
	   }

	 /*obtain the last subdir from the path */
	 path[i] = NULLC;
	 j++;
	 /*save the location of the last \ in an array of \ locations */
	 array[j] = i;
     }

    /*loop through the array of \ locations*/
    i = j;
    for (;;)
     {
       if (i >= 0 && !cant_make)				     /*;AC000;10*/
	 {
	   path[array[i]] = '\\';
	   if (mkdir(path))
	    { display_it(FILE_CREATION_ERROR,STND_ERR_DEV,0,NO_RESPTYPE,(BYTE)UTIL_MSG);/*;AN000;6*/
	      display_it(PRESS_ANY_KEY,STND_ERR_DEV,0,ANY_KEY_RESPTYPE,(BYTE)UTIL_MSG); /*;AN000;9*/
	      cant_make = TTRUE;				     /*;AN000;10*/
	      break;						     /*;AN000;10*/
	    }
	   --i;
	 }
	else
	  break;
     } /*end for loop */

    chdir(path);						      /*;AN000;3*/
    retcode = create_the_file(fflag); 		      /*;AN000;3*/

  return;	  /* wrw! */

}

/********************************************************/
/*
/*  SUBROUTINE NAME: create_the_file
/*
/*  DESCRIPTIVE NAME :	Create the target file.
/*			Use DOS 4.00 Extended Create Function 6C00h
/*			Remember to handle Extended Attributes!
/*
/********************************************************/
#define EXTENDEDOPEN 0x6c00					      /*;AN000;3*/
WORD create_the_file(fflag)				      /*;AN000;3*/
BYTE	fflag;							      /*;AN000;3*/
{								      /*;AN000;3*/
	WORD	retcode;					      /*;AN000;3*/
	union REGS reg; 					      /*;AN000;3*/


	retcode = NOERROR;					      /*;AN000;3*/
	reg.x.ax = EXTENDEDOPEN;	      /* Function */	      /*;AN000;3*/
	reg.x.bx = 0x2011;		      /* Mode */	      /*;AN000;3*/
	reg.x.bx = 0x0081;		      /* Mode */	      /*;AN000;3*/
	reg.x.cx = 0;			      /* Attribute */	      /*;AN000;3*/
	reg.x.dx = 0x112;		      /* Flag */	      /*;AN000;3*/

	reg.x.si = (WORD)&dest_file_spec[0];  /* Filename */	      /*;AN000;3*/
        reg.x.di = 0xffff;			/* No parmlist */     /*;AN000;3*/

	intdos(&reg,&reg);					      /*;AN000;3*/
	if (reg.x.cflag & CARRY)     /* If there was an error	      /*;AN000;3*/
	 retcode = reg.x.ax;		  /*  then set return code    /*;AN000;3*/

	dest_file_handle = reg.x.ax;				      /*;AN000;3*/

	return(retcode);					      /*;AN000;3*/
}								      /*;AN000;3*/

/****************  START OF SPECIFICATION  ********************************
/*
/*  SUBROUTINE NAME :  set_attributes_and_close
/*
/*  DESCRIPTIVE NAME :	Set the file attributes and close the file
/*
/*  FUNCTION: Set the attributes and last write date/time of the file just
/*	      restored to be like those of the backup file.
/*
/********************* END OF SPECIFICATIONS ********************************/
int set_attributes_and_close(finfo,destd)
struct file_info *finfo;
BYTE destd;
{
   struct FileStatus fileinfo_buf;
   WORD destdnum;
   WORD buflen = sizeof(struct FileStatus);

   WORD retcode;

   destdnum = destd - 'A' + 1;

   /************************************************************************/
   /* call DosQFileInfo: Request date and time of the dest file 	   */
   /************************************************************************/
   retcode = DOSQFILEINFO (
       (unsigned)dest_file_handle,	/* File handle */
       (unsigned)1,			/* File info data required */
       (char far *)&fileinfo_buf,	/* File info buffer */
       (unsigned)buflen);		/* File info buffer size */

   /*if fail, unexperror "file creation error"*/
   if (retcode != NOERROR)
    { display_it(FILE_CREATION_ERROR,STND_ERR_DEV,0,NO_RESPTYPE,(BYTE)UTIL_MSG);     /*;AN000;6*/
      usererror(retcode);
    }
   /************************************************************************/
   /* call DosSetFileInfo: Set date and time in dest file as the same date */
   /* and time in finfo 						   */
   /************************************************************************/
   fileinfo_buf.write_date = finfo->fdate;
   fileinfo_buf.write_time = finfo->ftime;
   retcode = DOSSETFILEINFO (
       (unsigned)dest_file_handle,	/* File handle */
       (unsigned)1,			/* File info data required */
       (char far *)&fileinfo_buf,	/* File info buffer */
       (unsigned)buflen);		/* File info buffer size */

   /*if fail, unexperror "file creation error"*/
   if (retcode != NOERROR)
    { display_it(FILE_CREATION_ERROR,STND_ERR_DEV,0,NO_RESPTYPE,(BYTE)UTIL_MSG);     /*;AN000;6*/
      usererror(retcode);
    }

   /******************************************************************/
   /*close dest file						     */
   /******************************************************************/
   DOSCLOSE(dest_file_handle);

   /******************************************************************/
   /*DosSetFileMode to set file attrib of d:infspec(from input line) */
   /*to be the attrib in finfo structure			     */
   /******************************************************************/
   finfo->attrib = finfo->attrib & 0xffdf;
   retcode =
    DOSSETFILEMODE
     (
      (char far *)dest_file_spec,
      (unsigned) finfo->attrib, (DWORD) 0
     );


   /******************************************************************/
   /*reset flag PARTIAL 					     */
   /******************************************************************/
   set_reset_test_flag(&control_flag,PARTIAL,RESET);

return(0);	/* wrw! */

} /*end of subroutine*/

/****************  START OF SPECIFICATION  ********************************
/*
/*  SUBROUTINE NAME :  dos_write_error
/*
/*  DESCRIPTIVE NAME : Determine the cause of the error during
/*		       DOS write, and output message according to it.
/*
/*  FUNCTION:  If error returned from get free space of the disk
/*	       is caused by disk full, a message "target disk is
/*	       full" is output to the user.
/*	       Otherwise, the error is caused by other reason, and
/*	       a message "file creation error" is output to the user.
/*
/*
/********************** END OF SPECIFICATIONS *******************************/
int dos_write_error(buf_size,destd)
DWORD buf_size;
BYTE destd;
{
   DWORD free_space;
   WORD drive_num;
   struct fsinfo *fsinfo_buf;

   WORD retcode;

   /******************************************************************/
   /*DosQFsinfo: get free space in the hard disk		     */
   /******************************************************************/
   drive_num = destd - 'A' + 1;
   retcode = DOSQFSINFO
      ((unsigned)drive_num,	      /* Drive number - 0=default, 1=A, etc */
       (unsigned)1,		      /* File system info required */
       (char far *)fsinfo_buf,	      /* File system info buffer */
       (unsigned)FSINFO_BYTES	      /* File system info buffer size */
      );


   free_space = fsinfo_buf->sectors_per_alloc_unit *
		fsinfo_buf->available_alloc_unit *
		fsinfo_buf->bytes_per_sector;


   /******************************************************************/
   /*if the free space left is less than buffer size for file read   */
   /* and write, output msg "target is full", and "file creation     */
   /* error", otherwise, output "file creation error".               */
   /******************************************************************/
   if ( free_space < buf_size)
    { display_it(TARGET_IS_FULL,STND_ERR_DEV,0,NO_RESPTYPE,(BYTE)UTIL_MSG);	     /*;AN000;6*/

      /*close dest file*/
      DOSCLOSE(dest_file_handle);

      if ((retcode = DOSDELETE((char far *)&dest_file_spec[0],
	 (DWORD)0)) != 0)
       {
	 /*set file mode to 0*/
	 retcode =
	   DOSSETFILEMODE
	    (
	     (char far *)&dest_file_spec[0],
	     (unsigned) 0x00,
	     (DWORD)0
	    );

	 /* delete the partially completed destination file*/
	 retcode = DOSDELETE((char far *) dest_file_spec,(DWORD)0);
       }

      display_it(LAST_FILE_NOT_RESTORED,STND_ERR_DEV,0,NO_RESPTYPE,(BYTE)UTIL_MSG);  /*;AN000;6*/
      usererror(TARGETFULL);
   }
   else
    { display_it(FILE_CREATION_ERROR,STND_ERR_DEV,0,NO_RESPTYPE,(BYTE)UTIL_MSG);     /*;AN000;6*/
      usererror(CREATIONERROR);
    }
   /*endif*/

	return(0);	/* wrw! */

}/*end of subroutine*/
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\restore\rtold.c ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

/******************************************************************************
*
*  Change Log:
*
*    Date    Who   #                      Description
*  --------  ---  ---  ------------------------------------------------------
*  07/02/90  EGH  C01  Added support for doing a directory of backed up
*                      diskettes via the /D option.
*
******************************************************************************/

/*----------------------------
/* SOURCE FILE NAME:   RTOLD.C
/*----------------------------
/*  0 */

#include "rt.h"
#include "rt1.h"
#include "rt2.h"
#include "restpars.h"                                                    /*;AN000;4*/
#include "string.h"
#include "dos.h"                                                      /*;AN000;2*/
#include "comsub.h"             /* common subroutine def'n */
#include "doscalls.h"
#include "error.h"

extern BYTE rtswitch;
extern BYTE rtswitch2;                                                  /*C01*/
extern BYTE control_flag;
extern BYTE control_flag2;
extern BYTE far *buf_pointer;
extern unsigned src_file_handle;
extern struct FileFindBuf filefindbuf;
extern struct  subst_list sublist;				      /*;AN000;6 Message substitution list */

/*****************  START OF SPECIFICATION  *********************************/
/*									    */
/*  SUBROUTINE NAME :  search_src_disk_old				    */
/*									    */
/*  DESCRIPTIVE NAME : For old format only, search the entire disk for	    */
/*		       matching files.					    */
/*									    */
/*  FUNCTION: Using find first and find next to find all the files	    */
/*	      which match the filename specified in the input		    */
/*	      cammand line.						    */
/*									    */
/*	      Whenever there is a file found, subroutine filespecmatch	    */
/*	      is called to match the file path, and file extension.	    */
/*	      If file path and file extension match the specification,	    */
/*	      subroutine switchmatch is called to match the file	    */
/*	      attributes, file modes, time, and date, then file sequence    */
/*	      number is checked.					    */
/*									    */
/*	      If the file matches all the specification, subroutine	    */
/*	      restore_a_file is called to actually restore the file.	    */
/*									    */
/*									    */
/********************** END OF SPECIFICATIONS *******************************/
void search_src_disk_old(dinfo,finfo,dheadold,dheadnew,fheadnew, /* wrw! */
		    srcd,destd,buf_size,dnumwant,
		    inpath,infname,infext,infspec,td)

     struct disk_info *dinfo;
     struct file_info *finfo;
     struct disk_header_old *dheadold;
     struct file_header_new far *fheadnew;
     struct disk_header_new far *dheadnew;
     BYTE   srcd;
     BYTE   destd;
     unsigned long buf_size;
     unsigned int *dnumwant;
     unsigned char *inpath;
     unsigned char *infname;
     unsigned char *infext;
     unsigned char *infspec;
     struct timedate *td;

{
     BYTE outstring[MAXPATH+MAXFSPEC];
     WORD    file_seq_num=1;
     WORD    first_file_on_diskette = TRUE;
     WORD    first_time_in_loop = TRUE;
     WORD return_code;
     DWORD partsize;
     unsigned int control_bufsize;
     BYTE temp_fname[MAXFNAME];
     BYTE temp_path[MAXPATH];
     WORD  temp_dirhandle;


    /*declaration for dosfindfirst */
    unsigned	dirhandle = 0xffff;	    /* directory handle 	    */
    unsigned	search_cnt = 1; 	    /* # of entries to find	    */
    unsigned	buf_len = sizeof(struct FileFindBuf);
    BYTE search_string[MAXPATHF+2];
    WORD retcode;
    /*end decleration for ffirst and fnext*/
    union REGS qregs;						      /*;AN000;8*/
    int    x;							      /*;AN000;8*/

/*************************************************************************/
/*  FIND THE FIRST FILE ON SOURCE					 */
/*************************************************************************/
  search_string[0] = srcd;
  search_string[1] = ':';
  search_string[2] = NULLC;
  strcat(search_string, infname);
  strcat(search_string, ".*");

retcode =				/* Find the 1st filename that	*/
  DOSFINDFIRST( 			/*   matches specified file spec*/
     ( char far * ) search_string,	/* File path name		*/
     ( unsigned far * ) &dirhandle,	/* Directory search handle	*/
     (unsigned) NOTV,			 /* Search attribute		*/
     (struct FileFindBuf far *) &filefindbuf,
     buf_len,				/* Result buffer length 	*/
     ( unsigned far * ) &search_cnt,	/* Number of entries to find	*/
     ( DWORD) 0
  );


/*************************************************************************/
/*  IF CANNOT FIND ANY FILES ON SOURCE, RETURN				 */
/*************************************************************************/
  if (retcode != 0)
     return;




/*************************************************************************/
/* start DO loop to find next until no more file found			 */
/*************************************************************************/
do
{
	/*if the directory found is a subdirectory, find next one*/
	if((retcode = filefindbuf.attributes & 0x0010) != 0x0010)
	{
	   /* SKIP BACKUPID */
	  if (strcmp(filefindbuf.file_name,BACKUPID) != 0)
	  {
	       if (first_time_in_loop == FALSE)
		 DOSCLOSE(src_file_handle);
	       else
		 first_time_in_loop = FALSE;

	       /*************************************************************************/
	       /*check_flheader_old: open and read file header, 			*/
	       /*************************************************************************/
	       strcpy(temp_fname,filefindbuf.file_name);
	       retcode = check_flheader_old( finfo, temp_fname,
		     filefindbuf.write_date, filefindbuf.write_time,
		     filefindbuf.attributes, filefindbuf.file_size,
		     file_seq_num, srcd, destd, infspec, inpath, dnumwant);

	    if (retcode == 0) {

	       /*************************/
	       /* SKIP SYSTEM FILES	*/
	    if ((set_reset_test_flag(&control_flag2,CPPC,TEST) == FALSE) &&
	       (strcmp(finfo->fname,"IBMBIO.COM")==0 ||
		strcmp(finfo->fname,"IBMDOS.COM")==0 ||
		strcmp(finfo->fname,"COMMAND.COM")==0 ||
                strcmp(finfo->fname,"MSDOS.SYS") == 0 ||
                strcmp(finfo->fname,"IO.SYS") == 0 ||
                strcmp(finfo->fname,"CMD.EXE") == 0 ))
	    {}
	    else {

	       /*************************************************************************/
	       /*if there is any switches set in the input line 			*/
	       /*switchmatch (this subroutine search the hard disk for the dest 	*/
	       /*************************************************************************/
	    if ((set_reset_test_flag(&control_flag,SWITCHES,TEST) == FALSE) ||
	       (set_reset_test_flag(&control_flag,SWITCHES,TEST) == TRUE &&
	       ((retcode = switchmatch(finfo, srcd, destd, td)) == TRUE) )) {

	       /*************************************************************************/
	       /*if dnum in fheadold.disknum is not 1 and is not in sequence, error    */
	       /*************************************************************************/
	    if (set_reset_test_flag(&control_flag2,OUTOF_SEQ,TEST) == TRUE &&
	       first_file_on_diskette == TRUE && finfo->dnum != 1)
	    {}
	    else
	    {
		if (finfo->dnum != 1 || finfo->dnum != file_seq_num)
		{
		   display_it(FILE_SEQUENCE_ERROR,STND_ERR_DEV,0,NO_RESPTYPE,(BYTE)UTIL_MSG); /*;AN000;6*/
		   unexperror(FILESEQERROR);
		}
		   /*endif*/
	       /*************************************************************************/
	       /* output msg to indicate which file is to be restored			*/
	       /*************************************************************************/
		/*outstring = inpath\infspec*/
		strcpy(outstring,finfo->path);
		if (strlen(finfo->path) != 1 )
		   strcat(outstring,"\\");

		strcat(outstring,finfo->fname);
		x = strlen(outstring);
		outstring[x] = CR;						  /*;AN000;6*/
		outstring[x+1] = LF;						  /*;AN000;6*/
		outstring[x+2] = NUL;						  /*;AN000;6*/
		qregs.x.ax = 0x4000;						  /*;AN000;6*/
		qregs.x.bx = 0x0001;						  /*;AN000;6*/
		qregs.x.cx = (WORD)strlen(outstring);				  /*;AN000;6*/
		qregs.x.dx = (unsigned int)&outstring[0];			  /*;AN000;6*/
		intdos(&qregs,&qregs);						  /*;AN000;6*/


	       /*************************************************************************/
	       /* call restore_a_file to restore the file				*/
	       /*************************************************************************/
                if (set_reset_test_flag(&rtswitch2,DIR,TEST) == TRUE)   /*C01*/
                    set_reset_test_flag(&control_flag,FOUND,SET);       /*C01*/
                else                                                    /*C01*/
                    restore_a_file(finfo,dinfo,buf_size,&control_bufsize,
			  fheadnew,dheadold,dheadnew,
			  srcd,destd,inpath,infname,infspec,dnumwant,&dirhandle);

	       first_file_on_diskette = FALSE;

	       /*************************************************************************/
	       /* if the file just restored is a split file, and last file, exit loop	*/
	       /*************************************************************************/
	       if (set_reset_test_flag(&control_flag,SPLITFILE,TEST)==TRUE)
	       {
		  set_reset_test_flag(&control_flag,SPLITFILE,RESET);

		  if (dirhandle == 0xffff)
		    break;
		  else
		  {
		    retcode = 0;
		    continue;
		  }
	       } /*end of if file splitted*/


	    } /*end of if disk and file out of sequence*/
	    } /*end of switch match fail*/
	    } /*end of PC/DOS and it is system files*/
	    } /*end of if check file header is ok */
	  } /*end of if file name is not BACKUPID*/
	} /*end of if the directory found is a subdirectory*/

	    search_cnt = 1;

	    retcode =
	      DOSFINDNEXT
		(dirhandle,
		 (struct FileFindBuf far *)&filefindbuf,
		 buf_len,
		 (unsigned far *)&search_cnt
		);

}
while(retcode == 0);	/* END MAIN DO LOOP */

DOSCLOSE(src_file_handle);
/*************************************************************************/
/* if error during findnext, error exit 				 */
/*************************************************************************/
    if (retcode != ERROR_NO_MORE_FILES && retcode != 0)
    {
      com_msg(retcode);
      unexperror(retcode);
    }


    if (dirhandle != 0xffff)
    {
       if ((retcode = DOSFINDCLOSE(dirhandle)) != 0)
       {
	 com_msg(retcode);
	 unexperror(retcode);
       }
    }


return;
} /*end of subroutine*/
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\restore\wrwdefs.h ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */



	/* built in 'c' functions */

	int	sprintf();
	int	printf();
	char	*strcat(char *,char *);
	int	strlen(char *);
	char	*strcpy(char *, char *);
	int	strncmp(char *,char *,unsigned int);
	int	strcmp(char *,char *);

	/* li functions */
	int	chdir(char *);
	int	mkdir(char *);

	void	search_src_disk_old(struct disk_info *,
				    struct file_info *,
				    struct disk_header_old *,
				    struct disk_header_new far *,
				    struct file_header_old *,
				    struct file_header_new far *,
				    unsigned char,
				    unsigned char,
				    unsigned long,
				    unsigned int *,
				    unsigned char *,
				    unsigned char *,
				    unsigned char *,
				    unsigned char *,
				    struct timedate *);

	void	search_src_disk_new(struct disk_info *,
				    struct file_info *,
				    struct disk_header_old *,
				    struct disk_header_new far *,
				    struct file_header_old *,
				    struct file_header_new far *,
				    unsigned char,
				    unsigned char,
				    unsigned int *,
				    unsigned long,
				    unsigned char *,
				    unsigned char *,
				    unsigned char *,
				    unsigned int *,
				    struct timedate *);


	int findfirst_new( struct file_info *,
			   unsigned int *,
			   unsigned int *,
			   unsigned char *,
			   unsigned char *,
			   unsigned int far**,
			   unsigned int far**,
			   unsigned int *,
			   unsigned char *);


	void restore_a_file(struct file_info *,
			   struct disk_info *,
			   unsigned long,
			   unsigned int *,
			   struct file_header_old *,
			   struct file_header_new far *,
			   struct disk_header_old *,
			   struct disk_header_new far *,
			   unsigned char,
			   unsigned char,
			   unsigned char *,
			   unsigned char *,
			   unsigned char *,
			   unsigned int *,
			   unsigned int *);


=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\restore\rtold1.c ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */


/*-------------------------------
/* SOURCE FILE NAME:   RTOLD1.C
/*-------------------------------
/*  0 */

#include "rt.h"
#include "rt1.h"
#include "rt2.h"
#include "restpars.h"                                                 /*;AN000;4*/
#include "string.h"
#include "dos.h"                                                      /*;AN000;2*/
#include "comsub.h"             /* common subroutine def'n */
#include "doscalls.h"
#include "error.h"
#include "stdio.h"

extern	BYTE rtswitch;
extern	BYTE rtswitch7; 		 /* MR001+ /Z: and /Y: flags	      */
extern	BYTE control_flag;
extern	BYTE control_flag2;
extern	char far *buf_pointer;
extern	unsigned src_file_handle;
extern	struct FileFindBuf filefindbuf;
extern	struct FileFindBuf dfilefindbuf;
BYTE	src_fname[MAXFSPEC];
extern	struct	subst_list sublist;				      /*;AN000;6 Message substitution list */
extern	char response_buff[5];					      /*;AN000;6*/
struct	file_header_old fheadold;				      /*;AN000;*/

/*****************  START OF SPECIFICATION  ********************************
/*
/*  SUBROUTINE NAME :  pathmatch
/*
/*  DESCRIPTIVE NAME : Compare two paths and return TRUE or FALSE
/*		       according to whether they match or not.
/*
/*  NOTES: Global characters * and ? are meaningless in the file path name
/*	   Assume both path pattern and path subject are not end with \
/*
/*  INPUT: (PARAMETERS)
/*	 subject  - the file path to be compared.
/*	 pattern  - the file path to be compared against.
/*
/********************** END OF SPECIFICATIONS *******************************/
WORD pathmatch(patterns,subjects)

BYTE *patterns;  /* the string to be matched with */
BYTE *subjects;  /* the string to be matched */
{
    BYTE *pattern;   /* the working pointer to point to the pattern */
    BYTE *subject;   /* the working pointer to point to the subject */
    int z;

    /*save the pointers to both strings*/
    pattern = patterns;
    subject = subjects;

    /* loop until matched or unmatched is determined */
    for (;;)
    {
	if (*pattern == *subject)
	 {
	  if (*pattern != NULLC)   /* not finish scanning yet*/
	    {
	      pattern+=1;	    /* advance the pointer by 1 */
	      subject+=1;	    /* advance the pointer by 1 */
	      continue; 	    /* continue on comparing again */
	    }
	  else
	    return(TRUE);
	 }
       else
	{   /* if subject is longer than pattern and SUB flag in rtswitches is on  */
	    if (set_reset_test_flag(&rtswitch, SUB, TEST)==TRUE)
	     {
	       if ((*pattern == NULLC && *subject == '\\') ||
		  (patterns[0] == '\\' && patterns[1] == NULLC))
		return(TRUE);
	       else
		return(FALSE);
	     }
	    else
	     return(FALSE);
	}
    }
  return(TRUE); 							/*;AN000;*/
}

/*****************  START OF SPECIFICATION  ********************************
/*
/*  SUBROUTINE NAME :  fspecmatch
/*
/*  DESCRIPTIVE NAME : Compare two file spec. and return TRUE or FALSE
/*		       according to whether they match or not.
/*
/*  FUNCTION: This subroutine compare the file names and file extensions
/*	      to determine whether they are match or not.
/*	      TRUE is returned if they are match, otherwise, FALSE
/*	      is returned.
/*
/*  NOTES: * and ? are acceptable in the file name and file extension.
/*
/********************** END OF SPECIFICATIONS *******************************/
fspecmatch(patterns, subjects)
char *patterns;
char *subjects;
{
	char *pattern;
	char *subject;
	int z;

	pattern = patterns;
	subject = subjects;

	for (;;)
	 {
	  if (*pattern == '*')
	   {
	     /*advance pointer in pattern until find '.' or nullc*/
	     for (;*pattern != '.' && *pattern != NULLC; ++pattern);
	     if (*pattern == NULLC)
	      {

		 /* pattern has no extension, so make sure subject doesn't either */
		 /* find end or '.' in subject */

		 for (;*subject != '.' && *subject != NULLC; ++subject);

		 if (*subject == NULLC || *(subject+1) == '.')
		   return(TRUE);
		  else	/* subject has extension, so return FALSE */
		   return(FALSE);
	      }
	     else
	      {
		if ( *(pattern+1) == '*')
		   return(TRUE);
		 else
		  {
		    /*advance pointer in subject until find '.' or nullc*/
		    for (;*subject != '.' && *subject != NULLC; ++subject);
		    if (*subject == NULLC )
		     {
		      if (*(pattern+1) != NULLC)
			return(FALSE);
		       else
			return(TRUE);
		      }
		     else
		      {
			pattern+=1;
			subject+=1;
			continue;
		      } /*end of if *subject is not NULL*/
		  }  /*end of if *(pattern+1) is not '*' */
	      } /*end of if *pattern == NULLC */
	   }
	  else
	   {
	    if (*pattern == *subject || *pattern == '?')
	     {
		 if (*pattern != NULLC)
		  {
		    pattern+=1;
		    subject+=1;
		    continue;
		  }
		 else
		  return(TRUE);
	     }
	    else
	       if (*pattern == '.' && *(pattern+1) == '*' && *subject == NULLC)
		 return(TRUE);
		else
		 return(FALSE);
	   }

	}    /*end of for loop*/

}  /*end of subroutine */

/*****************  START OF SPECIFICATION  ********************************
/*
/*  SUBROUTINE NAME :  switchmatch
/*
/*  DESCRIPTIVE NAME : Check the file attributes, and/or file modes
/*		       against the switches set in the input command
/*		       line.
/*
/*  FUNCTION: this subroutine search the hard disk for the dest
/*	      file first.  If dest file is found,  the attributs of the
/*	      destination file will be used for checking.
/*
/*	      Check the switches set in the input command line one by
/*	      one, whenever a  switch not match is found, FALSE is returne
/*	      In the case a switch is match, TRUE is not returned until al
/*	      switches is checked.
/*
/*
/********************** END OF SPECIFICATIONS *******************************/
WORD switchmatch(finfo, srcd, destd, td)
struct file_info *finfo;
BYTE srcd;
BYTE destd;
struct timedate *td;
{
     WORD   yy;
     WORD   mm;
     WORD   dd;
     WORD   hh;
     WORD   mn;
     WORD   ss;
     WORD  action;
     unsigned file_pointer;
     WORD retcode;
     int z;

     /*declaration for dosqfileinfo*/
     struct FileStatus fileinfo_buf;
     WORD destdnum;
     WORD buflen = sizeof(struct FileStatus);
     unsigned attributes;

     /*declaration for dosfindfirst */
     unsigned	 ddirhandle = 0xffff;
     unsigned	 attribute = NOTV;
     unsigned	 search_cnt = 1;
     unsigned	 buf_len = sizeof(struct FileFindBuf);
     BYTE search_string[MAXPATHF+2];
     /*end decleration for ffirst and fnext*/

								    /* MR001+ */
   /****************************************************************** MR001+ */
   /*if user requested restore of a file with a specified date	       MR001+ */
   /*via /Z:date then extract components of restore file date.	       MR001+ */
   /****************************************************************** MR001+ */
   if (set_reset_test_flag(&rtswitch7,EXACT_DATE,TEST) == TRUE) {   /* MR001+ */
       /*convert the restore file date into correct numbers.*/	    /* MR001+ */
       /*the input date is in the form of: yyyyyyymmmmddddd*/	    /* MR001+ */
	 yy = (finfo->fdate >> YRSHIFT & YRMASK) + LOYR;	    /* MR001+ */
	 mm =  finfo->fdate >> MOSHIFT & MOMASK;		    /* MR001+ */
	 dd =  finfo->fdate & DYMASK;				    /* MR001+ */
	 printf("***DEBUG*** Restore file date is %02d-%02d-%02d\n", /*DEBUG*/
						    yy,  mm,  dd);   /*DEBUG*/
	 printf("***DEBUG*** Requested date is    %02d-%02d-%02d\n", /*DEBUG*/
						    td->exact_year,  /*DEBUG*/
						    td->exact_month, /*DEBUG*/
						    td->exact_day);  /*DEBUG*/
								    /* MR001+ */
   /****************************************************************** MR001+ */
   /*  if date of file to be restored does not match the date	       MR001+ */
   /*  specified by the user then bypass the file.		       MR001+ */
   /****************************************************************** MR001+ */
	 if ( ( yy != td->exact_year  ) ||			    /* MR001+ */
	      ( mm != td->exact_month ) ||			    /* MR001+ */
	      ( dd != td->exact_day   ) ) {			    /* MR001+ */
	       return(FALSE);					    /* MR001+ */
	 }							    /* MR001+ */
   }								    /* MR001+ */
   /*endif*/							    /* MR001+ */
								    /* MR001+ */
   /****************************************************************** MR001+ */
   /*if user requested restore of a file with a specified time	       MR001+ */
   /*via /Y:time then extract components of restore file time	       MR001+ */
   /****************************************************************** MR001+ */
   if (set_reset_test_flag(&rtswitch7,EXACT_TIME,TEST) == TRUE) {   /* MR001+ */
       /*convert the restore file time into correct numbers.*/	    /* MR001+ */
       /*the input time is in the form of: hhhhhmmmmmmsssss*/	    /* MR001+ */
	 hh =  finfo->ftime >> HRSHIFT & HRMASK;		    /* MR001+ */
	 mn =  finfo->ftime >> MNSHIFT & MNMASK;		    /* MR001+ */
	 ss =  finfo->ftime & SCMASK;				    /* MR001+ */
#ifdef debug
	 printf("***DEBUG*** Restore file time is %02d:%02d:%02d\n", /*DEBUG*/
						    hh,  mn,  ss);   /*DEBUG*/
	 printf("***DEBUG*** Requested time is    %02d:%02d:%02d\n", /*DEBUG*/
						    td->exact_hour,  /*DEBUG*/
						    td->exact_minute,/*DEBUG*/
						    td->exact_second);/*DEBUG*/
#endif
								    /* MR001+ */
   /****************************************************************** MR001+ */
   /*  if time of file to be restored does not match the time	       MR001+ */
   /*  specified by the user then bypass the file.		       MR001+ */
   /****************************************************************** MR001+ */
	 if ( ( hh != td->exact_hour  ) ||			    /* MR001+ */
	      ( mn != td->exact_minute) ) { 			    /* MR001+ */
/*	      ( ss != td->exact_second) ) {	*/		    /* MR001+ */
	       return(FALSE);					    /* MR001+ */
	 }							    /* MR001+ */
   }								    /* MR001+ */
   /*endif*/							    /* MR001+ */
								    /* MR001+ */


   /***********************************************************************/
   /* Search hard file for the path and name of file about to be restored */
   /* and get the file information of the file on the hard disk 	  */
   /***********************************************************************/
     search_string[0] = destd;
     search_string[1] = ':';
     search_string[2] = NULLC;
     strcat(search_string, finfo->path);
     if (strlen(finfo->path) != 1)
	strcat(search_string, "\\");
     strcat(search_string, finfo->fname);

      retcode = DOSOPEN( (char far *)&search_string[0],
		      (unsigned far *)&file_pointer,
		      (unsigned far *)&action,
		      (DWORD)0,    /*file size*/
		      0,		   /*file attribute*/
		      0x01,		   /*if file exist, open*/
					   /*if file not exist, fail*/
		      0x00c0,		   /*deny write, read write access*/
		      (DWORD)0 );  /*reserved*/
   /***********************************************************************/
   /*if open fail (means the file does not exist on the hard disk), then  */
   /* return true							  */
   /***********************************************************************/
   if (retcode != NOERROR) {
	 /*set flag CREATIT*/
	 set_reset_test_flag(&control_flag,CREATIT,SET);
	 /*return TRUE*/
	 return (TRUE);
   }
   /*********************************************************************/
   /* call DosQFileInfo: Request date and time of the dest file 	*/
   /*********************************************************************/
   retcode = DOSQFILEINFO (
	     (unsigned)file_pointer,	      /* File handle */
	     (unsigned)1,		      /* File info data required */
	     (char far *)&fileinfo_buf,        /* File info buffer */
	     (unsigned)buflen); 	     /* File info buffer size */


   if (retcode != NOERROR) {
	com_msg(retcode);
	unexperror(retcode);
   }

   if ((retcode = DOSQFILEMODE((char far *)&search_string[0],
		  (unsigned far *) &attributes,
		  (DWORD) 0)) !=0) {
	com_msg(retcode);
	unexperror(retcode);
   }


   DOSCLOSE(file_pointer);
   /***********************************************************************/
   /*if NOTEXIST flag is on						  */
   /***********************************************************************/
   if (set_reset_test_flag(&rtswitch,NOTEXIST,TEST) == TRUE) {
	return(FALSE);
   }

   /***********************************************************************/
   /*if BEFORE or AFTER is on, convert date into integer form		  */
   /***********************************************************************/
   if  (set_reset_test_flag(&rtswitch,BEFORE,TEST) == TRUE ||
	set_reset_test_flag(&rtswitch,AFTER,TEST) == TRUE ) {
	/*convert the input date into correct numbers.*/
	/*Both new and old format have date in the form of date returned from*/
	/*ffirst*/
	/*the input date is in the form of: yyyyyyymmmmddddd*/
	 yy =  (fileinfo_buf.write_date >> YRSHIFT & YRMASK) + LOYR;
	 mm =  fileinfo_buf.write_date >> MOSHIFT & MOMASK;
	 dd =  fileinfo_buf.write_date & DYMASK;
   }
   /*endif*/

   /***********************************************************************/
   /*if BEFORE flag is on						  */
   /***********************************************************************/
   if  (set_reset_test_flag(&rtswitch,BEFORE,TEST) == TRUE) {
       if  ( yy > td->before_year ) {
	    return(FALSE);
      }

      if (yy == td->before_year && mm > td->before_month) {
	   return(FALSE);
      }

      if (yy == td->before_year && mm == td->before_month &&
      dd > td->before_day) {
	   return(FALSE);
      }
   }
   /*endif*/

   /***********************************************************************/
   /*if AFTER flag is on						  */
   /***********************************************************************/
   if (set_reset_test_flag(&rtswitch,AFTER,TEST) == TRUE) {
      if (yy < td->after_year ) {
	   return(FALSE);
      }

      if (yy == td->after_year && mm < td->after_month) {
	   return(FALSE);
      }

      if (yy == td->after_year && mm == td->after_month && dd < td->after_day) {
	   return(FALSE);
      }
   }
   /*endif*/

   /***********************************************************************/
   /*if EARLIER or LATER is on, convert date time into integer form	  */
   /***********************************************************************/
   if  (set_reset_test_flag(&rtswitch,EARLIER,TEST) == TRUE ||
	set_reset_test_flag(&rtswitch,LATER,TEST) == TRUE) {
	/* convert the input time into correct numbers. 		  */
	/* Both new and old format have time in the form of date returned */
	/* from ffirst. 						  */
	/* the input time is in the form of: hhhhhmmmmmmsssss		  */
	 hh =  fileinfo_buf.write_time >> HRSHIFT & HRMASK;
	 mn =  fileinfo_buf.write_time >> MNSHIFT & MNMASK;
	 ss =  fileinfo_buf.write_time & SCMASK;
   }
   /*endif*/

   /***********************************************************************/
   /*if EARLIER flag is on						  */
   /***********************************************************************/
   if (set_reset_test_flag(&rtswitch,EARLIER,TEST) == TRUE) {
      if (hh > td->earlier_hour) {
	   return(FALSE);
      }

      if (hh == td->earlier_hour && mn > td->earlier_minute) {
	   return(FALSE);
      }

      if (hh == td->earlier_hour && mn == td->earlier_minute &&
      ss > td->earlier_second) {
	   return(FALSE);
      }
   }
   /*endif*/

   /***********************************************************************/
   /*if LATER flag is on						  */
   /***********************************************************************/
   if  (set_reset_test_flag(&rtswitch,LATER,TEST) == TRUE) {
       if (hh < td->later_hour) {
	   return(FALSE);
       }

       if (hh == td->later_hour && mn < td->later_minute) {
	   return(FALSE);
       }

       if (hh == td->later_hour && mn == td->later_minute &&
       ss < td->later_second) {
	   return(FALSE);
       }
   }
   /*endif*/

   /*************************************************************************/
   /* if Revised flag is on and fileinfo->attrib indicate file has not */
   /* been Revised, return FALSE					    */
   /*************************************************************************/
   if (set_reset_test_flag(&rtswitch,Revised,TEST) == TRUE) {
      if((retcode = attributes & 0x0020) != 0x0020) {
	return(FALSE);
      }
   }
   /*endif*/

   /***********************************************************************/
   /* if PROMPT and fileinfo->file_attrib indicate READONLY, or CHANGED*/
   /***********************************************************************/
      if  ((set_reset_test_flag(&rtswitch,PROMPT,TEST) == TRUE) &&
	  (((retcode = attributes & 0x0001) == 0x0001) ||
	  ((retcode = attributes & 0x0020) == 0x0020) ))
      {
	  /*call subroutine to ask whether the user really wants to restore */
	  retcode = readonly_or_changed(attributes,destd,finfo->fname,finfo->path);
	  if  (retcode == FALSE) {
	      return(FALSE);
	  }
	  /*endif*/
      }
      /*endif*/

   /***********************************************************************/
   /* if pass all the switch testing, return TRUE			  */
   /***********************************************************************/
   return(TRUE);

} /*end of subroutine switch_match */

/*****************  START OF SPECIFICATION  ********************************
/*
/*  SUBROUTINE NAME :  check_flheader_old
/*
/*  DESCRIPTIVE NAME : Check the information in the file header of
/*		       the file to be restored.
/*
/*  FUNCTION: For old format only, Open the file to be restored, get
/*	      header informtion
/*
/*
/********************** END OF SPECIFICATIONS *******************************/
int check_flheader_old
     ( finfo,f_name,f_date,f_time,f_attrib,f_len,
       file_seq_num,srcd,destd,infspec,inpath,dnumwant
     )

     struct file_info *finfo;
     unsigned char *f_name;	   /* name string */
     unsigned f_date;		  /* file's date */
     unsigned f_time;		  /* file's time */
     unsigned f_attrib; 	  /* file's attribute */
     unsigned long f_len;	  /* file length */
     unsigned int  file_seq_num;
     BYTE     srcd;
     BYTE     destd;
     BYTE     *infspec;
     BYTE     *inpath;
     unsigned int  *dnumwant;
{
     WORD  temp_dnumwant;
     WORD  numread;
     WORD  action;
     BYTE file_to_be_opened[15];
     BYTE string_to_be_separate[79];
     BYTE path[65];
     BYTE name[9];
     BYTE ext[4];
     BYTE spec[13];
     WORD  i;		 /*loop counter*/
     WORD retcode;
    int z;

   temp_dnumwant = *dnumwant;	/*to fix a bug that dosread change the
				value of dnumwant */


   /***********************************************************************/
   /*open the file to be restored as deny write and read access 	  */
   /***********************************************************************/
    strcpy(src_fname,f_name);
    file_to_be_opened[0] = srcd;
    file_to_be_opened[1] = ':';
    file_to_be_opened[2] = NULLC;
    strcat(file_to_be_opened,f_name);
    retcode = DOSOPEN( (char far *)&file_to_be_opened[0],
		      (unsigned far *)&src_file_handle,
		      (unsigned far *)&action,
		      (DWORD)0,    /*file size*/
		      0,		   /*file attribute*/
		      0x01,		   /*if file exist, open it*/
					   /*if file not exist, fail it*/
		      0x00c0,		   /*deny write, read only*/
		      (DWORD)0 );  /*reserved*/

    /*if open fail*/
    if (retcode != 0) {
       /****not able to restore the file****/
       display_it(NOT_ABLE_TO_RESTORE_FILE,STND_ERR_DEV,0,NO_RESPTYPE,(BYTE)UTIL_MSG); /*;AN000;6*/
       unexperror(retcode);
    }
    /*endif*/

   /***********************************************************************/
   /*read 128 bytes header information from the file into fheadold	  */
   /***********************************************************************/
    retcode = _dos_read( src_file_handle,
		  (void far *)&fheadold,
		  HEADLEN,
		  (unsigned *)&numread);
    /*if read fail*/
    if (retcode != 0 )
     {
      display_it(NOT_ABLE_TO_RESTORE_FILE,STND_ERR_DEV,0,NO_RESPTYPE,(BYTE)UTIL_MSG); /*;AN000;6*/
      unexperror(retcode);
     }
    /*end of if read fail */

    /*if the number of read is less than HEADLEN, return FALSE */
    if (numread != HEADLEN)
       return(FALSE);

			/* save disk  number */
    finfo->dnum = fheadold.disknum[1]* 10 + fheadold.disknum[0];

   if ((fheadold.wherefrom[0] != '\\')  && (fheadold.wherefrom[0] != '/'))
      return(FALSE);
   strcpy(string_to_be_separate,fheadold.wherefrom);
   separate(string_to_be_separate,path,name,ext,spec);

   /***********************************************************************/
   /* match the path and file spec.					  */
   /***********************************************************************/
   if
    (  pathmatch(inpath,path) == FALSE	  ||
       fspecmatch(infspec,spec) == FALSE
    )
    {
     *dnumwant = temp_dnumwant;
     return(FALSE);
    }

   /***********************************************************************/
   /*Store some information from filefindbuf into finfo 		  */
   /***********************************************************************/
       finfo->ftime = f_time;
       finfo->fdate = f_date;
       finfo->attrib = f_attrib;
       finfo->partsize = f_len;

   /***********************************************************************/
   /*Store filename and path information from fheadold into finfo	  */
   /***********************************************************************/
       strcpy(finfo->fname,spec);
       strcpy(finfo->path,path);

   /***********************************************************************/
   /* store some other information from fheadold to finfo		  */
   /***********************************************************************/
       if (fheadold.headflg == 0xff)
	  finfo->fflag= LAST_PART;
       else
	  finfo->fflag= 0;

    *dnumwant = temp_dnumwant;
    return(TRUE);

    /*return nothing*/

} /*end of subroutine*/


/*****************  START OF SPECIFICATION  ********************************
/*
/*  SUBROUTINE NAME :  readonly_or_changed
/*
/*  DESCRIPTIVE NAME : handle the situration that a read only file
/*		       or is found, or the file has been Revised.
/*
/*  FUNCTION: In the case that a readonly file is found, or the file
/*	      on the destination disk has been Revised since last backup,
/*	      this subroutine output a warning message to the user, and
/*	      prompt for user to enter yes or no depending on whether
/*	      the user wants to proceed restoring the file.
/*
/*
/********************* END OF SPECIFICATIONS ********************************/
#define CHECK_YES_NO	  0x6523				      /*;AN000;6*/
#define YES_NO_RESPTYPE   0xc1					      /*;AN000;6*/
#define YES 1							      /*;AN000;6*/

int readonly_or_changed(attrib,destd,fspec,fpath)

    unsigned attrib;
    unsigned char  destd;
    unsigned char  *fspec;
    unsigned char  *fpath;
{

     union REGS inregs, outregs;				      /*;AN000;6 Register set */
     WORD retcode;

    char file_to_be_chmode[MAXPATHF+2];
    DWORD dw = 0L;
    int z;

     sublist.value1 = (char far *)fspec;			      /*;AN000;6 */
     sublist.flags1 = LEFT_ALIGN + CHAR_FIELD_ASCIIZ;		      /*;AN000;6 */
     sublist.max_width1 = (BYTE)strlen(fspec);			      /*;AN000;6 */
     sublist.min_width1 = sublist.max_width1;			      /*;AN000;6 */

     /***********************************************************************/
     /* if readonly, output msg and wait for user's prompt                  */
     /***********************************************************************/
     do 							      /*;AN000;6*/
      { 							      /*;AN000;6*/
	if((retcode = attrib & 0x0001) == 0x0001)
	 display_it(FILE_IS_READONLY,STND_ERR_DEV,1,YES_NO_RESPTYPE,(BYTE)UTIL_MSG); /*;AN000;6*/
	else
	 display_it(FILE_WAS_CHANGED,STND_ERR_DEV,1,YES_NO_RESPTYPE,(BYTE)UTIL_MSG); /*;AN000;6*/


	inregs.x.ax = (unsigned)CHECK_YES_NO;			      /*;AN000;6*/
	inregs.h.dl = response_buff[0]; 			      /*;AN000;6*/
	int86(0x21,&inregs,&outregs);				      /*;AN000;6*/
	display_it(CRLF,STND_ERR_DEV,0,NO_RESPTYPE,(BYTE)UTIL_MSG);   /*;AN000;6*/
      } 							      /*;AN000;6*/
      while (outregs.h.al > 1); 				      /*;AN000;6*/

     /***********************************************************************/
     /* if user's input is 'Y', return TRUE, else return FALSE              */
     /***********************************************************************/
     if (outregs.x.ax == YES)					      /*;AN000;6*/
      { file_to_be_chmode[0] = destd;
	file_to_be_chmode[1] = ':';
	file_to_be_chmode[2] = NULLC;
	strcat(file_to_be_chmode,fpath);
	if (strlen(fpath) != 1)  {
	   strcat(file_to_be_chmode,"\\");
      }
	strcat(file_to_be_chmode,fspec);
	/* change the file attribute to be 0, that is, reset it */
	if ((retcode = DOSSETFILEMODE((char far *)file_to_be_chmode,(unsigned) 0x00, dw)) != 0)
	 {
	    com_msg(retcode);
	    unexperror(retcode);
	 }
	return(TRUE);
     }
     else  {
	return(FALSE);
     }
     /* endif  */
} /* end of subroutine readonly_or_changed */
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\restore\rtt2.c ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

static char *SCCSID = "@(#)rtt2.c       8.4 86/10/19";
/*  0 */
#include <direct.h>
#include "rt.h"
#include "rt1.h"
#include "rt2.h"
#include <comsub.h>			/* common subroutine def'n */
#include <doscalls.h>
#include <wrwdefs.h>		   /* wrw! */

extern unsigned char rtswitch;
extern unsigned char control_flag;
extern unsigned char control_flag2;
extern struct internat ctry;	       /* data area for country info*/

/*****************  START OF SPECIFICATION  *********************************/
/*									    */
/*  SUBROUTINE NAME :  valid_input_time 				    */
/*									    */
/*  DESCRIPTIVE NAME :	to validate and convert the time input from the     */
/*			command line.					    */
/*									    */
/*  FUNCTION: This subroutine validate the time input from the command lin  */
/*	      against the country dependent information, and convert	    */
/*	      the deta into three integers which are hour, minute, and	    */
/*	      second.							    */
/*  NOTES:								    */
/*									    */
/*  INPUT: (PARAMETERS) 						    */
/*	    in_string - the string from command line which contains date    */
/*		     information.					    */
/*  OUTPUT:								    */
/*	    inhour - the input hour after converted			    */
/*	    inminute - the input minute after converted 		    */
/*	    insecond - the input second after converted 		    */
/*									    */
/*  EXIT-NORMAL: returns TRUE if the time is valid			    */
/*									    */
/*  EXIT-ERROR:  returns FALSE if the time is invalid			    */
/*									    */
/*  EFFECTS:								    */
/*									    */
/*  INTERNAL REFERENCES:						    */
/*	   ROUTINES:							    */
/*		    usererror						    */
/*		    unexperror						    */
/*		    putmsg						    */
/*		    set_reset_test_flag 				    */
/*									    */
/*  EXTERNAL REFERENCES:						    */
/*	   ROUTINES:							    */
/*									    */
/********************** END OF SPECIFICATIONS *******************************/
int valid_input_time(in_string, inhour, inminute, insecond)
    unsigned char *in_string;  /*the input string			*/
    unsigned int  *inhour;     /*the input hour 			*/
    unsigned int  *inminute;   /*the input minute			*/
    unsigned int  *insecond;   /*the input second			*/
{
    unsigned char chour[10];
    unsigned char cminute[10];
    unsigned char csecond[10];
    unsigned int i,j,z;    /*working pointer*/
    unsigned int no_second = FALSE;
    unsigned char string[20];

    /*declaration for get country information*/
    unsigned int byte_len;
    unsigned buflen = sizeof( struct internat );    /* length of data area  */
    unsigned int retcode;
    long country = 0L;

   /************************************************/
   /* find the string for hour			   */
   /************************************************/
   #ifdef DEBUG
   printf("\ntime to be validate %s",in_string);
   #endif
   /*save the pointer of input string*/
   strcpy(string,in_string);

   /* search the first occurance of country->timesep */
   for (i = 0; (string[i] != NULLC) && (string[i] != ctry.timesep &&
   string[i] != ':' && string[i] != '.'); ++i);

   if (string[i] == NULLC) {  /*if not found*/
       #ifdef DEBUG
       printf("\nno time seperator");
       #endif
       return(FALSE);
   }

   string[i] = NULLC;	  /*replace it with NULLC*/

   /*get the string which represent hour*/
   strcpy(chour,string);
   /*put the rest of the string into cminute*/
   strcpy(cminute,string+i+1);

   /************************************************/
   /* validate hour				   */
   /************************************************/
   if (strlen(chour) > MAXHOURLEN || strlen(chour)<1 ) {
       #ifdef DEBUG
       printf("\ninvalid hour length");
       #endif
       return(FALSE);
   }

   /* convert the string into integer form*/
   *inhour = 0;
   for (j=0; chour[j] != NULLC ; ++j) {
       if (chour[j] < '0' || chour[j] > '9') {
	  #ifdef DEBUG
	  printf("\nhour value not 0-9");
	  #endif
	  return(FALSE);
       }
       *inhour = *inhour*10 + chour[j]-'0';
   }

   if (*inhour > 23 || *inhour < 0) {
	   #ifdef DEBUG
	   printf("\ninvalid hour value");
	   #endif
	   return(FALSE);
   }

   /************************************************/
   /* find the string for minute		   */
   /************************************************/
   /*search the next occurance of country->timesep*/
   for (i = 0; (cminute[i] != NULLC) && (cminute[i] != ctry.timesep &&
   cminute[i] != ':' && cminute[i] != '.'); ++i);

   if (cminute[i] == NULLC) {  /*if not found*/
      no_second = TRUE;
   }

   /*put NULLC at the end of string which represent minute*/
   cminute[i] = NULLC;	   /*replace it with NULLC*/
   strcpy(csecond,cminute+i+1);

   /************************************************/
   /* validate minute				   */
   /************************************************/
   if (strlen(cminute) > MAXMINUTELEN || strlen(cminute)<1 ) {
      #ifdef DEBUG
      printf("\ninvalid min length");
      #endif
      return(FALSE);
   }

   /*convert the string into integer*/
   *inminute = 0;
   for (j=0; cminute[j] != NULLC ; ++j) {
       if (cminute[j] < '0' || cminute[j] > '9')  {
	  #ifdef DEBUG
	  printf("\ninvalid min value, not 0-9");
	  #endif
	  return(FALSE);
       }
       *inminute = *inminute*10 + cminute[j]-'0';
   }

   if (*inminute > 59 || *inminute < 0) {
	   #ifdef DEBUG
	   printf("\ninvalid min value");
	   #endif
	   return(FALSE);
   }

   /***************************************************/
   /* if user input second, get the string for second */
   /***************************************************/
   if (no_second == TRUE)
       return(TRUE);
   else {

       /************************************************/
       /* validate second			       */
       /************************************************/
       if (strlen(csecond) > MAXSECONDLEN || strlen(csecond) < 1 ) {
	  #ifdef DEBUG
	  printf("\ninvalid second length");
	  #endif
	  return(FALSE);
       }

       /*convert the rest of the string into integer*/
       *insecond = 0;
       for (j=0; csecond[j] != NULLC; ++j)
       {
	   if (csecond[j] < '0' || csecond[j] > '9') {
	      #ifdef DEBUG
	      printf("\ninvalid second, 0-9");
	      #endif
	      return(FALSE);
	   }
	   *insecond = *insecond*10 + csecond[j]-'0';
       }

       if (*insecond > 59 || *insecond < 0) {
	       #ifdef DEBUG
	       printf("\ninvalid second value");
	       #endif
	       return(FALSE);
       }
   } /*end of if no_second is true */
   return(TRUE);

} /*end of subroutine*/
/*****************  START OF SPECIFICATION  *********************************/
/*									    */
/*  SUBROUTINE NAME :  valid_input_date 				    */
/*									    */
/*  DESCRIPTIVE NAME :	to validate and convert the date input from the     */
/*			command line.					    */
/*									    */
/*  FUNCTION: This subroutine validate the date input from the command lin  */
/*	      against the country dependent information, and convert	    */
/*	      the deta into three integers which are year, month, and day.  */
/*  NOTES:								    */
/*									    */
/*  INPUT: (PARAMETERS) 						    */
/*	    in_string - the string from command line which contains date    */
/*		     information.					    */
/*  OUTPUT:								    */
/*	    inyear - the input year after converted			    */
/*	    inmonth - the input month after converted			    */
/*	    inday - the input day after converted			    */
/*									    */
/*  EXIT-NORMAL: returns TRUE if the date is valid			    */
/*									    */
/*  EXIT-ERROR:  returns FALSE if the date is invalid			    */
/*									    */
/*  EFFECTS:								    */
/*									    */
/*  INTERNAL REFERENCES:						    */
/*	   ROUTINES:							    */
/*		    usererror						    */
/*		    unexperror						    */
/*		    putmsg						    */
/*		    set_reset_test_flag 				    */
/*									    */
/*  EXTERNAL REFERENCES:						    */
/*	   ROUTINES:							    */
/*									    */
/********************** END OF SPECIFICATIONS *******************************/
int valid_input_date(in_string,inyear,inmonth,inday)

    unsigned char *in_string;
    unsigned int  *inyear;
    unsigned int  *inmonth;
    unsigned int  *inday;
{
    unsigned char c1[10];
    unsigned char c2[10];
    unsigned char c3[10];
    unsigned char cyear[10];
    unsigned char cmonth[10];
    unsigned char cday[10];
    unsigned int  in1;
    unsigned int  in2;
    unsigned int  in3;
    unsigned int i,j,z;    /*working pointer*/
    unsigned char string[30];
    unsigned int  remainder;

   #ifdef DEBUG
   printf("\ndate to be validate %s",in_string);
   #endif
   /************************************************/
   /* separate the input date string into 3 parts  */
   /************************************************/
   /*save the pointer to the input string*/
   strcpy(string,in_string);

   /* search the first occurance of country->datesep */
   for (i = 0; (string[i] != NULLC) && (string[i] != ctry.datesep &&
   string[i] != '/' && string[i] != '-' && string[i] != '.'); ++i);

   if (string[i] == NULLC) {  /*if not found*/
      #ifdef DEBUG
      printf("\ninvalid date sep");
      #endif
      return(FALSE);
   }

   string[i] = NULLC;	  /*replace it with NULLC*/

   /*get the string which represent year*/
   strcpy(c1,string);
   /*put the rest of the string into c2*/
   strcpy(c2,string+i+1);

   /*search the next occurance of country->datesep*/
   for (i = 0; (c2[i] != NULLC) && (c2[i] != ctry.datesep &&
   c2[i] != '/' && c2[i] != '-' && c2[i] != '.'); ++i);

   if (c2[i] == NULLC) {  /*if not found*/
      #ifdef DEBUG
      printf("\nno 2nd date sep");
      #endif
      return(FALSE);
   }

   /*put NULLC at the end of string which represent month*/
   c2[i] = NULLC;     /*replace it with NULLC*/
   strcpy(c3,c2+i+1);

   /************************************************/
   /* convert all 3 strings to integers 	   */
   /************************************************/
   in1 = 0;
   for (j=0; c1[j] != NULLC ; ++j) {
       if (c1[j] < '0' || c1[j] > '9') {
	  #ifdef DEBUG
	  printf("\ninvalid 1st in date not 0-9");
	  #endif
	  return(FALSE);
       }
       in1 = in1*10 + c1[j]-'0';
   }

   in2 = 0;
   for (j=0; c2[j] != NULLC ; ++j) {
       if (c2[j] < '0' || c2[j] > '9') {
	  #ifdef DEBUG
	  printf("\ninvalid 2nd in date not 0-9");
	  #endif
	  return(FALSE);
       }
       in2 = in2*10 + c2[j]-'0';
   }

   in3 = 0;
   for (j=0; c3[j] != NULLC ; ++j) {
       if (c3[j] < '0' || c3[j] > '9') {
	  #ifdef DEBUG
	  printf("\ninvalid 3rd in date not 0-9");
	  #endif
	  return(FALSE);
       }
       in3 = in3*10 + c3[j]-'0';
   }
   /************************************************/
   /* identify what these 3 integers are stand for */
   /************************************************/
   switch (ctry.dtformat) {
	 case USA:
		   *inmonth = in1;
		   *inday   = in2;
		   *inyear  = in3;
		   strcpy(cmonth,c1);
		   strcpy(cday,c2);
		   strcpy(cyear,c3);
		   break;
	 case EUR:
		   *inday   = in1;
		   *inmonth = in2;
		   *inyear  = in3;
		   strcpy(cday,c1);
		   strcpy(cmonth,c2);
		   strcpy(cyear,c3);
		   break;
	 case JAP:
		   *inyear  = in1;
		   *inmonth = in2;
		   *inday   = in3;
		   strcpy(cyear,c1);
		   strcpy(cmonth,c2);
		   strcpy(cday,c3);
		   break;
	 default:
		   #ifdef DEBUG
		   printf("\ninvalid country code %d",ctry.dtformat);
		   #endif
		   unexperror(UNEXPECTED);
		   break;
   }
   /************************************************/
   /* validate the value of year		   */
   /************************************************/
   if (strlen(cyear) > MAXYEARLEN || strlen(cyear)<1 ) {
	  #ifdef DEBUG
	  printf("\ninvalid year len");
	  #endif
	  return(FALSE);
   }

   if (*inyear <= 99 && *inyear >= 80)
      *inyear = *inyear + 1900;
   if (*inyear <= 79 && *inyear >= 00)
      *inyear = *inyear + 2000;

   /*validate the value of year  */
   if (*inyear > MAXYEAR || *inyear < MINYEAR) {
	  #ifdef DEBUG
	  printf("\ninvalid year value");
	  #endif
	  return(FALSE);
   }

   /************************************************/
   /* validate the value of month		   */
   /************************************************/
   if (strlen(cmonth) > MAXMONTHLEN || strlen(cmonth)<1 ) {
	  #ifdef DEBUG
	  printf("\ninvalid month length");
	  #endif
	  return(FALSE);
    }

   /*validate the value of year  */
   if (*inmonth > MAXMONTH || *inmonth <= 0) {
	  #ifdef DEBUG
	  printf("\ninvalid month value");
	  #endif
	  return(FALSE);
   }

   /************************************************/
   /* validate the value of day 		   */
   /************************************************/
   if (strlen(cday) > MAXDAYLEN || strlen(cday)<1 ) {
	  #ifdef DEBUG
	  printf("\ninvalid day len");
	  #endif
	  return(FALSE);
   }

   /*validate the value of year  */
   if (*inday > MAXDAY || *inday <= 0 )  {
	   #ifdef DEBUG
	   printf("\ninvalid day value");
	   #endif
	   return(FALSE);
    }
   if ((*inmonth == 1 || *inmonth == 3 || *inmonth == 5 ||
	*inmonth == 7 || *inmonth == 8 || *inmonth == 10 ||
	*inmonth == 12 ) && (*inday > 31 || *inday < 1)) {
	   #ifdef DEBUG
	   printf("\ninvalid day value");
	   #endif
	   return(FALSE);
   }
   else  {
       if ((*inmonth == 4 || *inmonth == 6 || *inmonth == 9 ||
	    *inmonth == 11 ) && (*inday > 30 || *inday < 1)) {
	      #ifdef DEBUG
	      printf("\ninvalid day value");
	      #endif
	      return(FALSE);
       }
       else {
	if (*inmonth == 2) {
	  /*check for leap year */
	  remainder = *inyear % 4;
	  if (remainder == 0) {
	     if (*inday > 29 || *inday < 1) {
		#ifdef DEBUG
		printf("\ninvalid day value");
		#endif
		return(FALSE);
	     }
	  }
	  else {
	     if (*inday > 28 || *inday < 1) {
		#ifdef DEBUG
		printf("\ninvalid day value");
		#endif
		return(FALSE);
	     }
	  }
	}
       }
   }

   /************************************************/
   /* if there is no error found, return TRUE	   */
   /************************************************/
   return(TRUE);

} /*end of subroutine valid_input_date*/

/**************************/

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\restore\rtt3.c ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */


/*---------------------------------
/* SOURCE FILE NAME:  RTT3.C
/*---------------------------------
/*  0 */

#include "rt.h"
#include "rt1.h"
#include "rt2.h"
#include "direct.h"
#include "string.h"
#include "dos.h"                                                      /*;AN000;2*/
#include "comsub.h"             /* common subroutine def'n */
#include "doscalls.h"
#include "error.h"
#include "process.h"                                                  /*;AN000;p972*/

extern BYTE filename[12];
extern BYTE destddir[MAXPATH+3];
extern BYTE srcddir[MAXPATH+3];
extern BYTE rtswitch;
extern BYTE control_flag;
extern BYTE control_flag2;
char far *buf_pointer;
char far *control_buf_pointer;
unsigned control_selector;
extern BYTE dest_file_spec[MAXFSPEC];
extern unsigned dest_file_handle;
extern BYTE append_indicator;					      /*;AN000;2*/
extern WORD original_append_func;				      /*;AN000;2*/
extern struct  subst_list sublist;				      /*;AN000;6 Message substitution list */
extern char response_buff[5];					      /*;AN000;6*/
BYTE far *DBCS_ptr;						      /*;AN005;*/
char  got_dbcs_vector = FFALSE; 				      /*;AN005;*/

/*****************  START OF SPECIFICATION  ********************************
/*
/*  SUBROUTINE NAME :  set_reset_test_flag
/*
/*  DESCRIPTIVE NAME :	to set a flag, reset a flag, or test a flag.
/*
/*  FUNCTION: This subroutine is called when there is a need to set
/*	      a flag, reset a flag, or test a flag.
/*  NOTES:
/*
/*  INPUT: (PARAMETERS)
/*	    flag - the flag to be set, reset, or tested.
/*	    targetbt - the target bit to be set, reset, or tested.
/*	    choice - = 1 if want to set
/*		     = 2 if want to reset
/*		     = 3 if want to test
/*
/********************* END OF SPECIFICATIONS ********************************/
int set_reset_test_flag(flag,targetbt,choice)

     BYTE *flag;	/*the flag to be tested against*/
     BYTE targetbt;	/*the byte to be tested   */
     int choice;
{
     BYTE temp;


switch (choice) {
case SET:
	    *flag = *flag | targetbt;
	    break;

case RESET:
	    *flag = *flag & ~targetbt;
	    break;

case TEST:
	    temp = *flag & targetbt;
	    if (temp == 0) {
	       return(FALSE); /*the tested bit is off*/
	       }
	    else {
	       return(TRUE); /*the tested bit is on */
	       }
	    break;

default:
	    unexperror(UNEXPECTED);
	    break;
} /*end of switch */

	return(FALSE);		/* wrw! */

}
/*****************  START OF SPECIFICATION  ********************************
/*
/*  SUBROUTINE NAME :  separate
/*
/*  DESCRIPTIVE NAME : Separate the given input string into 3 parts;
/*		       which is the path, filename, file extension, and
/*		       file specification.
/*
/*  FUNCTION: The subroutine searches the input string for the last '\',
/*	      which separates the path and file specification, and then
/*	      searches the file specification for '.', which separates
/*	      the filename and file extension.	Also take care the
/*	      situation of the user enter '.' for file specification.
/*	      This subroutine also validate the file specification
/*	      and each path entered by the user by calling common
/*	      subroutine Comverflnm.
/*
/*  NOTE: The input string must start with '\'
/*	  All the output string are terminated by 00h
/*
/*  INPUT: (PARAMETERS)
/*	   instring - input string to be separated into path, filename,
/*		      and file extension.
/*
/*  OUTPUT:
/*	   path     - output path name, always starts with '\' and not end
/*		      with '\'
/*	   filename - output file name
/*	   fileext  - output file extension
/*	   filespec - output file name and file extension
/*
/********************** END OF SPECIFICATIONS *******************************/
void separate(instring,path,filename,fileext,filespec)
BYTE *instring; 	/* point to beginning of input string */
BYTE *path;		/* point to beginning of path string  */
BYTE *filename; 	/* point to beginning of file name    */
BYTE *fileext;		/* point to beginning of file ext.    */
BYTE *filespec; 	/* point to beginning of file spec    */
{
	BYTE *iptr;	 /* working pointer */
	BYTE *fptr;	 /* working pointer */
	WORD i; 						       /*;AN005;*/

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
		/* Find last non-DBCS backslash character */
/*    fptr = com_strrchr(instring,'\\');                              /*;AN000;p2532*/

      for (							       /*;AN005;*/
	   i=strlen(instring);					       /*;AN005;*/
	   (i>=0) && (!chek_DBCS(instring,i,'\\') && 
                     (!chek_DBCS(instring,i,'/')));                    /*;AN005;*/
	   i--							       /*;AN005;*/
	  )							       /*;AN005;*/
       {};							       /*;AN005;*/

      fptr = instring + i;					      /*;AN005;*/
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++*/

      if (fptr!=instring || instring[0] == '\\' || instring[0] == '/')
      {
	 *fptr = NULLC; 					 /*;AC000;*/
	 strcpy(path, instring);
	 for(i=0; i<strlen(path);i++)
	     if(path[i] == '/')
		path[i] = '\\';
	 if (path[0] == NULLC)
	   strcpy(path,"\\");
	 *fptr = '\\';
	 ++fptr;
	 strcpy(filespec, fptr);

	 if (filespec[0] == '.' && filespec[1] == NULLC)
	 {
	    strcpy(filename, "*");
	    strcpy(fileext, "*");
	    strcpy(filespec, "*.*");
	 }
	 else
	 {   /*else if filespec is not '.'*/
	    for (iptr = fptr; *iptr!='.' && *iptr != NULLC; ++iptr);

	    if (*iptr == '.')
	    {
		*iptr = NULLC;
		strcpy(filename, fptr);
		*iptr = '.';

	       iptr = iptr+1;
	       strcpy(fileext, iptr);
	    }
	    else
	    {
	       strcpy(filename, filespec);
	       *fileext = NULLC;
	    }

	 }

      }
      else
      {}

      return;
}





/*****************  START OF SPECIFICATION  ********************************
/*
/*  SUBROUTINE NAME :  initbuf
/*
/*  DESCRIPTIVE NAME : Initialize buffer for reading and writting.
/*
/*  FUNCTION: Allocate up to 64 K bytes buffer for reading and writing
/*	      data, and make sure its size is divisible by the sector
/*	      size of the restore drive.
/*
/*  NOTES:
/*
/********************** END OF SPECIFICATIONS *******************************/

void initbuf(bufsize_long)
    DWORD *bufsize_long;
{
    unsigned bufsize;
    WORD selector;
    WORD retcode;

   bufsize = MAXBUF;  /*64K-1 */
   /*do while allocate bufsize fail, bufsize = bufsize - DOWNSIZE*/
   for (;;) {
	retcode = DOSALLOCSEG( (unsigned ) bufsize,	/*buf length  */
			 ( unsigned far * ) &selector,	/* buf pointer*/
			 ( unsigned) 0 );		/* no sharing */
	if ( retcode != 0)
	{
	    if (bufsize > DOWNSIZE)
		bufsize = bufsize - DOWNSIZE;
	    else
	       break;
	}
	else
	   break;
   }
   if (bufsize != 0 && bufsize <= DOWNSIZE ) {
      display_it(INSUFFICIENT_MEMORY,STND_ERR_DEV,0,NO_RESPTYPE,(BYTE)UTIL_MSG);/*;AN000;6*/
      usererror(INSUFMEM);
    }

    FP_SEG( buf_pointer ) = selector;
    FP_OFF( buf_pointer ) = 0 ;

    if (bufsize == 0)
       *bufsize_long = (DWORD)MAXBUF;
    else
       *bufsize_long = (DWORD)bufsize;
} /*end of subroutine*/

/*****************  START OF SPECIFICATION  ********************************
/*
/*  SUBROUTINE NAME :  init_control_buf
/*
/*  DESCRIPTIVE NAME : Initialize buffer for control.XXX.
/*
/*  FUNCTION: Allocate buffer for reading in control.xxx
/*
/*  OUTPUT:
/*	   control_bufsize - the size of buffer
/*
/*
/********************** END OF SPECIFICATIONS *******************************/
void init_control_buf(control_file_len,control_bufsize) 	   /* !wrw */
    DWORD control_file_len;					   /* !wrw */
    unsigned int  *control_bufsize;				   /* !wrw */
{								   /* !wrw */
    unsigned bufsize;						   /* !wrw */
    WORD retcode;						   /* !wrw */

  bufsize = 3072;						   /* !wrw */


   retcode = DOSALLOCSEG( (unsigned ) bufsize,			     /* !wrw */
			 ( unsigned far * ) &control_selector,	     /* !wrw */
			 ( unsigned) 0 );			     /* !wrw */


   if ( retcode != 0)		/* If there is insufficient memory /* !wrw */
   {								   /* !wrw */
     display_it(INSUFFICIENT_MEMORY,STND_ERR_DEV,0,NO_RESPTYPE,(BYTE)UTIL_MSG);      /*;AN000;6*/
     usererror(INSUFMEM);
    }								   /* !wrw */

    FP_SEG( control_buf_pointer ) = control_selector;		   /* !wrw */
    FP_OFF( control_buf_pointer ) = 0 ; 			   /* !wrw */

    *control_bufsize = bufsize; 				   /* !wrw */

} /*end of subroutine*/ 					   /* !wrw */

/*****************  START OF SPECIFICATION  ********************************
/*
/*  SUBROUTINE NAME :  unexperror
/*
/*  DESCRIPTIVE NAME : exit the program because of something really bad
/*		       occures
/*
/*  FUNCTION: Exit the program because of unexpected error
/*
/*
/********************** END OF SPECIFICATIONS *******************************/
void unexperror(retcode)
WORD retcode;
{
     exit_routine(retcode);
     return;
}

/*****************  START OF SPECIFICATION  ********************************
/*
/*  SUBROUTINE NAME :  usererror
/*
/*  DESCRIPTIVE NAME : exit the program because of a user error
/*
/********************** END OF SPECIFICATIONS *******************************/
void usererror(retcode)
WORD retcode;
{
     unexperror(retcode);
     return;
}

/*****************  START OF SPECIFICATION  ********************************
/*
/*  SUBROUTINE NAME :  exit_routine
/*
/*  DESCRIPTIVE NAME : exit the program
/*
/*  FUNCTION: 1. output msg if there is a sharing error.
/*	      2. if PCDOS, convert return codes to error levels
/*	      3. exit the program
/*
/*  NOTES:
/*
/*  INPUT: (PARAMETERS)
/*	 retcode - the reason of error
/*
/*
/********************** END OF SPECIFICATIONS *******************************/
void exit_routine(retcode)
WORD retcode;
{
     union REGS regs;			   /*;AN000;2*/

     chdir (destddir);

     chdir (srcddir);

      /* if flag indicates there is a SHAREERROR */
      if (retcode == NORMAL &&
      set_reset_test_flag(&control_flag,SHARERROR,TEST)==TRUE)
	 retcode = SHARERR;

	 switch(retcode)
	  {
	   case  NORMAL:   retcode = PC_NORMAL;
			   break;
	   case  NOFILES:  retcode = PC_NOFILES;
			   break;
	   case  SHARERR:  retcode = PC_SHARERR;
			   break;
	   case  TUSER:    retcode = PC_TUSER;
			   break;
	   default:	   retcode = PC_OTHER;
			   break;
	  } /* end switch */


	if (append_indicator == DOS_APPEND)	/*;AN000;2 If append /x was reset*/
	 {					/*;AN000;2*/
	    regs.x.ax = SET_STATE;		/*;AN000;2*/
	    regs.x.bx = original_append_func;	/*;AN000;2*/
	    int86(0x2f,&regs,&regs);		/*;AN000;2*/
	 }					/*;AN000;2*/

     exit(retcode);				/*;AN000;p972*/

}
/*****************  START OF SPECIFICATION  ********************************
/*
/*  SUBROUTINE NAME :  signal_handler_routine
/*
/*  DESCRIPTIVE NAME :	handle the situation that the user terminate
/*			the program by Control-break.
/*
/*  FUNCTION: This subroutine change the directory of the
/*	      destination disk back to the original directory.
/*	      If there is a file in the middle of restoring, close
/*	      the file, deleted the partially restored file, and
/*	      output a message.
/*	      Then exit with error level TUSER.
/*
/*
/********************** END OF SPECIFICATIONS *******************************/
void pascal far signal_handler_routine()
{
   WORD retcode;

   DWORD dw = 0L;	   /* reserved double word*/

   /*change dir to the original directory of the destination disk*/

   /**************************************************************/
   /*if PARTIAL flag is on, close and delete the destination file*/
   /**************************************************************/
   if (set_reset_test_flag(&control_flag,PARTIAL,TEST) == TRUE) {
      /* close the partially completed destination file*/
      DOSCLOSE(dest_file_handle);
      /* delete the partially completed destination file*/
      if ((retcode = DOSDELETE((char far *) dest_file_spec, dw)) != 0) {
	 /*set file mode to 0*/
	 if ((retcode = DOSSETFILEMODE((char far *)dest_file_spec,
	 (unsigned) 0x00, dw)) != 0)
	 {
	    com_msg(retcode);
	    unexperror(retcode);
	 }
	 /* delete the partially completed destination file*/
	 if ((retcode = DOSDELETE((char far *) dest_file_spec, dw)) != 0) {
	    com_msg(retcode);
	    unexperror(retcode);
	 }
      }
      display_it(LAST_FILE_NOT_RESTORED,STND_ERR_DEV,0,NO_RESPTYPE,(BYTE)UTIL_MSG);  /*;AN000;6*/
   }
   exit_routine(TUSER);

} /* end of signal_handler*/

/************************************************************/
/*
/*   SUBROUTINE NAME:	   display_it  (added for DOS 4.00)
/*
/*   SUBROUTINE FUNCTION:
/*	   Display the requested message to the standard output device.
/*
/*   INPUT:
/*	   1) (WORD) Number of the message to be displayed.
/*	   2) (WORD) Handle to be written to.
/*	   3) (WORD) Substitution Count
/*	   4) (WORD) Flag indicating user should "Strike any key..."
/*
/*   OUTPUT:
/*	   The message corresponding to the requested msg number will
/*	   be written to the requested handle.	If requested, substitution
/*	   text will be inserted as required.  The Substitution List
/*	   is global and, if used, will be initialized by DISPLAY_MSG
/*	   before calling this routine.
/*
/*   NORMAL EXIT:
/*	   Message will be successfully written to requested handle.
/*
/*   ERROR EXIT:
/*	   None.  Note that theoretically an error can be returned from
/*	   SYSDISPMSG, but there is nothing that the application can do.
/*
/*
/************************************************************/
#define CLASS		-1	/* Goes in DH register */	      /*;AN000;6*/
#define NUL_POINTER	0	/* Pointer to nothing */	      /*;AN000;6*/

void	display_it(msg_number,handle,subst_count,waitflag,class)      /*;AN000;6*/

WORD	msg_number;						      /*;AN000;6*/
WORD	handle; 						      /*;AN000;6*/
WORD	subst_count;						      /*;AN000;6*/
WORD	waitflag;						      /*;AN000;6*/
BYTE	class;							      /*;AN000;6*/
{								      /*;AN000;6*/
	union REGS reg; 					      /*;AN000;6*/

	reg.x.ax = msg_number;					      /*;AN000;6*/
	reg.x.bx = handle;					      /*;AN000;6*/
	reg.x.cx = subst_count; 				      /*;AN000;6*/
	reg.h.dh = class;					      /*;AN000;6*/
	reg.h.dl = (BYTE)waitflag;				      /*;AN000;6*/
	reg.x.di = (BYTE)&response_buff[0];			      /*;AN000;6*/
	reg.x.si = (WORD)(char far *)&sublist;			      /*;AN000;6*/

	sysdispmsg(&reg,&reg);					      /*;AN000;6*/
	response_buff[0] = reg.h.al;	/* User input */	      /*;AN000;6*/

	return; 						      /*;AN000;6 */
}								      /*;AN000;6 */
/*****************  START OF SPECIFICATION  ********************************
/*
/*  SUBROUTINE NAME :  com_msg
/*
/*  DESCRIPTIVE NAME : the routine to output a message according to
/*		       the return codes returned from API calls.
/*
/*  FUNCTION: 1. if CP/DOS, then call rctomid
/*
/*  NOTES:
/*
/*  INPUT: (PARAMETERS)
/*	    retcode - return code used to call rctomid
/*
/*
/********************** END OF SPECIFICATIONS *******************************/
void com_msg(retcode)
WORD retcode;
{
	/* Was IF CPDOS */
   display_it(rctomid(retcode),STND_ERR_DEV,0,NO_RESPTYPE,(BYTE)UTIL_MSG);  /*;AN000;6*/

   return;

}
/**/
/*									     */
/*     Subroutine Name:      chek_DBCS()				     */
/*									     */
/*	       (Ripped off and Revised from ATTRIB.C)			     */
/*									     */
/*     Subroutine Function:						     */
/*	  Given an array and a position in the array, check if the character */
/*	  is a non-DBCS character.					     */
/*									     */
/*    Input:  array, character position, character			     */
/*									     */
/*    Output: TRUE - if array[position-1] != DBCS character  AND	     */
/*			array[position] == character.			     */
/*	      FALSE - otherwise 					     */
/*									     */
/**/
WORD chek_DBCS(array,position,character)			       /*;AN005;*/
char *array;							       /*;AN005;*/
WORD position;							       /*;AN005;*/
char character; 						       /*;AN005;*/
{								       /*;AN005;*/
   BYTE far *ptr;						       /*;AN005;*/
   WORD i;							       /*;AN005;*/
   char c;							       /*;AN005;*/
   char darray[128];	    /* DBCS array, put "D" in every position*/ /*;AN005;*/
			    /* that corresponds to the first byte   */
			    /* of a DBCS character.		    */
   if (!got_dbcs_vector)					       /*;AN005;*/
     Get_DBCS_vector(); 					       /*;AN005;*/

   for (i=0;i<128;i++)						       /*;AN005;*/
      darray[i] = ' ';                                                 /*;AN005;*/

   /* Check each character, starting with the first in string, for DBCS */
   /* characters and mark each with a "D" in the corresponding darray.  */
   for (i=0;i<position;i++)					       /*;AN005;*/
   {								       /*;AN005;*/
      c = array[i];						       /*;AN005;*/

      /* look thru DBCS table to determine if character is first byte */
      /* of a double byte character				      */
      for (ptr=DBCS_ptr; (WORD)*(WORD far *)ptr != 0; ptr += 2)        /*;AN005;*/
      { 							       /*;AN005;*/

	 /* check if byte is within range values of DOS DBCS table */
	 if (c >= *ptr && c <= *(ptr+1))			       /*;AN005;*/
	 {							       /*;AN005;*/
	    darray[i] = 'D';                                           /*;AN005;*/
	    i++;	   /* skip over second byte of DBCS */	       /*;AN005;*/
	    break;						       /*;AN005;*/
	 }							       /*;AN005;*/
      } 							       /*;AN005;*/
   }								       /*;AN005;*/

   /* if character is not DBCS then check to see if it is == to character */
   if (darray[position-1] != 'D' && character == array[position])      /*;AN005;*/
      return (TTRUE);						       /*;AN005;*/
   else 							       /*;AN005;*/
      return (FFALSE);						       /*;AN005;*/
}								       /*;AN005;*/

/**/
/*									     */
/*     Subroutine Name:     Get_DBCS_vector()				     */
/*									     */
/*     Subroutine Function:						     */
/*	  Gets the double-byte table vector.				     */
/*	  Puts it in global variable DBCS_ptr				     */
/**/
void Get_DBCS_vector()						       /*;AN005;*/
{								       /*;AN005;*/
    union REGS inregs,outregs;					       /*;AN005;*/
    struct SREGS segregs;					       /*;AN005;*/
    char fix_es_reg[2]; 					       /*;AN005;*/
    WORD *ptr;							       /*;AN005;*/
    DWORD far *addr_ptr;					       /*;AN005;*/
    WORD *buffer;						       /*;AN005;*/

		/***********************************/
		/* Allocate a buffer		   */
		/***********************************/
    inregs.x.ax = 0x4800;		/* Allocate */		       /*;AN005;*/
    inregs.x.bx = 1;			/* Num	paragraphs */	       /*;AN005;*/
    intdos(&inregs,&outregs);		/* Int 21h */		       /*;AN005;*/
    buffer = (WORD *)outregs.x.ax;	/* Segment of buffer */        /*;AN005;*/

    inregs.x.ax = 0x6507;      /* get extended country info */	       /*;AN005;*/
    inregs.x.bx = 0xffff;	  /* use active code page */	       /*;AN005;*/
    inregs.x.cx = 5;		  /* 5 bytes of return data */	       /*;AN005;*/
    inregs.x.dx = 0xffff;	  /* use default country */	       /*;AN005;*/
    inregs.x.di = 0;		  /* buffer offset */		       /*;AN005;*/
    segregs.es = (WORD)buffer;	  /* buffer segment */		       /*;AN005;*/
    segregs.ds = (WORD)buffer;	  /* buffer segment */		       /*;AN005;*/
    intdosx(&inregs,&outregs,&segregs); 			       /*;AN005;*/
    strcpy(fix_es_reg,NUL);					       /*;AN005;*/

    outregs.x.di++;		  /* skip over id byte */	       /*;AN005;*/

    /* make a far ptr from ES:[DI] */
    addr_ptr = 0;						       /*;AN005;*/
    ptr = (WORD *)&addr_ptr;					       /*;AN005;*/
    *ptr = (WORD)outregs.x.di;	  /* get offset */		       /*;AN005;*/
    ptr++;							       /*;AN005;*/
    *ptr = (WORD)segregs.es;	  /* get segment */		       /*;AN005;*/
    DBCS_ptr = (BYTE far *)*addr_ptr;				       /*;AN005;*/
    DBCS_ptr += 2;		  /* skip over table length */	       /*;AN005;*/

    /* DBCS_ptr points to DBCS table */
    strcpy(fix_es_reg,NUL);					       /*;AN005;*/
    got_dbcs_vector = TTRUE;					       /*;AN005;*/
    return;							       /*;AN005;*/
}								       /*;AN005;*/
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\restore\_msgret.asm ===
page	60,132
name	_msgret
title	C	to Message Retriever

;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

;-------------------------------------------------------------------
;
;	MODULE: 	_msgret
;
;	PURPOSE:	Supplies an interface between C programs and
;			the DOS 3.3 message retriever
;
;	CALLING FORMAT:
;			sysloadmsg(&inregs,&outregs);
;			sysdispmsg(&inregs,&outregs);
;
;	DATE:		5-21-87
;
;-------------------------------------------------------------------

	INCLUDE SYSMSG.INC		;PERMIT SYSTEM MESSAGE HANDLER DEFINITION ;AN000;

	MSG_UTILNAME <RESTORE>		;IDENTIFY THE COMPONENT 		;AN000;

	.8087
_TEXT	SEGMENT BYTE PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT WORD PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT WORD PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT WORD PUBLIC 'BSS'
_BSS	ENDS
DGROUP	GROUP	CONST, _BSS, _DATA
	ASSUME	CS: _TEXT, DS: _TEXT, SS: DGROUP, ES: DGROUP


	public	_sysloadmsg
	public	_sysdispmsg

;-------------------------------------------------------------------
;-------------------------------------------------------------------

_DATA	segment
.XLIST
.XCREF
	MSG_SERVICES <MSGDATA>		;DATA AREA FOR THE MESSAGE HANDLER	     ;AN000;
.LIST
.CREF
_DATA	ends


_TEXT	segment

;-------------------------------------------------------------------
					;DEFAULT=CHECK DOS VERSION
					;DEFAULT=NEARmsg
					;DEFAULT=INPUTmsg
					;DEFAULT=NUMmsg
					;DEFAULT=NO TIMEmsg
					;DEFAULT=NO DATEmsg
.XLIST
.XCREF
	MSG_SERVICES <LOADmsg,INPUTmsg,DISPLAYmsg,CHARmsg,NUMmsg,DATEmsg,FARmsg> ;AN000;6
	MSG_SERVICES <RESTORE.CTL,RESTORE.CLA,RESTORE.CL1,RESTORE.CL2> ;AN000;6
.LIST
.CREF
;-------------------------------------------------------------------

_sysloadmsg proc near

	push	bp			; save user's base pointer
	mov	bp,sp			; set bp to current sp
	push	di			; save some registers
	push	si

;	copy C inregs into proper registers

	mov	di,[bp+4]		; fix di (arg 0)

;-------------------------------------------------------------------

	mov	ax,[di+0ah]		; load di
	push	ax			; the di value from inregs is now on stack

	mov	ax,[di+00]		; get inregs.x.ax
	mov	bx,[di+02]		; get inregs.x.bx
	mov	cx,[di+04]		; get inregs.x.cx
	mov	dx,[di+06]		; get inregs.x.dx
	mov	si,[di+08]		; get inregs.x.si
	pop	di			; get inregs.x.di from stack

	push	bp			; save base pointer

;-------------------------------------------------------------------
	call	sysloadmsg		; call the message retriever
;-------------------------------------------------------------------

	pop	bp			; restore base pointer
	push	di			; the di value from call is now on stack
	mov	di,[bp+6]		; fix di (arg 1)

	mov	[di+00],ax		; load outregs.x.ax
	mov	[di+02],bx		; load outregs.x.bx
	mov	[di+04],cx		; load outregs.x.cx
	mov	[di+06],dx		; load outregs.x.dx
	mov	[di+08],si		; load outregs.x.si

	lahf				; get flags into ax
	mov	al,ah			; move into low byte
	mov	[di+0ch],ax		; load outregs.x.cflag

	pop	ax			; get di from stack
	mov	[di+0ah],ax		; load outregs.x.di

;-------------------------------------------------------------------

	pop	si			; restore registers
	pop	di
	mov	sp,bp			; restore sp
	pop	bp			; restore user's bp
	ret

_sysloadmsg endp


;_sysgetmsg proc near
;
;	 push	 bp			 ; save user's base pointer
;	 mov	 bp,sp			 ; set bp to current sp
;	 push	 di			 ; save some registers
;	 push	 si
;
;;	 copy C inregs into proper registers
;
;	 mov	 di,[bp+4]		 ; fix di (arg 0)
;
;;-------------------------------------------------------------------
;
;	 mov	 ax,[di+0ah]		 ; load di
;	 push	 ax			 ; the di value from inregs is now on stack
;
;	 mov	 ax,[di+00]		 ; get inregs.x.ax
;	 mov	 bx,[di+02]		 ; get inregs.x.bx
;	 mov	 cx,[di+04]		 ; get inregs.x.cx
;	 mov	 dx,[di+06]		 ; get inregs.x.dx
;	 mov	 si,[di+08]		 ; get inregs.x.si
;	 pop	 di			 ; get inregs.x.di from stack
;
;	 push	 bp			 ; save base pointer
;
;;-------------------------------------------------------------------
;	 call	 sysgetmsg		 ; call the message retriever
;;-------------------------------------------------------------------
;
;	 pop	 bp			 ; restore base pointer
;	 push	 di			 ; the di value from call is now on stack
;	 mov	 di,[bp+6]		 ; fix di (arg 1)
;
;	 mov	 [di+00],ax		 ; load outregs.x.ax
;	 mov	 [di+02],bx		 ; load outregs.x.bx
;	 mov	 [di+04],cx		 ; load outregs.x.cx
;	 mov	 [di+06],dx		 ; load outregs.x.dx
;	 mov	 [di+08],si		 ; load outregs.x.si
;
;	 lahf				 ; get flags into ax
;	 mov	 al,ah			 ; move into low byte
;	 mov	 [di+0ch],ax		 ; load outregs.x.cflag
;
;	 pop	 ax			 ; get di from stack
;	 mov	 [di+0ah],ax		 ; load outregs.x.di
;
;;-------------------------------------------------------------------
;
;	 pop	 si			 ; restore registers
;	 pop	 di
;	 mov	 sp,bp			 ; restore sp
;	 pop	 bp			 ; restore user's bp
;	 ret
;
;_sysgetmsg endp

_sysdispmsg proc near

	push	bp			; save user's base pointer
	mov	bp,sp			; set bp to current sp
	push	di			; save some registers
	push	si

;	copy C inregs into proper registers

	mov	di,[bp+4]		; fix di (arg 0)

;-------------------------------------------------------------------

	mov	ax,[di+0ah]		; load di
	push	ax			; the di value from inregs is now on stack

	mov	ax,[di+00]		; get inregs.x.ax
	mov	bx,[di+02]		; get inregs.x.bx
	mov	cx,[di+04]		; get inregs.x.cx
	mov	dx,[di+06]		; get inregs.x.dx
	mov	si,[di+08]		; get inregs.x.si
	pop	di			; get inregs.x.di from stack

	push	bp			; save base pointer

;-------------------------------------------------------------------
	call	sysdispmsg		; call the message retriever
;-------------------------------------------------------------------

	pop	bp			; restore base pointer
	push	di			; the di value from call is now on stack
	mov	di,[bp+6]		; fix di (arg 1)

	mov	[di+00],ax		; load outregs.x.ax
	mov	[di+02],bx		; load outregs.x.bx
	mov	[di+04],cx		; load outregs.x.cx
	mov	[di+06],dx		; load outregs.x.dx
	mov	[di+08],si		; load outregs.x.si

	lahf				; get flags into ax
	mov	al,ah			; move into low byte
	mov	[di+0ch],ax		; load outregs.x.cflag

	pop	ax			; get di from stack
	mov	[di+0ah],ax		; load outregs.x.di

;-------------------------------------------------------------------

	pop	si			; restore registers
	pop	di
	mov	sp,bp			; restore sp
	pop	bp			; restore user's bp
	ret

_sysdispmsg endp

include msgdcl.inc

_TEXT	ends				; end code segment
	end


=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\restore\rtt.c ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

static char *SCCSID = "@(#)rtt.c        8.1 86/09/20";

/*  0 */

#include <stdio.h>
#include "rt.h"
#include "rt1.h"
#include "rt2.h"
#include <comsub.h>			/* common subroutine def'n */
#include <doscalls.h>
#include <basemid.h>
#include <wrwdefs.h>		   /* wrw! */

unsigned char destddir[MAXPATH+3] = {'\0'};
unsigned char srcddir[MAXPATH+3] = {'\0'};
unsigned char rtswitch=0;
unsigned char control_flag=0;
unsigned char control_flag2=0;
unsigned char filename[MAXFSPEC] = {"OSO001.MSG"};
unsigned char *buf_pointer;

/****************************************************************************/
/* The following comments are necessary to be here to make msgprof.exe	    */
/* correctly.								    */
/****************************************************************************/
/* #define  INSERT_SOURCE_DISK	      MSG_INS_BACKUP_DISK	    */
/* #define  SOURCE_TARGET_SAME	      MSG_REST_SOUR_TARG_SAME	    */
/* #define  INVALID_NUM_PARM	      MSG_REST_NUM_INVAL_PARA	    */
/* #define  INVALID_DRIVE	      MSG_REST_INVAL_SPEC	    */
/* #define  NO_FILE_TO_RESTORE	      MSG_REST_NO_FILE_FOUND	    */
/* #define  INVALID_PARM	      MSG_REST_INVAL_PARA	    */
/* #define  LAST_FILE_NOT_RESTORED    MSG_REST_LAST_FILE_NOT	    */
/* #define  SOURCE_NO_BACKUP_FILE     MSG_REST_SOURCE_NO_BACK	    */
/* #define  INSUFFICIENT_MEMORY       MSG_REST_INSUF_MEM	    */
/* #define  FILE_SEQUENCE_ERROR       MSG_REST_FILE_SEQ_ERROR	    */
/* #define  FILE_CREATION_ERROR       MSG_REST_FILE_CREAT_ERROR     */
/* #define  TARGET_IS_FULL	      MSG_REST_TARG_FULL	    */
/* #define  NOT_ABLE_TO_RESTORE_FILE  MSG_REST_CANNOT_REST_FILE     */
/* #define  INVALID_DOS_VER	      MSG_REST_INVAL_VERS	    */
/* #define  FILE_SHARING_ERROR	      MSG_REST_FILE_SHAR	    */
/* #define  FILE_WAS_CHANGED	      MSG_REST_CHNG_REPL	    */
/* #define  DISK_OUT_OF_SEQUENCE      MSG_REST_DISK_OUT_SEQ	    */
/* #define  FILE_IS_READONLY	      MSG_REST_FILE_READ	    */
/* #define  SYSTEM_FILE_RESTORED      MSG_REST_SYS		    */
/* #define  FILES_WERE_BACKUP_ON      MSG_REST_FILE_BACKUP	    */
/* #define  RESTORE_FILE_FROM_DRIVE   MSG_REST_FILE_FROM	    */
/* #define  INSERT_TARGET_DISK	      MSG_REST_TARG_DISK	    */
/* #define  FILE_TO_BE_RESTORED       MSG_REST_FILENAME 	    */
/* #define  DISKETTE_NUM	      MSG_REST_DISKETTE 	    */
/* #define  PATH_NOT_FOUND	      MSG_BACK_INVAL_PATH	    */

/*****************  START OF SPECIFICATION  *********************************/
/*									    */
/*  MODULE NAME :  RESTORE utility					    */
/*									    */
/*  DESCRIPTIVE NAME : Restore one or more backed-up files from a	    */
/*		       disk to another disk				    */
/*									    */
/*  FUNCTION: Restore files saved by BACKUP utility to their		    */
/*	      destination disk.  This utility will be able to identify	    */
/*	      which of the two backup formats was used and to do the	    */
/*	      restore accordingly.					    */
/*									    */
/*  NOTES:  This RESTORE utility recognize two data formats:		    */
/*	    1. The data format used by BACKUP utility of 3.2 and before.    */
/*	    2. The data format used by BACKUP utility of 3.3 and above,     */
/*	       and also used by CP/DOS 1.0 and above.			    */
/*									    */
/*	    DEPENDENCY: 						    */
/*	    This utility has a dependency on the BACKUP utility to	    */
/*	    perform file backup correctly using the data structure	    */
/*	    agreed on.							    */
/*									    */
/*	    RESTRICTION:						    */
/*	    This utility is able to restore the files which are previously  */
/*	    backup by IBM BACKUP utility only.				    */
/*									    */
/*  ENTRY POINT: Main							    */
/*									    */
/*  INPUT: (PARAMETERS) 						    */
/*									    */
/*	COMMAND SYNTAX: 						    */
/*	      [d:][path]Restore d: [d:][path][filename][.ext]		    */
/*	      [/S] [/P] [/B:date] [/A:date] [/E:time][/L:time][/M] [/N]     */
/*									    */
/*	Parameters:							    */
/*	      The first parameter you specify is the drive designator of    */
/*	      the disk containing the backed up files.	The second	    */
/*	      parameter is the a filespec indicating which files you want   */
/*	      to restore.						    */
/*	Switches:							    */
/*	      /S - Restore subdirectories too.				    */
/*	      /P - If any hidden or read-only files match the filespec,     */
/*		   prompt the user for permission to restore them.	    */
/*	      /B - Only restore those files which were last Revised on or  */
/*		   before the given date.				    */
/*	      /A - Only restore those files which were last Revised on or  */
/*		   after the given date.				    */
/*	      /E - Only restore those files which were last Revised at or  */
/*		   earlier then the given time. 			    */
/*	      /L - Only restore those files which were last Revised at or  */
/*		   later then the given time.				    */
/*	      /M - Only restore those files which have been Revised since  */
/*		   the last backup.					    */
/*	      /N - Only restore those files which no longer exist on the    */
/*		   destination disk.					    */
/*									    */
/*  EXIT-NORMAL:							    */
/*									    */
/*	      The following messages will be displayed when the program     */
/*	      exit normally.						    */
/*									    */
/*	      *** Files were backed up xx/xx/xxxx ***			    */
/*	      (xx/xx/xxxx will be different in differnt country codes)	    */
/*									    */
/*	      *** Restoring files from drive d: ***			    */
/*	      Diskette: xx						    */
/*	      path\filename.ext 					    */
/*	      path\filename.ext 					    */
/*	      path\filename.ext 					    */
/*	      path\filename.ext 					    */
/*	      .....							    */
/*									    */
/*  EXIT-ERROR: 							    */
/*	 The restore program sets the ERRORLEVEL in the following manner:   */
/*									    */
/*	   0   Normal completion					    */
/*	   1   No files were found to backup				    */
/*	   2   Some files not restored due to sharing conflict		    */
/*	   3   Terminated by user					    */
/*	   4   Terminated due to error					    */
/*									    */
/*  EFFECTS: None							    */
/*									    */
/*  OTHER USER INTERFACES:						    */
/*	   RESTORE prompts for the user to insert source diskette if	    */
/*	   the source disk specified is removable:			    */
/*									    */
/*	   Insert backup diskette 01 in drive d:			    */
/*	   (d: is the source diskette)					    */
/*	   Strike any key when ready					    */
/*									    */
/*	   If the destination disk is a removable drive, the following	    */
/*	   message is also displayed:					    */
/*									    */
/*	   Insert restore target in drive d:				    */
/*	   (d: is the destination disk) 				    */
/*	   Strike any key when ready					    */
/*									    */
/*	   No matter whether the destination disk is a removable drive	    */
/*	   or a non_removable drive, when the destination disk is full,     */
/*	   RESTORE output a message "Target is full" and exit.  RESTORE     */
/*	   does not prompt for user to change destination disk when it	    */
/*	   is full.							    */
/*									    */
/*	   When there is any system file restored, the following message    */
/*	   is displayed:						    */
/*	     System file restored					    */
/*	     Target disk may not be bootable				    */
/*									    */
/*  INTERNAL REFERENCES:						    */
/*	   ROUTINES:							    */
/*    Major routines are shown as follows:				    */
/*	      main							    */
/*	      parse_input_drive_and_file				    */
/*	      set_input_switches					    */
/*	      verify_input_switches					    */
/*	      dorestore 						    */
/*	      check_bkdisk_old						    */
/*	      printinfo 						    */
/*	      check_bkdisk_new						    */
/*	      search_src_disk_old					    */
/*	      check_flheader_old					    */
/*	      pathmatch 						    */
/*	      fspecmatch						    */
/*	      switchmatch						    */
/*	      restore_a_file						    */
/*	      search_src_disk_new					    */
/*	      findfirst_new						    */
/*	      findfile_new						    */
/*	      findnext_new						    */
/*	      check_flheader_new					    */
/*	      readonly_or_changed					    */
/*	      open_dest_file						    */
/*	      build_path_create_file					    */
/*	      dos_write_error						    */
/*	      set_attributes_and_close					    */
/*									    */
/*    Minor routines are shown as follows:				    */
/*	      signal_handler_routine					    */
/*	      usererror 						    */
/*	      unexperror						    */
/*	      exit_routine						    */
/*	      putmsg							    */
/*	      com_msg							    */
/*	      beep							    */
/*	      checkdosver						    */
/*	      separate							    */
/*	      initbuf							    */
/*	      init_control_buf						    */
/*	      set_reset_test_flag					    */
/*	      valid_input_date						    */
/*	      valid_input_time						    */
/*									    */
/*****************  END OF SPECIFICATION    *********************************/
/*****************  START OF SPECIFICATION  *********************************/
/*									    */
/*  SUBROUTINE NAME :  Main						    */
/*									    */
/*  DESCRIPTIVE NAME : Main routine for RESTORE utility 		    */
/*									    */
/*  FUNCTION: Main routine does the following:				    */
/*	      1. Verifies the DOS version				    */
/*	      2. Validate the input command line			    */
/*	      3. Calls dorestore to do the file restore.		    */
/*									    */
/*  NOTES:								    */
/*									    */
/*  ENTRY POINT: Main							    */
/*	Linkage: main((argc,argv)					    */
/*									    */
/*  INPUT: (PARAMETERS) 						    */
/*	   argc - number of arguments					    */
/*	   argv - array of pointers to arguments			    */
/*									    */
/*									    */
/*  EXIT-NORMAL:							    */
/*									    */
/*  EXIT-ERROR: 							    */
/*									    */
/*  EFFECTS: rtswitch is changed to reflect the switches passed.	    */
/*									    */
/*  INTERNAL REFERENCES:						    */
/*	   ROUTINES:							    */
/*		    dorestore						    */
/*		    checkdosver 					    */
/*		    set_input_switches					    */
/*		    parse_input_drive_and_file				    */
/*		    separate						    */
/*		    beep						    */
/*		    putmsg						    */
/*		    usererror						    */
/*		    exit_routine					    */
/*		    set_reset_test_flag 				    */
/*		    set_input_switches					    */
/*		    exit_routine					    */
/*									    */
/*  EXTERNAL REFERENCES:						    */
/*	   ROUTINES:							    */
/*		    com_strupr						    */
/*		    DSOSETSIGHANDLER					    */
/*									    */
/********************** END OF SPECIFICATIONS *******************************/
void main(argc,argv)  /* wrw! */
    int argc;
    char *argv[];
{
   /*variables for putmsg */
   unsigned char *ivtable[2];/*point to the table of bairables to insert*/
   unsigned char respdata; /*response data area*/
   unsigned int  msg_id;
   unsigned int retcode;

   unsigned int  destdnum;	  /*the destination disk in the integer form*/
   unsigned int  i;		  /*loop counter			    */
   unsigned int  j;		  /*arrary subcript			    */
   unsigned char *c;
   unsigned long drive_map;
   unsigned long prev_address;
   unsigned int  prev_action;
   unsigned char srcd;
   unsigned char destd;
   unsigned char srcf[MAXPATHF];
   unsigned char inpath[MAXPATH];
   unsigned char infname[MAXFNAME];
   unsigned char infext[MAXFEXT];
   unsigned char infspec[MAXFSPEC];
   unsigned int  next_arg;
   struct timedate td;
   void far  pascal signal_handler_routine();
   /************************************************************************/
   /* set signal handler						   */
   /************************************************************************/

   retcode = DOSSETSIGHANDLER(
	(void (far *)() )signal_handler_routine,   /* Signal handler address */
	(unsigned long far *)&prev_address,  /* Address of previous handler */
	(unsigned far *)&prev_action,	  /* Address of previous action */
	(unsigned)INSTALL_SIGNAL,	  /* Indicate request type */
	(unsigned)CTRL_C);		  /* Signal number */

   if (retcode != 0)
       com_msg(retcode);

   retcode = DOSSETSIGHANDLER(
	(void (far *)() )signal_handler_routine,   /* Signal handler address */
	(unsigned long far *)&prev_address,  /* Address of previous handler */
	(unsigned far *)&prev_action,	  /* Address of previous action */
	(unsigned)INSTALL_SIGNAL,	  /* Indicate request type */
	(unsigned)CTRL_BREAK);		  /* Signal number */

   if (retcode != 0)
      com_msg(retcode);

   /************************************************************************/
   /* check dos version 						   */
   /************************************************************************/
   retcode = checkdosver();
   if (retcode != TRUE) {

	msg_id = INVALID_DOS_VER;
	putmsg (ivtable,0,msg_id,NO_RESPTYPE,&respdata,RESPDATA_SIZE);

	usererror(ERROR_INVALID_DOSVER);
    }

   /************************************************************************/
   /*convert the input arguments into upper case			   */
   /************************************************************************/
   for (i=1; i <=argc-1; ++i) {
       com_strupr(argv[i]);
   }

   /************************************************************************/
   /* verify the number of parameters					   */
   /************************************************************************/
   if (argc-1 < MINARGS || argc-1 > MAXARGS) {
	msg_id = INVALID_NUM_PARM;    /*invalid number of parameters*/
	putmsg (ivtable,0,msg_id,NO_RESPTYPE,&respdata,RESPDATA_SIZE);
	usererror(INVALIDPARM);
   }
   /* endif*/

   /************************************************************************/
   /* call subroutine to parse the drive and file name entered		   */
   /************************************************************************/
   parse_input_drive_and_file( argc, argv, &destd, &srcd,
			      srcf, &next_arg) ;

   /************************************************************************/
   /* separate the filename for search into prefix(inpath),		   */
   /* filename(infname), and file extension (infext)			   */
   /* Also take care of the situation that user enter '.' only             */
   /* for file spec.							   */
   /************************************************************************/
   separate(srcf,inpath,infname,infext,infspec);
   if (strlen(infname) > MAXFNAME-1 ||
       strlen(infext) > MAXFEXT-1 ||
       strlen(inpath) > MAXPATH-1 ||
       strcmp(infspec,"LPT1")==0 ||
       strcmp(infspec,"LPT2")==0 ||
       strcmp(infspec,"PRN")==0 ||
       strcmp(infspec,"CON")==0 ||
       strcmp(infspec,"NUL")==0 ||
       strcmp(infspec,"AUX")==0 ||
       strcmp(infspec,"LPT1:")==0 ||
       strcmp(infspec,"LPT2:")==0 ||
       strcmp(infspec,"PRN:")==0 ||
       strcmp(infspec,"CON:")==0 ||
       strcmp(infspec,"NUL:")==0 ||
       strcmp(infspec,"AUX:")==0 )
   {
       msg_id =  INVALID_PARM;
       ivtable[0] = infspec;
       putmsg (ivtable,1,msg_id,NO_RESPTYPE,&respdata,RESPDATA_SIZE);
       usererror(INVALIDPARM);	     /* invalid parm */
   }

   /************************************************************************/
   /* set wildcard flag according to whether there is '*' or/and  '?' in   */
   /* file specification						   */
   /************************************************************************/
   c = infspec;
   while (*c) {
      if (*c == '*' || *c == '?') {
	set_reset_test_flag(&control_flag,WILDCARD,SET);
	break;
      }
      else
	c = c+1;
   } /*end while*/

   /************************************************************************/
   /* if there is any more parameters to be parsed, call set_input_switches*/
   /* to parse them started from argv[next_arg] 			   */
   /************************************************************************/
   if (next_arg != 0 && argc > next_arg) {
       set_input_switches(  argc, argv, &next_arg, &td);
   }	/* started from argv[next_arg] should be switches */

   /************************************************************************/
   /* call dorestore to actually do the restoring			   */
   /************************************************************************/
   dorestore(srcd,destd,inpath,infname,infext,infspec,&td);

   /************************************************************************/
   /* output a msg in the following situations: 			   */
   /*	       if flag indicates no file found				   */
   /************************************************************************/
   if (set_reset_test_flag(&control_flag,FOUND,TEST)==FALSE) {
      beep();
      msg_id = NO_FILE_TO_RESTORE; /*warning! No files were found to restore*/
      putmsg (ivtable,0,msg_id,NO_RESPTYPE,&respdata,RESPDATA_SIZE);
      exit_routine(NOFILES);
   }

   exit_routine(NORMAL);

} /* end of main*/
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\restore\rtt1.c ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */


/*----------------------------
/* SOURCE FILE NAME:  RTT1.C
/*----------------------------
/*  0 */

#include "rt.h"
#include "rt1.h"
#include "rt2.h"
#include "restpars.h"                                                 /*;AN000;4*/
#include "dos.h"                                                      /*;AN000;2*/
#include "comsub.h"             /* common subroutine def'n */
#include "doscalls.h"
#include "error.h"

extern BYTE destddir[MAXPATH+3];
extern BYTE srcddir[MAXPATH+3];
extern BYTE rtswitch;
extern BYTE control_flag;
extern BYTE control_flag2;
extern BYTE filename[12];
extern unsigned control_file_handle;				     /* !wrw */
extern BYTE append_indicator;					      /*;AN000;2*/
extern WORD original_append_func;				      /*;AN000;2*/

/*************************************************/
/*
/* SUBROUTINE NAME:	check_appendX
/*
/* FUNCTION:
/*	Check APPEND /X status.  If it is not active,
/*	do nothing. If it is active, then turn it off
/*	and set flag indicating that we must reset it later.
/*
/***************************************************/
void check_appendX()				/*;AN000;2*/
{						/*;AN000;2*/
	union REGS gregs;			/*;AN000;2 Register set */

	gregs.x.ax = INSTALL_CHECK;		/*;AN000;2 Get installed state*/
	int86(0x2f,&gregs,&gregs);		/*;AN000;2*/

		/*****************************************************/
		/*  1) See if append is active
		/*  2) If so, figure out if PCDOS or PCNET version
		/*****************************************************/
	if (gregs.h.al == 0)			/*;AN000;2 Zero if not installed*/
	  append_indicator = NOT_INSTALLED;	/*;AN000;2 */
	 else					/*;AN000;2 See which APPEND it is*/
	   {					/*;AN000;2*/
	    gregs.x.ax = GET_APPEND_VER;	/*;AN000;2*/
	    int86(0x2f,&gregs,&gregs);		/*;AN000;2*/

	    if (gregs.h.al == (BYTE)-1) 	/*;AN000;2 -1 if PCDOS version*/
	     append_indicator = DOS_APPEND;	/*;AN000;2*/
	    else				/*;AN000;2*/
	     append_indicator = NET_APPEND;	/*;AN000;2*/
	   }					/*;AN000;2*/

		/*****************************************************/
		/*  If it is the PCDOS append
		/*    1) Get the current append functions (returned in BX)
		/*    2) Reset append with /X support off
		/*****************************************************/
	if (append_indicator == DOS_APPEND)	/*;AN000;2*/
	 {					/*;AN000;2*/
	    gregs.x.ax = GET_STATE;		/*;AN000;2 Get active APPEND functions*/
	    int86(0x2f,&gregs,&gregs);		/*;AN000;2*/
	    original_append_func = gregs.x.bx;	/*;AN000;2*/

	    gregs.x.ax = SET_STATE;		/*;AN000;2*/
	    gregs.x.bx = gregs.x.bx & (!APPEND_X_BIT);	/*;AN000;2*/
	    int86(0x2f,&gregs,&gregs);		/*;AN000;2*/

	 }					/*;AN000;2*/

	return; 				/*;AN000;2*/
}						/*;AN000;2*/

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\restore\_parse.asm ===
page	60,132
name	_parse
title	C	to PARSER interface

;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

;-------------------------------------------------------------------
;
;	MODULE: 	_parse
;
;	PURPOSE:	Supplies an interface between C programs and
;			the DOS 3.3 parser
;
;	CALLING FORMAT:
;			parse(&inregs,&outregs);
;
;	DATE:		5-21-87
;
;-------------------------------------------------------------------

;	extrn	sysparse:far

	public	_parse

;-------------------------------------------------------------------
FarSW	equ	0			; make sysparse be a NEAR proc
TimeSW	equ	1			; Check time format
FileSW	equ	1			; Check file specification
CAPSW	equ	1			; Perform CAPS if specified
CmpxSW	equ	0			; Check complex list
NumSW	equ	0			; Check numeric value
KeySW	equ	0			; Support keywords
SwSW	equ	1			; Support switches
Val1SW	equ	0			; Support value definition 1
Val2SW	equ	0			; Support value definition 2
Val3SW	equ	0			; Support value definition 3
DrvSW	equ	1			; Support drive only format
QusSW	equ	0			; Support quoted string format
IncSW	equ	0			; Dont include PSDATA, I just did it
BaseSW	equ	1			; DS points to data
;-------------------------------------------------------------------

DGROUP	GROUP	_DATA
PGROUP	GROUP	_TEXT

_DATA	segment byte public 'DATA'
include version.inc
include psdata.inc
_DATA	ends

_TEXT	segment byte public 'CODE'

	ASSUME	CS: PGROUP
	ASSUME	DS: DGROUP

;-------------------------------------------------------------------
.xlist
include parse.asm			; include the parser
.list
;-------------------------------------------------------------------

_parse	proc	near

	push	bp			; save user's base pointer
	mov	bp,sp			; set bp to current sp
	push	di			; save some registers
	push	si

;	copy C inregs into proper registers

	mov	di,[bp+4]		; fix di (arg 0)

;-------------------------------------------------------------------

	mov	ax,[di+0ah]		; load di
	push	ax			; the di value from inregs is now on stack

	mov	ax,[di+00]		; get inregs.x.ax
	mov	bx,[di+02]		; get inregs.x.bx
	mov	cx,[di+04]		; get inregs.x.cx
	mov	dx,[di+06]		; get inregs.x.dx
	mov	si,[di+08]		; get inregs.x.si
	pop	di			; get inregs.x.di from stack

	push	bp			; save base pointer
;-------------------------------------------------------------------
	call	sysparse		; call the parser
;-------------------------------------------------------------------
	pop	bp			; restore base pointer
	push	di			; the di value from call is now on stack
	mov	di,[bp+6]		; fix di (arg 1)

	mov	[di+00],ax		; load outregs.x.ax
	mov	[di+02],bx		; load outregs.x.bx
	mov	[di+04],cx		; load outregs.x.cx
	mov	[di+06],dx		; load outregs.x.dx
	mov	[di+08],si		; load outregs.x.si

	lahf				; get flags into ax
	mov	al,ah			; move into low byte
	mov	[di+0ch],ax		; load outregs.x.cflag

	pop	ax			; get di from stack
	mov	[di+0ah],ax		; load outregs.x.di

;-------------------------------------------------------------------

	pop	si			; restore registers
	pop	di
	mov	sp,bp			; restore sp
	pop	bp			; restore user's bp
	ret

_parse	endp

_TEXT	ends				; end code segment
	end

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\setver\device.asm ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

;========================================================
COMMENT #

	DEVICE.ASM


	=================================================
	Device driver to activate the version table in
	MS-DOS 6.0. Upon initialization the driver will
	set the DWORD PTR in the DOS data area at offset
	05dh to point to the version table in the device
	driver and also calculates the minimum install
	size needed to include only the valid entries
	in the default version table.


	================================================

	johnhe - 12/30/90

END COMMENT #

; =======================================================

INCLUDE		VERSIONA.INC

CMD		EQU	2		; Command field offset in packet
STATUS		EQU	3		; Return status field offset
DEV_LEN		EQU	14		; Device length field offset

DOS_TABLE	EQU	5dh		; Lie table ptr offset in dos data
TABLE_LEN	EQU	2048		; Max size of lie table

; ====================================================================

A_DEVICE SEGMENT BYTE PUBLIC 'CODE'
	ASSUME	CS:A_DEVICE, DS:NOTHING, ES:NOTHING

PUBLIC	ENTRY
PUBLIC	DeviceInit

; ====================================================================


DeviceHeader:
		dw	-1,-1
		dw	1000000000000000b; Device attributes (character device)
		dw	Strategy	; Device strategy entry offset
		dw	Entry		; Device entry offset
		db	'SETVERXX'
ExtendedHeader:				; Extended header is used by the
					; SETVER.EXE program to determine
					; where the version table is located
					; within the .EXE file
VerMinor	db	0		; Version 1.0 of Setver
VerMajor	db	1		;
TableOffset	dd	OFFSET VerList	; Offset of table from device start
TableLength	dw	TABLE_LEN	; Max table size
PtrSave	dd	(?)			; Address of device packet

; ====================================================================

; ====================================================================

StratProc PROC	FAR

Strategy:
	mov	WORD PTR CS:[PtrSave],BX	; Save device packet for
	mov	WORD PTR CS:[PtrSave][2],ES	; use on call to dev entry
	ret

StratProc	ENDP	
	
; ====================================================================

; ====================================================================

Entry PROC FAR				; Device driver entry location
	push	BX
	push	DS
	
	lds	BX,[PtrSave]		; DS:BX --> Cmd structure
	mov	AL,DS:[BX].CMD		; AL == command from sysinit
	cbw
	or	AX,AX			; Check for init function zero
	jnz	CmdError		; If not init then error
	jmp	DeviceInit		; Jmp to initialize device

CmdError:
	mov	AL,3			; Return invalid function code
	mov	AH,10000001b		; Signal error in AH

SetStatus:
	mov	[BX].Status,AX		 ; Copy status to packet

	pop	DS
	pop	BX
	ret

Entry ENDP

; ====================================================================
; ====================================================================

SIG	db	'PCMN'
TblLen	dw	TABLE_LEN

; ====================================================================
; ====================================================================

	public	VerList
                                                ; B# refer to MSDOS 6 bug database
VerList	db	10,"KERNEL.EXE"         ,5,00   ; GeoWorks Pro 1.2 B#1344
        db      8, "NETX.COM"           ,5,00   ; NOVELL netx.com 3.26 B#707
        db      8, "NETX.EXE"           ,5,00   ; Novell Redir 3.31 B#4243
        db      8, "NET5.COM"           ,5,00   ; Microsoft Device Library
	db      9, "BNETX.COM"          ,5,00   ; Novell Burst Mode Redir B#3843
        db      9, "BNETX.EXE"          ,5,00   ; Novell Burst Mode Redir B#4377
        db      11,"EMSNETX.EXE"        ,5,00   ; Novell EMS Redir B#4775
        db      11,"EMSNET5.EXE"        ,5,00   ; Novell EMS Redir B#4775
        db      11,"XMSNETX.EXE"        ,5,00   ; Novell XMS Redir B#4775
        db      11,"XMSNET5.EXE"        ,5,00   ; Novell XMS Redir B#4775
        db      10,"DOSOAD.SYS"         ,5,00   ; Iomega bernoulli B#2223
        db      11,"REDIR50.EXE"        ,5,00   ; IBM PLCP 1.34    B#1459
        db      10,"REDIR5.EXE"         ,5,00   ; PATHWORKS 4.1    B#1646
        db      12,"REDIRALL.EXE"       ,5,00   ; Banyan Vines 4.115 B#1347
        db      12,"REDIRNP4.EXE"       ,5,00   ; Banyan redirector B#3283
        db      9, "EDLIN.EXE"          ,5,00   ; Microsoft Device Library
IFNDEF OEMBASE
        db      10,"BACKUP.EXE"         ,5,00   ; Microsoft Device Library
ENDIF
        db      10,"ASSIGN.COM"         ,5,00   ; Microsoft Device Library
        db      11,"EXE2BIN.EXE"        ,5,00   ; Microsoft Device Library
        db      8, "JOIN.EXE"           ,5,00   ; Microsoft Device Library
        db      11,"RECOVER.EXE"        ,5,00   ; Microsoft Device Library
        db      12,"GRAFTABL.COM"       ,5,00   ; Microsoft Device Library
        db      11,"LMSETUP.EXE"        ,5,00   ; LanMan 2.1 Setup B#969
        db      11,"STACKER.COM"        ,5,00   ; Stacker B#2338
        db      10,"NCACHE.EXE"         ,5,00   ; Norton Utilities B#1329
        db      11,"NCACHE2.EXE"        ,5,00   ; Norton Utilities B#3819
        db      12,"IBMCACHE.SYS"       ,5,00   ; B#2228
        db      11,"XTRADRV.SYS"        ,5,00   ; XtraDrive compression B#2371
        db      8, "2XON.COM"           ,5,00   ; Superstor floppy reader B#5272
	db	11,"WINWORD.EXE"	,4,10	; winword 1.0
	db	9, "EXCEL.EXE"		,4,10	; excel 2.x
        db      7, "LL3.EXE"            ,4,01   ; LapLink 3
        db      10,"REDIR4.EXE"         ,4,00   ; IBM PCLP
        db      11,"REDIR40.EXE"        ,4,00   ; IBM DLR
	db      11,"MSREDIR.EXE"        ,4,00   ; 3Com 3+Share
        db      10,"WIN200.BIN" 	,3,40  	; windows 2.x
	db      9, "METRO.EXE"          ,3,31   ; Lotus Metro

	db	(TABLE_LEN - ($ - VerList)) dup (0)
	db	0


; ====================================================================
; Device initialization function first determines minimum size the
; driver needs to be and then sets the DWORD PTR in the DOS data area
; to the location of the version table.
; ====================================================================

DeviceInit:

	push	BX
	push	CX
	mov	AH,30h			; Get version
	int	21h
	pop	CX
	pop	BX

	cmp	AX,expected_version
	je	SetupScan
	xor	AX,AX			; Set end of device to 0
	jmp	SHORT SetDevEnd
	
SetupScan:
	push	SI
	push	DS
	mov	AX,CS
	mov	DS,AX
	mov	SI, OFFSET VerList	; DS:SI --> Version table

	xor	AX,AX			; Clear high byte of AX
ScanLoop:
	lodsb				; Grab the name length
 	or	AX,AX			; Test for end of the table
	jz	FoundEnd
	inc	AX			; Add 2 bytes for the version number
	inc	AX
	add	SI,AX			; Make SI so it points to next entry
	jmp	SHORT ScanLoop

FoundEnd:
	mov	AX,SI			; AX == Offset of end of table
	inc	AX			; Need 1 zero byte at end of table
	pop	DS
	pop	SI

SetTablePtr:
	push	BX
	push	ES

	push	AX			; Save end of device offset
	mov	AH,52h			; Get the DOS data segment
	int	21h
	pop	AX			; Restore end of device offset to AX

	cli				; Safety measure when altering DOSdata
	mov	WORD PTR ES:[DOS_TABLE], OFFSET VerList ; Offset of lie table
	mov	WORD PTR ES:[DOS_TABLE][2],CS	; Segment of lie table
	sti
	pop	ES
	pop	BX

SetDevEnd:
	mov	WORD PTR DS:[BX].DEV_LEN,AX ; Set end of driver @ end of list
	mov	DS:[BX].DEV_LEN[2],CS	; Set device segment
	mov	AH,00000001b		; Normal status return

	jmp	SetStatus		; End of init code

; ====================================================================

A_DEVICE ENDS

; ====================================================================

	END

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\setver\parse.c ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

/***************************************************************************/
/* PARSE.C 													 									*/				 
/*																									*/								 
/*	Command line parsing functions for SETVER.C.										*/
/*																									*/
/*	Valid command lines are:																*/
/*		List table: 					SETVER [D:\path] 									*/
/*		Add entry:						SETVER [D:\path] name.ext X.XX			 	*/
/*		Delete entry:					SETVER [D:\path] name.ext /DELETE		 	*/
/*		Display help					SETVER /? 											*/
/*		Delete entry quietly:		SETVER [D:\path] name.ext /DELETE /QUIET	*/
/*																									*/
/*	The following error codes are returned: 											*/
/*																									*/
/*		S_INVALID_SWITCH	Invalid switch										 			*/
/*		S_INVALID_FNAME	Invalid file name 								 			*/
/*		S_BAD_VERSION_FMT	Invalid version number format 		 					*/
/*		S_BAD_DRV_SPEC		Invalid drive/path specifier				 				*/
/*		S_TOO_MANY_PARMS	Too many command line parameters	 						*/
/*		S_MISSING_PARM		Missing parameter 								 			*/
/*		S_INVALID_PATH		Path specifier is invalid									*/
/*																									*/
/*	johnhe	05-01-90																			*/
/***************************************************************************/

#include	<stdio.h>
#include	<stdlib.h>
#include	<ctype.h>
#include	<string.h>
#include	<dos.h>
#include	<direct.h>

#include	<setver.h>

/***************************************************************************/
/* Parses the command line to get the optional drive letter, optional 		*/
/* executable file name and optional switch /DELETE. Also handles a single */
/* "/?" switch for displaying command help. The /DELETE switch will accept */
/* any number of chars in the the word DELETE for the switch. 	Also			*/
/* supports a /QUIET switch, similarly handled, but only valid in 			*/
/* combination with the /DELETE switch													*/
/*																									*/
/*	int ParseCmd( int argc, char *argv[], struct TableEntry *Entry )	 		*/
/*																									*/
/*	ARGUMENTS:	argc	- Count of command line arguments 					 		*/
/*					argv	- Array of ptrs to command line argments		 			*/
/*					Entry - Ptr to struct to be filled in 						 		*/
/*	RETURNS:		int 	- Valid function number or parse error code  			*/
/*																									*/
/***************************************************************************/

int ParseCmd( int argc, char *argv[], struct TableEntry *Entry )
{
	register		Funct;
	unsigned		uVersion;
	int			iTmp;
	int			iStrLen;

	strcpy( Entry->Path, argv[0] );			/* Set default setver.exe path	*/

	if ( argc == 1 )								/* Chk for default of 0 parms		*/
		return( DO_LIST );						/* No args so just do a listing	*/

	for ( iTmp = 1; iTmp < argc; iTmp++ )
		strupr( argv[ iTmp ] );					/* Convert params to upper case	*/

														/* Chk for help switch				*/
	if ( MatchSwitch( argv[ 1 ], HELP_SWITCH ) )
		return( argc > 2 ? S_TOO_MANY_PARMS : DO_HELP);

	iTmp = 1;

												/* Chk for optional drive:\path spec	*/
	if ( strchr( argv[1], ':' ) )
	{
		if ( IsValidDrive( argv[1][0] - 0x40 ) && argv[1][1] == ':' )
		{
			if ( (iStrLen = strlen( argv[1] )) > (MAX_PATH_LEN - 1) )
				return( S_INVALID_PATH );
			else
			{
				strcpy( Entry->Path, argv[1] );
#ifdef DBCS
				if ( (*(Entry->Path + iStrLen - 1) != '\\' && argv[1][2] != EOL )
					|| CheckDBCSTailByte(Entry->Path,Entry->Path + iStrLen - 1) )
#else
				if ( *(Entry->Path + iStrLen - 1) != '\\' && argv[1][2] != EOL )
#endif
					strcat( Entry->Path, "\\" );
				strcat( Entry->Path, "SETVER.EXE" );
				iTmp++;
			}
		}
		else
			return( S_BAD_DRV_SPEC );
	}

	if ( iTmp >= argc )
		Funct = DO_LIST;

	else if ( IsValidFileName( argv[ iTmp ] ) )
	{
		strcpy( Entry->szFileName, argv[ iTmp++ ] );

		if ( iTmp >= argc )				/* Version # or /D or /Q must follow	*/
			Funct = S_MISSING_PARM;

				/* note that Quiet switch requires Del switch also be supplied */
		else if ( MatchSwitch( argv[ iTmp ], DEL_SWITCH ) )
		{
			if ( ++iTmp < argc )	 /* more args left */
			{
				if (MatchSwitch(argv[iTmp], QUIET_SWITCH))
					Funct = (++iTmp < argc ? S_TOO_MANY_PARMS : DO_QUIET);
				else
					Funct = S_TOO_MANY_PARMS;
			}
			else
				Funct = DO_DELETE;
		}
		else if ( MatchSwitch( argv[iTmp], QUIET_SWITCH ) )
		{
			if ( ++iTmp < argc )						 /* must find delete switch	*/
				if (MatchSwitch(argv[iTmp], DEL_SWITCH))
					Funct = (++iTmp < argc ? S_TOO_MANY_PARMS : DO_QUIET);
				else
					Funct = S_INVALID_SWITCH;
			else
				Funct = S_INVALID_SWITCH;
		}
		else if ( *argv[iTmp] == '/' )		/* Make sure not a bogus switch	*/
			Funct = S_INVALID_SWITCH;
		else if ( (uVersion = ParseVersion( argv[ iTmp++ ] )) != 0 )
		{
			Entry->MajorVer = (char)(uVersion >> 8);
			Entry->MinorVer = (char)(uVersion & 0xff);
			Funct = (iTmp < argc ? S_TOO_MANY_PARMS : DO_ADD_FILE);
		}
		else
			Funct = S_BAD_VERSION_FMT;
	}
	else
		Funct = S_INVALID_FNAME;

	return( Funct );
}


/***************************************************************************/
/* Parses a DOS major and minor version number from an ascii string in the */
/* form of "00.00" where the major number is on the left of the decminal	*/
/* point and the minor version follows the version number. Valid version	*/
/* numbers are decimal numbers between 2.00 and 9.99.				 				*/
/*										 															*/
/*	unsigned ParseVersion( char *szDosVer )					 						*/
/*										 															*/
/*	ARGUMENTS:	szDosVer - Ptr to an ascii verion number string 	 			*/
/*	RETURNS:		unsigned - Version # in the form (Major << 8) + 	 			*/
/*								  Minor or 0 if not valid version string  			*/
/*																									*/
/***************************************************************************/

unsigned ParseVersion( char *szDosVer )
{
	unsigned		Version = 0;
	size_t		Len;
	char			*szMinor;

		/* First parse the minor version number */
	if ( (szMinor = strchr( szDosVer, '.' )) != NULL )
	{
		*szMinor = EOL;
		szMinor++;
		if ( (Len = strlen( szMinor )) > 2	|| !IsDigitStr( szMinor ) )
			Version = (unsigned) S_ERROR;
		else
		{
			Version = (unsigned)atoi( szMinor );
			while( Len++ < 2 )								/* Convert .x to .x0	*/
				Version *= 10;
		}
	}
		/* Now get the major part of the number */
	szDosVer = SkipLeadingChr( szDosVer, '0' );
	if ( Version == (unsigned)S_ERROR || strlen( szDosVer ) > 2 ||
			 !IsDigitStr( szDosVer ) )
		Version = 0;
	else
		Version |= ((unsigned)atoi( szDosVer ) << 8);

		/* Check for min and max versions */
	if ( Version < MIN_VERSION || Version >= MAX_VERSION )
		Version = 0;

	return( Version );
}

/***************************************************************************/
/* Checks a string to verify that all characters in the string are decmial */
/* numbers 0-9.									 											*/
/*										 															*/
/*	int IsDigitStr( char *szStr )						 									*/
/*										 															*/
/*	ARGUMENTS:	szStr - Ptr to ascii string to be scanned 				 		*/
/*	RETURNS:		int 	- TRUE if all chars are numbers else FALSE	 			*/
/*										 															*/
/***************************************************************************/

int IsDigitStr( char *szStr )
{
	while( *szStr != EOL	)
	{
		if ( !isdigit( *(szStr++) ) )
			return( FALSE );
	}
	return( TRUE );
}

/***************************************************************************/
/* Accepts a pointer to a string and a single character to match. Returns  */
/* a ptr to the first character in the string not matching the specified	*/
/* character.									 												*/
/*										 															*/
/*	char *SkipLeadingChr( char *szStr, char chChar )			 					*/
/*										 															*/
/*	ARGUMENTS:	szStr  - Ptr to an ascii string										*/
/*					chChar - Ascii character to match 								 	*/
/*	RETURNS:		char * - Ptr to first char in the string not			 			*/
/*								matching the specified character 				 		*/
/***************************************************************************/

char *SkipLeadingChr( char *szStr, char chChar )
{
	while( *szStr == chChar )
		szStr++;
	return( szStr );
}


/***************************************************************************/
/* Compares a cmd line switch against a test string. The test switch is an */
/* ascii string which will be used as a pattern to be matched against the  */
/* command string. The command string may be any subset of the test string */
/* which has been prefixed with a switch character.				 				*/
/*										 															*/
/*	int MatchSwitch( char *szCmdParm, char *szTestSwitch )			 			*/
/*										 															*/
/*	ARGUMENTS:	szCmdParm		- Command line parameter to be tested 			*/
/*					szTestSwitch	- Switch to test command line against 			*/
/*	RETURN:		int				- TRUE if there is a match else FALSE 			*/
/*																									*/
/***************************************************************************/

int MatchSwitch( char *szCmdParm, char *szTestSwitch )
{
		/* Must have a leading '/' and at least 1 char */
	if ( *(szCmdParm++) != SWITCH_CHAR || *szCmdParm == EOL )
		return( FALSE );

	while ( *szTestSwitch != EOL && *szTestSwitch == *szCmdParm )
		szTestSwitch++, szCmdParm++;

	return( *szCmdParm == EOL ? TRUE : FALSE );
}


/***************************************************************************/
/* Scans a string to see if the string can be used a valid file name.		*/
/* The scan checks to be sure each character in the name is a valid		 	*/
/* character for a path name. There is also a check to be sure that only	*/
/* there is not more than 1 decimal in the name and that if there is a		*/
/* decimal that the primary name and extension do not exceed the maximum	*/
/* length of 8 chars for primary and 3 for extension. If the name does		*/
/* not include a decimal the max length is 8 characters.			 				*/
/*										 															*/
/*	int IsValidFileName( char *szPath )					 								*/
/*										 															*/
/*	ARGUMENTS:	szFile - String containing a file name. 					 		*/
/*	RETURNS	:	int 	 - TRUE if valid name else FALSE. 					 		*/
/*										 															*/
/***************************************************************************/

int IsValidFileName( char *szFile )
{
	char *szDecimal;

	RemoveTrailing( szFile, '.' );

		/*
		 *	Check to be sure length of filename is greater than 0,
		 *	there are no invalid file characters,
		 *	there is no path associated with the filename,
		 *	the filename is not a reserved DOS filename, and
		 *	there are no wildcard characters used in the filename.
	 	*/
#ifdef DBCS
	if ( strlen( szFile ) > 0 && ValidFileChar( szFile ) &&
			 ((strchr(szFile, '\\') == NULL) || CheckDBCSTailByte(szFile,strchr(szFile, '\\'))) &&
			 !IsReservedName( szFile ) && !IsWildCards( szFile ) )
#else
	if ( strlen( szFile ) > 0 && ValidFileChar( szFile ) &&
			 (strchr(szFile, '\\') == NULL) &&
			 !IsReservedName( szFile ) && !IsWildCards( szFile ) )
#endif
	{
			/* Check for appropriate 8.3 filename */
		if ( (szDecimal = strchr( szFile, '.' )) != NULL )
		{
			if ( strchr( szDecimal + 1, '.' ) == NULL &&	/* Chk for more '.'s */
					 (szDecimal - szFile) <= 8 && 			/* Chk lengths			*/
					 (strchr( szDecimal, EOL ) - szDecimal - 1) <= 3 )
				return ( TRUE );
		}
		else if ( strlen( szFile ) <= 8 )
			return ( TRUE );
	}
	return( FALSE );
}

/***************************************************************************/
/* Checks all of the characters in a string to see if they are vaild path  */
/* name characaters.								 											*/
/*										 															*/
/*	int ValidFileChar( char *szFile )					 								*/
/*										 															*/
/*	ARGUMENTS:	szFile - File name string 												*/
/*	RETURN:		int 	 - TRUE if chars in string are valid else 	 			*/
/*								FALSE																*/
/*										 															*/
/***************************************************************************/

int ValidFileChar( char *szFile )
{
	int IsOk = TRUE;

	while ( IsOk && *szFile != EOL )
	#ifdef DBCS
		if (IsDBCSLeadByte(*szFile))
			szFile += 2;
		else
	#endif
		IsOk = IsValidFileChr( *(szFile++) );
	return( IsOk );
}


/***************************************************************************/
/* Checks a file or path name against a list of reserved DOS filenames and */
/* returns TRUE if the name is a reserved name. The function must first		*/
/* off any extension from the name.						 								*/
/*										 															*/
/*	int IsReservedName( char *szFile )					 								*/
/*										 															*/
/*	ARGUMENTS:	szFile - File name string				 								*/
/*	RETURN:		int 	 - TRUE if name is reserved DOS name				 		*/
/*																									*/
/***************************************************************************/

int IsReservedName( char *szFile )
{
	register Status;
	register i;
	char *szTmp;
	static char *apszRes[] = { "AUX", "CLOCK$", "COM1", "COM2",
										"COM3", "COM4", "CON", "LPT", "LPT1",
										"LPT2", "LPT3", "LST", "NUL", "PRN", NULL };

	if ( (szTmp = strchr( szFile, '.' )) != NULL )
		*szTmp = EOL;
	for ( i = 0, Status = FALSE; Status == FALSE && apszRes[i] != NULL; i++ )
		Status = !strcmpi( szFile, apszRes[i] );
	if ( szTmp != NULL )
		*szTmp = '.';

	return( Status );
}

/***************************************************************************/
/* Checks a file or path name for any wildcards (* and ?).	If wildcard 	*/
/* characters exist, it returns TRUE.  Otherwise, it returns FALSE. 			*/
/*										 															*/
/*	int IsWildCards( char *szFile )									 					*/
/*										 															*/
/*	ARGUMENTS:	szFile - File name string				 								*/
/*	RETURN:		int 	 - TRUE if wildcards exist in name					 		*/
/*																									*/
/***************************************************************************/

int IsWildCards( char *szFile )
{
	if ( ((strchr( szFile, '*' )) != NULL) ||
		  ((strchr( szFile, '?' )) != NULL) )
		return( TRUE );
	return( FALSE );
}


/***************************************************************************/
/* Validates a character as a valid path and file name character. 			*/
/*													 												*/
/*	IsValidFileChr( char Char )						 									*/
/*													 												*/
/*	ARGUMENTS:	Char - Character to be tested 										*/
/*	RETURNS:    int  - TRUE if a valid character else FALSE 		 				*/
/*													 												*/
/***************************************************************************/

int IsValidFileChr( char Char )
{
	int IsOk;

	switch( Char )
	{
		case ' '	:
		case '\t' :
		case 0x0d :
		case '/'	:
		case ':'	:
		case ';'	:
		case '='	:
		case '<'	:
		case '>'	:
		case '|'	:
			IsOk = FALSE;
			break;
		default		:
			IsOk = TRUE;
			break;
	}
	return( IsOk );
}

/***************************************************************************/
/* Removes all trailing characters of the type specified from a string. 	*/
/*																									*/
/*	void RemoveTrailing( char *String, char Char )							 		*/
/*																									*/
/*	ARGUMENTS:	String - pointer to a string				 							*/
/*					Char	 - ascii char to remove from end of string				*/
/*	RETURNS:	void							 													*/
/*										 															*/
/***************************************************************************/

void RemoveTrailing( char *String, char Char )
{
	char *EndOfString;

	EndOfString = strchr(String, EOL );
	while( EndOfString != String && *(EndOfString-1) == Char )
		EndOfString--;
	*EndOfString = EOL;
}

/***************************************************************************/
/* Copyright (c) 1989 - Microsoft Corp.                                    */
/* All rights reserved.                                                    */
/*                                                                         */
/* Returns a pointer to the first character in the filename which may or	*/
/* may not be appended to a path.														*/
/* 																								*/
/* char *ParseFileName( char *szPath ) 												*/
/* 																								*/
/* ARGUMENTS:	szPath	- Ptr to a file path in the form d:\xxxx\xxx.xxx	*/
/* RETURNS: 	char *	- Ptr to file name or character after last			*/
/* 							  backslash or ':' in the string if the path did	*/
/* 							  not contain a file name									*/
/*										 															*/
/***************************************************************************/

char *ParseFileName( char *szPath )
{
	char	*szPtr;

	for ( szPtr = szPath;
			*szPtr != EOL && (IsValidFileChr( *szPtr ) ||	*szPtr == ':');
			szPtr++ )
		#ifdef DBCS
			if (IsDBCSLeadByte(*szPtr))
				szPtr++;
		#else
			;
		#endif

	#ifdef DBCS
		while(( --szPtr >= szPath && *szPtr != '\\' && *szPtr != ':') ||
				(szPtr >= szPath && CheckDBCSTailByte(szPath,szPtr)) )
	#else
		while( --szPtr >= szPath && *szPtr != '\\' && *szPtr != ':' )
	#endif
			;

	return( ++szPtr );
}

#ifdef DBCS
/***************************************************************************/
/* Test if the character is DBCS lead byte. 											*/
/*																									*/
/*	int IsDBCSLeadByte(char c)																*/
/*																									*/
/*	ARGUMENTS:	c - character to test 													*/
/*	RETURNS:	TRUE if leadbyte																*/
/*										 															*/
/***************************************************************************/

int IsDBCSLeadByte(c)
unsigned char c;
{
	static unsigned char far *DBCSLeadByteTable = NULL;
	union REGS inregs,outregs;
	struct SREGS segregs;
	unsigned char far *p;


	if (DBCSLeadByteTable == NULL)
	{
		inregs.x.ax = 0x6300;							/* get DBCS lead byte table */
		intdosx(&inregs, &outregs, &segregs);
		FP_OFF(DBCSLeadByteTable) = outregs.x.si;
		FP_SEG(DBCSLeadByteTable) = segregs.ds;
	}

	p = DBCSLeadByteTable;
	while (p[0] || p[1])
	{
		if (c >= p[0] && c <= p[1])
			return TRUE;
		p += 2;
	}
	return ( FALSE );
}


/***************************************************************************/
/*
/*	Check if the character point is at tail byte
/*
/*	input:	*str = strart pointer of the string
/*		*point = character pointer to check
/*	output:	TRUE if at the tail byte
/*
/***************************************************************************/

int	CheckDBCSTailByte(str,point)
unsigned char *str,*point;
{
	unsigned char *p;

	p = point;
	while (p != str)
	{
		p--;
		if (!IsDBCSLeadByte(*p))
		{
			p++;
			break;
		}
	}
	return ((point - p) & 1 ? TRUE : FALSE);
}
#endif

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\share\gshare.asm ===
Title	Share_1

;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

;				   $SALUT (0,36,41,44)
				   include SHAREHDR.INC
;
;     Label: "The DOS SHARE Utility"
;
;******************* END OF SPECIFICATIONS *************************************

;
;	Revision History
;	================
;
;	M001	SR	9/10/90	Removed /NC support -- 'skip_check'
;				references.
;
;	M003	SR	10/1/90	Bug #2425 fixed. In ASC, check if the
;				SFT to be chained is the same as the
;				current SFT. Dont chain if so.
;



extrn				   fnm:near, rsc:near, rmn:near, cps:near, ofl:near, sle:near, interr:near

				   NAME Sharer

				   .xlist
				   .xcref
					include sf.inc
					include filemode.inc
					include mult.inc
					include syscall.inc
				   INCLUDE DOSSYM.INC
				   include dpl.asm
				   .cref
				   .list

AsmVars 			   <IBM, Installed>

Installed			   =	TRUE ; for installed version

OFF				   Macro reg,val
				   IF	installed
				   mov	reg,OFFSET val
				   ELSE
				   mov	si,OFFSET DOSGROUP:val
				   ENDIF
				   ENDM

ERRNZ				   Macro x
				   IF	x NE 0
				   %out ERRNZ failed
				   ENDIF
				   ENDM
; if we are installed, then define the base code segment of the sharer first

				   IF	Installed
Share				   SEGMENT PARA PUBLIC 'SHARE'
Share				   ENDS

	include dosseg.inc

;  include the rest of the segment definitions for normal msdos
; We CANNOT include dosseg because start is not declared para in that file

;	$SALUT	(4,9,17,36)

;START	 SEGMENT PARA PUBLIC 'START'
;START	 ENDS

;CONSTANTS SEGMENT WORD PUBLIC 'CONST'
;CONSTANTS ENDS

;DATA	 SEGMENT WORD PUBLIC 'DATA'
;DATA	 ENDS

;TABLE	 SEGMENT BYTE PUBLIC 'TABLE'
;TABLE	 ENDS

;CODE	 SEGMENT BYTE PUBLIC 'CODE'
;CODE	 ENDS

;LAST_SEG    SEGMENT PARA PUBLIC 'LAST_SEG'
;LAST_SEG    ENDS

;DOSGROUP GROUP  START,CONSTANTS,DATA,TABLE,CODE,LAST_SEG
	ELSE
	include dosseg.asm
	ENDIF

DOSDATA    SEGMENT WORD PUBLIC 'DATA'
	Extrn	ThisSFT:DWORD	   ; pointer to SFT entry
	Extrn	User_ID:WORD
	Extrn	Proc_ID:WORD
	Extrn	WFP_START:WORD
	Extrn	BytPos:DWORD
	extrn	OpenBuf:BYTE
	extrn	user_in_ax:WORD
	IF	debug
	    Extrn   BugLev:WORD
	    Extrn   BugTyp:WORD
	    include bugtyp.asm
	ENDIF
DOSDATA    ENDS

;   if we are not installed, then the code here is just part of the normal
;   MSDOS code segment otherwise, define our own code segment

	.sall
	IF	NOT INSTALLED
CODE	    SEGMENT BYTE PUBLIC 'CODE'
	    ASSUME  SS:DOSGROUP,CS:DOSGROUP
	ELSE
Share	    SEGMENT PARA PUBLIC 'SHARE'
	    ASSUME  SS:DOSDATA,CS:SHARE
	ENDIF

	extrn	MFT:BYTE
;SR;
; This message is now defined in another file for internationalization
;purposes.
;
	extrn	AscErr:BYTE

	include mft.inc

	PUBLIC	FreLock,Serial

	IF	installed
Frelock     DW	    ?		   ; FWA of lock free list
	ELSE
Frelock     DW	    OFFSET DOSDATA:lck8 ; FWA of lock free list
	ENDIF
Serial	DW	0		   ; serial number
DS_Org	dw	0		   ;an000;DS on entry to routine

ZERO	EQU	0
ONE	EQU	1

FRAME	struc

SavedBP dw	?
RetOFF	dw	?
Parm_1	dw	?
Parm_2	dw	?

FRAME	ends

;  $SALUT (4,4,9,41)

   BREAK <Sharer - MultiProcess File Sharer>

;******************* START OF SPECIFICATIONS ***********************************
;
;	MSDOS MFT Functions
;
;	The Master File Table (MFT) associates the cannonicalized pathnames,
;	lock records and SFTs for all files open on this machine.
;
;	These functions are supplied to maintain the MFT and extract
;	information from it.  All MFT access should be via these routines so
;	that the MFT structure can remain flexible.
;
;******************* END OF SPECIFICATIONS *************************************

   BREAK <Mft_enter - Make an MFT entry and check access>

;******************* START OF SPECIFICATIONS ***********************************
;
;	mft_enter - make an entry in the MFT
;
;	mft_enter is called to make an entry in the MFT.
;	mft_enter checks for a file sharing conflict:
;		No conflict:
;		    A new MFT entry is created, or the existing one updated,
;		    as appropriate.
;		Conflicts:
;		    The existing MFT is left alone.  Note that if we had to
;		    create a new MFT there cannot be, by definition, sharing
;		    conflicts.
;	If no conflict has been discovered, the SFT list for the file is
;	checked for one that matches the following conditions:
;
;	    If mode == 70 then
;		don't link in SFT
;		increment refcount
;	    If mode&sfIsFCB and userids match and process ids match then
;		don't link in SFT
;
;	ENTRY	ThisSFT points to an SFT structure.  The sf_mode field
;		    contains the desired sharing mode.
;		WFP_Start is an offset from DOSData of the full pathname for
;		    the file
;		User_ID = 16-bit user id of issuer
;		Proc_ID = 16-bit process id of issuer
;		(DS) = (SS) = DOSData
;	EXIT	'C' clear if no error'
;		'C' set if error
;		  (ax) = error code
;	USES	ALL but DS
;
;******************* END OF SPECIFICATIONS *************************************

   Procedure mft_enter,NEAR

;  int 3
   nop
   nop

   EnterCrit critShare

   DOSAssume SS <DS>,"MFT_Enter entry"
   ASSUME ES:NOTHING,SS:DOSDATA
   push ds

;	find or make a name record

   mov	si,WFP_Start			; (DS:SI) = FBA of file name
   mov	al,1				; allow creation of MFT entry
   push es

   ASSUME DS:NOTHING

   call FNM				; find or create name in MFT
   pop	es
   mov	ax,error_sharing_buffer_exceeded
   jc	ent9				; not enough space
;
;	(bx) = fwa name record
;
   lds	si,ThisSFT
   call ASC				; try to add to chain

;	As noted above, we don't have to worry about an "empty" name record
;	being left if ASC refuses to add the SFT - ASC cannot refuse if we had
;	just created the MFT...

;	return.
;
;	'C' and (Ax) setup appropriately

ent9: pop ds

   LeaveCrit critShare

   ret

   EndProc mft_enter

   BREAK <MftClose - Close out an MFT for given SFT>

;******************* START OF SPECIFICATIONS ***********************************
;
;	MFTclose
;
;	MFTclose(SFT)
;
;	MFTclose removes the SFT entry from the MFT structure.	If this was
;	the last SFT for the particular file the file's entry is also removed
;	from the MFT structure.  If the sharer is installed after some
;	processing has been done, the MFT field of the SFTs will be 0; we must
;	ignore these guys.
;
;	If the sft indicates FCB, we do nothing special.  The SFT behaves
;	    EXACTLY like a normal handle.
;
;	If the sft indicates mode 70 then we do nothing special.  These are
;	normal HANDLES.
;
;	Note that we always care about the SFT refcount.  A refcount of 1
;	means that the SFT is going idle and that we need to remove the sft
;	from the chain.
;
;	ENTRY	(ES:DI) points to an SFT structure
;		(DS) = (SS) = DOSData
;	EXIT	NONE
;	USES	ALL but DS, ES:DI
;
;******************* END OF SPECIFICATIONS *************************************

   Procedure MFTclose,NEAR

;  int 3
   nop
   nop

   EnterCrit critShare

   DOSAssume SS,<DS>,"MFTClose entry"
   ASSUME ES:NOTHING
   mov	ax,es:[di].sf_MFT

   fmt	TypShare,LevShEntry,<"MFTClose by $x:$x of $x:$x ($x)\n">,<User_ID,Proc_id,ES,DI,AX>

   or	ax,ax
   jz	mcl10				; No entry for it, ignore (carry clear)
   push ds
   push es
   push di
;;;call CSL				; clear SFT locks		       ;AC008;

   ASSUME DS:NOTHING

   mov	ax,es:[di].sf_ref_count 	; (ax) = ref count
;
; We need to release information in one of two spots.  First, when the SFT has
; a ref count of 0.  Here, there are no more referents and, thus, no sharing
; record need be kept.	Second, the ref count may be -1 indicating that the
; sft is being kept but that the sharing information is no longer needed.
; This occurs in creates of existing files, where we verify the allowed
; access, truncate the file and regain the access.  If the truncation
; generates an error, we do NOT want to have the access locked down.
;


   OR	AX,AX
   jz	mcl85				; ref count is 0 - don't dechain
   inc	ax				; -1 + 1 = 0.  Busy sft.
   jnz	mcl9
mcl85:
   call CSL				; clear SFT locks		       ;AC008;
   call RSC				; remove sft from chain
   jnz	mcl9				; not the last sft for this name
   call RMN				; remove name record
mcl9:
   pop	di				; restore regs for exit
   pop	es
   pop	ds
mcl10:
   LeaveCrit critShare

   ret

   EndProc MFTclose

   BREAK <MftClU - Close out all MFTs for given UID>

;******************* START OF SPECIFICATIONS ***********************************
;
;	MFTcloseU
;
;	MFTcloseM(UID)
;
;	MFTcloseM removes all entrys for user UID from the MFT structure.  We
;	    walk the MFT structure closing all relevant SFT's for the user.
;	    We do it the dumb way, iterating closes until the SF ref count is
;	    0.
;
;	ENTRY	User_ID = 16-bit user id of issuer
;		(SS) + DOSData
;	EXIT	'C' clear
;	USES	ALL
;
;******************* END OF SPECIFICATIONS *************************************

   Procedure MFTclU,NEAR

;  int 3
   nop
   nop

   ASSUME DS:NOTHING,ES:NOTHING,SS:DOSDATA

   EnterCrit critShare
   mov	ax,User_ID

   fmt	TypShare,LevShEntry,<"\nCloseUser $x\n">,<AX>

   sub	bx,bx				; insensitive to PID
   sub	dx,dx
   invoke BCS				; bulk close the SFTs
   LeaveCrit critShare
   return
   EndProc MFTclU

   BREAK <MftCloseP - Close out all MFTs for given UID/PID>

;******************* START OF SPECIFICATIONS ***********************************
;
;	MFTcloseP
;
;	MFTcloseP(PID, UID)
;
;	MFTcloseP removes all entrys for process PID on machine MID from the
;	    MFT structure.  We walk the MFT structure closing all relevant
;	    SFT's.  Do it the dumb way by iterating closes until the SFTs
;	    disappear.
;
;	ENTRY	(SS) = DOSDATA
;		User_ID = 16-bit user id of issuer
;		Proc_ID = 16-bit process id of issuer
;	EXIT	'C' clear
;	USES	ALL
;
;******************* END OF SPECIFICATIONS *************************************

   Procedure MFTcloseP,NEAR

;  int 3
   nop
   nop

   ASSUME DS:NOTHING,ES:NOTHING,SS:DOSDATA

   EnterCrit critShare
   mov	ax,User_ID
   mov	bx,-1
   mov	dx,Proc_ID

   fmt	TypShare,LevShEntry,<"\nClose UID/PID $x:$x\n">,<AX,DX>

   call BCS				; Bulk close the SFTs
   LeaveCrit critShare

   ret

   EndProc MFTcloseP

   BREAK <MftCloN - Close file by name>

;******************* START OF SPECIFICATIONS ***********************************
;
;	MFTcloseN
;
;	MFTcloseN(name)
;
;	MFTcloseN removes all entrys for the given file from the MFT
;	structure.
;
;	NOTE: this function is used infrequently and need not be fast.
;		(although for typical use it's not all that slow...)
;
;	ENTRY	DS:SI point to dpl.
;		(SS) = DOSData
;	EXIT	'C' clear if no error
;		'C' set if error
;		  AX = error_path_not_found if not currently open
;	USES	ALL
;
;******************* END OF SPECIFICATIONS *************************************

   Procedure MFTcloN,NEAR

;  int 3
   nop
   nop

   ASSUME SS:DOSDATA,ES:NOTHING,DS:NOTHING

   EnterCrit critShare
   MOV	DX,[SI.DPL_DX]
   MOV	DS,[SI.DPL_DS]
   mov	si,dx				; (DS:SI) = fwa name
   sub	al,al				; don't create if not found
   push ds
   push si
   call FNM				; find name in MFT
   mov	ax,error_path_not_found 	; assume error
   jc	mclo9				; not found exit

;	Name was found.  Lets yank the SFT entrys one at a time.

mclo1: les di,[bx].mft_sptr		; (ES:DI) = SFT address
   mov	WORD PTR ThisSFT,di
   mov	WORD PTR ThisSFT+2,es		; point to SFT
   cmp	es:[di].sf_ref_count,1
   jnz	mclo15
   call CPS
mclo15:
   Context DS

   IF	installed
       MOV  AX,(multDOS SHL 8) + 1
       INT  2FH
   ELSE
       call DOS_Close
   ENDIF
mclo2:

   ASSUME DS:NOTHING

   pop	si
   pop	ds
   push ds
   push si
   sub	al,al				; don't create an entry
   call FNM				; find the name gain
   jnc	mclo1				; got still more
   clc

;	exit.  'C' and (ax) setup
;
;	(TOS+2:TOS) = address of ASCIZ string

mclo9: pop si				; clean stack
   pop	ds
   LeaveCrit critShare

   ret

   EndProc MFTcloN

   BREAK <Set_Mult_Block - Try to set multiple locks>

;******************* START OF SPECIFICATIONS ***********************************
;
;  NAME:	   Set_Mult_Block  -  Set Multiple Block Locks
;
;  FUNCTION:	   Set_Mult_Block sets a lock on 1 or more specified ranges
;		   of a file.  An error is returned if any lock range conflicts
;		   with another. Ranges of Locks are cleared via Clr_Mult_Block.
;
;		   In DOS 3.3 only one lock range could be set at a time using
;		   Set_Block.  For DOS 4.00 this routine will replace Set_Block
;		   in the jump table and will make repeated calls to Set_Block
;		   in order to process 1 or more lock ranges.
;
;		   NOTE: - This is an all new interface to IBMDOS
;
;  INPUT:	   (AL) = 0  - lock all
;			= 80 - lock write
;		   (CX) = the number of lock ranges
;		   (DS:DX) = pointer to the range list
;		   (ES:DI) = SFT address
;		   User_ID = 16-bit user id of issuer
;		   Proc_ID = 16-bit process id of issuer
;		   (SS) = DOSData
;
;  OUTPUT:	   Lock records filled in for all blocks specified
;
;  REGISTERS USED: ALL but DS
;  (NOT RESTORED)
;
;  LINKAGE:	   IBMDOS Jump Table
;
;  EXTERNAL	   Invoke: Load_Regs, Set_Block, Clr_Block
;  REFERENCES:
;
;  NORMAL	   'C' clear if no error
;  EXIT:
;
;  ERROR	   'C' set if error
;  EXIT:	     (ax) = error code
;			       ('error_lock_violation' if conflicting locks)
;
;  CHANGE	04/15/87 - First release
;  LOG:
;
;******************* END OF SPECIFICATIONS *************************************
;******************+ START OF PSEUDOCODE +**************************************
;
;	START Set_Mult_Block
;
;	count = start_count
;	search till count = 0
;		invoke Load_Regs
;		invoke Set_Block
;	exit if error
;		clear_count = start_count - current_count
;		loop till clear_count = 0
;			invoke Load_Regs
;			invoke Clr_Block
;		leave if error
;		end loop
;		set error status
;	orelse
;	endloop
;		set successful status
;	endsrch
;	if error status
;		load return code
;	endif
;	return
;
;	END Set_Mult_Block
;
;******************+  END  OF PSEUDOCODE +**************************************

   Procedure Set_Mult_Block,NEAR

;	PUSH	DS			;ICE
;	push	bx			;ICE
;	push	ax			;ICE

;	mov	bx,0140H		;ICE
;	xor	ax,ax			;ICE
;	mov	ds,ax			;ICE
;	mov	ax,word ptr ds:[bx]	;ICE
;	mov	word ptr ds:[bx],ax	;ICE

;	pop	ax			;ICE
;	pop	bx			;ICE
;	POP	DS			;ICE



   EnterCrit critShare			;				       ;AN000;

   ASSUME ES:NOTHING,DS:NOTHING 	;				       ;AN000;
;	      set up for loop

;      WE HAVE:   (from IBMDOS) 	|	  WE NEED:   (for Set_Block)

; (AL)	  = 0 - lock all		|    (BX)    = 0 lock all operations
;	  = 80- lock write		|	     = 1 lock write operations
; (CX)	  = the number of lock ranges	|    (CX:DX) = offset of area
; (DS:DX) = pointer to the range list	|    (SI:AX) = length of area
; (ES:DI) = SFT address 		|    (ES:DI) = SFT address

;  int 3
   nop
   nop

   mov	DS_Org,ds			;an000;save entry DS

   Context DS				;				       ;AN000;
   CMP	CX,01h				;DO WE HAVE A COUNT?		       ;AN000;

;; $if	ae				; if the count was valid	       ;AN000;
;  $if	e				; if the count was valid	       ;AC006;
   JNE $$IF1

;;     PUSH CX				; count = start_count		       ;AN000;
;;     PUSH DX				; save pointer to range list	       ;AN000;
       MOV  BP,DX			; save current index into list	       ;AN000;
;;     AND  AX,0080H			; clear high byte and be sure low is   ;AN000;
					; set if applicable
;;     ROL  AL,1			; move high bit to bit 0
;;     MOV  BX,AX			; SET UP TYPE OF LOCK		       ;AN000;

;;     $do				; loop till count = 0		       ;AN000;
;;	   cmp	cx,00			;an000;see if at end
;;     $leave e 			;an000;exit if at end
;;	   push cx			;an000;save cx - our counter
;;	   push di			;an000;save di - our SFT pointer
       call load_regs			;an000;load the registers for call
					;      to set_block
       call set_block			;an000;set the lock block
;SR;
; This routine destroys the error code returned by set_block and returns
;lock violation in case of any error. We want to preserve the error code
;returned by set_block. So, we are going to jump directly to return point
;on an error.
;
       jc   $$IF4

;;	   pop	di			;an000;restore our SFT pointer
;;	   pop	cx			;an000;restore cx - our counter
;;     $leave c 			;an000;on error exit loop
;;	   dec	cx			;an000;decrease counter
;;     $enddo				;an000;end loop

;;     $if  c				;an000;if an error occurred
;;	   pop	dx			;an000;restore range list pointer
;;	   pop	ax			;an000;obtain original count
;;	   sub	ax,cx			;an000;determine how many locks set
;;	   mov	cx,ax			;an000;set the loop counter with count
;;	   mov	bp,dx			;an000;set bp to point to range list
;;	   $do				;an000;while cx not = 0
;;	       cmp  cx,00		;an000;at end?
;;	   $leave e			;an000;yes, exit
;;	       push cx			;an000;save cx - our counter
;;	       push di			;an000;save di - our SFT pointer
;;	       call load_regs		;an000;load the registers for call
					;      to clr_block
;;	       call clr_block		;an000;clear the locks
;;	       pop  di			;an000;restore our SFT pointer
;;	       pop  cx			;an000;restore cx - our counter
;;	   $leave c			;an000;on error exit
;;	       dec  cx			;an000;decrease counter
;;	   $enddo			;an000;
;;	   stc				;an000;signal an error occurred
;;     $else				;an000;no error occurred in locking
;;	   pop	ax			;an000;clear off the stack
;;	   pop	ax			;an000;   to balance it
;;	   clc				;an000;signal no error occurred
;;     $endif				;an000;
;  $else				;an000;cx was 0 - this is an error
   JMP SHORT $$EN1
$$IF1:
       stc				;an000;signal an error occurred
;  $endif				;				       ;an000;
$$EN1:

;  $if	c				; if there was an error 	       ;AN000;
   JNC $$IF4
       MOV  AX,error_lock_violation	; load the return code		       ;AN000;
;  $endif				; endif there was an error	       ;AN000;
$$IF4:

   LeaveCrit critShare			;				       ;AN000;

   ret					; return - all set		       ;AN000;

   EndProc Set_Mult_Block

   BREAK <Load_Regs - Load Registers for ?_Block call>

;******************* START OF SPECIFICATIONS ***********************************
;
;  NAME:	   Load_Regs - Load Registers for ?_Block calls
;
;  FUNCTION:	   This subroutine loads the High and Low Offsets and the
;		   High and Low lengths for Lock ranges from the Range List.
;
;  INPUT:	   (DS_Org:PB) - Range list entry to be loaded
;
;  OUTPUT:	   (DX) - Low Offset
;		   (CX) - High Offset
;		   (AX) - Low Length
;		   (SI) - High Length
;
;  REGISTERS USED: AX CX DX BP SI
;  (NOT RESTORED)
;
;  LINKAGE:	   Called by: Set_Mult_Block, Clr_Mult_Block
;
;  EXTERNAL	   none
;  REFERENCES:
;
;  NORMAL	   none
;  EXIT:
;
;  ERROR	   none
;  EXIT:
;
;  CHANGE	   04/15/87 - first release
;  LOG:
;
;******************* END OF SPECIFICATIONS *************************************
;******************+ START OF PSEUDOCODE +**************************************
;
;	  START Load_Regs
;
;	  recover index into range list
;	  advance pointer to next entry
;	  load DX - Low Offset
;	  load CX - High Offset
;	  load AX - Low Length
;	  load SI - High Length
;	  return
;
;	  END Load_Regs
;
;******************+  END  OF PSEUDOCODE +**************************************

   Procedure Load_Regs,NEAR

   push ds				; save our DS			       ;an000;
   mov	ds,DS_Org			; get range list segment	       ;an000;
   mov	si,bp				; recover pointer		       ;AN000;
   ADD	BP,08h				; move to next entry in list	       ;AN000;
   MOV	DX,[SI] 			; low position			       ;AN000;
   MOV	CX,[SI+2]			; high position 		       ;AN000;
   MOV	AX,[SI+4]			; low length			       ;AN000;
   MOV	SI,[SI+6]			; high length			       ;AN000;
   pop	ds				; restore DS			       ;an000;

   ret					;				       ;AN000;

   EndProc Load_Regs

   BREAK <Clr_Mult_Block - Try to clear multiple locks>

;******************* START OF SPECIFICATIONS ***********************************
;
;  NAME:	   Clr_Mult_Block  -  Clear Multiple Block Locks
;
;  FUNCTION:	   Clr_Mult_Block removes the locks on 1 or more specified
;		   ranges of a file.  An error is returned if any lock range
;		   does not exactly match. Ranges of Locks are set via
;		   Set_Mult_Block.
;
;		   In DOS 3.3 only one lock range could be cleared at a time
;		   using Clr_Block.  For DOS 4.00 this routine will replace
;		   Clr_Block in the jump table and will make repeated calls
;		   to Set_Block in order to process 1 or more lock ranges.
;
;		   NOTE: - This is an all new interface to IBMDOS
;			 - an unlock all 'lock all' request will unlock both
;			   'lock all' and 'lock write'.
;			 - an unlock all 'lock write' request will not unlock
;			   'lock all's. It will only unlock 'lock write's.
;			  (if you can understand the above statement,
;			  understanding the code will be easy!)
;
;  INPUT:	   (AL) = 0 - lock all
;			= 80- lock write
;		   (CX) = the number of lock ranges - NB: all if -1 ***
;		   (DS:DX) = pointer to the range list
;		   (ES:DI) = SFT address
;		   User_ID = 16-bit user id of issuer
;		   Proc_ID = 16-bit process id of issuer
;		   (SS) = DOSData
;
;  OUTPUT:	   Lock records filled in for all blocks specified
;
;  REGISTERS USED: ALL but DS
;  (NOT RESTORED)
;
;  LINKAGE:	   IBMDOS Jump Table
;
;  EXTERNAL	   Invoke: Load_Regs, Set_Block, Clr_Block, Clr_List
;  REFERENCES:
;
;  NORMAL	   'C' clear if no error
;  EXIT:
;
;  ERROR	   'C' set if error
;  EXIT:	     (ax) = error code
;			       ('error_lock_violation' if conflicting locks)
;
;  CHANGE	04/15/87 - First release
;  LOG:
;
;******************* END OF SPECIFICATIONS *************************************
;******************+ START OF PSEUDOCODE +**************************************
;
;	START Clr_Mult_Block
;
;	if count is valid and
;	if file (SFT) is 'shared' then
;		if count = all
;			find first RLR
;			loop till all RLR cleared
;				if PROC_ID matches and
;				if UID matches and
;				if SFT matches then
;					if ulocking lock_all or
;					if this RLR is lock_write
;						clear the lock
;					endif
;				endif
;				find next RLR
;			end loop
;		else
;			invoke Clr_List
;		endif
;		set successful status
;	else
;		set error status
;	endif
;	if error
;		load return code
;	endif
;
;	ret
;
;	END Clr_Mult_Block
;
;******************+  END  OF PSEUDOCODE +**************************************

   Procedure clr_mult_block,NEAR


lock_all equ 0h

;	PUSH	DS			;ICE
;	push	bx			;ICE
;	push	ax			;ICE

;	mov	bx,0140H		;ICE
;	xor	ax,ax			;ICE
;	mov	ds,ax			;ICE
;	mov	ax,word ptr ds:[bx]	;ICE
;	mov	word ptr ds:[bx],ax	;ICE

;	pop	ax			;ICE
;	pop	bx			;ICE
;	POP	DS			;ICE

   EnterCrit critShare			;				       ;AN000;

   ASSUME ES:NOTHING,DS:NOTHING 	;				       ;AN000;

;  int 3
   nop
   nop

   mov	DS_Org,DS			;an000;save entry DS

   Context DS				;				       ;AN000;

   CMP	CX,01h				; do we have a count?		       ;AN000;
;; $IF	AE,AND				; IF A VALID COUNT
;  $IF	E,AND				; IF A VALID COUNT		       ;AC006;
   JNE $$IF6
   cmp	es:[di].sf_mft,0		; is this SFT shared?		       ;AN000;
;  $IF	NE				; AND IF FILE IS 'SHARED' THEN
   JE $$IF6

;      WE HAVE:   (from IBMDOS) 	|	  WE NEED:

; (AL)	  = 0 - lock all		|    (AX)    = 0 lock all operations
;	  = 80- lock write		|	     = 1 lock write operations
; (CX)	  = - 1  (unlock all locks)	|    (DS)    = CS
;					|    (DS:DI) = previous RLR
;					|    (DS:SI) = current RLR
; (ES:DI) = current SFT 		|

;;     and  ax,0080h			;be sure it is set right (mask 80 bit) ;AC002;
					;    existing interface
;;     rol  al,1			;put high bit in bit 0		       ;AC002;

;;     CMP  CX,-1h			;				       ;AN000;
;;     $IF  E				; IF unlock all locks then	       ;AN000;

;;	   push cs			;				       ;AN000;
;;	   pop	ds			;				       ;AN000;
;;	   mov	cx,di			; ES:CX is the SFT		       ;AN004;

;	   ASSUME ds:nothing

;;	   mov	si,es:[di].sf_mft	; DS:SI points to MFT		       ;AN000;

;;	   lea	di,[si].mft_lptr	; DS:DI = addr of ptr to lock record   ;AN000;
;;	   mov	si,[di] 		; DS:SI = address of 1st lock record   ;AN000;

;;	   $DO				; loop through the RLR's               ;AN000;

;	DS:DI = points to previous RLR or MFT if no RLR.
;	DS:SI = points to current RLR
;	ES:CX = SFT address
;	AX    = lock type

;;	       and  si,si		; are we at the end of the chain?      ;AN000;
;;	   $LEAVE Z			; we'er done with CF = 0               ;AN000;

;;	       mov  bp,[si].rlr_pid	; get PROC_ID			       ;AN000;
;;	       cmp  bp,PROC_ID		; is it ours?			       ;AN000;
;;	       $IF  E,AND		;				       ;AN000;
;;	       mov  bp,es		;				       ;AN000;
;;	       cmp  bp,WORD PTR [si].rlr_sptr+2 ;			       ;AC004;
;;	       $IF  E,AND		;				       ;AN000;
;;	       cmp  cx,WORD PTR [si].rlr_sptr ; 			       ;AC004;
;;	       mov  si,[di]		; restore pointer to current (using    ;AN000;
					;			     previous)
;;	       $IF  E			; if it is ours 		       ;AN000;

;	this is it. its OURS !

;;		   cmp	ax,lock_all	;				       ;AN000;

;;		   $IF	E,OR		; if unlocking all or		       ;AN000;

;;		   mov	bp,[si].rlr_type ; get lock type		       ;AN000;
;;		   cmp	bp,rlr_lall	; is it lock all?		       ;AN000;

;;		   $IF	NE		; if not a LOCK ALL lock	       ;AN000;

;	remove the RLR from the chain

;;		       mov  bx,[si].rlr_next ; get the pointer to the next RLR ;AN000;
;;		       mov  [di],bx	; install it in the last	       ;AN000;

;	put defunct lock record on the free chain

;;		       mov  bx,Frelock	;				       ;AN000;
;;		       mov  [si].rlr_next,bx ;				       ;AN000;
;;		       mov  Frelock,si	;				       ;AN000;
;;		       mov  si,di	; back up to last		       ;AN000;

;;		   $ENDIF		; should we unlock it		       ;AN000;

;;	       $ENDIF			; it was ours!			       ;AN000;

;	advance to next RLR

;;	       mov  di,si		; load address of next RLR	       ;AN000;
;;	       mov  si,[di]		; update pointer to next RLR	       ;AN000;

;;	   $ENDDO			; loop back to the start	       ;AN000;

;;     $ELSE				; else, its a LIST !		       ;AN000;

;	      set up for loop

;      WE HAVE:   (from IBMDOS) 	|	  WE NEED:   (for Clr_Block)

; (AX)	  = 0 - lock all		|    (BX)    = 0 lock all operations
;	  = 1 - lock write		|	     = 1 lock write operations
; (CX)	  = the number of lock ranges	|    (CX:DX) = offset of area
; (DS:DX) = pointer to the range list	|    (SI:AX) = length of area
; (ES:DI) = SFT address 		|    (ES:DI) = SFT address

;;	   PUSH CX			; count = start_count		       ;AN000;
;;	   PUSH DX			; save pointer to range list	       ;AN000;
       MOV  BP,DX			; save current index into list	       ;AN000;
;;	   MOV	BX,AX			; SET UP TYPE OF LOCK		       ;AN000;

       call Clr_List			; call Clr_List to process the list    ;AN000;

;;     $ENDIF				;				       ;AN000;

;  $ELSE				; NOT VALID
   JMP SHORT $$EN6
$$IF6:

       STC				;				       ;AN000;

;  $ENDIF				; VALID/INVALID 		       ;AN000;
$$EN6:

;  $IF	C				; if carry is set		       ;AN000;
   JNC $$IF9
       MOV  AX,error_lock_violation	; load error condition		       ;AN000;
;  $ENDIF				; carry not set 		       ;AN000;
$$IF9:

   LeaveCrit critShare			;				       ;AN000;

   ret					; return - all set		       ;AN000;

   EndProc clr_mult_block

   BREAK <Clr_List - Clear a list of user specified locks>

;******************* START OF SPECIFICATIONS ***********************************
;
;  NAME:	   Clr_List  -	Clear a list of user specified locks
;
;  FUNCTION:	   Clr_List makes multiple calls to Clr_Block to clear
;		   multiple lock ranges of a file.  An error is returned
;		   if any lock range does not exactly match. Ranges of
;		   Locks are then set via Set_Mult_Block.
;
;
;  INPUT:	   (BX)    = 0 lock all operations
;			   = 1 lock write operations
;		   (CX:DX) = offset of area
;		   (SI:AX) = length of area
;		   (ES:DI) = SFT address
;		   (SS:SP+2)= original index \ see FRAME struc
;		   (SS:SP+4)= original count /
;
;  OUTPUT:	   Lock records removed for all blocks specified
;		   Stack cleard on return
;
;  REGISTERS USED: ALL but DS
;  (NOT RESTORED)
;
;  LINKAGE:	   IBMDOS Jump Table
;
;  EXTERNAL	   Invoke: Load_Regs, Set_Block, Clr_Block
;  REFERENCES:
;
;  NORMAL	   'C' clear if no error
;  EXIT:
;
;  ERROR	   'C' set if error
;  EXIT:	     (ax) = error code
;			       ('error_lock_violation' if conflicting locks)
;
;  CHANGE	04/15/87 - First release
;  LOG:
;
;******************* END OF SPECIFICATIONS *************************************
;******************+ START OF PSEUDOCODE +**************************************
;
;	START Clr_List
;
;	search till count = 0
;		set up for call
;		call clr_Block
;	exit if c
;		clear_count = start_count - current_count
;		loop till clear_count = 0
;			set up for call
;			call Set_Block
;		end loop
;		set error status
;	orelse
;	endloop
;		set successful status
;	endsrch
;	return
;
;	END Clr_List
;
;******************+  END  OF PSEUDOCODE +**************************************

   Procedure Clr_List,NEAR

;; $do					;an000;while cx not = 0
;;     cmp  cx,00			;an000;at end?
;; $leave e				;an000;yes
;;     push cx				;an000;save cx - our counter
;;     push di				;an000;save di - our SFT pointer
   call load_regs			;an000;set up for clr_block call
;;     push bp				; save pointer to range entry	       ;AN000;
   call clr_block			;an000;remove the lock
;;     pop  bp				; recover pointer to range entry       ;AN000;
;;     pop  di				;an000;restore our SFT pointer
;;     pop  cx				;an000;restore cx - our counter
;; $leave c				;an000;leave on error
;;     dec  cx				;an000;decrease counter
;; $enddo				;an000;

;; $if	c				;an000;an error occurred
;;     push bp				;an000;save bp
;;     mov  bp,sp			;an000;get sp
;;     mov  dx,[bp].parm_1		;an000;recover original index
;;     mov  ax,[bp].Parm_2		; original count		       ;AN000;
;;     pop  bp
;;     SUB  AX,CX			; how many did we do?		       ;AN000;
;;     MOV  CX,AX			; set up the loop		       ;AN000;
;;     MOV  BP,DX			; save the index		       ;AN000;

;;     $DO				;				       ;AN000;
;;	   cmp	cx,00			;an000;at end?
;;     $leave e 			;an000;yes
;;	   push cx			;an000;save cx - our counter
;;	   push di			;an000;save di - our SFT pointer
;;	   call load_regs		;an000;set up for set_block call
;;	   call set_block		;an000;reset the locks
;;	   pop	di			;an000;restore our SFT pointer
;;	   pop	cx			;an000;restore cx - our counter
;;     $leave c 			;an000;leave on error
;;	   dec	cx			;an000;decrease counter
;;     $enddo				;an000;
;;     stc				;an000;signal an error
;; $else				;an000;
;;     clc				;an000;signal no error
;; $endif				;an000;

;; ret	4				; return (clear Parm_1 & Parm_2)       ;AN000;
   ret					; return (clear Parm_1 & Parm_2)       ;AC006;

   EndProc Clr_List


   BREAK <Set_Block - Try to set a lock>

;******************* START OF SPECIFICATIONS ***********************************
;
;  NAME:	   Set_Block - set byte range lock on a file
;
;  FUNCTION:	   Set_Block sets a lock on a specified range of a file.  An
;		   error is returned if the lock conflicts with another.
;		   Locks are cleared via clr_block.
;
;  INPUT:	   (ES:DI) = SFT address
;		   (CX:DX) = offset of area
;		   (SI:AX) = length of area
;		   (BX)    = 0 lock all operations
;			   = 1 lock write operations
;		   User_ID = 16-bit user id of issuer
;		   Proc_ID = 16-bit process id of issuer
;		   (SS) = DOSData
;
;  OUTPUT:	   Lock records removed for all blocks specified
;
;  REGISTERS USED: ALL but DS, BP
;  (NOT RESTORED)
;
;  LINKAGE:	   Invoked by: Set_Mult_Block
;
;  EXTERNAL	   Invoke: CLP (SLE), OFL
;  REFERENCES:
;
;  NORMAL	   'C' clear if no error
;  EXIT:
;
;  ERROR	   'C' set if error
;  EXIT:
;
;  CHANGE	04/15/87 - lock only write support
;  LOG:
;
;******************* END OF SPECIFICATIONS *************************************
;******************+ START OF PSEUDOCODE +**************************************
;
;	START Set_Block
;
;	if a valid SFT and
;	invoke CLP
;	if no lock conflicts and
;	invoke OFL
;	if empty lock record available
;		store SFT pointer
;		store lock range
;		add RLR to the chain
;		store PROC_ID
;		store rlr_type
;		set successful return status
;	else
;		set error return status
;	endif
;	return
;
;	END Set_Block
;
;******************+  END  OF PSEUDOCODE +**************************************

   Procedure Set_Block,NEAR

   ASSUME ES:NOTHING,DS:NOTHING

   Context DS

   push bp				; preserve (bp) 		       ;AN000;
   push ds				; preserve (ds)
;; push bx				; preserve (bx) 		       ;AN000;
   cmp	es:[di].sf_mft,ZERO
;  $if	nz,and				; if file is SHARED and 	       ;AC000;
   JZ $$IF11
   push di
   call clp				; do common setup code

   ASSUME DS:NOTHING

   pop	bp
;  $if	nc,and				; if no (lock conflict) error and      ;AC000;
   JC $$IF11

;	Its ok to set this lock.  Get a free block and fill it in
;	(es:bp) = sft
;	(ds:si) = pointer to name record
;	(ax:bx) = fba lock area
;	(cx:dx) = lba lock area
;	(ds:di) = pointer to pointer to previous lock
;	(TOS)	= saved (bx)
;	(TOS+1) = saved (ds)
;	(TOS+2) = saved (bp)

   call OFL				; (ds:di) = pointer to new, orphan lock record
;  $if	nc				; if space available		       ;AC000;

;SR;
; We have to return out_of_buffer error code in case no more locks can be
;allocated. The old code was returning a lock violation for this case also.
;
       JC out_of_space

       mov  WORD PTR [di].rlr_sptr,bp	; store SFT offset
       mov  WORD PTR [di].rlr_sptr+2,es ; store SFT offset
       mov  [di].rlr_fba+2,ax
       mov  [di].rlr_fba,bx		; store lock range
       mov  [di].rlr_lba+2,cx
       mov  [di].rlr_lba,dx

;	add to front of chain
;
;	(ds:si) = fwa MFT name record

       mov  ax,[si].mft_lptr
       mov  [di].rlr_next,ax
       mov  [si].mft_lptr,di
;
; Set process ID of lock
;
       mov  ax,proc_id
       mov  [di].rlr_pid,ax

;
;;     pop  bx				; recover lock type		       ;AN000;
;;     push bx				; restore the stack		       ;AN000;
;;     mov  [di].rlr_type,bx		; set the rlr_type field	       ;AN000;
       clc				; we finished OK

;  $else				;				       ;AC000;
   JMP SHORT $$EN11

;SR;
;We have to return a separate error code if we run out of space for locks
;
out_of_space:
       mov	ax,error_sharing_buffer_exceeded
       jmp	short $$EN11

$$IF11:

       mov  ax,error_lock_violation
       stc

;  $endif				;				       ;AC000;
$$EN11:

;; pop	bx				;				       ;AN000;
   pop	ds
   pop	bp				;				       ;AC000;

   ret					; return - all set

   EndProc Set_Block

   BREAK <Clr_Block - Try to clear a lock>

;******************* START OF SPECIFICATIONS ***********************************
;
;  NAME:	   Clr_Block - clear byte range lock on a file
;
;  FUNCTION:	   Clr_Block clears a lock on a specified range of a file.
;		   Locks are set via set_block.
;
;  INPUT:	   (ES:DI) = SFT address
;		   (CX:DX) = offset of area
;		   (SI:AX) = length of area
;		   (BX)    = 0 lock all operations
;			   = 1 lock write operations
;		   User_ID = 16-bit user id of issuer
;		   Proc_ID = 16-bit process id of issuer
;		   (SS) = DOSData
;
;  OUTPUT:	   Lock record removed for block specified.
;
;  REGISTERS USED: ALL but DS
;  (NOT RESTORED)
;
;  LINKAGE:	   Invoked by:	Clr_Mult_Block
;
;  EXTERNAL	   Invoke: CLP (SLE), OFL
;  REFERENCES:
;
;  NORMAL	   'C' clear if no error
;  EXIT:
;
;  ERROR	   'C' set if error
;  EXIT:	     (ax) = error code
;			       ('error_lock_violation' if conflicting locks or
;			       range does not exactly match previous lock)
;
;  CHANGE	04/15/87 - lock only write support
;  LOG:
;
;******************* END OF SPECIFICATIONS *************************************
;******************+ START OF PSEUDOCODE +**************************************
;
;	START Clr_Block
;
;	if file is SHARED and
;	if lock is valid and
;	if SFT matches and
;	if PROC_ID matches
;		if lock_reqest = lock_type
;			unchain the lock
;			put defunct lock on free chain
;			clear error status
;		else
;			set error status
;		endif
;	else
;		flush the stack
;		set error status
;	endif
;	if error
;		load return code
;	endif
;	return
;
;	END Clr_Block
;
;******************+  END  OF PSEUDOCODE +**************************************

   Procedure Clr_Block,NEAR

   ASSUME ES:NOTHING,DS:NOTHING

   Context DS
   push ds
;; push bx				; save type of operation	       ;AN000;
   cmp	es:[di].sf_mft,ZERO

;  $if	nz,and				; if file is SHARED and 	       ;AC000;
   JZ $$IF14

   push di
   call clp				; do common setup code

   ASSUME DS:NOTHING

   pop	bp				; ES:BP points to sft.
;; pop	bx				; recover the type of operation        ;AN000;

;  $if	c,and				; if lock exists and		       ;AC000;
   JNC $$IF14
;  $if	z,and				; if range given correctly and	       ;AC000;
   JNZ $$IF14
;
;	We've got the lock
;
;	(ds:di) = address of pointer (offset) to previous lock record
;	(es:BP) = sft address
;
; Now comes the tricky part.  Is the lock for us?  Does the lock match the SFT
; that was given us?  If not, then error.
;
   mov	si,[di] 			; (DS:SI) = address of lock record
   cmp	word ptr [si].rlr_sptr,bp

;  $if	z,and				; if SFT matches and		       ;AC000;
   JNZ $$IF14

   mov	bp,es
   cmp	word ptr [si].rlr_sptr+2,bp
;  $if	z,and				; (check both words of SFT pointer)    ;AC000;
   JNZ $$IF14
   mov	bp,proc_id
   cmp	[si].rlr_pid,bp

;; $if	z,and				; if PROC_ID matches		       ;AC000;
;  $if	z				; if PROC_ID matches		       ;AC006;
   JNZ $$IF14
;
; Make sure that the type of request and the lock type match
;
;; cmp	bx,lock_all			;				       ;AN000;

;; $IF	E,OR				; if unlocking all or		       ;AN000;

;; mov	bp,[si].rlr_type		; get lock type 		       ;AN000;
;; cmp	bp,rlr_lall			; is it lock all?		       ;AN000;

;; $IF	NE				; if not a LOCK ALL lock	       ;AN000;
;
; The locks match the proper open invocation.  Unchain the lock
;
       mov  ax,[si].rlr_next
       mov  [di],ax			; chain it out

;	put defunct lock record on the free chain
;
;	(ds:si) = address of freed lock rec

       mov  ax,Frelock
       mov  [si].rlr_next,ax
       mov  Frelock,si
       clc

;  $else				; we have an error		       ;AC000;
   JMP SHORT $$EN14
$$IF14:

       stc

;  $endif				; Endif - an error		       ;AC000;
$$EN14:

;  $if	c				; If an error was found 	       ;AC000;
   JNC $$IF17

       mov  ax,error_lock_violation

;  $endif				; Endif - an error was found	       ;AC000;
$$IF17:

   pop	ds				; restore DS

   ret


   EndProc Clr_Block

   BREAK <CLP - Common Lock Preamble>

;******************* START OF SPECIFICATIONS ***********************************
;
;  NAME:	   CLP - Common Lock Preamble
;
;  FUNCTION:	   This routine contains a common code fragment for set_block
;		   and clr_block.
;
;  INPUT:	   (ES:DI) = SFT address
;		   (CX:DX) = offset of area
;		   (SI:AX) = length of area
;		   User_ID = 16-bit user id of issuer
;		   Proc_ID = 16-bit process id of issuer
;		   (SS) = (DS) = DOSData
;
;  OUTPUT:	   (ds:si) = MFT address
;
;  REGISTERS USED: ALL but ES
;  (NOT RESTORED)
;
;  LINKAGE:	   Invoked by: Set_Block, Clr_Block
;
;  EXTERNAL	   Invoke: SLE
;  REFERENCES:
;
;  NORMAL	   'C' clear if no overlap
;  EXIT:	       (ax:bx) = offset of first byte in range
;		       (cx:dx) = offset of last byte in range
;
;  ERROR	   'C' set if overlap
;  EXIT:	   'Z' set if 1-to-1 match
;		       (di) points to previous lock
;
;  CHANGE	04/15/87 - lock only write support
;  LOG:
;
;******************* END OF SPECIFICATIONS *************************************
;******************+ START OF PSEUDOCODE +**************************************
;
;	START CLP
;
;	shuffle arguments
;	if valid length
;		invoke SLE
;		set successful return status
;	else
;		set error return status
;	endif
;	return
;
;	END CLP
;
;******************+  END  OF PSEUDOCODE +**************************************

   Procedure CLP,NEAR

   mov	bx,dx				; shuffle arguments
   xchg dx,ax
   xchg ax,cx				; (ax:bx) = offset
   mov	cx,si				; (cx:dx) = length

   or	si,dx				; see if length is 0

;  $if	nz,and				; if length is > 0 and		       ;AC000;
   JZ $$IF19

   add	dx,bx
   adc	cx,ax				; (cx:dx) = lba+1

;  $if	nc,or				; no carry is ok		       ;AC000;
   JNC $$LL19

   mov	si,dx
   or	si,cx

;  $if	z				; if !> 0 then			       ;AC000;
   JNZ $$IF19
$$LL19:

       sub  dx,1			; (cx:dx) = lba of locked region
       sbb  cx,0

       push cs
       pop  ds
;   (es:di) is sft
       push si
       mov  si,es:[di].sf_mft
       push si
       mov  di,1			; Find own locks
       call SLE
; di points to previous lock record
       pop  si
       pop  bp

;  $else				; we have an error		       ;AC000;
   JMP SHORT $$EN19
$$IF19:

       xor  si,si
       inc  si				; carry unchanged, zero reset
       mov  ax,error_lock_violation	; assume error
       stc

;  $endif				; endif - we have an error	       ;AC000;
$$EN19:

   ret

   EndProc CLP

   BREAK <Chk_Block - See if the specified I/O violates locks>

;******************* START OF SPECIFICATIONS ***********************************
;
;  NAME:	   Chk_Block - check range lock on a file
;
;  FUNCTION:	   Chk_Block is called to interogate the lock status of a
;		   region of a file.
;
;  NOTE:	   This routine is called for every disk I/O operation
;		   and MUST BE FAST
;
;  INPUT:	   (ES:DI) points to an SFT structure
;		   (AL) = 80h - Write operation  = 0 - any non write operation
;		   (CX) is the number of bytes being read or written
;		   BytPos is a long (low first) offset into the file
;			      of the I/O
;		   User_ID = 16-bit user id of issuer
;		   Proc_ID = 16-bit process id of issuer
;		   (SS) = DOSData
;
;  OUTPUT:	   CF set according to status and presence of locks (see below)
;
;  REGISTERS USED: ALL	but ES,DI,CX,DS
;  (NOT RESTORED)
;
;  LINKAGE:	   IBMDOS Jump Table
;
;  NORMAL	   'C' clear if no error
;  EXIT:
;
;  ERROR	   'C' set if error
;  EXIT:	     (ax) = error code
;			       ('error_lock_violation' if conflicting locks)
;
;  CHANGE	04/15/87 - lock only write support
;  LOG:
;
;******************* END OF SPECIFICATIONS *************************************
;******************+ START OF PSEUDOCODE +**************************************
;
;	START Chk_Block
;
;	if shared SFT and
;	if locks exist
;		invoke SLE
;		if lock conflicts occur (error)
;			if this is !write operation and
;			if a write lock found
;				set successfull status
;			else
;				set error status
;			endif
;		else no error
;			flush stack
;		endif
;	endif
;
;	ret
;
;	END Chk_Block
;
;******************+  END  OF PSEUDOCODE +**************************************

   Procedure Chk_Block,NEAR

   ASSUME DS:NOTHING,ES:NOTHING,SS:DOSDATA

write_op equ 080h			; write operation requested	       ;AN000;
lock_all equ 0h 			; lock all specified		       ;AN000;

;	PUSH	DS			;ICE
;	push	bx			;ICE
;	push	ax			;ICE

;	mov	bx,0140H		;ICE
;	xor	ax,ax			;ICE
;	mov	ds,ax			;ICE
;	mov	ax,word ptr ds:[bx]	;ICE
;	mov	word ptr ds:[bx],ax	;ICE

;	pop	ax			;ICE
;	pop	bx			;ICE
;	POP	DS			;ICE
   EnterCrit critShare

;  int 3
   nop
   nop

   PUSH ES
   PUSH DI
   PUSH CX
   PUSH DS
   cmp	es:[di].sf_mft,0

;  $if	nz,and				; if the file is SHARED and	       ;AC000;
   JZ $$IF22

   push cs
   pop	ds
   mov	si,es:[di].sf_MFT		; (DS:SI) = address of MFT record
   test [si].mft_lptr,-1

;  $if	nz,and				; if there are locks on this file and  ;AC000;
   JZ $$IF22

   sub	cx,1				; (cx) = count-1
   cmc

;  $if	c				; there are bytes to lock	       ;AC000;
   JNC $$IF22

;;     push ax				; preserve type of operation	       ;AN000;
					; DOS passes AL = 80 for writes
					;		= 00 for reads

       mov  ax,WORD PTR BytPos+2
       mov  bx,WORD PTR BytPos		; (ax:bx) = offset
       mov  dx,cx
       sub  cx,cx
       add  dx,bx
       adc  cx,ax			; (cx:dx) = lba of lock area
       sub  di,di			; ignore own locks
       call SLE
;;     pop  ax				; recover type of opperation	       ;AN000;

;   upon return DS:SI points to the RLR with the conflict

;;     $if  c				; if lock conflicts occur - error      ;AC000;

;   now we must check what type of lock exists
;   and the type of operation in progress.

;;	   cmp	al,write_op		;				       ;AN000;

;;	   $if	ne,and			; if NOT a write operation and	       ;AN000;

;;	   cmp	[si].rlr_type,rlr_lwr	;				       ;AN000;

;;	   $if	e			; if write locked (NOT all locked)     ;AN000;

;;	       clc			; then not true conflict - clear error ;AN000;

;;	   $else			; else it IS a valid conflict	       ;AC000;

;;	       stc			; true error - set error status

;;	   $endif			; endif - a valid conflict	       ;AC000;


;;     $endif				; endif -  conflicts		       ;AC000;

       mov  ax,error_lock_violation	; assume error

;  $endif				; endif - no need to check	       ;AC000;
$$IF22:

;	exit
;
;	'C' and (ax) setup

   POP	DS
   POP	CX
   POP	DI
   POP	ES
   LeaveCrit critShare

   ret					; exit

   EndProc Chk_Block

   BREAK <MFT_get - get an entry from the MFT>

;******************* START OF SPECIFICATIONS ***********************************
;
;	MFT_get - get an entry from the MFT
;
;	MFT_get is used to return information from the MFT.  System utilities
;	use this capability to produce status displays.
;
;	MFT_get first locates the (BX)'th file in the list (no particular
;		ordering is promised).	It returns that name and the UID of
;		the (CX)'th SFT on that file and the number of locks on that
;		file via that SFT.
;
;	ENTRY	DS:SI point to DPL which contains:
;		(dBX) = zero-based file index
;		(dCX) = zero-based SFT index
;		(SS) = DOSData
;	EXIT	'C' clear if no error
;		  ES:DI buffer is filled in with BX'th file name
;		  (BX) = user id of SFT
;		  (CX) = # of locks via SFT
;		'C' set if error
;		  (ax) = error code
;			    ('error_no_more_files' if either index is out
;			     of range)
;
;******************* END OF SPECIFICATIONS *************************************

   Procedure MFT_get,NEAR

;  int 3
   nop
   nop

   ASSUME DS:NOTHING,ES:NOTHING

   EnterCrit critShare
   MOV	BX,[SI.DPL_BX]
   MOV	CX,[SI.DPL_CX]
   Context ES
   MOV	DI,OFFSET DOSDATA:OpenBuf

   xchg bx,cx				; (cx) = file index
   push cs
   pop	ds

   Off	SI,mft				; (ds:si) = fwa of OFFSET MFT

;	scan forward until next name

mget1: cmp [si].mft_flag,MFLG_FRE
   jz	mget3				; is free space
   jl	mget7				; is END

;	have another name.  see if this satisfies caller

   jcxz mget4				; caller is happy
   dec	cx
mget3: add si,[si].mft_len		; skip name record
   JMP	SHORT mget1

;	we've located the file name.
;
;	(bx) = SFT index
;	(DS:SI) = MFT entry
;	(ES:DI) = address of caller's buffer

mget4: push di
   push si				; save table offset
   add	si,mft_name
mget5: lodsb
   stosb				; copy name into caller's buffer
   or	al,al
   jnz	mget5
   pop	si				; (DS:SI) = name record address
   xchg bx,cx				; (cx) = SFT chain count
   lds	di,[si].mft_sptr
mget6: jcxz mget8			; have reached the SFT we wanted
   dec	cx
   lds	di,[di].sf_chain		; get next link
   or	di,di
   jnz	mget6				; follow chain some more
   pop	di				; (es:di) = buffer address

;**	The file or SFT index was too large - return w/ error

mget7: mov ax,error_no_more_files
   stc
   LeaveCrit critShare

   ret

;**	We've got the SFT he wants.  Lets count the locks
;
;	(es:TOS) = buffer address
;	(DS:DI) = address of SFT
;	(si) = address of mft

mget8: mov ax,[DI].sf_flags
   mov	dx,ds				; save segment
   push cs
   pop	ds
   mov	si,[si].mft_lptr		; (DS:SI) = Lock record address
   sub	cx,cx				; clear counter

mget9: or si,si
   jz	mget11				; no more
   cmp	di,WORD PTR [si].rlr_sptr
   jnz	mget10
   cmp	dx,word PTR [si].rlr_sptr+2
   jnz	mget10
   inc	cx
mget10: mov si,[si].rlr_next
   JMP	SHORT mget9

;	Done counting locks.  return the info
;
;	(cx) = count of locks
;	(es:TOS) = buffer address

mget11: mov ds,dx
   mov	bx,[di].SF_UID			; (bx) = UID
   pop	di
   clc
   LeaveCrit critShare

   ret

   EndProc MFT_get

   BREAK <ASC - Add SFT to Chain>

;******************* START OF SPECIFICATIONS ***********************************
;
;	ASC - Add SFT to Chain
;
;	ASC is called to add an SFT to the front of the chain.
;
;	ASC checks the file share mode bits on the other SFTs in the chain and
;	reports a conflict.  The new SFT is NOT ADDED in the case of
;	conflicts.
;
;	ENTRY	(BX) = FBA MFT name record
;		(DS:SI) = SFT address
;	EXIT	'C' clear if added
;		    (ds:si) point to sft
;		    (bx) offset of mft
;		'C' set if conflict
;		  (ax) = error code
;	USES	ALL
;
;******************* END OF SPECIFICATIONS *************************************

   Procedure ASC,NEAR

   cmp	[si].sf_MFT,0
   jnz	asc9				; already on chain - internal error

;	The SFT looks good... lets see if there are any use conflicts

;	Message 1,<"Adding sft ">

   mov	ax,User_ID			; place user information in SFT
   mov	[si].sf_UID,ax			; do it before CUC (he checks UID)
   mov	ax,Proc_ID
   mov	[si].sf_PID,ax

       call CUC 			; check use conflicts
   jc	asc8				; use conflicts - forget it

;	MessageNum   AX

;	MessageNum   AX
;	Message 1,<" to ">
;	MEssageNum  DS
;	Message 1,<":">
;	MessageNum  SI
;	Message 1,<" ">

   mov	[si].sf_MFT,bx			; make SFT point to MFT

;	MessageNum  [si].sf_mft
;	Message 1,<13,10>

   mov	cx,[si].sf_mode 		; (cx) = open mode
   mov	dx,ds				; (dx:si) = SFT address
   push cs
   pop	ds				; (ds:bx) = MFT address

;
;   Not special file and no previous sft found OR normal SFT.  We link it in
;   at the head of the list.
;
;   (dx:si) point to sft
;   (ds:bx) point to mft
;
   les	di,[bx].mft_sptr		; get first link

;M003;
; If the SFT to be inserted is the same as the current one, do not link it in
;
   mov	ax,es				;M003
   cmp	si,di				;Offsets same? ;M003
   jne	asc_ins				;No, link in ;M003
   cmp	ax,dx				;Segments same? ;M003
   je	asc75				;Yes, do not insert ;M003
asc_ins:

   mov	word ptr [bx].mft_sptr,si	; link in this sft
   mov	word ptr [bx].mft_sptr+2,dx	; link in this sft
   mov	ds,dx
   mov	word ptr [si].sf_chain,di
   mov	word ptr [si].sf_chain+2,es
asc75: mov ds,dx			; point back to sft

   clc
asc8: ret

;	the SFT is already in use... internal error

asc9: push ax
   off	ax,AscErr
   call INTERR				; NEVER RETURNS

   EndProc ASC


   BREAK <BCS - Bulk Close of SFTs>

;******************* START OF SPECIFICATIONS ***********************************
;
;	BCS - Bulk Close of SFTs
;
;	BCS scans the MFT structures looking for SFTs that match a UID (and
;	perhaps a PID).  The SFTs are closed.  The MFT name record is removed
;	if all its SFTs are closed.
;
;	BCS is called with a PID and a PID MASK.  The SFT is closed if its UID
;	matches the supplied UID AND (PID_ & PIDMASK) == PID_supplied
;
;	We walk the MFT structure closing all relevant SFT's. There is no
;	need for special handling of 70 handles or FCBs.
;
;	Note that we call DOS_close to close the SFT; DOS_close in turn calls
;	mftclose which may remove the SFT and even the MFT.  This means that
;	the MFT may vanish as we are working on it.  Whenever we call
;	DOS_close we'll know the next SFT and, if there is no next SFT we'll
;	know the next MFT.  (If the MFT were released a pointer to the carcass
;	is not of any help.  An MFT carcass cannot help find the next MFT
;	record)
;
;	ENTRY	(AX) = UID to match
;		(BX) = PID mask
;		(DX) = PID value
;	EXIT	'C' clear
;	USES	ALL
;
;******************* END OF SPECIFICATIONS *************************************

   ASSUME SS:DOSDATA

   Procedure BCS,NEAR

   push cs
   pop	ds

   Off	SI,mft				; start at beginning of buffer

;	scan forward to the nearest name record (we may be at it now)
;
;	(DS:SI) = record pointer

bcs1: cmp [si].mft_flag,MFLG_FRE
   jl	bcs16				; at end of names, all done
   jg	bcs2				; have a name record

bcs1$5: add si,[si].mft_len		; skip record and loop
   jmp	bcs1

bcs16: jmp short bcs9

bcs2: les di,[si].mft_sptr		; got name record - get first SFT
;	run down SFT chain
;
;	(es:di) = FBA next SFT
;	(ds:si) = FBA name record
;	(ax) = UID to match
;	(bx) = PID mask
;	(dx) = PID value

bcs3: or di,di
   jz	bcs1$5				; at end of SFT chain
   cmp	ax,es:[di].sf_UID
   jnz	bcs4				; not a match
   mov	cx,es:[di].sf_PID
   and	cx,bx				; apply mask
   cmp	cx,dx
   jz	bcs51				; got a match
bcs4:
   les	di,es:[di].sf_chain
   JMP	bcs3				; chain to next SFT


;	We have an SFT to close
;
;	(es:di) = FBA SFT to be closed
;
;	(ds:si) = FBA name record
;	(ax) = UID to match
;	(bx) = PID mask
;	(dx) = PID value

bcs51: mov es:[di].sf_ref_count,1
   push ax
   push bx
   push dx				; save ID values (ax,bx,dx) and mask
   push ds
   push si				; save name record address (ds:si)
   mov	si,word ptr es:[di].sf_chain
   or	si,si
   jnz	bcs7				; isnt last sft, MFT will remain

;	yup, this is the last sft for this MFT, the MFT may evaporate.	we have
;	to find the next one NOW, and remember it

   pop	si				; undo saved name record address
   pop	ds
bcs6: add si,[si].mft_len		; go to next guy
   cmp	[si].mft_flag,MFLG_FRE
   jz	bcs6				; must be a non-free guy
   push ds
   push si				; resave our new next MFT
   sub	si,si				; no next sft

;	Allright, we're ready to call the DOS.
;
;	(es:di)     = FBA sft to be closed
;	((sp))	 = long address of current or next MFT
;	((sp)+4) = PID value
;	((sp)+6) = PID mask
;	((sp)+8) = UID value

bcs7: mov WORD PTR ThisSFT,di
   mov	WORD PTR ThisSFT+2,es
   mov	es,word ptr es:[di].sf_chain+2
   SaveReg <es,si>
   call CPS				; clear JFN
   Context DS

   CallInstall DOS_Close,multDos,1

   ASSUME DS:NOTHING

   RestoreReg <di,es>			; (es:DI) = offset of next sft
   pop	si
   pop	ds				; (DS:SI) = fwa of current or next MFT
   pop	dx
   pop	bx
   pop	ax
   or	di,di
   jnz	bcs85				; have more sft's
   JMP	bcs1				; look at this new MFT
bcs85: jmp bcs3

;	All Done

bcs9: clc

   ret

   EndProc BCS

   BREAK <CSL - Clear SFT Locks>

;******************* START OF SPECIFICATIONS ***********************************
;
;	CSL - Clear SFT Locks
;
;	CSL clears any locks associated with this SFT.
;
;	ENTRY	(ES:DI) = SFT address
;	EXIT	(ES:DI) unchanged
;	USES	All but ES,DI
;
;******************* END OF SPECIFICATIONS *************************************

   Procedure CSL,NEAR

   mov	si,es:[di].sf_MFT
   push cs
   pop	ds
   lea	bx,[si].mft_lptr		; (DS:BX) = addr of lock ptr
   mov	si,[bx] 			; (DS:SI) = fba first lock record

;	scan the locks looking for belongers.
;
;	(es:di) = SFT address
;	(ds:si) = this lock address
;	(ds:bx) = address of link (offset value) to this lock (prev lock)

csl1: or si,si
   jz	csl3				; done with lock list
   cmp	di,word ptr [si].rlr_sptr
   jnz	csl2				; not my lock
   mov	ax,es
   cmp	ax,word ptr [si].rlr_sptr+2
   jnz	csl2				; not my lock
;
; Make sure that the lock REALLY belongs to the correct process
;
   cmp	user_in_ax, (ServerCall shl 8) + 4 ; only check if   ; @@01
   jnz	csl15				; process specific; @@01
   mov	ax,Proc_ID
   cmp	ax,[si].rlr_pid 		; is process ID of lock = this PID?
   jnz	csl2				; nope, skip this lock

;	got a lock to remove

csl15:
   mov	dx,[si].rlr_next
   mov	[bx],dx 			; link him out
   mov	ax,Frelock
   mov	[si].rlr_next,ax
   mov	Frelock,si
   mov	si,dx				; (DS:SI) = next lock address
   JMP	SHORT csl1

   ERRNZ rlr_next			; lock is not ours... follow chain
csl2: mov bx,si
   mov	si,[si].rlr_next
   JMP	SHORT csl1

;	All done

csl3: ret

   EndProc CSL

   ASSUME DS:NOTHING

   BREAK <CUC - check usage conflicts>

;******************* START OF SPECIFICATIONS ***********************************
;
;	Use conflict table
;
;	Algorithm:
;
;		if ((newmode == COMPAT) or (oldmode == COMPAT))
;			and (user ID's match)
;		   then accept
;		else
;		for new and old mode, compute index of (SH*3)+ACC
;		shift right table[new_index] by old_index+2;
;			'C' set if FAIL
;
;	The bit in the old_index position indicates the success or failure.  0
;	=> allow access, 1 => fail access
;
;******************* END OF SPECIFICATIONS *************************************

   PUBLIC CUCA

CUCA: DW 0ffffh 			; Compat    Read
   DW	0ffffh				; Compat    Write
   DW	0ffffh				; Compat    Read/Write
   DW	0ffffh				; Deny R/W  Read
   DW	0ffffh				; Deny R/W  Write
   DW	0ffffh				; Deny R/W  Read/Write
   DW	0df7fh				; Deny W    Read
   DW	0dbffh				; Deny W    Write
   DW	0dfffh				; Deny W    Read/Write
   DW	0beffh				; Deny R    Read
   DW	0b7ffh				; Deny R    Write
   DW	0bfffh				; Deny R    Read/Write
   DW	01c7fh				; Deny None Read
   DW	003ffh				; Deny None Write
   DW	01fffh				; Deny None Read/Write

;					     4443 3322 2111 000
;   Deny/Compat 			/    DDDD DDDD DDDD CCCx
;   DenyRead			       /	R RR	RRR
;   DenyWrite		  1st Access =< 	    WW WWWW
;   AccessRead			       \     R RR  RR  RR R R R
;   AccessWrite 			\    WW W W WW	WW  WW
;   x					     1111 1111 1111 1111
;   C  R    00				     1111 1111 1111 1111  ffff
;   C	W   01				     1111 1111 1111 1111  ffff
;   C  RW   02				     1111 1111 1111 1111  ffff

;   DRWR    10				     1111 1111 1111 1111  ffff
;   DRW W   11				     1111 1111 1111 1111  ffff
;   DRWRW   12				     1111 1111 1111 1111  ffff
;   D WR    20				     1101 1111 0111 1111  df7f

;   D W W   21				     1101 1011 1111 1111  dbff
;   D WRW   22				     1101 1111 1111 1111  dfff
;   DR R    30				     1011 1110 1111 1111  beff
;   DR	W   31				     1011 0111 1111 1111  b7ff

;   DR RW   32				     1011 1111 1111 1111  bfff
;   D  R    40				     0001 1100 0111 1111  1c7f
;   D	W   41				     0000 0011 1111 1111  03ff
;   D  RW   42				     0001 1111 1111 1111  1fff

;   In order to allow the greatest number of accesses, compatability read mode
;   is treated as deny-write read.  The other compatability modes are treated
;   as deny-both.

;******************* START OF SPECIFICATIONS ***********************************
;
;	CUC - check usage conflicts
;
;	CUC is called to see if a would-be open would generate a share
;	conflict with an existing open.  See CUCA for the algorithm and table
;	format.
;
;	ENTRY	(BX) = FBA MFT name record
;		(DS:SI) = SFT address
;	EXIT	'C' clear if OK
;		'C' set if conflict
;		  (ax) = error code
;	USES	ALL but arguments (BX, DS:SI)
;
;******************* END OF SPECIFICATIONS *************************************

   Procedure CUC,NEAR

   push ds
   pop	es
   mov	di,si				; (es:di) = FBA SFT record
   call gom				; get open mode
   mov	ch,al
   and	ch,sharing_mask 		; (ch) = new guy share
   jz	cuc0				; new guy is compatability mode
   mov	ch,sharing_mask
cuc0: call csi				; compute share index
   add	ax,ax				; *2 for word index
   xchg ax,si				; (si) = share table index
   push cs
   pop	ds				; (ds:bx) = FBA MFT record
   mov	dx,WORD PTR CUCA[si]		; (dx) = share mask
   lds	si,[bx].mft_sptr		; (ds:si) = first sft guy

;	ready to do access compares.
;
;	(ds:si) = address of next sft
;	(es:di) = address of new  sft
;	(dx) = share word from CUCA
;	(cs:bx) = MFT offset
;	(ch) = 0 if new SFT is compatibilty mode, else sharing_mask

cuc1: or si,si
   jz	cuc9				; at end of chain, no problems
   call gom				; if not FCB, then mode in al is good
   mov	ah,al
   and	ah,sharing_mask 		; (ah) = sharing mode
   or	ah,ch				; (ah) = 0 iff new and old is SH_COMP
   jnz	cuc2				; neither is SH_COMP

;	Both the old and the new guy are SH_COMP mode.	If the UIDs match,
;	step onward.  If they don't match do normal share check.

   mov	bp,es:[di].sf_UID
   cmp	bp,[si].sf_UID
   jz	cuc20				; equal => next sft to check

cuc2: call csi				; compute the share index
   inc	ax
   inc	ax
   xchg al,cl				; (cl) = shift count
   mov	ax,dx
   sar	ax,cl				; select the bit
   jc	cuc8				; a conflict!
cuc20:
   lds	si,[si].sf_chain
   JMP	cuc1				; chain to next SFT and try again

;	Have a share conflict

cuc8: mov ax,error_sharing_violation	; assume share conflict
   stc

;	done with compare.  Restore regs and return
;
;	'C' set as appropriate
;	(es:di) = new SFT address
;	(ax) set as appropriate
;	(bx) = MFT offset

cuc9: push es
   pop	ds
   mov	si,di

   ret

   EndProc CUC

   BREAK <csi - compute share index>

;******************* START OF SPECIFICATIONS ***********************************
;
;	csi - compute share index
;
;
;	If the mode byte has a leading 7 then it is interpreted as a 0
;	csi turns a mode byte into an index from 0 to 14:
;
;		(share index)*3 + (access index)
;
;	ENTRY	(al) = mode byte
;	EXIT	(ax) = index
;	USES	AX, CL
;
;******************* END OF SPECIFICATIONS *************************************

   Procedure CSI,NEAR

   mov	ah,al
   and	ah,access_mask			; (ah) = access bits
   and	al,sharing_mask 		; (al) = share bites
   ERRNZ sharing_mask-0F0h
   cmp	al,sharing_net_FCB
   jnz	csi1
   xor	al,al
csi1:
   shr	al,1
   shr	al,1
   shr	al,1
   mov	cl,al				; (cl) = SHVAL*2
   shr	al,1
   add	al,cl				; (al) = SHVAL*3
   add	al,ah				; (al) = SH*3 + ACC
   sub	ah,ah

   ret

   EndProc CSI

   Break <GOM - get open mode>

;******************* START OF SPECIFICATIONS ***********************************
;
;	GOM - get open mode
;
;   Find the correct open mode given the encoded sf_mode.  Note that files
;   marked READ-ONLY and are opened in compatability read-only are treated as
;   deny-write read-only.  FCB opens are sharing_compat open_for_both and
;   net FCB opens are sharing_compat
;
;	Entry:	    (DS:SI) points to SFT
;   Exit:	(AL) has correct mode
;   Uses:	(AX)
;******************* END OF SPECIFICATIONS *************************************

   Procedure GOM,NEAR

   mov	ax,[si].sf_mode
   TEST AX,sf_IsFCB
   jz	gom1				; if not FCB, then mode in al is good
   mov	al,sharing_compat+open_for_both
gom1:
   mov	ah,al
   and	ah,sharing_mask
   cmp	ah,sharing_net_FCB		; is sharing from net FCB?
   jnz	gom2				; no, got good mode
   and	al,access_mask			; yes, convert to compat mode sharing
   or	al,sharing_compat
;
; The sharing mode and access mode in AL is now correct for the file.  See if
; mode is compatability.  If so and file is read-only, convert access mode to
; deny-write read.
;
gom2:
   mov	ah,al
   and	ah,sharing_mask
   retnz				; not compatability, return.
   test [si].sf_attr,attr_read_only
   retz 				; not read-only
   mov	al,sharing_deny_write + open_for_read

   ret

   EndProc GOM

   SHARE ENDS

   END
   ELSE
CODE ENDS
   ENDIF
   END					; This can't be inside the if
; mode is compatability.  If so and file is read-only, convert access mode to
; deny-write read.
;
gom2:
   mov	ah,al
   and	ah,sharing_mask
   retnz				; not compatability, return.
   test [si].sf_attr,attr_read_only
   retz 				; not read-only
   mov	al,sharing_deny_write + open_for_read

   ret

   EndProc GOM

   SHARE ENDS

   END
   ELSE
CODE ENDS
   ENDIF
   END					; This can't be inside the if
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\setver\setver.h ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

/***************************************************************************/
/*                                                                         */
/* SETVER.H                                                                */
/*                                                                         */
/*	Include file for MS-DOS set version program.                       		*/
/*                                                                         */
/*	johnhe	05-01-90                                                   		*/
/***************************************************************************/

#pragma pack(1)

/***************************************************************************/
/* Normal variable typedefs. These type defs are compatible with OS2	   	*/
/* typedefs.								   												*/
/***************************************************************************/

typedef  char           CHAR;
typedef  unsigned char  UCHAR;
typedef  int            INT;
typedef  unsigned int   UINT;
typedef  long           LONG;
typedef  unsigned long  UL;
typedef  float          FLOAT;
typedef  double         DOUBLE;

/***************************************************************************/
/* Standard global constants.						   									*/
/* Don't change the TRUE define because some functions depend on it being  */
/* 1 instead of !FALSE.							   										*/
/***************************************************************************/

#ifndef	FALSE
  #define FALSE    	0
#endif

#ifndef	TRUE
  #define TRUE 	   1
#endif

#define	EOL	  		'\0'

#define	HEX	  		16
#define	DECIMAL	  	10
#define	OCTAL      	8

/***************************************************************************/
/* Module specific constants						   									*/
/***************************************************************************/

#define	MAX_NAME_LEN			13
#define	MAX_ENTRY_SIZE			(MAX_NAME_LEN + 1 + 2 + 1)
#define	MAX_PATH_LEN			68

#define	MAX_VERSION 			0x0a00		/* Max version 9.99	*/
#define	MIN_VERSION 			0x020b		/* Min version 2.11	*/

#define	S_ERROR					-1
#define	S_OK						0
#define	S_INVALID_SWITCH		-1
#define	S_INVALID_FNAME		-2
#define	S_MEMORY_ERROR 		-3
#define	S_BAD_VERSION_FMT 	-4
#define	S_ENTRY_NOT_FOUND 	-5
#define	S_FILE_NOT_FOUND		-6
#define	S_BAD_DRV_SPEC 		-7
#define	S_TOO_MANY_PARMS		-8
#define	S_MISSING_PARM			-9	    		/* Missing version number or /d	*/
#define	S_FILE_READ_ERROR		-10
#define	S_CORRUPT_TABLE		-11
#define	S_INVALID_SIG			-12
#define	S_NO_ROOM				-13
#define	S_FILE_WRITE_ERROR	-14
#define	S_INVALID_PATH			-15

#define	DO_LIST 					1
#define	DO_ADD_FILE 			2
#define	DO_DELETE 				3
#define	DO_HELP   				4
#define	DO_QUIET					5

#define	VERSION_COLUMN			16				/* Screen column for version #	*/
#define	SIGNATURE_STR			"PCMN"		/* Signature string in MSDOS.SYS	*/
#define	SIGNATURE_LEN			4
#define	BUF_LEN					4096

/***************************************************************************/
/* Defines for possible command line switches.										*/
/***************************************************************************/

#define	HELP_SWITCH		"?"
#define	DEL_SWITCH		"DELETE"
#define	SWITCH_CHAR 	'/'
#define	QUIET_SWITCH   "QUIET"

/***************************************************************************/

struct TableEntry
{
	char		Drive;
	char		Path[ MAX_PATH_LEN ];
	char		szFileName[ MAX_NAME_LEN + 1 ];
	UCHAR		MajorVer;
	UCHAR		MinorVer;
};

struct ExeHeader
{
	UINT		Signature;
	UINT		LastPageLen;
	UINT		TotalFilePages;
	UINT		NumRelocEntries;
	UINT		HeaderParas;
	UINT		MinEndParas;
	UINT		MaxEndParas;
	UINT		StackSeg;
	UINT		StackPtr;
	UINT		NegChkSum;
	UINT		IndexPtr;
	UINT		CodeSeg;
	UINT		RelocTblOffset;
	UINT		OverlayNum;
};

struct DevHeader
{
	char far		*NextDevice;
	unsigned		DeviceAttrib;
	char near	*Strategy;
	char near	*Entry;
	char			Name[ 8 ];
	char			VersMinor;
	char			VersMajor;
	long			TblOffset;
	unsigned		TblLen;
};

/***************************************************************************/
/* Function prototypes for SETVER.C                                        */
/***************************************************************************/

extern  int   main( int argc, char *argv[] );
static  int   Error( int iErrCode );
static  int   DoFunction( int iFunction );

static  void  DisplayMsg( char *tbl[] );
static  int   DeleteEntry( void );
static  int   AddEntry( void );

static  int   DisplayTable( void );
static  int   MatchFile( char *pchStart, char *szFile );
static  int   IsValidEntry( char *pchPtr );
static  char  *GetNextFree( void );

static  int   ReadVersionTable( void );
static  int   WriteVersionTable( void );

static  int   SeekRead( int iFile, void *Buf, long lOffset, unsigned uBytes );

/***************************************************************************/
/* Function prototypes for PARSE.C                                         */
/***************************************************************************/

extern  int   ParseCmd( int argc, char *argv[], struct TableEntry *Entry );
static  int   IsValidFile( char *szFileName );
static  UINT  ParseVersion( char *szVersion );
static  int   IsDigitStr( char *szStr );
static  char  *SkipLeadingChr( char *szStr, char chChar );
static  void  RemoveTrailing( char *szStr, char chChar );
static  int   MatchSwitch( char *szCmdParm, char *szTestSwitch );
static  int   IsValidFileName( char *szFile );
static  int   IsReservedName( char *szFile );
static  int   IsWildCards( char *szFile );
static  int   ValidFileChar( char *szFile );
static  int   IsValidFileChr( char Char );

#ifdef DBCS 
static  int   IsDBCSLeadByte(unsigned char);
static	int   CheckDBCSTailByte(unsigned char *,unsigned char *);
#endif

/***************************************************************************/
/* Function prototypes for DOS.ASM                                         */
/***************************************************************************/

extern  int   IsValidDrive( char DrvLetter );
extern  void  PutStr( char *String );
extern  long  _dos_seek( int Handle, long lOffset, int Mode );
extern  int	  SetVerCheck ( void );					/* M001 */

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\setver\dos.asm ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

;================= DOS.ASM =========================
COMMENT #


  johnhe - 05/09/90

END COMMENT #

;========================================================

INVALID_DRIVE	EQU	15
DOS_PUTCHAR	EQU	02

DOSSEG
.Model	  SMALL,C


.Data

CrLf	db	0dh, 0ah, 0


.Code

; =========================================================================
; Verifies that a drive exists using the IsChangeable IOCtl function.
;
; int IsValidDrive( char DrvLetter )
;
; ARGUMENTS:	DrvLetter	- The drive letter to verify
; RETURNS:	int		- FALSE if not a valid drive letter
;				  else !FALSE
;
; =========================================================================

IsValidDrive	PROC Drive:WORD

	mov	BX,Drive		; BX = Drive number
	cmp	BX,26			; Make not greater than drive Z
	jg	NotValid

	mov	AX,4408h		; AX = IOCtl Is changeable function
	int	21h
	jnc	IsValid			; Drv valid
					; Else check error code to see if
	cmp	AX,INVALID_DRIVE	; invalid drive error
	jne	IsValid 		; Drive is valid

NotValid:
	xor	AX,AX			; Return FALSE
	jmp	SHORT DrvChkRet		; Done

IsValid:
	mov	AX,1			; Return TRUE

DrvChkRet:
	ret				; Return AX = TRUE or FALSE
	
IsValidDrive	ENDP

; =========================================================================
; Displays a zero terminated ascii string on the console followed by
; a carriage return line feed conbination.
;
; void PutStr( char *String )
;
; ARGUMENTS:	String - Ptr to string to be displayed
; RETURNS:	void
;
; =========================================================================

PutStr PROC USES SI, String:PTR

	mov	SI,String			; DS:SI -> to caller's string
	mov	CX,2				; 2 loops 

PrintLoop:
	cld					; Always clear direction flag
	lodsb					; Load char in AL & inc SI
	or	AL,AL				; Test for EOL character
	jz	EndOfStr

	mov	AH,DOS_PUTCHAR			; AH = DOS put char function
	mov	DL,AL				; Put character to print in DL
	int	21h				; Output the character
	jmp	SHORT PrintLoop			; Go back and do the next one

EndOfStr:
	mov	SI,OFFSET CrLf			; DS:SI -> CR/LF return string
	loop	PrintLoop			; Go back and print CR/LF

	ret

PutStr ENDP

; =========================================================================
;
; Seeks to the specified offset in an open disk
; disk file.
; 
; long	_dos_seek( int Handle, long lOffset, int Mode )
; 
; ARGUMENTS:	Handle	- Open DOS file handle
; 		lOffset - Offset to seek to in bytes
; 		Mode	- Seek mode as described below
; 			  0 = Beginning of file + offset
; 			  1 = Current file position + offset
; 			  2 = End of file + offset
; RETURNS:	long	- New offset in file is success
; 			  or -1L if error
; =========================================================================
  
_dos_seek PROC USES ES, Handle:WORD, lOffset:DWORD, Mode:BYTE

	mov	AH,42h		; AH = DOS file SEEK function
	mov	AL,Mode		; AL = SEEK mode specified by caller
	mov	BX,Handle	; BX = Open file handle from caller

LoadOffset:
	les	DX,lOffset	; Load file offset into ES:DX
	mov	CX,ES		; CX:DX = Offset to seek to in the file

Int21Call:
	int	21h		; DOS call
	jc	SeekError	; Error check
	jmp	SHORT SeekReturn ;Everything is OK

SeekError:
	mov	AX,-1		; Error code
	cwd			; Extend sign to make a LONG (dword)

SeekReturn:
	ret

_dos_seek ENDP

; =======================================================
; M001 ; Start of changes to check for SETVER.EXE in the
;        device chain.
; =======================================================

.DATA

SetVerStr	db	'SETVERXX'

LEN_SETVERSTR	EQU	$-SetVerStr

.Code

; =======================================================
;
; Checks to see if SETVER.EXE was installed as as a device
; driver by walking the device chain looking for the name
; "SETVERXX".
;
; int SetVerCheck ( void )
; 
; ARGUMENTS:	NONE
; RETURNS:	int - TRUE if SetVer device driver is installed else FALSE
;
; =======================================================

SetVerCheck PROC USES SI DI DS ES
	ASSUME	ES:NOTHING

	mov	AH,52h
	int	21h			; ES:BX --> first DBP

	push	BX			; Save offset
	mov	AH,30h
	int	21h			; AL == Major version
	pop	DI			; Restore DPB offset to BX

	add	DI,17h			; DOS 2.x offset of NULL device is 17h
	cmp	AL,2			; See if version is really 2.x
	jle	@f
	add	DI,0bh			; Offset for DOS > 2.x is 22h
@@:
	mov	AX,@DATA
	mov	DS,AX

	mov	SI,OFFSET SetVerStr
	mov	CX,LEN_SETVERSTR
	cld

NameCmpLoop:
	cmp	DI,0ffffh		; See if ES:DX is xxxx:ffff
	je	NoSetVer

SaveSetup:
	push	CX			; Save name length
	push	DI			; Save ptr to current device
	push	SI			; Save ptr to SetVer string
	add	DI,0ah			; ES:DI --> Device name + 1
	
	repe	cmpsb
	pop	SI
	pop	DI
	pop	CX

	je	FoundSetVer
	les	DI,ES:[DI]		; Load ptr to next device.
	jmp	SHORT NameCmpLoop

NoSetVer:
	xor	AX,AX
	jmp	SHORT SetVerReturn

FoundSetVer:
	mov	AX,1

SetVerReturn:
	ret

SetVerCheck ENDP

; =======================================================
; M001 ; End of changes
; =======================================================

	END
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\share\gshare2.asm ===
Title	Share_2

;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

;
;	Revision History
;	================
;
;	M000	SR	08/03/90	Fixed ShComndParse so that it exits
;					after displaying help text on a 
;					Share /?
;
;	M001	SR	9/10/90	Removed all /NC support from the code
;				and rewrote the init code to not use
;				all the special Share int 2fh calls.
;
;	M002	SR	9/26/90	Bug #3013. The installed message and
;				parse error message had identical
;				message numbers. Also check the class.
;
; 	M004	HKN	10/18/90	To determine whether the SFT is a
;					net SFT or a device we must check
;					the sf_flags. bug #3584
;
;	M005	SR	10/16/90	Bug #2914. Changed to ignore the /NC
;				switch instead of making it an
;				invalid switch.
;
;	M006	SR	10/22/90	Bug #3583. Changed parsing to check
;				for multiple occurrences of a switch
;				and give out an error message. Share
;				still continues to load and uses the
;				parameter value first specified.
;
;	M007	SR	11/16/90	Bug #4240. Added check to ShareInit
;				to look for switcher and fail to load
;				if switcher is present.
;



	include SHAREHDR.INC
;
;     Label: "The DOS SHARE Utility"
;
;******************* END OF SPECIFICATIONS *************************************


				   NAME Sharer2

					   ;  INCLUDE DOSSYM.INC
					   ;  INCLUDE SYSMSG.INC
				   .xlist
				   .xcref
				   INCLUDE DOSSYM.INC
				   INCLUDE SYSMSG.INC
					include filemode.inc
					include arena.inc
					include cpmfcb.inc
					include sf.inc
					include pdb.inc
					include sysvar.inc
					include syscall.inc
					include mult.inc
					include version.inc
					include vector.inc
					include int2a.inc
				   .cref
				   .list
				   page 80,132

				   MSG_UTILNAME <SHARE>

ShareDataVersion		   =	1

AsmVars 			   <IBM, Installed>

Installed			   =	TRUE ; for installed version

OFF				   Macro reg,val
				   IF	installed
				   mov	reg,OFFSET val
				   ELSE
				   mov	si,OFFSET DOSGROUP:val
				   ENDIF
				   ENDM

ERRNZ				   Macro x
				   IF	x    NE 0
				   %out ERRNZ failed
				   ENDIF
				   ENDM
					   ;---------------------------------------
					   ; if we are installed, then define the
					   ; base code segment of the sharer first
					   ;---------------------------------------
;	$SALUT	(4,9,17,36)

	IF	Installed

	    Share   SEGMENT BYTE PUBLIC 'SHARE'
	    Share   ENDS
	include dosseg.inc
	ENDIF

				   ;---------------------------------------
				   ; include the rest of the segment
				   ;  definitions for normal msdos

				   ; segment ordering for MSDOS

				   ;---------------------------------------


	DOSDATA SEGMENT

	extrn	DataVersion:BYTE   ; version number of DOS data.
	extrn	JShare:BYTE	   ; location of DOS jump table.
	extrn	sftFCB:DWORD	   ; [SYSTEM] pointer to FCB cache table
	extrn	KeepCount:WORD	   ; [SYSTEM] LRU count for FCB cache
	extrn	CurrentPDB:WORD

	extrn	ThisSFT:DWORD	   ; pointer to SFT entry
	extrn	WFP_start:WORD	   ; pointer to name string
	extrn	User_ID:WORD
	extrn	Proc_ID:WORD
	extrn	SFT_addr:DWORD
	extrn	Arena_Head:WORD
	extrn	fshare:BYTE
	extrn	pJFN:DWORD
	extrn	JFN:WORD

	IF	DEBUG

	    extrn   BugLev:WORD
	    extrn   BugTyp:WORD
	    include bugtyp.inc

	ENDIF


	DOSDATA    ENDS

				   ;---------------------------------------
				   ; if we are not installed, then the
				   ; code here is just part of the normal
				   ; MSDOS code segment otherwise,
				   ; define our own code segment
				   ;---------------------------------------



	.sall
	IF	NOT	INSTALLED

	    CODE    SEGMENT BYTE PUBLIC 'CODE'

	    ASSUME  SS:DOSGROUP,CS:DOSCODE

	ELSE

	    Share   SEGMENT BYTE PUBLIC 'SHARE'

	    ASSUME  SS:DOSDATA,CS:SHARE

	ENDIF



	Extrn	FreLock:WORD,Serial:WORD
	Extrn	MFT_Enter:NEAR,MFTClose:NEAR,MFTClu:NEAR,MFTCloseP:NEAR
	Extrn	MFTCloN:NEAR
	Extrn	Set_Mult_Block:NEAR,Clr_Mult_Block:NEAR,Chk_Block:NEAR
	Extrn	MFT_Get:NEAR

	include mft.inc

;  $SALUT (4,4,9,41)

   BREAK <FNM - Find name in MFT>

;******************* START OF SPECIFICATIONS ***********************************
;
;	FNM - Find name in MFT
;
;	FNM searches the MFT for a name record.
;
;	ENTRY	(DS:SI) = pointer to name string (.asciz)
;		(al) = 1 to create record if non exists
;		     = 0 otherwise
;	EXIT	'C' clear if found or created
;		  (DS:BX) = address of MFT name record
;		'C' set if error
;		  If not to create, item not found
;		    (DS:SI) unchanged
;		  If to create, am out of space
;		    (ax) = error code
;	USES	ALL
;
;******************* END OF SPECIFICATIONS *************************************

   Procedure FNM,NEAR

   push ds				; save string address
   push si
   xchg bh,al				; (bh) = create flag
   or	bh,bh				; if not creating
   jz	fnm01				; skip sft test

					;---------------------------------------
					; run down through string counting
					;  and summing
					;---------------------------------------

fnm01: sub dx,dx			; (dx) = byte count
   sub	bl,bl				; (bl) = sum

fnm1: lodsb				; (al) = next char
   add	bl,al
   adc	bl,0
   inc	dx
   and	al,al
   jnz	fnm1				; terminate after null char

					;---------------------------------------
					; Info computed.
					;  Start searching name list

					;  (bh) = create flag
					;  (bl) = sum byte
					;  (dx) = byte count
					;  (TOS+2:TOS) = name string address
					;---------------------------------------
   push cs
   pop	ds

   Off	SI,mft

fnm2: cmp [si].mft_flag,MFLG_FRE
   jl	fnm10				; at end - name not found
   jz	fnm4				; is free, just skip it
   cmp	bl,[si].mft_sum 		; do sums compare?
   jz	fnm5				; its a match - look further
fnm4: add si,[si].mft_len		; not a match... skip it
   JMP	SHORT fnm2
					;---------------------------------------
					; name checksums match
					;   - compare the actual strings
					;
					;   (dx)	= length
					;   (ds:si	= MFT address
					;   (bh)	= create flag
					;   (bl)	= sum byte
					;   (dx)	= byte count
					;   (TOS+2:TOS) = name string address
					;---------------------------------------

fnm5: mov cx,dx 			; (cx) = length to match
   pop	di
   pop	es				; (ES:DI) = fba given name
   push es
   push di
   push si				; save MFT offset
   add	si,mft_name			; (ds:si) = fwa string in record
   repz cmpsb
   pop	si				; (ds:si) = fwa name record
   jnz	fnm4				; not a match

					;---------------------------------------
					; Yes, we've found it.  Return the info
					;
					;  (TOS+2:TOS) = name string address
					;---------------------------------------

   fmt	TypShare,LevMFTSrch,<"FNM found name record at $x\n">,<si>
   pop	ax				; discard unneeded stack stuff
   pop	ax
   mov	bx,si				; (ds:bx) = fwa name record
   clc

   ret
					;---------------------------------------
					;**
					;**  Its not in the list
					;**  - lets find a free spot and put
					;**    it there
					;
					;  (bh)        = create flag
					;  (bl)        = sum byte
					;  (dx)        = string length
					;  (TOS+2:TOS) = ASCIZ string address
					;  (ds)        = SEG CODE
					;---------------------------------------
fnm10:
   and	bh,bh
   jnz	fnm10$5 			; yes, insert it
   pop	si
   pop	ds				; no insert, its a "not found"
   stc

   fmt	TypShare,LevMFTSrch,<"FNM failing\n">

   mov	ax,error_path_not_found

   ret

fnm10$5:
   add	dx,mft_name			; (dx) = minimum space needed

   off	SI,mft

fnm11: cmp [si].mft_flag,MFLG_FRE

   IF	NOT  DEBUG
       jl   fnm20			; at END, am out of space
   ELSE
       jl   fnm20j
   ENDIF

   jz	fnm12				; is a free record
   add	si,[si].mft_len 		; skip name record
   JMP	SHORT fnm11

   IF	DEBUG
fnm20j: jmp fnm20
   ENDIF

fnm12: mov ax,[si].mft_len		; Have free record, (ax) = total length
   cmp	ax,dx
   jnc	fnm13				; big enough
   add	si,ax
   JMP	SHORT fnm11			; not large enough - move on

					;---------------------------------------
					; OK, we have a record which is big
					;  enough.  If its large enough to hold
					;  another name record of 6 characters
					;  than we'll split the block, else
					;  we'll just use the whole thing
					;
					; (ax)	      = size of free record
					; (dx)	      = size needed
					; (ds:si)     = address of free record
					; (bl)	      = sum byte
					; (TOS+2:TOS) = name string address
					;---------------------------------------

fnm13: sub ax,dx			; (ax) = total size of proposed fragment
   cmp	ax,mft_name+6
   jc	fnm14				; not big enough to split
   push bx				; save sum byte
   mov	bx,dx				; (bx) = offset to start of new name record
   mov	[bx][si].mft_flag,MFLG_FRE
   mov	[bx][si].mft_len,ax		; setup tail as free record
   sub	ax,ax				; don't extend this record
   pop	bx				; restore sum byte
fnm14: add dx,ax			; (dx) = total length of this record
   mov	[si].mft_len,dx
   mov	[si].mft_sum,bl
   mov	[si].mft_flag,MFLG_NAM

   fmt	TypShare,LevMFTSrch,<"FNM creating record at $x\n">,<si>

   push ds
   pop	es				; (es) = MFT segment for "stow"
   sub	ax,ax
   mov	di,si
   add	di,mft_lptr
   stosw				; zero LCK pointer
   ERRNZ mft_sptr-mft_lptr-2
;	add	di,mft_sptr-mft_lptr-2
   stosw				; zero SFT pointer
   stosw				; zero SFT pointer
   inc	serial				; bump serial number
   mov	ax,serial
   ERRNZ mft_serl-mft_sptr-4
;	ADD	di,mft_serl-mft_sptr-4
   stosw
					;---------------------------------------
					; We're all setup except for the name.
					;  Note that we'll block copy the whole
					;  name field, even though the name may
					;  be shorter than that (we may have
					;  declined to fragment this memory block)
					;
					;	(dx) = total length of this record
					;	(ds:si) = address of working record
					;	(es) = (ds)
					;	(TOS+2:TOS) = name string address
					;---------------------------------------
   mov	cx,dx
   sub	cx,mft_name			; compute total size of name area
   ERRNZ mft_name-mft_serl-2
;	add	di,mft_name-mft_serl-2	; (ES:DI) = target address
   mov	ax,si				; save name record offset
   pop	si
   pop	ds
   rep	movsb
   mov	bx,ax				; (bx) = name record offset
   push es
   pop	ds				; (DS:BX) = name record offset
   clc

   ret

;**
;**	OUT OF FREE SPACE
;**
;**	This is tough, folks.  Lets trigger a garbage collection and see if
;**	there is enough room.  If there is, we'll hop back and relook for a
;**	free hunk; if there isnt enough space, its error-city!
;
;	WARNING: it is important that the garbage collector be told how big a
;		name record hole we're looking for...  if the size given GCM
;		is too small we'll loop doing "no space; collect; no space;
;		...)
;
;	(dx) = total length of desired name record
;	(ds) = SEG CODE
;	(bl) = sum byte
;	(TOS+2:TOS) = name string address

fnm20:
   mov	ax,dx				; (ax) = size wanted
   sub	dx,mft_name			; (dx) = string length for reentry at fnm10
   push dx
   push bx
   call GCM				; garbage collect MFT
   pop	bx
   pop	dx

   IF	DEBUG
       jnc  fnm10j
   ELSE
       jnc  fnm10			; go back and find that space
   ENDIF

					;---------------------------------------
					; no space, return w/error
					;---------------------------------------

fnm50: pop ax
   pop	ax				; clean stack
   mov	ax,error_sharing_buffer_exceeded
   stc

   ret

   IF	DEBUG
fnm10j: jmp fnm10
   ENDIF

   EndProc FNM

   BREAK <GCM - Garbage Collect MFT>

;******************* START OF SPECIFICATIONS ***********************************
;
;	GCM - Garbage Collect MFT
;
;	GCM runs down the MFT structure squeezing out the free space and
;	putting it into one free block at the end.  This is a traditional heap
;	collection process.  We must be sure to update the pointer in the
;	SFTs.  This presumes no adjacent free blocks.
;
;	ENTRY	(ax) = space desired in last free block
;		(DS) + SEG CODE
;	EXIT	'C' clear if enough space in block
;		'C' set if not enough space
;
;******************* END OF SPECIFICATIONS *************************************

   Procedure GCM,NEAR

   push ax				; save target
   off	si,mft				; (si) = from pointer
   mov	di,si				; (di) = to pointer

					;---------------------------------------
					; (DI) points to the beginning of
					;	a free space block
					; (SI) points to the next block.
					;---------------------------------------

gcm1: mov cx,[si].mft_len		; (cx) = size of whatever it is
   cmp	[si].mft_flag,MFLG_FRE
   jl	gcm10				; END marker
   jnz	gcm2				; have a name record

					;---------------------------------------
					; (SI) points to a free block.
					;    We coalesce it by changing the size.
					;---------------------------------------
   cmp	si,di
   jz	gcm15				; do NOT coalesce a block with itself
   add	[di].mft_len,cx 		; coalesce
gcm15:
   add	si,cx				; skip the empty one
   JMP	SHORT gcm1
					;---------------------------------------
					; (SI) points to a non-free,
					;	non-last block.
					; (DI) points to the beginning of a
					;	 free block.
					;
					; We move the non-free block down over
					;   the free block
					;---------------------------------------
gcm2: cmp si,di
   jnz	gcm3				; have to copy

					;---------------------------------------
					; SI = DI => we are at a boundary
					;	     between allocated blocks.
					;	     We do no copying.
					;---------------------------------------
   add	si,cx
   mov	di,si				; no emptys yet... no need to copy
   JMP	SHORT gcm1
					;---------------------------------------
					; CX is length of allocated block.
					;      - Move it
					;---------------------------------------

gcm3: mov bx,di 			; (DS:BX) = new home for this record
   mov	ax,ds
   mov	es,ax
   rep	movsb
					;---------------------------------------
					; We've moved the record, now fix up
					;  the pointers in the SFT chain
					;
					;  (si) = address of next record
					;  (di) = address of next free byte
					;  (bx) = address of record in its new home
					;  (TOS) = needed space
					;---------------------------------------
   push di
   push ds
   lds	di,[bx].mft_sptr		; (ds:di) = chain of SFT
gcm4: or di,di
   jz	gcm5				; no more SFT
   mov	[di].sf_mft,bx			; install new MFT position
   lds	di,[di].sf_chain		; link to next
   JMP	gcm4				; fix next SFT

gcm5: pop ds
   pop	di
					;---------------------------------------
					; (DI) points to beginning of
					;	new free record (moved)
					; (SI) points to next record
					;
					; Make sure that the (DI) record
					;  has correct format
					;---------------------------------------

   mov	[di].mft_flag,MFLG_FRE		; indicate free record
   mov	[di].mft_len,si 		; calculate correct length
   sub	[di].mft_len,di
					;---------------------------------------
					; MFT now has correct record structure.
					;  Go find more free blocks
					;---------------------------------------
   JMP	SHORT gcm1
					;---------------------------------------
					; We have scanned the entire table,
					;  compacting all empty records together.
					;
					;   (di) = first free byte in table
					;   (si) = address of END record
					;   (TOS) = size needed
					;
					; Be extra careful!!!
					;---------------------------------------
gcm10: mov ax,si
   sub	ax,di				; (ax) = free space
   pop	bx				; (bx) = space wanted
   sub	ax,bx

   ret

   EndProc GCM

   BREAK <RMN - Remove MFT Name record>

;******************* START OF SPECIFICATIONS ***********************************
;
;	RMN - Remove MFT Name record
;
;	RMN removes a name record from the MFT list.  The record is marked
;	free and all free space is coalesced.
;
;	ENTRY	(DS:BX) = FBA MFT name record
;	EXIT	to INTERR if lock and SFT chains are not empty
;	USES	ALL
;
;******************* END OF SPECIFICATIONS *************************************

   Procedure RMN,NEAR

   mov	si,bx
   mov	ax,word ptr [si].mft_sptr
   or	ax,word ptr [si].mft_lptr
   jnz	RMNIER1 			; not clean - internal error
   mov	si,bx				; (ds:si) = fwa name record

   mov	[si].mft_flag,MFLG_FRE		; mark free

   call mrg				; coalesce all free space

   ret

RMNIER1:push ax
   off	ax,RmnErr1

RMNIER: call INTERR			; internal error


   EndProc RMN

   Break <MRG - merge all free space>

;******************* START OF SPECIFICATIONS ***********************************
;
;   MRG - merge all free space
;
;   MRG - walk through mft merging adjacent free space.
;
;   Inputs:	ds = CS
;   Outputs:	none (all free space coalesced)
;   Registers Revised: none
;
;******************* END OF SPECIFICATIONS *************************************

   Procedure MRG,near

   assume ds:nothing,es:nothing

   push si
   push bx

   off	si,mft				; start at beginning
mrg1: mov bx,[si].mft_len		; get length
   cmp	[si].mft_flag,MFLG_FRE		; is record free?
   jl	mrg9				; done.
   jz	mrg2				; yes, try to merge with next
mrg15: add si,bx			; advance to next
   jmp	mrg1
					;---------------------------------------
					; (si) points to free record.
					;  - See if next is free
					;---------------------------------------
mrg2: cmp [bx][si].mft_flag,MFLG_FRE
   jnz	mrg15				; not free, go scan again
   mov	bx,[bx][si].mft_len		; get length of next guy
   add	[si].mft_len,bx 		; increase our length
   jmp	mrg1				; and check again
mrg9: pop bx
   pop	si

   ret

   EndProc MRG

   BREAK <RSC - Remove SFT from SFT chain>

;******************* START OF SPECIFICATIONS ***********************************
;
;	RSC - Remove SFT from SFT chain
;
;	RSC removes a given SFT from its chain.  The caller must insure that
;	any locks have been cleared and that the SFT is indeed free.  The
;	sf_mft field is zeroed to indicate that this SFT is no longer chained.
;
;	NOTE - RSC does NOT remove the name record if this was the last SFT on
;		it.  The caller must check for this and remove it, if
;		necessary.
;
;	ENTRY	(ES:DI) = SFT address
;	EXIT	(DS:BX) = FBA name record for this SFT
;		'Z' set if this is the last SFT
;	USES	ALL
;
;******************* END OF SPECIFICATIONS *************************************

   Procedure RSC,NEAR

   push cs
   pop	ds

   mov	ax,es				; easy spot for compare
   mov	bx,es:[di].sf_mft
   lea	si,[bx].mft_sptr-sf_chain	; ds:[si].sf_chain point to prev link
rsc1: or si,si
   jz	rscier
   cmp	word ptr [si].sf_chain,di
   jnz	rsc15
   cmp	word ptr [si].sf_chain+2,ax
   jz	rsc2
rsc15: lds si,[si].sf_chain
   jmp	rsc1
					;---------------------------------------
					; (es:di) is sft
					; (ds:si) is prev sft link
					;---------------------------------------
rsc2: mov ax,word ptr es:[di].sf_chain
   mov	word ptr ds:[si].sf_chain,ax
   mov	ax,word ptr es:[di].sf_chain+2
   mov	word ptr ds:[si].sf_chain+2,ax

   push cs
   pop	ds
   xor	bx,bx
   xchg bx,es:[di].sf_MFT		; (DS:bx) = MFT address
					;    and 0 MFT pointer (show free)
   cmp	word ptr [bx].mft_sptr,0	; set z flag if no more sft

   ret

rscier: push ax
   off	ax,RscErr

   call interr


   EndProc RSC

   BREAK <SLE - Scan for Lock Entry>

;******************* START OF SPECIFICATIONS ***********************************
;
;	SLE - Scan for Lock Entry
;
;	SLE scans a lock list looking for a lock range that overlaps the
;	caller-supplied range.	SLE indicates:
;
;		no overlap
;		partial overlay
;		1-to-1 match
;
;	ENTRY	(AX:BX) = FBA of area
;		(CX:DX) = LBA of area
;		(DS:SI) = address of name record
;		(DI)	= 0 to ignore locks by User_ID Proc_ID ThisSFT
;			= 1 to consider all locks
;	EXIT	'C' clear if no overlap
;		  AX,BX,CX,DX preserved
;		'C' set if overlap
;		  (di) = address of pointer to found record
;			 (i.e., DS:((di)) = address of lock record)
;		  'Z' set if 1-to-1 match
;	USES	ALL but (ds), (es) (also see EXIT)
;
;******************* END OF SPECIFICATIONS *************************************

   Procedure SLE,NEAR

   push es
   and	di,di
   pushf				; Z set to ignore own locks
   lea	di,[si].mft_lptr		; (ds:di) = addr of ptr to lock record
   mov	si,[di] 			; (ds:si) = address of 1st lock record

					;---------------------------------------
					; check out next lock
					;
					; (ds:si) = address of next lock record
					; (ds:di) = address of pointer to next
					;	     lock record
					; (TOS)   = flags (Z set to ignore
					;	      own locks)
					; (TOS+1) = Saved ES
					;---------------------------------------
sle1: and si,si
   jz	sle9				; list exhaused, ergo no overlap
   popf 				;
   pushf
   jnz	sle2				; am to check all locks

					;---------------------------------------
					; am to ignore own locks...
					;  check the user and proc IDs on this one
					;---------------------------------------

;dcl - this code used to compare the process id in the sft pointed to by the
;  lock.  now we compare the lock process id to the current process id.  this
;  allows a child process to lock an area and then do i/o with it.  before,
;  the child could lock it, but then could not access it


   mov	bp,[si].rlr_pid 		;dcl
   cmp	bp,Proc_id			;dcl
   jnz	sce1$5				;dcl
   les	si,[si].rlr_sptr		; (si) = sft address		;dcl
   mov	bp,es:[si].sf_UID		;dcl
   cmp	bp,User_ID			;dcl
   jnz	sce1$5				; doesn't belong to user        ;dcl
   mov	bp,es				;dcl
   cmp	bp,WORD PTR ThisSFT+2
   jnz	sce1$5
   cmp	si,WORD PTR ThisSFT
sce1$5: mov si,[di]			; (ds:si) = address of next lock record
   jz	sle3				; owned by user - ignore

sle2: mov bp,dx
   sub	bp,[si].rlr_fba 		; compare proposed last to first of record
   mov	bp,cx
   sbb	bp,[si].rlr_fba+2
   jc	sle3				; proposed is above current
   mov	bp,[si].rlr_lba
   sub	bp,bx				; compare proposed first to last of record
   mov	bp,[si].rlr_lba+2
   sbb	bp,ax
   jnc	sle5				; we have a hit

					;---------------------------------------
					; This entry is harmless...
					;    chain to the next one
					;---------------------------------------
   ERRNZ rlr_next

sle3: mov di,si 			; save addr of pointer to next
   mov	si,[di]
   JMP	SHORT sle1
					;---------------------------------------
					; We have an overlap.
					;  - See if its an exact match
					;
					; (ds:di) = address of pointer
					;	    (offset only) to the lock record
					; (ds:si) = address of lock record
					; (TOS) = flags ('Z' set if to ignore
					;	  own locks)
					; (TOS+1) = saved (es)
					;---------------------------------------

sle5: xor ax,[si].rlr_fba+2		; require a 4-word match
   xor	bx,[si].rlr_fba
   xor	cx,[si].rlr_lba+2
   xor	dx,[si].rlr_lba
   or	ax,bx
   or	ax,cx
   or	ax,dx				; 'Z' set if exact match
   stc					; flag an overlap
   mov	ax,error_lock_violation
sle9: pop bp				; discard flags (pushf)
   pop	es				; restore (es)

					;---------------------------------------
					; (ds:si) = address of lock record
					;	    for Chk_Block
					;---------------------------------------
   ret

   EndProc SLE

   BREAK <OFL - obtain free lock-record>

;******************* START OF SPECIFICATIONS ***********************************
;
;	OFL - obtain free lock-record
;
;	OFL returns a free lock-record, if one can be had.
;
;	ENTRY	(DS) = MFT Segment
;	EXIT	'C' clear if OK
;		  (DI) = FBA lock record
;		'C' set if no space
;		  (ax) = error code
;	USES	DI, FLAGS
;
;******************* END OF SPECIFICATIONS *************************************

   Procedure OFL,NEAR

   mov	di,Frelock
   and	di,di

;  $if	nz				; if something there
   JZ $$IF1

       push [di].rlr_next
       pop  Frelock			; chain off of the list
					; exit with 'C' clear

;  $else				; none on free list
   JMP SHORT $$EN1
$$IF1:

       mov  ax,error_sharing_buffer_exceeded ; None on free list, give up until
       stc				;  garbage collector is ready

;  $endif
$$EN1:

   ret

   EndProc OFL

   Break <CPS - close process SFT>

;******************* START OF SPECIFICATIONS ***********************************
;
;   CPS - close process SFT.
;
;	During maintenance, it is necessary to close a
;	file given ONLY the SFT.  This necessitates walking all PDB's JFN
;	tables looking for the SFN.  The difficult part is in generating the
;	SFN from the SFT.  This is done by enumerating SFT's and comparing for
;	the correct SFT.  Finding all PDBs is easy:  walk arena and check
;	owner fields
;
;   Inputs:	ThisSFT points to SFT of interest
;   Outputs:	Handle is closed on user
;   Registers Revised: none
;
;******************* END OF SPECIFICATIONS *************************************

   Procedure CPS,NEAR

   ASSUME DS:NOTHING,ES:NOTHING

   SaveReg <DS,SI,ES,DI,AX,BX,CX>

   lds	si,ThisSFT
   xor	bx,bx
cps01:

   CallInstall SFFromSFN,multDOS,22,bx,bx

   jc	cps31				; no more SFN's.  Must be FCB.

   CallInstall PointComp,multDOS,20

   jz	cps02				; found matching SFN, go scan.
   inc	bx				; did not match, go back for more
   jmp	cps01
					;---------------------------------------
					; BL is the sfn we want to find.  Walk
					;  the memory arena enumerating all PDB's
					;  and zap the handle tables for the
					;  specified sfn.
					;---------------------------------------
cps02:
   mov	al,bl
   mov	ds,Arena_Head			; get first arena pointer

					;---------------------------------------
					; DS:[0] is the arena header.
					; AL is sfn to be closed
					;---------------------------------------
cps1:
   mov	cx,ds:[arena_owner]
   mov	bx,ds
   inc	bx				; is the owner the same as the current
   cmp	cx,bx				; block?
   jnz	cps2				; no, go skip some more...

					;---------------------------------------
					; CX:0 is the correct pointer to a PDB.
					;---------------------------------------
   push ds
   mov	ds,cx
					;---------------------------------------
					; Given a PDB at DS:0, scan his handle
					;  table and then loop through the next
					;  PDB link.
					;---------------------------------------
cps15:
   call CPJ				; free for this PDB
   lds	cx,DS:[PDB_Next_PDB]		; advance to next
   cmp	cx,-1
   jnz	cps15				; there is another link to process
   pop	ds
					;---------------------------------------
					; We have processed the current
					;  allocation block pointed to by DS.
					;  DS:[0] is the allocation block
					;---------------------------------------
cps2:
   cmp	ds:[arena_signature],arena_signature_end
   jz	cps3				; no more blocks to do
   mov	bx,ds				; get current address
   add	bx,DS:[Arena_size]		; add on size of block
   inc	bx				; remember size of header
   mov	ds,bx				; link to next
   jmp	cps1
					;---------------------------------------
					; Just for good measure, use CurrentPDB
					;  and clean off him
					;---------------------------------------
cps3:
   mov	ds,CurrentPDB

   call CPJ

cps31:

   RestoreReg <

   RestoreReg <CX,BX,AX,DI,ES,SI,DS>

   ret

   EndProc CPS

;******************* START OF SPECIFICATIONS ***********************************
;
; CPJ -
;
; Scan JFN table for SFT # and put in -1 if found
;
; Input: DS:0 is PDB
;	 AL is SFT index # of interest
;
; Output: None
;
; Uses: Flags,CX,ES,DI
;
;******************* END OF SPECIFICATIONS *************************************

   Procedure CPJ,NEAR

   assume ds:nothing,es:nothing

   mov	cx,ds:[PDB_JFN_length]
   les	di,ds:[PDB_JFN_pointer]
   cld
cpj1: repne scasb

   retnz				; none found

   mov	byte ptr es:[di-1],-1		; free this
   jcxz CPJret				; Found one in last JFN entry
   jmp	cpj1				; keep looking
CPJret:

   ret

   EndProc CPJ

   Break <SFM - convert an mft pointer into a serial number>

;******************* START OF SPECIFICATIONS ***********************************
;
;   SFM - convert a pointer to a mft entry into the serial number for that
;   entry.  We keep these around to see if a FCB really points to the correct
;   SFT.
;
;   Inputs:	BX is the mft pointer
;   Outputs:	BX is the serial number
;   Registers Revised: none
;
;******************* END OF SPECIFICATIONS *************************************

   Procedure SFM,NEAR

   ASSUME CS:SHARE,DS:NOTHING,ES:NOTHING,SS:DOSDATA

   mov	bx,cs:[bx].mft_serl

   ret

   EndProc SFM

   Break <ShChk - check a fcb for share related information>

;******************* START OF SPECIFICATIONS ***********************************
;
;   ShChk - check a fcb for share related information
;
;   ShChk - checks the reserved field contents of an FCB with a SFT to see
;   if they represent the same file.  The open ref count must be > 0.
;
;   Inputs:	DS:SI point to FCB
;		ES:DI point to SFT
;   Outputs:	Carry Set if contents do not match
;		Carry clear if contents match
;		    BX has first cluster
;   Registers Revised: none
;
;******************* END OF SPECIFICATIONS *************************************

   Procedure ShChk,NEAR

   ASSUME CS:SHARE,DS:NOTHING,ES:NOTHING,SS:DOSDATA

   CMP	ES:[DI].sf_ref_count,0
   JZ	BadSFT
   MOV	BX,ES:[DI].sf_mft		; Local file or dev with sharing

   call SFM

   CMP	BX,[SI].fcb_l_mfs
   JNZ	BadSFT
   MOV	BX,[SI].fcb_l_firclus

   ret

BadSFT: stc

   ret

   EndProc ShChk

   Break <ShSave - save information from SFT into an FCB>

;******************* START OF SPECIFICATIONS ***********************************
;
;   ShSave - save information from SFT into an FCB
;
;   ShSave - copy information into the reserved area of an FCB from a SFT.
;   This is so that we can later match the SFT with the FCB.
;
;   Inputs:	ES:DI point to SFT
;		DS:SI point to FCB
;   Outputs:	FCB reserved field is filled in
;		BL = FCBSHARE
;   Registers Revised: AX,BX
;
;******************* END OF SPECIFICATIONS *************************************

   Procedure ShSave,NEAR

   ASSUME CS:SHARE,DS:NOTHING,ES:NOTHING,SS:DOSDATA

   MOV	AL,ES:[DI].sf_attr		; move attribute (for reopen)
   MOV	[SI].FCB_l_attr,AL
   MOV	AX,ES:[DI].sf_firclus		; get first cluster
   MOV	[SI].FCB_l_firclus,AX
   MOV	BX,ES:[DI].sf_mft		; get sharing pointer

   call SFM

   MOV	[SI].FCB_l_mfs,BX
   MOV	BL,FCBSHARE

   ret

   EndProc ShSave

   Break <ShCol - collapse identical handle SFTs in mode 70 only>

;******************* START OF SPECIFICATIONS ***********************************
;
;   ShCol - collapse identical handle SFTs in mode 70 only
;
;   ShCol - collapse same 70-mode handles together.  This represents network
;   originated FCBs.  Since FCB's are incredibly mis-behaved, we collapse the
;   SFT's for identical files, thus using a single sft for each file instead
;   of a separate sft for each instance of the file.
;
;   Note that the redirectors will collapse multiple instances of these
;   files together.  FCB's are pretty misbehaved, so the redirector will
;   inform us of EACH close done on an FCB.  Therefore, we must increment
;   the ref count each time we see a collapse here.
;
;   Inputs:	DS:SI ThisSFT has new sft to find.
;   Outputs:	Carry set - no matching SFT was found
;		Carry clear - matching SFT was found and all collapsing done.
;		    AX has proper handle
;   Registers Revised: all.
;
;******************* END OF SPECIFICATIONS *************************************

   Procedure ShCol,NEAR

   ASSUME CS:SHARE,DS:NOTHING,ES:NOTHING,SS:DOSDATA

					;---------------------------------------
					; Collapse the files ONLY if
					;  the mode is for net FCB's
					;---------------------------------------

   MOV	AL,BYTE PTR [SI].sf_mode
   AND	AL,sharing_mask
   CMP	AL,sharing_net_FCB
   JNZ	UseJFN

					;---------------------------------------
					; In share support
					;---------------------------------------

   XOR	BX,BX				;   for (i=0; sffromsfn(i); i++) {
OpenScan:

   CallInstall SFFromSFN,multDOS,22,bx,bx

   JC	UseJFN

   CallInstall PointComp,multDOS,20	;	if (!pointcomp (s,d))

   JZ	OpenNext
   CMP	ES:[DI].sf_ref_count,0
   JZ	OpenNext
   MOV	AX,ES:[DI].sf_mode
   CMP	AX,[SI].sf_mode
   JNZ	OpenNext
   MOV	AX,ES:[DI].sf_mft
   CMP	AX,[SI].sf_mft
   JNZ	OpenNext
   MOV	AX,WORD PTR ES:[DI].sf_UID
   CMP	AX,WORD PTR [SI].sf_uid
   JNZ	OpenNext
   MOV	AX,WORD PTR ES:[DI].sf_pid
   CMP	AX,WORD PTR [SI].sf_pid
   JZ	OpenFound
OpenNext:
   INC	BX
   JMP	OpenScan
					;--------------------------------------
					; DS:SI points to an sft which is a
					;	 duplicate of that found in
					; ES:DI is the older one.
					;
					; We call mftclose to release the
					;   appropriate info.
					;--------------------------------------
OpenFound:
   MOV	[SI].sf_ref_count,0		; free 'new' sft

   SaveReg <DS,SI,ES,DI,BX>

   Context DS

   LES	DI,ThisSFT

   call MFTClose

   RestoreReg <AX,DI,ES,SI,DS>

   ASSUME DS:NOTHING

   INC	ES:[DI].sf_ref_count		;   d->refcount++;
   XOR	BX,BX				; find jfn with sfn as contents
JFNScan:

   CallInstall pJFNFromHandle,multDOS,32,AX,AX

   JC	UseJFN				; ran out of handles?
   CMP	AL,BYTE PTR ES:[DI]		; does JFN have SFN?
   jz	JFNfound			; YES, go return JFN
   INC	BX				; no, look at next
   JMP	JFNScan
JFNFound:
   LDS	SI,pJFN
   MOV	BYTE PTR [SI],0FFh		; free JFN
   MOV	AX,BX				; return JFN

   ret

UseJFN:
   MOV	AX,JFN

   ret

   EndProc ShCol

   Break <ShCloseFile - close a particular file for a particular UID/PID>

;******************* START OF SPECIFICATIONS ***********************************
;
;   ShCloseFile - close a particular file for a particular UID/PID
;
;   ShCloseFile - Compatability mode programs will often delete files that
;   they had open.  This was perfectly valid in the 2.0 days, but this
;   presents a reliability problem in the network based operating environment.
;   As a result, both RENAME and DELETE will call us to see if the file is
;   open by is only.  If it is not open or is open by us only, we close it.
;   Note that we will ONLY close compatability SFTs.
;   Otherwise, we signal and error.
;
;   Inputs:	WFT_Start has a DOSDATA offset to the file name
;		DS is DOSData
;   Outputs:	nothing relevant.
;   Registers Revised: None.
;
;******************* END OF SPECIFICATIONS *************************************

   Procedure ShCloseFile,NEAR

   ASSUME DS:DOSDATA,ES:NOTHING,SS:DOSDATA

   SaveReg <AX,BX,CX,DX,SI,DI,BP,DS,ES>

   EnterCrit critShare

ShCl:
   MOV	SI,WFP_Start
   XOR	AL,AL

   call FNM				; attempt to find name in list

   ASSUME DS:NOTHING

   JC	ShCloseDone			; can't find, signal success

					;--------------------------------------
					; We have found a file in the MFT.
					;  Walk the open sft list to find
					;  the SFTs for the current UID/PID.
					;--------------------------------------
   MOV	CX,DS
   LDS	SI,[BX].mft_sptr
ShClCheck:
   MOV	AX,Proc_ID
   CMP	[SI].sf_PID,AX
   JNZ	ShCloseDone
   MOV	AX,User_ID
   CMP	[SI].sf_UID,AX
   JNZ	ShCloseDone
   MOV	AX,[SI].sf_mode
   AND	AX,sharing_mask
   CMP	AX,sharing_net_fcb
   jz	ShClNext
   CMP	AX,sharing_compat
   jnz	ShCloseDOne
ShClNext:
   LDS	SI,[SI].sf_chain
   OR	SI,SI
   JNZ	ShClCheck
   MOV	DS,CX
   LDS	SI,[BX].mft_sptr
					;--------------------------------------
					; Everything matches.  Set up ThisSFT
					;  and walk the chain from the beginning.
					;--------------------------------------
   MOV	WORD PTR ThisSFT,SI
   MOV	WORD PTR ThisSFT+2,DS
					;--------------------------------------
					; Close all handles for this SFT
					;--------------------------------------
   call CPS
					;--------------------------------------
					; Close the sft itself.
					;--------------------------------------
   Context DS

   CallInstall DOS_Close,multDos,1
					;--------------------------------------
					; The SFT may be free and we have no
					;  idea where the next is.  Go and loop
					;  all over.
					;--------------------------------------
   JMP	ShCl
					;--------------------------------------
					; There are no more SFTs to close. Leave
					;---------------------------------------
ShCloseDone:

   LeaveCrit critShare

   STC

   RestoreReg <ES,DS,BP,DI,SI,DX,CX,BX,AX>

   ret

   EndProc ShCloseFile

   .xall
   Break <ShSU - update all SFTs for a specified change>
;******************* START OF SPECIFICATIONS ***********************************
;
;  NAME:	   ShSU - update all SFTs for a specified change>
;
;  FUNCTION:	   In a shared environment, we want to propogate the SFT
;		   changes for a particular file to all other SFTs for that
;		   file.  The types of things we propogate are:
;
;		   - Time of last write - we only do this on CLOSE and on
;		     FILETIMES.
;
;		   - Size and allocation information - we do this ONLY when
;		     we change sf_size.
;
;		   We achieve this by walking the linked list of SFTs for the
;		   file. See PSEUDOCODE below
;
;  INPUT:	   ES.DI  has SFT that was just Revised.
;		   AX = 0 for updating of time from ES:DI into old sfts
;		   AX = 1 for updating of size/allocation for growth from ES:DI
;		   AX = 2 for updating of size/allocation for shrink from ES:DI
;		   AX = 3 for new instance copy into ES:DI
;		   AX = 4 for update of codepage and high attribute
;
;  OUTPUT:	   All relevant SFTs are updated.
;
;  REGISTERS USED: All except ES:DI and DS:SI
;  (NOT RESTORED)
;
;  LINKAGE:	   DOS Jump Table
;
;  EXTERNAL	   Invoke: New_Sft, Call_IFS
;  REFERENCES:	   Callinstall
;
;  NORMAL	   -
;  EXIT:
;
;  ERROR	   -
;  EXIT:
;
;  CHANGE	   04/15/87 - Major overhaul and IFS support
;  LOG:
;
;******************* END OF SPECIFICATIONS *************************************
;******************+ START OF PSEUDOCODE +**************************************
;
;	START ShSU
;
;	if not a device and
;	if not a network
;		search
;			if our SFT
;				advance to next SFT
;			endif
;		leave if no more SFT's
;		exitif cx = 3
;			invoke New_Sft
;		orelse
;			if cx = 0
;				update time
;				update date
;				if non - FAT file system
;					call IFSFUNC
;				endif
;			else cx = 1 or 2
;				update size
;				if non - FAT file system
;					call IFSFUNC
;				else
;					update first cluster
;					if cx = 2 or
;					if lstclus un-set from create
;						update cluster position
;						update last cluster
;					endif
;				endif
;			endif
;			advance to next SFT
;		endloop
;		endsearch
;	endif
;	return
;
;	END ShSU
;
;******************+  END  OF PSEUDOCODE +**************************************

   Procedure ShSU,near

   ASSUME DS:NOTHING,ES:NOTHING

   nop
;  int 3
   nop

ifs_flag equ 8000h			;				       ;AN000;
					;---------------------------------------
					; Do nothing for device or network
					;---------------------------------------

   mov	bx,es:[di].sf_flags		; M004: must check sf_flags field 
;; mov	bx,es:[di].sf_mode		; M004: sf_mode

   and	bx,sf_isnet + devid_device

;  $if	z,and,long			; if not device and		       ;AC000;
   JZ $$XL1
   JMP $$IF4
$$XL1:

   mov	bx,es:[di].sf_MFT
   or	bx,bx

;  $if	nz,,long			; if not network		       ;AC000;
   JNZ $$XL2
   JMP $$IF4
$$XL2:

       EnterCrit critShare
					;---------------------------------------
					; Walk the sft chain for this file and
					;  skip the current SFT (ES:DI)
					;---------------------------------------
       SaveReg <DS,SI>

       lds  si,cs:[bx].MFT_SPTR
       mov  cx,ax

;      $search				;				       ;AC000;
$$DO5:

	   CallInstall PointComp,multDOS,20 ; pointers different?

;	   $if	z			; if ourselves			       ;AC000;
	   JNZ $$IF6

	       lds  si,[si].sf_chain	; move to next			       ;AC000;

;	   $endif			; endif - ourselves		       ;AC000;
$$IF6:

	   or	si,si

;      $leave z 			;				       ;AC000;
       JZ $$EN5

					;---------------------------------------
					; CX = 0 for updating of time
					; CX = 1 for updating of size/allocation
					;	   for growth
					; CX = 2 for updating of size/allocation
					;	   for shrink
					; CX = 3 for new instance copy.
					;---------------------------------------
	   cmp	cx,2			;				       ;AC000;

;      $exitif a			;				       ;AC000;
       JNA $$IF5
					;---------------------------------------
					; CX = 3 for new instance copy.
					; CX = 4 for codepage and high attrib update
					;---------------------------------------
	   cmp	cx,3			; cx = 3 ?			       ;an000;
;	   $if	e			; yes				       ;an000;
	   JNE $$IF10
	       call New_Sft		;				       ;AN000;
;;	   $else			; cx = 4			       ;an000;
;;	       call New_CP_Attrib	; update codepage and high attrib      ;an000;
;	   $endif			;				       ;an000;
$$IF10:

;      $orelse				;				       ;AC000;
       JMP SHORT $$SR5
$$IF5:

	   or	cx,cx

;	   $if	z			; if cx = 0 then		       ;AC000;
	   JNZ $$IF13
					;---------------------------------------
					; CX = 0 for updating of time
					;
					; Copy time from ES:DI into DS:SI
					;---------------------------------------
	       mov  bx,es:[di].sf_time
	       mov  [si].sf_time,bx
	       mov  bx,es:[di].sf_date
	       mov  [si].sf_date,bx
	       test [si].sf_flags,ifs_flag ;				       ;AN000;

;	       $if  nz			; if non-FAT			       ;AC003;
	       JZ $$IF14

		   call Call_IFS	; tell IFS of SFT change	       ;AN000;

;	       $endif			; endif non- FAT		       ;AN000;
$$IF14:

;	   $else			; else - must be >0 and <2	       ;AC000;
	   JMP SHORT $$EN13
$$IF13:
					;---------------------------------------
					; CX = 1 for updating of size/allocation
					;	  for growth
					; CX = 2 for updating of size/allocation
					;	  for shrink
					;
					; We always copy size and firclus
					;---------------------------------------
	       mov  bx,word ptr es:[di].sf_size
	       mov  word ptr [si].sf_size,bx
	       mov  bx,word ptr es:[di].sf_size+2
	       mov  word ptr [si].sf_size+2,bx
	       test [si].sf_flags,ifs_flag ;				       ;AN000;

;	       $if  nz			; if non-FAT			       ;AC003;
	       JZ $$IF17

		   invoke Call_IFS	; tell IFS of SFT change	       ;AN000;

;	       $else			; else - its FAT		       ;AN000;
	       JMP SHORT $$EN17
$$IF17:

		   mov	bx,es:[di].sf_firclus
		   mov	[si].sf_firclus,bx
		   cmp	cx,2		;				       ;AC000;

;		   $if	z,or		; if SFT is shrinking or	       ;AC000;
		   JZ $$LL19

		   cmp	[si].sf_lstclus,0 ; lstclus UN-set from a create?      ;AC000;

;		   $if	z		; If it is, set lstclus and cluspos too;AC000;
		   JNZ $$IF19
$$LL19:
					;---------------------------------------
					; Shrink the file, move in new cluspos
					;  and lstclus
					;---------------------------------------
		       mov  [si].sf_cluspos,0 ; retrace from start
		       mov  [si].sf_lstclus,bx ; ditto

;		   $endif		; endif - set lstclus and cluspos      ;AC000;
$$IF19:

;	       $endif			; endif  FAT			       ;AN000;
$$EN17:

;	   $endif			; enndif - > 0			       ;AC000;
$$EN13:
					;---------------------------------------
					; Link to next SFT
					;---------------------------------------
	   lds	si,[si].sf_chain

;      $endloop 			;				       ;AC000;
       JMP SHORT $$DO5
$$EN5:

;      $endsrch 			;				       ;AC000;
$$SR5:
					;---------------------------------------
					; All Done
					;---------------------------------------
       RestoreReg <SI,DS>

       LeaveCrit critShare

;  $endif				; endif - device and network	       ;AC000;
$$IF4:

   ret

   EndProc ShSU

   Break <New_Sft - update a new SFT>

;******************* START OF SPECIFICATIONS ***********************************
;
;  NAME:	   New_Sft - update a new SFT
;
;  FUNCTION:	   Copy all SFT information into a NEW sft of a SHARED file.
;
;
;  INPUT:	   ES.DI  has SFT that was just Revised.
;		   DS:SI  has SFT that is to be updated
;
;  OUTPUT:	   SFT is updated.
;
;  REGISTERS USED: AX, BX
;  (NOT RESTORED)
;
;  LINKAGE:	   Invoked by: ShSU
;
;  EXTERNAL	   Invoke: Call_IFS
;  REFERENCES:
;
;  CHANGE	   04/15/87 - First release
;  LOG:
;
;******************* END OF SPECIFICATIONS *************************************
;******************+ START OF PSEUDOCODE +**************************************
;
;	START New_Sft
;
;	update time
;	update date
;	update size
;	if   non - FAT file system
;		call IFSFUNC
;	else
;		update first cluster
;		update cluster position
;		update last cluster
;	endif
;	return
;
;	END New_Sft
;
;******************+  END  OF PSEUDOCODE +**************************************

   Procedure New_Sft,near		;				       ;AN000;

   mov	bx,[si].sf_time 		; update time
   mov	es:[di].sf_time,bx
   mov	bx,[si].sf_date 		; update date
   mov	es:[di].sf_date,bx
   mov	bx,word ptr [si].sf_size	; update size
   mov	word ptr es:[di].sf_size,bx
   mov	bx,word ptr [si].sf_size+2
   mov	word ptr es:[di].sf_size+2,bx
   test es:[di].sf_flags,ifs_flag	;				       ;AN000;

;  $if	nz				; if non-FAT			       ;AC003;
   JZ $$IF26

       call Call_IFS			; tell IFS of SFT change	       ;AN000;

;  $else				; else - its FAT		       ;AN000;
   JMP SHORT $$EN26
$$IF26:

       mov  bx,[si].sf_firclus		; update first cluster
       mov  es:[di].sf_firclus,bx
       mov  es:[di].sf_cluspos,0	; retrace from start
       mov  es:[di].sf_lstclus,bx	; ditto

;  $endif				; endif  FAT			       ;AN000;
$$EN26:

   ret					; we'er done                           ;AN000;

   EndProc New_Sft			;				       ;AN000;

   Break <New_CP_Attrib - update the codepage and attrib in SFT>

;******************* START OF SPECIFICATIONS ***********************************
;
;  NAME:	   New_CP_Attrib - Update codepage and attrib in SFT
;
;  FUNCTION:	   Copy all codepage and attrib into SFT of a SHARED file.
;
;
;  INPUT:	   ES.DI  has SFT that was just Revised.
;		   DS:SI  has SFT that is to be updated
;
;  OUTPUT:	   SFT is updated.
;
;  REGISTERS USED: AX, BX
;  (NOT RESTORED)
;
;  LINKAGE:	   Invoked by: ShSU
;
;  EXTERNAL	   Invoke: Call_IFS
;  REFERENCES:
;
;  CHANGE	   10/06/87 - First release	- D. M. Sewell
;  LOG:
;
;******************* END OF SPECIFICATIONS *************************************
;******************+ START OF PSEUDOCODE +**************************************
;
;	START New_CP_Attrib
;
;	Update codepage
;	Update high attribute
;	$if ifs_flag
;		call Call_IFS
;	$endif
;	return
;
;	END New_CP_Attrib
;
;******************+  END  OF PSEUDOCODE +**************************************

;; Procedure New_CP_Attrib,near 	;				       ;AN000;

;; mov	bx,es:[di].SF_Codepage		; update codepage		       ;an000;
;; mov	[si].SF_Codepage,bx		;an000; dms;
;; mov	bl,es:[di].SF_Attr_Hi		; update high attribute 	       ;an000;
;; mov	[si].SF_Attr,bl 		;an000; dms;
;; test es:[di].sf_flags,ifs_flag	;				       ;AN000;

;; $if	nz				; if non-FAT			       ;AC003;

;;     call Call_IFS			; tell IFS of SFT change	       ;AN000;

;; $endif				; endif  FAT			       ;AN000;

;; ret					; we'er done                           ;AN000;

;; EndProc New_CP_Attrib		;				       ;AN000;


   Break <Call_IFS - warn IFS that SFT has changed>

;******************* START OF SPECIFICATIONS ***********************************
;
;  NAME:	   Call_IFS - warn IFS that SFT has changed
;
;  FUNCTION:	   Call IFS thru 2F interupt.
;
;  INPUT:	   DS.SI  points to SFT that was just Revised.
;
;  OUTPUT:	   none
;
;  REGISTERS USED: AX
;  (NOT RESTORED)
;
;  LINKAGE:	   Invoked by: ShSU, New_SFT
;
;  EXTERNAL	   Callinstall
;  REFERENCES:
;
;  CHANGE	   04/15/87 - First release
;  LOG:
;
;******************* END OF SPECIFICATIONS *************************************
;******************+ START OF PSEUDOCODE +**************************************
;
;	START Call_IFS
;
;	set up for INT
;	INT 2F
;	return
;
;	END Call_IFS
;
;******************+  END  OF PSEUDOCODE +**************************************

   Procedure Call_IFS,near		;				       ;AN000;

   CallInstall BlockUpdate,MultIFS,44,CX,CX ;				       ;AC005;

   ret					;				       ;AN000;

   EndProc Call_IFS			;				       ;AN000;

   Break <Internal error routines>

;******************* START OF SPECIFICATIONS ***********************************
;
; INTERR - INTernal ERRor routines
;
;******************* END OF SPECIFICATIONS *************************************

   Procedure INTERR,NEAR

   ASSUME DS:NOTHING,ES:NOTHING,SS:NOTHING

   SaveReg <BX,SI,DS>			; save registers that get clobbered

   push cs				; gain addressability
   pop	ds
   mov	si,ax				; get message to print

   call gout

   off	si,IntErrMsg

   call gout

   RestoreReg <ds,si,bx>

INTERRL:jmp INTERRL			; hang here - we're sick

gout: lodsb
   or	al,al
   retz
   mov	ah,14
   int	10h
   jmp	gout


   EndProc INTERR

   Break <INT 2F handler>

   IF	installed

Cont   dd   ?

INT2F  PROC FAR

       ASSUME CS:SHARE,DS:NOTHING,ES:NOTHING,SS:NOTHING
       cmp  ah,multSHARE
       jnz  ContJ

;
;      00h its anyone else  - return 0FFh - loaded
;
	or	al,al		;
	jnz	ContJ		;not our function, pass it on

loaded:
	mov	al,0ffh	;indicate that Share is loaded

	iret
ContJ:
	jmp	Cont		;chain on to next handler

INT2F  ENDP

       ASSUME CS:SHARE,DS:NOTHING,ES:NOTHING,SS:DOSData

IRP    rtn,<MFT_enter, MFTClose, MFTclU, MFTCloseP, MFTCloN, set_mult_block, clr_mult_block>
J&rtn  proc far
       call rtn
       ret
j&rtn  endp
endm

IRP    rtn,<chk_block, MFT_get, ShSave, ShChk, ShCol, ShCloseFile, ShSU>
J&rtn  proc far
       call rtn
       ret
j&rtn  endp
endm

IRP    sect,<critShare>
       Procedure E&sect,NEAR
       PUSH AX
       MOV  AX,8000h+sect
       INT  int_ibm
       POP  AX
       ret
       EndProc E&sect

       Procedure L&sect,NEAR
       PUSH AX
       MOV  AX,8100h+sect
       INT  int_ibm
       POP  AX
       ret
       EndProc L&sect
       ENDM

   ENDIF

;SR;
; The internal error messages are being included here. These have all been
;moved into a single file so that it is easy to internationalize the messages
;

include shmsg.inc



   BREAK <MFT and Lock Record Data Area>

;******************* START OF SPECIFICATIONS ***********************************
;
;	first MFT record
;
;	Note that the name field can have garbage after the trailing
;	00 byte.  This is because the field might be too long, but
;	not long enough (at least 16 extra bytes) to fragment.
;	in this case we copy the length of the string area, not
;	the length of the string and thus may copy tailing garbage.
;
;******************* END OF SPECIFICATIONS *************************************

PoolSize = 2048

   PUBLIC MFT

MFT DB	0				; free
   DW	PoolSize			; PoolSize bytes long

   IF	not  Installed

       DB   (PoolSize-3) DUP(0) 	; leave rest of record
MEND   DB   -1				; END record

lck1   DW   0				; link
       DB   SIZE RLR_entry-2 DUP(0)
lck2   DW   OFFSET DOSDATA:lck1        ; link
       DB   SIZE RLR_entry-2 DUP(0)
lck3   DW   OFFSET DOSDATA:lck2        ; link
       DB   SIZE RLR_entry-2 DUP(0)
lck4   DW   OFFSET DOSData:lck3        ; link
       DB   SIZE RLR_entry-2 DUP(0)
lck5   DW   OFFSET DOSDATA:lck4        ; link
       DB   SIZE RLR_entry-2 DUP(0)
lck6   DW   OFFSET DOSDATA:lck5        ; link
       DB   SIZE RLR_entry-2 DUP(0)
lck7   DW   OFFSET DOSDATA:lck6        ; link
       DB   SIZE RLR_entry-2 DUP(0)
lck8   DW   OFFSET DOSDATA:lck7        ; link
       DB   SIZE RLR_entry-2 DUP(0)

       CODE ENDS

       %out Ignore this END error (blasted assembler)

   ENDIF

IF Installed

   ASSUME CS:SHARE,DS:NOTHING,ES:NOTHING,SS:NOTHING

   IF1
InitSpace DW PoolSize
   ELSE
       IF   shareinit-MFT LT PoolSize
InitSpace  DW	PoolSize
       ELSE
InitSpace  DW	shareinit-MFT
       ENDIF
   ENDIF
InitLocks DW 20


JTable LABEL BYTE
   DD	?
   DD	JMFT_Enter			;   1	MFT_enter
   DD	JMFTClose			;   2	MFTClose
   DD	JMFTclU 			;   3	MFTclU
   DD	JMFTcloseP			;   4	MFTCloseP
   DD	JMFTcloN			;   5	MFTCloN
   DD	JSet_Mult_Block 		;   6	Set_Mult_Block
   DD	JClr_Mult_Block 		;   7	Clr_Mult_Block
   DD	JChk_Block			;   8	Chk_Block
   DD	JMFT_Get			;   9	MFT_get
   DD	JShSave 			;   10	ShSave
   DD	JShChk				;   11	ShChk
   DD	JShCol				;   12	ShCol
   DD	JShCloseFile			;   13	ShCloseFile
   DD	JShSU				;   14	ShSU
JTableLen = $ - JTable

;	$SALUT	(4,9,17,36)
				   ;---------------------------------------
				   ;  STRUCTURE TO DEFINE ADDITIONAL
				   ;  COMMAND LINE PARAMETERS
				   ;---------------------------------------
PARMS	LABEL	DWORD
	DW	OFFSET PARMSX	   ; POINTER TO PARMS STRUCTURE
	DB	0		   ; NO DELIMITER LIST FOLLOWS
	DB	0		   ; NUMBER OF ADDITIONAL DELIMITERS

				   ;---------------------------------------
				   ;  STRUCTURE TO DEFINE SORT
				   ;  SYNTAX REQUIREMENTS
				   ;---------------------------------------
PARMSX	LABEL	BYTE
	DB	0,0		   ; THERE ARE NO POSITIONAL PARAMETERS
	DB	2		   ; THERE ARE TWO TYPES OF SWITCH
	DW	OFFSET SW	   ; POINTER TO THE SWITCH DEFINITION AREA
	DW	OFFSET SW_OPT	   ; POINTER TO THE SWITCH DEFINITION AREA
	DW	0		   ; THERE ARE NO KEYWORDS IN SHARE SYNTAX

				   ;---------------------------------------
				   ;  STRUCTURE TO DEFINE THE SWITCHES
				   ;---------------------------------------

SW	LABEL	WORD
	DW	08001H		   ; MUST BE NUMERIC
	DW	0		   ; NO FUNCTION FLAGS
	DW	OFFSET SWITCH_BUFF ; PLACE RESULT IN SWITCH BUFFER
	DW	OFFSET VALUES	   ; NEED VALUE LIST
	DB	3		   ; TWO SWITCHES IN FOLLOWING LIST
F_SW	DB	"/F",0		   ; /F: INDICATES n FILESPACE REQUESTED
L_SW	DB	"/L",0		   ; /L: INDICATES m LOCKS REQUESTED
N_SW	DB	"/NC",0 	   ; /NC: INDICATES no checking required

	PUBLIC	SW_OPT, ?_SW
SW_OPT	LABEL	WORD
	DW	0		   ; MATCH MASK
	DW	0		   ; FUNCTION MASK
	DW	OFFSET SWITCH_BUFF ; PLACE RESULT IN SWITCH BUFFER
	DW	OFFSET VALUES	   ; NEED VALUE LIST
	DB	1		   ; 1 SWITCH IN FOLLOWING LIST
?_SW	DB	"/?",0             ; /?   INDICATES give options help


				   ;---------------------------------------
				   ;  VALUE LIST DEFINITION FOR n
				   ;---------------------------------------

VALUES	LABEL	BYTE
	DB	1		   ; ONE VALUE ALLOWED
	DB	1		   ; ONLY ONE RANGE
	DB	FILE_SWITCH	   ; IDENTIFY IT AS n
	DD	1,65535 	   ; USER CAN SPECIFY /+1 THROUGH /+65535

				   ;---------------------------------------
				   ;  RETURN BUFFER FOR SWITCH INFORMATION
				   ;---------------------------------------
;		$SALUT	  (4,17,27,36)

SWITCH_BUFF	LABEL	  BYTE
SW_TYPE 	DB	  ?	   ; TYPE RETURNED
SW_ITEM_TAG	DB	  ?	   ; SPACE FOR ITEM TAG
SW_SYN		DW	  ?	   ; POINTER TO SWITCH LIST ENTRY
SW_VALUE	DD	  ?	   ; SPACE FOR VALUE

Exit_Msg		db	0	;flag set if no exit on ShDispMsg ;M006
Fswitch		db	0	;flag set if /F given ;M006
Lswitch		db	0	;flag set if /L given ;M006


;  $SALUT (4,4,9,41)

   Break <INIT - INITalization routines>

;******************* START OF SPECIFICATIONS ***********************************
;
; INIT - INITalization routines
;
;******************* END OF SPECIFICATIONS *************************************

   Procedure Init,NEAR

   PUSH CS
   POP	DS

   ASSUME DS:SHARE

   MOV	BX,InitSpace

   SUB	BX,3
   MOV	SI,OFFSET MFT
   MOV	WORD PTR [SI+1],BX		; length of first item
   ADD	SI,BX				; link to end of structure
   MOV	BYTE PTR [SI],-1		; signal end
   INC	SI				; point to next free byte

   MOV	CX,initlocks			; count for loop
   MOV	AX,0

;  $do					;				       ;AC000;
$$DO48:

       MOV  [SI].RLR_next,AX		; link in previous
       MOV  AX,SI			; this is now previous
       ADD  SI,SIZE RLR_Entry		; move to next object

;  $enddo loop				;				       ;AC000;
   LOOP $$DO48

   MOV	FreLock,AX			; point to beginning of free list

   MOV	DX,CS
   MOV	BX,ES
   SUB	DX,BX
   ADD	SI,15
   RCR	SI,1
   SHR	SI,1
   SHR	SI,1
   SHR	SI,1

   ADD	SI,DX
   PUSH SI				; # of paras for share on stack

   MOV	AX,(Get_Interrupt_Vector SHL 8) + 2Fh
   INT	21h
   MOV	WORD PTR CONT,BX
   MOV	WORD PTR CONT+2,ES
   MOV	AX,(Set_Interrupt_Vector SHL 8) + 2Fh
   MOV	DX,OFFSET INT2F
   INT	21h
					;---------------------------------------
					; Notify the DOS that we are around so that
					; the DOS can make expensive calls to us.
					;---------------------------------------
   MOV	AH,Get_In_Vars
   INT	21h

   ASSUME ES:DOSDATA

   MOV	fShare,-1			; tell DOS we are here		       ;AC011;
					;---------------------------------------
					; Cram in the new jump table
					;---------------------------------------
   CLI
   MOV	SI,OFFSET JTable
   MOV	DI,OFFSET JShare
   MOV	CX,JTableLen/2
   REP	MOVSW
					;---------------------------------------
					; Examine the size of the FCB cache.
					; If it is NOT the system default of 4,0
					; change it (via reallocation) to 16,8.
					; The old table is lost.
					;---------------------------------------
   ASSUME DS:NOTHING

   CMP	KeepCount,0

;  $if	z,and				; if the ",0"  part and 	       ;AC000;
   JNZ $$IF52

   LDS	SI,ES:[BX].SYSI_FCB		; point to the existing cache
   CMP	[SI].sfCount,4

;  $if	z				; if the "4,"  part then	       ;AC000;
   JNZ $$IF52

					;---------------------------------------
					; Whammo, we need to allocate 16 * size
					; of SF_entry + size of sfTable.
					; Compute this size in paragraphs
					;---------------------------------------
       MOV  AX,16
       MOV  CX,size sf_entry
       MUL  CX
       ADD  AX,(size sf) - 2
					;---------------------------------------
					; This size is in bytes...
					; Round up to paragraph size
					;---------------------------------------
       ADD  AX,0Fh
       RCR  AX,1
       SHR  AX,1
       SHR  AX,1
       SHR  AX,1
					;---------------------------------------
					; AX is the number of paragraphs to add.
					; Word on stack is current TNR size.
					; Make dos point to new table
					;---------------------------------------
       MOV  WORD PTR ES:[BX].SYSI_FCB,0
       MOV  WORD PTR ES:[BX].SYSI_FCB+2,SS
       POP  SI
       ADD  WORD PTR ES:[BX].SYSI_FCB+2,SI
					;---------------------------------------
					; Initialize table parts, next link
					;   and size
					;---------------------------------------
       MOV  DS,WORD PTR ES:[BX].SYSI_FCB+2
       MOV  WORD PTR DS:[sfLink],-1
       MOV  WORD PTR DS:[sfLink+2],-1
       MOV  DS:[sfcount],16
					;---------------------------------------
					; Set up succeeding LRU size
					;---------------------------------------
       MOV  KeepCount,8

       ADD  SI,AX
       PUSH SI

;  $endif				; endif - "4,0" 		       ;AC000;
$$IF52:

					;---------------------------------------
					; Clean out the FCB Cache
					;---------------------------------------
   LES	DI,ES:[BX].SYSI_FCB

   ASSUME ES:Nothing

   MOV	CX,ES:[DI].SFCount
   LEA	DI,[DI].SFTable

;  $do					;				       ;AC000;
$$DO54:

       MOV  ES:[DI].sf_ref_count,0
       MOV  WORD PTR ES:[DI].sf_position,0
       MOV  WORD PTR ES:[DI].sf_position+2,0
       ADD  DI,SIZE sf_entry

;  $enddo loop				;				       ;AC000;
   LOOP $$DO54

   STI

   ASSUME ES:NOTHING

   XOR	BX,BX
   MOV	CX,5				; StdIN,StdOUT,StdERR,StdAUX,StdPRN

;  $do					; Close STD handles before	       ;AC000;
$$DO56:
					; keep process
       MOV  AH,CLOSE
       INT  21H
       INC  BX

;  $enddo loop				;				       ;AC000;
   LOOP $$DO56

   POP	DX				; T+R size in DX
   MOV	AX,(Keep_Process SHL 8) + 0
   INT	21h
   MOV	AX,(EXIT SHL 8) + 1
   INT	21h				; We'er now resident, return to DOS

   EndProc Init

   Break <SHAREINIT - Share initialization entry point>

;******************* START OF SPECIFICATIONS ***********************************
;
; SHAREINIT - Share initialization entry point
;
;******************* END OF SPECIFICATIONS *************************************

   Procedure SHAREINIT,NEAR

   ASSUME CS:SHARE,DS:NOTHING,ES:NOTHING,SS:STACK

;  int 3
   nop
   nop


   PUSH DS				; save PSP segment for later stack     ;AC001;
					;     relocation

					;---------------------------------------
					; Load Messages
					;---------------------------------------
   call ShLoadMsg			;				       ;AN000;
					;---------------------------------------
					; At this point, the DOS version is OK.
					;  (checked by SYSLOADMSG)
					;  Now - Check the DOS data version
					;---------------------------------------
;  $if	c,or				; if not same as us			;AC009;
   JC $$LL58

   MOV	AH,Get_In_Vars
   INT	21h

   ASSUME ES:DOSDATA

   CMP	DataVersion,ShareDataVersion

   ASSUME ES:NOTHING

;  $if	ne				; if not same as us			;AC000;
   JE $$IF58
$$LL58:
       mov  ax,(Utility_Msg_CLASS shl 8) + Bad_DOS_Ver ;			;AN000;
       call ShDispMsg			;					;AN000;
;  $endif				; endif - not same as us		;AC000;
$$IF58:

					;---------------------------------------
					; Deallocate memory if possible
					;---------------------------------------
   mov	ax,ds:[pdb_environ]
   or	ax,ax

;  $if	nz				; if > 0 deallocate memory	       ;AC000;
   JZ $$IF60
       mov  es,ax
       mov  ah,dealloc
       int  21h
;  $endif				; endif - > 0 deallocate memory        ;AC000;
$$IF60:

					;---------------------------------------
					; Parse the command line
					;---------------------------------------
   call ShComndParse			;				       ;AN000;
					;---------------------------------------
					; Check to see if share already installed.
					;---------------------------------------
   mov	ah,multShare			;				       ;AC010;
   xor	al,al
   INT	2Fh				;				       ;AC010;
   CMP	AL,0FFh 			;				       ;AC010;
   JNZ $$IF62
					;Share is already loaded
       mov  ax,(UTILITY_MSG_CLASS shl 8) + Sh_Already_Loaded ;		       ;AC010;
       call ShDispMsg			;				       ;AC010;
$$IF62:
;
;M007; Begin changes
; Check to see if we are under the Dosshell. If so, we issue an error
;message and exit
;
	mov	ax,4b02h      		; see if switcher enabled
	xor	bx,bx
	push	es
	mov	es,bx
	mov 	di,bx	       		; es:di <- 0 on entry
	int	2fh				
	mov	ax,es
	pop	es
	or	ax,di	       		; es:di == 0 =>no switcher
	jz	Sh_noshell		;switcher not present, continue
	mov	ax,(UTILITY_MSG_CLASS shl 8) + SH_DOSSHELL ;switcher present
	call	ShDispMsg		;display error message & terminate

Sh_noshell:

					;---------------------------------------
					; All set to initialize the world.
					; Make sure that we have enough memory
					; for everything in our little 64K here.
					; First get avail count of paras.
					;---------------------------------------
   pop	es				; recover PSP segment		       ;AC002;
   push es				;				       ;AC002;
   MOV	BX,CS
   MOV	AX,ES:[PDB_Block_Len]
   SUB	AX,BX
					;---------------------------------------
					; AX has the number of paragraphs
					; available to us after the beginning
					; of CS.  Max this out at 64K.
					;---------------------------------------
   CMP	AX,1000h

;  $if	a				; if more than we can handle	       ;AC000;
   JNA $$IF66
       MOV  AX,1000h			;  force it
;  $endif				; endif - more than we can handle      ;AC000;
$$IF66:

					;---------------------------------------
					; Take AX paragraphs and convert them
					; into BX:CX bytes.
					;---------------------------------------
   XOR	BX,BX
   SHL	AX,1
   SHL	AX,1
   SHL	AX,1
   SHL	AX,1
   ADC	BX,0
   MOV	CX,AX
					;---------------------------------------
					; compute in DX:AX, the size
					; requested by the user
					;---------------------------------------
   MOV	AX,initlocks
   MOV	SI,size RLR_Entry
   MUL	SI
   ADD	AX,OFFSET MFT
   ADC	DX,0
   ADD	AX,InitSpace
   ADC	DX,0
					;---------------------------------------
					; Compare the 32 bit sizes DX:AX and BX:CX.
					; If BX:CX is smaller, then we
					; are out of memory.
					;---------------------------------------

   CMP	DX,BX				; try upper half first

;  $if	a,or				; if most significant is bigger or     ;AC000;
   JA $$LL68

;  $if	e,and				; if equal and			       ;AC000;
   JNE $$IF68

   CMP	AX,CX				;

;  $if	a				; if least significant is bigger       ;AC000;
   JNA $$IF68
$$LL68:

       mov  ax,(EXT_ERR_CLASS shl 8) + No_Mem_Error ; issue error message      ;AN000;

       call ShDispMsg			;				       ;AN000;

;  $endif				; endif - bigger		       ;AC000;
$$IF68:

;SR;
; Display the installed message here
;
   mov	ax,(UTILITY_MSG_CLASS shl 8) + SH_LOADED
   mov	Exit_Msg,1			;do not exit after message ;M006
   call	ShDispMsg			;will return for this call
   mov	Exit_Msg,0			;reset exit flag ;M006


					;--------------------------------------
					; Move stack to PSP area.  Otherwise we
					; will run into problems with growing
					; the stack into the lock records.
					;---------------------------------------
   POP	AX				; this is the entry value for DS (PSP) ;AC001;
   MOV	SS,AX				;				       ;AC001;
   MOV	SP,100h 			;				       ;AC001;

   ASSUME SS:NOTHING
					;---------------------------------------
					; Continue with rest of initialization
					;---------------------------------------
   JMP	INIT

   EndProc SHAREINIT

   Break <ShLoadMsg  -	Share Load Message>

;******************* START OF SPECIFICATIONS ***********************************
;
;  NAME:	ShLoadMsg  -  Share Load Message
;
;  FUNCTION:	Load the Share messages into the message buffer.
;
;  INPUT:	None
;
;  OUTPUT:	Messages loaded into the message buffer and Message
;		Sevices code initalized
;
;  REGISTERS USED:  DI AX CX DX
;  (NOT RESTORED)
;
;  LINKAGE:	Call near
;
;  NORMAL	CF = O
;  EXIT:
;
;  ERROR	CF = 1
;  EXIT:
;
;  CHANGE	04/15/87 - First release
;  LOG:
;
;******************* END OF SPECIFICATIONS *************************************

					;---------------------------------------
					; Message Equates
					;---------------------------------------

;			  $SALUT (4,27,34,41)

Bad_DOS_Ver		  equ	 1	; Incorrect DOS version 	       ;AN000;
Sh_Already_Loaded	  equ	 2	; SHARE already loaded message number  ;AN000;
No_Mem_Error		  equ	 8	; insufficient memory message number   ;AN000;

;SR;
; Share installed messafe

SH_LOADED		  equ	 9	; Share loaded message

SH_DOSSHELL		  equ	3	; Share cannot load under dosshell

;  $SALUT (4,4,9,41)

   Procedure ShLoadMsg,near		;				       ;AN000;
					;---------------------------------------
					; Load the Messages
					;---------------------------------------
EXTRN SYSLOADMSG:NEAR			;				       ;AN000;

   call SYSLOADMSG			;				       ;AN000;

;  $IF	C				; if we have a MAJOR problem	       ;AN000;
   JNC $$IF70
       mov  ah,dh			; save the class
       call ShDispMsg			;				       ;AN000;
					; For pre DOS 2.0, we may come back
       xor  ax,ax			;   here - so do it the old way
       push ss				;   just in case
       push ax				;

xxx    proc far 			;				       ;AN000;
       ret				;				       ;AN000;
xxx    endp				;				       ;AN000;

;  $ENDIF				; endif - we have a MAJOR problem      ;AN000;
$$IF70:


   ret					;				       ;AN000;

   EndProc ShLoadMsg			;

   Break <ShDispMsg  -	Share Display Message>

;******************* START OF SPECIFICATIONS ***********************************
;
;  NAME:	ShDispMsg  -  Share Display Message
;
;  FUNCTION:	Display the messages for share
;
;  INPUT:	AX = message number - AH - Class
;				      AL - Number
;
;  OUTPUT:	- Messages output to Output Device
;		- Exit to DOS
;
;  REGISTERS USED:  CX DX
;  (NOT RESTORED)
;
;  LINKAGE:	Call near
;
;  NORMAL	CF = O
;  EXIT:
;
;  ERROR	CF = 1
;  EXIT:	CX = 0 - INCORRECT DOS VERSION
;
;  CHANGE	04/15/87 - First release
;  LOG:
;
;******************* END OF SPECIFICATIONS *************************************

;			  $SALUT (4,27,34,41)

					; The following structure is a
					;   SYSMSG SUBLIST control block.
					;   It is initalized for the "already
					;   installed " message.  The parse
					;   routine will set it up to work
					;   for parseing.
SUBLIST 		  LABEL  WORD

			  db	 sub_size ; size of sublist
			  db	 0	; reserved
msg_offset		  dw	 offset SHARE_Name ; insert 'SHARE'

msg_segment		  LABEL  WORD

IF			  NOT	 INSTALLED

			  dw	 CODE

ELSE

			  dw	 SHARE

ENDIF

num_ins 		  db	 1	; only one insert
			  db	 Char_Field_ASCIIZ ; data type flag - ascii z string
max_ins 		  db	 SHARE_Name_Size ; maximum field size
min_ins 		  db	 SHARE_Name_Size ; minimum field size
			  db	 " "	; pad character

sub_size		  equ	 $ - SUBLIST

SHARE_Name		  LABEL  WORD

			  db	 "SHARE"

SHARE_Name_Size 	  equ	 $ - Share_Name

			  db	 0	; make it a Z string
;  $SALUT (4,4,9,41)

   Procedure ShDispMsg,near		;				       ;AN000;
					;---------------------------------------
					; Set up required parameters
					;--------------------------------------
   MOV	BX,STDERR			;display message on STD ERROR	       ;AN000;
   XOR	CX,CX				;no substitution required	       ;AN000;
   XOR	DX,DX				;set flags to 0 		       ;AN000;
   DEC	DH				;and class to utility		       ;AN000;
   cmp	ah,PARSE_ERR_CLASS		;
;  $if	be,and				;				       ;AC009;
   JNBE $$IF72
   mov	dh,ah				;
;  $if	e				; set up implied substitution	       ;AC009;
   JNE $$IF72

       ASSUME DS:nothing,ES:DOSDATA

       mov  num_ins,cl			; set number of inserts to 0	       ;AN009;
       mov  BYTE PTR max_ins,030h	; set maximum size of insert	       ;AN009;
       mov  BYTE PTR min_ins,1		; set minimum size of insert	       ;AN009;
       push ds				; set up segment		       ;AN009;
       pop  [msg_segment]		;				       ;AN009;
       mov  BYTE PTR ds:[si],0		; turn it into a ASCIIZ string	       ;AN009;
       cmp  si,msg_offset		; is there something there?	       ;AN009;
;      $if  a				; if it is...			       ;AN009;
       JNA $$IF73
	   inc	cx			;				       ;AN009;
;      $endif				;				       ;AN009;
$$IF73:
;  $endif				;
$$IF72:
   cmp	al,Sh_Already_Loaded		; SHARE already loaded message ?       ;AN000;
;  $if	e				; if it is...			       ;AN000;
   JNE $$IF76

   mov	num_ins,1			;Set inserts to 1 ;M006
   push	cs				;M006
   pop	msg_segment			;Set segment for name ;M006

       inc  cx				;
       mov  msg_offset,OFFSET SHARE_name ; ensure the pointer is right	       ;AN010;
       jmp  short not_loadmsg
;  $endif				;
$$IF76:
;M002;
; Parse error message has the same number. Make sure the message does not
;belong to the parse class.
;
   cmp	dh,PARSE_ERR_CLASS		;M002
   je	not_loadmsg			;M002

;SR;
; If this is the Share Installed message, ensure that pointer is at name
;
   cmp	al, SH_LOADED
   jne	not_loadmsg

   mov	num_ins,1			;Set inserts to 1 ;M006
   push	cs				;M006
   pop	msg_segment			;Set segment for name ;M006

   inc	cx
   mov	msg_offset,OFFSET SHARE_name
not_loadmsg:

   push cs				; ensure that SYSMSG has proper        ;AC009;
   pop	ds				;	   addressability	       ;AC009;
   lea	si,SUBLIST			; point to sublist		       ;AC009;

   push	ax				;SR; save for later check
   xor	ah,ah				;				       ;AN000;

					;--------------------------------------
					; Output the Message
					;---------------------------------------
EXTRN SYSDISPMSG:NEAR			;				       ;AN000;

   CALL SYSDISPMSG			;				       ;AN000;

   pop	ax				;restore ax

;  $IF	C				; if error occured		       ;AN000;
   JNC $$IF78

       CALL Get_DOS_Error		; a DOS extended error occured	       ;AN000;
       CALL SYSDISPMSG			; try to issue it		       ;AN000;

;  $ENDIF				; endif - error occured 	       ;AN000;
$$IF78:

;M006
; Check if flag for no exit is set. If so, do not exit.
;
   cmp	Exit_Msg,1			; should we exit? ;M006
   jnz	doexit				; yes
   ret
doexit:

   MOV	AX,(EXIT SHL 8) + 0FFH		; exit to DOS			       ;AN000;
   INT	21h				;				       ;AN000;

   ret					; may return if pre DOS 2.0	       ;AN000;

   EndProc ShDispMsg			;				       ;AN000;

   BREAK < Get_DOS_Error >

;******************* START OF SPECIFICATIONS ***********************************
;Routine name: Get_DOS_Error
;*******************************************************************************
;
;Description:  Call DOS to obtain DOS extended error #
;
;Called Procedures: None
;
;Input: 	    None
;
;Output:	    AX = error number
;		    DH = DOS extended error class
;
;Change History:    Created	   5/01/87	   FG
;
;******************* END OF SPECIFICATIONS *************************************
;******************+ START OF PSEUDOCODE +**************************************
;
;	START  Get_DOS_Error
;
;	call DOS for extended error (INT21 GetExtendedError + 00 <5900>)
;	set up registers for return
;	ret
;
;	END  Get_DOS_Error
;
;******************-  END  OF PSEUDOCODE -**************************************

   public Get_DOS_Error

   Get_DOS_Error PROC NEAR

   mov	ax,(GetExtendedError shl 8)	; DOS ext. error		       ;AN000;
   xor	bx,bx
   push es				;				       ;AN000;
   INT	21h				;    GetExtendedError + not_used <5900>;AN000;
   pop	es
   mov	bx,STDERR			; fix up bx			       ;AN000;
   xor	cx,cx				; fix up cx			       ;AN000;
   mov	dh,EXT_ERR_CLASS		; set class to dos error

   ret					;				       ;AN000;

   ENDPROC Get_DOS_Error

   Break <ShComndParse	-  Share Command line Parser>

;******************* START OF SPECIFICATIONS ***********************************
;
;  NAME:	ShComndParse  -  Share Command line Parser
;
;  FUNCTION:	Call the DOS PARSE Service Routines to process the command
;		line. Search for valid switches (/F:n and /L:m) and
;		update the values for file size and number of locks accordingly
;
;  INPUT:	Parameter string from command line in the PSP
;
;  OUTPUT:	INITspace and INITlocks are updated.
;
;  REGISTERS USED: ES DI AX BX CX DX
;  (NOT RESTORED)
;
;  LINKAGE:	Call
;
;  NORMAL	- If /F:n specified, then INITspace is updated.
;  EXIT:	- If /L:m specified, then INITlocks is updated.
;
;  ERROR	If user enters:
;  EXIT:	- any parameter or switch other than /F:n or /L:m
;		- an invalid value for "n" or "m"
;		then this routine will display the "Invalid Parameter"
;		error message and terminate.
;
;  EXTERNAL	- System parse service routines
;  REFERENCES:	- INT21 - GET PSP Function Call 062h
;
;  CHANGE	04/15/87 - First release
;  LOG:
;
;******************* END OF SPECIFICATIONS *************************************
;******************+ START OF PSEUDOCODE +**************************************
;
;	START
;
;	return
;
;	END
;
;******************-  END  OF PSEUDOCODE -*************************************

;			  $SALUT (4,27,34,41)

					;--------------------------------------
					; Parse Equates
					;--------------------------------------

EOL			  equ	 -1	; Indicator for End-Of-Line	       ;AN000;
NOERROR 		  equ	 0	; Return Indicator for No Errors       ;AN000;
FILE_SWITCH		  equ	 1	; this is a file switch 	       ;AN000;
LOCK_SWITCH		  equ	 2	; this is a lock switch 	       ;AN000;
Syntax_Error		  equ	 9	; maximum PARSE error # 	       ;AN000;

INV_SWITCH		equ	 3	;invalid switch ( for /NC)
TOOMANYPARMS		equ	1	;too many parameters ;M006

MSG_OPTIONS_FIRST	equ	300	; first line of options msg
MSG_OPTIONS_LAST        equ     303     ; last line of options msg

;  $SALUT (4,4,9,41)

   Procedure ShComndParse,near		;				       ;AN000;
					;--------------------------------------
					;  Get address of command line
					;--------------------------------------
EXTRN SYSPARSE:NEAR			;				       ;AN000;

   MOV	SI,0081H			; OFFSET OF COMMAND LINE IN PSP        ;AN000;
   MOV	AH,62H				; AH=GET PSP ADDRESS FUNCTION CALL     ;AN000;
   INT	21H				; PSP SEGMENT RETURNED IN BX	       ;AN000;
   MOV	DS,BX				; PUT PSP SEG IN DS		       ;AN000;
   MOV	CX,0				; NUMBER OF PARMS PROCESSED SO FAR     ;AN000;
   PUSH CS				;				       ;AN000;
   POP	ES				;				       ;AN000;

   ASSUME ES:SHARE			;				       ;AN000;

					;--------------------------------------
					;  Loop for each operand at DS:SI
					;--------------------------------------
;  $do					;				       ;AN000;
$$DO80:

       LEA  DI,PARMS			; ADDRESS OF PARSE CONTROLS	       ;AN000;
       MOV  DX,0			; RESERVED			       ;AN000;
       mov  msg_offset,si		; save the start scan point	       ;AC009;
       CALL SYSPARSE			; PARSE IT!			       ;AN000;
       CMP  AX,EOL			; ARE WE AT END OF COMMAND LINE ?      ;AN000;

;  $leave e				;				       ;AN000;
   JnE	@f				;M006
       jmp	$$EN80			;M006
@@:					;M006

       CMP  AX,NOERROR			; ANY ERRORS?			       ;AN000;

;      $if  ne,or			; if parse says error or	       ;AN000;
       JNE $$LL82

       MOV  AX,Syntax_Error		; Parse syntax error - just in case    ;AN000;
       MOV  BX,DX			; PLACE RESULT ADDRESS IN BX	       ;AN000;
       CMP  BX,OFFSET SWITCH_BUFF	;				       ;AN000;

;      $if  ne				; if no pointer 		       ;AN000;
       JE $$IF82
$$LL82:

	   call PARSE_ERROR		;   call error routine		       ;AN000;

;      $endif				; endif - error 		       ;AN000;
$$IF82:

       MOV  AX,WORD PTR SW_VALUE	; load the value		       ;AN000;
       MOV  BX,SW_SYN			; load pointer to synonym	       ;AN000;

       ; DS = PSP segment
       ; ES = CS = Parse structures segment

       ; See if the user put /? on the command line.
       ; If so, they're asking for the options help
       ; message.

       CMP	BX, OFFSET ?_SW		; /? ?
       JNE	PARSE_NOT_OPHELP	; skip if not
         CALL	DisplayOptions		; display the user's options

	mov	ax,(EXIT shl 8) + 0		;normal exit ; M000
	int	21h			; M000

PARSE_NOT_OPHELP:
					;--------------------------------------
					;  If user said  /F:n, then
					;--------------------------------------

       CMP  BX,OFFSET F_SW		; IF USER SPECIFIED /F		       ;AN000;

;      $if  e				;				       ;AN000;
       JNE $$IF84

	cmp	Fswitch,1		;switch already given? ;M006
	jz	err_too_many		;yes, flag error ;M006
	mov	Fswitch,1		;no, indicate /F found ;M006

	   CMP	INITspace,AX		; is default < requested ?	       ;AN000;

;	   $if	b			; if default is <		       ;AN000;
	   JNB $$IF85
	       MOV  INITspace,AX	; save the new value		       ;AN000;
;	   $endif			; endif   (else leave it alone)        ;AN000;
$$IF85:

;      $else				; else - CHECK FOR LOCKS	       ;AN000;
       JMP SHORT $$EN84

;
;M006; Start block changes
;
err_too_many:
	mov	ax,TOOMANYPARMS		;too many parameters
	mov	Exit_Msg,1		;do not exit after msg
	push	ds			;save regs
	push	si
	push	es
	push	di
	push	cx
	mov	dl,byte ptr ds:[si]		;save byte zeroed out by ShDispMsg
	push	dx
	call	Parse_Error 		;display error message
	pop	dx
	pop	cx
	pop	di
	pop	es
	pop	si
	pop	ds			;restore regs
	mov	byte ptr ds:[si],dl		;restore saved byte to continue
	mov	Exit_Msg,0		;reset exit flag
	jmp	short $$EN84		;continue

;
;M006; End block changes
;
$$IF84:

					;---------------------------------------
					;  If user said /L:m, then update INITlocks
					;---------------------------------------
	   CMP	BX,OFFSET L_SW		; IF USER SPECIFIED /L		       ;AN000;

;	   $if	e			; if it is				;AN000;
	   JNE $$IF88

	cmp	Lswitch,1		;switch already given? ;M006
	jz	err_too_many		;yes, flag error ;M006
	mov	Lswitch,1		;no, indicate /L found ;M006

	       CMP  INITlocks,AX	; is default < requested ?	       ;AN000;

;	       $if  b			; if default is <		       ;AN000;
	       JNB $$IF89
		   MOV	INITlocks,AX	;   save the value		       ;AN000;
;	       $endif			; endif      (else leave it alone)     ;AN000;
$$IF89:

;	   $else			; else - CHECK FOR TOGGLE	       ;AN010;
	   JMP SHORT $$EN88
$$IF88:

;SR;
; /NC switch will not be allowed for DOS 5.0. This was needed only for
;automatic installation of Share. This will not be done in DOS 5.0 and so
;the /NC switch is not needed. Just display an error message and terminate
;

					;---------------------------------------
					; If user said /NC, then ignore it
					;---------------------------------------
	       CMP  BX,OFFSET N_SW	; IF USER SPECIFIED /NC 	       ;AN010;
	       JE $$EN84	; ignore /NC and continue ;M005

		   MOV	AX,INV_SWITCH ; Parse syntax error		       ;AN000;
		   call PARSE_ERROR	;   call error routine		       ;AN000;

;;;$$IF92:
;;;

;	   $endif			; endif - CHECK FOR TOGGLE	       ;AN010;
$$EN88:

;      $endif				; endif - CHECK FOR LOCKS	       ;AN000;
$$EN84:

;  $enddo				; CHECK FOR NEXT PARM		       ;AN000;
   JMP $$DO80
$$EN80:
ShComndParseExit:

   ret					; NORMAL RETURN TO CALLER	       ;AN000;

					;---------------------------------------
					;  If any other parameter specified,
					;  display message and quit
					;---------------------------------------
PARSE_ERROR:				;				       ;AN000;

   cmp	al,Syntax_Error 		; error 1 to 9 ?		       ;AN000;

;  $if	a				; if parse error		       ;AN000;
   JNA $$IF97

       mov  al,Syntax_Error		; Parse syntax error

;  $endif				; endif errors			       ;AN000;
$$IF97:

   lea	bx,Parse_Ret_Code
   xlat cs:[bx]
   mov	ah,PARSE_ERR_CLASS		; set class to parse error	       ;AN000;

   CALL ShDispMsg			; display the parse error	       ;AN000;

   ret					; this should never be used

Parse_Ret_Code label byte

   db	0				; Ret Code 0 -
   db	1				; Ret Code 1 - Too many parameters
   db	9				; Ret Code 2 - Required parameter missing
   db	3				; Ret Code 3 - Invalid switch
   db	9				; Ret Code 4 - Invalid keyword
   db	9				; Ret Code 5 - (reserved)
   db	6				; Ret Code 6 - Parm val out of range
   db	9				; Ret Code 7 - Parameter val not allowed
   db	9				; Ret Code 8 - Parameter val not allowed
   db	9				; Ret Code 9 - Parm format not correct

   EndProc ShComndParse 		;				       ;AN000;

   Break <DisplayOptions	-  Display Options Help Message>

;******************* START OF SPECIFICATIONS ***********************************
;
;  NAME:	DisplayOptions  -  Display Options Help Message
;
;  FUNCTION:	Display each of the lines of the options help message
;               on standard output.
;
;  INPUT:	No value passed.
;
;  OUTPUT:	No value returned.
;
;  REGISTERS USED: AX BX CX DX SI
;  (NOT RESTORED)
;
;  LINKAGE:	Call
;
;  NORMAL	
;  EXIT:	
;
;  ERROR	
;  EXIT:	
;
;  EXTERNAL
;  REFERENCES:	- SYSDISPMSG
;
;  CHANGE	05/01/90 - First release
;  LOG:
;
;******************* END OF SPECIFICATIONS *************************************

   Procedure DisplayOptions, near

	push	ds			; save caller's DS
	mov	ax, cs			; set
	mov	ds, ax			;  ds = cs

	mov	ax, MSG_OPTIONS_FIRST	; message to display
	mov	bx, STDOUT		; output handle
	mov	cx, 0			; no substitutions
	mov	dh, UTILITY_MSG_CLASS	; message class
	mov	dl, NO_INPUT		; no input wanted
	mov	si, 0			; no substitution list
DispOptLoop:
	call	SYSDISPMSG		; send this message
	cmp	ax, MSG_OPTIONS_LAST	; last message?
	je	DispOptDone		;  we're done if so
	inc	ax			; else get next message
	jmp	short DispOptLoop	;  and go do it

DispOptDone:
	pop	ds
	ret

   EndProc DisplayOptions

   include msgdcl.inc

   SHARE ENDS

   STACK SEGMENT STACK
   DB	278  + 128 DUP (?)		; 278 == IBM's ROM requirements
   STACK ENDS

ENDIF

   END	shareinit
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\setver\setver.c ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

/***************************************************************************/
/*	SETVER.C 																					*/
/*																									*/
/*	This module contains the functions which read in the version table		*/
/*	from MSDOS.SYS and then updates the table with new entries and				*/
/*	writes it back to the file.															*/
/*																									*/
/*	The fake version table is located in the DOS system file and it's			*/
/*	location and length are specified with 2 words at offset 7 in the			*/
/* file. The first word is the table offset and second word is length.		*/
/*																									*/
/*	Table layout:																				*/
/*																									*/
/* ENTRY FILENAME LEN:	Length of filename in bytes	1 byte					*/
/* ENTRY FILENAME:	Variable length to 12 bytes	? bytes						*/
/* ENTRY VERSION MAJOR: Dos major version to return	1 byte					*/
/* ENTRY VERSION MINOR: Dos minor version to return	1 byte					*/
/*																									*/
/*																									*/
/*	USEAGE:																						*/
/*		List table:		SETVER [D:]															*/
/*		Add entry:		SETVER [D:] name.ext X.XX										*/
/*		Delete entry:	SETVER [D:] name.ext /DELETE									*/
/*		Delete entry quietly: SETVER [D:] name.ext /DELETE /QUIET				*/
/*		Display help	SETVER /?															*/
/*																									*/
/*	WHERE:																						*/
/*		D: is the drive containing MSDOS.SYS											*/
/*		name.ext is the executable file name											*/
/*		X.XX is the major and minor version numbers									*/
/*																									*/
/*	RETURN CODES:																				*/
/*		0	Successful completion															*/
/*		1	Invalid switch																		*/
/*		2	Invalid file name																	*/
/*		3	Insuffient memory																	*/
/*		4	Invalid version number format													*/
/*		5	Entry not found in the table													*/
/*		6	MSDOS.SYS file not found														*/
/*		7	Invalid MSDOS.SYS or IBMDOS.SYS file										*/
/*		8	Invalid drive specifier															*/
/*		9	Too many command line parameters												*/
/*		10	DOS version was not specified													*/
/*		11	Missing parameter																	*/
/*		12 Error reading MS-DOS system file												*/
/*		13 Version table is corrupt														*/
/*		14 Specifed file does not support a version table							*/
/*		15 Insuffient space in version table for new entry							*/
/*		16 Error writing MS-DOS system file												*/
/*																									*/
/*	johnhe	05-01-90																			*/
/***************************************************************************/

#include <stdio.h>
#include <stdlib.h>
#include <ctype.h>
#include <string.h>
#include <dos.h>
#include <io.h>
#include <fcntl.h>

#include <setver.h>
#include <message.h>


/***************************************************************************/

static char				*ReadBuffer;
static char 			*LieBuffer;		 		/* Buffer to read lietable into	*/
static char 			*EndBuf;			 		/* Ptr to end of the buffer 		*/
struct ExeHeader		ExeHdr;
struct DevHeader		DevHdr;
struct TableEntry		Entry;
static char				*szSetVer = "SETVERXX";

long						FileOffset;
/* static UINT				TableLen; */

/***************************************************************************/
/* Program entry point. Parses the command line and if it's valid executes */
/* the requested function and then returns the proper error code. Any		*/
/* error codes returned by ParseCommand are negative so they must be			*/
/* converted with a negate before being returned as valid error codes.		*/
/*																									*/
/*	int main( int argc, char *argv[] )													*/
/*																									*/
/*	ARGUMENTS:	argc - Count of command line arguments				 				*/
/*					argv - Array of ptrs to argument strings							*/
/*	RETURNS:		int	- Valid return code for batch processing					*/
/*																								 	*/
/***************************************************************************/

int main( int argc, char *argv[] )
{
	register		iFunc;
	char			szError[ 80 ];

	iFunc = ParseCmd( argc, argv, &Entry );
	if ( iFunc >= 0 )
		iFunc = DoFunction( iFunc );

	if ( iFunc != S_OK )
	{
		iFunc = -(iFunc);
		strcpy( szError, ErrorMsg[ 0 ] );
		strcat( szError, ErrorMsg[ iFunc ] );
		PutStr( szError );
		PutStr( szMiniHelp );
	}
	return( iFunc	);
}

/***************************************************************************/
/* Calls the appropriate function to do whatever was specified by the		*/
/* user. The lie table if first read in except in the case only the help	*/
/* function was requested. To be sure duplicate table entries are not		*/
/* created a call to DeleteEntry with the new program name will be done		*/
/* before the new entry is created.														*/
/*																									*/
/*	int DoFunction( int iFunc )															*/
/*																									*/
/*	ARGUMENTS:	iFunct - The function to be performed								*/
/*	RETURNS:		int	 - S_OK if no errors else an error code					*/
/*																									*/
/***************************************************************************/

int DoFunction( int iFunc )
{
	register		iStatus;

	if ( iFunc == DO_HELP )
	{
		DisplayMsg( Help );
		return( S_OK );
	}

	if ( iFunc == DO_ADD_FILE )
		DisplayMsg( Warn );							/* Read in the lie table and	*/
															/* then decide what to do		*/
	if ( (iStatus = ReadVersionTable()) == S_OK )
	{
		if ( iFunc == DO_LIST )
			iStatus = DisplayTable();
		else
		{
			if ( (iFunc == DO_DELETE || iFunc == DO_QUIET) &&
				  (iStatus = MatchFile( LieBuffer, Entry.szFileName )) < S_OK )
				return( iStatus );
															/* Always a delete before add	*/

			if ( (iStatus = DeleteEntry()) == S_OK &&	iFunc == DO_ADD_FILE )
				iStatus = AddEntry();

			if ( iStatus == S_OK &&
				  (iStatus = WriteVersionTable()) == S_OK &&
				   !(iFunc == DO_QUIET) )
			{
				PutStr( SuccessMsg );
				if ( SetVerCheck() == TRUE )		/* M001 */
					PutStr( SuccessMsg2 );
			}
		}
	}
					/* M001 Install check to see if currently in device chain */
	if ( iStatus == S_OK && iFunc != DO_QUIET && SetVerCheck() == FALSE )
		DisplayMsg( szNoLoadMsg );

	return( iStatus );
}

/***************************************************************************/
/* Displays the help text for "/?" option, or the warning text.				*/
/*																									*/
/*	void DisplayHelp( tbl )																	*/
/*																									*/
/*	ARGUMENTS:	char *tbl[]													 				*/
/*	RETURNS:		void																			*/
/*																									*/
/***************************************************************************/

void DisplayMsg( char *tbl[] )
{
	register i;

	for ( i = 0; tbl[i] != NULL; i++ )
		PutStr( tbl[ i ] );
}

/***************************************************************************/
/* Displays all entries in the version table which must have already been	*/
/* read into the work buffer. The name and version number are created as	*/
/* as ascii string in a tempory buffer and then printed as a single string */
/* in the format:																			 	*/
/*																								 	*/
/*	1234567890123456789																		*/
/*	FILENAME.EXT	X.XX																		*/
/*																								 	*/
/*	int DisplayTable( void )														 		*/
/*																								 	*/
/*	ARGUMENTS:	void																			*/
/*	RETURNS:		int	- S_CORRUPT_TABLE if table corrupt else S_OK				*/
/*																								 	*/
/***************************************************************************/

int DisplayTable( void )
{
	char		*BufPtr;
	char		*szTmp;
	char		*szVersion;
	char		szEntry[ 50 ];

	BufPtr = LieBuffer;
	szVersion = szEntry + VERSION_COLUMN;

	PutStr( "" );
	while ( *BufPtr != 0 && BufPtr < EndBuf )
	{
														 	/* Chk for table corruption	*/
		if ( !IsValidEntry( BufPtr ) )
			return( S_CORRUPT_TABLE );
												/* Copy file name and pad with spaces	*/
		strncpy( szEntry, BufPtr+1, (unsigned)((int)*BufPtr) );
		for ( szTmp = szEntry + *BufPtr; szTmp < szVersion; szTmp++ )
			*szTmp = ' ';

															/* Point to version number		*/
		BufPtr += *BufPtr;
		BufPtr++;

															/* Now create ascii version	*/
		itoa( (int)*(BufPtr++), szVersion, DECIMAL );
		strcat( szVersion, (int)*BufPtr < 10 ? ".0" : "." );
		itoa( (int)*(BufPtr++), strchr( szVersion, EOL ), DECIMAL );

		PutStr( szEntry );
	}
	if ( BufPtr == LieBuffer )
		PutStr( szTableEmpty );

	return( S_OK );
}


/***************************************************************************/
/* Deletes all matching entries in the version table by moving all of the	*/
/* entries following the matched entry down in the buffer to replace the	*/
/* entry being deleted. After the entries are moved down the residuals		*/
/* at the end of the table must be zeroed out. Before returning the entire */
/* end of the table buffer after the valid entries is zeroed out to remove */
/* any possible corruption.																*/
/*																									*/
/*	int DeleteEntry( void )																	*/
/*																									*/
/*	ARGUMENTS:	NONE																			*/
/*	RETURNS:		int	- S_CORRUPT_TABLE if errors found else S_OK				*/
/*																									*/
/***************************************************************************/

int DeleteEntry( void )
{
	char		*pchPtr;
	char		*pchTmp;
	int		iOffset;
	UINT		uEntryLen;
	UINT		uBlockLen;

	pchPtr = LieBuffer;

	while ( (iOffset = MatchFile( pchPtr, Entry.szFileName )) >= 0 )
	{
		pchPtr = LieBuffer + iOffset;						/* Move block down		*/
		uEntryLen = (UINT)((int)*pchPtr) + 3;
		uBlockLen = (UINT)(EndBuf - pchPtr) + uEntryLen;
		memmove( pchPtr, pchPtr + uEntryLen, uBlockLen );

		pchTmp = pchPtr + uBlockLen;			 			/* Clean end of blk		*/
		memset( pchTmp, 0, uEntryLen );
	}

	if ( iOffset == S_ENTRY_NOT_FOUND )		 			/* Clean end of table	*/
	{
		if ( (pchTmp = GetNextFree()) != NULL )
			memset( pchTmp, 0, DevHdr.TblLen - (unsigned)(pchTmp - LieBuffer) );
		return( S_OK );
	}
	else
		return( S_CORRUPT_TABLE );
}


/***************************************************************************/
/* Adds a new entry to the end of any existing entries in the version		*/
/* table. There must be suffient room in the table for the entry or the	 	*/
/* call will fail with a S_NO_ROOM error returned.									*/
/*																									*/
/*	int AddEntry( void )																		*/
/*																									*/
/*	ARGUMENTS:	NONE																			*/
/*	RETURNS:		int	- S_OK if room for entry else S_NO_ROOM		 			*/
/*																									*/
/***************************************************************************/

int AddEntry( void )
{
	register		iLen;
	char			*pchNext;

	iLen = (int)strlen( Entry.szFileName ) + 3;

	if ( (pchNext = GetNextFree()) != NULL && iLen <= EndBuf - pchNext )
	{
		*pchNext = (char)(iLen - 3);
		strcpy( pchNext + 1, Entry.szFileName );
		pchNext += (int)(*pchNext) + 1;
		*(pchNext++) = (char)Entry.MajorVer;
		*pchNext = (char)Entry.MinorVer;
		return( S_OK );
	}
	else
		return( S_NO_ROOM );
}


/***************************************************************************/
/* Returns the offset of a specified name in the version table. The start	*/
/* of the search is specified by the caller so that searches for duplicate */
/* entries can be made without redundency. NOTE: file name entries in the	*/
/* version table are not zero terminated strings so the comparision must	*/
/* be conditioned by length and the search strings length must be checked	*/
/* to avoid an error caused by a match of a shorter table entry name.		*/
/*																								 	*/
/*	int MatchFile( char *pchStart, char *szFile )							 		*/
/*																								 	*/
/*	ARGUMENTS:	pchStart - Ptr specifying search starting point	 				*/
/*					szFile	- Ptr to file name to match								*/		
/*	RETURNS:		int		- Offset of entry from start of version				*/
/*								  buffer or -1 if not match or							*/
/*								  S_CORRUPT_TABLE if error					 				*/
/*																								 	*/
/***************************************************************************/

int MatchFile( char *pchPtr, char *szFile )
{
	for ( ; pchPtr < EndBuf && *pchPtr != 0; pchPtr += *pchPtr + 3 )
	{
		if ( !IsValidEntry( pchPtr ) )						/* Corruption check	*/
			return( S_CORRUPT_TABLE );
		else if ( strncmp( szFile, pchPtr + 1, (UINT)((int)*pchPtr) ) == S_OK &&
					 *(szFile + *pchPtr) == EOL )
			return( pchPtr - LieBuffer );						/* Return ptr offset */
	}
	return( S_ENTRY_NOT_FOUND );								/* Return no match	*/
}

/***************************************************************************/
/* Checks a version table entry to see if it a valid entry. The definition */
/* of a valid entry is one which has a file length less than MAX_NAME_LEN	*/
/* and the entire entry lies within the version table.							*/
/*																								 	*/
/*	int IsValidEntry( char *pchPtr )														*/
/*																								 	*/
/*	ARGUMENTS:	pchPtr - Ptr to version tbl entry in table buffer				*/
/*	RETURNS:		int	 - TRUE if entry is valid else FALSE						*/
/*																								 	*/
/***************************************************************************/

int IsValidEntry( char *pchPtr )
{
	if ( (int)*pchPtr < MAX_NAME_LEN && (pchPtr + (int)*pchPtr + 3) < EndBuf )
		return( TRUE );
	else
		return( FALSE );
}


/***************************************************************************/
/* Returns a pointer to the next free entry in the version table. If there */
/* are no free entries left in the buffer a NULL ptr will be returned.		*/
/* Since DeleteEntry is always called before AddEntry there is no check	 	*/
/* for table corruption since it will have already been done by the			*/
/* DeleteEntry call.																		 	*/
/*																								 	*/
/*	char *GetNextFree( void )																*/
/*																								 	*/
/*	ARGUMENTS:	NONE																			*/
/*	RETURNS:		char*	- Ptr to next free entry or NULL if tbl full 			*/
/*																								 	*/
/* NOTE: This caller of this function must check to be sure any entry any	*/
/*			entry to be added at the ptr returned will fit in the remaining	*/
/*			buffer area because the remaining buffer size may be less than	 	*/
/*			MAX_ENTRY_SIZE.																	*/
/*																								 	*/
/***************************************************************************/

char *GetNextFree( void )
{
	char		*pchPtr;

	for ( pchPtr = LieBuffer; *pchPtr != 0 && pchPtr < EndBuf;
			pchPtr += *pchPtr + 3 )
		;

	return( pchPtr < EndBuf ? pchPtr : NULL );
}

/***************************************************************************/
/* Opens the DOS system file and reads in the table offset and length		*/
/* structure. Then allocates a buffer and reads in the table.					*/
/*																									*/
/*	int ReadVersionTable( void )															*/
/*																									*/
/*	ARGUMENTS:	NONE																			*/
/*	RETURNS:		int	- OK if successful else error code							*/
/*																									*/
/***************************************************************************/

int ReadVersionTable( void )
{
	register		iStatus;						/* Function's return value				*/
	int			iFile;						/* DOS file handle 						*/
	unsigned		uRead;						/* Number of bytes read from file	*/


			/* Open the file and read in the max buffer len from stack seg		*/

	if ( _dos_open( Entry.Path, O_RDONLY, &iFile ) != S_OK )
		return( S_FILE_NOT_FOUND );

	if ( _dos_read( iFile, &ExeHdr, sizeof( ExeHdr ), &uRead ) == S_OK &&
		  uRead == sizeof( ExeHdr ) )
	{
		FileOffset += (long)(ExeHdr.HeaderParas * 16);
		if ( SeekRead( iFile, &DevHdr, FileOffset, sizeof( DevHdr ) ) == S_OK )
		{
			if ( strncmp( DevHdr.Name, szSetVer, 8 ) == S_OK &&
				  DevHdr.VersMajor == 1 )
			{
				FileOffset += DevHdr.TblOffset;
				if ( (LieBuffer = malloc( DevHdr.TblLen )) == NULL )
					iStatus = S_MEMORY_ERROR;

				else if ( SeekRead( iFile, LieBuffer, FileOffset,
							 DevHdr.TblLen ) == S_OK )
				{
					iStatus = S_OK;
					EndBuf = LieBuffer + DevHdr.TblLen;
				}
			}
			else
				iStatus = S_INVALID_SIG;
		}
		else
			iStatus = S_FILE_READ_ERROR;
	 }
	 else
		iStatus = S_FILE_READ_ERROR;
	_dos_close( iFile );

	return( iStatus );
}

/***************************************************************************/
/* Opens the DOS system file and writes the versin table back to the file. */
/*																									*/
/*	int WriteVersionTable( void )															*/
/*																									*/
/*	ARGUMENTS:	NONE																			*/
/*	RETURNS:		int	- OK if successful else error code							*/
/*																									*/
/***************************************************************************/

int WriteVersionTable( void )
{
	register			iStatus;					/* Function's return value				*/
	int				iFile;					/* DOS file handle						*/
	unsigned			uWritten;				/* Number of bytes written to file	*/
	struct find_t	Info;

	if ( _dos_findfirst( Entry.Path, _A_HIDDEN|_A_SYSTEM, &Info ) == S_OK &&
		  _dos_setfileattr( Entry.Path, _A_NORMAL ) == S_OK &&
		  _dos_open( Entry.Path, O_RDWR, &iFile ) == S_OK )
	{
		if ( _dos_seek( iFile, FileOffset, SEEK_SET ) == FileOffset &&
			  _dos_write(iFile, LieBuffer, DevHdr.TblLen, &uWritten ) == S_OK &&
			  uWritten == DevHdr.TblLen )
			iStatus = S_OK;
		else
			iStatus = S_FILE_WRITE_ERROR;

		_dos_setftime( iFile, Info.wr_date, Info.wr_time );
		_dos_close( iFile );
		_dos_setfileattr( Entry.Path, (UINT)((int)(Info.attrib)) );
	}
	else
		iStatus = S_FILE_NOT_FOUND;

	return( iStatus );
}

/***************************************************************************/
/* Seeks to the specified offset in a file and reads in the specified		*/
/* number of bytes into the caller's buffer.											*/
/*																									*/
/*	unsigned SeekRead( int iFile, char *Buf, long lOffset, unsigned uBytes )*/
/*																									*/
/*	ARGUMENTS:	iFile		- Open DOS file handle										*/
/*					Buf		- Ptr to read buffer											*/
/*					lOffset	- Offset in file to start reading at					*/
/*					uBytes	- Number of bytes to read									*/
/*	RETURNS:		unsigned	- S_OK if successfull else S_FILE_READ_ERROR			*/
/*																									*/
/***************************************************************************/

int SeekRead( int iFile, void *Buf, long lOffset, unsigned uBytes )
{
	unsigned		uRead;

	if ( _dos_seek( iFile, lOffset, SEEK_SET ) == lOffset &&
		  _dos_read( iFile, Buf, uBytes, &uRead ) == S_OK &&
		  uRead == uBytes )
		return( S_OK );
	else
		return( S_FILE_READ_ERROR );
}
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\share\sharehdr.inc ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

        page    80,132
;******************* START OF SPECIFICATIONS ***********************************
;
; MODULE NAME:          SHARE.EXE     (a true EXE file)
;
; DESCRIPTIVE NAME:     SHARE resident service routines - part 1 - GSHARE.SAL
;                                                       - part 2 - GSHARE2.SAL
;                                                       - part 3 - SHARESR.SAL
;
; FUNCTION:             Provide file sharing services for DOS
;
; ENTRY POINT:          DOS Jump Table - installed by SHARE at initalization
;
;                             MFT_Enter          1
;                             MFTClose           2
;                             MFTClu             3
;                             MFTCloseP          4
;                             MFTCloN            5
;                             Set_Mult_Block     6
;                             Clr_Mult_Block     7
;                             Chk_Block          8
;                             MFT_Get            9
;
; INPUT:                See Prolog to individual entry points
;
; EXIT NORMAL:          CF = 0 and requested task performed.
;
; EXIT ERROR:           CF = 1 ans error code in AX
;
; INTERNAL REFERENCES:
;
;       ROUTINES:       Set_Block               BCS
;                       Clr_Block               CSL
;                       CLP                     CUC
;                       Load_Regs               CSI
;                       ASC                     GOM
;
;       DATA AREAS:
;
; EXTERNAL REFERENCES:  INT 21       INT 2F
;     together with:
;
;     fnm:near, rsc:near, rmn:near, cps:near, ofl:near, sle:near, interr:near
;
;       ROUTINES:
;
;       DATA AREAS:
;
; NOTES:                The second part of this utility is GSHARE2.ASM
;
; REVISION HISTORY:       Version 1.0  09/09/83 - first release              GL
;                                      09/13/83 - Installability             MZ
;                                      01/11/84 - FCB compatability changes  MZ
;                         PTM P000438  08/21/86 - SFT LCK FIELDS not 0 error DL
;                   Ax000 Ver 4.0      04/15/87 - changed:- Set_Block        FJG
;                                                         - Clr_Block        FJG
;                                                         - Chk_Block        FJG
;                                                         - CLP              FJG
;                                                  new:   - Set_Mult_Block   FJG
;                                                         - Clr_Mult_Block   FJG
;                                                         - Load_Regs        FJG
;                                                         - Clr_List         FJG
;                   Ax002  PTM P001658  10/15/87 - changed I/F to IBMDOS     FJG
;                   Ax003  PTM P002064  10/15/87 - ShSU SFT - IFS call error FJG
;                   Ax004  PTM P002121  10/29/87 - Clr_Mult_Block cx=-1 err  FJG
;                   Ax005  PTM P002322  11/06/87 - Call_IFS - 2F semaphore   FJG
;                   Ax006  DCR D000494  12/17/87 - DOS 4.00 function reductionFJG
;                   Ax007  PTM P003841  03/17/88 - access error for Turbo L  FJG
;                   Ax008  PTM P003880  03/17/88 - duped handle error        FJG
;                   Ax009  PTM P003910  03/17/88 - wrong parse error format  FJG
;                   Ax010  DCR D000526  04/27/88 - add /nc switch support    FJG
;                   Ax011  PTM P004546  05/03/88 - add /nc support to fShare FJG
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\share\sharesr.asm ===
Title	Sharesr

;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

;				   $SALUT (0,36,41,44)
				   include SHAREHDR.INC
;
;     Label: "The DOS SHARE Utility"
;
;******************* END OF SPECIFICATIONS *************************************

				   NAME Sharsr

				   .xlist
				   .xcref

				   include SYSMSG.INC

				   .cref
				   .list

				   MSG_UTILNAME <SHARE>

Share				   SEGMENT BYTE PUBLIC 'SHARE'

				   PUBLIC SYSDISPMSG, SYSLOADMSG, SYSPARSE

				   ASSUME CS:Share,DS:nothing,ES:nothing

					   ; include Message Code


				   .xlist
				   .xcref


				   MSG_SERVICES <MSGDATA>

				   MSG_SERVICES <LOADmsg>

				   MSG_SERVICES <DISPLAYmsg,CHARmsg>

				   MSG_SERVICES <SHARE.CLA,SHARE.CL1,SHARE.CL2>

				   .cref
				   .list


false				   =	0

DateSW				   equ	false
TimeSW				   equ	false
CmpxSW				   equ	false
KeySW				   equ	false
DrvSW				   equ	false
FileSW				   equ	false
QusSW				   equ	false
Val2SW				   equ	false
Val3SW				   equ	false


				   ; include parse.asm
				   .xlist
				   .xcref
				   include version.inc
				   include parse.asm
				   include msgdcl.inc
				   .cref
				   .list



Share				   ENDS
END

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\share\sharelnk.asm ===
PAGE    ,132                            ; 
;       SCCSID = @(#)SHARELNK.asm 1.0 87/05/11
TITLE   SHARELNK LINK FIX ROUTINES - Routines to resolve SHARE externals
NAME    SHARELNK

;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

.xlist
.xcref
INCLUDE DOSSYM.INC
INCLUDE DEVSYM.INC
.cref
.list

;CODE    SEGMENT BYTE PUBLIC 'CODE'
;code    ENDS

include dosseg.inc

;dosdata    segment
;public swap_area_len
;SWAP_AREA_LEN	DW  0
;dosdata    ends

doscode    SEGMENT BYTE PUBLIC 'code'
        ASSUME  CS:doscode

	PUBLIC	IRETT ;, Hash_Temp
IRETT   DW      0
;Hash_Temp   DW  0

procedure   LCRITDEVICE,FAR
        NOP
Endproc LCRITDEVICE,FAR

procedure   SETMEM,FAR
        NOP
endproc SETMEM,FAR

procedure   SKIPONE,FAR
        NOP
endproc SKIPONE,FAR

procedure   TWOESC,FAR
        NOP
endproc TWOESC,FAR

procedure   $STD_CON_STRING_INPUT_NO_ECHO,FAR
        NOP
endproc $STD_CON_STRING_INPUT_NO_ECHO,FAR

procedure   $STD_CON_INPUT_NO_ECHO,FAR
        NOP
endproc $STD_CON_INPUT_NO_ECHO,FAR

procedure   INT2F,FAR
        NOP
endproc   INT2F,FAR

procedure   $dup_pdb,FAR
        NOP
endproc   $dup_pdb,FAR

procedure   LEAVEDOS,FAR
        NOP
endproc   LEAVEDOS,FAR

procedure   GETCH,FAR
        NOP
endproc   GETCH,FAR

procedure   COPYONE,FAR
        NOP
endproc   COPYONE,FAR

procedure   $SETDPB,FAR
        NOP
endproc     $SETDPB,FAR

procedure   CALL_ENTRY,FAR
        NOP
endproc     CALL_ENTRY,FAR

procedure   ECRITDISK,FAR
        NOP
endproc     ECRITDISK,FAR

procedure   COPYLIN,FAR
        NOP
endproc     COPYLIN,FAR

procedure   LCRITDISK,FAR
        NOP
endproc     LCRITDISK,FAR

procedure   QUIT,FAR
        NOP
endproc     QUIT,FAR

procedure   BACKSP,FAR
        NOP
endproc     BACKSP,FAR

procedure   DIVOV,FAR
        NOP
endproc     DIVOV,FAR

procedure   STAY_RESIDENT,FAR
        NOP
endproc     STAY_RESIDENT,FAR

procedure   CTRLZ,FAR
        NOP
endproc     CTRLZ,FAR

procedure   EXITINS,FAR
        NOP
endproc     EXITINS,FAR

procedure   OKCALL,FAR
        NOP
endproc     OKCALL,FAR

procedure   SKIPSTR,FAR
        NOP
endproc     SKIPSTR,FAR

procedure   ABSDWRT,FAR
        NOP
endproc     ABSDWRT,FAR

procedure   BADCALL,FAR
        NOP
endproc     BADCALL,FAR

procedure   REEDIT,FAR
        NOP
endproc     REEDIT,FAR


;procedure   INULDEV,FAR
;	 NOP
;endproc     INULDEV,FAR

procedure   ABSDRD,FAR
        NOP
endproc     ABSDRD,FAR

;procedure   SNULDEV,FAR
;	 NOP
;endproc     SNULDEV,FAR

procedure   COPYSTR,FAR
        NOP
endproc     COPYSTR,FAR

procedure   ECRITDEVICE,FAR
        NOP
endproc     ECRITDEVICE,FAR

procedure   COMMAND,FAR
        NOP
endproc     COMMAND,FAR

procedure   ENTERINS,FAR
        NOP
endproc     ENTERINS,FAR

procedure   DEVIOCALL2,FAR
        NOP
endproc     DEVIOCALL2,FAR

;procedure   FASTOPENTABLE,FAR
;	 NOP
;endproc     FASTOPENTABLE,FAR

procedure   HEADER,FAR
        NOP
endproc     HEADER,FAR

;procedure   SYSINITTABLE,FAR
;	NOP
;endproc     SYSINITTABLE,FAR

;procedure   FETCHI_TAG,FAR
;	 NOP
;endproc     FETCHI_TAG,FAR

procedure   IFS_DOSCALL,FAR
        NOP
endproc     IFS_DOSCALL,FAR

procedure   KILNEW,FAR
        NOP
endproc     KILNEW,FAR

;procedure   PACKET_TEMP,FAR
;	 NOP
;endproc     PACKET_TEMP,FAR

;procedure   Swap_in_DOS_Len,FAR
;	 NOP
;endproc     Swap_in_DOS_Len,FAR

;procedure   swap_always_area,far
;	 NOP
;endproc     swap_always_area,FAR

;procedure   swap_always_area_len,FAR
;	 NOP
;endproc     swap_always_area_len,FAR

;procedure   swap_in_dos,FAR
;	 NOP
;endproc     swap_in_dos,FAR

ifdef	DBCS
procedure   IntCNE0,FAR
	NOP
endproc     IntCNE0,FAR

procedure   OUTT,FAR				; MSKK01 07/18/89
	NOP
endproc     OUTT,FAR

endif

procedure  FastRet,FAR
	NOP
endproc    FastRet,FAR

procedure  DOSINIT,NEAR
	NOP
endproc    DOSINIT,NEAR

doscode    ENDS
    END

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\subst\_msgret.asm ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

page	60,132
name	_msgret
title	C	to Message Retriever
;-------------------------------------------------------------------
;
;	MODULE: 	_msgret
;
;	PURPOSE:	Supplies an interface between C programs and
;			the DOS 3.3 message retriever
;
;	CALLING FORMAT:
;			sysloadmsg(&inregs,&outregs);
;			sysgetmsg(&inregs,&outregs);
;			sysdispmsg(&inregs,&outregs);
;
;	DATE:		5-21-87
;
;-------------------------------------------------------------------

	INCLUDE SYSMSG.INC		;PERMIT SYSTEM MESSAGE HANDLER DEFINITION;AN000;

	MSG_UTILNAME <SUBST>		;IDENTIFY THE COMPONENT 		;AN000;

	.8087									;AN000;
_TEXT	SEGMENT BYTE PUBLIC 'CODE'						;AN000;
_TEXT	ENDS									;AN000;
_DATA	SEGMENT WORD PUBLIC 'DATA'						;AN000;
_DATA	ENDS									;AN000;
CONST	SEGMENT WORD PUBLIC 'CONST'						;AN000;
CONST	ENDS									;AN000;
_BSS	SEGMENT WORD PUBLIC 'BSS'						;AN000;
_BSS	ENDS									;AN000;
DGROUP	GROUP	CONST, _BSS, _DATA						;AN000;
	ASSUME	CS: _TEXT, DS: _TEXT, SS: DGROUP, ES: DGROUP			;AN000;


	public	_sysloadmsg							;AN000;
	public	_sysgetmsg							;AN000;
	public	_sysdispmsg							;AN000;

;-------------------------------------------------------------------
;-------------------------------------------------------------------

_DATA	segment 								;AN000;
.XLIST										;AN000;
.XCREF										;AN000;
	MSG_SERVICES <MSGDATA>		;DATA AREA FOR THE MESSAGE HANDLER	;AN000;
.LIST										;AN000;
.CREF										;AN000;
_DATA	ends									;AN000;


_TEXT	segment 								;AN000;

;-------------------------------------------------------------------

; =  =	=  =  =  =  =  =  =  =	=  =

					;DEFAULT=CHECK DOS VERSION		;AN000;
					;DEFAULT=NEARmsg			;AN000;
					;DEFAULT=INPUTmsg			;AN000;
					;DEFAULT=NUMmsg 			;AN000;
					;DEFAULT=NO TIMEmsg			;AN000;
					;DEFAULT=NO DATEmsg			;AN000;
;	MSG_SERVICES <LOADmsg,GETmsg,DISPLAYmsg,CHARmsg,NUMmsg,TIMEmsg,DATEmsg,INPUTmsg,FARmsg>;AN000;
;	MSG_SERVICES <SUBST.CLA,SUBST.CL1,SUBST.CL2> ;MSG TEXT			;AN000;
.XLIST										;AN000;
.XCREF										;AN000;
;	MSG_SERVICES <MSGDATA>		;DATA AREA FOR THE MESSAGE HANDLER	;AN000;
	MSG_SERVICES <LOADmsg,GETmsg,DISPLAYmsg,CHARmsg,NUMmsg,TIMEmsg,DATEmsg,INPUTmsg,FARmsg>;AN000;
	MSG_SERVICES <SUBST.CLA,SUBST.CL1,SUBST.CL2> ;MSG TEXT			;AN000;
.LIST										;AN000;
.CREF										;AN000;
;-------------------------------------------------------------------

_sysloadmsg proc near								;AN000;

	push	bp			; save user's base pointer              ;AN000;
	mov	bp,sp			; set bp to current sp			;AN000;
	push	di			; save some registers			;AN000;
	push	si								;AN000;

;	copy C inregs into proper registers

	mov	di,[bp+4]		; fix di (arg 0)			;AN000;

;-------------------------------------------------------------------

	mov	ax,[di+0ah]		; load di				;AN000;
	push	ax			; the di value from inregs is now on stack;AN000;

	mov	ax,[di+00]		; get inregs.x.ax			;AN000;
	mov	bx,[di+02]		; get inregs.x.bx			;AN000;
	mov	cx,[di+04]		; get inregs.x.cx			;AN000;
	mov	dx,[di+06]		; get inregs.x.dx			;AN000;
	mov	si,[di+08]		; get inregs.x.si			;AN000;
	pop	di			; get inregs.x.di from stack		;AN000;

	push	bp			; save base pointer			;AN000;

;-------------------------------------------------------------------
	call	sysloadmsg		; call the message retriever		;AN000;
;-------------------------------------------------------------------

	pop	bp			; restore base pointer			;AN000;
	push	di			; the di value from call is now on stack;AN000;
	mov	di,[bp+6]		; fix di (arg 1)			;AN000;

	mov	[di+00],ax		; load outregs.x.ax			;AN000;
	mov	[di+02],bx		; load outregs.x.bx			;AN000;
	mov	[di+04],cx		; load outregs.x.cx			;AN000;
	mov	[di+06],dx		; load outregs.x.dx			;AN000;
	mov	[di+08],si		; load outregs.x.si			;AN000;

	lahf				; get flags into ax			;AN000;
	mov	al,ah			; move into low byte			;AN000;
	mov	[di+0ch],ax		; load outregs.x.cflag			;AN000;

	pop	ax			; get di from stack			;AN000;
	mov	[di+0ah],ax		; load outregs.x.di			;AN000;

;-------------------------------------------------------------------

	pop	si			; restore registers			;AN000;
	pop	di								;AN000;
	mov	sp,bp			; restore sp				;AN000;
	pop	bp			; restore user's bp                     ;AN000;
	ret									;AN000;

_sysloadmsg endp								;AN000;


_sysgetmsg proc near								;AN000;

	push	bp			; save user's base pointer              ;AN000;
	mov	bp,sp			; set bp to current sp			;AN000;
	push	di			; save some registers			;AN000;
	push	si								;AN000;
										;AN000;
;	copy C inregs into proper registers

	mov	di,[bp+4]		; fix di (arg 0)			;AN000;

;-------------------------------------------------------------------

	mov	ax,[di+0ah]		; load di				;AN000;
	push	ax			; the di value from inregs is now on stack;AN000;

	mov	ax,[di+00]		; get inregs.x.ax			;AN000;
	mov	bx,[di+02]		; get inregs.x.bx			;AN000;
	mov	cx,[di+04]		; get inregs.x.cx			;AN000;
	mov	dx,[di+06]		; get inregs.x.dx			;AN000;
	mov	si,[di+08]		; get inregs.x.si			;AN000;
	pop	di			; get inregs.x.di from stack		;AN000;

	push	bp			; save base pointer			;AN000;

;-------------------------------------------------------------------
	call	sysgetmsg		; call the message retriever		;AN000;
;-------------------------------------------------------------------

	pop	bp			; restore base pointer			;AN000;
	push	di			; the di value from call is now on stack;AN000;
	mov	di,[bp+6]		; fix di (arg 1)			;AN000;

	mov	[di+00],ax		; load outregs.x.ax			;AN000;
	mov	[di+02],bx		; load outregs.x.bx			;AN000;
	mov	[di+04],cx		; load outregs.x.cx			;AN000;
	mov	[di+06],dx		; load outregs.x.dx			;AN000;
	mov	[di+08],si		; load outregs.x.si			;AN000;

	lahf				; get flags into ax			;AN000;
	mov	al,ah			; move into low byte			;AN000;
	mov	[di+0ch],ax		; load outregs.x.cflag			;AN000;

	pop	ax			; get di from stack			;AN000;
	mov	[di+0ah],ax		; load outregs.x.di			;AN000;

;-------------------------------------------------------------------

	pop	si			; restore registers			;AN000;
	pop	di								;AN000;
	mov	sp,bp			; restore sp				;AN000;
	pop	bp			; restore user's bp                     ;AN000;
	ret									;AN000;

_sysgetmsg endp 								;AN000;

_sysdispmsg proc near								;AN000;

	push	bp			; save user's base pointer              ;AN000;
	mov	bp,sp			; set bp to current sp			;AN000;
	push	di			; save some registers			;AN000;
	push	si								;AN000;

;	copy C inregs into proper registers

	mov	di,[bp+4]		; fix di (arg 0)			;AN000;

;-------------------------------------------------------------------

	mov	ax,[di+0ah]		; load di				;AN000;
	push	ax			; the di value from inregs is now on stack;AN000;

	mov	ax,[di+00]		; get inregs.x.ax			;AN000;
	mov	bx,[di+02]		; get inregs.x.bx			;AN000;
	mov	cx,[di+04]		; get inregs.x.cx			;AN000;
	mov	dx,[di+06]		; get inregs.x.dx			;AN000;
	mov	si,[di+08]		; get inregs.x.si			;AN000;
	pop	di			; get inregs.x.di from stack		;AN000;

	push	bp			; save base pointer			;AN000;

;-------------------------------------------------------------------
	call	sysdispmsg		; call the message retriever		;AN000;
;-------------------------------------------------------------------

	pop	bp			; restore base pointer			;AN000;
	push	di			; the di value from call is now on stack;AN000;
	mov	di,[bp+6]		; fix di (arg 1)			;AN000;

	mov	[di+00],ax		; load outregs.x.ax			;AN000;
	mov	[di+02],bx		; load outregs.x.bx			;AN000;
	mov	[di+04],cx		; load outregs.x.cx			;AN000;
	mov	[di+06],dx		; load outregs.x.dx			;AN000;
	mov	[di+08],si		; load outregs.x.si			;AN000;

	lahf				; get flags into ax			;AN000;
	mov	al,ah			; move into low byte			;AN000;
	mov	[di+0ch],ax		; load outregs.x.cflag			;AN000;

	pop	ax			; get di from stack			;AN000;
	mov	[di+0ah],ax		; load outregs.x.di			;AN000;

;-------------------------------------------------------------------

	pop	si			; restore registers			;AN000;
	pop	di								;AN000;
	mov	sp,bp			; restore sp				;AN000;
	pop	bp			; restore user's bp                     ;AN000;
	ret									;AN000;

_sysdispmsg endp								;AN000;

include msgdcl.inc

_TEXT	ends				; end code segment			;AN000;
	end									;AN000;


=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\sort\sort.asm ===
TITLE   SORT FILTER FOR DOS
        PAGE    ,132                    ;

;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

;**********************************************************
;*
;*   UTILITY NAME:         sort
;*
;*   SOURCE FILE NAME:     sort.asm
;*
;*   UTILITY FUNCTION:
;*
;*         External non-resident utility, written in Assembler.
;*         Reads from the standard input device until end-of-file,
;*         sorts the data (up to 64k) and writes the results to
;*         the standard output device.  Input and output can be
;*         redirected.
;*
;*   INPUT (Command line)
;*
;*           SORT [/?] [/R] [/+ n]
;*
;*          /?   - Give command line options
;*          /R   - Sort in reverse order
;*          /+n  - Start sorting in column "n" , default 1
;*
;*   OUTPUT:
;*         Sorted data will be written to the standard output device.
;*
;*   ERROR CONDITIONS:
;*         Incorrect DOS version
;*         Insufficient disk space on target
;*         Insufficient memory to allocate SORT buffer
;*         Invalid parameter
;*
;*   INTERNAL REFERENCES:
;*         Main
;*
;*   SOURCE HISTORY:
;*         Modification History:
;*         3-18-83 MZ   (Microsoft)
;*                      Fix CR-LF at end of buffer
;*                      Fix small file sorting
;*                      Fix CR-LF line termination bug
;*                      Comment the Damn source
;*
;*         6-23-86 RW (IBM)
;*                      Add DOS 3.30 support for multiple languages
;*                      Inclusion of common DOS VERSION check equate
;*
;*  ;AN000; Code added in DOS 4.0
;*         5-19-87 RW (IBM) (DOS 4.0)
;*                      Addition of IBM Parser Service Routines
;*                      Addition of DOS Message Retriever Service Routines
;*                      Add code page file tag support
;*
;*  ;AN001; Code added in DOS 4.0
;*  ;AN002; DCR 191
;*         9-18-87 BL (IBM) (DOS 4.0)
;*                      Added Extended Attribute support for code page checking
;*                       and file type checking.
;*  ;AN003; PTM 1805
;*         10-19-87 BL (IBM) (DOS 4.0)
;*
;*  ;AN004; PTM
;*         01-29-87 BL (IBM) (DOS 4.0)
;*                      Ran tool INSPECT on .lst file for optimizations
;*
;*         05-01-90 c-PaulB  (DOS 5.0)
;*                      Added /? options help.
;*
;**********************************************************

;
;	Revision History
;	================
;
;	M000	SR	9/12/90	Increased stacksize to 256 bytes.
;
;	M001	SR	10/23/90	Bug #3597. Sort fixed to display
;				"Insufficient disk space" message.
;


        PAGE   ;
;-------------------------
;---    Macro definitions
;-------------------------
BREAK   MACRO   subtitle
        SUBTTL  subtitle
        PAGE
ENDM



sys     MACRO   name            ;system call macro
        MOV     AH,name
        INT     21h
        ENDM



save    MACRO   reglist         ;push those registers
IRP reg,<reglist>
        PUSH    reg
ENDM
ENDM



restore MACRO   reglist         ;pop those registers
IRP reg,<reglist>
        POP     reg
ENDM
ENDM


        PAGE   ;
;-------------------------------
;---    Equates
;-------------------------------
FALSE   EQU     0
TRUE    EQU     NOT FALSE
MAXREC  EQU     256                     ;MAXIMUM NUL RECORD SIZE

SPACE   EQU     0                       ;Offset zero in the allocated block
BUFFER  EQU     MAXREC                  ;Offset MAXREC in the allocated block

RETCODE_NOERROR equ 0                   ;AN000; DOS return code (errorlevel)
RETCODE_ERROR   equ 1                   ;AN000; DOS return code (errorlevel)

NO_CODEPAGE     equ 0                   ;AN000; Tag for files with no codepage

GetCPSW         equ  3303h              ;AN000; Int 021h function calls
GetExtAttr      equ  5702h              ;AN000;
SetExtAttr      equ  5704h              ;AN000;
;-----------------------
;--     Parser equates
;-----------------------
EOL     EQU    -1                       ;AN000; Indicator for End-Of-Line
NOERROR EQU     0                       ;AN000; Return Indicator for No Errors
 
FarSW   equ     0                       ;AN000;
DateSW  equ     0                       ;AN000;
TimeSW  equ     0                       ;AN000;
FileSW  equ     0                       ;AN000;
CAPSW   equ     0                       ;AN000;
CmpxSW  equ     0                       ;AN000;
NumSW   equ     1                       ;AN000;
KeySW   equ     0                       ;AN000;
SwSW    equ     1                       ;AN000;
Val1SW  equ     1                       ;AN000;
Val2SW  equ     0                       ;AN000;
Val3SW  equ     0                       ;AN000;
DrvSW   equ     0                       ;AN000;
QusSW   equ     0                       ;AN000;

;-----------------------
;--     Message equates
;-----------------------
STDIN   equ     0
STDOUT  equ     1
STDERR  equ     2

Msg_NoMem       equ     2               ;AC003;
Msg_NoDisk      equ     4               ;AC003;
Msg_sort        equ     5               ;AN003;
Msg_switch      equ     3               ;AN003;

MSG_OPTIONS_FIRST	equ	300	; first options help message #
MSG_OPTIONS_LAST        equ     307     ;  and last.

;------------------------------
; EXTENDED ATTRIBUTE Equates
;------------------------------
EAISBINARY            equ     02h        ;AN001;  ea_type
EASYSTEM              equ     8000h      ;AN001;  ea_flags

        PAGE   ;
;---------------------;
.xlist                ;
.xcref                ;
INCLUDE syscall.inc   ;
INCLUDE sysmsg.inc    ;                 ;AN000; Include message equates and MACROS
INCLUDE version.inc   ; 		; MSKK01 07/18/89
.cref                 ;
.list                 ;
;---------------------;

MSG_UTILNAME <SORT>                     ;AN000;

SUBTTL  Segments used in load order


CODE    SEGMENT
CODE    ENDS

CONST   SEGMENT PUBLIC BYTE
CONST   ENDS


;-----------------------
;---    Stack Segment
;-----------------------
CSTACK  SEGMENT STACK
        db 256 DUP (0)          ;increased to 256 bytes; M000

CSTACK  ENDS



;-------------------------------
;---    Group
;-------------------------------
DG      GROUP   CODE,CONST,CSTACK


;-------------------------------
;---    Code Segment
;-------------------------------
CODE    SEGMENT
ASSUME  CS:DG,DS:DG,ES:NOTHING,SS:CSTACK

;-------------------------------
;---    Data Definition
;-------------------------------
COLUMN          dw      0               ;COLUMN TO USE FOR KEY + 1
cp_reset        db      FALSE           ;AN000;Flag indicating if Code Page was reset on target file

;------------------------------------------DOS 3.30 - Russ Whitehead
CTRY_INFO       db      ?
CTRY_TABLE_OFF  dw      ?
CTRY_TABLE_SEG  dw      ?
;------------------------------------------

ifdef	DBCS			; MSKK02 07/18/89

NoCollate	db	0		; Character Translation Flag

endif

MSG_SERVICES <MSGDATA>                  ;AN000;
ASSUME   ds:nothing

;----------------------------------------
;- STRUCTURE TO QUERY EXTENDED ATTRIBUTES
;----------------------------------------
querylist      struc                    ;AN001; ;query general list
qea_num        dw      1                ;AN001;
qea_type       db      EAISBINARY       ;AN001;
qea_flags      dw      EASYSTEM         ;AN001;
qea_namelen    db      ?                ;AN001;
qea_name       db      "        "       ;AN001;
querylist      ends                     ;AN001;

cp_qlist       querylist <1,EAISBINARY,EASYSTEM,2,"CP">   ;AN001; ;query code page attr.

cp_list        label   word             ;AN001; ;code page attr. get/set list
               dw      1                ;AN001; ; # of list entries
               db      EAISBINARY       ;AN001; ; ea type
               dw      EASYSTEM         ;AN001; ; ea flags
               db      ?                ;AN001; ; ea return code
               db      2                ;AN001; ; ea name length
               dw      2                ;AN001; ; ea value length
               db      "CP"             ;AN001; ; ea name
cp             dw      ?                ;AN001; ; ea value (code page)
cp_len         equ     ($ - cp_list)    ;AN001;

;-------Save area for Code Pages
src_cp         dw      ?                ;AN000; Save area for current code page
tgt_cp         dw      ?                ;AN000; Save area for current code page
endlist label  word                     ;AN000;

        PAGE   ;
;******************************************************************************
;*                                               PARSER DATA STRUCTURES FOLLOW
;******************************************************************************

;------------------------------
;- STRUCTURE TO DEFINE ADDITIONAL COMMAND LINE DELIMITERS
;------------------------------
parms   label   word                    ;AN000;
        dw      parmsx                  ;AN000; POINTER TO PARMS STRUCTURE
        db      1                       ;AN000; DELIMITER LIST FOLLOWS
        db      1                       ;AN000; NUMBER OF ADDITIONAL DELIMITERS
        db      ";"                     ;AN000; ADDITIONAL DELIMITER

;------------------------------
;- STRUCTURE TO DEFINE SORT SYNTAX REQUIREMENTS
;------------------------------
parmsx  label   word                    ;AN000;
        db      0,0                     ;AN000; THERE ARE NO POSITIONAL PARAMETERS
        db      3                       ;AN000; THERE ARE 3 SWITCHES (/R /+n /?)
        dw      sw1                     ;AN000; POINTER TO FIRST SWITCH DEFINITION AREA
        dw      sw2                     ;AN000; POINTER TO SECOND SWITCH DEFINITION AREA
        dw      sw3                     ;       POINTER TO THIRD  SWITCH DEFINITION AREA
        dw      0                       ;AN000; THERE ARE NO KEYWORDS IN SORT SYNTAX

;------------------------------
;- STRUCTURE TO DEFINE THE /R SWITCH
;------------------------------
sw1     label   word                    ;AN000;
        dw      0                       ;AN000; NO MATCH FLAGS
        dw      0                       ;AN000; NO FUNCTION FLAGS
        dw      switchbuff              ;AN000; PLACE RESULT IN switchbufF
        dw      novals                  ;AN000; NO VALUE LIST
        db      1                       ;AN000; ONLY ONE SWITCH IN FOLLOWING LIST
rev_sw  db      "/R",0                  ;AN000; /R INDICATES REVERSE SORT

;------------------------------
;- STRUCTURE TO DEFINE THE /+n SWITCH
;------------------------------
NUMERIC equ     08000h                  ;AN000; Control flag for numeric value
NO_COLON equ    0020h                   ;AN000;

sw2     label   word                    ;AN000;
        dw      NUMERIC                 ;AN000; MATCH_FLAGS
        dw      NO_COLON                ;AN000; NO FUNCTION FLAGS
        dw      switchbuff              ;AN000; PLACE RESULT IN switchbufF
        dw      valuelist               ;AN000; NEED VALUE LIST FOR n
        db      1                       ;AN000; ONLY 1 SWITCH ON FOLLOWING LIST
col_sw  db      "/+",0                  ;AN000; /+n INDICATES BEGIN SORT IN COLUMN n

;------------------------------
;- STRUCTURE TO DEFINE THE /? SWITCH
;------------------------------
sw3     label   word
        dw      0			; Match Mask
        dw      0			; Function Mask
        dw      switchbuff		; ptr to Result Buffer
        dw      novals			; ptr to Value List
        db      1			; # of synonyms
opt_sw  db      "/?",0			; text of 1st synonym

;------------------------------
;- VALUE LIST DEFINITION FOR NO VALUES
;------------------------------
novals  label   word                    ;AN000;
        DB      0                       ;AN000;  VALUE LIST

;------------------------------
;- VALUE LIST DEFINITION FOR /+n
;------------------------------
valuelist       label   word            ;AN000;
                db      1               ;AN000; ONE VALUE ALLOWED
                db      1               ;AN000; ONLY ONE RANGE
                db      1               ;AN000; IDENTIFY THE RANGE
                dd      1,65535         ;AN000; USER CAN SPECIFY /+1 THROUGH /+65535

;------------------------------
;- RETURN BUFFER FOR SWITCH INFORMATION
;------------------------------
switchbuff      label   word            ;AN000;
sb_type         db      ?               ;AN000; TYPE RETURNED
sb_item_tag     db      ?               ;AN000; SPACE FOR ITEM TAG
sb_synonym      dw      ?               ;AN000; ES:sb_synonym points to synonym

sb_value        dw      ?               ;AN000; SPACE FOR VALUE
sb_value_extra  dw      ?               ;AN000; UNUSED SPACE FOR VALUE

        PAGE   ;
;**************************************************************
;*
;*   SUBROUTINE NAME:      main
;*
;*   SUBROUTINE FUNCTION:
;*         Mainline routine, performs SYSLODMSG, calls routines to
;*         parse command line, performs the SORT and writes the
;*         results.
;*
;*   INPUT:
;*         Command Line.
;*
;*         File to be sorted will be read from Standard Input
;*         device handle 0.
;*
;*   OUTPUT:
;*         Sorted data will be written to the Standard Output
;*         device handle 1.
;*
;*   NORMAL EXIT:
;*         SORT will normally exit when data was successfully read
;*         in up to 64k or EOF, sorted, and displayed to the
;*         standard output device.
;*
;*   ERROR EXIT:
;*         If any of the following errors, SORT will display the
;*         corresponding error message and terminate.
;*
;*           Insufficient disk space on target device
;*           Incorrect DOS version
;*           Insufficient memory to sort
;*
;************************************************************

;-------------------------
; Preload messages
;-------------------------
        MSG_SERVICES <SORT.ctl,SORT.cla,SORT.cl1,SORT.cl2>      ;AN000;
        MSG_SERVICES <DISPLAYmsg,LOADmsg,CHARmsg,NOCHECKSTDIN>          ;AN002; Make retriever services available

        mov     ax,cs                   ;AN003; ;load ES to the right area,
        mov     es,ax                   ;AN003;
        mov     ds,ax                   ;AN003;
SORT:
        call    sysloadmsg              ;AN000;  Preload messages, Check DOS Version.
                                        ;If Inc DOS Ver or error loading messages,
                                        ;SYSLOADMSG will show msg and terminate for us
        jnc     parser                  ;AN000; If no error, parse command line
        call    sysdispmsg              ;AN000; There was error.  Let SYSDISPMSG Display
        cmp     bx,-1                   ;AN000; Is this DOS 1.0 or 1.1 ?
        je      OLD_ABORT               ;AN000;  Yes, terminate old way

        mov     ah,Exit                 ;AN000; No, terminate new way
        mov     al,0                    ;AN000; Errorlevel 0 (Compatible!)
        int     021h                    ;AN000; Bye bye!

OLD_ABORT:                              ;AN000; CS should point to PSP
        mov     ah,Abort                ;AN000; Terminate program (AH=0)
        int     021h                    ;AN000; Bye bye!
;-----------------------------------
;- DOS version is ok. Parse cmd line
;-----------------------------------
PARSER:                                 ;AN000;   message and terminate
        call    parse                   ;AN000;  Parse command line

;-----------------------------------
; set up column for proper sort offset
;-----------------------------------

        ADD     COLUMN,2
        CMP     COLUMN,2
        JZ      GOT_COL
        DEC     COLUMN

;------------------------------------
; Get sorting area, no more than 64K
;------------------------------------
GOT_COL:
        MOV     BX,1000H                ;64K worth of paragraphs
GET_MEM:
        mov     bp,bx                   ;AN003; save buffer length
        sys     ALLOC                   ;allocate them from somewhere
        JNC     GOT_MEM                 ;if error, BX has amount free, try to get it
        OR      BX,BX                   ;but, is BX = 0?
        JNZ     GET_MEM                 ;nope, try to allocate it
        JMP     short SIZERR            ;AN004; ;complain

GOT_MEM:
;------------------------------------RussW:--Following add in DOS 3.3 for Nat Lang Support
        push    ax                      ;Save AX
        push    ds                      ;Save DS
        push    es                      ;Save ES
        mov     al,6                    ;Function for Get collating sequence
        mov     bx,-1                   ;Get active code page
        mov     dx,-1                   ;Get info from active country
        mov     cx,5                    ;Number of bytes to be returned
        push    cs                      ;Place code segment
        pop     es                      ;in ES
        mov     di,offset ctry_info     ;Return area for 5 byte requested information
        sys     GetExtCntry             ;Get extended country information
                                        ;Ok, now copy the table in DOS to our segment
        lds     si,dword ptr cs:ctry_table_off
        mov     di,seg dg
        mov     es,di
        mov     di,offset dg:table
        mov     cx,word ptr [si]
        add     si,2
        mov     ax,256
        sub     ax,cx
        add     di,ax
        cld
        rep     movsb
                                        ;Done copying, so restore regs and cont
        pop     es                      ;Restore ES
        pop     ds                      ;Restore DS
        pop     ax                      ;Restore AX
;------------------------------------RussW:--End 3.3 addition
        MOV     DS,AX                   ;Point DS to buffer
        MOV     ES,AX                   ;and point ES to buffer
        MOV     CL,4                    ;2^4 bytes per paragraph
        MOV     BX,BP                   ;AN003; restore buffer length
        SHL     BX,CL                   ;Find out how many bytes we have
        MOV     BP,BX                   ;AN003; save buffer length in bytes

;---------------------------
; Clear out temporary record area
;---------------------------
        MOV     CX,MAXREC/2             ;Size of temporary buffer (words)
        MOV     AX,'  '                 ;Character to fill with
        XOR     DI,DI                   ;AN004; ;Beginning of temp buffer
        REP     STOSW                   ;Blam.
;-----------------------------------
; Make sure source and target code pages are the same
;-----------------------------------
        call    match_codepages         ;AN000;  Make sure codepages are the same
;---------------------------
; read in file from standard input
;---------------------------
        MOV     DX,BUFFER + 2           ;DX = place to begin reading
        MOV     CX,BP                   ;AN003; ;CX is the max number to read
        SUB     CX,MAXREC + 2           ;remember offset of temp buffer
SORTL:
        XOR     BX,BX                   ;Standard input
        sys     READ                    ;Read it in
        ADD     DX,AX                   ;Bump pointer by count read
        SUB     CX,AX                   ;subtract from remaining the count read
        JZ      SIZERR                  ;if buffer is full then error
        OR      AX,AX                   ;no chars read -> end of file
        JNZ     SORTL                   ;there were chars read. go read again
        JMP     SHORT SIZOK             ;trim last ^Z terminated record
SIZERR:
        mov     ax,msg_NoMem            ;AN000;  not enough memory error
        mov     dh,-1                   ;AN003;  class: utility error
        call    error_exit              ;AN000;  and write it out

;---------------------------
; Look for a ^Z. Terminate buffer at 1st ^Z.
;---------------------------
SIZOK:
        MOV     BX,DX                   ;save end pointer
        MOV     CX,DX                   ;get pointer to end of text
        SUB     CX,BUFFER+2             ;dif in pointers is count
        MOV     AL,1AH                  ;char is ^Z
        MOV     DI,BUFFER+2             ;point to beginning of text
        REPNZ   SCASB                   ;find one
        JNZ     NoBack                  ;nope, try to find CRLF
        DEC     BX                      ;pretend that we didn't see ^Z
NoBack:
        SUB     BX,CX                   ;sub from endpointer the number left
        SUB     BX,2                    ;Hope for a CR LF at end
        CMP     WORD PTR [BX],0A0Dh     ;Was there one there?
        JZ      GOTEND                  ;yep, here is the end
        ADD     BX,2                    ;nope, bump back to SCASB spot
        CMP     BYTE PTR [BX],AL        ;Was there ^Z there?
        JZ      GOTEND                  ;yep, chop it
        INC     BX                      ;Nope, skip last char
GOTEND:
        MOV     BP,BX                   ;BP = filesize-2(CRLF)+temp buffer+2
        MOV     WORD PTR DS:[BP],0      ;0 at end of the file

;---------------------------
;  We now turn the entire buffer into a linked list of chains by
;  replacing CRLFs with the length of the following line (with 2 for CRLF)
;---------------------------
        MOV     BX,BUFFER               ;pointer to line head (length)
        MOV     DI,BUFFER+2             ;pointer to line text
REPLACE_LOOP:
        MOV     AL,13                   ;char to look for is CR
        MOV     CX,BP                   ;count = end pointer
        SUB     CX,DI                   ;chop off start point to get length
        INC     CX                      ;add 1???
REPLACE_SCAN:
        REPNZ   SCASB                   ;look for CR
        JNZ     REPLACE_SKIP            ;count exhausted
        CMP     BYTE PTR [DI],10        ;LF there?
        JNZ     REPLACE_SCAN            ;nope, continue scanning
REPLACE_SKIP:
        MOV     AX,DI                   ;AX to point after CR
        DEC     AX                      ;AX to point to CR
        save    <AX>                    ;save pointer
        SUB     AX,BX                   ;AX is length of line found
        MOV     [BX],AX                 ;stuff it in previous link
        restore <BX>                    ;get pointer to next
        INC     DI                      ;skip LF???
        JCXZ    END_REPLACE_LOOP        ;no more to scan -> go sort
        JMP     REPLACE_LOOP            ;look for next

END_REPLACE_LOOP:
        MOV     WORD PTR [BX],0         ;terminate file with nul
        LEA     BP,[BX+2]               ;remember the null line at end
        MOV     DI,BUFFER               ;DI is start of unsorted section

;---------------------------
; begin sort. Outer loop steps over all unsorted lines
;---------------------------
OUTER_SORT_LOOP:
        MOV     BX,DI                   ;BX is start of unsorted section
        MOV     SI,BX                   ;SI is scanning place link
        CMP     WORD PTR [BX],0         ;are we at the end of the buffer?
        JNZ     INNER_SORT_LOOP         ;No, do inner process
        JMP     END_OUTER_SORT_LOOP     ;yes, go dump out

;---------------------------
; BX points to best guy found so far. We scan through the sorted section
; to find an appropriate insertion point
;---------------------------
INNER_SORT_LOOP:
        ADD     SI,[SI]                 ;link to next fellow
        MOV     AX,[SI]                 ;get length of comparison guy
        OR      AX,AX                   ;test for end of buffer
ifdef DBCS
	jnz	@f
        jmp     END_INNER_SORT_LOOP     ;if zero then figure out insertion
@@:
else
        JZ      END_INNER_SORT_LOOP     ;if zero then figure out insertion
endif
        save    <SI,DI>                 ;save SI,DI
        MOV     DI,BX                   ;DI = pointer to tester link
        SUB     AX,COLUMN               ;adjust length for column
        JA      AXOK                    ;more chars in tester than column?
        XOR     SI,SI                   ;AN004; ;point SI to blank area
        MOV     AX,MAXREC               ;make AX be max length
AXOK:
        MOV     DX,[DI]                 ;get length of best guy
        SUB     DX,COLUMN               ;adjust length for column
        JA      DXOK                    ;there are more chars after column
        XOR     DI,DI                   ;AN004; ;point air to a space
        MOV     DX,MAXREC               ;really big record
DXOK:
        MOV     CX,AX                   ;AX is shortest record
        CMP     AX,DX                   ;perhaps DX is shorter
        JB      SMALL                   ;nope, leace CX alone
        MOV     CX,DX                   ;DX is shorter, put length in CX
SMALL:
        ADD     DI,COLUMN               ;offset into record
        ADD     SI,COLUMN               ;offset into other record
        push    bx
        push    ax
        mov     bx,offset dg:table

ifdef	DBCS			; MSKK02 07/18/89

	mov	cs:NoCollate,0
tloop:  lodsb
	cmp	cs:NoCollate,0		; translate required?
	jnz	notxlate_1		; jump if not
        xlat    byte ptr cs:[bx]
notxlate_1:
        mov     ah,al
        mov     al,es:[di]
        inc     di
	cmp	cs:NoCollate,0		; translate required?
	jnz	notxlate_2		; jump if not
        xlat    byte ptr cs:[bx]
notxlate_2:
	cmp	cs:NoCollate,0
	jz	@f			; if this is single or lead byte
	mov	cs:NoCollate,0
	cmp	ah,al
	jmp	short skip_dcheck
@@:
        cmp     ah,al
	jnz	skip_dcheck
	pushf
	dec	si
	lodsb				; load string again
	call	TestDBCSLeadByte	; is char is lead byte?
	jnc	NotDbcsLB
	mov	cs:NoCollate,1		; indicate don't collate on 2nd dbcs chr
NotDbcsLB:
	popf
skip_dcheck:
        loopz   tloop
else


tloop:  lodsb
        xlat    byte ptr cs:[bx]
        mov     ah,al
        mov     al,es:[di]
        inc     di
        xlat    byte ptr cs:[bx]
        cmp     ah,al
        loopz   tloop

endif

        pop     ax
        pop     bx
        restore <DI,SI>                 ;get head pointers back
        JNZ     TESTED_NOT_EQUAL        ;didn't exhaust counter, conditions set
        CMP     AX,DX                   ;check string lengths
TESTED_NOT_EQUAL:

;---------------------------
; NOTE! jae is patched to a jbe if file is to be sorted in reverse!
;---------------------------
CODE_PATCH label byte
ifdef DBCS
	jnae	@f
        jmp     INNER_SORT_LOOP         ;if this one wasn't better then go again
@@:
else
        JAE     INNER_SORT_LOOP         ;if this one wasn't better then go again
endif
        MOV     BX,SI                   ;it was better, save header
        JMP     INNER_SORT_LOOP         ;and scan again

END_INNER_SORT_LOOP:
        MOV     SI,BX                   ;SI is now the best person
        CMP     SI,DI                   ;check best for current
        JZ      END_INSERT              ;best equals current, all done

;---------------------------
; SI points to best line found so far
; DI points to a place to insert this line
; DI is guaranteed to be < SI
; make room for line at destination
;---------------------------
        MOV     DX,[SI]                 ;get length of line
        save    <SI,DI>                 ;save positions of people
        STD                             ;go right to left
        MOV     CX,BP                   ;get end of file pointer
        SUB     CX,DI                   ;get length from destination to end
        MOV     SI,BP                   ;start from end
        DEC     SI                      ;SI points to end of file
        MOV     DI,SI                   ;destination is end of file
        ADD     DI,DX                   ;DI points to new end of file
        REP     MOVSB                   ;blam. Move every one up
        CLD                             ;back left to right
        restore <DI,SI>                 ;get old source and destination
;---------------------------
;  MOVE NEW LINE INTO PLACE
;---------------------------
        save    <DI>                    ;save destination
        ADD     SI,DX                   ;adjust for previous movement
        save    <SI>                    ;save this value
        MOV     CX,DX                   ;get number to move
        REP     MOVSB                   ;blam. move the new line in
        restore <SI,DI>                 ;get back destination and new source
;---------------------------
;  DELETE LINE FROM OLD PLACE
;---------------------------
        save    <DI>                    ;save destination
        MOV     CX,BP                   ;pointer to end
        ADD     CX,DX                   ;remember bump
        SUB     CX,SI                   ;get count of bytes to move
        INC     CX                      ;turn it into a word
        SHR     CX,1                    ;or a count of words
        MOV     DI,SI                   ;new destination of move
        ADD     SI,DX                   ;offset of block
        REP     MOVSW                   ;blam, squeeze out the space
        restore <DI>                    ;get back original destination
        MOV     WORD PTR DS:[BP-2],0    ;remake the end of file mark

END_INSERT:
        ADD     DI,[DI]                 ;link to next guy
        JMP     OUTER_SORT_LOOP         ;and continue
;------------------------------
;       PUT BACK IN THE CR-LF
;------------------------------
END_OUTER_SORT_LOOP:
        MOV     DI,BUFFER               ;start at beginning (where else)
        MOV     CX,[DI]                 ;count of butes

INSERT_LOOP:
        ADD     DI,CX                   ;point to next length
        MOV     CX,[DI]                 ;get length
        MOV     WORD PTR [DI],0A0DH     ;replace length with CRLF
        AND     CX,CX                   ;AN004; ;check for end of file
        JNZ     INSERT_LOOP             ;nope, try again

WRITE_FILE:
        MOV     DX,BUFFER+2             ;get starting point
        MOV     CX,BP                   ;pointer to end of buffer
        SUB     CX,DX                   ;dif in pointers is number of bytes
        MOV     BX,1                    ;to standard output
        sys     WRITE                   ;write 'em out
        JC      BADWRT                  ;some bizarre error -> flag it
        CMP     AX,CX                   ;did we write what was expected?
        JZ      WRTOK                   ;yes, say bye bye
BADWRT:

	mov     ax,msg_NoDisk           ;AN000; Strange write error
	mov     dh,-1                   ;AN003; class: extended error
	call    error_exit              ;AN000; Bye bye
        mov     al,RETCODE_ERROR        ;AN000; return an error code (errorlevel)
        sys     EXIT                    ;AN000;
WRTOK:
        MOV     AL,RETCODE_NOERROR      ;AN000; Errorlevel 0 (No error!)
        sys     EXIT                    ;bye!

        PAGE   ;
;************************************************************
;*
;*   SUBROUTINE NAME:      display_msg
;*
;*   SUBROUTINE FUNCTION:
;*         Display the requested message to the specified handle
;*
;*   INPUT:
;*      1)   AX = Number of the message to be displayed.
;*      2)   BX = Handle to be written to.
;*
;*   OUTPUT:
;*      The message corresponding to the requested msg number will
;*      be written to the requested handle. There is no substitution
;*      text in SORT.
;*
;*   NORMAL EXIT:
;*      Message will be successfully written to requested handle.
;*
;*   ERROR EXIT:
;*      None.  Note that theoretically an error can be returned from
;*      SYSDISPMSG, but there is nothing that the application can do.
;*
;*   INTERNAL REFERENCES:
;*      System Display Message service routines
;*
;*   EXTERNAL REFERENCES:
;*      None
;*
;************************************************************

display_msg     proc    near            ;AN000;
        push    ds                      ;AN000; save DS value
        push    cs                      ;AN000; get DS addressability
        pop     ds                      ;AN000;

        xor     cx,cx                   ;AN004; ;AN000;  No substitution text
;;      mov     dh,-1                   ;AN003;  Message class
                                        ; 1=DOS Extended error
                                        ; 2=DOS Parse error
                                        ; -1=Utility message
        mov     dl,0                    ;AN000;  DOS INT 21H function number to use for input
                                        ; 00H=No input, 01H=Keyboard input,
                                        ; 07H=Direct Console Input Without Echo,
                                        ; 08H=Console Input Without Echo, 0AH=Buffered Keyboard Input
        call    SYSDISPMSG              ;AN000;

        pop     ds                      ;AN000;  restore DS
        ret                             ;AN000;
display_msg     ENDP                    ;AN000;

        PAGE   ;
;************************************************************
;*
;*   SUBROUTINE NAME:      parse
;*
;*   SUBROUTINE FUNCTION:
;*         Call the DOS PARSE Service Routines to process the command
;*         line. Search for valid switches (/R and /+n) and take
;*         appropriate action for each. Display error message and
;*         terminate on error.
;*
;*   INPUT:        None
;*
;*   OUTPUT:       None
;*
;*   NORMAL EXIT:
;*
;*         If /R specified, then patches code to perform reverse sort
;*         by changing JAE to a JB.
;*
;*         If /+n entered, COLUMN will be set to "n," otherwise COLUMN
;*         will be set to 1.
;*
;*   ERROR EXIT:
;*
;*         If user enters any parameter or switch other than /R or /+n,
;*         or an invalid value for "n", then this routine will display
;*         the "Invalid Parameter" error message and terminate with
;*         errorlevel 1.
;*
;*   EXTERNAL REFERENCES:
;*         System parse service routines
;*         INT21 - GET PSP Function Call 062h
;*
;************************************************************

parse   proc    near                    ;AN000;

        sys     GetCurrentPSP           ;AN000; Get PSP address, returned in BX

        mov     ds,bx                   ;AN000; Put PSP Seg in DS
        mov     si,081h                 ;AN000; Offset of command line in PSP
        cmp     byte ptr ds:080h,0      ;AN000; Check length of command line
        je      end_parse               ;AN000; If 0 len, the we are done parsing
        xor     cx,cx                   ;AN000; Number of parms processed so far = 0
        push    cs                      ;AN000; Put CS
        pop     es                      ;AN000;  in ES
;---------------------------------
;- Loop for each operand at DS:SI (Initially PSP + 081h)
;---------------------------------
parse_loop:                             ;AN000;
        mov     di,offset parms         ;AN000; Address of parse control block
        xor     dx,dx                   ;AN000; Reserved
        call    sysparse                ;AN000; Parse parm at DS:SI
        cmp     ax,EOL                  ;AN000; Q: Are we at end of command line?
        je      end_parse               ;AN000;  YES: We are done
        and     ax,ax                   ;AN004; ;AN000;  NO:  Q: Any errors?
        jne     parse_error             ;AN000;   YES: Display msg and terminate
        mov     bx,sb_synonym           ;AN000; Get offset of switch entered

;----------------------------------
;- If user said /?, then give options
;----------------------------------
        cmp     bx,offset opt_sw        ; If user specified /?
	je	display_options_exit	;  give message & exit

;----------------------------------
;- If user said /R, then patch code
;----------------------------------
        cmp     bx,offset rev_sw        ;AN000; If user specified /R
        jne     check_column            ;AN000;
ifdef DBCS
        mov     cs:code_patch,073h      ;AN000; Sleazy patch to make reverse order sort
else
        mov     cs:code_patch,072h      ;AN000; Sleazy patch to make reverse order sort
endif
        jmp     parse_loop              ;AN000; Look for another parm

;---------------------------------------------
;- If user said /+n, then save COLUMN index
;---------------------------------------------
check_column:                           ;AN000;
        cmp     bx,offset col_sw        ;AN000; Q: Did user specified /+n ?
        jne     switch_error            ;AC003;  No:  Unrecognized parm
        mov     ax,sb_value             ;AN000;  Yes: Get number entered by user
        mov     column,ax               ;AN000;       Set up column to begin sort
        jmp     parse_loop              ;AN000;       Check for next parm

;------------------------------------------------------------
;- If any other parameter specified, display message and die
;------------------------------------------------------------
switch_error:                           ;AN003;
        mov     ax,Msg_switch           ;AN003;
parse_error:                            ;AN000;
        mov     dh,2                    ;AN003;  class: parse error
        call    error_exit              ;AN000;  Terminate utility

end_parse:                              ;AN000;
        ret                             ;AN000;
parse   endp                            ;AN000;

;************************************************************
;*
;*   SUBROUTINE NAME:   display_options_exit
;*
;*   SUBROUTINE FUNCTION:
;*      Displays the options help message lines, and then
;*	exits so the user can try again.
;*
;*   INPUT:     No value passed.
;*
;*   INTERNAL REFERENCES:
;*      display_msg
;*
;*   EXTERNAL REFERENCES:
;*      INT 021h - Terminate Function 04Ch
;*
;************************************************************

display_options_exit	proc near

	; display all the lines of the options help message

	mov	ax, MSG_OPTIONS_FIRST	; first message to display
	mov	bx, STDOUT		; output handle
	mov	dh, UTILITY_MSG_CLASS	; message class
doe_loop:
	call	display_msg		; display this message
	cmp	ax, MSG_OPTIONS_LAST	; last message?
	je	doe_done		;  done if so
	inc	ax			; else bump message number
	jmp	short doe_loop		;  and go do it
doe_done:

	; exit to the system so the user can try again

        mov     al,RETCODE_NOERROR	; show no error
        sys     EXIT			;  and exit

display_options_exit	endp


        PAGE   ;
;************************************************************
;*
;*   SUBROUTINE NAME:   error_exit
;*
;*   SUBROUTINE FUNCTION:
;*      Displays the message number in AX to the standard
;*      error device, then terminates with errorlevel 1.
;*
;*   INPUT:     AX = Message number
;*
;*   INTERNAL REFERENCES:
;*      display_msg
;*
;*   EXTERNAL REFERENCES:
;*      INT 021h - Terminate Function 043h
;*
;************************************************************
error_exit      proc    near            ;AN000;
        call    prt_sort                ;AN003;
        mov     bx,STDERR               ;AN000; output to standard error
        xor     cx,cx                   ;AN004; ;AN003;
        call    display_msg             ;AN000; and write it out
        mov     al,RETCODE_ERROR        ;AN000; return an error code (errorlevel)
        sys     EXIT                    ;AN000;
        ret                             ;AN000;  Meaningless RET
error_exit      endp                    ;AN000;


;************************************************************
;*
;*   SUBROUTINE NAME:   match_codepages
;*
;*   SUBROUTINE FUNCTION:
;*      Check to see if Code Page Support is active. If so,
;*      check code page of input and output handles. If the
;*      source file has a code page file tag AND the target
;*      handles code page is different, then set code  page
;*      of the target to that of the source.
;*
;*   INTERNAL REFERENCES:
;*      none
;*
;*   EXTERNAL REFERENCES:
;*      INT 021h - Check CPSW
;*      INT 021h - Get Extended Attributes by Handle
;*      INT 021h - Set Extended Attributes by Handle
;*
;************************************************************

match_codepages proc    near            ;AN000;

;-----------------------------------
; Check status of Code page support
;-----------------------------------
        push    es                      ;AN000; Save ES register
        push    ds                      ;AN001; Save DS register
;
        mov     ax,cs                   ;AN001; ES, DS -> CS
        mov     ds,ax                   ;AN001;
        mov     es,ax                   ;AN001;
;
        mov     ax,GetCPSW              ;AN000; Get CPSW state, assume support is OFF
        int     021h                    ;AN000; DL: 0=NotSupported,1=Supported
        cmp     dl,1                    ;AN000; CPSW supported if DL=1
        jne     done_cpsw               ;AN000; If not supported, we're done
;-----------------------------------
; Get Code Pages of STDIN and STDOUT
;-----------------------------------
        mov     ax,GetExtAttr           ;AN000; Get Extended Attributes by Handle
        mov     bx,STDOUT               ;AN000; For Standard output device
        mov     di,offset cp_list       ;AC001; Return buffer address
        mov     si,offset cp_qlist      ;AN001; Query the code page attribute
        mov     cx,cp_len               ;AN001; return buffer length
        int     021h                    ;AN000;
        jc      done_cpsw               ;AN000; Error condition, let system handle
        mov     ax,cp                   ;AN000; Save target code page
        mov     tgt_cp,ax               ;AN000;  for later reference

        mov     ax,GetExtAttr           ;AN000; Get Extended Attributes by Handle
        xor     bx,bx                   ;AN004; ;AN000; bx = STDIN (0)  For Standard input device
        mov     di,offset cp_list       ;AC001; Return buffer address
        mov     si,offset cp_qlist      ;AN001; Query the code page attribute
        mov     cx,cp_len               ;AN001; return buffer length
        int     021h                    ;AN000;
        jc      done_cpsw               ;AN000; Error condition, let system handle
        mov     ax,cp                   ;AN000; Save source code page
        mov     src_cp,ax               ;AN000;  for later reference

        mov     ax,src_cp               ;AN000; Get source codepage
        and     ax,ax                   ;AN004; ;AN000; IF no codepage
        je      done_cpsw               ;AN000;   THEN no action required;
        cmp     ax,tgt_cp               ;AN000; IF src_cp = tgt_cp
        je      done_cpsw               ;AN000;   THEN no action required;
;-------------------------------------
;- Set CP of target to that of source
;-------------------------------------
        mov     cp_reset,TRUE           ;AN000; Set flag indicating change
        mov     ax,SetExtAttr           ;AN000; Set Extended Attributes by Handle
        mov     bx,STDOUT               ;AN000; For Standard output device
        mov     di,offset cp_list       ;AC001; Input buffer address
        int     021h                    ;AN000;

done_cpsw:                              ;AN000;
        pop     ds                      ;AN001; Restore DS register
        pop     es                      ;AN000; Restore ES register
        ret                             ;AN000;
match_codepages endp                    ;AN000;

        PAGE   ;
;************************************************************
;*
;*   SUBROUTINE NAME:   prt_sort
;*
;*   SUBROUTINE FUNCTION:
;*      Preceeds all error messages with "SORT: ".
;*
;*   INTERNAL REFERENCES:
;*         none
;*   EXTERNAL REFERENCES:
;*         none
;************************************************************
prt_sort proc near                      ;AN003;
        push    ax                      ;AN003;
        push    dx                      ;AN003;
;
        mov     dh,-1                   ;AN003;
        mov     ax,Msg_sort             ;AN003;
        xor     cx,cx                   ;AN004; ;AN003;
        mov     bx,STDERR               ;AN003;
        call    display_msg             ;AN003;
;
        pop     dx                      ;AN003;
        pop     ax                      ;AN003;
;
        ret                             ;AN003;
prt_sort endp                           ;AN003;

ifdef	DBCS			; MSKK02 07/18/89

;******************************************************************************
;*
;*	TestDBCSLeadByte - Check DBCS lead byte or not
;*
;*	Entry:	AL <= Character to be Check
;*
;*	Exit:	CF = 1, if a character is lead byte of DBCS
;*
;******************************************************************************

DBCS_VECTOR_SAVE	dd	-1		; DBCS vector pointer  from DOS

TestDBCSLeadByte	proc	near

	push	ds
	push	si
	cmp	cs:word ptr DBCS_VECTOR_SAVE,-1	; already get vector?
	jnz	@F				; jump if so
	push	ax
	mov	ax,6300h			; Call DOS to get DBCS vector
	int	21h
	mov	cs:word ptr [DBCS_VECTOR_SAVE],si
	mov	cs:word ptr [DBCS_VECTOR_SAVE+2],ds
	pop	ax
@@:
	lds	si,cs:dword ptr [DBCS_VECTOR_SAVE]
DBCS_LOOP:
	cmp	ds:word ptr [si],0		; end of lead byte table?
	jz	DBCS_CHK_END			; jump if so
	cmp	al,ds:[si]			; jump if out of range
	jb	DBCS_LOW			
	cmp	al,ds:[si+1]
	ja	DBCS_LOW			; jump if out of range
	stc					; mark lead byte!
	jmp	short DBCS_EXIT
DBCS_LOW:
	add	si,2				; check next entry
	jmp	short DBCS_LOOP
DBCS_CHK_END:
	clc					; not a lead byte
DBCS_EXIT:
	pop	si
	pop	ds
	ret
TestDBCSLeadByte	endp

endif

        PAGE   ;
;--------------------
.xlist
.xcref
INCLUDE parse.asm
include msgdcl.inc
.cref
.list
;--------------------

CODE    ENDS







CONST   SEGMENT PUBLIC BYTE

        extrn   table:byte

CONST   ENDS




SUBTTL  Initialized Data
;-------------------------------
;---    Stack Segment
;-------------------------------
CSTACK   SEGMENT STACK
         db      (362 - 80h) + 96 dup (0) ;(362 - 80h) == New - Old IBM
                                          ;interrupt reqs. == size of growth
CSTACK   ENDS

        END     SORT



=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\subst\substpar.h ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

/*  */
/*----------------------------------------------------------------------+
|                                                                       |
| This file contains the structures and defines that are needed to use  |
| the parser from a C program.                                          |
|   ** customized for the JOIN and SUBST utilities **                   |
|                                                                       |
| Date:         5-21-87                                                 |
|                                                                       |
+----------------------------------------------------------------------*/


struct p_parms
        {
        struct p_parmsx *p_parmsx_address;      /* address of p_parmsx */
        unsigned char   p_num_extra;            /* number of extra stuff */
        };

struct p_parmsx
        {
        unsigned char   p_minp;                 /* Minimum positional number */
        unsigned char   p_maxp;                 /* Maximum positional number  */
        struct p_control_blk *p_control1;       /* Address of the 1st CONTROL block */
        struct p_control_blk *p_control2;       /* Address of the 2nd CONTROL block */
        unsigned char   p_maxs;                 /* Maximun switches */
        struct p_switch_blk *p_switch;          /* Address of the 1st SWITCH block */
        struct p_switch_blk *p_switch2;         /* Address of the 2nd SWITCH block */
        unsigned char   p_maxk;                 /* Maximum keywords */
        };


struct p_control_blk
        {
        unsigned int    p_match_flag;           /* Controls type matched */
        unsigned int    p_function_flag;        /* Function should be taken */
        unsigned int    p_result_buf;           /* Result buffer address */
        unsigned int    p_value_list;           /* Value list address */
        unsigned char   p_nid;                  /* # of keyword/SW synonyms */
        };

struct p_switch_blk
        {
        unsigned int   sp_match_flag;           /* Controls type matched */
        unsigned int   sp_function_flag;        /* Function should be taken */
        unsigned int   sp_result_buf;           /* Result buffer address */
        unsigned int   sp_value_list;           /* Value list address */
        unsigned char  sp_nid;                  /* # of keyword/SW synonyms */
        unsigned char  sp_keyorsw[3];           /* keyword or sw */
        };

/* Match_Flags */

#define P_Num_Val               0x8000          /* Numeric Value */
#define P_SNum_Val              0x4000          /* Signed numeric value */
#define P_Simple_S              0x2000          /* Simple string */
#define P_Date_S                0x1000          /* Date string */
#define P_Time_S                0x0800          /* Time string */
#define P_Cmpx_S                0x0400          /* Complex string */
#define P_File_Spc              0x0200          /* File Spec */
#define P_Drv_Only              0x0100          /* Drive Only */
#define P_Qu_String             0x0080          /* Quoted string */
#define P_Ig_Colon              0x0010          /* Ignore colon at end in match */
#define P_Repeat                0x0002          /* Repeat allowed */
#define P_Optional              0x0001          /* Optional */

/*----------------------------------------------------------------------+
|                                                                       |
|  Function flags                                                       |
|                                                                       |
+----------------------------------------------------------------------*/

#define P_CAP_File              0x0001          /* CAP result by file table */
#define P_CAP_Char              0x0002          /* CAP result by character table */
#define P_Rm_Colon              0x0010          /* Remove ":" at the end */



#define P_nval_None             0               /* no value list ID */
#define P_nval_Range            1               /* range list ID */
#define P_nval_Value            2               /* value list ID */
#define P_nval_String           3               /* string list ID */
#define P_Len_Range             9               /* Length of a range choice(two DD plus one DB) */
#define P_Len_Value             5               /* Length of a value choice(one DD plus one DB) */
#define P_Len_String            3               /* Length of a string choice(one DW plus one DB) */


/*----------------------------------------------------------------------+
|                                                                       |
|  Result block structure                                               |
|                                                                       |
+----------------------------------------------------------------------*/

struct p_result_blk
        {
        unsigned char   P_Type;                 /* Type returned */
        unsigned char   P_Item_Tag;             /* Matched item tag */
        char *          P_SYNONYM_Ptr;          /* pointer to Synonym list returned */
        unsigned int    p_result_buff[2];       /* result value */
        };

struct p_fresult_blk
        {
        unsigned char  fP_Type;                 /* Type returned */
        unsigned char  fP_Item_Tag;             /* Matched item tag */
        unsigned int   fP_SYNONYM_Ptr;          /* pointer to Synonym list returned */
        char far *     fp_result_buff;          /* result value */
        };

/*----------------------------------------------------------------------+
|                                                                       |
|  type                                                                 |
|                                                                       |
+----------------------------------------------------------------------*/

#define P_EOL                   0               /* End of line */
#define P_Number                1               /* Number */
#define P_List_Idx              2               /* List Index */
#define P_String                3               /* String */
#define P_Complex               4               /* Complex */
#define P_File_Spec             5               /* File Spec */
#define P_Drive                 6               /* Drive */
#define P_Date_F                7               /* Date */
#define P_Time_F                8               /* Time */
#define P_Quoted_String         9               /* Quoted String */

#define P_No_Tag                0x0FF           /* No ITEM_TAG found */

/*----------------------------------------------------------------------+
|                                                                       |
|  Value list structure                                                 |
|                                                                       |
+----------------------------------------------------------------------*/

struct noval
        {
        unsigned char   null;
        };

/*----------------------------------------------------------------------+
|                                                                       |
|  following return code will be returned in the AX register.           |
|                                                                       |
+----------------------------------------------------------------------*/

#define P_No_Error              0               /* No error */
#define P_Too_Many              1               /* Too many operands */
#define P_Op_Missing            2               /* Required operand missing */
#define P_Not_In_SW             3               /* Not in switch list provided */
#define P_Not_In_Key            4               /* Not in keyword list provided */
#define P_Out_Of_Range          6               /* Out of range specified */
#define P_Not_In_Val            7               /* Not in value list provided */
#define P_Not_In_Str            8               /* Not in string list provided */
#define P_Syntax                9               /* Syntax error */
#define P_RC_EOL                0x0ffff         /* End of command line */
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\subst\subst.h ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

/*
 *  This file contains the constants, globals, structure definitions,
 *  extern declarations, and macro definitions for the subst utility.
 *
 *  Date:       10-10-90
 */


/*
 *  Parse Equates
 */
#define ASCII_DRIVE       'A'-1             /* Convert to Ascii drive */
#define CAPRESULT         0x0001            /* Cap result by file table */
#define DRVONLY_OPT       0x0101            /* Drive only & optional */
#define ERRORLEVEL1       1                 /* Parsing error occurred */
#define FALSE             0
#define FILESPEC_OPT      0x0201            /* File spec & optional */
#define MAX               256               /* Define a limit */
#define MAXPOSITION       2                 /* Max positionals in cmdline */
#define MINPOSITION       0                 /* Min positionals in cmdline */
#define NOCAPPING         0x0000            /* Do not cap result */
#define NULL              0
#define SWITCH_OPT        0x0000            /* Optional switch */

/*
 *  Message Equates
 */
#define MSG_PARMNUM       1                 /* Incorrect Num of Parms */
#define MSG_BADPATH       2                 /* Path not Found */
#define MSG_NOMEM         3                 /* Insufficient memory */
#define MSG_BADPARM       4                 /* Invalid parameter */
#define MSG_NETERR        5                 /* Cannot %1 a network drv */
#define MSG_INVSWTCH      6                 /* Invalid switch */
#define MSG_INUSE	  7

#define MSG_OPTIONS_FIRST 300
#define MSG_OPTIONS_LAST  306

#define BLNK              ' '               /* For sublist.pad_char */
#define CARRY             0x0001            /* To test carry from msg hndlr */
#define D_SWITCH          "/D"              /* For switch id */
#define O_SWITCH          "/?"              /* /? for options help */
#define EXT_ERR_CLASS     0x01              /* DOS Extended error class */
#define MAXWIDTH          0                 /* 0 ensures no padding */
#define MINWIDTH          1                 /* At least 1 char in parm */
#define NO_INPUT          0x00              /* No input characters */
#define PARSE_ERR_CLASS   0x02              /* Parse error class */
#define RESERVED          0                 /* Reserved byte field */
#define STDERR            0x0002            /* Standard error device handle */
#define STDOUT            0x0001            /* Std output device handle */
#define STR_INPUT         16                /* Byte def for sublist.flags */
#define SUB_ID0           0                 /* 0 for error substitution */
#define SUB_ID1           1                 /* Only 1 replaceable parameter */
#define SUBCNT0           0                 /* 0 substitutions in message */
#define SUBCNT1           1                 /* 1 substitution in message */
#define SUBLIST_LENGTH    11                /* Length of sublist structure */
#define UTILITY_CLASS     0x0ff             /* Utility message class */

/*
 *  Miscellaneous
 */
char cmdln_drive[64]   = {0};               /* Save user's input in   */
char cmdln_flspec[64]  = {0};               /* order to pass to error */
char cmdln_invalid[64] = {0};
char cmdln_switch[64]  = {0};               /* message, if needed     */
char p_drive[3];                            /* Recvs drive ltr from parser */
char p_filespec[64];                        /* Recvs filespec from parser */
char replparm_SUBST[]  = "SUBST";           /* Cannot SUBST a network drv */
                                           
unsigned char source[MAX] = {0};            /* buffer for string manipulation */

int index;                                  /* Used in creating cmdline string */

struct sysVarsType SysVars;

/*
 *  Parse Structures
 */
struct p_parms  p_p;                        /* # of extras & pts to descrptn */
struct p_parmsx p_px;                       /* min/max parms & pts to controls */
struct p_control_blk p_con1;                /* 1st posit parm in cmd str */
struct p_control_blk p_con2;                /* 2nd posit parm in cmd str */
struct p_switch_blk p_swi1;                 /* /D switch in cmd str */
struct p_switch_blk p_swi2;                 /* /D switch in cmd str */
struct p_result_blk rslt1;                  /* Result blk rtrnd from parser */
struct p_fresult_blk rslt2;                 /* Result blk rtrnd from parser */
struct p_result_blk rslt3;                  /* Result blk rtrnd from parser */
struct noval novals = {0};                  /* Value list not used */

union REGS inregs, outregs;                 /* Define register variables */


/*
 *  External Function Prototypes
 */
extern	int   access(char *, char *);
extern	void  exit(int);
extern	char  fGetCDS(int, struct CDSType *);
extern	int   fNet(int);
extern	int   fPathErr(char *);
extern	int   fPhysical(int);
extern	char  fPutCDS(int, struct CDSType *);
extern	int   fShared(int);
extern	long  GetDPB(int);
extern	int   getdrv(void);
extern	void  GetVars(struct sysVarsType *);
extern	int   open(char *, int);
extern	void  parse(union REGS*, union REGS*);
extern	void  printf(const char *, ...);
extern	void  PutVars(struct sysVarsType *);
extern	void  rootpath(char *, char *);
extern	char  *strbscan(char *, char *);                                                      /* SM extern'd */
extern	void  sysdispmsg(union REGS*, union REGS*);
extern	void  sysloadmsg(union REGS*, union REGS*);
              

/*
 *  Internal Function Prototypes
 */
extern  void  main(int, char **);
extern  int   ParseIt(void);
extern  char  *BackFix(char *);
extern  char  fDelete(char *);
extern  void  Insert(char *, char *);
extern  void  Display(void);
extern  void  load_msg(void);
extern  void  display_msg(int, char*);
extern  void  DisplayOptions(void);
extern  void  dispmsg_terminate(int, char*);
extern  void  Parser_Prep(char *);


=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\subst\subst.c ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

/*    */
/**************************************************************************/
/*                                                                        */
/*  UTILITY NAME:      Subst                                              */
/*                                                                        */
/*  SOURCE FILE NAME:  Subst.C						  */
/*                                                                        */
/*  STATUS:            Subst Utility, DOS Version 4.0                     */
/*                                                                        */
/*  FUNCTIONAL DESCRIPTION:  This utility allows the substitution of a    */
/*  physical drive for a pathname on another drive such that operations   */
/*  performed using the physical drive as an argument take place on the   */
/*  pathname.                                                             */
/*                                                                        */
/*  SYNTAX:            [d:][path]SUBST                     or             */
/*                     [d:][path]SUBST d: d:path           or             */
/*                     [d:][path]SUBST d: /D                              */
/*            where:                                                      */
/*                     [d:][path] to specify the drive and path that      */
/*                     contains the SUBST command file                    */
/*                                                                        */
/*                     d: specifies the drive letter that you want        */
/*                     to use to refer to another drive or path.          */
/*                                                                        */
/*                     d:path to specify the drive or path that you       */
/*                     want to refer to with a nickname.                  */
/*                                                                        */
/*                     /D to delete a substitution.  You must specify     */
/*                        the letter of the drive whose substitution      */
/*                        you want to delete.                             */
/*                                                                        */
/*  LINKS:                                                                */
/*    CDS.C       - Functions to get/set DOS CDS structures               */
/*    DPB.C       - Functions to get DOS DPB structures                   */
/*    ERRTST.C    - Drive and path validity testing functions             */
/*    SYSVAR.C    - Functions to get/set DOS System Variable structures   */
/*    COMSUBS.LIB - DOS DBCS function calls                               */
/*    MAPPER.LIB  - DOS function calls                                    */
/*    SLIBC3.LIB  - C library functions                                   */
/*    _MSGRET.ASM - Assembler interface for common DOS message services   */
/*    _PARSE.ASM  - Assembler interface for common DOS parser             */
/*                                                                        */
/*  ERROR HANDLING:    Error message displayed and utility is terminated. */
/*                                                                        */
/**************************************************************************/

#include "cds.h"
#include "dos.h"
#include "fcntl.h"
#include "jointype.h"
#include "malloc.h"
#include "string.h"
#include "substpar.h"                       /* Parser structures */
#include "sysvar.h"
#include "subst.h"


/**************************************************************************/
/*                                                                        */
/*  SUBROUTINE NAME:   main (program entry point)                         */
/*                                                                        */
/*  SUBROUTINE FUNCTION:  Preload message file                            */
/*                        Get the command line parameters                 */
/*                        Parse the command line by calling SYSPARSE      */
/*                        Verify the correctness of the parameters        */
/*                        Check for deletion switch                       */
/*                        Check source path and destination not same      */
/*                        Determine if source or destination is network   */
/*                        Determine if currently spliced                  */
/*                        Print messages by calling SYSDISPMSG            */
/*                                                                        */
/*  EXTERNAL ROUTINES:    SYSLOADMSG                                      */
/*                        SYSDISPMSG                                      */
/*                        SYSPARSE                                        */
/*                                                                        */
/**************************************************************************/

void main(c, v)
int c;
char *v[];
{
  int delflag = FALSE;                      /* Deletion specified */


  load_msg();                               /* Point to msgs & chk DOS ver */
  for (index = 1; index <= c; index++)      /* Loop through end of cmd line */
  {
    strcat(source,v[index]);                /* Add the argument */
    strcat(source," ");                     /* Separate with a space */
  }
  Parser_Prep(source);                      /* Initialization for the parser */

  delflag = ParseIt();                      /* Parse the command line */

  GetVars(&SysVars);

  if (c == 1)                               /* display all tree aliases */
    Display();
  else
  {
    if (delflag)                            /* Are we to delete a subst? */
    {
      if (!fDelete(p_drive))
        dispmsg_terminate(MSG_BADPARM,cmdln_drive);
    }
    else
      Insert(p_drive,p_filespec);
  }
  exit(0);
}


/**************************************************************************/
/*                                                                        */
/*  SUBROUTINE NAME:   ParseIt                                            */
/*                                                                        */
/*  SUBROUTINE FUNCTION:  Parse the command line entered by the user.     */
/*                        Returns whether or not the /d switch was used.  */
/*                                                                        */
/*  INPUT:             none                                               */
/*                                                                        */
/*  OUTPUT:            command line is parsed                             */
/*                     returns whether or not /d switch was used          */
/*                                                                        */
/**************************************************************************/

int ParseIt()
{
  char far * fptr;                          /* Pointer to parser's buffer */
  int delflag       = FALSE;                /* Deletion specified */
  int fchar         = 0;                    /* Parser filespec chars */
  int more_to_parse = TRUE;                 /* While parsing cmdline */
  int pdrive_flg    = FALSE;                /* Is there a drive letter? */
  int pflspec_flg   = FALSE;                /* Is there a filespec? */


  while (more_to_parse)                     /* test the flag */
  {
    index = 0;                              /* Init array index */
    parse(&inregs,&outregs);                /* call the parser */
    if (outregs.x.ax == P_No_Error)         /* if no error */
    {
      /* If result is a drive letter */
      if (outregs.x.dx == (unsigned short)&rslt1)
      {
        /* save the drive letter and set the flag */
        p_drive[0] = (char )(rslt1.p_result_buff[0]);
        p_drive[0] += (char)ASCII_DRIVE;
        p_drive[1] = COLON;
        pdrive_flg = TRUE;
        /* Copy whatever the parser just parsed */
        for (inregs.x.si; inregs.x.si < outregs.x.si; inregs.x.si++)
        {
          cmdln_drive[index] = *(char *)inregs.x.si;
          index++;
        }
      }
      else
      {
        /* If result is filespec */
        if (outregs.x.dx == (unsigned short)&rslt2)
        {
          /* From begginning of buffer til nul */
          for (fptr = rslt2.fp_result_buff; (char)*fptr != NULL; fptr++)
          {
            /* copy from result field buffer */
            p_filespec[fchar] = (char)*fptr;
            fchar++;
          }
          pflspec_flg = TRUE;               /* and set the flag */
          /* Copy whatever the parser just parsed */
          for (inregs.x.si; inregs.x.si < outregs.x.si; inregs.x.si++)
          {
            cmdln_flspec[index] = *(char *)inregs.x.si;
            index++;
          }
        }
        else   /* check for switches */
        {
          /* Copy whatever the parser just parsed */
          for (inregs.x.si; inregs.x.si < outregs.x.si; inregs.x.si++)
          {
            cmdln_switch[index] = *(char *)inregs.x.si;
            index++;
          }
          if (rslt3.P_SYNONYM_Ptr == &p_swi2.sp_keyorsw[0])       /* /? */
          {
            DisplayOptions();               /* show valid options */
            exit(0);                        /* so they can retry  */
          }
          else if (rslt3.P_SYNONYM_Ptr == &p_swi1.sp_keyorsw[0])  /* /D */
          {
            if (!delflag)                   /* Check for dup switch */
              delflag = TRUE;               /* it's /D switch */
            else                            /* else it's a duplicate switch */
              dispmsg_terminate(MSG_INVSWTCH,cmdln_switch);
          }
          else                                                    /* unknown */
            dispmsg_terminate(MSG_INVSWTCH,cmdln_switch);
        }
      }
    }
    else
    {
      if (outregs.x.ax != P_RC_EOL)         /* there must be an error */
      {
        /* Copy whatever the parser just parsed */
        for (inregs.x.si; inregs.x.si < outregs.x.si; inregs.x.si++)
        {
          cmdln_invalid[index] = *(char *)inregs.x.si;
          index++;
        }
        switch (outregs.x.ax)               /* See what error parser found */
        {
          case P_Too_Many :
              /* Too Many Parameters - more_to_parse = FALSE */
              dispmsg_terminate(MSG_PARMNUM,cmdln_invalid);
              break;
          case P_Not_In_SW :
              /* Invalid Switch - more_to_parse = FALSE */
              dispmsg_terminate(MSG_INVSWTCH,cmdln_invalid);
              break;
          case P_Op_Missing   :             /* Required operand missing */
          case P_Not_In_Key   :             /* Not in kywrd list provided */
          case P_Out_Of_Range :             /* Out of range specified */
          case P_Not_In_Val   :             /* Not in val list provided */
          case P_Not_In_Str   :             /* Not in strg list provided */
          case P_Syntax       :             /* Incorrect syntax */
              /* more_to_parse = FALSE */
              dispmsg_terminate(MSG_BADPARM,cmdln_invalid);
              break;
          default :
              /* more_to_parse = FALSE */
              display_msg(MSG_BADPARM,cmdln_invalid);
              exit(ERRORLEVEL1);
        }
      }
      else                                  /* End of the cmdline */
        more_to_parse = FALSE;
    }
    inregs.x.cx = outregs.x.cx;             /* Move the count */
    inregs.x.si = outregs.x.si;             /* Move the pointer */
  }

   /* If drive & no flspec or delete, then display error msg & exit utility */
  if (pdrive_flg && !(pflspec_flg || delflag))
    dispmsg_terminate(MSG_BADPARM,cmdln_drive);

  /* If filespec & no drive, then display error msg & exit utility */
  if (pflspec_flg && !pdrive_flg)
    dispmsg_terminate(MSG_BADPARM,cmdln_flspec);

  /* If delete & no drive, then display error msg & exit utility */
  if (delflag && !pdrive_flg)
    dispmsg_terminate(MSG_BADPARM,cmdln_switch);

  /* If drive, filespec, & /D, then display error msg & exit utility */
  if (pdrive_flg && pflspec_flg && delflag)
    dispmsg_terminate(MSG_PARMNUM,cmdln_switch);

  return(delflag);
}


/**************************************************************************/
/*                                                                        */
/*  SUBROUTINE NAME:   BackFix                                            */
/*                                                                        */
/**************************************************************************/

char *BackFix(p)
char *p;
{
  char *p1;
  char *p2;

  p2 = p-1;
  while (*(p2 = strbscan(p1 = p2+1,"\\")) != NULL);

  /* p1 points to char after last path sep.                */
  /* If this is a NULL, p already has a trailing path sep. */

  if (*p1 != NULL)
  {
    if ((p1 = malloc(strlen(p)+2)) == NULL)
      dispmsg_terminate(MSG_NOMEM, (char *)0);
    else
    {
      strcpy(p1, p);
      strcat(p1, "\\");
      p = p1;
    }
  }
  return(p);
}


/**************************************************************************/
/*                                                                        */
/*  SUBROUTINE NAME:   fDelete                                            */
/*                                                                        */
/**************************************************************************/

char fDelete(v)
char *v;
{
  struct CDSType CDS;
  int drive;

  /* Only 2 characters in the drive specifier */
  /* (and move before the call to BackFix)    */

  if (strlen(v) != 2 || v[1] != ':')
    return(FALSE);

  v = BackFix(v);
  drive = *v - 'A';

  /* If CDS doesn't exist OR was not substed OR is the current drive */
  if (!fGetCDS(drive, &CDS) || !TESTFLAG(CDS.flags,CDSLOCAL) ||
      drive == getdrv())
    dispmsg_terminate(MSG_BADPARM,cmdln_drive);

  strcpy(CDS.text, "A:\\");                 /* Set-up text of curr directory */
  CDS.text[0] += (char)drive;
  CDS.cbEnd = 2;                            /* Set backup limit */

  /* If physical, then mark as inuse and set-up DPB pointer */
  CDS.flags = drive >= SysVars.cDrv ? FALSE : CDSINUSE;
  CDS.pDPB = drive >= SysVars.cDrv ? 0L : GetDPB(drive);

  fPutCDS(drive, &CDS);
  return(TRUE);
}


/**************************************************************************/
/*                                                                        */
/*  SUBROUTINE NAME:   Insert                                             */
/*                                                                        */
/**************************************************************************/

void Insert(s, d)
char *s, *d;
{
  struct CDSType CDS;
  int drives, drived;
  char buf[MAXPATHLEN];


  rootpath(d, buf);

  /* Ensure destination not just a drive */
  if (strlen(d) == 2 && d[1] == ':')
    dispmsg_terminate(MSG_BADPARM,cmdln_flspec);

  /* Destination must exist, try root first */
  if (strlen(buf) == 3)
  {
    if (buf[1] != ':' || (buf[2]) != PathChr)
      dispmsg_terminate(MSG_BADPARM,cmdln_flspec);
  }

  /* path verification was treated as an ELSE condition */
  /* else                          Must be subdir... make sure */

  if (open(buf,O_BINARY) != -1)
    dispmsg_terminate(MSG_BADPARM,cmdln_flspec);
  else
  {
    if (access(buf,NULL) == -1)
      dispmsg_terminate(MSG_BADPATH,cmdln_flspec);
  }

  s = BackFix(s);
  d = BackFix(buf);
  drives = *s - 'A';
  drived = *d - 'A';

  /* Source can't be a net drive, is reuse of CDS */
  if (fNet(drives))
    dispmsg_terminate(MSG_NETERR, (char *)0);

  /* Destination can't be a net drive either */
  if (fNet(drived))
    dispmsg_terminate(MSG_NETERR, (char *)0);

  /* If src or dest invalid; or dest too long; or drives the same; or can't */
  /* get CDS for source; or source is current drive; or drive is net,       */
  /* splices or substed already; or destination is not physical             */

  if (drives < 0 || drives >= SysVars.cCDS || drives == drived ||
      !fGetCDS(drives, &CDS) || drives == getdrv() ||
      TESTFLAG(CDS.flags,CDSNET|CDSSPLICE))
    dispmsg_terminate(MSG_BADPARM,cmdln_drive);

  if (TESTFLAG(CDS.flags,CDSLOCAL))
    /* dispmsg_terminate(MSG_INUSE,cmdln_drive); */
    dispmsg_terminate(MSG_INUSE,(char *)0);

  if (drived < 0 || drived >= SysVars.cCDS || strlen(d) >= DIRSTRLEN ||
      !fPhysical(drived))
    dispmsg_terminate(MSG_BADPARM,cmdln_flspec);

  /* Chop trailing \ if not at root */
  if (strlen(d) != 3)
    d[strlen(d)-1] = 0;

  strcpy(CDS.text, d);
  CDS.cbEnd = strlen(CDS.text);
  if (CDS.cbEnd == 3)
    CDS.cbEnd--;
  CDS.flags = CDSINUSE|CDSLOCAL;
  if ((CDS.pDPB = GetDPB(drived)) == -1L)
    dispmsg_terminate(MSG_BADPARM,cmdln_flspec);

  CDS.ID = -1L;
  fPutCDS(drives, &CDS);
  return;
}


/**************************************************************************/
/*                                                                        */
/*  SUBROUTINE NAME:   Display                                            */
/*                                                                        */
/*  SUBROUTINE FUNCTION:  Displays current list of substs.                */
/*                                                                        */
/**************************************************************************/

void Display()
{
  struct CDSType CDS;
  int i;

  for (i=0; fGetCDS(i, &CDS); i++)
  {
    if (TESTFLAG(CDS.flags,CDSLOCAL))
    {
      if (CDS.cbEnd == 2)
        CDS.cbEnd ++;
      CDS.text[CDS.cbEnd] = 0;
      printf("%c: => %s\n", i+'A', CDS.text);
    }
  }
  return;
}


/**************************************************************************/
/*                                                                        */
/*  SUBROUTINE NAME:   load_msg                                           */
/*                                                                        */
/*  SUBROUTINE FUNCTION:  Load the set of SUBST Utility messages to       */
/*                        become available for display_msg call.          */
/*                                                                        */
/*  ERROR EXIT:        Utility will be terminated by sysloadmsg if        */
/*                     version check is incorrect.                        */
/*                                                                        */
/*  EXTERNAL REF:      SYSLOADMSG                                         */
/*                                                                        */
/**************************************************************************/

void load_msg()
{
  sysloadmsg(&inregs,&outregs);             /* Load utility messages */
  if (outregs.x.cflag & CARRY)              /* If problem loading msgs */
  {
    sysdispmsg(&outregs,&outregs);          /* then display the err msg */
    exit(ERRORLEVEL1);
  }
  return;
}


/**************************************************************************/
/*                                                                        */
/*  SUBROUTINE NAME:   display_msg                                        */
/*                                                                        */
/*  SUBROUTINE FUNCTION:  The correct message called by main is displayed */
/*                        to standard out.                                */
/*                                                                        */
/*  INPUT:             msg_num   (message number to display)              */
/*                     outline   (substitution parameter)                 */
/*                                                                        */
/*  OUTPUT:            none                                               */
/*                                                                        */
/*  ERROR EXIT:        Display error message corresponding to number      */
/*                     returned in AX.                                    */
/*                                                                        */
/*  EXTERNAL REF:      SYSDISPMSG                                         */
/*                                                                        */
/**************************************************************************/

void display_msg(msg_num,outline)
int msg_num;                                /* Message number #define'd */
char *outline;                              /* Substitution parameter */
{
  unsigned char function;                   /* Y/N response or press key? */
  unsigned int message,                     /* Message number to display */
               msg_class,                   /* Which class of messages? */
               sub_cnt,                     /* Number of substitutions? */
               handle;                      /* Display where? */

  struct sublist
  {
    unsigned char size;                     /* Points to next sublist */
    unsigned char reserved;                 /* Required for sysdispmsg */
    unsigned far *value;                    /* Data pointer */
    unsigned char id;                       /* Id of substitution parm (%1) */
    unsigned char flags;                    /* Format of data - (a0sstttt) */
    unsigned char max_width;                /* Maximum field width */
    unsigned char min_width;                /* Minimum field width */
    unsigned char pad_char;                 /* char to pad field */
  } sublist;


  switch (msg_num)                          /* Which msg to display? */
  {
    case MSG_PARMNUM :                      /* Incorrect Number of Parameters */
        function  = NO_INPUT;               /* Y/N response or press key? */
        message   = 2;                      /* Message number to display */
        msg_class = UTILITY_CLASS;          /* Which class of messages? */
        sub_cnt   = SUBCNT1;                /* Number of substitutions? */
        handle    = STDERR;                 /* Display where? */
        break;
    case MSG_BADPATH :                      /* Invalid Path */
        function  = NO_INPUT;               /* Y/N response or press key? */
        message   = 3;                      /* Message number to display */
        msg_class = EXT_ERR_CLASS;          /* Which class of messages? */
        sub_cnt   = SUBCNT1;                /* Number of substitutions? */
        handle    = STDERR;                 /* Display where? */
        break;
    case MSG_INUSE :                        /* In Use */
        function  = NO_INPUT;
        message   = 5;
        msg_class = UTILITY_CLASS;
        sub_cnt   = SUBCNT0;
        handle    = STDERR;
	break;
    case MSG_NOMEM :                        /* Insufficient Memory */
        function  = NO_INPUT;               /* Y/N response or press key? */
        message   = 8;                      /* Message number to display */
        msg_class = EXT_ERR_CLASS;          /* Which class of messages? */
        sub_cnt   = SUBCNT0;                /* Number of substitutions? */
        handle    = STDERR;                 /* Display where? */
        break;
    case MSG_BADPARM :                      /* Invalid Parameter */
        function  = NO_INPUT;               /* Y/N response or press key? */
        message   = 10;                     /* Message number to display */
        msg_class = PARSE_ERR_CLASS;        /* Which class of messages? */
        sub_cnt   = SUBCNT1;                /* Number of substitutions? */
        handle    = STDERR;                 /* Display where? */
        break;
    case MSG_NETERR :                       /* Cannot SUBST network drive */
        function  = NO_INPUT;               /* Y/N response or press key? */
        message   = 12;                     /* Message number to display */
        msg_class = UTILITY_CLASS;          /* Which class of messages? */
        sub_cnt   = SUBCNT1;                /* Number of substitutions? */
        handle    = STDERR;                 /* Display where? */
        break;
    case MSG_INVSWTCH :                     /* Invalid Switch */
        function  = NO_INPUT;               /* Y/N response or press key? */
        message   = 3;                      /* Message number to display */
        msg_class = PARSE_ERR_CLASS;        /* Which class of messages? */
        sub_cnt   = SUBCNT1;                /* Number of substitutions? */
        handle    = STDERR;                 /* Display where? */
        break;
    default:
        if (msg_num >= MSG_OPTIONS_FIRST && msg_num <= MSG_OPTIONS_LAST)
        {
          function  = NO_INPUT;
          message   = msg_num;
          msg_class = UTILITY_CLASS;
          sub_cnt   = SUBCNT0;
          handle    = STDOUT;
        }
        else
         exit(ERRORLEVEL1);
        break;
  }

  switch (msg_num)
  {
    case MSG_INUSE :                             /* In use */
    case MSG_NOMEM :                             /* Insufficient memory */
        inregs.x.ax = message;
        inregs.x.bx = handle;                    /* STDERR */
        inregs.x.cx = sub_cnt;                   /* SUBCNT0 */
        inregs.h.dl = function;                  /* NO_INPUT */
        inregs.h.dh = (unsigned char)msg_class;  /* Extended, Parse or Utility */
        sysdispmsg(&inregs,&outregs);            /* Call common msg service */
        break;
    case MSG_INVSWTCH :                          /* Invalid switch */
    case MSG_PARMNUM  :                          /* Incorrect num of parms */
    case MSG_BADPARM  :                          /* Invalid parameter */
    case MSG_BADPATH  :                          /* Path not found */
        sublist.value = (unsigned far *)outline;
        sublist.reserved = RESERVED;
        sublist.id = SUB_ID0;
        sublist.flags = STR_INPUT;
        sublist.max_width = MAXWIDTH;
        sublist.min_width = MINWIDTH;
        sublist.pad_char = (unsigned char)BLNK;
        inregs.x.ax = message;
        inregs.x.bx = handle;                    /* STDERR */
        inregs.x.si = (unsigned int)&sublist;    /* Point to the sub buffer */
        inregs.x.cx = sub_cnt;                   /* SUBCNT1 */
        inregs.h.dl = function;                  /* STR_INPUT */
        inregs.h.dh = (unsigned char)msg_class;  /* Extended, Parse or Utility */
        sysdispmsg(&inregs,&outregs);            /* Call common msg service */
        break;
    case MSG_NETERR :                            /* Cannot SUBST network drive */
        sublist.value = (unsigned far *)replparm_SUBST;
        sublist.reserved = RESERVED;
        sublist.id = SUB_ID1;
        sublist.flags = STR_INPUT;
        sublist.max_width = MAXWIDTH;
        sublist.min_width = MINWIDTH;
        sublist.pad_char = (unsigned char)BLNK;
        inregs.x.ax = message;                   /* Cannot SUBST network drive */
        inregs.x.bx = handle;                    /* STDERR */
        inregs.x.si = (unsigned int)&sublist;    /* Point to the sub buffer */
        inregs.x.cx = sub_cnt;                   /* SUBCNT1 */
        inregs.h.dl = function;                  /* STR_INPUT */
        inregs.h.dh = (unsigned char)msg_class;  /* Extended, Parse or Utility */
        sysdispmsg(&inregs,&outregs);            /* Call common msg service */
        break;
    default:
        if (msg_num >= MSG_OPTIONS_FIRST && msg_num <= MSG_OPTIONS_LAST)
        {
 	  inregs.x.ax = message;
          inregs.x.bx = handle;
          inregs.x.cx = sub_cnt;
          inregs.h.dl = function;
          inregs.h.dh = (unsigned char)msg_class;
          sysdispmsg(&inregs,&outregs);
        }
        else
          exit(ERRORLEVEL1);
        break;
  }

    if (outregs.x.cflag & CARRY)            /* Is the carry flag set? */
    {                                       /* Then setup regs for extd-err */
      inregs.x.bx = STDERR;
      inregs.x.cx = SUBCNT0;
      inregs.h.dl = NO_INPUT;
      inregs.h.dh = EXT_ERR_CLASS;
      sysdispmsg(&inregs,&outregs);         /* Call to display ext_err msg */
      exit(ERRORLEVEL1);
    }
    return;
}


/**************************************************************************/
/*                                                                        */
/*  SUBROUTINE NAME:   DisplayOptions                                     */
/*                                                                        */
/*  SUBROUTINE FUNCTION:  Display the options help message to the user.   */
/*                                                                        */
/*  INPUT:             no value passed.                                   */
/*                                                                        */
/*  OUTPUT:            none                                               */
/*                                                                        */
/*  ERROR EXIT:        none                                               */
/*                                                                        */
/*  EXTERNAL REF:      SYSDISPMSG                                         */
/*                                                                        */
/**************************************************************************/

void DisplayOptions()
{
  int MsgNbr;

  /*
   * Display all the message lines in the
   * options help message.
   */
  for (MsgNbr = MSG_OPTIONS_FIRST; MsgNbr <= MSG_OPTIONS_LAST; MsgNbr++)
    display_msg(MsgNbr, (char *)0);
}


/**************************************************************************/
/*                                                                        */
/*  SUBROUTINE NAME:   dispmsg_terminate                                  */
/*                                                                        */
/*  SUBROUTINE FUNCTION:  Display the message, then terminate the utility.*/
/*                                                                        */
/*  INPUT:             msg_num     (#define'd message to display)         */
/*                     outline     (substitution parameter)               */
/*                                                                        */
/**************************************************************************/

void dispmsg_terminate(msg_num,outline)
int msg_num;                                /* Message number #define'd */
char *outline;                              /* Substitution parameter */
{
  display_msg(msg_num,outline);             /* First, display the msg */
  exit(ERRORLEVEL1);                        /* Then, terminate utility */
}


/**************************************************************************/
/*                                                                        */
/*  SUBROUTINE NAME:   Parser_Prep                                        */
/*                                                                        */
/*  SUBROUTINE FUNCTION:  Initialize all structures for the parser.       */
/*                                                                        */
/*  INPUT:             source (command line string)                       */
/*                                                                        */
/*  OUTPUT:            none                                               */
/*                                                                        */
/*  EXTERNAL REF:      parse                                              */
/*                                                                        */
/**************************************************************************/

void Parser_Prep(source)
char *source;                                    /* Commandline */
{
  p_p.p_parmsx_address = &p_px;                  /* Address of extended parm list */
  p_p.p_num_extra = 0;                           /* No extra declarations */

  p_px.p_minp = MINPOSITION;
  p_px.p_maxp = MAXPOSITION;
  p_px.p_control1 = &p_con1;                     /* Point to 1st control blk */
  p_px.p_control2 = &p_con2;                     /* Point to 2nd control blk */
  p_px.p_maxs = 2;                               /* Specify # of switches */
  p_px.p_switch = &p_swi1;                       /* Point to 1st switch blk */
  p_px.p_switch2 = &p_swi2;                      /* Point to 2nd switch blk */
  p_px.p_maxk = 0;                               /* Specify # of keywords */

  p_con1.p_match_flag = DRVONLY_OPT;             /* Drive only & optional */
  p_con1.p_function_flag = NOCAPPING;            /* Cap result by file table */
  p_con1.p_result_buf = (unsigned int)&rslt1;    /* Point to result blk */
  p_con1.p_value_list = (unsigned int)&novals;   /* Point to no value list */
  p_con1.p_nid = 0;                              /* Not a switch id */

  p_con2.p_match_flag = FILESPEC_OPT;            /* File spec & optional */
  p_con2.p_function_flag = CAPRESULT;            /* Cap result by file table */
  p_con2.p_result_buf = (unsigned int)&rslt2;    /* Point to result blk */
  p_con2.p_value_list = (unsigned int)&novals;   /* Point to no value list */
  p_con2.p_nid = 0;                              /* Not a switch id */

  p_swi1.sp_match_flag = SWITCH_OPT;             /* Optional (switch) */
  p_swi1.sp_function_flag = NOCAPPING;           /* Cap result by file table */
  p_swi1.sp_result_buf = (unsigned int)&rslt3;   /* Point to result blk */
  p_swi1.sp_value_list = (unsigned int)&novals;  /* Point to no value list */
  p_swi1.sp_nid = 1;                             /* One switch allowed */
  strcpy(p_swi1.sp_keyorsw,D_SWITCH);            /* Identify the switch */

  p_swi2.sp_match_flag = SWITCH_OPT;             /* Optional (switch) */
  p_swi2.sp_function_flag = NOCAPPING;           /* Cap result by file table */
  p_swi2.sp_result_buf = (unsigned int)&rslt3;   /* Point to result blk */
  p_swi2.sp_value_list = (unsigned int)&novals;  /* Point to no value list */
  p_swi2.sp_nid = 1;                             /* One switch allowed */
  strcpy(p_swi2.sp_keyorsw,O_SWITCH);            /* Identify the switch */

  inregs.x.cx = 0;                               /* Operand ordinal */
  inregs.x.di = (unsigned int)&p_p;              /* Address of parm list */
  inregs.x.si = (unsigned int)source;            /* Make DS:SI point to source */
  return;
}


=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\sys\sys1.asm ===
;******************************************************************************
;
;	Microsoft Confidential
;	Copyright (c) Microsoft Corporation 1991
;	All Rights Reserved
;
;  Change Log:
;
;    Date    Who   #			  Description
;  --------  ---  ---  ------------------------------------------------------
;  03/26/90  EGH  C00  Cleaned up build by removing unused variables, declaring
;		       functions properly, changing long JMPs to short JMPs,
;		       etc.
;  03/26/90  EGH  C01  Problem fixed - if a source path was specified with an
;		       ending backslash (i.e. SYS A:\ C:), the message "Insert
;		       system diskette in drive A:  Press any key to continue"
;		       would be displayed endlessly with every keypress.  Fix
;		       is to insure that all paths have an ending backslash and
;		       remove the backslash from the file names.  STR #1976.
;  03/26/90  EGH  C02  Problem fixed - attempting to SYS to a non-FAT file
;		       system would result in the message "Not able to SYS to
;		       xxx file system" with only the first three letters of
;		       the file system name displayed.	Fix is to allow a
;		       maximum of 8 characters to be displayed.
;  03/27/90  EGH  C03  Problem fixed - specifying a source path longer than 53
;		       characters resulted in an error message.  Fix is to
;		       increase the buffer size to support the maximum DOS
;		       path size of 63 characters and change the associated
;		       code.
;  03/28/90  EGH  C04  Problem fixed - source and target drives being the same
;		       (i.e. SYS A: A:) did not generate an error and made the
;		       disk unbootable.  Fix is to add a check to see if the
;		       source drive is the same as the target drive and issue
;		       an appropriate error message.
;  03/28/90  EGH  C05  Problem fixed - an ASSIGNed source drive, specified or
;		       default, that is really the target drive did not
;		       generate an error and made the disk unbootable.	Fix is
;		       to translate the source drive before comparing it to
;		       the target drive. STR #1977
;  03/29/90  EGH  C06  Problem fixed - the buffer for the system files was
;		       being overwritten when a cluster needed to be moved
;		       and the cluster size was greater than 4K.  Fix is to
;		       use the system file buffer for cluster transfers and
;		       load in the system files afterwards.
;  11/21/90  DLB  M008 Made TargDrv public for use in updating CDS.
;  01/09/91  DLB  M009 Do not use COMSPEC unless it specifies COMMAND.COM.
;  01/09/91  DLB  M010 Send "System transferred" msg to STDOUT instead of
;		       STDERR.
;  02/05/91  DLB  M011 Fix computation of Transfer buffer size (cbBuf).
;                      Display error message and exit if buffer too small.
;
;  05/22/91  MD   M012 Check for ROM DOS, exit if found
;
;  08/05/91  MD        Removed M012 changes.
;
;******************************************************************************
	TITLE	SYS-1-	Program
	include version.inc
	include find.inc
	include dpb.inc
	include syscall.inc
	INCLUDE SYSHDR.INC
	page	80,132

false	= 0

DATA	SEGMENT PARA PUBLIC

	public	TargDrvNum, TargSpec, bio_owns_it, DOS_VER
	public	packet, packet_sectors, packet_buffer
        public  TargDrv                 ;M008

	extrn	THIS_DPB:dword, BUF:word, DIR_SECTOR:word, first_dir_sector:word

;			$SALUT (4,25,30,41)

; DOS_VER was formerly used to allow SYS to run on DOS < 4.0.
; Now we just reject DOS less than the current version.
; References to DOS_VER haven't been cleaned up, though.
DOS_VER 		DB   0		; DOS Version - 0 = current
					;		
DEFALT			DB   0		; Default Drive (source - NUMBER
TargAttr                DW   1          ; Attributes for target command.com (+R)
TargDrvNum		DB   0		; Target Drive (destination) - NUMBER
TargDrv 		DB   0		; Target Drive (destination) - LETTER
TargSpec		DB   "A:\",0	; z string for target name

;M002 - begin
IF IBMCOPYRIGHT
BIOSName		DB   "A:\IBMBIO.COM",0 ; z string for target name
DOSName 		DB   "A:\IBMDOS.COM",0 ; z string for target name
OTHERBIOSName		DB   "A:\IO.SYS",0
OTHERDOSName 		DB   "A:\MSDOS.SYS",0
ELSE
BIOSName		DB   "A:\IO.SYS",0
DOSName 		DB   "A:\MSDOS.SYS",0
OTHERBIOSName		DB   "A:\IBMBIO.COM",0
OTHERDOSName 		DB   "A:\IBMDOS.COM",0
ENDIF
;M002 - end

SourceBIOSName		LABEL WORD
SourceSpec		DB   "A:"
			DB   "\"					   ;C01
			DB   64 dup (0) 				   ;C03
IF IBMCOPYRIGHT
SourceBIOS		DB   "IBMBIO.COM",0				   ;C01
ELSE
SourceBIOS		DB   "IO.SYS",0 				   ;C01
ENDIF

IF  IBMCOPYRIGHT
NameLen 		equ  $ - SourceBios
ELSE
BiosNameLen		equ  $ - SourceBios
ENDIF

SourceDOSName		DB   "A:"
			DB   "\"					   ;C01
			DB   64 dup (0) 				   ;C03

IF IBMCOPYRIGHT
SourceDOS		DB   "IBMDOS.COM",0				   ;C01
ELSE
SourceDOS		DB   "MSDOS.SYS",0				   ;C01
ENDIF
IF  IBMCOPYRIGHT
ELSE
DosNameLen		equ  $ - SourceDOS
ENDIF

SourceSize		dw   3						   ;C01
Spec_flag		db   0

; M000 - begin
SourceCommandName	DB   "A:\"
			DB   64 dup (0) 				
targ_com		db   "?:"

; M009: The code in Copy_Command() expects the following of command_string:
;       1) The first character must be a '\'.
;       2) "command.com" must be lower case.
;       3) It must be NULL terminated.
command_string		db   "\command.com", 0
LEN_COMMAND_STRING      equ  $-command_string           ;M009

IFDEF DBLSPACE_HOOKS
SourceDblSpaceName      db   "A:\"
                        db   64 dup (0)

; Do not insert anything between the next two data items!
TargDblSpace            db   "A:\"
SourceDblSpace          db   "DBLSPACE.BIN",0
DblSpaceNameLen         equ $ - offset SourceDblSpace
ENDIF

old_psp			dw   0
rdhndle			dw   0
wthndle			dw   -1
lastround		db   0
trying_comspec  	db   0

IBMBIO_LOW		DW   0		;length of IBMBIO on target disk
IBMBIO_HIGH		DW   0
IBMDOS_LOW		DW   0		;length of old IBMDOS on target disk
IBMDOS_HIGH		DW   0

IFDEF DBLSPACE_HOOKS
DblSpace_Low            DW   0          ;length of Dblspace.bin on target
DblSpace_High           DW   0
ENDIF

CommandCom_Low          DW   0          ;length of command.com on target
CommandCom_High         DW   0

Need_Clusters		dw   0
Bytes_Per_Cluster	dw   0
Number_Free_Clusters	dw   0

;	$SALUT	(4,9,17,41)
					;---------------------------------------
					;  SRORAGE FOR COMMAND LINE PARAMETERS
					;---------------------------------------

PARMS	LABEL	WORD
	DW	OFFSET PARMSX		; POINTER TO PARMS STRUCTURE
	DB	0			; NO DELIMITER LIST FOLLOWS
	DB	0			; NUMBER OF ADDITIONAL DELIMITERS

					;---------------------------------------
					;  STRUCTURE TO DEFINE SYS SYNTAX REQUIREMENT
					;---------------------------------------

PARMSX	LABEL	BYTE
PAR_MIN DB	1			; MINIMUM POSITIONAL PARAMETERS = 1    ;AC021;
	DB	2			; MAXIMUM PARAMETERS = 2	       ;AC021;
	DW	OFFSET POS1		; POINTER TO POSITIONAL DEFINITION
	DW	OFFSET POS1		; POINTER TO SAME POSITIONAL DEFINITION;AC021;
	DB	1			; THERE IS 1 SWITCH
	DW	OFFSET SW1		; POINTER TO SWITCH DEFINITION
	DB	0			; THERE ARE NO KEYWORDS IN PRINT SYNTAX

					;---------------------------------------
					;  STRUCTURE TO DEFINE THE POSITIONAL PARAMETER (Drive ID)
					;---------------------------------------

POS1	LABEL	WORD
POSREP	DB	reqd			; MATCH FLAG LOW		       ;AC021;
POSTYP	DB	f_spec + drv_id 	; MATCH FLAG HIGH		       ;AC021;
	DW	0001H			; CAPS BY FILE TABLE
	DW	OFFSET POS_BUFF 	; PLACE RESULT IN POSITIONAL BUFFER
	DW	OFFSET NOVALS		; NO VALUES LIST REQUIRED
	DB	0			; NO KEYWORDS

reqd	equ	0
f_spec	equ	2
drv_id	equ	1
					;---------------------------------------
					;  STRUCTURE TO DEFINE THE /? SWITCH
					;---------------------------------------
	PUBLIC	SW1, SW1_SYN
SW1	LABEL	WORD
	DW	0			; MATCH MASK
	DW	0			; FUNC MASK
	DW	OFFSET SW_BUFF 		; PLACE RESULT IN SWITCH BUFFER
	DW	OFFSET NOVALS		; NO VALUES LIST REQUIRED
	DB	1			; 1 SYNONYM
SW1_SYN	DB	"/?",0			; TEXT OF SYNONYM TO MATCH

					;---------------------------------------
					;  VALUE LIST FOR POSITIONAL
					;---------------------------------------

NOVALS	LABEL	WORD
	DB	0			; NO VALUES

;			$SALUT (4,25,30,41)

					;---------------------------------------
					;  RETURN BUFFER FOR POSITIONAL INFORMATION
					;---------------------------------------
POS_BUFF		LABEL BYTE
POS_TYPE		DB   ?		; TYPE RETURNED
POS_ITEM_TAG		DB   ?		; SPACE FOR ITEM TAG
POS_SYN 		DW   ?		; POINTER TO LIST ENTRY
POS_OFF 		LABEL WORD
POS_DRV_ID		DB   ?		; SPACE FOR DRIVE NUMBER (1=A, 2=B, ect)
			DB   ?		;				       ;AC021;
POS_SEG 		DW   ?		;				       ;AC021;


					;---------------------------------------
					;  RETURN BUFFER FOR SWITCH INFORMATION
					;---------------------------------------
	PUBLIC	SW_BUFF,SW_SYN
SW_BUFF			LABEL BYTE
SW_TYPE			DB   ?		; TYPE RETURNED
SW_ITEM_TAG		DB   ?		; SPACE FOR ITEM TAG
SW_SYN 			DW   ?		; POINTER TO LIST ENTRY
			DD	?

failopen		equ  0		; extended open 'does not exist action
openit			equ  1		; extended open 'exists' action
replaceit		equ  2		; extended open 'exists' action - replace

OPEN_PARMS		label dword

open_off		dw   ?		; name pointer offset
open_seg		dw   ?		; name pointer segment

PACKET			dw   0,0	; CONTROL PACKET		       ;AN001;
packet_sectors		dw   0		; COUNT 			       ;AN001;
PACKET_BUFFER		dw   0,0	; BUFFER ADDRESS		       ;AN001;

					;---------------------------------------
					;  Buffer for IOCtl Get/Set Media
					;---------------------------------------

IOCTL_BUF		LABEL BYTE

IOCtl_Level		DW   0		; INFO LEVEL (SET ON INPUT)
IOCtl_Ser_No_Low	DW   ?		; SERIAL #
IOCtl_Ser_No_Hi 	DW   ?		; SERIAL #
IOCtl_Vol_ID		DB   "NO NAME    " ; VOLUME LABEL - 11 bytes
IOCTL_File_Sys		DB   8 DUP(' ') ; FILE SYSTEM TYPE

IOCTL_Ser_Vol_Sys	equ  $ - IOCtl_Ser_No_Low
file_sys_size		equ  $ - IOCtl_File_Sys

File_Sys_End		LABEL WORD

			db   0		; safety

fat_12			DB   "FAT12   " ; 12 bit FAT
FAT_len 		equ  $ - fat_12
fat_16			DB   "FAT16   " ; 16 or 32 bit FAT

					;---------------------------------------
					; SUBLIST for Message call
					;---------------------------------------

.xlist
			include sysmsg.inc

			MSG_UTILNAME <SYS> ;				       ;AN000;

			MSG_SERVICES <MSGDATA> ;			       ;AN000;
.list

SUBLIST 		LABEL DWORD

			DB   sub_size	; size of sublist
			DB   0		; reserved
insert_ptr_off		DW   ?		; pointer to insert - offset
insert_ptr_seg		DW   ?		; pointer to insert - segment
insert_number		DB   1		; number of insert
			DB   Char_Field_ASCIIZ ;type flag
insert_max		DB   3		; maximum field size (limited to 3)
					;   - this handles - SYS
					;   - and - D:\
			DB   1		; minimum field size
			DB   " "	; pad character

sub_size		equ  $ - SUBLIST ; size of sublist

sys_ptr 		db   "SYS",0

bio_owns_it		db   0
EntryFree		db   0		; for create file

IFDEF DBLSPACE_HOOKS
NoDblSpace              db   FALSE      ; flag is Dblspace must be copied
ENDIF

;*** WARNING ***
; KEEP THE FOLLOWING ITEMS IN THE EXACT ORDER BELOW!!!
DOSEntFree		DB   1
BIOSEntFree		DB   1

Xfer_data		STRUC

InFH			DW   ?		; file handle of source
LenLow			DW   ?		; 32-bit length of source
LenHigh 		DW   ?
FTime			DW   ?		; place to store time of write
FDate			DW   ?		; place to store date of write
OutFH			DW   ?		; fh of destination
BufPos                  DW   ?          ; start of this file in xfer buffer
BufferedSize            DW   ?          ; count of bytes read into buffer
OutFileName             DW   ?          ; pathname of destination file

Xfer_data		ENDS

; following are instances of the xfer_data structure

BIOSInFH		DW   -1		; file handle of source BIOS
BIOSLenLow		DW   0		; 32-bit length of BIOS
BIOSLenHigh		DW   0
BIOSTime		DW   2 DUP (?)	; place to store time of BIOS write
BIOSOutFH		DW   -1		; fh of BIOS destination
BIOSBufPos 		DW   0  	; start of file in xfer buffer
BIOSBufferedSize        DW   0          ; count of bytes read into buffer
BIOSOutFileName         DW   offset BIOSName

DOSInFH 		DW   -1		; file handle of source DOS
DOSLenLow		DW   0		; 32-bit length of DOS
DOSLenHigh		DW   0
DOSTime 		DW   2 DUP (?)	; place to store time of DOS write
DOSOutFH		DW   -1		; fh of DOS destination
DOSBufPos 		DW   0  	; start of file in xfer buffer
DOSBufferedSize         DW   0          ; count of bytes read into buffer
DOSOutFileName          DW   offset DOSName

IFDEF DBLSPACE_HOOKS
DblSpaceInFH 		DW   -1		; file handle of source DblSpace
DblSpaceLenLow		DW   0		; 32-bit length of DblSpace
DblSpaceLenHigh		DW   0
DblSpaceTime 		DW   2 DUP (?)	; place to store time of DblSpace write
DblSpaceOutFH		DW   -1		; fh of DblSpace destination
DblSpaceBufPos 		DW   0  	; start of file in xfer buffer
DblSpaceBufferedSize    DW   0          ; count of bytes read into buffer
DblSpaceOutFileName     DW   offset TargDblSpace
ENDIF

; array of pointers to the xfer_data structures.  Last field of 0 is
; the terminator.  Loops that use this array check for this terminator
; as loop end.
IFDEF DBLSPACE_HOOKS
; If DblSpace.bin isn't going to be copied, the entry for it (FHArrayDS) will
; be cleared, so the loop termination comes after the DOS file is copied.
ENDIF

FHArray                 dw   offset BIOSInFH
                        dw   offset DOSInFH
IFDEF DBLSPACE_HOOKS
FHArrayDS               dw   offset DblSpaceInFH
ENDIF
                        dw   0
IF IBMCOPYRIGHT
FCBDOS			DB   "IBMDOS  COM"
FCBBIO			DB   "IBMBIO  COM"
ELSE
FCBDOS			DB   "MSDOS   SYS"
FCBBIO			DB   "IO      SYS"
ENDIF

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;   The following is a Extended FCB
ExtFCB			db   0FFh
			db   5 dup (0)
			db   DOS_volume_atrib
ExtFCB_Drive		db   0
ExtFCB_Name		db   "???????????"
			db   24 dup (0)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

DOS_BUFFER		DB   80h DUP (?)
cbBuf			DW   ?		; number of bytes in buffer
pDOS			DW   ?		; offset of beginning of DOS in buffer
pDOSEnd 		DW   ?		; offset of end of DOS in buffer


public			boot
BOOT			LABEL BYTE
.xlist
			INCLUDE BOOT.INC
.list
					;
					; Following structure used by Generic IOCTL call Get Device Parameters to get
					; the BPB of a hard disk. It 'overflows' into area of BUF.
					;
DeviceParameters	a_DeviceParameters <1,DEV_HARDDISK>

DATA			ENDS

CODE			SEGMENT PARA PUBLIC

			EXTRN SYSLOADMSG:near, SYSDISPMSG:near, SYSPARSE:near
			EXTRN Data_Space:WORD, Find_DPB:near,
			EXTRN Move_DIR_Entry:near, Direct_Access:near
                        EXTRN Find_Path_In_Environment:near
                        EXTRN Search:near, Path_Crunch:near
                        EXTRN Find_Comspec_In_Environment:near
IFDEF NEED_CLUSTER_2
                        EXTRN Free_Cluster:near
ENDIF

			BREAK <SYS - Main>
;******************* START OF SPECIFICATIONS ***********************************
;Routine name:	Main
;*******************************************************************************
;
;Description: Main control routine. Subroutines are structured so that they
;	      will pass back an error return code (message number) and set
;	      the fail flag (CF) if there was a fatal error.
;
;	NOTES:
;
;  1 -	This program uses its own internal stack.  The stack space provided
;	by DOS is used as an input buffer for transfering IBMBIO and IBMDOS.
;
;	SYS is linked with the CODE segment followed by the DATA segment. The
;	last symbol in DATA is BUF. It marks the end end of data and the
;	start of the BUFfer.  The BUFfer extends from here to SP.  The first
;	6.5Kb (13 sectors) in BUFfer are used for up to 12 sectors of the FAT
;	or the directory. In Main, the remaining space is set
;	as follows:
;		      cdBuf = SP - ( FAT_BUF + BUF )
;
;  2 -	The main line program calls 1 routine that loops until specific
;	requirements are met. It is:
;			Get_System_Files - if default drive has replaceable
;					   media this routine loops until
;					   a diskette with the correct system
;					   files is inserted.
;
;Called Procedures: Init_Input_Output
;		    Validate_Target_Drive
;		    Get_System_Files
;		    Check_SYS_Conditions
;		    Do_SYS
;		    Message
;
;Input: Command line input in PSP
;
;Ouput: no error - System transfered to target media
;	   error - Appropriate error message displayed
;
;Change History: Created	5/01/87 	FG
;
;******************* END OF SPECIFICATIONS *************************************
;******************+ START OF PSEUDOCODE +**************************************
;
;	START  Main
;
;	setup messages and parsing (CALL Init_Input_Output)
;	if there is no error and
;		verify target drive is valid (CALL Validate_Target_Drive)
;	if there is no error and
;		get system files loaded (CALL Get_System_Files)
;	if there is no error and
;		verify target drive is SYSable (Check_SYS_Conditions)
;	if there is no error and
;		perform SYS operation (CALL Do_SYS)
;	if no error and
;		clean up loose ends (CALL Do_End)
;	if no error
;		load return code (System transfered)
;	endif
;	display message (CALL Message)
;	ret
;
;	END  Main
;
;******************-  END  OF PSEUDOCODE -**************************************

			ASSUME CS:CODE,DS:NOTHING,ES:NOTHING

			ORG  80H

PSP_PRAM		DB   128 DUP(?)

START:			JMP  BEGIN

			DB   " - SYS - Utility "
			DB   01Ah

			even

			db   510 dup(0) ; stack

EOS			EQU  BYTE PTR $

			DW   0		; RETURN OFFSET


public			Begin

BEGIN			PROC NEAR

   mov	ax,OFFSET Data_Space
   add	ax,15				; round up to next segment
   mov	cl,4				; convert to segment value
   shr	ax,cl
   mov	cx,ds
   add	ax,cx				; generate DATA segment value
   mov	ds,ax

   ASSUME DS:DATA,ES:NOTHING

   mov  ax,  es
   mov  old_psp, ax

   mov	cbBuf,sp			; M011: Temporarily save SP.
   mov	sp,OFFSET EOS			; set up internal stack

   mov	dx,OFFSET DOS_BUFFER		; set up DTA
   mov	ah,SET_DMA
   INT	21h

   call Init_Input_Output		; setup messages and parsing	
   jc   $$if1
;
; close reserved file handles 0 and 3-4 so we can reuse them.  Leave
; 1 & 2 open for our output messages.
;
; Don't close file handle 0, leave it open so the standard input
; remains available.
;
;  mov	ah,CLOSE
;  xor	bx,bx
;  int	21h				; Close stdin

   mov  ah,CLOSE
   mov  bx,3
   int  21h                             ; Close stdaux

   mov  ah,CLOSE
   inc  bx
   int  21h                             ; Close stdprn

;M011
; Ensure that a Transfer buffer of at least XFER_BUF exists beyond
; CODE + DATA + FAT_BUF (FAT sector buffer).  (This check MUST be done
; after messages are setup in Init_Input_Output.)
; If we are not supporting relocating the owner of cluster 2, we don't
; need to include the FAT_BUF space.
;
   mov  ax,(util_B shl 8) + no_mem	; Return code = Insufficient memory.
   mov  cx,(OFFSET Data_Space)          ; CX = End of code.
IFDEF NEED_CLUSTER_2
   add	cx,(OFFSET BUF) + FAT_BUF + XFER_BUF ; CX = End of minimum buffer.
ELSE
   add  cx,(OFFSET BUF) + XFER_BUF
ENDIF
   jc   $$if1                           ; Error return if buffer too small.
   sub  cbBuf,cx                        ; cbBuf = SP - End of min. buffer.
   jb   $$if1                           ; Error return if buffer too small.
   add  cbBuf,XFER_BUF                 	; cbBuf = Transfer buffer size.
;M011

   call Validate_Target_Drive		; verify target drive is valid	
   jc   $$if1

   call Get_System_Files		; get system files loaded	
   jc   $$if1

   call Check_SYS_Conditions		; verify target drive is SYSable
   jc   $$if1

   call Do_SYS				; perform SYS operation 	
   jc   $$if1

   call Do_End				; clean up loose ends		
   jc   $$if1

   call Copy_Command                    ; copy command.com
   jc   $$if1

   mov  ax,(util_B shl 8) + done

$$IF1:
   push ax				;Save message number		
   mov  ah,DISK_RESET                   ; reset the disks to make sure
                                        ; our writes get flushed out
   int  21h
   pop  ax
   push ax
   call Message 			; display message		
   pop	ax				;Retrieve message number	

   cmp	ax,(util_B shl 8) + done 	;Was it successful ?		
   jne  $$if3

   xor  ax,ax           	 	;  set return code = zero	
   jmp  short   $$en3

$$IF3:
   mov   ax,error_rc	;  set return code = error	     ;AN999;APAR;RussW

$$EN3:
   mov	ah,exit 			; just set function - RC set by MAIN
   int	21h				; if version is < DOS 2.0 the int 21

   ret					; ret if version < 2.00

BEGIN ENDP

; M000 - begin
;**************************************************************************
;Routine name: Copy_Command
;
; Function: Copy command.com onto the target disk.  Search hierarchy for
; command.com is 1) if they specify a source directory for system files,
; look ONLY there.  Else 2) if boot disk == source disk, try the command.
; com specified by comspec.  If there isn't one, or boot disk != source
; then 3) look in the root directory.
;
; Returns carry clear if successful, carry set if not
;
;**************************************************************************
Copy_Command  Proc  Near
public  Copy_Command

; set correct drive in targ_com
	mov	al, TargDrv
	mov	targ_com, al

;M002 - begin
;
; Remove the opposite DOS if present. The opposite DOS are the files
; IBMBIO.COM and IBMDOS.COM for Microsoft compilation and IO.SYS and
; MSDOS.SYS for IBM compilation. Not that command.com is untouched
; but will probably be replaced by Copy_command. This is done after
; the correct DOS files have been copyied but before copying command.com
;
	mov	byte ptr OTHERBIOSName,al
	mov	byte ptr OTHERDOSName,al

	lea	dx,OTHERBIOSName		; first process IBMBIO.COM (IO.SYS)

CC_Process_one_other_DOS:

	mov	ax,(CHMod shl 8)+1		; set attribute
	xor	cx,cx				; to no attribute at all
	int	21h
	jc	CC_one_processed		; if no can do, just to bad
						; (in all likelihood the file
						;  is just not there)

	mov	ah,Unlink			; Delete file
	int	21h				; no error check

CC_one_processed:
	lea	ax,OTHERDOSName			; get address of IBMDOS.COM (MSDOS.SYS)
	cmp	ax,dx				; is it the one we just processed?
	jz	CC_Other_DOS_removed		;    if so we're done
	mov	dx,ax				;    if not let's go do it
	jmp	SHORT CC_Process_one_other_DOS

CC_Other_DOS_removed:

;M002 - end

find_source:
; if user specified a source directory for system files, we look for
; command.com there and only there
	test	Spec_Flag, 1
	jz 	try_comspec

; copy the source path into SourceCommandName
	mov	si,  OFFSET SourceSpec
	mov	di,  OFFSET SourceCommandName
	xor	al,  al
	call	string_len
	push 	cx
	rep	movsb

; backtrack to the '\', since tail end of SourceSpec is "io.sys".  now
; di is positioned so "command.com" gets copied over "io.sys"
	std
	mov 	al,  '\'
	pop	cx
	inc	cx			; in case we have to go all the way
					;    to start of string
ifdef DBCS
	push	bx
	lea	bx,SourceCommandName
@@:
	repne	scasb
	jcxz	@f
	push	di
	inc	di
	call	CheckDBCSTailByte
	pop	di
	jz	@b
@@:
	pop	bx
else
	repne	scasb
endif
	cld
	inc	di
	jmp	short  add_com_to_source

try_comspec:
; if the source disk == boot disk, we try to find command.com based on
; comspec.  if this fails we will look for command.com in the root directory
; of the source drive

; see if the source disk == boot disk
	mov 	ax, 3305h
	int 	21h
	jc	look_in_root

	cmp	dl,  defalt
	jne	look_in_root

;M009
; get the path COMSPEC points to
 	mov	es, old_psp
	mov	es, es:[002ch]   		; get ENV seg ptr
	call	Find_Comspec_in_Environment	; es:di -> first byte after
						;    the "COMSPEC="
	jc	look_in_root                    ; Jump if no COMSPEC found.

	push	ds				; Save ds.
        push    di                              ; es:di -> COMSPEC string.

; verify that COMSPEC specifies "COMMAND.COM".

        push    ds                              ; Exchange ds, es.
        push    es
        pop     ds
        pop     es

        mov	si,di				; ds:si -> COMSPEC string.
        xor     al,al                           ; NULL terminator char.
        call    string_len                      ; cx = COMSPEC string len.
        push    cx
        sub     cx,LEN_COMMAND_STRING-1
        jae	cc120	                  	; Jump if COMSPEC long enough.

cc100:  pop     cx                              ; Restore ds; don't care di,cx.
        pop     di
        pop     ds
        jmp     short look_in_root              ; COMSPEC is not COMMAND.COM.

cc120:  add     si,cx                           ; ds:si -> first character of
                                                ;  string to verify.
	mov     di,OFFSET command_string
        inc     di                              ; es:di -> "command.com",0
        mov     cx,LEN_COMMAND_STRING-2         ; Ignore '\' and NULL.

; Perform case insensitive compare of string at es:[di] ("command.com",0) to
; string at ds:[si] (COMSPEC).

cc140:	mov     al,es:[di]
        sub     al,ds:[si]
        je      cc160                           ; Jump if match.
        jb      cc100                           ; Jump if match failed (since
                                                ;  lower case > upper case).
        cmp     al,'a'-'A'                      ; Upper case?
        jne     cc100                           ;  No, jump: match failed.
cc160:  inc     si                              ; Setup for next character.
        inc     di
        loop    cc140                           ; Fall thru if string matches.

; Copy the COMSPEC string to SourceCommandName.

        pop     cx                              ; cx = COMSPEC string length.
	pop	si                              ; ds:si -> COMSPEC string.
	mov 	di, OFFSET SourceCommandName    ; es:di -> dest. for string.
	rep  	movsb
;M009
	pop	ds				; restore ds
	mov	trying_comspec, TRUE
	jmp	short  	find_com

look_in_root:
	push	ds				; set es == ds
	pop	es
	mov  	di, OFFSET SourceCommandName

add_com_to_source:
; add the string "\command.com" to tail of SourceCommandName
	mov	si,  OFFSET command_string		
	cmp  	byte ptr [di],  '\'		; if path already has '\'
	jne  	add_slash		
	inc  	si				;    set SI -> "command.com"
	inc  	di

add_slash:
	xor  	al,  al
	call 	string_len
	rep  	movsb				; now add command.com to
						;  SourceCommandName

; Now try to find COMMAND.COM in the correct directory
find_com:
	mov   	dx, OFFSET SourceCommandName
	xor   	cx, cx
	mov   	ah, 4eh
	int   	21h
	jnc   	go_read
	cmp	trying_comspec, TRUE
	mov	trying_comspec, FALSE
	je	look_in_root
	jmp   	print_errmsg

;M003 - begin
go_read:
	mov	ax, 3d00h
	mov	dx, OFFSET SourceCommandName
	int	21h
	mov	rdhndle, ax
	jnc	read_more
	jmp	print_errmsg

; open the target file for writing

; while (there are more bytes to transfer)
;   read in as much as we can and write it out
read_more:
	mov	ah, 3fh
	mov	bx, rdhndle
	mov	cx, cbBuf
	mov	dx, (OFFSET BUF)
	int	21h
	jc	close_read
	cmp	ax, cx
	je	dont_flag
	mov	lastround, TRUE

dont_flag:
	cmp	wthndle,-1
	jnz	got_write_handle

	push	ax
;
; before we create the new command.com file, get its current attribute set,
; so we can restore it later, and also clear any read-only attribute.
;
        mov     ax, 4300h                       ; get attribute
        mov     dx, OFFSET targ_com
        int     21h
        jc      clear_attr                      ; don't save if error
        mov     TargAttr, cx                    ; save current attribute

clear_attr:
        mov     ax, 4301h                       ; set new attribute
        xor     cx,cx                           ; normal file, writable
        int     21h

	mov	ah, 3ch
	xor	cx, cx
	mov	dx, OFFSET targ_com
	int	21h
	mov	wthndle, ax
	pop	ax
	mov	dx, (OFFSET BUF)
	jc	close_read

got_write_handle:
	mov	cx, ax
	mov	ah, 40h
	mov	bx, wthndle
	int	21h
	jc	close_write
	cmp	ax,cx
	stc
	jne	close_write

no_prob:
	cmp	lastround, TRUE
	jne 	read_more

; set the date & time stamps of target command.com == source
	mov	ax,  5700h
	mov	bx,  rdhndle
	int	21h
	jc	no_date_and_time
	mov	al,  1
	mov	bx,  wthndle
	int	21h

no_date_and_time:
	clc				; we will later test for carry,
					; but if carry was set in date&time
					; stuff, it doesn't count, clear it
; close the file handles
close_write:
	pushf				; first save flags so we can
					;  tell if there was previous error
	mov	ah, 3eh
	mov	bx, wthndle
	int	21h
	popf

close_read:
	pushf				; first save flags so we can
					;  tell if there was previous error
	mov	ah, 3eh
	mov	bx, rdhndle
	int	21h
;
; reset original attributes of command.com
;
        mov     ax, 4301h               ; set attributes
        mov     cx, TargAttr
        mov     dx, OFFSET targ_com
        int     21h

	popf

	jnc	alldone

;M003 - end
	
; there was a previous problem, so delete <target>:\command.com
; turn off that read-only attribute we just set first

        mov     ax,4301h
        xor     cx,cx
        mov     dx,OFFSET targ_com
        int     21h

	mov	ah,  4eh
	xor	cx,  cx
	int	21h
	jc	print_errmsg 			; it never got created

	mov	ah, 41h
	int	21h

print_errmsg:
        mov     ax,(util_B shl 8) + CMD_NOT_PROCESSED
        stc                                     ; signal error

alldone:
	ret

Copy_Command  endp

;***************************************************************************
; string_len expects ds:si to point to the desired string, and al to contain
; the desired terminator character.  it returns the length of the string
; INCLUDING a terminating NUL.
;***************************************************************************
string_len 	proc	near

; save es:di because we  trash them
	push	es
	push	di

; set es:di = ds:si
	push	ds
	pop	es
	mov	di, si	

; find the terminator character somewhere in the first 256 bytes
	mov	cx, 100h
	repne	scasb
	jne	finis

; set CX equal to string length
	sub	cx, 100h
	neg	cx
	
finis:	pop	di
	pop	es
	ret

string_len	endp


   BREAK <SYS - Init_Input_Output >
;******************* START OF SPECIFICATIONS ***********************************
;Routine name: Init_Input_Output
;*******************************************************************************
;
;Description: Initialize messages and Parse command line.
;
;Called Procedures: Preload_Messages
;		    Parse_Command_Line
;
;Input: PSP command line at 81h and length at 80h
;
;Output: no error  - CF = 0	  AX = 0
;	    error  - CF = 1	  AX = return code (message #)
;
;Change History: Created	5/01/87 	FG
;
;******************* END OF SPECIFICATIONS *************************************
;******************+ START OF PSEUDOCODE +**************************************
;
;	START  Init_Input_Output
;
;	load messages (CALL Preload_Messages)
;	if no error
;	    get DOS version
;	    if not = current and
;	    set not current flag
;	    if not = current - 1
;		load incorrect DOS version message
;		set fail flag
;	    else
;		if no error and
;			parse the saved command line (CALL Parse_Command_Line)
;		if no error
;			load return code (success)
;		endif
;	    endif
;	endif
;	ret
;
;	END  Init_Input_Output
;
;******************-  END  OF PSEUDOCODE -**************************************

public Init_Input_Output

   Init_Input_Output PROC NEAR

command_line		  equ	 081H	; offset of command line in PSP    ;C00

       call SysLoadMsg			; preload all error messages	       ;AN000;

                			; if error  - set to Utility	       ;AN000;
       JNC    $$IF6
       mov  ah,0bh		        ;				       ;AN000;
       JMP SHORT $$EN6
$$IF6:
       mov  ax,(GET_VERSION shl 8)      ;				       ;AN019;
       int  21h 		        ;				       ;AN019;
       xchg al,ah		        ;				       ;AN019;
       cmp  ax,(major_version shl 8) + minor_version ;			       ;AN019;
       je   $$EN10

$$IF10:
       mov ax,(util shl 8) + DOS_error ;				       ;AN019;
       stc				;				       ;AN019;
$$EN10:
                  			; no error and			       ;AN000;
       JC $$IF15
       xor  cx,cx			; zero out # of parms processed so far ;AN000;
       mov  si,command_line		; move here to loop thru twice	       ;AN000;
       call Parse_Command_Line		; parse the saved command line	       ;AN000;
              				; no error			       ;AN000;
       JC $$IF15
       mov al,noerror	        	; load return code (success)	       ;AN000;

$$IF15:
$$EN6:
       ret					;				       ;AN000;

   ENDPROC Init_Input_Output

   BREAK <SYS - Parse_Command_Line >
;******************* START OF SPECIFICATIONS ***********************************
;Routine name: Parse_Command_Line
;*******************************************************************************
;
;Description: Parse the command line. Check for errors, loading return code and
;	      setting fail flag if found. Use parse error messages except in
;	      case of no parameters, which has its own message.
;
;Called Procedures: SysParse
;
;Input: None
;
;Output: no error - CF = 0
;	    error - CF = 1	  AX = return code (Parse error + error #)
;
;Change History: Created	5/01/87 	FG
;
;******************* END OF SPECIFICATIONS *************************************
;******************+ START OF PSEUDOCODE +**************************************
;
;	START  Parse_Command_Line
;
;	parse command line (Call Do_Parse)
;	if parse error
;		call GetError to find out what happened
;		(fail flag set)
;	else
;		if filespec found
;			set up to move filespec into SourceBIOSName
;			call Move_It to do the move
;			save size of filespec
;			set source spec flag
;		else
;			call Set_Target to process drive id (only other non error
;		endif
;		turn off filespec as valid input
;		if first parm was NOT a filespec (ie a drive id)
;			turn on optional bit
;		else
;			force required parms to 2
;		endif
;		call Do_Parse
;		if no errors
;			call Set_Target to initialize drive id
;			call Do_Parse to look for EOF or error
;			if eol
;				clear error flag
;			else
;				call Get_Error to see what went wrong
;			endif
;		else
;			if not EOL
;				call Get_Error to see what went wrong
;			else
;				clear error flag
;			endif
;		endif
;	endif
;
;	ret
;
;	END  Parse_Command_Line
;
;******************-  END  OF PSEUDOCODE -**************************************

public Parse_Command_Line

   Parse_Command_Line PROC NEAR
					;---------------------------------------
					; Parse Equates
					;---------------------------------------
eol			  equ	 -1	; Indicator for End-Of-Line	       ;AN000;
noerror 		  equ	 0	; Return Indicator for No Errors       ;AN000;
command_line		  equ	 081H	; offset of command line in PSP        ;AN000;
Syntax_Error		  equ	 9	; PARSE syntax error		       ;AN000;
					;---------------------------------------
					;  Get address of command line
					;---------------------------------------
   push ds				;				       ;AN000;
   pop	es				;				       ;AN000;
   lea	di,PARMS			;				       ;AC021:
   call Do_Parse			;				       ;AC021:
   cmp	ax,0				; did we find our required parm?       ;AN000;
   je   $$if18

   call Get_Error			;				       ;AC021;
   jmp  short  $$en18

$$IF18:
   cmp  POS_TYPE,5			; is it a file spec?		       ;AN021;
   jne  $$if20				; if not, skip this

   push ds				; copy spec into source 	       ;AN021;
   push di				;				       ;AN021;
   push si				;				       ;AN021;
   lea	di,SourceSpec			;				       ;AN021;
   mov	si,word ptr POS_OFF		;				       ;AN021;
   mov	ax,POS_SEG			;				       ;AN021;
   mov	ds,ax				;				       ;AN021;

   ASSUME ds:nothing,es:DATA
   xor	bx,bx				;				       ;AN021;
   call Move_Source			;				       ;AN021;
   pop	si				;				       ;AN021;
   pop	di				;				       ;AN021;
   pop	ds				;				       ;AN021;

   ASSUME ds:DATA,es:nothing
   mov	SourceSize,bx			;				       ;AN021;
   mov	Spec_Flag,1			; set spec flag 		       ;AN021;
   jmp  short  $$en20

$$IF20:
   call Set_Target			; initialize target just in case       ;AN021;
   mov	SourceSpec,al			; save Source Spec		       ;AN000;
					; remember that the colon and size
$$EN20:
   and  POSTYP,drv_id			; off filespec bit - on drive bit      ;AN021;
   cmp  Spec_Flag,0 			; do we have a source spec ?	       ;AN021;
   jne  $$if23

   inc	POSREP				; turn on optional		       ;AN021;
   jmp  short  $$en23

$$IF23:
   inc	PAR_MIN 			; must have the second parm.	       ;AN021;
$$EN23:
   call Do_Parse			;				       ;AN021;
   cmp  ax,0				; no parse errors?		       ;AN000;
   jne  $$if26
	
   call Set_Target			; initialize target		       ;AN021;
   cmp	Spec_Flag,0			; do we have a source spec ?	       ;AN021;
   jne  $$if27
	
   inc  Spec_Flag			; turn it on			       ;AN021;

$$IF27:
   call Do_Parse			; make sure there are no extra parms.  ;AN021;
   cmp	ax,eol				;				       ;AN021;
   jne  $$if29
	
   clc					;				       ;AN021;
   jmp  short  $$en29

$$IF29:
   call Get_Error			;				       ;AN021;
$$EN29:
   jmp  short  $$en26
$$IF26:
   cmp	ax,eol				; is it EOL ?			       ;AN021;
   je   $$if33

   call Get_Error			; error - make sure it makes sense     ;AN021;
   jmp  short  $$en33
$$IF33:
   clc					;				       ;AN021;
$$EN33:
$$EN26:
$$EN18:

   ret					;				       ;AN000;


public Move_Source
   Move_Source PROC NEAR
ifdef DBCS
	mov	dx,di			; save start address
endif
;  $search				;				       ;AN021;
$$DO38:
       lodsb				;				       ;AN021;
       stosb				;				       ;AN021;
       inc  bl				;				       ;AN021;
       cmp  bl,67			; are we past the maximum?	   ;C03
;  $exitif a				;				       ;AN021;
   JNA $$IF38
       mov  ax,(util_B SHL 8) + bad_path ; Invalid path 		       ;AN021;
       stc				;				       ;AN021;
;  $orelse				;				       ;AN021;
   JMP SHORT $$SR38
$$IF38:
       or   al,al			;				       ;AN021;
;  $endloop z				;				       ;AN021;
   JNZ $$DO38
       dec  bl				;				       ;AN021;

ifdef DBCS
	cmp	byte ptr es:[di-2],"\"
	jnz	@f			; if no '\'
	push	bx
	push	di
	mov	bx,dx			; set the start address
	sub	di,2
	call	CheckDBCSTailByte
	pop	di
	pop	bx
	jnz	yes_backslash		; if this is not tail byte
@@:
else
       cmp  byte ptr es:[di-2],"\"      ;Q: Ending backslash?              ;C01
       je   yes_backslash		; Y: Then exit			   ;C01
endif
       mov  byte ptr es:[di-1],"\"      ; N: Add one                       ;C01
       mov  byte ptr es:[di],0		;    replace zero		   ;C01
       inc  bl				;    One byte larger		   ;C01
yes_backslash:				;				   ;C01
       clc				;				       ;AN021;
;  $endsrch				;				       ;AN021;
$$SR38:

   ret					;				       ;AN021;

   ENDPROC Move_Source

   Do_Parse PROC NEAR

   mov	insert_ptr_off,si		; save it in case of error	       ;AN024;
   push cs				;				       ;AN000;
   pop	ds				;				       ;AN000;
   xor	dx,dx				;				       ;AN021;

   ASSUME ds:nothing,es:DATA

   call SysParse			; parse command line		       ;AN000;

   push es				;				       ;AN000;
   pop	ds				;				       ;AN000;

   ASSUME ds:DATA,es:nothing

   call Check_Options_Exit		; may not return...

   ret					;				       ;AN021;

   ENDPROC Do_Parse

   Set_Target PROC NEAR

   mov	al,byte ptr pos_drv_id		; initalize drive id		       ;AN000;
   mov	TargDrvNum,al			; save it for later		       ;AN000;
   mov	ExtFCB_Drive,al 		; save it for finding VOL id	       ;AN000;
   or	al,num_2_letter 		; convert to a drive letter	       ;AC000;
   mov	TargSpec,al			; save it for later		       ;AN000;
   mov	TargDrv,al			;				       ;AC000;
   ret					;				       ;AN021;

   ENDPROC Set_Target

   Get_Error PROC NEAR

   lea	bx,Parse_Ret_Code		; error - make sure it makes sense     ;AN000;
   xlat cs:[bx] 			;				       ;AN000;
   mov	ah,parse_error			; indicate parse error CLASS	       ;AN000;
   stc					; set fail flag 		       ;AN000;
   ret					;				       ;AN021;

   ENDPROC Get_Error

Parse_Ret_Code label byte

   db	0				; Ret Code 0 -			       ;AN000;
   db	1				; Ret Code 1 - Too many operands       ;AN000;
   db	2				; Ret Code 2 - Required operand missing;AC002;
   db	9				; Ret Code 3 - Not in switch list provided ;AC002;
   db	9				; Ret Code 4 - Not in keyword list provided;AC002;
   db	9				; Ret Code 5 - (not used)	       ;AN000;
   db	9				; Ret Code 6 - Out of range specified  ;AN000;
   db	9				; Ret Code 7 - Not in value list provided
   db	9				; Ret Code 8 - Not in string list provided
   db	9				; Ret Code 9 - Syntax error

   ENDPROC Parse_Command_Line

   BREAK <SYS - Check_Options_Exit >
;******************* START OF SPECIFICATIONS ***********************************
;Routine name: Check_Options_Exit
;*******************************************************************************
;
;Description: Check to see if the parser has just found "/?" on the
;             command line.  If so, display the options help message
;             lines, and exit so the user may try again.
;
;Called Procedures: SysDispMsg
;
;Input: SW_SYN may have been set by the parser
;
;Output: no /? - flags modified, returns to caller
;	 /?    - displays message lines and exits - does not return
;
;Change History: Created	5/01/89 	c-PaulB
;
;******************* END OF SPECIFICATIONS *************************************

public Check_Options_Exit

Check_Options_Exit PROC NEAR

	; See if /? was matched by parser
	; return now if not

	cmp	[SW_SYN], offset SW1_SYN	; was /? specified?
	jne	COE_Return			;  back to caller if not

	; Display the options help message lines.

	mov	ax, MSG_OPTIONS_FIRST		; message to display
	mov	bx, STDOUT			; output handle
	mov	cx, 0				; no substitutions
	mov	dh, UTILITY_MSG_CLASS		; message class
	mov	dl, NO_INPUT			; no input wanted
	mov	si, 0				; no substitution list
COE_Disp_Loop:
	call	SysDispMsg			; display the message
	cmp	ax, MSG_OPTIONS_LAST		; last message?
	je	COE_Disp_Done			;  we're done if so
	inc	ax				; else get next msg
	jmp	short COE_Disp_Loop		;  and go do it
COE_Disp_Done:

	; Exit so the user can try again.

	mov	ax, (exit SHL 8)		; exit function, clear ret code
	int	21h				;  we're outta here!

COE_Return:
	ret

ENDPROC Check_Options_Exit


   BREAK <SYS - Validate_Target_Drive >
;******************* START OF SPECIFICATIONS ***********************************
;Routine name: Validate_Target_Drive
;*******************************************************************************
;
;Description: Verify that target drive was specified, is not default drive,
;	      is a valid drive letter, and is not a network drive
;
;Called Procedures: Check_Default_Drive
;		    Check_Target_Drive
;		    Check_For_Network
;
;Input: None
;
;Output: no error  - CF = 0	  AX = 0
;	    error  - CF = 1	  AX = return code (message #)
;
;Change History: Created	5/01/87 	FG
;
;******************* END OF SPECIFICATIONS *************************************
;******************+ START OF PSEUDOCODE +**************************************
;
;	START  Validate_Target_Drive
;
;	can't have target as default (CALL Check_Default_Drive)
;	if no error and
;		can't have target as network (CALL Check_For_Network)
;	if no error
;		see if valid drive letter (CALL Check_Target_Drive)
;	ret
;
;	END  Validate_Target_Drive
;
;******************-  END  OF PSEUDOCODE -**************************************

public Validate_Target_Drive

   Validate_Target_Drive PROC NEAR

   call Check_Default_Drive		; can't have target as default         ;AN000;

;  $if	nc,and				; no error and			       ;AN000;
   JC $$IF43

   call Check_For_Network		; can't have target as network         ;AC022;

;  $if	nc				; no error			       ;AN000;
   JC $$IF43

       call Check_Target_Drive		; see if valid drive letter	       ;AC022;

IFDEF DBLSPACE_HOOKS
;; a-emoryh: Running SYS on a DblSpace drive is dangerous, so i'm leaving
;;           this check in.
ENDIF

;; IFDEF DBLSPACE_HOOKS
       jc $$IF43

	; SYS to a DblSpace Compressed Volume File is not supported,
	; so check if that's what the user has requested.

	push	ax
	mov	al, TargDrvNum		; 1 based target drive
	dec	al			;   to 0 based
	call	Get_Host_Drive		; host will != target if CVF
	inc	al			; 1 based
	cmp	al, TargDrvNum		; trying to SYS a CVF?
	pop	ax
	je	$$IF43			;   no, return with CY clear

	mov	ax,(util_B shl 8) + cant_sys_target  ; indicate error
	stc
;; ENDIF

;  $endif				;				       ;AN000;
$$IF43:

   ret					;				       ;AN000;

   ENDPROC Validate_Target_Drive

   BREAK <SYS - Check_Default_Drive >
;******************* START OF SPECIFICATIONS ***********************************
;Routine name: Check_Default_Drive
;*******************************************************************************
;
;Description: Check to see if drive specified is default drive. If it is,
;	      load return code and set fail flag.  Initialize source names
;             for IO.SYS, MSDOS.SYS, and DBLSPACE.BIN.
;
;Called Procedures: None
;
;Input: None
;
;Output: no error - CF = 0
;	    error - CF = 1	AX = 16d - Can not specify default drive
;
;Change History: Created	5/01/87 	FG
;Change History: Ax021		2/22/88 	FG
;                               11/17/92        MD Added Dblspace support
;
;******************* END OF SPECIFICATIONS *************************************

public Check_Default_Drive

   Check_Default_Drive PROC NEAR
   push ds
   pop	es

   ASSUME DS:DATA,ES:DATA

   cmp	Spec_Flag,1			; was a source specified ?	       ;AN021;
                			; if a source was specified	       ;AN021;
   JNE $$IF45
;
; we have source specifier, check that it isn't same as target
;
   mov  si,offset SourceSpec	        ; point to Source Spec		   ;C04
   mov  di,offset DIR_SECTOR	        ; point at output buffer	   ;C05
   mov  ax,(xNameTrans SHL 8)	        ; check for name translation	   ;C05
   int  21h 			        ; get real path 		   ;C05
   mov  si,offset DIR_SECTOR	        ; pointer to source path	   ;C05
   mov  di,offset TargSpec		; pointer to target path	   ;C04
   mov  cx,4			        ; 3 chars in target path + zero    ;C04
   repz cmpsb			        ; compare source and target	   ;C04
               				; If equal - we have a problem	   ;C04
   JNZ $$IF46
;
; Source == target, report error
;
   mov	ax,(util_B shl 8) + src_targ_same  ; load return code	   ;C04
   stc				        ; indicate error		   ;C04
   JMP $$IF54
;
; Source != target, so get base path into source names.  Note that SourceSpec
; is part of the SourceBIOSName field, so we don't need to initialize
; SourceBIOSName with SourceSpec
;
$$IF46:
   lea	si,SourceSpec		        ; copy source for IBMDOS.COM	       ;AN021;
   mov	al,[si] 		        ; get the drive ID		       ;AN025;
   sub	al,num_2_letter 	        ; convert it to a 1 base number        ;AN025;
   mov	DEFALT,al		        ; save it in case its removable        ;AN025;
   lea	di,SourceDOSName	        ;				       ;AN021;
   mov	cx,SourceSize		        ; set up size to move		       ;AN021;
   rep	movsb			        ; move it!

IFDEF DBLSPACE_HOOKS
   lea  si,SourceSpec                   ; copy source for dblspace.bin
   lea  di,SourceDblSpaceName
   mov  cx,SourceSize
   rep  movsb
ENDIF

   JMP SHORT $$EN45                     ; now go compose source BIOS name
;
; No source specified on command line, so figure out default source location
; If default source is a double-spaced drive, locate the host drive, and
; use it instead.
;
$$IF45:

   mov  ax,(Get_Default_Drive shl 8) + not_used ; get_default_drive
   INT  21h 			        ;   Get_Default_Drive  <1900>
   call Get_Host_Drive                  ; translate to Dblspace Host drive
   inc  al				; turn from phys drive to logical drive
   mov  DEFALT,al			; save default for later
   mov  SourceSpec,al
   or   SourceSpec,num_2_letter	        ; covert number to letter
   mov  si,offset SourceSpec	        ; point to source spec		   ;C05
   mov  di,offset DIR_SECTOR	        ; point at output buffer	   ;C05
   mov  ax,(xNameTrans SHL 8)	        ; check for name translation	   ;C05
   int  21h 			        ; get real path 		   ;C05
   mov  al,byte ptr DIR_SECTOR	        ; get real drive		   ;C05
   sub  al,num_2_letter		        ; convert it to a 1 base number    ;C05
   cmp  al,TargDrvNum		        ; is target drive = default drive
        				; if it is the same - we have a problem;AC000;
   JNE $$IF50

   mov	ax,(util_B shl 8) + not_on_default ; load return code
   			                ;      - Can not specify default drive
   stc				        ; set fail flag
   JMP SHORT $$IF54                     ; go report error
;
; We've now determined the correct default source path.  Set up the source names
;
$$IF50:
					; initalize SourceBIOSNane, SourceDOSName
   mov	al,DEFALT
   or	al,num_2_letter 	        ; turn into letter
   mov	byte ptr SourceBIOSName,AL      ; twiddle source name
   mov	SourceDOSName,AL	        ; twiddle source name
IFDEF DBLSPACE_HOOKS
   mov  SourceDblSpaceName,AL
ENDIF

$$EN45:
   cld				
   IF   IBMCOPYRIGHT
   mov  bx,NameLen		
   mov  cx,bx			
   ELSE
   mov  cx,BIOSNameLen
   ENDIF

   lea  di,SourceBiosName		; move IBMBIO.COM into place	       ;AN021;
   add  di,SourceSize		        ; move to end of specified part        ;AN021;
   lea  si,SourceBIOS		        ; point to system file name	       ;AN021;
   rep  movsb			

   IF   IBMCOPYRIGHT
   mov  cx,bx			
   ELSE
   mov  cx,DosNameLen
   ENDIF

   lea  di,SourceDOSName		; move IBMDOS.COM into place	       ;AN021;
   add  di,SourceSize		        ; move to end of specified part        ;AN021;
   lea  si,SourceDOS		        ; point to system file name	       ;AN021;
   rep  movsb			        ;				       ;AN021;

IFDEF DBLSPACE_HOOKS
   mov  cx,DblSpaceNameLen
   lea  di,SourceDblSpaceName           ; move DBLSPACE.BIN into place
   add  di,SourceSize
   lea  si,SourceDblSpace
   rep  movsb
ENDIF

$$IF54:
   ret

   ENDPROC Check_Default_Drive


   BREAK <SYS - Get_Host_Drive >
;******************* START OF SPECIFICATIONS ***********************************
;Routine name: Get_Host_Drive
;*******************************************************************************
;
;Description: Given a drive number in AL, check to see if it is a dblspace
;             drive, and if so, translate the drive number to the host
;             drive number.
;
;Called Procedures: None
;
;Input: 0-based drive number in AL
;
;Output: drive number in AL
;
;Change History: Created       11/21/92         MD
;
;******************* END OF SPECIFICATIONS *************************************

public Get_Host_Drive

   Get_Host_Drive PROC NEAR

        push    ax
   	mov	ax,4a11h	; DBLSPACE multiplex number
	xor	bx,bx		; inquire version number
	int	2fh
	or	ax,ax		; error?
	jnz	not_dblspace
	cmp	bx,'DM'		; stamp returned correctly?
	jnz	not_dblspace

;	DBLSPACE.BIN is loaded.  At this time:
;
;	(dx & 0x7fff) == driver internal version number
;	high bit of DH set of driver has not yet been permanently placed
;	cl == first disk letter reserved for DBLSPACE
;	ch == number of disk letters reserved for DBLSPACE

	mov	ax,4a11h	; DBLSPACE multiplex number
	mov	bx,1		; inquire drive map
        pop     dx
        push    dx
	int	2fh
	test	bl,80h		; COMPRESSED bit true?
	jz	not_dblspace

;	Drive is compressed.  At this time:
;
;	(bl & 0x7f) == host drive's CURRENT drive number
;	bh          == CVF extension number
;
        mov     al,bl
        and     al,7Fh
        cbw
        pop     dx
        push    ax

not_dblspace:
        pop     ax
        ret

    ENDPROC Get_Host_Drive

   BREAK <SYS - Check_Target_Drive >
;******************* START OF SPECIFICATIONS ***********************************
;Routine name: Check_Target_Drive
;*******************************************************************************
;
;Description: Determine if target drive is valid. To do this, we will make an
;	      IOCTL - check media ID call.
;
;Called Procedures:
;
;Input:  Default_Drive
;
;Output: no error - CF = 0
;	    error - CF = 1	  AX = 16d - Can not specify default drive
;
;Change History: Created	5/01/87 	FG
;
;******************* END OF SPECIFICATIONS *************************************
;******************+ START OF PSEUDOCODE +**************************************
;
;	START  Check_Target_Drive
;
;	Check media ID (INT21 IOCTL + IOCTL_CHANGEABLE? <4408>)
;	if no error
;		if invalid drive
;			set return code
;			set fail flag
;		else
;			clear fail flag
;	else
;		reset fail flag
;	endif
;	if no error
;		if ASSIGNed or SUBSTd drive
;			set return code
;			set fail flag
;		else
;			clear fail flag
;	else
;		reset fail flag
;	endif
;	ret
;
;	END  Check_Target_Drive
;
;******************-  END  OF PSEUDOCODE -**************************************

public Check_Target_Drive

   Check_Target_Drive PROC NEAR

   mov	bl,TargDrvNum			; get the target drive number	       ;AN000;
   mov	ax,(IOCTL SHL 8) + IOCTL_CHANGEABLE? ; do a media check 	       ;AC000;
   INT	21h				;	  IOCtl + 08 <4408>	       ;AC000;

   cmp	ax,0fh				; is it invalid - al = F (CF may be set;AC000;

;  $if	e				;				       ;AC000;
   JNE $$IF56

       mov  ax,(DOS_error shl 8) + extended_15 ; load return code	       ;AC000;
					;		- invalid drive
       stc				;				       ;AC000;

;  $else				; if valid device so far - make sure   ;AN012;
   JMP SHORT $$EN56
$$IF56:
					; its not ASSIGNed or SUBSTed drive
       mov  si,offset TargSpec		; point to Target Spec		       ;AN012;
       mov  di,offset DIR_SECTOR	; point at output buffer	       ;AN012;
       mov  ax,(xNameTrans SHL 8)	; check for name translation	       ;AN012;
       int  21h 			; get real path 		       ;AN012;
;      $if  nc				;				       ;AC012;
       JC $$IF58
	   mov	bl,byte ptr [TargSpec]	; get drive letter from path	       ;AN012;
	   cmp	bl,byte ptr DIR_SECTOR	; did drive letter change?	       ;AN012;
;	   $if	ne			; if not the same, it be bad	       ;AN012;
	   JE $$IF59
	       lea  si,sys_ptr		; set insert pointer in SUBLIST        ;AN012;
	       mov  [insert_ptr_off],si ;				       ;AN012;
	       mov  [insert_ptr_seg],ds ;				       ;AN012;
	       lea  si,sublist		; set pointer to SUBLIST	       ;AN012;
	       mov  ax,(util_C shl 8) + cant_assign ; load ret cd (Cannot..SUB);AN012;
	       stc			; tell user			       ;AN012;
;	   $else			; - its ok			       ;AN012;
	   JMP SHORT $$EN59
$$IF59:
	       clc			; keep going			       ;AN012;
;	   $endif			;				       ;AN012;
$$EN59:
;      $else				; - its a critical error	       ;AN012;
       JMP SHORT $$EN58
$$IF58:
	   xor	ah,ah			; set up for extended error call       ;AN012;
	   inc	ah			;				       ;AN012;
;      $endif				;				       ;AN012;
$$EN58:
;  $endif				;				       ;AN012;
$$EN56:

   ret					;				       ;AC000;

   ENDPROC Check_Target_Drive

   BREAK <SYS - Check_For_Network >
;******************* START OF SPECIFICATIONS ***********************************
;Routine name: Check_For_Network
;*******************************************************************************
;
;Description: Verify that the target drive is local, and not a shared drive.
;	      If shared,load return code and set fail flag.
;
;	      NOTE: This is a design point on how to determine net
;
;CALLed Procedures: None
;
;Input:  None
;
;Output: no error - CF = 0
;	    error - CF = 1	  AX = return code = 7 - Cannot SYS to a Network drive
;
;Change History: Created	5/01/87 	FG
;
;******************* END OF SPECIFICATIONS *************************************
;******************+ START OF PSEUDOCODE +**************************************
;
;	START  Check_For_Network
;
;	IOCtl call to see if target drive is local
;	if target drive not local (INT21 IOCtl + 09 <4409>) and
;	if return code indicates network drive (test 1200h)
;		set insert pointer in SUBLIST
;		set pointer to SUBLIST
;		load return code (Cannot SYS to a Network drive)
;		set fail flag
;	else
;		reset fail flag
;	endif
;	ret
;
;	END  Check_For_Network
;
;******************-  END  OF PSEUDOCODE -**************************************

public Check_For_Network

   Check_For_Network PROC NEAR

					; IOCtl call to see if target drive is local
   mov	bl,TargDrvNum			;   x = IOCTL (getdrive, Drive+1)      ;AC022;
   mov	ax,(IOCTL SHL 8) + dev_local
   INT	21h				; IOCtl + dev_local  <4409>

;  $if	nc,and				; target drive local and	       ;AC000;
   JC $$IF65

   test dx,1200H			; check if (x & 0x1000)
					;      (redirected or shared)
;  $if	nz				; return code indicates network drive  ;AC000;
   JZ $$IF65

       lea  si,sys_ptr			; set insert pointer in SUBLIST        ;AN000;
       mov  [insert_ptr_off],si 	;				       ;AN000;
       mov  [insert_ptr_seg],ds 	;				       ;AN000;
       lea  si,sublist			; set pointer to SUBLIST	       ;AN000;
       mov  ax,(util_C shl 8) + cant_network ; load return code (Cannot SYS to.;AC000;
       stc				; set fail flag 		       ;AN000;

;  $else				;				       ;AC000;
   JMP SHORT $$EN65
$$IF65:

       clc				; reset fail flag		       ;AC000;

;  $endif				;				       ;AC000;
$$EN65:

   ret					;				       ;AN000;

   ENDPROC Check_For_Network

   BREAK <SYS - Get_System_Files >
;******************* START OF SPECIFICATIONS ***********************************
;Routine name: Get_System_Files
;*******************************************************************************
;
;Description:	    Ensure that the the files IBMBIO, IBMDOS and DBLSPACE.BIN
;                   are available
;		    on the source media. If they are not on the source media,
;		    and the media is removeable, a prompt will be issued to
;		    insert a new source.
;
;Called Procedures: Prompt_For_Media	       Open_File
;		    Check_Removable	       Fill_Memory
;
;Input: 	    IBMBIO, IBMDOS, and DBLSPACE.BIN on source media
;
;Output: no error - CF = 0
;	    error - CF = 1	  AX = return code (message #)
;
;Change History:    Created	   5/01/87	   FG
;		    Major change   1/07/88	   FG	Ax019 now makes SYS check
;							for the CORRECT version
;							of IBMBIO !
;							IBMBIO looks like this:
;				       1	2	 3	  4	  5
;				  
;				    JMP      LO   	HI   extected_version
;				  
;
;                                  11/17/92        MD   Added support for
;                                                       DBLSPACE.BIN
;******************* END OF SPECIFICATIONS *************************************

public Get_System_Files

        Get_System_Files PROC NEAR
        cld

$$DO68:
        lea  si,DOS_BUFFER		; set up addressability
;
; Find and open BIOS file
;
        mov  dx,OFFSET SourceBIOSName	; look on source for IBMBIOS
        mov  di,OFFSET BIOSInFH		; pointer to block of data
        call Open_File			; open file
        JC   $$IF69                     ; jump on open error
;
; Now find and open DOS file
;
        mov  dx,OFFSET SourceDOSName	; look on source for IBMDOS
        mov  di,OFFSET DOSInFH		; pointer to block of data
        call Open_File			; open file
        JC   $$IF69                     ; jump on open error


IFDEF DBLSPACE_HOOKS
;
; Now find and open Dblspace.bin file
;
gsf_open_Dblspace:
        mov  dx,OFFSET SourceDblSpaceName ; look on source for Dblspace
        mov  di,OFFSET DblSpaceInFH	; pointer to block of data
        call Open_File			; open file
        JNC  gsf_got_dblspace           ; carry on if we located it
;
; We didn't locate the DBLSPACE.BIN file on the source drive.  Look for
; it along the path.
;
        call Find_DblSpace_on_Path
        jnc  gsf_open_dblspace

; Unable to locate Dblspace.bin file.  This isn't a fatal error, but
; we need to avoid further attempts to process the Dblspace file.  Set the
; flag that tells us to skip the create, and clear out the entry for
; it in the FHArray, to signal termination in Fill_Memory and Dump_Memory
;
        mov  NoDblSpace,TRUE            ; don't create it
        mov  FHArrayDS,0                ; don't copy it

gsf_got_dblspace:
ENDIF


        mov  ah,Read			; read the first sector of BIO	   ;C06
        mov  bx,BIOSInFH 		; get bios source handle	   ;C06
        mov  cx,512			; only one sector		   ;C06
IFDEF NEED_CLUSTER_2
        mov  dx,OFFSET BUF+FAT_BUF	; point to beginning of buffer	   ;C06
ELSE
        mov  dx,OFFSET BUF
ENDIF
        int  21h 			; read + not_used <3F00>	   ;C06
        JC $$IF69                        ; jump on read error
IFDEF NEED_CLUSTER_2
        cmp  WORD PTR BUF+FAT_BUF+3,expected_version ; point to beginning       ;AN019;
ELSE
        cmp  word ptr BUF+3,expected_version
ENDIF
					;  of buffer + near jump instruction
        JNE $$IF69                       ; jump if wrong version
;
; Seek back to beginning of file, so Fill_Memory doesn't get confused
; later
;
        mov  ax,LSEEK Shl 8 + 0          ; seek from beginning
        mov  cx,0                        ; seek to offset 0
        mov  dx,cx
        int  21h

        clc				; reset fail flag		       ;AN019:
        mov	al,noerror		; load success return code	       ;AN000;
        JMP SHORT $$EN69

;
; Some error occurred accessing source files
;
$$IF69:
        mov  bl,defalt		        ;; specify drive ;;dcl		       ;AN001;
        call Check_Removeable	        ; check if source media replaceable    ;AC000;
        JC   $$EN68                      ; error if not

        mov  ax,(util_C shl 8) + sys_disk ; load message number	
       		                	;    - Insert system disk....
        lea  si,SourceSpec	        ; set insert pointer to DRIVE ID
        mov  bx,SourceSize	        ; only display correct path length
        call Prompt_For_Media	        ; prompt for source media	
        JC   $$EN68                      ;

        mov  ax,error_RC	                ; load return code (try again)	

$$EN69:
        				; if fail flag set		       ;AC018;
        JC $$EN68
        cmp  al,noerror			; is it an error return code?	       ;AC018;
        				; quit if success return code	       ;AC018;
        JE   $$en68
;
; Before we go try again, close all the files we just opened
;
        mov  bx,BIOSInFH
        mov  ah,CLOSE
        int  21h

        mov  bx,DOSInFH
        mov  ah,CLOSE
        int  21h

IFDEF DBLSPACE_HOOKS
        cmp  NoDblSpace,TRUE
        je   gsf_retry
        mov  bx,DblSpaceInFH
        mov  ah,CLOSE
        int  21h

gsf_retry:
;
;      reset DblSpace state variables, in case we find it on the second try
;
        mov  NoDblSpace,FALSE
        mov  FHArrayDS,offset DblSpaceInFH
ENDIF

        jmp  $$DO68


$$EN68:
        ret

   ENDPROC Get_System_Files


IFDEF DBLSPACE_HOOKS
   BREAK <SYS - Find_DblSpace_on_Path >
;******************* START OF SPECIFICATIONS ***********************************
;Routine name: Find_DblSpace_on_Path
;*******************************************************************************
;
;Description:	    Search Path for Dblspace.bin
;
;Output: no error - CF = 0        SourceDblSpaceName filled in with
;                                 full path to dblspace.bin
;	    error - CF = 1	  Dblspace.bin not found
;
;******************* END OF SPECIFICATIONS *************************************

Find_DblSpace_on_Path PROC NEAR
        public Find_DblSpace_on_Path

        push es
        push ds                         ; save our segments
        push si                         ; save DTA address

        mov  es,[old_psp]               ; get our PSP
        call Find_Path_In_Environment   ; returns ptr to path string in ES:DI
        jc   fdp_exit                   ; no path, can't find dblspace.bin

        assume es:nothing
        mov  ax,ds                      ; swap DS and ES
        push es
        pop  ds
        assume ds:nothing
        mov  si,di                      ; DS:SI ==> Path string
        mov  es,ax
        assume es:data

fdp_path_loop:
        mov  bh,';'                     ; path separator character
        mov  dx,offset SourceDblSpace   ; base file name
        mov  di,offset SourceDblSpaceName ; buffer to stick full path in
        call Path_Crunch                ; concatenate name and path
        pushf                           ; save result
        push ds                         ; save segment of Path
        push es
        pop  ds
        assume ds:data
        mov  dx,offset SourceDblSpaceName ; buffer with full path name
        mov  bx,offset DOS_BUFFER       ; DMA buffer for finds
        mov  al,1                       ; extension is specified
        call Search
        or   al,al                      ; found the file?
        pop  ds                         ; recover path segment
        assume ds:nothing
        pop  ax                         ; recover flags in AX
        jnz  fdp_exit                   ; found it!
        xchg ah,al
        sahf                            ; check Path_Crunch result
        jnc  fdp_path_loop

fdp_exit:
        pop  si
        pop  ds
        pop  es
        assume ds:data
        ret

EndProc Find_DblSpace_on_Path
ENDIF


   BREAK <SYS - Prompt_For_Media >
;******************* START OF SPECIFICATIONS ***********************************
;Routine name: Prompt_For_Media
;*******************************************************************************
;
;Description:	    Make call to Message to display:
;
;			Insert system disk in drive %1
;			and strike any key when ready
;
;Called Procedures: Message
;
;Input: 	    (AL) = message #
;		    (BL) = drive/path length
;		    (SI) = insert pointer
;
;Output: no error - CF = 0
;	    error - CF = 1	  AX = return code (DOS error)
;
;Change History:    Created	   5/01/87	   FG
;
;******************* END OF SPECIFICATIONS *************************************
;******************+ START OF PSEUDOCODE +**************************************
;
;	START  Prompt_For_Media
;
;	set up for message call
;	call Message  - display first line
;	if no error
;		clear insert indicator
;		load Message #x - Press any key to continue
;		ask for keystroke response (direct CON in no echo)
;		call Message  - display second line
;	endif
;	if error
;		load return code (DOS extended error)
;	endif
;	ret
;
;	END  Prompt_For_Media
;
;******************-  END  OF PSEUDOCODE -**************************************

public Prompt_For_Media

   Prompt_For_Media PROC NEAR

   mov	[insert_ptr_off],si		; set up for message call	       ;AN000;
   mov	[insert_ptr_seg],ds
   mov	insert_max,bl			; only display correct path length     ;AN025;
   lea	si,sublist			; set pointer to SUBLIST	       ;AN000;

   call Message 			; display first line		       ;AN000;

;  $if	nc				; if no error			       ;AN000;
   JC $$IF81

       mov  ax,(util_D shl 8) + press_key ; load Message		       ;AN000;
					;    - Press any key to continue
					; the class will signal to ask for
					; keystroke response
					;	 (direct CON in no echo)
       call Message			; display second line		       ;AN000;

;  $endif				;				       ;AN000;
$$IF81:

;  $if	c				; if an error occured		       ;AN000;
   JNC $$IF83

       mov  ah,DOS_error		; load return code (DOS extended error);AN000;

;  $endif				;				       ;AN000;
$$IF83:

   ret					;				       ;AN000;

   ENDPROC Prompt_For_Media

   BREAK <SYS - Check_Removeable >
;******************* START OF SPECIFICATIONS ***********************************
;Routine name: Check_Removeable
;*******************************************************************************
;
;Description:	    Make IOCtl call to see if media in the drive indicated in
;		    BX is removable
;
;Called Procedures: None
;
;Input: 	    BX has drive (0=default, 1=A)
;
;Output: removeable	       - CF = 0
;	 nonremovable or error - CF = 1
;				 AX = 11d - No system on default drive
;
;Change History:    Created	   5/01/87	   FG
;
;******************* END OF SPECIFICATIONS *************************************
;******************+ START OF PSEUDOCODE +**************************************
;
;	START  Check_Removeable
;
;	if source not specified
;	       do an IOCTL changeable check (INT21 IOCtl + 08 <4408>)
;	       if no error
;		       test if removeable
;		       if removeable
;			       reset fail flag
;		       else
;			       load return code (No system on default drive)
;			       set fail flag
;		       endif
;	       endif
;	else
;	       load return code (No system on specified path)
;	       set fail flag
;	endif
;	ret
;
;	END  Check_Removeable
;
;******************-  END  OF PSEUDOCODE -**************************************

public Check_Removeable

   Check_Removeable PROC NEAR

   mov	ax,(IOCTL SHL 8) + IOCTL_CHANGEABLE? ; do a media check
   INT	21h				;	  IOCtl + 08 <4408>
					; cy set if remote or invalid device ;;dcl;;
;  $if	nc				;
   JC $$IF85
       cmp  ax,0			;
;      $if  e				;
       JNE $$IF86
	   clc				;
;      $else				;
       JMP SHORT $$EN86
$$IF86:
	   cmp	Spec_Flag,1		;				       ;AC025;
;	   $if	ne			;				       ;AC025;
	   JE $$IF88
	       mov  ax,(util_B shl 8) + no_sys_on_def ; No system on...        ;AC000;
;	   $else			;				       ;AC025;
	   JMP SHORT $$EN88
$$IF88:
	       mov  ax,(util_B shl 8) + system_not_found ; Invalid path or Sy..;AN021;
;	   $endif			;				       ;AC025;
$$EN88:
	   stc				;
;      $endif				;
$$EN86:
;  $endif				;
$$IF85:

   ret					;				       ;AN021;

   ENDPROC Check_Removeable

   BREAK <SYS - Open_File >
;******************* START OF SPECIFICATIONS ***********************************
;Routine name: Open_File
;*****************************************************************************
;
;Description:	    Finds and opens file and gets date and size
;
;Called Procedures: None
;
;Input: 	    SI ==> DTA used for find operation
;                   DX ==> file name to search for
;                   DI = xfer_data struc to record info in
;
;Output: no error - CF = 0
;	    error - CF = 1	      AX = DOS extended errors
;
;Change History:    Created	   5/01/87	   FG
;                                  11/17/92        MD  Rewrote
;
;******************* END OF SPECIFICATIONS *************************************

public open_file

   Open_File PROC NEAR

   mov  CX,DOS_system_atrib 	        ; its an 'everything' file
   mov  ah,Find_First		        ; do a find first INT21
   INT  21h 			        ;      Find_First <4Exx>
   JC   of_err_exit                     ; jump if not found
;
; Found file, store size data
;
   mov  ax,[si].find_buf_size_l	        ; move size (low and high)	
   mov  [di].LenLow,AX                  ;     from DTA
   mov  ax,[si].find_buf_size_h	        ;	to			
   mov  [di].LenHigh,AX                 ;	  SYS data space
;
; Now open file to get time and date
;
   mov	ax,(OPEN SHL 8) + not_used	; open file for read
   INT	21h				;    Read + not_used <3D00>
   JC   of_err_exit

   mov  [di].InFH,ax		        ; save file handle		
   mov  bx,ax			        ; move handle for next call
   mov  ax,(File_Times SHL 8) + 0	; find last write time
   INT  21h 			        ;	 File_Times + not_used <5700>
   mov  [di].FTime,cx		        ; save time			
   mov  [di].FDate,dx		        ; save date			
   JMP  SHORT of_end

of_err_exit:
    mov  ah,DOS_error		        ; load return code (DOS extended error)

of_end:
   ret

   ENDPROC Open_File

   BREAK <SYS - Fill_Memory >
;******************* START OF SPECIFICATIONS ***********************************
;Routine name: Fill_Memory
;*******************************************************************************
;
;Description:  Read in as much of IBMBIOS, IBMDOS and DBLSPACE.BIN
;              as room permits
;
;Called Procedures: None
;
;Input: 	    None
;
;Output: no error - CF = 0
;	    error - CF = 1
;
;Change History:    Created	   5/01/87	   FG
;                   rewritten     11/18/92         MD
;
;******************* END OF SPECIFICATIONS *************************************

public fill_memory

   Fill_Memory PROC NEAR

   mov  si,offset FHArray               ; get pointers at xfer_data strucs
   mov  cx,cbBuf                        ; initial buffer size
IFDEF NEED_CLUSTER_2
   mov  dx,OFFSET BUF+FAT_BUF           ; buffer starting address
ELSE
   mov  dx,OFFSET BUF
ENDIF
   xor  ax,ax                           ; size of last read = 0 to start

; Entry:
;   si = FHArray entry (which file we are reading)
;   dx = position in buffer to read into
;   cx = space remaining in buffer
;   ax = size of last read operation (0 initially)
;
; NOTE: The BUF buffer is always less than 64K, because we are a COM
;       file.  This means that we will only make one read call per file
;       per call to Fill_Memory.
;
fm_loop:
   mov  di,[si]                         ; get next xfer_data struc
   mov  [di].BufPos,ax                  ; store our starting location in buf
   add  dx,ax                           ; set buffer address
   sub  cx,ax                           ; adjust buffer size

   mov  bx,[di].InFH                    ; get file handle
   mov  bp,cx                           ; save starting buffer size
   cmp  [di].LenHigh,0                  ; more than 64Kb to read?
   jne  fm_do_read                      ; yes, just proceed

   cmp  [di].LenLow,cx                  ; more than buffer size to read?
   jae  fm_do_read                      ; yes, just proceed

   mov  cx,[di].LenLow                  ; adjust size of read
   or   cx,cx                           ; nothing to read?
   jnz  fm_do_read                      ; no, carry on with read

; nothing left to read from this file, so close it so we can reuse the SFT

   push ax
   mov  ah,CLOSE
   int  21h
   mov  [di].InFH,-1                    ; forget this file handle
   pop  ax
   jmp  short fm_adjust_size

fm_do_read:
   mov  ah,Read
   int  21h
   jc   fm_end                          ; quit on read error

   cmp  ax,cx                           ; check that we read it all
   je   fm_adjust_size                  ; yes, go adjust size left to read

   stc
   jmp  short fm_end                    ; else go report error

fm_adjust_size:
   sub  [di].LenLow,ax                  ; subtract size read
   sbb  [di].LenHigh,0
   mov  [di].BufferedSize,ax            ; store size of data read in

   cmp  ax,bp                           ; any space left in buffer?
   jae  fm_end                          ; no, done with this pass

;* We read all of the current file, and still have space in the buffer,
;  so read the next file.

   mov  cx,bp                           ; recover original buffer size
   add  si,TYPE FHArray                 ; advance to next xfer_data struc
   cmp  word ptr [si],0
   jne  fm_loop                         ; continue with next file

fm_end:
   ret

   ENDPROC Fill_Memory

   BREAK <SYS - Dump_Memory >
;******************* START OF SPECIFICATIONS ***********************************
;Routine name: Dump_Memory
;*******************************************************************************
;
;Description:	    Write out as much of IBMBIOS, IBMDOS, and DBLSPACE.BIN
;                       as is in memory.
;
;Called Procedures: None
;
;Input: 	    None
;
;Output: no error - CF = 0
;	    error - CF = 1
;
;Change History:    Created	   5/01/87	   FG
;                   Rewritten     11/18/92         MD
;
;******************* END OF SPECIFICATIONS *************************************

   public Dump_Memory

   Dump_Memory PROC NEAR

   xor  ax,ax
   mov  si,offset FHArray               ; point at xfer_data strucs
IFDEF NEED_CLUSTER_2
   mov  dx,offset BUF+FAT_BUF           ; start of buffer
ELSE
   mov  dx,offset BUF
ENDIF
   mov  bp,cbBuf                        ; original buffer size

; Entry:
;   si = FHArray entry (which file we are writing)
;   dx = position in buffer to read from
;   ax = size of last write operation (0 initially)
;   bp = count of bytes in buffer to be written
;
dm_loop:
   mov  di,[si]                         ; get next xfer_data struc
   mov  cx,[di].BufferedSize            ; bytes of this file in buffer
   jcxz dm_get_next                     ; anything there to write?

   add  dx,[di].BufPos                  ; start of this file in buffer
   mov  bx,[di].OutFH                   ; target file handle

; file may not yet be open, file handle will be -1 if so.  If that's
; the case, open the target file here.  We'll be opening the file for
; its initial write, so we don't need to seek into the file.

   cmp  bx,-1
   jne  dm_write                        ; file already open, continue

   push ax
   push dx
   mov  ax,OPEN shl 8 + 1               ; open for write access
   mov  dx,[di].OutFileName
   int  21h

   mov  [di].OutFH,ax                   ; save the file handle
   mov  bx,ax                           ; ready for write
   pop  dx
   pop  ax
   jc   dm_err_exit                     ; error on open, shouldn't happen

dm_write:
   mov  ah,WRITE
   int  21h                             ; write the file
   jc   dm_err_exit                     ; quit on error
   cmp  ax,cx                           ; check that we wrote it all
   jne  dm_err_exit                     ; quit if not

dm_get_next:
   sub  bp,ax                           ; account for part of buffer now used
   jbe  dm_exit                         ; quit if buffer all used
   add  si,TYPE FHArray                 ; point at next xfer_data struc
   cmp  word ptr [si],0                 ; reached last file?
   jne  short dm_loop                   ; go try again

dm_exit:
   ret

dm_err_exit:
;
;       On error, close and delete the file we failed on, so we don't
;       leave partial files lying around.
;
   mov  ah,CLOSE
   int  21h                             ; close the output file
   mov  dx,[di].OutFileName             ; get the target file name
   mov  ah,UNLINK
   int  21h                             ; delete it
   stc                                  ; signal error
   ret


   ENDPROC Dump_Memory

   BREAK <SYS - Check_SYS_Conditions >
;******************* START OF SPECIFICATIONS ***********************************
;Routine name: Check_SYS_Conditions
;*******************************************************************************
;
;Description: Verify that the target disk is in a state that a SYS to it will
;	      be allowed. If an error occurs in any of the called routines,
;	      the return code will already be loaded by the failing routine.
;
;Called Procedures: Verify_File_System
;		    Read_Directory
;		    Verify_File_Location
;		    Determine_Free_Space
;
;Input: None
;
;Output: no error - CF = 0
;	    error - CF = 1	  AX = return code (message #)
;
;Change History: Created	5/01/87 	FG
;
;******************* END OF SPECIFICATIONS *************************************
;******************+ START OF PSEUDOCODE +**************************************
;
;	START  Check_SYS_Conditions
;
;	verify target is a FAT file system (CALL Verify_File_System)
;	if no error and
;		load root directory of target (CALL Read_Directory)
;	if no error and
;		check that IBMBIO,IBMDOS are in right place (CALL Verify_File_Location)
;	if no error and
;		check for  sufficient space for system files (CALL Determine_Free_Space)
;	if no error
;		load return code (success)
;		reset fail flag
;	endif
;	ret
;
;	END  Check_SYS_Conditions
;
;******************-  END  OF PSEUDOCODE -**************************************

public Check_SYS_Conditions

   Check_SYS_Conditions PROC NEAR

   call Verify_File_System		; verify target is a FAT file system   ;AN000;

;  $if	nc,and				; no error and			       ;AN000;
   JC $$IF108

   call Read_Directory			; load root directory of target        ;AN000;

;  $if	nc,and				; no error and			       ;AN000;
   JC $$IF108

   call Verify_File_Location		; check that IBMBIO,IBMDOS are in right;AN000;
					;    place
;  $if	nc				; no error and			       ;AN000;
   JC $$IF108

       call Determine_Free_Space	; check if enough space for system file;AN000;

;  $endif				;				       ;AN000;
$$IF108:

   ret					;				       ;AN000;

   ENDPROC Check_SYS_Conditions

   BREAK <SYS - Verify_File_System >
;******************* START OF SPECIFICATIONS ***********************************
;Routine name: Verify_File_System
;*******************************************************************************
;
;Description: Get the file system for the specified drive, then compare to
;	      FAT. If not, issue message and exit. Must ensure that target
;	      drive has media in it before this routine is called
;
;Note:	      This routine contains code that is specifically required for
;	      operation on DOS 3.3.  This code must be removed for later releases
;	      of DOS.
;
;Called Procedures: None
;
;Input: 	    Drive Number (0=default, 1=A, 2=B) in BL
;
;Output: no error - CF = 0
;	    error - CF = 1
;		    AX = return code
;			  AH = utility messages
;			  AL = 15d - Not able to SYS to xxx file system
;		    CX = 1 - only one substitution
;		 DS:SI = sublist for substitution
;
;Change History:    Created	   5/01/87	   FG
;
;******************* END OF SPECIFICATIONS *************************************
;******************+ START OF PSEUDOCODE +**************************************
;
;	START  Verify_File_System
;
;	if   dos = current
;		load drive id (BL)
;		get_extended_device_parameters (INT21 IOCtl + 0Dh <440D> CX=086E) for drive
;		if error - check if old version destination
;			find out what the error was (CALL Get_DOS_Error)
;			if not old version error
;				load return code (DOS Extended Error Class)
;				set fail flag
;			else
;				reset fail flag
;			endif
;		else
;			if returned file system type = "FAT12   " or
;			if returned file system type = "FAT16   "
;				reset fail flag
;			else
;				indicate insert required
;				set up pointer for insert - sublist
;				load return code (Unable to SYS to xxxxxxxx file system)
;				set fail flag
;			endif
;		endif
;	endif
;
;	ret
;
;	END  Verify_File_System
;
;******************-  END  OF PSEUDOCODE -**************************************

public Verify_File_System

   Verify_File_System PROC NEAR

   cmp	DOS_VER,0			; running on current DOS ?	       ;AN019;
;  $if	e,long				; if we are		      ;AC999;FAT;APAR;;AN019;
   JE $$XL1
   JMP $$IF110
$$XL1:
       mov  bl,TargDrvNum		; load drive id (BL)		       ;AN000;
       lea  dx,IOCtl_Buf		; point to output buffer	       ;AN000;
       mov  ax,(GetSetMediaID shl 8) + 0 ; get volid, ser# and filetype        ;AC019;
       INT  21h 			;  INT 21 GetSetMediaID request <6900> ;AC019;

;      $if  c				; error - check if old version dest    ;AN000;
       JNC $$IF111

	   call Get_DOS_Error		; find out what the error was	       ;AN000;

	   cmp	al,old_type_media	; is it IBM but < 4.0 ? 	       ;AN000;

;	   $if	ne			; not old version error 	       ;AN000;
	   JE $$IF112

	       mov  ah,DOS_error	; load return code (DOS Extended Error);AN000;
	       stc			; set fail flag 		       ;AN000;

;	   $else			;				       ;AN000;
	   JMP SHORT $$EN112
$$IF112:

	       clc			; reset fail flag		       ;AN000;

;	   $endif			;				       ;AN000;
$$EN112:

;      $else				; ELSE it is => 4.00		       ;AN000;
       JMP SHORT $$EN111
$$IF111:

	   lea	si,IOCtl_File_Sys	; see if file type is fat12	       ;AN000;
	   lea	di,fat_12		;				       ;AN000;
	   mov	cx,file_sys_size	;				       ;AN000;
	   cld				;				       ;AN000;
	   repe cmpsb			;				       ;AN000;
;--------------------			; IF failed at 4th character, then it
	   cmp	cx,4			;  may have been "FAT     "
;	   $IF	e,and			;			
	   JNE $$IF116
	     cmp  BYTE PTR ds:[si-1]," ";  Is 4th char a blank?
;	   $IF	e,and			;			
	   JNE $$IF116
	     cmp  BYTE PTR ds:[si  ]," ";  Is 5th char a blank?
;	   $IF	e,and			;			
	   JNE $$IF116
	     cmp  BYTE PTR ds:[si+1]," ";  Is 6th char a blank?
;	   $IF	e,and			;			
	   JNE $$IF116
	     cmp  BYTE PTR ds:[si+2]," ";  Is 7th char a blank?
;	   $IF	e,and			;			
	   JNE $$IF116
	     cmp  BYTE PTR ds:[si+3]," ";  Is 8th char a blank?
;	   $IF	e			;			
	   JNE $$IF116
	     mov  cx,0						
;	   $ELSE						
	   JMP SHORT $$EN116
$$IF116:
;--------------------		MAYBE IT IS FAT12 OR FAT16?
	   cmp	cx,3			; did it fail at the 2 in fat12 ?      ;AN000;

;	   $if	e,and			; if it did and............	       ;AN000;
	   JNE $$IF118

	   cmp	BYTE PTR ds:[si-1],"6"	; was it a 6 ?		  :	       ;AN000;

;	   $if	e			; if it was...............:	       ;AN000;
	   JNE $$IF118

	       repe cmpsb		; then keep going		       ;AN000;

;	   $endif			;				       ;AN000;
$$IF118:
;	   $ENDIF			    ;DONE SCANNING	      ;AN999;FAT;APAR;
$$EN116:

	   cmp	cx,0			; did we reach the end ?	       ;AN000;

;	   $if	e			; if we did it was "FAT12   " or       ;AN000;
	   JNE $$IF121
					;     "FAT16   " so its OK to SYS

	       clc			; reset fail flag		       ;AN000;

;	   $else			;				       ;AN000;
	   JMP SHORT $$EN121
$$IF121:

	       lea  di,File_Sys_End	; set up pointer to end of insert      ;AN000;
	       dec  di			; back up to last character	       ;AN000;
	       mov  cx,file_sys_size	; strip off trailing blanks	       ;AN017;
	       mov  al," "		; strip off trailing blanks	       ;AN017;
	       std			; scan backwards		       ;AN017;
	       repe scas IOCTL_File_Sys ;				       ;AN017;
	       cld			; stops at 2 past last " "	       ;AN017;
	       inc  di			; 1 past			       ;AN017;
	       inc  di			; last (first) blank		       ;AN017;
	       xor  al,al		; make it an ASCIIZ		       ;AN017;
	       stos IOCTL_File_Sys	;				       ;AN017;
	       lea  si,IOCTL_File_Sys	; set up pointer to the insert	       ;AN000;
	       mov  [insert_ptr_off],si ;				       ;AN017;
	       mov  [insert_ptr_seg],ds ;				       ;AN017;
	       lea  si,sublist		; set pointer to SUBLIST	       ;AN017;
	       mov  insert_max,8	; max characters for file system   ;C02
	       mov  ax,(util_C shl 8) + cant_sys ; load return code	       ;AN000;
					;  - Unable to SYS to xxx file system
	       stc			; set fail flag 		       ;AN000;

;	   $endif			;				       ;AN000;
$$EN121:

;      $endif				;				       ;AN000;
$$EN111:

;  $else				; not running on current DOS	       ;AN019;
   JMP SHORT $$EN110
$$IF110:

       clc				; keep going			       ;AN019;

;  $endif				; running on current DOS	       ;AN019;
$$EN110:

   ret					;				       ;AN000;

   ENDPROC Verify_File_System

   BREAK <SYS - Read_Directory >
;******************* START OF SPECIFICATIONS ***********************************
;Routine name: Read_Directory
;*******************************************************************************
;
;Description: Read in first sector of directory. The reason that we do the
;	      direct read of the directory is the find first/next or search
;	      first/next do an exclusive search for volume labels. By using
;	      these CALLs, there is no way to determine if a volume label
;	      occupies the first location in the directory. Hence we get sleazy
;	      and read the directory directly (no pun intended) to get this
;	      info. Only read in the first sector of directory. Also, this
;	      ensures there is a media in the drive.
;
;CALLed Procedures: Prompt_for_Media, Find_DPB
;
;Input:  None
;
;Output: no error - CF = 0
;	    error - CF = 1	  AX = return code (message #)
;
;Change History: Created	5/01/87 	FG
;
;******************* END OF SPECIFICATIONS *************************************
;******************+ START OF PSEUDOCODE +**************************************
;
;	START  Read_Directory
;
;	set up drive letter in destignation filespecs
;	call Find_DPB to get directory location
;	load first DIR sector number
;	point at buffer for directory
;	read first sector of directory (INT 25h)
;	ret
;
;	END  Read_Directory
;
;******************-  END  OF PSEUDOCODE -**************************************

   public Read_Directory

   Read_Directory PROC NEAR

   mov	al,TargDrv			; set up drive letter in destignation filespecs
   mov	BIOSName,al			; point names at destination drive
   mov	DOSName,al
   mov  Targ_Com,al
IFDEF DBLSPACE_HOOKS
   mov  TargDblSpace,al
ENDIF

   MOV	DL,TargDrvNum			; load drive
   PUSH DS				; save register
   call Find_DPB			; initalize DPB parameters
   pop  dx
   mov	ds,dx
   mov	es,dx
   jc   rd_exit                         ; exit on error from Find_DPB
   xor	ax,ax				; request a read
   mov	dx,[first_dir_sector]		; read starting dir sector
   mov	[packet],dx			; get starting dir sector	       ;AN001;
   mov	bx,offset DIR_SECTOR
   mov	PACKET_BUFFER[0],bx		;				       ;AN001;
   mov	PACKET_BUFFER[2],ds		;				       ;AN001;
   mov	word ptr [packet_sectors],1	;				       ;AN001;
   call Direct_Access			; to read the sector

   mov	ax, (util_B shl 8) + write_fail ; load message			       ;AC000;
					;   - Write failure, diskette unuseable
					;  in case an error occured
rd_exit:
   ret

   ENDPROC Read_Directory

   BREAK <SYS - Verify_File_Location >
;******************* START OF SPECIFICATIONS ***********************************
;Routine name: Verify_File_Location
;*******************************************************************************
;
;Last Update: 09/22/87
;
;Description: Determines if IBMBIO and IBMDOS are the first two directory
;	      entries, or if these entries are empty. If so, find the size
;	      of the files if they exist. If spaces not empty and don't
;	      contain IBMBIO and IBMDOS, set fail flag and load return code.
;	      Also determines if existing IBMBIO starts in cluster 2. If not
;	      set fail flag and load return code.
;             Also records sizes for COMMAND and DBLSPACE, if they are present
;             on the target drive.
;
;CALLed Procedures: None
;
;Input: 	    DIR in BUFFER
;
;Output: no error - CF = 0
;	    error - CF = 1
;		    AX = return code
;			  AH = utility messages
;			  AL = 8 - No room for system on destination disk
;			       9 - Incompatible system size
;
;Change History: Created	5/01/87 	FG
;
;******************* END OF SPECIFICATIONS *************************************

   public Verify_File_Location

   Verify_File_Location PROC NEAR

;---------------------------------------					
; see if the first two directory					
; entries are available...					
; First check for being free:					
;---------------------------------------					

   mov	bp,OFFSET DIR_SECTOR
   mov	si,bp
   cmp	BYTE PTR [si],empty		; empty dir?
        				; if all files deleted		       ;AC012;
   JE   vfl_first_free
					;   (Dir_Name in dir is 00h)
   cmp	BYTE PTR [si],deleted		; is first file deleted ?
                			; if it is			       ;AC012;
   JNE  vfl_first_not_free
;
; First directory entry is empty or deleted
;
vfl_first_free:
   clc				        ; clear error flag		       ;AN003;

IFDEF NEED_CLUSTER_2
   call Free_Cluster		        ; check the cluster chain just in case ;AC012;
ENDIF

   JMP SHORT vfl_check_second           ; go check the second entry

vfl_first_not_free:

;---------------------------------------					
; The first entry is not free.	See if					
;     the BIOS is there.					
;---------------------------------------					

   mov  di,OFFSET FCBBIO		; pointer to name
   mov  cx,file_spec_length 	        ; length of name
   cld				        ; go forward
   rep  cmpsb			        ; check it
   JNE  vfl_first_not_BIOS              ; jump if not IBMBIO

   dec	BIOSEntFree		        ; indicate we found IBMBIO ( = 0)
   mov	si,bp
   mov	ax,word ptr ds:[si].dir_size_l  ; Get the size of IBMBIO
   mov	word ptr IBMBIO_Low,ax
   mov	ax,word ptr ds:[si].dir_size_h
   mov	word ptr IBMBIO_High,ax

IFDEF NEED_CLUSTER_2
   cmp	ds:[si].dir_first,2	        ; does IBMBIO own Clust 2?	       ;AC005;
   JNE $$IF130
   inc  [bio_owns_it]	                ;     - keep track		       ;AC005;

$$IF130:
   call Free_Cluster		
ENDIF

   JMP SHORT vfl_check_second

;
; Someone is in the first directory entry, and it isn't IBMBIO!
;

vfl_first_not_BIOS:
   call Determine_Free_Space	        ; M004; Need size (IBMBIO+IBMDOS)
   JC   vfl_err			        ; M004; of free clusters

   mov	si,bp			        ; restore pointer to start of entry    ;AN003;
   call Move_DIR_Entry		        ; move the entry out of the way        ;AN003;
   JC   vfl_err

IFDEF NEED_CLUSTER_2
   call Free_Cluster		
ENDIF

   JC   vfl_err

   xor  ax,ax
   JMP SHORT vfl_check_second

;
; Problem relocating owner of first directory entry, report error
;

vfl_err:

   mov  ax,(util_B shl 8) + no_room     ; load return code in case we fail;AN000;
   stc			                ;    - No room for system on dest...   ;AC000;

vfl_check_second:
;---------------------------------------					
; Check the second entry					
;---------------------------------------					

   JNC  vfl_check_second_0              ; exit if we get here with an error
   jmp  vfl_end

vfl_check_second_0:
					; ensure that the first sector of root ;AN003;
					;    is loaded			       ;AN003;
   mov  ax,[first_dir_sector]	        ; get starting dir sector	       ;AN001;
   mov  packet,ax			;				       ;AN001;
   mov  [packet_buffer],offset DIR_SECTOR
   mov  word ptr [packet_sectors],1
   xor  ax,ax			        ; request a read
   call Direct_Access		        ; to read the root
   mov	ax,(util_B shl 8) + no_room     ; load return code in case we fail
   JC   vfl_end

   add	bp,TYPE dir_entry	
   mov	si,bp			
   cmp	BYTE PTR [si],empty     	; empty dir entry?

   JE   vfl_getsizes

   cmp  BYTE PTR [si],deleted           ; deleted ?

   JE   vfl_getsizes
;
; Someone owns the second entry
;
   mov  di,OFFSET FCBDOS	        ;   see if it is IBMDOS
   mov  cx,file_spec_length             ; length of name
   rep  cmpsb		                ; compare it
   mov  si,bp	                	; restore pointer to start	       ;AC000;
   JNE  vfl_move_second

   dec	DOSEntFree	                ; indicate we found IBMDOS
   mov	ax,word ptr ds:[si].dir_size_l  ; Get the size of
   mov	word ptr IBMDOS_Low,ax          ;	   file for IBMDOS
   mov	ax,word ptr ds:[si].dir_size_h
   mov	word ptr IBMDOS_High,ax
   JMP SHORT vfl_getsizes
;
; The owner of the second entry isn't IBMDOS!
;
vfl_move_second:
   call Move_DIR_Entry	
   jc   vfl_err

vfl_getsizes:

IFDEF DBLSPACE_HOOKS
;
; Now get the sizes of DBLSPACE.BIN and COMMAND.COM, if they are present
;
   mov  si,offset DOS_BUFFER
   mov  dx,offset TargDblSpace
   mov  cx,DOS_system_atrib
   mov  ah,Find_First
   int  21h
   jc   vfl_getsizes_0

   mov  ax,[si].find_buf_size_l
   mov  DblSpace_Low,ax
   mov  ax,[si].find_buf_size_h
   mov  DblSpace_High,ax

vfl_getsizes_0:
ENDIF

   mov  dx,offset targ_com
   mov  cx,DOS_system_atrib
   mov  ah,Find_First
   int  21h
   jc   vfl_getsizes_1

   mov  ax,[si].find_buf_size_l
   mov  CommandCom_Low,ax
   mov  ax,[si].find_buf_size_h
   mov  CommandCom_High,ax

vfl_getsizes_1:
   clc

vfl_end:
   ret

   ENDPROC Verify_File_Location



   BREAK <SYS - Determine_Free_Space >
;******************* START OF SPECIFICATIONS ***********************************
;Routine name: Determine_Free_Space
;*******************************************************************************
;
;Last Update: 3/18/87
;
;Description: Determine if there is enough space on the disk, given the free
;	      space and the space taken up by IBMBIO, IBMDOS, DBLSPACE.BIN
;             and COMMAND.COM to install the system files.  Routine will set
;             fail flag and load return
;	      code if there is not enough room.
;
;	      Here we make some VERY IMPORTANT assumptions.
;
;	      1) If IBMBIO exists on the disk currently, we assume it is in the
;		 correct place, i.e. at the front of the data area & contiguous.
;	      2) The stub loader portion of IBMBIO is less than 2048 bytes long.
;		 This number comes about by assuming we will never overlay
;		 anything smaller than 1920 bytes (DOS 1.10 IBMBIO size). This
;		 can be expanded to 2048 if we also assume the smallest possible
;		 cluster length is 512 bytes.
;
;	      Therefore, if we have an empty disk or IBMBIO exists, then we have
;	      enough contiguous room to install the portion of IBMBIO that
;	      requires itself to be contiguous.
;
;             Note there is a design bug in the computation process - we
;             don't account for the size of COMMAND.COM when checking the
;             amount of free space available.  This is a result of the way
;             that Command.com handling has been tacked on, as an afterthought
;             to the normal processing.  So, there are boundary cases on
;             nearly full disks, where we will fail to detect inadequate
;             space for Command.com.  In that case, we will fail when we
;             attempt to copy it.
;
;
;Input: 	    None
;
;Output: no error - CF = 0
;	    error - CF = 1
;		    AX = return code
;			  AH = utility messages
;			  AL = 8d - No room for system on destination disk
;
;Change History:    Created	   5/01/87	   FG
;                   DblSpace support added 11/18/92 MD
;******************* END OF SPECIFICATIONS *************************************

   public Determine_Free_Space

   Determine_Free_Space PROC NEAR


   mov	ah,Get_Drive_Freespace		; get disk free space
   mov	dl,TargDrvNum			; get the drive number
   INT	21h				; Get_Drive_Freespace  <36xx>
					; compute Bytes/Cluster - 16 bit math ok
					;   AX = sectors / cluster
					;   CX = bytes / sector
					;   BX = available clusters
   mul	cx				; get bytes/cluster
					; result left in AX
   mov	Bytes_Per_Cluster,ax		; save this value for Get_Clusters
   mov	Number_Free_Clusters,bx 	; save available space

   mov	ax,IBMBIO_Low			; low result in AX, High result in DX
   mov	dx,IBMBIO_High
   call Get_Cluster			; convert old IBMBIO into cluster size
   add	Number_Free_Clusters,ax 	; add it to available space

   mov	ax,IBMDOS_Low			; low result in AX, High result in DX
   mov	dx,IBMDOS_High
   call Get_Cluster			; convert old IBMDOS into cluster size
   add	Number_Free_Clusters,AX 	; get total number of clusters available

IFDEF DBLSPACE_HOOKS
   cmp  NoDblSpace,TRUE
   je   dfs_nodbl_1                     ; skip this if no Dblspace.bin
   mov	ax,DblSpace_Low			; low result in AX, High result in DX
   mov	dx,DblSpace_High
   call Get_Cluster			; convert old Dblspace.bin into cluster size
   add	Number_Free_Clusters,AX 	; get total number of clusters available

dfs_noDbl_1:
ENDIF

   mov	ax,CommandCom_Low		; low result in AX, High result in DX
   mov	dx,CommandCom_High
   call Get_Cluster			; convert old Command.com into cluster size
   add	Number_Free_Clusters,AX 	; get total number of clusters available

   mov	ax,BIOSLenLow   		; find total size of new DOS and BIOS
   mov	dx,BIOSLenHigh
   call Get_Cluster			; convert new IBMBIO into cluster size
   mov	Need_Clusters,ax		;save new BIO clusters

   mov	ax,DOSLenLow
   mov	dx,DOSLenHigh
   call Get_Cluster			; convert new IBMDOS into cluster size
   add	AX,Need_Clusters		; get total number of clusters needed

IFDEF DBLSPACE_HOOKS
   cmp  NoDblSpace,TRUE
   je   dfs_noDbl_2                     ; skip this if no Dblspace.bin
   mov  ax,DblSpaceLenLow
   mov  dx,DblSpaceLenHigh
   call Get_Cluster
   add  ax,Need_Clusters

dfs_noDbl_2:
ENDIF

   cmp	AX,Number_Free_Clusters 	;Now see if there is enough room
					;	for all of it on the disk
   JNA $$IF149

   mov  ax,(util_B shl 8) + no_room     ; load return code		       ;AC000;
					; - No room for system on dest..
   stc				        ; set fail flag
   JMP SHORT $$EN149

$$IF149:

   clc				        ; reset fail flag

$$EN149:

   ret					;				       ;AN000;

   ENDPROC Determine_Free_Space

   BREAK <SYS - Get_Cluster >
;******************* START OF SPECIFICATIONS ***********************************
;Routine name: Get_Cluster
;*******************************************************************************
;
;Description:	    Convert bytes to clusters, rounding up to the next
;		    cluster size if needed.
;
;Called Procedures: None
;
;Input: 	    (AX) = Number of bytes
;		    Bytes_Per_Cluster = # of bytes per cluster
;
;Output:	    (AX) = Number of clusters
;
;Registers used:    AX	BX  DX
;
;Change History:    Created	   5/01/87	   FG
;
;******************* END OF SPECIFICATIONS *************************************
;******************+ START OF PSEUDOCODE +**************************************
;
;	START Get_Cluster
;
;	divide size by bytes_per_cluster
;	if there is a remainder
;		round up to next cluster
;	endif
;	ret
;
;	END Get_Cluster
;
;******************-  END  OF PSEUDOCODE -**************************************

   public Get_Cluster

   Get_Cluster PROC NEAR

   mov	bx,Bytes_Per_Cluster		; Bytes/cluster
   div	bx				; divide size by bytes_per_cluster
   cmp	dx,0				; is there a remainder in DX?

;  $if	ne				; if there is a remainder	       ;AC000;
   JE $$IF152
					; we have another cluster to round up
       inc  ax				; round up to next cluster

;  $endif				;				       ;AC000;
$$IF152:

   ret

   ENDPROC Get_Cluster

   BREAK <SYS - Do_SYS >
;******************* START OF SPECIFICATIONS ***********************************
;Routine name: Do_SYS
;*******************************************************************************
;
;Description: Control routine to handle the transfer of system files from
;	      memory to target drive.
;
;Called Procedures: Create_System
;		    Fill_Memory
;		    Dump_Memory
;
;Input: IBMBIO_Size_Loaded
;	IBMDOS_Size_Loaded
;
;Output: no error - CF = 0
;	    error - CF = 1	  AX = return code (message #)
;
;Change History: Created	5/01/87 	FG
;
;******************* END OF SPECIFICATIONS *************************************

   public Do_SYS

   Do_SYS PROC NEAR

   call CREATE_SYSTEM			; create IBMBIO and IBMDOS, in place
   jc   ds_end

IFDEF NEED_CLUSTER_2
   push ds
   lds  bx,THIS_DPB 		; set up pointer to DPB 	
   mov  [bx.dpb_next_free],2	; reset Allocation to start of disk
   pop  ds				;  so BIOS goes in right place!
ENDIF

$$DO155:
   call Fill_Memory		; read in file from source	   ;C06
   mov	ax,(util_B shl 8) + cant_read_system ; load error RC (assume error)     ;AC000;
   jc   ds_end

   call Dump_Memory		; write out contents of memory to file
   mov	ax,(util_B shl 8) + no_room ; load error RC (assume error)     ;AC000;
   jc   ds_end

   mov	ax,DOSLenHigh		; more DOS to move ?
   or	AX,DOSLenLow		; more low dos
   or	AX,BIOSLenHigh		; more high BIOS
   or	AX,BIOSLenLow		; more low BIOS

IFDEF DBLSPACE_HOOKS
   or   ax,DblSpaceLenLow       ; more Dblspace?
   or   ax,DblSpaceLenHigh
ENDIF

   jnz  $$do155			; if not all files copied

   clc				;	 reset fail flag	       ;AC000;

ds_end:
   ret

   ENDPROC Do_SYS

   BREAK <SYS - Create_System >
;******************* START OF SPECIFICATIONS ***********************************
;Routine name: Create_System
;*******************************************************************************
;
;Description:       Creates directory entries for system files.
;
;Called Procedures: Create_File
;
;Input: 	    None
;
;Output:	    IBMBIO_Handle
;		    IBMDOS_Handle
IFDEF DBLSPACE_HOOKS
;                   DblSpace Handle
ENDIF
;
;Change History:    Created	   5/01/87	   FG
;
;******************* END OF SPECIFICATIONS *************************************

   public Create_System

   Create_System PROC NEAR

   mov	[open_seg],ds
   mov	dx,OFFSET BIOSName		; point to IBMBIO ASCIIZ string
   mov	al,[BIOSEntFree]		; get status of IBMBIO		       ;AN006;
   mov	[EntryFree],al			; update file status (0 = found,1 = not;AN006;

   call Create_File			; create IBMBIO 		       ;AN000;
   JC $$IF162

   mov	dx,OFFSET DOSName		; pointer to IBMDOS ASCIIZ string
   mov	al,[DOSEntFree] 		; get status of IBMDOS		       ;AN006;
   mov	[EntryFree],al			; update file status (0 = found,1 = not;AN006;

   call Create_File			; create IBMDOS 		       ;AN000;
   JC $$IF162

IFDEF DBLSPACE_HOOKS
   cmp  NoDblSpace,TRUE                 ; check if we need to copy Dblspace.bin
   je   $$IF162                         ; jump if not

   mov  dx,OFFSET TargDblSpace          ; create Dblspace.bin entry
   mov  [EntryFree],0                   ; tell Create_File it doesn't need
                                        ;   to delete it first
   call Create_File
   jc   $$IF162
ENDIF

$$IF162:

   ret				

   ENDPROC Create_System

   BREAK <SYS - Create_File >
;******************* START OF SPECIFICATIONS ***********************************
;Routine name: Create_File
;*******************************************************************************
;
;Last Update: 9/23/87
;
;Description: Remove the read only attribute from IBMBIO and IBMDOS. If
;	      file not found error occurs, it is okay, because it just
;	      means the file was not there. Do create with read-only
;	      hidden, and system file attributes. This is an in place
;	      create if the file exists already.  Close the file after
;             the create, to conserve SFT entries.  We'll open the file
;             again before we write it.
;
;Called Procedures: None
;
;Input: 	    DS:DX = pointer to ASCIIZ string for file create
;
;Output: no error - CF = 0
;	    error - CF = 1
;		    AX = return code
;			  AH = extended DOS errors
;
;Change History:    Created	   5/01/87	   FG
;
;******************* END OF SPECIFICATIONS *************************************

   public Create_File

   Create_File PROC NEAR

   mov	ax,(CHMod shl 8) + SetAtrib	; set file attributes to 0
   xor	cx,cx				; set attributes to 0
   mov	[open_off],dx			; save pointer to ASCIIZ for OPEN
   INT	21h				;   CHMod + SetAtrib <4301>)
   JC   crf_cannot_open

   cmp  [EntryFree],0		        ; is file in the correct spot?	       ;AN006;
   JE   crf_got_file

   mov	dx,[open_off]		        ; get pointer to ASCIIZ for UNLINK     ;AN006;
   mov	ax,(UNLINK shl 8)	        ; UNLINK the file
   INT	21h			        ;   UNLINK	     <4100>)	       ;AN006;
   JMP  SHORT crf_got_file

crf_cannot_open:
   call Get_DOS_Error		        ; find out what went wrong	       ;AN000;
   cmp  al,file_not_found		; not there?
   je   crf_got_file                    ; if not there, we'll create it
   stc                                  ; can't handle any other error
   JMP  SHORT crf_error

crf_got_file:
   JC   crf_error

   lds  si,OPEN_PARMS		
   xor  cx,cx			        ; DOS system file atributes	       ;AC005;
   cmp  DOS_VER,0			; running on current DOS ?	       ;AN019;
   JE   crf_use_extopen

   mov	dx,si			        ; DS:DX - file name		       ;AN019;
   mov	ax,(Creat shl 8) + 0	        ; Create file  <3D00>		       ;AN019;
   JMP  SHORT crf_do_create

crf_use_extopen:
   mov	di,cx			
   dec	di			
   mov	bx,open_mode		        ; set up for mode		       ;AN000;
   mov	dx,(openit shl 4) + replaceit   ; create if does not exist,      ;AN000;
  			                ;     replace it if it does
   mov	ax,(ExtOpen shl 8) + 0	        ; ext Open file with attributes of 0   ;AN000;
                			; ExtOpen + SetAtrib  <6C12> CX=0
crf_do_create:
   INT  21h 			        ; do the open
   JC   crf_error
                                        ; now close the file so we can
                                        ; reuse the SFT
   mov  bx,ax
   mov  ah,CLOSE
   int  21h
   jnc  crf_exit

crf_error:
   call Get_DOS_Error		        ; find out what went wrong	       ;AN000;
   mov  ah,DOS_error		        ; load return code (DOS Extended Error);AN000;
   stc				

crf_exit:
   ret					;				       ;AC000;

   ENDPROC Create_File


   BREAK <SYS - Do_End >
;******************* START OF SPECIFICATIONS ***********************************
;Routine name: Do_End
;*******************************************************************************
;
;Description:	    Finish off with IBMBIOS and IBMDOS
;
;Called Procedures: Close_File
;		    Write_Boot_Record
;
;Input: 	    None
;
;Output: no error - CF = 0
;
;Change History:    Created	   5/01/87	   FG
;
;******************* END OF SPECIFICATIONS *************************************
;******************+ START OF PSEUDOCODE +**************************************
;
;	START  Do_End
;
;	finish off and close IBMBIOS and IBMDOS (CALL Close_Files)
;	update boot record (CALL Write_Boot_Record)
;	ret
;
;	END  Do_End
;
;******************-  END  OF PSEUDOCODE -**************************************

   public Do_End

   Do_End PROC NEAR

   call Close_File			; finish off & close IBMBIOS and IBMDOS;AN000;

   call Write_Boot_Record		; update boot record		       ;AN000;

   ret					;				       ;AN000;

   ENDPROC Do_End

   BREAK <SYS - Close_File >
;******************* START OF SPECIFICATIONS ***********************************
;Routine name: Close_File
;*******************************************************************************
;
;Description:	    Set date and time on IBMBIOS, IBMDOS, and DBLSPACE.BIN,
;                   and close them.
;
;Called Procedures: None
;
;Input: 	
;
;Output:	    IBMBIOS, IBMDOS, and DBLSPACE.BIN closed
;
;Change History:    Created	   5/01/87	   FG
;                   Rewritten     11/18/92         MD
;******************* END OF SPECIFICATIONS *************************************

   public Close_File

   Close_File PROC NEAR

   mov  si,offset FHArray               ; point at xfer_data strucs

cf_loop:
   mov  di,[si]                         ; get next file struc
   mov  bx,[di].OutFH                   ; get handle
   mov  dx,[di].FDate                   ; get date
   mov  cx,[di].FTime                   ; get time
   mov  ax,(FILE_TIMES shl 8) + set     ;
   int  21h                             ; set the time stamp

   mov  ah,CLOSE
   int  21h                             ; close the file

   add  si,TYPE FHArray                 ; advance to next file struc
   cmp  word ptr [si],0                 ; end of array?
   jne  cf_loop                         ; no, keep going
;
; Now set the system/hidden/readonly attributes on the files
;
   mov	dx,offset BIOSName		;				       ;AN001;
   mov	ax,(CHMod shl 8) + SetAtrib	; set file attributes to 0
   mov	cx,DOS_system_atrib		; DOS system file atributes
   INT	21h				;   CHMod + SetAtrib <4301>)

   mov	dx,offset DOSName		;				       ;AN001;
   mov	ax,(CHMod shl 8) + SetAtrib	; set file attributes to 0
   mov	cx,DOS_system_atrib		; DOS system file atributes
   INT	21h				;   CHMod + SetAtrib <4301>)

IFDEF DBLSPACE_HOOKS
   cmp  NoDblSpace,TRUE                 ; did we copy Dblspace.bin?
   je   cf_exit                         ; quit if not
   mov	dx,offset TargDblSpace
   mov	ax,(CHMod shl 8) + SetAtrib	; set file attributes to 0
   mov	cx,DOS_system_atrib		; DOS system file atributes
   INT	21h				;   CHMod + SetAtrib <4301>)
ENDIF

cf_exit:
   ret					;				       ;AN000;

   ENDPROC Close_File

   BREAK <SYS - Write_Boot_Record >
;******************* START OF SPECIFICATIONS ***********************************
;Routine name: Write_Boot_Record
;*******************************************************************************
;
;Description:	    Get a best guess EBPB and get the Media ID or fill the
;		    information in manually. Write out the canned boot record
;		    and then make IOCtl calls to set the EBPB and Media ID.
;
;Called Procedures: Create_Serial_ID
;
;Input: 	    None
;
;Output:	    Boot record on destination media is installed.
;
;Change History:    Created	   5/01/87	   FG
;
;******************* END OF SPECIFICATIONS *************************************
;******************+ START OF PSEUDOCODE +**************************************
;
;	START  Write_Boot_Record
;
;	get BPB using IOCtl Get Device Parameters (INT21 IOCtl + 0Dh <440d> CX=0860)
;	get volid, ser# and file type using IOCtl Get Media ID (INT21 IOCtl + 0Dh <440d> CX=086E)
;	if error and
;	get Extended error
;	if 'unknown media' - set fields manually
;		compute serial id and put in field (CALL Create_Serial_ID)
;		copy in volume label if available
;		set pointer to FAT1x (CALL FAT_Size)
;		move file system string into Boot_System_ID field
;	else
;		set fail flag
;		load return code (DOS error)
;	endif
;	if no fail flag
;		if fixed media
;			fill in Ext_PhyDrv in canned boot record
;		endif
;		set BPB using data from GET BPB IOCTL
;		write out canned boot record (INT26)
;		set volid, ser# and file type using Set Media ID (INT21 SetID <6900> CX=084E)
;	endif
;	ret
;
;	END  Write_Boot_Record
;
;******************-  END  OF PSEUDOCODE -**************************************

   public Write_Boot_Record

   Write_Boot_Record PROC NEAR

   mov	bl,TargDrvNum			; Drive number			       ;AN000;
   mov	dx,offset DeviceParameters	;				       ;AN000;
   mov	cx,(rawio shl 8) + get_device_parameters ; Generic IOCtl Request       ;AN000;
					;     CX=0860
   mov	ax,(IOCtl shl 8) + generic_ioctl ; get BPB using Set Device Parm       ;AN000;
   INT	21h				; IOCtl + gen_IOCtl_request <440d>     ;AN000;

   cmp	DOS_VER,0ffh			; is it DOS 3.3?		       ;AN019;
;  $if	ne				; only do a GET if DOS 4.00		;AN019;
   JE $$IF185
       lea  dx,IOCtl_Buf		; point to output buffer	       ;AN000;
       mov  ax,(GetSetMediaID shl 8) + 0 ; get volid, ser# and file type       ;AC008;
       INT  21h 			; GetSetMediaID + 0  INT 21 <6900>     ;AC008;

;      $if  c				; error - see if its 'unknown media'   ;AN000;
       JNC $$IF186

	   call Get_DOS_Error		; get error			       ;AN000;
	   cmp	al,old_type_media	;				       ;AN000;

;	   $if	e			;				       ;AN019;
	   JNE $$IF187
	       stc			; do it all manually		       ;AN019;
;	   $else			;				       ;AN019;
	   JMP SHORT $$EN187
$$IF187:
	       clc			; some other dos error occured - le    ;AN019;
;	   $endif			;	       it go by 	       ;AN019;
$$EN187:

;      $endif				;				       ;AN019;
$$IF186:
;  $else				;				       ;AN019;
   JMP SHORT $$EN185
$$IF185:
       stc				; do it all manually		       ;AN019;
;  $endif				;				       ;AN019;
$$EN185:

;  $if	c				; if it is pre 4.00 IBM format	       ;AN000;
   JNC $$IF193

       call Create_Serial_ID		; compute serial id and put in field   ;AN000;

					; find first with type = VOLUME ID

       mov  dx,OFFSET ExtFCB		; set up for FCB call		       ;AN019;
       mov  ah,Dir_Search_First 	; do a find first INT21 	       ;AN019;

       INT  21h 			;      Find_First <11xx>	       ;AN000;

       cmp  al,0			; was a match found?  al = 0 yes       ;AN019;
					;		      al = ff no
;      $if  e				; if so - copy it in		       ;AN000;
       JNE $$IF194

	   lea	si,DOS_BUFFER + 8	; source id is in DTA		       ;AN019;
	   lea	di,IOCtl_Vol_ID 	; destination is in IOCtl_Buf	       ;AN000;
	   mov	cx,file_spec_length	; move 11 bytes worth		       ;AN000;
	   cld				; copy it in			       ;AN000;
	   rep	movsb			;				       ;AN000;

;      $else
       JMP SHORT $$EN194
$$IF194:

	   clc				; leave it as default - NO NAME

;      $endif				; endif 			       ;AN000;
$$EN194:

					; NOTE:
					; since the GET MEDIA ID failed - its
					; pre 32 bit fat  - so no 32 bit math
					; is required.
       call FAT_Size			; set pointer to FAT1x		       ;AN000;

       mov  cx,FAT_len			; move file system string into	       ;AN000;
					;     Boot_System_ID field
       lea  di,IOCTL_File_Sys		; update buffer 		       ;AN000;
       cld				;				       ;AN000;
       rep  movsb			;				       ;AN000;
;  $endif
$$IF193:

;  $if	nc				;				       ;AN000;
   JC $$IF198

       lea  si,DeviceParameters.DP_BPB
       lea  di,boot.EXT_BOOT_BPB
       mov  cx,type EXT_BPB_INFO
       cld
       rep  movsb

       cmp  DeviceParameters.DP_BPB.BPB_MediaDescriptor,hard_drive ; is it Hard drive?;AC000;

;      $if  e				; if its a hard drive		       ;AC000;
       JNE $$IF199

					; NOTE: The physical hard drive number
					;	is placed in the third byte from
					;	the end in the boot sector in
					;	DOS 3.2. This is a change from
					;	the previous DOS versions.

					; fill in PhyDrv in canned boot record
	   mov	al,80h			; (set physical hard drive number)     ;AC016;
;      $else
       JMP SHORT $$EN199
$$IF199:
	   xor	al,al			; (set physical drive number to zero)  ;AC016;
;      $endif				;				       ;AC000;
$$EN199:

       mov  BOOT.EXT_PHYDRV,al		; (set physical hard drive number)     ;AC016;

       cmp  DOS_VER,0			;				       ;AN019;
;      $if  ne				; copy IOCTL stuff into boot record    ;AN019;
       JE $$IF202
					;     (no set ID available for 3.3)
	   lea	si,IOCtl_Ser_No_Low	; point to source buffer (IOCTL)       ;AN000;
	   lea	di,BOOT.EXT_BOOT_SERIAL ; point to target buffer (BOOT record) ;AN000;

	   mov	cx,IOCTL_Ser_Vol_SyS	; move serial # , Volid , System       ;AN019;
	   cld				;				       ;AN019;
	   rep	movsb			;				       ;AN019;
;      $endif				;				       ;AN019;
$$IF202:

       xor  cx,cx			; Sector 0			       ;AN019;
       mov  [packet],cx 		; set starting sector as 0	       ;AN019;
       mov  bx,offset BOOT		;				       ;AN019;
       mov  packet_buffer[0],bx 	;				       ;AN019;
       mov  word ptr [packet_sectors],1 ;				       ;AN019;
       mov  ah,1			; request a write		       ;AN019;
       call Direct_Access		;				       ;AN019;

;      $if  c				;				       ;AC000;
       JNC $$IF204
;      $endif				;				       ;AC000;
$$IF204:

       cmp  DOS_VER,0			;				       ;AN019
;      $if  e				; only do a SET if DOS 4.00
       JNE $$IF206
	   mov	bl,TargDrvNum		; Drive number			       ;AN000;
	   lea	dx,IOCtl_Buf		; point to output buffer	       ;AN000;
	   mov	ax,(GetSetMediaID shl 8) + 1 ; set volid, ser# and filetype    ;AC008;
	   INT	21h			; GetSetMediaID + 1  INT 21 <6901>     ;AC008;
;      $endif				;AN019;
$$IF206:

;  $endif				;				       ;AC000;
$$IF198:
   ret

   ENDPROC Write_Boot_Record

   BREAK <SYS - FAT_Size >
;******************* START OF SPECIFICATIONS ***********************************
;Routine name: FAT_Size
;*******************************************************************************
;
;Description:	    Determine FAT Type (12 or 16)
;
;		    NOTE: This routine is only called if the IOCtl call for
;			  Get Media Type FAILS with an extended error of
;			  'Unknown media type'.  This indicates it is a
;			  pre DOS 4.00 media (ie: it MUST be a 12 or old style
;			  16 bit FAT
;
;			  This is the same algorithm used by FORMAT
;
; Algorithm:
;
; UsedSectors = number of reserved sectors
;	 + number of FAT Sectors	( Number of FATS * Sectors Per FAT )
;	 + number of directory sectors	( 32* Root Entries / bytes Per Sector )
;
; t_clusters = ( (Total Sectors - Used Sector) / Sectors Per Cluster)
;
;   if T_Clusters <= 4086 then it a FAT12 - else - its a FAT16
;
;Called Procedures: None
;
;Input: 	    EBPB of Target media in memory
;
;Output:	    SI: points to  "FAT12    "
;			       or  "FAT16     "
;
;Change History:    Created	   5/01/87	   FG
;
;******************* END OF SPECIFICATIONS *************************************
;******************+ START OF PSEUDOCODE +**************************************
;
;	START  FAT_Size
;
;	Calculate the number of directory sectors
;	Calculate and add the number of FAT sectors
;	Add in the number of boot sectors
;	subtract used sectors from total sectors
;	if <= FAT THRESHOLD then
;		set pointer to FAT12
;	else
;		set pointer to FAT12
;	endif
;
;	ret
;
;	END  FAT_Size
;
;******************-  END  OF PSEUDOCODE -**************************************

   public FAT_Size

   FAT_Size PROC NEAR

					;--------------------------
					; Calculate UsedSectors
					;---------------------------

					; Calculate the number of directory sectors

   mov	ax, deviceParameters.DP_BPB.BPB_RootEntries ;			       ;AN000;
   mov	bx, TYPE dir_entry		;				       ;AN000;
   mul	bx				;				       ;AN000;
   add	ax, deviceParameters.DP_BPB.BPB_BytesPerSector ;		       ;AN000;
   dec	ax				;				       ;AN000;
   xor	dx,dx				;				       ;AN000;
   div	deviceParameters.DP_BPB.BPB_BytesPerSector ;			       ;AN000;
   mov	cx,ax				;				       ;AN000;

					; Calculate the number of FAT sectors

   mov	ax, deviceParameters.DP_BPB.BPB_SectorsPerFAT ; 		       ;AN000;
   mul	deviceParameters.DP_BPB.BPB_NumberOfFATs ;			       ;AN000;

					; Add in the number of boot sectors

   add	ax, deviceParameters.DP_BPB.BPB_ReservedSectors ;		       ;AN000;
   add	cx,ax				;				       ;AN000;

					;--------------------------
					; Calculate t_clusters
					;--------------------------

   mov	ax, deviceParameters.DP_BPB.BPB_TotalSectors ;			       ;AN000;

   sub	ax,cx				;Get sectors in data area	       ;AN000;
   xor	dx,dx				;				       ;AN000;
   xor	bx,bx				;				       ;AN000;
   mov	bl,deviceParameters.DP_BPB.BPB_SectorsPerCluster ;		       ;AN000;
   div	bx				;Get total clusters		       ;AN000;
   cmp	ax,BIG_FAT_THRESHOLD		;Is clusters < 4086?		       ;AN000;

;  $if	be				; if less then its a FAT12	       ;AN000;
   JNBE $$IF209
       lea  si,FAT_12			;				       ;AN000;
;  $else				;				       ;AN000;
   JMP SHORT $$EN209
$$IF209:
       lea  si,FAT_16			;				       ;AN000;
;  $endif				;				       ;AN000;
$$EN209:

   clc					; leave cleanly

   return				;				       ;AN000;

   ENDPROC FAT_Size

   BREAK <SYS - Create_Serial_ID >
;******************* START OF SPECIFICATIONS ***********************************
;Routine name: Create_Serial_ID
;*******************************************************************************
;
;Description:	    Create unique 32 bit serial number by getting current date
;		    and time and then scrambling it around
;
;Called Procedures: None
;
;Input: 	    None
;
;Output:	    serial number installed in Boot_Serial
;
;Change History:    Created	   5/01/87	   FG
;
;******************* END OF SPECIFICATIONS *************************************
;******************+ START OF PSEUDOCODE +**************************************
;
;	START  Create_Serial_ID
;
;	Get date (INT21 Get_Date + 00 <2A00>)
;	Get time (INT21 Get_Time + 00 <2C00>)
;	Boot_Serial+0 = DX reg date + DX reg date
;	Boot_Serial+2 = CX reg time + CX reg time
;	ret
;
;	END  Create_Serial_ID
;
;******************-  END  OF PSEUDOCODE -**************************************

   public Create_Serial_ID

   Create_Serial_ID PROC NEAR

   mov	ax,(Get_Date shl 8) + not_used	; Get date			       ;AN000;
   INT	21h				; Get_Date + not_used <2A00>	       ;AN000;
   mov	ax,(Get_Time shl 8) + not_used	; Get time			       ;AN000;
   INT	21h				; Get_Time + not_used <2C00>	       ;AN000;
   add	dx,dx				; Boot_Serial+0 = DX (date) + DX (date);AN000;
   add	cx,cx				; Boot_Serial+2 = CX (time) + CX (time);AN000;
   mov	IOCtl_Ser_No_Low,dx		; SERIAL # - low		       ;AN000;
   mov	IOCtl_Ser_No_Hi,cx		; SERIAL # - hi 		       ;AN000;

   ret					;				       ;AN000;

   ENDPROC Create_Serial_ID

   BREAK <SYS - Message >
;******************* START OF SPECIFICATIONS ***********************************
;Routine name: Message
;*******************************************************************************
;
;Description:  Display a message
;
;Called Procedures: SYSDISPMSG, Get_DOS_Error
;
;Input: 	    (AL) message number
;		    (AH) message class
;			  = C - DS:SI points to sublist
;
;Output: no error   AX = 0
;	    error - AX = error exit code
;
;Change History:    Created	   5/01/87	   FG
;
;******************* END OF SPECIFICATIONS *************************************
;******************+ START OF PSEUDOCODE +**************************************
;
;	START  Message
;
;	if DOS error
;		call Get_DOS_error
;	endif
;	move message class into place
;	reset insert  (CX)
;	reset response	(DL)
;	set output handle (BX)
;	if CLASS requires insert
;		load insert required
;	if CLASS requires response
;		flush keystroke buffer
;		load response required (Dir CON in no echo)
;	endif
;	call SysDispMsg to display message
;	if error or
;		call Get_DOS_error
;		call SysDispMsg to try again
;	if not success message
;		load error exit code
;	else
;		load success exit code
;	endif
;	ret
;
;	END  Message
;
;******************-  END  OF PSEUDOCODE -**************************************

   public Message

   Message PROC NEAR

   xor	dx,dx				; reset response  (DL)		       ;AN000;
   xor	cx,cx				; reset insert	(CX)		       ;AC024;
   dec	dh				; assume CLASS is Utility	       ;AN000;

   cmp	ah,PARSE_Error			;				       ;AN000;

;  $if	be,and				; if DOS or PARSE error 	       ;AN000;
   JNBE $$IF212

   mov	dh,ah				;				       ;AN000;

;  $if	e,and				; if PARSE error		       ;AN024;
   JNE $$IF212
   cmp	al,reqd_missing 		;				       ;AC024;
;  $if	ne				; and if theres something there        ;AC024;
   JE $$IF212

       push cs				; set up for insert		       ;AN024;
       pop  [insert_ptr_seg]		;   (offset set by parse routine)      ;AN024;
       mov  cs:[si],dl			; make it an ASCIIZ string	       ;AN024;
       mov  insert_number,dl		; zero out for %0
       mov  insert_max,030h		; set length to something reasonable   ;AN024;
       inc  cx				; there's an insert                    ;AC024;
       lea  si,SUBLIST			; point to the sublist		       ;AC024;

;  $endif				;				       ;AN024;
$$IF212:


   cmp	ah,DOS_Error			;				       ;AN000;

;  $if	be				; if DOS error			       ;AC019;
   JNBE $$IF214

       call Get_DOS_error		; to find out what message to display  ;AN000;
       mov  dh,DOS_Error		; ensure message type is DOS_Error     ;AN019;

;  $endif				;				       ;AN000;
$$IF214:

   mov	bx,STDERR			; set output handle (BX)	       ;AN000;

;M010
   cmp	ax,(util_B shl 8) + done 	; "System transferred" msg?
   jne  msg20                           ;   No, jump: output to STDERR.
   mov  bx,STDOUT                       ;   Yes: output to STDOUT.
msg20:
;M010

   cmp	ah,util_C			; is it CLASS C 		       ;AN000;

;  $if	e				; CLASS C requires insert	       ;AN000;
   JNE $$IF216

       inc  cx				; load insert required		       ;AN000;

;  $endif				;				       ;AN000;
$$IF216:

   cmp	ah,util_D			; is it CLASS D 		       ;AN000;

;  $if	e				; CLASS D requires response	       ;AN000;
   JNE $$IF218

       mov  dl,DOS_CON_INP		; load response required  - con: input ;AN000;

;  $endif				;				       ;AN000;
$$IF218:

   xor	ah,ah				;				       ;AN000;


   call SysDispMsg			; to display message		       ;AN000;

;  $if	c,and				; error and...............	       ;AN000;
   JNC $$IF220

   call SysDispMsg			; to try again		 :	       ;AN000;

;  $if	c				; if reaaly bad .........:	       ;AN000;
   JNC $$IF220

       mov  ax,return_error		; load error exit code		       ;AN000;

;  $else				;				       ;AN000;
   JMP SHORT $$EN220
$$IF220:

       mov  ax,success			; load success exit code	       ;AN000;

;  $endif				;				       ;AN000;
$$EN220:

   ret					;				       ;AN000;

   ENDPROC Message


   BREAK <SYS - Get_DOS_Error >
;******************* START OF SPECIFICATIONS ***********************************
;Routine name: Get_DOS_Error
;*******************************************************************************
;
;Description:  Call DOS to obtain DOS extended error #
;
;Called Procedures: None
;
;Input: 	    None
;
;Output:	    AX = error number
;
;Change History:    Created	   5/01/87	   FG
;
;******************* END OF SPECIFICATIONS *************************************
;******************+ START OF PSEUDOCODE +**************************************
;
;	START  Get_DOS_Error
;
;	call DOS for extended error (INT21 GetExtendedError + 00 <5900>)
;	set up registers for return
;	ret
;
;	END  Get_DOS_Error
;
;******************-  END  OF PSEUDOCODE -**************************************

   public Get_DOS_Error

   Get_DOS_Error PROC NEAR

   push bx
   mov	ax,(GetExtendedError shl 8) + not_used ; call DOS for extended error   ;AN000;
   xor	bx,bx
   push es				;				       ;AN000;
   INT	21h				;    GetExtendedError + not_used <5900>;AN000;
   pop	es
   pop	bx				;				       ;AN000;
   xor	cx,cx				; reset insert	(CX)		       ;AC024;

   ret					;				       ;AN000;

   ENDPROC Get_DOS_Error

ifdef DBCS
;------------------------------------------------------------------------------
;
;	***** DBCS functions *****
;

;
;	Test if the character is DBCS Lead Byte
;
;	input:	AL = character to check
;	outpit:	ZF = 1 if DBCS Lead Byte
;

DBCSLeadByteTable	dd	0

IsDBCSLeadByte		proc	near
	push	ax
	push	si
	push	ds
	lds	si,cs:DBCSLeadByteTable
	cmp	word ptr cs:DBCSLeadByteTable+2,0
	jnz	idlb_check		; if table is already set
	push	ax
	mov	ax,6300h
	int	21h			; get DBCS lead byte table
	pop	ax
	mov	word ptr cs:DBCSLeadByteTable,si
	mov	word ptr cs:DBCSLeadByteTable+2,ds
idlb_check:
	cmp	word ptr [si],0
	jz	idlb_not		; if end of table
	cmp	al,[si]
	jb	idlb_next		; if below low value
	cmp	al,[si+1]
	jbe	idlb_yes		; if below high value
idlb_next:
	add	si,2			; do next
	jmp	short idlb_check
idlb_not:
	or	al,1			; reset ZF
	jmp	short idlb_end
idlb_yes:
	and	al,0			; set ZF
idlb_end:
	pop	ds
	pop	si
	pop	ax
	ret
IsDBCSLeadByte		endp

;
;	Check if the character position is at Tail Byte of DBCS
;
;	input:	es:bx = start address of the string
;		es:di = character position to check
;	output:	ZF = 1 if at Tail Byte
;
CheckDBCSTailByte	proc	near
	push	ax
	push	cx
	push	di
	mov	cx,di			; save character position
cdtb_check:
	cmp	di,bx
	jz	cdtb_next		; if at the top
	dec	di			; go back
	mov	al,es:[di]			; get character
	call	IsDBCSLeadByte
	jz	cdtb_check		; if DBCS lead byte do next
	inc	di			; adjust
cdtb_next:
	sub	cx,di			; if the length is odd then
	xor	cl,1			; the character position is
	test	cl,1			; at the tail byte
	pop	di
	pop	cx
	pop	ax
	ret
CheckDBCSTailByte	endp

;------------------------------------------------------------------------------
endif


   CODE ENDS

   include msgdcl.inc

   END	START


=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\sys\path.asm ===
Page    ,132
        title   Path Searching Routines

; PATH.ASM - Code to search the environment for a particular data string,
; and to search the path for a particular file.  Adapted from the original
; COMMAND.COM version.
;
; Routines supported:
;       Find_in_Environment - locate the start of a given string
;                               in the environment
;       Path_Crunch - concantenates a file name with a directory path from
;                       the PATH environment variable
;       Search - Finds executable or other files, given a base name
;
        include dossym.inc
        include curdir.inc
        include find.inc
        include pdb.inc
        include syscall.inc

        DATA segment para public
Path_str        db      "PATH="
Path_str_size   equ     $ - offset Path_Str

Comspec_str     db      "COMSPEC="
Comspec_str_size equ    $ - offset Comspec_str

        DATA ends

        CODE segment para public
        assume	cs:CODE,ds:DATA

IFDEF DBCS
        extrn   IsDBCSLeadByte:near
ENDIF

;----------------------------------------------------------------------------
; Path_Crunch - takes a pointer into a environment PATH string and a file
; name, and sticks them together, for subsequent searching.
;
; ENTRY:
;   BH			--	additional terminator character (i.e., ';')
;   DS:SI		--	pointer into pathstring to be dissected
;   ES:DI               --      buffer to store target name
;   DX			--	pointer to filename
; EXIT:
;   SI			--	moves along pathstring from call to call
;   ES:DI               --      filled in with concatenated name
;   Carry set if end of path string has been reached.
;
;---------------
Path_Crunch PROC NEAR
        public  Path_Crunch
;---------------
        assume  ds:nothing
        assume  es:DATA

IFDEF DBCS
	xor	cl,cl				; clear flag for later use 3/3/KK
ENDIF

path_cr_copy:
	lodsb					; get a pathname byte
	or	al,al				; check for terminator(s)
	jz	path_seg			; null terminates segment & pathstring
	cmp	AL, BH
	jz	path_seg			; BH terminates a pathstring segment

IFDEF DBCS
	invoke	IsDBCSLeadByte			;
	jz	NotKanj2			;
	stosb					;
	movsb					;
	MOV	CL,1				; CL=1 means latest stored char is DBCS
	jmp	path_cr_copy			;

NotKanj2:					;
	xor	cl,cl				; CL=0 means latest stored char is SBCS
ENDIF

	stosb					; save byte in concat buffer
	jmp	path_cr_copy			; loop until we see a terminator

path_seg:
        push    si                              ; save resting place in env. seg.
	mov	BL, AL				; remember if we saw null or not...

path_cr_look:					; form complete pathname
	mov	al, '\'      			; add pathname separator for suffix

IFDEF DBCS
	or	cl,cl				;
	jnz	path_cr_store			; this is a trailing byte of ECS code 3/3/KK
ENDIF
	cmp	al,es:byte ptr [di-1]
	jz	path_cr_l1

path_cr_store:					
	stosb

path_cr_l1:
	mov	SI, DX

path_cr_l2:
	lods	byte ptr es:[si]       		; tack the stripped filename onto
	stosb					; the end of the path, up to and
	or	AL, AL				; including the terminating null
	jnz	path_cr_l2

path_cr_leave:
	or	BL, BL				; did we finish off the pathstring?
	clc
        jnz	path_cr_exit			; null in BL means all gone...
	cmc

path_cr_exit:
        pop     si                              ; retrieve
	ret

        assume  es:nothing

;---------------
Path_Crunch endp
;----------------------------------------------------------------------------

;----------------------------------------------------------------------------
;   SEARCH, when given a pathname, attempts to find a file with
; one of the following extensions:  .com, .exe (highest to
; lowest priority).  Where conflicts arise, the extension with
; the highest priority is favored.
; ENTRY:
;   DX		--	pointer to null-terminated pathname
;   BX  	--	dma buffer for findfirst/next
;   AL          --      0 if we should look for .COM and .EXE extensions
;                       1 if extensions is pre-specified
; EXIT:
;   AX		--	8)  file found with .com extension, or file with
;                           pre-specified extension found
;			4)  file found with .exe extension
;			0)  no such file to be found
;   DX          --      points to resolved path name 
;   DS          --      DATA
; NOTES:
;   1)	Requires caller to have allocated executed a setdma.
;       
;---------------
; CONSTANTS:
;---------------
search_attr                 equ         attr_read_only+attr_hidden
search_file_not_found	    equ 	0
search_com		    equ 	8
search_exe		    equ 	4
fname_len		    equ 	8
fname_max_len		    equ 	23
dot			    equ 	'.'
wildchar		    equ 	'?'

search_best                 db          (?)
;---------------
Search PROC NEAR
        public Search
;---------------
        push    si                              ; 
        push    ax                              ; save extension flag
	mov	DI, DX				; working copy of pathname

	mov	CX, search_attr 		; filetypes to search for
        mov     ah, Find_First			; request first match, if any
        int     21h
        pop     ax                              
	jc	search_no_file
        
        or      al,al                           ; looking for specific ext?
        jz      search_no_ext                   ; no, jump
        mov     search_best,search_com          ; report we found best match
        jmp     short search_file_found         ; yes, found it

search_no_ext:
        mov     search_best, search_file_not_found

search_loop:
	call	search_ftype			; determine if .com, &c...
	cmp	AL, search_best 		; better than what we've found so far?
	jle	search_next			; no, look for another
	mov	search_best, AL 		; found something... save its code
	cmp	AL, search_com			; have we found the best of all?
	je	search_done

search_next:					; keep on looking
	mov	CX, search_attr
        mov     ah, Find_Next                   ; next match
        int     21h
	jnc	search_loop

search_done:					; it's all over with...
        cmp     search_best, search_file_not_found
        je      search_no_file
        cmp     search_best, search_com
        mov     si, offset comext
        je      search_move_ext
        mov     si, offset exeext

search_move_ext:
        mov     di, dx
        mov     al, '.'
        mov     cx, DIRSTRLEN
        rep     scasb
        dec     di
        movsw   
        movsw   

search_file_found:
        mov     al, search_best
	jmp	short search_exit

search_no_file: 				; couldn't find a match
	mov	AX, search_file_not_found

search_exit:
        pop     si
	ret
Search endp
;----------------------------------------------------------------------------


;----------------------------------------------------------------------------
;   SEARCH_FTYPE determines the type of a file by examining its extension.
; ENTRY:
;   BX    --	    dma buffer containing filename
; EXIT:
;   AL	    --	    file code, as given in search header
;---------------
comext  db      ".COM",0
exeext  db      ".EXE",0

Search_Ftype PROC NEAR
        public Search_Ftype

	push	DI
	mov	AL, search_file_not_found			; find the end of the filename
	mov	DI, BX
        add     si,Find_Buf_Pname
	mov	CX, fname_max_len
	cld
	repnz	scasb				; search for the terminating null
	jnz	ftype_exit			; weird... no null byte at end
;
; Scan backwards to find the start of the extension
;
        dec     di                              ; point back to null
        mov     cx, 5                           ; . + E + X + T + null
        std                                     ; scan back
        mov     al, '.'
        repnz   scasb
        jnz     ftype_exit                      ; must not be any extension
        inc     di                              ; point to start of extension
        cld
;
; Compare .COM
;
	mov	si,offset comext
	mov	ax,di
	cmpsw
	jnz	ftype_exe
	cmpsw
	jnz	ftype_exe
	mov	AL, search_com			; success!
	jmp	short ftype_exit
;
; Compare .EXE
;
ftype_exe:					; still looking... now for '.exe'
	mov	di,ax
	mov	si,offset exeext
	cmpsw
	jnz	ftype_fail
	cmpsw
	jnz	ftype_fail
	mov	AL, search_exe			; success!
	jmp	short ftype_exit

ftype_fail:					; file doesn't match what we need
	mov	al,search_file_not_found

ftype_exit:
	pop	DI
	ret

Search_Ftype endp

;----------------------------------------------------------------------------
;
; Find_Comspec_In_Environment - find the beginning of the COMSPEC string
;       Entry : DS = DATA
;               ES = PSP
;       Exit  : ES:DI => start of Comspec path
;       

FIND_COMSPEC_IN_environment PROC NEAR
        public Find_Comspec_In_Environment
        lea     si,Comspec_str
	mov     cx,Comspec_str_size		; cx = length of name
        jmp     short Find_in_Environment
Find_Comspec_in_Environment        endp

;----------------------------------------------------------------------------
;
; Find_Path_In_Environment - find the beginning of the PATH string
;       Entry : DS = DATA
;               ES = PSP
;       Exit  : ES:DI => start of Path directory list
;       

FIND_PATH_IN_environment PROC NEAR
        public Find_Path_In_Environment
        lea     si,Path_str
	mov     cx,Path_str_size		; cx = length of name
; fall through to following
Find_Path_in_Environment        endp


; Find_In_Environment - locate a given string in the environment
;        
; Input :       SI = name to find in environment
;               CX = length of name
;               DS = DATA
;               ES = PSP segment
;
; Output: ES:DI points to the arguments in the environment
;	  carry is set if name not found
;

Find_in_Environment PROC NEAR
        public Find_In_Environment

	cld
        xor     di,di
        mov     ax,es:[di].PDB_Environ
        or      ax,ax                          ; is there an environment?
        jz      find_nf_exit                   ; no, quit now
        mov     es,ax
        assume  es:nothing        

find1:
        push    si
        push    cx                              ; save starting values
find11:

ifdef dbcs
	lodsb
	call	IsDBCSLeadByte
	jz	notkanj3
	dec	si
	lodsw
	inc	di
	inc	di
	cmp	ax,es:[di-2]
	jnz	find12
	dec	cx
	loop	find11
	jmp	short find12

notkanj3:
	inc	di
	cmp	al,es:[di-1]
	jnz	find12
	loop	find11

else    ;dbcs

        repe cmpsb   

endif   ;dbcs

find12:
        pop     dx
        pop     si                              ; clear stack
	jz      find_exit
        dec     di
	xor	al,al				; scan for a nul
	mov	cx,100h                         ; arbitrary size 
	repnz	scasb
	cmp	byte ptr es:[di],0              ; check for trailing null
        mov     cx,dx                           ; original count back in CX
	jnz	find1
	
find_nf_exit:
        stc					; indicate not found

find_exit:
	ret

Find_in_environment endp


CODE    ends
        end
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\sys\syshdr.inc ===
page    80,132
;******************* START OF SPECIFICATIONS ***********************************
;
;	Microsoft Confidential
;	Copyright (c) Microsoft Corporation 1991
;	All Rights Reserved
;
; MODULE NAME:          SYS1.ASM + SYS2.ASM + SYSSR.ASM
;
; DESCRIPTIVE NAME:     SYS
;
; FUNCTION:             Copies system programs BIOS.SYS and
;                       MSDOS.SYS onto a specified media.
;
; ENTRY POINT:
;
; INPUT:
;
; EXIT NORMAL:
;
; EXIT ERROR:
;
; INTERNAL REFERENCES:
;
;       ROUTINES:
;
;       DATA AREAS:
;
; EXTERNAL REFERENCES:
;
;       ROUTINES:
;
;       DATA AREAS:
;
; NOTES:  Version 4.0 is a MAJOR diversion from all previous versions of DOS.
;
;         In all older versions of SYS the target diskette, HAD to meet the
;         following criteria in order to be SYSed:
;                       - there must be enough physical room for BIOS and
;                         MSDOS.
;                       - the first data cluster (#2) had to be either not
;                         used - or owned by IBMBIO allready on the disk
;                       - The first 2 root DIR entries had to be unused, deleted
;                          or owned by IBMBIO and IBMDOS.
;
;         4.0 SYS is far less restrictive.
;                       - there must still be enough physical room for BIOS
;                         and MSDOS.
;                       - SYS will free up all required data clusters required
;                         by MSBIO.
;                       - The 2 root DIR entries for MSDOS and BIOS may
;                         be anywhere in the root.  SYS will move entrys
;                         in order for BIOS and MSDOS to be in their proper
;                         positions.
;        *** NOTE ****  - Sys will operate on DOS 3.2, 3.3 and 4.0.
;                         This has reqired a HARD CODED lower bound - DOS_low
;                         that is set in this file to 3.20
;
; REVISION HISTORY: Ax000  Version 4.0  05/01/87 - first release             FG
;                   Ax001          4.0  PTR P324                         D Love
;                   Ax002          4.0  PTR P583                             FG
;                   Ax003          4.0  DCR D4    - sys anything,anywhere    FG
;                   Ax004          4.0  DCR D201  - extended arbib change    FG
;                   Ax005          4.0  PTR P1334 - 1.2 MB + system  hang    FG
;                   Ax006          4.0  PTR P1403 - BIO & DOS wrong spots    FG
;                   Ax007          4.0  PTR P1404,5 - DIR search error       FG
;                   Ax008          4.0  PTR P1406 - IOCTL to INT 21-69       FG
;                   Ax009          4.0  PTR P1637 - full 720KB error         FG
;                   Ax010          4.0  PTR P1764 - single file error        FG
;                   Ax011          4.0  PTR P1772 - IBMBIO cluster chain     FG
;                   Ax012          4.0  PTR P1710 - ASSIGN or SUBST invalid  FG
;                   Ax013          4.0  PTR P1872 - ROOT restoration problem FG
;                   Ax014          4.0  PTR P1884 - more ROOT problems       FG
;                   Ax015          4.0  PTR P2165 - ROOT DIR above #100h sec.FG
;                   Ax016          4.0  DCR D304  - change in BOOT.INC       FG
;                   Ax017          4.0  PTR P2356 - HILDA error message      FG
;                   Ax018          4.0  PTR P2769 - no system on default drv FG
;                   Ax019          4.0  DCR D380  - run on current VER -1    FG
;                   Ax020          4.0  PTR P3028 - run using PATHGEN        FG
;                   Ax021          4.0  DCR D494  - add "source" & DOS 3.2   FG
;                   Ax022          4.0  PTR P3728 - wrong network message    FG
;                   Ax023          4.0  DCR D503  - Version is now 4.0       FG
;                   Ax024          4.0  PTM P3905 - fix parse error format   FG
;                   Ax025          4.0  PTM P4118 - fix message error        FG
;
; PRE-VERSION 4.0 HISTORY:
;
;   1.6     05/21/82    Added rev number message
;   1.61    06/04/82    Allow SYS to blank disk TimP at SCP
;   1.70    06/30/82    NON contiguous DOS allowed on 2.00 IBM.  Allows SYS to
;                       1.0 1.1 disks.
;   1.71    07/02/82    Put in CHDIRs to make sure everything done in root dir.
;   1.80    04/26/83    MZ make sys work in small machines; use full 2.0
;                       system calls
;   1.81    07/22/83    ARR Added check in IBM version for valid FAT ID on
;                       destination because of IBM problem with SYSing to
;                       unformatted disks which are really formatted.  Prints
;                       NoDest message for ridic IBM reasons, should have a
;                       better message.
;   1.82    08/12/83    ARR ZIBOed again.  Mark fails to check for errors on
;                       his file I/O.  Results in SYS saying system
;                       transferred when it hasn't been.
;   1.83    09/08/83    EKE Added code to quit if sys called on a drive across
;                       a net.
;   1.84    09/09/83    CHRISP grabbed against his will to make this stupid
;                       program write out a boot sector
;   1.85    10/18/83    NP Printf to print messages and it's now an .EXE file
;   1.86    11/8/83     MZ fix hard file output of boot sector
;   1.87    5/1/84      MZ make sys prompt for system disk in default drive.
;   3.20    11/9/84     RS make sys write out a correct boot sector for the
;                       version of DOS. It grabs the boot sector off the system
;                       disk and inserts the correct BPB.
;                       Uses IOCTL Get Device Parms to get BPB for a Hard drive.
;   3.20    08/5/85     RS Allow FAT ID byte of 0F0H for 'strange' media
;                       layouts. These come about because of /T /N switches in
;                       FORMAT.
;   3.20    09/16/85    Incorporate tables of filenames to allow system files
;                       used by other OEMs to be SYSed onto disks formatted on
;                       other MSDOS systems. Allows the flexibility to replace
;                       system files for one OEM by system files for another.
;
;
;   3.30    06/04/86    MT removes initial check for IBMBIO and DOS - not needed
;                       because of later search of dirs
;   3.30    06/16/86    MT only force part of IBMBIO contig - do this by assuming
;                       contig part smaller than 1.10 BIOS
;   3.30    06/16/86    MT Check diks space for enough room to install BIO and DOS
;
; POST-VERSION 4.0 HISTORY:
;
;    Date    Who   #			  Description
;  --------  ---  ---  ------------------------------------------------------
;  02/05/91  DLB  M011 Added "no_mem" and "XFER_BUF".
;
;******************* END OF SPECIFICATIONS *************************************
        BREAK   <SYS1 - Program Organization>
;******************+ START OF PSEUDOCODE +**************************************
;
;Ä¿   Ä¿     Ä¿
; Main Â´Init_Input_OutputÂ´SysLoadMsg (DOS version check)
;      
;                                 Ä¿
;                                 Parse_Command_Line
;                                  
;          Ä¿ Ä¿
;          Ã´Validate_Target_DriveÂ´Check_Default_Drive
;          Ù³
;                                 Ä¿
;                                 Ã´Check_Target_Drive
;                                 
;                                 Ä¿
;                                 Check_For_Network
;                                  
;          Ä¿      Ä¿
;          Ã´Get_System_FilesÂ´Prompt_For_Media
;               
;                                 Ä¿
;                                 Ã´Check_Removable
;                                 
;                                 Ä¿
;                                 Ã´Open_File
;                                 
;                                 Ä¿
;                                 Fill_Memory
;                                  
;          Ä¿  Ä¿
;          Ã´Check_SYS_ConditionsÂ´Verify_File_System
;           
;                                 Ä¿                 
;                                 Ã´Read_DirectoryÄ´Prompt_For_Media
;                                                  
;                                 Ä¿
;                                 Ã´Verify_File_Location
;                                 
;                                 Ä¿   Ä¿
;                                 Determine_Free_SpaceÄ´Get_Cluster
;                                     
;          Ä¿                Ä¿          Ä¿
;          Ã´Do_SYSÂ´Create_SystemÄ´Create_File
;                                   
;                                      Ä¿
;                                 Ã´Fill_Memory
;                                      
;                                 Ä¿
;                                 Dump_Memory
;                                  
;          Ä¿                Ä¿
;          Ã´Do_EndÂ´Close_Files
;                         
;                                 Ä¿      Ä¿
;                                 Write_Boot_RecordÂ´Create_Serial_ID
;                                       
;                                                          Ä¿
;                                                          FAT_Size
;                                                           
;          Ä¿            Ä¿
;          Message   Ä´Get_DOS_Error
;                       
;
;******************-  END  OF PSEUDOCODE -**************************************
        BREAK   <SYS - Segment Definition>
                                        ;---------------------------------------
                                        ;  NOTE: Structures used by SYS include:
                                        ;
                                        ;   find_buf           - DTA mapper
                                        ;   a_bpb              - EBPB struc
                                        ;   dir_entry          - Directory struc
                                        ;   A_DeviceParameters - IOCtl struc
                                        ;   BootForm           - Boot Rec struc
                                        ;---------------------------------------


;       INCLUDE DOSSYM.INC              ;also defines version of dos
.xlist
.xcref
        INCLUDE DOSSYM.INC
	include bpb.inc
.cref
.list


;       INCLUDE IOCTL.INC               ; Get / Set Device Parameters IOCTL
.xlist
.xcref
        INCLUDE IOCTL.INC
.cref
.list


;       INCLUDE BOOTFORM.INC            ; Boot Record Structure
.xlist
.xcref
        INCLUDE BOOTFORM.INC
.cref


;       INCLUDE PATHMAC.INC            ; PATH macro for PATHGEN
.xlist
.xcref
        INCLUDE PATHMAC.INC
.cref
.list

;IBMJAPVER EQU	 FALSE			 ; this and the following are mutually	MSKK01 07/18/89
;IBMVER  EQU	 TRUE			 ; exclusive				MSKK01 07/18/89

CODE    SEGMENT PARA PUBLIC
CODE    ENDS

DATA    SEGMENT PARA PUBLIC
DATA    ENDS

; The following must be defined to turn on the code which relocates the
; owner of the first few clusters, if it is not IBMBIO.  Although the
; entire IBMBIO file need not be contiguous, the number of clusters
; required to contain IBMLOADSIZE sectors (defined in BOOTFORM.INC) must
; be.  These sectors need not be located in the first sectors of the disk's
; data area, but we still claim the first clusters, rather than rewrite the
; code which moves things around.

NEED_CLUSTER_2  equ     TRUE            ; this must be defined to turn on
                                        ; the code which relocates the
                                        ; owner of the first few clusters
                                
                                        ;--------------------------------------
                                        ; constants
                                        ;--------------------------------------

DOS_low                 equ  0300h + 20 ; 3 in high reg, 20 in low reg.        ;AN023;
not_used                equ  0          ; filler for INT 21's
num_2_letter            equ  040h       ; turn dirve number to letter
dev_local               equ  9          ; IOCtl - get device parameters
removable               equ  01h        ; for testing removeability
net_drive               equ  01000h     ; for testing net drive
DOS_system_atrib        equ  7          ; DOS system file atributes
DOS_volume_atrib        equ  8          ; DOS volume label atribute
error_RC                equ  1          ; error return code
any_error               equ  255        ; mask for detecting errors
success                 equ  0          ; successful completion of SYS
LSeek_EOF               equ  2          ; seek relative to eof
LSeek_Start             equ  0          ; seek relative to beginning
old_type_media          equ  26         ; DOS extended error - old type media
file_not_found          equ  2          ; DOS extended error - file not found
file_spec_length        equ  11         ; length of file name
empty                   equ  0          ; empty directory entry
deleted                 equ  0E5h       ; entry is deleted
SetAtrib                equ  01h        ; set file attributes
set                     equ  1          ; set file date and time
BIG_FAT_THRESHOLD       equ  4086       ; size break for FAT12 - FAT16
PRELOAD                 equ  1          ; normal preload
return_error            equ  1          ; SYS return error code
FQ_DOS_DIR_CON_INP      equ  07h        ; Flush Queue / Direct CON in no echo
hard_drive              equ  0F8H       ; Media Descriptor for Hard drive
first_drive             equ  80H        ; first physical hard drive number
noerror                 equ  0          ; no errors
FAT_sect_size           equ  12         ; FAT sector count
dot                     equ  02Eh       ; Sub DIR DOT
bad_sector              equ  0F7h       ; FAT bad sector mark
end_cluster             equ  0FFh       ; FAT last cluster mark
not_found               equ  0FFh       ; current cluster not yet found
cluster_ent_per_sect    equ  512/2      ; (bytes/sector) / (bytes/cluster entry)
                                        ;    = cluster entries / sector
clusters_loaded         equ  cluster_ent_per_sect * FAT_sect_size ; = # of cluster
                                        ;    entries loaded in 12 sectors.

FAT_BUF                 equ  512 * 13   ; This space is used to do a number
                                        ;  of tasks. It existes at the START
                                        ;  of BUF. It is used as a 1 sector
                                        ;  buffer for processing DIR sector
                                        ;  manipulation. It is also used to
                                        ;  process the FAT. NOTE: a 12 bit fat
                                        ;  has a max. of FFFh (4K) entries - or
                                        ;  6K of space - or 12 sectors (512 bytes)
                                        ;  an extra 512 bytes is added for safety

XFER_BUF                equ  4096       ; M011: Minimum Transfer buffer size
                                        ;  (an arbitrary, but reasonable
                                        ;  value).  The actual Transfer buffer
                                        ;  may be larger than this.

                                        ;----------------------------------------
                                        ;  definition of the MODE bits
                                        ;     for an extended open
                                        ;----------------------------------------

;                 BITS DEFINED FOR THE MODE WORD
;                       FORMAT = 0WF0000CISSS0AAA
;              Write   Ù³        Access code
;                0 = no commit                      0 = read
;                1 = auto commit                    1 = write
;                                                   2 = read/write
;          Fail action                  3 = execute
;            0 = INT 24h                             4 = FCB
;            1 = return error           
;                                         Sharing mode
;             Code Page support Ù³         0 = compatability
;               0 = validate code page            1 = deny read/write
;               1 = no code page check            2 = deny write
;                                                 3 = deny read
;                                                 4 = deny none
;                                      Inherit
;                                        0 = pass handle to child
;                                        1 = no inherit
;
MODE_COM                equ  0100000000000000b ; Auto Commit
MODE_NO24               equ  0010000000000000b ; No 24 - return error
MODE_NOCP               equ  0000000100000000b ; No 24 - return error
MODE_NOINH              equ  0000000010000000b ; No child procees access
;                                            Sharing mode
;MODE_SH_COMP   equ       0000000000000000b        0 = compatability
MODE_SH_D_RW            equ  0000000000010000b ;    1 = deny read/write
MODE_SH_D_W             equ  0000000000100000b ;    2 = deny write
MODE_SH_D_R             equ  0000000000110000b ;    3 = deny read
MODE_SH_D_NONE          equ  0000000001000000b ;    4 = deny none
;                                            Access code
;MODE_AC_R      equ       0000000000000000b        0 = read
MODE_AC_W               equ  0000000000000001b ;    1 = write
MODE_AC_RW              equ  0000000000000010b ;    2 = read/write
MODE_AC_EXE             equ  0000000000000011b ;    3 = execute
MODE_AC_FCB             equ  0000000000000100b ;    4 = FCB

open_mode               equ  MODE_NO24+MODE_NOCP+MODE_NOINH+MODE_SH_D_RW+ MODE_AC_RW

                                        ;----------------------------------------
                                        ; Message Number Equates
                                        ;----------------------------------------

util                    equ  0ffh       ; all Utility messages
DOS_error               equ  1          ; DOS error CLASS
PARSE_error             equ  2          ; PARSE error CLASS
util_B                  equ  0bh        ; Utility CLASS B messages
                                        ;   (plain message)
util_C                  equ  0ch        ; Utility CLASS C messages
                                        ;   (insert message)
util_D                  equ  0dh        ; Utility CLASS D messages
                                        ;   (wait message)
extended_15             equ  15         ; DOS extended error 15
reqd_missing            equ  2          ; PARSE error 2

                                        ; CLASS B
no_room                 equ  7          ; No room for system on destination disk   Old
system_not_found        equ  8          ; Invalid path or System files not found   Old
done                    equ  9          ; System transferred                       Old
no_sys_on_def           equ  10         ; No system on default drive               Old
not_on_default          equ  11         ; Can not specify default drive            New
write_fail              equ  12         ; Write failure, diskette unusable         New
bad_path                equ  19         ; Invalid path
cant_read_system        equ  20         ; error reading system files
cant_sys_target         equ  21         ; SYS can not operate on target drive
CMD_NOT_PROCESSED	equ  25         ; can't transfer command.com
no_mem                  equ  26         ; M011: Insufficient memory

                                        ; CLASS C

cant_network            equ  13         ; Cannot %1 to a Network drive             Old
sys_disk                equ  14         ; Insert system disk in drive %1           Old
dest_disk               equ  15         ; Insert destination disk in drive %1      Old
cant_sys                equ  16         ; Not able to SYS to %1 file system        New
cant_assign             equ  18         ; Cannot %1 a SUBSTed or ASSIGNed drive    Old
src_targ_same           equ  19         ; Source path and target drive cannot be the same ;C04

                                        ; CLASS D

press_key               equ  17         ; Press any key to continue. . .           Change

MSG_OPTIONS_FIRST	equ	300	; first options help message
MSG_OPTIONS_LAST        equ     303     ;  last one


                        BREAK <SYS >


=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\sys\syssr.asm ===
; SYSSR.ASM
;
;	Microsoft Confidential
;	Copyright (c) Microsoft Corporation 1991
;	All Rights Reserved


	INCLUDE SYSHDR.INC

; include SYSMSG.INC

.xlist
.xcref

	include SYSMSG.INC		;				       ;AN000;

.cref
.list

	MSG_UTILNAME <SYS>		;				       ;AN000;

CODE	SEGMENT PARA PUBLIC

ASSUME	CS:CODE,DS:nothing,ES:nothing

	PUBLIC	SYSDISPMSG, SYSLOADMSG, SYSPARSE
	PUBLIC	Data_Space

;;dcl	MSG_SERVICES <MSGDATA>		;				      ;AN000;

;  MSG_SERVICES <SYS.CL1,SYS.CL2,SYS.CLA,SYS.CLB,SYS.CLC,SYS.CLD>		;AN000;

.xlist
.xcref

	MSG_SERVICES <SYS.CL1,SYS.CL2,SYS.CLA,SYS.CLB,SYS.CLC,SYS.CLD> ;       ;AN000;

.cref
.list

;  MSG_SERVICES <LOADmsg,DISPLAYmsg,INPUTmsg,CHARmsg,NOVERCHECKmsg>

.xlist
.xcref

	MSG_SERVICES <LOADmsg,DISPLAYmsg,INPUTmsg,CHARmsg,NOVERCHECKmsg> ;		     ;AN000;

.cref
.list


false	=	0			;				       ;AN000;

DateSW	equ	false			;				       ;AN000;
TimeSW	equ	false			;				       ;AN000;
CmpxSW	equ	false			;				       ;AN000;
KeySW	equ	false			;				       ;AN000;
QusSW	equ	false			;				       ;AN000;
Val1SW	equ	false			;				       ;AN000;
Val2SW	equ	false			;				       ;AN000;
Val3SW	equ	false			;				       ;AN000;
SwSW	equ	true			;				       ;AN000;
NumSW	equ	false			;				       ;AN000;
CAPSW	equ	false			; Perform CAPS if specified	       ;AN000;


ASSUME	CS:CODE,DS:CODE,ES:nothing

; include parse.asm

;xlist
;xcref

include version.inc
include parse.asm			;				       ;AN000;

.cref
.list

Data_Space LABEL BYTE			;				       ;AN000;



CODE	Ends

include msgdcl.inc

	End
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\subst\_parse.asm ===
page	60,132
name	_parse
title	C	to PARSER interface

;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

;-------------------------------------------------------------------
;
;	MODULE: 	_parse
;
;	PURPOSE:	Supplies an interface between C programs and
;			the DOS 3.3 parser
;
;		      **(Customized for the SUBST utility)
;
;	CALLING FORMAT:
;			parse(&inregs,&outregs);
;
;	DATE:		5-21-87
;
;-------------------------------------------------------------------

;	extrn	sysparse:far

	public	_parse								;AN000;

;-------------------------------------------------------------------

; set for SUBST
; -------------

FarSW	equ	0			; make sysparse be a NEAR proc		;AN000;
TimeSW	equ	0			; Check time format			;AN000;
FileSW	equ	1			; Check file specification		;AN000;
CAPSW	equ	1			; Perform CAPS if specified		;AN000;
CmpxSW	equ	0			; Check complex list			;AN000;
NumSW	equ	0			; Check numeric value			;AN000;
KeySW	equ	0			; Support keywords			;AN000;
SwSW	equ	1			; Support switches			;AN000;
Val1SW	equ	0			; Support value definition 1		;AN000;
Val2SW	equ	0			; Support value definition 2		;AN000;
Val3SW	equ	0			; Support value definition 3		;AN000;
DrvSW	equ	1			; Support drive only format		;AN000;
QusSW	equ	0			; Support quoted string format		;AN000;
;-------------------------------------------------------------------

DGROUP	GROUP	_DATA
PGROUP	GROUP	_TEXT

_DATA	segment byte public 'DATA'	;AN000;
BASESW	=	1			;SPECIFY, PSDATA POINTED TO BY "DS"
INCSW	=	0			;PSDATA.INC IS ALREADY INCLUDED
	include version.inc
	INCLUDE PSDATA.INC		;PARSER'S WORK SPACE
_DATA	ends				;AN000;

_TEXT	segment byte public 'CODE'	;AN000;

	ASSUME	CS: PGROUP		;AN000;
	ASSUME	DS: DGROUP		;AN000;

;-------------------------------------------------------------------
include parse.asm			; include the parser			;AN000;
;-------------------------------------------------------------------

_parse	proc	near								;AN000;

	push	bp			; save user's base pointer              ;AN000;
	mov	bp,sp			; set bp to current sp			;AN000;
	push	di			; save some registers			;AN000;
	push	si								;AN000;

;	copy C inregs into proper registers

	mov	di,[bp+4]		; fix di (arg 0)			;AN000;

;-------------------------------------------------------------------

	mov	ax,[di+0ah]		; load di				;AN000;
	push	ax			; the di value from inregs is now on stack;AN000;

	mov	ax,[di+00]		; get inregs.x.ax			;AN000;
	mov	bx,[di+02]		; get inregs.x.bx			;AN000;
	mov	cx,[di+04]		; get inregs.x.cx			;AN000;
	mov	dx,[di+06]		; get inregs.x.dx			;AN000;
	mov	si,[di+08]		; get inregs.x.si			;AN000;
	pop	di			; get inregs.x.di from stack		;AN000;

	push	bp			; save base pointer			;AN000;

;-------------------------------------------------------------------
	call	sysparse		; call the parser			;AN000;
;-------------------------------------------------------------------

	pop	bp			; restore base pointer			;AN000;
	push	di			; the di value from call is now on stack;AN000;
	mov	di,[bp+6]		; fix di (arg 1)			;AN000;

	mov	[di+00],ax		; load outregs.x.ax			;AN000;
	mov	[di+02],bx		; load outregs.x.bx			;AN000;
	mov	[di+04],cx		; load outregs.x.cx			;AN000;
	mov	[di+06],dx		; load outregs.x.dx			;AN000;
	mov	[di+08],si		; load outregs.x.si			;AN000;

	lahf				; get flags into ax			;AN000;
	mov	al,ah			; move into low byte			;AN000;
	mov	[di+0ch],ax		; load outregs.x.cflag			;AN000;

	pop	ax			; get di from stack			;AN000;
	mov	[di+0ah],ax		; load outregs.x.di			;AN000;

;-------------------------------------------------------------------

	pop	si			; restore registers			;AN000;
	pop	di								;AN000;
	mov	sp,bp			; restore sp				;AN000;
	pop	bp			; restore user's bp                     ;AN000;
	ret									;AN000;

_parse	endp									;AN000;

_TEXT	ends				; end code segment			;AN000;
	end									;AN000;

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\sys\sys2.asm ===
;******************************************************************************
;
;	Microsoft Confidential
;	Copyright (c) Microsoft Corporation 1991
;	All Rights Reserved
;
;  Change Log:
;
;    Date    Who   #			  Description
;  --------  ---  ---  ------------------------------------------------------
;  03/29/90  EGH  C06  Problem fixed - the buffer for the system files was
;		       being overwritten when a cluster needed to be moved
;		       and the cluster size was greater than 4K.  Fix is to
;		       use the system file buffer for cluster transfers and
;		       load in the system files afterwards.
;  11/16/90  DB   M005 Fixed problems involving large cluster numbers.
;  11/19/90  DB   M006 Fixed incorrect tests for last FAT entry.
;  11/20/90  DB   M007 Fixed over-write of root directory during the flush
;		       of FAT buffer to FAT #2 in Check_FAT.
;  11/21/90  DB   M008 Update CDS following move of subdirectory.
;
;******************************************************************************
	TITLE	SYS-2-	Program
	include version.inc
	include dpb.inc
	include syscall.inc
	INCLUDE SYSHDR.INC
        include sysvar.inc              ;M008
        include curdir.inc              ;M008

	page	80,132
	BREAK	<SYS2 - Program Organization>
;******************+ START OF PSEUDOCODE +**************************************
;        Ä¿	Ä¿
; Read_Directory Ä´Find_DPB 
;        	
;          Ä¿
; Verify_File_LocationÄ¿
;           
; 
;  Ä¿   Ä¿         
; Ä´Move_DIR_EntryÂ´Find_Empty_Entry Ä´Direct_Access
;             
; 		      Ä¿
; 		      Direct_Access
; 		       
;   - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
;  Ä¿     Ä¿	    Ä¿
; Ä´Free_ClusterÂ´Is_It_EmptyÄ´Unpack 
;       	    
;		      Ä¿	        
;		      Ã´Search_FATÂ´Unpack 
;		      	       
;		       		   Ä¿
;		       		   Ã´Pack  
;		       		   
;		       		   Ä¿      
;		       		   Ã´Find_Empty_ClusterÄ´Unpack 
;		       		         
;		       		   Ä¿ 	         
;		       		   Ã´Xfer_DataÄ´Direct_Access
;		       		    	         
;		       		          
;	 		   Direct_Access
;					           
;	Ä¿	 Ä¿	        
;	Search_DIRÄ´Search_LoopÂ´Unpack 
;	 	 	       
;					   Ä¿
;					   Ã´Pack  				     Direct_Access
;					   
;					   Ä¿      
;					   Ã´Find_Empty_ClusterÄ´Unpack 
;					         
;					   Ä¿      
;					   Ã´Sub_DIR_LoopÄ´Unpack 
;					         
;					   Ä¿ 	         
;					   Ã´Xfer_DataÄ´Direct_Access
;					    	         
;					          
;					   Direct_Access
;					           
;
;******************+ END OF PSEUDOCODE +*****************************************
	BREAK	<SYS2 - Data space>

	DATA	SEGMENT PARA PUBLIC

	extrn	TargDrvNum:BYTE, TargSpec:WORD, bio_owns_it:BYTE, DOS_VER:BYTE
	extrn	packet_sectors:WORD, packet_buffer:WORD, packet:WORD
        extrn   TargDrv:BYTE            ;M008

	public	THIS_DPB, BUF, DIR_SECTOR, first_dir_sector


;			$SALUT (4,25,30,41)

first_dir_sector	dw   ?
current_dir_sector	dw   ?
last_dir_sector 	dw   ?
entries_per_sector	db   ?
current_entry		db   3
source_ptr		dw   ?
ibmbio_status		db   ?
ibmdos_status		db   ?
FAT_sectors		dw   FAT_sect_size ; initailize it to 12 sectors
FAT_changed		db   0		; FAT must be written - its packed
FAT_2			db   0		; if non zero, [packet] points at FAT 2
cluster_count		dw   ?		; number of clusters that must be free
last_cluster		dw   0		; cluster pointing to [current_cluster]
current_cluster 	dw   2		; start at cluster 2
next_cluster		dw   0		; cluster [current_cluster] points at
empty_cluster		dw   0		; newly aquired cluster
cluster_low		dw   0
cluster_high		dw   clusters_loaded

l_sector_offset 	dw   ?		; this is the value required to convert
					;  a sector from a cluster # to a
					;  logical sector # for INT 25 & 26

DIR_cluster		dw   0		; Sub DIR cluster being processed
					;  = 0 - not processing s Sub DIR
					;  = 1 - starting to process
					;	 (set by Search_Loop)
					;  = n - Sub DIR cluster now being
					;	 processed. (set by Xfer_Data)
present_cluster 	dw   ?		; current cluster for DIR search
sector_offset		dw   ?		; current sector in present_cluster
entry_number		db   ?		; DIR entry in current sector
FRAME_ptr		dw   ?
dir_sector_low		dw   ?
dir_sector_hi		dw   ?
DIR_offset		dw   ?
sector_count		db   1

FRAME			STRUC

p_cluster		dw   ?		; current cluster for DIR search
s_offset		dw   ?		; current sector in present_cluster
e_number		db   ?		; DIR entry in current sector

FRAME			ENDS

BIGFAT			DB   0		;0=12 bit FAT, NZ=16bit FAT
EOFVAL			DW   0FF8H	;0FF8 for 12 bit FAT,0FFF8 for 16 bit
BADVAL			DW   0FF7H	;0FF7 for 12 bit FAT,0FFF7 for 16 bit

THIS_DPB		DD   ?		;Pointer to drive DPB
CSIZE			DW   ?		;Sectors per cluster
SSIZE			DW   ?		;bytes per sector
DSIZE			DW   ?		;# alloc units on disk
FSIZE			DW   ?		;# sectors in 1 FAT
first_FAT		DW   ?		; first cluster of first FAT
num_of_FATS		db   ?		; number of FATS
MCLUS			DW   ?		;DSIZE + 1
;
; The following is used as the source/destination for a name trans
;
ENTRY_BUF		DB   size dir_entry DUP (?)
DIR_BUF 		DB   ( 34 * size frame) DUP (?) ; space for DIR frames - see Search_DIR
DIR_SECTOR		DB   512 DUP (?) ; space for 1 DIR sector

BUF			LABEL BYTE	; beginning of area for file reads

			DATA ENDS

;  $SALUT (4,4,9,41)

   CODE SEGMENT PARA PUBLIC

   ASSUME cs:CODE, ds:nothing, es:nothing

   BREAK <SYS - Find_DPB >
;******************* START OF SPECIFICATIONS ***********************************
;Routine name:	Find_DPB
;*******************************************************************************
;
;Description:	Find_DPB gets the pointer to the Target DPB and initializes all
;		local valiables required by Move_DIR_Entry and Free_Cluster.
;
;               If this function finds a disk with only one FAT, it will
;               refuse to allow SYS to run on it.
;
;NOTE:		This routine contains code that is specific for DOS 3.3.  It
;		must be removed for subsequent releases.  In and before
;		DOS 3.3 the DPB was one byte smaller.  The field dpb_FAT_size
;		was changed from a byte to a word in DOS 4.00.
;
;
;Entry: 	Called by Verify_File_Location
;
;Called Procedures:
;
;		INT 21 - 32h
;
;Input: 	al = Drive number
;
;Output:	All local variables initalized
;		DS:BX = pointer to DPB
;               Carry set and AX == error message number if only 1 FAT
;               on disk
;
;Change History: Created	7/01/87 	FG
;
;******************* END OF SPECIFICATIONS *************************************
;******************+ START OF PSEUDOCODE +**************************************
;
;	START Find_DPB
;
;	get DPB pointer (INT 21 - 32h)
;	initalize first_dir_sector
;	initalize current_dir_sector
;	initalize current_cluster (0 for root)
;	calculate # of clusters required by IBMBIO
;	initalize [cluster_count]
;	calculate # of dir sectors
;	initalize [dir_sectors]
;	initalize [current_entry] to #3
;	allocate memory for FAT + 32 DIR frames
;	allocate memory for data sectors
;
;	ret
;
;	END Find_DPB
;
;******************-  END  OF PSEUDOCODE -**************************************


   PUBLIC Find_DPB

   Find_DPB PROC NEAR

   MOV	AH,GET_DPB			;Get the DPB			       ;AN004;
   INT	21H

   mov	ax,(disk_reset shl 8)		; reset the disk to protect all INT 26's
   INT	21h				;   that follow


					; initalize current_entry to #3

   ASSUME ds:nothing,es:DATA

   MOV	WORD PTR [THIS_DPB+2],DS	;				       ;AN004;
   push es				;				       ;AN004;
   pop	ds				;				       ;AN004;

   ASSUME ds:DATA

   mov	WORD PTR [THIS_DPB],bx		;				       ;AN004;
   lds	bx,[THIS_DPB]			;				       ;AN004;

   ASSUME ds:nothing

   mov	ax,[bx.dpb_sector_size] 	;				       ;AN004;
   mov	[SSIZE],ax			;Sector size in bytes		       ;AN004;

   xor	ax,ax				;				       ;AN004;
   mov	al,[bx.dpb_cluster_mask]	;				       ;AN004;
   inc	al				;				       ;AN004;
   mov	[CSIZE],ax			;Sectros per cluster		       ;AN004;

   mov	ax,[BX.dpb_first_FAT]		;First sector of FAT		       ;AN004;
   mov	[first_FAT],ax			;				       ;AN004;

   mov	al,[BX.dpb_FAT_count]		;Number of FATs 		       ;AN004;
   cmp  al,2                            ; We only support 2 FATs
   je   fd_continue                     ; YES, keep going
   mov  ax,(util_B shl 8) + cant_sys_target  ; indicate error
   stc
   jmp  fd_exit

fd_continue:
   mov	[num_of_FATS],al		;				       ;AN004;

   mov	ax,[bx.dpb_max_cluster] 	;				       ;AN004;
   mov	[MCLUS],ax			;Bound for FAT searching	       ;AN004;

   cmp	ax,4096-10			;Big or little FAT?		       ;AN004;
;  $if	ae				;				       ;AN004;
   JNAE $$IF1
       inc  [BIGFAT]			;				       ;AN004;
       mov  [EOFVAL],0FFF8h		;				       ;AN004;
       mov  [BADVAL],0FFF7h		;				       ;AN004;
;  $endif				;				       ;AN004;
$$IF1:
   dec	ax				;				       ;AN004;
   mov	[DSIZE],ax			;Total data clusters on disk	       ;AN004;

					;--------------------------------------
					; calculate # of dir sectors and
					;    initalize last_dir_sector
					;--------------------------------------
   mov	ax,[bx.dpb_root_entries]	; max # of entries in the root	       ;AN004;
   mov	cx,size dir_entry		; size of each entry		       ;AN004;
   mul	cx				; size of root directory in bytes      ;AN004;
					; in AX:DX			       ;AN004;
   mov	cx,[SSIZE]			; # of bytes per sector 	       ;AN004;
   div	cx				; = # of root directory sectors        ;AN004;
   cmp	dx,0				; any remainder ?		       ;AN004;
;  $if	nz				;				       ;AN004;
   JZ $$IF3
       inc  ax				;				       ;AN004;
;  $endif				;				       ;AN004;
$$IF3:
   mov	[first_dir_sector],ax		; save for last directory sector calc. ;AN004;

   mov	ax,[bx.dpb_FAT_size]		;Sectors for one fat		       ;AN004;
   cmp	DOS_VER,0			; running on current version?	       ;AN019;

;  $if	ne				; BANG! - we'er running on DOS 3.3     ;AN019;
   JE $$IF5
					;	  dpb_FAT_size is only a BYTE
					;	  so ajust it to a word
       xor  ah,ah							       ;AN019;
       dec  bx				; BACK UP the index into the DPB       ;AN019;
       mov  WORD PTR [THIS_DPB],bx	;   save it for later (dpb_next_free)  ;AN021;
					; Now  everything else lines up !
;  $endif
$$IF5:

   mov	[FSIZE],ax			;				       ;AN004;

   mov	ax,[SSIZE]			;				       ;AN004;
   mov	cx,SIZE dir_entry		;				       ;AN004;
   div	cx				;				       ;AN004;

;; following line removed for Compaq bug fix #989
;; dec	ax				; first entry number is zero	       ;AN004;

   mov	[entries_per_sector],al 	;				       ;AN004;
   cmp	[BIGFAT],0			; is it a big fat ?		       ;AN004;

;  $if	e				; if not			       ;AN004;
   JNE $$IF7
       mov  ax,[FSIZE]			;				       ;AN004;
       mov  [FAT_sectors],ax		; bring it down to the actual size     ;AN004;
;  $endif				;				       ;AN004;
$$IF7:
					;--------------------------------------
					; initalize first_dir_sector
					;	and current_dir_sector
					;--------------------------------------
   mov	ax,[bx.dpb_dir_sector]		; first dir sector		       ;AN004;
   mov	[current_dir_sector],ax 	; save it for later		       ;AN004;
   xchg [first_dir_sector],ax		; save it and recover # of dir sectors ;AN004;

   add	ax,[first_dir_sector]		; # of last directory sector	       ;AN004;
   mov	[l_sector_offset],ax		;				       ;AN004;
   dec	ax				;				       ;AN004;
   mov	[last_dir_sector],ax		; save it for later		       ;AN004;
   clc

fd_exit:
   ret					;				       ;AN004;

   Find_DPB ENDP

   BREAK <SYS - Move_DIR_Entry >
;******************* START OF SPECIFICATIONS ***********************************
;Routine name: Move_DIR_Entry
;*******************************************************************************
;
;Description:	Move_DIR_Entry will move the entry pointed to by the caller into
;		the first available location in the root, if one exists.
;
;Entry: 	Called by Verify_File_Location
;
;Called Procedures:
;
;		Find_Empty_Entry - find an available entry
;		Direct_Access	 - do an INT 25 & INT 26
;
;Input: 	first_dir_sector
;		current_dir_sector
;		last_dir_sector
;		current_entry
;		pointer set to source entry to be moved
;
;Output:	CF = 0 - DIR entry moved to first available entry
;		CF = 1 - Error, not able to free up entry
;
;Change History: Created	7/01/87 	FG
;
;******************* END OF SPECIFICATIONS *************************************
;******************+ START OF PSEUDOCODE +**************************************
;
;	START  Move_DIR_Entry
;
;	set dest = entry_buffer
;	save source pointer
;	copy input entry to buffer
;	if no error and
;	call Find_Empty_Entry to find hole in directory
;	if no error
;		set source to entry_buffer
;		set dest to hole pointer
;		copy buffer to enpty entry
;		if first_dir_sector != current_dir_sector
;		set up for write
;		call Direct_Access to write it out
;			if no error
;				set up for first_dir_sector
;				set up for read
;				call Direct_Access to read it in
;			endif
;		if no error
;			recover source pointer
;			null out entry being processed
;			set up for write
;			call Direct_Access to update the root
;		endif
;	endif
;
;	ret
;
;	END   Move_DIR_Entry
;
;******************-  END  OF PSEUDOCODE -**************************************


   PUBLIC Move_DIR_Entry

   Move_DIR_Entry PROC NEAR

   ASSUME ds:DATA			;  must ensure this is true xxxxxxxxxxxxxxxxx

					; source = source entry (#1 or #2) DS:SI
   lea	di,ENTRY_BUF			; dest	 = entry_buffer 	       ;AN004;
   mov	[source_ptr],si 		; save source pointer		       ;AN004;
   mov	ax,size dir_entry		;				       ;AN004;
   mov	cx,ax				;				       ;AN004;
   rep	movsb				; copy directory entry into entry buffer;AN004;
   lea	si,DIR_SECTOR			; start at beginning of directory      ;AN004;
   mov	di,si				; save start for end calculation       ;AN004;
   shl	ax,1				; set pointer for current entry to #3  ;AN004;
   add	ax,si				;				       ;AN004;
   mov	si,ax				;				       ;AN004;
   add	di,[SSIZE]			; calculate end of directory	       ;AN004;
   call Find_Empty_Entry		; find hole in directory	       ;AN004;
;  $if	nc				; if no error and		       ;AN004;
   JC $$IF9
       mov  di,si			; dest	 = hole pointer 	       ;AN004;
       lea  si,ENTRY_BUF		; source = entry_buffer 	       ;AN004;
       mov  cx,size dir_entry		;				       ;AN004;
       rep  movsb			; copy buffer to DTA		       ;AN004;
       mov  ax,[first_dir_sector]	;				       ;AN004;
       cmp  ax,[current_dir_sector]	;				       ;AN004;
;      $if  ne				; if first_dir_sector != current_dir_sector;AN004;
       JE $$IF10
	   mov	ah,-1			; set up for write		       ;AN004;
	   call Direct_Access		; write it out			       ;AN004;
;	   $if	nc			; if no error			       ;AN004;
	   JC $$IF11
	       mov  ax,[first_dir_sector] ; set up for first_dir_sector        ;AN004;
	       mov  [current_dir_sector],ax ; update current_dir_sector        ;AN004;
	       mov  [packet],ax 	;				       ;AN004;
	       xor  ah,ah		; set up for read		       ;AN004;
	       call Direct_Access	; read it in			       ;AN004;
;	   $endif			;				       ;AN004;
$$IF11:
;      $endif				;				       ;AN004;
$$IF10:
;      $if  nc				; if no error			       ;AN004;
       JC $$IF14
	   mov	si,[source_ptr] 	; recover source pointer	       ;AN004;
	   mov	BYTE PTR [si],deleted	; delete entry being processed	       ;AN004;
	   mov	BYTE PTR [si.dir_first],0 ; null out cluster #		       ;AN004;
	   cmp	si,offset DIR_SECTOR	;  are we at the first entry ?	       ;AN010;
;	   $if	e,and			; if so -			       ;AN010;
	   JNE $$IF15
	   cmp	BYTE PTR [si + size DIR_ENTRY],0 ; is second one a null entry? ;AN010;
;	   $if	e			; if so -			       ;AN010;
	   JNE $$IF15
	       mov  BYTE PTR [si + size DIR_ENTRY],deleted ; make it deleted   ;AN010;
;	   $endif			;				       ;AN010;
$$IF15:
	   mov	ah,-1			; set up for write		       ;AN004;
	   call Direct_Access		; write it out			       ;AN004;
;      $endif				;				       ;AN004;
$$IF14:
;  $endif				;				       ;AN004;
$$IF9:

   ret					;				       ;AN004;

   Move_DIR_Entry ENDP

   BREAK <SYS - Find_Empty_Entry >
;******************* START OF SPECIFICATIONS ***********************************
;Routine name: Find_Empty_Entry
;*******************************************************************************
;
;Description:	Find_Empty_Entry scans all root directory sectors looking for
;		an empty entry.
;
; NOTE; 	It is assumed that each DIRectory entry is 32 bytes long
;
;Called Procedures:
;
;		Direct_Acces - do INT 25
;
;Input: 	current_dir_sector
;		last_dir_sector
;		first_dir_sector in DTA buffer
;		DS:SI set for first entry to check
;		DS:DI set to end of directory (sector)
;
;Output:	success 	pointer set to hole
;		CF = 0		current_entry updated
;				current_dir_sector updated
;
;		fail		message # set
;		CF = 1
;
;Change History: Created	7/01/87 	FG
;
;******************* END OF SPECIFICATIONS *************************************
;******************+ START OF PSEUDOCODE +**************************************
;
;	START  Find_Empty_Entry
;
;	search all available sectors
;		search for hole  (leaves pointer set to the hole)
;		leave if empty
;		leave if deleted
;		advace to next entry
;		exitif past end of sector
;			set carry
;		orelse
;		endloop
;			clear carry
;			save current_entry
;		endsrch
;	exitif hole found (no CF)
;		update current_entry
;	orelse
;		if not at end (current <= last)
;			set for read
;			call Direct_Access to read in next sector
;		else
;			load error message (no room for system files)
;			set error (CF)
;		endif
;	leave if error (CF)
;			update current_DIR_sector
;			update current_entry
;		endif
;	endloop
;	endsrch
;
;	ret
;
;	END  Find_Empty_Entry
;
;******************-  END  OF PSEUDOCODE -**************************************

   PUBLIC Find_Empty_Entry

   Find_Empty_Entry PROC NEAR

;  $search				; for sectors available 	       ;AN004;
$$DO19:
					;				       ;AN004;
;      $search				; for hole - this leaves pointer set at;AN004;
$$DO20:
					; the hole			       ;AN004;
	   cmp	BYTE PTR [si],empty	; empty   ?			       ;AN004;
;      $leave e 			;				       ;AN004;
       JE $$EN20
	   cmp	BYTE PTR [si],deleted	; deleted ?			       ;AN004;
;      $leave e 			;				       ;AN004;
       JE $$EN20
	   add	ax,size dir_entry	; advace to next entry		       ;AN004;
	   mov	si,ax			;				       ;AN004;
	   cmp	ax,di			; past end of sector ?		       ;AN004;
;      $exitif ae			; at end			       ;AN004;
       JNAE $$IF20
	   stc				; set carry			       ;AN004;
;      $orelse				;				       ;AN004;
       JMP SHORT $$SR20
$$IF20:
;      $endloop 			;				       ;AN004;
       JMP SHORT $$DO20
$$EN20:
	   clc				; clear carry			       ;AN004;
;      $endsrch 			;				       ;AN004;
$$SR20:
;  $exitif nc				; hole is found 		       ;AN004;
   JC $$IF19
;  $orelse				;				       ;AN004;
   JMP SHORT $$SR19
$$IF19:
       inc  [current_dir_sector]	; advance to next sector	       ;AN004;
       mov  ax,[current_dir_sector]	;				       ;AN004;
       cmp  ax,[last_dir_sector]	; past last_dir_sector ?	       ;AN004;
;  $leave a				; if at end (current <= last)	       ;AN004;
   JA $$EN19
       lea  si,DIR_SECTOR		; start at start of next sector        ;AN004;
       mov  [packet],ax 		;				       ;AN004;
       xor  ah,ah			; set for read			       ;AN004;
       call Direct_Access		; read in next sector		       ;AN004;
;      $if  c				; if error			       ;AN004;
       JNC $$IF30
	   dec	[current_dir_sector]	; restore curren_dir_sector	       ;AN004;
;      $endif				;				       ;AN004;
$$IF30:
;  $leave c				; error 			       ;AN004;
   JC $$EN19
       mov  ax,si			; reset pointer to start	       ;AN004;
;  $endloop a				; past last_dir_sector		       ;AN004;
   JNA $$DO19
$$EN19:
       mov  ax,(util shl 8) + no_room	; set message# and class	       ;AN004;
       stc				; ensure carry still set	       ;AN004;
;  $endsrch				;				       ;AN004;
$$SR19:

   ret					;				       ;AN004;

   Find_Empty_Entry ENDP



   BREAK <SYS - Direct_Access >
;******************* START OF SPECIFICATIONS ***********************************
;Routine name: Direct_Access
;*******************************************************************************
;
;Description:  Direct_Access
;
;Called Procedures:
;
;		INT 25
;		INT 26
;
;Input:       ah = 0  - read
;	      ah = -1 - write
;
;Output:      CF = 0 - Sectors moved
;	      CF = 1 - Message and class in AX
;
;Change History: Created	7/01/87 	FG
;
;******************* END OF SPECIFICATIONS *************************************
;******************+ START OF PSEUDOCODE +**************************************
;
;	START  Direct_Access
;
;	save registers
;	if read
;		INT 25
;	else
;		zero ah
;		INT 26
;	endif
;	save return flag
;	clear stack
;	if error
;	       set message# and class
;	endif
;	restore registers
;
;	ret
;
;	END  Direct_Access
;
;******************-  END  OF PSEUDOCODE -**************************************

   public Direct_Access

   Direct_Access PROC NEAR

   push si				; save registers		       ;AN004;
   push bp				; save registers		       ;AN004;
   cmp	DOS_VER,0			;				       ;AN019;

;  $if	e				;				       ;AN019;
   JNE $$IF35

       mov  cx,-1			; set up for INT		       ;AN004;
       mov  bx,offset packet		;				       ;AN004;

;  $else				;				       ;AN019;
   JMP SHORT $$EN35
$$IF35:
					; If running on DOS 3.3 the INT 25
					; interface is:
					;	al = drive number
					;	bx = buffer for read data
					;	cx = # of sectors
					;	dx = start sector
       mov  cx,word ptr [packet_sectors] ;				       ;AN019;
       mov  dx,[packet] 		; get starting dir sector	       ;AN019;
       mov  bx,PACKET_BUFFER[0] 	;				       ;AN019;

;  $endif				;				       ;AN019;
$$EN35:

   mov	al,TargDrvNum			; set up drive number		       ;AN004;
   dec	al				;				       ;AN004;
   cmp	ah,0				;				       ;AN004;
;  $if	e				; if read			       ;AN004;
   JNE $$IF38
       INT  25h 			; INT 25			       ;AN004;
;  $else				; else				       ;AN004;
   JMP SHORT $$EN38
$$IF38:
       xor  ah,ah			; zero ah			       ;AN004;
       INT  26h 			; INT 26			       ;AN004;
;  $endif				; endif 			       ;AN004;
$$EN38:
;; ?					; save return flag		       ;AN004;
   pop	ax				; clear stack			       ;AN004;
   pop	bp				;				       ;AN004;
   pop	si				;				       ;AN004;

   ret					;				       ;AN004;

   Direct_Access ENDP

IFDEF NEED_CLUSTER_2               ; if system files must be loaded in cluster 2

   BREAK <SYS - Free_Cluster >
;******************* START OF SPECIFICATIONS ***********************************
;Routine name:	Free_Cluster processor
;*******************************************************************************
;
;Description: IBMBIO MUST have at least IBMLOADSIZE sectors contiguous, for 
;             the beginning of its file. This
;	      routine ensures that cluster 2 and any additional clusters (if
;	      needed) ARE available. If they are chained, their data is copied
;	      into the first available cluster, and the needed cluster is
;	      is replaced by this cluster in the FAT
;
;Entry:       Called by Verify_File_Location
;
;Called Procedures:
;
;	      Is_It_Empty - see if Cluster is empty
;	      Search_FAT  - scan FAT to see if the cluster is chained
;	      Search_DIR  - use FAT to walk directories looking for the cluster
;
;	NOTES: Check_FAT and Check_DIR will do the processing requred to move
;	       data out of the cluster and fix up the FAT and the Dir (if needed).
;
;Input:       All local DBP values initalized by Get_DPB
;
;Ouput:       CF = 0  -  Cluster available
;	      CF = 1  -  Cluster not available
;
;
;Change History: Created	7/01/87 	FG
;
;******************* END OF SPECIFICATIONS *************************************
;******************+ START OF PSEUDOCODE +**************************************
;
;	START  Free_Cluster
;
;	initialize [cluster_count]
;	do until all copies of FAT attempted
;		load FAT into memory (INT 25)
;	leave if successful
;	enddo
;	do until [cluster_count] = 0
;		call Is_It_Empty
;		if not found and
;		if no errors and
;		call Search_FAT
;		if not found and
;		if no errors
;			call Search_DIR
;		endif
;	leave if error
;	enddo
;
;	ret
;
;	END Free_Cluster
;
;******************-  END  OF PSEUDOCODE -**************************************

   public Free_Cluster

   Free_Cluster PROC NEAR

   mov	ax,IBMLOADSIZE			; calculate # of clusters reqd	       ;AN004;
   xor	cx,cx				;				       ;AN004;
   mov	di,cx				;				       ;AN004;
   dec	di				;				       ;AN004;
   mov	cx,[CSIZE]			;   by IBMLOAD (consecutive clusters   ;AN004;
   div	cl				;   for IBMBIO) 		       ;AN004;
   cmp	ah,0				;				       ;AN004;
;  $if	ne				;				       ;AN004;
   JE $$IF41
       inc  al				;				       ;AN004;
       xor  ah,ah			;				       ;AN004;
;  $endif				;				       ;AN004;
$$IF41:
   inc	ax				; will be decrimenter immediately upon ;AN004;
					;   entering complex do below
   mov	[cluster_count],ax		; save for later		       ;AN004;
   mov	ax,[FAT_sectors]		;only read needed sectors	       ;AN004;
   mov	[packet_sectors],ax		;				       ;AN004;
   mov	cl,[num_of_FATS]		;Number of FATs 		       ;AN004;
   mov	ax,[first_FAT]			;First sector of FAT		       ;AN004;
   mov	[packet],ax			;				       ;AN004;
   mov	[packet_buffer],OFFSET BUF	; point to FAT buffer		       ;AN004;
   call Load_FAT			;				       ;AN004;
;  $if	nc				; no error so far.......	       ;AN004;
   JC $$IF43
;      $do  complex			;				       ;AN004;
       JMP SHORT $$SD44
$$DO44:
	   mov	[cluster_count],cx	;				       ;AN004;
	   call Is_It_Empty		;				       ;AN004;
;      $leave c 			;				       ;AN014;
       JC $$EN44
	   cmp	al,not_found		; ( -1 ?)			       ;AN004;
;	   $if	e			; if not found			       ;AN004;
	   JNE $$IF46
	       call Search_FAT		; scan FAT to see if cluster chained   ;AN004;
;	   $else			;				       ;AN004;
	   JMP SHORT $$EN46
$$IF46:
	       clc			;				       ;AN004;
;	   $endif			;				       ;AN004;
$$EN46:
;      $leave c 			;				       ;AN004;
       JC $$EN44
	   cmp	al,not_found		; if still not found		       ;AN004;
;	   $if	e			;				       ;AN004;
	   JNE $$IF50
	       call Search_DIR		; scan DIR to see who starts with #2   ;AN004;
;	   $else			;				       ;AC013;
	   JMP SHORT $$EN50
$$IF50:
	       clc			; ensure carry is still clear	       ;AC013;
;	   $endif			;				       ;AN004;
$$EN50:
;      $leave c 			;				       ;AN004;
       JC $$EN44
	   inc	[current_cluster]	;				       ;AN004;
;      $strtdo				;				       ;AN004;
$$SD44:
	   mov	cx,[cluster_count]	;				       ;AN004;
;      $enddo LOOP			;				       ;AN004;
       LOOP $$DO44
$$EN44:
;  $endif				;				       ;AN004;
$$IF43:
;  $if	c				;				       ;AN004;
   JNC $$IF57
       mov  ax,(util shl 8) + no_room	; error message - no room to sys       ;AN014;
;  $endif				;				       ;AN004;
$$IF57:

   ret					;				       ;AN004;

   Free_Cluster ENDP

   public Load_FAT

   Load_FAT PROC NEAR

   lea	bx,[packet]			;				       ;AN004;

;  $search				;				       ;AN004;
$$DO59:
       xchg cx,di			;				       ;AN004;
       push cx				;				       ;AN004;
       push di				;				       ;AN004;
       push dx				;				       ;AN004;
       push bx				;				       ;AN004;
       xor  ah,ah			;				       ;AN004;
       mov  al,TargDrvNum		; set up drive number		       ;AN004;
       dec  al				;				       ;AN004;
       cmp  DOS_VER,0			; if DOS 3.3			       ;AN019;

;      $if  ne				; load registers for old style INT 25  ;AN019;
       JE $$IF60
	   mov	bx,[packet_buffer]	;				       ;AN019;
	   mov	cx,[packet_sectors]	;				       ;AN019;
	   mov	dx,[packet]		;				       ;AN019;
;      $endif				;				       ;AN019;
$$IF60:

       push bp				;				       ;AN019;
       int  25h 			;Read in the FAT		       ;AN004;
       pop  ax				;Flags				       ;AN004;
       pop  bp				;				       ;AN019;
;  $exitif nc				; error - set up for next fat	       ;AN004;
   JC $$IF59
       add  sp,8			;Clean up stack 		       ;AN004;
       mov  ax,1			;				       ;AN004;
;	mov [packet],ax ; reset to first FAT				       ;AN004;
;  $orelse				;				       ;AN004;
   JMP SHORT $$SR59
$$IF59:
       pop  bx				;				       ;AN004;
       pop  dx				;				       ;AN004;
       pop  cx				;				       ;AN004;
       pop  di				;				       ;AN004;
       add  [packet],dx 		; point to start of next FAT	       ;AN004;
       inc  [FAT_2]			;				       ;AN004;
;  $endloop LOOP			;Try next FAT			       ;AN004;
   LOOP $$DO59
       mov  ax,(util shl 8) + no_room	; set message# and class	       ;AN004;
;  $endsrch				;				       ;AN004;
$$SR59:

   ret

   Load_FAT ENDP


   BREAK <SYS - Is_It_Empty >
;******************* START OF SPECIFICATIONS ***********************************
;Routine name: Is_It_Empty
;*******************************************************************************
;
;Description: Is_It_Empty looks directly into the FAT to see if a specified
;	      cluster is allocated.
;
;Entry:       Called by Free_Cluster
;
;Called Procedures:
;
;	      Unpack - unpack a FAT cluster number (CF set on error)
;
;Input:       CX = cluster to check
;	      12 sectors of FAT in BUF
;
;Output:      CF = 0   AL = 0  - cluster 2 found empty
;		       AL =-1  - not found & no error
;	      CF = 1   - critical error
;
;Change History: Created	7/01/87 	FG
;
;******************* END OF SPECIFICATIONS *************************************
;******************+ START OF PSEUDOCODE +**************************************
;
;	START Is_It_Empty
;
;	set up for call to Unpack
;	set cluster # to [cluster_number]
;	call Unpack
;	if no error
;		if cluster is not empty
;			if bad cluster
;				set error flag
;			else
;				if cluster belongs to IBMBIO
;					if next cluster is not contiguous
;						 reset ownership flag
;					endif
;					set cluster empty (ax = 0)
;				else
;					save cluster number
;					set cluster used (ax = -1)
;				endif
;		else
;			set cluster empty (ax = 0)
;		endif
;	endif
;
;	ret
;
;	END Is_It_Empty
;
;******************-  END  OF PSEUDOCODE -**************************************

   public Is_It_Empty

   Is_It_Empty PROC NEAR

   mov	si,[current_cluster]		; set up for call to Unpack	       ;AN004;
   call Unpack				; to find the value		       ;AN004;
;  $if	nc				; if no error			       ;AN004;
   JC $$IF66
;      $if  nz				; cluster is not empty		       ;AN004;
       JZ $$IF67
	   mov	ax,di			;				       ;AN004;
	   cmp	al,bad_sector		;				       ;AN004;
;	   $if	e			;				       ;AN004;
	   JNE $$IF68
	       stc			;				       ;AN004;
;	   $else			;				       ;AN004;
	   JMP SHORT $$EN68
$$IF68:
	       cmp  [bio_owns_it],0	; is it owned by IBMBIO ?	       ;AN004;
;	       $if  ne			; if it is			       ;AN004;
	       JE $$IF70
		   dec	ax		;				       ;AN004;
		   cmp	ax,[current_cluster] ;				       ;AN004;
;		   $if	ne		;				       ;AC011;
		   JE $$IF71
		       dec  [bio_owns_it] ; its not the owner form here on     ;AC011;
;		   $endif		;				       ;AC011;
$$IF71:
		   xor	ax,ax		;				       ;AN004;
		   clc			; its IBMBIO's anyway                  ;AC011;
;	       $else			;				       ;AN004;
	       JMP SHORT $$EN70
$$IF70:
		   mov	[next_cluster],di ;				       ;AN004;
		   xor	ax,ax		; reset fail flag		       ;AN004;
		   dec	ax		;  - its not empty		       ;AN014;
;	       $endif			;				       ;AN004;
$$EN70:
;	   $endif			;				       ;AN004;
$$EN68:
;      $else				; its empty !			       ;AN005;
       JMP SHORT $$EN67
$$IF67:
	   xor	ax,ax			; its empty - and no error	       ;AN014;
;      $endif				;				       ;AN014;
$$EN67:
;  $endif				;				       ;AN004;
$$IF66:

   ret					;				       ;AN004;

   Is_It_Empty ENDP

   BREAK <SYS - Search_FAT >
;******************* START OF SPECIFICATIONS ***********************************
;Routine name: Search_FAT
;*******************************************************************************
;
;Description: Search_FAT for a [cluster_number]. If it is listed in the FAT,
;	      then its chained into a file. The data in the [cluster_number] is
;	      then buffered, and copied into an empty cluster, and the FAT is
;	      updated
;
;Called Procedures:
;
;		Unpack		   - to find a FAT entry for a Cluster #
;		Pack		   - to set a FAT entry for a Cluster #
;		Find_Empty_Cluster - find an unused cluster
;		Xfer_Data	   - transfere data from one cluster to another
;		Direct_Access	   - absolute disk i/o
;
;Input: 	FAT in BUF
;		[cluster_number] of specified cluster
;
;Output:	CF = 0	- AX = 0 if cluster found
;			     = -1 if cluster not found
;		CF = 1 if critical error
;
;Change History: Created	7/01/87 	FG
;
;******************* END OF SPECIFICATIONS *************************************
;******************+ START OF PSEUDOCODE +**************************************
;
;	START Search_FAT
;
;	set cluster # to [cluster_number]
;	search till at end of FAT
;		call Unpack
;	exitif cluster found
;		save [last_cluster]
;		clear CF
;	orelse
;		advance to next cluster
;	endloop if past last cluster in fat
;		set CF
;	endsrch
;	if cluster found
;		call Find_Empty_Cluster
;	endif
;
;	if empty cluster available and
;
;	call Xfer_Data
;
;	if no errors
;
;	set taget cluster as one pointing to [cluster_number]
;	set value to that of empty cluster
;	call Pack to update FAT
;	set target cluster as [cluster_number]
;	set cluster value to empty
;	call Pack to update FAT
;	set destination to first sector of first FAT
;	set count to # of fat sectors
;	set up for write
;	do until all FATS written
;		call Direct_Access
;		advace to next FAT  (ignore errors)
;	enddo
;
;	endif
;
;	if no errors
;		update DPB first cluster and total empty clusters
;	endif
;
;	ret
;
;	END Search_FAT
;
;******************-  END  OF PSEUDOCODE -**************************************

   public Search_FAT

   Search_FAT PROC NEAR

   mov	si,[current_cluster]		; set cluster # to [cluster_number]    ;AN004;
;  $search				; till at end of FAT		       ;AN004;
$$DO79:
       call Unpack			;				       ;AN004;
;  $leave c				; quit on an error		       ;AN004;
   JC $$EN79
       cmp  di,[current_cluster]	; is it [current_cluster] ?	       ;AN004;
;  $exitif e				; it is 			       ;AN004;
   JNE $$IF79
       mov  [last_cluster],si		; save number for later 	       ;AN004;
       xor  ax,ax			;				       ;AN004;
       clc				; clear error flag (found)	       ;AN004;
;  $orelse				;				       ;AN004;
   JMP SHORT $$SR79
$$IF79:
       inc  si				; advance to next cluster	       ;AN004;
       xor  ax,ax			;				       ;AN004;
       dec  ax				;				       ;AN004;
       cmp  si,[MCLUS]			; at the end ?			       ;AN004;
;  $endloop e				; if past last cluster		       ;AN004;
   JBE $$DO79                           ; M006
$$EN79:
       stc				;				       ;AN014;
;  $endsrch				;				       ;AN004;
$$SR79:
;  $if	nc				; if cluster found		       ;AN004;
   JC $$IF85
       call Find_Empty_Cluster		; to move data to		       ;AN004;
;  $endif				;				       ;AN004;
$$IF85:
;  $if	nc,and				; empty cluster available and	       ;AN004;
   JC $$IF87
   call Xfer_Data			; to move data to new cluster	       ;AN004;
;  $if	nc,and				; no errors			       ;AN004;
   JC $$IF87
   mov	si,[last_cluster]		; set target [last_cluster]	       ;AN004;
   mov	dx,[empty_cluster]		; set value to [empty_cluster]	       ;AN004;
   call Pack				; to update FAT 		       ;AN004;
;  $if	nc,and				; no errors			       ;AN004;
   JC $$IF87
   mov	si,[empty_cluster]		; set target [empty_cluster]	       ;AN004;
   mov	dx,[next_cluster]		; set value to [next_cluster]	       ;AN004;
   call Pack				; to update FAT 		       ;AN004;
;  $if	nc,and				; no errors			       ;AN004;
   JC $$IF87
   mov	si,[current_cluster]		; set target [current_cluster]	       ;AN004;
   xor	dx,dx				; set cluster value to empty	       ;AN004;
   call Pack				; to update FAT 		       ;AN004;
;  $if	nc				; no errors			       ;AN004;
   JC $$IF87
       xor  ah,ah			;				       ;AN004;
       dec  ah				;				       ;AN004;
       call Direct_Access		; write it out - ignore errors	       ;AN004;
       mov  ax,[FSIZE]			;				       ;AN004;
       cmp  [FAT_2],0			;				       ;AN004;
;      $if  e				;				       ;AN004;
       JNE $$IF88
	   add	[packet],ax		;				       ;AN004;
	   inc	[FAT_2] 		; packet points to FAT #2	       ;AC006;
;      $else				;				       ;AN004;
       JMP SHORT $$EN88
$$IF88:
	   sub	[packet],ax		;				       ;AN004;
	   mov	[FAT_2],0		; reset - packet points to FAT #1      ;AN004;
;      $endif				;				       ;AN004;
$$EN88:
       xor  ah,ah			;				       ;AN004;
       dec  ah				;				       ;AN004;
       call Direct_Access		; write it out - ignore errors	       ;AN004;
       mov  [FAT_changed],0		; FAT now cleared		       ;AN004;
       push es				; update DPB first cluster	       ;AN004;
       mov  bx,ds			;				       ;AN004;
       mov  es,bx			;				       ;AN004;
       lds  bx,[THIS_DPB]		;				       ;AN004;

       ASSUME ds:nothing,es:DATA

       mov  [bx.dpb_next_free],2	;				       ;AN004;
       mov  ax,es			;				       ;AN004;
       mov  ds,ax			;				       ;AN004;
       pop  es				;				       ;AN004;
       xor  ax,ax			; signal success (ax = 0 , cf = 0)     ;AN004;

       ASSUME DS:data, es:nothing

;  $endif				;				       ;AN004;
$$IF87:
;  $if	c				;				       ;AN004;
   JNC $$IF92
       cmp  ax,-1			;				       ;AN004;
;      $if  e				;				       ;AN004;
       JNE $$IF93
	   clc				; not a critical error - keep trying   ;AN004;
;      $else				;				       ;AN004;
       JMP SHORT $$EN93
$$IF93:
	   stc				; major problem - critical error       ;AN004;
;      $endif				;				       ;AN004;
$$EN93:
;  $endif				;				       ;AN004;
$$IF92:

   ret					;				       ;AN000;

   Search_FAT ENDP

   BREAK <SYS - Find_Empty_Cluster >
;******************* START OF SPECIFICATIONS ***********************************
;Routine name: Find_Empty_Cluster
;*******************************************************************************
;
;Description: Find_Empty_Cluster finds the first available empty cluster
;
;Called Procedures:
;
;		Unpack	- find next cluster number
;
;Input: 	none
;
;Output:	CF = 0 - empty cluster found (# in [empty_cluster])
;		CF = 1 - no empty clusters (ax = message)
;
;Change History: Created	7/01/87 	FG
;
;******************* END OF SPECIFICATIONS *************************************
;******************+ START OF PSEUDOCODE +**************************************
;
;	START Find_Empty_Cluster
;
;	search till at end of FAT
;		call Unpack
;	exitif cluster is empty (ZF)
;		save empty cluster number
;		clear CF
;	orelse
;		advance to next cluster
;	endloop if past last cluster
;		load ax message # - no room for sys files
;		set CF
;	endsrch
;
;	ret
;
;	END Find_Empty_Cluster
;
;******************-  END  OF PSEUDOCODE -**************************************

   public Find_Empty_Cluster

   Find_Empty_Cluster PROC NEAR

   mov	si,[current_cluster]		;				       ;AN004;
   mov	ax,[cluster_count]		;				       ;AN004;
   add	si,ax				; look past required space	       ;AN004;
;  $search				; till at end of FAT		       ;AN004;
$$DO97:
       call Unpack			; to convert # to value 	       ;AN004;
;  $exitif z				; cluster is empty		       ;AN004;
   JNZ $$IF97
       mov  [empty_cluster],si		; save it for later		       ;AN004;
       clc				; clear error flag		       ;AN004;
;  $orelse				;				       ;AN004;
   JMP SHORT $$SR97
$$IF97:
       inc  si				; advance to next cluster	       ;AN004;
       cmp  si,[MCLUS]			; past the end ?		       ;AN004;
;  $endloop e				; if past last cluster		       ;AN004;
   JBE $$DO97                           ; M006
       stc				; set error flag		       ;AN004;
       mov  ax,(util shl 8) + no_room	; error message - no room to sys       ;AN014;
;  $endsrch				;				       ;AN004;
$$SR97:

   ret					;				       ;AN004;

   Find_Empty_Cluster ENDP

   BREAK <SYS - Xfer_Data >
;******************* START OF SPECIFICATIONS ***********************************
;Routine name: Xfer_Data
;*******************************************************************************
;
;Description: Xfer_Data moves the data from [cluster_number] into the cluster
;	      number passed in ax.
;
;Called Procedures:
;
;		Direct_Access - do disk i/o
;
;Input: 	[current_cluster]
;		[empty_cluster]
;
;Output:	CF = 0	- data transfered
;		CF = 1	- error - message in AX
;
;Change History: Created	7/01/87 	FG
;
;******************* END OF SPECIFICATIONS *************************************
;******************+ START OF PSEUDOCODE +**************************************
;
;	START Xfer_Data
;
;	save active FAT starting sector
;	set source to first sector of [current_cluster]
;	set count to # of sectors per cluster
;	set up for read
;	call Direct_Access to read data
;	if no errors
;		set source to first sector of [empty_cluster]
;		set up for write
;		call Direct_Access to write data
;	endif
;	restore Fat starting sector
;	set count to FAT_sectors
;	set up for read
;	call Direct_Access to restore the FAT copy
;
;	endif
;
;	ret
;
;	END Xfer_Data
;
;******************-  END  OF PSEUDOCODE -**************************************

   public Xfer_Data

   Xfer_Data PROC NEAR

   push [packet]			; save active FAT starting sector      ;AN004;
   push [packet+2]			;				       ;AN004;
   push [packet_sectors]		;				       ;AN004;
   mov	ax,[CSIZE]			;				       ;AN004;
   mov	[packet_sectors],ax		;				       ;AN004;
   mov	ax,[current_cluster]		; set source to [current_cluster]      ;AN004;
   call cluster_2_sector		; convert Cluster to sector #	       ;AN004;
   mov	[packet],ax			; low sector word		       ;AN004;
   mov	[packet+2],dx			; high sector word		       ;AN004;
   xor	ah,ah				; set up for read		       ;AN004;
   call Direct_Access			; to read data			       ;AN004;
;  $if	nc				; no errors			       ;AN004;
   JC $$IF102
   mov	ax,[empty_cluster]		; set destination to [empty_cluster]   ;AN004;
   cmp	[DIR_cluster],0 		; have we just loaded a directory?     ;AN007;
;  $if	ne				; if so -			       ;AN007;
   JE $$IF103
   mov	[DIR_cluster],ax		; save the new cluster		       ;AN007;
   lea	bx,BUF				;				       ;AN007;
   mov	[bx.dir_first],ax		; update the '.' entry start cluster   ;AN007;
;  $endif				;				       ;AN007;
$$IF103:
   call cluster_2_sector		; conver to logical sector	       ;AN004;
   mov	[packet],ax			; low word			       ;AN004;
   mov	[packet+2],dx			; high word			       ;AN004;
   xor	ah,ah				; set up for write		       ;AN004;
   dec	ah				;				       ;AN004;
   call Direct_Access			; to write data 		       ;AN004;
;  $endif				;				       ;AN004;
$$IF102:
   pop	[packet_sectors]		;				       ;AN004;
   pop	[packet+2]			; restore starting sector	       ;AN004;
   pop	[packet]			;				       ;AN004;
   xor  ah,ah                           ; set up for read                  ;C07
   call Direct_Access                   ; to restore the FAT copy          ;C07

   ret					;				       ;AN004;

   Xfer_Data ENDP

   BREAK <SYS - cluster_2_sector >
;******************* START OF SPECIFICATIONS ***********************************
;Routine name: cluster_2_sector
;*******************************************************************************
;
;Description:  cluster_2_sector
;
;
;Called Procedures:
;
;		none
;
;Input: 	AX - cluster number
;
;Output:	AX - low word of sector
;		DX - high word of sector
;		CX - sectors per cluster
;
;Change History: Created	7/01/87 	FG
;
;******************* END OF SPECIFICATIONS *************************************
;******************+ START OF PSEUDOCODE +**************************************
;
;	START cluster_2_sector
;
;	ret
;
;	END cluster_2_sector
;
;******************-  END  OF PSEUDOCODE -**************************************

   public cluster_2_sector

   cluster_2_sector PROC NEAR

   dec	ax				;    of [current_cluster]	       ;AN004;
   dec	ax				;				       ;AN004;
   mov	cx,[CSIZE]			;				       ;AN004;
   mul	cx				;				       ;AN004;
   add	ax,[l_sector_offset]		;				       ;AN004;
   adc  dx,0                            ; M005

   ret					;				       ;AN004;

   cluster_2_sector ENDP

   BREAK <SYS - Search_DIR >
;******************* START OF SPECIFICATIONS ***********************************
;Routine name: Search_DIR
;*******************************************************************************
;
;Description: Search_DIR walks the directory tree looking for the file that
;	      starts with [cluster_number]. If found, the data is moved to the
;	      first empty cluster (if available), and the directory entry is
;	      updated.
;
;	      This routine walks the DIR tree by creating a 'FRAME' for each
;	      Sub DIR it encounters. It saves all the data needed to continue
;	      the search once the Sub DIR has been checked.
;
;      FRAME   Ä¿
;	             present_cluster #     sector_offset  entry_number 
;	       
;	  byte	       1	    2		    3		   4
;
;	      There is space in DIR_BUF for 32 frames (current DOS maximum
;	      level of nesting).
;
;Called Procedures:
;
;		Search_Loop   - scan the directory
;
;Input: 	[current_cluster] - # of cluster to be freed
;
;Output:	CF = 0	cluster now available
;		CF = 1	error - ax = message #
;
;
;Change History: Created	7/01/87 	FG
;
;******************* END OF SPECIFICATIONS *************************************
;******************+ START OF PSEUDOCODE +**************************************
;
;	START  Search_DIR
;
;	set up for first_dir_sector of root DIR
;	set up for read
;	call Direct_Access to read first root sector
;	if no error
;		set [current_sector]
;		set [sector_count] = #_dir_sectors
;		set [current_entry] = 1
;		set [sub_dir_level] = 0
;		do until cluster free (NC)
;			call Search_Loop
;			if SubDir
;				save [current_cluster] in frame
;				save [current_sector]in frame
;				save [current_entry] in frame
;				save [sector_count] in frame
;				incriment [sub_dir_level] (frame)
;				zero ax
;				set error flag (CF)
;			else
;				if end of DIR (CF + 00) and
;				if [dir_count] > 0
;					recover [current_cluster] from frame
;					recover [current_sector] from frame
;					recover [current_entry] from frame
;					recover [sector_count] from frame
;					decriment [sub_dir_level]
;					zero ax
;					set error flag (CF)
;				 else
;					load error message - no room to sys
;				 endif
;				 set error flag (CF) (ax = message)
;			endif
;		leave if error (ax > 0)
;		enddo
;	endif
;
;	ret
;
;	END  Search_DIR
;
;******************-  END  OF PSEUDOCODE -**************************************

   public Search_DIR

   Search_DIR PROC NEAR

   mov	ax,[first_dir_sector]		; set up for first_dir_sector of root  ;AN004;
   mov	[packet],ax			;				       ;AN004;
   mov	[packet+2],0			; zero out high word		       ;AN004;
   mov	[packet_sectors],1		; only process 1 sector at a time      ;AN004;
   mov	[packet_buffer],OFFSET DIR_SECTOR ;				       ;AN004;
   xor	ah,ah				; set up for read		       ;AN004;
   call Direct_Access			; to read first root sector	       ;AN004;
;  $if	nc,long 			; no error			       ;AN004;
   JNC $$XL1
   JMP $$IF106
$$XL1:
       xor  ax,ax			;				       ;AN004;
       mov  [present_cluster],ax	; set [present_cluster] = 0 (root)     ;AN004;
       mov  [entry_number],al		; set [entry_number] = 0 (first)       ;AN004;
       mov  ax,[first_dir_sector]	;				       ;AN013;
       mov  [sector_offset],ax		; set [sector_offset] = [first_dir_sec];AC015;
       lea  bx,DIR_BUF			; set [FRAME_ptr] = DIR_BUF	       ;AN004;
       mov  [FRAME_ptr],bx		;				       ;AN004;
;      $do				;  until cluster free (NC)	       ;AN004;
$$DO107:
	   call Search_Loop		;				       ;AN004;
;      $leave nc,long			; cluster found and moved	       ;AN004;
       JC $$XL2
       JMP $$EN107
$$XL2:
	   cmp	ax,0ffffh		;				       ;AN004;
;	   $if	e			; SubDir			       ;AN004;
	   JNE $$IF109

					; Search DIR returned with BX pointing
					;  to the current entry - now update
					;  current_cluster to this SubDIRs first
					;  cluster

	       mov  ax,[bx.dir_first]	; get starting cluster for where we    ;AN007;
					;  want to go
	       mov  bx,[present_cluster] ; get [present_cluster] for frame     ;AN004;
					;  (where we were)
	       mov  [present_cluster],ax ;  [present_cluster] for next pass    ;AN007;
	       xchg ax,bx		; recover old [present_cluster]        ;AN007;
	       mov  bx,[FRAME_ptr]	; get FRAME pointer		       ;AN004;
	       mov  [bx.p_cluster],ax	; save [present_cluster] in frame      ;AN004;
	       mov  ax,[sector_offset]	; save [sector_offset]in frame	       ;AC015;
	       mov  [bx.s_offset],ax	;				       ;AC015;
	       mov  al,[entry_number]	; save [entry_number] in frame	       ;AN004;
	       mov  [bx.e_number],al	;				       ;AN004;
	       xor  ax,ax		; reset -			       ;AN007;
	       mov  [sector_offset],ax	;	  [sector_offset]	       ;AC015;
	       mov  [entry_number],al	;	  [entry_number]	       ;AN007;
	       add  bx,SIZE FRAME	; incriment FRAME pointer	       ;AN004;
	       lea  ax,DIR_SECTOR	;				       ;AN004;
	       cmp  ax,bx		;				       ;AN004;
;	       $if  a			;				       ;AC007;
	       JNA $$IF110
		   mov	[FRAME_ptr],bx	;				       ;AN004;
		   clc			; no error			       ;AN004;
;	       $else			;				       ;AN004;
	       JMP SHORT $$EN110
$$IF110:
		   stc			; set error flag (CF)		       ;AN004;
;	       $endif			;				       ;AN004;
$$EN110:
;	   $else long			;				       ;AN004;
	   JMP $$EN109
$$IF109:
	       cmp  ax,0		;				       ;AN004;
;	       $if  e,and,long		; end of DIR (CF + 00) and	       ;AN004;
	       JE $$XL3
	       JMP $$IF114
$$XL3:
next_level_down:			;				       ;AN004;
	       mov  bx,[FRAME_ptr]	; recover FRAME_ptr - but remember **  ;AC007;
					;  it points to the next available
					;  frame - not the last one - so
	       sub  bx,SIZE FRAME	; move back!			       ;AN007;
	       lea  ax,DIR_BUF		;				       ;AN004;
	       cmp  ax,bx		;				       ;AN004;
;	       $if  be			; as long as there are still FRAMEs    ;AC007;
	       JNBE $$IF114
		   mov	ax,[bx.p_cluster] ; get [present_cluster] from frame   ;AN004;
		   mov	[present_cluster],ax ;				       ;AN004;
		   mov	ax,[bx.s_offset] ; recover [sector_offset] from frame  ;AC015;
		   mov	[sector_offset],ax ;				       ;AC015;
		   mov	al,[bx.e_number] ; recover [entry_number] from frame   ;AN004;
		   mov	[entry_number],al ;				       ;AN004;
		   mov	[FRAME_ptr],bx	;				       ;AN004;

					; Now set up at exactly same point
					;  as when SubDIR was entered -
					;  advance to next entry

		   inc	al		;				       ;AN004;
		   cmp	al,[entries_per_sector] ;			       ;AN004;
;		   $if	b		;				       ;AN004;
		   JNB $$IF115
		       inc  [entry_number] ;				       ;AN004;
		       clc		; no error			       ;AN004;
;		   $else		; we've left the sector                ;AN004;
		   JMP SHORT $$EN115
$$IF115:
			xor	al, al
			mov [entry_number], al	; shall we start at, say, ENTRY ZERO?  Hmmmmm?

		       mov  ax,[present_cluster] ;			       ;AN004;
		       cmp  ax,0	; in the root ? 		       ;AN004;
;		       $if  ne		; no				       ;AN004;
		       JE $$IF117
			   mov	si,ax	;				       ;AN004;
			   mov	[cluster_high],1 ; force Upack to load FAT     ;AN004;
			   mov	ax,[FAT_sectors] ; get the size right	       ;AN004;
			   mov	[packet_sectors],ax ;			       ;AN004;
			   mov	[packet_buffer],OFFSET BUF ;		       ;AN004;
			   call Unpack	; to get next cluster # 	       ;AN004;
			   mov	[packet_buffer],OFFSET DIR_SECTOR ;	       ;AN004;
			   mov	[packet_sectors],1 ; set size back	       ;AN004;
			   mov	[cluster_high],1 ; ensure that FAT will be     ;AN004;
					;	      re-loaded

			   mov	ax,di	; check if at end		       ;AN007;
			   cmp	al,end_cluster ;  at the end?		       ;AN007;
;			   $if	nz	; not at end of line		       ;AN004;
			   JZ $$IF118
			       mov  [present_cluster],di ; save it	       ;AN004;
			       clc	;				       ;AN004;
;			   $else	; we are at the end of a Sub DIR chain ;AN004;
			   JMP SHORT $$EN118
$$IF118:

					; the following is a best attempt fix
					; to a bad design problem ...... (how
					;  to get back a level.....???

; SEPT 21 - best solution is to check BEFORE putting the entry in the frame
;			       (not when taking it off !!! )

			       jmp  next_level_down ;			       ;AN004;

;			   $endif	;				       ;AN004;
$$EN118:
;		       $else		;  yes - in the root		       ;AN004;
		       JMP SHORT $$EN117
$$IF117:
			   mov	ax,[sector_offset] ;			       ;AC015;
			   inc	ax	;				       ;AN004;
			   cmp	ax,[l_sector_offset] ;			       ;AC015;
;			   $if	b	;				       ;AN004;
			   JNB $$IF122
			       inc  [sector_offset] ;			       ;AN004;
				clc	; no error, continue with loop
;			   $else	; end of the line		       ;AN004;
			   JMP SHORT $$EN122
$$IF122:
			       stc	; we failed to find it		       ;AN004;
;			   $endif	;				       ;AN004;
$$EN122:
;		       $endif		;				       ;AN004;
$$EN117:
;		   $endif		;				       ;AN004;
$$EN115:
;	       $else			;				       ;AN004;
	       JMP SHORT $$EN114
$$IF114:
		   stc			; set error flag (CF)		       ;AN004;
;	       $endif			;				       ;AN004;
$$EN114:
;	   $endif			;				       ;AN004;
$$EN109:
;	   $if	c			; error 			       ;AN004;
	   JNC $$IF130
	       mov  ax,(util shl 8) + no_room ; error message - no room to sys ;AN004;
;	   $endif			;				       ;AN004;
$$IF130:
;      $leave c 			; if error			       ;AN004;
       JC $$EN107
;      $enddo long			;				       ;AN004;
       JMP $$DO107
$$EN107:
;  $endif				;				       ;AN004;
$$IF106:

   ret					;				       ;AN004;

   Search_DIR ENDP

   BREAK <SYS - Search_Loop >
;******************* START OF SPECIFICATIONS ***********************************
;Routine name: Search_Loop
;*******************************************************************************
;
;Description: Search_Loop scans through all entries of all sectors of all
;	      clusters of a given Directory for a specified cluster
;
;Called Procedures:
;
;		Unpack		   - to find a FAT entry for a Cluster #
;		Pack		   - to set a FAT entry for a Cluster #
;		Find_Empty_Cluster - find an unused cluster
;		Xfer_Data	   - transfere data from one cluster to another
;		Direct_Access	   - absolute disk i/o
;
;Input:
;
;Output:	CF = 0	found and freed [cluster_number]
;		CF = 1 - ax = 0 		- at end of directory
;			 ax = (message + class) - error occured
;			 ax = -1		- SubDir found
;			 bx = pointer to current entry
;
;Change History: Created	7/01/87 	FG
;
;******************* END OF SPECIFICATIONS *************************************
;******************+ START OF PSEUDOCODE +**************************************
;
;	START  Search_Loop
;
;	search till at end of directory - all clusters checked
;		search till at end of sectors - in given cluster
;			search till at end of sector - all entries checked
;			exitif starting cluster = [cluster_number]
;				set up for FAT
;				call Find_Empty_Cluster
;				if no error and
;				call Xfer_Data
;				reset for DIR
;				if no error
;					update dir_first_clust
;					set up for write
;					call Direct_Access to write out the directory
;				endif
;			orelse
;			leave if entry is a subdirectory (ah = ffh)
;				advace to next entry
;				zero ax
;			endloop if past end of sector
;				set fail flag (CF)
;			endsrch
;		exit if [current_cluster] found (NC)
;		orelse
;		leave if subdirectory found (CF + FF)
;			if sectors left to read
;				set up to read
;				call Direct_Access to read sector
;			else
;				set error flag (CF)
;				zero ax (end of sectors)
;			endif
;		endloop if error
;		endsrch
;	leave if [current_cluster] found (NC)
;	leave if SubDir found (CF + FF)
;	leave if Error (CF + message)
;		get [current_cluster] #
;		call Unpack to get next cluster #
;	exitif no more clusters
;		zero ax (end of clusters)
;		set error flag (CF)
;	orelse
;		convert cluster # to logical sector #
;		update [current_sector]
;	endloop
;	endsrch
;
;	ret
;
;	END  Search_Loop
;
;******************-  END  OF PSEUDOCODE -**************************************

   public Search_Loop

   Search_Loop PROC NEAR

   mov	ax,[present_cluster]		; initailize for search 	       ;AN004;
   cmp	ax,0				;				       ;AN004;
;  $if	ne				;				       ;AN004;
   JE $$IF135
       call cluster_2_sector		; convert it to a sector	       ;AN004;
       add  ax,[sector_offset]		;				       ;AC015;
;      $if  c				;				       ;AN004;
       JNC $$IF136
	   inc	dx			;				       ;AN004;
;      $endif				;				       ;AN004;
$$IF136:
;  $else				;				       ;AN004;
   JMP SHORT $$EN135
$$IF135:
       mov  ax,[sector_offset]		;[sector_offset] = current root sector ;AC015;
       xor  dx,dx			;				       ;AN004;
;  $endif				;				       ;AN004;
$$EN135:
   mov	[packet],ax			;				       ;AN004;
   mov	[packet+2],dx			;				       ;AN004;
   xor	ah,ah				;				       ;AN004;
   call Direct_Access			; to read the DIR		       ;AN004;
   mov	al,SIZE dir_entry		;				       ;AN004;
   mov	cl,[entry_number]		;				       ;AN004;
   mul	cl				;				       ;AN004;
   lea	bx,DIR_SECTOR			;				       ;AN004;
   add	bx,ax				; BX now points to the DIR entry       ;AN004;
;  $search				; till at end of directory	       ;AN004;
$$DO140:
					;     - all clusters checked
;      $search				; till at end of sectors	       ;AN004;
$$DO141:
					;     - in given cluster
;	   $search			; till at end of sector 	       ;AN004;
$$DO142:
					;     - all entries checked
	       cmp  BYTE PTR [bx],deleted ; make sure the entry is valid !!!   ;AN019;
;	       $if  e			; if it is not -		       ;AN019;
	       JNE $$IF143
		   xor	ax,ax		;				       ;AN019:
		   mov	[bx.dir_first],ax ; zap the starting cluster	       ;AN019;
		   mov	[bx.dir_attr],al ;  zap the attribute		       ;AN019;
;	       $endif			;				       ;AN019;
$$IF143:
	       mov  ax,[bx.dir_first]	;				       ;AN004;
	       cmp  ax,[current_cluster] ;				       ;AN004;
;	   $exitif e,and,long		; starting cluster = [current_cluster] ;AN004;
	   JE $$XL4
	   JMP $$IF142
$$XL4:
	       cmp  BYTE PTR [bx],deleted ; make sure the entry is valid !!!   ;AN007;
;	   $exitif ne,and,long		; and entry is not deleted	       ;AN007;
	   JNE $$XL5
	   JMP $$IF142
$$XL5:
	       cmp  BYTE PTR [bx],dot	;				       ;AN007;
;	   $exitif ne,long		; and entry is not a . or .. name      ;AN007;
	   JNE $$XL6
	   JMP $$IF142
$$XL6:
	       test [bx.dir_attr],attr_directory ; is it a subdir ?	       ;AN007;
;	       $if  nz			;if entry is a subdirectory	       ;AN007;
	       JZ $$IF146
		   inc	[DIR_cluster]	; signal special processing	       ;AN007;
					;   Xfere_Data will use this later -
					;    0 = not a sub DIR
					;    1 = do Sub DIR processing and
					;	 update [DIR_cluster] to the
					;	 same value as [empty_cluster]
;	       $endif			;				       ;AN007;
$$IF146:
	       mov  ax,[packet] 	; save pointer to this DIR	       ;AN007;
	       mov  [dir_sector_low],ax ;				       ;AN007;
	       mov  ax,[packet+2]	;				       ;AN007;
	       mov  [dir_sector_hi],ax	;				       ;AN007;
	       mov  [source_ptr],bx	; save pointer			       ;AN004;
	       mov  [cluster_high],1	; force Upack to load FAT	       ;AN004;
	       mov  ax,[FAT_sectors]	; get the size right		       ;AN004;
	       mov  [packet_sectors],ax ;				       ;AN004;
	       mov  [packet],1		;				       ;AN004;
	       mov  [packet+2],0	;				       ;AN004;
	       mov  [packet_buffer],OFFSET BUF ;			       ;AN004;
	       call Find_Empty_Cluster	;				       ;AN004;
;	       $if  nc,and		; no errors so far		       ;AN004;
	       JC $$IF148
	       mov  si,[empty_cluster]	;				       ;AN004;
	       mov  dx,[next_cluster]	;				       ;AN004;
	       call PACK		;				       ;AN004;
;	       $if  nc,and		; no errors so far		       ;AN004;
	       JC $$IF148
	       mov  si,[current_cluster] ;				       ;AN004;
	       xor  dx,dx		; make it empty 		       ;AN004;
	       call PACK		;				       ;AN004;
;	       $if  nc			; no errors so far		       ;AN004;
	       JC $$IF148
		   cmp	[bigfat],0	;				       ;AN004;
;		   $if	ne		;				       ;AN004;
		   JE $$IF149
		       mov  [cluster_high],1 ; ensure that FAT will be updated ;AN004;
		       call Unpack	;				       ;AN004;
;		   $else		; must manualy write out 12 bit FATS   ;AN004;
		   JMP SHORT $$EN149
$$IF149:
		       xor  ah,ah	;				       ;AN004;
		       dec  ah		;				       ;AN004;
		       mov  [packet],1	; start with the first FAT	       ;AN004;
		       call Direct_Access ; write it out - ignore errors       ;AN004;
		       mov  ax,[FSIZE]	;				       ;AN004;
		       add  [packet],ax ; advance to second FAT 	       ;AN004;
		       xor  ah,ah	;				       ;AN004;
		       dec  ah		;				       ;AN004;
		       call Direct_Access ; write it out - ignore errors       ;AN004;
;		   $endif		;				       ;AN004;
$$EN149:
;	       $endif			;				       ;AN004;
$$IF148:
;	       $if  nc,and		; no error and			       ;AN004;
	       JC $$IF153
	       call Xfer_Data		;				       ;AN004;
;	       $if  nc			; no error			       ;AN004;
	       JC $$IF153

;M008
;                  [current_cluster] = old cluster #
;                  [empty_cluster]   = new cluster #

                   call Update_CDS      ;Update current dir. entries
;M008

		   mov	ax,[empty_cluster] ; update dir_first_clust	       ;AN004;
		   mov	bx,[source_ptr] ; recover pointer		       ;AN004;
		   mov	[bx.dir_first],ax ;				       ;AN004;
		   mov	[packet_sectors],1 ; set size back		       ;AN004;
		   mov	[packet_buffer],OFFSET DIR_SECTOR ;		       ;AN004;
		   mov	ax,[dir_sector_low] ; reset DIR sector		       ;AN007;
		   mov	[packet],ax	;				       ;AN007;
		   mov	ax,[dir_sector_hi] ;				       ;AN007;
		   mov	[packet+2],ax	;				       ;AN007;
		   xor	ah,ah		; set up for write		       ;AN004;
		   dec	ah		;				       ;AN004;
		   call Direct_Access	; to write out the directory	       ;AN004;
;		   $if	nc,and		;				       ;AN004;
		   JC $$IF154
		   cmp	[DIR_cluster],0 ; is a DIR being processed ?	       ;AN007;
;		   $if	ne		;				       ;AN007;
		   JE $$IF154
		       call Sub_DIR_Loop ; update any children		       ;AN007;
;		   $endif		;				       ;AN007;
$$IF154:
;		   $if	nc		; if no errors			       ;AN007;
		   JC $$IF156
		       mov  ax,[FAT_sectors] ;only read needed sectors	       ;AN004;
		       mov  [packet_sectors],ax ;			       ;AN004;
		       mov  [packet],1	;				       ;AN004;
		       mov  [packet_buffer],OFFSET BUF ; point to FAT buffer   ;AN004;
		       mov  [cluster_high],clusters_loaded ;		       ;AN004;
		       mov  [cluster_low],0 ;				       ;AN004;
		       xor  cx,cx	;				       ;AN004;
		       mov  di,cx	;				       ;AN004;
		       dec  di		;				       ;AN004;
		       mov  cl,[num_of_FATS] ;				       ;AN004;
					;				       ;AN004;
		       call Load_FAT	; restore FAT			       ;AN004;
					;				       ;AN004;
		       push es		; update DPB first cluster	       ;AN004;
		       mov  bx,ds	;				       ;AN004;
		       mov  es,bx	;				       ;AN004;
		       lds  bx,[THIS_DPB] ;				       ;AN004;

		       ASSUME ds:nothing,es:DATA

		       mov  [bx.dpb_next_free],2 ;			       ;AN004;
		       mov  ax,es	;				       ;AN004;
		       mov  ds,ax	;				       ;AN004;
		       pop  es		;				       ;AN004;

		       ASSUME DS:data, es:nothing

;		   $endif		;				       ;AN004;
$$IF156:
;	       $endif			;				       ;AN004;
$$IF153:
;	   $orelse			;				       ;AN004;
	   JMP SHORT $$SR142
$$IF142:
	       xor  ax,ax		; get ready in case -----	       ;AN007;
	       cmp  BYTE PTR [bx],0	; at the end of the dir?	       ;AN007;
;	   $leave e			;   then no point in continuing        ;AN007;
	   JE $$EN142
	       dec  ax			; get ready in case we fail	       ;AN004;
	       test [bx.dir_attr],attr_directory ; is it a subdir ?	       ;AN004;
;	   $leave nz, and		;if entry is a subdirectory (ah = ffh) ;AN004;
	   JZ $$LL161
	       cmp  byte ptr [bx],dot	; but not a DOT 		       ;AN007;
;	   $leave ne			;				       ;AN007;
	   JNE $$EN142
$$LL161:
	       xor  ax,ax		; zero ax			       ;AN004;
	       add  bx,SIZE dir_entry	; advace to next entry		       ;AN004;
	       inc  [entry_number]	;				       ;AN004;
	       cmp  bx,OFFSET BUF	; are we out of sector ?	       ;AN004;
;	   $endloop ae,long		;if past end of sector		       ;AN004;
	   JAE $$XL7
	   JMP $$DO142
$$XL7:
$$EN142:
	       stc			; set fail flag (CF)		       ;AN004;
;	   $endsrch			;				       ;AN004;
$$SR142:
;      $exitif nc			;[current_cluster] found (NC)	       ;AN004;
       JC $$IF141
;      $orelse				;				       ;AN004;
       JMP SHORT $$SR141
$$IF141:

					; we have  CF = 1 and could have:
					;		AX = 0 -
					;		AX = 1 to fffe
					;		AX = ffff
					;  so - leave if anything other than
					;	AX = 0 (out of stuff)

;      $leave c,and			; if not out of stuff		       ;AN004;
       JNC $$LL166
	   cmp	ax,0			;				       ;AN009;
	   stc				; restore carry flag!		       ;AN007;
;      $leave nz			;	------ leave !		       ;AN009;
       JNZ $$EN141
$$LL166:
	   mov	ax,[sector_offset]	;				       ;AC015;
	   inc	ax			;				       ;AN004;
	   cmp	[present_cluster],0	; are we in the root?		       ;AN007;
;	   $if	e			; if so -			       ;AN004;
	   JNE $$IF167
	       cmp  ax,[l_sector_offset] ;   use root sectors		       ;AC013;
;	   $else			;  else -			       ;AN004;
	   JMP SHORT $$EN167
$$IF167:
	       cmp  ax,[CSIZE]		;      use sectors per cluster	       ;AN004;
;	   $endif			;				       ;AN004;
$$EN167:
;	   $if	b			; sectors left to read		       ;AN004;
	   JNB $$IF170
	       add  [packet],1		; advance to the next sector	       ;AN004;
;	       $if  c			;				       ;AN004;
	       JNC $$IF171
		   inc	[packet+2]	; adjust high word if needed	       ;AN004;
;	       $endif			;				       ;AN004;
$$IF171:
	       xor  ah,ah		; set up to read		       ;AN004;
	       mov  [entry_number],ah	;				       ;AN004;
	       inc  [sector_offset]	;				       ;AN004;
	       call Direct_Access	; to read sector		       ;AN004;
	       lea  bx,DIR_SECTOR	; set index to start of sector	       ;AN004;
;	   $else			;				       ;AN004;
	   JMP SHORT $$EN170
$$IF170:
	       xor  ax,ax		; zero ax (end of sectors)	       ;AN004;
	       stc			; set error flag (CF)		       ;AN004;
;	   $endif			;				       ;AN004;
$$EN170:
;      $endloop c,long			; if error			       ;AN004;
       JC $$XL8
       JMP $$DO141
$$XL8:
$$EN141:
;      $endsrch 			;				       ;AN004;
$$SR141:
;  $leave nc				; if [current_cluster] found (NC)      ;AN004;
   JNC $$EN140
;  $leave c,and 			;if SubDir found (CF + FF)	       ;AN004;
   JNC $$LL178
       cmp  ax,0			;				       ;AN004;
       stc				; set carry			       ;AN007;
;  $leave nz				; if Error (CF + messageor FFFFh)      ;AN004;
   JNZ $$EN140
$$LL178:

					;--------------------------------------
					; CF = 1 and AX = 0 means - no critical
					;			     errors
					;			  -  no Sub DIR
					;			     found
					;  inner SEARCH is out of sectors
					;   - so advance to the next cluster
					;--------------------------------------
       mov  si,[present_cluster]	; get [present_cluster] #	       ;AN004;
       cmp  si,0			; end of the root ?		       ;AN004;
;      $if  nz				;				       ;AN004;
       JZ $$IF179
	   mov	[cluster_high],1	; force Upack to load FAT	       ;AN004;
	   mov	ax,FAT_sectors		; get the size right		       ;AN004;
	   mov	[packet_sectors],ax	;				       ;AN004;
	   mov	[packet_buffer],OFFSET BUF ;				       ;AN004;
	   call Unpack			; to get next cluster # 	       ;AN004;
	   mov	[packet_sectors],1	; set size back 		       ;AN004;
	   mov	[cluster_high],1	; ensure that FAT will be re-loaded    ;AN004;
	   mov	[packet_buffer],OFFSET DIR_SECTOR ;			       ;AN004;
	   mov	ax,di			;				       ;AN007;
	   cmp	al,end_cluster		;				       ;AN007;
;      $endif				;				       ;AN004;
$$IF179:
;  $exitif z				; no more clusters		       ;AN004;
   JNZ $$IF140
       xor  ax,ax			; zero ax (end of clusters)	       ;AN004;
       stc				; set error flag (CF)		       ;AN004;
;  $orelse				;				       ;AN004;
   JMP SHORT $$SR140
$$IF140:
       mov  [present_cluster],di	;				       ;AN004;
       mov  ax,di			; set up for cluster_2_sector	       ;AN004;
       call cluster_2_sector		; convert cluster # to logical sector #;AN004;
       mov  [packet],ax 		;				       ;AN004;
       mov  [packet+2],dx		;				       ;AN004;
       xor  ax,ax			;				       ;AN004;
       mov  [sector_offset],ax		; reset [sector_offset] 	       ;AC015;
       mov  [entry_number],ah		; reset [entry_number]		       ;AN004;
       call Direct_Access		; to read sector		       ;AN004;
       lea  bx,DIR_SECTOR		; set pointer			       ;AN004;
;  $endloop c,long			; end loop if read fails	       ;AN004;
   JC $$XL9
   JMP $$DO140
$$XL9:
$$EN140:
;  $endsrch				;				       ;AN004;
$$SR140:

   ret					;				       ;AN004;

   Search_Loop ENDP

   BREAK <SYS - Update_CDS >

;******************* START OF SPECIFICATIONS ***********************************
;Routine name:  Update_CDS
;*******************************************************************************
;
;Description:   Following a move of a subdirectory, entries in the Current
;		Directory Structure (CDS) must be updated to reflect the new
;		cluster # of the subdirectory, if that subdirectory was in
;               the CDS list.
;
;Called Procedures:
;               INT 21H, function 52H ($GET_IN_VARS)
;
;Input:         [current_cluster] = old cluster #.
;		[empty_cluster]   = new cluster #.
;
;Output:        No error return.
;
;Uses:          AX,BX,CX,DX,DI
;
;Change History: Created       11/21/90         M008
;
;******************* END OF SPECIFICATIONS *************************************
;******************+ START OF PSEUDOCODE +**************************************
;
; for (all entries in CDS table)
; {
;	if (CDS entry cluster # == old subdir. cluster # ([current_cluster]))
;	{
;		CDS entry cluster # = new subdir. cluster # ([empty_cluster])
;	}
; }
;
;******************-  END  OF PSEUDOCODE -**************************************

public Update_CDS

Update_CDS PROC NEAR

ASSUME  ES:NOTHING

        push    es
        mov     ah,Get_In_Vars
        int     21h                     ;ES:BX -> SysInitVars structure.

        xor     cx,cx
        mov     cl,es:[bx].SYSI_NCDS    ;CX = # of CDS entries.
        les     bx,es:[bx].SYSI_CDS     ;ES:BX -> Head of CDS list.
        mov     ax,[current_cluster]    ;AX = old cluster #.
        mov     di,[empty_cluster]      ;DI = new cluster #.
        mov     dl,TargDrv              ;DL = drive letter.

ucds1:  test    es:[bx].CURDIR_FLAGS,CURDIR_inuse ;In use?
        jz      ucds5                             ; -no, jump.
        test    es:[bx].CURDIR_FLAGS,CURDIR_isnet ;Net drive?
        jnz	ucds5                             ; -yes, jump: skip it.
        cmp     es:[bx].CURDIR_TEXT,dl  ;Same drive?
        jne     ucds5                   ; -no, jump.
        cmp     es:[bx].CURDIR_ID,ax    ;Same cluster?
        jne     ucds5                   ; -no, jump.
        mov     es:[bx].CURDIR_ID,di    ; -yes, update cluster #.
ucds5:  add     bx,curdirLen            ;ES:BX -> next CDS entry.
        loop    ucds1

        pop     es
	ret

Update_CDS ENDP

   BREAK <SYS - Sub_DIR_Loop >

;******************* START OF SPECIFICATIONS ***********************************
;Routine name: Sub_DIR_Loop
;*******************************************************************************
;
;Description: Sub_DIR_Loop scans through all entries of a subdirectory looking
;	      child subdirectories. If found, their parent [dir_first] entries
;	      (the .. entry) are updated to point to the correct cluster
;
;Called Procedures:
;
;		Unpack		   - to find a FAT entry for a Cluster #
;		Direct_Access	   - absolute disk i/o
;
;Input: 	[empty_cluster]   - new parent Sub DIR cluster #
;		[DIR_cluster]	  - current cluster of DIR being looped
;
;Output:	CF = 0	at end of directory
;		CF = 1	a read/write error occured
;
;Change History: Created       10/07/87 	FG
;
;******************* END OF SPECIFICATIONS *************************************
;******************+ START OF PSEUDOCODE +**************************************
;
;	START Sub_DIR _Loop
;
;	get DIR_cluster
;	call cluster_2_sector
;	update packet
;	set for read
;	reset entry pointer
;	reset sector count
;	call Direct_Access
;	if no error
;	      search till at end of directory - all clusters checked
;		    search till at end of sectors - in given cluster
;			  search till at end of sector - all entries checked
;			  leave if null entry
;				if entry is not deleted and
;				if this entry is a subdir and
;				if this is a true entry and
;				save current sector
;				save current entry
;				get start cluster
;				call cluster_2_sector
;				set for read
;				call Direct_Access
;				if no errors and
;				update pointer to parent
;				set for write
;				call Direct_Access
;				if no errors and
;				recover current sector
;				recover current entry
;				if no errors
;				     call Direct_Access
;				endif
;			  exitif error (CF)
;			  orelse
;				advance to next entry
;			  endloop if past end of sector
;				clear error flag
;			  endsrch
;		    leave if error
;			  advance to next sector (packet)
;			  incriment sector count
;		    exitif past end of cluster
;			  clear error flag
;		    orelse
;			  reset entry pointer
;			  set for read
;			  call Direct_Access
;		    endloop if error
;		    endsrch
;	      leave if error
;		    get DIR_cluster
;		    call UNPACK to find next Sub DIR cluster
;	      exitif at end of chain
;		    clear error flag
;	      orelse
;		    update DIR_cluster
;		    call cluster_2_sector
;		    update packet
;		    set for read
;		    call Direct_Access
;	      leave if error
;		    reset entry pointer
;		    reset sector count
;	      endloop
;	      endsrch
;	endif
;	reset Sub_DIR_cluster to 0
;
;	ret
;
;	END  Sub_DIR_Loop
;
;******************-  END  OF PSEUDOCODE -**************************************

   public Sub_DIR_Loop

   Sub_DIR_Loop PROC NEAR

   mov	ax,[DIR_cluster]		; get DIR_cluster		       ;AN007;
   call cluster_2_sector		; to convert to a logical sector       ;AN007;
   mov	[packet],ax			; update packet 		       ;AN007;
   mov	[packet+2],dx			;				       ;AN007;
   xor	ax,ax				; set for read			       ;AN007;
   call Direct_Access			; to read the first sector of the DIR  ;AN007;
;  $if	nc,long 			; if no error			       ;AN007;
   JNC $$XL10
   JMP $$IF185
$$XL10:
       mov  [sector_count],1		; reset sector count		       ;AN007;
       lea  bx,DIR_SECTOR		; reset entry pointer		       ;AN007;
;      $search				; till at end of directory	       ;AN007;
$$DO186:
					;      - all clusters checked	       ;AN007;
;	   $search			; till at end of sectors	       ;AN007;
$$DO187:
					;      - in given cluster	       ;AN007;
;	       $search			; till at end of sector 	       ;AN007;
$$DO188:
					;      - all entries checked	       ;AN007;
		   mov	[dir_offset],bx ; reset entry pointer		       ;AN007;
		   cmp	BYTE PTR [bx],0 ; null entry (00)?		       ;AN007;
;	       $leave z 		; if null entry 		       ;AN007;
	       JZ $$EN188
		   cmp	BYTE PTR [bx],deleted ; deleted entry (E5)?	       ;AN007;
;		   $if	ne,and		; if entry is not deleted and	       ;AN007;
		   JE $$IF190
		   test [bx.dir_attr],attr_directory ; is it a subdir ?        ;AN007;
;		   $if	nz,and		; if this entry is a subdir and        ;AN007;
		   JZ $$IF190
		   cmp	BYTE PTR [bx],dot ; dot entry (2E)?		       ;AN007;
;		   $if	ne,and		; this is a true entry and	       ;AN007;
		   JE $$IF190
		   mov	ax,[packet]	; save current sector		       ;AN007;
		   mov	[dir_sector_low],ax ;				       ;AN007;
		   mov	ax,[packet+2]	;				       ;AN007;
		   mov	[dir_sector_hi],ax ;				       ;AN007;
		   mov	ax,[bx.dir_first] ; get start cluster		       ;AN007;
		   call cluster_2_sector ; convert to sector		       ;AN007;
		   mov	[packet],ax	; update packet 		       ;AN007;
		   mov	[packet+2],dx	;				       ;AN007;
		   xor	ax,ax		; set for read			       ;AN007;
		   call Direct_Access	; to read it in 		       ;AN007;
;		   $if	nc,and		; no errors and 		       ;AN007;
		   JC $$IF190
		   mov	ax,[empty_cluster] ; update pointer to parent	       ;AN007;
		   lea	bx,DIR_SECTOR	;				       ;AN007;
		   mov	[bx + dir_first + size dir_entry],ax ;			 ;AN007;
		   xor	ax,ax		; set for write 		       ;AN007;
		   dec	ax		;				       ;AN007;
		   call Direct_Access	; to write it back		       ;AN007;
;		   $if	nc,and		; if no errors and		       ;AN007;
		   JC $$IF190
		   mov	ax,[dir_sector_low] ;				       ;AN007;
		   mov	[packet],ax	; recover current sector	       ;AN007;
		   mov	ax,[dir_sector_hi] ;				       ;AN007;
		   mov	[packet+2],ax	;				       ;AN007;
;		   $if	nc		; if no errors			       ;AN007;
		   JC $$IF190
		       call Direct_Access ; to continue where we left off      ;AN007;
;		   $endif		;				       ;AN007;
$$IF190:
;	       $exitif c		; quit if error (CF)		       ;AN007;
	       JNC $$IF188
;	       $orelse			;				       ;AN007;
	       JMP SHORT $$SR188
$$IF188:
		   mov	bx,[dir_offset] ; recover current entry 	       ;AN007;
		   add	bx,SIZE dir_entry ; advance to next entry	       ;AN007;
		   cmp	bx,OFFSET BUF	;				       ;AN007;
;	       $endloop a		; if past end of sector 	       ;AN007;
	       JNA $$DO188
$$EN188:
		   clc			; clear error flag		       ;AN007;
;	       $endsrch 		;				       ;AN007;
$$SR188:
;	   $leave c			; if error - quit		       ;AN007;
	   JC $$EN187
	       xor  ax,ax		;				       ;AN007;
	       mov  ax,[CSIZE]		; incriment sector count	       ;AN007;
	       inc  [sector_count]	;				       ;AN007;
	       cmp  [sector_count],al	;				       ;AN007;
;	   $exitif a			; past end of cluster		       ;AN007;
	   JNA $$IF187
	       clc			; clear error flag		       ;AN007;
	       mov  [sector_count],1	; reset sector count		       ;AN007;
;	   $orelse			;				       ;AN007;
	   JMP SHORT $$SR187
$$IF187:
	       xor  ax,ax		; set for read			       ;AN007;
	       add  WORD PTR [packet],1 ; advance to next sector (packet)      ;AN007;
	       adc  [packet+2],ax	; look after carry		       ;AN007;
	       call Direct_Access	; to read in next sector	       ;AN007;
	       lea  bx,DIR_SECTOR	; reset entry pointer		       ;AN007;
;	   $endloop c,long		; if error - quit		       ;AN007;
	   JC $$XL11
	   JMP $$DO187
$$XL11:
$$EN187:
;	   $endsrch			;				       ;AN007;
$$SR187:
;      $leave c 			; if error - quit		       ;AN007;
       JC $$EN186
	   mov	si,[DIR_cluster]	; get DIR_cluster		       ;AN007;
	   push [packet_sectors]	; save current packet stuff	       ;AN007;
	   push [packet_buffer] 	;				       ;AN007;
	   mov	ax,[FAT_sectors]	; update packet to FAT		       ;AN007;
	   mov	[packet_sectors],ax	;				       ;AN007;
	   mov	[packet_buffer],OFFSET BUF ;				       ;AN007;
	   mov	[cluster_high],1	; force FAT to be reloaded - if needed ;AN007;
	   call UNPACK			; to find next Sub DIR cluster	       ;AN007;
	   pop	[packet_buffer] 	; recover packet to DIR 	       ;AN007;
	   pop	[packet_sectors]	;				       ;AN007;
	   mov	ax,di			;				       ;AN007;
	   cmp	al,end_cluster		;				       ;AN007;
;      $exitif e			; at end of chain		       ;AN007;
       JNE $$IF186
	   clc				; clear error flag		       ;AN007;
;      $orelse				;				       ;AN007;
       JMP SHORT $$SR186
$$IF186:
	   mov	[DIR_cluster],ax	;				       ;AN007;
	   call cluster_2_sector	; to convert to sector		       ;AN007;
	   mov	[packet],ax		; update packet 		       ;AN007;
	   mov	[packet+2],dx		;				       ;AN007;
	   xor	ax,ax			; set for read			       ;AN007;
	   call Direct_Access		; to read first sector of next cluster ;AN007;
;      $leave c 			; if error			       ;AN007;
       JC $$EN186
	   lea	bx,DIR_SECTOR		; reset entry pointer		       ;AN007;
	   mov	[sector_count],1	; reset sector count		       ;AN007;
;      $endloop long			;				       ;AN007;
       JMP $$DO186
$$EN186:
;      $endsrch 			;				       ;AN007;
$$SR186:
;  $endif				;				       ;AN007;
$$IF185:
   mov	[DIR_cluster],0 		; reset Sub_DIR_cluster to 0	       ;AN007;

   ret					;				       ;AN007;

   Sub_DIR_Loop ENDP

   BREAK <SYS - Unpack >
;******************* START OF SPECIFICATIONS ***********************************
;Routine name: Unpack
;*******************************************************************************
;
;Description: Read an entry in the FAT
;
;Called Procedures:
;
;		Check_FAT - to make sure right part of FAT is loaded (16 bit only)
;
;Input: 	Cluster number in SI
;
;Output:	Return contents in DI
;		xX destroyed
;		ZF set if cluster is free
;
;Change History: Created	7/01/87 	FG
;
;******************* END OF SPECIFICATIONS *************************************
;******************+ START OF PSEUDOCODE +**************************************
;
;	START Unpack
;
;	if 16 bit FAT
;		call Check_FAT
;		multiply # by 2
;		read value
;		check if empty
;	else
;		multiply # by 2
;		read value
;		if not word alligned
;			shift to allign
;		endif
;		mask off unused portion (set ZF if empty)
;	endif
;
;	ret
;
;	END Unpack
;
;******************-  END  OF PSEUDOCODE -**************************************

   public Unpack

   Unpack PROC NEAR

   lea	bx,BUF				;				       ;AN004;
   mov	di,si				;				       ;AN004;
   cmp	[BIGFAT],0			;				       ;AN004;
;  $if	nz				; if 16 bit FAT 		       ;AN004;
   JZ $$IF208
       push si				;				       ;AN004;
       call Check_FAT			; make sure right part of FAT loaded   ;AN004;
;      $if  nc				;				       ;AN004;
       JC $$IF209
	   mov	di,si			; Check_FAT ajusts si		       ;AN004;
	   shl	di,1			; Mult by 2			       ;AN004;
	   mov	di,WORD PTR [di+bx]	;				       ;AN004;
	   or	di,di			; Set zero			       ;AN004;
	   clc				;				       ;AN004;
;      $endif				;				       ;AN004;
$$IF209:
       pop  si				;				       ;AN004;
;  $else				; is 12 bit fat 		       ;AN004;
   JMP SHORT $$EN208
$$IF208:
       shr  di,1			;				       ;AN004;
       add  di,si			; Mult by 1.5			       ;AN004;
       mov  di,WORD PTR [di+bx] 	;				       ;AN004;
       test si,1			;				       ;AN004;
;      $if  nz				; not allign on cluster 	       ;AN004;
       JZ $$IF212
	   shr	di,1			;				       ;AN004;
	   shr	di,1			;				       ;AN004;
	   shr	di,1			;				       ;AN004;
	   shr	di,1			;				       ;AN004;
;      $endif				;				       ;AN004;
$$IF212:
       and  di,0FFFh			;				       ;AN004;
;  $endif				;				       ;AN004;
$$EN208:


   ret					;				       ;AN004;

   Unpack ENDP

   BREAK <SYS - Pack >
;******************* START OF SPECIFICATIONS ***********************************
;Routine name: Pack
;*******************************************************************************
;
;Description:	Change an entry in the FAT
;
;Called Procedures:
;
;		Check_FAT - to make sure right part of FAT is loaded (16 bit only)
;
;Input: 	si - cluster number to be packed
;		dx - data to be placed in cluster (si)
;
;Output:	bx,dx	destroyed
;
;Change History: Created	7/01/87 	FG
;
;******************* END OF SPECIFICATIONS *************************************
;******************+ START OF PSEUDOCODE +**************************************
;
;	START Pack
;
;	if 16 bit FAT
;		call Check_FAT
;		convert cluster # to offset
;		add offset of FAT
;		store value
;	else
;		convert cluster # to offset
;		add offset of FAT
;		recover current entry word
;		if not alligned on word boundary
;			shift to allign
;			mask off value to be replaced (byte)
;		else
;			mask off value to be replaced (word)
;		endif
;	combine new value and ballace
;	store the entry
;
;	ret
;
;	END Pack
;
;******************-  END  OF PSEUDOCODE -**************************************

   public Pack

   Pack PROC NEAR

   lea	bx,BUF				;				       ;AN004;
   push si				;				       ;AN004;
   mov	di,si				;				       ;AN004;
   cmp	[BIGFAT],0			;				       ;AN004;
;  $if	nz				; 16 bit FAT			       ;AN004;
   JZ $$IF215
       call Check_FAT			; make sure the part of the FAT we want;AN004;
					;   is loaded & ajust offset to match  ;AN004;
       shl  si,1			; convert cluster # to offset	       ;AN004;
       add  si,bx			; add offset of FAT		       ;AN004;
       mov  [si],dx			; store value			       ;AN004;
       mov  [FAT_changed],1		; the fat has been changed	       ;AN004;
;  $else				; its 12 bit FAT		       ;AN004;
   JMP SHORT $$EN215
$$IF215:
       shr  si,1			;				       ;AN004;
       add  si,bx			;				       ;AN004;
       add  si,di			;				       ;AN004;
       shr  di,1			;				       ;AN004;
       mov  di,[si]			;				       ;AN004;
;      $if  c				; no alligned			       ;AN004;
       JNC $$IF217
	   shl	dx,1			;				       ;AN004;
	   shl	dx,1			;				       ;AN004;
	   shl	dx,1			;				       ;AN004;
	   shl	dx,1			;				       ;AN004;
	   and	di,0Fh			;				       ;AN004;
;      $else				;				       ;AN004;
       JMP SHORT $$EN217
$$IF217:
	   and	di,0F000h		;				       ;AN004;
;      $endif				;				       ;AN004;
$$EN217:
       or   di,dx			;				       ;AN004;
       mov  [si],di			;				       ;AN004;
;  $endif				;				       ;AN004;
$$EN215:
   pop	si				;				       ;AN004;

   ret					;				       ;AN004;

   Pack ENDP

   BREAK <SYS - Check_FAT >
;******************* START OF SPECIFICATIONS ***********************************
;Routine name: Check_FAT
;*******************************************************************************
;
;Description:	Check that the protion of the FAT that is referenced in SI
;		is presently in memory.
;
;		Only 12 sectors of the FAT are kept in memory. If the requested
;		cluster does not fall within that range, 12 sectors of the FAT
;		are read into memory - the first cluster will contain the entry
;		of interest.
;
;Called Procedures:
;
;		none
;
;Input: 	si - cluster number to be checked
;		[FAT_changed] = 0 - no need to write out FAT before changing
;			      = x - must write before reading.
;
;
;Output:	appropriate block of FAT in BUF
;		si ajusted to match
;		NB: BX, DX preserved (for UNPACK)
;
;Change History: Created	7/01/87 	FG
;
;******************* END OF SPECIFICATIONS *************************************
;******************+ START OF PSEUDOCODE +**************************************
;
;	START Check_FAT
;
;
;	ret
;
;	END  Check_FAT
;
;******************-  END  OF PSEUDOCODE -**************************************

   public Check_FAT

   Check_FAT PROC  NEAR

   push bx
   cmp	si,[cluster_low]		;				       ;AN004;
;  $if	ae,and				;				       ;AN004;
   JNAE $$IF221
   cmp	si,[cluster_high]		;				       ;AN004;
;  $if	be				;				       ;AN004;
   JNBE $$IF221
       sub  si,[cluster_low]		;				       ;AN004;
;  $else				; the cluster is outside the range
   JMP $$EN221                          ; M007
$$IF221:
					;  of the part of the FAT presently loaded.
					; convert cluster # into sector + offset
					; by dividing the cluster # by # of entries
					; per sector IE: sector = 512 bytes
					;	     cluster entry = 2 bytes
					;	then # of entries/sector = 256

       cmp  [FAT_changed],0		;				       ;AN004;
;      $if  ne				;				       ;AN004;
       JE $$IF223

;M007
;       Flush the FAT buffer to both copies of the FAT on the disk.  Since
;	the FAT buffer may include sectors which extend beyond the end of
;	the FAT, we take care to only flush the FAT sectors.

	push	[packet_sectors]
        mov     ax,[packet]             ;AX = logical sector # of FAT. (Note:
                                        ; this assumes FAT sector # < 64k).
        cmp     [FAT_2],0               ;packet -> FAT #2?
        je      cf10                    ; -no, jump.
        sub     ax,[FSIZE]              ; -yes, change it to FAT #1.
	mov     [packet],ax
        mov     [FAT_2],0
cf10:	mov	bx,first_FAT            ;BX = starting sector # of FAT #1.
        add     bx,[FSIZE]              ;BX = last sector # of FAT #1 + 1.
        sub     bx,ax                   ;BX = # of remaining FAT #1 sectors.
        cmp     bx,[packet_sectors]     ;FAT buffer extends beyond FAT?
        jae     cf20                    ; -no, jump.
        mov     [packet_sectors],bx     ; -yes, do not write beyond FAT.
cf20:   mov     ah,-1
        call    Direct_Access           ;Write FAT #1 to disk; ignore errors.
        mov     ax,[FSIZE]
        add     [packet],ax
        mov     ah,-1
        call    Direct_Access           ;Write FAT #2 to disk; ignore errors.
        pop     [packet_sectors]
	mov	[FAT_changed],0 	;FAT has been flushed.
;M007                                   ;FAT_2 = 0.

$$IF223:
       mov  ax,si			;				       ;AN004;
       xor  cx,cx			;				       ;AN004;
       mov  cl,al			; this is a cheap and		       ;AN004;
       mov  al,ah			;  dirty divide by 256		       ;AN004;
       xor  ah,ah			;   ax = result 		       ;AN004;
       push ax				; save starting sector		       ;AN006;
       mov  si,cx			;   cx = remainder		       ;AN004;
       inc  ax				; leave room for boot sector	       ;AN004;
       mov  [packet],ax 		;				       ;AN004;
       mov  [packet+2],0		;				       ;AN004;
       push dx				;				       ;AN004;
       call Direct_Access		;				       ;AN004;
;      $if  c				;				       ;AN004;
       JNC $$IF228
	   mov	ax,[FSIZE]		;				       ;AN004;
	   add	[packet],ax		;				       ;AN004;
	   mov	[FAT_2],1		; packet points to FAT #2	       ;AN004;
	   call Direct_Access		;				       ;AN004;
;      $endif				;				       ;AN004;
$$IF228:
       pop  dx				;				       ;AN004;
       pop  ax				; recover starting sector	       ;AN006;
;      $if  nc				;				       ;AN004;
       JC $$IF230
	   xchg al,ah			; convert sector back to cluster       ;AN004;
	   mov	[cluster_low],ax	; new bottom of FAT		       ;AN004;
	   mov	[cluster_high],ax	;				       ;AN004;
	   add	[cluster_high],clusters_loaded ; new top of FAT 	       ;AN004;
           jnc  $$IF230                 ; M005: Jump if no overflow.
           mov  [cluster_high],-1       ; M005: Set to max. value.
           clc                          ; M005: No error.
;      $endif				;				       ;AN004;
$$IF230:
;  $endif				;				       ;AN004;
$$EN221:
   pop	bx


   ret					;				       ;AN004;

   Check_FAT ENDP

ENDIF           ; NEED_CLUSTER_2

   CODE ENDS

   END


=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\tree\treems.inc ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

;:util TREE			 ;utility name
;:class 1			 ;DOS extended errors
;:class 2			 ;parse errors:
;1  Too many parameters
;2  Required parameter missing
;3  Invalid switch
;4  Invalid keyword
;5  Parameter value not in allowed range
;6  Parameter value not allowed    [parse ret codes 6 and 7]
;7   (undefined)
;8  Parameter format not correct
;9   (undefined)
;10 Invalid parameter		   [no corresponding parse ret code]
;11 Invalid parameter combination  [no corresponding parse ret code]
;;
;:class A			 ;system messages
;:use 1 COMMON1 	 ;MSG 1 is always "Incorrect DOS version"
;
;:def 2 "Directory PATH listing for Volume %1",CR,LF  ;define message
;:def 3 "Directory PATH listing",CR,LF
;:def 4 "No sub-directories exist",CR,LF,LF
;:use 5 COMMON25	 ;"Invalid path"
;:use 6 COMMON36	 ;"Volume Serial Number is %1-%2",CR,LF
;:def 7 "Ã³"            ;"elbo","dash","tee","bar"
;;	 1. NONE OF THE FOUR CAN BE BLANK
;;	 2. EACH OF THE FOUR MUST BE UNIQUE
;;	 3. EACH CHAR MUST BE A SINGLE BYTE (NO DBCS)
;:end
	IF1			   ;AN000;
            ;%out    COMPONENT=TREE, MODULE=TREEMS.INC...;AN000;
	ENDIF			   ;AN000;
PAD_0	EQU    "0"                 ;AN001;NUMERIC PAD CHARACTER

SUBLIST_PARSE  SUBLIST <,,FILL_OFF,FILL_SEG,PC_ID_0,SF_BITS <SF_LEFT,,SF_ASCIIZ,SF_CHAR>,MAX_0,MIN_1,PAD_BLK> ;AN004;
	PUBLIC SUBLIST_PARSE	   ;AN004;

;		THE NEXT GROUP ARE ADDITIONAL CLASS "A" MESSAGES
;		SPECIFICALLY DEFINED FOR THE TREE UTILITY

MSGNUM_VOL     MSG_DESC <2,,SUBLIST_VOL,ONE_SUBS> ;AN000;"Directory PATH listing for Volume %1"
	PUBLIC MSGNUM_VOL	   ;AN000;

	EXTRN Current_DTA_Filename:BYTE    ;AN000;ASCIIZ OF VOLUME LABEL STRING
SUBLIST_VOL    SUBLIST <,,Current_DTA_Filename,FILL_SEG,PC_ID_1,SF_BITS <SF_LEFT,,SF_ASCIIZ,SF_CHAR>,MAX_0,MIN_1,PAD_BLK> ;AN000;
	PUBLIC SUBLIST_VOL	   ;AN000;
; = = = = = = = = = = = = = = = =
MSGNUM_LIST    MSG_DESC <3>	   ;AN000;"Directory PATH listing"
	PUBLIC MSGNUM_LIST	   ;AN000;
; = = = = = = = = = = = = = = = =
MSGNUM_NOSUB   MSG_DESC <4>	   ;AN000;"No sub-directories exist"
	PUBLIC MSGNUM_NOSUB	   ;AN000;
; = = = = = = = = = = = = = = = =
MSGNUM_INVPATH MSG_DESC <5,STDERR,SUBLIST_INVPATH,ONE_SUBS> ;AC014;"Invalid path"
	PUBLIC MSGNUM_INVPATH	   ;AN000;

	EXTRN START_PATH:BYTE	   ;AN014;
SUBLIST_INVPATH SUBLIST <,,START_PATH,FILL_SEG,PC_ID_0,SF_BITS <SF_LEFT,,SF_ASCIIZ,SF_CHAR>,MAX_0,MIN_1,PAD_BLK> ;AN014;
	PUBLIC SUBLIST_INVPATH
; = = = = = = = = = = = = = = = =
MSGNUM_SERNO   MSG_DESC <6,,SUBLIST_6A,TWO_SUBS> ;AN001;"Volume Serial Number is %1-%2",CR,LF
	PUBLIC MSGNUM_SERNO	   ;AN001;
SUBLIST_6A     SUBLIST <,,FILL_OFF,FILL_SEG,PC_ID_1,SF_BITS<SF_RIGHT,,SF_WORD,SF_UN_BH>,DWORD,DWORD,PAD_0> ;AN001;
SUBLIST_6B     SUBLIST <,,FILL_OFF,FILL_SEG,PC_ID_2,SF_BITS<SF_RIGHT,,SF_WORD,SF_UN_BH>,DWORD,DWORD,PAD_0> ;AN001;
	       PUBLIC SUBLIST_6A,SUBLIST_6B ;AN001;
; = = = = = = = = = = = = = = = =
;NOTE: THERE IS NO "MSG_DESC" FOR MESSAGE 7, SINCE THIS IS NEVER DISPLAYED
;AS A MESSAGE, BUT IS REFERENCED ONLY BY SYSGETMSG.
; = = = = = = = = = = = = = = = =

MSG_OPTIONS_FIRST	equ	300	; first line of options msg
MSG_OPTIONS_LAST        equ     303     ;  and last

MSGNUM_OPTIONS MSG_DESC <MSG_OPTIONS_FIRST, STDOUT>
	PUBLIC MSGNUM_OPTIONS, MSG_OPTIONS_FIRST, MSG_OPTIONS_LAST
; = = = = = = = = = = = = = = = =
;END OF TREEMS.INC

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\tree\tree.asm ===
PAGE    90,132                  ;AN000
	TITLE   TREE.SAL - DISPLAY THE SUBDIRECTORY TREE ;AN000;
LISTPARM =      1                       ;AN000;0=SUPPRESS LIST; 1=ALLOW LIST

;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

;       .XLIST
;****************** START OF SPECIFICATIONS *****************************
; MODULE NAME: TREE

; DESCRIPTIVE NAME: Tree structure of subdirectories is displayed.

; FUNCTION: Displays to standard output a graphic representation
;           of the subdirectory tree structure, beginning
;           with the specified subdirectory, and optionally
;           displaying all filenames in that tree.

; ENTRY POINT: START

; INPUT: (DOS COMMAND LINE PARAMETERS)

;             [d:][path] TREE [D:][path] [/F] [/A]

;        WHERE
;             [d:][path] - Path where the TREE command resides.

;             [D:][path] - Display of subdirectories starts with this
;                          specified subdirectory.  If this is not
;                          specified, the default is the drive root directory.

;             [/F]       - This requests the files in each subdirectory
;                          in addition to the subdirectories themselves
;                          are to be listed.

;             [/A]       - This requests use of alternate graphic chars

; EXIT-NORMAL:  ERRORLEVEL 0 - Normal completion

; EXIT-ERROR:   ERRORLEVEL 1 - I/O error

;               ERRORLEVEL 2 - Incorrect DOS version

;               ERRORLEVEL 3 - Control Break termination

; EFFECTS: The result is a display of the Tree of subdirectories.
;          No changes are made to the system, to the current subdirectory,
;          nor to the current DOS default drive.

;                   1. NO FILES, JUST SUBDIRECTORIES

;                D:\ROOT
;                SUBDIR1
;                SUBDIR2
;                   SUBDIR21
;                   SUBDIR22
;                SUBDIR3
;                    SUBDIR31
;                    SUBDIR32

;                   2. FILES AND SUBDIRECTORIES

;                D:\ROOT
;                   MAINFIL1
;                   MAINFIL2
;                
;                SUBDIR1
;                       FILE1
;                       FILE2
;                
;                SUBDIR2
;                      FILE2A
;                      FILE2B
;                   
;                   SUBDIR21
;                          FILEA
;                          FILEB
;                   
;                   SUBDIR22
;                           FILEC
;                           FILED
;                           FILEF
;                
;                SUBDIR3
;                    SUBDIR31
;                    SUBDIR32
;                            FILE32A
;                            FILE32B

; INCLUDED FILES: TREEQU.INC - EQUATES
;                 PATHMAC.INC - PATHGEN MACRO

; INTERNAL REFERENCES:
;    ROUTINES:

;     BEGIN - VERSION CHECK, SYSMSG INIT, EXIT TO DOS
;     DEFINE_GRAPHICS - GET GRAPHIC CHARS FROM MSG
;     PARSE - TOKENIZE THE DOS COMMAND LINE PARMS
;     VERIFY_DRIVE - CHECK IF USER DRIVE ID IS OK
;     INIT_CONDITIONS - GET INITIAL SUBDIR, APPEND,CTL_BREAK
;     GET_VOL_LABEL - GET VOLUME LABEL ON SPECIFIED DRIVE
;     VOLSER - DISPLAY VOLUME SERIAL NUMBER, IF ANY AN001
;     LEN_ASCIIZ - GET LENGTH OF ASCIIZ STRING
;     EXECUTE - LOOK THRU DIRECTORY LIST FOR SUBDIRS
;     ANY_MORE_SUBDIR - LOOK AHEAD,SEE IF MORE SUBDIR
;     FIND_TYPE_NORMAL - PROCESS NORMAL, NON-DIR, FILES
;     FIND_TYPE_DIR - PROCESS THE DIRECTORY
;     NEXT_LEVEL - SET UP TO LOOK AT LOWER LEVEL SUBDIR
;     BEGIN_FIND - DO FIND FIRST FILE
;     FIND_NEXT - LOOK FOR NEXT ENTRY IN DIRECTORY
;     SHOW_FN - DISPLAY THE FILENAME FOUND
;     FLN_TO_BUF - MOVE FILENAME TO BUFFER
;     GRAF_TO_BUF - SELECT LEADING GRAPHIC CHAR FOR BUF
;     BLANK_DASH - PUT BLANKS OR DASHES BEFORE FILENAME
;     FIX_GRAF - CHANGE CURRENT GRAPHIC FOR NEXT LINE
;     ANY_SUBDIRS - DISPLAY MSG IF NO SUBDIRS PRINTED
;     DO_WRITE - SEND STRING TO STDOUT
;     IF_NOMOREFILES - ASK EXTENDED ERROR FOR WHY IS ERROR
;     GET_EXTERR - CALL EXTENDED ERROR
;     SENDMSG - PASS IN REGS DATA FROM MSG DESCRIPTOR TO DISP MSG
;     BREAK_HANDLER - CONTROL BREAK VECTOR POINTS HERE
;     RESTORE - RETURN TO INITIAL DOS DEFAULT DRIVE
;     MYERRORHANDLER - SERVICE CRITICAL ERROR HANDLER
;     CHK_DBCS -SEE IF SPECIFIED BYTE IS A DBCS LEAD BYTE

;    DATA AREAS:
;       PSP - Contains the DOS command line parameters.
;       STACK - Dynamic allocation of workareas.

; EXTERNAL REFERENCES:
;    ROUTINES:
;       SYSDISPMSG (FAR)  - MESSAGE DISPLAY ROUTINE
;       SYSLOADMSG (FAR)  - SYSTEM MESSAGE LOADER
;       PARSER     (NEAR) - INTERROGATE DOS COMMAND LINE PARMS

;    DATA AREAS:
;       DTA - defined by the DOS FINDFIRST function.

; NOTES:
;        This module should be processed with the SALUT pre-processor
;        with the re-alignment not requested, as:

;               SALUT TREE,NUL

;        To assemble these modules, the sequential or alphabetical
;        ordering of segments may be used.

;        Sample LINK command:

; LINK @TREE.ARF

; Where the TREE.ARF is defined as:
;              TREE+
;              TREEPAR+
;              TREESYSP+
;              TREESYSM
;              TREE

;        These modules should be linked in this order.  The load module is
;        a COM file.  It should be converted via EXE2BIN to a .COM file.

; REVISION HISTORY: A000 Version 4.00: add PARSER, System Message Handler,
;                   Display graphically the subdirectories and their files.
;                   A001 DCR 27, display vol serial number, if present.
;                   A002 Add support for /A switch for alternate graphics.
;                   A003 PTM 471 Avoid duplicate switches
;                   A004 PTM 537 Display parm in error
;                   A005 PTM 692 Remove period from vol label field
;                   A006 PTR1044 Append interface change
;                   A007 PTM1082 Critical error handler
;                   A008 PTM1199 DEFAULT DIR OF TARGET ALTERED
;                   A009 PTM1416 INT24 CLOBBERED USER'S RESPONSE
;                   A010 PTM1406 GET MEDIA ID WITH 69H, NOT IOCTL
;                   A011 PTM1821 COPYRIGH.INC moved to within msgserv.asm
;                   A012 PTM2352 DBCS ENABLING, CHECKING FOR "\"
;                   A013 PTM3512 PATHGEN
;                   A014 PTM3560 INVALID PATH DOES NOT DISPLAY PATHNAME
;

;****************** END OF SPECIFICATIONS *****************************
	IF1                             ;AN000;
	    ;%out    COMPONENT=TREE, MODULE=TREE.SAL... ;AN000;
	ENDIF                           ;AN000;
	HEADER  <MACRO DEFINITIONS>     ;AN000;
	INCLUDE PATHMAC.INC             ;AN013;
	include cpmfcb.inc              ; leaf
; =  =  =  =  =  =  =  =  =  =  =  =
FIXLIST MACRO   LP,DOIT                 ;;AN000;
	IF      LP                      ;;AN000;
	    DOIT                        ;;AN000;
	ENDIF                           ;;AN000;
	ENDM                            ;;AN000;
; =  =  =  =  =  =  =  =  =  =  =  =
HEADER  MACRO   TEXT                    ;;AN000;
	FIXLIST LISTPARM,.XLIST         ;;AN000;
	SUBTTL  TEXT                    ;;AN000;
	FIXLIST LISTPARM,.LIST          ;;AN000;
	PAGE                            ;;AN000;
	ENDM                            ;;AN000;
; =  =  =  =  =  =  =  =  =  =  =  =
;                                  $SALUT (0,36,41,52) ;AN000;
DOSCALL                            MACRO FN,SF     ;;AN000;
				   IFNB <FN>       ;;AN000;ARE THERE ANY PARMS AT ALL?
				   IFNB <SF>       ;;AN000;
				   MOV  AX,(FN SHL 8)+SF ;;AN000;AH=FN;AH=SF
				   ELSE            ;;AN000;SINCE THERE IS NO SUB FUNC
				   MOV  AH,FN      ;;AN000;
				   ENDIF           ;;AN000;
				   ENDIF           ;;AN000;
				   INT  21H        ;;AN000;
				   ENDM            ;;AN000;

	     HEADER <EQUATES - DOS FUNCTION CALLS> ;AN000;
	     INCLUDE TREEQU.INC    ;AN000;EQUATES, CONTROL BLOCKS

; =  =  =  =  =  =  =  =  =  =  =  =

;
; Set F_Carry based on current carry value in flags register.
; Leave carry in flags register unchanged.
;
Set_F_Carry MACRO
   LOCAL C_High, C_Low, SFC_Exit

   jc   C_High

C_Low:
   and  Flags, NOT F_Carry
   clc
   jmp  short SFC_Exit

C_High:
   or   Flags, F_Carry
   stc

SFC_Exit:

ENDM

; =  =  =  =  =  =  =  =  =  =  =  =

Copy_DTA MACRO Source_DTA, Dest_DTA

  mov  si, offset Source_DTA
  mov  di, offset Dest_DTA
  mov  cx, DTA_Length
  rep  movsb

ENDM

; =  =  =  =  =  =  =  =  =  =  =  =

;
; Copy all information (which isn't already there) pertinent to the current
; directory level from global variables on to the stack frame.
;
Push_Frame MACRO

  ; We don't need to copy Fram_Char or Fram_Curr_Path since we have already
  ; been using them on the stack.

  ; Copy Next_DTA on to stack.
  mov  si, offset Next_DTA
  mov  di, bp
  add  di, Fram_Next_DTA
  mov  cx, DTA_Length
  rep  movsb

  ; Copy Flags.
  mov  al, Flags
  mov  [bp].Fram_Flags, al

ENDM

; =  =  =  =  =  =  =  =  =  =  =  =

;
; Copy all information (which isn't already there) pertinent to the previous
; directory level from the stack frame into global variables.
;
Pop_Frame MACRO

  ; Copy Next_DTA off stack.
  mov  si, bp
  add  si, Fram_Next_DTA
  mov  di, offset Next_DTA
  mov  cx, DTA_Length
  rep  movsb

  ; Copy Flags.
  mov  al, [bp].Fram_Flags
  mov  Flags, al

ENDM

; =  =  =  =  =  =  =  =  =  =  =  =

LISTPARM     =    1                ;AN000;PERMIT LISTING
.LIST                              ;AN000;
	     HEADER <STATIC DATA AREA> ;AN000;


CSEG         SEGMENT PARA PUBLIC 'CODE' ;AN000;


	     ASSUME CS:CSEG,DS:CSEG,ES:CSEG,SS:CSEG ;AN000;AS SET BY DOS LOADER

; =  =  =  =  =  =  =  =  =  =  =  =
; $SALUT (4,3,8,36)                ;AN000;
  EXTRN SUBLIST_PARSE:WORD         ;AN004;PARSE ERROR XX - %0

  EXTRN MSGNUM_VOL:WORD            ;AN000;"Directory PATH listing for Volume %1"
  EXTRN SUBLIST_VOL:WORD           ;AN000;SUBLIST TO VOL LABEL IN Current_DTA_Filename

  EXTRN MSGNUM_LIST:WORD           ;AN000;"Directory PATH listing"

  EXTRN MSGNUM_INVPATH:WORD        ;AN000;"INVALID PATH"
  EXTRN SUBLIST_INVPATH:WORD       ;AN014;THE ASCIIZ PATH CONSIDERED INVALID

  EXTRN MSGNUM_EXTERR:WORD         ;AN000;ALL EXTENDED ERRORS
  EXTRN MSGNUM_NOSUB:WORD          ;AN000;"No subdirectories exists"

  EXTRN MSGNUM_SERNO:WORD          ;AN001;"Volume Serial Number is %1-%2"
  EXTRN SUBLIST_6A:WORD            ;AN001;FIRST PART OF SERIAL NUMBER
  EXTRN SUBLIST_6B:WORD            ;AN001;SECOND PART OF SERIAL NUMBER

  EXTRN CURRENT_PARM:WORD          ;AN000;POINT TO NEXT PARM TO PARSE
  EXTRN ORDINAL:WORD               ;AN000;NUMBER OF CURRENT PARM
  EXTRN LAST_BYTE:BYTE             ;AN000;TAG AT END OF USED MEMORY, BEFORE STACK

  EXTRN SYSDISPMSG:NEAR            ;AN000;MESSAGE DISPLAY ROUTINE
  EXTRN SYSLOADMSG:NEAR            ;AN000;SYSTEM MESSAGE LOADER
  EXTRN SYSGETMSG:NEAR             ;AN002;SYSTEM MESSAGE LOCATER ROUTINE
  EXTRN PARSER:NEAR                ;AN000;INTERROGATE DOS COMMAND LINE PARMS
; =  =  =  =  =  =  =  =  =  =  =  =
;            $SALUT (0,14,19,36)   ;AN000;

	     ORG  80H              ;AN000;

	     PUBLIC COMMAND        ;AN000;
COMMAND      DB   128 DUP (?)      ;AN000;DOS INPUT COMMAND LINE
; =  =  =  =  =  =  =  =  =  =  =  =

	     ORG  100H             ;AN000;REQUIRED LOCATION OF ENTRY POINT

START:

IFDEF MAKE_EXE
;
; .EXE stub to turn .COM into .EXE for debugging.
;

	      ; duplicate PSP at start of CS for .EXE
	      mov  first_ax, ax
	      mov  ax, cs
	      mov  es, ax
	      xor  si, si
	      xor  di, di
	      mov  cx, 100h
	      cld
	      rep  movsb

	      ; set up data segment and stack just like .COM
	      mov  ds, ax
	      mov  ss, ax
	      mov  sp, 0fffeh

	      ; restore original ax
	      mov  ax, first_ax
ENDIF

	      JMP  BEGIN           ;AN000;DOS ENTRY POINT

IFDEF MAKE_EXE
	 first_ax dw ?
ENDIF


; =  =  =  =  =  =  =  =  =  =  =  =
;THERE ARE TWO SETS OF DEFINITIONS OF THE GRAPHIC CHARACTERS USED IN THE DISPLAY.
;THE FIRST SET LOOKS THE BEST, BUT ON SOME PRINTERS IS A TEDIOUS, SLOW PROCESS.
;THERE ARE SOME CODEPAGES THAT DO NOT HAVE THESE SAME GRAPHIC CHARACTERS IN
;THESE CORRESPONDING CODE POINT POSITIONS.  JAPAN HAS ITS KATAKANA CHARACTER
;SET WHERE THESE GRAPHICS ARE DEFINED, AND WOULD THUS NOT WANT TO USE THIS
;FIRST GRAPHIC CHARACTERS SET.  THE SECOND SET OF EQUATES DEFINE ALTERNATE
;CHARACTERS THAT, ALTHOUGH THE OUTPUT DOES NOT LOOK AS GOOD, AT LEAST WILL
;PRINT NORMALLY, AND DOES USE THE TRADITIONAL ASCII LOWER 128 AS ITS CODE
;POINTS, THUS WOULD BE AVAILABLE FOR THOSE OTHER CODEPAGES, LIKE JAPAN'S.

;IF IT BECOMES DESIRABLE TO GENERATE YET ANOTHER DEFINITION OF THESE CHARACTERS,
;THE REQUIREMENTS ARE:
;       1. NONE OF THE FOUR CAN BE BLANK
;       2. EACH OF THE FOUR MUST BE UNIQUE
;       3. EACH CHAR MUST BE A SINGLE BYTE (NO DBCS)

;               GRAPHIC CHARACTERS
;THIS SET OF GRAPHIC CHARACTERS ARE ACTUALLY DEFINED BY THE MESSAGE 7,
;WHERE TRANSLATORS HAVE PROVIDED THE CHARACTERS COMPATABLE WITH THEIR
;NATIONAL CHARACTER CODEPAGE SET.

INCLUDE version.inc

IFNDEF TAIWAN
GRAF_TABLE   LABEL BYTE            ;AN002;DEFINITION OF FOUR GRAPHIC CHARACTERS
	     PUBLIC GRAF_TABLE     ;AN002;
ifndef JAPAN

Graf_Elbow    DB   ""             ;AN000;192 DECIMAL ASCII VAL
GRAF_DASH    DB   ""              ;AN000;196 DECIMAL ASCII VALUE
GRAF_TEE     DB   ""              ;AN000;195 DECIMAL ASCII VALUE
GRAF_BAR     DB   ""              ;AN000;179 DECIMAL ASCII VALUE

else                            ; if JAPAN

Graf_Elbow    DB   1
GRAF_DASH    DB   2
GRAF_TEE     DB   3
GRAF_BAR     DB   4

endif


;               ALTERNATE SET OF GRAPHIC CHARACTERS
;IF THE "/A" SWITCH IS SPECIFIED, THIS SET OF FOUR CHARACTERS WILL
;OVERLAY THE ABOVE SET OF GRAPHIC CHARACTERS.

GRAF_TABLE_ALT LABEL BYTE          ;AN002;ALTERNATE SET OF GRAPHIC CHARACTERS
	     PUBLIC GRAF_TABLE_ALT ;AN002;
ifndef JAPAN
A_Graf_Elbow  DB   "\"             ;AN000;
A_GRAF_DASH  DB   "-"              ;AN000;
A_GRAF_TEE   DB   "+"              ;AN000;
A_GRAF_BAR   DB   "|"              ;AN000;

else                            ; if JAPAN

A_Graf_Elbow  DB   "+"
A_GRAF_DASH  DB   "-"
A_GRAF_TEE   DB   "|"
A_GRAF_BAR   DB   "|"
endif

  ELSE                          ; if TAIWAN

GRAF_TABLE   LABEL BYTE            ;AN002;DEFINITION OF FOUR GRAPHIC CHARACTERS
	     PUBLIC GRAF_TABLE     ;AN002;
Graf_Elbow  DB  "\"              ;AN000;
GRAF_DASH  DB   "-"              ;AN000;
GRAF_TEE   DB   "+"              ;AN000;
GRAF_BAR   DB   "|"              ;AN000;

;               ALTERNATE SET OF GRAPHIC CHARACTERS
;IF THE "/A" SWITCH IS SPECIFIED, THIS SET OF FOUR CHARACTERS WILL
;OVERLAY THE ABOVE SET OF GRAPHIC CHARACTERS.

GRAF_TABLE_ALT LABEL BYTE          ;AN002;ALTERNATE SET OF GRAPHIC CHARACTERS
	     PUBLIC GRAF_TABLE_ALT ;AN002;
A_Graf_Elbow    DB   ""             ;AN000;192 DECIMAL ASCII VAL
A_GRAF_DASH    DB   ""              ;AN000;196 DECIMAL ASCII VALUE
A_GRAF_TEE     DB   ""              ;AN000;195 DECIMAL ASCII VALUE
A_GRAF_BAR     DB   ""              ;AN000;179 DECIMAL ASCII VALUE
ENDIF

; =  =  =  =  =  =  =  =  =  =  =  =
FLAGS        db   0                ;AN000;INITIALIZE ALL FLAGS TO "FALSE"
	     PUBLIC FLAGS,F_SWITCH ;AN000;ADD ENTRIES IN LINK MAP
F_DEF_PAT_TAR EQU 40H              ;AN008;IF ON, DEFAULT SUBDIR OF TARGET DRIVE IS KNOWN
				   ;IF OFF, DEF SUBDIR OF TARGET NOT KNOWN     ;AN008;
F_SUBDIR     EQU  20H              ;AN000;IF ON, A SUBDIR HAS BEEN DISPLAYED
				   ;IF OFF, A SUBDIR HAS NOT YET BEED DISPLAYED
F_FAILING    EQU  10H              ;AN000;IF ON, DO NOT RESTORE SUBDIR ON FAILING DRIVE
				   ;IF OFF, DO RESTORE SUBDIR ON TARGET DRIVE   ;AN000;
F_FLN       EQU  08H               ;AN000;IF ON, A FILENAME HAS BEEN DISPLAYED
				   ;IF OFF, NO FILNAME FOR THIS SUBDIR YET
F_SWITCH     EQU  02H              ;AN000;IF ON, THE /F SPECIFIED
				   ;IF OFF, THEN /F NOT SPECIFIED
F_APPEND     EQU  01H              ;AC006;IF ON, DOS APPEND IS IN THE MULTIPLEXOR
				   ;IF OFF, DOS APPEND IS NOT THE MULTIPLEXOR

F_Carry      equ  80h         ; 0 ==> last DOSCall FindNext didn't set carry
			      ; 1 ==> last DOSCall FindNext did set carry

APPEND_FLAGS DW   0                ;AN006;RECORDS ORIGINAL STATE OF APPEND
				   ;8000H = /X:1
				   ;4000H = /E
				   ;2000H = /PATH:1
				   ;1000H = /DRIVE:1
				   ;0001H = ENABLE APPEND

DBCSENV      DD   0                ;AN000;POINTER TO DBCS RANGES
ORIG_AX      DW   0                ;AN000;DRIVE VERIFICATION FROM DOS AT ENTRY
CURRENT_COL  DW   1                ;AN000;IN BUF, WHERE IS ELBO/TEE?
				   ; INITIALLY SET TO START IN COLUMN ONE
MEDIA_ID_BUF A_MEDIA_ID_INFO <>    ;AN001;AREA TO READ VOL SERIAL NUMBER WITH GET_MEDIA_ID
BUF          DB   ((DASH_NUM+1)*LEVEL_LIMIT+2) DUP(0) ;AN000;HAS ELBO,TEE,DASH,NUL ENDED
JUSTIN_CASE  DB   64 DUP(0)        ;AN000;CATCHES THE OVERFLOW
EXITFL       DB   EXOK             ;AN000;RETURN CODE, INITIALLY "NORMAL"
;          (SEE INCLUDED FILE OF EQUATES FOR DEFINITIONS OF VALUES)

;               REMEMBER THE DOS DEFAULT DRIVE AND SUBDIRECTORY
DEFAULT_DR   DB   ?                ;AN000;ALPHA LETTER OF DOS DEFAULT DRIVE
START_DR_NUM DB   ?                ;AN000;NUMERIC VALUE OF DOS DEFAULT DRIVE
				   ; WHERE 0=A:, 1=B:, ETC...
DEFAULT_PATH DB   BACK_SLASH       ;AN000;FIRST BYTE OF PATH IS BACKSLASH
	     DB   MAX_PATH DUP(0)  ;AN000;ORIGINAL DEFAULT PATH
JUSTIN_CASE2 DB   64 DUP(0)        ;AN000;CATCHES THE OVERFLOW
OLDINT23     DD   ?                ;AN000;ORIGINAL CONTENTS OF CTRL-BREAK VECTOR
OLDINT24     DD   ?                ;AN000;ORIGINAL CONTENTS OF CRITICAL ERROR VECTOR

QUESTION_MARK   EQU   03FH
PATH_LEN        EQU   11

;
; Current_DTA and Next_DTA are used in a single lookahead scheme for DOS
; FindFirst / FindNext calls.  This method eliminates an extra level of
; search which would otherwise be needed to set the leading graphics
; character before a file or directory name.  We also avoid re-using old
; "snapshots" of DTAs which often fail on network servers with limited
; resources.
;
; The filename from Current_DTA has always been printed before descending to
; a subdirectory, so the search position in a directory may be maintained by
; only keeping a copy of Next_DTA.
;
Current_DTA  DB   21 DUP(?)        ;AN000;RESERVED FOR FIND NEXT CALLS
TREE_FCB     EQU  Current_DTA + 7  ; this space will be used for FCB calls also
Current_DTA_Attr DB   ?            ;AN000;ATTRIBUTE
DTA_Attr_Offset  equ Current_DTA_Attr - Current_DTA
Current_DTA_Time DW   ?            ;AN000;TIME
Current_DTA_Date DW   ?            ;AN000;DATE
Current_DTA_LSize DW   ?                   ;AN000;LOW WORD OF FILE SIZE
Current_DTA_HSize DW   ?                   ;AN000;HIGH WORD OF FILE SIZE
DTA_Filename_Offset  equ Current_DTA_Filename - Current_DTA
Current_DTA_Filename DB   13 DUP(?)        ;AN000;FILENAME, WITH PERIOD, +0 BYTE
	     PUBLIC Current_DTA_Filename   ;AN000;USED TO DISPLAY VOLUME LABEL
EXTRA_SPACE  DB   20               ;leaf; want to use the DTA as space for an
; fcb, since the volume label will be found via fcb-based FindFirst, and i
; was concerned that the dta as defined above wasn't large enough


Next_DTA  DB   21 DUP(?)           ;AN000;RESERVED FOR FIND NEXT CALLS
Next_DTA_Attr DB   ?               ;AN000;ATTRIBUTE
Next_DTA_Time DW   ?               ;AN000;TIME
Next_DTA_Date DW   ?               ;AN000;DATE
Next_DTA_LSize DW   ?              ;AN000;LOW WORD OF FILE SIZE
Next_DTA_HSize DW   ?              ;AN000;HIGH WORD OF FILE SIZE
Next_DTA_Filename DB   13 DUP(?)           ;AN000;FILENAME, WITH PERIOD, +0 BYTE


;
; File_DTA is used to search the current directory for files.
;
File_DTA  DB   21 DUP(?)           ;AN000;RESERVED FOR FIND NEXT CALLS
File_DTA_Attr DB   ?               ;AN000;ATTRIBUTE
File_DTA_Time DW   ?               ;AN000;TIME
File_DTA_Date DW   ?               ;AN000;DATE
File_DTA_LSize DW   ?              ;AN000;LOW WORD OF FILE SIZE
File_DTA_HSize DW   ?              ;AN000;HIGH WORD OF FILE SIZE
File_DTA_Filename DB   13 DUP(?)           ;AN000;FILENAME, WITH PERIOD, +0 BYTE


EXTENDED_FCB    EQU     0FFH       ; leaf
FCB_FINDFIRST   EQU     11H         ; leaf

CRLF         db   CR, LF
LEN_CRLF     equ  $ - CRLF
Star_Star    DB   "*.*",0          ;AN000;UNIVERSAL FILENAME, +0
Star_Star_L  EQU  $-Star_Star      ;AN000;LENGTH OF UNIVERSAL FILENAME, INCL NUL
SAVEFILN     DB   13 DUP(?)        ;AN000;COPY OF Current_DTA_Filename, ABOVE
;        THIS NEXT SET OF WORKSPACE DEFINES THE PATH BEING PROCESSED.
;        THESE ITEMS MUST REMAIN TOGETHER, IN THIS ORDER:
START_DRIVE  DB   0,":"            ;AN000;DRIVE LETTER NEEDS TO BE FILLED IN HERE
	     PUBLIC START_DRIVE,START_PATH ;AN000;
START_PATH   DB   PERIOD           ;AN000;AREA TO RECEIVE STARTING PATH ASCIIZ
	     DB   (MAX_PATH+SIZE Current_DTA_Filename) DUP(0) ;AN000;
JUSTIN_CASE3 DB   64 DUP(0)        ;AN000;CATCHES THE OVERFLOW
;       END OF CONTIGUOUS WORKSPACE DEFINING PATH
; =  =  =  =  =  =  =  =  =  =  =  =



	     PATHLABL TREE         ;AN013;
	     HEADER <BEGIN - VERSION CHECK, SYSMSG INIT, EXIT TO DOS> ;AN000;
; $SALUT (4,3,8,36)                ;AN000;



BEGIN PROC NEAR                    ;AN000;
  PUBLIC BEGIN                     ;AN000;
;INPUT - DOS COMMAND LINE PARMS, AS DEFINED IN MODULE PROLOG.
;         CONTROL IS PASSED HERE FROM "START" AT ORG 100H.
;        AX IS SET BY DOS TO FLAG ANY INVALID DRIVE SPECIFIED ON PARMS.
;OUTPUT - "EXITFL" HAS ERRORLEVEL RETURN CODE
; =  =  =  =  =  =  =  =  =  =  =  =

  MOV  ORIG_AX,AX                  ;AN000;SAVE ORIGINAL VALUE OF AX

;SINCE THIS IS A .COM STYLE UTILITY, THE SEG ID IN THE MSG SUBLIST
;CANNOT BE SET BY THE LOADER, BUT MUST BE SET HERE, AT RUN TIME.

  MOV  SUBLIST_VOL.SUB_VALUE_SEG,CS ;AN000;MAKE SUBLIST VARIABLE ADDRESSABLE
  MOV  SUBLIST_6A.SUB_VALUE_SEG,CS ;AN001;
  MOV  SUBLIST_6B.SUB_VALUE_SEG,CS ;AN001;
  MOV  SUBLIST_PARSE.SUB_VALUE_SEG,CS ;AN004;
  MOV  SUBLIST_INVPATH.SUB_VALUE_SEG,CS ;AN014;

  CALL SYSLOADMSG                  ;AN000; INIT SYSMSG HANDLER

; $IF  C                           ;AN000; IF THERE WAS A PROBLEM
  JNC $$IF1
      CALL SYSDISPMSG              ;AN000; LET HIM SAY WHY HE HAD A PROBLEM

      MOV  EXITFL,EXVER            ;AN000; TELL ERRORLEVEL BAD DOS VERSION
; $ELSE                            ;AN000; SINCE SYSDISPMSG IS HAPPY
  JMP SHORT $$EN1
$$IF1:
      CLD                          ;AN000;CLEAR DIRECTION FLAG TO AUTO-INCREMENT

;               GET CURRENT DRIVE ID
      DOSCALL CURRDISK             ;AN000;(19H) SET AL=0 IF A:, 1 IF B:, ETC...

      MOV  START_DR_NUM,AL         ;AN000;SAVE NUMERIC VALUE OF DOS DEFAULT DRIVE
      ADD  AL,DRIVEA               ;AN000;CONVERT DRIVE NUMBER TO LETTER
      MOV  DEFAULT_DR,AL           ;AN000;REMEMBER ALPHA OF DEFAULT DRIVE
				   ; OF FILENAME TO BE SEARCHED FOR
;                   RECORD THE INITIAL SET UP
      CALL INIT_CONDITIONS         ;AC007;SET DTA,APPEND STATUS,CAPTURE CTL-BREAK VEC

ifndef JAPAN
      CALL DEFINE_GRAPHICS         ;AN002;GET PROPER GRAPHIC CHARS FROM MSG
endif

      CALL PARSE                   ;AN000;LOOK AT DOS COMMAND LINE PARAMETERS,
				   ; AND DISPLAY ERR MSG IF BAD
;     $IF  NC                      ;AN000;PARMS ARE OK?
      JC $$IF3
;           CURIOUS ODDITY:
;           "CURRDISK"    AL=0 DRIVE A:,      AL=1 DRIVE B: ETC...
;           "GET_CUR_DIR" AL=0 DEFAULT DRIVE, AL=1 DRIVE A: ETC...
;           "SELECT_DISK" AL=0 DRIVE A:,      AL=1 DRIVE B: ETC...
;           SO... THE NUMBER WE HAVE HERE AGREES WITH "SELECT_DISK", BUT
;           WE MUST ADD ONE WHEN WE DO THE "GET_CUR_DIR".

;               GET CURRENT DIRECTORY OF TARGET DRIVE
				   ;DS:SI = POINTER TO 64 BYTE USER AREA
				   ;DL = DRIVE NUM (0=DEF, 1=A, ETC)
				   ;OUTPUT: DS:SI POINTS TO FULL PATH NAME
; "DEFAULT_PATH" WILL HAVE THE DOS DEFAULT SUBDIRECTORY PATH.

	  MOV  SI,OFFSET DEFAULT_PATH+1 ;AN000;PASS 64 BYTE AREA
	  MOV  DL,START_DRIVE      ;AN000;PASS NUMERIC VALUE
	  SUB  DL,DRIVEA           ;AN000;  OF DRIVE TO BE SCANNED
	  INC  DL                  ;AN000;SEE "CURIOUS ODDITY" ABOVE...
	  DOSCALL GET_CUR_DIR      ;AN000;(47H) GET THE CURRENT SDIR OF TARGET DRIVE

	  OR   FLAGS,F_DEF_PAT_TAR ;AN008;INDICATE DEFAULT PATH OF TARGET IS KNOWN


;                    DISPLAY FUNCTION HEADER
	  CALL GET_VOL_LABEL       ;AN000;GET VOLUME LABEL TO Current_DTA_Filename

;                    DISPLAY VOLUME SERIAL ID
	  CALL EXECUTE             ;AN000;DISPLAY THE SET OF SUBDIRS

	  CALL ANY_SUBDIRS         ;AN000;DISPLAY FINAL MSG IN CASE NO SUBDIRS

;     $ELSE                        ;AN000;SINCE PARMS HAD A PROBLEM,
      JMP SHORT $$EN3
$$IF3:
	  MOV  EXITFL,EXERR        ;AN000;SET ERROR RETURN CODE
;     $ENDIF                       ;AN000;PARMS OK?
$$EN3:
;                    RESTORE SYSTEM TO INITIAL CONDITIONS
      CALL RESTORE                 ;AN007;RETURN TO INITIAL DOS DEFAULT DRIVE,
				   ; THE INITIAL DEFAULT PATH,
				   ; AND THE INITIAL "APPEND" STATE.
; $ENDIF                           ;AN000;OK WITH SYSDISPMSG?
$$EN1:

  MOV  AL,EXITFL                   ;AN000;PASS BACK ERRORLEVEL RET CODE
  DOSCALL RET_CD_EXIT              ;AN000;(4CH) RETURN TO DOS WITH RET CODE

  INT  20H                         ;AN000; IF ABOVE NOT WORK, EXIT ANYWAY

;FOR CONTROL-BREAK, "TREE" WILL EXIT TO DOS AT "CTL_BREAK" PROC
; IN STEAD OF HERE.
BEGIN ENDP                         ;AN000;
; =  =  =  =  =  =  =  =  =  =  =  =



  HEADER <DEFINE_GRAPHICS - GET GRAPHIC CHARS FROM MSG> ;AN002;
DEFINE_GRAPHICS PROC NEAR          ;AN002;
  PUBLIC DEFINE_GRAPHICS           ;AN002;
;INPUT - MESSAGE 7 HAS THE FOUR GRAPIC CHARS, DEFINED BY THE TRANSLATORS
;        TO BE ACCEPTABLE TO THIS NATIONAL CODEPAGE.
;OUTPUT- THE "GRAF_TABLE" AREA IS Revised TO HAVE THE 4 GRAPHIC CHARS
;        AS DEFINED BY THE MESSAGE
; =  =  =  =  =  =  =  =  =  =  =  =
;               DEFINE THE GRAPHIC CHARACTERS
  MOV  AX,GRAPHIC_MSGNUM           ;AN002;REQUEST THE MESSAGE WITH GRAPHIC CHAR DEFS
  MOV  DH,UTILITY_MSG_CLASS        ;AN002;
  CALL SYSGETMSG                   ;AN002;ASK WHERE THOSE GRAPHIC CHARS ARE
				   ;IF ANY PROBLEM HERE, JUST LEAVE
				   ; THE GRAPHICS AS DEFINED AT ASSEMBLY TIME.
; $IF  NC                          ;AN002;IF ALL OK, DS:SI POINTS TO MESSAGE
  JC $$IF7
      LEA  DI,GRAF_TABLE           ;AN002;POINT TO WHERE GRAPHIC CHARS ARE TO GO
      LODSW                        ;AN002;GET FIRST PAIR OF CHARS
      STOSW                        ;AN002;SAVE THEM
      LODSW                        ;AN002;GET SECOND PAIR OF CHARS
      STOSW                        ;AN002;AND SAVE THEM ALSO
; $ENDIF                           ;AN002;
$$IF7:
  RET                              ;AN002;
DEFINE_GRAPHICS ENDP               ;AN002;
; =  =  =  =  =  =  =  =  =  =  =  =



  HEADER <PARSE - TOKENIZE THE DOS COMMAND LINE PARMS> ;AN000;
PARSE PROC NEAR                    ;AN000;
  PUBLIC PARSE                     ;AN000;
;INPUT - PSP HAS DOS COMMAND LINE PARAMETERS
;OUTPUT- CARRY IS SET IF THERE IS A PROBLEM
;        CARRY IS CLEAR IF PARMS ARE OK

;        IF THERE WERE ANY PARMS, THEY ARE MOVED FROM THE PSP
;          INTO THE STRING, "COMMAND", WHERE THE PARSER WILL LOOK AT THEM.

;        IF THE SWITCH "/F" WAS SPECIFIED, "F_SWITCH" IS SET TO "ON"
;        IF THE SWITCH IS NOT SPECIFIED, "F_SWITCH" IS LEFT "OFF".

;        IF THERE ARE NO PARMS, THE DEFAULTS OF CURRENT DRIVE AND CURRENT
;          SUBDIRECTORY ARE SET UP TO BE WHERE THE SUBDIR SEARCH WILL
;          START, AND THE "/F" SWITCH IS ASSUMED NOT SPECIFIED, SO
;          THE DEFAULT DISPLAY WILL SHOW SUBDIRS ONLY, NO FILES.

;        "START_DRIVE" EITHER HAS THE SPECIFIED STARTING DRIVE, OR
;               WILL HAVE THE CURRENT DOS DEFAULT DRIVE.
;        "START_PATH" EITHER WILL HAVE THE SPECIFIED STARTING PATH, OR
;               WILL HAVE THE CURRENT DEFAULT PATH
; =  =  =  =  =  =  =  =  =  =  =  =

  MOV  CURRENT_PARM,OFFSET COMMAND+1 ;AN000;SET POINT TO BEGINNING OF STRING
  MOV  ORDINAL,ZERO                ;AN000;START WITH FIRST PARM
  CALL PARSER                      ;AN000;INTERROGATE THE DOS COMMAND LINE PARMS
				   ;OUTPUT: SET CARRY IF PROBLEM
				   ;        CLEAR CARRY IF ALL OK
; $IF  NC                          ;AN000;IF ALL OK SO FAR WITH PARSER,
  JC $$IF9
      CMP  START_DRIVE,NUL         ;AN000;SEE IF START_DRIVE FILLED IN YET
;     $IF  E                       ;AN000;NO, NOT FILLED IN YET
      JNE $$IF10
	  MOV  AL,DEFAULT_DR       ;AN000;GET ALPHA LETTER OF DEFAULT DRIVE
	  MOV  START_DRIVE,AL      ;AN000;SET WHERE TO SEARCH FOR SUBDIRS
	  CLC                      ;AN000;NO ERROR SO FAR
;     $ELSE                        ;AN000;SINCE START_DRIVE WAS SPECIFIED
      JMP SHORT $$EN10
$$IF10:
	  CALL VERIFY_DRIVE        ;AN000;SEE IF USER SPECIFIED DRIVE IS OK, AND
				   ; IF SO, CHANGE DOS DEFAULT DRIVE TO IT
				   ;CARRY WILL BE SET IF ERROR

				   ;IF A NEW DRIVE WAS SPECIFIED,
				   ; DEFAULT DRIVE HAS BEEN CHANGED TO
				   ; NEW DEFAULT DRIVE, USER SPECIFIED

;     $ENDIF                       ;AN000;FILLED IN START_DRIVE YET?
$$EN10:
;     $IF  NC                      ;AN000;IF ALL OK SO FAR,
      JC $$IF13
	  CMP  START_PATH,NUL      ;AN000;SEE IF START_PATH FILLED IN YET
;         $IF  E                   ;AN000;NO, NOT FILLED IN YET,
	  JNE $$IF14
	      MOV  DI,OFFSET START_PATH ;AN000;SET WHERE TO PUT STARTING PATH
	      MOV  AL,BACK_SLASH   ;AN000;START CURRENT SUBDIR AT ROOT
	      STOSB                ;AN000;  SO START WITH BACK SLASH

				   ;DI POINTS TO BYTE AFTER BACK SLASH
				   ; JUST ADDED TO "START_PATH"

	      MOV  SI,DI           ;AN000;DS:SI = POINTER TO 64 BYTE USER AREA
	      MOV  DL,DEFDRIVE     ;AN000;DL = DRIVE NUM (0=DEF, 1=A, ETC)
	      DOSCALL GET_CUR_DIR  ;AN000;(47H) GET CURRENT DIRECTORY
				   ;OUTPUT: DS:SI POINTS TO FULL PATH NAME
;         $ENDIF                   ;AN000;START_PATH FILLED IN YET?
$$IF14:
	  CLC                      ;AN000;INDICATE NO PROBLEM WITH PARMS
;     $ENDIF                       ;AN000;ALL OK SO FAR?
$$IF13:
; $ENDIF                           ;AN000;ALL OK WITH PARSER?
$$IF9:
  RET                              ;AN000;RETURN TO CALLER
PARSE ENDP                         ;AN000;
; =  =  =  =  =  =  =  =  =  =  =  =



  HEADER <VERIFY_DRIVE - CHECK IF USER DRIVE ID IS OK> ;AN000;
VERIFY_DRIVE PROC NEAR             ;AN000;
  PUBLIC VERIFY_DRIVE              ;AN000;
;THE USER HAS SPECIFIED A DRIVE LETTER.  VERIFY IT IS A PROPER DRIVE.
;IF THE DRIVE LETTER SPECIFIED IS THE SAME AS THE DEFAULT DRIVE, IT IS OK.
;IF DIFFERENT, ADDITIONAL VERIFICATION TESTS MUST BE MADE.
;THIS TEST IS DONE BY TRYING TO CHANGE THE CURRENT DRIVE TO THE SPECIFIED
; DRIVE, THEN BY ASKING WHAT IS THE CURRENT DRIVE.  IF THE CURRENT DRIVE
; HAS CHANGED FROM WHAT IT WAS ORIGINALLY, THEN THE NEW DRIVE LETTER IS OK.
; IF IT DID NOT CHANGE, THEN IT WAS A BOGUS DRIVE LETTER AND WE QUIT.

;INPUT: "START_DRIVE" - USER SPECIFIED DRIVE LETTER TO BE TESTED
;       "DEFAULT_DR" - ORIGINAL DOS DEFAULT DRIVE
;       "START_DR_NUM" - NUMERIC EQUIVALENT OF THE ORIGINAL DOS DEFAULT DRIVE
;       "ORIG_AX" - HAS FLAGS TO VERIFY DRIVE, SET BY DOS AT LOAD TIME.
;OUTPUT: CARRY SET IF BAD, CARRY CLEAR IF OK
;       IF BAD, ERROR MESSAGE IS DISPLAYED: "INVALID DRIVE SPECIFICATION"
; =  =  =  =  =  =  =  =  =  =  =  =
  MOV  DL,START_DRIVE              ;AN000;USING THE DRIVE SPECIFIED IN PARMS,
  CMP  DL,DEFAULT_DR               ;AN000;DID PARMS SPECIFY DRIVE SAME AS DEFAULT?
; $IF  NE                          ;AN000;IF DRIVE SPECIFIED IS DIFFERENT
  JE $$IF18
      MOV  AX,ORIG_AX              ;AN000;GET DRIVE VERIFICATION FLAGS, SAVED FROM AX
      OR   AL,AH                   ;AN000;COMBINE FLAGS FOR BOTH DRIVE ID'S, IF GIVEN
;     $IF  NZ,OR                   ;AN000;IF THERE IS A PROBLEM, OR...
      JNZ $$LL19

      SUB  DL,DRIVEA               ;AN000;CONVERT DRIVE LETTER TO DRIVE NUMBER
				   ; DL=DRIVE NUMBER (0=A,1=B)
      DOSCALL SELECT_DISK          ;AN000;(0EH) SET DEFAULT DRIVE
				   ;OUTPUT: AL=NUM. OF DRIVES (MIN 5) (NOT USED);AN000;
				   ; (NOT INTERESTED...)
      DOSCALL CURRDISK             ;AN000;(19H) GET CURRENT DEFAULT DRIVE
				   ;OUTPUT: AL = CURRENT DRIVE
				   ;  0=A,1=B,ETC.
      CMP  AL,START_DR_NUM         ;AN000;HAS THE ORIGINAL DOS DEFAULT DRIVE CHANGED?
      CLC                          ;AN000;NO ERROR
;     $IF  E                       ;AN000;IF NO CHANGE, THEN USER SPECIFIED
      JNE $$IF19
$$LL19:
				   ; INVALID DRIVE
	  MOV  MSGNUM_EXTERR,INVDRSPEC ;AN000;"INVALID DRIVE SPECIFICATION"
	  MOV  DI,OFFSET MSGNUM_EXTERR ;AN000;
	  CALL SENDMSG             ;AN000;TELL USER HE SAID BAD DRIVE LETTER

	  STC                      ;AN000;RETURN AN ERROR
;     $ENDIF                       ;AN000;NO CHANGE?
$$IF19:
; $ELSE                            ;AN000;SINCE DRIVE SPECIFIED IS THE SAME
  JMP SHORT $$EN18
$$IF18:
      CLC                          ;AN000;NO ERROR
; $ENDIF                           ;AN000;NEW DRIVE SPECIFIED?
$$EN18:
  RET                              ;AN000;RETURN TO CALLER
VERIFY_DRIVE ENDP                  ;AN000;
; =  =  =  =  =  =  =  =  =  =  =  =



  HEADER <INIT_CONDITIONS - GET INITIAL SUBDIR, APPEND,CTL_BREAK> ;AN000;
INIT_CONDITIONS PROC NEAR          ;AN000;
  PUBLIC INIT_CONDITIONS           ;AN000; MAKE ENTRY IN LINK MAP
;INPUT  - "START_DR_NUM" WILL HAVE THE NUMERIC VALUE OF DOS DEFAULT DRIVE.
;       - "DEFAULT_DR" WILL HAVE THE LETTER DRIVE ID OF DOS DEFAULT DRIVE.
;OUTPUT - "APPEND_FLAGS" RECORDS ORIGINAL STATUS OF /X OF APPEND.
;               APPEND IS COMMANDED TO HALT ITS /X PROCESSING.
;         CONTROL BREAK VECTOR IS ALTERED TO POINT TO MY HANDLER.
; =  =  =  =  =  =  =  =  =  =  =  =
;               SET UP THE LOCAL DTA
  MOV  DX,OFFSET Current_DTA       ;AN000;PASS POINTER TO DTA BUFFER
  DOSCALL SET_DTA                  ;AN000;(1AH) SET DTA FOR FIND FIRST/NEXT
;               GET CURRENT APPEND STATUS
  MOV  AX,APPEND_CHECK             ;AN006;SEE IF APPEND IS ACTIVE
  INT  2FH                         ;AN006;CALL THE MULTIPLEXOR FUNCTION

  OR   AL,AL                       ;AN006;TEST THE RESULTS
; $IF  NZ,AND                      ;AN006;IF INSTALLED
  JZ $$IF23

  MOV  AX,APPEND_VERSION           ;AN006;ASK IF DOS VERSION OF APPEND
  INT  2FH                         ;AN006;CALL THE MULTIPLEXOR FUNCTION
  CMP  AX,DOS_APPEND_VER           ;AN006;IS THIS THE DOS VERSION OF APPEND
; $IF  E                           ;AN006;YES, DEAL WITH THIS VERSION
  JNE $$IF23
      OR   FLAGS,F_APPEND          ;AN000;FLAG IT AS THE DOS VERSION
      MOV  AX,GET_APPEND           ;AN000;
      INT  2FH                     ;AN000;READ STATUS OF /X FROM APPEND
				   ;OUTPUT-BX=(SEE "APPEND_FLAGS" FOR DEFINITION
      MOV  APPEND_FLAGS,BX         ;AC006;REMEMBER APPEND STATUS
; $ENDIF                           ;AN000;APPEND INSTALLED?
$$IF23:
;               CAPTURE THE CRITICAL ERROR VECTOR
  PUSH ES                          ;AN000;SAVE SEGREG
				   ;AL = INTERRUPT NUMBER
  DOSCALL GET_VECTOR,VEC_CRITERR   ;AN000;(3524H) GET INTERRUPT VECTOR
				   ;OUTPUT: ES:BX = CONTENTS OF VECTOR
  MOV  WORD PTR OLDINT24,BX        ;AN000;SAVE THE ORIGINAL
  MOV  WORD PTR OLDINT24+WORD,ES   ;AN000; CRITICAL ERROR HANDLER VECTOR
  POP  ES                          ;AN000;RESTORE SEGREG

  MOV  DX,OFFSET MYERRORHANDLER    ;AN000;DS:DX = VECTOR TO INT HANDLER
				   ;AL = INTERRUPT NUMBER
  DOSCALL SET_VECTOR,VEC_CRITERR   ;AN000;(25H) SET INTERRUPT VECTOR

;               CAPTURE THE CONTROL BREAK VECTOR
  PUSH ES                          ;AN000;SAVE SEGREG
				   ;AL = INTERRUPT NUMBER
  DOSCALL GET_VECTOR,VEC_CTLBREAK  ;AN000;(3523H) GET INTERRUPT VECTOR
				   ;OUTPUT: ES:BX = CONTENTS OF VECTOR
  MOV  WORD PTR OLDINT23,BX        ;AN000;SAVE THE ORIGINAL
  MOV  WORD PTR OLDINT23+WORD,ES   ;AN000; CTRL-BREAK VECTOR
  POP  ES                          ;AN000;RESTORE SEGREG

  MOV  DX,OFFSET BREAK_HANDLER     ;AN000;DS:DX = VECTOR TO INT HANDLER
				   ;AL = INTERRUPT NUMBER
  DOSCALL SET_VECTOR,VEC_CTLBREAK  ;AN000;(25H) SET INTERRUPT VECTOR

;               STOP THE APPEND FUNCTION.
  MOV  AX,SET_APPEND               ;AN000;CHANGE APPEND /X STATUS
  XOR  BX,BX                       ;AN000;REQUEST TERMINATION OF /X SUPPORT OF APPEND
  INT  2FH                         ;AN000;SET IT

  RET                              ;AN000;RETURN TO CALLER
INIT_CONDITIONS ENDP               ;AN000;
; =  =  =  =  =  =  =  =  =  =  =  =



  HEADER <GET_VOL_LABEL - GET VOLUME LABEL ON SPECIFIED DRIVE> ;AN000;
GET_VOL_LABEL PROC NEAR            ;AN000;
  PUBLIC GET_VOL_LABEL             ;AN000;MAKE ENTRY IN LINK MAP
;INPUT - "START_PATH" IS ASCIIZ OF STARTING PATH
;OUTPUT - "Current_DTA_Filename" WILL HAVE ASCIIZ STRING OF VOLUME LABEL.
;         STARTING DRIVE AND PATH TO SPECIFIED SUBDIR IS DISPLAYED.
; =  =  =  =  =  =  =  =  =  =  =  =

	push    ax

	mov     al,  EXTENDED_FCB  ; EXTENDED_FCB = FFH
	mov     Current_DTA, al   ; set byte 0 to FFH
	mov     al,  attr_volid
	mov     Current_DTA + 6, al   ; set attribute byte to VOLUME
	mov     al,  start_drive   ; user specified drive.  if bad, program
				   ; should have quit by now
	sub     al,  40h           ; start_drive has ascii drive value.
				   ; convert to numeric
	mov     tree_fcb.fcb_drive,  al

; fill in the filename fields in FCB with wildcard character ?
	push    cx
	push    bx
	mov     al,  QUESTION_MARK ; QUESTION_MARK = 3FH
	mov     bx,  1
	mov     cx,  PATH_LEN      ; PATH_LEN = 11, path length in FCB
wldcrd: mov     tree_fcb.fcb_drive[bx],  al
	inc     bx
	loop    wldcrd
	pop     bx
	pop     cx

; do the int 21 - FCB-based Find First
	mov     dx,  OFFSET Current_DTA
	doscall fcb_findfirst
	or      al,  al           ; AL == 0 means found the file
	pop     ax
	jz      ffsuccess

	stc                                 ; if didn't find, set carry flag
	 mov  di, OFFSET MSGNUM_LIST   ;AN000; "Directory PATH listing"
	 call SENDMSG                   ;AN000;DISPLAY STARTING MESSAGE

	jmp     short  gvl_error

; copy the volume label into Current_DTA_Filename
ffsuccess:
	mov     si,  OFFSET tree_fcb.fcb_drive
	inc     si
	mov     di,  OFFSET Current_DTA_Filename
	mov     cx,  PATH_LEN
	rep     movsb

	mov     di,  OFFSET msgnum_vol
	 CALL SENDMSG                      ;AN000;DISPLAY STARTING MESSAGE

gvl_error:
  CALL VOLSER                      ;AN001;DISPLAY VOLUME SERIAL NUMBER, IF ANY

;               DISPLAY THE STARTING DRIVE AND SUBDIRECTORY
  MOV  DX,OFFSET START_DRIVE       ;AN000;PASS POINTER TO STRING TO BE DISPLAYED
  CALL LEN_ASCIIZ                  ;AN000;SETS CX = NUMBER OF BYTES TO WRITE

				        ;DS:DX = ADDRESS OF DATA TO WRITE
  CALL DO_WRITE                    ;AN000;DISPLAY STARTING SUBDIR TO STDOUT

  mov  dx, offset CRLF
  mov  cx, LEN_CRLF
  call Do_Write                    ; terminate line with CR / LF

; now do handle-based Findfirst so that DTA has correct information for the
; Findnext
  MOV  CX,ATTR_VOLID               ;AN000;REQUEST THE VOLUME ID
  MOV  DX,OFFSET Star_Star         ;AN000;PASS FILENAME TO BE LOOKED FOR
  DOSCALL FINDFIRST                ;AN000;LOOK FOR VOLUME LABEL

  RET                              ;AN000;RETURN TO CALLER
GET_VOL_LABEL ENDP                 ;AN000;
; =  =  =  =  =  =  =  =  =  =  =  =



  HEADER <VOLSER - DISPLAY VOLUME SERIAL NUMBER, IF ANY> ;AN001;
VOLSER PROC NEAR                   ;AN001;
  PUBLIC VOLSER                    ;AN001;
;IF THE MEDIA SUPPORTS A VOL SERIAL NUMBER, DISPLAY IT
; =  =  =  =  =  =  =  =  =  =  =  =
;              ISSUE GET MEDIA ID
  MOV  BH,ZERO                     ;AN001;BH=0, RES
  MOV  BL,START_DRIVE              ;AN001;GET LETTER OF DRIVE BEING LOOKED AT
  SUB  BL,DRIVEA-1                 ;AN001;(BACK UP 40H) BL=DRIVE NUM (1=A:, 2=B:, ETC)
  MOV  DX,OFFSET MEDIA_ID_BUF      ;AN001;DS:DX=BUFFER (see A_MEDIA_ID_INFO STRUC)
  DOSCALL GSET_MEDIA_ID,GET_ID     ;AC010;(6900H) GET MEDIA ID
				   ;CARRY SET ON ERROR (OLD STYLE BOOT RECORD)

; $IF  NC                          ;AN001;IF THE GET MEDIA ID WORKED OK,
  JC $$IF28

; NOTE: IN THE FOLLOWING TWO SUBLISTS, WE ARE GOING TO DISPLAY, IN HEX,
; A CONSECUTIVE SET OF 4 BYTES, THE VOLUME SERIAL NUMBER.  THE ORDER OF
; THESE TWO WORDS OF HEX IS, LEAST SIGNIFICANT WORD FIRST, THEN THE
; MOST SIGNIFICANT WORD.  WHEN DISPLAYED, THE MOST SIGNIFICANT IS TO BE
; DISPLAYED FIRST, SO THE VALUE AT SERIAL+2 GOES TO THE 6A SUBLIST,
; AND THE LEAST SIGNIFICANT VALUE AT SERIAL+0 GOES TO THE SECOND POSITION,
; REPRESENTED BY THE 6B SUBLIST.

      LEA  AX,MEDIA_ID_BUF.MI_SERIAL ;AN001;GET POINTER TO DATA TO BE PRINTED
      MOV  SUBLIST_6B.SUB_VALUE,AX ;AN001; INTO THE SUBLIST FOR %2

      LEA  AX,MEDIA_ID_BUF.MI_SERIAL+WORD ;AN001;GET POINTER TO DATA TO BE PRINTED
      MOV  SUBLIST_6A.SUB_VALUE,AX ;AN001; INTO THE SUBLIST FOR %1

				   ;"Volume Serial Number is %1-%2"
      MOV  DI,OFFSET MSGNUM_SERNO  ;AN001;DISPLAY THE NEW SERIAL NUMBER
      CALL SENDMSG                 ;AN001;DISPLAY THE MESSAGE

; $ENDIF                           ;AN001;IS VOL SERIAL NUM PRESENT?
$$IF28:
  RET                              ;AN001;RETURN TO CALLER
VOLSER ENDP                        ;AN001;
; =  =  =  =  =  =  =  =  =  =  =  =



  HEADER <LEN_ASCIIZ - GET LENGTH OF ASCIIZ STRING> ;AN000;
LEN_ASCIIZ PROC NEAR               ;AN000;
  PUBLIC LEN_ASCIIZ                ;AN000;MAKE ENTRY IN LINK MAP
;INPUT - ES:DX = POINTS TO START OF ASCIIZ STRING
;OUTPUT - CX = LENGTH OF CHARACTERS, NOT INCLUDING THE NUL AT THE END
; =  =  =  =  =  =  =  =  =  =  =  =

  PUSH AX                          ;AN000;SAVE THE CALLER'S
  PUSH DI                          ;AN000; REGISTERS
  MOV  CX,FULL_SEG_SIZE            ;AN000;BETTER FIND THAT NUL SOMEWHERE...
  MOV  DI,DX                       ;AN000;SET INDEX TO WALK THRU THE STRING
  MOV  AL,NUL                      ;AN000;THIS IS THE CHAR I AM LOOKING FOR
  REPNE SCASB                      ;AN000;LOOK FOR IT

  SUB  DI,DX                       ;AN000;TAKE AWAY WHERE WE STARTED, FROM WHERE WE AT
  MOV  CX,DI                       ;AN000; TO FIND NOW FAR WE MOVED
  dec  cx                          ; don't add nul
  POP  DI                          ;AN000;RESTORE THE CALLER'S
  POP  AX                          ;AN000; REGISTERS

  RET                              ;AN000;RETURN TO CALLER
LEN_ASCIIZ ENDP                    ;AN000;
; =  =  =  =  =  =  =  =  =  =  =  =



  HEADER <EXECUTE - LOOK THRU DIRECTORY LIST FOR SUBDIRS> ;AN000;
EXECUTE PROC NEAR                  ;AN000;
  PUBLIC EXECUTE                   ;AN000;MAKE ENTRY IN LINK MAP
;BECAUSE OF THE RECURSIVE NATURE OF THIS ROUTINE, ALL ITS LOCAL WORKAREA
;MUST BE DYNAMICALLY ALLOCATED BY USING A PORTION OF THE STACK.  AS EACH
;LOWER LEVEL OF STACK IS PROCESSED, A NEW CALL IS MADE TO THIS SUBROUTINE
;WHICH THEN CREATES A NEW WORKAREA FOR THAT SUBDIRECTORY.
;THE CURRENT STACK SIZE IS CHECKED TO SEE IF THERE IS ENOUGH ROOM FOR
;THE NEW STACK WORKAREA.
;INPUT:START_PATH - STRING OF PATHNAME OF PATH TO BE PROCESSED
;OUTPUT: WHEN THIS PROC RETURNS, ALL FILES IN THIS SUBDIR AND LOWER
;       LEVELS OF SUBDIRS HAVE BEEN PROCESSED.
; =  =  =  =  =  =  =  =  =  =  =  =

  PUSH BP                          ;SAVE CALLER'S BP REG

  SUB  SP,WA_SIZE                  ;ALLOCATE STACK SPACE AS WORKAREA

  MOV  BP,SP                       ;SET BASE FOR WORKAREA CALLED "FRAME"

  MOV  AX,BP                       ;
  SUB  AX,OFFSET LAST_BYTE         ;WHERE MY CODE ENDS
  CMP  AX,MIN_STACK                ;IS THE MINIMUM STACK REMAINING?

  jb   $$IF30

Check_For_Root:
  CMP  START_PATH,BACK_SLASH       ;WAS A BACKSLASH SDIR SPECIFIED,
  JE $$IF31                        ; IF SO, SKIP THIS

  MOV  DX,OFFSET START_PATH        ;POINT TO SPECIFIED PATH
  DOSCALL CHDIR                    ;(3BH) CHANGE CURRENT DIR
  JC $$IF32

  MOV  DL,START_DRIVE              ;GET TARGET DRIVE
  SUB  DL,DRIVEA-1                 ;CONVERT TO NUM (A=1,B=2,ETC.)
  LEA  SI,[BP].FRAM_CURR_PATH+1    ;WHERE TO PUT PATH
  MOV  [BP].FRAM_CURR_PATH,BACK_SLASH 
  DOSCALL GET_CUR_DIR              ;FIND WHERE WE ARE NOW

  LEA  SI,[BP].FRAM_CURR_PATH      ;WHERE PATH WENT, WITH BACKSLASH
  MOV  DI,OFFSET START_PATH        ;WHERE TO PUT IT
  MOV  CX,MAX_PATH+1               ;MOVE FULL LENGTH PLUS BACKSLASH
  REP  MOVSB                       ; TO START_PATH

$$IF32:
  JMP SHORT $$EN31

$$IF31:
  MOV  SI,OFFSET START_PATH        ;USING THE STARTING PATH,
  LEA  DI,[BP].FRAM_CURR_PATH      ;SAVE IT IN THE STACK WORKAREA
				   ;(at times like this, sure is nice to
				   ; have ES=SS.  .EXE would be a problem..)
  MOV  CX,MAX_PATH+1               ;MOVE THE ENTIRE STARTING PATH+LEADING "\"
  REP  MOVSB                       ;INTO THE WORKAREA

  MOV  DX,OFFSET START_PATH        ;POINT TO SPECIFIED PATH
  DOSCALL CHDIR                    ;(3BH) CHANGE CURRENT SDIR TO SPECIFIED SDIR

$$EN31:
  JC $$IF36

  call Begin_Find
  ; Save Error state for FIND_TYPE_DIR 
  pushf

  TEST FLAGS,F_SWITCH      ;ARE ALL FILES ASKED FOR?
				   ; (TEST WILL CLEAR CARRY FLAG)
  JZ $$IF37                        ;IS /F SET?

  CALL FIND_TYPE_NORMAL            ;DISPLAY ALL THE FILENAMES

$$IF37:
  OR   FLAGS,F_FLN                 ; Allow buffer display in Find_Type_Dir

  call Find_Next
 
  ; Restore carry out value from Begin_Find for Find_Type_Dir.
  popf

  CALL FIND_TYPE_DIR               ;DISPLAY ALL THE DIRECTORIES

  JMP SHORT $$EN36

$$IF36:
  MOV  DI,OFFSET MSGNUM_INVPATH    ;"INVALID PATH"
  CALL SENDMSG                     ;SAY WHY I QUIT

  MOV  EXITFL,EXERR                ;SET ERROR FLAG TO QUIT

$$EN36:
				   ;FINISHED WITH THIS SUBDIRECTORY, SO
  JMP SHORT $$EN30                 ;SINCE STACK TOO SMALL

$$IF30:
  MOV  DI,OFFSET MSGNUM_EXTERR     ;DESCRIPTOR FOR EXTENDED ERRORS
  MOV  [DI].MSG_NUM,INSUF_MEM      ;"INSUFFICIENT MEMORY"
  CALL SENDMSG             
  MOV  EXITFL,EXERR                ;SET ERRORLEVEL RET CODE

$$EN30:
  ADD  SP,WA_SIZE                  ;DISCARD WORKAREA

  POP  BP                          ;RESTORE CALLER'S BP REG
  RET                              ;RETURN TO CALLER
EXECUTE ENDP                       ;
; =  =  =  =  =  =  =  =  =  =  =  =



  HEADER <ANY_MORE_SUBDIR - LOOK AHEAD,SEE IF MORE SUBDIR> ;AN000;
ANY_MORE_SUBDIR PROC               ;AN000;
;HAVING JUST DONE A FIND FIRST/NEXT FOR A SUBDIRECTORY,LOOK FOR ANOTHER
;INPUT: BP = DYNAMIC WORKAREA
;OUTPUT: "FRAM_CHAR"="ELBO" = NO MORE SUBDIRS AFTER THIS ONE.
;        "FRAM_CHAR"="TEE"  = ANOTHER SUBDIR AFTER THIS ONE
; =  =  =  =  =  =  =  =  =  =  =  =
;WARNING! The function should be called only once per Find_Next!

; We can set Fram_Char here simply based on the carry out value from the last
; DOS FindNext call, which is stored in the F_Carry bit of Flags.

  test  Flags, F_Carry
  jnz   Elbow

Tee:
  mov   al, Graf_Tee
  mov   [bp].Fram_Char, al       ; store tee as frame character
  jmp   short AMS_Exit

Elbow:
  mov   al, Graf_Elbow
  mov   [bp].Fram_Char, al       ; store elbow as frame character

AMS_Exit:
  ret

ANY_MORE_SUBDIR ENDP               ;AN000;
; =  =  =  =  =  =  =  =  =  =  =  =



  HEADER <FIND_TYPE_NORMAL - PROCESS NORMAL, NON-DIR, FILES> ;AN000;
FIND_TYPE_NORMAL PROC NEAR         ;AN000;
  PUBLIC FIND_TYPE_NORMAL          ;AN000;MAKE ENTRY IN LINK MAP
;INPUT - BP=BASE OF FRAME, DYNAMIC WORKAREA WITH DTA
;OUTPUT - CY SET IF A PROBLEM, AND "EXITFL" HAS ERROR CODE
;         CY CLEAR IF NORMAL "NO MORE FILES" FROM FIND FIRST/NEXT.
; =  =  =  =  =  =  =  =  =  =  =  =

; Turn off display name flag until we have a filename to print.
  AND   FLAGS, 0ffh - F_FLN

; Set leading graphics character for files in this directory..
  call Any_More_Subdir           ; character into [BP].Fram_Char

  mov  dx, offset File_DTA
  DOSCall Set_DTA                ; set DTA as File_DTA

  mov  cx, attr_normal
  mov  dx, offset Star_Star
  DOSCall FindFirst              ; FindFirst using normal file attribute
  jc   FF_Exit                   
  or   Flags, F_FLN              ; permit display of filename

FF_Loop:
  mov  dx, offset File_DTA       ; set ds:dx to File_DTA for Show_FN
  mov  al, File_DTA_Attr
  call Show_FN

  DOSCall FindNext
  jnc   FF_Loop

FF_Exit:
  CALL IF_NOMOREFILES      ;AN000;SEE IF REASON FOR ERROR IS NO MORE FILES
				   ;CY NOT SET = "NO MORE FILES"
				   ;CY IS SET = OTHER PROBLEM, "EXITFL" SET
  JC   FTN_Exit

  mov  File_DTA_Filename, NUL
  mov  dx, offset File_DTA       ; set ds:dx to File_DTA for Show_FN
  MOV  AL,ATTR_NORMAL            ;AN000;SAY IT IS JUST A FILENAME
  CALL SHOW_FN

FTN_Exit:
  mov  dx, offset Next_DTA
  DOSCall Set_DTA                      ; set DTA back to Next_DTA

  ret

FIND_TYPE_NORMAL ENDP
; =  =  =  =  =  =  =  =  =  =  =  =



  HEADER <FIND_TYPE_DIR - PROCESS THE DIRECTORY> ;AN000;
FIND_TYPE_DIR PROC NEAR            ;AN000;
  PUBLIC FIND_TYPE_DIR             ;AN000;MAKE ENTRY IN LINK MAP
;INPUT - BP=BASE OF FRAME, DYNAMIC WORKAREA WITH DTA
;OUTPUT - CY SET IF A PROBLEM
;         CY CLEAR IF NORMAL "NO MORE FILES" FROM FIND FIRST/NEXT.
; =  =  =  =  =  =  =  =  =  =  =  =

Check_File:
  jc   Check_Error

  mov  al, Current_DTA_Attr            ; Is this really a directory?
  and  al, Attr_Dir
  jz   Not_Subdir

  CMP  Current_DTA_Filename,PERIOD      ;AN000;WAS THAT A "PERIOD" FILENAME?
  JE   Dot_Name

	 CALL ANY_MORE_SUBDIR          ;SEE IF MORE SUBDIRS BELOW THIS ONE
	 ;SETS "FRAM_CHAR" TO:
	 ;  "ELBO" - NO MORE DIR BELOW THIS ONE
	 ;  "TEE" - THERE IS ANOTHER DIR BELOW HERE

	 mov  dx, offset Current_DTA   ; set up ds:dx for Show_FN
	 mov  al, Current_DTA_Attr

	 CALL SHOW_FN      ;AN000;SHOW THIS FILE JUST FOUND

	 ADD  CURRENT_COL,DASH_NUM+1 ;AN000;LOCATE SDIR NAME IN PRINTOUT LINE

	 CALL NEXT_LEVEL           ;AN000;SHIFT TO LOWER LEVEL SUBDIRECTORY

	 Push_Frame

	 CALL EXECUTE      ;AN000;RECURSIVE CALL, PROCESS NEW LEVEL OF SUBDIR

	 Pop_Frame            ; Restore values for this frame.

	 SUB  CURRENT_COL,DASH_NUM+1 ;AN000;BACK TO ORIGINAL LEVEL
	 LEA  DX,[BP].FRAM_CURR_PATH ;AN000;DS:DX = POINTER TO ASCIIZ STRING
	 DOSCALL CHDIR     ;AN000;(3BH) CHANGE CURRENT DIRECTORY
	 ;GO BACK TO THE DIRECTORY THIS LEVEL OF
	 ; STACK WORKAREA HAS BEEN DEALING WITH,
	 ; SINCE "EXECUTE" HAD CHANGED IT TO WORK ON
	 ; A LOWER SUBDIRECTORY.

Not_Subdir:
Dot_Name:
  CMP  EXITFL,EXOK                 ;AN000;ANY ERRORS SO FAR?
  JNE  FTD_Exit

; There are more subdirectories to display; get the next one.
  CALL FIND_NEXT
  JMP  Check_File

Check_Error:
  CMP  EXITFL,EXOK                 ;AN000;IF NO ERROR FOUND SO FAR
  JNE  FTD_Exit
  CALL IF_NOMOREFILES      ;AN000;SEE IF REASON FOR ERROR IS NO MORE FILES
  ;CY NOT SET = "NO MORE FILES"
  ;CY IS SET = OTHER PROBLEM, "EXITFL" SET

FTD_Exit:
  ret

FIND_TYPE_DIR ENDP
; =  =  =  =  =  =  =  =  =  =  =  =



  HEADER <NEXT_LEVEL - SET UP TO LOOK AT LOWER LEVEL SUBDIR> ;AN000;
NEXT_LEVEL PROC NEAR               ;AN000;
  PUBLIC NEXT_LEVEL                ;AN000;
;INPUT: Current_DTA_Filename - FILE NAME OF LOWER LEVEL SUBDIR
;OUTPUT: START_PATH - HAS COMPLETE PATH TO THE NEW LEVEL SUBDIR
; =  =  =  =  =  =  =  =  =  =  =  =

  MOV  SI,OFFSET START_PATH+1   ;AN000;WHERE TO SAVE CURRENT PATH
  MOV  DL,DEFDRIVE                 ;AN000;DL = DRIVE NUM (0=DEF, 1=A, ETC)
  DOSCALL GET_CUR_DIR              ;AN000;(47H) GET CURRENT DIRECTORY
				   ;OUTPUT: DS:SI POINTS TO FULL PATH NAME
  DEC  SI                          ;AN012;START SCAN AT START_PATH
  CALL SCAN_DBCS                   ;AN012;GET LAST 2 CHARS IN DL,DH
				   ; SI NOW AT END OF STRING
  MOV  DI,SI                       ;AN012;GET POINTER TO NUL
  CMP  DL,BACK_SLASH               ;AN000;
; $IF  NE                          ;AN012;IF PATH NOT ALREADY TERMINATED WITH A "\"
  JE $$IF70
      MOV  BYTE PTR [DI],BACK_SLASH ;AN000;TERMINATE PREVIOUS PATH
      INC  DI                      ;AN000;DI POINTS TO NEXT NUL AT END OF STRING
; $ENDIF                           ;AN000;END IN "\"?
$$IF70:
  MOV  SI,OFFSET Current_DTA_Filename      ;AN000;GET NAME OF NEW SUBDIR
  MOV  CX,LENGTH Current_DTA_Filename      ;AN000;
  REP  MOVSB                       ;AN000;ADD THE NEW SUBDIR TO END

  RET                              ;AN000;RETURN TO CALLER
NEXT_LEVEL ENDP                    ;AN000;
; =  =  =  =  =  =  =  =  =  =  =  =



  HEADER <SCAN_DBCS - FIND LAST 2 SBCS CHARS IN ASCIIZ> ;AN000;
SCAN_DBCS PROC NEAR                ;AN000;
  PUBLIC SCAN_DBCS                 ;AN000;
;INPUT: DS:SI = ASCIIZ STRING TO BE SCANNED
;OUTPUT: DL=LAST SBCS CHAR BEFORE NUL
;        DH=NEXT TO LAST SBCS CHAR BEFORE NUL
;        IF NO SBCS CHAR FOUND, DL OR DH WILL BE NUL
;        SI=OFFSET TO NUL DELIMITER

  XOR  DX,DX                       ;AN000;CLEAR CHAR ACCUMULATOR
; $DO                              ;AN000;
$$DO72:
      LODSB                        ;AN000;GET NEXT CHAR FROM DS:SI TO AL
      CMP  AL,NUL                  ;AN000;IS THAT THE DELIMITER?
; $LEAVE E                         ;AN000;FOUND THE END, SO QUIT
  JE $$EN72
      CALL CHK_DBCS                ;AN000;IS THIS THE FIRST OF A DBCS PAIR?

;     $IF  C                       ;AN000;IF SO, FOUND A DBCS PAIR
      JNC $$IF74
	  INC  SI                  ;AN000;SKIP ITS PARTNER
	  MOV  AL,NUL              ;AN000;PASS BACK A NUL, INSTEAD OF AN SBCS CHAR
;     $ENDIF                       ;AN000;
$$IF74:
      MOV  DH,DL                   ;AN000;SAVE PREVIOUS CHAR
      MOV  DL,AL                   ;AN000;REMEMBER THE CHAR JUST FOUND
; $ENDDO                           ;AN000;
  JMP SHORT $$DO72
$$EN72:
  DEC  SI                          ;AN000;LODSB SET SI ONE BEYOND NUL
				   ; SO SET SI BACK TO POINT TO THE NUL
  RET                              ;AN000;RETURN TO CALLER
SCAN_DBCS ENDP                     ;AN000;
; =  =  =  =  =  =  =  =  =  =  =  =



  HEADER <BEGIN_FIND - DO FIND FIRST FILE> ;AN000;
BEGIN_FIND PROC NEAR               ;AN000;
  PUBLIC BEGIN_FIND                ;AN000;MAKE ENTRY IN LINK MAP
;INPUT - CURRENT DOS DEFAULT DRIVE HAS TARGET DRIVE TO BE RESEARCHED.
;        CURRENT DEFAULT SUBDIRECTORY HAS SUBDIR TO BE RESEARCHED.
;       BP = OFFSET OF DYNAMIC WORKAREA
;OUTPUT - DTA IS SET UP WITH FIRST FILE FOUND, READY TO BE USED BY FINDNEXT.
;        WORKAREA HAS SAVED THE RESULT OF FINDFIRST.
; =  =  =  =  =  =  =  =  =  =  =  =

  mov  dx, offset Next_DTA
  DOSCall Set_DTA                ; set DTA as Next_DTA

  mov  cx, attr_dir
  mov  dx, offset Star_Star
  DOSCall FindFirst              ; FindFirst using directory attribute
  jmp  short Skip_FN

FindFirst_Loop:
  DOSCall FindNext

Skip_FN:
  Set_F_Carry
  jc   BF_Exit

  ; Make sure we have found a directory here.  If not, keep doing FindNexts
  ; until we find one or run out of files.
  mov  al, Next_DTA_Attr
  and  al, attr_dir
  jz   FindFirst_Loop                 ; Only found a file, look again.

  cmp  byte ptr Next_DTA_Filename,Period ;Now check for "." (and "..")
  je   FindFirst_Loop                 ;If this is a "dot" directory, try again

  clc

BF_Exit:

  ret

BEGIN_FIND ENDP                    ;AN000;
; =  =  =  =  =  =  =  =  =  =  =  =



  HEADER <FIND_NEXT - LOOK FOR NEXT ENTRY IN DIRECTORY> ;AN000;
FIND_NEXT PROC NEAR                ;AN000;
  PUBLIC FIND_NEXT                 ;AN000;
;INPUT: RESERVED FIELD, LEFT FROM PREVIOUS FIND FIRST/NEXT, IN [BP].FRAM_DTA_RES
;OUTPUT: [BP].FRAM_DTA_RES UPDATED WITH NEW RESERVED DATA, FROM CURRENT DTA
;       FIX_DTA.? FIELDS ARE SET UP TO DEFINE NEW FILE JUST FOUND.
;       CY SET IF NO MORE FILES FOUND, CY CLEAR IF A NEW FILE FOUND.
; =  =  =  =  =  =  =  =  =  =  =  =

; N.b., the DOS DTA must already be set as Next_DTA
; for Find_Next to proceed properly.

  test Flags, F_Carry
  jnz  Last_Find_Not_OK

Last_Find_OK:
  ; Not first time, so copy DTA_Current to DTA_Next.
  Copy_DTA Next_DTA, Current_DTA       ;NOTE! CopyDTA SOURCE,DESTINATION

FindNext_Loop:
  DOSCall FindNext
  Set_F_Carry
  jc   Clear_C_Exit                    ; Ran out of files.

  ; Make sure we have found a directory here.  If not, keep doing FindNexts
  ; until we find one or run out of files.
  mov  al, Next_DTA_Attr
  and  al, attr_dir
  jz   FindNext_Loop                 ; Only found a file, look again.

  cmp  byte ptr Next_DTA_Filename,Period ;Now check for "." (and "..")
  je   FindNext_Loop                 ;If this is a "dot" directory, try again

Clear_C_Exit:
; N.b., the carry out from Find_Next is the carry out from the DOS FindNext
; on the file now in Current_DTA, not for the file we just got in Next_DTA.
  clc

FN_Exit:
  ret

Last_Find_Not_OK:
  ; Previous find failed, so we fail here, too.
  stc
  jmp  short FN_Exit

FIND_NEXT ENDP                     ;AN000;
; =  =  =  =  =  =  =  =  =  =  =  =



  HEADER <SHOW_FN - DISPLAY THE FILENAME FOUND> ;AN000;
SHOW_FN PROC NEAR                  ;AN000;
  PUBLIC SHOW_FN                   ;AN000;MAKE ENTRY IN LINK MAP
;INPUT - BP=OFFSET TO WORKAREA IN STACK
;        ds:dx = DTA holding filename to display
;        FLAGS (F_FLN) INDICATOR OF FLN HAVING BEEN PRINTED
;        al = file attribute to use, NOT the attribute from ds:dx.attribute
;             (copied to bl for subfunctions)
;OUTPUT - "BUF" IS SET UP TO CONTAIN THE DISPLAY LINE, AND IS SENT TO STDOUT.
; =  =  =  =  =  =  =  =  =  =  =  =
;DESCRIPTION OF THE LINE TO BE DISPLAYED, IN "BUF":
;"CURRENT_COL" HAS COL NUMBER WHERE LEADING GRAPHIC IS TO GO.
;"DASH_NUM" IS THE NUM OF DASHES THAT IMMEDIATELY FOLLOWS THE LEADING
;   GRAPHIC.  (FOR SUBDIRECTORIES ONLY - FOR REGULAR FILENAMES, THIS
;   FIELD WOULD HAVE SPACES INSTEAD OF DASHES.)
;"FLN_INDENT" IS THE NUMBER OF SPACES TO BE PUT RIGHT IN FRONT OF A
;   FILENAME.  FOR SUBDIRS, THERE IS NO SUCH FIELD
;EXAMPLE, FOR SUBDIRS
;      DIR_FILN
;         FOR ORDINARY FILES
;      xxxssssANY_FILN.EXT  (WHERE x AND s ARE SPACES)
; =  =  =  =  =  =  =  =  =  =  =  =

  mov  si, dx
  CMP  byte ptr [si].DTA_Filename_Offset, PERIOD           ;AN000;DOES FILENAME START WITH PERIOD?
; $IF  NE                          ;AN000;IF NOT, CONTINUE...
  JE   SF_Exit

      MOV  BL, AL                   ;AN000;SAVE FILE ATTRIBUTE INTO BL

      CALL FLN_TO_BUF              ;AN000; MOVE NAME OF FILE TO OUTPUT BUFFER

      CALL GRAF_TO_BUF             ;AN000;DETERMINE LEADING GRAPHIC FOR BUFFER

      CALL BLANK_DASH              ;AN000;PUT BLANKS OR DASHES INTO BUF BEFORE FILENAME

; BUFFER INITIALIZED, DISPLAY IT

      MOV  DX, OFFSET BUF          ;AN000;DISPLAY FILENAME OF FILE FOUND
      CALL LEN_ASCIIZ              ;AN000;SET CX=LEN OF DX@ BUFFER, UP THRU NUL

      TEST FLAGS,F_FLN             ;AN000;HAVE ANY FLN BEEN PRINTED YET?

;     $IF  NZ                      ;AN000;IF SO, PRINT THIS
      JZ   No_Display
      CALL DO_WRITE        ;AN000;DISPLAY FILENAME IN DX TO STDOUT

No_Display:
;               CLEAN UP BUFFER FOR NEXT TIME

      CALL FIX_GRAF                ;AN000;SET UP GRAPHIC FOR NEXT LINE

      MOV  AL,[BP].FRAM_CHAR       ;AN000;GET ALTERED GRAPHIC CHAR
      MOV  DI,CURRENT_COL          ;AN000;FIND WHERE IN "BUF"
      LEA  DI,BUF-1[DI]    ;AN000; TO PUT ALTERED GRAPHIC
      STOSB                        ;AN000;STORE ALTERED GRAPHIC INTO BUFFER

      ; Is this a subdirectory?
      mov  al, bl
      and  al, ATTR_DIR
      jz   SF_Exit

      OR   FLAGS,F_SUBDIR          ;AN000;SAY, "A SUBDIR HAS BEEN PRINTED"

      MOV  DI,CURRENT_COL          ;AN000;GET COL NUM OF ELBO/TEE
      LEA  DI,BUF[DI]      ;AN000;POINT TO JUST AFTER ELBO/TEE
      MOV  AL,BLANK        ;AN000;BLANK OUT THE HORIZONTAL DASHES
      MOV  CX,DASH_NUM     ;AN000;HOW MANY DASHES WERE PUT IT
      REP  STOSB                   ;AN000;WIPE OUT THOSE DASHES FOR NEXT GUY

SF_Exit:
  RET                              ;AN000;RETURN TO CALLER
SHOW_FN ENDP                       ;AN000;
; =  =  =  =  =  =  =  =  =  =  =  =



  HEADER <FLN_TO_BUF - MOVE FILENAME TO BUFFER> ;AN000;
FLN_TO_BUF PROC NEAR               ;AN000;
  PUBLIC FLN_TO_BUF                ;AN000;
;INPUT: CURRENT_COL - INDEX INTO "BUF" WHERE THIS DISPLAY STARTS
;       ds:dx = DTA holding filename to display
;OUTPUT: "BUF" HAS LEADING GRAPHIC AND FILENAME READY FOR DISPLAY.
; =  =  =  =  =  =  =  =  =  =  =  =

  MOV  DI,CURRENT_COL              ;AN000;

  ; Is this a subdirectory?
  mov  al, bl
  and  al, ATTR_DIR
  jnz  Yes_Subdir

  LEA  DI,BUF+DASH_NUM+FLN_INDENT[DI] ;AN000;SET DESTINATION TO "BUF"+
  JMP SHORT $$EN83

Yes_Subdir:
  LEA  DI,BUF+DASH_NUM[DI]         ;AN000;SET DESTINATION TO "BUF"+

$$EN83:
  MOV  CX,LENGTH Current_DTA_Filename      ;AN000;SET COUNT TO MOVE ENTIRE FILE NAME
  MOV  SI, dx
  add  SI, DTA_Filename_Offset     ;AN000;FROM DTA OF FIND FIRST

Copy_Loop:
  LODSB                    ;AN000;GET FIRST\NEXT CHAR OF FILENAME
  STOSB                    ;AN000;MOVE THAT BYTE TO OUTPUT MSG FIELD
  CMP  AL,NUL              ;AN000;IS THIS THE NUL CHAR DELIMITER?

  JE   FTB_Exit

  LOOP Copy_Loop

FTB_Exit:
  ; Terminate with carriage return/line feed and NULL terminate
  dec  di
  mov  ax, (LF SHL 8) OR CR
  stosw
  xor  al,al
  stosb
  ret

FLN_TO_BUF ENDP                    ;AN000;
; =  =  =  =  =  =  =  =  =  =  =  =



  HEADER <GRAF_TO_BUF - SELECT LEADING GRAPHIC CHAR FOR BUF> ;AN000;
GRAF_TO_BUF PROC NEAR              ;AN000;
  PUBLIC GRAF_TO_BUF               ;AN000;
;INPUT: BL = ATTRIBUTE OF FILENAME
;       ds:dx = DTA holding filename to display
;       FLAGS (F_First_Time BIT)
;       FRAM_CHAR = LEADING CHAR, FOR FILENAME DISPLAY
;       CURRENT_COL = WHERE IN BUF TO PUT CHARS
;       BUF = TO RECEIVE LEADING CHAR
;OUTPUT: BUF HAS LEADING CHAR
; =  =  =  =  =  =  =  =  =  =  =  =

  ; Is this a subdirectory?
  mov  al, bl
  and  al, ATTR_DIR
  jnz  Y_Subdir

  CALL FIX_GRAF            ;AN000;SET UP GRAPHIC FOR NEXT LINE

Y_Subdir:
  MOV  AL,[BP].FRAM_CHAR           ;AN000;START BUF WITH CURRENT GRAPHIC CHAR
  MOV  DI,CURRENT_COL              ;AN000;
  LEA  DI,BUF-1[DI]        ;AN000;
  STOSB                            ;AN000;

  RET                              ;AN000;RETURN TO CALLER

GRAF_TO_BUF ENDP                   ;AN000;
; =  =  =  =  =  =  =  =  =  =  =  =



  HEADER <BLANK_DASH - PUT BLANKS OR DASHES BEFORE FILENAME> ;AN000;
BLANK_DASH PROC NEAR               ;AN000;
  PUBLIC BLANK_DASH                ;AN000;
;INPUT: BL - FILE ATTRIBUTE
;       CURRENT_COL - WHERE THIS DISPLAY STARTS IN "BUF"
;       BUF - PARTLY READY CHARS FOR DISPLAY
;OUTPUT: BUF HAS PROPER CHARS BETWEEN LEADING GRAPHIC AND FILENAME FIELDS.
; =  =  =  =  =  =  =  =  =  =  =  =
  ; Is this a subdirectory?
  mov  al, bl
  and  al, ATTR_DIR
  jnz  $$IF96

      MOV  AL,BLANK                ;AN000;PUT IN BLANKS
      MOV  CX,DASH_NUM + FLN_INDENT ;AN000;SPECIFY HOW MANY BLANKS TO PUT IN
; $ELSE                            ;AN000;SINCE IT IS A SUBDIR
  JMP SHORT $$EN96
$$IF96:
      MOV  AL,GRAF_DASH            ;AN000;PUT IN THE DASHES
      MOV  CX,DASH_NUM             ;AN000;SPECIFY HOW MANY DASHES TO PUT IN
; $ENDIF                           ;AN000;
$$EN96:
  MOV  DI,CURRENT_COL              ;AN000;GET COL NUM OF ELBO/TEE
  LEA  DI,BUF[DI]                  ;AN000;POINT TO JUST AFTER ELBO/TEE
  REP  STOSB                       ;AN000;ADD DASHES/BLANKS TO PRINT LINE IN "BUF"
  RET                              ;AN000;RETURN TO CALLER
BLANK_DASH ENDP                    ;AN000;
; =  =  =  =  =  =  =  =  =  =  =  =



  HEADER <FIX_GRAF - CHANGE CURRENT GRAPHIC FOR NEXT LINE> ;AN000;
  PUBLIC FIX_GRAF                  ;AN000;MAKE ENTRY IN LINK MAP
FIX_GRAF PROC NEAR                 ;AN000;
;IN THE WORKAREA, IS A CHAR THAT SHOWS WHAT HAS BEEN FOUND REGARDING ANY
;LOWER LEVELS OF SUBDIRS.
;WHEN DISPLAYING A SUBDIR, THE PRINT LINE STARTS EITHER WITH "ELBO",
;MEANING, NO LOWER LEVELS AFTER THIS ONE, OR WITH "TEE" WHICH MEANS
;THERE IS ANOTHER LEVEL OF SUBDIR BELOW THIS ONE.  AFTER THE DISPLAY,
;THE REST OF THE DISPLAY OF FILENAMES WITHIN THIS SUBDIR, WILL SHOW
;THIS CHARACTER, BUT IN A Revised FORMAT.  THIS SUBROUTINE PERFORMS
;THE MODIFICATION, AS:
;CHANGE "ELBO" TO "BLANK, OR CHANGE "TEE" TO "VERTICAL BAR".
;INPUT: BP=POINTER TO STACK WORKAREA
;       FRAM_CHAR=FIELD IN WORKAREA WITH CHAR TO BE Revised
; =  =  =  =  =  =  =  =  =  =  =  =

  MOV  AL, Graf_Elbow              ;AN002;GET ELBO CHAR
  CMP  [BP].FRAM_CHAR, AL          ;AN000;FOR NEXT DISPLAY LINE AFTER THIS ONE,
; $IF  E                           ;AN000;IF CURRENT LINE STARTS WITH "ELBO"
  JNE  Not_Elbow
  MOV  [BP].FRAM_CHAR,BLANK    ;AN000;CHANGE IT TO JUST A BLANK
; $ELSE                            ;AN000;SINCE NOT ELBO
  JMP SHORT FG_Exit

Not_Elbow:
  MOV  AL,GRAF_TEE                 ;AN002;GET THE TEE CHAR
  CMP  [BP].FRAM_CHAR,AL           ;AC002;CHANGE A "TEE"
;     $IF  E                       ;AN000;
  JNE  Not_Tee

  MOV  AL,GRAF_BAR         ;AN002;GET BAR CHAR
  MOV  [BP].FRAM_CHAR,AL   ;AC002; TO A VERTICAL "BAR"
;     $ENDIF                       ;AN000;

Not_Tee:
; $ENDIF                           ;AN000;ELBO?

FG_Exit:
  RET                              ;AN000;RETURN TO CALLER
FIX_GRAF ENDP                      ;AN000;
; =  =  =  =  =  =  =  =  =  =  =  =



  HEADER <ANY_SUBDIRS - DISPLAY MSG IF NO SUBDIRS PRINTED> ;AN000;
ANY_SUBDIRS PROC NEAR              ;AN000;
;INPUT:FLAGS (F_SUBDIR BIT) IS SET IF ANY SUBDIR HAD BEEN DISPLAYED.  IF THIS
;       BIT IS OFF, THEN DISPLAY THE MESSAGE
; =  =  =  =  =  =  =  =  =  =  =  =

  TEST FLAGS,F_SUBDIR              ;AN000;HAVE ANY SUBDIRS BEEN PRINTED YET?
; $IF  Z                           ;AN000;NO, NONE PRINTED SO FAR
  JNZ $$IF104
      MOV  DI,OFFSET MSGNUM_NOSUB  ;AN000;"No sub-directories exist"
      CALL SENDMSG                 ;AN000;DISPLAY THE MESSAGE

; $ENDIF                           ;AN000;ANY SUBDIRS PRINTED?
$$IF104:
  RET                              ;AN000;RETURN TO CALLER
ANY_SUBDIRS ENDP                   ;AN000;
; =  =  =  =  =  =  =  =  =  =  =  =



  HEADER <DO_WRITE - SEND STRING TO STDOUT> ;AN000;
DO_WRITE PROC NEAR                 ;AN000;
  PUBLIC DO_WRITE                  ;AN000;
;AFTER THE REQUESTED STRING IS SEND TO STDOUT, IT IS TERMINATED BY CR,LF
;INPUT: DX=OFFSET TO STRING TO BE WRITTEN
;       CX=LENGTH
;OUTPUT: STRING IS SENT TO STDOUT, FOLLOWED BY CR,LF.
;       BX = SAVED AND RESTORED.
; =  =  =  =  =  =  =  =  =  =  =  =

ifdef JAPAN
	call    conv_graph              ; convert graphic character to kanji
endif

  PUSH BX                          ;AN000;SAVE CALLER'S REG
  MOV  BX,STDOUT                   ;AN000;BX = FILE HANDLE
  DOSCALL WRITE                    ;AN000;(40H) WRITE FUNCTION

  POP  BX                          ;AN000;RESTORE CALLER'S REG
  RET                              ;AN000;RETURN TO CALLER
DO_WRITE ENDP                      ;AN000;
; =  =  =  =  =  =  =  =  =  =  =  =



  HEADER <IF_NOMOREFILES - ASK EXTENDED ERROR FOR WHY IS ERROR> ;AN000;
IF_NOMOREFILES PROC NEAR           ;AN000;
  PUBLIC IF_NOMOREFILES            ;AN000;
;INPUT - A DOS FUNCTION HAS JUST RETURNED WITH A CARRY INDICATING ERROR
;OUTPUT - AX=EXTENDED ERROR CODE
;       IF THE ERROR IS JUST A NO MORE FILES, CARRY IS CLEAR
;       IF ANY OTHER ERROR, THEN CARRY IS SET, AND "EXITFL" HAS RET CODE
; =  =  =  =  =  =  =  =  =  =  =  =

  CALL GET_EXTERR                  ;AN000;GET THE EXTENDED ERROR TO AX

  CMP  AX,NO_MORE_FILES            ;AN000;SEE IF FILE WAS NOT FOUND
  JNE $$IF106

  CLC                      ;AN000;INDICATE A NORMAL RETURN

; $ELSE                            ;AN000;SINCE ERROR IS SOMETHING ELSE
  JMP SHORT $$EN106

$$IF106:
      STC                          ;AN000;INDICATE AN ABNORMAL RETURN
      MOV  EXITFL,EXERR            ;AN000;INDICATE A PROBLEM TO RETURN CODE
; $ENDIF                           ;AN000;NO MORE FILES?
$$EN106:

  RET                              ;AN000;RETURN TO CALLER
IF_NOMOREFILES ENDP                ;AN000;
; =  =  =  =  =  =  =  =  =  =  =  =



  HEADER <GET_EXTERR - CALL EXTENDED ERROR> ;AN000;
GET_EXTERR PROC NEAR               ;AN000;
  PUBLIC GET_EXTERR                ;AN000;
;INPUT - A DOS FUNCTION HAS JUST RETURNED WITH A CARRY INDICATING ERROR
;OUTPUT: AX HAS EXTENDED ERROR CODE
;       NOTE: OTHER REGS, BX, CX, NORMALLY SET BY THE EXTERROR CALL
;             ARE NOT KEPT.  THESE CONTAIN "LOCUS" AND SECONDARY LEVEL CODES
;             THAT ARE NOT USED.
; =  =  =  =  =  =  =  =  =  =  =  =
  PUSH BX                          ;AN000;SAVE THE
  PUSH DS                          ;AN000; CALLER'S
  PUSH ES                          ;AN000;  REGISTERS
  PUSH CX                          ;AN000;

  MOV  BX,LEVEL_0                  ;AN000;BX=LEVEL NUMBER
  DOSCALL EXTERROR                 ;AN000;(59H) SET REGS TO SAY WHY PROBLEM

  POP  CX                          ;AN000;RESTORE REGS
  POP  ES                          ;AN000; CLOBBERED BY
  POP  DS                          ;AN000;  THE DOSCALL
  POP  BX                          ;AN000;

  RET                              ;AN000;RETURN TO CALLER
GET_EXTERR ENDP                    ;AN000;
; =  =  =  =  =  =  =  =  =  =  =  =



  HEADER <SENDMSG - PASS IN REGS DATA FROM MSG DESCRIPTOR TO DISP MSG> ;AN000;
SENDMSG PROC NEAR                  ;AN000;
  PUBLIC SENDMSG                   ;AN000;
; INPUT - DI=POINTER TO MSG_DESC STRUC FOR THIS MESSAGE
; OUTPUT - IF CARRY SET, EXTENDED ERROR MSG ATTEMPTED DISPLAYED
;          IF CARRY CLEAR, ALL OK
;          IN EITHER CASE, DI AND AX ALTERED, OTHERS OK

;  =  =  =  =  =  =  =  =  =  =  =  =

  PUSH BX                          ;AN000; SAVE CALLER'S REGS
  PUSH CX                          ;AN000;
  PUSH DX                          ;AN000;
  PUSH SI                          ;AN000;

;                PASS PARMS TO MESSAGE HANDLER IN
;                THE APPROPRIATE REGISTERS IT NEEDS.
  MOV  AX,[DI].MSG_NUM             ;AN000; MESSAGE NUMBER
  MOV  BX,[DI].MSG_HANDLE          ;AN000; HANDLE TO DISPLAY TO
  MOV  SI,[DI].MSG_SUBLIST         ;AN000; OFFSET IN ES: OF SUBLIST, OR 0 IF NONE
  MOV  CX,[DI].MSG_COUNT           ;AN000; NUMBER OF %PARMS, 0 IF NONE
  MOV  DX,[DI].MSG_CLASS           ;AN000; CLASS IN HIGH BYTE, INPUT FUNCTION IN LOW
  CALL SYSDISPMSG                  ;AN000; DISPLAY THE MESSAGE

; $IF  C                           ;AN000; IF THERE IS A PROBLEM,
  JNC $$IF109
				   ; AX=EXTENDED ERROR NUMBER
      MOV  DI,OFFSET MSGNUM_EXTERR ;AN000; GET REST OF ERROR DESCRIPTOR
      MOV  BX,[DI].MSG_HANDLE      ;AN000; HANDLE TO DISPLAY TO
      MOV  SI,[DI].MSG_SUBLIST     ;AN000; OFFSET IN ES: OF SUBLIST, OR 0 IF NONE
      MOV  CX,[DI].MSG_COUNT       ;AN000; NUMBER OF %PARMS, 0 IF NONE
      MOV  DX,[DI].MSG_CLASS       ;AN000; CLASS IN HIGH BYTE, INPUT FUNCTION IN LOW
      CALL SYSDISPMSG              ;AN000; TRY TO SAY WHAT HAPPENED

      STC                          ;AN000; REPORT PROBLEM
; $ENDIF                           ;AN000; PROBLEM WITH DISPLAY?
$$IF109:

  POP  SI                          ;AN000; RESTORE CALLER'S REGISTERS
  POP  DX                          ;AN000;
  POP  CX                          ;AN000;
  POP  BX                          ;AN000;

  RET                              ;AN000;RETURN TO CALLER
SENDMSG ENDP                       ;AN000;
; =  =  =  =  =  =  =  =  =  =  =



  HEADER <BREAK_HANDLER - CONTROL BREAK VECTOR POINTS HERE> ;AN000;
BREAK_HANDLER PROC FAR             ;AN000;"FAR" HERE IS REQUIRED FOR
  PUBLIC BREAK_HANDLER             ;AN000; BREAK INTERRUPT HANDLERS
;THE INT 23H VECTOR HAS BEEN SET TO POINT HERE.
;THIS ROUTINE GETS CONTROL IF CONTROL-BREAK IS PRESSED.
;OUTPUT: THE "STC" REQUESTS THAT DOS ABORT WHEN I RETURN.
;       THERE IS NO ERRORLEVEL VALUE TO BE PASSED BACK TO DOS AT THIS POINT.

  CALL RESTORE                     ;AN000;PUT THINGS BACK LIKE THEY WERE

  DOSCALL RET_CD_EXIT,EXCTL        ;AN000;RETURN TO DOS, WITH CTL-BREAK ERROR CODE
  INT  20H                         ;AN000;IN CASE ABOVE FAILS

;NOTE: THIS IS NOT THE MAIN EXIT FROM "TREE".
;      THE USUAL EXIT IS IN "BEGIN" PROC.
BREAK_HANDLER ENDP                 ;AN000;
; =  =  =  =  =  =  =  =  =  =  =  =



  HEADER <RESTORE - RETURN TO INITIAL DOS DEFAULT DRIVE> ;AN000;
RESTORE PROC NEAR                  ;AN000;
  PUBLIC RESTORE                   ;AN000;
;SET DOS DEFAULT DRIVE BACK TO THE INITIAL VALUE, AND
; RESTORE THE INITIAL DEFAULT PATH,
; AND THE INITIAL "APPEND" STATE,
; AND THE ORIGINAL CONTROL BREAK VECTOR.
;INPUT - "DEFAULT_DR" SET TO ALPHA LETTER OF ORIGINAL DOS DEFAULT DRIVE.
;        "START_DR_NUM" SET TO NUMERIC VALUE OF ORIGINAL DOS DEFAULT DRIVE
;        "DEFAULT_PATH" SET TO ORIGINAL CURRENT PATH OF DOS DEFAULT DRIVE
;        "APPEND_FLAGS" HAS ORIGINAL STATUS OF /X OF APPEND
;        "OLDINT23" HAS ORIGINAL OWNER OF CONTROL BREAK VECTOR 23H
;        "OLDINT24" HAS ORIGINAL OWNER OF CRITICAL ERROR VECTOR 24H
; =  =  =  =  =  =  =  =  =  =  =  =

  TEST FLAGS,F_FAILING             ;AN000;IS RESTORING SUBDIR PERMITTED?
; $IF  Z,AND                       ;AN000;YES, DO IT
  JNZ $$IF111
  TEST FLAGS,F_DEF_PAT_TAR         ;AN000;HAS ORIGINAL SUBDIR BE FOUND YET?
; $IF  NZ                          ;AN000;YES, DO IT
  JZ $$IF111

;               RESTORE THE CURRENT SUBDIRECTORY TO ITS ORIGINAL PATH

      MOV  DX,OFFSET DEFAULT_PATH  ;AN000;DS:DX = POINTER TO ASCIIZ STRING
      DOSCALL CHDIR                ;AN000;(3BH) CHANGE CURRENT DIRECTORY

; $ENDIF                           ;AN000;
$$IF111:

;               RESTORE THE DOS DEFAULT DRIVE TO ITS ORIGINAL DRIVE

  MOV  DL,START_DR_NUM             ;AN000; DL=DRIVE NUMBER (0=A,1=B)
  DOSCALL SELECT_DISK              ;AN000;(0EH) SETS DEFAULT DRIVE

;               SET APPEND BACK TO ITS ORIGINAL STATUS

  TEST FLAGS,F_APPEND              ;AN006;IF DOS VERSION OF APPEND IS ACTIVE
; $IF  NZ                          ;AN006;IT NEEDS TO BE FIXED BACK LIKE IT WAS
  JZ $$IF113
      MOV  AX,SET_APPEND           ;AN000;RESTORE APPEND TO PREVIOUS /X STATUS
      MOV  BX,APPEND_FLAGS         ;AC006;GET PREVIOUS STATUS
      INT  2FH                     ;AN000;SET IT BACK AS IT WAS

; $ENDIF                           ;AN006;DOS VERSION OF APPEND?
$$IF113:

;               FIXUP THE CONTROL BREAK VECTOR TO ITS ORIGINAL CONTENTS

  PUSH DS                          ;AN000;SAVE THE SEGREG
  LDS  DX,OLDINT23                 ;AN000;USING THE ORIGINAL CONTENTS OF THE VECTOR
				   ;DS:DX = DWORD POINTER TO BE PUT INTO VECTOR
  DOSCALL SET_VECTOR,VEC_CTLBREAK  ;AN000;(25H) RESTORE THE ORIG INT 23 HANDLER

  POP  DS                          ;AN000;RESTORE THE SEGREG

;               FIXUP THE CRITICAL ERROR VECTOR TO ITS ORIGINAL CONTENTS

  PUSH DS                          ;AN000;SAVE THE SEGREG
  LDS  DX,OLDINT24                 ;AN000;USING THE ORIGINAL CONTENTS OF THE VECTOR
				   ;DS:DX = DWORD POINTER TO BE PUT INTO VECTOR
  DOSCALL SET_VECTOR,VEC_CRITERR   ;AN000;(25H) RESTORE THE ORIG INT 24 HANDLER

  POP  DS                          ;AN000;RESTORE THE SEGREG
  RET                              ;AN000;RETURN TO CALLER
RESTORE ENDP                       ;AN000;
; =  =  =  =  =  =  =  =  =  =  =  =



  HEADER <MYERRORHANDLER - SERVICE CRITICAL ERROR HANDLER> ;AN000;
MYERRORHANDLER PROC NEAR           ;AN000;
;INPUT: DOS HAS CALLED THE CRITICAL ERROR INTERRUPT, VECTOR 24
;       AL=FAILING DRIVE NUMBER (A:=0; B:=1; ETC.)
;OUTPUT: EITHER TREE IS TERMINATED (ON ABORT OR FAIL), OR
;       AL HAS OPERATOR RESPONSE, AND IRET BACK TO DOS TO HANDLE IT.
; =  =  =  =  =  =  =  =  =  =  =  =
  ASSUME CS:CSEG                   ;AN000;ONLY THE CS REG IS WORTH A HOOT
  ASSUME DS:NOTHING                ;AN000;
  ASSUME ES:NOTHING                ;AN000;
  ASSUME SS:NOTHING                ;AN000;

  PUSH AX                          ;AN000;SAVE FAILING DRIVE NUMBER (A:=0, B:=1, ETC)
  PUSHF                            ;AN000;SAVE THE FLAGS
				   ;(THIS IS NEEDED BECAUSE THE OLD INT 24
				   ;  HANDLER WILL EXIT WITH AN "IRET")
  CALL DWORD PTR OLDINT24          ;AN000;INVOKE THE DOS ERROR HANDLER
				   ;RESPONSE WILL BE RETURNED IN AL
				   ;AL=0=IGNORE
				   ;AL=1=RETRY
				   ;AL=2=ABORT
				   ;AL=3=FAIL
  CMP  AL,ABORT                    ;AN000;DID USER SAY ABORT ?
; $IF  GE                          ;AN000;YES, PROCESS "ABORT"
  JNGE $$IF115
      PUSH CS                      ;AN000;SET UP SEGREGS
      PUSH CS                      ;AN000; SO "RESTORE" WILL LIKE THEM
      POP  ES                      ;AN000;
      POP  DS                      ;AN000;
      ASSUME DS:CSEG,ES:CSEG       ;AN000;TELL THE ASSEMBLER WHAT I JUST DID
      POP  AX                      ;AN007;GET AL=FAILING DRIVE NUMBER
      MOV  AH,START_DRIVE          ;AN007;GET THE TARGET DRIVE BEING USED
      SUB  AH,DRIVEA               ;AN007; A:=0, B:=1, ETC
      CMP  AH,AL                   ;AN007;IS START DRIVE SAME AS FAILING DRIVE?
;     $IF  E                       ;AN007;IF SAME DRIVE
      JNE $$IF116
	  OR   FLAGS,F_FAILING     ;AN007;REQUEST CHDIR ON FAILING DRIVE NOT TO BE DONE
;     $ENDIF                       ;AN007;
$$IF116:

      CALL RESTORE                 ;AN000;RESTORE ORIGINAL CONDITIONS

      DOSCALL RET_CD_EXIT,EXABORT  ;AN000;QUIT, RETURN ERRORLEVEL CODE TO DOS
; = = = = = = = = = = = = = = = = =
; $ENDIF                           ;AN000;
$$IF115:
  ADD  SP,WORD                     ;AC009;UNDO THE PUSH AX ABOVE
  IRET                             ;AN000;
MYERRORHANDLER ENDP                ;AN000;
; =  =  =  =  =  =  =  =  =  =  =  =



  HEADER <CHK_DBCS -SEE IF SPECIFIED BYTE IS A DBCS LEAD BYTE> ;AN012;
;*****************************************************************************
; Check DBCS environment
;*****************************************************************************

; Function: Check if a specified byte is in ranges of the DBCS lead bytes
; Input:    AL = Code to be examined
; Output:   If CF is on then a lead byte of DBCS
; Register: FL is used for the output, others are unchanged.

  PUBLIC CHK_DBCS                  ;AN012;
Chk_DBCS PROC                      ;AN012;
  PUSH DS                          ;AN012;save these regs, about to be clobbered
  PUSH SI                          ;AN012;
  LDS  SI,DBCSENV                  ;AN012;GET VECTOR OF DBCS RANGES

  ASSUME DS:NOTHING                ;AN012;that function clobbered old DS

  OR   SI,SI                       ;AN012;IS THIS VECTOR SET YET?
; $IF  Z                           ;AN012;NO, GO GET THE VECTOR
  JNZ $$IF119
      PUSH AX                      ;AN012;
      DOSCALL DBCS_ENV,GET_DBCS_ENV ;AN012;SET DS:SI TO POINT TO DBCS VECTOR

      MOV  WORD PTR DBCSENV,SI     ;AN012;SAVE THE DBCS VECTOR OFFSET
      MOV  WORD PTR DBCSENV+WORD,DS ;AN012; AND ITS SEGID
      POP  AX                      ;AN012;REGAIN THE CHAR TO BE CHECKED
; $ENDIF                           ;AN000;
$$IF119:
; $SEARCH                          ;AN012;
$$DO121:
      CMP  WORD PTR [SI],NUL       ;AN012;vector ends with a nul terminator entry
; $LEAVE E                         ;AN012;if that was the terminator entry, quit
  JE $$EN121
      CMP  AL,[SI]                 ;AN012;look at LOW value of vector
; $EXITIF NB,AND                   ;AN012;if this byte is in range with respect to LOW
  JB $$IF121
      CMP  AL,[SI+1]               ;AN012;look at HIGH value of vector
; $EXITIF NA                       ;AN012;if this byte is still in range
  JA $$IF121
      STC                          ;AN012;set flag to say, found a DBCS char.
; $ORELSE                          ;AN012;since char not in this vector
  JMP SHORT $$SR121
$$IF121:
      ADD  SI,WORD                 ;AN012;go look at next vector in dbcs table
; $ENDLOOP                         ;AN012;go back and check out new vector entry
  JMP SHORT $$DO121
$$EN121:
      CLC                          ;AN012;set flag to say this is not a DBCS character
; $ENDSRCH                         ;AN012;
$$SR121:
  POP  SI                          ;AN012;restore the regs
  POP  DS                          ;AN012;

  ASSUME DS:CSEG                   ;AN012;tell masm, DS back to normal

  RET                              ;AN012;
Chk_DBCS ENDP                      ;AN012;
; =  =  =  =  =  =  =  =  =  =  =  =



ifdef JAPAN
; Kanji graphic characters
KANJI_ELBO      equ     0a484h          ; 84a4h
KANJI_DASH      equ     09f84h          ; 849fh
KANJI_TEE       equ     0a584h          ; 84a5h
KANJI_BAR       equ     0a084h          ; 84a0h

;
;       convert graphic character to kanji
;
;       input:  DX = buffer address
;               CX = length
;
conv_graph      proc    near
	push    ax
	push    cx
	push    si
	mov     al,A_Graf_Elbow
	cmp     al,Graf_Elbow
	jz      cg_ret                  ; if it is in ascii mode
	mov     si,dx
cg_loop:
	lodsb
	cmp     al,Graf_Elbow
	jz      cg_elbo
	cmp     al,GRAF_DASH
	jz      cg_dash
	cmp     al,GRAF_TEE
	jz      cg_tee
	cmp     al,GRAF_BAR
	jz      cg_bar
cg_next:
	loop    cg_loop
cg_ret:
	pop     si
	pop     cx
	pop     ax
	ret

cg_elbo:
	mov     word ptr [si-1],KANJI_ELBO
	jmp     short cg_adj
cg_dash:
	mov     word ptr [si-1],KANJI_DASH
	jmp     short cg_adj
cg_tee:
	mov     word ptr [si-1],KANJI_TEE
	jmp     short cg_adj
cg_bar:
	mov     word ptr [si-1],KANJI_BAR
cg_adj:
	inc     si
	dec     cx
	jmp     short cg_next
conv_graph      endp

endif
; =  =  =  =  =  =  =  =  =  =  =  =


PATHLABL TREE              ;AN013;

CSEG ENDS                  ;AN000;

END  START                 ;AN000;


=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\tree\treesysp.asm ===
PAGE	90,132			;AN000
	TITLE	TREESYSP.SAL - INCLUDES THE COMMON SYSTEM PARSER ;AN000;

;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

;****************** START OF SPECIFICATIONS *****************************
; MODULE NAME: TREESYSP.SAL
;
; DESCRIPTIVE NAME: Include the DOS system PARSER
;
;FUNCTION: The common code of the DOS command line PARSER is optimized by
;	   the setting of certain switches that cause the conditional
;	   assembly of only the required portions of the common PARSER.
;	   The segment registers are ASSUMED according to the type .COM.
;	   The Common PARSER is then INCLUDEd.
;
; ENTRY POINT: SYSPARSE, near
;
; INPUT:
;	ES - has seg id of the SEGMENT
;	     that contains the input control blocks,
;	     defined below.
;
;	DI - offset into ES of the PARMS INPUT BLOCK
;
;	DS - has seg id of the SEGMENT
;	     that contains the DOS input COMMAND
;	     string, which is originally presented at 81h
;	     in the PSP.
;
;	SI - offset into DS of the text of the DOS input COMMAND string
;	     as originally presented at 81H in the PSP.
;
;	DX - zero
;
;	CX - ordinal value, intially zero, updated on each subsequent call
;	     to the value returned in CX on the previous call.
;
;	CS - points to the segment containing the
;	     INCLUDE PARSE.ASM statement
;
;	DS - also points to the segment containing the INCLUDE
;	     PARSE.ASM statement.
;
; EXIT-NORMAL:	Output registers:
;	 AX - return code:
;	    RC_No_Error     equ     0	 ; No error
;	    RC_EOL	    equ     -1	 ; End of command line
;
;	 DX - Offset into ES of the selected RESULT BLOCK.
;	 BL - terminated delimiter code
;	 CX - new operand ordinal
;	 SI - set past scanned operand
;
; EXIT-ERROR: Output registers:
;	 AX - return code:
;	    RC_Too_Many     equ     1	 ; Too many operands
;	    RC_Op_Missing   equ     2	 ; Required operand missing
;	    RC_Not_In_SW    equ     3	 ; Not in switch list provided
;	    RC_Not_In_Key   equ     4	 ; Not in keyword list provided
;	    RC_Out_Of_Range equ     6	 ; Out of range specified
;	    RC_Not_In_Val   equ     7	 ; Not in value list provided
;	    RC_Not_In_Str   equ     8	 ; Not in string list provided
;	    RC_Syntax	    equ     9	 ; Syntax error
;
; INCLUDED FILES: PARSE.ASM - System Parser
;		  PSDATA.INC - Equates and workareas used by PARSE.ASM
;		  PATHMAC.INC - PATHGEN MACRO
;
; INTERNAL REFERENCES:
;    ROUTINES: SYSPARSE:near (INCLUDEd in PARSE.ASM)
;
;    DATA AREAS: none
;
; EXTERNAL REFERENCES:
;    ROUTINES: none
;
;    DATA AREAS: control blocks pointed to by input registers.
;
; NOTES:
;	 This module should be processed with the SALUT preprocessor
;	 with the re-alignment not requested, as:
;
;		SALUT TREESYSP,NUL,;
;
;	 To assemble these modules, the alphabetical or sequential
;	 ordering of segments may be used.
;
;	 For LINK instructions, refer to the PROLOG of the main module,
;	 TREE.SAL.
;
;****************** END OF SPECIFICATIONS *****************************
	IF1				;AN000;
            ;%out    COMPONENT=TREE, MODULE=TREESYSP.SAL... ;AN000;
	ENDIF				;AN000;

	INCLUDE PATHMAC.INC		;AN013;

CSEG	SEGMENT PARA PUBLIC 'CODE'	;AN000;
	ASSUME	CS:CSEG 		;AN000;ESTABLISHED BY CALLER
	ASSUME	SS:CSEG 		;AN000;ESTABLISHED BY CALLER
	ASSUME	DS:CSEG 		;AN000;ESTABLISHED BY CALLER
	ASSUME	ES:CSEG 		;AN000;ESTABLISHED BY CALLER

	PUBLIC	SYSPARSE		;AN000;SUBROUTINE ENTRY POINT

DATESW	=	0			;AN000;SUPPRESS DATE CHECKING
TIMESW	=	0			;AN000;SUPPRESS TIME CHECKING
CMPXSW	=	0			;AN000;SUPPRESS CHECKING COMPLEX LIST
NUMSW	=	0			;AN000;SUPPRESS CHECKING NUMERIC VALUE
KEYSW	=	0			;AN000;SUPPRESS KEYWORD SUPPORT
VAL1SW	=	0			;AN000;SUPPRESS SUPPORT OF VALUE DEFINITION 1
VAL2SW	=	0			;AN000;SUPPRESS SUPPORT OF VALUE DEFINITION 2
VAL3SW	=	0			;AN000;SUPPRESS SUPPORT OF VALUE DEFINITION 3
DRVSW	=	0			;AN000;SUPPRESS SUPPORT OF DRIVE ONLY FORMAT
QUSSW	=	0			;AN000;SUPPRESS SUPPORT OF QUOTED STRING FORMAT
BASESW	=	1			;AN012;SPECIFY, PSDATA POINTED TO BY "DS"
INCSW	=	0			;AN013;PSDATA.INC IS ALREADY INCLUDED
	include version.inc
	INCLUDE PSDATA.INC
	PATHLABL TREESYSP		;AN013;
;	INCLUDE PARSE.ASM		 ;GENERATED CODE SUPPRESSED FROM LISTING
.XLIST					;AN000;
.XCREF					;AN000;
	INCLUDE PARSE.ASM		;AN000;
.LIST					;AN000;
.CREF					;AN000;
	PATHLABL TREESYSP		;AN013;
CSEG	ENDS				;AN000;
	END				;AN000;


=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\tree\treepar.asm ===
PAGE	,132			;AN000
	TITLE	TREEPAR.SAL - PARSE THE DOS COMMAND LINE ;AN000;

;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

;****************** START OF SPECIFICATIONS *****************************
; MODULE NAME: TREEPAR.SAL
;
; DESCRIPTIVE NAME: Handle the definition of the DOS command line parameters
;		    and the interface to the DOS system PARSER.
;
;FUNCTION: The static data areas are prescribed by the DOS system PARSER
;	   to define the several parameters presented to TREE.	These
;	   data areas are passed to the PARSER, and its responses checked
;	   to determine the nature of the user's specifications.  Any errors
;	   found in the user's parameters are defined in messages back
;	   to the user.
;
; ENTRY POINT: PARSER, near
;
; INPUT: (DOS COMMAND LINE PARAMETERS)
;
;	      [d:][path] TREE [D:][path] [/F] [/A]

;	 WHERE
;	      [d:][path] - Path where the TREE command resides.

;	      [D:][path] - Display of subdirectories starts with this
;			   specified subdirectory.  If this is not
;			   specified, the default is the drive root directory.

;	      [/F]	 - This requests the files in each subdirectory
;			   in addition to the subdirectories themselves
;			   are to be listed.
;
;	      [/A]	  -This requests use of alternate char in place of graphics.
;
;	Upon entry to PARSER in this module,
;	"CURRENT_PARM" = offset to start of parm text in command string
;	"ORDINAL" = initialized to zero
;	PSP+81H = text of DOS command line parms string

; EXIT-NORMAL: Carry flag is clear.

; EXIT-ERROR: Carry flag is set.  Parse error msg has been displayed.

; INTERNAL REFERENCES:
;    ROUTINES:
;	PARSE_ERROR:NEAR Display the appropriate Parse error message.

;    DATA AREAS:
;	The several parameter control blocks, defined by the System
;	PARSER interface, defining the TREE parameters.
;	INCLUDE PATHMAC.INC - PATHGEN MACRO

; EXTERNAL REFERENCES:
;    ROUTINES:
;	SENDMSG:NEAR	Uses Msg Descriptor to drive message handler.
;	SYSPARSE:NEAR	System Command Line Common Parser.
;
;    DATA AREAS:
;	EXITFL:BYTE	Errorlevel return code.
;	MSGNUM_PARSE:WORD Message descriptor for all parse errors.
;
; NOTES:
;	 This module should be processed with the SALUT preprocessor
;	 with the re-alignment not requested, as:
;
;		SALUT TREEPAR,NUL
;
;	 To assemble these modules, the alphabetical or sequential
;	 ordering of segments may be used.
;
;	 For LINK instructions, refer to the PROLOG of the main module,
;	 TREE.SAL.
;
;
;****************** END OF SPECIFICATIONS *****************************
	HEADER	<LOCAL MACROS, EQUATES> ;AN000;
	IF1				;AN000;
            ;%out    COMPONENT=TREE, MODULE=TREEPAR.SAL... ;AN000;
	ENDIF				;AN000;
	INCLUDE PATHMAC.INC		;AN012;
; =  =	=  =  =  =  =  =  =  =	=  =
HEADER	MACRO	TEXT			;;AN000;
.XLIST					;;AN000;
	SUBTTL	&TEXT			;;AN000;
.LIST					;;AN000;
	PAGE				;;AN000;
	ENDM				;;AN000;
; =  =	=  =  =  =  =  =  =  =	=  =
	EXTRN	MAX_PATH:ABS		;AN000;MAX LENGTH OF PATH PERMITTED

;		      $SALUT (4,23,28,36) ;AN004;
MSG_DESC	      STRUC	   ;AN004;
MSG_NUM 	      DW   ?	   ;AN004;MESSAGE NUMBER (TO AX)
MSG_HANDLE	      DW   ?	   ;AN004;HANDLE OF OUTPUT DEVICE (TO BX)
MSG_SUBLIST	      DW   ?	   ;AN004;POINTER TO SUBLIST (TO SI)
MSG_COUNT	      DW   ?	   ;AN004;SUBSTITUTION COUNT (TO CX)
MSG_CLASS	      DW   ?	   ;AN004;MESSAGE CLASS (IN HIGH BYTE, TO DH)
				   ; LOW BYTE HAS 0 (FUNCTION "NO INPUT", TO DL);AN004;
MSG_DESC	      ENDS	   ;AN004;

ONE_SUBS	      EQU  1	   ;AN004;NUMBER OF VARIABLES

SUBLIST 	      STRUC	   ;AN000;
SUB_SIZE	      DB   ?	   ;AN004;SUBLIST SIZE (POINTER TO NEXT SUBLIST)
SUB_RES 	      DB   ?	   ;AN004;RESERVED
				   ;NEXT FIELD IS TO BE USED AS A DOUBLE WORD	   ;AN004;
SUB_VALUE	      DW   ?	   ;AN004;TIME, DATE, OR PTR TO DATA ITEM
SUB_VALUE_SEG	      DW   ?	   ;AN004;SEG ID OF PTR
				   ;(ABOVE FIELD MUST BE FILLED AT EXECUTION TIME  ;AN004;
				   ; IF THIS IS A .COM FILE)			   ;AN004;
SUB_ID		      DB   ?	   ;AN004;N OF %N
SUB_FLAGS	      DB   ?	   ;AN004;DATA TYPE FLAGS
SUB_MAX_WIDTH	      DB   ?	   ;AN004;MAXIMUM FIELD WIDTH (0=UNLIMITED)
SUB_MIN_WIDTH	      DB   ?	   ;AN004;MINIMUM FIELD WIDTH
SUB_PAD_CHAR	      DB   ?	   ;AN004;CHARACTER FOR PAD FIELD
				   ; CAN BE " ", "0" OR ",".			   ;AN004;
				   ; "," CAUSES INSERTION OF THE ACTIVE 	   ;AN004;
				   ; THOUSANDS SEPARATOR BETWEEN EVERY 3 DIGITS.   ;AN004;
SUBLIST 	      ENDS	   ;AN004;

;		LOCAL EQUATES

CMD_BUF_SIZE	      EQU  127	   ;AN000;NUMBER BYTES IN DOS COMMAND LINE BUFFER
ZERO		      EQU  0	   ;AN000;COMPARAND FOR CLEARED REG
COLON		      EQU  ":"	   ;AN000;FOLLOWS DRIVE LETTER IN FULL FILESPEC
NUL		      EQU  0	   ;AN000;DELIMITER FOR ASCIIZ STRINGS
BACK_SLASH	      EQU  "\"	   ;AN000;PATH DELIMITER
BLANK		      EQU  " "	   ;AN003;WIPE OUT SWITCH, AVOIDS DUPLICATES

;		EXIT CODES FROM SYSPARSE (WHEN CY=0)

SYSPRM_EX_OK	      EQU  0	   ;AN000; no error
SYSPRM_EX_MANY	      EQU  1	   ;AN000; too many operands
SYSPRM_EX_MISSING     EQU  2	   ;AN000; required operand missing
SYSPRM_EX_NOT_SWLIST  EQU  3	   ;AN000; not in switch list provided
SYSPRM_EX_NOT_KEYLIST EQU  4	   ;AN000; not in keyword list provided
SYSPRM_EX_RANGE       EQU  6	   ;AN000; out of range specified
SYSPRM_EX_VALUE       EQU  7	   ;AN000; not in value list provided
SYSPRM_EX_STRING      EQU  8	   ;AN000; not in string list provided
SYSPRM_EX_SYNTAX      EQU  9	   ;AN000; syntax error
SYSPRM_EX_EOL	      EQU  -1	   ;AN000; end of command line
		      HEADER <EXTRN REFERENCES, LOCAL VARIABLES> ;AN000;
		      EXTRN F_SWITCH:ABS ;AN000;BIT FLAGS TO TURN ON IF /F SPECIFIED



;	      $SALUT (4,15,20,28) ;AN000;
CSEG	      SEGMENT PARA PUBLIC 'CODE' ;AN000;
	      ASSUME CS:CSEG,DS:CSEG,ES:CSEG,SS:CSEG ;AN000;ESTABLISHED BY CALLER

;WHERE THE PARMS COME FROM:
	      EXTRN COMMAND:BYTE ;AN000;DOS INPUT COMMAND LINE PARMS

;WHERE THE PARMS GO:
	      EXTRN FLAGS:BYTE ;AN000;HAS INDICATOR FOR /F
			   ; WHERE F_SWITCH BIT GOES
	      EXTRN START_DRIVE:BYTE ;AN000;LETTER OF DRIVE BEING RESEARCHED
	      EXTRN START_PATH:BYTE ;AN000;PATH OF START OF CHAIN BEING RESEARCHED
	      EXTRN GRAF_TABLE:BYTE ;AN002;TABLE OF GRAPHIC CHARACTERS
	      EXTRN GRAF_TABLE_ALT:BYTE ;AN002;ALTERNATE SET OF GRAPHIC CHARACTERS

;MESSAGES USED:
	      EXTRN MSGNUM_PARSE:WORD ;AN000;MSG DESCRIPTOR FOR PARSE ERRORS
	      EXTRN SUBLIST_PARSE:WORD ;AN004;POINTS TO INVALID PARM
	      EXTRN MSGNUM_INVPATH:WORD ;AN000;"INVALID PATH" COMMON MESSAGE
	      EXTRN MSGNUM_OPTIONS: WORD	; Options Help Message
	      EXTRN MSG_OPTIONS_FIRST : ABS	; number of first msg
	      EXTRN MSG_OPTIONS_LAST  : ABS	; number of last msg

;EXTERNAL SUBROUTINES USED:
	      EXTRN SYSPARSE:NEAR ;AN000;COMMAND LINE PARM PARSER
	      EXTRN SENDMSG:NEAR ;AN000;USES MSG DESCRIPTOR TO DRIVE MESSAGE HANDLR
	      EXTRN SCAN_DBCS:NEAR ;AN012;GET LAST TWO CHARS OF STRING

CURRENT_PARM  DW   ?	   ;AN000;POINTER INTO COMMAND OF NEXT OPERAND
	      PUBLIC CURRENT_PARM ;AN000;

ORDINAL       DW   ?	   ;AN000;ORDINAL NUMBER OF WHICH PARM TO PARSE
	      PUBLIC ORDINAL ;AN000;


; INPUT: (DOS COMMAND LINE PARAMETERS)

;	      [d:][path] TREE [D:][path] [/F] [/A]

;	 WHERE
;	      [d:][path] - Path where the TREE command resides.

;	      [D:][path] - Display of subdirectories starts with this
;			   specified subdirectory.  If this is not
;			   specified, the default is the drive root directory.

;	      [/F]	 - This requests the files in each subdirectory
;			   in addition to the subdirectories themselves
;			   are to be listed.

;	      [/A]	 - This requests use of alternate graphic chars
; = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
	      HEADER <PARSE CONTROL BLOCKS DEFINING PARMS> ;AN000;
;INPUT PARAMETERS CONTROL BLOCK, POINTED TO BY ES:DI WHEN CALLING PARSER

PARMS	      LABEL BYTE   ;AN000;PARMS CONTROL BLOCK
	      DW   PARMSX  ;AN000;POINTER TO PARMS EXTENSION
	      DB   0	   ;AN000; NUMBER OF STRINGS (0, 1, 2)
			   ; NEXT LIST WOULD BE EXTRA DELIM LIST
			   ;  (,& WHITESPACE ALWAYS)
			   ; NEXT LIST WOULD BE EXTRA END OF LINE LIST
			   ;  (CR,LF,0 ALWAYS)

PARMSX	      LABEL BYTE   ;AN000;PARMS EXTENSION CONTROL BLOCK
	      DB   0,1	   ;AN000; MIN, MAX POSITIONAL OPERANDS ALLOWED
	      DW   CONTROL_POS ;AN000; DESCRIPTION OF POSITIONAL 1

	      DB   2	   ;AN000; MAX SWITCH OPERANDS ALLOWED
	      DW   CONTROL_SW  ;AN000; DESCRIPTION OF SWITCH 1
	      DW   CONTROL_SW2 ;       DESCRIPTION OF SWITCH 2

	      DB   0	   ;AN000; MAX KEYWORD OPERANDS ALLOWED
			   ; THERE IS NO CONTROL BLOCK
			   ;  DEFINING KEYWORDS

; = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =

;PARSER CONTROL BLOCK DEFINING THE ONLY POSITIONAL PARAMETER, OPTIONAL

;FIRST POSITIONAL PARAMETER IS:
;	[D:][PATH]

CONTROL_POS   LABEL BYTE   ;AN000;FIRST POSITIONAL DESCRIPTOR FOR FILESPEC,
			   ; OPTIONAL
	      DW   0201H   ;AN000; CONTROLS TYPE MATCHED
			   ; SELECTED BITS: "FILE SPEC" AND "OPTIONAL"

			   ; 8000H=NUMERIC VALUE, (VALUE LIST WILL BE CHECKED)
			   ; 4000H=SIGNED NUMERIC VALUE (VALUE LIST WILL BE
			   ;   CHECKED)
			   ; 2000H=SIMPLE STRING(VALUE LIST WILL BE CHECKED)
			   ; 1000H=DATE STRING (VALUE LIST WON'T BE CHECKED)
			   ; 0800H=TIME STRING (VALUE LIST WON'T BE CHECKED)
			   ; 0400H=COMPLEX LIST (VALUE LIST WON'T BE CHECKED)
			   ; 0200H=FILE SPEC (VALUE LIST WON'T BE CHECKED)
			   ; 0100H=DRIVE ONLY (VALUE LIST WON'T BE CHECKED)
			   ; 0080H=QUOTED STRING (VALUE LIST WON'T BE CHECKED)
			   ; 0010H=IGNORE ":" AT END IN MATCH
			   ; 0002H=REPEATS ALLOWED
			   ; 0001H=OPTIONAL

	      DW   0001H   ;AN000;FUNCTION_FLAGS
			   ; 0001H=CAP RESULT BY FILE TABLE
			   ; 0002H=CAP RESULT BY CHAR TABLE
			   ; 0010H=REMOVE ":" AT END
	      DW   RESULT1 ;AN000; RESULT BUFFER
	      DW   NOVALS  ;AN000; VALUE LISTS
	      DB   0	   ;AN000; NUMBER OF KEYWORD/SWITCH SYNONYMS
			   ;   IN FOLLOWING LIST


NOVALS	      LABEL BYTE   ;AN000;
	      DB   0	   ;AN000; NUMBER OF VALUE DEFINITIONS (0 - 3)

RESULT1       LABEL BYTE   ;AN000; BELOW FILLED IN FOR DEFAULTS
	      DB   5	   ;AN000; TYPE RETURNED: 0=RESERVED,
			   ;	   1=NUMBER, 2=LIST INDEX,
			   ;	   3=STRING, 4=COMPLEX,
			   ;	   5=FILESPEC, 6=DRIVE
			   ;	   7=DATE, 8=TIME
			   ;	   9=QUOTED STRING
	      DB   0FFH    ;AN000; MATCHED ITEM TAG
	      DW   0	   ;AN000;POINTER TO SYNONYM

RESULT_PTR1   DD   ?	   ;AN000; OFFSET OF STRING VALUE


; = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =

;PARSER CONTROL BLOCK DEFINING THE SWITCHES, OPTIONAL

;SWITCH IS "/F".  WHEN REQUESTED, IT MEANS TO LIST ALL FILE
;NAMES IN EVERY DIRECTORY BEING TRACED.
;THE OTHER SWITCH IS "/A". IT MEANS TO USE THE ALTERNATE SET OF GRAPHIC CHARS.

CONTROL_SW    LABEL BYTE   ;AN000;SWITCH DESCRIPTOR
	      DW   0000H   ;AN000; CONTROLS TYPE MATCHED
			   ; 8000H=NUMERIC VALUE, (VALUE LIST WILL BE CHECKED)
			   ; 4000H=SIGNED NUMERIC VALUE (VALUE LIST WILL BE
			   ;   CHECKED)
			   ; 2000H=SIMPLE STRING(VALUE LIST WILL BE CHECKED)
			   ; 1000H=DATE STRING (VALUE LIST WON'T BE CHECKED)
			   ; 0800H=TIME STRING (VALUE LIST WON'T BE CHECKED)
			   ; 0400H=COMPLEX LIST (VALUE LIST WON'T BE CHECKED)
			   ; 0200H=FILE SPEC (VALUE LIST WON'T BE CHECKED)
			   ; 0100H=DRIVE ONLY (VALUE LIST WON'T BE CHECKED)
			   ; 0080H=QUOTED STRING (VALUE LIST WON'T BE CHECKED)
			   ; 0010H=IGNORE ":" AT END IN MATCH
			   ; 0002H=REPEATS ALLOWED
			   ; 0001H=OPTIONAL

	      DW   0002H   ;AN000;FUNCTION_FLAGS
			   ; 0001H=CAP RESULT BY FILE TABLE
			   ; 0002H=CAP RESULT BY CHAR TABLE
			   ; 0010H=REMOVE ":" AT END

	      DW   RESULTSW1 ;AN000; RESULT BUFFER
	      DW   NOVALS  ;AN000; VALUE LISTS
	      DB   2	   ;AN002; NUMBER OF KEYWORD/SWITCH SYNONYMS
			   ;   IN FOLLOWING LIST
F_SW	      DB   "/F",0  ;AN000; IF n >0, KEYWORD 1
A_SW	      DB   "/A",0  ;AN002; IF n >0, KEYWORD 2



RESULTSW1     LABEL BYTE   ;AN000; BELOW FILLED IN FOR DEFAULTS
	      DB   3	   ;AN000; TYPE RETURNED: 0=RESERVED,
			   ;	   1=NUMBER, 2=LIST INDEX,
			   ;	   3=STRING, 4=COMPLEX,
			   ;	   5=FILESPEC, 6=DRIVE
			   ;	   7=DATE, 8=TIME
			   ;	   9=QUOTED STRING
	      DB   0FFh    ;AN000; MATCHED ITEM TAG

SYNONYM       DW   0	   ;AN000; SYNONYM POINTER (BASED ON ES:)
RESULT_PTR2   DD   ?	   ;AN000; OFFSET OF STRING VALUE

; = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =

;SWITCH IS "/?".  WHEN REQUESTED, IT MEANS TO DISPLAY THE
;OPTIONS HELP MESSAGE AND EXIT.

CONTROL_SW2   LABEL BYTE
	      DW   0		; MATCH MASK
	      DW   0		; FUNC MASK
	      DW   RESULTSW2	; ptr to RESULT BUFFER
	      DW   NOVALS	; ptr to VALUE LIST
	      DB   1		; # of SYNONYMS FOLLOWING
SW2_SYN	      DB   "/?",0	; TEXT OF SYNONYM 1


RESULTSW2     LABEL BYTE
	      DB   0		; TYPE
	      DB   0		; TAG
SYNONYM2      DW   0		; ptr to SYNONYM FOUND
              DD   ?		; padding...

	      PATHLABL TREEPAR ;AN013;
; =  =	=  =  =  =  =  =  =  =	=  =



	      HEADER <PARSER - DRIVE SYSPARSE, VERIFY RESULTS> ;AN000;
;  $SALUT (4,4,9,36)		   ;AN000;
PARSER PROC NEAR		   ;AN000;
   PUBLIC PARSER		   ;AN000;

;INPUT: "CURRENT_PARM" = OFFSET TO NEXT PARM IN COMMAND STRING
;	"ORDINAL" = COUNT OF NEXT PARM TO PARSE
;	"COMMAND" = TEXT OF DOS COMMAND LINE PARMS STRING
;OUTPUT: CARRY IS SET IF THERE WAS A PROBLEM, AX HAS PARSE RET CODE.
;	 CARRY IS CLEAR IF ALL OK WITH THE PARMS
;THE PSP IS NOT REFERENCED, SINCE THE PARMS HAVE BEEN MOVED OUT OF THERE.
; =  =	=  =  =  =  =  =  =  =	=  =

;  $SEARCH COMPLEX		   ;AN000;LOOP THRU COMMAND LINE
   JMP SHORT $$SS1
$$DO1:
       MOV  ORDINAL,CX		   ;AN000;SAVE UPDATED COUNT

				   ;LOOKING AT RETURN CODE IN AX,
				   ; JUST PRODUCED BY SYSPARSE...
       CMP  AX,ZERO		   ;AN000;WERE THERE ANY ERRORS?
;      $IF  NE			   ;AN000;HAD A PROBLEM FOUND BY SYSPARSE
       JE $$IF2
	   CALL PARSE_ERROR	   ;AN000;DISPLAY REASON FOR ERROR

	   STC			   ;AN000;SET CARRY TO INDICATE ERROR
;      $ELSE			   ;AN000;SINCE OK BY SYSPARSE
       JMP SHORT $$EN2
$$IF2:
	   MOV	CURRENT_PARM,SI    ;AN000;REMEMBER HOW FAR I GOT
	   CALL CHECK_PATH	   ;AN000;SEE IF A GOOD PATH WAS SPECIFIED
				   ;OUTPUT: CY SET IF ERROR
;      $ENDIF			   ;AN000;
$$EN2:
;  $EXITIF C,NUL		   ;AN000;HAD A PROBLEM WITH THE PARMS
   JC $$SR1

				   ;SINCE ALL OK SO FAR, CONTINUE
;  $STRTSRCH			   ;AN000;ENTRY POINT INTO THE SEARCH LOOP
$$SS1:
       LEA  DI,PARMS		   ;AN000; ES:DI = PARSE CONTROL DEFINITON
       MOV  SI,CURRENT_PARM	   ;AN000; DS:SI = COMMAND STRING, NEXT PARM
       XOR  DX,DX		   ;AN000; RESERVED, INIT TO ZERO
       MOV  CX,ORDINAL		   ;AN000; OPERAND ORDINAL, INITIALLY ZERO
       CALL SYSPARSE		   ;AN000;
				   ; AX=EXIT CODE
				   ; BL=TERMINATED DELIMITER CODE
				   ; CX=NEW OPERAND ORDINAL
				   ; SI=SET TO PAST SCANNED OPERAND
				   ; DX=SELECTED RESULT BUFFER
       CMP  AX,SYSPRM_EX_EOL	   ;AN000; IS THAT THE END OF THE PARMS?
				   ;IF NOT, LOOP BACK AND FIND OUT
				   ; WHAT THAT PARM IS
;  $ENDLOOP E			   ;AN000;END OF LIST
   JNE $$DO1
       CLC			   ;AN000;SAY ALL OK
;  $ENDSRCH			   ;AN000;
$$SR1:
   RET				   ;AN000;RETURN TO CALLER
PARSER ENDP			   ;AN000;
; =  =	=  =  =  =  =  =  =  =	=  =



   HEADER <CHECK_PATH - SEE IF THE PATH IS OK> ;AN000;
;MOVE THE PATH STRING FROM RESULT BUFFER TO "START_DRIVE" AND "START_PATH",
;VERIFY THE LENGTH OF THE PATH AS BEING WITHIN LIMITS.
;CHECK FOR THE /F SWITCH, SETTING "FLAGS" (F_SWITCH BIT ON) IF /F SPECIFIED.

;INPUT: DX AS SET BY SYSPARSE, POINTS TO RESULT BUFFER
;OUTPUT: CY SET IF PROBLEM, CY CLEAR IF ALL OK
; =  =	=  =  =  =  =  =  =  =	=  =

CHECK_PATH PROC NEAR		   ;AN000;
   PUBLIC CHECK_PATH		   ;AN000;

   MOV	BX,DX			   ;AN000;SET DATA BASE REG TO POINT TO THIS OPERAND
   CMP	BX,OFFSET RESULT1	   ;AN000;WAS PATH SPECIFIED?
;  $IF	E			   ;AN000;IF PATH SPECIFIED,
   JNE $$IF9
       MOV  SI,WORD PTR RESULT_PTR1 ;AN000;GET WHERE THE STRING IS
       CMP  BYTE PTR [SI]+1,COLON ;AN000;DOES PATH START WITH DRIVE?
;      $IF  E			   ;AN000;STARTS WITH DRIVE
       JNE $$IF10
	   LEA	DI,START_DRIVE	   ;AN000;MOVE PARM TO STARTUP FILESPEC
	   LODSB		   ;AN000;MOVE THE DRIVE ID
	   STOSB		   ;AN000; INTO "START_DRIVE"
	   INC	SI		   ;AN000;STEP SOURCE INDEX OVER COLON
	   INC	DI		   ;AN000;STEP DEST INDEX OVER COLON
;      $ELSE			   ;AN000;DOES NOT START WITH DRIVE
       JMP SHORT $$EN10
$$IF10:
	   LEA	DI,START_PATH	   ;AN000;MOVE PARM TO STARTUP FILESPEC
;      $ENDIF			   ;AN000;PATH HAVE DRIVE?
$$EN10:

       PUSH SI			   ;AN012;SAVE WHERE STRING STARTS
       CALL SCAN_DBCS		   ;AN012;SCAN STRING FOR DBCS
				   ;DL=LAST CHAR, DH=NEXT TO LAST CHAR
       POP  SI			   ;AN012;RESTORE POINTER TO START OF STRING
				   ;NOW TO GET THE PATH ITSELF

       MOV  CX,MAX_PATH 	   ;AN000;SET THE LIMIT OF PATH LENGTH
       INC  CX			   ;AN000; INCLUDING THE NUL AT THE END
;      $SEARCH COMPLEX		   ;AN000;
       JMP SHORT $$SS13
$$DO13:
	   STOSB		   ;AN000;PUT THIS CHAR INTO "START_PATH"
;      $STRTSRCH		   ;AN000;
$$SS13:
	   LODSB		   ;AN000;GET A CHAR FROM PARSED STRING
	   CMP	AL,NUL		   ;AN000;IS THIS THE DELIMITER?
;      $EXITIF E		   ;AN000;NORMAL END OF STRING FOUND
       JNE $$IF13
	   CMP	DL,BACK_SLASH	   ;AN012;IS PREV CHAR A BACKSLASH?
;	   $IF	E,AND		   ;AN012;YES, PREV CHAR WAS A BACKSLASH
	   JNE $$IF16
	   CMP	DH,BACK_SLASH	   ;AN012;IS CHAR BEFORE THAT A BACKSLASH?
;	   $IF	NE,AND		   ;AN012;NO, CHAR BEFORE THAT WAS NOT A BACKSLASH
	   JE $$IF16
	   CMP	CX,MAX_PATH	   ;AN000;WAS THIS THE ONLY CHAR?
;	   $IF	NE		   ;AN000;NO, NOT THE ONLY ONE
	   JE $$IF16
	       MOV  BYTE PTR [DI-1],NUL ;AN000;CHANGE IT TO A "NUL"
;	   $ENDIF		   ;AN000;
$$IF16:
	   CLC			   ;AN000;FLAG NO ERROR
;      $ORELSE			   ;AN000;CHECK OUT THIS NEW CHAR
       JMP SHORT $$SR13
$$IF13:
;      $ENDLOOP LOOP		   ;AN000;GO BACK AND SAVE IT, IF ROOM
       LOOP $$DO13
	   LEA	DI,MSGNUM_INVPATH  ;AN000;"INVALID PATH"
	   CALL SENDMSG 	   ;AN000;DISPLAY THE MESSAGE

	   STC			   ;AN000;FLAG AN ERROR
;      $ENDSRCH 		   ;AN000;
$$SR13:

;  $ELSE			   ;AN000;FILESPEC NOT SPECIFIED
   JMP SHORT $$EN9
$$IF9:

       CMP  [SYNONYM2], offset SW2_SYN	; was /? specified?
       JNE  CP_OPTIONS_DONE		;  skip if not
       CALL DISPLAY_OPTIONS		; else show options to user
       STC				; flag that it's time to leave
       JMP  SHORT CHECK_PATH_RET	;  and exit
CP_OPTIONS_DONE:

       MOV  AX,SYNONYM		   ;AN002;GET SYNONYM POINTER
       CMP  AX,OFFSET F_SW	   ;AN002;WAS THE SWITCH /F?
;      $IF  E			   ;AN002;IF /F
       JNE $$IF22
	   MOV	F_SW,BLANK	   ;AN003;STRIKE THE /F FROM THE LIST OF SWITCHES
	   OR	FLAGS,F_SWITCH	   ;AN000;REQUEST LISTING OF FILENAMES
	   CLC			   ;AN000;NO ERROR
;      $ELSE			   ;AN002;SINCE NOT /F, MUST BE /A
       JMP SHORT $$EN22
$$IF22:
	   MOV	A_SW,BLANK	   ;AN003;STRIKE THE /A FROM THE LIST OF SWITCHES
	   MOV	AX,WORD PTR GRAF_TABLE_ALT ;AN002;PICK UP THE ALTERNATE SET
	   MOV	WORD PTR GRAF_TABLE,AX ;AN002; OF GRAPHICS CHARACTERS
	   MOV	AX,WORD PTR GRAF_TABLE_ALT+WORD ;AN002; AND MOVE THEM TO
	   MOV	WORD PTR GRAF_TABLE+WORD,AX ;AN002; THE TABLE OF GRAPHICS TO BE USED
;      $ENDIF			   ;AN002;
$$EN22:
;  $ENDIF			   ;AN000;FILESPEC?
$$EN9:
CHECK_PATH_RET:
   RET				   ;AN000;RETURN TO CALLER
CHECK_PATH ENDP 		   ;AN000;
; =  =	=  =  =  =  =  =  =  =	=  =



   HEADER <PARSE_ERROR - DISPLAY ERROR MSG FOR PARSER> ;AN000;
PARSE_ERROR PROC NEAR		   ;AN000;
   PUBLIC PARSE_ERROR		   ;AN000;

;INPUT: AX - ERROR NUMBER RETURNED FROM PARSE.
;	SI - OFFSET INTO COMMAND OF FIRST BYTE BEYOND PARM IN ERROR
;	"CURRENT_PARM" - OFFSET INTO COMMAND OF WHERE TO START LOOKING FOR PARM
; =  =	=  =  =  =  =  =  =  =	=  =

   MOV	MSGNUM_PARSE,AX 	   ;AN000;SET THE ERROR NUMBER
   MOV	AX,CURRENT_PARM 	   ;AN004;GET POINTER TO START OF BAD PARM
   CMP	SI,AX			   ;AN004;HAS THE INDEX TO COMMAND LINE MOVED?
;  $IF	NE			   ;AN004;YES, THERE IS A FAULTY PARM
   JE $$IF26
       MOV  BYTE PTR [SI],NUL	   ;AN004;DELIMIT THE BAD PARM
       MOV  SUBLIST_PARSE.SUB_VALUE,AX ;AN000;POINT SUBLIST TO BAD PARM

       MOV  MSGNUM_PARSE.MSG_SUBLIST,OFFSET SUBLIST_PARSE ;AN004;POINT TO SUBLIST
       MOV  MSGNUM_PARSE.MSG_COUNT,ONE_SUBS ;AN004;SET COUNT OF SUBLISTS TO ONE
;  $ENDIF			   ;AN004;INDEX MOVED?
$$IF26:
   LEA	DI,MSGNUM_PARSE 	   ;AN000;PASS MESSAGE DESCRIPTOR
   CALL SENDMSG 		   ;AN000;DISPLAY ERROR MESSAGE

   RET				   ;AN000;RETURN TO CALLER
PARSE_ERROR ENDP		   ;AN000;
; =  =	=  =  =  =  =  =  =  =	=  =



; =  =	=  =  =  =  =  =  =  =	=  =
   HEADER <DISPLAY_OPTIONS - DISPLAY OPTIONS MSG>
DISPLAY_OPTIONS PROC NEAR
   PUBLIC DISPLAY_OPTIONS

;INPUT:    NO VALUE PASSED
;
;OUTPUT:   NO VALUE RETURNED
;
;FUNCTION: DISPLAYS THE OPTIONS HELP MESSAGE ON STDOUT.
;
; =  =	=  =  =  =  =  =  =  =	=  =

       LEA	DI, MSGNUM_OPTIONS	; get message
DO_LOOP:
       CALL	SENDMSG			; send it
       CMP	MSGNUM_OPTIONS, MSG_OPTIONS_LAST	; last msg?
       JE	DO_DONE			; done if so
       INC	[MSGNUM_OPTIONS]	; else bump msg number
       JMP	SHORT DO_LOOP		;  and go do it
DO_DONE:

	RET
DISPLAY_OPTIONS ENDP
; =  =	=  =  =  =  =  =  =  =	=  =
   PATHLABL TREEPAR		   ;AN013;
CSEG ENDS			   ;AN000;
   END				   ;AN000;


=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\tree\treesysm.asm ===
PAGE	90,132			;AN000
	TITLE	TREESYSM.SAL - INCLUDES THE COMMON SYSTEM MESSAGE HANDLER ;AN000;

;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

;****************** START OF SPECIFICATIONS *****************************
; MODULE NAME: TREESYSM.SAL

; DESCRIPTIVE NAME: Include the DOS system MESSAGE HANDLER in the SEGMENT
;		    configuration expected by the modules of TREE.

;FUNCTION: The common code of the DOS SYSTEM MESSAGE HANDLER is made a
;	   part of the TREE module by using INCLUDE to bring in the
;	   common portion, in SYSMSG.INC.  This included code contains
;	   the routines to initialize for message services, to find
;	   where a particular message is, and to display a message.

; ENTRY POINT: SYSDISPMSG:near
;	       SYSGETMSG:near
;	       SYSLOADMSG:near

; INPUT:
;    AX = MESSAGE NUMBER
;    BX = HANDLE TO DISPLAY TO (-1 means use DOS functions 1-12)
;    SI = OFFSET IN ES: OF SUBLIST, OR 0 IF NONE
;    CX = NUMBER OF %PARMS, 0 IF NONE
;    DX = CLASS IN HIGH BYTE, INPUT FUNCTION IN LOW
;   CALL SYSDISPMSG		;DISPLAY THE MESSAGE

;    If carry set, extended error already called:
;    AX = EXTENDED MESSAGE NUMBER
;    BH = ERROR CLASS
;    BL = SUGGESTED ACTION
;    CH = LOCUS
; _ _ _ _ _ _ _ _ _ _ _ _

;    AX = MESSAGE NUMBER
;    DH = MESSAGE CLASS (1=DOS EXTENDED ERROR, 2=PARSE ERROR, -1=UTILITY MSG)
;   CALL SYSGETMSG		 ;FIND WHERE A MSG IS

;    If carry set, error
;     CX = 0, MESSAGE NOT FOUND
;    If carry NOT set, ok, and resulting regs are:
;     CX = MESSAGE SIZE
;     DS:SI = MESSAGE TEXT
; _ _ _ _ _ _ _ _ _ _ _ _

;   CALL SYSLOADMSG		 ;SET ADDRESSABILITY TO MSGS, CHECK DOS VERSION
;    If carry not set:
;    CX = SIZE OF MSGS LOADED

;    If carry is set, regs preset up for SYSDISPMSG, as:
;    AX = ERROR CODE IF CARRY SET
;	  AX = 1, INCORRECT DOS VERSION
;	  DH =-1, (Utility msg)
;	OR,
;	  AX = 1, Error loading messages
;	  DH = 0, (Message manager error)
;    BX = STDERR
;    CX = NO_REPLACE
;    DL = NO_INPUT

; EXIT-NORMAL: CARRY is not set

; EXIT-ERROR:  CARRY is set
;	       Call Get Extended Error for reason code, for SYSDISPMSG and
;	       SYSGETMSG.

; INTERNAL REFERENCES:
;    ROUTINES: (Generated by the MSG_SERVICES macro)
;	SYSLOADMSG
;	SYSDISPMSG
;	SYSGETMSG

;    DATA AREAS:
;	INCLUDE TREEMS.INC ;message defining control blocks
;	INCLUDE SYSMSG.INC   ;Permit System Message handler definition
;	INCLUDE COPYRIGH.INC ;Standard copy right notice
;	INCLUDE MSGHAN.INC   ;Defines message control blocks STRUCs
;	INCLUDE VERSIONA.INC ;INCLUDEd by code generated by SYSMSG.INC
;	INCLUDE PATHMAC.INC - PATHGEN MACRO

; EXTERNAL REFERENCES:
;    ROUTINES: none

;    DATA AREAS: control blocks pointed to by input registers.

; NOTES:
;	 This module should be processed with the SALUT preprocessor
;	 with the re-alignment not requested, as:

;		SALUT TREESYSM,NUL

;	 To assemble these modules, the alphabetical or sequential
;	 ordering of segments may be used.

;	 For LINK instructions, refer to the PROLOG of the main module,
;	 TREE.SAL.

;
;
;****************** END OF SPECIFICATIONS *****************************
	IF1				;AN000;
            ;%out    COMPONENT=TREE, MODULE=TREESYSM.SAL... ;AN000;
	ENDIF				;AN000;
	INCLUDE PATHMAC.INC		;AN013;

;	INCLUDE SYSMSG.INC
.XLIST					;AN000;
	INCLUDE SYSMSG.INC		;AN000;PERMIT SYSTEM MESSAGE HANDLER DEFINITION
.LIST					;AN000;
	MSG_UTILNAME <TREE>		;AN000;IDENTIFY THE COMPONENT
; =  =	=  =  =  =  =  =  =  =	=  =

CSEG	SEGMENT PARA PUBLIC 'CODE'	;AN000;
	ASSUME	CS:CSEG 		;AN000;ESTABLISHED BY CALLER
	ASSUME	SS:CSEG 		;AN000;ESTABLISHED BY CALLER
	ASSUME	DS:CSEG 		;AN000;ESTABLISHED BY CALLER
	ASSUME	ES:CSEG 		;AN000;ESTABLISHED BY CALLER

	INCLUDE MSGHAN.INC		;AN000;DEFINE MESSAGE HANDLER CONTROL BLOCKS
	INCLUDE TREEMS.INC		;AN000;DEFINE THE MESSAGES, AND CONTROL BLOCKS
	MSG_SERVICES <TREE.CLA,TREE.CL1,TREE.CL2> ;AN000;MESSAGE TEXTS
	MSG_SERVICES <MSGDATA>		;AN000;SYS MSG HANDLER WORKAREAS
; =  =	=  =  =  =  =  =  =  =	=  =
	PUBLIC	SYSLOADMSG		;AN000;
	PUBLIC	SYSDISPMSG		;AN000;
	PUBLIC	SYSGETMSG		;AN002;
;	INCLUDE COPYRIGH.INC		;TO BE INCLUDED BY THE MSG_SERVICES	;AN011;
	PATHLABL TREESYSM		;AN013;
					;DEFAULT=CHECK DOS VERSION
					;DEFAULT=NEARmsg
					;DEFAULT=NO INPUTmsg
					;DEFAULT=NO TIMEmsg
					;DEFAULT=NO DATEmsg
;	MSG_SERVICES <LOADmsg,DISPLAYmsg,GETmsg,CHARmsg,NUMmsg> 		       ;AN027;
.xlist					;AN000;
.xcref					;AN000;
	MSG_SERVICES <LOADmsg,DISPLAYmsg,GETmsg,CHARmsg,NUMmsg> ;AN027; 		     ;AC002;
.cref					;AN000;
.list					;AN000;
; = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
	PATHLABL TREESYSM		;AN013;
LAST_BYTE EQU	$			;AN000;START OF AREA AVAIL FOR STACK
	PUBLIC	LAST_BYTE		;AN000;

include msgdcl.inc

CSEG	ENDS				;AN000;
	END				;AN000;


=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\xcopy\xcopypar.asm ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

;/*************************************************************************
;*                                                                        *
;*  Change History:                                                       *
;*                                                                        *
;*   Date    ID    MSFT #   STR #        Description                      *
;* -----------------------------------------------------------------------*
;*  25JUL90  C06            2133    Parser errors will sometimes not be   *
;*                                  reported correctly (eg. XCOPY Z Z Z is*
;*                                  not reported as invalid number of     *
;*                                  parameters.)                          *
;*                                                                        *
;*  08AUG90  C07          PET 668   Some errors were being printed to     *
;*                                  stdout instead of stderr.             *
;*                                                                        *
;**************************************************************************

	PAGE	,132
	TITLE	XCOPYPAR.SAL - LOOK AT COMMAND LINE PARMS
;****************** START OF SPECIFICATIONS *****************************
; MODULE NAME: XCOPYPAR.SAL
;
; DESCRIPTIVE NAME: Handle the definition of the DOS command line parameters
;		    and the interface to the DOS system PARSER.
;
;FUNCTION: The static data areas are prescribed by the DOS system PARSER
;	   to define the several parameters presented to XCOPY.  These
;	   data areas are passed to the PARSER, and its responses checked
;	   to determine the nature of the user's specifications.  Any errors
;	   found in the user's parameters are defined in messages back
;	   to the user.
;
; ENTRY POINT: PARSER, near
;
; INPUT: (DOS COMMAND LINE PARAMETERS)
;
;	      SOURCE OPERAND:			   TARGET OPERAND:
;
;	      [d:] [path] filename[.ext]	   [d:] [path] [filename[.ext]]
;		or
;	      [d:] path [filename[.ext]]
;		or
;	      d: [path] [filename[.ext]]
;
;	 WHERE
;
;	      [d:] - To specify the Source drive
;
;	      [d:] - To specify the Destination drive
;
;
;	      SWITCHES:
;
;	      /A /D /E /M /P /S /V /W
;
;
;	Upon entry to PARSER in this module,
;	"CURRENT_PARM" = offset to start of parm text in command string
;	"ORDINAL" = initialized to zero
;	PSP+81H = text of DOS command line parms string

; EXIT-NORMAL:

; EXIT-ERROR:

; INTERNAL REFERENCES:
;    ROUTINES:
;	PARSE_ERROR:NEAR Display the appropriate Parse error message.

;    DATA AREAS:
;	The several parameter control blocks, defined by the System
;	PARSER interface, defining the XCOPY parameters.

; EXTERNAL REFERENCES:
;    ROUTINES:
;	SYSPARSE:NEAR	System Command Line Common Parser.
;
;    DATA AREAS:
;	EXITFL:BYTE	Errorlevel return code.
;	MSGNUM_PARSE:WORD Message descriptor for all parse errors.
;
; NOTES:
;	 This module should be processed with the SALUT preprocessor
;	 with the re-alignment not requested, as:
;
;		SALUT XCOPYPAR,NUL
;
;	 To assemble these modules, the alphabetical or sequential
;	 ordering of segments may be used.
;
;	 For LINK instructions, refer to the PROLOG of the main module,
;	 XCOPY.SAL.
;
; REVISION HISTORY: A000 Version 4.00: add PARSER, System Message Handler,
;			 Ignore unique volume serial number differences
;		    A004 PTM0700 9/02/87 Avoid duplicate switches and
;			 display parm in error.
;
;     Label: "The DOS XCOPY Utility"
;
;****************** END OF SPECIFICATIONS *****************************
	IF1
	    %OUT    COMPONENT=XCOPY, MODULE=XCOPYPAR.SAL...
	ENDIF
; =  =	=  =  =  =  =  =  =  =	=  =
HEADER	MACRO	TEXT
.XLIST
	SUBTTL	TEXT
.LIST
	PAGE
	ENDM
; =  =	=  =  =  =  =  =  =  =	=  =
;		      $SALUT (4,23,28,36)
;		LOCAL EQUATES

INIT_ERROR_FLAG       EQU  80H	   ;AN000;critical initialization error. Should abort
CMD_BUF_SIZE	      EQU  127	   ;AN000;NUMBER BYTES IN DOS COMMAND LINE BUFFER
ZERO		      EQU  0	   ;AN000;COMPARAND FOR CLEARED REG
NUL		      EQU  0	   ;AN000;DELIMITER FOR ASCIIZ STRINGS

; =  =	=  =  =  =  =  =  =  =	=  =

;		PARSER ASSEMBLE SWITCHES

FarSW		      EQU  0	   ;AN000;CALL THE PARSER BY FAR CALL
DateSW		      EQU  1	   ;AN000;DATE FORMAT
TimeSW		      EQU  1	   ;AN000;TIME FORMAT
FileSW		      EQU  1	   ;AN000;FILE SPECIFICATION
CAPSW		      EQU  1	   ;AN000;USE FILE TABLE CAPS
CmpxSW		      EQU  0	   ;AN000;COMPLEX LIST
DrvSW		      EQU  1	   ;AN000;DRIVE ONLY FORMAT
QusSW		      EQU  0	   ;AN000;QUOTED STRING
NumSW		      EQU  1	   ;AN000;NUMERIC VALUE
KeySW		      EQU  0	   ;AN000;KEYWORDS
SwSW		      EQU  1	   ;AN000;SWITCHES
Val1SW		      EQU  0	   ;AN000;VALUE DEFINITION #1
Val2SW		      EQU  0	   ;AN000;VALUE DEFINITION #2
Val3SW		      EQU  0	   ;AN000;VALUE DEFINITION #3
; =  =	=  =  =  =  =  =  =  =	=  =
;		EXIT CODES FROM SYSPARSE (WHEN CY=0)

SYSPRM_EX_OK	      EQU  0	   ;AN000; no error
SYSPRM_EX_MANY	      EQU  1	   ;AN000; too many operands
SYSPRM_EX_MISSING     EQU  2	   ;AN000; required operand missing
SYSPRM_EX_NOT_SWLIST  EQU  3	   ;AN000; not in switch list provided
SYSPRM_EX_NOT_KEYLIST EQU  4	   ;AN000; not in keyword list provided
SYSPRM_EX_RANGE       EQU  6	   ;AN000; out of range specified
SYSPRM_EX_VALUE       EQU  7	   ;AN000; not in value list provided
SYSPRM_EX_STRING      EQU  8	   ;AN000; not in string list provided
SYSPRM_EX_SYNTAX      EQU  9	   ;AN000; syntax error
SYSPRM_EX_EOL	      EQU  -1	   ;AN000; end of command line
; =  =	=  =  =  =  =  =  =  =	=  =

		      HEADER <STRUC - DEFINITIONS OF EXTERNAL CONTROL BLOCKS>
;		$SALUT (4,17,22,36)
PSP		STRUC
		DB   80H DUP (?)   ;AN000;SKIP OVER FIRST HALF OF PSP
PSP_PARMLEN	DB   ?		   ;AN000;NUMBER OF BYTES IN DOS COMMAND LINE
PSP_COMMAND	DB   127 DUP(?)    ;AN000;TEXT OF DOS COMMAND LINE
PSP		ENDS
; =  =	=  =  =  =  =  =  =  =	=  =
CSEG		SEGMENT PUBLIC 'CODE'	   ;AN000;PLACE HOLDER FOR PARSE CODE
;C07 EXTRN	        PRINT_STDOUT:NEAR
EXTRN	        PRINT_STDERR:NEAR                                         ;C07
CSEG		ENDS
DGROUP		GROUP DSEG, DSEG_INIT
DSEG		SEGMENT PARA	PUBLIC 'DATA'
DSEG		ENDS
;
DSEG_INIT	SEGMENT PARA PUBLIC 'INIT_DATA'
;
 include version.inc
 INCLUDE PSDATA.INC		   ;AN018;WORK AREA USED BY PARSE.ASM
;
;--- EXTERNAL VARIABLES ---
EXTRN		PARM_FLAG: BYTE    ;AN000;
EXTRN		OPTIONS_SENT: BYTE
EXTRN		ERRORLEVEL: BYTE
EXTRN		ESET: BYTE
EXTRN		SSET: BYTE
EXTRN		QSET: BYTE
EXTRN   	MSG_NUM:WORD			;AN000;MESSAGE NUMBER
EXTRN	        MSG_CLASS:BYTE			;AN000;MESSAGE CLASS
EXTRN	        INPUT_FLAG:BYTE 		;AN000;TYPE INT21 USED FOR KBD INPUT
EXTRN	        SUBST_COUNT:WORD		;AN000;MESSAGE SUBSTITUTION COUNT


		IF1
		    %OUT COMPONENT=XCOPY, SUBCOMPONENT=PARSE
		ENDIF
;---
COMMAND_LINE	DB   127 DUP(?)    ;AN000;TEXT OF DOS COMMAND LINE (INTERNAL USE)
		PUBLIC COMMAND_LINE

CURRENT_PARM	DW   DGROUP:COMMAND_LINE ;AN000;POINTER INTO COMMAND OF NEXT
				   ;OPERAND
		PUBLIC CURRENT_PARM

ORDINAL 	DW   0		   ;AN000;ORDINAL NUMBER OF WHICH PARM TO PARSE
		PUBLIC ORDINAL

TAR_DRIVE	DB   " "	   ;AN000;TARGET DRIVE LETTER SPECIFIED IN PARMS
SO_DRIVE	DB   " "	   ;AN000;SOURCE DRIVE LETTER SPECIFIED
		PUBLIC TAR_DRIVE,SO_DRIVE ;AN000;PASS RESULTS TO INIT ROUTINE

; =  =	=  =  =  =  =  =  =  =	=  =
		HEADER <DOS COMMAND LINE PARSER CONTROL BLOCKS>

;INPUT PARAMETERS CONTROL BLOCK, POINTED TO BY ES:DI WHEN CALLING PARSER

		PUBLIC PARMS	   ;AN000;LET LINK MAKE PARMS BLOCK ADDRESSABLE
PARMS		LABEL BYTE	   ;AN000;PARMS CONTROL BLOCK
		DW   DGROUP:PARMSX ;AN000;POINTER TO PARMS EXTENSION
		DB   0		   ;AN000; NUMBER OF STRINGS (0, 1, 2)
		DB   1		   ;AN000; NUMBER OF ADDITIONAL DELIMITERS
		DB   ";"	   ;AN000; ADDITIONAL DELIMITER


;SYSTEM PARSER PARAMETER EXTENSION CONTROL BLOCK
PARMSX		LABEL BYTE	   ;AN000; PARMS EXTENSION CONTROL BLOCK
		DB   1,2	   ;AN000; MIN, MAX POSITIONAL OPERANDS ALLOWED
		DW   DGROUP:CONTROL_POS1 ;AN000; DESCRIPTION OF POSITIONAL 1
		DW   DGROUP:CONTROL_POS2 ;AN000; DESCRIPTION OF POSITIONAL 2

		DB   3		   ;AN000; THERE ARE 8 SWITCHES IN 2 GROUPS
				   ;AN000; (/A, /E, /M, /P, /S, /V, /W, /D)
		DW   DGROUP:SW1_7  ;AN000; POINTER TO THE  SWITCH DEFINITION AREA
		DW   DGROUP:SW8    ;AN000; POINTER TO EIGHTH SWITCH DEFINITION AREA
		DW   DGROUP:SW9    ;       POINTER TO NINTH  SWITCH DEFINITION AREA

		DB   0		   ;AN000; MAX KEYWORD OPERANDS ALLOWED
				   ;AN000; THERE IS NO CONTROL BLOCK
				   ;AN000; DEFINING KEYWORDS

; = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
		HEADER <POSITIONAL PARM DESCRIPTOR BLOCK>
;PARSER CONTROL BLOCK DEFINING THE ONLY POSITIONAL PARAMETER, OPTIONAL

;FIRST POSITIONAL PARAMETER IS:
;
;	      [d:] [path] filename[.ext]
;		or
;	      [d:] path [filename[.ext]]
;		or
;	      d: [path] [filename[.ext]]
;
		PUBLIC CONTROL_POS1 ;AN000; LET LINK MAKE THIS ADDRESSABLE
CONTROL_POS1	LABEL BYTE	   ;AN000; FIRST POSITIONAL DESCRIPTOR FOR FILESPEC
				   ;AN000;
		DW   0200H	   ;AN000; CONTROLS TYPE MATCHED
				   ; SELECTED BITS: "FILE SPEC"

				   ; 8000H=NUMERIC VALUE, (VALUE LIST WILL BE CHECKED)
				   ; 4000H=SIGNED NUMERIC VALUE (VALUE LIST WILL BE
				   ;   CHECKED)
				   ; 2000H=SIMPLE STRING(VALUE LIST WILL BE CHECKED)
				   ; 1000H=DATE STRING (VALUE LIST WON'T BE CHECKED)
				   ; 0800H=TIME STRING (VALUE LIST WON'T BE CHECKED)
				   ; 0400H=COMPLEX LIST (VALUE LIST WON'T BE CHECKED)
				   ; 0200H=FILE SPEC (VALUE LIST WON'T BE CHECKED)
				   ; 0100H=DRIVE ONLY (VALUE LIST WON'T BE CHECKED)
				   ; 0080H=QUOTED STRING (VALUE LIST WON'T BE CHECKED)
				   ; 0010H=IGNORE ":" AT END IN MATCH
				   ; 0002H=REPEATS ALLOWED
				   ; 0001H=OPTIONAL

		DW   0002H	   ;AN000; FUNCTION_FLAGS
				   ; 0001H=CAP RESULT BY FILE TABLE
				   ; 0002H=CAP RESULT BY CHAR TABLE
				   ; 0010H=REMOVE ":" AT END
		DW   DGROUP:RESULT1 ;AN000; RESULT BUFFER (FIRST)
		PUBLIC RESULT1
		DW   DGROUP:NOVALS ;AN000; NO VALUE LISTS
		DB   0		   ;AN000; NUMBER OF KEYWORD/SWITCH SYNONYMS
				   ;AN000;   IN FOLLOWING LIST

;SECOND POSITIONAL PARAMETER IS:
;
;	      [d:] [path] [filename[.ext]]
;
		PUBLIC CONTROL_POS2 ;AN000; LET LINK MAKE THIS ADDRESSABLE
CONTROL_POS2	LABEL BYTE	   ;AN000; SECOND POSITIONAL DESCRIPTOR FOR FILESPEC,
				   ;AN000; OPTIONAL
		DW   0201H	   ;AN000; CONTROLS TYPE MATCHED
				   ;AN000; SELECTED BITS: "FILE SPEC"
		DW   0002H	   ;AN000; FUNCTION_FLAGS
		DW   DGROUP:RESULT2 ;AN000; RESULT BUFFER (SECOND)
		DW   DGROUP:NOVALS ;AN000; NO VALUE LISTS
		DB   0		   ;AN000; NUMBER OF KEYWORD/SWITCH SYNONYMS
				   ;AN000;   IN FOLLOWING LIST


;VALUE CONTROL BLOCK FOR THE POSITIONAL PARAMETERS
NOVALS		DB   0		   ;AN000;NO VALUE DEFINITIONS

;RESULTS CONTROL BLOCK FOR THE FIRST POSITIONAL PARAMETER
RESULT1 	LABEL BYTE	   ;AN000; BELOW FILLED IN FOR DEFAULTS
TYPE1		DB   0		   ;AN000; TYPE RETURNED: 0=RESERVED,
		PUBLIC TYPE1
				   ;AN000;	 1=NUMBER, 2=LIST INDEX,
				   ;AN000;	 3=STRING, 4=COMPLEX,
				   ;AN000;	 5=FILESPEC, 6=DRIVE
				   ;AN000;	 7=DATE, 8=TIME
				   ;AN000;	 9=QUOTED STRING
RESULT_TAG1	DB   0FFH	   ;AN000; MATCHED ITEM TAG
		DW   0		   ;AN000; POINTER TO SYNONYM

RESULT_PTR1	DD   0		   ;AN000; FILESPEC OFFSET
		PUBLIC RESULT_PTR1

;RESULTS CONTROL BLOCK FOR THE SECOND POSITIONAL PARAMETER
RESULT2 	LABEL BYTE	   ;AN000; BELOW FILLED IN FOR DEFAULTS
		PUBLIC RESULT2
TYPE2		DB   0		   ;AN000; TYPE RETURNED: 0=RESERVED,
		PUBLIC TYPE2
				   ;AN000;	 1=NUMBER, 2=LIST INDEX,
				   ;AN000;	 3=STRING, 4=COMPLEX,
				   ;AN000;	 5=FILESPEC, 6=DRIVE
				   ;AN000;	 7=DATE, 8=TIME
				   ;AN000;	 9=QUOTED STRING
RESULT_TAG2	DB   0FFH	   ;AN000; MATCHED ITEM TAG
		DW   0		   ;AN000; POINTER TO SYNONYM

RESULT_PTR2	DD   0		   ;AN000; FILESPEC OFFSET
		PUBLIC RESULT_PTR2

; = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
		HEADER <SWITCH PARM DESCRIPTOR BLOCK>
;PARSER CONTROL BLOCK DEFINING THE SWITCHES, OPTIONAL

		PUBLIC SW1_7	   ;AN000;LET LINK MAKE THIS ADDRESSABLE
SW1_7		LABEL BYTE	   ;AN000;SWITCH DESCRIPTOR FOR THE FIRST SEVEN SW
		DW   0001H	   ;AN000; CONTROLS TYPE MATCHED
				   ;SELECTED BITS: "OPTIONAL"
				   ; 8000H=NUMERIC VALUE, (VALUE LIST WILL BE CHECKED)
				   ; 4000H=SIGNED NUMERIC VALUE (VALUE LIST WILL BE
				   ;   CHECKED)
				   ; 2000H=SIMPLE STRING(VALUE LIST WILL BE CHECKED)
				   ; 1000H=DATE STRING (VALUE LIST WON'T BE CHECKED)
				   ; 0800H=TIME STRING (VALUE LIST WON'T BE CHECKED)
				   ; 0400H=COMPLEX LIST (VALUE LIST WON'T BE CHECKED)
				   ; 0200H=FILE SPEC (VALUE LIST WON'T BE CHECKED)
				   ; 0100H=DRIVE ONLY (VALUE LIST WON'T BE CHECKED)
				   ; 0080H=QUOTED STRING (VALUE LIST WON'T BE CHECKED)
				   ; 0010H=IGNORE ":" AT END IN MATCH
				   ; 0002H=REPEATS ALLOWED
				   ; 0001H=OPTIONAL

		DW   0002H	   ;AN000; FUNCTION_FLAGS
				   ; 0001H=CAP RESULT BY FILE TABLE
				   ; 0002H=CAP RESULT BY CHAR TABLE
				   ; 0010H=REMOVE ":" AT END

		DW   DGROUP:RESULTSW1 ;AN000; RESULT BUFFER
		PUBLIC RESULTSW1   ;AN000;LET LINK MAKE THIS ADDRESSABLE
		DW   DGROUP:NOVALS ;AN000; VALUE LISTS
		DB   7		   ;AN000; NUMBER OF KEYWORD/SWITCH SYNONYMS
				   ;AN000;   IN FOLLOWING LIST
SW_A		DB   "/A",0
		PUBLIC SW_A
SW_E		DB   "/E",0
		PUBLIC SW_E
SW_M		DB   "/M",0
		PUBLIC SW_M
SW_P		DB   "/P",0
		PUBLIC SW_P
SW_S		DB   "/S",0
		PUBLIC SW_S
SW_V		DB   "/V",0
		PUBLIC SW_V
SW_W		DB   "/W",0
		PUBLIC SW_W

;PARSER CONTROL BLOCK DEFINING THE DATE SWITCH, OPTIONAL

		PUBLIC SW8	   ;AN000; LET LINK MAKE THIS ADDRESSABLE
SW8		LABEL BYTE	   ;AN000; SWITCH DESCRIPTOR FOR THE DATE SW
		DW   1000H	   ;AN000; CONTROLS TYPE MATCHED
		DW   0000H	   ;AN000; FUNCTION_FLAGS
		DW   DGROUP:DATE_BUFF ;AN000; RESULT BUFFER
		DW   DGROUP:NOVALS ;AN000; VALUE LISTS
		DB   1		   ;AN000; NUMBER OF KEYWORD/SWITCH SYNONYMS
				   ;AN000;   IN FOLLOWING LIST
SW_D		DB   "/D",0
		PUBLIC SW_D


;PARSER CONTROL BLOCK DEFINING THE /? SWITCH, OPTIONAL

		PUBLIC SW9, SW9_SYN
SW9		LABEL BYTE
		DW   0			; MATCH MASK
		DW   0			; FUNC MASK
		DW   DGROUP:SW9_BUFF	; ptr to RESULT BUFFER
		DW   DGROUP:NOVALS	; ptr to VALUE LIST
		DB   1			; # of SYNONYMS
SW9_SYN		DB   "/?",0



;RESULTS CONTROL BLOCK FOR THE /A,/E,/M,/P,/S,/V,/W SWITCHES
RESULTSW1	LABEL BYTE	   ;AN000; BELOW FILLED IN FOR DEFAULTS
		DB   3		   ;AN000; TYPE RETURNED: 0=RESERVED,
				   ;	   1=NUMBER, 2=LIST INDEX,
				   ;	   3=STRING, 4=COMPLEX,
				   ;	   5=FILESPEC, 6=DRIVE
				   ;	   7=DATE, 8=TIME
				   ;	   9=QUOTED STRING
		DB   0FFh	   ;AN000; MATCHED ITEM TAG

RESULTSWSYN	DW   0		   ;AN000; SYNONYM POINTER (BASED ON ES:)
		PUBLIC RESULTSWSYN
RESULTSWVAL	DD   0		   ;AN000; OFFSET OF STRING VALUE
		PUBLIC RESULTSWVAL


;RESULT CONTROL BLOCK FOR THE /D SWITCH
DATE_BUFF	LABEL BYTE
		DB   7		   ;AN000; TYPE RETURNED (DATE)
		DB   0FFh	   ;AN000; MATCHED ITEM TAG
		DW   0		   ;AN000; SYNONYM POINTER (BASED ON ES:)
DATE_YEAR	DW   0		   ;AN000; YEAR
		PUBLIC DATE_YEAR
DATE_MONTH	DB   0		   ;AN000; MONTH
		PUBLIC DATE_MONTH
DATE_DAY	DB   0		   ;AN000; DAY
		PUBLIC DATE_DAY

;RESULT CONTROL BLOCK FOR THE /? SWITCH

		PUBLIC SW9_BUFF, SW9_BUFF_SYN
SW9_BUFF	LABEL BYTE
		DB   0			; TYPE
		DB   0			; TAG
SW9_BUFF_SYN	DW   0			; ptr to matched SYNONYM
		DD   0			; padding (not used)


; =  =	=  =  =  =  =  =  =  =	=  =
DSEG_INIT	ENDS
		HEADER <PARSING WORKAREAS>
;	     $SALUT (4,14,19,36)
CSEG	     SEGMENT PUBLIC 'CODE'
	     ASSUME CS:CSEG, DS:DGROUP, ES:DGROUP

	     PUBLIC SYSPARSE	   ;AN000;SUBROUTINE ENTRY POINT		 ;AN000;


	     IF1
		 %OUT COMPONENT=XCOPY, SUBCOMPONENT=PARSE, MODULE=PARSE.ASM...
	     ENDIF
INCSW EQU 0			  ;AN018;TELL PARSE.ASM PSDATA.INC IS INCLUDED
BASESW EQU 1			  ;AN018;PSDATA.INC IS ADDRESSABLE WITH DS
;	INCLUDE PARSE.ASM	  ;AN000;GENERATED CODE SUPPRESSED FROM LISTING
.XLIST
.XCREF
	     INCLUDE PARSE.ASM
.LIST
.CREF

	     EXTRN GET_PARMS:NEAR  ;AN000;COMMAND LINE PARMS AND OPTIONS PROCESSING

	     HEADER <PARSER - ASK SYSPARM TO DECODE PARAMETERS>
;  $SALUT (4,4,9,36)
PARSER PROC NEAR
   PUBLIC PARSER

;INPUT: CURRENT_PARM = OFFSET TO NEXT PARM IN COMMAND STRING
;	COMMAND_LINE = COPY OF DOS COMMAND LINE PARAMETERS
;	"ORDINAL" = COUNT OF NEXT PARM TO PARSE
;OUTPUT: CARRY IS SET IF THERE WAS A PROBLEM, AX HAS PARSE RET CODE.
;	 CARRY IS CLEAR IF ALL OK WITH THE PARMS
;THE PSP IS NOT REFERENCED, SINCE THE PARMS HAVE BEEN MOVED OUT OF THERE.


   MOV	ORDINAL,ZERO		   ;AN000;OPERAND ORDINAL, INITALLY ZERO
;  $SEARCH COMPLEX		   ;AN000;LOOP THRU COMMAND LINE
   JMP SHORT $$SS1
$$DO1:
				   ;AN000;LOOKING AT RETURN CODE IN AX,
				   ;AN000; JUST PRODUCED BY SYSPARSE...
       CMP  AX,ZERO		   ;AN000;WERE THERE ANY ERRORS?
;  $EXITIF NE,OR		   ;AN000;HAD A PROBLEM
   JNE $$LL2
       MOV  ORDINAL,CX		   ;AN000;SAVE UPDATED COUNT
       MOV  CURRENT_PARM,SI	   ;AN000;REMEMBER HOW FAR I GOT
       MOV  BX,DX		   ;AN000;SET DATA BASE REG TO POINT TO THIS OPERAND
       CALL GET_PARMS		   ;AN000;GET 1ST AND 2ND PARAMETERS
       CMP  DGROUP:[OPTIONS_SENT], 0	; were options sent?
       JNE  PARSER_EXIT			; bail out now if so
       TEST PARM_FLAG,INIT_ERROR_FLAG ;AN000;CRITICAL PARAMETER ERROR HAS OCCURRED
;  $EXITIF NZ			   ;AN000;HAD A PROBLEM
   JZ $$IF1
$$LL2:
       STC			   ;AN000;SET CARRY TO INDICATE ERROR
       CALL PARM_ERROR		   ;AN000;GET OUT WITH ERROR INFORMATION
				   ;AN000;EITHER PARAMETER OR PARSER ERROR PROCESSED


;  $ORELSE			   ;AN000;SINCE NO PROBLEM, SO FAR
   JMP SHORT $$SR1
$$IF1:
;  $STRTSRCH
$$SS1:

       LEA  DI,PARMS		   ;AN000; ES:DI = PARSE CONTROL DEFINITON
       MOV  SI,CURRENT_PARM	   ;AN000; DS:SI = COMMAND STRING, NEXT PARM
       XOR  DX,DX		   ;AN000; RESERVED, INIT TO ZERO
       MOV  CX,ORDINAL		   ;AN000; OPERAND ORDINAL, INITIALLY ZERO
       CALL SYSPARSE
				   ;AN000; AX=EXIT CODE
				   ;AN000; BL=TERMINATED DELIMITER CODE
				   ;AN000; CX=NEW OPERAND ORDINAL
				   ;AN000; SI=SET TO PAST SCANNED OPERAND
				   ;AN000; DX=SELECTED RESULT BUFFER
       CMP  AX,SYSPRM_EX_EOL	   ;AN000; IS THAT THE END OF THE PARMS?
				   ;AN000;IF NOT, LOOP BACK AND FIND OUT
				   ;AN000; WHAT THAT PARM IS
;  $ENDLOOP E			   ;AN000;END OF LIST
   JNE $$DO1
       CLC			   ;AN000;CLEAR CARRY, END OF LIST OK
;  $ENDSRCH
;C06 $$SR1:
PARSER_EXIT:
;	JC  BLIP

; if /? was also specified, /e & /s not relevant, do not print errmsg
       CMP  QSET, 1
       JE   BLIP

       CMP  ESET, 0
       JE   BLIP
       CMP  SSET, 1
       JE   BLIP
 
; /E was specified w/o /S also specified.  Give Syntax Error msg and return
       PUSH    AX			
       MOV     AX, 35              ; MSG_INV_SW  (invalid switch)
       MOV     MSG_NUM,AX	
       MOV     SUBST_COUNT,  00H   ; NO_SUBST (no substitutions)
       MOV     INPUT_FLAG,  00H    ; NO_INPUT
       MOV     MSG_CLASS, 0FFH     ; UTILITY_MSG_CLASS

;C07   CALL    PRINT_STDOUT
       CALL    PRINT_STDERR                                               ;C07
       POP     AX
       MOV     OPTIONS_SENT, 1
       MOV     ERRORLEVEL, 1

$$SR1:                                                                    ;C06
BLIP:   RET				   ;AN000;RETURN TO CALLER
PARSER ENDP
; =  =	=  =  =  =  =  =  =  =	=  =
   HEADER <PARM_ERROR - ????????????>
PARM_ERROR PROC NEAR
;INPUT: DX - ADDRESS OF MESSAGE TEXT
;	PARM_FLAG set to INIT_ERROR_FLAG (critical error)
;	OR THERE WAS A PARSER ERROR

   RET				   ;AN000;RETURN TO CALLER WITH C SET

PARM_ERROR ENDP


; =  =	=  =  =  =  =  =  =  =	=  =
CSEG ENDS
   END

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\xcopy\xcopy.asm ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

;/*************************************************************************
;*                                                                        *
;*  Change History:                                                       *
;*                                                                        *
;*   Date    ID    MSFT #   STR #        Description                      *
;* -----------------------------------------------------------------------*
;*  02APR90  C01   85       1264    XCOPY will not work reliably when     *
;*                                  trying to copy from a disk that has   *
;*                                  the maximum number of files in the    *
;*                                  root directory or the max depth of    *
;*                                  directories.  Print files not copied  *
;*                                  and terminates.                       *
;*                                  Fix inserted in this module ONLY.     *
;*                                  DIC - 02APR90.                        *
;*  02APR90  C02   791      1038    If an XCOPY with a /S option is done  *
;*                                  and the summation of the source path  *
;*                                  and target path would cause one or    *
;*                                  more of the ultimate target paths to  *
;*                                  exceed 63 characters, then all of the *
;*                                  files and directories may NOT get     *
;*                                  copied.  No error message is given.   *
;*                                  XCOPY would merely return the number  *
;*                                  of files copied and list their file   *
;*                                  specifications.  This fix will cause  *
;*                                  the displaying of the message:        *
;*                                  "Invalid path, not all directories/   *
;*                                   files copied"                        *
;*                                  Modules affected by this fix are:     *
;*                                  XCOPY.ASM   XMAINMSG.EQU  XCOPY.SKL   *
;*  07AUG90  C08         PET 758    Reserved target error message not     *
;*                                  being sent to stderr.                 *
;*  31JAN91  C09          PET 6033  Error level being set in int 24       *
;*                                  handler was using the wrong DS for the*
;*                                  ERRORLEVEL variable.  When the floppy *
;*                                  drive door is open at the beginning of*
;*                                  the copy.  (EX. XCOPY * A:)           *
;*  24APR91  I00	  CWL	    Fix errorlevel 1 when /s specified	  *
;**************************************************************************

	PAGE,	132
TITLE	XCOPY	WITH FULL MEMORY USE - Ver. 4.00

;****************** START OF SPECIFICATIONS *****************************
; MODULE NAME: XCOPY
;
; DESCRIPTIVE NAME: selectively copy groups of files, which can include
;		    lower level subdirectories.
;
; FUNCTION:  The modules of XCOPY will be placed in the following order -
;	     SSEG, DSEG(MAIN DATA, MAIN MSG), CSEG (MAIN + INIT),
;	     DSEG_INIT(INIT DATA, INIT MSG)
;
;	     HEADER - informations needed about the file, subdirectory ...
;		      Continue_Info -> 0 - a whole single file in this header
;		      segment, or dir.
;		      1 - Continuation of a small file.
;		      2 - Continuation of a Big file
;		      3 - Eof of continuation
;	     Next_Ptr	   -> points to the next header segment
;	     Before_Ptr    -> points to the old header segment
;
;	     By optionally using the Archive bit in the directory of each
;	     file, XCOPY can be used as an alternative method of creating
;	     backup files which can be accessed directly by DOS and its
;	     applications without the need to "restore" the backup files.
;
;	     XCOPY is especially useful when several files are being copied
;	     and there is a generous amount of RAM available, because XCOPY
;	     will fill the memory with all the source files it can read in
;	     before starting to create output files.  If the memory is not
;	     enough to hold all the source, this cycle will be repeated until
;	     the process is completed.	For single drive systems, this maximum
;	     usage of the memory greatly reduces the amount of diskette
;	     swapping that would be required by the usual COPY command.
;
; ENTRY POINT: MAIN
;
; INPUT: (DOS COMMAND LINE PARAMETERS)
;
;	      SOURCE OPERAND:			   TARGET OPERAND:
;
;	      [d:] [path] filename[.ext]	   [d:] [path] [filename[.ext]]
;		or
;	      [d:] path [filename[.ext]]
;		or
;	      d: [path] [filename[.ext]]
;
;
;	      SWITCHES:
;
;	      /A /D /E /M /P /S /V /W
;
;The /A switch will copy only those files whose archive bit of the attribute is
;set to one.  The attribute of the source file is not changed.	This option is
;useful when making multiple backups when doing the non-final backup.
;The archive bit is one when a file has be created or Revised since the last
;time the bit was turned off.  XCOPY /M or BACKUP /M will turn this bit off.
;The ATTRIB command can also be used to change the setting of the archive bit.
;
;The /D switch will copy only those files whose date is the same or later than
;the date specified.  Depending on the country code you selected using the
;COUNTRY command, the date is specified in the format corresponding to the
;indicated country.
;
;The /E switch will create subdirectories on the target even if they end up
;being empty after all copying is over.  If /E is not specified, empty
;subdirectories are not created.
;
;The /M switch will copy only those files whose archive bit is set in its
;attribute.  Unlike the /A switch, /M will cause the archive bit in the source
;file to be turned off.  This allows XCOPY to be used in making a final backup.
;The archive bit is one when a file has be created or Revised since the last
;time the bit was turned off.  XCOPY /M or BACKUP /M will turn this bit off.
;The ATTRIB command can also be used to change the setting of the archive bit.
;
;The /P switch will prompt the operator before copying each file.  In this
;situation, each file is copied onto the target before reading in the next
;file. The multi-file copy into a large memory buffer is not done.  The prompt
;displays the complete filespec it proposes to copy and asks for (Y/N)
;response, which is then read in from the standard input device.
;
;The /S switch will not only copy the files in the current source directory but
;also those in all the subdirectories below the current one, with XCOPY
;following the Tree of the subdirectories to access these files.  /S does not
;create an empty subdirectory on the target (unless /E is also specified).
;If the /S switch is not specified, XCOPY works only within the specified (or
;current) subdirectory of the source.
;
;The /V switch will cause DOS to verify that the sectors written on the target
;are recorded properly.  This option has been provided so you can verify that
;critical data has been correctly recorded.  This option will cause XCOPY to
;run more slowly, due to the additional overhead of verification.
;
;The /W switch will instruct XCOPY to pause before actually starting the
;movement of data, thus permit the copying of diskettes that do not actually
;have XCOPY available on them.	The diskette containing XCOPY can be mounted
;first, the XCOPY command given with the /W option, then when the prompt
;requesting permission to continue is given, that diskette can then be removed
;and the source diskette mounted in its place, then the operator can press any
;key to continue after the pause.  This feature is especially useful in a
;non-hardfile system.
;
; EXIT-NORMAL:	ERRORLEVEL_0 - This is the normal completion code.
;		ERRORLEVEL_2 - This is due to termination via Control-Break.
;		ERRORLEVEL_4 - This is used to indicate an error condition.
;
;    There are many types of problems that are detected and result in this
;    return code, such as:
;
;    write failure due to hard disk error
;    disk full
;    conflict between name of new subdirectory and existing filename
;    access denied
;    too many open files
;    sharing violation
;    lock violation
;    general failure
;    file not found
;    path not found
;    directory full
;    invalid parms
;    reserved file name as source
;    insufficient memory
;    incorrect DOS version
;
;
; INTERNAL REFERENCES:
;
;    ROUTINES:
;
;
;    DATA AREAS:
;
;
; EXTERNAL REFERENCES:
;
;    ROUTINES:
;
;
;    DATA AREAS:
;
;
; NOTES: This module should be processed with the SALUT pre-processor
;	 with the re-alignment not requested, as:
;
;		SALUT XCOPY,NUL,;
;
;	 To assemble these modules, the sequential
;	 ordering of segments may be used.
;
;	 For LINK instructions:
;		link  profile ..\lib
;
; REVISION HISTORY: A000 Version 4.00: add PARSER, System Message Handler,
;			 Remove the BELL char.,turn off APPEND during TREE
;			 search,Extended Attribute processing, Uppercasing
;			 and "Out Of Space" during write to standard out.
;		    A001 PTM0011 XCOPY not handling path >63 characters.
;			 CHK_MAX_LENGTH proc(XCPYINIT) is Revised to err if
;			 >63 chrs.
;		    A002 PTM0012 XCOPY unnecessarily accessing current drive.
;			 ORG_S_T_DEF is Revised to ignore CHDIR if drive
;			 is not TARGET or SOURCE.
;		    A003 PTM0088 XCOPY (\) missing in 'FILE SHARING ERROR'.
;			 This problem is fixed with incorporation of the
;			 new message services.
;		    A004 PTM0700 9/02/87 Avoid duplicate switches and
;			 display parm in error.
;		    A005 DCR0201 9/11/87 Incorperate new format for EXTENDED
;			 ATTRIBUTES.
;		    A006 PTM1490 10/04/87 XCOPY /D CAUSES "INVALID PARAMETER"
;			 MSG AND SHOULD BE "INVALID NUMBER OF PARAMETERS" ALSO
;			 DATE IS NOT VALIDATED.
;		    A007 PTM1657 10/14/87 XCOPY INVALIDLY FAILS TO READ A READ
;			 ONLY FILE, AND OUTPUTS THE WRONG MSG.
;		    A008 PTM1688 10/15/87 XCOPY NOT CREATING EMPTY SUBDIRS IF
;			 THE SOURCE DIR. IS EMPTY.
;		    A009 PTM2199 11/02/87 XCOPY NOT HANDELING FILENAMES GREATER
;			 THAN 12 CHARACTERS.
;		    A010 PTM2203 11/03/87 XCOPY NOT HANDELING DBCS PATH NAMES
;			 PROPERLY. (INCORP. CHK. IF 1st BYTE IS DBCS)
;		    A011 PTM2271 11/04/87 XCOPY NOT HANDELING FILENAMES GREATER
;			 THAN 12 CHARACTERS.(S_FILE BUFFER OVERFLOWES).
;		    A012 PTM2347 11/09/87 XCOPY SETTING THE CODE PAGE OF A DEV.
;			 AND A DEV. IS NOT ALLOWED FOR A TARGET.
;		    A013 PTM2565 11/17/87 XCOPY HANGS AUTOTEST. SET EXTENDED
;			 ATTRIBUTE CALL TO DOS POINTS TO INVALID BUFFER.
;		    A014 PTM2597 11/20/87 XCOPY REPORTS FILE CREATION ERROR
;			 IF TARGET FILE IS GREATER THAN 12 CHARACTERS.
;		    A015 PTM2782 12/04/87 XCOPY FILENAME (EXTENSION)
;			 TRUNCATION ERROR. INCREASE HEADER BUFFER TO 3 PARA.
;		    A016 PTM2783 12/09/87 XCOPY ALLOWS 'ASSIGN' DRIVES TO
;			 BE COPIED ONTO THEMSELVS. ADD NEW CODE TO INIT.
;		    A017 PTM3139 01/15/88 XCOPY HANGS WHEN TRYING TO OUTPUT
;			 "INSUFFICIENT DISK SPACE" FOR MAKE DIRECTORY.
;		    A018 PTM3283 02/01/88 XCOPY NEEDS TO CHANGE 'FILE NOT
;			 FOUND' MSG TO EXTENDED ERROR MSG FORMAT. ALSO
;			 DELETED DEF 28 IN XCOPY.SKL & XMAINMSG.EQU
;		    A019 PTM3395 02/08/88 XCOPY FAILING TO SUSPEND THE
;			 'APPEND /X' FUNCTION. FIX IN XCOPY.SAL, XCOPY.EQU,
;			 AND DOS.EQU.
;		    A020 PTM3344 02/09/88 XCOPY READING PAST TOP_OF_MEMORY,
;			 OVER-WRITING VIDIO BUFFER SET BY MODE 13H ON PS2s.
;		    A021 PTM3513 02/19/88 XCOPY READING PAST TOP_OF_MEMORY,
;			 OVER-WRITING VIDIO BUFFER SET BY MODE 13H ON PS2s.
;		    A022 PTM3933 03/18/88 XCOPY NOT RESTORING DIRECTORY OF
;			 DEFAULT DRIVE. FIX IN XCOPY.SAL.
;		    A023 PTM3904 03/18/88 XCOPY NOT USING PARSE 03 MSG. FOR
;			 'INVALID SWITCH'. FIX IN XCOPY.SKL & XCPYINIT.SAL.
;		    A024 PTM3958 03/22/88 XCOPY MSGS DO NOT CONFORM TO SPEC.
;			 NEED NULL DELIMITER IN XCPYINIT.SAL.
;		    A025 PTM3965 03/23/88 XCOPY LEAVING CURRENT TARGET DIR.
;			 CHANGED. FIX IN XCPYINIT.SAL.
;		    A026 PTM4920 05/19/88 XCOPY NOT OVERLAYING FILES ON FULL
;			 TARGET DISK. FIX IN XCOPY.SAL.
;		    A027 PTM5022 06/03/88 'PATH TOO LONG' MSG. WITH TWO CHAR.
;			 SOURCE SUBDIR. FILESPEC. FIX IN XCPYINIT.SAL.
;		    A028 PTM5818 01/24/89 Last_Dir_Out routine - picking up
;			 incorrect DBCS char because segment override was missing.
;		    C001 PTM5739 09/08/89 XCOPY deletes empty source directory
;			 instead of empty target directory.
;		    C002 PTM6267 09/12/89 Move instruction MOV DS,ES:PSP_SEG
;			 before call to GET CURRENT DTA.
;
;     Label: "The DOS XCOPY Utility"
;
;****************** END OF SPECIFICATIONS *****************************

;--------------------------------
;   Include Files
;--------------------------------
INCLUDE XMAINMSG.EQU			;AN000;message file
INCLUDE DOS.EQU 			;AN000;
INCLUDE XCOPY.EQU			;AN000;
INCLUDE VERSION.INC			; MSKK01 07/18/89

INCLUDE SYSMSG.INC			;AN000;

MSG_UTILNAME <XCOPY>			;AN000;

;******************************************************************************
SSEG	SEGMENT PARA STACK 'STACK'
	DB	64     DUP ('STACK   ') ;256 words
SSEG	ENDS



;******************************************************************************
DGROUP	GROUP	DSEG,DSEG_INIT		;FOR CONVENIENT ADDRESSIBLITY OF
					      ;DSEG_INIT in INIT routine


;-------------------------------
;    Structures
;-------------------------------
;HEADER - informations needed about the file, subdirectory ...
;Continue_Info -> 0 - a whole single file in this header segment, or dir.
;		  1 - Continuation of a small file.
;		  2 - Continuation of a Big file
;		  3 - EOF of continuation
;Next_Ptr      -> points to the next header segment
;Before_Ptr    -> points to the old header segment

HEADER	STRUC
	CONTINUE_INFO DB      0 	;set for filesize bigger then 0FFD0h
	NEXT_PTR DW	 ?		;next buffer ptr in para
	BEFORE_PTR DW	   ?		;before ptr in para
	DIR_DEPTH DB	  ?		;same as S_DEPTH
	CX_BYTES DW	 0		;actual # of bytes in this buffer seg.
	ATTR_FOUND DB	   ?		;attribute found
	FILE_TIME_FOUND DW	?
	FILE_DATE_FOUND DW	?
	LOW_SIZE_FOUND DW      ?
	HIGH_SIZE_FOUND DW	?
	TARGET_DRV_LET DB      " :"	;used for writing
	FILENAME_FOUND DB      13 DUP (0) ;AC015; FILENAME
	TERMINATE_STRING DB    16 DUP (0) ;AC015;TERM FILENAME STRING FOR DOS
	ATTRIB_LIST DW	 ?		;AC005;EXTENDED ATTRIBUTE BUFFER
;-------------------------------------------------------------------
;	extended attribute list used by extended open & get extended
;-------------------------------------------------------------------
;	ATTRIB_LIST LABEL BYTE		 extended attribute buffer
;
;EA		STRUC		; EXTENDED ATTRIBUTE
;EA_TYPE	DB	?	; TYPE
;EAISUNDEF	EQU	0	; UNDEFINED TYPE	      (ATTRIB SKIPS)
;				;   (OR TYPE NOT APPLICABLE)
;				;   LENGTH: 0 TO 64K-1 BYTES
;EAISLOGICAL	EQU	1	; LOGICAL (0 OR 1)	      (ATTRIB DISPLAYS) 				  ;   LENGTH: 1 BYTE
;EAISBINARY	EQU	2	; BINARY INTEGER	      (ATTRIB DISPLAYS)
;				;   LENGTH: 1, 2, 4 BYTES
;EAISASCII	EQU	3	; ASCII TYPE		      (ATTRIB DISPLAYS)
;				;   LENGTH: 0 TO 128 BYTES
;EAISDATE	EQU	4	; DOS FILE DATE FORMAT	      (ATTRIB DISPLAYS)
;				;   LENGTH: 2 BYTES
;EAISTIME	EQU	5	; DOS FILE TIME FORMAT	      (ATTRIB DISPLAYS)
;				;   LENGTH: 2 BYTES
;				; OTHER VALUES RESERVED
;EA_FLAGS	DW	?	; FLAGS
;EASYSTEM	EQU	8000H	; EA IS SYSTEM DEFINED
;				; (BUILTIN, NOT APPLICATION DEFINED)
;EAREADONLY	EQU	4000H	; EA IS READ ONLY (CANT BE CHANGED)
;EAHIDDEN	EQU	2000H	; EA IS HIDDEN FROM ATTRIB
;EACREATEONLY	EQU	1000H	; EA IS SETABLE ONLY AT CREATE TIME
;				; OTHER BITS RESERVED
;EA_RC		DB	?	; FAILURE REASON CODE (SET BY DOS)
;EARCNOTFOUND	EQU	1	; NAME NOT FOUND
;EARCNOSPACE	EQU	2	; NO SPACE TO HOLD NAME OR VALUE
;EARCNOTNOW	EQU	3	; NAME CAN'T BE SET ON THIS FUNCTION
;EARCNOTEVER	EQU	4	; NAME CAN'T BE SET
;EARCUNDEF	EQU	5	; NAME KNOWN TO THIS FS BUT NOT SUPPORTED
;EARCDEFBAD	EQU	6	; EA DEFINTION BAD (TYPE, LENGTH, ETC)
;EARCACCESS	EQU	7	; EA ACCESS DENIED
;EARCUNKNOWN	EQU	-1	; UNDETERMINED CAUSE
;EA_NAMELEN	DB	?	; LENGTH OF NAME
;EA_VALLEN	DW	?	; LENGTH OF VALUE
;EA_NAME	DB	?	; FIRST BYTE OF NAME
;
;EA_VALUE	DB	?	; FIRST BYTE OF VALUE
;
HEADER	ENDS



SUB_LIST STRUC
	DB	11			;AN000;
	DB	0			;AN000;
DATA_OFF DW	0			;AN000; offset of data to be inserted
DATA_SEG DW	0			;AN000; offset of data to be inserted
MSG_ID	DB	0			;AN000; n of %n
FLAGS	DB	0			;AN000; Flags
MAX_WIDTH DB	0			;AN000; Maximum field width
MIN_WIDTH DB	0			;AN000; Minimum field width
PAD_CHAR DB	0			;AN000; character for pad field

SUB_LIST ENDS


DSEG	SEGMENT PARA PUBLIC 'DATA'		; DATA Segment

;******************************************************************************
;--- EXTERNAL VARIABLES ---
EXTRN	PARM_FLAG: BYTE
EXTRN	COMMAND_LINE: BYTE		;AN000;THE COMMAND LINE FOR THE PARSER
;--- PUBLIC VARIABLES ---
PUBLIC	ERRORLEVEL
PUBLIC	OPTIONS_SENT

PUBLIC	DISP_S_PATH
PUBLIC	DISP_T_PATH
PUBLIC	S_DRV
PUBLIC	S_DRV_1
PUBLIC	T_DRV
PUBLIC	T_DRV_1
PUBLIC	T_DRV_2
PUBLIC	S_DRV_PATH
PUBLIC	S_PATH
PUBLIC	T_DRV_PATH
PUBLIC	T_PATH
PUBLIC	S_FILE
PUBLIC	T_FILENAME
PUBLIC	T_TEMPLATE
PUBLIC	T_MKDIR_LVL
PUBLIC	S_ARC_DRV
PUBLIC	S_ARC_PATH
;
PUBLIC	PSP_SEG
PUBLIC	SAV_DEFAULT_DRV
PUBLIC	SAV_DEFAULT_DIR
PUBLIC	SAV_S_DRV
PUBLIC	SAV_S_CURDIR
PUBLIC	SAV_T_DRV
PUBLIC	SAV_T_CURDIR
PUBLIC	S_DRV_NUMBER
PUBLIC	T_DRV_NUMBER
PUBLIC	TOP_OF_MEMORY
PUBLIC	BUFFER_PTR
PUBLIC	BUFFER_BASE
PUBLIC	BUFFER_LEFT
PUBLIC	MAX_BUFFER_SIZE
PUBLIC	MAX_CX
;
PUBLIC	MY_FLAG
PUBLIC	SYS_FLAG
PUBLIC	COPY_STATUS
PUBLIC	OPTION_FLAG
PUBLIC	INPUT_DATE
PUBLIC	INPUT_TIME

PUBLIC	SUBST_COUNT			;AN000;
PUBLIC	MSG_CLASS			;AN000;
PUBLIC	INPUT_FLAG			;AN000;
PUBLIC	MSG_NUM 			;AN000;

PUBLIC	SUBLIST1			;AN000;MSG SUBLIST USED BY INIT


;--- VARIABLES DEFINED ---

	MSG_SERVICES <MSGDATA>		;AN000;

ERRORLEVEL DB	0			;errorlevel
OPTIONS_SENT	DB	0		; non-0 if options msg sent
INPUT_DATE DW	0
INPUT_TIME DW	0
PSP_SEG DW	?
SAV_DEFAULT_DRV DB ?			;1 = A, 2 = B etc. saved default
SAV_DEF_DIR_ROOT DB '\'
SAV_DEFAULT_DIR DB 80 DUP (0)
SAV_S_DRV DB	'A:\'
SAV_S_CURDIR DB 80 DUP (0)
SAV_T_DRV DB	'B:\'
SAV_T_CURDIR DB 80 DUP (0)
;

DISP_S_PATH DB	67 DUP (0)		;mirror image of source path. used for display message when copying
DISP_S_FILE DB	13 DUP (0)
DISP_T_PATH DB	67 DUP (0)		;mirror image of target path
DISP_T_FILE DB	13 DUP (0)
;
B_SLASH DB	'\',0			;AN000;


FILE_COUNT LABEL WORD			;AN000;
FILE_CNT_LOW DW 0			;copied file count
FILE_CNT_HIGH DW 0
;

;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
APPENDFLAG DW	0			;AN000;append /X status save area
FOUND_FILE_FLAG DB 0			;used for showing the message "File not found"
;
S_DRV_NUMBER DB 0			;source, target drv #
T_DRV_NUMBER DB 0
;
S_DRV_PATH LABEL BYTE			;source drv, path used for single_drv_copy
S_DRV	DB	'A:\'
S_PATH	DB	80 DUP (0)		;AN000;Initialized by calling GET CUR DIR
S_DEPTH DB	0
S_DRV_1 DB	'A:'
S_FILE	DB	'????????.???',0	;default filename to find file
S_FILE_OVERFLO DB 20 DUP (0)		;AN011;BUFFER IF MORE THAN 12 CHARS.
S_DIR	DB	'????????.???',0	;to find any subdirectory name
S_DIR_OVERFLO DB 20 DUP (0)		;AN011;BUFFER IF MORE THAN 12 CHARS.

S_PARENT DB	'..',0			;source parent used for non single_drv_copy
S_HANDLE DW	0			;file handle opened

S_ARC_DRV_PATH LABEL BYTE		;informations used to change source file's
S_ARC_DRV DB	'A:\'			;archive bits.
S_ARC_PATH DB	64 DUP (0)
S_ARC_DEPTH DB	0

T_DRV_PATH LABEL BYTE			;target drv, path used all the time
T_DRV	DB	'B:\'
T_PATH	DB	80 DUP (0)		;AC016;init by call GET CUR DIR in INIT
T_DEPTH DB	0
T_FILE	LABEL	BYTE			;target filename for file creation
T_DRV_1 DB	'B:'			;target drv letter
T_FILENAME DB	15 DUP (0)		;target filename
T_TEMPLATE DB	15 DUP (0)		;if global chr entered, this will be used instead of filename.

T_PARENT LABEL	BYTE
T_DRV_2 DB	'B:'
T_PARENT_1 DB	'..',0
T_HANDLE DW	0			;target handle created
T_MKDIR_LVL DB	0			;# of target starting directories created.
;
;------------------------------------------
; PRINT_STDOUT input parameter save area
;------------------------------------------

SUBST_COUNT	DW	0		;AN000; message substitution count
MSG_CLASS	DB	0		;AN000; message class
INPUT_FLAG	DB	0		;AN000; Type of INT 21 used for KBD input
MSG_NUM		DW	0		;AN000; message number


INPUT_BUFF 	db	20  dup(0)	;AN000; keyboard input buffer used
					;for user response (Y/N)

;--------------------------------------------------------------
; Following three sublists are used by the  Message Retriever
;--------------------------------------------------------------
SUBLIST1 LABEL	DWORD			;AN000;SUBSTITUTE LIST 1
	DB	11			;AN000;sublist size
	DB	0			;AN000;reserved
	DD	0			;AN000;substition data Offset
	DB	1			;AN000;n of %n
	DB	0			;AN000;data type
	DB	0			;AN000;maximum field width
	DB	0			;AN000;minimum field width
	DB	0			;AN000;characters for Pad field


SUBLIST2 LABEL	DWORD			;AN000;SUBSTITUTE LIST 2
	DB	11			;AN000;sublist size
	DB	0			;AN000;reserved
	DD	0			;AN000;substition data Offset
	DB	2			;AN000;n of %n
	DB	0			;AN000;data type
	DB	0			;AN000;maximum field width
	DB	0			;AN000;minimum field width
	DB	0			;AN000;characters for Pad field


SUBLIST3 LABEL	DWORD			;AN000;SUBSTITUTE LIST 3
	DB	11			;AN000;sublist size
	DB	0			;AN000;reserved
	DD	0			;AN000;substition data Offset
	DB	3			;AN000;n of %n
	DB	0			;AN000;data type
	DB	0			;AN000;maximum field width
	DB	0			;AN000;minimum field width
	DB	0			;AN000;characters for Pad field


FILE_SEARCH_ATTR DW NORM_ATTR
DIR_SEARCH_ATTR DW is_subdirectory
;
OPEN_MODE DB	Read_Only_Deny_Write	;READ_ONLY_DENY_WRITE	 ;access, sharing mode
;
;Equates are defined in XCOPY.EQU

MY_FLAG DB	0			;informations for a tree walk
;	find_first_flag    equ	   01h	;set MY_FLAG by "OR"
;	findfile_flag	   equ	   02h
;	no_more_file	   equ	   04h
;	single_copy_flag   equ	   08h	;single copy instead of multi copy
;	visit_parent_flag  equ	   10h	;visit parent node
;	found_flag	   equ	   20h	;found flag - for find subdir
;	missing_link_flag  equ	   40h	;insufficient info. for not creating empty dir
;	is_source_flag	   equ	   80h	;if set, dealing with source
;	reset_find_first   equ	  0FEh	;reset by AND
;	reset_findfile	   equ	  0FDh
;	reset_no_more	   equ	  0FBh
;	reset_visit_parent equ	  0EFh
;	reset_found	   equ	  0DFh
;	reset_missing_link equ	  0BFh
;	reset_is_source    equ	  07Fh

FILE_FLAG DB	0
;	cont_flag	   equ	   01h
;	eof_flag	   equ	   02h
;	big_file_flag	   equ	   04h
;	file_bigger_flag   equ	   08h
;	created_flag	   equ	   10h
;	reset_cont	   equ	  0FEh
;	reset_eof	   equ	  0FDh
;	reset_big_file	   equ	  0FBh
;	reset_file_bigger  equ	  0F7h
;	reset_created	   equ	  0EFh
;	reset_readfile	   equ	  0F0h	;reset FILE_FLAG for read a file
;
COPY_STATUS DB	0
;	open_error_flag    equ	   01h
;	read_error_flag    equ	   02h
;	create_error_flag  equ	   04h
;	write_error_flag   equ	   08h
;	mkdir_error_flag   equ	   10h
;	chdir_error_flag   equ	   20h
;	maybe_itself_flag  equ	   40h
;	disk_full_flag	   equ	   80h
;	reset_open_error   equ	  0FEh
;	reset_read_error   equ	  0FDh
;	reset_create_error equ	  0FBh
;	reset_write_error  equ	  0F7h
;	reset_close_error  equ	  0EFh
;	reset_chdir_error  equ	  0DFh
;
ACTION_FLAG DB	0
;	reading_flag	   equ	  01h	;display "Reading source files..."
;	reset_reading	   equ	  0FEh	;do not display.
;
SYS_FLAG DB	0			;system information
;	one_disk_copy_flag   equ   01h	;xcopy with only one logical drive.
;	default_drv_set_flag equ   02h	;default drive has been changed by this program
;	default_s_dir_flag   equ   04h	;source current directory saved.
;	default_t_dir_flag   equ   08h	;target current directory saved.
;	removable_drv_flag   equ   10h
;	sharing_source_flag  equ   20h	;source shared
;	sharing_target_flag  equ   40h
;	turn_verify_off_flag equ   80h	;turn the verify off when exit to dos
;	reset_default_s_dir  equ  0FBh	;reset default_s_dir_flag
;
OPTION_FLAG DB	0
;	slash_a 	   equ	  01h	;soft archive ?
;	slash_d 	   equ	  02h	;date?
;	slash_e 	   equ	  04h	;create empty dir?
;	slash_m 	   equ	  08h	;hard archive ? (turn off source archive bit)
;	slash_p 	   equ	  10h	;prompt?
;	slash_s 	   equ	  20h	;walk the tree?
;	slash_v 	   equ	  40h	;verify on?
;	slash_w 	   equ	  80h	;show "Press any key to begin copying" msg)
;	reset_slash_a	   equ	 0FEh	;turn off soft archive
;	reset_slash_m	   equ	 0F7h	;turn off hard archive

MAX_CX	DW	0			;less than 0FFD0h
ACT_BYTES DW	0			;actual bytes read.
HIGH_FILE_SIZE DW 0
LOW_FILE_SIZE DW 0
;
TOP_OF_MEMORY DW 0			;para
BUFFER_BASE DW	0			;para
MAX_BUFFER_SIZE DW 0			;para.	BUFFER_LEFT at INIT time.
BUFFER_LEFT DW	0			;para
BUFFER_PTR DW	0			;para. If buffer_left=0 then invalid value
DATA_PTR DW	0			;buffer_ptr + HEADER
OLD_BUFFER_PTR DW 0			;last buffer_ptr
SIZ_OF_BUFF DW	?			;AN005;para. EXTENDED ATTRIB BUFF SIZE
BYTS_OF_HDR DW	?			;AN005;bytes TOTAL HEADER SIZE
PARA_OF_HDR DW	3			;AC008;para. TOTAL HDR SIZE INIT TO 3
OPEN_FILE_COUNT DW ?			;AN005;TRACKING OF OPEN FLS FOR BUFFER
;					      ;SIZE CALCULATION.
DBCSEV_OFF DW	0			;AN010; remember where dbcs vector is
DBCSEV_SEG DW	0			;AN010;next time I don't have to look
;
;structured data storage allocation
FILE_DTA Find_DTA <>			;DTA for find file

;C01    DTAS	Find_DTA 32 dup (<>)		;DTA STACK for find dir
DTAS Find_DTA 33 DUP(<>)  ; DTA STACK for find dir    ;C01  Ref: XCOPY-85. XCOPY problem
                                                      ;C01       with full or deep dir(s).
;** Througout the program BP will be used for referencing fieldsname in DTAS.
;For example, DS:[BP].dta_filename.

NEWFILE_SEG  DW  0 ; added jan 2 1990 leaf
NEWFILE_OFF  DW  0 ; added jan 2 1990 leaf

DSEG	ENDS

;******************************************************************************

CSEG	SEGMENT PUBLIC 'CODE'
	ASSUME	CS:CSEG, DS:DGROUP, SS:SSEG

	MSG_SERVICES <LOADmsg,GETmsg,DISPLAYmsg,INPUTmsg,CHARmsg,NUMmsg> ;AN000;
	MSG_SERVICES <XCOPY.CLA,XCOPY.CL1,XCOPY.CL2> ;AN000;




;--- EXTERNAL PROCEDURES ---
EXTRN	INIT:	NEAR			;INIT PROC
;
;--- PUBLIC   PROCEDURES ---		;USED BY INIT
PUBLIC	SET_BUFFER_PTR
PUBLIC	STRING_LENGTH
PUBLIC	CONCAT_ASCIIZ
PUBLIC	LAST_DIR_OUT
PUBLIC	CHK_DRV_LETTER
PUBLIC	COMPRESS_FILENAME
PUBLIC	PRINT_STDOUT
PUBLIC	PRINT_STDERR
PUBLIC	SET_DEFAULT_DRV
PUBLIC	MAIN_EXIT
PUBLIC	MAIN_EXIT_A
PUBLIC	CTRL_BREAK_EXIT
PUBLIC	SWITCH_DS_ES
PUBLIC	MY_INT24

;--- INT 24 ADDR ----------
PUBLIC	SAV_INT24_OFF
PUBLIC	SAV_INT24_SEG

PUBLIC	SYSLOADMSG			;AN000;
PUBLIC	SYSDISPMSG
PUBLIC	SYSGETMSG

SAV_INT24 LABEL DWORD
SAV_INT24_OFF DW 0			;original int 24 addr holder
SAV_INT24_SEG DW 0
;--- START OF A PROGRAM ---
	ASSUME	DS:NOTHING		;AN000;
	ASSUME	ES:NOTHING		;AN000;

md_err_ignore    db     0          ; flag-md error, we ignored it.     ; C02
more_than_63     db     0          ; error, tryed to make LONG subdir. ; C02

MAIN	PROC	FAR
	PUSH	AX			;AN000;PRESERVE FOR INIT DRV VALIDITY
	MOV	BX,DGROUP
	MOV	ES,BX			;AN000;SET UP ADDRESS OF DSEG IN ES
	ASSUME	ES:DGROUP		;AN000;
	MOV	SI,81H			;AN000;POINT TO THE INPUT STRING
	LEA	DI,COMMAND_LINE 	;AN000;POINT TO THE SAVE AREA IN PARSER
	MOV	CX,127			;AN000;GET ALL THE DATA(LOOP COUNT)
	REP	MOVSB			;AN000;MOVE IT
	MOV	PSP_SEG,DS		;AN000;REMEMBER WHERE THE PSP IS
	MOV	DS,BX			;AN000;SET UP ADDRESS OF DSEG IN DS
	ASSUME	DS:DGROUP		;AN000;

	CALL	SYSLOADMSG		;AN000; preload all messages
	jnc	XCOPY_INIT		;AN000; no error, do xcopy init

	CALL	SYSDISPMSG		;AN000; else display error message
	POP	AX			;AN000;WAS PRESERVED FOR DRV VALIDATION
	JMP	JUST_EXIT		;AN000; exit

XCOPY_INIT:
	POP	AX			;AN000;WAS PRESERVED FOR DRV VALIDATION
	CALL	INIT			;initialization
	JC	MAIN_EXIT		;error. (Already message has been displayed)

	CMP	DGROUP:[OPTIONS_SENT], 0 ; should we exit now?
	JE	@F			; skip if options not sent
	JMP	JUST_EXIT		; else we're done!
@@:
	MOV	BP, OFFSET DTAS 	;initialize BP
	OR	ACTION_FLAG, READING_FLAG ;set reading flag for copy message

;Before walking the tree, find out the /X status of APPEND and save it.
;Then terminate the /X feature.  After the tree search, restore the
;original /X status. This is done at EXIT time.

	MOV	AX,CHK_APPEND		;AN000;CHECK IF APPEND INSTALLED
	INT	2FH			;AN000;
	OR	AL,AL			;AN000;INSTALLED?
;	$IF	NZ			;AN000;YES
	JZ $$IF1
	    MOV     AX,VER_APPEND	;AN019;ASK IF DOS VERSION OF APPEND
	    INT     2FH 		;AN019;CALL THE FUNCTION
	    CMP     AX,D_V_APPEND	;AN000;DOS VERSION?
;	    $IF     E			;AN000;YES
	    JNE $$IF2
		MOV	AX,GET_APPEND	;AN000;GET THE APPEND STATE
		INT	2FH		;AN000;
		MOV	APPENDFLAG,BX	;AN000;SAVE THE STATE TO RESTORE
		TEST	APPENDFLAG,F_APPEND  ;AN019;IS THE /X BIT ON?
;		$IF	NZ		;AN000;YES
		JZ $$IF3
		    MOV     AX,SET_APPEND ;AN000;SET THE APPEND STATE
		    MOV     BX,APPENDFLAG ;AN000;GET THE SAVED STATE
		    XOR     BX,F_APPEND ;AN000;TURN OFF THE /X BIT
		    INT     2FH 	;AN000;DO IT
;		$ENDIF			;AN000;
$$IF3:
;	    $ENDIF			;AN000;
$$IF2:
;	$ENDIF				;AN000;
$$IF1:

	CALL	TREE_COPY
	CALL	WRITE_FROM_BUFFER	;write from buffer if we missed it.
	CALL	ORG_S_DEF		;restore the original source default dir

MAIN_EXIT:
	MOV	BX, DGROUP
	MOV	DS, BX			;re initialize ds, es
	MOV	ES, BX			;exit here if the status of source, target or default drv has been changed.
	CALL	CHK_FILE_NOT_FOUND	;if no files has been found, show the message.
					;
; Set message substitution list
	LEA	SI,SUBLIST1		;AN000; get addressability to sublist
	LEA	DX,FILE_COUNT		;AN000; offset to file count
	MOV	[SI].DATA_OFF,DX	;AN000; save data offset
	MOV	[SI].DATA_SEG,DS	;AN000; save data segment
	MOV	[SI].MSG_ID,1		;AN000; message ID
	MOV	[SI].FLAGS,RIGHT_ALIGN+UNSGN_BIN_DWORD ;AN018;
	MOV	[SI].MAX_WIDTH,9	;AN018; MAXIMUM FIELD WITH
	MOV	[SI].MIN_WIDTH,9	;AN018; MINIMUM FIELD WITH
	MOV	[SI].PAD_CHAR,SPACE	;AN018; MINIMUM FIELD WITH

; Set message parameters
	MOV	AX,MSG_FILES_COPIED	;AN000; message number
	MOV	MSG_NUM,AX		;AN000; set message number
	MOV	SUBST_COUNT,PARM_SUBST_ONE ;AN000; one message substitution
	MOV	MSG_CLASS,UTILITY_MSG_CLASS ;AN000; message class
	MOV	INPUT_FLAG,NO_INPUT	;AN000; no user input
	CALL	PRINT_STDOUT		;AN000; display file count

 cmp   cs:more_than_63,1        ; Q: Is "not all files copied" nec ?  ;C02
 jnz   MAIN_EXIT_A              ;  N:                                 ;C02
 call  err_long_63              ;  Y: print message                   ;C02

MAIN_EXIT_A:
	MOV	BX, DGROUP
	MOV	DS, BX			;re initialize ds, es
	MOV	ES, BX			;exit here if the status of source, target or default drv has been changed.
	CALL	CHK_MKDIR_LVL		;starting target directory has been created?
	CALL	ORG_S_T_DEF		;restore original target, source, default drv, and verify status

JUST_EXIT:				;unconditional immediate exit

; Restore the original status of APPEND if active.


	MOV	BX,APPENDFLAG		;AN000;GET THE STATUS WORD
	OR	BX,BX			;AN019;IF FLAGS SAVED, THIS IS DOS VER.
;	$IF	NZ			;AN019;IF ACTIVE,
	JZ $$IF7
	    MOV     AX,SET_APPEND	;AN000;SET TO THE ORIGINAL STATE
	    INT     2FH 		;AN000; turn on the /X feature
;	$ENDIF				;AN000;
$$IF7:
;
	MOV	AH, 4Ch 		;return to dos
	MOV	AL, ERRORLEVEL		;set return code whatever
	INT	21H
CTRL_BREAK_EXIT:
	MOV	ERRORLEVEL, 2		;set errorlevel to 2 for control break
	JMP	MAIN_EXIT_A

MAIN	ENDP
;


;----------------- SUBROUTINES ---------------------------------------------

TREE_COPY PROC	NEAR

;Walk the source tree to read files and subdirectories

	OR	MY_FLAG, FINDFILE_FLAG	;deals with files
	OR	MY_FLAG, FIND_FIRST_FLAG ;find first
	CALL	SET_MY_DTA		;set DTA to FILE_DTA
;	$DO
$$DO9:
	    CALL    FIND_FILE		;find first (next)
	    TEST    MY_FLAG, NO_MORE_FILE ;no more file?
;	$LEAVE	NZ			;then exit loop
	JNZ $$EN9
	    CALL    READ_INTO_BUFFER	;else read the file into the buffer
;	$ENDDO
	JMP SHORT $$DO9
$$EN9:

	TEST	OPTION_FLAG, SLASH_S	;walk the tree?
;	$IF	NZ,LONG
	JNZ $$XL1
	JMP $$IF12
$$XL1:

	    AND     MY_FLAG, RESET_FINDFILE ;now, deals with directory
	    OR	    MY_FLAG, FIND_FIRST_FLAG ;find first
;	    $DO
$$DO13:
		CALL	SET_MY_DTA	;set DTA to DTAS according to BP
		CALL	FIND_DIR	;find first (next)
		TEST	MY_FLAG, NO_MORE_FILE ;no more subdirectory?
;	    $LEAVE  NZ			;then leave this loop to return to caller
	    JNZ $$EN13
		LEA	DI, S_DRV_PATH
		LEA	SI, [BP].DTA_FILENAME
		CMP	S_PATH, 0	;root directory?
;		$IF	E
		JNE $$IF15
		    MOV     AL, 0FFh	;then '\' is already provided. Just concat.
;		$ELSE
		JMP SHORT $$EN15
$$IF15:
		    MOV     AL, PATH_DELIM ;put delimiter
;		$ENDIF
$$EN15:
		CALL	CONCAT_ASCIIZ	;make new path
		test	option_flag, slash_p ;prompt mode?
;		$IF	NZ
		JZ $$IF18
		    call    p_concat_display_path
;		$ENDIF
$$IF18:
		INC	S_DEPTH 	;increase depth
		CALL	MAKE_HEADER	;make header in the buffer
		OR	MY_FLAG, IS_SOURCE_FLAG ;dealing with source
		AND	MY_FLAG, RESET_VISIT_PARENT ;going to visit child node
		CALL	CHANGE_S_DIR	;change source dir
		ADD	BP, type FIND_DTA ;increase DTAS stack pointer
		CALL	TREE_COPY	;tree copy the sub directory
;	    $ENDDO
	    JMP SHORT $$DO13
$$EN13:

	    CMP     S_DEPTH, 0		;starting directory? then exit
;	    $IF     NE			;else
	    JE $$IF21
		DEC	S_DEPTH 	;dec depth
		TEST	OPTION_FLAG, SLASH_E ;copy subdirectories even if empty?
;		$IF	Z
		JNZ $$IF22
		    CALL    DEL_EMPTY	;then check the old_buffer_ptr and
					;if it is a directory, then restore
					;buffer_ptr to old.
;		$ENDIF
$$IF22:
		LEA	DI, S_DRV_PATH
		CALL	LAST_DIR_OUT	;change environments
		test	option_flag, slash_p ;prompt mode?
;		$IF	NZ
		JZ $$IF24
		    call    p_cut_display_path
;		$ENDIF
$$IF24:
		LEA	DX, S_DRV_PATH	;before returning to the caller
		OR	MY_FLAG, IS_SOURCE_FLAG
		OR	MY_FLAG, VISIT_PARENT_FLAG
		CALL	CHANGE_S_DIR
		SUB	BP, type FIND_DTA
;	    $ENDIF
$$IF21:
;	$ENDIF				;walk the tree
$$IF12:
	RET
TREE_COPY ENDP
;

DEL_EMPTY PROC	NEAR
;If buffer is not full, and the tree walk is going to return to the parents,
;this routine should be called.
;If old_buffer_ptr points to a directory, then set buffer_ptr to this, and
;increase buffer_left by HEADER (para) and set old_buffer_ptr to that of
;BEFORE_PTR. i.e. delete the empty directory entry from the buffer.

	PUSH	ES

	PUSH	CS
	POP	AX
	CMP	OLD_BUFFER_PTR, AX	;buffer is empty?
	JE	DE_EXIT 		;yes, exit

	MOV	ES, OLD_BUFFER_PTR
	TEST	ES:ATTR_FOUND, 10h	;directory?
	JZ	DE_EXIT 		;if not, exit
	MOV	AX, OLD_BUFFER_PTR
	MOV	BUFFER_PTR, AX		;set new BUFFER_PTR
	MOV	AX, ES:BEFORE_PTR
	MOV	OLD_BUFFER_PTR, AX	;set new OLD_BUFFER_PTR
	MOV	AX, PARA_OF_HDR 	;AN005;GET THE HEADER SIZE (para.)
	ADD	BUFFER_LEFT, AX 	;AC005;dir entry must be only hdr SIZE.

DE_EXIT:
	POP	ES
	RET
DEL_EMPTY ENDP
;


P_concat_display_path proc near
;concatenate subdirectory name found from DTAS to the
;DISP_S_PATH which will be used for prompts
;DS - data seg
	MOV	DI, OFFSET DISP_S_PATH
	LEA	SI, [BP].DTA_FILENAME
	CMP	S_DEPTH, 0		;this will be the first subdir?
;	$IF	E
	JNE $$IF28
	    MOV     AL, 0FFh		;then do not put '\'
;	$ELSE
	JMP SHORT $$EN28
$$IF28:
	    MOV     AL, Path_delim
;	$ENDIF
$$EN28:
	CALL	CONCAT_ASCIIZ
	RET
P_concat_display_path endp
;


P_cut_display_path proc near
;take the last dir out from the DISP_S_PATH for prompt.
;DS,ES - data seg
	MOV	SI, OFFSET DISP_S_PATH
	MOV	DI, OFFSET DISP_S_PATH
	CALL	LAST_DIR_OUT
;	$IF	C
	JNC $$IF31
	    CALL    CHK_DRV_LETTER
;	    $IF     NC
	    JC $$IF32
		MOV	BYTE PTR DS:[SI], 0
;	    $ELSE
	    JMP SHORT $$EN32
$$IF32:
		MOV	BYTE PTR [DI], 0
;	    $ENDIF
$$EN32:
;	$ELSE
	JMP SHORT $$EN31
$$IF31:
	    CMP     S_DEPTH, 0
;	    $IF     E
	    JNE $$IF36
		MOV	DI, AX
		DEC	DI
		MOV	BYTE PTR [DI], '\'
		MOV	BYTE PTR [DI+1], 0
;	    $ENDIF
$$IF36:
;	$ENDIF
$$EN31:
	RET
P_cut_display_path endp
;


READ_INTO_BUFFER PROC NEAR
;Read *** a *** file	into buffer
	TEST	MY_FLAG, SINGLE_COPY_FLAG ;single copy?
;	$IF	Z,AND			;no, multi copy
	JNZ $$IF39
	TEST	ACTION_FLAG, READING_FLAG ;show message?
;	$IF	NZ			;yes.
	JZ $$IF39
	    MOV     AX,MSG_READING_SOURCE ;AN000; message number
	    MOV     MSG_NUM,AX		;AN000; set message number
	    MOV     SUBST_COUNT,NO_SUBST ;AN000; no message substitution
	    MOV     MSG_CLASS,UTILITY_MSG_CLASS ;AN000; message class
	    MOV     INPUT_FLAG,NO_INPUT ;AN000; no input
	    CALL    PRINT_STDOUT	;AN000;show message "Reading source files"

	    AND     ACTION_FLAG, RESET_READING ;reset it
;	$ENDIF
$$IF39:

	AND	FILE_FLAG, RESET_READFILE ;reset file_flag to read a file
	MOV	AX,FILE_DTA.DTA_FILE_SIZE_HIGH
	MOV	HIGH_FILE_SIZE, AX
	MOV	AX,FILE_DTA.DTA_FILE_SIZE_LOW
	MOV	LOW_FILE_SIZE, AX
	CALL	CMP_FILESIZE_TO_BUFFER_LEFT ;compare sizes

	MOV	AX, PARA_OF_HDR 	;AN005;GET THE HEADER SIZE (para.)
	CMP	MAX_BUFFER_SIZE, AX	;AN005;IS EA BUFFER TOO LARGE?
;	$IF	B
	JNB $$IF41
	    CLC 			;AN005;CLEAR CARRY
	    MOV     AX, MSG_INSUF_MEMORY ;AC005;GET THE MESSAGE ID
	    MOV     MSG_NUM,AX		;AN005;NEED MESSAGE ID FOR PRINT
	    MOV     SUBST_COUNT,NO_SUBST ;AN005;NO SUBSTITUTION TEXT
	    MOV     INPUT_FLAG,NO_INPUT ;AN005;NO INPUT = 0
	    MOV     MSG_CLASS,UTILITY_MSG_CLASS ;AN005;MESSAGE CLASS = -1
	    CALL    PRINT_STDERR	;AN005;print error. AX points to msg ID
;	$ENDIF				;AN005;WE HAVE ENOUGH MEMORY
$$IF41:
	MOV	AX, PARA_OF_HDR 	;AN005;GET THE HEADER SIZE (para.)
	CMP	MAX_BUFFER_SIZE,AX	;AN005;IS EA BUFFER TOO LARGE?
	JB	RIB_ERROR		;AN005;CLOSE THE FILE AND GET THE NEXT

	TEST	FILE_FLAG, FILE_BIGGER_FLAG ;filesize > buffer_left - HEADER ?
	JZ	RIB_SMALL		;if not, then small file
	MOV	BX, S_HANDLE		;AN005;
	CALL	CLOSE_A_FILE		;AN005;ONLY OPENED TO GET BUFFER SIZE
	CALL	WRITE_FROM_BUFFER
	CALL	CMP_FILESIZE_TO_BUFFER_LEFT ;compare again
	TEST	FILE_FLAG, FILE_BIGGER_FLAG ;still bigger?
	JNZ	RIB_BIG 		;yes.  Big file
RIB_SMALL:
	CALL	SMALL_FILE
	JC	RIB_ERROR
	JMP	short RIB_EXIT
RIB_BIG:
	MOV	BX, S_HANDLE		;AN005;
	CALL	CLOSE_A_FILE		;AN005;ONLY OPENED TO GET BUFFER SIZE
	CALL	BIG_FILE
	JNC	RIB_EXIT
RIB_ERROR:
	TEST	COPY_STATUS, OPEN_ERROR_FLAG ;open error?
	JNZ	RIB_EXIT		;just exit. find next file
	MOV	BX, S_HANDLE		;else write error
	CALL	CLOSE_A_FILE		;close the troubled file
					;and find next file
RIB_EXIT:
	TEST	MY_FLAG, SINGLE_COPY_FLAG ;single copy?
;	$IF	NZ
	JZ $$IF43
	    CALL    WRITE_FROM_BUFFER	;then write a file
;	$ENDIF
$$IF43:
	RET
READ_INTO_BUFFER ENDP
;


SMALL_FILE PROC NEAR
;handles a file smaller than max_buffer_size or buffer_left, i.e. fit in memory.
;This routine will call MAKE_HEADER, SET_BUFFER_PTR< READ_A_FILE,
;CALC_FILE_SIZE, CMP_FILE_FFD0h, CLOSE_A_FILE.

SMF_CONT:
	CALL	CMP_FILE_FFD0h		;filesize > 0FFD0h ?
	TEST	FILE_FLAG, FILE_BIGGER_FLAG
	JZ	SMF_EOF 		;filesize <= 0FFD0h
	OR	FILE_FLAG, CONT_FLAG	;filesize > 0FFD0h. set cont_flag
	MOV	CX, 0FFD0h		;# of bytes to read
	CALL	READ_A_FILE
	JC	SMF_ERROR		;unsuccessful read?
	CALL	MAKE_HEADER		;else make header and ready for next
	CALL	CALC_FILE_SIZE		;filesize = filesize - bytes read
	JMP	SMF_CONT		;loop. compare again with the rest

SMF_EOF:
	MOV	CX, LOW_FILE_SIZE	;rest of the bytes to read
	OR	FILE_FLAG, EOF_FLAG	;AN000;set EOF
	CALL	READ_A_FILE
	JC	SMF_ERROR
	CALL	MAKE_HEADER
	MOV	BX, S_HANDLE
	CALL	CLOSE_A_FILE
	JMP	short SMF_EXIT
SMF_ERROR:
					;
SMF_EXIT:
	RET
SMALL_FILE ENDP
;


BIG_FILE PROC	NEAR
;handles a file which is bigger than max_buffer_size
;Needs 2 file handles open concurrently for read and write

	OR	FILE_FLAG, BIG_FILE_FLAG
	OR	FILE_FLAG, CONT_FLAG
	CALL	OPEN_A_FILE
	JC	BIF_ERROR		;error in open?
	CMP	MAX_BUFFER_SIZE, 0FFFh	;max buffer size > 0FFFh in para ?
	JA	BIF_BIG 		;yes. large buffer system
					;else small buffer
	MOV	CX, MAX_CX		;CX = max_buffer_size * 16 - HEADER
BIF_SM:
	CALL	READ_A_FILE
	JC	BIF_ERROR		;read error?
	CALL	MAKE_HEADER
	CALL	WRITE_FROM_BUFFER
	JC	BIF_ERROR		;write error?
	TEST	FILE_FLAG, EOF_FLAG	;end of file set by READ_A_FILE?
	JZ	BIF_SM			;if not, read again
	MOV	BX, S_HANDLE
	CALL	CLOSE_A_FILE
	JMP	short BIF_EXIT		;finished.
BIF_BIG:
	MOV	CX, 0FFD0h		;max # of data bytes this program supports
BIF_BIG1:
	CALL	READ_A_FILE
	JC	BIF_ERROR
	CALL	MAKE_HEADER
	CALL	CALC_FILE_SIZE		;modify file size
BIF_BIG2:
	CALL	CMP_FILESIZE_TO_BUFFER_LEFT ;filesize > buffer_left?
	TEST	FILE_FLAG, FILE_BIGGER_FLAG ;yes.
	JZ	BIF_END 		;if it is not, call small_file
	MOV	AX, PARA_OF_HDR 	;AN021;GET THE ATTR. HDR SIZE
	ADD	AX, 0FFFh		;AN021;
	CMP	BUFFER_LEFT, AX 	;AC021;BUFFER_LEFT >= 0FFF0h+HDR SIZE?
	JAE	BIF_BIG 		;then loop again.
	MOV	AX, PARA_OF_HDR 	;AN021;GET THE ATTR. HDR SIZE
	ADD	AX, 140H		;AN021;
	CMP	BUFFER_LEFT, AX 	;AC021;BUFFER_LEFT >= 5Kbytes+HDR SIZE?
					;minimum buffer size this pgm supports.
	JL	BIF_BIG3		;then flush buffer and try again. **IF system buffer left < 5 K then infinit loop can happen.
	MOV	AX,BUFFER_LEFT
	SUB	AX,PARA_OF_HDR		;AC005;FOR HEADER SIZE para.
	MOV	CX,16
	MUL	CX			;AN020;MAKE IT NUMBER OF BYTES
	MOV	CX,AX			;AN020;FOR READ
	JMP	BIF_BIG1		;read again
BIF_BIG3:
	CALL	WRITE_FROM_BUFFER
	JC	BIF_ERROR
	JMP	BIF_BIG2		;flush buffer and compare again.
BIF_END:
	CALL	SMALL_FILE		;when filesize <= buffer_left then SMALL_FILE will finish it.
	JC	BIF_ERROR		;something wrong?
	CALL	WRITE_FROM_BUFFER	;else finish copying this file
	JNC	BIF_EXIT
BIF_ERROR:
					;what happened?
BIF_EXIT:
	RET
BIG_FILE ENDP
;


MAKE_HEADER PROC NEAR
;When called by READ_A_FILE after the data had been read into the buffer, this
;routine will put the header which is just below the data area where the
;current BUFFER_PTR points.  The header E.A.BUFFER SIZE + (3 para) long. And
;this routine will also call SET_BUFFER_PTR to set the BUFFER_PTR, BUFFER_LEFT
;for the next process.
;If called by TREE_COPY for a SUBDIRECTORY handle, this routine should
;check the BUFFER_LEFT (when called by READ_A_FILE, the caller is assumed
;to check the size of buffer_left before calling.)  In this case, this
;routine will set the next BUFFER_PTR, BUFFER_LEFT, OLD_BUFFER_PTR
;instead of SET_BUFFER_PTR routine.
;Informations are obtained from the DTA area (for file - FILE_DTA.xxx
;dir - DS:[BP].xxx ) and stored into the header by referencing ES:field;s name.
;DS - Program Data area
;ES - will be used for a header segment in the buffer.
;
	PUSH	ES			;save ES
	PUSH	AX

MH_AGAIN:
	MOV	AX,BUFFER_PTR		;buffer_ptr is a segment
	MOV	ES, AX			;now, ES is a header seg.
;

	MOV	AX, PARA_OF_HDR 	;AN005;GET THE HEADER SIZE (para.)
	CMP	BUFFER_LEFT,AX		;AC005;buffer_left=less than NEEDED?
	JAE	MH_START
	CALL	WRITE_FROM_BUFFER	;if so, flush buffer
	JC	MH_ERROR_BRIDGE 	;write error?
	JMP	SHORT MH_AGAIN		;reinitialize ES to new buffer ptr
MH_START:
	TEST	MY_FLAG, FINDFILE_FLAG	;identify caller.
	JNZ	MH_FILE 		;if a file, jmp to MH_FILE
					;else deals with directory.
	MOV	ES:CONTINUE_INFO, 0	;not a continuation.
	MOV	AX,OLD_BUFFER_PTR
	MOV	ES:BEFORE_PTR, AX	;set before_ptr in header
	MOV	AX,BUFFER_PTR
	MOV	OLD_BUFFER_PTR, AX	;set variable OLD_BUFFER_PTR
	ADD	AX,PARA_OF_HDR		;AC005;AX = BUFFER_PTR+HEADER(para)
	MOV	BUFFER_PTR, AX		;set new BUFFER_PTR
	MOV	ES:NEXT_PTR, AX 	;set NEXT_PTR in the header
	MOV	AX, PARA_OF_HDR 	;AN005;GET THE HEADER SIZE (para.)
	SUB	BUFFER_LEFT,AX		;AC005;adjust BUFFER_LEFT
	CMP	BUFFER_LEFT,AX		;AC005;less than HEADER SIZE (para) ?
;	$IF	B
	JNB $$IF45
	    MOV     BUFFER_LEFT, 0	;indicate buffer_full
;	$ENDIF
$$IF45:
	MOV	AL, S_DEPTH
	MOV	ES:DIR_DEPTH, AL	;now save other info's
	MOV	AL, DS:[BP].DTA_ATTRIBUTE
	MOV	ES:ATTR_FOUND, AL	;in this case, DIR
	MOV	AL, BYTE PTR T_DRV
	MOV	ES:TARGET_DRV_LET, AL	;mov target drive letter
	MOV	ES:TARGET_DRV_LET+1, DRV_delim ; ':'
	MOV	CX, 13
	LEA	SI, [BP].DTA_FILENAME	;DS:SI
	MOV	DI, FILENAME_FOUND ;ES:DI
	REP	MOVSB			;mov sting until cx = 0
	JMP	MH_EXIT
MH_ERROR_BRIDGE: JMP MH_ERROR
MH_FILE:				;handles a file header hereafter.
	TEST	FILE_FLAG, CONT_FLAG	;continuation?
	JZ	MH_WHOLE_FILE		;no, just a whole file
	TEST	FILE_FLAG, EOF_FLAG	;Eof flag set?
	JNZ	MH_CONT_END		;yes, must be end of continuation
	TEST	FILE_FLAG, BIG_FILE_FLAG ;Is this a big file?
	JNZ	MH_BIG			;yes
	MOV	ES:CONTINUE_INFO, 1	;else small file continuation.
	JMP	short MH_A_FILE
MH_WHOLE_FILE:
	MOV	ES:CONTINUE_INFO, 0
	JMP	short MH_A_FILE
MH_CONT_END:
	MOV	ES:CONTINUE_INFO, 3
	JMP	short MH_A_FILE
MH_BIG:
	MOV	ES:CONTINUE_INFO, 2
MH_A_FILE:
	MOV	AX,FILE_DTA.DTA_FILE_TIME
	MOV	ES:FILE_TIME_FOUND, AX
	MOV	AX, FILE_DTA.DTA_FILE_DATE
	MOV	ES:FILE_DATE_FOUND, AX
	MOV	AX, FILE_DTA.DTA_FILE_SIZE_LOW
	MOV	ES:LOW_SIZE_FOUND, AX
	MOV	AX, FILE_DTA.DTA_FILE_SIZE_HIGH
	MOV	ES:HIGH_SIZE_FOUND, AX
	MOV	AL, BYTE PTR T_DRV
	MOV	ES:TARGET_DRV_LET, AL
	MOV	ES:TARGET_DRV_LET+1, DRV_DELIM
	MOV	CX, 13
	MOV	SI, OFFSET FILE_DTA.DTA_FILENAME
	MOV	DI, FILENAME_FOUND
	REP	MOVSB

; EA stuff used to be here

	MOV	AX, OLD_BUFFER_PTR
	MOV	ES:BEFORE_PTR, AX
	MOV	AX, ACT_BYTES
	MOV	ES:CX_BYTES, AX
	CALL	SET_BUFFER_PTR		;set buffer_ptr for next. AX is already set.
	MOV	AX, BUFFER_PTR
	MOV	ES:NEXT_PTR, AX 	;next buffer_ptr is next_ptr
	MOV	AL, S_DEPTH
	MOV	ES:DIR_DEPTH, AL	;same as source depth
	MOV	AL, FILE_DTA.DTA_ATTRIBUTE
	MOV	ES:ATTR_FOUND, AL	;attribute found
	JMP	short MH_EXIT 		;AN000;
MH_ERROR:
	OR	COPY_STATUS, OPEN_ERROR_FLAG ;AN000;
	CALL	EXTENDED_ERROR_HANDLER	;AN000;
MH_EXIT:
	POP	AX
	POP	ES
	RET
MAKE_HEADER ENDP
;


OPEN_A_FILE PROC NEAR

;-------------------------------------------------------------------------
; Use extended open DOS call to open source file,
; if successfully open, then save filehand to S_HANDLE.
; And update the open file count.
;-------------------------------------------------------------------------

	LEA	SI,FILE_DTA.DTA_FILENAME ;AN005; DS:SI-->NAME TO OPEN
	MOV	DX,OPN_FLAG		;AN000; flag = 0101H
	MOV	CX,OPN_ATTR		;AN000; attribute = 0
	MOV	BX,OPN_MODE		;AN007; open mode = 0000H (READ)
	MOV	DI, NUL_LIST		;AN005; ES:DI = -1
	MOV	AX, Ext_Open		;AN000; = 6Ch
	INT	21H			;AN000; OPEN SOURCE FILE

	JC	OF_ERROR
	MOV	S_HANDLE, AX		;save filehandle
	INC	OPEN_FILE_COUNT 	;AN005;UPDATE THE OPEN FILE COUNTER

	JMP	SHORT OF_EXIT 		;AN000; exit

OF_ERROR:
	OR	COPY_STATUS, OPEN_ERROR_FLAG
	CALL	EXTENDED_ERROR_HANDLER
OF_EXIT:
	RET
OPEN_A_FILE ENDP
;


CMP_FILE_FFD0h PROC NEAR
;check whether the filesize in HIGH_FILE_SIZE, LOW_FILE_SIZE is bigger than
;0FFD0h.  If it is, then set FILE_BIGGER_FLAG, else reset it.
	CMP	HIGH_FILE_SIZE, 0
;	$IF	E,AND
	JNE $$IF47
	CMP	LOW_FILE_SIZE, 0FFD0h
;	$IF	BE
	JNBE $$IF47
	    AND     FILE_FLAG, RESET_FILE_BIGGER ;filesize <= 0FFD0h
;	$ELSE
	JMP SHORT $$EN47
$$IF47:
	    OR	    FILE_FLAG, FILE_BIGGER_FLAG
;	$ENDIF
$$EN47:
	RET
CMP_FILE_FFD0h ENDP
;

CALC_FILE_SIZE PROC NEAR
;subtract the bytes read (ACT_BYTES) from the filesize in HIGH_FILE_SIZE,
;LOW_FILE_SIZE.
	MOV	AX, ACT_BYTES
	SUB	LOW_FILE_SIZE, AX
	SBB	HIGH_FILE_SIZE, 0
	RET
CALC_FILE_SIZE ENDP
;


READ_A_FILE PROC NEAR
;read a file.
;if after reading, AX < CX or AX = 0 the set EOF_FLAG.
;INPUT:CX - # of bytes to read
;      BUFFER_PTR
;      S_HANDLE
;OUTPUT: ACT_BYTES

	PUSH	DS			;save program data seg
	MOV	AH, Read
	MOV	BX, S_HANDLE
	MOV	DX, BUFFER_PTR		;current buffer header seg
	ADD	DX, PARA_OF_HDR 	;AC005;skip the header part
	MOV	DS, DX			;now DS = buffer_ptr + HDR, data area
	XOR	DX, DX			;offset DX = 0
	INT	21H
	POP	DS			;restore program data area
	JC	RF_ERROR		;read error?
	CMP	AX, CX
	JE	RF_OK
	OR	FILE_FLAG, EOF_FLAG	;EOF reached. AX = 0 or AX < CX
RF_OK:
	CLC				;clear carry caused from CMP
	MOV	ACT_BYTES, AX		;save actual bytes read
	JMP	SHORT RF_EXIT
RF_ERROR:
	OR	COPY_STATUS, READ_ERROR_FLAG
	CALL	EXTENDED_ERROR_HANDLER
RF_EXIT:
	RET
READ_A_FILE ENDP
;


;*********************************************************************
;* Routine:  find_it						     *
;* Function: determine whether the file referenced by DX exists, by  *
;* calling either Find First File (function 4Eh) or Find Next File   *
;* (function 4Fh)						     *
;* Side Effects: If the function finds a directory entry that	     *
;* matches the name and attribute, it fills the current Disk	     *
;* Transfer Address with the following: 21 bytes reserved for	     *
;* subsequent Find Next File calls, 1 byte of the attribute found,   *
;* 2 bytes of time file last written, 2 bytes of date last written,  *
;* 2 bytes of low word of file size, 2 bytes of high word of file    *
;* size, and 13 bytes of name/extension of file 		     *
;*********************************************************************

FIND_IT PROC	NEAR
;set first or next depending on FIND_FIRST_FLAG.
;once called, reset FIND_FIRST_FLAG.
;*procedure rewritten entirely Dec 27, 1989 Lea F.

; ====================================================================	  ;I00
									  ;I00
	TEST	MY_FLAG,  FIND_FIRST_FLAG				  ;I00
	JZ	DONEXT							  ;I00
	AND	MY_FLAG,  RESET_FIND_FIRST				  ;I00
	MOV	AH,  FIND_FIRST						  ;I00
	INT	21H							  ;I00
	PUSHF				; Preserver flag status		  ;I00
;	JNC	END_FIND_IT						  ;I00
	JNC	FIX_FLAGS						  ;I00
	CMP	FOUND_FILE_FLAG, 1	;Q. Found any files before?	  ;I00
	JE	FIX_FLAGS		;  Y. go correct the errorlevel   ;I00
	MOV	ERRORLEVEL,  1		;  N. errorlevel=no files found   ;I00
									  ;I00
FIX_FLAGS:								  ;I00
	POPF				; Return Flag status		  ;I00
	JMP	SHORT	END_FIND_IT					  ;I00
									  ;I00
DONEXT: MOV	AH,  FIND_NEXT						  ;I00
	INT	21H							  ;I00
END_FIND_IT:	RET							  ;I00

; ====================================================================	  ;I00
; I000
; I000	TEST	MY_FLAG,  FIND_FIRST_FLAG
; I000	JZ	DONEXT
; I000	AND	MY_FLAG,  RESET_FIND_FIRST
; I000	MOV	AH,  FIND_FIRST
; I000	INT	21H
; I000	JNC	END_FIND_IT
; I000	MOV	ERRORLEVEL,  1
; I000	JMP	SHORT	END_FIND_IT
; I000DONEXT: MOV	AH,  FIND_NEXT
; I000	INT	21H
; I000END_FIND_IT:	RET
; I000
; ====================================================================	  ;I00

FIND_IT ENDP
;



FIND_FILE PROC	NEAR
;find a file
;set NO_MORE_FILE if carry.
;	$SEARCH
$$DO50:
	    TEST    MY_FLAG, FIND_FIRST_FLAG ;find first ?
;	    $IF     NZ
	    JZ $$IF51
		MOV	DX, OFFSET S_FILE
		MOV	CX, File_Search_Attr ;normal = 0
;	    $ELSE
	    JMP SHORT $$EN51
$$IF51:
		MOV	DX, OFFSET FILE_DTA
;	    $ENDIF
$$EN51:
	    CALL    FIND_IT
;	$EXITIF C
	JNC $$IF50
	    OR	    MY_FLAG, NO_MORE_FILE ;no more file in this directory
;	$ORELSE
	JMP SHORT $$SR50
$$IF50:
	    MOV     FOUND_FILE_FLAG, 1	;set the flag for "File not found" msg.

; We have found a file. So, if errorlevel 1 is a 1, which means no file has
; been found so far, reset errorlevel 1 to 0.
	    CMP     ERRORLEVEL,1	    ;Q. Is errorlevel=no file found
	    JNE     $$IF52		    ;  N. filter files
	    MOV     ERRORLEVEL, 0	    ;  Y. It shouldn't, correct it!
$$IF52:     CALL    FILTER_FILES	;found. filter it with options
	    TEST    MY_FLAG, FOUND_FLAG
;	$ENDLOOP NZ			;if found, leave this loop else start again
	JZ $$DO50
	    AND     MY_FLAG, RESET_NO_MORE
;	$ENDSRCH
$$SR50:
	RET
FIND_FILE ENDP
;




FIND_DIR PROC	NEAR
;find directory entry
;set NO_MORE_FLAG if carry.
;	$SEARCH
$$DO58:
	    TEST    MY_FLAG, FIND_FIRST_FLAG
;	    $IF     NZ
	    JZ $$IF59
		MOV	DX, OFFSET  S_DIR
		MOV	CX, DIR_SEARCH_ATTR
;	    $ELSE
	    JMP SHORT $$EN59
$$IF59:
		MOV	DX, BP
;	    $ENDIF

$$EN59:
	    CALL    FIND_IT
;	$EXITIF C			;no more file
	JNC $$IF58
	    OR	    MY_FLAG, NO_MORE_FILE ;set MY_FLAG and exit this loop
;	$ORELSE 			;otherwise found a file
	JMP SHORT $$SR58
$$IF58:      ; found a file
	    TEST    DS:[BP].DTA_ATTRIBUTE, Is_subdirectory ; directory?
;	    $IF     E,AND
	    JZ  $$IF64
	    CMP     DS:[BP].DTA_FILENAME, A_dot ;starts with . ?
;	    $IF     NE			;if not, then desired subdir
	    JE $$IF64
		OR	MY_FLAG, FOUND_FLAG ;found
;	    $ELSE
	    JMP SHORT $$EN64
$$IF64:
		AND	MY_FLAG, RESET_FOUND
;	    $ENDIF
$$EN64:
	    TEST    MY_FLAG, FOUND_FLAG
;	$ENDLOOP NZ			;if found, leave this loop else start again
	JZ $$DO58
	    AND     MY_FLAG, RESET_NO_MORE ;found. set my_flag and exit
;	$ENDSRCH
$$SR58:
	RET
FIND_DIR ENDP
;




;*********************************************************************
;* Routine: filter_files					     *
;* Function: compare the file currently being examined against any   *
;* options which might have been specified.  If the file satisfies   *
;* all options specified, designate it as "found".		     *
;* Procedure: OPTION_FLAG is the byte containing all the options     *
;* which were set by the user.	If /a was one, call chk_archive_bit *
;* to determine if the archive bit for the file is set.  Etc.  If    *
;* file satisfies all options found, FOUND_FLAG is set to true. Else *
;* RESET_FOUND is set to true.					     *
;*********************************************************************
FILTER_FILES PROC NEAR
;FILE_DTA.XXX HAS INFORMATIONS
;this routine also show the prompt of source path, filename, if SLASH_P is on.

	TEST	OPTION_FLAG, SLASH_A	;soft archive?
	JNZ	SLASH_AM_RTN		;yes
	TEST	OPTION_FLAG, SLASH_M	;then hard archive?
	JNZ	SLASH_AM_RTN		;yes
FF_D:
	TEST	OPTION_FLAG, SLASH_D	;date?
	JNZ	SLASH_D_RTN
FF_P:
	TEST	OPTION_FLAG, SLASH_P	;prompt mode? ** this should be placed last.
	JNZ	SLASH_P_RTN
	JMP	SHORT FF_FOUND		;no more selective options. copy this file.
SLASH_AM_RTN:				;soft or hard archive.
	CALL	CHK_ARCHIVE_BIT
	JC	FF_NOT_FOUND
	JMP	SHORT FF_D		;check other options
SLASH_D_RTN:
	CALL	CHK_DATE_FILE		;check file's date
	JC	FF_NOT_FOUND
	JMP	SHORT FF_P
slash_p_rtn:
	call	prompt_path_file	;show message and get input from the user
	jc	ff_not_found		;user does not want this file
FF_FOUND:
	OR	MY_FLAG, FOUND_FLAG	;set found_flag
	JMP	SHORT FF_EXIT
FF_NOT_FOUND:
	AND	MY_FLAG, RESET_FOUND	;this file is not what we want to copy
FF_EXIT:
	RET
FILTER_FILES ENDP
;

;*********************************************************************
;* Routine: chk_archive_bit					     *
;* Function: determine whether the file currently being examined has *
;* its archive bit turned on					     *
;* Procedure: examine the archive byte in the file DTA area.  If bit *
;* is set, clear the carry flag, else set it			     *
;*********************************************************************
CHK_ARCHIVE_BIT PROC NEAR
;check the current FILE.DTA area and if archive bit is on, found.
	TEST	FILE_DTA.DTA_ATTRIBUTE, 20h ;archive on?
;	$IF	NZ			;yes
	JZ $$IF69
	    CLC 			;clear carry
;	$ELSE
	JMP SHORT $$EN69
$$IF69:
	    STC 			;archive bit is off. Don't
;	$ENDIF				;have to copy this file
$$EN69:
	RET
CHK_ARCHIVE_BIT ENDP
;
CHK_DATE_FILE PROC NEAR
;
	MOV	CX, FILE_DTA.DTA_FILE_DATE
	CMP	CX, INPUT_DATE		;FILE_DATE < INPUT_DATE
;	$IF	B
	JNB $$IF72
	    STC 			;not found
;	$ELSE
	JMP SHORT $$EN72
$$IF72:
	    CLC 			;found desired file
;	$ENDIF
$$EN72:
	RET
CHK_DATE_FILE ENDP
;


PROMPT_PATH_FILE PROC NEAR

;show the current source path, filename found, and get the user input.
;if it is yes, then reset carry, no, set carry otherwise show
;the whole message again.
;DS, ES - data seg

	MOV	CX, 13			;13 max
	LEA	SI, FILE_DTA.DTA_FILENAME
	MOV	DI, OFFSET DISP_S_FILE
	REP	MOVSB			;filename => disp_s_file
PPF_AGAIN:
	LEA	SI,SUBLIST1		;AN000; get addressability to sublist
	LEA	DX,DISP_S_PATH		;AN000; offset to PATH NAME
	MOV	[SI].DATA_OFF,DX	;AN000; save offset
	MOV	[SI].DATA_SEG,DS	;AN000; save data segment
	MOV	[SI].MSG_ID,1		;AN000; message ID
	MOV	[SI].FLAGS,010H 	;AN000; ASCIIZ string, left align
	MOV	[SI].MAX_WIDTH,0	;AN000; MAXIMUM FIELD WITH
	MOV	[SI].MIN_WIDTH,0	;AN000; MINIMUM FIELD WITH

	LEA	SI,SUBLIST2		;AN000; get addressability to sublist
	LEA	DX,DISP_S_FILE		;AN000; offset to FILE NAME
	MOV	[SI].DATA_OFF,DX	;AN000; save offset
	MOV	[SI].DATA_SEG,DS	;AN000; save data segment
	MOV	[SI].MSG_ID,2		;AN000; message ID
	MOV	[SI].FLAGS,010H 	;AN000; ASCIIZ string, left align
	MOV	[SI].MAX_WIDTH,0	;AN000; MAXIMUM FIELD WITH
	MOV	[SI].MIN_WIDTH,0	;AN000; MINIMUM FIELD WITH
	LEA	SI,SUBLIST1		;AN000;

	CMP	S_DEPTH,0		;now dealing with starting dir?
	JE	PATH_FILE_QUERY 	;ask (Y/N)
	JMP	SHORT PPF_1

PATH_FILE_QUERY:

	MOV	AX,P_S_PATH_FILE0	;no back slash, since it is already there
	JMP	SHORT PPF_PRT 		;AN000;

PPF_1:

	MOV	AX,P_S_PATH_FILE1	; Path and file name with
					; back slash delemeter
PPF_PRT:
	MOV	MSG_NUM,AX		;AN000; set message number
	MOV	SUBST_COUNT,PARM_SUBST_TWO ;AN000; substitution count
	MOV	MSG_CLASS,UTILITY_MSG_CLASS ;AN000; message class
	MOV	INPUT_FLAG,DOS_KEYB_INP ;AN000; Y or N INPUT
	CALL	PRINT_STDOUT		;AN000; Display message
	PUSH	AX			;AN000; SAVE IT

	MOV	AX,MSG_CR_LF_STR	;AN000; JUST CR,LF
	MOV	MSG_NUM,AX		;AN000; set message number
	MOV	SUBST_COUNT,NO_SUBST	;AN000; substitution count = 0
	MOV	MSG_CLASS,UTILITY_MSG_CLASS ;AN000; message class
	MOV	INPUT_FLAG,NO_INPUT	;AN000; NO INPUT
	CALL	PRINT_STDOUT		;AN000; Display message

	POP	AX			;AN000; GET IT BACK
; On return from prompt msg, AX contains Y or N response character
	MOV	DL,AL			;AN000;
	MOV	AH,65H			;AN000;
	MOV	AL,023H 		;AN000; Y/N check function
	INT	21H			;AN000; Issue Extended country to
					;	 capitalize  the Y/N response
	JC	PPF_RETRY		;AN000; NOT Y OR N, ASK AGAIN
	CMP	AX,1			;AN000; look for Y
	JG	PPF_RETRY		;AN000; NOT Y OR N, ASK AGAIN

	CMP	AX,0			;AN000; look for N
	JE	PPF_NO			;AN000;
PPF_YES:
	CLC				;AN000;CLEAR CARRY
	JMP	SHORT PPF_EXIT
PPF_RETRY:
	JMP	PPF_AGAIN		;AN000;ASK AGAIN
PPF_NO:
	STC				;AN000;set carry
PPF_EXIT:
	RET
PROMPT_PATH_FILE ENDP
;



SET_MY_DTA PROC NEAR
;set DS:DX for find_first(next). If MY_FLAG is set to FINDFILE_FLAG then
;set it to the offset FILE_DTA, otherwise to BP.
;DS should be set to the area whre FILE_DTA, DTAS are.
	PUSH	DX			;save current DX
	TEST	MY_FLAG, FINDFILE_FLAG	;handling file?
;	$IF	NZ
	JZ $$IF75
	    MOV     DX, OFFSET FILE_DTA
;	$ELSE
	JMP SHORT $$EN75
$$IF75:
	    MOV     DX, BP
;	$ENDIF
$$EN75:
	MOV	AH, Set_DTA
	INT	21H
	POP	DX
	RET
SET_MY_DTA ENDP
;

CHANGE_S_DIR PROC NEAR
;change source directory
;DS points to program data seg.

	CMP	S_DRV[2], 0		;LAST_DIR_OUT have took '\' out?
;	$IF	E
	JNE $$IF78
	    MOV     S_DRV[2], '\'	;then restore '\' for root dir
	    MOV     S_DRV[3], 0
;	$ENDIF
$$IF78:

	TEST	SYS_FLAG, ONE_DISK_COPY_FLAG ;one drive letter copy?
;	$IF	NZ,OR			;yes
	JNZ $$LL80
	TEST	OPTION_FLAG, SLASH_M	;hard archive option? (should use full path
;	$IF	NZ			; since hard archive operation will corrupt the current directory)
	JZ $$IF80
$$LL80:
	    MOV     DX, OFFSET S_DRV_PATH ;always use full path
;	$ELSE
	JMP SHORT $$EN80
$$IF80:
	    TEST    MY_FLAG, VISIT_PARENT_FLAG ;now going toward the root?
;	    $IF     NZ			;yes
	    JZ $$IF82
		MOV	DX, OFFSET S_PARENT ;just '..',0
;	    $ELSE
	    JMP SHORT $$EN82
$$IF82:
		LEA	DX, [BP].DTA_FILENAME ;use the subdir name just found
;	    $ENDIF
$$EN82:
;	$ENDIF
$$EN80:
	MOV	AH, Chdir		; = 3Bh
	INT	21H
;	$IF	C
	JNC $$IF86
	    OR	    COPY_STATUS, CHDIR_ERROR_FLAG ;chdir error in source. critical
	    CALL    EXTENDED_ERROR_HANDLER
;	$ENDIF
$$IF86:

	RET
CHANGE_S_DIR ENDP
;

CHANGE_T_DIR PROC NEAR
;change target dir according to t_drv_path.
;Since this routine is called by WRITE_FROM_BUFFER and DS now points
;to buffer area while ES points to the program data area, we set DS
;to data seg again here for the function call Chdir.
	PUSH	DS			;save current buffer seg
	PUSH	ES			;currentpy es is a data seg
	POP	DS			;restore DS value as program data seg

	CMP	T_DRV[2], 0		;LAST_DIR_OUT took '\' out?
;	$IF	E
	JNE $$IF88
	    MOV     T_DRV[2], '\'	;then put it back for root dir
	    MOV     T_DRV[3], 0
;	$ENDIF
$$IF88:

	MOV	DX, OFFSET T_DRV_PATH
	MOV	AH, CHDIR
	INT	21H

	POP	DS			;restore caller's DS value
	RET
CHANGE_T_DIR ENDP
;

CMP_FILESIZE_TO_BUFFER_LEFT PROC NEAR
;Compare buffer_left (paragraph) with filesize (high_file_size, low_file_size.)
;if filesize is bigger than buffer_left, then set FILE_BIGGER_FLAG
;indicating filesize > buffer_left.
;
	PUSH	DX
	PUSH	AX

	CMP	OPEN_FILE_COUNT,NUL	;AN005;ARE THERE ANY OPEN FILES
;	$IF	Z			;AN005;NO, THEN GO AHEAD AND OPEN
	JNZ $$IF90
	    CALL    OPEN_A_FILE 	;AN005;OPEN A FILE USING FILE_DTA

; EA stuff used to be here

	    XOR     CX,CX		;AN005; JUST QUERY SIZE NEEDED
	    ADD     CX,PARA_BOUND	;AN005; TO FIGURE THE NEXT PARAGRAPH
	    MOV     AX,CX		;AN005;
	    MOV     CL,PARAGRAPH	;AN005; GET PARAGRAPHS (DIV BY 16)
	    SHR     AX,CL		;AN005;
	    MOV     SIZ_OF_BUFF,AX	;AN005;SAVE BUFF SIZE FOR THE HEADER
	    ADD     AX,FIXD_HD_SIZ	;AN005;GET THE TOTAL HEADER SIZE
	    MOV     PARA_OF_HDR,AX	;AN005;SAVE FOR LATER
	    SHL     AX, CL		;AN005;CONVERT BACK TO TOTAL BYTES
	    MOV     BYTS_OF_HDR,AX	;AN005;SAVE FOR LATER
;	$ENDIF				;AN005;
$$IF90:

	AND	FILE_FLAG, RESET_FILE_BIGGER
	MOV	AX,PARA_OF_HDR		;AN005;GET THE HEADER SIZE (para.)
	CMP	BUFFER_LEFT,AX		;AC005;buffer_left >= HEADER SIZE
;	$IF	AE
	JNAE $$IF92
	    MOV     AX, BUFFER_LEFT	;buffer_left in para
	    SUB     AX,PARA_OF_HDR	;AC005;consider header size in advance
	    MOV     CX, 16
	    MUL     CX			;* 16. result in DX;AX
	    CMP     HIGH_FILE_SIZE, DX
;	    $IF     A			;if high_filesize > dx
	    JNA $$IF93
		OR	FILE_FLAG, FILE_BIGGER_FLAG
;	    $ELSE
	    JMP SHORT $$EN93
$$IF93:
;		$IF	E
		JNE $$IF95
		    CMP     LOW_FILE_SIZE, AX
;		    $IF     A
		    JNA $$IF96
			OR	FILE_FLAG, FILE_BIGGER_FLAG
;		    $ENDIF
$$IF96:
;		$ENDIF
$$IF95:
;	    $ENDIF
$$EN93:
;	$ELSE
	JMP SHORT $$EN92
$$IF92:
	    OR	    FILE_FLAG, FILE_BIGGER_FLAG ;buffer_left < HEADER SIZE
;	$ENDIF
$$EN92:

	POP	AX
	POP	DX
	RET
CMP_FILESIZE_TO_BUFFER_LEFT ENDP
;

SET_BUFFER_PTR PROC NEAR
;set BUFFER_PTR, BUFFER_LEFT, OLD_BUFFER_PTR in paragraph boundary
;to be used when reading a file into buffer.
;this routine uses current BUFFER_PTR to figure out the next BUFFER_PTR.
;So, at initialization time set BUFFER_PTR to CS, and set AX to the offset
;of INIT,  then the resultant BUFFER_PTR indicates the BUFFER_BASE and
;OLD_BUFFER_PTR indicates CS.(This means if old_buffer_ptr = cs, then
;it is the start of buffer)
;To get the next BUFFER_PTR during multi-copy, just set the AX to the
;number of bytes read. This routine will add E.A.BUFFER SIZE + 3 para.
;for header size and will set the next BUFFER_PTR.
;input: AX - offset of buffer
;	Top_of_memory	in segment
;	current BUFFER_PTR
;	current OLD_BUFFER_PTR
;	current BUFFER_LEFT
;output: BUFFER_PTR	for next reading
;	 OLD_BUFFER_PTR
;	 BUFFER_LEFT (Top_of_memory - Buffer_Ptr. If it is 0, then indicates
;		      the BUFFER is FULL.  In this case, the BUFFER_PTR is
;		      invalid, but OLD_BUFFER_PTR keep the former buffer_ptr
;		      value which says that it is the last header in the buffer)
;** Currently this program support maxium top of memory in seg 0FFFF - resident
;   area.  This routine will check the overflow case to gaurd the next buffer_ptr
;   not to exceed FFFF.

	PUSH	CX
	MOV	CX, BUFFER_PTR
	MOV	OLD_BUFFER_PTR, CX	;set old_buffer_ptr
	MOV	CL, 4
	SHR	AX, CL			;get paragraphs
	INC	AX			;get next paragraph
	ADD	AX,PARA_OF_HDR		;AC005;consider header size
	ADD	BUFFER_PTR, AX		;add this to the current buffer_ptr

;	$IF	NC,AND			;not exceed 16 bit.
	JC $$IF102
	MOV	AX, Top_of_memory
	SUB	AX, BUFFER_PTR		;AX = Top_of_memory - Buffer_ptr
;	$IF	A			;if buffer_left > 0
	JNA $$IF102
	    MOV     BUFFER_LEFT, AX
;	$ELSE
	JMP SHORT $$EN102
$$IF102:
	    MOV     BUFFER_LEFT, 0	;indication of buffer full
;	$ENDIF
$$EN102:
	POP	CX
	RET
SET_BUFFER_PTR ENDP
;

WRITE_FROM_BUFFER PROC NEAR
;Write from the first header starting at buffer_base until finishes
;the last header which, actually, happens to be the old_buffer_ptr
;at the time of the call.  After the writing, reset the buffer_ptr
;to buffer_base again for the next read_into_buffer.
;If continue_info is 1 or 2 (Continue of small, bigfile) then after
;the creation of a target file, it will set the CREATED_FLAG.
;This flag will be reset when it found the continue_info to be 3
;(End of contine).
;For convenience of use of function call, ES will be used for
;the program data seg while DS will be used for the BUFFER seg.
;
	PUSH	DS
	PUSH	ES			;save ds, es

	PUSH	DS
	POP	ES			;set ES to program data seg

	OR	ACTION_FLAG, READING_FLAG ;show reading message next time
;	AND	ES:MY_FLAG, RESET_IS_SOURCE	;now, deals with target
					;set this for change_dir
	MOV	AX, ES:BUFFER_BASE
	MOV	DS, AX
	PUSH	CS
	POP	AX
	CMP	ES:OLD_BUFFER_PTR, AX	;if old_buffer_ptr = CS then
					;buffer is empty. Just exit
	JE	WFB_EXIT_BRIDGE
WFB_CD:
	CALL	CHANGE_T_DIR

; C02           	JC	WFB_ERROR_BRIDGE	;error?
  jnc   WFB_CHATT          ; no error, continue                      ; C02
  cmp   cs:md_err_ignore,1 ; did we have a problem with MKDIR ?      ; C02
  jne   WFB_ERROR_BRIDGE   ; No, just quit with message.             ; C02
  mov   cs:more_than_63,1  ; yes - set flag for later message.       ; C02
  jmp   short WFB_ERROR_BRIDGE  ;  leave program.                    ; C02


WFB_CHATT:
	TEST	DS:ATTR_FOUND, Is_subdirectory ;a subdirectory? = 10H
	JZ	WFB_FILE		;no. a file
WFB_CMP_DEPTH:
	MOV	AH, ES:T_DEPTH		;yes. a subdir.
	CMP	DS:DIR_DEPTH, AH	;DIR_DEPTH > T_DEPTH ?
	JBE	WFB_DEC_DEPTH		;if not, go to parent node
	LEA	DI, ES:T_DRV_PATH	;else goto child node
	LEA	SI, DS:FILENAME_FOUND
	CMP	ES:T_PATH, 0		;root directory?
;	$IF	E
	JNE $$IF105
	    MOV     AL, 0FFh		;then don't need to put delim since it is already there
;	$ELSE
	JMP SHORT $$EN105
$$IF105:
	    MOV     AL, Path_delim	;path_delim '\'
;	$ENDIF
$$EN105:
	CALL	CONCAT_ASCIIZ
	call	concat_display_path	;modify the path for display
	INC	ES:T_DEPTH
	CALL	MAKE_DIR		;try to make a new sub directory
	JC	WFB_EXIT_A_BRIDGE	;there exists a file with same name.
	MOV	AX, DS			;current buffer seg = old_buffer_ptr?
	CMP	ES:OLD_BUFFER_PTR, AX
	JNE	WFB_NEXT		;not finished yet. jmp to next
	OR	ES:MY_FLAG, MISSING_LINK_FLAG ;Finished. Missing link condition occurred regarding empty sub dir
	JMP	SHORT WFB_EXIT_A	;check archive options.
WFB_NEXT:
	MOV	DS, DS:NEXT_PTR 	;let's handles next header.
	JMP	WFB_CD			;change directory first.
WFB_EXIT_BRIDGE: JMP WFB_EXIT
WFB_ERROR_BRIDGE: JMP short WFB_ERROR
WFB_EXIT_A_BRIDGE: JMP short WFB_EXIT_A
WFB_DEC_DEPTH:
	LEA	DI, ES:T_DRV_PATH
	CALL	RM_EMPTY_DIR		;check flags and remove empty dir
	CALL	LAST_DIR_OUT		;take off the last dir from path
	call	cut_display_path	;modify path for display purpose
	DEC	ES:T_DEPTH		;and decrease depth
	JMP	WFB_CD			;CHANGE DIR AND compare the depth again.

WFB_FILE:				;Handling a file
	AND	ES:MY_FLAG, RESET_MISSING_LINK ;if found a file, then current dir is not empty.
	TEST	ES:FILE_FLAG, CREATED_FLAG ; A file handle is created ?
	JNZ	WFB_WRITE		;yes, skip create again.
	CALL	CREATE_A_FILE		;create a file in the cur dir
	JC	WFB_ERROR		;file creation error?
WFB_WRITE:
	CALL	WRITE_A_FILE
	JC	WFB_EXIT_A		;target file has been already deleted.
	CMP	DS:CONTINUE_INFO, 0
;	$IF	E,OR			;if continue_info = 0 or 3
	JE $$LL108
	CMP	DS:CONTINUE_INFO, 3
;	$IF	E
	JNE $$IF108
$$LL108:
	    MOV     BX, ES:T_HANDLE
	    CALL    SET_FILE_DATE_TIME	;then set file's date, time
	    PUSH    DS			;AN005;SAVE THE BUFFER PTR
	    PUSH    ES			;AN005;WE NEED THE DATA PTR
	    POP     DS			;AN005;DS = THE DATA PTR
	    CALL    CLOSE_A_FILE	;and close the handle
	    POP     DS			;AN005;DS = THE BUFFER PTR AGAIN
	    CALL    RESTORE_FILENAME_FOUND ;if filename_found has been changed, restore it for reset_s_archive.
	    AND     ES:FILE_FLAG, RESET_CREATED ;and reset created_flag
	    CALL    INC_FILE_COUNT	;increase file count
;	$ENDIF
$$IF108:
	MOV	AX, DS
	CMP	ES:OLD_BUFFER_PTR, AX	;current header is the last one?
	JE	WFB_EXIT_A		;then exit
	MOV	DS, DS:NEXT_PTR 	;else set ds to the next ptr
	JMP	WFB_CHATT		;handle the next header
WFB_ERROR:
	jmp	main_exit		;meaningful when MKDIR failed because
					;of there already exist same named file,
					;or disk_full case.
WFB_EXIT_A:
	test	ES:option_flag, slash_m ;hard archive ? - turn off source archive bit.
	jz	wfb_exit_B		;no, chk error flag and exit
	call	reset_s_archive	;reset source file(s) archive bit using header info(s).
WFB_EXIT_B:
	test	ES:copy_status, mkdir_error_flag ;mkdir error happened?
	JNZ	WFB_ERROR		;yes, exit
	test	ES:copy_status, disk_full_flag ;disk full happened?
	JNZ	WFB_ERROR		;yes, exit
WFB_EXIT:
	MOV	ES:OLD_BUFFER_PTR, CS	;set old_buffer_ptr to CS
	MOV	AX, ES:BUFFER_BASE
	MOV	ES:BUFFER_PTR, AX	;set buffer_ptr to base
	MOV	AX, ES:MAX_BUFFER_SIZE
	MOV	ES:BUFFER_LEFT, AX	;set buffer_left
	POP	ES
	POP	DS
	TEST	SYS_FLAG, ONE_DISK_COPY_FLAG ;one drive letter copy?
;	$IF	NZ			;yes
	JZ $$IF110
	    CALL    CHANGE_S_DIR	;then change current dir to s dir
;	$ENDIF
$$IF110:
	RET
WRITE_FROM_BUFFER ENDP
;
INC_FILE_COUNT PROC NEAR
;increase the file count by one.
;increase file_cnt_low, file_cnt_high.
;input: DS - buffer
;	ES - data seg
	INC	ES:FILE_CNT_LOW
	JNZ	IFC_EXIT
	INC	ES:FILE_CNT_HIGH	;if carry over, then inc file_cnt_high
IFC_EXIT:
	RET
INC_FILE_COUNT ENDP
;
RM_EMPTY_DIR PROC NEAR
;check the slash_E option, missing_link_flag.  Remove the empty directory
;from the target disk.
;INPUT: DS - buffer
;	ES - data seg
;	DI - points to the current target drv, path

	TEST	ES:OPTION_FLAG, SLASH_E ;user want to copy empty subdir?
	JNZ	RED_EXIT		;then exit
	TEST	ES:MY_FLAG, MISSING_LINK_FLAG ;missing informations for not to copying empty dir
					;at the tree travesal phase?
	JZ	RED_EXIT		;no.
	CALL	SWITCH_DS_ES		;ds - data, es - buffer
	MOV	DX, OFFSET T_PARENT	;chdir to parent dir
	MOV	AH, 3Bh 		;Chdir
	INT	21h
	PUSH	DI
	POP	DX			;DS:DX points to drv, path
	MOV	AH, 3Ah 		;REMOVE SUBDIR
	INT	21h
	CALL	SWITCH_DS_ES		;restore ds, es
RED_EXIT:
	RET
RM_EMPTY_DIR ENDP
;
RESTORE_FILENAME_FOUND PROC NEAR
;when the filename_found has been Revised according to the user's specified
;input parm, then restore the original source filename in filename_found.
;This will be used when reset_s_archive routine reset the source file's
;archive bit.
;input: DS - buffer
;	ES - data seg

	CMP	ES:T_FILENAME, 0	;if t_filename ot t_template is not blank,
;	$IF	NE,OR			;then filename_found has been Revised.
	JNE $$LL112
	CMP	ES:T_TEMPLATE, 0
;	$IF	NE
	JE $$IF112
$$LL112:
	    CALL    SWITCH_DS_ES	;DS - data seg, ES - buffer
	    MOV     CX, 13
	    LEA     SI, DS:DISP_S_FILE	;we know filename_found has been save into DISP_S_FILE when create the file.
	    LEA     DI, ES:FILENAME_FOUND ;use this to restore source filename this time.
	    REP     MOVSB		;disp_s_file => filename_found
	    CALL    SWITCH_DS_ES	;restore ds, es
;	$ENDIF
$$IF112:
	RET
RESTORE_FILENAME_FOUND ENDP
;



RESET_S_ARCHIVE PROC NEAR
;INPUT: DS - buffer
;       ES - data seg

	TEST	ES:COPY_STATUS, DISK_FULL_FLAG ;called when disk full?
	JZ	RSA_START		;no, just goto start
					;else disk_full.
	MOV	AX, DS			;current DS when called
	CMP	ES:BUFFER_BASE, AX	;current DS(BUFFER) is the first one?
	JE	RSA_EXIT_BRIDGE 	;yes, just exit
	MOV	AX, DS:BEFORE_PTR	;set old_buffer_ptr to the header
	MOV	ES:OLD_BUFFER_PTR, AX	;that is just before the troubled one.
RSA_START:
	MOV	AX, ES:BUFFER_BASE
	MOV	DS, AX			;set DS to buffer base again to start traveling
RSA_CD:
	CALL	CHANGE_ARC_S_DIR	;change souce dir
RSA_CHATT:
	TEST	DS:ATTR_FOUND, Is_subdirectory ; = 10h
	JZ	RSA_FILE		;no a file
RSA_CMP_DEPTH:
	MOV	AH, ES:S_ARC_DEPTH	;yes, a subdir
	CMP	DS:DIR_DEPTH, AH	;dir_depth > s_arc_depth?
	JBE	RSA_DEC_DEPTH		;if not, goto parent node
	LEA	DI, ES:S_ARC_DRV_PATH
	LEA	SI, DS:FILENAME_FOUND
	CMP	ES:S_ARC_PATH, 0	;root dir?
;	$IF	E
	JNE $$IF114
	    MOV     AL, 0FFh
;	$ELSE
	JMP SHORT $$EN114
$$IF114:
	    MOV     AL, Path_delim	;path_delim '\'
;	$ENDIF
$$EN114:
	CALL	CONCAT_ASCIIZ
	INC	ES:S_ARC_DEPTH
	MOV	AX, DS
	CMP	ES:OLD_BUFFER_PTR, AX
	JE	RSA_EXIT_A		;finished. Set the source current dir and return to caller
	MOV	DS, DS:NEXT_PTR 	;else let's handles next header
	JMP	RSA_CD			;chdir first.
RSA_EXIT_A:
	CALL	CHANGE_ARC_S_DIR	;to restore the same current source dir
					;as that of the READ_INTO_BUFFER proc.
RSA_EXIT_BRIDGE:JMP short RSA_EXIT
RSA_DEC_DEPTH:
	LEA	DI, ES:S_ARC_DRV_PATH
	CALL	LAST_DIR_OUT
	DEC	ES:S_ARC_DEPTH
	JMP	RSA_CD
RSA_FILE:
	CMP	DS:CONTINUE_INFO, 0
;	$IF	E,OR
	JE $$LL117
	CMP	DS:CONTINUE_INFO, 3
;	$IF	E
	JNE $$IF117
$$LL117:
	    CALL    CHANGE_S_FILEMODE	;change source file mode
;	$ENDIF
$$IF117:
	MOV	AX, DS
	CMP	ES:OLD_BUFFER_PTR, AX	;current header is the last one?
	JE	RSA_EXIT
	MOV	DS, DS:NEXT_PTR
	JMP	RSA_CHATT
RSA_EXIT:
	OR	ES:SYS_FLAG, DEFAULT_S_DIR_fLAG ;this is for restoring default source dir before exit to DOS.
	RET				;return to caller
RESET_S_ARCHIVE ENDP



;
CHANGE_S_FILEMODE PROC NEAR
;input: DS - buffer
;	ES - data seg

	LEA	DX, DS:FILENAME_FOUND
	MOV	AH, 43h 		;chmod
	MOV	AL, 0			;get attribute in CX
	INT	21h
	MOV	AH, 43h
	MOV	AL, 1
	AND	CX, 0FFDFh		;turn off the archive bit
	INT	21h
	RET
CHANGE_S_FILEMODE ENDP
;
CHANGE_ARC_S_DIR PROC NEAR
;change the source directory according to S_ARC_DRV_PATH
;INPUT: DS - buffer
;	ES - data seg
	call	switch_ds_es
	CMP	S_ARC_DRV[2], 0
;	$IF	E
	JNE $$IF119
	    MOV     S_ARC_DRV[2], '\'	;LAST_DIR_OUT have took '\' out?
	    MOV     S_ARC_DRV[3],0	;then restore it
;	$ENDIF
$$IF119:
	MOV	DX, OFFSET S_ARC_DRV_PATH ;use full drv, path
	MOV	AH, CHDIR		; = 3Bh
	INT	21h
;	$IF	C
	JNC $$IF121
	    OR	    COPY_STATUS, CHDIR_ERROR_FLAG
	    CALL    EXTENDED_ERROR_HANDLER
;	$ENDIF
$$IF121:
	call	switch_ds_es
	RET
CHANGE_ARC_S_DIR ENDP

;
CONCAT_DISPLAY_PATH PROC NEAR
;concatenate subdirectory name found from the header to DISP_S_PATH which
;will be used for display copying file messages.
;if slash_p option has been set, then just return.
;DS: buffer header
;ES: data seg
;
	TEST	ES:OPTION_FLAG, SLASH_P ;prompt option?
;	$IF	Z			;no
	JNZ $$IF123
	    LEA     DI, ES:DISP_S_PATH
	    LEA     SI, DS:FILENAME_FOUND
	    CMP     ES:T_DEPTH, 0	;this will be the first child directory?
;	    $IF     E			;yes
	    JNE $$IF124
		MOV	AL, 0FFh	;then do not put '\' between them
;	    $ELSE
	    JMP SHORT $$EN124
$$IF124:
		MOV	AL, Path_delim	;else put '\'
;	    $ENDIF
$$EN124:
	    CALL    CONCAT_ASCIIZ
;	$ENDIF				;else just return
$$IF123:
	RET
CONCAT_DISPLAY_PATH ENDP
;
CUT_DISPLAY_PATH PROC NEAR
;take the last dir out from the DISP_S_PATH for display copy messages.
;if prompt option has been set, just return.
;INPUT: DS - buffer header
;	ES - data seg
;

	TEST	ES:OPTION_FLAG, SLASH_P ;prompt?
;	$IF	Z			;no.
	JNZ $$IF128
	    PUSH    DS			;save DS
	    PUSH    ES
	    POP     DS			;ds = es = data seg
	    MOV     SI, OFFSET DISP_S_PATH ;for CHK_DRV_LETTER
	    MOV     DI, OFFSET DISP_S_PATH ;for LASR_DIR_OUT

	    CALL    LAST_DIR_OUT
;	    $IF     C			;failure? no '\' found
	    JNC $$IF129
		CALL	CHK_DRV_LETTER	;drive letter?
;		$IF	NC		;yes. "D:filename",0 case
		JC $$IF130
		    MOV     BYTE PTR DS:[SI], 0 ;make it "D:",0 since SI now points to the next chr
;		$ELSE			;no. "filename",0 case
		JMP SHORT $$EN130
$$IF130:
		    MOV     BYTE PTR [DI], 0 ;set DISP_S_PATH to 0
;		$ENDIF
$$EN130:
;	    $ELSE			;found '\' and last '\' became 0
	    JMP SHORT $$EN129
$$IF129:
		CMP	T_DEPTH, 1	;now going to the starting path?
;		$IF	E		;yes. restore it for concat_display_path routine.
		JNE $$IF134
		    MOV     DI, AX	;we want to restore '\' and put 0 just after that.
		    DEC     DI		;for ex, "D:\DIR1"=>"D:"=>"D:\" -- original starting path
		    MOV     BYTE PTR [DI], '\' ; "D:dir1\dir2"=>"D:dir1"(starting path) => "D:dir1\"
		    MOV     BYTE PTR [DI+1], 0
;		$ENDIF
$$IF134:
;	    $ENDIF
$$EN129:
	    POP     DS			;restore ds to buffer header
;	$ENDIF
$$IF128:
	RET
CUT_DISPLAY_PATH ENDP
;


;***************************************************************************
CHK_DRV_LETTER PROC NEAR
; ** CHECK CURRENT CHR IS ALPHA CHR FOLLOWED BY COLON.			   *
; INPUT: DS:SI POINTS TO THE CURRENT CHR TO BE CHECKED. 		   *
; OUTPUT: FOUND - SI POINTS TO THE NEXT CHR.				   *
;		  IF THIS HAD BEEN A LAST WORD, ZERO FLAG WILL BE SET.	   *
;	  NOT FOUND - CARRY IS SET. DI, CX UNCHANGED.			   *
;***************************************************************************

	PUSH	AX
	PUSH	SI			;AN010;IN CASE DRIVE LETTER NOT FOUND
;	$DO				;AN010;
$$DO138:
	    CLC 			;AN010;INITIALIZE TO NOT DBCS
	    MOV     AL,DS:BYTE PTR [SI] ;AN010;GET THE 1st CHAR TO TEST
	    CALL    CHK_DBCS		;AN010;SEE IF WE ARE IN DBCS
;	$LEAVE	NC			;AN010;THIS IS NOT DBCS
	JNC $$EN138
	    INC     SI			;AN010;GO TO THE NEXT CHAR TO CHECK
	    INC     SI			;AN010;DITO
;	$ENDDO				;AN010;
	JMP SHORT $$DO138
$$EN138:
	CMP	AL, 'A'
	JB	CK_DR_1 		;LESS THAN 'A', THEN NOT FOUND.
	CMP	AL, 'Z'
	JA	CK_DR_1 		;ABOVE 'Z', THEN NOT FOUND.
	MOV	AL, DS:BYTE PTR [SI+1]	;LOOK AHEAD THE FOLLOWING CHR.
	CMP	AL, ':' 		;SHOULD BE A COLON.
	JNZ	CK_DR_1 		;NOT FOUND.
	POP	AX			;AN010;THROW AWAY SAVED SI
	INC	SI			;FOUND. SI TO THE NEXT CHR.
	INC	SI
	JMP	short CK_DR_2
CK_DR_1:
	STC				;SET CARRY
	POP	SI			;AN010;RESTORE SI TO ENTRY VALUE
CK_DR_2:
	POP	AX
	RET
CHK_DRV_LETTER ENDP
;


CREATE_A_FILE PROC NEAR
;create a file in the header and return the file handle in T_HANDLE.
;Set CREATED_FLAG.  This will be reset by WRITE_FROM_BUFFER when it
;close the handle.
;this routine will check the T_FILENAME and T_TEMPLATE if any target
;filename has been entered.  If T_FILENAME is there, then DX will
;points to this (This is the case when the user has specified non_global
;chr filename and any source filename be changed to this name.)
;If T_TEMPLATE is present, then modify the filename found in the
;header part.
;Also, this routine show copy messages just before a file creation using
;FILENAME_FOUND.
;ES - data seg
;DS - buffer seg

	PUSH	DS
	PUSH	ES

					;save the original filename from the header
	MOV	CX, 13			;max 13 chr
	LEA	SI, DS:FILENAME_FOUND	;original source file name
	LEA	DI, ES:DISP_S_FILE	;filename to be displayed
	REP	MOVSB			;filename_found => disp_s_file
	test	es:option_flag, slash_p
;	$IF	Z
	JNZ $$IF141
	    CALL    SHOW_COPY_MESSAGE	;show the source path, file
;	$ENDIF
$$IF141:

	CMP	ES:T_FILENAME, 0
;	$IF	NE			;non_global target filename entered.
	JE $$IF143
	    TEST    ES:COPY_STATUS, MAYBE_ITSELF_FLAG
;	    $IF     NZ
	    JZ $$IF144
		LEA	SI, DS:FILENAME_FOUND
		LEA	DI, ES:T_FILENAME
		CALL	COMP_FILENAME	;compare it. if same then show
					;file cannot be copied onto itself and
					;abort
;	    $ENDIF
$$IF144:

	    CALL    SWITCH_DS_ES	;now ds - data, es - buffer
	    MOV     CX, 13
	    LEA     SI, DS:T_FILENAME
	    LEA     DI, ES:FILENAME_FOUND
	    REP     MOVSB		; t_filename => filename_found
	    MOV     AL, NUL		;AN014;DOS NEEDS A NUL TO TERM.
	    MOV     ES:TERMINATE_STRING,AL ;AN014;PUT IT IN THE HEADER
	    CALL    SWITCH_DS_ES	;now ds - buffer, es - data seg

;	$ELSE
	JMP SHORT $$EN143
$$IF143:
	    CMP     ES:T_TEMPLATE, 0	;global chr target filename entered?
;	    $IF     NE			;yes, entered. modify the filename found
	    JE $$IF147
		CALL	MODIFY_FILENAME
		TEST	ES:COPY_STATUS, MAYBE_ITSELF_FLAG
;		$IF	NZ
		JZ $$IF148
		    LEA     SI, DS:FILENAME_FOUND ;compare the Revised filename
		    LEA     DI, ES:DISP_S_FILE ;with original name
		    CALL    COMP_FILENAME ;if same, then issue error message and exit
;		$ENDIF
$$IF148:
;	    $ELSE
	    JMP SHORT $$EN147
$$IF147:
		TEST	ES:COPY_STATUS, MAYBE_ITSELF_FLAG ;*.* CASE
;		$IF	NZ
		JZ $$IF151
		    PUSH    ES
		    POP     DS		;ds - data seg

					; Set message parameters
		    MOV     AX,MSG_COPY_ITSELF ;AN000;
		    MOV     MSG_NUM,AX	;AN000; set message number
		    MOV     SUBST_COUNT,NO_SUBST ;AN000; no message subst.
		    MOV     MSG_CLASS,UTILITY_MSG_CLASS ;AN000; message class
		    MOV     INPUT_FLAG,NO_INPUT ;AN000; no user input
		    CALL    PRINT_STDERR ;AN000; display error
		    JMP     MAIN_EXIT
;		$ENDIF
$$IF151:
;	    $ENDIF
$$EN147:
;	$ENDIF
$$EN143:

; save current DS for use in CLOSE_DELETE_FILE
	mov	es:NEWFILE_SEG,  ds
	mov	ax, target_drv_let
	mov	es:NEWFILE_OFF,  ax

;-------------------------------------------------------------------------
; Use extended open DOS call to create the target file, use attribute list
; obtained from the previous Get Extended attribute DOS call
;-------------------------------------------------------------------------
	MOV	AX, Ext_Open		;AN000; = 6Ch
	MOV	BX,CREATE_MODE		;AN000;CREATE MODE = 0002H
	MOV	CX,CREATE_ATTR		;AN000; attribute = 0
	MOV	DX,CREATE_FLAG		;AN000; flag = 0112H
	MOV	SI, TARGET_DRV_LET ;AN005; DS:SI-->NAME TO CREATE
	MOV	DI,NUL_LIST		;AN012; ES:DI = -1
	INT	21H			;AN000; create file

	JC	CAF_ERROR		;AN000;
	MOV	ES:T_HANDLE, AX 	;AN000;save handle

	CALL	CHK_T_RES_DEVICE	;check target handle is a reserved dev

	; EA stuff used to be here

	OR	ES:FILE_FLAG, CREATED_FLAG ;set created_flag
	JMP	short CAF_EXIT
CAF_ERROR:
	PUSH	DS
	PUSH	ES
	POP	DS
	OR	COPY_STATUS, CREATE_ERROR_FLAG
	CALL	EXTENDED_ERROR_HANDLER
	POP	DS
CAF_EXIT:
	POP	ES
	POP	DS
	RET
CREATE_A_FILE ENDP
;
chk_t_res_device proc near
;check the target handle if it is for reserved device
;input: ES - data seg
;	DS - buffer
;	AX - filehandle created

	cmp	es:t_filename,0 	;if no user specified filename
	jne	ctrd_ioctl		;then should not be a reserved device name
	cmp	es:t_template,0
	je	ctrd_exit
ctrd_ioctl:
	mov	bx, ax			;file handle
	mov	ax, 4400h		;IOCTL get device info.
	int	21h
	test	dx, 80h 		;is device? (not a block device?)
	jz	ctrd_exit
	PUSH	ES			;AN000;
	POP	DS			;AN000;ds - data seg

; Set message parameters
	MOV	AX,MSG_RES_T_NAME	;AN000; message number
	MOV	MSG_NUM,AX		;AN000; set message number
	MOV	SUBST_COUNT,NO_SUBST	;AN000; no message substitution
	MOV	MSG_CLASS,UTILITY_MSG_CLASS ;AN000; message class
	MOV	INPUT_FLAG,NO_INPUT	;AN000; no input
;C08    CALL	PRINT_STDOUT		;AN000; display message
	CALL	PRINT_STDERR		;AN000; display message           ;C08
	jmp	main_exit
ctrd_exit:
	ret
chk_t_res_device endp

;
MODIFY_FILENAME PROC NEAR
;modify the filename in the header using T_TEMPLATE.
;INPUT:
;DS: BUFFER
;ES: DATA SEG

	PUSH	DS			;save ds, es = data seg
	PUSH	ES

	PUSH	DS
	PUSH	ES
	MOV	ES, ES:PSP_SEG		;ES points to PSP
	MOV	DI, PSPFCB2_DRV 	;DI points to FCB2, 6c
	MOV	SI, TARGET_DRV_LET ;filename found, DS = buffer header
	MOV	AH, 29H 		;parse a filename
	MOV	AL, 0			;control bits
	INT	21h			;unfold the filename found into PSP FCB2 area

	POP	DS			;now DS=data seg, ES=PSP seg
	MOV	SI, OFFSET T_TEMPLATE	;SI points to template
	MOV	DI, PSPFCB2_DRV
	INC	DI			;DI points to the formatted filename

ifdef DBCS				; ### if DBCS ###

	mov	cx,8
	call	make_name
	mov	cx,3
	call	make_name

else					; ### if Not DBCS ###

	MOV	CX, 11
	CLD
;	$DO
$$DO155:
	    CMP     CX, 0		;done?
;	$LEAVE	E			;yes. exit
	JE $$EN155
	    LODSB			;[SI] => AL, SI = SI + 1
	    CMP     AL, '?'		;global chr?
;	    $IF     E			;yes
	    JNE $$IF157
		INC	DI		;just skip the corresponding target chr
;	    $ELSE			;no
	    JMP SHORT $$EN157
$$IF157:
		STOSB			;change the target chr to this. DI = DI + 1
;	    $ENDIF
$$EN157:
	    DEC     CX
;	$ENDDO
	JMP SHORT $$DO155
$$EN155:

endif					; ### end if Not DBCS ###

	POP	ES			;now ES = Buffer
	MOV	DI, FILENAME_FOUND ; di points to filename in the header
	MOV	DS, PSP_SEG		;DS = PSP seg
	MOV	SI, PSPFCB2_DRV
	INC	SI			;di points to Revised filename
	CALL	COMPRESS_FILENAME	;fold it

	POP	ES
	POP	DS
	RET
MODIFY_FILENAME ENDP
;

ifdef DBCS				; ### if DBCS ###
make_name	proc	near
	push	bx
	push	dx
	mov	bx,di
	mov	ah,0			; reset DBCS flag
	mov	dl,cl			; reset counter
	mov	dh,cl			; save length to do
mkname_loop:
	cmp	ah,1			; if it was lead byte
	jz	mkname_dbcs
	mov	ah,0			; reset if it was single or tail byte
	mov	al,es:[bx]			; get source char
	call	chk_dbcs
	jnc	mkname_load		; if not lead byte
mkname_dbcs:
	inc	ah			; set dbcs flag
mkname_load:
	lodsb				; get raw char
	cmp	al,'?'
	jnz	mkname_store		; if not '?'
	cmp	ah,0
	jz	mkname_conv		; if source is single
	cmp	ah,1
	jnz	mkname_pass		; if source is not lead
	cmp	cl,dh
	jnz	mkname_lead		; if this is not 1st char
	cmp	byte ptr [si],' '
	jz	mkname_double		; if this is the end
mkname_lead:
	cmp	byte ptr [si],'?'
	jnz	mkname_pass		; if no '?' for tail byte
	cmp	cx,1
	jbe	mkname_pass		; if no room for tail byte
mkname_double:
	mov	al,es:[bx]
	stosb
	dec	dl
	inc	bx
	inc	si
	dec	cx
mkname_conv:
	mov	al,es:[bx]
mkname_store:
	stosb				; store in destination
	dec	dl			; decrese counter
mkname_pass:
	inc	bx
	loop	mkname_loop
	mov	cl,dl			; get stored length
	xor	ch,ch
	jcxz	mkname_ret		; if all done
	mov	al,' '
	rep	stosb			; put sapce
mkname_ret:
	pop	dx
	pop	bx
	ret
make_name	endp
endif					; ### end if DBCS ###
;

COMP_FILENAME PROC NEAR
;this routine is called when MAYBE_COPY_ITSELF flag in on.
;SI, DI asciiz string will be compared and if they are identical
;the show "Cannot copy onto itself" msg and jmp to main_exit.
;INPUT: DS - buffer
;	ES - data seg

	CLD
	MOV	AL, 0
	PUSH	DI			;save DI
	CALL	STRING_LENGTH		;CX get the length of string
	MOV	BX, CX			;now, BX got the length of the target filename entered.
	PUSH	BX			;save BX
	PUSH	ES			;save ES

	PUSH	DS
	POP	ES			;now ES set to DS
	PUSH	SI
	POP	DI			;now DI points to the source filename found.

	MOV	AL, 0
	CALL	STRING_LENGTH		;CX got the length of the string

	POP	ES			;restore ES
	POP	BX			;restore BX
	POP	DI			;restore DI

	CMP	BX, CX			;COMPARE LENGTH
	JNE	CF_EXIT 		;IF THEY ARE DIFFERENT, EXIT

	REPE	CMPSB			;compare SI, DI until not equal,
	CMP	CX, 0			;finish at cx = 0?
	JE	CF_SAME
	JMP	SHORT CF_EXIT
CF_SAME:
	PUSH	ES
	POP	DS			;ds = data seg

; Set message parameters
	MOV	AX,MSG_COPY_ITSELF	;AN000; message number
	MOV	MSG_NUM,AX		;AN000; set message number
	MOV	SUBST_COUNT,NO_SUBST	;AN000; no message substitution
	MOV	MSG_CLASS,UTILITY_MSG_CLASS ;AN000; message class
	MOV	INPUT_FLAG,NO_INPUT	;AN000; no input
	CALL	PRINT_STDERR		;AN000; display error message
	JMP	MAIN_EXIT
CF_EXIT:
	RET
COMP_FILENAME ENDP

;
SHOW_COPY_MESSAGE PROC NEAR
;show the source path, filename that is ready for creation in the target disk.
;INPUT: ES - data seg
;	DS - buffer header seg
	PUSH	DS			;save DS

	PUSH	ES
	POP	DS			;DS = data seg

	LEA	SI,SUBLIST1		;AN000; get addressability to list
	LEA	DX,DISP_S_PATH		;AN000; offset to path name
	MOV	[SI].DATA_OFF,DX	;AN000; save offset
	MOV	[SI].DATA_SEG,DS	;AN000; save data segment
	MOV	[SI].MSG_ID,1		;AN000; message ID
	MOV	[SI].FLAGS,010H 	;AN000; ASCIIZ string, left align
	MOV	[SI].MAX_WIDTH,0	;AN000; MAXIMUM FIELD WITH
	MOV	[SI].MIN_WIDTH,0	;AN000; MINIMUM FIELD WITH

	LEA	SI,SUBLIST2		;AN000; get addressability to list
	LEA	DX,DISP_S_FILE		;AN000; offset to file name
	MOV	[SI].DATA_OFF,DX	;AN000; save offset
	MOV	[SI].DATA_SEG,DS	;AN000; save data segment
	MOV	[SI].MSG_ID,2		;AN000; message ID
	MOV	[SI].FLAGS,010H 	;AN000; ASCIIZ string, left align
	MOV	[SI].MAX_WIDTH,0	;AN000; MAXIMUM FIELD WITH
	MOV	[SI].MIN_WIDTH,0	;AN000; MINIMUM FIELD WITH

	LEA	SI,SUBLIST1		;AN000;
	CMP	ES:T_DEPTH, 0		;starting directory?
;	$IF	E			;yes
	JNE $$IF161
	    MOV     AX,S_PATH_FILE0	;AN000;NO BACK SLASH BETWEEN PATH,FNAME

;	$ELSE
	JMP SHORT $$EN161
$$IF161:
	    MOV     AX,S_PATH_FILE1	;AN000;BACK SLASH IS BETWEEN PATH,FNAME

;	$ENDIF
$$EN161:
	MOV	MSG_NUM,AX		;AN000; set message number
	MOV	SUBST_COUNT,PARM_SUBST_TWO ;AN000; substitution count = 2
	MOV	MSG_CLASS,UTILITY_MSG_CLASS ;AN000; message class
	MOV	INPUT_FLAG,NO_INPUT	;AN000; no input
	CALL	PRINT_STDOUT		;show message "Reading source
	POP	DS			;restore DS
	RET
SHOW_COPY_MESSAGE ENDP
;
WRITE_A_FILE PROC NEAR
;write a file from the data area in the buffer.
;Remember the caller is WRITE_FROM_BUFFER which use ES for
;the program data area and DS for the header in the buffer.

	MOV	AH, Write		; = 40h
	MOV	BX, ES:T_HANDLE 	;handle saved in the program data area
	MOV	DX, ES:BYTS_OF_HDR	;AC005;skip header
	MOV	CX, DS:CX_BYTES 	;get the # from the header
	INT	21h
	JC	WAF_ERROR		;write error
	CMP	AX, DS:CX_BYTES
	JNE	WAF_DISKFULL
	JMP	short WAF_EXIT
WAF_ERROR:
	CALL	CLOSE_DELETE_FILE	;close delete troubled file
	OR	COPY_STATUS, WRITE_ERROR_FLAG
	CALL	SWITCH_DS_ES		;AN000;DS = DATA SEG, ES = BUFFER
	CALL	EXTENDED_ERROR_HANDLER
	CALL	SWITCH_DS_ES		;AN000;ES = DATA SEG, DS = BUFFER
WAF_DISKFULL:
	MOV	ES:ERRORLEVEL, 4	   ;set errorlevel

; Set message parameters
; Target disk full, critical error

	PUSH	DS			;AN000;DS = BUFFER
	PUSH	ES			;AN000;ES = DATA SEG
	POP	DS			;AN000;ES => DS = DATA SEG
	MOV	AX,MSG_DISK_FULL	;AN000; message number
	MOV	MSG_NUM,AX		;AN000; set message number
	MOV	SUBST_COUNT,NO_SUBST	;AN000; no message substitution
	MOV	MSG_CLASS,UTILITY_MSG_CLASS ;AN000; message class
	MOV	INPUT_FLAG,NO_INPUT	;AN000; no input
	CALL	PRINT_STDERR		;AN000; display error message
	OR	COPY_STATUS, DISK_FULL_FLAG ;set disk_full_flag
	POP	DS			;AN000;RESTORE DS = BUFFER
	CALL	CLOSE_DELETE_FILE
	STC				;set carry and return to caller
WAF_EXIT:
	RET
WRITE_A_FILE ENDP
;
SET_FILE_DATE_TIME PROC NEAR
;input: BX - target file handle
;
	MOV	AH, File_date_time	; = 57h
	MOV	AL, Set_file_time	; = 1
	MOV	CX, DS:FILE_TIME_FOUND
	MOV	DX, DS:FILE_DATE_FOUND
	INT	21h
	RET
SET_FILE_DATE_TIME ENDP
;
CLOSE_A_FILE PROC NEAR
;
;CLOSE A FILE AND UPDATE COUNT OF OPEN FILES
;
;INPUT: BX - file handle to be closed
;
	CMP	OPEN_FILE_COUNT,NUL	;AN005;ARE THERE ANY OPEN FILES?
;	$IF	A			;AN005;
	JNA $$IF164
	    DEC     OPEN_FILE_COUNT	;AN005;IF SO, REDUCE THE COUNT BY 1.
;	$ENDIF				;AN005;
$$IF164:
	MOV	AH, Close		; = 3Eh
	INT	21H
	RET
CLOSE_A_FILE ENDP
;
DELETE_A_FILE PROC NEAR
;input: DS:DX - points to ASCIIZ string

	MOV	AH, 41h 		; = 41h
	INT	21H
	RET
DELETE_A_FILE ENDP
;
MAKE_DIR PROC	NEAR
;make a subdirectory in the current target directory.
;The directory name is in the header part Target_drv_Let
;with the drive letter.
;input:DS - buffer
;      ES - data seg

 mov cs:md_err_ignore,0     ; clr flag for "We ignored error"    ; C02

	MOV	AH, Mkdir		; = 39h
	MOV	DX, TARGET_DRV_LET ;target drv and filename
	INT	21h
	JC	MD_ERROR
	JMP	MD_EXIT
MD_ERROR:
;cannot distinguish between cases of: 1. already there exists a directory.
; 2. there has been a file exist with the same name in the target.
; 3. no disk space to make dir.
; Case 1, should ignore and just exit this routine
; Case 2, critical error.
; Case 3, critical error.
	call	chk_disk_full		;check disk full condition first
	jc	MD_EXIST		;AC026;yes, disk full, check if exist
	push	es			;else check a file with the same name.
	push	ds
	push	dx
	mov	ds, es:psp_seg		;CC002;ds -> psp_seg
	mov	ah, 2fH 		;get current DTA addr in ES:BX
	int	21h
	mov	dx, 80h
	mov	ah, 1ah
	int	21h			;set dta to psp default dta area
	pop	dx			;restore DX - target drv and filename
	pop	ds			;restore DS - buffer
	mov	cx, 6			;HIDDEN + SYSTEM inclusive search
	mov	ah, 4Eh 		;FIND FIRST MATCHING FILE
	int	21h
	jc	md_ok			;not found. There exists subdir. ignore
	stc				;else found a file with same name.
	jmp	short MD_RESTORE

MD_OK:

 mov  cs:md_err_ignore,1    ; set flage for "We ignored error"    ; C02

	clc				;else there exists dir., ignore error.
MD_RESTORE:
	pushf
	push	ds			;save ds again	- buffer
	push	es			;es - save dta seg
	pop	ds			;ds = saved DTA seg
	mov	dx, bx			;     saved DTA off
	mov	ah, 1ah
	int	21h			;restore DTA
	pop	ds			;restore ds
	popf
	pop	es			;restore ES
	jnc	md_exit 		;if no error, then exit
	jmp	short md_err		;AN026;

;else check a file with the same name.

MD_EXIST:
	push	es			;AN026;
	push	ds			;AN026;
	push	dx			;AN026;
	mov	ds, es:psp_seg		;CC002;ds -> psp_seg
	mov	ah, 2fH 		;AN026;get current DTA addr in ES:BX
	int	21h			;AN026;
	mov	dx, 80h 		;AN026;
	mov	ah, 1ah 		;AN026;
	int	21h			;AN026;set dta to psp default dta area
	pop	dx			;AN026;restore DX - tar drv and filenm
	pop	ds			;AN026;restore DS - buffer
	mov	cx, 10h 		;AN026;sub-directory search
	mov	ah, 4Eh 		;AN026;FIND FIRST MATCHING dir.
	int	21h			;AN026;

	pushf				;AN026;save carry state
	push	ds			;AN026;save ds again  - buffer
	push	es			;AN016;es - save dta seg
	pop	ds			;AN026;ds = saved DTA seg
	mov	dx, bx			;AN026;     saved DTA off
	mov	ah, 1ah 		;AN026;
	int	21h			;AN026;restore DTA
	pop	ds			;AN026;restore ds
	popf				;AN026;get carry state from find
	pop	es			;AN026;restore ES
	jnc	md_exit 		;AN026;if no error, then dir. exits

MD_ERR:
	call	switch_ds_es		;switch ds, es
	mov	errorlevel, 4		;set the errorlevel to 4
	test	copy_status, disk_full_flag ;disk full?
	jnz	MD_FULL 		;yes, full.
	mov	ax,msg_unable_create	; else make dir fails because of
					; the same file name
	or	copy_status, mkdir_error_flag ;set make dir error flag
	jmp	short MD_PRT
MD_FULL:
	mov	ax,msg_disk_full
MD_PRT:
; Set message parameters
	PUSH	ES			;AN017;ES = BUFFER
	PUSH	DS			;AN017;DS = DATA SEG
	POP	ES			;AN017;DS => ES = DATA SEG
	MOV	MSG_NUM,AX		;AN000; set message number
	MOV	SUBST_COUNT,NO_SUBST	;AN000; no  message substitution
	MOV	MSG_CLASS,UTILITY_MSG_CLASS ;AN000; message class
	MOV	INPUT_FLAG,NO_INPUT	;AN000; no input
	CALL	PRINT_STDERR		;AN000; display message
	POP	ES			;AN017;RESTORE ES = BUFFER

	call	switch_ds_es		;restore ds, es
	stc				;error - set carry
MD_EXIT:
	RET

MAKE_DIR ENDP
;
CHK_DISK_FULL PROC NEAR
;check target disk space, and if no more clusters then set carry, disk_full_flag.
;this routine is called by MAKE_DIR routine.
;INPUT: DS - buffer
;	ES - data seg
	PUSH	AX
	PUSH	BX
	PUSH	CX
	PUSH	DX
	MOV	AH, 36h 		;GET DISK FREE SPACE
	MOV	DL, ES:T_DRV_NUMBER	;OF TARGET
	INT	21h
	CMP	BX, 0			;NO MORE CLUSTER?
	JE	CDF_FULL
	CLC
	JMP	SHORT CDF_EXIT
CDF_FULL:
	OR	ES:COPY_STATUS, DISK_FULL_FLAG ;SET DISK FULL FLAG
	STC				;SET CARRY
CDF_EXIT:
	POP	DX
	POP	CX
	POP	BX
	POP	AX
	RET

CHK_DISK_FULL ENDP
;

CHK_FILE_NOT_FOUND PROC NEAR
;if FILE_CNT_LOW=FILE_CNT_HIGH=FOUND_FILE_FLAG=0 AND NO INIT ERROR,
; then show "File not found" msg
;INPUT: ES, DS = data seg

	TEST	PARM_FLAG, INIT_ERROR_FLAG
;	$IF	Z,AND			;no init error
	JNZ $$IF166
	CMP	FILE_CNT_LOW, 0
;	$IF	E,AND
	JNE $$IF166
	CMP	FILE_CNT_HIGH, 0
;	$IF	E,AND
	JNE $$IF166
	CMP	FOUND_FILE_FLAG, 0
;	$IF	E
	JNE $$IF166
	    MOV     ES, PSP_SEG 	;use PSP area for parsing
	    MOV     DI, PSPFCB1_DRV
	    MOV     SI, OFFSET S_FILE
	    MOV     AH, 29h
	    MOV     AL, 0		;control byte
	    INT     21h
	    CALL    SWITCH_DS_ES	;now, ds - psp seg, es - data seg
	    MOV     DI,OFFSET DISP_S_FILE
	    MOV     SI,PSPFCB1_DRV
	    INC     SI			;now SI points to the formatted filename area
	    CALL    COMPRESS_FILENAME	;[pspfcb1_drv+1] => disp_s_file
	    PUSH    ES
	    POP     DS			;now DS=ES=data seg
	    LEA     SI,SUBLIST1 	;AN000;
	    MOV     DI,OFFSET DISP_S_FILE ;AN000;
	    MOV     [SI].DATA_OFF,DI	;AN000; SI-->File name
	    MOV     [SI].DATA_SEG,DS	;AN000; DS-->Segment
	    MOV     [SI].MSG_ID,0	;AN018; message ID
	    MOV     [SI].FLAGS,010H	;AN000; ASCIIZ string, left align
	    MOV     [SI].MAX_WIDTH,0	;AN000; MAXIMUM FIELD WITH
	    MOV     [SI].MIN_WIDTH,0	;AN000; MINIMUM FIELD WITH
	    MOV     AX,MSG_FILE_NOT_ERR ;AN018;
	    MOV     MSG_NUM,AX		;AN000; set message number
	    MOV     SUBST_COUNT,PARM_SUBST_ONE ;AN000; substitution count
	    MOV     MSG_CLASS,UTILITY_MSG_CLASS ;AN000; message class
	    MOV     INPUT_FLAG,NO_INPUT ;AN000; no input
	    CALL    PRINT_STDOUT	;AN000; display message
;	$ENDIF
$$IF166:

	RET

CHK_FILE_NOT_FOUND ENDP

;
subttl	string_length
page
;******************************************************************************
;PURPOSE: Get the length of a string pointed by ES:DI until it encounters
;	  the same character given by the user in AL.
;	  The length will be an output in CX.  The number includes the
;	  charater found.
;	  For example, if you want to determine the length of an ASCIIZ string,
;	  set ES:DI to that string and set AL to 0.  The output CX is the
;	  total length of the ASCIIZ string including 0.
;	  So, if the first character pointed by DI is the same as that of AL,
;	  then the length will be 1.
;	  !!! It is the user's responsibility to make it sure that the string
;	      contains the character given in AL.  If not, unpredictable
;	      results will occur.!!!
;
; DATA INPUT
;   REGISTERS: AL - ASCII CHARACTER
;	       ES:DI - POINTER TO THE STRING.
; DATA OUTPUT
;   REGISTERS: AX,DX,SI etc - PRESERVED.
;	       BX - DISTROYED
;	       CX - STRING LENGTH UNTIL FOUND THE GIVEN CHARACTER.
;	       DI - POINTS TO THE NEXT CHARACTER AFTER THE STRING.
;	       DIRECTION FLAG -  CLEARED
;	       ZERO FLAG - RESET
;******************************************************************************
;
STRING_LENGTH PROC NEAR
PUBLIC	STRING_LENGTH
	CLD				;CLEAR DIRECTION
	MOV	BX,DI			;SAVE ORIGINAL DI VALUE
	MOV	CX,80H			;TRY MAX 128 BYTES
	REPNE	SCASB			;SCAN THE STRING UNTIL FOUND
	PUSH	DI			;SAVE CURRENT DI VALUE WHICH POINTS TO NEXT CHR AFTER STRING
	SUB	DI,BX			;GET THE LENGTH
	MOV	CX,DI			;MOV THE LENGTH TO CX
	POP	DI
	RET
STRING_LENGTH ENDP
;
subttl	concat_asciiz
page
;******************************************************************************
;PURPOSE: Concatenate two ASCIIZ string into one ASCIIZ string.
;	  The ASCIIZ string pointed by DS:SI will be concatenated to
;	  the one pointed by ES:DI.  The result string will be pointed by
;	  ES:DI.
;	  AL is used to put the delimeter character in between the strings.
;	  If you *DON'T* like to put the delimeter ***make AL to 0FFh***.
;	  For example, assume sting1 "ABCDE",0 pointed by DI and string2
;	  "FGHI",0 pointed by SI.
;	  If you want a delimeter "\" between two string, set AL to "\"
;	  before calling.  The result will "ABCDE\FGHI",0 pointed by DI.
;	  If you set AL to "0FFh", then it becomes "ABCDEFGHI",0.
;	  This feature is useful for handling PATH if you set AL to "\"
;	  and, for any general string processes if you set AL to "0FFh".
;	  This routine will call subroutine STRING_LENGTH.
;DATA INPUT
;  REGISTERS: AL - DELIMETER OR 0FFh
;	      ES:DI - POINTER TO THE DESTINATION STRING.
;	      DS:SI - POINTER TO THE SOURCE TO BE CONCATENATED.
;DATA OUTPUT
;  REGISTERS: AL, DX - preserved
;	      DI - preserved. POINTER TO THE RESULT STRING
;	      SI - DISTROYED
;	      CX - RESULT ASCIIZ STRING LENGTH INCLUDE 0
;	      DIRECTION FLAG - CLEARED
;******************************************************************************
CONCAT_ASCIIZ PROC NEAR

PUBLIC	CONCAT_ASCIIZ
	PUSH	DI			;SAVE POINTER VALUE WHICH WILL BE RETRUNED TO CALLER.
	PUSH	AX			;SAVE VALUE IN AL.
	MOV	AL, 0			;DEALING WITH ASCIIZ STRING
	CALL	STRING_LENGTH		;LET DI POINTS TO THE NEXT CHR AFTER THIS STRING
					;DIRECTION WILL BE CLEARED.
	DEC	DI			;MAKE DI POINT TO THE LAST CHARACTER 0
	POP	AX			;RESTORE AL.
	CMP	AL, 0FFh
;	$IF	NE			;IF THE USER WANTS TO PUT DIMIMETER,
	JE $$IF168
	    STOSB			;  REPLACE 0 WITH IT.
;	$ELSE
	JMP SHORT $$EN168
$$IF168:
	    DEC     CX			;ELSE DECREASE LENGTH BY 1
;	$ENDIF
$$EN168:
;	$DO
$$DO171:
	    LODSB			;MOV [SI] TO AL
	    STOSB			;STORE AL TO [DI]
	    INC     CX			;INCREASE LENGTH
	    CMP     AL, 0		;WAS IT A LAST CHARACTER?
;	$ENDDO	E			;THEN EXIT THIS LOOP
	JNE $$DO171
	POP	DI
	RET
CONCAT_ASCIIZ ENDP
;

subttl	last_dir_out
page
;******************************************************************************
;PURPOSE: Take off the last directory name from the path pointed by DI.
;	  This routine assumes the pattern of a path to be an ASCIIZ string
;	  in the form of "[d:][\]dir1\dir2".  Notice that this path does not
;	  have entailing "\".	This routine will simply travel the string
;	  until it found last "\" which will, then, be replaced with 0.
;	  If no "\" found, then carry will be set.
;	  *** This should be not be used for the path in the form of
;	  *** "d:\", 0 for the root directory, since in this case the returned
;	  *** string will be "d:",0 and AX value returned be meaningless (Just
;	  *** points to 0.)
;DATA INPUT
; REGISTERS: DI - points to an ASCIIZ path string.
;	     ES - assumed default segment for DI
;DATA OUTPUT
; REGISTERS: DI - points to the resultant path string.
;	     AX - offset value of the last subdirectory name taken out, in case
;		  of the user's need.
;	     Other register will be unchanged.
; CARRY FLAG WILL SET IF NOT FOUND.
;******************************************************************************

LAST_DIR_OUT PROC NEAR
PUBLIC	LAST_DIR_OUT

	PUSH	DI
	PUSH	SI			;save current DI, SI
	CLD				;clear direction
	MOV	SI, 0FFFFh		;used as a not_found flag if unchanged.
;	$DO
$$DO173:
;	    $DO 			;AN010;
$$DO174:
		CLC			;AN010;INITIALIZE TO NOT DBCS
		MOV	AL,BYTE PTR ES:[DI] ;AC028;GET THE 1st CHAR TO TEST
		CALL	CHK_DBCS	;AN010;SEE IF WE ARE IN DBCS
;	    $LEAVE  NC			;AN010;THIS IS NOT DBCS
	    JNC $$EN174
		INC	DI		;AN010;GO TO THE NEXT CHAR TO CHECK
		INC	DI		;AN010;DITO
;	    $ENDDO			;AN010;
	    JMP SHORT $$DO174
$$EN174:
	    MOV     AL, 0
	    SCASB
;	$LEAVE	Z			;if [DI] = 0, then end of string. Ends this loop.
	JZ $$EN173
	    DEC     DI			;if [DI] <> 0, then go back and scan char again
	    MOV     AL, "\"		;to see it was a back slash.
	    SCASB
;	    $IF     Z			;if it was, then save the addr to SI.
	    JNZ $$IF178
		PUSH	DI
		POP	SI

		DEC	SI
;	    $ENDIF			;else do loop again.
$$IF178:
;	$ENDDO
	JMP SHORT $$DO173
$$EN173:
	CLC				;clear carry flag.
	CMP	SI, 0FFFFh		;Had SI been changed?
;	$IF	E
	JNE $$IF181
	    STC 			;No, set the carry. Not found.
;	$ELSE
	JMP SHORT $$EN181
$$IF181:
	    MOV     BYTE PTR ES:[SI], 0 ;Yes, replace "\" with 0. Seg override to get default DI seg.
	    MOV     AX, SI
	    INC     AX			;let AX have the last dir offset value.
	    CLC 			;clear carry
;	$ENDIF
$$EN181:
	POP	SI			;restore original value
	POP	DI			;original string offset
	RET
LAST_DIR_OUT ENDP
;
;	HEADER	<CHK_DBCS -SEE IF SPECIFIED BYTE IS A DBCS LEAD BYTE>
;*****************************************************************************
; Check DBCS environment
;*****************************************************************************

; Function: Check if a specified byte is in ranges of the DBCS lead bytes
; Input:    AL = Code to be examined
; Output:   If CF is on then a lead byte of DBCS
; Register: FL is used for the output, others are unchanged.

	PUBLIC	CHK_DBCS
Chk_DBCS PROC				;AN010;
	PUSH	DS			;AN010; save these regs, about to be clobbered
	PUSH	SI			;AN010;
	CMP	DBCSEV_SEG,0		;AN010; ALREADY SET ?
;	$IF	E			;AN010; if the vector not yet found
	JNE $$IF184
	    PUSH    AX			;AN010;
	    MOV     AX,6300H		;AN010; GET DBCS EV CALL
	    INT     21H 		;AN010; ds:si points to the dbcs vector

	    ASSUME  DS:NOTHING		;AN010; that function clobbered old DS

	    MOV     DBCSEV_OFF,SI	;AN010; remember where the dbcs vector is
	    MOV     DBCSEV_SEG,DS	;AN010;  so next time I don't have to look for it
	    POP     AX			;AN010;
;	$ENDIF				;AN010;
$$IF184:
	LDS	SI,DWORD PTR DBCSEV_OFF ;AN010;SET DS:SI TO POINT TO THE DBCS VECTOR
;	$SEARCH 			;AN010;
$$DO186:
	    CMP     WORD PTR [SI],0	;AN010; vector ends with a nul terminator entry
;	$LEAVE	E			;AN010; if that was the terminator entry, quit
	JE $$EN186
	    CMP     AL,[SI]		;AN010; look at LOW value of vector
;	$EXITIF NB,AND			;AN010; if this byte is in range with respect to LOW
	JB $$IF186
	    CMP     AL,[SI+1]		;AN010; look at HIGH value of vector
;	$EXITIF NA			;AN010; if this byte is still in range
	JA $$IF186
	    STC 			;AN010; set flag to say, found a DBCS char.
;	$ORELSE 			;AN010; since char not in this vector
	JMP SHORT $$SR186
$$IF186:
	    ADD     SI,2		;AN010; go look at next vector in dbcs table
;	$ENDLOOP			;AN010; go back and check out new vector entry
	JMP SHORT $$DO186
$$EN186:
	    CLC 			;AN010; set flag to say, this is not a DBCS character
;	$ENDSRCH			;AN010;
$$SR186:
	POP	SI			;AN010; restore the regs
	POP	DS			;AN010;

;	ASSUME	DS:DSEG 		;AN010; tell masm, DS back to normal

	RET				;AN010;
chk_DBCS ENDP				;AN010;
;
;

subttl	Compress_Filename
page

;
;******************************************************************************
;
; PURPOSE:
; --------
;  Compress the FCB style filename into an ASCIIZ packed name.
;  For example, 'ABC?????EXE' = > 'ABC?????.EXE',0
;	    or	'ABC     EXE' = > 'ABC.EXE',0
;  Note that the length of the source is *** 11 *** byte long.
;  The max length of result is *** 13 *** bytes long.
;  In the usual practice, the source filename with extention can be obtained
;  by using function call 29h (Parse a Filename).  So this routine is
;  an inverse function of fun. 29h except DI should be the *** starting point
;  of destination string *** instead of that of an unopened FCB (When you use
;  fun 29h together with this routine, keep this thing in mind. Also if ES, DS
;  values are different in your program, be careful to use them correctly.)
;------------------------------------------------------------------------------
; REGISTERS INPUT
; ----------------
; AX:
; BX:
; CX:
; DX:
; SI: offset of source unpacked filename with extention
; DI: offset where the resultant asciiz filename(.ext) will be placed.
; SP:
; BP:
; DS: source seg
; ES: result seg
; SS:
;
; DATA INPUT
; -----------
; Memory_Label -
;
;-----------------------------------------------------------------------------
; REGISTERS OUTPUT
; ----------------
; AX:
; BX:
; CX:
; DX:
; SI:
; DI:
; SP:
; BP:
; DS:
; ES:
; SS:
;
; DATA OUTPUT
; -----------
;
; FLAG OUTPUT
; -----------
;******************************************************************************

COMPRESS_FILENAME PROC NEAR
PUBLIC	COMPRESS_FILENAME
	PUSH	DI
	XOR	CX, CX			;CX = 0
;	$DO
$$DO192:
	    LODSB			;[SI] => AL, SI = SI + 1
	    CMP     CX, 10		;CX > 10 then exit
;	$LEAVE	A
	JA $$EN192
	    CMP     CX,  8		;filename extention position
;	    $IF     B			;CX < 8. handling filename
	    JNB $$IF194
		CMP	AL, ' ' 	;AL = blank ?
;		$IF	E
		JNE $$IF195
		    MOV     AX, 7
		    SUB     AX, CX
		    ADD     SI, AX	;SI = SI + (7 - CX)
		    MOV     CX, 8	;then skip to handles extention
;		$ELSE
		JMP SHORT $$EN195
$$IF195:
		    STOSB		;AL => [DI], DI = DI + 1
		    INC     CX		;CX = CX + 1
;		$ENDIF
$$EN195:
;	    $ELSE			;extention part
	    JMP SHORT $$EN194
$$IF194:
		CMP	AL, ' '
;		$IF	E
		JNE $$IF199
		    MOV     CX, 11	;exit this loop
;		$ELSE
		JMP SHORT $$EN199
$$IF199:
		    CMP     CX, 8	;the first chr of extention?
;		    $IF     E		;yes
		    JNE $$IF201
			PUSH	AX	;save cur chr
			MOV	AL, '.' ;and put a dot
			STOSB		; . => [DI], DI = DI + 1
			POP	AX	;restore AX
;		    $ENDIF
$$IF201:
		    STOSB		;AL => [DI], DI = DI + 1
		    INC     CX		;CX = CX + 1
;		$ENDIF
$$EN199:
;	    $ENDIF
$$EN194:
;	$ENDDO
	JMP SHORT $$DO192
$$EN192:
	MOV	AL, 0
	STOSB				;put 0 at the current [DI]

	POP	DI			;restore DI
	RET
COMPRESS_FILENAME ENDP
;


SET_DEFAULT_DRV PROC NEAR
;change source drv as a default drv for conveniece of find, read operation
;of source. (handling target should be more specific as for as drive letter
;goes.)
;input: DL - drive # (0 = A, 1 = B ...)

	MOV	AH, Select_Disk 	; = 0Eh
	INT	21H
	OR	SYS_FLAG, DEFAULT_DRV_SET_FLAG ;indicates default drv has been changed
					;Used for exit the program to restore default drv
	RET
SET_DEFAULT_DRV ENDP
;


ORG_S_DEF PROC	NEAR
;restore the original source directory.
	PUSH	ES
	PUSH	DS

	PUSH	DS
	POP	ES			;DS=ES=data seg

	TEST	SYS_FLAG, DEFAULT_S_DIR_FLAG ;source default directory saved?
;	$IF	NZ
	JZ $$IF206
	    MOV     DX, OFFSET SAV_S_DRV ;saved source drive letter & directory
	    MOV     AH, 3Bh
	    INT     21h 		;restore source
	    AND     SYS_FLAG, RESET_DEFAULT_S_DIR ;reset the flag
;	$ENDIF
$$IF206:

	POP	DS
	POP	ES

	RET
ORG_S_DEF ENDP
;
ORG_S_T_DEF PROC NEAR
;retore original target, source and default drv and directory
;check default_s(t)_dir_flag, default_drv_set_flag to restore source,
;or target directory and default drive.

	TEST	SYS_FLAG, TURN_VERIFY_OFF_FLAG ;turn off verify?
;	$IF	NZ			;yes
	JZ $$IF208
	    MOV     AX, 2E00h		;turn it off
	    INT     21H
;	$ENDIF
$$IF208:
	TEST	SYS_FLAG, DEFAULT_DRV_SET_FLAG ;default drive has been changed?
;	$IF	NZ			;yes
	JZ $$IF210
	    MOV     DL, SAV_DEFAULT_DRV
	    DEC     DL
	    CALL    SET_DEFAULT_DRV	;restore default drv.

; Following is a fix for PTR 0000012 . The fix is to skip changing default
; drive directory if source drive is not the default drive.

	    MOV     AL, S_DRV_NUMBER	;AN002; get source drive number
	    CMP     AL, SAV_DEFAULT_DRV ;AN002; src drive is the default drv ?
;	    $IF     NE			;AC022;NO, SO SEE IF DEF. DRV. IS CHGD.
	    JE $$IF211
		TEST	SYS_FLAG, DEFAULT_DRV_SET_FLAG ;AN022;DEF DRV CHGD?
;		$IF	NZ		;AN022;YES, RESET IT
		JZ $$IF212
		    MOV     DX, OFFSET SAV_DEF_DIR_ROOT ;AN022;GET THE SETTING
		    MOV     AH, Chdir	;AN022;MAKE THE CALL
		    INT     21H 	;AN022;
;		$ENDIF			;AN022;
$$IF212:
;	    $ELSE			;AN022;SRC IS DEF DRIVE!
	    JMP SHORT $$EN211
$$IF211:
		MOV	DX, OFFSET SAV_DEF_DIR_ROOT
		MOV	AH, Chdir
		INT	21H		    ;restore current dir of default dir
;	    $ENDIF			;AN022;
$$EN211:
;	$ENDIF
$$IF210:


	TEST	SYS_FLAG, DEFAULT_S_DIR_FLAG ;source default directory saved?
;	$IF	NZ
	JZ $$IF217
	    MOV     DX, OFFSET SAV_S_DRV ;saved source drive letter & directory
	    MOV     AH, 3Bh
	    INT     21h 		;restore source. This is for the case of ERROR exit.
;	$ENDIF
$$IF217:

	TEST	SYS_FLAG, DEFAULT_T_DIR_FLAG ;target default directory saved?
;	$IF	NZ			;then assume both source, target default saved
	JZ $$IF219
	    MOV     DX, OFFSET SAV_T_DRV ;saved target drive letter & directory
	    MOV     AH, 3Bh
	    INT     21h 		;restore target
;	$ENDIF
$$IF219:

	RET
ORG_S_T_DEF ENDP
;

CHK_MKDIR_LVL PROC NEAR
;if starting target directories has been created, and no files has been found to copy,
;and /E option is not specified, then remove the directories created.
;
	CMP	T_MKDIR_LVL, 0		;target starting directory created?
;	$IF	A,AND			;yes.
	JNA $$IF221
	TEST	OPTION_FLAG, SLASH_E	;/E option taken?
;	$IF	Z,AND			;no.
	JNZ $$IF221
	CMP	FOUND_FILE_FLAG, 0	;found any file?
;	$IF	E
	JNE $$IF221
	    CALL    T_RM_STARTING_DIR	;then, remove created directories.
;	$ENDIF
$$IF221:
	RET
CHK_MKDIR_LVL ENDP
;

T_RM_STARTING_DIR PROC NEAR
;based on the current target directory, remove directories T_MKDIR_LVL times
;INPUT: T_MKDIR_LVL
;	T_DRV_NUMBER
;	T_DRV_PATH
;	T_PATH

	MOV	DX, offset T_DRV_PATH	     ;CN001;PTM#5739
	MOV	AH, 3BH 		     ;CN001;change to current target directory
	INT	21H			     ;CN001;..if not already there.

	MOV	DL, T_DRV_NUMBER
	LEA	SI, T_PATH
	MOV	AH, Get_Current_Directory
	INT	21h

TRSD_AGAIN:
	MOV	DX, OFFSET T_PARENT	;chdir to the parent directory
	MOV	AH, 3Bh 		;Chdir
	INT	21h
	MOV	DX, OFFSET T_DRV_PATH
	MOV	AH, 3Ah 		;Rmdir
	INT	21h
	MOV	DI, OFFSET T_DRV_PATH
	CALL	LAST_DIR_OUT		;take out the last removed dir name
	DEC	T_MKDIR_LVL		;decrease the number
	CMP	T_MKDIR_LVL, 0		;no more?
	JA	TRSD_AGAIN

	RET
T_RM_STARTING_DIR ENDP
;


;************************************************************
;*
;*   SUBROUTINE NAME:	   PRINT_STDOUT
;*
;*   SUBROUTINE FUNCTION:
;*	   Display the requested message to the specified handle
;*
;*   INPUT:
;*	     Paramters in parater storage area
;*	     DS:SI-->Substitution List
;*	     ES:DI-->PTR to input buffer if buffered keyboard
;*		     input is specified (DL = 0A)
;*   OUTPUT:
;*	     AX =   Single character entered if DL=01
;*		OR
;*	     ES:DI-->input buffer where string is returned if DL=0A
;*
;*	The message corresponding to the requested msg number will
;*	be written to Standard Out. Message substitution will
;*	be performed if specified
;*
;*   NORMAL EXIT:
;*	Message will be successfully written to requested handle.
;*
;*   ERROR EXIT:
;*	None.  Note that theoretically an error can be returned from
;*	SYSDISPMSG, but there is nothing that the application can do.
;*
;*   INTERNAL REFERENCES:    SysDispMsg
;*
;*   EXTERNAL REFERENCES:
;*	None
;*
;************************************************************
PRINT_STDOUT PROC NEAR			;AN000:

	PUSH	BX			;AN000;
	PUSH	CX			;AN000;
	PUSH	DX

	MOV	AX,MSG_NUM		;AN000; Message ID
	MOV	BX,STDOUT		;AN000; standard input message handle
	MOV	CX,SUBST_COUNT		;AN000; message substitution count
	MOV	DH,MSG_CLASS		;AN000; message class
	MOV	DL,INPUT_FLAG		;AN000; Type of INT 10 for KBD input

	CALL	SYSDISPMSG		;AN000:  AX=Extended key value if wait
					;for key
	JNC	DISP_DONE		;AN000:  If CARRY SET then registers
					;will contain extended error info
					;	AX - Extended error Number
					;	BH - Error Class
					;	BL - Suggested action
DISP_DONE:				;AN000: CH - Locus
	POP	DX
	POP	CX			;AN000;
	POP	BX			;AN000;

	RET				;AN000:
PRINT_STDOUT ENDP			;AN000:




;************************************************************
;*
;*   SUBROUTINE NAME:	   PRINT_STDERR
;*
;*   FUNCTION: Display the requested message to Standard Out
;*
;*   INPUT:
;*	     Parameters in parameter storage area
;*	     DS:SI-->Substitution List
;*	     ES:DI-->PTR to input buffer if buffered keyboard
;*		     input is specified (DL = 0A)
;*
;*   OUTPUT:
;*	     AX =   Single character entered if DL=01
;*		OR
;*	     ES:DI-->input buffer where string is returned if DL=0A
;*	The message corresponding to the requested msg number will
;*	be written to the Standard Error. Message substitution will
;*	be performed if specified
;*
;*   NORMAL EXIT:
;*	Message will be successfully written to requested handle.
;*
;*   ERROR EXIT:
;*	None.  Note that theoretically an error can be returned from
;*	SYSDISPMSG, but there is nothing that the application can do.
;*
;*   INTERNAL REFERENCES:    SysDispMsg
;*
;*   EXTERNAL REFERENCES:    None
;*
;************************************************************
PRINT_STDERR PROC NEAR			;AN000:

	PUSH	AX			;AN000;
	PUSH	BX			;AN000;
	PUSH	CX			;AN000;
	PUSH	DX

	MOV	AX,MSG_NUM		;AN000;  Message ID
	MOV	BX,STDERR		;AN000;  Handle
	MOV	CX,SUBST_COUNT		;AN000;  message substitution count
	MOV	DH,MSG_CLASS		;AN000;  message class
	MOV	DL,INPUT_FLAG		;AN000;  INT 10 KBD input type

	CALL	SYSDISPMSG		;AN000:  AX=Extended key value if wait
					;for key
	JNC	DISP_EXIT		;AN000:  If CARRY SET then registers
					;will contain extended error info
					;	AX - Extended error Number
					;	BH - Error Class
					;	BL - Suggested action
DISP_EXIT:				;AN000: CH - Locus
	POP	DX
	POP	CX			;AN000;
	POP	BX			;AN000;
	POP	AX			;AN000;
	RET				;AN000:

PRINT_STDERR ENDP			;AN000:





;
EXTENDED_ERROR_HANDLER PROC NEAR
;This routine calls fun 59(Get extended error) and
;check the actions returned.  If it is Immediate exit, then jmp to JUST_EXIT
;If it is abort, then jmp to MAIN_EXIT.
;Or else, it check the COPY_STATUS flag.  If is not open, read, create or
;write, then it is considered as a critical error and jmp to MAIN_EXIT.
;If access denied
;   too many open files
;   sharing violation
;   lock violation
;   general failure
;then show the message and jmp to the MAIN_EXIT.
; *** Currently, this routine directly jump to the main_exit instead of
; *** returing to the caller.  The reason is we regard the above error conditions
; *** as being not suitable to continue copying and, hence, to simplify
; *** the error process.
;INPUT:
;      DS - DATA SEG
;OUTPUT:
;      ALL THE REG PRESERVED

	PUSH	ES			;save ES
	PUSH	AX
	PUSH	BX
	PUSH	CX
	PUSH	DS			;AN000;
	POP	ES			;AN000;DS = ES = DATA SEG
	PUSHF				;save flags

	PUSH	ES
	MOV	AH, 59h 		;get extended error
	MOV	BX, 0			;version 3.0
	INT	21h
	POP	ES

	MOV	ERRORLEVEL, 4		;error in operation
	TEST	COPY_STATUS, OPEN_ERROR_FLAG ;open error?
	JNZ	OPEN_ERROR_RTN		;yes
	TEST	COPY_STATUS, READ_ERROR_FLAG ;read error?
	JNZ	READ_ERROR_RTN
	TEST	COPY_STATUS, CREATE_ERROR_FLAG ;create error?
	JNZ	CREATE_ERROR_RTN
	TEST	COPY_STATUS, WRITE_ERROR_FLAG ;write error?
	JNZ	WRITE_ERROR_RTN
	TEST	COPY_STATUS, CHDIR_ERROR_FLAG ;chdir error?
	JNZ	CHDIR_ERROR_RTN
	JMP	SHORT GOTO_MAIN_EXIT

OPEN_ERROR_RTN: 			;open error. show error message and exit
	CALL	SHOW_S_PATH_FILE_ERR	;show the troubled path filename
	CALL	SHOW_ERROR_MESSAGE
	JMP	SHORT GOTO_MAIN_EXIT	;abort

READ_ERROR_RTN:
	CALL	SHOW_S_PATH_FILE_ERR
	CALL	SHOW_ERROR_MESSAGE	;show message and abort
	JMP	SHORT GOTO_MAIN_EXIT

CREATE_ERROR_RTN:
	CMP	AX, 2			;"file not found" to create?
	JNE	CER_1
; Set message parameters
	MOV	AX,MSG_FILE_CREATE_ERR	;AN000; message number
	MOV	MSG_NUM,AX		;AN000; set message number
	MOV	SUBST_COUNT,NO_SUBST	;AN000; no  message substitution
	MOV	MSG_CLASS,UTILITY_MSG_CLASS ;AN000; message class
	MOV	INPUT_FLAG,NO_INPUT	;AN000; no input
	CALL	PRINT_STDERR		;show "File creation error" message
					;instead of "File not found"
	JMP	SHORT GOTO_MAIN_EXIT
CER_1:
	CALL	SHOW_ERROR_MESSAGE	;show error_message
	JMP	SHORT GOTO_MAIN_EXIT
WRITE_ERROR_RTN:
	CALL	SHOW_ERROR_MESSAGE	;show message
	JMP	SHORT GOTO_MAIN_EXIT
CHDIR_ERROR_RTN:

	PUSH	AX			;AN000;
; Set substitution list
	LEA	SI,SUBLIST1		;AN000; get addressability to sublist
	LEA	DX,S_DRV_PATH		;AN000; offset to PATH NAME
	MOV	[SI].DATA_OFF,DX	;AN000; save offset
	MOV	[SI].DATA_SEG,DS	;AN000; save data segment
	MOV	[SI].MSG_ID,1		;AN000; message ID
	MOV	[SI].FLAGS,010H 	;AN000; ASCIIZ string, left align
	MOV	[SI].MAX_WIDTH,0	;AN000; MAXIMUM FIELD WITH
	MOV	[SI].MIN_WIDTH,0	;AN000; MINIMUM FIELD WITH

; Set message parameters
	MOV	AX,DISPLAY_S_PATH	;AN000; message number
	MOV	MSG_NUM,AX		;AN000; set message number
	MOV	SUBST_COUNT,PARM_SUBST_ONE ;AN000; one message substitution
	MOV	MSG_CLASS,UTILITY_MSG_CLASS ;AN000; message class
	MOV	INPUT_FLAG,NO_INPUT	;AN000; no input
	CALL	PRINT_STDERR		;show source drv,path
	POP	AX			;AN000;
	CALL	SHOW_ERROR_MESSAGE	;display error message

GOTO_MAIN_EXIT:
	JMP	MAIN_EXIT		;restore conditions
					;and exit
QUICK_EXIT:
	JMP	JUST_EXIT		;immediate exit

EEH_EXIT:
	MOV	ERRORLEVEL, 0		;reset errorlevel
	POPF
	POP	CX
	POP	BX
	POP	AX
	POP	ES
	RET

EXTENDED_ERROR_HANDLER ENDP
;


SHOW_ERROR_MESSAGE PROC NEAR
;called immediately after Get_extended error
;This will show simple error message according to error_code in AX
;If the message is not what it wanted, just exit without message- Set carry.
;input: DS - data seg
;output: Carry flag is distroyed.

	clc				;clear carry
	CMP	AX, 5			;access denied?
	JE	ACCESS_DENIED_MESSAGE
	CMP	AX, 4			;too many open files?
	JE	TOO_MANY_OPEN_MESSAGE
	CMP	AX, 31			;general failure?
	JE	GENERAL_FAIL_MESSAGE
	CMP	AX, 32			;sharing violation?
	JE	SHARING_VIOL_MESSAGE
	CMP	AX, 33			;lock violation?
	JE	LOCK_VIOL_MESSAGE
	CMP	AX, 3			;path not found?
	JE	PATH_NOT_MESSAGE
	CMP	AX, 2			;file not found error?
	JE	FILE_NOT_ERR_MESSAGE
	CMP	AX, 65			;access denied on the network?
	JE	ACCESS_DENIED_MESSAGE
	CMP	AX, 82			;no more directory entry to create a file?
	JE	FILE_CREATE_ERR_MESSAGE

	STC				;else set carry


	JMP	GOTO_MAIN_EXIT		;and exit

ACCESS_DENIED_MESSAGE:
	MOV	AX, MSG_ACCESS_DENIED	;AN000;
	JMP	SHORT SHOW_MESSAGE
TOO_MANY_OPEN_MESSAGE:
	MOV	AX, MSG_TOO_MANY_OPEN	;AN000;
	JMP	SHORT SHOW_MESSAGE
GENERAL_FAIL_MESSAGE:
	MOV	AX, MSG_GENERAL_FAIL	;AN000;
	JMP	SHORT SHOW_MESSAGE
SHARING_VIOL_MESSAGE:
	MOV	AX, MSG_SHARING_VIOL	;AN000;
	JMP	SHORT SHOW_MESSAGE
LOCK_VIOL_MESSAGE:
	MOV	AX, MSG_LOCK_VIOL	;AN000;
	JMP	SHORT SHOW_MESSAGE
PATH_NOT_MESSAGE:
	MOV	AX, MSG_PATH_NOT	;AN000;

	JMP	SHORT SHOW_MESSAGE
FILE_NOT_ERR_MESSAGE:
	MOV	AX, MSG_FILE_NOT_ERR	;AN000;
	JMP	SHORT SHOW_MESSAGE
FILE_CREATE_ERR_MESSAGE:
	MOV	AX, MSG_FILE_CREATE_ERR ;AN000;


SHOW_MESSAGE:				; Display error message
; Set message parameters
	MOV	MSG_NUM,AX		;AN000; set message number
	MOV	SUBST_COUNT,NO_SUBST	;AN000; NO message substitution
	MOV	MSG_CLASS,UTILITY_MSG_CLASS ;AN000; message class
	MOV	INPUT_FLAG,NO_INPUT	;AN000; no input
	CALL	PRINT_STDERR		;AN000; print it
	RET

SHOW_ERROR_MESSAGE ENDP
;


SHOW_S_PATH_FILE_ERR PROC NEAR
;show current source path(drv, full path), and filename to the
;standard error display device.
;input: ds: data seg
	PUSH	ES			;save ES
	PUSH	AX			;save ERROR_CODE
	push	ds
	pop	es			;es = ds
	MOV	DI,OFFSET S_DRV_PATH
	CALL	STRING_LENGTH		;cx got the length
	MOV	SI,OFFSET S_DRV_PATH	;full path of source
	MOV	DI,OFFSET DISP_S_PATH
	REP	MOVSB			;S_DRV_PATH => DISP_S_PATH
	MOV	CX, 13			;max 13 chr
	MOV	SI,OFFSET FILE_DTA.DTA_FILENAME
	MOV	DI,OFFSET DISP_S_FILE
	REP	MOVSB			;dta_filename => disp_s_file

	LEA	SI,SUBLIST1		;AN000; get addressability to list
	LEA	DX,DISP_S_PATH		;AN000; offset to path name
	MOV	[SI].DATA_OFF,DX	;AN000; save offset
	MOV	[SI].DATA_SEG,DS	;AN000; save data segment
	MOV	[SI].MSG_ID,1		;AN000; message ID
	MOV	[SI].FLAGS,010H 	;AN000; ASCIIZ string, left align
	MOV	[SI].MAX_WIDTH,0	;AN000; MAXIMUM FIELD WITH
	MOV	[SI].MIN_WIDTH,0	;AN000; MINIMUM FIELD WITH

	LEA	SI,SUBLIST2		;AN000; get addressability to list
	LEA	DX,DISP_S_FILE		;AN000; offset to file name
	MOV	[SI].DATA_OFF,DX	;AN000; save offset
	MOV	[SI].DATA_SEG,DS	;AN000; save data segment
	MOV	[SI].MSG_ID,2		;AN000; message ID
	MOV	[SI].FLAGS,010H 	;AN000; ASCIIZ string, left align
	MOV	[SI].MAX_WIDTH,0	;AN000; MAXIMUM FIELD WITH
	MOV	[SI].MIN_WIDTH,0	;AN000; MINIMUM FIELD WITH


	CMP	S_DEPTH,0		;AN000;it happened, when dealing with the starting dir?
;	$IF	E
	JNE $$IF223
	    LEA     SI,SUBLIST2 	;AN007;PIONT TO THE FIRST LIST
	    MOV     [SI].MSG_ID,1	;AN007; message ID
	    MOV     AX,DISPLAY_S_PATH	;AC007;ITS ONLY A FILE NAME
	    MOV     SUBST_COUNT,PARM_SUBST_ONE ;AN007; ONE message sub
;	$ELSE
	JMP SHORT $$EN223
$$IF223:
	    LEA     SI,SUBLIST1 	;AN007;PIONT TO THE FIRST LIST
	    MOV     AX,S_PATH_FILE1	;AN000;put '\'
	    MOV     SUBST_COUNT,PARM_SUBST_TWO ;AN007;TWO message subs
;	$ENDIF
$$EN223:

; Set message parameters

	MOV	MSG_NUM,AX		;AN000; set message number
	MOV	MSG_CLASS,UTILITY_MSG_CLASS ;AN000; message class
	MOV	INPUT_FLAG,NO_INPUT	;AN000; no input
	CALL	PRINT_STDERR		;display error message

	POP	AX			;restore ERROR_CODE
	POP	ES
	RET

SHOW_S_PATH_FILE_ERR ENDP
;


CLOSE_DELETE_FILE PROC NEAR
;when writing error occurs, then this routine is called to
;clean up the troubled target file.
;INPUT: DS - buffer seg
;	ES - data seg

	MOV	BX, ES:T_HANDLE 	;close target file
	PUSH	DS			;AN005;SAVE THE BUFFER PTR
	PUSH	ES			;AN005;WE NEED THE DATA PTR
	POP	DS			;AN005;DS = THE DATA PTR
	CALL	CLOSE_A_FILE		;and close the handle
	mov	ds,  es:NEWFILE_SEG
	mov	dx,  es:NEWFILE_OFF
;	LEA	DX, DS:target_drv_let	;target drv, filename
	CALL	DELETE_A_FILE		;delete it
	pop	ds
	RET
CLOSE_DELETE_FILE ENDP
;
;

SWITCH_DS_ES PROC NEAR
; switch DS, ES
	PUSH	DS
	PUSH	ES
	POP	DS
	POP	ES
	RET
SWITCH_DS_ES ENDP

err_long_63  proc     near                                            ; C02
             push     es         ; es=buffer                          ; C02
             push     ax                                              ; C02
             push     ds         ; ds = data seg                      ; C02
             pop      es         ; DS => ES = DATA SEG                ; C02
             mov      ax,long_63_message  ; set message number        ; C02
             mov      msg_num,ax ; set message number                 ; C02
             mov      subst_count,no_subst ; no message substitution. ; C02
             mov      msg_class,utility_msg_class ; message class.    ; C02
             mov      input_flag,no_input  ; no input                 ; C02
             call     print_stderr         ; display message.         ; C02
             pop      ax                                              ; C02
             pop      es                   ; RESTORE ES = BUFFER      ; C02

             call     switch_ds_es         ; restore ds, es           ; C02
             ret                                                      ; C02
err_long_63  endp                                                     ; C02



MY_INT24:
	CMP	CS:INT24_ABORT_CNT, 0	;if aborted more than once, then just exit.
	JNE	MI_JUST_EXIT
	PUSHF				;we are calling interrupt handler
	CALL	DWORD PTR CS:SAV_INT24	;call original int 24 handler
	CMP	AL, 1			;retry?
	JE	MI_RETRY
	CMP	AL, 0			;ignore? Cannot ignore. Try again
	JE	MI_RETRY
	MOV	CX,DGROUP                                                ;*C09
	MOV	DS,CX                                                    ;*C09
	MOV	ES,CX                                                    ;*C09
	POP	CX			;remove IP, CS, FLAGS
	POP	CX			;since we are not going back
	POP	CX			;to the place int 24 was called.
	CMP	AL, 2			;abort?
	JE	MI_ABORT
	CMP	AL, 3			;AN000;fail?
	JE	MI_ABORT
	MOV	ERRORLEVEL,  5
	JMP	MAIN_EXIT		;show files copied message
					;restore default value and exit
MI_ABORT:
	INC	CS:INT24_ABORT_CNT	;increase the count of int24_abort
	MOV	ERRORLEVEL,  5
	JMP	MAIN_EXIT_A		;restore default value and exit
MI_JUST_EXIT:
	MOV	CX,DGROUP                                                ;*C09
	MOV	DS,CX                                                    ;*C09
	MOV	ES,CX                                                    ;*C09
	POP	CX
	POP	CX
	POP	CX
	MOV	ERRORLEVEL,  5
	JMP	JUST_EXIT
MI_RETRY:
	IRET				;return where it happened
					;and retry that operation.
;
INT24_ABORT_CNT DB 0
;
include msgdcl.inc

CSEG	ENDS
DSEG_INIT SEGMENT PARA PUBLIC 'INIT_DATA'		;AN000;
DSEG_INIT ENDS				;AN000;
	END	MAIN

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\xcopy\xcpyinit.asm ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

;/*************************************************************************
;*                                                                        *
;*  Change History:                                                       *
;*                                                                        *
;*   Date    ID    MSFT #   STR #        Description                      *
;* -----------------------------------------------------------------------*
;*  17JUN90  C03            1273    Error message id in reg. DX destroyed *
;*                                  when the change dir command is        *
;*                                  performed.                            *
;*  17JUN90  C04            1750    When translating network drive names, *
;*                                  sometimes they won't translate.  Use  *
;*                                  the original untranslated name to     *
;*                                  deternime cyclic copy.                *
;*  17JUN90  C05            1743    Do a SUBST D: C:\test then try to     *
;*                                  XCOPY C:\ D:\ /S and it would go on   *
;*                                  and on.  Now in this case we issue    *
;*                                  the "Cannot perform a cyclic copy"    *
;*                                                                        *
;**************************************************************************

	PAGE	,132
TITLE	XCPYINIT - XCOPY INITIALIZATION PROGRAM - Ver. 4.00

;****************** START OF SPECIFICATIONS *****************************
; MODULE NAME: XCPYINIT
;
; DESCRIPTIVE NAME: Called by XCOPY(MAIN) to perform initialization
;		    functions.
;
; FUNCTION:  Performs Parsing, Resource validation and Tagging, Error
;	     hooking and then returns to XCOPY(MAIN). This code will
;	     then be overwritten, providing additional memory for the
;	     copy process.
;
; ENTRY POINT: INIT
;
; INPUT: (DOS COMMAND LINE PARAMETERS)
;
;	      SOURCE OPERAND:			   TARGET OPERAND:
;
;	      [d:] [path] filename[.ext]	   [d:] [path] [filename[.ext]]
;		or
;	      [d:] path [filename[.ext]]
;		or
;	      d: [path] [filename[.ext]]
;
;	      SWITCHES:
;
;	      /A /D /E /M /P /S /V /W
;
; EXIT-NORMAL:	ERRORLEVEL_0 - This is the normal completion code.
;		ERRORLEVEL_2 - This is due to termination via Control-Break.
;		ERRORLEVEL_4 - This is used to indicate an error condition.
;
; INTERNAL REFERENCES:
;
;    ROUTINES:
;
;    DATA AREAS:
;
;
; EXTERNAL REFERENCES:
;
;    ROUTINES:
;
;    DATA AREAS:
;
;
; NOTES: This module should be processed with the SALUT pre-processor
;	 with the re-alignment not requested, as:
;
;		SALUT XCOPY,NUL,;
;
;	 To assemble these modules, the sequential
;	 ordering of segments may be used.
;
;	 For LINK instructions:
;		link  profile ..\lib
;
; REVISION HISTORY: A000 Version 4.00: add PARSER, System Message Handler,
;			 Remove the BELL char.,turn off APPEND during TREE
;			 search,Extended Attribute processing, Uppercasing
;			 and "Out Of Space" during write to standard out.
;		    NOTE: SEE XCOPY.SAL FOR TOTAL HISTORY.
;
;		    M00  Commented out a line so that "Invalid number of
;      			 parameters" was not being cited as requiring a
;			 substitution list, rather, as having no subs.  LeaF
;
;     Label: "The DOS XCOPY Utility"
;
;****************** END OF SPECIFICATIONS *****************************
;EQUATES
INCLUDE XCOPY.EQU
INCLUDE DOS.EQU
include versiona.inc

;
CSEG	SEGMENT PUBLIC 'CODE'		;PLACE HOLDER FOR INIT CODE
CSEG	ENDS

;******************************************************************************

DGROUP	GROUP	DSEG, DSEG_INIT
DSEG	SEGMENT PARA	PUBLIC 'DATA'
;--- EXTERNAL VARIABLES ---
EXTRN	ERRORLEVEL:BYTE
EXTRN	OPTIONS_SENT:BYTE
EXTRN	PSP_SEG:WORD			;PSP segment ** USE OF ES SHOULD BE EXAMINED FURTHER
EXTRN	SAV_DEFAULT_DRV:BYTE		;1 = A, 2 = B ...
EXTRN	SAV_DEFAULT_DIR:BYTE
EXTRN	SAV_S_DRV:BYTE
EXTRN	SAV_S_CURDIR:BYTE
EXTRN	SAV_T_DRV:BYTE
EXTRN	SAV_T_CURDIR:BYTE
EXTRN	TOP_OF_MEMORY:WORD
EXTRN	S_DRV_NUMBER:BYTE		;source drive number, 1 = A, 2 = B ...
EXTRN	T_DRV_NUMBER:BYTE		;target drive number
EXTRN	SO_DRIVE:BYTE			;AN000;S DRIVE LETTER SPECIFIED IN PARSE
EXTRN	S_DRV:BYTE
EXTRN	S_DRV_1:BYTE
EXTRN	S_DRV_PATH:BYTE 		;formal source drv, path
EXTRN	S_PATH:BYTE
EXTRN	T_DRV_PATH:BYTE 		;formal target drv, path
EXTRN	T_PATH:BYTE
EXTRN	TAR_DRIVE:BYTE			;AN000;T DRIVE LETTER SPECIFIED IN PARSE
EXTRN	PARMS:DWORD			;AN000;PARSER PARAMETER CONTROL BLOCK
EXTRN	CURRENT_PARM:WORD		;AN004;POINTER TO NEXT CMD LINE OPERAND
EXTRN	T_DRV:BYTE			;target drv letter
EXTRN	T_DRV_1:BYTE			;target drv letter
EXTRN	T_DRV_2:BYTE
EXTRN	S_FILE:BYTE			;source filename
EXTRN	T_FILENAME:BYTE
EXTRN	T_TEMPLATE:BYTE
EXTRN	DISP_S_PATH:BYTE		;input mirror image source path
EXTRN	DISP_T_PATH:BYTE		;input mirror image target path
EXTRN	BUFFER_PTR:WORD
EXTRN	BUFFER_BASE:WORD
EXTRN	BUFFER_LEFT:WORD
EXTRN	MAX_BUFFER_SIZE:WORD
EXTRN	MAX_CX:WORD
EXTRN	S_ARC_DRV:BYTE			;source drv, path for archive bit handling
EXTRN	S_ARC_PATH:BYTE
EXTRN	T_MKDIR_LVL:BYTE		;# of target starting directories created.
EXTRN	MSG_NUM:WORD			;AN000;MESSAGE NUMBER
EXTRN	MSG_CLASS:BYTE			;AN000;MESSAGE CLASS
EXTRN	INPUT_FLAG:BYTE 		;AN000;TYPE INT21 USED FOR KBD INPUT
EXTRN	SUBST_COUNT:WORD		;AN000;MESSAGE SUBSTITUTION COUNT
EXTRN	SUBLIST1:DWORD			;AN000;MSG SUBLIST USED BY INIT & MAIN
;
EXTRN	MY_FLAG:BYTE
EXTRN	SYS_FLAG:BYTE
EXTRN	COPY_STATUS:BYTE
EXTRN	OPTION_FLAG:BYTE
;
EXTRN	INPUT_DATE:WORD
EXTRN	INPUT_TIME:WORD
;
;
DSEG	ENDS
;
DSEG_INIT SEGMENT PARA PUBLIC 'INIT_DATA'		;AN000;
;--- Local variables for INIT which will be free into memory after init.
;----include file(s)------
INCLUDE XINITMSG.EQU			;AN000;xcopy initialization, prompt msg
;----variables------------
S_INPUT_PARM DB 80 DUP (0)		;source image of input parm
T_INPUT_PARM DB 80 DUP (0)		;target image of input parm
T_TRANS_PATH DB 128 DUP (0)		;AN016;TARGET BUFFER FOR NAME TRANSLATE
S_TRANS_PATH DB 128 DUP (0)		;AN016;SOURCE BUFFER FOR NAME TRANSLATE

PUBLIC	PARM_FLAG
PARM_FLAG DB	0
;	first_parm_flag equ	01h	;first parm entered in input parm
;	second_parm_flag equ	 02h	;second parm entered.
;	end_of_parm_flag equ	 04h	;end of parm reached
;	copy_onto_itself_flag equ     08h ;copy onto itself flag
;	cyclic_flag equ     10h 	;cyclic copy flag
;	inv_time_flag equ     20h	;invalid time
;	inv_date_flag equ     40h	;invalid date
;	init_error_flag equ    80h	;critical initialization error. Should abort.

PARM1_FLAG DB	0
;	inv_s_path_flag equ	01h	;invalid source path (path not found)
;	inv_t_path_flag equ	02h	;invalid target path
;	s_file_flag equ     04h 	;source filename entered
;	t_file_flag equ     08h 	;target filename entered
;	INV_SW_flag equ     10h 	;AN004;DUPLICATE OR INVALID SW ENTERED
;
TEMP_T_FILENAME DB 15 DUP (0)		;temporary target filename holder
FILENAME_FOR_PROMPT DB 15 DUP (0)	;upper case lettered TEMP_T_FILENAME for prompts
;** The following definitions are used for "Does ... specify a file name
;** or directory name (F:file, D:directory)?.
ALPHA_FILE DW	?			;AN000;THIS IS THE TRANSLATION OF 'F'
ALPHA_DIR DW	?			;AN000;THIS IS THE TRANSLATION OF 'D'
USER_INPUT DW	?			;AC000;KEYBOARD SAVE - MAY BE DBCS -

Maxdays db	31,28,31,30,31,30,31,31,30,31,30,31 ;Max days per month
Day	db	?			;
Month	db	?			;
Year	dw	?			;
Parmdate dw	?			;date parameter used in file date
;
COUNTRY_INFO DB 34 DUP (0)
;-------------------------------
;    Structures
;-------------------------------

SUB_LIST STRUC				;AN000;MSG RETRIEVER SUBSTITUTION LST
	DB	11			;AN000;
	DB	0			;AN000;
DATA_OFF DW	0			;AN000; offset of data to be inserted
DATA_SEG DW	0			;AN000; offset of data to be inserted
MSG_ID	DB	0			;AN000; n of %n
FLAGS	DB	0			;AN000; Flags
MAX_WIDTH DB	0			;AN000; Maximum field width
MIN_WIDTH DB	0			;AN000; Minimum field width
PAD_CHAR DB	0			;AN000; character for pad field

SUB_LIST ENDS				;AN000;

SSET	DB	0
PUBLIC	SSET
ESET	DB	0
PUBLIC  ESET
QSET	DB	0
PUBLIC	QSET

DSEG_INIT ENDS
;*******************************************************************************

CSEG	SEGMENT PUBLIC 'CODE'			;ATTACHED TO MAIN PROGRAM
	ASSUME	CS:CSEG, DS:DGROUP, ES:DGROUP
;
;--- PUBLIC   PROCEDURES ---		;USED BY PARSER
PUBLIC	GET_PARMS			;AN000;
;---------------------------

;--- EXTERNAL PROCEDURES ---
EXTRN	SET_BUFFER_PTR:NEAR
EXTRN	STRING_LENGTH:NEAR
EXTRN	CONCAT_ASCIIZ:NEAR
EXTRN	LAST_DIR_OUT:NEAR
EXTRN	CHK_DBCS:NEAR			;AN010;NEEDED TO PARSE THE PATH STRING
EXTRN	COMPRESS_FILENAME:NEAR
EXTRN	CHK_DRV_LETTER:NEAR
EXTRN	SET_DEFAULT_DRV:NEAR
EXTRN	PRINT_STDOUT:NEAR
EXTRN	PRINT_STDERR:NEAR
EXTRN	MAIN_EXIT:NEAR
EXTRN	MAIN_EXIT_A:NEAR
EXTRN	CTRL_BREAK_EXIT:NEAR
EXTRN	PARSER:NEAR			;AN000;PROCESS THE KBD INPUT STRING
EXTRN	SYSGETMSG:NEAR			;AN000;TO GET THE 'F'ILE or 'D'IRECTORY
EXTRN	MY_INT24:WORD
;---
EXTRN	SAV_INT24_OFF:WORD		;int 24, critical error handler addr.
EXTRN	SAV_INT24_SEG:WORD
;
;--- PARSER REFERENCES ---
;
EXTRN	RESULT1:BYTE			;AN000;
EXTRN	RESULT_PTR1:DWORD		;AN000;
EXTRN	TYPE1:BYTE			;AN000;
EXTRN	RESULT2:BYTE			;AN000;
EXTRN	RESULT_PTR2:DWORD		;AN000;
EXTRN	TYPE2:BYTE			;AN000;
EXTRN	RESULTSW1:BYTE			;AN000;
EXTRN	RESULTSWSYN:WORD		;AN000;
EXTRN	SW_A:BYTE			;AN000;
EXTRN	SW_E:BYTE			;AN000;
EXTRN	SW_M:BYTE			;AN000;
EXTRN	SW_P:BYTE			;AN000;
EXTRN	SW_S:BYTE			;AN000;
EXTRN	SW_V:BYTE			;AN000;
EXTRN	SW_W:BYTE			;AN000;
EXTRN	SW_D:BYTE			;AN000;
EXTRN	DATE_YEAR:WORD			;AN000;
EXTRN	DATE_MONTH:BYTE 		;AN000;
EXTRN	DATE_DAY:BYTE			;AN000;
EXTRN	SW9_BUFF_SYN : WORD		; xcopypar.asm
EXTRN	SW9_SYN : BYTE			; xcopypar.asm
;---

PUBLIC	INIT
INIT	PROC	NEAR
	CMP	AX, 0			;check drv validity
;	$IF	NE
	JE $$IF1
	    MOV     DX, MSG_INVALID_DRV ;AC000;GET THE MESSAGE ID
	    OR	    PARM_FLAG, INIT_ERROR_FLAG ;critical error. Abort
;	$ELSE
	JMP SHORT $$EN1
$$IF1:
	    CALL    HOOK_CTRL_BREAK	;hooks control break
	    CALL    SAV_HOOK_INT24	;hooks critical err handler
	    CALL    GET_CUR_DRV 	;save current default drv
	    MOV     DL, SAV_DEFAULT_DRV
	    LEA     SI, SAV_DEFAULT_DIR
	    CALL    GET_CUR_DIR 	;save current default dir
	    CALL    PARSE_INPUT_PARM
	    CMP     DGROUP:[OPTIONS_SENT], 0	; should we bail out?
	    JE      @F				; jump if not
	    JMP     SHORT INIT_EXIT		; else get out now
@@:
	    TEST    PARM_FLAG, INIT_ERROR_FLAG
;	    $IF     Z			;no error
	    JNZ $$IF3
		CALL	TOP_OF_MEM	;set top_of_memory
		CALL	INIT_BUFFER	;init buffer information

		MOV	DL, S_DRV_NUMBER
		DEC	DL
		CALL	SET_DEFAULT_DRV ;set source as a default drv
;	    $ENDIF
$$IF3:
;	$ENDIF
$$EN1:
	TEST	PARM_FLAG, INIT_ERROR_FLAG ;any error?
;	$IF	NZ			;yes. critical error
	JZ $$IF6
	    CMP     DX,MSG_INV_SW	;AN004;MSG REQUIRES SUB LIST
;	    $IF     NE,AND		;AC023;NO SUBLIST REQUIRED
	    JE $$IF7
	    CMP     DX,MSG_INVALID_PARM ;AN004;MSG REQUIRES SUB LIST
;	    $IF     NE,AND		;AC023;NO SUBLIST REQUIRED
	    JE $$IF7
	    CMP     DX,MSG_INV_NUM_PARM ;AN004;MSG REQUIRES SUB LIST
;	    $IF     NE			;AC023;NO SUBLIST REQUIRED
;	    JE $$IF7                    ; M00
		MOV	SUBST_COUNT,NO_SUBST ;AN000;NO SUBSTITUTION TEXT
		CMP	DX,SYSPRM_MISSING_OP ;AN024;OPERANDS MISSING(2) ERR?
;		$IF	E		;AN024;
		JNE $$IF8
		    MOV DX,MSG_INV_NUM_PARM ;AN024;NO SUBLIST REQUIRED
;		$ENDIF			;AN024;
$$IF8:
		MOV	MSG_NUM,DX	;AN000;NEED MESSAGE ID FOR PRINT
;	    $ELSE			;AN004;SUBST LIST REQUIRED
	    JMP SHORT $$EN7
$$IF7:
		MOV	MSG_NUM,DX	;AN004;NEED MESSAGE ID FOR PRINT
		MOV	SUBST_COUNT,PARM_SUBST_ONE ;AN004;PARM SUBST COUNT=1
;
		MOV	DX,CURRENT_PARM ;AN004;OFFSET TO BAD SWITCH
		LEA	SI,SUBLIST1	;AN004; address to sublist
		MOV	[SI].DATA_OFF,DX ;AN004; save data offset
		MOV	[SI].DATA_SEG,DS ;AN004; save data segment
		MOV	[SI].MSG_ID,0	;AN023; message ID
		MOV	[SI].FLAGS,010H ;AN004; ASCIIZ str,l align
		MOV	[SI].MAX_WIDTH,0 ;AN004; MAXIMUM FIELD WITH
		MOV	[SI].MIN_WIDTH,0 ;AN004; MINIMUM FIELD WITH
;	    $ENDIF			;AN004;
$$EN7:
	    MOV     INPUT_FLAG,NO_INPUT ;AN000;NO INPUT = 0
	    MOV     MSG_CLASS,UTILITY_MSG_CLASS ;AN000;MESSAGE CLASS = -1
	    CALL    PRINT_STDERR	;AN000;print error. AX point to msg ID
	    MOV     ERRORLEVEL, 4	;error ending
	    STC 			;set carry and exit to the main_exit
;	$ELSE
	JMP SHORT $$EN6
$$IF6:
	    CLC
;	$ENDIF
$$EN6:
INIT_EXIT:
	RET
INIT	ENDP

;
PARSE_INPUT_PARM PROC NEAR
;
	CALL	PARSER		    ;AN000;the PARSER interface routine
;	$IF	C		    ;AC000;if no non_delimiter chr?
	JNC $$IF14
	    TEST    PARM_FLAG,INIT_ERROR_FLAG ;AN000;PARM ERR HAS OCCURRED
;	    $IF     Z		    ;AN000;NO, MUST BE PARSER ERROR
	    JNZ $$IF15
		OR	PARM_FLAG,INIT_ERROR_FLAG ;AN000;SET THE FLAG
		CMP	AX,SYSPRM_EX_MANY ;AN000;TOO MANY OPERANDS (1) ERR?
;		$IF	E	    ;AN000;
		JNE $$IF16
		    MOV     BYTE PTR [SI],NUL ;AN024;DELIMIT BAD PARM
		    MOV     DX,MSG_INV_NUM_PARM ;AN000;MSG NUM = 21
;		$ELSE		    ;AN000;
		JMP SHORT $$EN16
$$IF16:
		    CMP     AX,SYSPRM_DUP_SW ;AN004;DUPLICATE SW REQUESTED
;		    $IF     E	    ;AN004;
		    JNE $$IF18
			MOV	BYTE PTR [SI],NUL ;AN004;DELIMIT BAD PARM
			MOV	DX,MSG_INV_SW ;AN004;MSG NUM = 35
;		    $ELSE	    ;AN004;
		    JMP SHORT $$EN18
$$IF18:
			CMP	AX,SYSPRM_MISSING_OP ;AN006;MISSING PARM=2
;			$IF	E   ;AN006;
			JNE $$IF20
			    MOV     DX,AX     ;AN024 ;MSG NUM=21-NO SUBLIST
;			$ELSE	    ;AN006;
			JMP SHORT $$EN20
$$IF20:
			    MOV     BYTE PTR [SI],NUL ;AN024;DELIMIT BAD PARM
			    MOV     DX,MSG_INVALID_PARM ;AN000;MSG NUM = 3
;			$ENDIF	    ;AN006;
$$EN20:
;		    $ENDIF	    ;AN004;
$$EN18:
;		$ENDIF		    ;AN000;
$$EN16:
;	    $ELSE		    ;AN006;INIT_ERROR_FLAG ALSO SET
	    JMP SHORT $$EN15
$$IF15:
		TEST	PARM_FLAG,INV_DATE_FLAG ;AN006;WAS DATE INVALID?
;		$IF	NZ	    ;AN006;THE DATE IS INVALID
		JZ $$IF26
		    MOV     DX,MSG_INVALID_DATE ;AN006;MSG NUM = 9
;		$ENDIF		    ;AN006;
$$IF26:
;	    $ENDIF		    ;AN000;
$$EN15:
;	$ELSE			    ;AN000;
	JMP SHORT $$EN14
$$IF14:
	    CMP	    DGROUP:[OPTIONS_SENT], 0	; do we bail out?
	    JNE     PIP_EXIT			;  go if options sent
	    CALL    GET_DRIVES	    ;get source, target drive
	    TEST    PARM_FLAG, INIT_ERROR_FLAG ;critical syntax error?
;	    $IF     Z		    ;if not,
	    JNZ $$IF30
		CALL	CHK_SLASH_W ;with /w, show "Press any key to begin ... " msg.
		call	save_for_display ;save source, target parm for display purposes
		CALL	CHK_SET_PARMS ;check and set each parms.
		TEST	PARM_FLAG, INIT_ERROR_FLAG ;critical syntax error?
;		$IF	Z	    ;no
		JNZ $$IF31
		    call    modify_for_display ;set the source, target parm for display
;		$ENDIF
$$IF31:
;	    $ENDIF
$$IF30:
;	$ENDIF
$$EN14:
	MOV	AL, 0
	LEA	DI, S_PATH
	CALL	STRING_LENGTH		;cx - # of chr
	LEA	SI, S_PATH
	LEA	DI, S_ARC_PATH
	REP	MOVSB			;s_path => s_arc_path
PIP_EXIT:
	RET
PARSE_INPUT_PARM ENDP
;

CHK_SLASH_W PROC NEAR
;if /W option is specified, then
;show "Press any key to begin copying file(z)" message and wait for a key stroke.


	TEST	OPTION_FLAG, SLASH_W	;/W option taken?
;	$IF	NZ			;yes.
	JZ $$IF35
	    PUSH    AX			;AN000;
	    MOV     AX, MSG_TO_BEGIN	;AC000;GET THE MESSAGE ID
	    MOV     MSG_NUM,AX		;AN000;SET THE MESSAGE NUMBER
	    MOV     SUBST_COUNT,NO_SUBST ;AN000;NO SUBSTITUTION TEXT
	    MOV     INPUT_FLAG,DOS_KEYB_INP ;AN000;RESPONSE EXPECTED = 1
	    MOV     MSG_CLASS,UTILITY_MSG_CLASS ;AN000;MESSAGE CLASS = -1
	    CALL    PRINT_STDOUT	;AN000;MSG AX points to message ID

	    MOV     AX,MSG_CR_LF_STR	;AN000; JUST CR,LF
	    MOV     MSG_NUM,AX		;AN000; set message number
	    MOV     INPUT_FLAG,NO_INPUT ;AN000; NO INPUT
	    CALL    PRINT_STDOUT	;AN000; Display message

	    POP     AX			;AN000;
;	$ENDIF
$$IF35:
	RET

CHK_SLASH_W ENDP
;
PROMPT_TO_USER PROC NEAR
;guide the user to enter the input parameters
;get user input to S_INPUT_PARM, T_INPUT_PARM for source, target parms.
;INPUT: ES - PSP seg
;	DS - data seg
;	SAV_DEFAULT_DRV
;
	MOV	dx, msg_inv_num_parm	;AC000;GET THE MESSAGE ID
	or	parm_flag, init_error_flag
	RET
PROMPT_TO_USER ENDP
;
GET_PARMS PROC	NEAR
;Get the first parameter(s), second parameter(s) and option(s).
;Not checking correct character entered.
;The logic is:
;1). Find the first non_delim from the Parser control block. This is the
;    start of the first parm. Validate the length and put into S_INPUT_PARM.
; Note that this routine currently does not check the S_INPUT_PARM to see
;    if it is valid or not.
;2). Find the next non_delim from the Parser control block. This is the
;    start of the second parm. Validate the length and put into T_INPUT_PARM.
; Note that this routine currently does not check the T_INPUT_PARM to see
;    if it is valid or not.
;3). Find the switch(es) from the parser control block and set the
;    corresponding bit in the option flag word(OPTION_FLAG) by calling
;    GET_OPTIONS.
;
;INPUT:
;      BX - PARSER OPERAND POINTER

	PUSH	DS			;AN000;
	CMP	BX,OFFSET DGROUP:RESULT1 ;AN000;WAS FIRST FILESPEC SPECIFIED?
;	$IF	E			;AN000;IF FIRST FILESPEC SPECIFIED,
	JNE $$IF37
	    LDS     SI,RESULT_PTR1	;AN000;GET WHERE THE STRING IS
	    ASSUME  DS:NOTHING		;AN000;
	    CMP     DS:BYTE PTR [SI]+BYTE,COLON ;AN000;DOES FILESPEC START WITH
					;DRIVE?
;	    $IF     E			;AN000;STARTS WITH DRIVE
	    JNE $$IF38
		LODSW			;AN000;GET JUST THE DRIVE LETTER AND
		MOV	ES:SO_DRIVE,AL	;AN000;ALSO ADJUSTS WHERE THE STRING IS
		LEA	DI,ES:S_INPUT_PARM ;AN000;MOVE PARM TO SOURCE FILESPEC
		STOSW			;AN000;MOVE DRIVE TO FILESPEC
;	    $ELSE			;AN000;DOES NOT START WITH DRIVE
	    JMP SHORT $$EN38
$$IF38:
		LEA	DI,ES:S_INPUT_PARM ;AN000;MOVE PARM TO SOURCE FILESPEC
;	    $ENDIF			;AN000;FILESPEC HAVE DRIVE?
$$EN38:
	    CMP     DGROUP:TYPE1,5	;AN000;FILESPEC ?
;	    $IF     E			;AN000;MORE THAN JUST DRIVE
	    JNE $$IF41
					;MOVE PARM TO WHERE FIND FIRST/NEXT
					; WILL KNOW WHERE TO START
		PUSH	BX		;AN000;SAVE THE DATABASE POINTER
		XOR	BX,BX		;AN000;ZERO FOR THE PARAMETER LENGTH
;		$DO	COMPLEX 	;AN000;
		JMP SHORT $$SD42
$$DO42:
		    INC     BX		;AN000;CALCULATE LENGTH
		    STOSB		;AN000;MOVE CHAR TO FILESPEC
;		$STRTDO 		;AN000;
$$SD42:
		    LODSB		;AN000;GET NEXT CHAR FROM COMMAND LINE
		    CMP     AL,NUL	;AN000;IS THAT THE END OF THE STRING
;		$ENDDO	E		;AN000;GOT IT ALL, QUIT
		JNE $$DO42
		CALL	CHK_MAX_LENGTH	;AN000;LENGTH OF STRING <=64
		POP	BX		;AN000;RESTORE THE DATA BASE POINTER
;		$IF	NC		;no, less than or equal
		JC $$IF45
		    OR	    PARM_FLAG, FIRST_PARM_FLAG
;		$ELSE			;AN000;
		JMP SHORT $$EN45
$$IF45:
		    MOV     DX, MSG_LONG_PATH ;AN000;ADDRESS OF MESSAGE TXT
		    OR	    PARM_FLAG, INIT_ERROR_FLAG ;AN000;
;		$ENDIF			;AN000;CRITICAL ERROR INDICATED
$$EN45:
;	    $ENDIF			;AN000;MOVE ALL DONE
$$IF41:
;	$ELSE				;AN000;IF SECOND FILESPEC SPECIFIED,
	JMP SHORT $$EN37
$$IF37:
	    CMP     BX,OFFSET DGROUP:RESULT2 ;AN000;WAS 2nd FILESPEC SPECIFIED?
;	    $IF     E			;AN000;IF SECOND FILESPEC SPECIFIED
	    JNE $$IF50
		LDS	SI,RESULT_PTR2	;AN000;GET WHERE THE STRING IS
		ASSUME	DS:NOTHING	;AN000;
		CMP	DS:BYTE PTR [SI]+BYTE,COLON ;AN000;DOES FILESPEC START
					;WITH DRIVE?
;		$IF	E		;AN000;STARTS WITH DRIVE
		JNE $$IF51
		    LODSW		;AN000;GET JUST THE DRIVE LETTER AND
		    MOV     ES:TAR_DRIVE,AL ;AN000;ALSO ADJUSTS WHERE THE STRING IS
		    LEA     DI,ES:T_INPUT_PARM ;AN000;MOVE PARM TO TARGET FILESPEC
		    STOSW		;AN000;MOVE DRIVE TO FILESPEC
;		$ELSE			;AN000;DOES NOT START WITH DRIVE
		JMP SHORT $$EN51
$$IF51:
		    LEA     DI,ES:T_INPUT_PARM ;AN000;MOVE PARM TO TARGET FILESPEC
;		$ENDIF			;AN000;FILESPEC HAVE DRIVE?
$$EN51:
		CMP	DGROUP:TYPE2,5	;AN000;FILESPEC ?
;		$IF	E		;AN000;MORE THAN JUST DRIVE
		JNE $$IF54
					;AN000;MOVE PARM TO WHERE FIND FIRST/NEXT
					;AN000; WILL KNOW WHERE TO START
		    PUSH    BX		;AN000;SAVE THE DATABASE POINTER
		    XOR     BX,BX	;AN000;ZERO FOR THE PARAMETER LENGTH
;		    $DO     COMPLEX	;AN000;
		    JMP SHORT $$SD55
$$DO55:
			INC	BX	;AN000;CALCULATE LENGTH
			STOSB		;AN000;MOVE CHAR TO FILESPEC
;		    $STRTDO		;AN000;
$$SD55:
			LODSB		;AN000;GET NEXT CHAR FROM COMMAND LINE
			CMP	AL,NUL	;AN000;IS THAT THE END OF THE STRING
;		    $ENDDO  E		;AN000;GOT IT ALL, QUIT
		    JNE $$DO55
		    CALL    CHK_MAX_LENGTH ;AN000;LENGTH OF STRING <=64
		    POP     BX		;AN000;RESTORE THE DATA BASE POINTER
;		    $IF     NC
		    JC $$IF58
			OR	PARM_FLAG, SECOND_PARM_FLAG
;		    $ELSE
		    JMP SHORT $$EN58
$$IF58:
			MOV	DX, MSG_LONG_PATH ;AN000;ADDRESS OF MESSAGE TXT
			OR	PARM_FLAG, INIT_ERROR_FLAG ;AN000;
;		    $ENDIF		;AN000;CRITICAL ERROR INDICATED
$$EN58:
;		$ENDIF			;AN000;SECOND FILESPEC
$$IF54:
;	    $ELSE			;AN000;FILESPEC NOT SPECIFIED
	    JMP SHORT $$EN50
$$IF50:
		CALL	GET_OPTIONS	;AN000;PROCESS THE SWITCHES
;	    $ENDIF			;AN000;MOVE ALL DONE
$$EN50:
;	$ENDIF				;AN000;FILESPEC?
$$EN37:
	POP	DS			;AN000;
	ASSUME	DS:DGROUP		;AN000;
	RET
GET_PARMS ENDP
;
SAVE_FOR_DISPLAY PROC NEAR
;save first parm, second parm into DISP_S_PATH, DISP_T_PATH.
;at this time, this is not gauranteed to be a path. They may
;contains filename in it.
;input: S_INPUT_PARM, T_INPUT_PARM, PARM_FLAG
;	DS: data seg
;	ES: psp

	PUSH	ES			;save ES
	PUSH	DS
	POP	ES			;ES = DS
	TEST	PARM_FLAG, FIRST_PARM_FLAG ;first parm entered?
;	$IF	NZ			;yes
	JZ $$IF65
	    MOV     AL, 0		;asciiz
	    LEA     DI, S_INPUT_PARM
	    CALL    STRING_LENGTH	;now CX has length
	    LEA     SI, S_INPUT_PARM
	    LEA     DI, DISP_S_PATH	;source path for display
	    CALL    MOV_STRING		;AC000;s_input_parm => disp_s_path

;	$ENDIF
$$IF65:
	TEST	PARM_FLAG, SECOND_PARM_FLAG ;second parm entered?
;	$IF	NZ
	JZ $$IF67
	    MOV     AL, 0
	    LEA     DI, T_INPUT_PARM
	    CALL    STRING_LENGTH
	    LEA     SI, T_INPUT_PARM
	    LEA     DI, DISP_T_PATH
	    CALL    MOV_STRING		;AC000;s_input_parm => disp_s_path
;	$ENDIF
$$IF67:
	POP	ES
	RET
SAVE_FOR_DISPLAY ENDP
;
MOV_STRING PROC NEAR			;AN000;
; move string from DS:SI to ES:DI
; CX should indicate string length
	cld
;	$DO
$$DO69:
	    CMP     CX, 0
;	$LEAVE	Z
	JZ $$EN69
	    LODSB			;[si] => AL
	    STOSB			;AL => [di]
	    DEC     CX
;	$ENDDO
	JMP SHORT $$DO69
$$EN69:
	RET
MOV_STRING ENDP 			;AN000;
;
MODIFY_FOR_DISPLAY PROC NEAR
;finally trims DISP_S_PATH, DISP_T_PATH into good shape.
;input: DS, ES = data seg. S_FILE_FLAG, T_FILE_FLAG

	LEA	DI, DISP_S_PATH
	LEA	SI, DISP_S_PATH
	TEST	PARM1_FLAG, S_FILE_FLAG ;source filename entered?
	JZ	MFD_NO_FILE1		;no
	CALL	MASSAGE_DISP_PATH	;yes, entered.
	JMP	SHORT MFD_TARGET
MFD_NO_FILE1:				;no source filename
	CALL	CHK_DRV_LETTER		;using [si]
	JC	MFD_CHK_TAIL1
	CMP	BYTE PTR [SI], 0	;D:,0 case
	JE	MFD_TARGET		;OK
	CMP	BYTE PTR [SI], '\'
	JNE	MFD_CHK_TAIL1		;D:dir... case
	CMP	BYTE PTR [SI+1], 0	;D:\,0 case
	JE	MFD_TARGET		;OK
MFD_CHK_TAIL1:				;else check tail
	CALL	CHK_TAIL_CHR		;chk tail and put \ at the end. using di
MFD_TARGET:
	LEA	DI, DISP_T_PATH
	LEA	SI, DISP_T_PATH
	TEST	PARM1_FLAG, T_FILE_FLAG
	JZ	MFD_NO_FILE2
	CALL	MASSAGE_DISP_PATH
	JMP	SHORT MFD_EXIT
MFD_NO_FILE2:
	CALL	CHK_DRV_LETTER
	JC	MFD_CHK_TAIL2
	CMP	BYTE PTR [SI], 0
	JE	MFD_EXIT
	CMP	BYTE PTR [SI], '\'
	JNE	MFD_CHK_TAIL2
	CMP	BYTE PTR [SI+1], 0
	JE	MFD_EXIT
MFD_CHK_TAIL2:
	CALL	CHK_TAIL_CHR
MFD_EXIT:
	RET
MODIFY_FOR_DISPLAY ENDP
;
CHK_TAIL_CHR PROC NEAR
;check the last chr of ASCIIZ string pointed by DI.
;if it is \,0 then OK, else put \ there.
;DS, ES = data seg
;DI points to string.
;OUTPUT: Revised string.
;AX, BX, CX - destroyed
	MOV	AL, 0			;asciiz
	PUSH	DI			;save di
	CALL	STRING_LENGTH		;now cx got the length including 0
	POP	DI			;restore di
	DEC	CX
	DEC	CX
	MOV	BX, CX

ifdef DBCS
	push	bx
	push	si
	add	bx,di
	mov	si,di
	call	CheckDBCSTailByte
	pop	si
	pop	bx
	jz	@f			; if last character is tail byte
endif

	CMP	BYTE PTR [DI][BX], '\'	;last chr before 0
	JE	CTC_EXIT		;\,0 case

ifdef DBCS
@@:
endif

	MOV	BYTE PTR [DI][BX+1], '\' ;change 0 to '\'
	MOV	BYTE PTR [DI][BX+2], 0	;make it asciiz again.
CTC_EXIT:
	RET
CHK_TAIL_CHR ENDP
;
MASSAGE_DISP_PATH PROC NEAR
;INPUT: DS, ES = data seg
;	DI = points to source. Used for LAST_DIR_OUT
;	SI = points to source. Used for CHK_DRV_LETTER routine
;OUTPUT: Revised source string

	CALL	LAST_DIR_OUT
;	$IF	C			;failure? no '\' found
	JNC $$IF72
	    CALL    CHK_DRV_LETTER	;drive letter?
;	    $IF     NC			;yes. "D:filename",0 case
	    JC $$IF73
		MOV	BYTE PTR DS:[SI], 0 ;make it "D:",0 since SI now points to the next chr
;	    $ELSE			;no. "filename",0 case
	    JMP SHORT $$EN73
$$IF73:
		MOV	BYTE PTR [DI], 0 ;set DISP_S_PATH to 0
;	    $ENDIF
$$EN73:
;	$ELSE				;found '\' and last '\' became 0
	JMP SHORT $$EN72
$$IF72:
	    MOV     DI, AX		;we want to restore '\' and put 0 just after that.
	    DEC     DI			;for ex, "D:\filename"=>"D:"=>"D:\"
	    MOV     BYTE PTR [DI], '\'	;	 "D:dir1\dir2"=>"D:dir1"=>"D:dir1\"
	    MOV     BYTE PTR [DI+1], 0
;	$ENDIF
$$EN72:
	RET
MASSAGE_DISP_PATH ENDP
;
CHK_MAX_LENGTH PROC NEAR
;Check the length of the source or target input string although this does not
;gaurantee the validity of the length of path.	This will just check/reduce
;the possibilities of long path.
;If the path string is longer than 64 (this includes 0 at the end of the string)
;then, carry will be set.
;INPUT: ds - data seg
;	es - psp seg
;	SI - points to the starting chr of the string.
;	BX - length of the string
;OUTPUT:
;	carry will set if the length if longer than we expected.

	PUSH	BX			;AN000;
	PUSH	DI
	PUSH	SI
					;AC001;DELETED CODE FOR PTM0011
	CMP	BYTE PTR [SI], '\'	;SI points to '\'?
	JNE	CML_LENGTH		;no, now compare the length
	DEC	BX			;AC000;decrease length by 1 for '\'
CML_LENGTH:
	CMP	BX, 63			;AC000;length of string > 63?
	JG	CML_CARRY		;AC027;WORK WITH ONLY + CMP RESULT
	CLC				;NO.  OK.
	JMP	SHORT CML_EXIT
CML_CARRY:
	STC				;not OK
CML_EXIT:
	POP	SI
	POP	DI
	POP	BX			;AN000;
	RET

CHK_MAX_LENGTH ENDP
;
;
	PUBLIC	GET_OPTIONS
GET_OPTIONS PROC NEAR
;get options from the PARSER and
;set OPTION_FLAG.
;INPUT:
;      BX - PARSER OPERAND POINTER
;

	CMP	DS:[SW9_BUFF_SYN], offset DGROUP:SW9_SYN	; was /? specified?
	JNE	GO_OPTIONS_DONE			; skip if not
	MOV	QSET, 1
	CALL	DISPLAY_OPTIONS			; show user the options
	MOV	DGROUP:[OPTIONS_SENT], 1	; flag this as done
	MOV	DGROUP:[ERRORLEVEL], 0		;  and no error
	CLC					;   at all
	JMP	GO_EXIT				;  and bail out
GO_OPTIONS_DONE:

	CMP	BX,OFFSET DGROUP:RESULTSW1 ;AN000;WAS SW 1 THROUGH 7 SPECIFIED?
	MOV	DI,RESULTSWSYN		;AN000;GET THE SYNONYM POINTER [ES]

;	$IF	E,LONG			;AN000;IF SWITCH SPECIFIED
	JE $$XL1
	JMP $$IF78
$$XL1:
	    CMP     BYTE PTR ES:[DI+BYTE],ALPHA_S ;AC000;"S"
	    JNE     GO_A
 	    MOV	    SSET, 1
	    OR	    OPTION_FLAG, SLASH_S ;set the walk the tree bit on.
	    MOV     SW_S,SPACE		;AN004;DISALLOW DUPLICATE SWITCHES
	    JMP     GO_EXIT		;AC000;
GO_A:
	    CMP     BYTE PTR ES:[DI+BYTE],ALPHA_A ;AN000;"A"
	    JNE     GO_M
	    MOV     SW_A,SPACE		;AN004;DISALLOW DUPLICATE SWITCHES
	    TEST    OPTION_FLAG, SLASH_M ;hard archive already on?
	    JZ	    GO_A1		;if not, continue
	    AND     OPTION_FLAG, RESET_SLASH_M ;else turn it off
GO_A1:
	    OR	    OPTION_FLAG, SLASH_A ;set soft archive
	    JMP     GO_EXIT		;AC000;
GO_M:
	    CMP     BYTE PTR ES:[DI+BYTE],ALPHA_M ;AN000;"M"
	    JNE     GO_P
	    MOV     SW_M,SPACE		;AN004;DISALLOW DUPLICATE SWITCHES
	    TEST    OPTION_FLAG, SLASH_A ;soft archive already on?
	    JZ	    GO_M1		;if not, skip this part
	    AND     OPTION_FLAG, RESET_SLASH_A ;else turn off the soft archive bit
GO_M1:
	    OR	    OPTION_FLAG, SLASH_M ;turn on the hard archive bit.
	    JMP     SHORT GO_EXIT	;AC000;
GO_P:
	    CMP     BYTE PTR ES:[DI+BYTE],ALPHA_P ;AN000;"P"
	    JNE     GO_E
	    MOV     SW_P,SPACE		;AN004;DISALLOW DUPLICATE SWITCHES
	    OR	    OPTION_FLAG, SLASH_P
	    OR	    MY_FLAG, SINGLE_COPY_FLAG ;if user want prompt, then should be single copy (not a multi copy).
	    JMP     SHORT  GO_EXIT	;AC000;
GO_E:
	    CMP     BYTE PTR ES:[DI+BYTE],ALPHA_E ;AN000;"E"
	    JNE     GO_V
	    MOV	    ESET, 1
	    MOV     SW_E,SPACE		;AN004;DISALLOW DUPLICATE SWITCHES
	    OR	    OPTION_FLAG, SLASH_E ;turn on "creating empty dir" bit.
	    JMP     SHORT  GO_EXIT	;AC000;
GO_V:
	    CMP     BYTE PTR ES:[DI+BYTE],ALPHA_V ;AN000;"V"
	    JNE     GO_W
	    MOV     SW_V,SPACE		;AN004;DISALLOW DUPLICATE SWITCHES
	    MOV     AH, 54h		;get verify setting
	    INT     21H
	    CMP     AL, 0
	    JNE     GO_EXIT		;AC000;if not 0, then already on.
	    MOV     AX, 2E01h		;else set it on
	    INT     21h
	    OR	    SYS_FLAG, TURN_VERIFY_OFF_FLAG ;don't forget it off when exit to dos.
	    JMP     SHORT   GO_EXIT	;AC000;
GO_W:
	    OR	    OPTION_FLAG, SLASH_W
	    MOV     SW_W,SPACE		;AN004;DISALLOW DUPLICATE SWITCHES
	    JMP     SHORT   GO_EXIT	;AC000;
;	$ELSE				;AN000;SINCE SWITCH 1 - 7 NOT SPECIFIED
	JMP SHORT $$EN78
$$IF78:
					; IT MUST BE THE DATE SWITCH
	    CALL    GET_INPUT_DATE	;AN000;get date from parser control block
	    OR	    OPTION_FLAG, SLASH_D
	    MOV     SW_D,SPACE		;AN004;DISALLOW DUPLICATE SWITCHES
;	$ENDIF				;AN000;
$$EN78:
GO_EXIT:
	RET
GET_OPTIONS ENDP


	PUBLIC	DISPLAY_OPTIONS
DISPLAY_OPTIONS PROC NEAR
;Display the options help message to the user.
;
;INPUT:
;      No value passed.
;
;OUTPUT:
;      No value returned.
;

	MOV	[MSG_NUM], MSG_OPTIONS_FIRST	; message to display
	MOV	[SUBST_COUNT], 0		; no substitutions
	MOV	[MSG_CLASS], UTILITY_MSG_CLASS	; message class
	MOV	[INPUT_FLAG], 0			; no input
DO_LOOP:
	CALL	PRINT_STDOUT
	CMP	[MSG_NUM], MSG_OPTIONS_LAST	; last message?
	JE	DO_DONE				;  done if so
	INC	[MSG_NUM]			; else get next msg
	JMP	DO_LOOP				;  and go do it
DO_DONE:
	RET

DISPLAY_OPTIONS	ENDP


GET_INPUT_DATE PROC NEAR
;get the input date from the parser and save it to  INPUT_DATE form which
;it can be used for comparison with FILE_DATE_DTA.
;INPUT:
;
;
;OUTPUT:
;
;
;

	CALL	VALIDATE_INPUT_DATE	;AN006;GO CHECK THE DATE
;	$IF	C			;AN006;SET IF THE DATE WAS INVALID
	JNC $$IF81
	    OR	    PARM_FLAG,INV_DATE_FLAG ;AN006;SET THE FLAG FOR DATE ERROR
	    OR	    PARM_FLAG,INIT_ERROR_FLAG ;AN006;SET THE FLAG FOR ERROR
;	$ELSE				;AN006;DATE WAS OK
	JMP SHORT $$EN81
$$IF81:
	    MOV     AX,DATE_YEAR	;AN000;GET YEAR FROM PARSER CTRL BLOCK
	    SUB     AX,1980		;AN000;SUBTRACT THE BASE YEAR
	    mov     cl,4		;AN000;SHIFT REG COUNT = 4
	    shl     ax,cl		;AN000;Shift it over 4
	    xor     dh,dh		;AN000;CLEAR THE AREA
	    mov     dl,DATE_MONTH	;AN000;GET MONTH FROM PARSER CTRL BLOCK
	    add     ax,dx		;AN000;Add in the Month
	    inc     cl			;AN000;BUMP SHIFT COUNT
	    shl     ax,cl		;AN000;Shift it over 5
	    xor     dh,dh		;AN000;CLEAR THE AREA
	    mov     dl,DATE_DAY 	;AN000;GET DAY FROM PARSER CTRL BLOCK
	    add     ax,dx		;AN000;Add in the Day
	    mov     INPUT_DATE,ax	;AN000;Store the date in DOS FCB format
	    CLC 			;AN000;CLEAR THE CARRY
;	$ENDIF				;AN006;
$$EN81:
	RET
GET_INPUT_DATE ENDP
;
VALIDATE_INPUT_DATE PROC NEAR
;CHECK FOR VALID DATE.
;
;OUTPUT: INVALID DATE = CARRY SET
;
;
;
;
	MOV	AH,GET_DATE		;AN006;DOS INT 2AH
	INT	21H			;AN006;MAKE THE CALL
	PUSH	CX			;AN006;YEAR
	PUSH	DX			;AN006;MONTH,DAY
	MOV	AH,SET_DATE		;AN006;DOS INT 2BH
	MOV	CX,DATE_YEAR		;AN006;GET YEAR FROM PARSER CTL BLOCK
	MOV	DH,DATE_MONTH		;AN006;GET MONTH FROM PARSER CTL BLOCK
	MOV	DL,DATE_DAY		;AN006;GET DAY FROM PARSER CTL BLOCK
	INT	21H			;AN006;MAKE THE CALL
	POP	DX			;AN006;GET THE SYSTEM MONTH,DAY
	POP	CX			;AN006;GET THE SYSTEM YEAR
	OR	AL,AL			;AN006;WAS MY INPUT DATE VALID?
	STC				;AN006;SET THE CARRY
	JNZ	ERR_DATE		;AN006;GET OUT WITH C SET
	CLC				;AN006;CLEAR THE CARRY, NO ERROR
	MOV	AH,SET_DATE		;AN006;RESTORE THE SYSTEM DATE
	INT	21H			;AN006;MAKE THE CALL
ERR_DATE:				;AN006;
	RET				;AN006;
;
VALIDATE_INPUT_DATE ENDP
;
CHK_SET_PARMS PROC NEAR
;This does a semantic checking on the given S_INPUT_PARM, T_INPUT_PARM and
;sets each of the starting drv path into S_PATH, T_PATH.
;The basic logic is:
;1). Try to change dir to a given S_INPUT_PARM.
;    if a success, then it must be the path. Chdir to it and get current
;    source directory using S_DRV_NUMBER by issuing GET_Current_directory call,
;    which starts from the root of the source drive.  In this way, you don't
;    have to worry about what type of path for the source has been entered.
;    You just try to chdir according to S_INPUT_PARM and
;    then call get_cur_dir to get the S_PATH which will always start
;    from the root of the source drive.
;    if not, then there must be the filename at the end, or there might be
;    garbage in the path.  So, take the last path name (which is, hopely,
;    a filename) and try chdir again.  If a success, then current source dir
;    is determined. Otherwise, error. Issue "Invalid direcory name". If a
;    success, then check the saved filename to make sure that there are no
;    invalid chr's in it. (When you try to take the last_dir_out, and
;    it has failed (carry set), then it was a filename candidate itself
;    (sometimes together with an drive id d:).	In this case, you have to
;    check the filename candidate if it has a drive id in front of it.
;    if it is, then take the drive id d: off from it and reshape the
;    filename candidate.  And check the invalid characters if any. Of cause
;    in this case, current direcory of source drv becomes S_PATH.
;2). Try to change dir to a given T_INPUT_PARM, if any. (If no T_INPUT_PARM
;    entered, then set current directory to the starting path of target using
;    T_DRV_NUMBER.)
;    If a success, then no problem.  It is a strating target path.
;    If not, then take the last dir out and try again.	If a failure, then
;    error "Invalid directory".
;    If a success, then check the saved filename to see if any illigal
;    characters in it.	If they are, then error. Else issue fun.29h
;    to see if there are any global characters in it.  If there
;    are, then assume a filename.  If there are not, then ask user
;    "Is XXXXX a filename in the target? (n)" If no, then it is a
;    subdirectory name.  Make a new subdirectory in the target and
;    concatenate a new directory name to the T_INPUT_PARM and chdir to
;    the new path (, which is the original path in fact) again.
;INPUT:
;	ES - PSP seg ; this will be changed to DS within this routine
;	DS - data seg

	PUSH	DS
	POP	ES			;set ES to DS
	TEST	PARM_FLAG, FIRST_PARM_FLAG ;first parm entered?
;	$IF	Z,AND			;NO
	JNZ $$IF84
	TEST	PARM_FLAG, SECOND_PARM_FLAG ;second parm entered?
;	$IF	Z			;NO
	JNZ $$IF84
	    MOV     DX, MSG_INV_NUM_PARM ;AC000;GET THE MESSAGE ID
	    OR	    PARM_FLAG, INIT_ERROR_FLAG ;critical error. exit program
;	$ELSE
	JMP SHORT $$EN84
$$IF84:

	    MOV     DL, S_DRV_NUMBER
	    LEA     SI, SAV_S_CURDIR
	    CALL    GET_CUR_DIR 	;get and save current source directory
	    OR	    SYS_FLAG, DEFAULT_S_DIR_FLAG ;indicates source dir saved
	    TEST    PARM_FLAG, FIRST_PARM_FLAG ;first parm only entered?
;	    $IF     Z			;no first parm
	    JNZ $$IF86
		LEA	SI, S_PATH	;then make current source dir as S_PATH
		CALL	GET_CUR_DIR
;	    $ELSE			;else first parm entered. check it
	    JMP SHORT $$EN86
$$IF86:
		LEA	DX, S_INPUT_PARM ;try to chdir to S_INPUT_PARM
		MOV	AH, Chdir	;= 3Bh
		INT	21h
;		$IF	NC		;success?
		JC $$IF88
		    MOV     DL, S_DRV_NUMBER
		    LEA     SI, S_PATH	;get current dir and save it
		    CALL    GET_CUR_DIR ;as a starting dir to S_PATH
;		$ELSE
		JMP SHORT $$EN88
$$IF88:
		    LEA     BX, S_INPUT_PARM
		    LEA     DX, S_FILE	;source filename
		    CALL    TAKE_PATH_TAIL ;take out the tail part of S_INPUT_PARM
		    LEA     DX, S_INPUT_PARM
		    MOV     AH, Chdir	;= 3Bh
		    INT     21h 	;try chdir again
;		    $IF     NC,AND	;success?
		    JC $$IF90
		    CMP     S_FILE, 0	;check s_file if something is there
;		    $IF     NE		;yes, filename entered.
		    JE $$IF90
			MOV	DL, S_DRV_NUMBER
			LEA	SI, S_PATH
			CALL	GET_CUR_DIR ;save current dir
			OR	PARM1_FLAG, S_FILE_FLAG ;source filename entered
			call	chk_s_reserved_name ;is it a reserved name?
;		    $ELSE
		    JMP SHORT $$EN90
$$IF90:
			MOV	DX, MSG_INVALID_PATH ;AC000;GET THE MESSAGE ID
			OR	PARM_FLAG, INIT_ERROR_FLAG ;critical error
;		    $ENDIF
$$EN90:
;		$ENDIF
$$EN88:
;	    $ENDIF
$$EN86:
;	$ENDIF
$$EN84:
	TEST	PARM_FLAG, INIT_ERROR_FLAG
;	$IF	Z,LONG			;no error so far,
	JZ $$XL2
	JMP SHORT $$IF96
$$XL2:
	    TEST    SYS_FLAG, ONE_DISK_COPY_FLAG ;if one disk copy
;	    $IF     NZ			;then saved source default directory
	    JZ $$IF97
		LEA	DX, SAV_S_DRV	;is the same as target current dir
		MOV	AH, Chdir	;=3Bh
		INT	21h		;so restore target default dir.
;	    $ENDIF
$$IF97:
	    MOV     DL, T_DRV_NUMBER
	    LEA     SI, SAV_T_CURDIR
	    CALL    GET_CUR_DIR 	;save current target directory
	    OR	    SYS_FLAG, DEFAULT_T_DIR_FLAG ;indicates target dir saved
	    TEST    PARM_FLAG, SECOND_PARM_FLAG ;second parm has been entered?
;	    $IF     Z			;second parm not entered
	    JNZ $$IF99
		LEA	SI, T_PATH
		CALL	GET_CUR_DIR	;make the current target dir as T_PATH
;	    $ELSE			;then deals with the second parm
	    JMP SHORT $$EN99
$$IF99:

		LEA	DX, T_INPUT_PARM ;try to chdir according to T_INPUT
		MOV	AH, Chdir
		INT	21h		;= 3Bh
;		$IF	C		;FAILURE?
		JNC $$IF101
		    CALL    PARSE_SECOND_PARM
;		$ENDIF
$$IF101:

		TEST	PARM_FLAG, INIT_ERROR_FLAG ;no error so far?
;		$IF	Z		;no error
		JNZ $$IF103
		    MOV     DL, T_DRV_NUMBER
		    LEA     SI, T_PATH
		    CALL    GET_CUR_DIR ;save target starting dir
		    CMP     TEMP_T_FILENAME, 0 ;any non_global target file name entered?
;		    $IF     NE		;yes
		    JE $$IF104
			MOV	CX, 13	;maximum 13 char.
			LEA	SI, TEMP_T_FILENAME
			LEA	DI, T_FILENAME ;then move it to T_FILENAME while convert it to capital letter.
			CALL	MOV_STRING ;AC000; SI => DI
;		    $ENDIF
$$IF104:
;		$ENDIF			;end - no error so far
$$IF103:
;	    $ENDIF			;end - second parm not entered
$$EN99:
;	$ENDIF
$$IF96:

	TEST	PARM_FLAG, INIT_ERROR_FLAG
;	$IF	Z			;no error
	JNZ $$IF109
	    CALL    CHK_CYCLIC_COPY	;check source, target parms
	    TEST    PARM_FLAG, INIT_ERROR_FLAG ;cyclic copy?
;	    $IF     Z,AND		;no
	    JNZ $$IF110
	    TEST    SYS_FLAG, ONE_DISK_COPY_FLAG ;if one disk drv letter copy
;	    $IF     NZ			;then set the starting dir
	    JZ $$IF110
		LEA	DX, S_DRV_PATH	;to that of source.
		MOV	AH, Chdir	; = 3Bh
		INT	21H		;should succeed since alreay tested.
;	    $ENDIF
$$IF110:
;	$ENDIF
$$IF109:

	RET
CHK_SET_PARMS ENDP
;
PARSE_SECOND_PARM PROC NEAR
;called after the initial chdir to T_INPUT_PARM failed.  Remember the second parm should
;exist when you call this routine.
;INPUT: DS, ES - data seg
;OUTPUT:if error, init_error_flag will be set.
;
	LEA	SI, T_INPUT_PARM
	CALL	CHK_HEAD_PARM		;check the head part of parm. SI will points
					;to the next chr after the header.
	TEST	PARM_FLAG, INIT_ERROR_FLAG
	JNZ	PSP_EXIT		;YES, ERROR.
	CALL	NEXT_PATH_DELIM 	;Let SI points to the next path delim "\" or 0
	LEA	DX, T_INPUT_PARM
	CALL	PARSING_T_PATH		;chdir for every directory starting from the
					;first. If it fails, then create a directory
					;and chdir to it.
PSP_EXIT:
	RET
PARSE_SECOND_PARM ENDP
;
NEXT_PATH_DELIM PROC NEAR
;starting from SI, check every chr until it is '\' or 0 or ':'.
;if the starting chr is '\' or 0 or ':', then SI won't change.
;the caller should be sure that it is an ASCIIZ string.
;INPUT: DS, ES - data seg
;	SI - starting point
;OUTPUT:
;	SI - next path delimeter

	CLD
	PUSH	DI
	PUSH	SI
	POP	DI			;NOW DI POINTS TO THE STARTING CHR
NPD_LOOP:
;	$DO				;AN010;
$$DO113:
	    CLC 			;AN010;INITIALIZE TO NOT DBCS
	    MOV     AL,BYTE PTR [DI]	;AN010;GET THE 1st CHAR TO TEST
	    CALL    CHK_DBCS		;AN010;SEE IF WE ARE IN DBCS
;	$LEAVE	NC			;AN010;THIS IS NOT DBCS
	JNC $$EN113
	    INC     DI			;AN010;GO TO THE NEXT CHAR TO CHECK
	    INC     DI			;AN010;DITO
;	$ENDDO				;AN010;
	JMP SHORT $$DO113
$$EN113:
	MOV	AL, 0
	SCASB				;0 - ES:[DI], DI=DI+1
	JZ	NPD_FOUND
	DEC	DI			;check it again if it is '\'
	MOV	AL, '\'
	SCASB

ifdef DBCS
	jnz	@f			; if not found
	push	bx
	mov	bx,di
	dec	bx
	call	CheckDBCSTailByte
	pop	bx
	jnz	NPD_FOUND		; if last '\' is not tail byte
@@:
else
	JZ	NPD_FOUND
endif

	DEC	DI
	MOV	AL, ':' 		;is it a filename terminator not filter before?
	SCASB
	JZ	NPD_FOUND
	JMP	SHORT NPD_LOOP
NPD_FOUND:
	DEC	DI			;adjust DI to the chr found
	PUSH	DI
	POP	SI			;now SI points to the chr
	POP	DI			;restore DI
	RET
NEXT_PATH_DELIM ENDP
;

CHK_HEAD_PARM PROC NEAR
;check the starting header part of parameter pointed by SI to eliminate
;error such as A:\\..., A:\.., \\, \.. etc.
;This routine will change the current target directory to the root
;when "d:\" or "\" has been found.
;The parameter string should be ASCIIZ and should exist.
;INPUT: DS, ES - DATA SEG
;	SI - POINTS TO THE PARAMETER
;OUTPUT:SI POINTS TO THE NEXT VALID PATH
;	DX WILL POINTS TO THE ERROR MESSAGE

	CALL	CHK_DRV_LETTER		;si points to the next chr after drv letter, if found.
	CMP	BYTE PTR [SI], 0	;"A:0" case
;	$IF	E
	JNE $$IF116
	    MOV     BYTE PTR [SI], '.'
	    INC     SI
	    MOV     BYTE PTR [SI], 0	;make it "A:.0"
;	$ELSE
	JMP SHORT $$EN116
$$IF116:
	    CMP     BYTE PTR [SI], '\'
;	    $IF     E			;A:\--- or \--- cases
	    JNE $$IF118
		INC	SI
		CLC			;AN010;INITIALIZE TO NOT DBCS
		MOV	AL,DS:BYTE PTR [SI] ;AN010;GET THE 1st CHAR TO TEST
		CALL	CHK_DBCS	;AN010;SEE IF WE ARE IN DBCS
;		$IF	NC		;AN010;THIS IS NOT DBCS
		JC $$IF119
		    CMP     BYTE PTR [SI], '\'
;		    $IF     E		;A:\\--- or \\--- cases ; ERROR
		    JNE $$IF120
			MOV	DX, MSG_INVALID_PATH ;AC000;GET THE MESSAGE ID
			OR	PARM_FLAG, INIT_ERROR_FLAG
;		    $ELSE
		    JMP SHORT $$EN120
$$IF120:
			CMP	BYTE PTR [SI], '.'
;			$IF	E	;A:\.--- or \.--- cases
			JNE $$IF122
			    INC     SI
			    MOV     AL,DS:BYTE PTR [SI] ;AN010;GET 1st CHAR
					;      TO TEST
			    CALL    CHK_DBCS ;AN010;SEE IF WE ARE IN
					;      DBCS
;			    $IF     NC	;AN010;THIS IS NOT DBCS
			    JC $$IF123
				CMP	BYTE PTR [SI], '.'
;				$IF	E,OR
				JE $$LL124
				CMP	BYTE PTR [SI], '\'
;				$IF	NE ;if not A:\.\--- or \.\--- cases
				JE $$IF124
$$LL124:
				    MOV     DX, MSG_INVALID_PATH ;AC000;MSG ID
				    OR	    PARM_FLAG, INIT_ERROR_FLAG
;				$ENDIF
$$IF124:
;			    $ENDIF	;AN010;END OF DBCS TEST
$$IF123:
			    CLC 	;AN010;
;			$ENDIF
$$IF122:
;		    $ENDIF
$$EN120:
                    PUSH    DX          ;Preserve DX around CHDIR         ;C03
		    LEA     DX, T_DRV
		    MOV     AH, Chdir
		    INT     21h 	;"Chdir to root" is no problem.
                    POP     DX                                            ;C03
;		$ENDIF			;AN010;DBCS TEST END
$$IF119:
		CLC			;AN010;
;	    $ENDIF
$$IF118:
;	$ENDIF
$$EN116:
	RET
CHK_HEAD_PARM ENDP
;
PARSING_T_PATH PROC NEAR
;chdir to every path element from the first. If fails, create the directory and
;try to chdir again.  T_MKDIR_LVL will increase when new starting directory is created
;INPUT: DX - OFFSET OF T_INPUT_PARM
;	SI - points to '\' or 0, or ':'
;OUTPUT: directories are created if necessary.
;	 DX points to the last path entry
;	 if fails to create a directory, then INIT_ERROR_FLAG set and
;	 DX points to MSG_NOT_CREATE_DIR msg.

	PUSH	DX			;save DX
	MOV	DL, T_DRV_NUMBER
	DEC	DL
	CALL	SET_DEFAULT_DRV 	;set target drive as a default
	POP	DX			;restore DX
PTP_NEXT:
	CMP	BYTE PTR [SI], 0	;end of string? the last path element?
	JE	PTP_LAST
	CMP	BYTE PTR [SI], ':'	;filename terminator not checked before?
	JNE	PTP_CHDIR		;else it is '\'.
	MOV	BYTE PTR [SI], 0	;change ':' to 0 for termination.
PTP_LAST:
	CALL	LAST_T_PATH
	JMP	SHORT PTP_EXIT
PTP_CHDIR:
	MOV	BYTE PTR [SI], 0	;replace '\' with 0
	MOV	AH, Chdir		;=38h
	INT	21h
	JC	PTP_MKDIR
	MOV	BYTE PTR [SI], '\'	;restore '\'
	INC	SI			;SI points to next to old '\'
	MOV	DX, SI			;DX points to next path entry
	CALL	NEXT_PATH_DELIM
	JMP	PTP_NEXT		;handles next path element
PTP_MKDIR:
	MOV	AH, Mkdir		;=39h
	INT	21h
	JC	PTP_ERROR		;cannot make directory
	INC	T_MKDIR_LVL		;# of MKDIR for the starting directory.
	JMP	PTP_CHDIR		;try again to chdir
PTP_ERROR:
	MOV	DX, MSG_NOT_CREATE_DIR	;AC000;GET THE MESSAGE ID
	OR	PARM_FLAG, INIT_ERROR_FLAG ;critical error
PTP_EXIT:
	RET

PARSING_T_PATH ENDP
;
LAST_T_PATH PROC NEAR
;called when the second parm reached last. *** this routine is the same as the old routine ***
;and the initial try to chdir to the given T_INPUT_PARM has been failed.
;INPUT: ES, DS - data seg
;	DX - points to the last path entry
;OUTPUT:target starting directory.

	MOV	AH, Chdir		;try to chdir to the last path entry
	INT	21h
;	$IF	C,LONG			;if fail.
	JC $$XL3
	JMP SHORT $$IF132
$$XL3:

	    LEA     BX, T_INPUT_PARM
	    LEA     DX, TEMP_T_FILENAME ;take the last path element into TEMP_T_FILENAME
	    CALL    TAKE_PATH_TAIL
	    CMP     TEMP_T_FILENAME, 0	;any filename candidate entered?
;	    $IF     NE,LONG		;yes. let's check it has any global chr.
	    JNE $$XL4
	    JMP SHORT $$IF133
$$XL4:
		PUSH	ES
		MOV	AH, 29h
		LEA	SI, TEMP_T_FILENAME
		MOV	ES, PSP_SEG	;ES - psp seg
		MOV	DI, PSPFCB2_DRV ;use this area for this test purposes
		MOV	AL, 0		;control bit
		INT	21h
		POP	ES
		CMP	AL, 0		;no global filename entered?
;		$IF	E		;yes, no globals
		JNE $$IF134
		    CALL    PROMPT_CREATE_DIR ;then ask the user, it is a filename or subdir name?
		    MOV     DX,USER_INPUT ;AN000;SET UP FOR COMPAIR
		    CMP     DX, alpha_dir ;directory?
;		    $IF     E		;yes, a subdir name.
		    JNE $$IF135
			LEA	DX, TEMP_T_FILENAME
			MOV	AH, Mkdir ;=39h
			INT	21h	;create a new subdir
;			$IF	NC
			JC $$IF136
			    INC     T_MKDIR_LVL ;one more directory has been made.
			    MOV     AH, Chdir
			    INT     21h ;Chdir to a new dir. This time it should be a success.
			    MOV     TEMP_T_FILENAME, 0 ;mark temp_t_filename that it is empty
;			$ELSE		;ERROR IN CREATING DIRECTORY
			JMP SHORT $$EN136
$$IF136:
			    MOV     DX, MSG_NOT_CREATE_DIR ;AC000;GET THE MESSAGE ID
			    OR	    PARM_FLAG, INIT_ERROR_FLAG
;			$ENDIF
$$EN136:
;		    $ELSE		;USER ANSWERED IT A FILENAME
		    JMP SHORT $$EN135
$$IF135:
			OR	PARM1_FLAG, T_FILE_FLAG ;set target file entered.
;		    $ENDIF		;use TEMP_T_FILENAME as a filename
$$EN135:
;		$ELSE			;GLOBALS IN THE FILENAME
		JMP SHORT $$EN134
$$IF134:
		    MOV     TEMP_T_FILENAME, 0 ;mark it to 0 since we don;t need this.
		    CALL    MAKE_TEMPLATE ;make a template of the target filename
		    OR	    PARM1_FLAG, T_FILE_FLAG ;set target file entered flag
;		$ENDIF			;GLOBAL TEST
$$EN134:
;	    $ENDIF			;NO, FILENAME NOT ENTERED. TEMP_T_FILENAME = 0
$$IF133:
;	$ENDIF				;CHDIR FAIL
$$IF132:
	RET
LAST_T_PATH ENDP
;
;
CHK_S_RESERVED_NAME PROC NEAR
;check the source filename entered, and if it does not have any global chr,
;then check it whether it is reserved filename or not.
;input: es,ds - data seg

	mov	ax, 3d00h		;let's try to open it
	lea	dx, s_drv_1		;'A:S_FILE'
	int	21h
	jc	csrn_exit		;open failure? jmp to exit
	mov	bx, ax			;else ax has file handle
	mov	ax, 4400h		;get device info.
	int	21h			;ioctl fun call
	test	dx, 80h 		;ISDEV ?
	jz	csrn_close		;no, block device. close handle and exit
	PUSH	AX			;AN000;
	MOV	AX, msg_res_s_name	;AC000;reserved file name as a source"
	MOV	MSG_NUM,AX		;AN000;NEED MESSAGE ID FOR PRINT
	MOV	SUBST_COUNT,NO_SUBST	;AN000;NO SUBSTITUTION TEXT
	MOV	INPUT_FLAG,NO_INPUT	;AN000;NO INPUT = 0
	MOV	MSG_CLASS,UTILITY_MSG_CLASS ;AN000;MESSAGE CLASS = -1
	CALL	PRINT_STDERR		;AN000;print error. AX points to msg ID
	POP	AX			;AN000;
	mov	errorlevel, 4		;abnormal termination
	or	parm_flag, init_error_flag ;set init_error_flag
	jmp	main_exit
csrn_close:
	mov	ah, 3eh 		;close filehandle in bx
	int	21h
csrn_exit:
	ret
CHK_S_RESERVED_NAME ENDP
;
PROMPT_CREATE_DIR PROC NEAR
;DS, ES - data seg
	PUSH	AX			;AN000;
	mov	cx, 13
	lea	si, temp_t_filename
	lea	di, filename_for_prompt
	call	mov_STRING		;AC000;

;CALL GET MESSAGE TO DETERMINE WHAT THIS COUNTRY INPUT FOR 'F' OR 'D' IS.

	PUSH	DS			;AN000;
	ASSUME	DS:NOTHING		;AN000;TELL THE ASSEMBLER
	MOV	AX,MSG_F_D		;AN000;MESSAGE NUMBER = 29 = 'F D '
	MOV	DH,UTILITY_MSG_CLASS	;AN000;MESSAGE DEFINED FOR XCPYINIT
	CALL	SYSGETMSG		;AN000;GET THE MESSAGE
	LODSW				;AN000;'F'PART OF MSG (DS:SI => AX)
	CMP	AH,SPACE		;AN000;NOT 'SPACE' THEN IT IS DBCS !
;	$IF	E			;AN000;IGNORE THE NEXT WORD
	JNE $$IF145
	    MOV     AH,NUL		;AN000;THE END OF THE STRING
;	$ENDIF				;AN000;NOW GET TRANSLATION OF 'D'
$$IF145:
	MOV	ES:ALPHA_FILE,AX	;AN000;TRANSLATED CHAR FOR 'F' TO BUFF
	LODSW				;AN000;'D'PART OF MSG (DS:SI => AX)
	CMP	AH,SPACE		;AN000;NOT 'SPACE' THEN IT IS DBCS !
;	$IF	E			;AN000;IGNORE THE NEXT WORD
	JNE $$IF147
	    MOV     AH,NUL		;AN000;REMOVE SPACE CHARACTER
;	$ENDIF				;AN000;NOW GET TRANSLATION OF 'D'
$$IF147:
	MOV	ES:ALPHA_DIR,AX 	;AN000;TRANSLATED CHAR FOR 'D' TO BUFF
	POP	DS			;AN000;RESTORE AFTER CALL TO MSG HANDLR
	ASSUME	DS:DGROUP		;AN000;TELL THE ASSEMBLER
					;remember this may be DBCS
PCD_AGAIN:
; Set message substitution list
	LEA	SI,SUBLIST1		;AN000; get addressability to sublist
	LEA	DX,FILENAME_FOR_PROMPT	;AN000; offset to file name
	MOV	[SI].DATA_OFF,DX	;AN000; save data offset
	MOV	[SI].DATA_SEG,DS	;AN000; save data segment
	MOV	[SI].MSG_ID,1		;AN000; message ID
	MOV	[SI].FLAGS,010H 	;AN000; ASCIIZ string, left align
	MOV	[SI].MAX_WIDTH,0	;AN000; MAXIMUM FIELD WITH
	MOV	[SI].MIN_WIDTH,0	;AN000; MINIMUM FIELD WITH

	MOV	AX,MSG_CREATE_DIR	;AN000;ID OF MESSAGE TO BE DISPLAYED
	MOV	MSG_NUM,AX		;AN000;SET THE MESSAGE NUMBER
	MOV	SUBST_COUNT,PARM_SUBST_ONE ;AN000;PARM SUBSTITUTION COUNT=1
	MOV	MSG_CLASS,UTILITY_MSG_CLASS ;AN000;MESSAGE CLASS = -1
	MOV	INPUT_FLAG,KEYBOARD_INPUT ;AN000;KEYBOARD INPUT EXPECTED FUNCTION
	CALL	PRINT_STDOUT		;show prompt and get user input

	MOV	USER_INPUT,AX		;AN000;RESPONSE BUFF FOR CAPITALIZATION

	MOV	AX,MSG_CR_LF_STR	;AN000; JUST CR,LF
	MOV	MSG_NUM,AX		;AN000; set message number
	MOV	SUBST_COUNT,NO_SUBST	;AN000;NO PARAMETER SUBSTITUTION
	MOV	INPUT_FLAG,NO_INPUT	;AN000; NO INPUT
	CALL	PRINT_STDOUT		;AN000; Display message

	MOV	AX,UPPER_CASE_STRING	;AN000;AX = 6521H GET EXT CTRY INFO
	LEA	DX,USER_INPUT		;AN000;RESPONSE BUFF FOR CAPITALIZATION
	MOV	CX,2			;AN000;TWO CHARACTERS, ONE WORD
	INT	21H			;AN000;ISSUE INT TO CAP STRING (DBCS?)
	MOV	AX,USER_INPUT		;AN000;SO I CAN DO THE COMPARE
	CMP	AX,ALPHA_FILE		;AN000;KEYBOARD INPUT AX = 'F' ?
	JE	PCD_EXIT
	CMP	AX,ALPHA_DIR		;AN000;KEYBOARD INPUT AX = 'D' ?
	JE	PCD_EXIT
	JMP	SHORT  PCD_AGAIN
PCD_EXIT:

	POP	AX			;AN000;
	RET
PROMPT_CREATE_DIR ENDP
;
TAKE_PATH_TAIL PROC NEAR
;check the tail of the source input parm.
;Call LAST_DIR_OUT
;If carry set
;	then check the drive letter
;	     if entered, then save the rest of the string after drv: into
;	     a tempory filename holder, and put "." after the drive letter
;	     (For ex, if the input had been 'A:name1',0 then no change after
;	      LAST_DIR_OUT.  This has to be changed to 'A:.',0 and name1.)
;	else save the last dir into a filename, and
;	     check the result path
;	     if it is a drive only, then put "\" ( For ex, if the input
;	     had been 'A:\name1',0 then after LAST_DIR_OUT, it will be changed
;	     to 'A:',0 and 'name1',0.  In this case, we have to change the
;	     path to A:\)
;	     else OK.
;INPUT: DS - data seg
;	ES - data seg
;	BX - offset value of S_INPUT_PARM or T_INPUT_PARM
;	DX - offset value of TEMP_S_FILENAME or TEMP_T_FILENAME


	MOV	DI, BX			;offset of S(T)_INPUT_PARM
	CALL	LAST_DIR_OUT
;	$IF	C			;Not found a "\"
	JNC $$IF149
	    MOV     SI, DI		;set si = di
	    CALL    CHK_DRV_LETTER	;if drv letter:, then SI will
					;point to next chr. Otherwise no change
	    cmp     byte ptr [si], 0	;only drv letter has entered. No filename
;	    $IF     NE			;filename entered
	    JE $$IF150
		push	si		;save si
		MOV	CX, 13		;max # of filename in ASCIIZ
		MOV	DI, DX
		REP	MOVSB		;save it to temporay name holder
		pop	si		;restore si
;	    $ENDIF
$$IF150:
	    mov     byte ptr [si], A_dot ;to be used for Chdir fun call
	    mov     byte ptr [si+1], 0	;make it ASCIIZ
;	$ELSE				;at least found a "\"
	JMP SHORT $$EN149
$$IF149:
	    mov     cx, 13		;let's save tail into filename holder first
	    mov     si, ax		;AX is an offset value of the tail
	    mov     di, DX		;TEMP_FILENAME
	    rep     movsb
	    mov     si, BX		;return to the Revised input
	    CALL    CHK_DRV_LETTER	;it starts with drv letter?
	    cmp     byte ptr [si], 0	;si points to the end of string?
;	    $IF     E
	    JNE $$IF153
		MOV	byte ptr [SI], '\' ;then add '\' in the Revised S_INPUT_PARM
		MOV	byte ptr [SI+1], 0
;	    $ENDIF
$$IF153:
;	$ENDIF
$$EN149:
	RET

TAKE_PATH_TAIL ENDP
;
CHK_CYCLIC_COPY PROC NEAR
;With the one_disk_copy case, if the starting source path is a member of
;parent directory of the starting target path, then infinite copy cycle
;can occur.  This routine prevents that situation.
;ES: data seg
;DS: data seg

	PUSH	DS
	POP	ES			;set ES to DS (ES = DS)
	CALL	TRANS_NAMES		;AN016;CHK ASSIGN, JOIN & SUBST CONDITN
	TEST	SYS_FLAG, ONE_DISK_COPY_FLAG ;source, target drv let same
;	$IF	NZ			;if they are, then check below facts
	JZ $$IF156
	    MOV     DI, OFFSET DGROUP:T_TRANS_PATH ;AC025;
	    MOV     AL, 0
	    CALL    STRING_LENGTH
	    MOV     DX, CX		;save the length of S_PATH
	    MOV     DI, OFFSET DGROUP:S_TRANS_PATH ;AC025;
	    CALL    STRING_LENGTH
	    CMP     DX,CX		;compare the length
;	    $IF     AE			;if target length >= source length
	    JNAE $$IF157
		MOV	SI, OFFSET DGROUP:S_TRANS_PATH ;AC025;
		MOV	DI, OFFSET DGROUP:T_TRANS_PATH ;AC025;
		DEC	CX		;get the actual length of chr's
		DEC	DX
		CLD
;		$SEARCH 		;current CX = source length
$$DO158:
		    CMP     CX, 0
;		$EXITIF E		;exit if cx = 0
		JNE $$IF158
		    CMP     DX, 0	;target length = 0 too?
;		    $IF     E		;yes, source = target
		    JNE $$IF160
			TEST	OPTION_FLAG, SLASH_S ; tree copy?
;			$IF	NZ,OR	;yes
			JNZ $$LL161
			TEST	OPTION_FLAG, SLASH_E
;			$IF	NZ
			JZ $$IF161
$$LL161:
			    MOV     DX, MSG_CYCLIC_COPY ;AC000;GET THE MESSAGE ID
			    OR	    PARM_FLAG, INIT_ERROR_FLAG ;critical error
;			$ELSE		;same length, but not a tree copy.
			JMP SHORT $$EN161
$$IF161:
			    OR	    COPY_STATUS, MAYBE_ITSELF_FLAG ;possibly, copy onto itself.
;			$ENDIF		;cannot fully determine this time until file creation time
$$EN161:
;		    $ELSE		;target > source
		    JMP SHORT $$EN160
$$IF160:
			TEST	OPTION_FLAG, SLASH_S ;tree copy?
;			$IF	NZ,OR
			JNZ $$LL165
			TEST	OPTION_FLAG, SLASH_E
;			$IF	NZ
			JZ $$IF165
$$LL165:
			    CMP     BYTE PTR [DI], '\' ;source = d:\abc, target = d:\abc\def case
;			    $IF     E,OR
			    JE $$LL166
			    CMP     BYTE PTR [DI-1], '\' ;source = d:\, target=d:\abc case
;			    $IF     E
			    JNE $$IF166
$$LL166:
				MOV	DX, MSG_CYCLIC_COPY ;AC000;GET THE MESSAGE ID
				OR	PARM_FLAG, INIT_ERROR_FLAG ; critical error
;			    $ENDIF
$$IF166:
;			$ENDIF
$$IF165:
;		    $ENDIF
$$EN160:
;		$ORELSE
		JMP SHORT $$SR158
$$IF158:
		    LODSB		;[SI] => AL, SI = SI + 1
		    SCASB		;AL vs. [DI], DI = DI + 1
;		$LEAVE	NE		;leave if not same
		JNE $$EN158
		    DEC     CX
		    DEC     DX		;decrease target length, too
;		$ENDLOOP
		JMP SHORT $$DO158
$$EN158:
;		$ENDSRCH
$$SR158:
;	    $ENDIF
$$IF157:
;	$ENDIF
$$IF156:
	RET

CHK_CYCLIC_COPY ENDP
;
TRANS_NAMES PROC NEAR
;TRANSLATE THE INPUT TARGET AND SOURCE PATH TO DETERMINE
;IF ASSIGN, JOIN OR SUBSD WAS USET TO MODIFY HIDE THE TRUE
;PATH. THIS INFO. WILL BE USED TO DETERMINE CYCLIC COPY.
;INPUT: T_DRV_PATH, S_DRV_PATH

	PUSH	SI			;AN016;SI WILL BE DESTROYED
	PUSH	DI			;AN016;DI WILL BE DESTROYED

	MOV	SI,OFFSET DGROUP:T_DRV_PATH    ;AN016;DO NAME TRANSLATE OF TAR
	MOV	DI,OFFSET DGROUP:T_TRANS_PATH  ;AN025;SAVE FOR COMPARE
	MOV	AH,60h			;AN016;NAMETRANSLATE
	INT	21h			;AN016;EXECUTE

        MOV     DI,OFFSET DGROUP:T_TRANS_PATH  ;SAVE FOR COMPARE          ;C04
        JNC     T_TRANSLATED                                              ;C04
        MOV     DI,OFFSET DGROUP:T_DRV_PATH  ;IF no trans. use original   ;C04
T_TRANSLATED:                                                             ;C04
        PUSH    DI                      ;Save Target path                 ;C04

	MOV	SI,OFFSET DGROUP:S_DRV_PATH    ;AN016;DO NAME TRANSLATE OF SRC
	MOV	DI,OFFSET DGROUP:S_TRANS_PATH  ;AN025;SAVE FOR COMPARE
	MOV	AH,60h			;AN016;NAMETRANSLATE
	INT	21h			;AN016;EXECUTE

        MOV     SI,OFFSET DGROUP:S_TRANS_PATH  ;SAVE FOR COMPARE          ;C04
        JNC     S_TRANSLATED                                              ;C04
        MOV     SI,OFFSET DGROUP:S_DRV_PATH  ;IF no trans. use original   ;C04
S_TRANSLATED:                                                             ;C04
        POP     DI                      ;Pop target path for compare      ;C04

;NOW COMPARE THE TRANSLATED NAMES

;	MOV	SI,OFFSET DGROUP:T_TRANS_PATH  ;AN025;GET THE TAR FOR COMPARE
;	MOV	DI,OFFSET DGROUP:S_TRANS_PATH  ;AN025;GET THE SRC FOR COMPARE

        CALL    CHK_SUBST               ;see if one drive xcopy and SUBST ;C05
        JC      NEXT_STAR_A             ;not same drive                   ;C05
           OR   SYS_FLAG, ONE_DISK_COPY_FLAG ;source, target drv let same ;C05
NEXT_STAR_A:                            ;here to continue                 ;C05
	CALL	STR_COMP		;AN016;DO THE COMPARE
;	$IF	Z			;AN016;STRING DID COMPARE
	JNZ $$IF176
	   OR	SYS_FLAG, ONE_DISK_COPY_FLAG ;AN016;source, target drv let same
;	$ENDIF				;AN016;
$$IF176:

	POP	DI			;AN016;restore DI
	POP	SI			;AN016;restore SI
	RET
TRANS_NAMES ENDP
;
STR_COMP PROC NEAR
;COMPARE ASCIIZ DS:SI WITH ES:DI
;DI,SI ARE DESTROYED

STRCOMP:
	CMPSB				;AN016;ONE BYTE AT A TIME
;	$IF NZ				;AN016;DID NOT COMPARE
	JZ $$IF178
	    RET 			;AN016;NZ = DIFFERENCE
;	$ENDIF				;AN016;
$$IF178:
	CMP	BYTE PTR [SI-1],NUL	;AN016;CHK FOR END OF THE STRING
;	$IF Z				;ANO16;IT IS E O S
	JNZ $$IF180
	    RET 			;AN016;IT COMPARED
;	$ENDIF				;AN016;
$$IF180:
	JMP	SHORT STRCOMP		;AN016;GO AGAIN
STR_COMP ENDP

MAKE_TEMPLATE PROC NEAR
;copy the formatted filename into the T_TEMPLATE which will be
;used to name a new filename.
;INPUT: PSP FCB 6ch for filename which have global chr.
;
	PUSH	DS			;ES = DS = DATA SEG

	MOV	DS, PSP_SEG		;DS = PSP_SEG

	MOV	SI, PSPFCB2_DRV
	INC	SI
	LEA	DI, T_TEMPLATE
	MOV	CX, 11
	REP	MOVSB			;filename => t_template

	POP	DS			;restore DS
	RET
MAKE_TEMPLATE ENDP

GET_DRIVES PROC NEAR
;get source and target phisical drive letter from parser area.
;set ONE_DISK_COPY_FLAG, if the user XCOPY using the same drive letter.

	MOV	AL, SO_DRIVE		;AN000;source drive letter
	CMP	AL,SPACE		;AN000;IS DRIVE LETTER BLANK?
;	$IF	E			;AN000;YES, GET THE DEFAULT
	JNE $$IF182
	    MOV     AL, SAV_DEFAULT_DRV ;(1=A, 2=B,...)
;	$ELSE				;AN000;NO, CHANGE FROM CHAR TO #
	JMP SHORT $$EN182
$$IF182:
	    SUB     AL,BASE_OF_ALPHA_DRV ;AN000;NEED THE DRV # HERE
;	$ENDIF
$$EN182:
	MOV	S_DRV_NUMBER, AL	;SAVE DRV #
	ADD	AL, BASE_OF_ALPHA_DRV
	MOV	S_DRV, AL		;save source drive letter
	MOV	S_DRV_1, AL
	MOV	S_ARC_DRV, AL
	MOV	SAV_S_DRV, AL

	MOV	AL, TAR_DRIVE		;AN000;target drive letter
	CMP	AL,SPACE		;AN000;IS DRIVE LETTER BLANK?
;	$IF	E			;AN000;YES, GET THE DEFAULT
	JNE $$IF185
	    MOV     AL, SAV_DEFAULT_DRV ;AN000;(1=A, 2=B,...)
;	$ELSE				;AN000;NO, CHANGE FROM CHAR TO #
	JMP SHORT $$EN185
$$IF185:
	    SUB     AL,BASE_OF_ALPHA_DRV ;AN000;NEED THE DRV # HERE
;	$ENDIF
$$EN185:
	MOV	T_DRV_NUMBER, AL	;save target drv #

	CMP	S_DRV_NUMBER, AL	;s_drv_number = t_drv_number?
;	$IF	E
	JNE $$IF188
	    OR	    SYS_FLAG, ONE_DISK_COPY_FLAG ;same logical drv copy
;	$ENDIF
$$IF188:

	ADD	AL, BASE_OF_ALPHA_DRV	;make target drv # to drive letter
	MOV	T_DRV, AL		;target drive letter
	MOV	T_DRV_1, AL
	MOV	T_DRV_2, AL
	MOV	SAV_T_DRV, AL
	RET
GET_DRIVES ENDP
;
;
GET_CUR_DRV PROC NEAR
;get the current default drive number (0 = A, 1 = B ..),
;change it to BIOS drive number and save it.
	MOV	AH, Current_Disk	; = 19h
	INT	21h
	INC	AL			;(1 = A, 2 = B ..)
	MOV	SAV_DEFAULT_DRV, AL	;save it
	RET
GET_CUR_DRV ENDP
;
GET_CUR_DIR PROC NEAR
;get current directory and save it
;input: DL - drive # (0 = default, 1 = A etc)
;	DS:SI - pointer to 64 byte user memory

	MOV	AH, Get_Current_Directory
	INT	21H
	RET
GET_CUR_DIR ENDP
;
TOP_OF_MEM PROC NEAR
;set Top_of_memory

	PUSH	ES
	MOV	BX, PSP_SEG
	MOV	ES, BX
	MOV	AX, ES:2		;PSP top of memory location
	SUB	AX, 140H		;subtract dos transient area (5k)
	MOV	TOP_OF_MEMORY, AX	;save it for buffer top
	POP	ES
	RET
TOP_OF_MEM ENDP

INIT_BUFFER PROC NEAR
;initialize buffer information
;set buffer_base, max_buffer_size
;	call	set_block		;SET BLOCK FOR BUFFR (for new 3.2 linker)
	MOV	AX, OFFSET INIT
	PUSH	CS			;cs segment is the highest segment in this program
	POP	DX
	MOV	BUFFER_PTR, DX
	CALL	SET_BUFFER_PTR
	MOV	AX, BUFFER_PTR
	MOV	BUFFER_BASE, AX 	;set buffer_base
	MOV	AX, BUFFER_LEFT
	CMP	AX, 140h		;BUFFER_LEFT < 5K which is the minimum size this program supports?
	JAE	IB_CONT
	PUSH	AX			;AN000;
	MOV	AX, MSG_INSUF_MEMORY	;AC000;GET THE MESSAGE ID
	MOV	MSG_NUM,AX		;AN000;NEED MESSAGE ID FOR PRINT
	MOV	SUBST_COUNT,NO_SUBST	;AN000;NO SUBSTITUTION TEXT
	MOV	INPUT_FLAG,NO_INPUT	;AN000;NO INPUT = 0
	MOV	MSG_CLASS,UTILITY_MSG_CLASS ;AN000;MESSAGE CLASS = -1
	CALL	PRINT_STDERR		;AN000;print error. AX points to msg ID
	POP	AX			;AN000;
	MOV	ERRORLEVEL, 4		;abnormal termination
	JMP	MAIN_EXIT_A		;terminate this program
IB_CONT:
	MOV	MAX_BUFFER_SIZE, AX	;set max buffer size in para
	CMP	AX, 0FFFh		;max_buffer_size > 64 K in para ?
;	$IF	B
	JNB $$IF190
	    MOV     CX, 16
	    MUL     CX			;AX = AX * 16 (DX part will be 0)
	    SUB     AX, 544		;AN000;subtract header size
	    MOV     MAX_CX, AX		;this will be max_cx
;	$ELSE
	JMP SHORT $$EN190
$$IF190:
	    MOV     MAX_CX, 0FFD0h	;else max_cx = fff0 - 32 bytes
					;which is the max # this program can support.
;	$ENDIF				;(min # this program support for buffer is 5 k
$$EN190:
					; which has been decided by BIG_FILE )
	RET
INIT_BUFFER ENDP
;
HOOK_CTRL_BREAK PROC NEAR
;
	PUSH	DS			;save DS
	PUSH	CS
	POP	DS			;ds = cs
	MOV	AX, 2523h
	MOV	DX, OFFSET CTRL_BREAK_EXIT
	INT	21H
	POP	DS			;restore ds
	RET
HOOK_CTRL_BREAK ENDP
;
SAV_HOOK_INT24 PROC NEAR
;sav the int_24 addr, and hooks it to my_int24
	PUSH	ES
	MOV	AH, 35h
	MOV	AL, 24h 		;get critical error handler addr
	INT	21h
	MOV	SAV_INT24_OFF, BX	;offset ip
	MOV	SAV_INT24_SEG, ES	;seg cs
	POP	ES
	PUSH	DS			;save DS
	PUSH	CS
	POP	DS			;ds = cs
	MOV	AH, 25h
	MOV	AL, 24h
	MOV	DX, OFFSET MY_INT24	;now DS:DX contains the addr.
	INT	21h			;hook it to my_int24 routine
	POP	DS			;restore ds
	RET
SAV_HOOK_INT24 ENDP

;***********************************************************************;C05
;  CHK_SUBST does nothing than see if the source and dest drives are the;C05
;            same physical drive.  On entry di and si point to the      ;C05
;            actual asciiz names of the source and path (not SUBSTed)   ;C05
;            On return, the CARRY FLAG is SET if they are different drv ;C05
;***********************************************************************;C05
CHK_SUBST       PROC    NEAR                                            ;C05
        PUSH    DI                                                      ;C05
        PUSH    SI                                                      ;C05
        CMPSB                           ;Q: First char (drv let.) same? ;C05
        JNZ NO_SAME                     ; N: go set carry               ;C05
        CMPSB                           ;Q: Second char (:) same?       ;C05
        JNZ NO_SAME                     ; N: go set carry               ;C05
YES_SAME:                               ; Y: clear carry                ;C05
        CLC                                                             ;C05
        JMP     SHORT SUBST_RET                                         ;C05
NO_SAME:                                                                ;C05
        STC                                                             ;C05
SUBST_RET:                                                              ;C05
        POP     SI                                                      ;C05
        POP     DI                                                      ;C05
        RET                                                             ;C05
CHK_SUBST       ENDP                                                    ;C05

ifdef DBCS
;
;	Check if the character position is at Tail Byte of DBCS
;
;	input:	ds:si = start address of the string
;		ds:bx = character position to check
;	output:	ZF = 1 if at Tail Byte
;
CheckDBCSTailByte	proc	near
	push	ax
	push	bx
	push	cx
	mov	cx,bx			; save character position
cdtb_check:
	cmp	bx,si
	jz	cdtb_next		; if at the top
	dec	bx			; go back
	mov	al,[bx]			; get character
	call	CHK_DBCS
	jc	cdtb_check		; if DBCS lead byte do next
	inc	bx			; adjust
cdtb_next:
	sub	cx,bx			; if the length is odd then
	xor	cl,1			; the character position is
	test	cl,1			; at the tail byte
	pop	cx
	pop	bx
	pop	ax
	ret
CheckDBCSTailByte	endp
endif


;
CSEG	ENDS
	END


=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\tree\treequ.inc ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

	IF1				;AN000;
            ;%out    COMPONENT=TREE, MODULE=TREEQU.INC...;AN000;
	ENDIF				;AN000;
;		  $SALUT (4,19,24,36)	;					;AN000;
;		    DOS FUNCTION CALLS, USING INT 21H

SELECT_DISK	  EQU  0EH	   ;AN000;SETS DEFAULT DRIVE
				   ; DL=DRIVE NUMBER (0=A,1=B)
				   ;OUTPUT: AL=NUMBER OF DRIVES (MIN 5) ???

CHDIR		  EQU  3BH	   ;AN000;CHANGE CURRENT DIRECTORY
				   ;DS:DX = POINTER TO ASCIIZ STRING

CURRDISK	  EQU  19H	   ;AN000;GET CURRENT DEFAULT DRIVE
				   ;OUTPUT: AL = CURRENT DRIVE
				   ;  0=A,1=B,ETC.

SET_DTA 	  EQU  1AH	   ;AN000;SET DISK TRANSFER ADDRESS
				   ; DS:DX = DISK TRANSFER ADDRESS

SET_VECTOR	  EQU  25H	   ;AN000;SET INTERRUPT VECTOR
				   ;DS:DX = VECTOR TO INT HANDLER
				   ;AL = INTERRUPT NUMBER

DOS_VERSION	  EQU  30H	   ;AN000;DETERMINE VERSION OF DOS
				   ;OUTPUT: AL=MAJOR, AH=MINOR VERSION NUMBER
				   ;	    BX AND CX SET TO ZER

GET_VECTOR	  EQU  35H	   ;AN000;GET INTERRUPT VECTOR
				   ;AL = INTRRUPT NUMBER
				   ;OUTPUT: ES:BX = CONTENTS OF VECTOR

WRITE		  EQU  40H	   ;AN000;WRITE TO A FILE OR DEVICE
				   ;BX = FILE HANDLE
				   ;DS:DX = ADDRESS OF DATA TO WRITE
				   ;CX = NUMBER OF BYTES TO WRITE

IOCTL		  EQU  44H	   ;AN001;I/O CONTROL FOR DEVICES
				   ;DS:DX = DATA OR BUFFER
				   ;CX = NUMBER OF BYTES TO READ OR WRITE
				   ;BX = FILE HANDLE, OR,
				   ;BL = DRIVE NUMBER (0=DEFAULT,1=A,...)
				   ;AL = FUNCTION VALUE
				   ;OUTPUT: AX=NO. BYTES TRANSFERRED
				   ; OR ERROR CODE IS CY SET

BLOCK_GENERIC	  EQU  0DH	   ;AN001;AL=SUBFUNCTION, FOR "IOCTL" ABOVE
				   ;BH=0, RES
				   ;BL=DRIVE NUM
				   ;CX=0843h=SET MEDIA ID
				   ;CX=0863h GET MEDIA ID			;AN001;
				   ;DS:DX=BUFFER (see A_MEDIA_ID_INFO STRUC)
				   ;CARRY SET ON ERROR (OLD STYLE BOOT RECORD)

GET_CUR_DIR	  EQU  47H	   ;AN000;GET CURRENT DIRECTORY
				   ;DS:SI = POINTER TO 64 BYTE USER AREA
				   ;DL = DRIVE NUM (0=DEF, 1=A, ETC)
				   ;OUTPUT: DS:SI POINTS TO FULL PATH NAME

RET_CD_EXIT	  EQU  4CH	   ;AN000;EXIT TO DOS, PASSING RETURN CODE
				   ;AL=RETURN CODE

FINDFIRST	  EQU  4EH	   ;AN000;FIND FIRST MATCHING FILE
				   ;DS:DX = POINT TO ASCIIZ OF FILENAME
				   ;CX = ATTRIBUTE USED IN SEARCH
				   ;OUTPUT: CURRENT DTA WILL HAVE:
				   ;   21 BYTES - RESERVED
				   ;   1  BYTE	- ATTRIBUTE
				   ;   2  BYTES - FILE'S TIME
				   ;   2  BYTES - FILE'S DATE
				   ;   2  BYTES - LOW WORD OF FILE SIZE
				   ;   2  BYTES - HIGH WORD OF FILE SIZE
				   ;   13 BYTES - NAME.EXT +0 OF FOUND FILE
ATTR_NORMAL	  EQU  00H	   ;AN000;NON-SYS, NON-HIDDEN, NON-LABEL FILES
ATTR_DIR	  EQU  10H	   ;AN000;DIRECTORY FILES ATTRIBUTE
ATTR_VOLID	  EQU  08H	   ;AN000;VOLUME LABEL

FINDNEXT	  EQU  4FH	   ;AN000;FIND NEXT MATCHING FILE
				   ;DTA = INFO LEFT FROM FIND FIRST/NEXT

EXTERROR	  EQU  59H	   ;AN000;EXTENDED ERROR
				   ;BX = 0 (LEVEL NUMBER)
				   ;OUTPUT: AX=EXTENDED ERROR, BH=ERROR CLASS
				   ;BL=SUGGESTED ACTION, CH=LOCUS
				   ;DX,SI,DI,ES,CL,DS DESTROYED

DBCS_ENV	  EQU  63H	   ;AN012;GET DBCS SUPPORT
GET_DBCS_ENV	  EQU  0	   ;AN012;SUBFUNCTION, GET POINTER TO DBCS VECTOR

GSET_MEDIA_ID	  EQU  69H	   ;AN010;GET or SET MEDIA ID
				   ;BL=DRIVE NUMBER (0=DEFAULT, 1=A,...)
				   ;BH=0 (RESERVED)
GET_ID		  EQU  0	   ;AN010;AL=0 GET MEDIA ID
SET_ID		  EQU  1	   ;AN010;AL=1 SET MEDIA ID
				   ;DS:DX=@BUFFER (SEE A_MEDIA_ID_INFO STRUC)
;		END OF INT 21H DOS FUNCTIONS

;		MULTIPLEXOR (INT 2FH) FUNCTIONS:				;AN000;
APPEND_CHECK	  EQU  0B700H	   ;AN006;SEE IF APPEND IS INSTALLED
				   ;OUTPUT-AL=0FFH IF INSTALLED
APPEND_VERSION	  EQU  0B702H	   ;AN006;ASK IF DOS VERSION OF APPEND
DOS_APPEND_VER	  EQU  -1	   ;AN006;OUTPUT-AX=-1 IF DOS VERSION OF APPEND

GET_APPEND	  EQU  0B706H	   ;AN000;READ /X STATUS OF APPEND WITH INT 2FH
				   ;OUTPUT-BX= (SEE "APPEND_FLAGS" FOR DEFINITION)

SET_APPEND	  EQU  0B707H	   ;AN000;SET /X TO APPEND WITH INT 2FH
				   ;INPUT-BX= (SEE "APPEND_FLAGS" FOR DEFINITION)

		  HEADER <LOCAL EQUATES>					;AN000;
;		LOCAL EQUATES

BACK_SLASH	  EQU  "\"         ;AN000;PATH DELIMITER
SLASH		  EQU  "/"         ;AN000;SWITCH INDICATOR
NOPATH		  EQU  1	   ;AN000;LENGTH OF EMPTY PATH, INCL NUL DELIMITER
ZERO		  EQU  0	   ;AN000;CLEARS REG, COMPARAND FOR ZERO VALUE
DEFDRIVE	  EQU  0	   ;AN000;IN GET_CUR_DIR, DL=0 MEANS DOS DEFAULT DR
DRIVEA		  EQU  "A"         ;AN000;CORRESPONDS TO DRIVE 00H NUMERICALLY
PERIOD		  EQU  "."         ;AN000;FILENAME EXTENSION DELIMITER
BLANK		  EQU  " "         ;AN000;SPACE CHAR
FULL_SEG_SIZE	  EQU  -1	   ;AN000;SCAN COUNT TO LOOK THRU ENTIRE SEG
VEC_CTLBREAK	  EQU  23H	   ;AN000;NUMBER OF THE VECTOR POINTING TO CTL-BREAK
VEC_CRITERR	  EQU  24H	   ;AN000;NUM. OF VECTOR OF CRITICAL ERROR HANDLER
MIN_STACK	  EQU  512	   ;AN000;MINIMUM REQUIRED STACK SIZE
MAX_PATH	  EQU  64	   ;AN000;MAX LENGTH PERMITTED FOR ANY PATH
		  PUBLIC MAX_PATH  ;AN000;LET THE OTHERS IN ON THIS
LEVEL_LIMIT	  EQU  MAX_PATH/2  ;AN000;MAX PATH IS 64 CHAR;
				   ; REQUIRES MIN OF 2 CHAR PER PATH
DASH_NUM	  EQU  3	   ;AN000;NUMBER OF DASHES BETWEEN ELBO AND
				   ; SUBDIRECTORY NAME
FN_SIZE 	  EQU  12	   ;AN000;NUMBER CHARS IN FILENAME,PERIOD,EXTENSION
FLN_INDENT	  EQU  0	   ;AN000;NUMBER OF BLANKS TO INDENT FILENAME
				   ; UNDER SUBDIRECTORY AFTER THE "DASH_NUM"
NIBBLE		  EQU  4	   ;AN000;NUMBER BITS IN HALF A BYTE
LEVEL_0 	  EQU  0	   ;AN000;FOR EXTENDED ERROR
ABORT		  EQU  2	   ;AN000;"ABORT" FROM CRITICAL ERROR HANDLER

;		EXTENDED ERROR NUMBERS
NO_MORE_FILES	  EQU  18	   ;AN000;"NO MORE FILES"
INSUF_MEM	  EQU  8	   ;AN000;"INSUFFICIENT MEMORY"
INVDRSPEC	  EQU  15	   ;AN000;"INVALID DRIVE SPECIFICATION"
; =  =	=  =  =  =  =  =  =  =	=  =
;		SYSTEM MESSAGE HANDLER
GRAPHIC_MSGNUM	  EQU  7	   ;AN002;NUMBER OF MESSAGE DEFINING GRAPHIC CHARS

;		SUBSET OF "SYSMSG.INC":
MSG_SER_CLASS	  EQU  0	   ;AN000;MSG CLASS FOR MESSAGE HANDLER MSGS
EXT_ERR_CLASS	  EQU  1	   ;AN000;MSG CLASS FOR EXTENDED ERROR MSGS
PARSE_ERR_CLASS   EQU  2	   ;AN000;MSG CLASS FOR PARSE ERROR MSGS
UTILITY_MSG_CLASS EQU  0FFH	   ;AN000;MSG CLASS FOR UTILTITY DEFINED MSGS

;	     PRE-ASSIGNED FILE HANDLES:
STDIN		  EQU  0	   ;AN000;STANDARD INPUT
STDOUT		  EQU  1	   ;AN000;STANDARD OUTPUT
STDERR		  EQU  2	   ;AN000;STANDART ERROR

NUL		  EQU  0	   ;AN000;DELIMITER TO ANY ASCIIZ STRING
CR		  EQU  0DH	   ;AN000;CARRIAGE RETURN
LF		  EQU  0AH	   ;AN000;LINE FEED
; =  =	=  =  =  =  =  =  =  =	=  =
;		ERRORLEVEL RETURN CODES, PASSED BACK TO DOS ON EXIT
EXOK		  EQU  0	   ;AN000;NORMAL COMPLETION
EXERR		  EQU  1	   ;AN000;I/O ERROR,
				   ; LOAD MESSAGE FAILURE
				   ; BAD PARMS:
				   ; INVALID DRIVE
				   ; INVALID PATH
EXABORT 	  EQU  1	   ;AN000;CRITICAL ERROR HANDLER ABORTED
EXVER		  EQU  2	   ;AN000;BAD DOS VERSION
EXCTL		  EQU  3	   ;AN000;CONTROL BREAK

; =  =	=  =  =  =  =  =  =  =	=  =
		  HEADER <STRUC OF CONTROL BLOCKS>				;AN000;
;		CONTROL BLOCKS


DTA_Length     equ 43


FRAME		  STRUC 	   ;AN000;DYNAMIC VARIABLES ALLOCATED TO THE STACK

Fram_Next_DTA    db DTA_Length     dup(?)

FRAM_CHAR	  DB   ?	   ;AN000;CONTAINS ONE OF THESE:
;      "GRAF_ELBO"  - THIS IS THE LAST SUBDIRECTORY
;      "GRAF_TEE"   - THERE IS ANOTHER SUBDIRECTORY AFTER THIS ONE
;      "GRAF_BLANK" - NO MORE SUBDIRECTORIES

Fram_Flags       db   ?

FRAM_CURR_PATH	  DB   MAX_PATH+2 DUP(?) ;AN000;CURRENT PATH TO THIS LEVEL OF SUBDIR

FRAM_BP 	        DW   ?	   ;AN000;SAVES CALLER'S BP REG
FRAM_RET	        DW   ?	   ;AN000;RETURN ADDRESS

FRAME ENDS


WA_SIZE 	  EQU  FRAM_BP - Fram_Next_DTA ;AN000;SIZE OF STACK WORKAREA
; =  =	=  =  =  =  =  =  =  =	=  =
;THIS MESSAGE DESCRIPTOR CONTROL BLOCK IS GENERATED, ONE PER MESSAGE,
;TO DEFINE THE SEVERAL PARAMETERS THAT ARE EXPECTED TO BE PASSED IN
;CERTAIN REGISTERS WHEN THE SYSDISPMSG FUNCTION IS TO BE INVOKED.

MSG_DESC	  STRUC 	   ;AN000;
MSG_NUM 	  DW   ?	   ;AN000;MESSAGE NUMBER (TO AX)
MSG_HANDLE	  DW   ?	   ;AN000;HANDLE OF OUTPUT DEVICE (TO BX)
MSG_SUBLIST	  DW   ?	   ;AN000;POINTER TO SUBLIST (TO SI)
MSG_COUNT	  DW   ?	   ;AN000;SUBSTITUTION COUNT (TO CX)
MSG_CLASS	  DW   ?	   ;AN000;MESSAGE CLASS (IN HIGH BYTE, TO DH)
				   ; LOW BYTE HAS 0 (FUNCTION "NO INPUT", TO DL)
MSG_DESC	  ENDS								;AN000;
; =  =	=  =  =  =  =  =  =  =	=  =
SUBLIST 	  STRUC 	   ;AN000;
SUB_SIZE	  DB   ?	   ;AN000;SUBLIST SIZE (POINTER TO NEXT SUBLIST)
SUB_RES 	  DB   ?	   ;AN000;RESERVED
				   ;NEXT FIELD IS TO BE USED AS A DOUBLE WORD
SUB_VALUE	  DW   ?	   ;AN000;TIME, DATE, OR PTR TO DATA ITEM
SUB_VALUE_SEG	  DW   ?	   ;AN000;SEG ID OF PTR
				   ;(ABOVE FIELD MUST BE FILLED AT EXECUTION TIME
				   ; IF THIS IS A .COM FILE)
SUB_ID		  DB   ?	   ;AN000;N OF %N
SUB_FLAGS	  DB   ?	   ;AN000;DATA TYPE FLAGS
SUB_MAX_WIDTH	  DB   ?	   ;AN000;MAXIMUM FIELD WIDTH (0=UNLIMITED)
SUB_MIN_WIDTH	  DB   ?	   ;AN000;MINIMUM FIELD WIDTH
SUB_PAD_CHAR	  DB   ?	   ;AN000;CHARACTER FOR PAD FIELD
SUBLIST 	  ENDS		   ;AN000;
; =  =	=  =  =  =  =  =  =  =	=  =
A_MEDIA_ID_INFO STRUC		   ;AN001;USED IN GET_MEDIA_ID IN BLOCK GENERIC IOCTL
MI_LEVEL	  DW   0	   ;AN001;INFO LEVEL
MI_SERIAL	  DD   0	   ;AN001;SERIAL #
MI_LABEL	  DB   11 DUP (' ') ;AN001;VOLUME LABEL
MI_SYSTEM	  DB   8 DUP (' ') ;AN001;FILE SYSTEM TYPE
A_MEDIA_ID_INFO ENDS		   ;AN001;
; =  =	=  =  =  =  =  =  =  =	=  =

;END OF TREEQU.INC


=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dev\ansi\ansi.asm ===
PAGE	,132
TITLE	CONDEV	FANCY CONSOLE DRIVER
;******************************************************************************

;  Change Log:

;    Date    Who   #                      Description
;  --------  ---  ---  ------------------------------------------------------
;  06/01/90  MKS  C02  Bug#173.  ANSI was permitting you to go  one line below
;                      the bottom of the screen.  PROMPT $e[25;3H $e[1B will
;                      show you. (PYS: badly done. M005)
;******************************************************************************

;:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

;       ADDRESSES FOR I/O

;:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
;------------------------------------------------------------------------------
; New functionality in DOS 4.00
; GHG fix scrolling flashes on Mod 25/30's
; P1767 VIDEO_MODE_TABLE not initialized correctly		10/16/87 J.K.
; D375 /X needs to be supported by ANSI sequence also		12/14/87 J.K.
; D397 /L option for Enforcing number of lines			12/17/87 J.K.
; D479  An option to disable the extended keyboard functions	02/12/88 J.K.
; P4241 AN001 fix be Revised to fix this problem		04/20/88 J.K.
; P4532 Scrolling has a snow for CGA adapter			04/27/88 J.K.
; P4533 In mode Dh, Eh, Fh, 10h and 13h, Scrolling not working	04/27/88 J.K.
; P4766 In mode 11h, and 12h erase display leaves bottom 5	05/24/88 F.G.
;------------------------------------------------------------------------------

INCLUDE	DEVSYM.INC
INCLUDE	ANSI.INC		;equates and structures
INCLUDE	VECTOR.INC

BREAK	<ANSI driver code>

PUBLIC	SWITCH_X		; /X option for extended keyboard redefinition support
PUBLIC  SWITCH_R                ; /R option for using screen readers
PUBLIC	SCAN_LINES
PUBLIC	VIDEO_MODE_TABLE
PUBLIC	VIDEO_TABLE_MAX
PUBLIC	MAX_VIDEO_TAB_NUM	;P1767
PUBLIC	PTRSAV
PUBLIC	ERR1
PUBLIC	ERR2
PUBLIC	EXT_16
PUBLIC	BRKKY
PUBLIC	COUT
PUBLIC	BASE
PUBLIC	MODE
PUBLIC	MAXCOL
PUBLIC	EXIT
PUBLIC	NO_OPERATION
PUBLIC	HDWR_FLAG
PUBLIC	SWITCH_L
PUBLIC	SWITCH_K
PUBLIC	SWITCH_S		; M008 /S for screensize option setting.
PUBLIC	fhavek09		; M006

PUBLIC	CON$READ
PUBLIC	CON$RDND
PUBLIC	CON$FLSH
PUBLIC	CON$WRIT
PUBLIC	VIDEO
PUBLIC	CUU
PUBLIC	CUD
PUBLIC	CUF
PUBLIC	CUB
PUBLIC	CUP
PUBLIC	ED
PUBLIC	CPR
PUBLIC	SM
PUBLIC	RM
PUBLIC	SGR
PUBLIC	DSR
PUBLIC	KEYASN
PUBLIC	EXTKEY
PUBLIC	PSCP
PUBLIC	PRCP

IFDEF	JAPAN
PUBLIC	ROW_ADJ
ENDIF

CODE	SEGMENT PUBLIC BYTE

	ASSUME CS:CODE,DS:NOTHING,ES:NOTHING
;-----------------------------------------------

;	C O N - CONSOLE DEVICE DRIVER


EXTRN	CON$INIT	: NEAR		; ANSI initialization code
EXTRN	GENERIC_IOCTL	: NEAR		; Generic IOCTL code
EXTRN	REQ_TXT_LENGTH	: WORD		; current text length
EXTRN	GRAPHICS_FLAG	: BYTE		; graphics flag

ATTRIB	EQU	CHARDEV+DEVIOCTL+DEV320+ISSPEC+ISCOUT+ISCIN
CONDEV:	SYSDEV	<-1,ATTRIB,STRATEGY,ENTRY,'CON     '>	; Matches CON

;--------------------------------------------------------------

;	COMMAND JUMP TABLES
CONTBL:
	DW	CON$INIT
	DW	NO_OPERATION
	DW	NO_OPERATION
	DW	NO_OPERATION
	DW	CON$READ
	DW	CON$RDND
	DW	NO_OPERATION
	DW	CON$FLSH
	DW	CON$WRIT
	DW	CON$WRIT
	DW	NO_OPERATION
	DW	NO_OPERATION
	DW	NO_OPERATION
	DW	NO_OPERATION
	DW	NO_OPERATION
	DW	NO_OPERATION
	DW	NO_OPERATION
	DW	NO_OPERATION
	DW	NO_OPERATION
	DW	GENERIC_IOCTL		; generic IOCTL routine offset
MAX_CMD	EQU	($ - CONTBL)/2		; size of CONTBL

CMDTABL DB	'A'
	DW	CUU			; cursor up
	DB	'B'
	DW	CUD			; cursor down
	DB	'C'
	DW	CUF			; cursor forward
	DB	'D'
	DW	CUB			; cursor back
	DB	'H'
	DW	CUP			; cursor position
	DB	'J'
	DW	ED			; erase display
	DB	'K'
	DW	EL			; erase line
	DB	'R'
	DW	CPR			; cursor postion report
	DB	'f'
	DW	CUP			; cursor position
	DB	'h'
	DW	SM			; set mode
	DB	'l'
	DW	RM			; reset mode
	DB	'm'
	DW	SGR			; select graphics rendition
	DB	'n'
	DW	DSR			; device status report
	DB	'p'
	DW	KEYASN			; key assignment
	DB	'q'			; dynamic support of /X option through ansi sequence
	DW	EXTKEY			; esc[0q = reset it. esc[1q = set it
	DB	's'
	DW	PSCP			; save cursor postion
	DB	'u'
	DW	PRCP			; restore cursor position
IFDEF	JAPAN
	DB	'M'
	DW	DELETE			; delete line
	DB	'L'
	DW	INSERT			; insert line
ENDIF
	DB	00

GRMODE	DB	00,00000000B,00000111B
	DB	01,11111111B,00001000B
	DB	04,11111000B,00000001B
	DB	05,11111111B,10000000B
	DB	07,11111000B,01110000B
	DB	08,10001000B,00000000B
	DB	30,11111000B,00000000B
	DB	31,11111000B,00000100B
	DB	32,11111000B,00000010B
	DB	33,11111000B,00000110B
	DB	34,11111000B,00000001B
	DB	35,11111000B,00000101B
	DB	36,11111000B,00000011B
	DB	37,11111000B,00000111B
	DB	40,10001111B,00000000B
	DB	41,10001111B,01000000B
	DB	42,10001111B,00100000B
	DB	43,10001111B,01100000B
	DB	44,10001111B,00010000B
	DB	45,10001111B,01010000B
	DB	46,10001111B,00110000B
	DB	47,10001111B,01110000B
	DB	0FFH

;---------------------------------------------------
;	Device entry point


PTRSAV	DD	0

BUF1:	BUF_DATA <>			; Next CON Buffer area

STRATP	PROC	FAR

STRATEGY:
	mov	word ptr cs:[PTRSAV],bx
	mov	word ptr cs:[PTRSAV+2],es
	ret

STRATP	ENDP

ENTRY:
	push	si
	push	ax
	push	cx
	push	dx
	push	di
	push	bp
	push	ds
	push	es
	push	bx

; Check if header link has to be set	(Code ported from
;						DISPLAY.SYS)

	lea	bx,BUF1
	mov	di,OFFSET CONDEV	; CON Device header

	mov	CONPTR.DEV_HDRO,di
	mov	CONPTR.DEV_HDRS,cs
	cld				; all moves forward

	cmp	CONPTR.CON_STRAO, -1
	jne	L4			; has been linked to DOS CON
	cmp	CONPTR.CON_STRAS, -1
	jne	L4			; has been linked to DOS CON
					; next device header :	ES:[DI]
	lds	si,dword ptr CONPTR.DEV_HDRO
	les	di,HP.SDEVNEXT

L1:					; while pointer to next device header
	push	es			; is not -1
	pop	ax
	cmp	ax,-1
	jne	NOT0FFFF		; leave if both offset and segment are
	cmp	di,-1			; 0FFFFH
	je	L4

NOT0FFFF:
	push	di
	push	si
	mov	cx,8
	lea	di,NHD.SDEVNAME
	lea	si,HP.SDEVNAME
	repe	cmpsb
	pop	si
	pop	di
	and	cx,cx
					; Exit if name is found in linked hd.
	jnz	L3			; Name is not found
					; Name is found in the linked header
	mov	ax,NHD.SDEVSTRAT	; Get the STRATEGY address
	mov	CONPTR.CON_STRAO,ax
	mov	ax,es
X1:	mov	CONPTR.CON_STRAS,ax

	mov	ax,NHD.SDEVINT	 	; Get the INTERRUPT address
	mov	CONPTR.CON_INTRO,ax
	mov	ax,es
X2:	mov	CONPTR.CON_INTRS,ax

	jmp	SHORT L4		; Device Name
L3:
	les	di,NHD.SDEVNEXT
	jmp	L1
L4:
	lds	bx,cs:[PTRSAV]		; GET PONTER TO I/O PACKET

	mov	cx,word ptr ds:[bx].COUNT

	mov	al,byte ptr ds:[bx].CMD
	cbw
	mov	si,OFFSET CONTBL
	add	si,ax
	add	si,ax
	cmp	al,MAX_CMD		; not a call for ANSI...chain to lower device
	ja	NO_OPERATION

ifdef   KOREA                                   ; <MSCH>
        mov     ah, byte ptr ds:[bx].media
endif   ; KOREA

	les	di,dword ptr ds:[bx].TRANS

	; Following code, supplied by Compaq, is the "hit-it-on-the-head"
	; approach to solving the problem of resetting the screen length
	; after a character set reload.	We should try to find a better
	; approach.	For now this will stay in. - MGD

	push	ax			; SAVE AX
	mov	ax,40H			; GET ROM VAR
	mov	ds,ax			;

	mov	al,ds:[84h]		; GET MAX NUM OF ROWS
	cmp	al,0			; Q:ZERO
	jne	ENTRY10			; jmp IF NO
	mov	al,24			; SET TO 24 ROWS
ENTRY10:				;
	push	cs
	pop	ds

	ASSUME	ds:CODE

	inc	al			; BUMP FOR ONE BASED
	mov	byte ptr [REQ_TXT_LENGTH],al ; SET LENGTH TO 40:84H VALUE.	*F
	pop	ax			; RESTORE AX

	jmp	word ptr [si]		; GO DO COMMAND

;=====================================================
;=
;=	SUBROUTINES SHARED BY MULTIPLE DEVICES
;=
;=====================================================
;----------------------------------------------------------

;	EXIT - ALL ROUTINES RETURN THROUGH THIS PATH

BUS$EXIT:				; DEVICE BUSY EXIT
	mov	ah,00000011B
	jmp	SHORT ERR1

NO_OPERATION:
	call	PASS_CONTROL		; Pass control to lower CON
	jmp	SHORT ERR2

ERR$EXIT:
	mov	ah,10000001B		; MARK ERROR RETURN
	jmp	SHORT ERR1

EXITP	PROC	FAR

EXIT:	mov	ah,00000001B

ifdef   KOREA
INTERIM$EXIT:                           ; <MSCH>
endif   ; KOREA

ERR1:	lds	bx,cs:[PTRSAV]
	mov	word ptr [bx].STATUS,ax	; MARK OPERATION COMPLETE
ERR2:
	pop	bx
	pop	es
	pop	ds
	pop	bp
	pop	di
	pop	dx
	pop	cx
	pop	ax
	pop	si
	ret				; RESTORE REGS and RETURN
EXITP	ENDP


;	PASS CONTROL

;	This calls the attached device to perform any further
;	action on the call!


PASS_CONTROL	PROC
	lea	si,BUF1
	les	bx,cs:[PTRSAV]			; pass the request header to the
	call	dword ptr cs:[si].CON_STRAO	; CON strategy routine.
	call	dword ptr cs:[si].CON_INTRO	; interrupt the CON
	ret
PASS_CONTROL	ENDP
;-----------------------------------------------

;	BREAK KEY HANDLING

BRKKY:
	mov	byte ptr cs:ALTAH,3	; INDICATE BREAK KEY SET
INTRET: iret


;	WARNING - Variables are very order dependent, be careful
;		 when adding new ones!	- c.p.

WRAP		DB	0		; 0 = WRAP, 1 = NO WRAP
ASNPTR		DW	4
STATE		DW	S1
MODE		DB	3		;*
MAXCOL		DB	79		;*
COL		DB	0
ROW		DB	0
SAVCR		DW	0
INQ		DB	0
PRMCNT		LABEL	BYTE
PRMCNTW 	DW	0
KEYCNT		DB	0
KEYPTR		DW	BUF
REPORT		DB	ESC_CHAR,'[00;00R',CR	;CURSOR POSTION REPORT BUFFER
ALTAH		DB	0			;Special key handling

SAVE_CHAR	DW	0			; Temp storage for char/attr for new scroll code

EXT_16		DB	0		; Extended INT 16h flag
SWITCH_X	DB	OFF		; /X flag
SWITCH_L	DB	OFF		; DCR397; 1= /L flag entered.
SWITCH_K	DB	OFF		; To control EXT_16
fhavek09	DB	OFF		; M006
SCAN_LINES	DB	?		; flag for available scan lines (VGA)
HDWR_FLAG	DW	0		; byte of flags indicating video support
SWITCH_S	DB	OFF		; M008; /S flag
SWITCH_R        DB      OFF             ; /R flag for screen readers

ifdef   KOREA                           ;
REQ_TYPE        DB      0               ;
EXT_REQ_TYPE    DB      0               ;
LEADBYTE        DB      0               ;
TRAILBYTE       DB      0               ;
ECSPRE          DB      0               ;
endif   ; KOREA                         ;

VIDEO_MODE_TABLE	LABEL	BYTE	; table containing applicable
MODE_TABLE	<>			; video modes and corresponding
MODE_TABLE	<>			; data.
MODE_TABLE	<>			; this table is initialized at
MODE_TABLE	<>			; INIT time
MODE_TABLE	<>			
MODE_TABLE	<>
MODE_TABLE	<>
MODE_TABLE	<>
MODE_TABLE	<>
MODE_TABLE	<>
MODE_TABLE	<>
MODE_TABLE	<>
MODE_TABLE	<>
MODE_TABLE	<>
MODE_TABLE	<>

ifdef	KOREA				;  The KOREAN video mode
MODE_TABLE   <>                         ;  have 4 more than standard
MODE_TABLE   <>                         ;  VGA  card
MODE_TABLE   <>                         ;
MODE_TABLE   <>                         ;
endif   ; KOREA                         ;

VIDEO_TABLE_MAX	EQU	$		; maximum address for video table
MAX_VIDEO_TAB_NUM	EQU	($-VIDEO_MODE_TABLE)/TYPE MODE_TABLE ;P1767 Max number of table


IFDEF		DBCS
dbcs_flag	DB	0		; 0=single, 1=lead byte, 2=tail byte
ENDIF
IFDEF		JAPAN
new_mode	DB	0		; mode for '>'
row_adj		DB	0		; for ESC[>1l
ENDIF

;-------------------------------------------------------------

;	CHROUT - WRITE OUT CHAR IN AL USING CURRENT ATTRIBUTE

ATTRW		LABEL	WORD
ATTR		DB	00000111B		; CHARACTER ATTRIBUTE
BPAGE		DB	0			; BASE PAGE
BASE		DW	0b800h
SCREEN_SEG 	DW	00000h

chrout:

ifdef   KOREA                   ; <MSCH>
;
        cmp     [leadbyte],1    ; Is the previous byte a lead byte?  ; KeyW
        jnz     TestDBCSRange   ; No,
        mov     byte ptr [leadbyte],0
        mov     byte ptr [trailbyte],1   ; Mark that this is trail byte of ECS
        jmp     short OUTCHR
;
;
; Note : TestECS routine is hard coded. If you have the different code range,
;        you should change some codes below.
; 1990/11/9 This routine is changed to use IsDBCS routines.
;
TestDBCSRange:
        mov     byte ptr [trailbyte], 0 ; Mark it as a non trail byte
        call    IsDBCSleadbyte
        jnz     realout                 ; Jump if one byte code
;
;       CMP     AL, 0A1H                ;
;       JB      REALOUT                 ;
;       CMP     AL, 0FEH                ;
;       JA      REALOUT                 ;

        mov     byte ptr [leadbyte], 1  ;  it as a lead byte
        mov     ah, [col]               ;
        cmp     ah, [maxcol]            ;
        jnz     outchr                  ;
;                                       ;
; Decide the position to print the Lead byte which is on the column boundary.
;
        cmp     [wrap],0                ;
        jz      skip1                   ;
        dec     [col]                   ;
        cmp     [ecspre],1              ;
        jnz     oneback1                ;
        dec     [col]                   ;
oneback1:                               ;
        call    setit1                  ;
        jmp     short outchr            ;
skip1:                                  ;
        push    ax                      ;
        call    outchr1                 ;
        pop     ax                      ;
        jmp     short outchr            ;
realout:
endif   ; KOREA                         ;

	cmp	al,13
	jnz	trylf
	mov	[COL],0

ifdef	KOREA
	jmp	setit
else
IFDEF	JAPAN
	jmp	setit
ELSE
	jmp	short setit
ENDIF
endif   ; KOREA

trylf:	cmp	al,10
	jz	lf
	cmp	al,7
	jnz	tryback
torom:
	mov	bx,[ATTRW]
	and	bl,7
	mov	ah,14
	int	10h
ret5:	ret

tryback:
	cmp	al,8
	jnz	outchr
	cmp	[COL],0
	jz	ret5
	dec	[COL]
	jmp	short setit

outchr:
	mov	bx,[ATTRW]
	mov	cx,1
	mov	ah,9
	int	10h
	inc	[COL]
	mov	al,[COL]
	cmp	al,[MAXCOL]
	jbe	setit
	cmp	[wrap],0
	jz	outchr1
	dec	[COL]

ifdef   KOREA
;
;       Set boundary position for DBCS code.
;               No lead byte can arrive here.
;
        cmp     [trailbyte],1
        jnz     onebk
        dec     [col]
onebk:
        call    setit1
;
; We don't need ECSPRE change, because we have enough time to deal with it.
; Wait for another character to change ECSPRE.
;
endif	; KOREA

	ret
outchr1:
	mov	[COL],0
lf:	inc	[ROW]
	mov	ah,30			; GHG	Fix for ROUNDUP/PALACE
	mov	al,MODE		 	; GHG	Fix for ROUNDUP/PALACE
	cmp	al,11H			; GHG	Fix for ROUNDUP/PALACE
	je	LF2			; GHG	Fix for ROUNDUP/PALACE
	cmp	al,12H			; GHG	Fix for ROUNDUP/PALACE
	je	LF2			; GHG	Fix for ROUNDUP/PALACE

	cmp	GRAPHICS_FLAG,GRAPHICS_MODE
	jne	tmplab1
	mov	ah,DEFAULT_LENGTH
	jmp	short tmplab2
tmplab1:
	mov	ah,byte ptr [REQ_TXT_LENGTH]
tmplab2:
LF2:					; GHG	Fix for ROUNDUP/PALACE
IFDEF JAPAN
	sub	ah,row_adj
ENDIF
	cmp	[ROW],AH		; GHG	Fix for ROUNDUP/PALACE
	jb	setit
	dec	ah			; GHG	Fix for ROUNDUP/PALACE
	mov	[ROW],AH		; GHG	Fix for ROUNDUP/PALACE
	call	scroll

setit:

ifdef	   KOREA
preset:
        xor     al, al
        cmp     [trailbyte],al
        jz      noDBCStrail
        inc     al
noDBCStrail:
        mov     [ecspre], al
setit1:
endif   ; KOREA

	mov	dh,row
	mov	dl,col
	mov	bh,[bpage]
	mov	ah,2
	int	10h
	ret

;Writing a LF char through Teletype function to scroll the screen
;has a side effect of changing the color of the cursor when the PROMPT
;setting in PTM P4241 is used. AN001 uses this method to fix the strobing
;problem of the palace machine.	The old method of scrolling used to directly
;write into video buffer.	The old method has been used by AN001 for
;CGA adater of mode 2 or 3 only.
;To solve P4241, but to maintain the fix of the strobing problem of palace
;machine, we return back to the old logic but the old logic has to be
;Revised for the displays above CGA level.	For the adapters above
;CGA display, we don't need to turn off/on the video - this will causes
;a strobing, if you use do this,	for Palace machine.
;This logic will be only applied to mode 2 and 3 only.

; Following code is bug fix supplied by Compaq - MGD
scroll:

ifdef	KOREA				; Responsible for ROM
        mov     al, 10
        jmp     torom
else
IFDEF	JAPAN				; ### if JAPAN ###

	xor	cx,cx
	cmp	GRAPHICS_FLAG,GRAPHICS_MODE
	jnz	scroll10		; if nor graphic
	mov	dh,DEFAULT_LENGTH
	xor	bh,bh
	jmp	short scroll20
scroll10:
	mov	dh,byte ptr [REQ_TXT_LENGTH]
	mov	bh,[ATTR]
scroll20:
	sub	dh,row_adj
	dec	dh
	mov	dl,[MAXCOL]
	mov	ax,0601h		; scroll up
	int	10h
	jmp	short setit

else					; ### if Not JAPAN ###

;  Because of screen reader problem, /R switch was added.
;  If Switch_R set all line feeds go to torom. Bug #1241- msdos6:

        cmp     SWITCH_R,OFF
	je	is_2or3		 	; if off, goto test mode
	mov	al,10			; if ON send the line feed to the ROM
	jmp	torom			; exit

is_2or3:
	mov	al,mode		 	; get display mode
	cmp	al,4			;Q: mode less than 4?
	jc	is_text		 	;Y: perform kludge
	cmp	al,7			;N: Q: monochrome mode?
	je	is_text		 	;   Y: perform kludge
	mov	al,10			; send the line feed to the ROM
	jmp	torom			; exit

is_text:
	mov	ah,8			; read char/attr at cursor pos
	mov	bh,[bpage]
	int	10h
	mov	[save_char],ax		; save char/attribute

	mov	ah,9			; write char at cursor pos
	mov	bx,[ATTRW]		; use current attribute
	mov	cx,1
	int	10h

	mov	al,10			; send the line feed to the ROM
	call	torom
	mov	ah,3			; read cursor pos
	int	10h
	push	dx			; save it
	mov	ah,2			; set cursor position
	dec	dh			; (to row-1)
	int	10h

	mov	ax,[save_char]		; retrieve saved char/attr
	mov	bl,ah
	mov	ah,9			; write it back to the screen
	mov	cx,1
	int	10h

	pop	dx			; retrieve new cursor position
	mov	ah,2			; set cursor position
	int	10h
	ret
ENDIF					; ### end if Not JAPAN ###
endif   ; KOREA


;------------------------------------------------------

;	CONSOLE READ ROUTINE

CON$READ:
	jcxz	CON$EXIT

ifdef   KOREA                           ;
        mov     [req_type], 0           ;
        mov     [ext_req_type], 10h     ;
        test    ah, 00000001b           ;
        jz      con$loop                ;
        mov     [req_type], 0f0h        ; ; Get Interim mode
        mov     [ext_req_type], 0f8h    ;
        cmp     cx, 1                   ;
        jnz     con$ndisp               ;
                                        ;
        call    chrin                   ;
        stosb                           ;
        cmp     ah, 0f0h                ; ; Is this an interim code ?
        jnz     con$exit                ;
        mov     ah, 00000101b           ;
        jmp     interim$exit            ; ; return to DOS with interim flag set
con$ndisp:                              ;
        call    chrin                   ;
        cmp     ah, 0f0h                ; ; Is this an interim code ?
        jz      con$ndisp               ; ; Skip the interims
        stosb                           ;
        LOOP    CON$NDISP               ;
        JMP     EXIT                    ;
endif   ; KOREA


CON$LOOP:
	push	cx			; SAVE COUNT
	call	CHRIN			; GET CHAR IN AL
	pop	cx
	stosb				; STORE CHAR AT ES:DI
	loop	CON$LOOP
CON$EXIT:
	jmp	EXIT
;---------------------------------------------------------

;	INPUT SINGLE CHAR INTO AL

CHRIN:	xor	ax,ax
	xchg	al,ALTAH		; GET CHARACTER & ZERO ALTAH
	or	al,al
	jnz	KEYRET

INAGN:	cmp	KEYCNT,0
	jnz	KEY5A

ifdef   KOREA
        mov     ah, [req_type]
else
	xor	ah,AH
endif   ; KOREA

	cmp	EXT_16,ON		; extended interrupt available?
	jne	tmplab3

ifdef   KOREA
        mov     ah, [ext_req_type]
else
	mov	ah,10h			; yes..perform extended call
endif	; KOREA

	INT	16h

ifdef   KOREA
        cmp     ah, 0f0h
        jz      keyret1                 ; Breief return for the interim code
endif   ; KOREA

	cmp	SWITCH_X,OFF		; /X switch used?
	jne	tmplab5
	call	CHECK_FOR_REMAP 	; no....map to normal call

tmplab5:
	call	SCAN			; check for redefinition
	jz	tmplab4			; no redefinition?....and
	cmp	SWITCH_X,ON		; /X switch used?
	jne	tmplab4
	call	CHECK_FOR_REMAP 	; then remap..
	or	bx,bx			; reset zero flag for jump test in old code

	jmp	short tmplab4

;	extended interrupt not available

tmplab3:
	int	16h

ifdef   KOREA
        cmp     ah, 0f0h
        jz      keyret1
endif   ; KOREA

	call	SCAN			; check for redefinition

tmplab4:
	jnz	ALT10			; IF NO MATCH JUST RETURN IT

	dec	cx
	dec	cx
	inc	bx
	inc	bx
	cmp	al,0			; check whether keypacket is an extended one
	jz	tmplab7
	cmp	al,0e0h
	jnz	tmplab6

ifdef   KOREA
        cmp     ah, 0f0h
        jb      mschtmp2
        cmp     ah, 0f2h
        jbe     tmplab7
mschtmp2:
endif   ; KOREA

	cmp	SWITCH_X,1
	jnz	tmplab6
tmplab7:
	dec	cx			; adjust pointers
	inc	bx			; appropiately
tmplab6:
	mov	KEYCNT,cl
	mov	KEYPTR,bx
KEY5A:					; Jmp here to get rest of translation
	call	KEY5			; GET FIRST KEY FROM TRANSLATION
ALT10:
	or	ax,ax			; Check for non-key after BREAK
	jz	INAGN
	or	al,al			; SPECIAL CASE?
	jnz	KEYRET
	mov	ALTAH,ah		; STORE SPECIAL KEY
KEYRET:

ifdef   KOREA
        mov     ah, 0f1h
keyret1:
endif   ; KOREA

	ret

KEY5:	mov	bx,KEYPTR		; GET A KEY FROM TRANSLATION TABLE
	mov	ax,word ptr [bx]
	dec	KEYCNT
	inc	bx
	or	al,al
	jnz	KEY6
	inc	bx
	dec	KEYCNT
KEY6:	mov	KEYPTR,bx
	ret

SCAN:	mov	bx,OFFSET BUF
KEYLP:	mov	cl,byte ptr [bx]
	xor	ch,ch
	or	cx,cx
	jz	NOTFND
	cmp	al,0			; check whether extended keypacket
	jz	tmplab8
	cmp	al,0e0h			; extended must be enabled with /x
	jnz	tmplab9

ifdef   KOREA                           ; Jump when Hangeul char
        cmp     ah, 0f0h
        jb      mschtmp1
        cmp     ah, 0f2h
        jbe     tmplab9
mschtmp1:
endif   ; KOREA

	cmp	SWITCH_X,ON
	jnz	tmplab9
tmplab8:
	cmp	ax,word ptr [bx+1]	; yes...compare the word
	jmp	short tmplab10
tmplab9:
	cmp	al,byte ptr [bx+1]	; no...compare the byte
tmplab10:
	jz	MATCH
	add	bx,cx
	jmp	KEYLP
NOTFND:	or	bx,bx
MATCH:	ret
;--------------------------------------------------------------

;	KEYBOARD NON DESTRUCTIVE READ, NO WAIT

CON$RDND:
	mov	al,[ALTAH]
	or	al,al

ifdef   KOREA
        jnz     To_RDEXIT
else
	jnz	RDEXIT
endif   ; KOREA

	cmp	[KEYCNT],0
	jz	RD1
	mov	bx,[KEYPTR]
	mov	al,byte ptr [bx]

ifdef   KOREA
to_rdexit:
        jmp     rdexit
else
	jmp	SHORT RDEXIT
endif   ; KOREA

RD1:

ifdef   KOREA
        mov     [req_type], 1
        mov     [ext_req_type], 11H
        test    ah, 00000001b
        jz      rd11
        mov     [req_type], 0f1h
        mov     [ext_req_type], 0f9H
RD11:
        mov     ah, [req_type]
        cmp     ext_16, on
        jnz     tmplab11
        mov     ah, [ext_req_type]
else
        mov     ah,1
	cmp	EXT_16,ON
	jnz	tmplab11
	add	ah,10h			; yes....adjust to extended call
endif	; KOREA

tmplab11:
	int	16h
	jz	CheckForEvent
	or	ax,ax
	jnz	RD2

ifdef   KOREA
        mov     ah, [req_type]
        and     ah, 11111110b
else
        mov     ah,0
endif   ; KOREA

	cmp	EXT_16,ON		; extended interrupt available?
	jne	tmplab12

ifdef   KOREA
        mov     ah, [ext_req_type]
        and     ah, 11111110b
else
	mov	ah,10h			; yes..perform extended call
endif   ; KOREA

	int	16h
	cmp	SWITCH_X,OFF		; /X switch used?
	jnz	tmplab13
	call	CHECK_FOR_REMAP		; no....map to normal call
	jmp	short tmplab13
tmplab12:
	int	16h
tmplab13:
	jmp	CON$RDND

RD2:

ifdef   KOREA
        cmp     ah, 0f0h
        jz      rdexit
endif   ; KOREA

	call	SCAN
	jz	tmplab14		; if no redefinition
	cmp	EXT_16,ON
	jnz	tmplab14		; and extended INT16 used
	cmp	SWITCH_X,ON		; and /x used
	jnz	tmplab14

	call	CHECK_FOR_REMAP		; remap to standard call
	or	bx,bx			; reset zero flag for jump test in old code

tmplab14:
	jnz	RDEXIT

	mov	al,byte ptr [bx+2]
	cmp	byte ptr [bx+1],0
	jnz	RDEXIT
	mov	al,byte ptr [bx+3]
RDEXIT: lds	bx,[PTRSAV]
	mov	[bx].MEDIA,al
EXVEC:	jmp	EXIT

; M006 - begin

CheckForEvent:
	cmp	fhavek09,0
	jz	CONBUS			; return with busy status if not k09

	les	bx,[ptrsav]
	assume	es:nothing
	test	es:[bx].status,0400h	; system wait enabled?
	jz	CONBUS			;  return with busy status if not

;	need to wait for ibm response to request for code
;	on how to use the system wait call.

	mov	ax,4100h		; wait on an external event
	xor	bl,bl			; wait for any event
	int	15h			; call rom for system wait

; M006 - end

CONBUS: jmp	BUS$EXIT
;--------------------------------------------------------------

;	KEYBOARD FLUSH ROUTINE

CON$FLSH:
	mov	[ALTAH],0		; Clear out holding buffer
	mov	[KEYCNT],0

ifdef   KOREA
        mov     ah, 0f3h
        int     16h
 ReadNullByte:                          ; We may have final char
        mov     ah, 0f1h
        int     16h
        jz      FlushDone
        mov     ah, 0f0h
        int     16h
        jmp     short   ReadNullByte
FlushDone:
else
Flush:	mov	ah,1
	cmp	EXT_16,ON		; if extended call available
	jnz	tmplab15
	add	ah,10h			; then use it
tmplab15:

	int	16h
	jz	FlushDone
	mov	ah,0

	cmp	EXT_16,ON		; if extended call available
	jnz	tmplab16
	add	ah,10h			; use it
tmplab16:
	int	16h
	jmp	Flush
FlushDone:
endif   ; KOREA

	jmp	EXVEC
;----------------------------------------------------------

;	CONSOLE WRITE ROUTINE

CON$WRIT:
	jcxz	EXVEC

ifdef   KOREA
        test    ah, 00000001b
        jnz     con$lp_nac      ;OUT CHAR WITHOUT CURSOR ADVANCING
endif   ; KOREA

CON$LP: mov	al,es:[di]		; GET CHAR
	inc	di
	call	OUTC			; OUTPUT CHAR
	loop	CON$LP			; REPEAT UNTIL ALL THROUGH
	jmp	EXVEC

ifdef   KOREA
con$lp_nac:
        mov     al, es:[di]
        inc     di
        call    outchr_nac      ;OUTPUT CHAR WITHOUT CURSOR MOVE
        loop    con$lp_nac      ;REPEAT UNTIL ALL THROUGH
        jmp     exit

outchr_nac:
        push    ax
        push    si
        push    di
        push    bp
        mov     ah, 0feh        ;OUTPUT CHAR WITHOUT CURSOR ADVANCING
        mov     bl, 7           ;SET FOREGROUND COLOR
        int     10h             ;CALL ROM BIOS
        pop     bp
        pop     di
        pop     si
        pop     ax
        ret
endif

COUT:	sti
	push	ds
	push	cs
	pop	ds
	call	OUTC
	pop	ds
	Iret

OUTC:	push	ax
	push	bx
	push	cx
	push	dx
	push	si
	push	di
	push	es
	push	bp

	mov	[BASE],0b800h
	xchg	ax,si			; SAVE CHARACTER TO STUFF
	mov	ax,40h			; POINT TO ROS BIOS
	mov	ds,ax
	mov	ax,ds:[49h]		; AL=MODE, AH=MAX COL
	dec	ah			; ANSI NEEDS 0-79 OR 0-39
	mov	word ptr cs:[MODE],ax	; SAVE MODE and MAX COL
	cmp	al,7
	jnz	NOT_BW
	mov	word ptr cs:[BASE],0B000H
NOT_BW: mov	al,ds:[62H]		; GET ACTIVE PAGE
	mov	cs:[BPAGE],al
	cbw
	add	ax,ax
	mov	bx,ax
	mov	ax,ds:[bx+50H]		; AL=COL, AH=ROW
	mov	word ptr cs:[COL],ax	; SAVE ROW and COLUMN
	mov	ax,ds:[4EH]		; GET START OF SCREEN SEG
	mov	cl,4
	shr	ax,cl			; CONVERT TO A SEGMENT
	push	cs
	pop	ds
	mov	[SCREEN_SEG],ax
	xchg	ax,si			; GET BACK CHARACTER IN AL

	call	VIDEO
	pop	bp
	pop	es
	pop	di
	pop	si
	pop	dx
	pop	cx
	pop	bx
	pop	ax
	ret


;----------------------------------------------------------

;	OUTPUT SINGLE CHAR IN AL TO VIDEO DEVICE

VIDEO:	mov	si,OFFSET STATE
	jmp	[si]

S2:	cmp	al,'['
	jz	S22

ifdef   KOREA
        cmp     al, '$'
        jnz     chk_off
        mov     word ptr [si], offset S8
        ret
chk_off:
        cmp     al, '('
        jnz     jmp_S1
        mov     word ptr [si], offset S10
        ret
jmp_S1:
endif   ; KOREA

	jmp	S1
S22:	mov	word ptr [si],OFFSET S3
	xor	bx,bx
	mov	word ptr INQ,bx
	jmp	SHORT S3B

S3:	cmp	al,';'
	jnz	S3C
S3A:	inc	PRMCNT
S3B:	call	GETPTR
	xor	ax,ax
	mov	word ptr [bx],ax	; DEFAULT VALUE IS ZERO
	ret

S3C:	cmp	al,'0'
	jb	S3D
	cmp	al,'9'
	ja	S3D
	call	GETPTR
	sub	al,'0'
	xchg	al,byte ptr [bx]
	mov	ah,10
	mul	ah			; *10
	add	byte ptr [bx],al	; movE IN DIGIT
	ret

S3D:	cmp	al,'='
	jz	S3ret
	cmp	al,'?'
	jz	S3ret
IFDEF JAPAN
	cmp	al,'>'
	jz	s3f
ENDIF
	cmp	al,'"'			; BEGIN QUOTED STRING
	jz	S3E
	cmp	al,"'"
	jnz	S7
S3E:	mov	word ptr [si],OFFSET S4
	mov	[INQ],al
S3ret:	ret

IFDEF JAPAN
s3f:
	mov	new_mode,1
	jmp	short s3ret
ENDIF


;	ENTER QUOTED STRINGS


S4:	cmp	al,[INQ]		; CHECK FOR STRING TERMINATOR
	jnz	S4A
	dec	PRMCNT			; TERMINATE STRING
	mov	word ptr [si],OFFSET S3
	ret

S4A:	call	GETPTR
	mov	byte ptr [bx],al
	mov	word ptr [si],OFFSET S4
	jmp	S3A

;	LOOK FOR ANSI COMMAND SPECIFIED IN AL


	PUBLIC	S7
S7:	mov	bx,OFFSET CMDTABL-3

S7A:	add	bx,3
	cmp	byte ptr [bx],0
	jz	S1B
	cmp	byte ptr [bx],al
	jnz	S7A

S7B:	mov	ax,word ptr [bx+1]	; AX = JUMP addRESS
	mov	bx,OFFSET BUF
	inc	bx
	add	bx,ASNPTR		; BX = PTR TO PARM LIST
	mov	DL,byte ptr [bx]
	xor	DH,DH			; DX = FIRST PARAMETER
	mov	cx,dx
	or	cx,cx
	jnz	S7C
	inc	cx			; CX = DX, CX=1 IF DX=0
S7C:	jmp	ax			; AL = COMMAND

S1:	cmp	al,ESC_CHAR		; ESCAPE SEQUENCE?
	jnz	S1B
IFDEF	DBCS
	mov	dbcs_flag,0
ENDIF
IFDEF	JAPAN
	mov	new_mode,0
ENDIF
	mov	word ptr [si],OFFSET S2
	ret

S1B:

ifndef  KOREA                           ; IN KOREA, WE ALREADY handled
IFDEF DBCS
	cmp	dbcs_flag,1
	jz	set_dbcs		; if it was lead byte
	cmp	dbcs_flag,2
	jnz	@f			; if it was not tail byte
	mov	dbcs_flag,0		; reset
@@:
	call	IsDBCSLeadByte
	jnz	@f			; if this is not lead byte
set_dbcs:
	inc	dbcs_flag
@@:
	cmp	dbcs_flag,1
	jnz	@f
	mov	dl,col
	cmp	dl,maxcol
	jnz	@f
	push	ax
	mov	al,' '
	call	chrout
	pop	ax
@@:
ENDIF
endif   ; NOT KOREA

	call	CHROUT
S1A:	mov	word ptr [STATE],OFFSET S1
	ret

ifdef   KOREA
S8:     cmp     al, ')'
        jnz     s1
        mov     word ptr [si], offset S9
        ret
S9:     cmp     al, '1'
        jnz     S1
han_on:
        mov     ah, 0f2h
        mov     al, 08h                 ; Hangeul input mode on
        int     16h
        ret

S10:    cmp     al, '2'
        jnz     S1
han_off:
        mov     ah, 0f2h
        mov     al, 00h
        int     16h
        ret
endif   ; KOREA

MOVCUR:					;C02
	cmp	byte ptr [bx],AH
	jz	SETCUR
	add	byte ptr [bx],al
	loop	MOVCUR
SETCUR: mov	dx,word ptr COL
;*C05	xor	bx,bx
	mov	ah,0fh			;*C05
	int	10h			;*C05
	mov	ah,2
	int	16
	jmp	S1A

CUP:
					
IFDEF	JAPAN				; ### if JAPAN ###
	cmp	GRAPHICS_FLAG,GRAPHICS_MODE
	jnz	tmplab17		; if not graphic mode
	mov	ah,DEFAULT_LENGTH
	jmp	short tmplab18
tmplab17:
	mov	ah,byte ptr [REQ_TXT_LENGTH]
tmplab18:
	sub	ah,row_adj
	cmp	cl,ah
ELSE
	cmp	GRAPHICS_FLAG,GRAPHICS_MODE
	jnz	tmplab17
	cmp	cl,DEFAULT_LENGTH
	jmp	short tmplab18
tmplab17:
	cmp	cl,byte ptr [REQ_TXT_LENGTH]
tmplab18:
ENDIF					; ### end if JAPAN ###

	ja	SETCUR
	mov	al,MAXCOL
	mov	ch,byte ptr [bx+1]
	or	ch,CH
	jz	CUP1
	dec	CH
CUP1:	cmp	al,CH
	ja	CUP2
	mov	ch,al
CUP2:	xchg	cl,CH
	dec	CH
	mov	word ptr COL,cx
	jmp	SETCUR

CUF:	mov	ah,MAXCOL
	mov	al,1
CUF1:	mov	bx,OFFSET COL
	jmp	MOVCUR

CUB:	mov	ax,00FFH
	jmp	CUF1

CUU:	mov	ax,00FFH
CUU1:	mov	bx,OFFSET ROW
	jmp	MOVCUR

CUD:
	cmp	GRAPHICS_FLAG,GRAPHICS_MODE
	jnz	tmplab19
	mov	ah,DEFAULT_LENGTH
	jmp	short tmplab20
tmplab19:
	mov	ah,byte ptr [REQ_TXT_LENGTH]
	dec	ah			; M005; REQ_TXT_LENGTH is not 0 based
tmplab20:
IFDEF JAPAN
	sub	ah,row_adj
ENDIF
	mov	al,1
	jmp	CUU1

ExtKey:
	cmp	dl, 0			; DL = previous parameter
	jne	ExtKey_1
	mov	Switch_X, OFF		; reset it if 0.
	jmp	S1A
ExtKey_1:
	cmp	dl, 1			; 1 ?
	je	SetExtKey
	jmp	S1A			; ignore it
SetExtKey:
	mov	Switch_X, ON		; set it if 1.
	jmp	S1A

PSCP:	mov	ax,word ptr COL
	mov	SAVCR,ax
	jmp	SETCUR

PRCP:	mov	ax,SAVCR
	mov	word ptr COL,ax
	jmp	SETCUR

SGR:	xor	cx,cx
	xchg	cl,PRMCNT
	call	GETPTR
	inc	cx
SGR1:	mov	al,byte ptr [bx]
	push	bx
	mov	bx,OFFSET GRMODE
SGR2:	mov	ah,byte ptr [bx]
	add	bx,3
	cmp	ah,0FFH
	jz	SGR3
	cmp	ah,al
	jnz	SGR2
	mov	ax,word ptr [bx-2]
	and	ATTR,al
	or	ATTR,AH
SGR3:	pop	bx
	inc	bx
	loop	SGR1
	jmp	SETCUR

IFDEF JAPAN				; ### if JAPAN ###
ED:
	mov	bl,dl			; save function no.
	mov	dh,30
	mov	al,MODE
	cmp	al,11h
	je	ed20			; if graphic 640X480
	cmp	al,12h
	je	ed20			; if graphic 640X480
	cmp	GRAPHICS_FLAG,GRAPHICS_MODE
	jnz	ed10			; if not graphic mode
	mov	dh,DEFAULT_LENGTH
	jmp	short ed20
ed10:
	mov	dh,byte ptr [REQ_TXT_LENGTH]
ed20:
	sub	dh,row_adj
	dec	dh			; last row
	mov	dl,MAXCOL
	xor	cx,cx
	cmp	bl,0
	jz	ed_func0
	cmp	bl,1
	jz	ed_func1
	mov	word ptr COL,cx		; ESC[2J
	jmp	short ed_30
ed_func0:				; ESC[0J
	push	dx
	mov	cx,word ptr COL
	mov	dh,ch
	mov	dl,MAXCOL
	call	erase			; erase to eol
	pop	dx
	mov	ch,ROW
	cmp	ch,dh
	jz	ed_end			; if at bottom
	inc	ch
	mov	cl,0
	jmp	short ed_30
ed_func1:				; ESC[1J
	mov	dx,word ptr COL
	mov	ch,dh
	mov	cl,0
	call	erase			; erase from top
	mov	dh,ROW
	cmp	dh,0
	jz	ed_end
	dec	dh
	mov	dl,MAXCOL
	xor	cx,cx
ed_30:
	call	erase
ed_end:
	jmp	setcur

EL:
	cmp	dl,1
	jz	el_func1
	cmp	dl,2
	jz	el_func2
	mov	cx,word ptr COL		; ESC[0K
	mov	dh,ch
	mov	dl,MAXCOL
	jmp	short el_10
el_func1:
	mov	dx,word ptr COL		; ESC[1K
	mov	ch,dh
	mov	cl,0
	jmp	short el_10
el_func2:
	mov	ch,ROW			; ESC[2K
	mov	dh,ch
	mov	cl,0
	mov	dl,MAXCOL
el_10:
	call	erase
	jmp	setcur

erase:
	cmp	GRAPHICS_FLAG,GRAPHICS_MODE	; if we are in graphics mode,
	jnz	erase10
	xor	bh,bh			; then use 0 as attribute
	jmp	short erase20
erase10:
	mov	bh,ATTR			; else use ATTR
erase20:
	mov	ax,0600H		; clear
	int	10h
	ret

else					; ### if Not JAPAN ###

ED:	xor	cx,cx
	mov	word ptr COL,cx
	mov	DH,30
	mov	al,MODE
	cmp	al,11H
	je	ERASE
	cmp	al,12H
	je	ERASE

	cmp	GRAPHICS_FLAG,GRAPHICS_MODE
	jnz	tmplab21
	mov	dh,DEFAULT_LENGTH
	jmp	short tmplab22
tmplab21:
	mov	dh,byte ptr [REQ_TXT_LENGTH]
tmplab22:
ERASE:	mov	DL,MAXCOL

	cmp	GRAPHICS_FLAG,GRAPHICS_MODE	; if we are in graphics mode,
	jnz	tmplab23
	xor	bh,bh			;	then use 0 as attribute
	jmp	short tmplab24
tmplab23:
	mov	bh,ATTR			;	else use ATTR
tmplab24:
	mov	ax,0600H
	int	16
ED3:	jmp	SETCUR

EL:	mov	cx,word ptr COL
	mov	DH,CH
	jmp	ERASE

ENDIF					; ### end if Not JAPAN ###

IFDEF JAPAN				; ### if JAPAN ###
delete:
	mov	ah,6			; scroll up
	jmp	short insdel
insert:
	mov	ah,7			; scroll down
insdel:
	mov	al,cl			; set scroll number
	mov	COL,0			; set to top of row
	mov	cx,word ptr COL
	cmp	GRAPHICS_FLAG,GRAPHICS_MODE
	jnz	line10			; if not graphic mode
	mov	dh,DEFAULT_LENGTH
	xor	bh,bh			; attribute
	jmp	short line20
line10:
	mov	bh,ATTR
	mov	dh,byte ptr [REQ_TXT_LENGTH]
line20:
	sub	dh,row_adj
	dec	dh
	mov	dl,MAXCOL
	int	10h			; scroll
	jmp	setcur
ENDIF					; ### end if JAPAN ###

BIN2ASC:mov	DL,10
	inc	AL
	xor	ah,AH
	div	dl
	add	ax,'00'
	ret
DSR:	mov	ah,REQ_CRSR_POS
	push	bx
	xor	bh,bh
	int	10h
	pop	bx
	push	dx
	mov	al,dh			;REPORT CURRENT CURSOR POSITION
	call	BIN2ASC
	mov	word ptr REPORT+2,ax
	pop	dx
	mov	al,DL
	call	BIN2ASC
	mov	word ptr REPORT+5,ax
	mov	[KEYCNT],9
	mov	[KEYPTR],OFFSET REPORT
CPR:	jmp	S1A

RM:	mov	cl,1
	jmp	SHORT SM1

SM:	xor	cx,cx
SM1:	mov	al,DL

IFDEF JAPAN
	cmp	new_mode,1
	jz	nmode
ENDIF

	cmp	al,MODE7		;	if mode isn't (0-6, 13-19)
	jl	tmplab25		;	then skip	(cas -- signed?)
	cmp	al,MODE13
	jl	tmplab26
	cmp	al,MODE19
	jg	tmplab26

tmplab25:
	test	HDWR_FLAG,LCD_ACTIVE	; is this the LCD?
	jz	tmplab25a		; skip if not

	push	ds			; WGR yes...
	push	ax			; WGR save mode
	mov	ax,ROM_BIOS
	mov	ds,ax			; WGR get equipment status flag..
	mov	ax,DS:[EQUIP_FLAG]
	and	ax,INIT_VID_MASK	; WGR clear initial video bits..
	or	ax,LCD_COLOR_MODE	; WGR .....set bits as color
	mov	ds:[EQUIP_FLAG],ax 	; WGR replace updated flag.
	pop	ax			; WGR restore mode.
	pop	ds

tmplab25a:

	mov	ah,SET_MODE		; WGR yes....set mode..
	int	10H
	jmp	short tmplab27

tmplab26:
	cmp	al,7			; then if 7, wrap at EOL
	jnz	tmplab27
	mov	[WRAP],CL		; WGR yes....wrap...
tmplab27:
	jmp	CPR

IFDEF JAPAN				; ### if JAPAN ###
nmode:
	mov	new_mode,0
	cmp	al,1
	jz	row_mode		; set row mode
	cmp	al,5
	jz	cur_mode		; set cursor mode
	jmp	cpr
row_mode:
	mov	row_adj,0
	jcxz	row_mode_ret		; if set mode
	cmp	GRAPHICS_FLAG,GRAPHICS_MODE
	jnz	row_mode10		; if not graphic mode
	mov	ah,DEFAULT_LENGTH
	jmp	short row_mode20
row_mode10:
	mov	ah,byte ptr [REQ_TXT_LENGTH]
row_mode20:
	dec	ah
	cmp	row,ah
	jb	row_mode_30		; if cursor not at bottom row
	dec	row
	call	scroll
row_mode_30:
	inc	row_adj
row_mode_ret:
	jmp	cpr
cur_mode:
	push	cx
	mov	ah,3			; get cursor
	mov	bh,bpage
	int	10h
	pop	ax
	or	ax,ax
	jz	cur_mode10		; if for cursor off
	and	ch,11011111b		; cursor on
	jmp	short cur_mode20
cur_mode10:
	or	ch,00100000b		; corsor off
cur_mode20:
	mov	ah,1			; set cursor
	int	10h
	jmp	cpr
ENDIF					; ### end if JAPAN ###

KEYASN: xor	dx,dx
	xchg	DL,PRMCNT		;GET CHARACTER COUNT
	inc	dx
	inc	dx

	call	GETPTR
	mov	ax,word ptr [bx]	;GET CHARACTER TO BE ASSIGNED
	call	SCAN			;LOOK IT UP
	jnz	KEYAS1

	mov	di,bx			;DELETE OLD DEFINITION
	sub	ASNPTR,cx
	mov	KEYCNT,0		; This delete code shuffles the
					; key definition table all around.
					; This will cause all sorts of trouble
					; if we are in the middle of expanding
					; one of the definitions being shuffled.
					; So shut off the expansion.
	mov	si,di
	add	si,cx
	mov	cx,OFFSET BUF+ASNMAX
	sub	cx,si
	cld
	push	es			; SAVE USER'S ES
	push	CS
	pop	es			; SET UP ES addRESSABILITY
	rep	movsb
	pop	es			; RESTORE ES

KEYAS1: call	GETPTR
	cmp	DL,3
	jb	KEYAS3
	mov	byte ptr [bx-1],DL	; SET LENGTH
	add	ASNPTR,dx		; REMEMBER END OF LIST
	add	bx,dx
	cmp	ASNPTR,ASNMAX		; Too much???
	jb	KEYAS3			; No
	sub	bx,dx			; Next three instructions undo the above
	sub	ASNPTR,dx
KEYAS3: mov	byte ptr [bx-1],00
	mov	STATE,OFFSET S1		; RETURN
	ret

GETPTR: mov	bx,ASNPTR
	inc	bx
	add	bx,PRMCNTW
	cmp	bx,ASNMAX + 8
	jb	GET1
	dec	PRMCNT
	jmp	GETPTR
GET1:	add	bx,OFFSET BUF
	ret




; CHECK_FOR_REMAP:

; This function esnures that the keypacket
; passed to it in AX is mapped to a standard INT16h call



CHECK_FOR_REMAP PROC NEAR
	cmp	al,0e0h			; extended key?
	jnz	tmplab28

ifdef   KOREA
        cmp     ah, 0f0h
        jb      mschtmp
        cmp     ah, 0f2h
        jbe     tmplab28
mschtmp:
endif   ; KOREA

	or	ah,ah			; probably, but check for alpha character
	jz	tmplab28
	xor	al,al			; if not an alpha, map extended to standard
tmplab28:
	ret
CHECK_FOR_REMAP ENDP

IFDEF DBCS

;	Test if the character is DBCS Lead Byte

;	input:	AL = character to check
;	outpit:	ZF = 1 if DBCS Lead Byte

	public	DBCSLeadByteTable
DBCSLeadByteTable	dd	0

IsDBCSLeadByte		proc	near
	push	ax
	push	si
	push	ds
	lds	si,cs:DBCSLeadByteTable
idlb_check:
	cmp	word ptr [si],0
	jz	idlb_not		; if end of table
	cmp	al,[si]
	jb	idlb_next		; if below low value
	cmp	al,[si+1]
	jbe	idlb_yes		; if below high value
idlb_next:
	add	si,2			; do next
	jmp	short idlb_check
idlb_not:
	or	al,1			; reset ZF
	jmp	short idlb_end
idlb_yes:
	and	al,0			; set ZF
idlb_end:
	pop	ds
	pop	si
	pop	ax
	ret
IsDBCSLeadByte		endp
ENDIF


BUF	DB	4,00,72H,16,0
	DB	ASNMAX+8-5 DUP (?)

CODE	ENDS
	END

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dev\ansi\ansivid.inc ===
VGA_TABLE	   LABEL BYTE
    MODE_TABLE	 < 1, 1,, 16,  -1,  -1, 40, -1> ; mode	1 Ä¿ To give preference
    MODE_TABLE	 < 0, 1,, 16,  -1,  -1, 40, -1> ; mode	0   of COxx over
    MODE_TABLE	 < 3, 1,, 16,  -1,  -1, 80, -1> ; mode	3   BWxx.
    MODE_TABLE	 < 2, 1,, 16,  -1,  -1, 80, -1> ; mode	2 	(see text)
    MODE_TABLE	 < 7, 1,,  0,  -1,  -1, 80, -1> ; mode	7
    MODE_TABLE	 <13, 2,, 16, 320, 200, 40, 25> ; mode 13
    MODE_TABLE	 <14, 2,, 16, 640, 200, 80, 25> ; mode 14
    MODE_TABLE	 <15, 2,,  0, 640, 350, 80, 25> ; mode 15
    MODE_TABLE	 <16, 2,, 16, 640, 350, 80, 25> ; mode 16
    MODE_TABLE	 <17, 2,,  2, 640, 480, 80, 30> ; mode 17
    MODE_TABLE	 <18, 2,, 16, 640, 480, 80, 30> ; mode 18
    MODE_TABLE	 <19, 2,,256, 320, 200, 40, 25> ; mode 19
VGA_NUM 	 EQU  ($ - VGA_TABLE)/(TYPE MODE_TABLE)

MCGA_TABLE	   LABEL BYTE
    MODE_TABLE	 <17, 2,,  2, 640, 480, 80, 30> ; mode 17
    MODE_TABLE	 <19, 2,,256, 320, 200, 40, 25> ; mode 19
MCGA_NUM	 EQU  ($ - MCGA_TABLE)/(TYPE MODE_TABLE)

EGA_5154_TABLE	   LABEL BYTE
    MODE_TABLE	 < 1, 1,, 16,  -1,  -1, 40, 43> ; mode	1 Ä¿ To give preference
    MODE_TABLE	 < 0, 1,, 16,  -1,  -1, 40, 43> ; mode	0   of COxx over
    MODE_TABLE	 < 3, 1,, 16,  -1,  -1, 80, 43> ; mode	3   BWxx.
    MODE_TABLE	 < 2, 1,, 16,  -1,  -1, 80, 43> ; mode	2 	(see text)
    MODE_TABLE	 <13, 2,, 16, 320, 200, 40, 25> ; mode 13
    MODE_TABLE	 <14, 2,, 16, 640, 200, 80, 25> ; mode 14
    MODE_TABLE	 <16, 2,, 16, 640, 350, 80, 25> ; mode 16
EGA_5154_NUM	 EQU  ($ - EGA_5154_TABLE)/(TYPE MODE_TABLE)

EGA_5153_TABLE	   LABEL BYTE
    MODE_TABLE	 <13, 2,, 16, 320, 200, 40, 25> ; mode 13
    MODE_TABLE	 <14, 2,, 16, 640, 200, 80, 25> ; mode 14
EGA_5153_NUM	 EQU  ($ - EGA_5153_TABLE)/(TYPE MODE_TABLE)

EGA_5151_TABLE	   LABEL BYTE
    MODE_TABLE	 < 7, 1,,  0,  -1,  -1, 80, 43> ; mode	7
    MODE_TABLE	 <15, 2,,  0, 640, 350, 80, 25> ; mode 15
EGA_5151_NUM	 EQU  ($ - EGA_5151_TABLE)/(TYPE MODE_TABLE)

MONO_TABLE	   LABEL BYTE
    MODE_TABLE	 < 7, 1,,  0,  -1,  -1, 80, 25> ; mode	7
MONO_NUM	 EQU  ($ - MONO_TABLE)/(TYPE MODE_TABLE)

COLOR_TABLE	   LABEL BYTE
    MODE_TABLE	 < 1, 1,, 16,  -1,  -1, 40, 25> ; mode	1 Ä¿ To give preference
    MODE_TABLE	 < 0, 1,, 16,  -1,  -1, 40, 25> ; mode	0   of COxx over
    MODE_TABLE	 < 3, 1,, 16,  -1,  -1, 80, 25> ; mode	3   BWxx.
    MODE_TABLE	 < 2, 1,, 16,  -1,  -1, 80, 25> ; mode	2 	(see text)
    MODE_TABLE	 < 4, 2,,  4, 320, 200, 40, 25> ; mode	4
    MODE_TABLE	 < 5, 2,,  2, 320, 200, 40, 25> ; mode	5
    MODE_TABLE	 < 6, 2,,  2, 640, 200, 80, 25> ; mode	6
COLOR_NUM	 EQU  ($ - COLOR_TABLE)/(TYPE MODE_TABLE)

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dev\ansi\parser.asm ===
PAGE	    ,132
TITLE	    PARSE CODE AND CONTROL BLOCKS FOR ANSI.SYS

;****************** START OF SPECIFICATIONS **************************

;  MODULE NAME: PARSER.ASM

;  DESCRIPTIVE NAME: PARSES THE DEVICE= STATEMENT IN CONFIG.SYS FOR
;		     ANSI.SYS

;  FUNCTION: THE COMMAND LINE PASSED TO ANSI.SYS IN THE CONFIG.SYS
;	     STATEMENT IS PARSED TO CHECK FOR THE /X SWITCH. A FLAG
;	     IS CLEARED IF NOT FOUND.

;  ENTRY POINT: PARSE_PARM

;  INPUT: DS:SI POINTS TO EVERYTHING AFTER DEVICE=

;  AT EXIT:
;     NORMAL: SWITCH FLAGS WILL BE SET IF /X or /L IS FOUND

;     ERROR: CARRY SET

;  INTERNAL REFERENCES:

;     ROUTINES: SYSLOADMSG - MESSAGE RETRIEVER LOADING CODE
;		SYSDISPMSG - MESSAGE RETRIEVER DISPLAYING CODE
;		PARM_ERROR - DISPLAYS ERROR MESSAGE
;		SYSPARSE - PARSING CODE

;     DATA AREAS: PARMS - PARSE CONTROL BLOCK FOR SYSPARSE

;  EXTERNAL REFERENCES:

;     ROUTINES: N/A

;     DATA AREAS: SWITCH - BYTE FLAG FOR EXISTENCE OF SWITCH PARAMETER

;  NOTES:

;  REVISION HISTORY:
;	    A000 - DOS Version 4.00

;      Label: "DOS ANSI.SYS Device Driver"
;	      "Version 4.00 (C) Copyright 1988 Microsoft"
;	      "Licensed Material - Program Property of Microsoft"

;****************** END OF SPECIFICATIONS ****************************
;Modification history**********************************************************
; P1529 ANSI /x /y gives wrong error message		   10/8/87 J.K.
; D397  /L option for "Enforcing" the line number            12/17/87 J.K.
; D479  An option to disable the extended keyboard functions 02/12/88 J.K.
;******************************************************************************


INCLUDE     ANSI.INC	    ; ANSI equates and structures
.XLIST
INCLUDE     SYSMSG.INC	    ; Message retriever code
MSG_UTILNAME <ANSI>	    ; Let message retriever know its ANSI.SYS
.LIST

PUBLIC	    PARSE_PARM	     ; near procedure for parsing DEVICE= statement



; Set assemble switches for parse code that is not required!!



DateSW	      EQU     0
TimeSW	      EQU     0
CmpxSW	      EQU     0
DrvSW	      EQU     0
QusSW	      EQU     0
NumSW	      EQU     0
KeySW	      EQU     0
Val1SW	      EQU     0
Val2SW	      EQU     0
Val3SW	      EQU     0


CODE	      SEGMENT  PUBLIC BYTE
	      ASSUME CS:CODE

.XLIST
MSG_SERVICES <MSGDATA>
MSG_SERVICES <DISPLAYmsg,LOADmsg,CHARmsg>
MSG_SERVICES <ANSI.CL1>
MSG_SERVICES <ANSI.CL2>
MSG_SERVICES <ANSI.CLA>

INCLUDE     VERSION.INC
INCLUDE     PARSE.ASM       ; Parsing code
.LIST


EXTRN	    SWITCH_X:BYTE	 ; /X switch flag
extrn	    Switch_L:Byte	 ; /L switch flag
extrn	    Switch_K:Byte	 ; /K switch flag
extrn	    Switch_S:Byte	 ; M008 ; /S or /SCREENSIZE switch flag	
extrn       SWITCH_R:Byte        ; /R switch flag


; PARM control blocks for ANSI
; Parsing DEVICE= statment from CONFIG.SYS

; DEVICE=[d:][path]ANSI.SYS [/X] [/K] [/L] [/R] [/S | /SCREENSIZE] ; M008



PARMS	       LABEL WORD
	       DW	PARMSX
	       DB	0		   ; no extra delimeters or EOLs.

PARMSX	       LABEL BYTE
	       DB	1,1		   ; 1 valid positional operand
	       DW	FILENAME	   ; filename
	       DB	1		   ; 1 switche definition in the following
	       DW	Switches
	       DB	0		   ; no keywords

FILENAME       LABEL WORD
	       DW	0200H		   ; file spec
	       DW	0001H		   ; cap by file table
	       DW	RESULT_BUF	   ; result
	       DW	NOVALS		   ; no value checking done
	       DB	0		   ; no switch/keyword synonyms

Switches       LABEL WORD
	       DW	0		   ; switch with no value
	       DW	0		   ; no functions
	       DW	RESULT_BUF	   ; result
	       DW	NOVALS		   ; no value checking done
	       DB	6		   ;AN003; M008; 6 switch synonym
X_SWITCH       DB	"/X",0             ; /X name
L_SWITCH       DB	"/L",0             ; /L
K_SWITCH       DB	"/K",0             ; /K
SSIZE_SWITCH   DB	"/SCREENSIZE",0    ; M008; /SCREENSIZE
S_SWITCH       DB	"/S",0             ; M008; /S
R_SWITCH       DB       "/R",0

NOVALS	       LABEL BYTE
	       DB	0		   ; no value checking done

RESULT_BUF     LABEL BYTE
	       DB	?		   ; type returned (number, string, etc.)
	       DB	?		   ; matched item tag (if applicable)
SYNONYM_PTR    DW	0		   ; synonym ptr (if applicable)
	       DD	?		   ; value

SUBLIST        LABEL DWORD		   ; list for substitution
	       DB	SUB_SIZE
	       DB	0
	       DD	?
	       DB	1
	       DB	LEFT_ASCIIZ
	       DB	UNLIMITED
	       DB	1
	       DB	" "

Old_SI		dw	?
Saved_Chr	db	0
Continue_Flag	db	ON
Parse_Err_Flag	db	OFF



; PROCEDURE_NAME: PARSE_PARM

; FUNCTION:
; THIS PROCEDURE PARSES THE DEVICE= PARAMETERS FROM THE INIT REQUEST
; BLOCK. ERROR MESSAGES ARE DISPLAYED ACCORDINGLY.

; AT ENTRY: DS:SI POINTS TO EVERYTHING AFTER THE DEVICE= STATEMENT

; AT EXIT:
;    NORMAL: CARRY CLEAR - SWITCH FLAG BYTE SET TO 1 IF /X FOUND

;    ERROR: CARRY SET



PARSE_PARM    PROC     NEAR
	      CALL     SYSLOADMSG		; load message

	jnc	plab01

		CALL	 SYSDISPMSG		; display error message
		STC				; ensure carry still set

	jmp	plab02

plab01:
		PUSH	 CS			; establish ES ..
		POP	 ES			; addressability to data
		LEA	 DI,PARMS		; point to PARMS control block
		XOR	 CX,CX			; clear both CX and DX for
		XOR	 DX,DX			;  SYSPARSE
		CALL	 SYSPARSE		; move pointer past file spec
		mov	 Switch_L, OFF
		mov	 Switch_X, OFF

while01:
	cmp	Continue_Flag,ON
	jz	plab_bogus		; M008; bogus label to avoid jmp
	jmp	while01_end		; M008; out of short range.

plab_bogus:				; M008

	mov Old_SI, SI		;to be use by PARM_ERROR
	call SysParse

	cmp	ax,RC_EOL
	jnz	plab09

	mov Continue_Flag, OFF
	jmp	short while01

plab09:

	cmp	ax,RC_NO_ERROR
	jz	plab07

	   mov Continue_Flag, OFF
	   mov Switch_X, OFF
	   mov Switch_L, OFF
	   mov Switch_K, OFF
           mov Switch_R, OFF
	   call Parm_Error
	   mov Parse_Err_Flag,ON

	jmp	short while01

plab07:

	cmp	Synonym_ptr,offset X_SWITCH
	jnz	plab06

	mov	Switch_X,ON
	jmp	short plab04

plab06:

	cmp	Synonym_ptr,offset R_SWITCH
	jnz	plab05

	mov	Switch_R,ON
	jmp	short plab04

plab05:
	cmp	Synonym_ptr,offset L_SWITCH
	jnz	plab03

	mov	Switch_L,ON
	jmp	short plab04

plab03:						; M008
	cmp	Synonym_ptr, offset S_SWITCH	; M008
	jnz	plab11				; M008

plab12:						; M008
	mov	Switch_S,ON			; M008
	jmp	short plab04			; M008
						
plab11:						; M008
	cmp	Synonym_ptr, offset SSIZE_SWITCH; M008
	jz	plab12				; M008

	mov	Switch_K,ON		; must be /K

plab04:
	clc

	jmp	while01

while01_end:

	cmp	Parse_Err_Flag,ON
	jnz	plab10

	stc
	jmp	short plab02

plab10:
	clc

plab02:

	      RET
PARSE_PARM    ENDP




; PROCEDURE_NAME: PARM_ERROR

; FUNCTION:
; LOADS AND DISPLAYS "Invalid parameter" MESSAGE

; AT ENTRY:
;   DS:Old_SI -> parms that is invalid

; AT EXIT:
;    NORMAL: ERROR MESSAGE DISPLAYED

;    ERROR: N/A



PARM_ERROR    PROC   NEAR
	      PUSH   CX
	      PUSH   SI
	      PUSH   ES
	      PUSH   DS

;	       PUSH   CS
;	       POP    DS		 ; establish addressability
;	       MOV    BX,DX
;	       LES    DX,[BX].RES_PTR	 ; find offending parameter
	       push   ds
	       pop    es
	       mov    si, cs:Old_SI	;Now es:dx -> offending parms
	       push   si		;Save it
Get_CR:
	       cmp    byte ptr es:[si], 13 ;CR?
	       je     Got_CR
	       inc    si
	       jmp    Get_CR
Got_CR:
	       inc    si		   ; The next char.
	       mov    al, byte ptr es:[si]
	       mov    cs:Saved_Chr, al	   ; Save the next char

	       mov    byte ptr es:[si], 0     ; and make it an ASCIIZ
	       mov    cs:Old_SI, si	; Set it again
	       pop    dx		; saved SI -> DX

	       push   cs
	       pop    ds		;for addressability

	      LEA    SI,SUBLIST 	; ..and place the offset..
	      MOV    [SI].SUB_PTR_O,DX	; ..in the SUBLIST..
	      MOV    [SI].SUB_PTR_S,ES
	      MOV    AX,INVALID_PARM	; load 'Invalid parameter' message number
	      MOV    BX,STDERR		; to standard error
	      MOV    CX,ONE		; 1 substitution
	      XOR    DL,DL		; no input
	      MOV    DH,UTILITY_MSG_CLASS ; parse error
	      CALL   SYSDISPMSG 	; display error message
	      mov    si, cs:Old_SI	;restore the original char.
	      mov    cl, cs:Saved_Chr
	      mov    byte ptr es:[si], cl

	      POP    DS
	      POP    ES
	      POP    SI
	      POP    CX
	      RET
PARM_ERROR    ENDP

include msgdcl.inc

CODE	      ENDS
	      END

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dev\ansi\ioctl.asm ===
PAGE	,132
TITLE	ANSI Generic IOCTL Code

;******************************************************************************

;  Change Log:

;    Date    Who   #			  Description
;  --------  ---  ---  ------------------------------------------------------

;  06/29/90  MKS  C04  Bug#1150.  Video 7 Fastwrite VGA has problems if a
;		       Hercules mono board is the active display.

;******************************************************************************

;****************** START OF SPECIFICATIONS **************************

;  MODULE NAME: IOCTL.ASM

;  DESCRIPTIVE NAME: PERFORM THE GENERIC IOCTL CALL IN ANSI.SYS

;  FUNCTION: THE GENERIC DEVICE IOCTL IS USED TO SET AND GET THE
;	     MODE OF THE DISPLAY DEVICE ACCORDING TO PARAMETERS PASSED
;	     IN A BUFFER. ADDITIONALLY, THE CALL CAN TOGGLE THE
;	     USE OF THE INTENSITY BIT, AND CAN LOAD THE 8X8 CHARACTER
;	     SET, EFFECTIVELY GIVING MORE LINES PER SCREEN. THE
;	     AVAILABILITY OF THIS FUNCTION VARIES STRONGLY WITH HARDWARE
;	     ATTACHED.

;  ENTRY POINT: GENERIC_IOCTL

;  INPUT: LOCATION OF REQUEST PACKET STORED DURING STRATEGY CALL.

;  AT EXIT:
;     NORMAL: CARRY CLEAR - DEVICE CHARACTERISTICS SET

;     ERROR: CARRY SET - ERROR CODE IN AX.
;	     AX = 1  - INVALID FUNCTION. EXTENDED ERROR = 20
;	     AX = 10 - UNSUPPORTED FUNCTION ON CURRENT HARDWARE.
;			EXTENDED ERROR = 29
;	     AX = 12 - DISPLAY.SYS DOES NOT HAVE 8X8 RAM CHARACTER SET.
;			EXTENDED ERROR = 31

;  INTERNAL REFERENCES:

;     ROUTINES: GET_IOCTL - PERFORMS THE GET DEVICE CHARACTERISTICS
;		SET_IOCTL - PERFORMS THE SET DEVICE CHARACTERISTICS
;		GET_SEARCH - SEARCHES THE INTERNAL VIDEO TABLE FOR THE
;			     CURRENT MODE MATCH
;		SET_SEARCH - SEARCHES THE INTERNAL VIDEO TABEL FOR THE
;			     CURRENT MODE MATCH
;		SET_CURSOR_EMUL - SETS THE BIT THAT CONTROLS CURSOR EMULATION
;		INT10_COM - INTERRUPT 10H HANDLER TO KEEP CURRENT SCREEN SIZE
;		INT2F_COM - INTERRUPT 2FH INTERFACE TO GENERIC IOCTL
;		MAP_DOWN - PERFORMS CURSOR TYPE MAPPING FOR EGA WITH MONOCHROME
;		SET_VIDEO_MODE - SETS THE VIDEO MODE

;     DATA AREAS: SCAN_LINE_TABLE - HOLDS SCAN LINE INFORMATION FOR PS/2
;		  FUNC_INFO - BUFFER FOR PS/2 FUNCTIONALITY CALL.


;  EXTERNAL REFERENCES:

;     ROUTINES: INT 10H SERVICES

;     DATA AREAS: VIDEO_MODE_TABLE - INTERNAL TABLE FOR CHARACTERISTICS TO MODE
;				     MATCH-UPS

;  NOTES:

;  REVISION HISTORY:

;      Label: "DOS ANSI.SYS Device Driver"
;	      "Version 4.00 (C) Copyright 1988 Microsoft"
;	      "Licensed Material - Program Property of Microsoft"

;****************** END OF SPECIFICATIONS ****************************
;Modification history *********************************************************
; P1350 Codepage switching not working on EGA		   10/10/87 J.K.
; P1626 ANSI does not allow lines=43 with PS2,Monochrome	   10/15/87 J.K.
; p1774 Lines=43 after selecting cp 850 does not work	   10/20/87 J.K.
; p1740 MODE CON LINES command causes problem with PE2 w PS/210/24/87 J.K.
; p2167 Does'nt say EGA in medium resol. cannot do 43 lines  10/30/87 J.K.
; p2236 After esc [=0h, issuing INT10h,AH=fh returns mode=1. 11/3/87  J.K.
; p2305 With ANSI loaded, loading RDTE hangs the system	   11/06/87 J.K.
; P2617 Order dependecy problem with Display.sys		   11/23/87 J.K.
; p2716 HOT key of VITTORIA does not work properly	   12/03/87 J.K.
; d398  /L option for Enforcing the number of lines	   12/17/87 J.K.
; D425 For OS2 compatibiltiy box, /L option status query	   01/14/88 J.K.
; P5699 Moving selecting alternate print screen routine to only when it
; 10/26/88    is needed.  OEM EGA cards don't support the call it, so they
; K. Sayers   couldn't (shift) print screen at all when the alt. routine was
;	      invoked during initialization.
;******************************************************************************

INCLUDE		DEVSYM.INC
INCLUDE		ANSI.INC
INCLUDE		MULT.INC

PUBLIC		GENERIC_IOCTL
PUBLIC		SET_IOCTL
PUBLIC		GET_IOCTL
PUBLIC		SET_SEARCH
PUBLIC		GET_SEARCH
PUBLIC		SET_CURSOR_EMUL
PUBLIC		FUNC_INFO
PUBLIC		MAX_SCANS
PUBLIC		INT10_COM
PUBLIC		SET_MODE_HANDLER
PUBLIC		SET_CURSOR_HANDLER
PUBLIC		ROM_INT10
PUBLIC		INT2F_COM
PUBLIC		INT2F_HANDLER
PUBLIC		ROM_INT2F
PUBLIC		ABORT
PUBLIC		MAP_DOWN
PUBLIC		SET_VIDEO_MODE
PUBLIC		REQ_TXT_LENGTH
PUBLIC		GRAPHICS_FLAG
PUBLIC		DO_ROWS
PUBLIC		Display_Loaded_Before_Me

CODE		SEGMENT  PUBLIC  BYTE
		ASSUME CS:CODE,DS:CODE

EXTRN		PTRSAV:DWORD
EXTRN		NO_OPERATION:NEAR
EXTRN		ERR1:NEAR
EXTRN		VIDEO_MODE_TABLE:BYTE
EXTRN		MAX_VIDEO_TAB_NUM:ABS
EXTRN		HDWR_FLAG:WORD
EXTRN		SCAN_LINES:BYTE
EXTRN		SWITCH_L:Byte			;Defined in ANSI.ASM

IFDEF		JAPAN
EXTRN		row_adj:byte
ENDIF

SCAN_LINE_TABLE	LABEL	BYTE
		SCAN_LINE_STR <200,000000001B,0>	; 200 scan lines
		SCAN_LINE_STR <344,000000010B,1>	; 350 scan lines
		SCAN_LINE_STR <400,000000100B,2>	; 400 scan lines
SCANS_AVAILABLE	EQU	($ - SCAN_LINE_TABLE)/TYPE SCAN_LINE_STR

;This is used when ANSI calls Get_IOCTL, Set_IOCTL by itself.
In_Generic_IOCTL_flag	db	0
I_AM_IN_NOW		EQU	00000001b
SET_MODE_BY_DISPLAY	EQU	00000010b	;Display.sys calls Set mode INT 10h.
CALLED_BY_INT10COM	EQU	00000100b	;To prevent from calling set mode int 10h again.

INT10_V_Mode		db	0ffh		;Used by INT10_COM

My_IOCTL_Req_Packet	REQ_PCKT <0,0,0Eh,0,?,0,?,?,?,?,?>

FUNC_INFO		INFO_BLOCK <>		;data block for functionality call
ROM_INT10		DW	?		;segment and offset of original..
			DW	?		;interrupt 10h vector.
ROM_INT2F		DW	?		;segment and offset of original..
			DW	?		;interrupt 2Fh vector.
INTENSITY_FLAG		DW	OFF		;intensity flag initially off
REQ_TXT_LENGTH		DW	DEFAULT_LENGTH	;requested text screen length
SCAN_DESIRED		DB	0		;scan lines desired
MAX_SCANS		DB	0		;maximum scan line setting
GRAPHICS_FLAG		DB	TEXT_MODE	;flag for graphics mode
Display_Loaded_Before_Me db	0		;flag
ANSI_SetMode_Call_Flag	db	0		;Ansi is issuing INT10,AH=0.
ALT_PRT_SC_INVOKED	DB	FALSE		;indicates that have already set up alternat print screen routine



; PROCEDURE_NAME: GENERIC_IOCTL

; FUNCTION:
; TO GET OR SET DEVICE CHARACTERISTICS ACCORDING TO THE BUFFER PASSED
; IN THE REQUEST PACKET.

; AT ENTRY:

; AT EXIT:
;	NORMAL: CARRY CLEAR - DEVICE CHARACTERISTICS SET

;	ERROR: CARRY SET - ERROR CODE IN AL. (SEE MODULE DESCRIPTION ABOVE).

; NOTE: THIS PROC IS PERFORMED AS A JMP AS WITH THE OLD ANSI CALLS.



GENERIC_IOCTL:
	les	bx,[PTRSAV]			; establish addressability to request header
	mov	al,es:[bx].MINORFUNCTION
	les	di,es:[bx].GENERICIOCTL_PACKET	; point to request packet

	cmp	al,GET_FUNC			; is this get subfunction?
	jnz	gi_not_get

	call	GET_IOCTL			; yes...execute routine

	jmp	short gi_check_error

gi_not_get:
	cmp	al,SET_FUNC			; is this the set subfunction?
	jnz	gi_none

	call	SET_IOCTL			; yes....execute routine

gi_check_error:
	jnc	gi_done				; branch if no error
	or	ax,CMD_ERROR			; yes...set error bit in status

gi_done:
	or	ax,DONE				; add done bit to status
	jmp	ERR1				; return with status in ax

gi_none:
	jmp	NO_OPERATION			; call lower CON device


; PROCEDURE_NAME: GET_IOCTL

; FUNCTION:
; THIS PROCEDURE RETURNS DEVICE CHARACTERISTICS.

; AT ENTRY: ES:DI POINTS TO REQUEST BUFFER

; AT EXIT:
;	NORMAL: CARRY CLEAR - REQUEST BUFFER CONTAINS DEVICE CHARACTERISTICS

;	ERROR: CARRY SET - ERROR CONDITION IN AX



GET_IOCTL	PROC	NEAR

	cmp	es:[di].INFO_LEVEL,0		; check for valid info level
	jnz	gi_invalid
	cmp	es:[di].DATA_LENGTH,TYPE MODE_TABLE+1 ; and buffer size
	jge	gi_valid

gi_invalid:
	mov	ax,INVALID_FUNC			; not valid...unsupported
	stc					; function..set error flag and
	ret

gi_valid:
	mov	es:[di].INFO_LEVEL+1,0		; set reserved byte to 0.
	mov	ah,REQ_VID_MODE			; request current video mode
	int	10H
	and	al,VIDEO_MASK
	lea	si,VIDEO_MODE_TABLE		; point to resident video table
	call	GET_SEARCH			; perform search
	jnc	gi_supported			; found?

	mov	ax,NOT_SUPPORTED		; no....load unsupported function
	ret					; carry already set

gi_supported:
	push	di				;Save Request Buffer pointer
	mov	WORD PTR es:[di].DATA_LENGTH,(TYPE MODE_TABLE)+1 ;length of data is struc size
	inc	si				; skip mode value
	add	di,RP_FLAGS			; point to flag word

;	VGA,MCGA: VALUE RETURNED FROM FUNCTIONALITY CALL
;	EGA: VALUE LAST SET THROUGH IOCTL. DEFAULT IS BLINKING.
;	CGA,MONO: BLINKING

	cmp	al,7				; M004; Monochrome screen?
	mov	ax,OFF				; assume CGA,MONO 
						; (we always have blink).
	jz	gi_flags_done			; M004;

	cmp	HDWR_FLAG,MCGA_ACTIVE		; if we have an EGA or better
	jl	gi_flags_done

	test	HDWR_FLAG,VGA_ACTIVE		; VGA supported?
	jz	gi_as_intensity_flag

	push	es				; yes...prepare for
	push	di				; functionality call

	push	ds
	pop	es
	lea	di,FUNC_INFO			; point to data block
	mov	ah,FUNC_CALL			; load function number
	xor	bx,bx				; implementation type 0
	int	10H

	mov	INTENSITY_FLAG,OFF		; assume no intensity
	test	es:[di].MISC_INFO,INT_BIT	; is blink bit set?
	jnz	gi_intensity_is_fine		; if not no intensity

	inc	INTENSITY_FLAG			; we want intensity

gi_intensity_is_fine:
	pop	di				; restore registers
	pop	es

gi_as_intensity_flag:
	mov	ax,INTENSITY_FLAG		; write the control flag..

gi_flags_done:
	stosw					; write the control flag..
						; point to next field (display)
	mov	cx,(TYPE MODE_TABLE)-1		; load count
	rep	movsb				; transfer data from video table
						; to request packet
	sub	si,TYPE MODE_TABLE		; point back to start of mode data

ifdef JAPAN
	dec	di				; point to number of rows
	dec	di
ENDIF

	cmp	[si].D_MODE,TEXT_MODE		; if we are in text mode and
	jnz	gi_row_counted
	cmp	[si].SCR_ROWS,DEFAULT_LENGTH	; length <> 25 then we have an EGA or VGA
	jz	gi_row_counted

ifndef JAPAN
	dec	di				; point back to length entry in req packet
	dec	di
ENDIF
	push	ds
	mov	ax,ROM_BIOS			; load ROM BIOS data area segment
	mov	ds,ax
	mov	al,BYTE PTR ds:[NUM_ROWS]	; load current number of rows
	cbw
	inc	ax				; add 1 to row count
	mov	WORD PTR es:[di],ax		; and copy to request packet
	pop	ds

gi_row_counted:

ifdef JAPAN
	mov	al,row_adj
	xor	ah,ah
	sub	es:[di],ax			; support ESC[>1l
ENDIF

	xor	ax,ax				; no errors
	clc					; clear error flag
	pop	di				; Restore Request Buffer pointer
	ret					; return to calling module

GET_IOCTL	ENDP




; PROCEDURE_NAME: SET_IOCTL

; FUNCTION:
; THIS PROCEDURE SETS THE VIDEO MODE AND CHARACTER SET ACCORDING
; TO THE CHARACTERSTICS PROVIDED.

; AT ENTRY:
;	ES:[DI] POINTS TO REQUEST BUFFER

; AT EXIT:
;	NORMAL: CLEAR CARRY - VIDEO MODE SET

;	ERROR: CARRY SET - ERROR CONDITION IN AX



SET_IOCTL	PROC	NEAR

	or	In_Generic_IOCTL_Flag, I_AM_IN_NOW	; Signal GENERIC_IOCTL request being processed
	push	REQ_TXT_LENGTH			; save old value in case of error

	cmp	es:[di].INFO_LEVEL,0		; check for valid info level
	jnz	si_invalid
	cmp	es:[di].DATA_LENGTH,TYPE MODE_TABLE+1 ; ane buffer size
	jnz	si_invalid
	mov	ax,es:[di].RP_FLAGS		; test for invalid flags
	test	ax,INVALID_FLAGS
	jnz	si_invalid
	test	es:[di].RP_FLAGS,ON		; if intensity is requested and..
	jz	si_valid
	cmp	HDWR_FLAG,MCGA_ACTIVE		; hardware does not support it
	jge	si_valid

si_invalid:
	mov	ax,INVALID_FUNC			; not valid...unsupported..
	jmp	si_failed

si_valid:
	call	SET_SEARCH			; search table for match
	jnc	si_mode_valid

si_not_supp:
	jmp	si_not_supported

si_mode_valid:
	cmp	[si].D_MODE,TEXT_MODE		; is a text mode being requested?
	jz	si_do_text_mode

	call	SET_VIDEO_MODE
	jmp	si_end_ok	

si_do_text_mode:
	mov	ax,es:[di].RP_ROWS		; save new requested value.
	mov	REQ_TXT_LENGTH,ax

	cmp	ax,DEFAULT_LENGTH		; is it just 25 lines needed?
	jz	si_display_ok

	mov	ax,DISPLAY_CHECK
	int	2FH

	cmp	al,INSTALLED			; or is DISPLAY.SYS not there?
	jnz	si_display_ok

	mov	ax,CHECK_FOR_FONT
	int	2FH				; or if it is does it have the..
	jnc	si_display_ok

	mov	ax,NOT_AVAILABLE		; DISPLAY.SYS does not have the font
	jmp	si_failed
	
si_display_ok:
	cmp	[si].SCR_ROWS,UNOCCUPIED
	jz	si_is_vga
	test	HDWR_FLAG,VGA_ACTIVE
	jz	si_non_vga

si_is_vga:
	mov	ax,1A00h			;Get currently active adap.;C04
	int	10h				;VGA interrupt             ;C04
	mov	ax,REQ_TXT_LENGTH		; restore AX
	cmp	bl,7				;Q: non_vga adapter?	   ;C04
	jb	si_non_vga			;Yes so do other stuff	   ;C04

process_vga:
	mov	cl,3				; ax loaded with length requested
	shl	ax,cl				; mulitply by 8 to get scan lines
	lea	bx,SCAN_LINE_TABLE		; load bx with scan line table start
	mov	cx,SCANS_AVAILABLE		; total number of scan lines settings

pv_while:
	cmp	ax,[bx].NUM_LINES		; pointing at the right setting?
	jz	pv_found

	add	bx,TYPE SCAN_LINE_STR		; not this setting..point to next
	loop	pv_while
	
	jmp	short si_not_supp

pv_found:
	mov	dl,[bx].REP_1BH

	test	SCAN_LINES,dl			; does the hardware have it?
	jz	si_not_supp

	mov	cl,[bx].REP_12H			; yes, store value to set it
	mov	SCAN_DESIRED,cl

	cmp	REQ_TXT_LENGTH,DEFAULT_LENGTH	; 25 lines requested?
	jnz	pv_scan_ok

	mov	al,MAX_SCANS			; desired scan setting should be..
	mov	SCAN_DESIRED,AL			; the maximum.

pv_scan_ok:

; following added to overcome problems with rolling
; screens in QBX and WZMAIL.	Problem still exists when switching between
; mono and VGA screens when ANSI is loaded with /L.

	test	In_Generic_IOCTL_Flag,CALLED_BY_INT10COM
	jnz	si_set_mode_done

	mov	ah,ALT_SELECT			; set the appropriate number..
	mov	bl,SELECT_SCAN			; of scan lines..
	mov	al,SCAN_DESIRED
	int	10H

	jmp	short si_processed

si_non_vga:
	mov	ax,REQ_TXT_LENGTH
	cmp	ax,DEFAULT_LENGTH		; see if length requested..
	jz	si_cursor_emul			; is valid
	cmp	ax,[si].SCR_ROWS
	jnz	si_not_supported

si_cursor_emul:
	call	SET_CURSOR_EMUL

si_processed:
	call	SET_VIDEO_MODE

si_set_mode_done:
	call	DO_ROWS
	cmp	ALT_PRT_SC_INVOKED,FALSE	; If not set up already
	jnz	si_printscreen_ok
	cmp	es:[di].RP_ROWS,DEFAULT_LENGTH	; and needed because lines	(or 30?)
	jle	si_printscreen_ok
	cmp	HDWR_FLAG,MCGA_ACTIVE		; and if we have EGA or better then.. (supported)
	jl	si_printscreen_ok

	mov	ah,ALT_SELECT			; issue select alternate print..
	mov	BL,ALT_PRT_SC			; screen routine call..
	int	10H
	mov	ALT_PRT_SC_INVOKED,TRUE		; mark that it was done

si_printscreen_ok:
	call	SET_CURSOR_EMUL			; yes..ensure cursor emulation
						; is set accordingly.
	cmp	HDWR_FLAG,MCGA_ACTIVE		; for the EGA and better...
	jl	si_end_ok

	cmp	[si].V_MODE,7			; M004; and not monochrome
	jz	si_end_ok

	xor	bx,bx				; bx: 1=intensity on, 0: off
						; assume off
	test	es:[di].RP_FLAGS,ON		
	jz	si_intensity_ok

	inc	bx				; user wants intensity

si_intensity_ok:
	mov	INTENSITY_FLAG,bx
	mov	ax,BLINK_TOGGLE
	xor	bl,ON				; bl is opposite
						; of INTENSITY_FLAG
	int	10H

si_end_ok:
	and	In_Generic_IOCTL_Flag, NOT I_AM_IN_NOW	; Turn the flag off
	pop	ax				; forget old REQ_TXT_LENGTH
	xor	ax,ax				; clear error register
	clc					; clear error flag
	ret

si_not_supported:
	mov	ax,NOT_SUPPORTED

si_failed:
	and	In_Generic_IOCTL_Flag, NOT I_AM_IN_NOW	; Turn the flag off
	pop	REQ_TXT_LENGTH			; error...so restore old value.
	stc					; set error flag
	ret

SET_IOCTL	ENDP



; Procedure name: DO_ROWS
; Function:
;	Only called for TEXT_MODE.
;	If (REQ_TXT_LENGTH <> DEFAULT_LENGTH) &
;	(DISPLAY.SYS not loaded or CODEPAGE not active)
;	then
;	LOAD ROM 8X8 charater.


DO_ROWS		PROC	NEAR

	cmp	req_txt_length, DEFAULT_LENGTH
	je	dr_exit
	mov	ax,LOAD_8X8 			; load 8x8 ROM font
	xor	bl,bl
	int	10H				; M003;
	mov	ax,SET_BLOCK_0			; activate block = 0
	xor	bl,bl
	int	10H				; M003;
dr_exit:
	ret

DO_ROWS 	ENDP






; PROCEDURE_NAME: SET_SEARCH

; FUNCTION:
; THIS PROCEDURE SEARCHES THE RESIDENT VIDEO TABLE IN ATTEMPT TO
; FIND A MODE THAT MATCHES THE CHARACTERISTICS REQUESTED.

; AT ENTRY:

; AT EXIT:
;	NORMAL: CARRY CLEAR - SI POINTS TO APPLICABLE RECORD

;	ERROR: CARRY SET

; When INT10_V_Mode <> 0FFH, then assumes that the user
;	issuing INT10h, Set mode function call.	Unlike Generic IOCTL
;	set mode call, the user already has taken care of the video mode.
;	So, we also find the matching V_MODE.

; WARNING: TRASH CX

SET_SEARCH	PROC	NEAR

	lea	si,VIDEO_MODE_TABLE		; point to video table
	mov	cx,MAX_VIDEO_TAB_NUM 		; load counter, # of tables

ss_while:
	cmp	[si].V_MODE,UNOCCUPIED		; while we have valid entries
	jz	ss_not_found

	mov	al,INT10_V_Mode

	cmp	al,0ffh				; if not issued by Int10 set mode,
	jnz	ss_from_set_mode

	
	mov	al,es:[di].RP_MODE		; load register for compare.
	cmp	[si].D_MODE,al			; match?
	jnz	ss_end_while

	mov	ax,es:[di].RP_COLORS		; yes...prepare next field
	cmp	[si].COLORS,ax			; match?
	jnz	ss_end_while

	cmp	es:[di].RESERVED2,0		; yes, ensure reserved byte is zero
	jnz	ss_end_while

	cmp	es:[di].RP_MODE,GRAPHICS_MODE	; for graphics mode
	jnz	ss_not_graphic			; check the following:

	mov	ax,es:[di].RP_WIDTH		; screen width.
	cmp	[si].SCR_WIDTH,ax
	jnz	ss_end_while

	mov	ax,es:[di].RP_LENGTH		; screen length
	cmp	[si].SCR_LENGTH,ax
	jnz	ss_end_while			; ignore #rows and #coloumns

	jmp	short ss_found

ss_not_graphic:
	mov	ax,es:[di].RP_COLS		; the rows are matched
	cmp	[si].SCR_COLS,ax		; in the main routine
	jnz	ss_end_while

ss_found:
	clc
	jmp	short ss_done

ss_from_set_mode:
	cmp	[si].V_MODE,al			; if V_MODE = AL, we are ok
	jz	ss_found

ss_end_while:
	add	si,type MODE_TABLE		; then, this is not the correct entry.
	loop	ss_while			; Let's find the next entry.

ss_not_found:
	stc

ss_done:
	mov	INT10_V_Mode, 0FFh		; Done. Reset the value
	ret

SET_SEARCH	ENDP




; PROCEDURE_NAME: GET_SEARCH

; FUNCTION:
; THIS PROCEDURE SEARCHES THE VIDEO TABLE LOOKING FOR A MATCHING
; VIDEO MODE.

; AT ENTRY: DS:SI POINTS TO VIDEO TABLE
;		AL CONTAINS THE MODE REQUESTED

; AT EXIT:
;	NORMAL: CARRY CLEAR, DS:SI POINTS TO MATCHING RECORD

;	ERROR: CARRY SET

; WARNING: TRASH CX

GET_SEARCH	PROC	NEAR

	mov	cx,MAX_VIDEO_TAB_NUM		; # of total tables

gs_while:
	cmp	[si].V_MODE,UNOCCUPIED		; while we're not pointing to
	jz	gs_error
	cmp	[si].V_MODE,al			; the right mode and we are still
	jz	gs_got_it

	add	si,TYPE MODE_TABLE		; point to the next mode
	loop	gs_while

gs_error:
	stc					; no, set error flag
	ret

gs_got_it:
	clc
	ret

GET_SEARCH	ENDP



; PROCEDURE_NAME: SET_CURSOR_EMUL

; FUNCTION:
; THIS PROCEDURE SETS THE CURSOR EMULATION BIT OFF IN ROM BIOS. THIS
; IS TO PROVIDE A CURSOR ON THE EGA WITH THE 5154 LOADED WITH AN 8X8
; CHARACTER SET.

; AT ENTRY:

; AT EXIT:
;	NORMAL: CURSOR EMULATION BIT SET FOR APPLICABLE HARDWARE

;	ERROR: N/A



SET_CURSOR_EMUL PROC	NEAR

	test	HDWR_FLAG,E5154_ACTIVE		; EGA with 5154?
	jz	sce_done

	push	si
	push	ds				; yes..so..
	mov	ax,ROM_BIOS			; check cursor emulation..
	mov	ds,ax
	mov	si,CURSOR_FLAG
	mov	al,BYTE PTR [si]

	cmp	cs:REQ_TXT_LENGTH,DEFAULT_LENGTH; >25 lines req?
	jnz	sce_cursor_on

	and	al,TURN_OFF			; no....set it OFF

	jmp	short sce_cursor_ok

sce_cursor_on:
	or	al,TURN_ON			; yes...set it ON

sce_cursor_ok:
	mov	BYTE PTR [si],AL
	pop	ds
	pop	si

sce_done:
	ret					; return to calling module

SET_CURSOR_EMUL	ENDP




; PROCEDURE_NAME: INT10_COM

; FUNCTION:
; THIS IS THE INTERRUPT 10H HANDLER TO CAPTURE THE FOLLOWING FUNCTIONS:

;	AH=1H (SET CURSOR TYPE). CURSOR EMULATION IS PERFORMED IF WE HAVE
;		AND EGA WITH A 5151 MONITOR, AND 43 LINES IS REQUESTED.

;M002; What is bellow was modified. The /L option was removed. But ansi
;M002; will still do a GET_IOCTL/SET_IOCTL for the application.
;	AH=0H (SET MODE) SCREEN LENGTH IS MAINTAINED WHEN POSSIBLE. (IE. IN
;		TEXT MODES ONLY.)
;	AN004; Capturing Set Mode call and enforcing the # of Rows based on the
;		previous Set_IOCTL request lines was a design mistake.	ANSI cannot
;		covers the all the application program out there which use INT 10h
;		directly to make a full screen interface by their own way.
;		This part of logic has been taken out by the management decision.
;		Instead, for each set mdoe INT 10h function call, if it were not
;		issued by SET_IOCTL procedures itself, or by DISPLAY.SYS program,
;		then we assume that it was issued by an APPS, that usually does not
;		know the new ANSI GET_IOCTL/SET_IOCTL interfaces.
;		In this case, ANSI is going to call GET_IOCTL and SET_IOCTL function
;		call - This is not to lose the local data consistency in ANSI.

; AT ENTRY:

; AT EXIT:
;	NORMAL:

;	ERROR:



INT10_COM	PROC	NEAR

	sti 					; restore interrupts
	cmp	ah,SET_CURSOR_CALL
	jz	SET_CURSOR_HANDLER
	cmp	ah,SET_MODE
	jz	SET_MODE_HANDLER

	jmp	DWORD PTR cs:ROM_INT10		; no...pass it on.

SET_CURSOR_HANDLER:
	push	ax

	test	cs:HDWR_FLAG,E5151_ACTIVE	; do we have an EGA?
	jz	sch_goto_rom
	cmp	cs:REQ_TXT_LENGTH,DEFAULT_LENGTH
	jz	sch_goto_rom
	cmp	cs:GRAPHICS_FLAG,TEXT_MODE	; with 5151..so perform cursor mapping
	jnz	sch_goto_rom
	cmp	cl,8
	jl	sch_goto_rom

	mov	al,ch				; check for cursor..
	and	al,60h				; off emulation. J.K.

	cmp	al,20h
	jz	sch_goto_rom

	mov	al,ch				; start position for cursor
	call	MAP_DOWN
	mov	ch,al
	mov	al,cl				; end position for cursor
	call	MAP_DOWN
	mov	cl,al

sch_goto_rom:
	pop	ax
	jmp	DWORD PTR CS:ROM_INT10		; continue interrupt processing

SET_MODE_HANDLER:
	pushf					; prepare for IRET
	mov	cs:ANSI_SetMode_Call_Flag, 1	; Used by INT2F_COM
	call	DWORD PTR CS:ROM_INT10		; call INT10 routine
	mov	cs:ANSI_SetMode_Call_Flag, 0	; Reset it
	push	bp
	push	es
	push	ds
	push	si
	push	di
	push	dx
	push	cx
	push	bx
	push	ax
	push	cs
	pop	ds
	mov	ah,REQ_VID_MODE			; get current mode..
	pushf
	call	DWORD PTR ROM_INT10
	and	al,VIDEO_MASK			; mask bit 7 (refresh)
	test	In_Generic_IOCTL_Flag, (I_AM_IN_NOW + SET_MODE_BY_DISPLAY)	; Flag is on?
;If not (I_AM_IN_NOW or SET_MODE_BY_DISPLAY),

	jnz	smh_ioctl_done

;	cmp	SWITCH_L,0			;M002; No more /L
;	jnz	smh_ioctl_done			;M002; No more /L

	push	ax				;Save mode
	push	es
	push	cs
	pop	es
	mov	di,offset My_IOCTL_Req_Packet
	mov	INT10_V_Mode,al			;Save current mode for SET_SEARCH
	call	Get_IOCTL

	jc	smh_set_ioctl_done

	or	In_Generic_IOCTL_Flag, CALLED_BY_INT10COM ;Do not set mode INT 10h again. Already done.
	call	Set_IOCTL
	and	In_Generic_IOCTL_Flag, not CALLED_BY_INT10COM

smh_set_ioctl_done:

	pop	es
	pop	ax				;Restore mode
	mov	INT10_V_Mode,0FFh


smh_ioctl_done:

	lea	si,VIDEO_MODE_TABLE
	call	GET_SEARCH 			; look through table for mode selected.
	jc	smh_graphic_mode		; M001; if not found then
						; M001; assume graphic mode

	cmp	[si].D_MODE,TEXT_MODE		; text mode?
	jz	smh_text_mode

smh_graphic_mode:
	mov	GRAPHICS_FLAG,GRAPHICS_MODE	; no, set graphics flag
	jmp	short smh_flag_done

smh_text_mode:
	mov	GRAPHICS_FLAG,TEXT_MODE		; set TEXT MODE


smh_flag_done:

;	test	In_Generic_IOCTL_Flag, I_AM_IN_NOW
;	jnz	smh_l_done			; M002; No more /L
;	cmp	Graphics_Flag,TEXT_MODE		; M002; No more /L
;	jnz	smh_l_done			; M002; No more /L
;	cmp	SWITCH_L,1			; M002; No more /L
;	jnz	smh_l_done			; M002; No more /L

;	call	DO_ROWS				; M002; No more /L

smh_l_done:

;For each SET mode function int 10h function call, if it is not
;issued by ANSI GET_IOCTL and SET_IOCTL procedure themselves, we assume
;that the APPS, which usually does not know the ANSI GET_IOCTL/SET_IOCTL
;interfaces, intend to change the screen mode.	In this case, ANSI is
;kind enough to call GET_IOCTL and SET_IOCTL function call for themselves.

	pop	ax
	pop	bx
	pop	cx
	pop	dx
	pop	di
	pop	si
	pop	ds
	pop	es
	pop	bp
	iret

INT10_COM	ENDP




; PROCEDURE_NAME: INT2F_COM

; FUNCTION:
; THIS IS THE INTERRUPT 2FH HANDLER TO CAPTURE THE FOLLOWING FUNCTIONS:

;	ax=1A00H INSTALL REQUEST. ANSI WILL RETURN AL=FFH IF LOADED.

;	AH=1A01H THIS IS THE INT2FH INTERFACE TO THE GENERIC IOCTL.
;	NOTE: THE GET CHARACTERISTICS FUNCTION CALL WILL RETURN
;		THE REQ_TXT_LENGTH IN THE BUFFER AS OPPOSED TO
;		THE ACTUAL HARDWARE SCREEN_LENGTH
;	Ax=1A02h This is an information passing from DISPLAY.SYS about
;		the INT 10h, SET MODE call.

; AT ENTRY:

; AT EXIT:
;	NORMAL:

;	ERROR:



INT2F_COM	PROC	NEAR

	sti
	cmp	ah,multANSI			; is this for ANSI?
	jnz	ic_goto_rom
	cmp	al,DA_INFO_2F
	jle	INT2F_HANDLER

ic_goto_rom:
	jmp	DWORD PTR CS:ROM_INT2F		; no....jump to old INT2F

INT2F_HANDLER:

	cmp	al,INSTALL_CHECK
	jnz	ih_not_check

;	do install check

	mov	al,INSTALLED			; load value to indicate installed
	clc					; clear error flag.
	jmp	ih_iret

ih_not_check:
	cmp	al,DA_INFO_2F			; IOCTL or INFO passing?
	jbe	ih_valid
	jmp	ih_iret

ih_valid:
	push	bp
	push	ax				; s
	push	cx				; a
	push	dx				; v
	push	ds				; e	r
	push	es				;	e
	push	di				;	g
	push	si				;	s.
	push	bx
	push	ds				; load ES with DS (for call)
	pop	es
	mov	di,dx				; load DI with dx (for call)
	push	cs				; setup local addressability
	pop	ds

	cmp	al,IOCTL_2F			; IOCTL request
	jnz	ih_not_ioctl

	cmp	cl,GET_FUNC			; get function requested.
	jnz	ih_not_get

	call	GET_IOCTL

	jc	ih_set_flags			; if no error and
	cmp	HDWR_FLAG,E5151_ACTIVE		; >25 lines supported
	jl	ih_set_flags
	cmp	[si].D_MODE,TEXT_MODE		; this is a text mode then..
	jnz	ih_set_flags


;	cmp	SWITCH_L,1			; M002; No more /L
;	jz	ih_use_rtl			; M002; No more /L

	cmp	ANSI_SetMode_Call_Flag,1
	jnz	ih_use_rtl			; if not originated by ANSI thru AH=0, Int10
	cmp	Display_Loaded_Before_me,1	; or Display.sys not loaded before ANSI,
	jz	ih_get_ok

ih_use_rtl:
	mov	bx,REQ_TXT_LENGTH		; then use REQ_TXT_LENGTH instead..
	mov	es:[di].RP_ROWS,bx

ih_get_ok:
	clc
	jmp	short ih_set_flags

ih_not_get:
	cmp	cl,SET_FUNC
	jnz	ih_invalid

	call	SET_IOCTL			; set function requested.

	jmp	short ih_set_flags

;	invalid function

ih_invalid:
	mov	ax,INVALID_FUNC			; load error and...
	stc 					; set error flag.
	jmp	short ih_set_flags		; Info. passing

ih_not_ioctl:
	cmp	es:[di].DA_INFO_LEVEL,0		; 0 - DA_SETMODE_FLAG request
	jnz	ih_not_info


	cmp	es:[di].DA_SETMODE_FLAG,1
	jnz	ih_not_set

	or	In_Generic_IOCTL_Flag, SET_MODE_BY_DISPLAY	;Turn the flag on
	jmp	short ih_info_ok

ih_not_set:
	and	In_Generic_IOCTL_Flag, not SET_MODE_BY_DISPLAY	;Turn the flag off

	jmp	short ih_info_ok

ih_not_info:

	cmp	es:[di].DA_INFO_LEVEL,1		; 1 = DA_L_STATA query
	jnz	ih_info_ok

;	mov	al,cs:[SWITCH_L]		; M002; No more /L
	mov	al,OFF				; M002; No more /L

	mov	es:[di].DA_L_STATE, al

ih_info_ok:
	clc					; clear carry. There is no Error in DOS 4.00 for this call.

ih_set_flags:
	pop	bx				; restore all..
	pop	si
	pop	di				;	registers except..
	pop	es
	pop	ds				;	BP.
	pop	dx
	pop	cx
	push	ax				; save error condition
	mov	bp,sp				; setup frame pointer
	mov	ax,[bp+10]			; load stack flags
	jc	ih_error			; carry set???

	and	ax,NOT_CY			; no.. set carry off.
	mov	[bp+10],ax			; put back on stack.
	pop	ax				; remove error flag from stack
	pop	ax				; no error so bring back function call
	XCHG	ah,al				; exchange to show that ANSI present
	jmp	short ih_pop_bp

ih_error:
	or	ax,CY				; yes...set carry on.
	mov	[bp+10],ax			; put back on stack.
	pop	ax				; restore error flag
	pop	bp				; pop off saved value of ax (destroyed)

ih_pop_bp:
	pop	bp				; restore final register.
ih_iret:
ABORT:	iret

INT2F_COM	ENDP




; PROCEDURE_NAME: MAP_DOWN

; FUNCTION:
; THIS PROCEDURE MAPS THE CURSOR START (END) POSITION FROM A 14 PEL
; BOX SIZE TO AN 8 PEL BOX SIZE.

; AT ENTRY: AL HAS THE CURSOR START (END) TO BE MAPPED.

; AT EXIT:
;	NORMAL: AL CONTAINS THE MAPPED POSITION FOR CURSOR START (END)

;	ERROR: N/A



MAP_DOWN	PROC	NEAR

	push	bx
	xor	ah,ah 			; clear upper byte of cursor position
	mov	bl,EIGHT		; multiply by current box size.
	push	dx			;	al	x
	mul	bl			;	---- = ---
	pop	dx			;	14	8
	mov	bl,FOURTEEN
	div	bl			; divide by box size expected.
	pop	bx
	ret

MAP_DOWN	ENDP




; PROCEDURE_NAME: SET_VIDEO_MODE

; FUNCTION:
; THIS PROCEDURE SETS THE VIDEO MODE SPECIFIED IN DS:[SI].V_MODE.

; AT ENTRY: DS:SI.V_MODE CONTAINS MODE NUMBER

; AT EXIT:
;	NORMAL: MODE SET

;	ERROR: N/A



SET_VIDEO_MODE PROC	NEAR

	test	In_Generic_IOCTL_Flag,CALLED_BY_INT10COM
	jnz	svm_done

	mov	al,[si].V_MODE			; ..issue set mode

	test	HDWR_FLAG,LCD_ACTIVE
	jnz	svm_update_bios			; is this the LCD?
	test	HDWR_FLAG,VGA_ACTIVE		; or VGA? (done for BRECON card)
	jz	svm_update_done

svm_update_bios:
	push	ds				; yes...
	mov	bl,al				; save mode
	mov	ax,ROM_BIOS
	mov	ds,ax				; get equipment status flag..
	mov	ax,ds:[EQUIP_FLAG]
	and	ax,INIT_VID_MASK		; clear initial video bits..

	cmp	bl,MODE7			; are we setting mono?
	jz	svm_mono
	cmp	bl,MODE15
	jnz	svm_color

svm_mono:
	or	ax,LCD_MONO_MODE		; yes...set bits as mono
	jmp	short svm_update_it

svm_color:
	or	ax,LCD_COLOR_MODE		; no...set bits as color

svm_update_it:
	mov	ds:[EQUIP_FLAG],ax	 	; replace updated flag.
	mov	al,bl			 	; restore mode.
	pop	ds

svm_update_done:
	mov	ah,SET_MODE			; set mode
	int	10H

svm_done:
	ret

SET_VIDEO_MODE	ENDP

CODE		ENDS
		END
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dev\country\cntry2\country.asm ===
page	84,132
; July 8, 1986 - updated Finland for 437 dcl.
; July 8, 1986 - updated Netherland for 437 dcl.
; July 8, 1986 - updated Italy for 437 dcl.
; July 8, 1986 - updated Canada for 863 dcl.
; July 8, 1986 - updated Belgium for 437 dcl. (except Collate)
; July 8, 1986 - updated AreaSouth for 437 dcl.
; July 8, 1986 - updated Switzerland for 437 dcl.
; July 8, 1986 - updated Norway for 865 dcl.
; July 8, 1986 - updated Denmark for 865 dcl.
; July 14, 1986 - updated Sweden for 437 dcl.
; July 8, 1986 - updated AFE for 850 dcl.
; July 8, 1986 - updated Finland for 850 dcl.
; July 8, 1986 - updated Netherland for 850 dcl.
; July 8, 1986 - updated Canada for 850 dcl.
; July 8, 1986 - updated Italy for 850 dcl.
; July 8, 1986 - updated UK for 850 dcl.
; July 8, 1986 - updated Norway for 850 dcl.
; July 8, 1986 - updated Denmark for 850 dcl.
; July 8, 1986 - updated US for 850 dcl.
; July 8, 1986 - updated Switzerland for 850 dcl.
; July 14, 1986 - updated Sweden for 850 dcl.
; July 14, 1986 - updated Belgium for 850 dcl. (except Collate)
; August 26,1986 - updated Belgium for 437 collate EMG
; August 27,1986 - updated Belgium for 850 collate EMG
; August 27,1986 - updated Area South for 437  EMG
; August 27,1986 - updated Area South for 864  EMG
; August 27,1986 - make all collates 256 bytes	EMG
; August 27,1986 - updated Germany for 850  EMG
; August 27,1986 - updated Spain for 850  EMG
; August 28,1986 - updated Latin America for 850  EMG
; September 12, 1986 - updated SP,IS,CF,AS,PO,LA  EMG
; October 2, 1986 - updated AS and IS  EMG
; July 23,1987	  - DCR to alter Germany collate table to match US 850 DCR037
;		    CNS
; July 23,1987	  - DCR to alter SWISS collate info and ucase table 850 & 437
;		    DCR059--- CNS ***
; July 23,1987	  - DCR to alter Denmark's primary codepage to 850 instead of
;		    865 --- CNS ***
; NOvember 12,1987 - PTM2390 DBCS length of terminating value included for
;		     for DBCS countries
;		   - FILEUPCASE & UCASE swapped for 437 & 850 mapping incorrect
;		   - -ly for DOS 3.3
;		   - Make the FUCASE & UCASE tables equivalent for 850 & 437
; March 9, p3811, Finland to default to 850 now, w/437 as alternate code page
;
; March 30, p4072, LA wants to be same as Spain
; ***CNS
; April 14,1988    Re-adjust LA to match SPAIN which should have 850 as a
;PTM 4389	   default instead of 437 for both countries
;
;	create country.sys file
;
;
	include mkcntry.inc
;
; -----------------------------------------------------------
;
;	Data for COUNTRY.SYS file
;
; -----------------------------------------------------------
dseg	segment para
cdinfo	label	word
	db	0ffh,'COUNTRY'          ; signature
	db	8 dup (0)		; reserved
	dw	PTRCNT			; number of pointers in header
	db	CIPTYPE 		; type = country info pointer
	dd	offset cntryinfo	; pointer to country information
;
cntryinfo label word
cntrycnt=0
	dw	finalCNT		; number of countries
	ctryent <CENTRYSIZE,CID_US,437,,,us437_data>	    ; United States
	ctryent <CENTRYSIZE,CID_US,850,,,us850_data>	    ;
	ctryent <CENTRYSIZE,CID_UK,437,,,uk437_data>	    ; United Kingdom
	ctryent <CENTRYSIZE,CID_UK,850,,,uk850_data>	    ;
	ctryent <CENTRYSIZE,CID_FR,437,,,fr437_data>	    ; France
	ctryent <CENTRYSIZE,CID_FR,850,,,fr850_data>	    ;
	ctryent <CENTRYSIZE,CID_GR,437,,,gr437_data>	    ; Germany
	ctryent <CENTRYSIZE,CID_GR,850,,,gr850_data>	    ;
	ctryent <CENTRYSIZE,CID_SP,850,,,sp850_data>	    ;
	ctryent <CENTRYSIZE,CID_SP,437,,,sp437_data>	    ; Spain
	ctryent <CENTRYSIZE,CID_IT,437,,,it437_data>	    ; Italy
	ctryent <CENTRYSIZE,CID_IT,850,,,it850_data>	    ;
	ctryent <CENTRYSIZE,CID_SV,437,,,sv437_data>	    ; Sweden
	ctryent <CENTRYSIZE,CID_SV,850,,,sv850_data>	    ;
	ctryent <CENTRYSIZE,CID_DK,850,,,dk850_data>	    ; Denmark
	ctryent <CENTRYSIZE,CID_DK,865,,,dk865_data>	    ; DCR060 CNS ***** ;AN000;
	ctryent <CENTRYSIZE,CID_SW,850,,,sw850_data>	    ; Switzerland
	ctryent <CENTRYSIZE,CID_SW,437,,,sw437_data>	    ;
	ctryent <CENTRYSIZE,CID_NO,850,,,no850_data>	    ; Norway
	ctryent <CENTRYSIZE,CID_NO,865,,,no865_data>	    ;
	ctryent <CENTRYSIZE,CID_NL,437,,,nl437_data>	    ; Netherlands
	ctryent <CENTRYSIZE,CID_NL,850,,,nl850_data>	    ;
	ctryent <CENTRYSIZE,CID_BE,850,,,be850_data>	    ; Belgium
	ctryent <CENTRYSIZE,CID_BE,437,,,be437_data>	    ;
	ctryent <CENTRYSIZE,CID_FI,850,,,fi850_data>	    ; Finland p3811, requested 850 default
	ctryent <CENTRYSIZE,CID_FI,437,,,fi437_data>	    ; Finland
	ctryent <CENTRYSIZE,CID_IS,862,,,is862_data>	    ; Israel
	ctryent <CENTRYSIZE,CID_IS,850,,,is850_data>	    ;
	ctryent <CENTRYSIZE,CID_CA,863,,,ca863_data>	    ; Canada French
	ctryent <CENTRYSIZE,CID_CA,850,,,ca850_data>	    ;
	ctryent <CENTRYSIZE,CID_AS,864,,,as864_data>	    ; Area South (Arab States)
	ctryent <CENTRYSIZE,CID_AS,850,,,as850_data>	    ;
	ctryent <CENTRYSIZE,CID_PO,850,,,po850_data>	    ; Portugal
	ctryent <CENTRYSIZE,CID_PO,860,,,po860_data>	    ;
	ctryent <CENTRYSIZE,CID_LA,850,,,la850_data>	    ;
	ctryent <CENTRYSIZE,CID_LA,437,,,la437_data>	    ; Latin America
	ctryent <CENTRYSIZE,CID_AFE,437,,,afe437_data>	    ; International English
	ctryent <CENTRYSIZE,CID_AFE,850,,,afe850_data>	    ;
	ctryent <CENTRYSIZE,CID_JP,932,,,jp932_data>	    ; Japan
	ctryent <CENTRYSIZE,CID_JP,437,,,jp437_data>	    ;
	ctryent <CENTRYSIZE,CID_KO,934,,,ko934_data>	    ; Korea
	ctryent <CENTRYSIZE,CID_KO,437,,,ko437_data>	    ;
	ctryent <CENTRYSIZE,CID_PR,936,,,pr936_data>	    ; PRC
	ctryent <CENTRYSIZE,CID_PR,437,,,pr437_data>	    ;
	ctryent <CENTRYSIZE,CID_TA,938,,,ta938_data>	    ; Taiwan
	ctryent <CENTRYSIZE,CID_TA,437,,,ta437_data>	    ;

;	cs3 -- begin additions of new country data

	 ctryent <CENTRYSIZE,CID_BR,850,,,br850_data>        ; Brazil
	 ctryent <CENTRYSIZE,CID_BR,437,,,br437_data>        ;
         ctryent <CENTRYSIZE,CID_IC,861,,,ic861_data>       ;
         ctryent <CENTRYSIZE,CID_IC,850,,,ic850_data>       ; Iceland
	 ctryent <CENTRYSIZE,CID_TR,850,,,tr850_data>       ; Turkey
	 ctryent <CENTRYSIZE,CID_TR,857,,,tr857_data>       ;
	 ctryent <CENTRYSIZE,CID_YU,852,,,yu852_data>       ; yugoslavia
	 ctryent <CENTRYSIZE,CID_YU,850,,,yu850_data>       ;
	 ctryent <CENTRYSIZE,CID_CS,852,,,cs852_data>       ; czech
	 ctryent <CENTRYSIZE,CID_CS,850,,,cs850_data>       ;
	 ctryent <CENTRYSIZE,CID_PL,852,,,pl852_data>       ; poland
	 ctryent <CENTRYSIZE,CID_PL,850,,,pl850_data>       ;
	 ctryent <CENTRYSIZE,CID_HU,852,,,hu852_data>       ; hungary
	 ctryent <CENTRYSIZE,CID_HU,850,,,hu850_data>       ;

;	cs3 -- end additions


dummy	macro	p
finalCNT	equ	p
	endm
	dummy	%cntrycnt
;
uk437_data label   word
	dw	CDATAITEMS				; number of entries
	ctrydat <CDATASIZE,SETCOUNTRYINFO,,uk437_info>
	ctrydat <CDATASIZE,SETCOLLATE,,uk_collate>
	ctrydat <CDATASIZE,SETUCASE,,uk_ucase>
	ctrydat <CDATASIZE,SETUCASEFILE,,uk_ucase>
	ctrydat <CDATASIZE,SETFILELIST,,uk_flist>
	ctrydat <CDATASIZE,SETDBCS,,uk_dbcs>
;
uk850_data label   word
	dw	CDATAITEMS				; number of entries
	ctrydat <CDATASIZE,SETCOUNTRYINFO,,uk437_info>
	ctrydat <CDATASIZE,SETCOLLATE,,uk850_collate>
	ctrydat <CDATASIZE,SETUCASE,,uk850_ucase>
	ctrydat <CDATASIZE,SETUCASEFILE,,uk850_ucase>
	ctrydat <CDATASIZE,SETFILELIST,,uk_flist>
	ctrydat <CDATASIZE,SETDBCS,,uk_dbcs>
;
fr437_data label   word
	dw	CDATAITEMS				; number of entries
	ctrydat <CDATASIZE,SETCOUNTRYINFO,,fr437_info>
	ctrydat <CDATASIZE,SETCOLLATE,,fr_collate>
	ctrydat <CDATASIZE,SETUCASE,,fr_ucase>
	ctrydat <CDATASIZE,SETUCASEFILE,,fr_ucase>
	ctrydat <CDATASIZE,SETFILELIST,,fr_flist>
	ctrydat <CDATASIZE,SETDBCS,,fr_dbcs>
;
fr850_data label   word
	dw	CDATAITEMS				; number of entries
	ctrydat <CDATASIZE,SETCOUNTRYINFO,,fr437_info>
	ctrydat <CDATASIZE,SETCOLLATE,,fr850_collate>
	ctrydat <CDATASIZE,SETUCASE,,fr850_ucase>
	ctrydat <CDATASIZE,SETUCASEFILE,,fr850_ucase>
	ctrydat <CDATASIZE,SETFILELIST,,fr_flist>
	ctrydat <CDATASIZE,SETDBCS,,fr_dbcs>
;
gr437_data label   word
	dw	CDATAITEMS				; number of entries
	ctrydat <CDATASIZE,SETCOUNTRYINFO,,gr437_info>
	ctrydat <CDATASIZE,SETCOLLATE,,gr_collate>
	ctrydat <CDATASIZE,SETUCASE,,gr_ucase>
	ctrydat <CDATASIZE,SETUCASEFILE,,gr_ucase>
	ctrydat <CDATASIZE,SETFILELIST,,gr_flist>
	ctrydat <CDATASIZE,SETDBCS,,gr_dbcs>
;
gr850_data label   word
	dw	CDATAITEMS				; number of entries
	ctrydat <CDATASIZE,SETCOUNTRYINFO,,gr437_info>
	ctrydat <CDATASIZE,SETCOLLATE,,gr850_collate>
	ctrydat <CDATASIZE,SETUCASE,,gr850_ucase>
	ctrydat <CDATASIZE,SETUCASEFILE,,gr850_ucase>
	ctrydat <CDATASIZE,SETFILELIST,,gr_flist>
	ctrydat <CDATASIZE,SETDBCS,,gr_dbcs>
;
sp437_data label   word
	dw	CDATAITEMS				; number of entries
	ctrydat <CDATASIZE,SETCOUNTRYINFO,,sp437_info>
	ctrydat <CDATASIZE,SETCOLLATE,,sp_collate>
	ctrydat <CDATASIZE,SETUCASE,,sp_ucase>
	ctrydat <CDATASIZE,SETUCASEFILE,,sp_ucase>
	ctrydat <CDATASIZE,SETFILELIST,,sp_flist>
	ctrydat <CDATASIZE,SETDBCS,,sp_dbcs>
;
sp850_data label   word
	dw	CDATAITEMS				; number of entries
	ctrydat <CDATASIZE,SETCOUNTRYINFO,,sp850_info>
	ctrydat <CDATASIZE,SETCOLLATE,,sp850_collate>
	ctrydat <CDATASIZE,SETUCASE,,sp850_ucase>
	ctrydat <CDATASIZE,SETUCASEFILE,,sp850_ucase>
	ctrydat <CDATASIZE,SETFILELIST,,sp_flist>
	ctrydat <CDATASIZE,SETDBCS,,sp_dbcs>
;
it437_data label   word
	dw	CDATAITEMS				; number of entries
	ctrydat <CDATASIZE,SETCOUNTRYINFO,,it437_info>
	ctrydat <CDATASIZE,SETCOLLATE,,it_collate>
	ctrydat <CDATASIZE,SETUCASE,,it_ucase>
	ctrydat <CDATASIZE,SETUCASEFILE,,it_ucase>
	ctrydat <CDATASIZE,SETFILELIST,,it_flist>
	ctrydat <CDATASIZE,SETDBCS,,it_dbcs>
;
it850_data label   word
	dw	CDATAITEMS				; number of entries
	ctrydat <CDATASIZE,SETCOUNTRYINFO,,it437_info>
	ctrydat <CDATASIZE,SETCOLLATE,,it850_collate>
	ctrydat <CDATASIZE,SETUCASE,,it850_ucase>
	ctrydat <CDATASIZE,SETUCASEFILE,,it850_ucase>
	ctrydat <CDATASIZE,SETFILELIST,,it_flist>
	ctrydat <CDATASIZE,SETDBCS,,it_dbcs>
;
sv437_data label   word
	dw	CDATAITEMS				; number of entries
	ctrydat <CDATASIZE,SETCOUNTRYINFO,,sv437_info>
	ctrydat <CDATASIZE,SETCOLLATE,,sv_collate>
	ctrydat <CDATASIZE,SETUCASE,,sv_ucase>
	ctrydat <CDATASIZE,SETUCASEFILE,,sv_ucase>
	ctrydat <CDATASIZE,SETFILELIST,,sv_flist>
	ctrydat <CDATASIZE,SETDBCS,,sv_dbcs>
;
sv850_data label   word
	dw	CDATAITEMS				; number of entries
	ctrydat <CDATASIZE,SETCOUNTRYINFO,,sv437_info>
	ctrydat <CDATASIZE,SETCOLLATE,,sv850_collate>
	ctrydat <CDATASIZE,SETUCASE,,sv850_ucase>
	ctrydat <CDATASIZE,SETUCASEFILE,,sv850_ucase>
	ctrydat <CDATASIZE,SETFILELIST,,sv_flist>
	ctrydat <CDATASIZE,SETDBCS,,sv_dbcs>
;
dk850_data label   word
	dw	CDATAITEMS				; number of entries
	ctrydat <CDATASIZE,SETCOUNTRYINFO,,dk865_info>
	ctrydat <CDATASIZE,SETCOLLATE,,dk850_collate>
	ctrydat <CDATASIZE,SETUCASE,,dk850_ucase>
	ctrydat <CDATASIZE,SETUCASEFILE,,dk850_ucase>
	ctrydat <CDATASIZE,SETFILELIST,,dk_flist>
	ctrydat <CDATASIZE,SETDBCS,,dk_dbcs>
;
dk865_data label   word
	dw	CDATAITEMS				; number of entries
	ctrydat <CDATASIZE,SETCOUNTRYINFO,,dk865_info>
	ctrydat <CDATASIZE,SETCOLLATE,,dk_collate>
	ctrydat <CDATASIZE,SETUCASE,,dk_ucase>
	ctrydat <CDATASIZE,SETUCASEFILE,,dk_ucase>
	ctrydat <CDATASIZE,SETFILELIST,,dk_flist>
	ctrydat <CDATASIZE,SETDBCS,,dk_dbcs>
;
sw437_data label   word
	dw	CDATAITEMS				; number of entries
	ctrydat <CDATASIZE,SETCOUNTRYINFO,,sw437_info>
	ctrydat <CDATASIZE,SETCOLLATE,,sw_collate>
	ctrydat <CDATASIZE,SETUCASE,,sw_ucase>
	ctrydat <CDATASIZE,SETUCASEFILE,,sw_ucase>
	ctrydat <CDATASIZE,SETFILELIST,,sw_flist>
	ctrydat <CDATASIZE,SETDBCS,,sw_dbcs>
;
sw850_data label   word
	dw	CDATAITEMS				; number of entries
	ctrydat <CDATASIZE,SETCOUNTRYINFO,,sw437_info>
	ctrydat <CDATASIZE,SETCOLLATE,,sw850_collate>
	ctrydat <CDATASIZE,SETUCASE,,sw850_ucase>
	ctrydat <CDATASIZE,SETUCASEFILE,,sw850_ucase>
	ctrydat <CDATASIZE,SETFILELIST,,sw_flist>
	ctrydat <CDATASIZE,SETDBCS,,sw_dbcs>
;
no865_data label   word
	dw	CDATAITEMS				; number of entries
	ctrydat <CDATASIZE,SETCOUNTRYINFO,,no865_info>
	ctrydat <CDATASIZE,SETCOLLATE,,no_collate>
	ctrydat <CDATASIZE,SETUCASE,,no_ucase>
	ctrydat <CDATASIZE,SETUCASEFILE,,no_ucase>
	ctrydat <CDATASIZE,SETFILELIST,,no_flist>
	ctrydat <CDATASIZE,SETDBCS,,no_dbcs>
;
no850_data label   word
	dw	CDATAITEMS				; number of entries
	ctrydat <CDATASIZE,SETCOUNTRYINFO,,no865_info>
	ctrydat <CDATASIZE,SETCOLLATE,,no850_collate>
	ctrydat <CDATASIZE,SETUCASE,,no850_ucase>
	ctrydat <CDATASIZE,SETUCASEFILE,,no850_ucase>
	ctrydat <CDATASIZE,SETFILELIST,,no_flist>
	ctrydat <CDATASIZE,SETDBCS,,no_dbcs>
;
nl437_data label   word
	dw	CDATAITEMS				; number of entries
	ctrydat <CDATASIZE,SETCOUNTRYINFO,,nl437_info>
	ctrydat <CDATASIZE,SETCOLLATE,,nl_collate>
	ctrydat <CDATASIZE,SETUCASE,,nl_ucase>
	ctrydat <CDATASIZE,SETUCASEFILE,,nl_ucase>
	ctrydat <CDATASIZE,SETFILELIST,,nl_flist>
	ctrydat <CDATASIZE,SETDBCS,,nl_dbcs>
;
nl850_data label   word
	dw	CDATAITEMS				; number of entries
	ctrydat <CDATASIZE,SETCOUNTRYINFO,,nl437_info>
	ctrydat <CDATASIZE,SETCOLLATE,,nl850_collate>
	ctrydat <CDATASIZE,SETUCASE,,nl850_ucase>
	ctrydat <CDATASIZE,SETUCASEFILE,,nl850_ucase>
	ctrydat <CDATASIZE,SETFILELIST,,nl_flist>
	ctrydat <CDATASIZE,SETDBCS,,nl_dbcs>
;
be437_data label   word
	dw	CDATAITEMS				; number of entries
	ctrydat <CDATASIZE,SETCOUNTRYINFO,,be437_info>
	ctrydat <CDATASIZE,SETCOLLATE,,be_collate>
	ctrydat <CDATASIZE,SETUCASE,,be_ucase>
	ctrydat <CDATASIZE,SETUCASEFILE,,be_ucase>
	ctrydat <CDATASIZE,SETFILELIST,,be_flist>
	ctrydat <CDATASIZE,SETDBCS,,be_dbcs>
;
be850_data label   word
	dw	CDATAITEMS				; number of entries
	ctrydat <CDATASIZE,SETCOUNTRYINFO,,be437_info>
	ctrydat <CDATASIZE,SETCOLLATE,,be850_collate>
	ctrydat <CDATASIZE,SETUCASE,,be850_ucase>
	ctrydat <CDATASIZE,SETUCASEFILE,,be850_ucase>
	ctrydat <CDATASIZE,SETFILELIST,,be_flist>
	ctrydat <CDATASIZE,SETDBCS,,be_dbcs>
;
fi437_data label   word
	dw	CDATAITEMS				; number of entries
	ctrydat <CDATASIZE,SETCOUNTRYINFO,,fi437_info>
	ctrydat <CDATASIZE,SETCOLLATE,,fi_collate>
	ctrydat <CDATASIZE,SETUCASE,,fi_ucase>
	ctrydat <CDATASIZE,SETUCASEFILE,,fi_ucase>
	ctrydat <CDATASIZE,SETFILELIST,,fi_flist>
	ctrydat <CDATASIZE,SETDBCS,,fi_dbcs>
;
fi850_data label   word
	dw	CDATAITEMS				; number of entries
	ctrydat <CDATASIZE,SETCOUNTRYINFO,,fi437_info>
	ctrydat <CDATASIZE,SETCOLLATE,,fi850_collate>
	ctrydat <CDATASIZE,SETUCASE,,fi850_ucase>
	ctrydat <CDATASIZE,SETUCASEFILE,,fi850_ucase>
	ctrydat <CDATASIZE,SETFILELIST,,fi_flist>
	ctrydat <CDATASIZE,SETDBCS,,fi_dbcs>
;
us437_data label   word
	dw	CDATAITEMS				; number of entries
	ctrydat <CDATASIZE,SETCOUNTRYINFO,,us437_info>
	ctrydat <CDATASIZE,SETCOLLATE,,us_collate>
	ctrydat <CDATASIZE,SETUCASE,,us_ucase>
	ctrydat <CDATASIZE,SETUCASEFILE,,us_ucase>
	ctrydat <CDATASIZE,SETFILELIST,,us_flist>
	ctrydat <CDATASIZE,SETDBCS,,us_dbcs>
;
us850_data label   word
	dw	CDATAITEMS				; number of entries
	ctrydat <CDATASIZE,SETCOUNTRYINFO,,us437_info>
	ctrydat <CDATASIZE,SETCOLLATE,,us850_collate>
	ctrydat <CDATASIZE,SETUCASE,,us850_ucase>
	ctrydat <CDATASIZE,SETUCASEFILE,,us850_ucase>
	ctrydat <CDATASIZE,SETFILELIST,,us_flist>
	ctrydat <CDATASIZE,SETDBCS,,us_dbcs>
;
is862_data label   word
	dw	CDATAITEMS				; number of entries
	ctrydat <CDATASIZE,SETCOUNTRYINFO,,is862_info>
	ctrydat <CDATASIZE,SETCOLLATE,,is_collate>
	ctrydat <CDATASIZE,SETUCASE,,is_ucase>
	ctrydat <CDATASIZE,SETUCASEFILE,,is_ucase>
	ctrydat <CDATASIZE,SETFILELIST,,is_flist>
	ctrydat <CDATASIZE,SETDBCS,,is_dbcs>
;
is850_data label   word
	dw	CDATAITEMS				; number of entries
	ctrydat <CDATASIZE,SETCOUNTRYINFO,,is862_info>
	ctrydat <CDATASIZE,SETCOLLATE,,is850_collate>
	ctrydat <CDATASIZE,SETUCASE,,is850_ucase>
	ctrydat <CDATASIZE,SETUCASEFILE,,is850_ucase>
	ctrydat <CDATASIZE,SETFILELIST,,is_flist>
	ctrydat <CDATASIZE,SETDBCS,,is_dbcs>
;
ca863_data label   word
	dw	CDATAITEMS				; number of entries
	ctrydat <CDATASIZE,SETCOUNTRYINFO,,ca863_info>
	ctrydat <CDATASIZE,SETCOLLATE,,ca_collate>
	ctrydat <CDATASIZE,SETUCASE,,ca_ucase>
	ctrydat <CDATASIZE,SETUCASEFILE,,ca_ucase>
	ctrydat <CDATASIZE,SETFILELIST,,ca_flist>
	ctrydat <CDATASIZE,SETDBCS,,ca_dbcs>
;
ca850_data label   word
	dw	CDATAITEMS				; number of entries
	ctrydat <CDATASIZE,SETCOUNTRYINFO,,ca863_info>
	ctrydat <CDATASIZE,SETCOLLATE,,ca850_collate>
	ctrydat <CDATASIZE,SETUCASE,,ca850_ucase>
	ctrydat <CDATASIZE,SETUCASEFILE,,ca850_ucase>
	ctrydat <CDATASIZE,SETFILELIST,,ca_flist>
	ctrydat <CDATASIZE,SETDBCS,,ca_dbcs>
;
as864_data label   word
	dw	CDATAITEMS				; number of entries
	ctrydat <CDATASIZE,SETCOUNTRYINFO,,as864_info>
	ctrydat <CDATASIZE,SETCOLLATE,,as_collate>
	ctrydat <CDATASIZE,SETUCASE,,as_ucase>
	ctrydat <CDATASIZE,SETUCASEFILE,,as_ucase>
	ctrydat <CDATASIZE,SETFILELIST,,as_flist>
	ctrydat <CDATASIZE,SETDBCS,,as_dbcs>
;
as850_data label   word
	dw	CDATAITEMS				; number of entries
	ctrydat <CDATASIZE,SETCOUNTRYINFO,,as850_info>
	ctrydat <CDATASIZE,SETCOLLATE,,as850_collate>
	ctrydat <CDATASIZE,SETUCASE,,as850_ucase>
	ctrydat <CDATASIZE,SETUCASEFILE,,as850_ucase>
	ctrydat <CDATASIZE,SETFILELIST,,as_flist>
	ctrydat <CDATASIZE,SETDBCS,,as_dbcs>
;
po860_data label   word
	dw	CDATAITEMS				; number of entries
	ctrydat <CDATASIZE,SETCOUNTRYINFO,,po860_info>
	ctrydat <CDATASIZE,SETCOLLATE,,po_collate>
	ctrydat <CDATASIZE,SETUCASE,,po_ucase>
	ctrydat <CDATASIZE,SETUCASEFILE,,po_ucase>
	ctrydat <CDATASIZE,SETFILELIST,,po_flist>
	ctrydat <CDATASIZE,SETDBCS,,po_dbcs>
;
po850_data label   word
	dw	CDATAITEMS				; number of entries
	ctrydat <CDATASIZE,SETCOUNTRYINFO,,po860_info>
	ctrydat <CDATASIZE,SETCOLLATE,,po850_collate>
	ctrydat <CDATASIZE,SETUCASE,,po850_ucase>
	ctrydat <CDATASIZE,SETUCASEFILE,,po850_ucase>
	ctrydat <CDATASIZE,SETFILELIST,,po_flist>
	ctrydat <CDATASIZE,SETDBCS,,po_dbcs>
;
la437_data label   word
	dw	CDATAITEMS				; number of entries
	ctrydat <CDATASIZE,SETCOUNTRYINFO,,la437_info>
	ctrydat <CDATASIZE,SETCOLLATE,,la_collate>
	ctrydat <CDATASIZE,SETUCASE,,la_ucase>
	ctrydat <CDATASIZE,SETUCASEFILE,,la_ucase>
	ctrydat <CDATASIZE,SETFILELIST,,la_flist>
	ctrydat <CDATASIZE,SETDBCS,,la_dbcs>
;
la850_data label   word
	dw	CDATAITEMS				; number of entries
	ctrydat <CDATASIZE,SETCOUNTRYINFO,,la437_info>
	ctrydat <CDATASIZE,SETCOLLATE,,la850_collate>
	ctrydat <CDATASIZE,SETUCASE,,la850_ucase>
	ctrydat <CDATASIZE,SETUCASEFILE,,la850_ucase>
	ctrydat <CDATASIZE,SETFILELIST,,la_flist>
	ctrydat <CDATASIZE,SETDBCS,,la_dbcs>
;
jp932_data label   word
	dw	CDATAITEMS				; number of entries
	ctrydat <CDATASIZE,SETCOUNTRYINFO,,jp932_info>
	ctrydat <CDATASIZE,SETCOLLATE,,jp932_collate>
	ctrydat <CDATASIZE,SETUCASE,,jp932_ucase>
	ctrydat <CDATASIZE,SETUCASEFILE,,jp932_ucase>
	ctrydat <CDATASIZE,SETFILELIST,,jp932_flist>
	ctrydat <CDATASIZE,SETDBCS,,jp932_dbcs>
;
jp437_data label   word
	dw	CDATAITEMS				; number of entries
	ctrydat <CDATASIZE,SETCOUNTRYINFO,,jp437_info>
	ctrydat <CDATASIZE,SETCOLLATE,,jp437_collate>
	ctrydat <CDATASIZE,SETUCASE,,jp437_ucase>
	ctrydat <CDATASIZE,SETUCASEFILE,,jp437_ucase>
	ctrydat <CDATASIZE,SETFILELIST,,jp437_flist>
	ctrydat <CDATASIZE,SETDBCS,,jp437_dbcs>
;
ko934_data label   word
	dw	CDATAITEMS				; number of entries
	ctrydat <CDATASIZE,SETCOUNTRYINFO,,ko934_info>
	ctrydat <CDATASIZE,SETCOLLATE,,ko934_collate>
	ctrydat <CDATASIZE,SETUCASE,,ko934_ucase>
	ctrydat <CDATASIZE,SETUCASEFILE,,ko934_ucase>
	ctrydat <CDATASIZE,SETFILELIST,,ko934_flist>
	ctrydat <CDATASIZE,SETDBCS,,ko934_dbcs>
;
ko437_data label   word
	dw	CDATAITEMS				; number of entries
	ctrydat <CDATASIZE,SETCOUNTRYINFO,,ko437_info>
	ctrydat <CDATASIZE,SETCOLLATE,,ko437_collate>
	ctrydat <CDATASIZE,SETUCASE,,ko437_ucase>
	ctrydat <CDATASIZE,SETUCASEFILE,,ko437_ucase>
	ctrydat <CDATASIZE,SETFILELIST,,ko437_flist>
	ctrydat <CDATASIZE,SETDBCS,,ko437_dbcs>
;
pr936_data label   word
	dw	CDATAITEMS				; number of entries
	ctrydat <CDATASIZE,SETCOUNTRYINFO,,pr936_info>
	ctrydat <CDATASIZE,SETCOLLATE,,pr936_collate>
	ctrydat <CDATASIZE,SETUCASE,,pr936_ucase>
	ctrydat <CDATASIZE,SETUCASEFILE,,pr936_ucase>
	ctrydat <CDATASIZE,SETFILELIST,,pr936_flist>
	ctrydat <CDATASIZE,SETDBCS,,pr936_dbcs>
;
pr437_data label   word
	dw	CDATAITEMS				; number of entries
	ctrydat <CDATASIZE,SETCOUNTRYINFO,,pr437_info>
	ctrydat <CDATASIZE,SETCOLLATE,,pr437_collate>
	ctrydat <CDATASIZE,SETUCASE,,pr437_ucase>
	ctrydat <CDATASIZE,SETUCASEFILE,,pr437_ucase>
	ctrydat <CDATASIZE,SETFILELIST,,pr437_flist>
	ctrydat <CDATASIZE,SETDBCS,,pr437_dbcs>
;
ta938_data label   word
	dw	CDATAITEMS				; number of entries
	ctrydat <CDATASIZE,SETCOUNTRYINFO,,ta938_info>
	ctrydat <CDATASIZE,SETCOLLATE,,ta938_collate>
	ctrydat <CDATASIZE,SETUCASE,,ta938_ucase>
	ctrydat <CDATASIZE,SETUCASEFILE,,ta938_ucase>
	ctrydat <CDATASIZE,SETFILELIST,,ta938_flist>
	ctrydat <CDATASIZE,SETDBCS,,ta938_dbcs>
;
ta437_data label   word
	dw	CDATAITEMS				; number of entries
	ctrydat <CDATASIZE,SETCOUNTRYINFO,,ta437_info>
	ctrydat <CDATASIZE,SETCOLLATE,,ta437_collate>
	ctrydat <CDATASIZE,SETUCASE,,ta437_ucase>
	ctrydat <CDATASIZE,SETUCASEFILE,,ta437_ucase>
	ctrydat <CDATASIZE,SETFILELIST,,ta437_flist>
	ctrydat <CDATASIZE,SETDBCS,,ta437_dbcs>
;
afe437_data label   word
	dw	CDATAITEMS				; number of entries
	ctrydat <CDATASIZE,SETCOUNTRYINFO,,afe437_info>
	ctrydat <CDATASIZE,SETCOLLATE,,afe_collate>
	ctrydat <CDATASIZE,SETUCASE,,afe_ucase>
	ctrydat <CDATASIZE,SETUCASEFILE,,afe_ucase>
	ctrydat <CDATASIZE,SETFILELIST,,afe_flist>
	ctrydat <CDATASIZE,SETDBCS,,afe_dbcs>
;
afe850_data label   word
	dw	CDATAITEMS				; number of entries
	ctrydat <CDATASIZE,SETCOUNTRYINFO,,afe437_info>
	ctrydat <CDATASIZE,SETCOLLATE,,afe850_collate>
	ctrydat <CDATASIZE,SETUCASE,,afe850_ucase>
	ctrydat <CDATASIZE,SETUCASEFILE,,afe850_ucase>
	ctrydat <CDATASIZE,SETFILELIST,,afe_flist>
	ctrydat <CDATASIZE,SETDBCS,,afe_dbcs>
	page

;	cs3 -- begin additions for new countries

br850_data label   word
	 dw    CDATAITEMS                    ; number of entries
	 ctrydat <CDATASIZE,SETCOUNTRYINFO,,br850_info>
	 ctrydat <CDATASIZE,SETCOLLATE,,br850_collate>
	 ctrydat <CDATASIZE,SETUCASE,,br850_ucase>
	 ctrydat <CDATASIZE,SETUCASEFILE,,br850_ucfile>
	 ctrydat <CDATASIZE,SETFILELIST,,br_flist>
	 ctrydat <CDATASIZE,SETDBCS,,br_dbcs>
;
br437_data label   word
	 dw    CDATAITEMS                    ; number of entries
	 ctrydat <CDATASIZE,SETCOUNTRYINFO,,br850_info>
	 ctrydat <CDATASIZE,SETCOLLATE,,br437_collate>
	 ctrydat <CDATASIZE,SETUCASE,,br_ucase>
	 ctrydat <CDATASIZE,SETUCASEFILE,,br_ucase>
	 ctrydat <CDATASIZE,SETFILELIST,,br_flist>
	 ctrydat <CDATASIZE,SETDBCS,,br_dbcs>
;
ic861_data label   word
	 dw     CDATAITEMS                              ; number of entries
	 ctrydat <CDATASIZE,SETCOUNTRYINFO,,ic861_info>
	 ctrydat <CDATASIZE,SETCOLLATE,,ic_collate>
	 ctrydat <CDATASIZE,SETUCASE,,ic_ucase>
	 ctrydat <CDATASIZE,SETUCASEFILE,,ic_ucase>
	 ctrydat <CDATASIZE,SETFILELIST,,ic_flist>
	 ctrydat <CDATASIZE,SETDBCS,,ic_dbcs>
;
ic850_data label   word
	 dw     CDATAITEMS                              ; number of entries
	 ctrydat <CDATASIZE,SETCOUNTRYINFO,,ic850_info>
	 ctrydat <CDATASIZE,SETCOLLATE,,ic850_collate>
	 ctrydat <CDATASIZE,SETUCASE,,ic850_ucase>
	 ctrydat <CDATASIZE,SETUCASEFILE,,ic850_ucfile>
	 ctrydat <CDATASIZE,SETFILELIST,,ic_flist>
	 ctrydat <CDATASIZE,SETDBCS,,ic_dbcs>
;
tr850_data label   word
	 dw     CDATAITEMS                              ; number of entries
	 ctrydat <CDATASIZE,SETCOUNTRYINFO,,tr850_info>
	 ctrydat <CDATASIZE,SETCOLLATE,,tr850_collate>
	 ctrydat <CDATASIZE,SETUCASE,,tr850_ucase>
	 ctrydat <CDATASIZE,SETUCASEFILE,,tr850_ucfile>
	 ctrydat <CDATASIZE,SETFILELIST,,tr_flist>
	 ctrydat <CDATASIZE,SETDBCS,,tr_dbcs>
;
tr857_data label   word
	 dw     CDATAITEMS                              ; number of entries
	 ctrydat <CDATASIZE,SETCOUNTRYINFO,,tr857_info>
	 ctrydat <CDATASIZE,SETCOLLATE,,tr857_collate>
	 ctrydat <CDATASIZE,SETUCASE,,tr857_ucase>
	 ctrydat <CDATASIZE,SETUCASEFILE,,tr857_ucase>
	 ctrydat <CDATASIZE,SETFILELIST,,tr_flist>
	 ctrydat <CDATASIZE,SETDBCS,,tr_dbcs>
;
yu850_data label   word
	 dw     CDATAITEMS                              ; number of entries
	 ctrydat <CDATASIZE,SETCOUNTRYINFO,,yu852_info>
	 ctrydat <CDATASIZE,SETCOLLATE,,yu850_collate>
	 ctrydat <CDATASIZE,SETUCASE,,yu850_ucase>
	 ctrydat <CDATASIZE,SETUCASEFILE,,yu850_ucfile>
	 ctrydat <CDATASIZE,SETFILELIST,,yu_flist>
	 ctrydat <CDATASIZE,SETDBCS,,yu_dbcs>   ;  This is DOUBLE BYTE CHAR SET
;                                               ;  char set (ahead of its time)
;                                               ; and doesn't need to be
;
yu852_data label   word
	 dw     CDATAITEMS                      ; number of entries
	 ctrydat <CDATASIZE,SETCOUNTRYINFO,,yu852_info>
	 ctrydat <CDATASIZE,SETCOLLATE,,yu852_collate>
	 ctrydat <CDATASIZE,SETUCASE,,yu852_ucase>
	 ctrydat <CDATASIZE,SETUCASEFILE,,yu_ucfile>
	 ctrydat <CDATASIZE,SETFILELIST,,yu_flist>
	 ctrydat <CDATASIZE,SETDBCS,,yu_dbcs>
;
cs850_data label   word
	 dw     CDATAITEMS                              ; number of entries
	 ctrydat <CDATASIZE,SETCOUNTRYINFO,,cs852_info>
	 ctrydat <CDATASIZE,SETCOLLATE,,cs850_collate>
	 ctrydat <CDATASIZE,SETUCASE,,cs850_ucase>
	 ctrydat <CDATASIZE,SETUCASEFILE,,cs850_ucfile>
	 ctrydat <CDATASIZE,SETFILELIST,,cs_flist>
	 ctrydat <CDATASIZE,SETDBCS,,cs_dbcs>
;
cs852_data label   word
	 dw     CDATAITEMS                              ; number of entries
	 ctrydat <CDATASIZE,SETCOUNTRYINFO,,cs852_info>
	 ctrydat <CDATASIZE,SETCOLLATE,,cs852_collate>
	 ctrydat <CDATASIZE,SETUCASE,,cs852_ucase>
	 ctrydat <CDATASIZE,SETUCASEFILE,,cs_ucfile>
	 ctrydat <CDATASIZE,SETFILELIST,,cs_flist>
	 ctrydat <CDATASIZE,SETDBCS,,cs_dbcs>
;
sl850_data label   word
	 dw     CDATAITEMS                              ; number of entries
	 ctrydat <CDATASIZE,SETCOUNTRYINFO,,cs852_info>
	 ctrydat <CDATASIZE,SETCOLLATE,,sl850_collate>
	 ctrydat <CDATASIZE,SETUCASE,,sl850_ucase>
	 ctrydat <CDATASIZE,SETUCASEFILE,,sl850_ucfile>
	 ctrydat <CDATASIZE,SETFILELIST,,sl_flist>
	 ctrydat <CDATASIZE,SETDBCS,,sl_dbcs>
;
sl852_data label   word
	 dw     CDATAITEMS                              ; number of entries
	 ctrydat <CDATASIZE,SETCOUNTRYINFO,,cs852_info>
	 ctrydat <CDATASIZE,SETCOLLATE,,sl852_collate>
	 ctrydat <CDATASIZE,SETUCASE,,sl852_ucase>
	 ctrydat <CDATASIZE,SETUCASEFILE,,sl_ucfile>
	 ctrydat <CDATASIZE,SETFILELIST,,sl_flist>
	 ctrydat <CDATASIZE,SETDBCS,,sl_dbcs>
;
pl850_data label   word
	 dw     CDATAITEMS                              ; number of entries
	 ctrydat <CDATASIZE,SETCOUNTRYINFO,,pl852_info>
	 ctrydat <CDATASIZE,SETCOLLATE,,pl850_collate>
	 ctrydat <CDATASIZE,SETUCASE,,pl850_ucase>
	 ctrydat <CDATASIZE,SETUCASEFILE,,pl850_ucfile>
	 ctrydat <CDATASIZE,SETFILELIST,,pl_flist>
	 ctrydat <CDATASIZE,SETDBCS,,pl_dbcs>
;
pl852_data label   word
	 dw     CDATAITEMS                              ; number of entries
	 ctrydat <CDATASIZE,SETCOUNTRYINFO,,pl852_info>
	 ctrydat <CDATASIZE,SETCOLLATE,,pl852_collate>
	 ctrydat <CDATASIZE,SETUCASE,,pl852_ucase>
	 ctrydat <CDATASIZE,SETUCASEFILE,,pl_ucfile>
	 ctrydat <CDATASIZE,SETFILELIST,,pl_flist>
	 ctrydat <CDATASIZE,SETDBCS,,pl_dbcs>
;
hu850_data label   word
	 dw     CDATAITEMS                              ; number of entries
	 ctrydat <CDATASIZE,SETCOUNTRYINFO,,hu852_info>
	 ctrydat <CDATASIZE,SETCOLLATE,,hu850_collate>
	 ctrydat <CDATASIZE,SETUCASE,,hu850_ucase>
	 ctrydat <CDATASIZE,SETUCASEFILE,,hu850_ucfile>
	 ctrydat <CDATASIZE,SETFILELIST,,hu_flist>
	 ctrydat <CDATASIZE,SETDBCS,,hu_dbcs>
;
hu852_data label   word
	 dw     CDATAITEMS                              ; number of entries
	 ctrydat <CDATASIZE,SETCOUNTRYINFO,,hu852_info>
	 ctrydat <CDATASIZE,SETCOLLATE,,hu852_collate>
	 ctrydat <CDATASIZE,SETUCASE,,hu852_ucase>
	 ctrydat <CDATASIZE,SETUCASEFILE,,hu_ucfile>
	 ctrydat <CDATASIZE,SETFILELIST,,hu_flist>
	 ctrydat <CDATASIZE,SETDBCS,,hu_dbcs>
;
;	cs3 -- end additions for new countries
	page
; ----------------------------------------
;
;	World Trade Country Info Tables
;
; ----------------------------------------
uk437_info	   label   word
		ctable	<>
;cs3		cinfo	<CID_UK,437,DATE_DMY,156,,,,,',',,'.',,'-',,':',,,2,HR12,,','>
		cinfo	<CID_UK,437,DATE_DMY,156,,,,,',',,'.',,'/',,':',,,2,HR24,,','>	; cs3
;
fr437_info	   label   word
		ctable	<>
;cs3		cinfo	<CID_FR,437,DATE_DMY,'F',,,,,' ',,',',,'/',,':',,3,2,HR24,,';'>
		cinfo	<CID_FR,437,DATE_DMY,'F',,,,,' ',,',',,'.',,':',,3,2,HR24,,';'>	; cs3
;
gr437_info	   label   word
		ctable	<>
;cs3		cinfo	<CID_GR,437,DATE_DMY,'D','M',,,,'.',,',',,'.',,'.',,2,2,HR24,,';'>
		cinfo	<CID_GR,437,DATE_DMY,'D','M',,,,'.',,',',,'.',,':',,0,2,HR24,,';'> ; cs3

;
sp437_info	   label   word
		ctable	<>
;cs3		cinfo	<CID_SP,437,DATE_DMY,158,,,,,'.',,',',,'/',,':',,3,2,HR24,,';'>
		cinfo	<CID_SP,437,DATE_DMY,158,,,,,'.',,',',,'/',,':',,2,0,HR24,,';'>	; cs3

;
sp850_info	   label   word
		ctable	<>
;cs3		cinfo	<CID_SP,437,DATE_DMY,'P','t','s',,,'.',,',',,'/',,':',,3,2,HR24,,';'>
		cinfo	<CID_SP,437,DATE_DMY,'P','t','s',,,'.',,',',,'/',,':',,2,0,HR24,,';'>	; cs3

;
it437_info	   label   word
		ctable	<>
;cs3		cinfo	<CID_IT,437,DATE_DMY,'L','.',,,,'.',,',',,'/',,':',,,,HR24,,';'>
		cinfo	<CID_IT,437,DATE_DMY,'L','.',,,,'.',,',',,'/',,'.',,2,,HR24,,';'>	; cs3
;
sv437_info	   label   word
		ctable	<>
;cs3		cinfo	<CID_SV,437,DATE_YMD,'S','E','K',,,'.',,',',,'-',,'.',,2,2,HR24,,';'>
		cinfo	<CID_SV,437,DATE_YMD,'K','r',,,,' ',,',',,'-',,'.',,3,2,HR24,,';'>	; cs3
;
dk865_info	   label   word
		ctable	<>
		cinfo	<CID_DK,865,DATE_DMY,'k','r',,,,'.',,',',,'-',,'.',,2,2,HR24,,';'>
;
sw437_info	   label   word
		ctable	<>
;cs3		cinfo	<CID_SW,437,DATE_DMY,'F','r',,,,"'",,'.',,'.',,'.',,2,2,HR24,,','>
		cinfo	<CID_SW,437,DATE_DMY,'F','r','.',,,"'",,'.',,'.',,',',,2,2,HR24,,';'>	;cs3
;
;*** CNS Change date separator from slash to period - DCR 357
no865_info	   label   word
		ctable	<>
;cs3		cinfo	<CID_NO,865,DATE_DMY,'K','r',,,,'.',,',',,'.',,'.',,2,2,HR24,,';'> ;AN000;
		cinfo	<CID_NO,865,DATE_DMY,'K','r',,,,'.',,',',,'.',,':',,2,2,HR24,,';'> ;AN000;cs3
;*** CNS Change date separator from slash to period - DCR 357
;*** Field #14
;
nl437_info	   label   word
		ctable	<>
		cinfo	<CID_NL,437,DATE_DMY,159,,,,,'.',,',',,'-',,':',,2,2,HR24,,';'>
;
be437_info	   label   word
		ctable	<>
;cs3		cinfo	<CID_BE,437,DATE_DMY,'B','E','F',,,'.',,',',,'/',,':',,2,2,HR24,,';'>
		cinfo	<CID_BE,437,DATE_DMY,'B','F',,,,'.',,',',,'/',,':',,2,2,HR24,,';'>	; cs3
;
fi437_info	   label   word
		ctable	<>
		cinfo	<CID_FI,437,DATE_DMY,'m','k',,,,' ',,',',,'.',,'.',,3,2,HR24,,';'>
;
jp437_info	   label   word
;cs3 ko437_info	   label   word
pr437_info	   label   word
;cs3 ta437_info	   label   word
us437_info	   label   word
		ctable	<>
		cinfo	<CID_US,437,DATE_MDY,'$',,,,,',',,'.',,'-',,':',,,2,HR12,,','>
;
is862_info	   label   word
		ctable	<>
		cinfo	<CID_IS,862,DATE_DMY,153,,,,,',',,'.',,' ',,':',,2,2,HR24,,','>
;
ca863_info	   label   word
		ctable	<>
		cinfo	<CID_CA,863,DATE_YMD,'$',,,,,' ',,',',,'-',,':',,3,2,HR24,,';'>
;
as864_info	   label   word
		ctable	<>
		cinfo	<CID_AS,864,DATE_DMY,164,,,,,'.',,',',,'/',,':',,3,3,HR12,,';'>
;
as850_info	   label   word
		ctable	<>
		cinfo	<CID_AS,864,DATE_DMY,207,,,,,'.',,',',,'/',,':',,3,3,HR12,,';'>
;
po860_info	   label   word
		ctable	<>
;cs3		cinfo	<CID_PO,860,DATE_DMY,'$',,,,,'.',,',',,'/',,':',,4,2,HR24,,';'>
		cinfo	<CID_PO,860,DATE_DMY,'E','s','c','.',,'.',,',',,'-',,':',,3,2,HR24,,';'>	; cs3
;
la437_info	   label   word
		ctable	<>
;cs3		cinfo	<CID_LA,437,DATE_DMY,'$',,,,,',',,'.',,'/',,':',,3,2,HR24,,';'>
		cinfo	<CID_LA,437,DATE_DMY,'$',,,,,',',,'.',,'/',,':',,0,2,HR12,,','>	; cs3
;
afe437_info	   label   word
		ctable	<>
		cinfo	<CID_AFE,437,DATE_DMY,'$',,,,,',',,'.',,'-',,':',,,2,HR12,,','>
;
jp932_info	   label   word
		ctable	<>
		cinfo	<CID_JP,932,DATE_YMD,'\',,,,,',',,'.',,'-',,':',,,0,HR24,,','>
;
ko934_info	   label   word
		ctable	<>
;cs3		cinfo	<CID_KO,934,DATE_YMD,'\',,,,,',',,'.',,'-',,':',,,0,HR24,,','>
		cinfo	<CID_KO,934,DATE_YMD,'\',,,,,',',,'.',,'.',,':',,,0,HR24,,','>	; cs3
;
;	cs3 -- added separate entries for ko437 and ta437

ta437_info	label	word
		ctable	<>
		cinfo	<CID_US,437,DATE_YMD,'$',,,,,',',,'.',,'/',,':',,,2,HR12,,','>
ko437_info	label	word
		ctable	<>
		cinfo	<CID_US,437,DATE_MDY,'$',,,,,',',,'.',,'.',,':',,,2,HR12,,','>
;
;	cs3 -- end additions

pr936_info	   label   word
		ctable	<>
		cinfo	<CID_PR,936,DATE_YMD,'\',,,,,',',,'.',,'-',,':',,,2,HR24,,','>
;
ta938_info	   label   word
		ctable	<>
;cs3		cinfo	<CID_TA,938,DATE_MDY,'N','T','$',,,',',,'.',,'-',,':',,,2,HR24,,','>
		cinfo	<CID_TA,938,DATE_YMD,'N','T','$',,,',',,'.',,'/',,':',,,2,HR24,,','>	; cs3
;

;	cs3 -- begin additions for new countries

br850_info        label   word
	       ctable      <>
	       cinfo <CID_BR,850,DATE_DMY,'C','r','$',,,'.',,',',,'/',,':',,,2,HR24,,';'>
;
ic861_info        label   word
	       ctable   <>
	       cinfo    <CID_IC,861,DATE_DMY,'','K','r',,,'.',,',',,'.',,':',,2,2,HR24,,';'>
;
ic850_info        label   word
	       ctable   <>
	       cinfo    <CID_IC,861,DATE_DMY,'','K','r',,,'.',,',',,'.',,':',,2,2,HR24,,';'>
;
tr850_info        label   word
	       ctable   <>
	       cinfo    <CID_TR,850,DATE_DMY,'T','L',,,,'.',,',',,'/',,':',,4,2,HR24,,','>
;
tr857_info        label   word
	       ctable   <>
	       cinfo    <CID_TR,857,DATE_DMY,'T','L',,,,'.',,',',,'/',,':',,4,2,HR24,,','>
;
yu852_info        label   word   ; Country info for yugoslavia 852
	       ctable   <>
	       cinfo    <CID_YU,852,DATE_YMD,'D','i','n',,,'.',,',',,'-',,':',,2,2,HR24,,','>
;
cs852_info        label   word   ; Country info for CSSR   852
	       ctable   <>
	       cinfo    <CID_CS,852,DATE_YMD,'K',9FH,'s',,,'.',,',',,'-',,':',,2,2,HR24,,','>
;
pl852_info        label   word   ; Country info for poland 852
	       ctable   <>
	       cinfo    <CID_PL,852,DATE_YMD,'Z',88H,,,,'.',,',',,'-',,':',,,2,HR24,,','>
;
hu852_info        label   word   ; Country info for hungary 852
	       ctable   <>
	       cinfo	<CID_HU,852,DATE_YMD,'F','t',,,,' ',,',',,'-',,':',,,2,HR24,,','>
;
;	cs3 -- end additions for new countries

	page
; ------------------------------------------------
;
;	World Trade Collating sequence tables
;
; ------------------------------------------------
;
; --------------------------------------------------------------------------
;
;	Collating Table Same for United States, United Kingdom, France, Germany,
;			Italy, and International English
; --------------------------------------------------------------------------
;
us_collate	label	word
;
uk_collate	label	word
;
fr_collate	label	word
;
gr_collate	label	word
;
it_collate	label	word
;
jp437_collate	label	word
;
ko437_collate	label	word
;
pr437_collate	label	word
;
ta437_collate	label	word
;
afe_collate	label	word
;
;	cs3 -- begin added country

br437_collate	label	word

;	cs3 -- end additions

		ctable	<,'COLLATE',256>
		db	0,1,2,3,4,5,6,7
		db	8,9,10,11,12,13,14,15
		db	16,17,18,19,20,21,22,23
		db	24,25,26,27,28,29,30,31
		db	" ","!",'"',"#","$","%","&","'"
		db	"(",")","*","+",",","-",".","/"
		db	"0","1","2","3","4","5","6","7"
		db	"8","9",":",";","<","=",">","?"
		db	"@","A","B","C","D","E","F","G"
		db	"H","I","J","K","L","M","N","O"
		db	"P","Q","R","S","T","U","V","W"
		db	"X","Y","Z","[","\","]","^","_"
		db	"`","A","B","C","D","E","F","G"
		db	"H","I","J","K","L","M","N","O"
		db	"P","Q","R","S","T","U","V","W"
		db	"X","Y","Z","{","|","}","~",127
		db	"C","U","E","A","A","A","A","C"
		db	"E","E","E","I","I","I","A","A"
		db	"E","A","A","O","O","O","U","U"
		db	"Y","O","U","$","$","$","$","$"
		db	"A","I","O","U","N","N",166,167
		db	"?",169,170,171,172,"!",'"','"'
		db	176,177,178,179,180,181,182,183
		db	184,185,186,187,188,189,190,191
		db	192,193,194,195,196,197,198,199
		db	200,201,202,203,204,205,206,207
		db	208,209,210,211,212,213,214,215
		db	216,217,218,219,220,221,222,223
		db	224,"S"
		db	226,227,228,229,230,231
		db	232,233,234,235,236,237,238,239
		db	240,241,242,243,244,245,246,247
		db	248,249,250,251,252,253,254,255
	page
	;
; Netherland 437 Collate
;
nl_collate	label	word
		ctable	<,'COLLATE',256>
		db	000,001,002,003,004,005,006,007
		db	008,009,010,011,012,013,014,015
		db	016,017,018,019,020,021,022,023
		db	024,025,026,027,028,029,030,031
		db	032,033,034,035,036,037,038,039
		db	040,041,042,043,044,045,046,047
		db	048,049,050,051,052,053,054,055
		db	056,057,058,059,060,061,062,063
		db	064,065,066,067,068,069,070,071
		db	072,073,074,075,076,077,078,079
		db	080,081,082,083,084,085,086,087
		db	088,089,090,091,092,093,094,095
		db	096,065,066,067,068,069,070,071
		db	072,073,074,075,076,077,078,079
		db	080,081,082,083,084,085,086,087
		db	088,089,090,123,124,125,126,127
		db	128,154,144,065,142,065,143,128
		db	069,069,069,073,073,073,142,143
		db	144,146,146,079,079,079,085,085
		db	152,079,085,155,156,157,158,159
		db	065,073,079,085,165,165,166,167
		db	168,169,170,171,172,173,174,175
		db	176,177,178,179,180,181,182,183
		db	184,185,186,187,188,189,190,191
		db	192,193,194,195,196,197,198,199
		db	200,201,202,203,204,205,206,207
		db	208,209,210,211,212,213,214,215
		db	216,217,218,219,220,221,222,223
		db	224,225,226,227,228,229,230,231
		db	232,233,234,235,236,237,238,239
		db	240,241,242,243,244,245,246,247
		db	248,249,250,251,252,253,254,255
	page
;
;la_collate	 label	 word
;		 ctable  <,'COLLATE',256>
;		 db	 000,001,002,003,004,005,006,007
;		 db	 008,009,010,011,012,013,014,015
;		 db	 016,017,018,019,020,021,022,023
;		 db	 024,025,026,027,028,029,030,031
;		 db	 032,033,034,035,036,037,038,039
;		 db	 040,041,042,043,044,045,046,047
;		 db	 048,049,050,051,052,053,054,055
;		 db	 056,057,058,059,060,061,062,063
;		 db	 064,065,066,067,068,069,070,071
;		 db	 072,073,074,075,076,077,078,079
;		 db	 080,081,082,083,084,085,086,087
;		 db	 088,089,090,091,092,093,094,095
;		 db	 096,065,066,067,068,069,070,071
;		 db	 072,073,074,075,076,077,078,079
;		 db	 080,081,082,083,084,085,086,087
;		 db	 088,089,090,123,124,125,126,127
;		 db	 128,"U","E","A","A","A","A",128
;		 db	 "E","E","E","I","I","I","A","A"
;		 db	 "E","A","A","O","O","O","U","U"
;		 db	 "Y","O","U","$","$","$","$","$"
;		 db	 "A","I","O","U",165,165,166,167
;		 db	 "?",169,170,171,172,"!",'"','"'
;		 db	 176,177,178,179,180,181,182,183
;		 db	 184,185,186,187,188,189,190,191
;		 db	 192,193,194,195,196,197,198,199
;		 db	 200,201,202,203,204,205,206,207
;		 db	 208,209,210,211,212,213,214,215
;		 db	 216,217,218,219,220,221,222,223
;		 db	 224,"S"
;		 db	 226,227,228,229,230,231
;		 db	 232,233,234,235,236,237,238,239
;		 db	 240,241,242,243,244,245,246,247
;		 db	 248,249,250,251,252,253,254,255
	page
la_collate	label	word			  ; new for DOS 4.0, wants same as spain
;
sp_collate	label	word			   ; new for DOS 4.0
		ctable	<,'COLLATE',256>
		db 000,150,151,152,153,154,155,156 ;7
		db 157,158,159,160,161,162,163,164 ;15
		db 165,166,167,168,169,170,171,172 ;23
		db 173,174,175,176,177,178,179,180 ;31
		db 000,060,061,062,063,064,065,000 ;39
		db 066,067,068,069,070,000,071,072 ;47
		db 034,035,036,037,038,039,040,041 ;55
		db 042,043,073,074,075,076,077,078 ;63
		db 079,001,002,003,006,008,009,010 ;71
		db 011,012,013,014,015,017,018,020 ;79
		db 021,022,023,024,026,028,029,030 ;87
		db 031,032,033,080,081,082,083,084 ;95
		db 085,001,002,003,006,008,009,010 ;103
		db 011,012,013,014,015,017,018,020 ;111
		db 021,022,023,024,026,028,029,030 ;119
		db 031,032,033,086,087,088,089,090 ;127
		db 004,028,008,001,001,001,001,004 ;135
		db 008,008,008,012,012,012,001,001 ;143
		db 008,001,001,020,020,020,028,028 ;151
		db 032,020,028,091,092,093,094,095 ;159
		db 001,012,020,028,019,019,001,020 ;167
		db 096,097,098,099,100,101,102,103 ;175
		db 104,105,106,107,108,181,182,183 ;183
		db 184,109,110,111,112,185,186,113 ;191
		db 114,115,116,117,118,119,187,188 ;199
		db 120,121,122,123,124,125,126,189 ;207
		db 190,191,192,193,194,195,196,197 ;215
		db 198,127,128,129,130,199,200,131 ;223
		db 201,025,202,203,204,205,132,206 ;231
		db 207,208,209,210,211,212,213,214 ;239
		db 215,133,216,217,218,219,134,220 ;247
		db 221,222,000,223,224,135,136,225 ;255
	page
;
dk_collate	label	word		; Denmark (dk) 865
		ctable	<,'COLLATE',256>
		db	000,001,002,003,004,005,006,007
		db	008,009,010,011,012,013,014,015
		db	016,017,018,019,020,021,022,023
		db	024,025,026,027,028,029,030,031
		db	032,033,034,035,036,037,038,039
		db	040,041,042,043,044,045,046,047
		db	048,049,050,051,052,053,054,055
		db	056,057,058,059,060,061,062,063
		db	064,065,066,067,068,069,070,071
		db	072,073,074,075,076,077,078,079
		db	080,081,082,083,084,085,086,087
		db	088,089,090,040,047,041,094,095
		db	096,065,066,067,068,069,070,071
		db	072,073,074,075,076,077,078,079
		db	080,081,082,083,084,085,086,087
		db	088,089,090,040,047,041,126,127
		db	067,089,069,065,091,065,093,067
		db	069,069,069,073,073,073,091,093
		db	069,091,091,079,092,079,085,085
		db	089,092,089,092,036,092,036,036
		db	065,073,079,085,078,078,065,079
		db	063,169,170,171,172,033,034,036
		db	176,177,178,179,180,181,182,183
		db	184,185,186,187,188,189,190,191
		db	192,193,194,195,196,197,198,199
		db	200,201,202,203,204,205,206,207
		db	208,209,210,211,212,213,214,215
		db	216,217,218,219,220,221,222,223
		db	224,083,226,227,228,229,230,231
		db	232,233,234,235,236,237,238,239
		db	240,241,242,243,244,245,246,247
		db	248,249,250,251,252,253,254,255
	page
;
no_collate	label	word		; Norway (no) 865
		ctable	<,'COLLATE',256>
		db	000,001,002,003,004,005,006,007
		db	008,009,010,011,012,013,014,015
		db	016,017,018,019,020,021,022,023
		db	024,025,026,027,028,029,030,031
		db	032,033,034,035,036,037,038,039
		db	040,041,042,043,044,045,046,047
		db	048,049,050,051,052,053,054,055
		db	056,057,058,059,060,061,062,063
		db	064,065,066,067,068,069,070,071
		db	072,073,074,075,076,077,078,079
		db	080,081,082,083,084,085,086,087
		db	088,089,090,091,092,093,094,095
		db	096,065,066,067,068,069,070,071
		db	072,073,074,075,076,077,078,079
		db	080,081,082,083,084,085,086,087
		db	088,089,090,123,124,125,126,127
		db	067,089,069,065,091,065,093,067
		db	069,069,069,073,073,073,091,093
		db	069,091,091,079,092,079,085,085
		db	089,092,089,092,036,092,036,036
		db	065,073,079,085,078,078,065,079
		db	063,169,170,171,172,033,034,036
		db	176,177,178,179,180,181,182,183
		db	184,185,186,187,188,189,190,191
		db	192,193,194,195,196,197,198,199
		db	200,201,202,203,204,205,206,207
		db	208,209,210,211,212,213,214,215
		db	216,217,218,219,220,221,222,223
		db	224,083,226,227,228,229,230,231
		db	232,233,234,235,236,237,238,239
		db	240,241,242,243,244,245,246,247
		db	248,249,250,251,252,253,254,255
	page
;
; Finland 437 Collate (same as Sweden)
;
fi_collate	label	word
;
sv_collate	label	word
		ctable	<,'COLLATE',256>
		db	000,001,002,003,004,005,006,007
		db	008,009,010,011,012,013,014,015
		db	016,017,018,019,020,021,022,023
		db	024,025,026,027,028,029,030,031
		db	032,033,034,035,036,037,038,039
		db	040,041,042,043,044,045,046,047
		db	048,049,050,051,052,053,054,055
		db	056,057,058,059,060,061,062,063
		db	064,065,066,067,068,069,070,071
		db	072,073,074,075,076,077,078,079
		db	080,081,082,083,084,085,086,087
		db	088,089,090,091,092,093,094,095
		db	096,065,066,067,068,069,070,071
		db	072,073,074,075,076,077,078,079
		db	080,081,082,083,084,085,086,087
		db	088,089,090,123,124,125,126,127
		db	067,089,069,065,092,065,091,067
		db	069,069,069,073,073,073,092,091
		db	069,092,092,079,093,079,085,085
		db	089,093,089,036,036,036,036,036
		db	065,073,079,085,078,078,166,167
		db	063,169,170,171,172,033,034,034
		db	176,177,178,179,180,181,182,183
		db	184,185,186,187,188,189,190,191
		db	192,193,194,195,196,197,198,199
		db	200,201,202,203,204,205,206,207
		db	208,209,210,211,212,213,214,215
		db	216,217,218,219,220,221,222,223
		db	224,083,226,227,228,229,230,231
		db	232,233,234,235,236,237,238,239
		db	240,241,242,243,244,245,246,247
		db	248,249,250,251,252,253,254,255
	page
;
;  Israel 862 collate
;
is_collate	label	word
		ctable	<,'COLLATE',256>
		db	000,001,002,003,004,005,006,007
		db	008,009,010,011,012,013,014,015
		db	016,017,018,019,020,021,022,023
		db	024,025,026,027,028,029,030,031
		db	032,033,034,035,036,037,038,039
		db	040,041,042,043,044,045,046,047
		db	048,049,050,051,052,053,054,055
		db	056,057,058,059,060,061,062,063
		db	064,065,066,067,068,069,070,071
		db	072,073,074,075,076,077,078,079
		db	080,081,082,083,084,085,086,087
		db	088,089,090,091,092,093,094,095
		db	096,065,066,067,068,069,070,071
		db	072,073,074,075,076,077,078,079
		db	080,081,082,083,084,085,086,087
		db	088,089,090,123,124,125,126,127
		db	128,129,130,131,132,133,134,135
		db	136,137,138,139,140,141,142,143
		db	144,145,146,147,148,149,150,151
		db	152,153,154,036,036,036,036,036
		db	065,073,079,085,078,078,166,167
		db	063,169,170,171,172,033,034,034
		db	176,177,178,179,180,181,182,183
		db	184,185,186,187,188,189,190,191
		db	192,193,194,195,196,197,198,199
		db	200,201,202,203,204,205,206,207
		db	208,209,210,211,212,213,214,215
		db	216,217,218,219,220,221,222,223
		db	224,083,226,227,228,229,230,231
		db	232,233,234,235,236,237,238,239
		db	240,241,242,243,244,245,246,247
		db	248,249,250,251,252,253,254,255
	page
;
; Canada 863 Collate
;
ca_collate	label	word
		ctable	<,'COLLATE',256>
		db	000,001,002,003,004,005,006,007
		db	008,009,010,011,012,013,014,015
		db	016,017,018,019,020,021,022,023
		db	024,025,026,027,028,029,030,031
		db	032,033,034,035,036,037,038,039
		db	040,041,042,043,044,045,046,047
		db	048,049,050,051,052,053,054,055
		db	056,057,058,059,060,061,062,063
		db	064,065,066,067,068,069,070,071
		db	072,073,074,075,076,077,078,079
		db	080,081,082,083,084,085,086,087
		db	088,089,090,091,092,093,094,095
		db	096,065,066,067,068,069,070,071
		db	072,073,074,075,076,077,078,079
		db	080,081,082,083,084,085,086,087
		db	088,089,090,123,124,125,126,127
		db	067,085,069,065,065,065,134,067
		db	069,069,069,073,073,141,065,143
		db	069,069,069,079,069,073,085,085
		db	152,079,085,155,156,085,085,159
		db	160,161,079,085,164,165,166,167
		db	073,169,170,171,172,173,174,175
		db	176,177,178,179,180,181,182,183
		db	184,185,186,187,188,189,190,191
		db	192,193,194,195,196,197,198,199
		db	200,201,202,203,204,205,206,207
		db	208,209,210,211,212,213,214,215
		db	216,217,218,219,220,221,222,223
		db	224,225,226,227,228,229,230,231
		db	232,233,234,235,236,237,238,239
		db	240,241,242,243,244,245,246,247
		db	248,249,250,251,252,253,254,255
	page
;
; Portugal 860 collating
;
po_collate	label	word
		ctable	<,'COLLATE',256>
		db	000,001,002,003,004,005,006,007
		db	008,009,010,011,012,013,014,015
		db	016,017,018,019,020,021,022,023
		db	024,025,026,027,028,029,030,031
		db	032,033,034,035,036,037,038,039
		db	040,041,042,043,044,045,046,047
		db	048,049,050,051,052,053,054,055
		db	056,057,058,059,060,061,062,063
		db	064,065,066,067,068,069,070,071
		db	072,073,074,075,076,077,078,079
		db	080,081,082,083,084,085,086,087
		db	088,089,090,091,092,093,094,095
		db	096,065,066,067,068,069,070,071
		db	072,073,074,075,076,077,078,079
		db	080,081,082,083,084,085,086,087
		db	088,089,090,123,124,125,126,127
		db	067,085,069,065,065,065,065,067
		db	069,069,069,073,079,073,065,065
		db	069,065,069,079,079,079,085,085
		db	073,079,085,036,036,085,036,079
		db	065,073,079,085,078,078,166,167
		db	063,079,170,171,172,033,034,034
		db	176,177,178,179,180,181,182,183
		db	184,185,186,187,188,189,190,191
		db	192,193,194,195,196,197,198,199
		db	200,201,202,203,204,205,206,207
		db	208,209,210,211,212,213,214,215
		db	216,217,218,219,220,221,222,223
		db	224,083,226,227,228,229,230,231
		db	232,233,234,235,236,237,238,239
		db	240,241,242,243,244,245,246,247
		db	248,249,250,251,252,253,254,255
	page
;
sw_collate	label	word
		ctable	<,'COLLATE',256>
		db	001,200,201,202,203,204,205,206
		db	207,208,209,210,211,212,213,214
		db	215,216,217,218,140,141,219,220
		db	221,222,223,224,225,226,227,228
		db	001,060,061,062,063,064,065,066  ;DCR059 CNS ******  ;AN000;
		db	067,068,069,070,071,072,073,074
		db	032,033,034,035,036,037,038,039
		db	040,041,075,076,077,078,079,080
		db	081,002,003,004,005,007,008,009
		db	010,011,012,013,014,015,016,018
		db	019,020,021,022,024,026,027,028
		db	029,030,031,082,083,084,052,085
		db	051,002,003,004,005,007,008,009
		db	010,011,012,013,014,015,016,018
		db	019,020,021,022,024,026,027,028
		db	029,030,031,086,087,088,054,089
		db	004,026,007,002,002,002,002,004
		db	007,007,007,011,011,011,002,002
		db	007,002,002,018,018,018,026,026
		db	030,018,026,111,090,112,150,092
		db	002,011,018,026,017,017,002,018
		db	093,151,095,096,097,098,099,100
		db	101,102,103,104,105,152,153,154
		db	155,107,108,109,110,156,157,113
		db	114,115,116,117,118,119,158,159
		db	120,121,122,123,124,125,126,160
		db	161,162,163,164,165,166,167,168
		db	169,128,129,130,131,170,171,133
		db	172,023,173,174,175,176,134,177
		db	178,179,180,181,182,183,184,185
		db	186,137,187,188,189,190,142,191
		db	143,192,144,193,194,147,148,001
	page
;
be_collate	label	word
		ctable	<,'COLLATE',256>
		db	255,255,255,255,255,255,255,255
		db	255,255,255,255,255,255,255,255
		db	255,255,255,255,255,255,255,255
		db	255,255,255,255,255,255,255,255
		db	255,033,034,035,036,037,038,255
		db	040,041,042,043,044,255,046,047
		db	048,049,050,051,052,053,054,055
		db	056,057,058,059,060,061,062,063
		db	064,065,066,067,068,069,070,071
		db	072,073,074,075,076,077,078,079
		db	080,081,082,083,084,085,086,087
		db	088,089,090,091,092,093,094,095
		db	096,065,066,067,068,069,070,071
		db	072,073,074,075,076,077,078,079
		db	080,081,082,083,084,085,086,087
		db	088,089,090,123,124,125,126,127
		db	067,085,069,065,065,065,065,067
		db	069,069,069,073,073,073,065,065
		db	069,065,065,079,079,079,085,085
		db	089,079,085,155,156,157,158,159
		db	065,073,079,085,078,078,166,167
		db	168,169,170,171,172,173,174,175
		db	255,255,255,255,255,255,255,255
		db	255,255,255,255,255,255,255,255
		db	255,255,255,255,255,255,255,255
		db	255,255,255,255,255,255,255,255
		db	255,255,255,255,255,255,255,255
		db	255,255,255,255,255,255,255,255
		db	224,083,226,227,228,229,230,231
		db	232,233,234,235,236,237,238,239
		db	240,241,242,243,244,245,246,247
		db	248,249,250,251,252,253,255,255
	page
;
; Area South 864 Collate
;
as_collate	label	word
		ctable	<,'COLLATE',256>
		db	000,001,002,003,004,005,006,007
		db	008,009,010,011,012,013,014,015
		db	016,017,018,019,020,021,022,023
		db	024,025,026,027,028,029,030,031
		db	032,033,034,035,036,037,038,039
		db	040,041,042,043,044,045,046,047
		db	048,049,050,051,052,053,054,055
		db	056,057,058,059,060,061,062,063
		db	064,065,066,067,068,069,070,071
		db	072,073,074,075,076,077,078,079
		db	080,081,082,083,084,085,086,087
		db	088,089,090,091,092,093,094,095
		db	096,065,066,067,068,069,070,071
		db	072,073,074,075,076,077,078,079
		db	080,081,082,083,084,085,086,087
		db	088,089,090,123,124,125,126,127
		db	128,129,130,131,132,133,134,135
		db	136,137,138,139,140,141,142,143
		db	144,145,146,147,148,149,150,151
		db	152,233,234,251,255,235,236,179
		db	153,154,182,155,156,184,253,254
		db	188,189,192,194,163,196,198,200
		db	164,165,166,167,168,169,170,171
		db	172,173,224,174,206,208,210,175
		db	157,180,181,183,185,217,186,187
		db	190,191,193,195,197,199,201,202
		db	203,204,205,207,209,211,213,214
		db	215,218,222,158,159,160,161,216
		db	178,225,227,229,237,239,241,243
		db	245,246,250,212,219,221,220,238
		db	177,176,240,242,244,247,249,223
		db	226,231,232,230,228,248,162,255


	page
;
; -----------------------------------------
;
;     Collating Tables for Code Page 850
;
; -----------------------------------------
;
fr850_collate	   label   word
;
ca850_collate	   label   word
;
us850_collate	   label   word
;
uk850_collate	   label   word
;
it850_collate	   label   word
;
;;sp850_collate      label   word  ; spain now has there own
;
is850_collate	   label   word
;
po850_collate	   label   word
;
;;la850_collate      label   word   ; wants same as spain
;
as850_collate	   label   word
;
gr850_collate	   label   word 	 ;omitted tobe consistent with US DCR
;
afe850_collate	   label   word
		ctable	<,'COLLATE',256>
		db	000,001,002,003,004,005,006,007
		db	008,009,010,011,012,013,014,015
		db	016,017,018,019,020,021,022,023
		db	024,025,026,027,028,029,030,031
		db	032,033,034,035,036,037,038,039
		db	040,041,042,043,044,045,046,047
		db	048,049,050,051,052,053,054,055
		db	056,057,058,059,060,061,062,063
		db	064,065,066,067,068,069,070,071
		db	072,073,074,075,076,077,078,079
		db	080,081,082,083,084,085,086,087
		db	088,089,090,091,092,093,094,095
		db	096,065,066,067,068,069,070,071
		db	072,073,074,075,076,077,078,079
		db	080,081,082,083,084,085,086,087
		db	088,089,090,123,124,125,126,127
		db	067,085,069,065,065,065,065,067
		db	069,069,069,073,073,073,065,065
		db	069,065,065,079,079,079,085,085
		db	089,079,085,079,036,079,158,036
		db	065,073,079,085,078,078,166,167
		db	063,169,170,171,172,033,034,034
		db	176,177,178,179,180,065,065,065
		db	184,185,186,187,188,036,036,191
		db	192,193,194,195,196,197,065,065
		db	200,201,202,203,204,205,206,036
		db	068,068,069,069,069,073,073,073
		db	073,217,218,219,220,221,073,223
		db	079,083,079,079,079,079,230,232
		db	232,085,085,085,089,089,238,239
		db	240,241,242,243,244,245,246,247
		db	248,249,250,251,252,253,254,255
	page

;formerly GERMAN COLLATE TABLE DCR0037
;		ctable	<,'COLLATE',256>
;		db	000,001,002,003,004,005,006,007
;		db	008,009,010,011,012,013,014,015
;		db	016,017,018,019,020,021,022,023
;		db	024,025,026,027,028,029,030,031
;		db	032,033,034,035,036,037,038,039
;		db	040,041,042,043,044,045,046,047
;		db	048,049,050,051,052,053,054,055
;		db	056,057,058,059,060,061,062,063
;		db	064,065,066,067,068,069,070,071
;		db	072,073,074,075,076,077,078,079
;		db	080,081,082,083,084,085,086,087
;		db	088,089,090,091,092,093,094,095
;		db	096,065,066,067,068,069,070,071
;		db	072,073,074,075,076,077,078,079
;		db	080,081,082,083,084,085,086,087
;		db	088,089,090,123,124,125,126,127
;		db	067,117,069,065,097,065,065,067
;		db	069,069,069,073,073,073,065,065
;		db	069,065,065,079,111,079,085,085
;		db	089,079,085,079,036,079,158,036
;		db	065,073,079,085,078,078,166,167
;		db	063,169,170,171,172,033,034,034
;		db	176,177,178,179,180,065,065,065
;		db	184,185,186,187,188,036,036,191
;		db	192,193,194,195,196,197,065,065
;		db	200,201,202,203,204,205,206,036
;		db	068,068,069,069,069,073,073,073
;		db	073,217,218,219,220,221,073,223
;		db	079,115,079,079,079,079,230,232
;		db	232,085,085,085,089,089,238,239
;		db	240,241,242,243,244,245,246,247
;		db	248,249,250,251,252,253,254,255
	page
;
nl850_collate	  label   word
		ctable	<,'COLLATE',256>
		db	000,001,002,003,004,005,006,007
		db	008,009,010,011,012,013,014,015
		db	016,017,018,019,020,021,022,023
		db	024,025,026,027,028,029,030,031
		db	032,033,034,035,036,037,038,039
		db	040,041,042,043,044,045,046,047
		db	048,049,050,051,052,053,054,055
		db	056,057,058,059,060,061,062,063
		db	064,065,066,067,068,069,070,071
		db	072,073,074,075,076,077,078,079
		db	080,081,082,083,084,085,086,087
		db	088,089,090,091,092,093,094,095
		db	096,065,066,067,068,069,070,071
		db	072,073,074,075,076,077,078,079
		db	080,081,082,083,084,085,086,087
		db	088,089,090,123,124,125,126,127
		db	067,085,069,065,065,065,143,067
		db	069,069,069,073,073,073,065,143
		db	069,146,146,079,079,079,085,085
		db	152,079,085,079,156,079,158,159
		db	065,073,079,085,165,165,166,167
		db	168,169,170,171,172,173,174,175
		db	176,177,178,179,180,065,065,065
		db	184,185,186,187,188,189,190,191
		db	192,193,194,195,196,197,065,065
		db	200,201,202,203,204,205,206,207
		db	209,209,069,069,069,073,073,073
		db	073,217,218,219,220,221,073,223
		db	079,225,079,079,079,079,230,232
		db	232,085,085,085,089,089,238,239
		db	240,241,242,243,244,245,246,247
		db	248,249,250,251,252,253,254,255
	page
;
dk850_collate	   label   word
		ctable	<,'COLLATE',256>
		db	000,001,002,003,004,005,006,007
		db	008,009,010,011,012,013,014,015
		db	016,017,018,019,020,021,022,023
		db	024,025,026,027,028,029,030,031
		db	032,033,034,035,036,037,038,039
		db	040,041,042,043,044,045,046,047
		db	048,049,050,051,052,053,054,055
		db	056,057,058,059,060,061,062,063
		db	064,065,066,067,068,069,070,071
		db	072,073,074,075,076,077,078,079
		db	080,081,082,083,084,085,086,087
		db	088,089,090,040,047,041,094,095
		db	096,065,066,067,068,069,070,071
		db	072,073,074,075,076,077,078,079
		db	080,081,082,083,084,085,086,087
		db	088,089,090,040,047,041,126,127
		db	067,089,069,065,091,065,093,067
		db	069,069,069,073,073,073,091,093
		db	069,091,091,079,092,079,085,085
		db	089,092,089,092,036,092,158,036
		db	065,073,079,085,078,078,065,079
		db	063,169,170,171,172,033,034,034
		db	176,177,178,179,180,065,065,065
		db	184,185,186,187,188,036,036,191
		db	192,193,194,195,196,197,065,065
		db	200,201,202,203,204,205,206,036
		db	068,068,069,069,069,073,073,073
		db	073,217,218,219,220,221,073,223
		db	079,083,079,079,079,079,230,080
		db	080,085,085,085,089,089,238,239
		db	240,241,242,243,244,245,246,247
		db	248,249,250,251,252,253,254,255
	page
;
no850_collate	   label   word
		ctable	<,'COLLATE',256>
		db	000,001,002,003,004,005,006,007
		db	008,009,010,011,012,013,014,015
		db	016,017,018,019,020,021,022,023
		db	024,025,026,027,028,029,030,031
		db	032,033,034,035,036,037,038,039
		db	040,041,042,043,044,045,046,047
		db	048,049,050,051,052,053,054,055
		db	056,057,058,059,060,061,062,063
		db	064,065,066,067,068,069,070,071
		db	072,073,074,075,076,077,078,079
		db	080,081,082,083,084,085,086,087
		db	088,089,090,091,092,093,094,095
		db	096,065,066,067,068,069,070,071
		db	072,073,074,075,076,077,078,079
		db	080,081,082,083,084,085,086,087
		db	088,089,090,123,124,125,126,127
		db	067,085,069,065,091,065,093,067
		db	069,069,069,073,073,073,091,093
		db	069,091,091,079,092,079,085,085
		db	089,092,089,092,036,092,158,036
		db	065,073,079,085,078,078,065,079
		db	063,169,170,171,172,033,034,034
		db	176,177,178,179,180,065,065,065
		db	184,185,186,187,188,036,036,191
		db	192,193,194,195,196,197,065,065
		db	200,201,202,203,204,205,206,036
		db	068,068,069,069,069,073,073,073
		db	073,217,218,219,220,221,073,223
		db	079,083,079,079,079,079,230,080
		db	080,085,085,085,089,089,238,239
		db	240,241,242,243,244,245,246,247
		db	248,249,250,251,252,253,254,255
	page
;
sv850_collate	  label   word
		ctable	<,'COLLATE',256>
		db	000,001,002,003,004,005,006,007
		db	008,009,010,011,012,013,014,015
		db	016,017,018,019,020,021,022,023
		db	024,025,026,027,028,029,030,031
		db	032,033,034,035,036,037,038,039
		db	040,041,042,043,044,045,046,047
		db	048,049,050,051,052,053,054,055
		db	056,057,058,059,060,061,062,063
		db	064,065,066,067,068,069,070,071
		db	072,073,074,075,076,077,078,079
		db	080,081,082,083,084,085,086,087
		db	088,089,090,091,092,093,094,095
		db	096,065,066,067,068,069,070,071
		db	072,073,074,075,076,077,078,079
		db	080,081,082,083,084,085,086,087
		db	088,089,090,123,124,125,126,127
		db	067,089,069,065,092,065,091,067
		db	069,069,069,073,073,073,092,091
		db	069,092,092,079,093,079,085,085
		db	089,093,089,093,036,093,158,036
		db	065,073,079,085,078,078,166,167
		db	063,169,170,171,172,033,034,034
		db	176,177,178,179,180,065,065,065
		db	184,185,186,187,188,036,036,191
		db	192,193,194,195,196,197,065,065
		db	200,201,202,203,204,205,206,036
		db	068,068,069,069,069,073,073,073
		db	073,217,218,219,220,221,073,223
		db	079,083,079,079,093,093,230,232
		db	232,085,085,085,089,089,238,239
		db	240,241,242,243,244,245,246,247
		db	248,249,250,251,252,253,254,255
	page
;
fi850_collate	   label   word
		ctable	<,'COLLATE',256>
		db	000,001,002,003,004,005,006,007
		db	008,009,010,011,012,013,014,015
		db	016,017,018,019,020,021,022,023
		db	024,025,026,027,028,029,030,031
		db	032,033,034,035,036,037,038,039
		db	040,041,042,043,044,045,046,047
		db	048,049,050,051,052,053,054,055
		db	056,057,058,059,060,061,062,063
		db	064,065,066,067,068,069,070,071
		db	072,073,074,075,076,077,078,079
		db	080,081,082,083,084,085,086,087
		db	088,089,090,091,092,093,094,095
		db	096,065,066,067,068,069,070,071
		db	072,073,074,075,076,077,078,079
		db	080,081,082,083,084,085,086,087
		db	088,089,090,123,124,125,126,127
		db	067,089,069,065,092,065,091,067
		db	069,069,069,073,073,073,092,091
		db	069,092,092,079,093,079,085,085
		db	089,093,089,093,036,093,158,036
		db	065,073,079,085,078,078,166,167
		db	063,169,170,171,172,033,034,034
		db	176,177,178,179,180,065,065,065
		db	184,185,186,187,188,036,036,191
		db	192,193,194,195,196,197,065,065
		db	200,201,202,203,204,205,206,036
		db	068,068,069,069,069,073,073,073
		db	073,217,218,219,220,221,073,223
		db	079,083,079,079,079,079,230,232
		db	232,085,085,085,089,089,238,239
		db	240,241,242,243,244,245,246,247
		db	248,249,250,251,252,253,254,255
	page
;
sw850_collate	   label   word
		ctable	<,'COLLATE',256>

		db	224,225,226,227,228,229,230,231
		db	232,233,234,235,236,237,238,239
		db	240,241,242,243,244,245,246,247
		db	248,249,250,251,252,253,254,255
		db	000,165,168,133,185,134,135,169
		db	170,171,136,158,172,174,175,176
		db	117,118,120,122,124,125,126,127
		db	128,129,177,178,160,161,162,179
		db	137,002,018,020,024,028,038,040
		db	042,044,055,057,059,061,063,067
		db	081,083,085,087,090,094,104,106
		db	108,110,115,138,139,140,191,173
		db	190,003,019,021,025,029,039,041
		db	043,056,045,058,060,062,064,068
		db	082,084,086,088,091,095,105,107
		db	109,111,116,142,143,144,193,157
		db	022,103,031,009,011,007,015,023
		db	035,037,033,053,051,049,010,014
		db	030,017,016,074,076,072,101,099
		db	114,075,102,080,184,079,164,188
		db	005,047,070,097,066,065,149,148
		db	180,154,156,131,130,166,181,182
		db	207,208,209,206,204,004,008,006
		db	153,210,211,212,213,186,187,198
		db	197,202,201,203,205,200,013,012
		db	214,215,216,217,218,219,220,183
		db	027,026,034,036,032,054,046,050
		db	052,199,196,223,221,155,048,222
		db	069,089,073,071,078,077,146,092
		db	093,096,100,098,113,112,145,189
		db	167,159,141,132,151,150,163,194
		db	147,192,195,119,123,121,152,001

;		db	001,200,201,202,203,204,205,206
;		db	207,208,209,210,211,212,213,214
;		db	215,216,217,218,140,141,219,220
;		db	221,222,223,224,225,226,227,228
;		db	001,060,061,062,063,064,065,066
;		db	067,068,069,070,071,072,073,074
;		db	032,033,034,035,036,037,038,039
;		db	040,041,075,076,077,078,079,080
;		db	081,002,003,004,005,007,008,009
;		db	010,011,012,013,014,015,016,018
;		db	019,020,021,022,024,026,027,028
;		db	029,030,031,082,083,084,052,085
;		db	051,002,003,004,005,007,008,009
;		db	010,011,012,013,014,015,016,018
;		db	019,020,021,022,024,026,027,028
;		db	029,030,031,086,087,088,054,089
;		db	004,026,007,002,002,002,002,004
;		db	007,007,007,011,011,011,002,002
;		db	007,002,002,018,018,018,026,026
;		db	030,018,026,018,090,018,091,092
;		db	002,011,018,026,017,017,002,018
;		db	093,094,095,096,097,098,099,100
;		db	101,102,103,104,105,002,002,002
;		db	106,107,108,109,110,111,112,113
;		db	114,115,116,117,118,119,002,002
;		db	120,121,122,123,124,125,126,127
;		db	006,006,007,007,007,011,011,011
;		db	011,128,129,130,131,132,011,133
;		db	018,023,018,018,018,018,134,025
;		db	025,026,026,026,030,030,135,050
;		db	136,137,138,139,140,141,142,055
;		db	143,053,144,145,146,147,148,001
	page
;
be850_collate	label	word
		ctable	<,'COLLATE',256>
		db	255,255,255,255,255,255,255,255
		db	255,255,255,255,255,255,255,255
		db	255,255,255,255,255,255,255,255
		db	255,255,255,255,255,255,255,255
		db	255,033,034,035,036,037,038,255
		db	040,041,042,043,044,255,046,047
		db	048,049,050,051,052,053,054,055
		db	056,057,058,059,060,061,062,063
		db	064,065,066,067,068,069,070,071
		db	072,073,074,075,076,077,078,079
		db	080,081,082,083,084,085,086,087
		db	088,089,090,091,092,093,094,095
		db	096,065,066,067,068,069,070,071
		db	072,073,074,075,076,077,078,079
		db	080,081,082,083,084,085,086,087
		db	088,089,090,123,124,125,126,127
		db	067,085,069,065,065,065,065,067
		db	069,069,069,073,073,073,065,065
		db	069,065,065,079,079,079,085,085
		db	089,079,085,079,156,079,158,159
		db	065,073,079,085,078,164,166,167
		db	168,169,170,171,172,173,174,175
		db	255,255,255,255,255,065,065,065
		db	184,255,255,255,255,189,190,255
		db	255,255,255,255,255,255,065,065
		db	255,255,255,255,255,255,255,207
		db	068,068,069,069,069,073,073,073
		db	073,255,255,255,255,221,073,255
		db	079,083,079,079,079,079,230,084
		db	084,085,085,085,089,089,238,239
		db	255,241,242,243,244,245,246,247
		db	248,249,250,251,252,253,255,255
	page

la850_collate	   label   word 		   ; wants same as spain
;
sp850_collate	   label   word 		   ; new for DOS 4.0
		ctable	<,'COLLATE',256>
		db 000,150,151,152,153,154,155,156 ;7
		db 157,158,159,160,161,162,163,164 ;15
		db 165,166,167,168,169,170,171,172 ;23
		db 173,174,175,176,177,178,179,180 ;31
		db 000,060,061,062,063,064,065,000 ;39
		db 066,067,068,069,070,000,071,072 ;47
		db 034,035,036,037,038,039,040,041 ;55
		db 042,043,073,074,075,076,077,078 ;63
		db 079,001,002,003,006,008,009,010 ;71
		db 011,012,013,014,015,017,018,020 ;79
		db 021,022,023,024,026,028,029,030 ;87
		db 031,032,033,080,081,082,083,084 ;95
		db 085,001,002,003,006,008,009,010 ;103
		db 011,012,013,014,015,017,018,020 ;111
		db 021,022,023,024,026,028,029,030 ;119
		db 031,032,033,086,087,088,089,090 ;127
		db 004,028,008,001,001,001,001,004 ;135
		db 008,008,008,012,012,012,001,001 ;143
		db 008,001,001,020,020,020,028,028 ;151
		db 032,020,028,020,092,020,094,095 ;159
		db 001,012,020,028,019,019,001,020 ;167
		db 096,097,098,099,100,101,102,103 ;175
		db 104,105,106,107,108,001,001,001 ;183
		db 184,109,110,001,001,091,093,113 ;191
		db 114,115,116,117,118,119,187,188 ;199
		db 120,121,122,123,124,125,126,189 ;207
		db 007,007,008,008,008,012,012,012 ;215
		db 012,127,128,129,130,199,012,131 ;223
		db 020,025,020,020,020,020,132,027 ;231
		db 027,028,028,028,032,032,213,214 ;239
		db 000,133,216,217,218,219,134,220 ;247
		db 221,222,000,223,224,135,136,225 ;255

	page
;
jp932_collate	   label   word
		ctable	<,'COLLATE',256>
		db	0,1,2,3,4,5,6,7
		db	8,9,10,11,12,13,14,15
		db	16,17,18,19,20,21,22,23
		db	24,25,26,27,28,29,30,31
		db	" ","!",'"',"#","$","%","&","'"
		db	"(",")","*","+",",","-",".","/"
		db	"0","1","2","3","4","5","6","7"
		db	"8","9",":",";","<","=",">","?"
		db	"@","A","B","C","D","E","F","G"
		db	"H","I","J","K","L","M","N","O"
		db	"P","Q","R","S","T","U","V","W"
		db	"X","Y","Z","[","\","]","^","_"
		db	"`","A","B","C","D","E","F","G"
		db	"H","I","J","K","L","M","N","O"
		db	"P","Q","R","S","T","U","V","W"
		db	"X","Y","Z","{","|","}","~",127
		db	128,193,194,195,196,197,198,199
		db	200,201,202,203,204,205,206,207
		db	208,209,210,211,212,213,214,215
		db	216,217,218,219,220,221,222,223
		db	129,130,131,132,133,189,134,135
		db	136,137,138,139,140,141,142,143
		db	144,145,146,147,148,149,150,151
		db	152,153,154,155,156,157,158,159
		db	160,161,162,163,164,165,166,167
		db	168,169,170,171,172,173,174,175
		db	176,177,178,179,180,181,182,183
		db	184,185,186,187,188,190,191,192
		db	224,225,226,227,228,229,230,231
		db	232,233,234,235,236,237,238,239
		db	240,241,242,243,244,245,246,247
		db	248,249,250,251,252,253,254,255
	page
;
ko934_collate	   label   word
		ctable	<,'COLLATE',256>
		db	0,1,2,3,4,5,6,7
		db	8,9,10,11,12,13,14,15
		db	16,17,18,19,20,21,22,23
		db	24,25,26,27,28,29,30,31
		db	" ","!",'"',"#","$","%","&","'"
		db	"(",")","*","+",",","-",".","/"
		db	"0","1","2","3","4","5","6","7"
		db	"8","9",":",";","<","=",">","?"
		db	"@","A","B","C","D","E","F","G"
		db	"H","I","J","K","L","M","N","O"
		db	"P","Q","R","S","T","U","V","W"
		db	"X","Y","Z","[","\","]","^","_"
		db	"`","A","B","C","D","E","F","G"
		db	"H","I","J","K","L","M","N","O"
		db	"P","Q","R","S","T","U","V","W"
		db	"X","Y","Z","{","|","}","~",127
		db	128,190,191,192,193,194,195,196
		db	197,198,199,200,201,202,203,204
		db	205,206,207,208,209,210,211,212
		db	213,214,215,216,217,218,219,220
		db	221,222,223,224,225,226,227,228
		db	229,230,231,232,233,234,235,236
		db	237,238,239,240,241,242,243,244
		db	245,246,247,248,249,250,251,252
		db	129,130,131,132,133,134,135,136
		db	137,138,139,140,141,142,143,144
		db	145,146,147,148,149,150,151,152
		db	153,154,155,156,157,158,159,160
		db	161,162,163,164,165,166,167,168
		db	169,170,171,172,173,174,175,176
		db	177,178,179,180,181,182,183,184
		db	185,186,187,188,189,253,254,255

	page
;
pr936_collate	   label   word
;
ta938_collate	   label   word
		ctable	<,'COLLATE',256>
		db	0,1,2,3,4,5,6,7
		db	8,9,10,11,12,13,14,15
		db	16,17,18,19,20,21,22,23
		db	24,25,26,27,28,29,30,31
		db	" ","!",'"',"#","$","%","&","'"
		db	"(",")","*","+",",","-",".","/"
		db	"0","1","2","3","4","5","6","7"
		db	"8","9",":",";","<","=",">","?"
		db	"@","A","B","C","D","E","F","G"
		db	"H","I","J","K","L","M","N","O"
		db	"P","Q","R","S","T","U","V","W"
		db	"X","Y","Z","[","\","]","^","_"
		db	"`","A","B","C","D","E","F","G"
		db	"H","I","J","K","L","M","N","O"
		db	"P","Q","R","S","T","U","V","W"
		db	"X","Y","Z","{","|","}","~",127
		db	128,129,130,131,132,133,134,135
		db	136,137,138,139,140,141,142,143
		db	144,145,146,147,148,149,150,151
		db	152,153,154,155,156,157,158,159
		db	160,161,162,163,164,165,166,167
		db	168,169,170,171,172,173,174,175
		db	176,177,178,179,180,181,182,183
		db	184,185,186,187,188,189,190,191
		db	192,193,194,195,196,197,198,199
		db	200,201,202,203,204,205,206,207
		db	208,209,210,211,212,213,214,215
		db	216,217,218,219,220,221,222,223
		db	224,225,226,227,228,229,230,231
		db	232,233,234,235,236,237,238,239
		db	240,241,242,243,244,245,246,247
		db	248,249,250,251,252,253,254,255

	 page
;
;	cs3 -- begin additions for new languages
;
ic_collate      label   word            ; Iceland (ic) 861
		ctable  <,'COLLATE',256>
		db      000,001,002,003,004,005,006,007
		db      008,009,010,011,012,013,014,015
		db      016,017,018,019,020,021,022,023
		db      024,025,026,027,028,029,030,031
		db      032,033,034,035,036,037,038,039
		db      040,041,042,043,044,045,046,047
		db      048,049,050,051,052,053,054,055
		db      056,057,058,059,060,061,062,063
        	db	064,065,066,067,068,069,070,071
		db	072,073,074,075,076,077,078,079
		db	080,081,082,083,084,085,086,087
		db	088,089,090,040,047,041,094,095
		db	096,065,066,067,068,069,070,071	;6
		db	072,073,074,075,076,077,078,079	;
		db	080,081,082,083,084,085,086,087	;7
		db	088,089,090,040,047,041,126,127	;
		db	067,089,'E',065,091,065,093,067	;8
		db	069,069,069,'D','D','[',091,093	;
		db	'E','\','\',079,']','[',085,'Y'	;9
		db	'Y',']',089,092,036,092,036,036	;
		db	'A','I','O','U','A','I','O','U'	;A
		db	063,169,170,171,172,033,034,036	;
		db	176,177,178,179,180,181,182,183	;B
		db	184,185,186,187,188,189,190,191	;
		db	192,193,194,195,196,197,198,199	;C
		db	200,201,202,203,204,205,206,207	;
		db	208,209,210,211,212,213,214,215	;D
		db	216,217,218,219,220,221,222,223	;
		db	224,083,226,227,228,229,230,231	;E
		db	232,233,234,235,236,237,238,239	;
		db	240,241,242,243,244,245,246,247	;F
		db	248,249,250,251,252,253,254,255	;
;			 0   1	 2   3	 4   5	 6   7
;			 8   9	 A   B	 C   D	 E   F
page
;
yu852_collate    label   word
cs852_collate         label   word
sl852_collate         label   word
hu852_collate         label   word
pl852_collate         label   word
;
		ctable  <,'COLLATE',256>
;
;                       000 001 002 003 004 005 006 007
;                       -------------------------------
		db      000,001,002,003,004,005,006,007


;                       008 009 010 011 012 013 014 015
;                       -------------------------------
		db      008,009,010,011,012,013,014,015
;
;                       016 017 018 019 020 021 022 023
;                       -------------------------------
		db      016,017,018,019,020,021,022,023
;
;                       024 025 026 027 028 029 030 031
;                       -------------------------------
		db      024,025,026,027,028,029,030,031
;
;                            !   "   #   $   %   &   '
;                       -------------------------------
		db      110,111,112,113,114,115,116,117
;
;                        (   )   *   +   ,   -   .   /
;                       -------------------------------
		db      118,119,120,121,122,123,124,125
;
;                        0   1   2   3   4   5   6   7
;                       -------------------------------
		db      100,101,102,103,104,105,106,107
;
;                        8   9   :   ;   <   =   >   ?
;                       -------------------------------
		db      108,109,126,127,128,129,130,131
;
;                        @   A   B   C   D   E   F   G
;                       -------------------------------
		db      132,033,039,040,044,047,052,053
;
;                        H   I   J   K   L   M   N   O
;                       -------------------------------
		db      054,055,058,059,060,064,065,068
;
;                        P   Q   R   S   T   U   V   W
;                       -------------------------------
		db      073,074,075,078,083,086,091,092
;
;                        X   Y   Z   [   \   ]   ^   _
;                       -------------------------------
		db      093,094,096,133,134,135,136,137
;
;                        `   a   b   c   d   e   f   g
;                       -------------------------------
		db      138,033,039,040,044,047,052,053
;
;                        h   i   j   k   l   m   n   o
;                       -------------------------------
		db      054,055,058,059,060,064,065,068
;
;                        p   q   r   s   t   u   v   w
;                       -------------------------------
		db      073,074,075,078,083,086,091,092
;
;                        x   y   z   {   |   }   ~   
;                       -------------------------------
		db      093,094,096,139,140,141,142,032
;
;                                             
;                       -------------------------------
		db      043,089,048,038,035,088,041,043
;
;                                             
;                       -------------------------------
		db      063,051,072,072,057,098,035,041
;
;                                             
;                       -------------------------------
		db      048,061,061,070,071,062,062,082
;
;                                             
;                       -------------------------------
		db      082,071,089,084,084,063,143,042
;
;                                             
;                       -------------------------------
		db      034,056,069,087,036,036,097,097
;
;                             SPC              
;                       -------------------------------
		db      050,050,144,098,042,081,145,146
;
;                                             
;                       -------------------------------
		db      151,152,153,154,155,034,038,049
;
;                                             
;                       -------------------------------
		db      081,156,157,158,159,099,099,160
;
;                                             
;                       -------------------------------
		db      161,162,163,164,165,166,037,037
;
;                                             
;                       -------------------------------
		db      167,168,169,170,171,172,173,147
;
;                                             
;                       -------------------------------
		db      045,045,046,051,046,066,056,057
;
;                                             
;                       -------------------------------
		db      049,174,175,176,177,085,088,178
;
;                                             
;                       -------------------------------
		db      069,079,070,067,067,066,080,080
;
;                                             
;                       -------------------------------
		db      076,087,076,090,095,095,085,180
;
;                                             
;                       -------------------------------
		db      148,181,182,183,184,149,150,185
;
;                                            IGN
;                       -------------------------------
		db      186,187,188,090,077,077,179,255
;
	page
;
;  ***  MODIFIED FOR CP 857  ***  FI 16/03/90
tr857_collate      label   word
;
		ctable  <,'COLLATE',256>
;
;  0
		db      000,001,002,003,004,005,006,007
		db      008,009,010,011,012,013,014,015
;
;  1
		db      016,017,018,019,020,021,022,023
		db      024,025,026,027,028,029,030,031
;
;
;  2                    sp   !   "   #   $   %   &   '
		db      032,040,054,076,070,077,075,053
		db      057,058,073,078,037,036,045,044
;                        (   )   *   +   ,   -   .   /
;
;  3                     0   1   2   3   4   5   6   7
		db      091,092,093,094,095,096,097,098
		db      099,100,039,038,082,083,084,042
;                        8   9   :   ;   <   =   >   ?
;
;  4                     @   A   B   C   D   E   F   G
		db      067,101,102,103,105,106,107,108
		db      110,111,113,114,115,116,117,118
;                        H   I   J   K   L   M   N   O
;
;  5                     P   Q   R   S   T   U   V   W
		db      120,121,122,123,125,126,128,129
		db      130,131,132,059,074,060,048,033
;                        X   Y   Z   [   \   ]   ^   _
;
;  6                     `   a   b   c   d   e   f   g
		db      047,101,102,103,105,106,107,108
		db      110,112,113,114,115,116,117,118
;                        h   i   j   k   l   m   n   o
;
;  7                     p   q   r   s   t   u   v   w
		db      120,121,122,123,125,126,128,129
		db      130,131,132,061,086,062,050,150
;                        x   y   z   {   |   }   ~   
;
;  8                                          
		db      104,127,106,101,101,101,101,104
		db      106,106,106,112,112,111,101,101
;                                             
;
;  9                                          
		db      106,101,101,118,119,118,126,126
		db      112,119,127,118,071,118,124,124
;                                             
;
;  A                                          
		db      101,112,118,126,117,117,109,109
		db      043,066,085,091,091,041,055,056
;                                             
;
;  B               HEX  B0   1   2   3   4   5   6   7
		db      151,152,153,154,155,101,101,101
		db      065,156,157,158,159,069,072,160
;                  HEX  B8   9   A   B   C   D   E   F
;
;  C               HEX  C0   1   2   3   4   5   6   7
		db      161,162,163,164,165,166,101,101
		db      167,168,169,170,171,172,173,068
;                  HEX  C8   9   A   B   C   D   E   F
;
;  D               HEX  D0   1   2   3   4   5   6   7
		db      118,101,106,106,106,032,112,112
		db      112,174,175,176,177,087,112,178
;                  HEX  D8   9   A   B   C   D   E   F
;
;  E               HEX  E0   1   2   3   4   5   6   7
		db      118,123,118,118,118,118,089,032
		db      081,126,126,126,112,131,034,046
;                  HEX  E8   9   A   B   C   D   E   F
;
;  F               HEX  F0   1   2   3   4   5   6   7
		db      035,079,032,091,064,063,080,052
		db      088,049,051,092,094,093,179,090
;                  HEX  F8   9   A   B   C   D   E   F
;
	page
;
;
; Brazil 860 collating
;
br_collate     label word
	       ctable      <,'COLLATE',256>
	       db    000,001,002,003,004,005,006,007
	       db    008,009,010,011,012,013,014,015
	       db    016,017,018,019,020,021,022,023
	       db    024,025,026,027,028,029,030,031
	       db    032,033,034,035,036,037,038,039
	       db    040,041,042,043,044,045,046,047
	       db    048,049,050,051,052,053,054,055
	       db    056,057,058,059,060,061,062,063
	       db    064,065,066,067,068,069,070,071
	       db    072,073,074,075,076,077,078,079
	       db    080,081,082,083,084,085,086,087
	       db    088,089,090,091,092,093,094,095
	       db    096,065,066,067,068,069,070,071
	       db    072,073,074,075,076,077,078,079
	       db    080,081,082,083,084,085,086,087
	       db    088,089,090,123,124,125,126,127
	       db    067,085,069,065,065,065,065,067
	       db    069,069,069,073,079,073,065,065
	       db    069,065,069,079,079,079,085,085
	       db    073,079,085,036,036,085,036,079
	       db    065,073,079,085,078,078,166,167
	       db    063,079,170,171,172,033,034,034
	       db    176,177,178,179,180,181,182,183
	       db    184,185,186,187,188,189,190,191
	       db    192,193,194,195,196,197,198,199
	       db    200,201,202,203,204,205,206,207
	       db    208,209,210,211,212,213,214,215
	       db    216,217,218,219,220,221,222,223
	       db    224,083,226,227,228,229,230,231
	       db    232,233,234,235,236,237,238,239
	       db    240,241,242,243,244,245,246,247
	       db    248,249,250,251,252,253,254,255
	 page
;
br850_collate	label	word		; cs3 *** this may match another

	       ctable      <,'COLLATE',256>
	       db    000,001,002,003,004,005,006,007
	       db    008,009,010,011,012,013,014,015
	       db    016,017,018,019,020,021,022,023
	       db    024,025,026,027,028,029,030,031
	       db    032,033,034,035,036,037,038,039
	       db    040,041,042,043,044,045,046,047
	       db    048,049,050,051,052,053,054,055
	       db    056,057,058,059,060,061,062,063
	       db    064,065,066,067,068,069,070,071
	       db    072,073,074,075,076,077,078,079
	       db    080,081,082,083,084,085,086,087
	       db    088,089,090,091,092,093,094,095
	       db    096,065,066,067,068,069,070,071
	       db    072,073,074,075,076,077,078,079
	       db    080,081,082,083,084,085,086,087
	       db    088,089,090,123,124,125,126,127
	       db    067,085,069,065,065,065,065,067
	       db    069,069,069,073,073,073,065,065
	       db    069,065,065,079,079,079,085,085
	       db    089,079,085,079,036,079,158,036
	       db    065,073,079,085,078,078,166,167
	       db    063,169,170,171,172,033,034,034
	       db    176,177,178,179,180,065,065,065
	       db    184,185,186,187,188,036,036,191
	       db    192,193,194,195,196,197,065,065
	       db    200,201,202,203,204,205,206,036
	       db    068,068,069,069,069,073,073,073
	       db    073,217,218,219,220,221,073,223
	       db    079,083,079,079,079,079,230,232
	       db    232,085,085,085,089,089,238,239
	       db    240,241,242,243,244,245,246,247
	       db    248,249,250,251,252,253,254,255
	 page

ic850_collate         label   word
tr850_collate         label   word
yu850_collate         label   word
cs850_collate         label   word
sl850_collate         label   word
hu850_collate         label   word
pl850_collate         label   word
		ctable  <,'COLLATE',256>
		db      000,001,002,003,004,005,006,007
		db      008,009,010,011,012,013,014,015
		db      016,017,018,019,020,021,022,023
		db      024,025,026,027,028,029,030,031
		db      032,033,034,035,036,037,038,039
		db      040,041,042,043,044,045,046,047
		db      048,049,050,051,052,053,054,055
		db      056,057,058,059,060,061,062,063
		db      064,065,067,068,069,071,073,074 ;@
		db      075,076,078,079,080,081,082,083 ;H
		db      085,086,087,088,089,090,092,093 ;P
		db      094,095,097,040,047,041,094,095 ;X
		db      096,065,067,068,069,071,073,074 ;'
		db      075,076,078,079,080,081,082,083 ;h
		db      085,086,087,088,089,090,092,093 ;p
		db      094,095,097,040,047,041,126,127 ;x
		db      068,091,072,066,066,066,066,068 ;c cedilla
		db      072,072,072,077,077,077,066,066 ;e circ
		db      072,099,099,084,100,084,091,091 ;E acute
		db      096,100,091,084,036,084,158,036 ;y diar
		db      066,077,084,091,082,082,065,084 ;a acute
		db      063,169,170,171,172,033,034,034 ;a underscore
		db      176,177,178,179,180,066,066,066 ;sf1400
		db      184,185,186,187,188,036,036,191 ;copywrite symbol
		db      192,193,194,195,196,197,066,066 ;lower left single
		db      200,201,202,203,204,205,206,036 ;lower left double
		db      070,070,072,072,072,076,077,077 ;eth
		db      077,217,218,219,220,221,077,223 ;I diar
		db      084,067,084,084,084,084,230,098 ;O acute
		db      098,091,091,091,096,096,238,239 ;THORN
		db      240,241,242,243,244,245,246,247 ;sp32
		db      248,249,250,251,252,253,254,255 ;overcircle
	page
;
;	cs3 -- end additions for new languages
;
; ---------------------------------------------------------------
;
;	World Trade Case Mappings
;
; ---------------------------------------------------------------
;
us_ucase	label	word
;
uk_ucase	label	word
;
fr_ucase	label	word
;
gr_ucase	label	word
;
sp_ucase	label	word
;
la_ucase	label	word
;
it_ucase	label	word
;
afe_ucase	label	word
;
as_ucase	label	word
;
jp437_ucase	label	word
;
ko437_ucase	label	word
;
pr437_ucase	label	word
;
ta437_ucase	label	word
;
;	cs3 -- brazil added to this table

br_ucase label word

;	cs3 -- end additions

;
		ctable	<,'UCASE  ',128>
;***CNS PTM2390 table omitted	;AN000;
;***CNS restored for PTM 2575 to establish consistent and maintain 3.3 &
;under compatibility
	       db      128,154,069,065,142,065,143,128
	       db      069,069,069,073,073,073,142,143
	       db      144,146,146,079,153,079,085,085
	       db      089,153,154,155,156,157,158,159
	       db      065,073,079,085,165,165,166,167
	       db      168,169,170,171,172,173,174,175
	       db      176,177,178,179,180,181,182,183
	       db      184,185,186,187,188,189,190,191
	       db      192,193,194,195,196,197,198,199
	       db      200,201,202,203,204,205,206,207
	       db      208,209,210,211,212,213,214,215
	       db      216,217,218,219,220,221,222,223
	       db      224,225,226,227,228,229,230,231
	       db      232,233,234,235,236,237,238,239
	       db      240,241,242,243,244,245,246,247
	       db      248,249,250,251,252,253,254,255
;***CNS PTM2390 table omitted
;**CNS	replacement
;		 db	 067,085,069,065,065,065,065,067  ;AD000;
;		 db	 069,069,069,073,073,073,065,065  ;AD000;
;		 db	 069,146,146,079,079,079,085,085  ;AD000;
;		 db	 089,079,085,079,156,079,158,159  ;AD000;
;		 db	 065,073,079,085,165,165,166,167  ;AD000;
;		 db	 168,169,170,171,172,173,174,175  ;AD000;
;		 db	 176,177,178,179,180,065,065,065  ;AD000;
;		 db	 184,185,186,187,188,189,190,191  ;AD000;
;		 db	 192,193,194,195,196,197,065,065  ;AD000;
;		 db	 200,201,202,203,204,205,206,207  ;AD000;
;		 db	 209,209,069,069,069,073,073,073  ;AD000;
;		 db	 073,217,218,219,220,221,073,223  ;AD000;
;		 db	 079,225,079,079,079,079,230,232  ;AD000;
;		 db	 232,085,085,085,089,089,238,239  ;AD000;
;		 db	 240,241,242,243,244,245,246,247  ;AD000;
;		 db	 248,249,250,251,252,253,254,255  ;AD000;
;
page
;	Canadian French Code Page 863
;
ca_ucase	label	word
		ctable	<,'UCASE  ',128>
		db	067,085,069,065,065,065,134,067
		db	069,069,069,073,073,141,065,143
		db	069,069,069,079,069,073,085,085
		db	152,079,085,155,156,085,085,159
		db	160,161,079,085,164,165,166,167
		db	073,169,170,171,172,173,174,175
		db	176,177,178,179,180,181,182,183
		db	184,185,186,187,188,189,190,191
		db	192,193,194,195,196,197,198,199
		db	200,201,202,203,204,205,206,207
		db	208,209,210,211,212,213,214,215
		db	216,217,218,219,220,221,222,223
		db	224,225,226,227,228,229,230,231
		db	232,233,234,235,236,237,238,239
		db	240,241,242,243,244,245,246,247
		db	248,249,250,251,252,253,254,255
page
;	Denmark (Da) case mapping for 865
;
dk_ucase	label	word
;
;	Norway (No) case mapping for 865
;
no_ucase	label	word
		ctable	<,'UCASE  ',128>
		db	128,154,144,065,142,065,143,128
		db	069,069,069,073,073,073,142,143
		db	144,146,146,079,153,079,085,085
		db	089,153,154,157,156,157,158,159
		db	065,073,079,085,165,165,166,167
		db	168,169,170,171,172,173,174,175
		db	176,177,178,179,180,181,182,183
		db	184,185,186,187,188,189,190,191
		db	192,193,194,195,196,197,198,199
		db	200,201,202,203,204,205,206,207
		db	208,209,210,211,212,213,214,215
		db	216,217,218,219,220,221,222,223
		db	224,225,226,227,228,229,230,231
		db	232,233,234,235,236,237,238,239
		db	240,241,242,243,244,245,246,247
		db	248,249,250,251,252,253,254,255
page
;	Belgium (Be) case mapping for 437
;
be_ucase	label	word
;
;	Finland (Fi) case mapping for 437
;
fi_ucase	label	word
;
;	Sweden (Sv) case mapping
;
sv_ucase	label	word
		ctable	<,'UCASE  ',128>
		db	128,154,144,065,142,065,143,128
		db	069,069,069,073,073,073,142,143
		db	144,146,146,079,153,079,085,085
		db	089,153,154,155,156,157,158,159
		db	065,073,079,085,165,165,166,167
		db	168,169,170,171,172,173,174,175
		db	176,177,178,179,180,181,182,183
		db	184,185,186,187,188,189,190,191
		db	192,193,194,195,196,197,198,199
		db	200,201,202,203,204,205,206,207
		db	208,209,210,211,212,213,214,215
		db	216,217,218,219,220,221,222,223
		db	224,225,226,227,228,229,230,231
		db	232,233,234,235,236,237,238,239
		db	240,241,242,243,244,245,246,247
		db	248,249,250,251,252,253,254,255
page
;	Switzerland case mapping for 437
;
sw_ucase	label	word
		ctable	<,'UCASE  ',128>
		db	128,154,144,065,142,065,143,128
		db	069,069,069,073,073,073,142,143
		db	144,146,146,079,153,079,085,085
		db	089,153,154,155,156,157,158,159
		db	065,073,079,085,165,165,166,167    ;AN000;;DCR 059 CNS ***
		db	168,169,170,171,172,173,174,175
		db	176,177,178,179,180,181,182,183
		db	184,185,186,187,188,189,190,191
		db	192,193,194,195,196,197,198,199
		db	200,201,202,203,204,205,206,207
		db	208,209,210,211,212,213,214,215
		db	216,217,218,219,220,221,222,223
		db	224,225,226,227,228,229,230,231
		db	232,233,234,235,236,237,238,239
		db	240,241,242,243,244,245,246,247
		db	248,249,250,251,252,253,254,255
page
;
;	Netherlands case mapping for 437
;
nl_ucase	label	word
		ctable	<,'UCASE  ',128>
		db	128,085,069,065,065,065,143,128
		db	069,069,069,073,073,073,065,143
		db	069,146,146,079,079,079,085,085
		db	152,079,085,155,156,157,158,159
		db	065,073,079,085,165,165,166,167
		db	168,169,170,171,172,173,174,175
		db	176,177,178,179,180,181,182,183
		db	184,185,186,187,188,189,190,191
		db	192,193,194,195,196,197,198,199
		db	200,201,202,203,204,205,206,207
		db	208,209,210,211,212,213,214,215
		db	216,217,218,219,220,221,222,223
		db	224,225,226,227,228,229,230,231
		db	232,233,234,235,236,237,238,239
		db	240,241,242,243,244,245,246,247
		db	248,249,250,251,252,253,254,255
page
;
;	Portuguese (Po) case mapping
;
po_ucase	label	word
		ctable	<,'UCASE  ',128>
		db	128,154,144,143,142,145,134,128
		db	137,137,146,139,140,152,142,143
		db	144,145,146,140,153,169,150,157
		db	152,153,154,155,156,157,158,159
		db	134,139,159,150,165,165,166,167
		db	168,169,170,171,172,173,174,175
		db	176,177,178,179,180,181,182,183
		db	184,185,186,187,188,189,190,191
		db	192,193,194,195,196,197,198,199
		db	200,201,202,203,204,205,206,207
		db	208,209,210,211,212,213,214,215
		db	216,217,218,219,220,221,222,223
		db	224,225,226,227,228,229,230,231
		db	232,233,234,235,236,237,238,239
		db	240,241,242,243,244,245,246,247
		db	248,249,250,251,252,253,254,255
page
;
;	Is case mapping
;
is_ucase	label	word
		ctable	<,'UCASE  ',128>
		db	128,129,130,131,132,133,134,135
		db	136,137,138,139,140,141,142,143
		db	144,145,146,147,148,149,150,151
		db	152,153,154,155,156,157,158,159
		db	065,073,079,085,165,165,166,167
		db	168,169,170,171,172,173,174,175
		db	176,177,178,179,180,181,182,183
		db	184,185,186,187,188,189,190,191
		db	192,193,194,195,196,197,198,199
		db	200,201,202,203,204,205,206,207
		db	208,209,210,211,212,213,214,215
		db	216,217,218,219,220,221,222,223
		db	224,225,226,227,228,229,230,231
		db	232,233,234,235,236,237,238,239
		db	240,241,242,243,244,245,246,247
		db	248,249,250,251,252,253,254,255
page
;
us850_ucase	label	word
;
afe850_ucase	label	word
;
uk850_ucase	label	word
;
fr850_ucase	label	word
;
it850_ucase	label	word
;
is850_ucase	label	word
;
as850_ucase	label	word
;
po850_ucase	label	word
;
ca850_ucase	label	word
		ctable	<,'UCASE  ',128>
;**CNS replacement
	 